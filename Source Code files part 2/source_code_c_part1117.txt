UE;

        MYASSERT(pCurr);

        while (TRUE) {
            pNext = pCurr->Next;
            //
            // If the current node is the last one, reset to the beginning
            // and break out to start a new inner loop.
            //
            if (pNext == NULL) {
                pCurr = pList->First;
                break;
            }

            //
            // If the node *after* the current node has a lower sequence
            // number, fix up the pointers to swap the two nodes.
            //
            if (pCurr->SequenceNumber > pNext->SequenceNumber) {
                done = FALSE;

                pCurr->Next = pNext->Next;
                pNext->Next = pCurr;
                *ppPrev = pNext;
                ppPrev = &(pNext->Next);
            }
            else {
                ppPrev = &(pCurr->Next);
                pCurr  =   pCurr->Next;
            }
        }
    }
}


VOID
AsrpPerformSifIntegrityCheck(IN HINF Handle)
{
    //
    // No check for now.
    //
    return;
}

//
// This checks if the following entries are different in setup.log
// from their values.  This could happen because we might have installed
// to a new disk that has a different disk number
//
// [Paths]
// TargetDevice = "\Device\Harddisk0\Partition2"
// SystemPartition = "\Device\Harddisk0\Partition1"
//
// If they are different, we'll update them.
//
BOOL
AsrpCheckSetupLogDeviceEntries(
    PWSTR CurrentSystemDevice,      // used for SystemPartition
    PWSTR CurrentBootDevice,        // used for TargetDevice
    PWSTR LogFileName               // path to setup.log
   )
{
    WCHAR szLine[MAX_INF_STRING_LENGTH + 1];
    PWSTR lpLine = NULL;
    BOOL isDifferent = FALSE;
    FILE *fp = NULL;
    INT iNumEntries = 0;

    //
    // Open existing setup.log
    //
    fp = _wfopen(LogFileName, L"r");
    if (!fp) {
        AsrpPrintDbgMsg(_asrwarn,
            "Could not open setup log file [%ws]\r\n",
            LogFileName
            );
        return FALSE;
    }

    //
    // Check each line of the file for the System or Boot device entries
    //
    lpLine = fgetws(szLine, MAX_PATH-1, fp);
    while ((lpLine) && (iNumEntries < 2)) {
        BOOL systemEntry = FALSE;
        BOOL bootEntry = FALSE;

        if (wcsstr(szLine, L"SystemPartition =")) {
            systemEntry = TRUE;
            iNumEntries++;
        }
        if (wcsstr(szLine, L"TargetDevice =")) {
            bootEntry = TRUE;
            iNumEntries++;
        }

        if (systemEntry || bootEntry) {

            PWSTR DeviceName = NULL;
            //
            // Both the system and boot entries must have the full
            // devicepath in them, of the form \Device\Harddisk0\Partition1
            //
            DeviceName = wcsstr(szLine, L"\\Device");
            if (!DeviceName) {
                isDifferent = TRUE;
                AsrpPrintDbgMsg(_asrlog,
                    "Marking setup logs different:  \\Device\\ not found in boot or system entry\r\n"
                    );
                break;
            }
            else {
                //
                // Find the start of the "Hardisk0\Partition1" text after \Device
                //
                PWSTR ss = wcsstr(DeviceName, L"\"");
                if (!ss) {
                    isDifferent = TRUE;
                    AsrpPrintDbgMsg(_asrlog,
                        "Marking setup logs different:  \\Device\\ not found in boot or system entry\r\n"
                        );
                    break;
                }
                else {
                    ss[0] = L'\0';
                }
            }

            //
            // And check if this device matches
            //
            if (systemEntry) {
                AsrpPrintDbgMsg(_asrinfo,
                    "Comparing System Device.  Current:[%ws] setup.log:[%ws]\r\n",
                    CurrentSystemDevice,
                    DeviceName
                    );

                if (wcscmp(DeviceName, CurrentSystemDevice) != 0) {
                    isDifferent = TRUE;
                    AsrpPrintDbgMsg(_asrlog,
                        "System Device has changed.  Current:[%ws] setup.log:[%ws]\r\n",
                        CurrentSystemDevice,
                        DeviceName
                        );
                    break;
                }
            }
            else if (bootEntry) {
                AsrpPrintDbgMsg(_asrinfo,
                    "Comparing Boot Device.  Current:[%ws] setup.log:[%ws]\r\n",
                    CurrentBootDevice,
                    DeviceName
                    );

                if (wcscmp(DeviceName, CurrentBootDevice) != 0) {
                    isDifferent = TRUE;
                    AsrpPrintDbgMsg(_asrlog,
                        "Boot device has changed.  Current:[%ws] setup.log:[%ws]\r\n",
                        CurrentBootDevice,
                        DeviceName
                        );
                    break;
                }
            }
        }

        lpLine = fgetws(szLine, MAX_PATH-1, fp);
    }

    if (!isDifferent) {
        AsrpPrintDbgMsg(_asrinfo,  "No changes in system and boot devices for setup.log\r\n");
    }

    fclose(fp);
    fp = NULL;

    return isDifferent;
}


//
// If the setup.log restored by the backup from tape has a different
// boot or system device marked (we might have picked a new disk in
// textmode Setup), this will update the relevant entries to match the
// current boot and system devices.
//
VOID
AsrpMergeSetupLog(
    PWSTR CurrentSystemDevice,
    PWSTR CurrentBootDevice,
    PWSTR LogFileName
    )
{
    WCHAR szLine[MAX_INF_STRING_LENGTH + 1];

    PWSTR lpLine = NULL,
        lpOldFileName = NULL,
        lpNewFileName = NULL;

    BOOL result = FALSE;
    FILE *fpNew = NULL,
        *fpCurrent = NULL;

    INT iNumEntries = 0;

    //
    // Create the "new" and "old" file names, i.e., "setup.log.new" and "setup.log.old"
    //
    _AsrAlloc(lpNewFileName, ((wcslen(LogFileName) + 5) * sizeof(WCHAR)), TRUE)
    wcscpy(lpNewFileName, LogFileName);
    wcscat(lpNewFileName, L".new");

    _AsrAlloc(lpOldFileName, ((wcslen(LogFileName) + 5) * sizeof(WCHAR)), TRUE);
    wcscpy(lpOldFileName, LogFileName);
    wcscat(lpOldFileName, L".old");

    //
    // Open the current setup.log file.
    //
    fpCurrent = _wfopen(LogFileName, L"r");
    if (!fpCurrent) {
        AsrpPrintDbgMsg(_asrwarn, "Setup was unable to open the setup log file \"%ws\"\r\n", LogFileName);
        goto EXIT;
    }

    //
    // Open the new file - we will write into this one.
    //
    fpNew = _wfopen(lpNewFileName, L"w");
    if (!fpNew) {
        AsrpPrintDbgMsg(_asrwarn, "Setup was unable to open the setup log file \"%ws\"\r\n", lpNewFileName);
        goto EXIT;
    }

    //
    // Read each line in the log file, copy into the new file, unless we hit
    // one of the two lines in question. Once we've seen both of them, don't
    // check for them anymore.
    //
    lpLine = fgetws(szLine, MAX_INF_STRING_LENGTH, fpCurrent);
    while (lpLine) {
        BOOL systemEntry = FALSE;
        BOOL bootEntry = FALSE;

        //
        // If we've already found both entries of interest, just copy
        // and continue.
        //
        if (iNumEntries >= 2) {
            fputws(szLine, fpNew);

            lpLine = fgetws(szLine, MAX_INF_STRING_LENGTH, fpCurrent);
            continue;
        }

        //
        // Is this line either the boot or system device?
        //
        if (wcsstr(szLine, L"SystemPartition =")) {

            AsrpPrintDbgMsg(_asrlog,
                "Changing SystemPartition in setup.log to %ws\r\n",
                CurrentSystemDevice
                );
            ++iNumEntries;

            wcscpy(szLine, L"SystemPartition = \"");
            wcscat(szLine, CurrentSystemDevice);
            wcscat(szLine, L"\"\n");
        }
        else if (wcsstr(szLine, L"TargetDevice =")) {

            AsrpPrintDbgMsg(_asrlog,
                "Changing TargetDevice in setup.log to %ws\r\n",
                CurrentBootDevice
                );
            ++iNumEntries;

            wcscpy(szLine, L"TargetDevice = \"");
            wcscat(szLine, CurrentBootDevice);
            wcscat(szLine, L"\"\n");
        }

        fputws(szLine, fpNew);

        lpLine = fgetws(szLine, MAX_INF_STRING_LENGTH, fpCurrent);
   }

    //
    // Rename the current setup.log to setup.log.old, and setup.log.new to
    // setup.log.  Need to delay this until reboot since setup.log is in
    // use.
    //
    result = MoveFileExW(LogFileName,
        lpOldFileName,
        MOVEFILE_REPLACE_EXISTING | MOVEFILE_DELAY_UNTIL_REBOOT
        );
    if (!result) {
        AsrpPrintDbgMsg(_asrwarn,
            "MoveFileEx([%ws] to [%ws]) failed (%lu)",
            LogFileName, lpOldFileName, GetLastError()
            );
    }
    else {
        result = MoveFileExW(lpNewFileName,
            LogFileName,
            MOVEFILE_REPLACE_EXISTING | MOVEFILE_DELAY_UNTIL_REBOOT
            );
        if (!result) {
            AsrpPrintDbgMsg(_asrwarn,
                "MoveFileEx([%ws] to [%ws]) failed (%lu)",
                lpNewFileName, LogFileName, GetLastError()
                );
        }
    }

EXIT:


    if (fpCurrent) {
        fclose(fpCurrent);
        fpCurrent = NULL;
    }

    if (fpNew) {
        fclose(fpNew);
        fpNew = NULL;
    }

    _AsrFree(lpNewFileName);
    _AsrFree(lpOldFileName);
}


VOID
AsrpMergeSetupLogIfNeeded()
{
    PWSTR currentSystemDevice = NULL,
        currentBootDevice = NULL,
        winntRootDir = NULL,
        setupLogFileName = NULL;

    BOOL isSetupLogDifferent = FALSE;

    //
    // Get the environment variable for the partition devices
    //
    currentSystemDevice = AsrpExpandEnvStrings(Asr_SystemDeviceEnvName);
    currentBootDevice = AsrpExpandEnvStrings(Asr_WinntDeviceEnvName);
    setupLogFileName = AsrpExpandEnvStrings(Asr_SetupLogFilePath);

    if ((!currentSystemDevice) ||
        (!currentBootDevice) ||
        (!setupLogFileName)) {
        goto EXIT;
    }

    //
    // Check if the system and/or boot devices listed in setup.log are
    // different than the current devices
    //
    isSetupLogDifferent = AsrpCheckSetupLogDeviceEntries(
        currentSystemDevice,
        currentBootDevice,
        setupLogFileName
        );

    if (isSetupLogDifferent) {
        //
        // They are different: fix it.
        //
        AsrpMergeSetupLog(currentSystemDevice,
            currentBootDevice,
            setupLogFileName
            );
    }

EXIT:
    _AsrFreeIfNotNull(setupLogFileName);
    _AsrFreeIfNotNull(currentBootDevice);
    _AsrFreeIfNotNull(currentSystemDevice);
}


BOOL
AsrpConstructSecurityAttributes(
    IN OUT LPSECURITY_ATTRIBUTES psaSecurityAttributes
)
{
    BOOL bResult = FALSE;
    DWORD dwStatus = ERROR_SUCCESS;
    PSID psidBackupOperators  = NULL;
    PSID psidAdministrators   = NULL;
    PACL paclDiscretionaryAcl = NULL;
    SID_IDENTIFIER_AUTHORITY sidNtAuthority = SECURITY_NT_AUTHORITY;
    EXPLICIT_ACCESS eaExplicitAccess[2];

    //
    // Initialise the security descriptor.
    //
    bResult = InitializeSecurityDescriptor(
        psaSecurityAttributes->lpSecurityDescriptor,
        SECURITY_DESCRIPTOR_REVISION
        );
    _AsrpErrExitCode((!bResult), dwStatus, GetLastError());

    //
    // Create a SID for the Backup Operators group.
    //
    bResult = AllocateAndInitializeSid(&sidNtAuthority,
        2,
        SECURITY_BUILTIN_DOMAIN_RID, //SECURITY_LOCAL_SYSTEM_RID,
        DOMAIN_ALIAS_RID_BACKUP_OPS,
        0, 0, 0, 0, 0, 0,
        &psidBackupOperators
        );
    _AsrpErrExitCode((!bResult), dwStatus, GetLastError());

    //
    // Create a SID for the Administrators group.
    //
    bResult = AllocateAndInitializeSid (&sidNtAuthority,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0,
        &psidAdministrators
        );
    _AsrpErrExitCode((!bResult), dwStatus, GetLastError());

    //
    // Initialize the array of EXPLICIT_ACCESS structures for an
    // ACEs we are setting.
    //
    // The first ACE allows the Backup Operators group full access
    // and the second, allowa the Administrators group full
    // access.
    //
    eaExplicitAccess[0].grfAccessPermissions             = FILE_ALL_ACCESS;
    eaExplicitAccess[0].grfAccessMode                    = SET_ACCESS;
    eaExplicitAccess[0].grfInheritance                   = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    eaExplicitAccess[0].Trustee.pMultipleTrustee         = NULL;
    eaExplicitAccess[0].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    eaExplicitAccess[0].Trustee.TrusteeForm              = TRUSTEE_IS_SID;
    eaExplicitAccess[0].Trustee.TrusteeType              = TRUSTEE_IS_ALIAS;
    eaExplicitAccess[0].Trustee.ptstrName                = (LPTSTR) psidAdministrators;

    eaExplicitAccess[1].grfAccessPermissions             = FILE_ALL_ACCESS;
    eaExplicitAccess[1].grfAccessMode                    = SET_ACCESS;
    eaExplicitAccess[1].grfInheritance                   = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    eaExplicitAccess[1].Trustee.pMultipleTrustee         = NULL;
    eaExplicitAccess[1].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    eaExplicitAccess[1].Trustee.TrusteeForm              = TRUSTEE_IS_SID;
    eaExplicitAccess[1].Trustee.TrusteeType              = TRUSTEE_IS_ALIAS;
    eaExplicitAccess[1].Trustee.ptstrName                = (LPTSTR) psidBackupOperators;

    //
    // Create a new ACL that contains the new ACEs.
    //
    dwStatus = SetEntriesInAcl(2,
        eaExplicitAccess,
        NULL,
        &paclDiscretionaryAcl
        );
    if (ERROR_SUCCESS != dwStatus) {
        SetLastError(dwStatus);
        bResult = FALSE;
    }
    _AsrpErrExitCode((!bResult), dwStatus, dwStatus);

    //
    // Add the ACL to the security descriptor.
    //
    bResult = SetSecurityDescriptorDacl(
        psaSecurityAttributes->lpSecurityDescriptor,
        TRUE,
        paclDiscretionaryAcl,
        FALSE
        );
    _AsrpErrExitCode((!bResult), dwStatus, GetLastError());

    paclDiscretionaryAcl = NULL;    // We shouldn't clean this buffer yet.


EXIT:
    //
    // Free locally allocated structures
    //
    if (NULL != psidAdministrators) {
        FreeSid(psidAdministrators);
        psidAdministrators = NULL;
    }

    if (NULL != psidBackupOperators) {
        FreeSid(psidBackupOperators);
        psidBackupOperators = NULL;
    }
    if (NULL != paclDiscretionaryAcl) {
        LocalFree(paclDiscretionaryAcl);
        paclDiscretionaryAcl = NULL;

    }


    return bResult;

} // ConstructSecurityAttributes


BOOL
AsrpCleanupSecurityAttributes(
    IN LPSECURITY_ATTRIBUTES psaSecurityAttributes
    )
{
    BOOL bResult = FALSE;
    BOOL bDaclPresent = FALSE;
    BOOL bDaclDefaulted = TRUE;
    PACL paclDiscretionaryAcl = NULL;

    bResult = GetSecurityDescriptorDacl(
        psaSecurityAttributes->lpSecurityDescriptor,
        &bDaclPresent,
        &paclDiscretionaryAcl,
        &bDaclDefaulted
        );

    if (bResult &&
        bDaclPresent &&
        !bDaclDefaulted &&
        (NULL != paclDiscretionaryAcl)
        ) {
        LocalFree(paclDiscretionaryAcl);
    }

    return TRUE;

} // CleanupSecurityAttributes


//
// This creates an ASR log file at %systemroot%\asr.log,
// and also initialises Gbl_AsrLogFileHandle.
//
VOID
AsrpInitialiseLogFile()
{

    PWSTR currentSystemDevice = NULL;

    Gbl_AsrLogFileHandle = NULL;
    Gbl_AsrSystemVolumeHandle = NULL;

    //
    // Get full path to the error file.
    //
    Gbl_AsrLogFilePath = AsrpExpandEnvStrings(Asr_AsrLogFilePath);
    if (!Gbl_AsrLogFilePath) {
        goto OPENSYSTEMHANDLE;
    }

    //
    // Create an empty file (over-write it if it already exists).
    //
    Gbl_AsrLogFileHandle = CreateFileW(
        Gbl_AsrLogFilePath,             // lpFileName
        GENERIC_WRITE | GENERIC_READ,   // dwDesiredAccess
        FILE_SHARE_READ,                // dwShareMode: nobody else should write to the log file while we are
        NULL,                           // lpSecurityAttributes
        OPEN_ALWAYS,                    // dwCreationFlags
        FILE_FLAG_WRITE_THROUGH,        // dwFlagsAndAttributes: write through so we flush
        NULL                            // hTemplateFile
        );

    if ((Gbl_AsrLogFileHandle) && (INVALID_HANDLE_VALUE != Gbl_AsrLogFileHandle)) {
        //
        // Move to the end of file
        //
        SetFilePointer(Gbl_AsrLogFileHandle, 0L, NULL, FILE_END);

    }
    else {
        AsrpPrintDbgMsg(_asrlog,
            "Unable to create/open ASR log file at %ws (0x%x)\r\n",
            Gbl_AsrLogFilePath,
            GetLastError()
           );
    }

OPENSYSTEMHANDLE:

    //
    // Open a handle to the system volume.  This is needed since the system
    // disk might otherwise be removed and added back by PnP during the
    // device detecion and re-installation phase (which will cause the
    // HKLM\System\Setup\SystemPartition key to be out-of-sync, and apps/
    // components such as LDM that depend on that key to find the system
    // partition will fail).
    //
    // The more permanent work-around to this involves a change in mountmgr,
    // (such that it updates this key everytime the system volume disappears
    // and reappears) but for now, holding an open handle to the system
    // volume should suffice.
    //
    // See Windows Bugs 155675 for more information.
    //
    currentSystemDevice = AsrpExpandEnvStrings(Asr_SystemDeviceWin32Path);

    if (currentSystemDevice) {
        Gbl_AsrSystemVolumeHandle = CreateFileW(
            currentSystemDevice,           // lpFileName
            FILE_READ_ATTRIBUTES,             // dwDesiredAccess
            FILE_SHARE_READ | FILE_SHARE_WRITE,          // dwShareMode
            NULL,                     // lpSecurityAttributes
            OPEN_EXISTING,              // dwCreationFlags
            FILE_ATTRIBUTE_NORMAL,    // dwFlagsAndAttributes: write through so we flush
            NULL                      // hTemplateFile
            );

        if ((Gbl_AsrSystemVolumeHandle) && (INVALID_HANDLE_VALUE != Gbl_AsrSystemVolumeHandle)) {
            AsrpPrintDbgMsg(_asrinfo, "Opened a handle to the system volume %ws\r\n", currentSystemDevice);
        }
        else {
            AsrpPrintDbgMsg(_asrinfo, "Unable to open a handle to the system volume %ws (0x%x)\r\n",
                currentSystemDevice,
                GetLastError()
               );
        }

        _AsrFree(currentSystemDevice);
    }
    else {
        AsrpPrintDbgMsg(_asrinfo, "Unable to get current system volume (0x%x)\r\n", GetLastError());
    }

}


//
// This creates an empty ASR error file at %systemroot%\asr.err,
// and also initialises Gbl_AsrErrorFilePath with the full path
// to asr.err
//
VOID
AsrpInitialiseErrorFile()
{
    HANDLE errorFileHandle = NULL;
    PWSTR lpOldFileName = NULL;
    DWORD size = 0;
    BOOL bResult = FALSE;
    char  UnicodeFlag[3];

    //
    // Get full path to the error file.
    //
    Gbl_AsrErrorFilePath = AsrpExpandEnvStrings(Asr_AsrErrorFilePath);
    if (!Gbl_AsrErrorFilePath) {
        return;
    }

    lpOldFileName = AsrpExpandEnvStrings(Asr_OldAsrErrorFilePath);

    if (lpOldFileName) {
        //
        // If the file already exists, move it to asr.err.old
        //
        MoveFileExW(Gbl_AsrErrorFilePath, lpOldFileName, MOVEFILE_REPLACE_EXISTING);
    }

    //
    // Create an empty file (append to it if it already exists), and close it
    // immediately
    //
    errorFileHandle = CreateFileW(
        Gbl_AsrErrorFilePath,           // lpFileName
        GENERIC_WRITE,                  // dwDesiredAccess
        FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
        NULL,                           // lpSecurityAttributes
        CREATE_ALWAYS,                  // dwCreationFlags
        FILE_FLAG_WRITE_THROUGH,        // dwFlagsAndAttributes
        NULL                            // hTemplateFile
        );

    if ((errorFileHandle) && (INVALID_HANDLE_VALUE != errorFileHandle)) {
        sprintf(UnicodeFlag, "%c%c", 0xFF, 0xFE);
        WriteFile(errorFileHandle, UnicodeFlag, strlen(UnicodeFlag)*sizeof(char), &size, NULL);
        CloseHandle(errorFileHandle);
        DbgPrintEx(DPFLTR_SETUP_ID, DPFLTR_TRACE_LEVEL,
            "ASR %c%lu Create ASR error file at %ws\r\n",
            THIS_MODULE, __LINE__, Gbl_AsrErrorFilePath);
    }
    else {
        DbgPrintEx(DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
            "ASR %c%lu (ERROR) Unable to create ASR error file at %ws (0x%lu)\r\n",
            THIS_MODULE, __LINE__, Gbl_AsrErrorFilePath, GetLastError());
    }
}


VOID
AsrpCloseLogFiles() {

    if (Gbl_AsrErrorFilePath) {
        _AsrFree(Gbl_AsrErrorFilePath);
    }

    if (Gbl_AsrLogFilePath) {
        _AsrFree(Gbl_AsrLogFilePath);
    }

    if ((Gbl_AsrLogFileHandle) && (INVALID_HANDLE_VALUE != Gbl_AsrLogFileHandle)) {
        CloseHandle(Gbl_AsrLogFileHandle);
        Gbl_AsrLogFileHandle = NULL;
    }
}

//
// This executes "notepad <Asr-Log-File>".  If we encounter a critical
// failure, we display the error log to the user, and reboot.  We
// document that any critical application that returns a fatal error
// code is required to make an entry explaining the error in the
// ASR error file.
//
VOID
AsrpExecuteOnFatalError()
{
    BOOL result = FALSE;
    DWORD exitCode = 0;
    PWSTR onFatalCmd = NULL;

    if (!Gbl_AsrErrorFilePath) {
        MYASSERT(0 && L"ExecuteOnFatalError called before InitialiseErrorFile: Gbl_ErrorFilePath is NULL");
        return;
    }

    //
    // Make the error file read-only, so that the user's changes
    // aren't accidentally saved.
    //
    result = SetFileAttributesW(Gbl_AsrErrorFilePath, FILE_ATTRIBUTE_READONLY);
    if (!result) {
        AsrpPrintDbgMsg(_asrwarn,
            "Setup was unable to reset file attributes on file [%ws] to read-only (0x%x)\r\n",
            Gbl_AsrErrorFilePath,
            GetLastError()
           );
    }

    //
    // Pop up the ASR failed wizard page.
    //

    //
    // Finally run "notepad <asr-log-file>"
    //
    onFatalCmd = AsrpExpandEnvStrings(Asr_FatalErrorCommand);
    if (!onFatalCmd) {
        //
        // Nothing we can do here--we couldn't find the command
        // to execute on fatal errors.  Just bail--this is going
        // to make the system reboot.
        //
        return;
    }

    result = InvokeExternalApplication(
        NULL,           // no Application Name
        onFatalCmd,    // the full command string
        &exitCode       // we want a synchronous execution
       );
    if (!result) {
        SetFileAttributesW(Gbl_AsrErrorFilePath, FILE_ATTRIBUTE_NORMAL);
        AsrpPrintDbgMsg(_asrwarn,
            "Setup was unable to display error file, [%ws] failed (0x%x)\r\n",
            onFatalCmd,
            GetLastError()
           );
    }

    _AsrFree(onFatalCmd);
}


BOOL
AsrpSetFileSecurity(
    )
{
    DWORD dwStatus = ERROR_SUCCESS;
    SECURITY_ATTRIBUTES securityAttributes;
    SECURITY_DESCRIPTOR securityDescriptor;
    BOOL bResult = FALSE;

    if ((!Gbl_AsrErrorFilePath) || (!Gbl_AsrLogFilePath)) {
        SetLastError(ERROR_FILE_NOT_FOUND);
        AsrpPrintDbgMsg(_asrlog,
            "Unable to set backup operator permissions for log/error files (0x2)\r\n");
        return FALSE;
    }

    securityAttributes.nLength  = sizeof(SECURITY_ATTRIBUTES);
    securityAttributes.lpSecurityDescriptor = &securityDescriptor;
    securityAttributes.bInheritHandle = FALSE;

    bResult = AsrpConstructSecurityAttributes(&securityAttributes);
    _AsrpErrExitCode((!bResult), dwStatus, GetLastError());

    bResult = SetFileSecurity(Gbl_AsrErrorFilePath,
        DACL_SECURITY_INFORMATION,
        &securityDescriptor
        );
    _AsrpErrExitCode((!bResult), dwStatus, GetLastError());
    AsrpPrintDbgMsg(_asrinfo,
        "Set backup operator permissions for error file at %ws\r\n",
        Gbl_AsrErrorFilePath
        );


    bResult = SetFileSecurity(Gbl_AsrLogFilePath,
        DACL_SECURITY_INFORMATION,
        &securityDescriptor
        );
    _AsrpErrExitCode((!bResult), dwStatus, GetLastError());
    AsrpPrintDbgMsg(_asrinfo,
        "Set backup operator permissions for log file at %ws\r\n",
        Gbl_AsrLogFilePath
        );


EXIT:
    AsrpCleanupSecurityAttributes(&securityAttributes);

    if (ERROR_SUCCESS != dwStatus) {
        SetLastError(dwStatus);
    }

    if (bResult) {
        AsrpPrintDbgMsg(_asrinfo, "Set backup operator permissions for files\r\n");
    }
    else {
        AsrpPrintDbgMsg(_asrlog,
            "Unable to set backup operator permissions for log/error files (0x%lu)\r\n",
            GetLastError());
    }

    return bResult;
}



///////////////////////////////////////////////////////////////////////////////
// Public function definitions.
///////////////////////////////////////////////////////////////////////////////

VOID
AsrInitialize(VOID)
/*++
Description:

    Initializes the data structures required to complete ASR (Automated System
    Recovery, aka Disaster Recovery).  This consists of reading the asr.sif
    file then initializing a list of recovery applications to be executed.

Arguments:

    None.

Returns:

    None.
--*/
{
    PWSTR sifName = NULL;
    HINF sifHandle  = NULL;
    BOOL result = FALSE;
    UINT errorLine = 0;

    SYSTEMTIME currentTime;
    GetSystemTime(&currentTime);


    //
    // Set the %TEMP% to c:\temp
    //
    AsrpSetEnvironmentVariables();

    //
    // Initialise the log files
    //
    AsrpInitialiseErrorFile();
    AsrpInitialiseLogFile();

    AsrpPrintDbgMsg(_asrlog,
        "Entering GUI-mode Automated System Recovery.  UTC: %04hu/%02hu/%02hu %02hu:%02hu:%02hu.%03hu.\r\n",
        currentTime.wYear,
        currentTime.wMonth,
        currentTime.wDay,
        currentTime.wHour,
        currentTime.wMinute,
        currentTime.wSecond,
        currentTime.wMilliseconds
       );

    //
    // Open the asr.sif file
    //
    sifName = AsrpExpandEnvStrings(AsrSifPath);
    if (!sifName) {
        AsrpPrintDbgMsg(_asrerror, "Setup was unable to locate the ASR state file asr.sif.\r\n");
        FatalError(MSG_LOG_SYSINFBAD, L"asr.sif",0,0);
    }

    sifHandle = SetupOpenInfFileW(
        sifName,
        NULL,               // Inf Class
        INF_STYLE_WIN4,
        &errorLine                // Error-line
       );

    if ((!sifHandle) || (INVALID_HANDLE_VALUE == sifHandle)) {

        AsrpPrintDbgMsg(_asrerror,
            "Setup was unable to open the ASR state file [%ws].  Error-code: 0x%x, Line %lu\r\n",
            sifName,
            GetLastError(),
            errorLine
           );
        _AsrFree(sifName);

        FatalError(MSG_LOG_SYSINFBAD, L"asr.sif",0,0);
    }

    //
    // Add the "last instance" registry entry for ASR.
    //
    AsrpAddRegistryEntry();

    //
    // Set the time-zone information.
    //
    result = AsrpRestoreTimeZoneInformation(sifName);
    if (!result) {
        AsrpPrintDbgMsg(_asrwarn,
            "Setup was unable to restore the time-zone information on the machine.  (0x%x)  ASR state file %ws\r\n",
            GetLastError(),
            (sifName ? sifName : L"could not be determined")
            );
    }
    else {
        AsrpPrintDbgMsg(_asrlog, "Successfully restored time-zone information.\r\n");
    }


    _AsrFree(sifName);

    //AsrpPerformSifIntegrityCheck(Handle); No check at the moment

    //
    // Make sure the licensed processors key is set.  I'm adding this call here
    // since if this key isn't present when we reboot, the system bugchecks with
    // 9A: system_license_violation.
    //
    SetEnabledProcessorCount();

    SetupCloseInfFile(sifHandle);
    Gbl_IsAsrEnabled = TRUE;
}


BOOL
AsrIsEnabled(VOID)
/*++
Description:

    Informs the caller whether ASR has been enabled by returning the value of
    the Gbl_IsAsrEnabled flag.

Arguments:

    None.

Returns:

    TRUE, if ASR is enabled.  Otherwise, FALSE is returned.

--*/
{
    return Gbl_IsAsrEnabled;
}


VOID
AsrExecuteRecoveryApps(VOID)
/*++
Description:

    Executes the commands in the [COMMANDS] section of the asr.sif file.

Arguments:

    None.

Returns:

    None.
--*/
{
    BOOL errors = FALSE,
     result = FALSE;
    DWORD exitCode = 0;
    LONG criticalApp = 0;
    PWSTR sifPath = NULL;
    PWSTR application = NULL;
    PASR_RECOVERY_APP_NODE pNode = NULL;
    ASR_RECOVERY_APP_LIST list = {NULL, NULL, 0};
    SYSTEMTIME currentTime;
    PWSTR errString = NULL;

    ASSERT_HEAP_IS_VALID();
    //
    // Restore the non-critical disks.
    //
    SetLastError(ERROR_SUCCESS);
    sifPath = AsrpExpandEnvStrings(AsrSifPath);
    if (sifPath) {
        result = AsrpRestoreNonCriticalDisksW(sifPath, TRUE);
    }
    if (!result) {
        AsrpPrintDbgMsg(_asrwarn,
            "Setup was unable to restore the configuration of some of the disks on the machine.  (0x%x)  ASR state file %ws\r\n",
            GetLastError(),
            (sifPath ? sifPath : L"could not be determined")
            );
    }
    else {
        AsrpPrintDbgMsg(_asrlog,
            "Successfully recreated disk configurations.\r\n");
    }
    _AsrFree(sifPath);

    ASSERT_HEAP_IS_VALID();

    //
    // Close the system handle
    //
    if ((Gbl_AsrSystemVolumeHandle) && (INVALID_HANDLE_VALUE != Gbl_AsrSystemVolumeHandle)) {
        CloseHandle(Gbl_AsrSystemVolumeHandle);
        Gbl_AsrSystemVolumeHandle = NULL;
        AsrpPrintDbgMsg(_asrinfo, "Closed system device handle.\r\n");
    }
    else {
        AsrpPrintDbgMsg(_asrinfo, "Did not have a valid system device handle to close.\r\n");
    }


    //
    // Set the file security for the log and err files, to allow
    // backup operators to be able to access it on reboot
    //
    AsrpSetFileSecurity();


    AsrpInitExecutionEnv(&list);

    //
    // Sort the list of recovery apps, by sequence number.
    //
    AsrpSortAppListBySequenceNumber(&list);

    //
    // Change the boot timeout value in the boot.ini file. We do this now,
    // since executed apps in the list might result in changing drive letter,
    // which would make finding boot.ini non-trivial.
    //
    if (!ChangeBootTimeout(30)) {
        AsrpPrintDbgMsg(_asrwarn, "Failed to change boot.ini timeout value.\r\n");
    }

    //
    // Remove an application from the list and execute it.  Continue until
    // no more applications remain.
    //
    pNode = AsrpRemoveFirstNodeFromList(&list);

    while (pNode && !errors) {

        application = AsrpBuildInvocationString(pNode);
        criticalApp = pNode->CriticalApp;

        //
        // We don't need pNode any more
        //
        if (pNode->RecoveryAppParams) {
            _AsrFree(pNode->RecoveryAppParams);
        }
        _AsrFree(pNode->RecoveryAppCommand);
        _AsrFree(pNode);

        //
        // if the cmd line couldn't be created:
        // for a critical app, fail.
        // for a non-critical app, move on to next
        //
        if (!application) {
            if (0 < criticalApp) {
                errors = TRUE;
            }
        }

        else {
            //
            // Launch the app
            //
            AsrpPrintDbgMsg(_asrlog, "Invoking external recovery application [%ws]\r\n", application);
            exitCode = ERROR_SUCCESS;
            SetLastError(ERROR_SUCCESS);

            result = InvokeExternalApplication(
                NULL,           // no Application Name
                application,    // the full command string
                &exitCode       // we want a synchronous execution
               );

            if (!result) {
                AsrpPrintDbgMsg(_asrerror,
                    "Setup was unable to start the recovery application \"%ws\" (0x%x).\r\n",
                    application,
                    GetLastError()
                   );
                //
                // If a critical app couldn't be launched, it's a fatal error
                //
                if (0 < criticalApp) {

                    errString = MyLoadString(IDS_ASR_ERROR_UNABLE_TO_LAUNCH_APP);

                    if (errString) {
                        swprintf(g_szErrorMessage, errString, application, GetLastError());
                        AsrpLogErrorMessage(g_szErrorMessage);
                        MyFree(errString);
                        errString = NULL;
                    }
                    else {
                        FatalError(MSG_LOG_OUTOFMEMORY, L"", 0, 0);
                    }

                    errors = TRUE;
                }
            }
            else {
                //
                // Application was started: check the return code.  If return
                // code is not zero and this is a critical app (ie criticalApp=1)
                // it is a fatal error
                //
                if ((ERROR_SUCCESS != exitCode) && (0 < criticalApp)) {

                    AsrpPrintDbgMsg(_asrerror, "The recovery application \"%ws\" returned an error code 0x%x.  Since this indicates an unrecoverable error, ASR cannot continue on this machine.\r\n", application, exitCode);

                    errString = MyLoadString(IDS_ASR_ERROR_RECOVERY_APP_FAILED);

                    if (errString) {
                        swprintf(g_szErrorMessage, errString, application, exitCode);
                        AsrpLogErrorMessage(g_szErrorMessage);
                        MyFree(errString);
                        errString = NULL;
                    }
                    else {
                        FatalError(MSG_LOG_OUTOFMEMORY, L"", 0, 0);
                    }

                    errors = TRUE;
                }
                else {
                    AsrpPrintDbgMsg(_asrlog, "The recovery application \"%ws\" returned an exit code of 0x%x\r\n", application, exitCode);
                }
            }
        }

        _AsrFree(application);

        pNode = AsrpRemoveFirstNodeFromList(&list);
    }

    if (errors) {
        //
        // A critical app above did not return 0.
        //
        AsrpExecuteOnFatalError();
    }
    else {
        //
        // We executed all the apps, without any critical failure.
        //
        RemoveRestartability(NULL);
        DeleteLocalSource();
        AsrpMergeSetupLogIfNeeded();

        AsrpPrintDbgMsg(_asrlog, "ASR completed successfully.\r\n");
    }


    GetSystemTime(&currentTime);
    AsrpPrintDbgMsg(_asrlog,
        "Exiting from GUI-mode Automated System Recovery.  UTC: %04hu/%02hu/%02hu %02hu:%02hu:%02hu.%03hu.\r\n",
        currentTime.wYear,
        currentTime.wMonth,
        currentTime.wDay,
        currentTime.wHour,
        currentTime.wMinute,
        currentTime.wSecond,
        currentTime.wMilliseconds
       );

    //
    // Clean up global values
    //
    AsrpCloseLogFiles();
    ASSERT_HEAP_IS_VALID();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\setupp.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    setupp.h

Abstract:

    Private top-level header file for Windows NT Setup module.

Author:

    Ted Miller (tedm) 11-Jan-1995

Revision History:

--*/


//
// System header files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <ntlsa.h>
#include <ntdddisk.h>
#include <ntapmsdk.h>
#define OEMRESOURCE     // setting this gets OBM_ constants in windows.h
#include <windows.h>
#include <winspool.h>
#include <winsvcp.h>
#include <ntdskreg.h>
#include <ntddft.h>
#include <ddeml.h>
#include <commdlg.h>
#include <commctrl.h>
#include <setupapi.h>
#include <spapip.h>
#include <cfgmgr32.h>
#include <objbase.h>
#include <syssetup.h>
#include <ntsetup.h>
#include <userenv.h>
#include <userenvp.h>
#include <regstr.h>
#include <setupbat.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <cryptui.h>
#include <wincrypt.h>
#include <dnsapi.h>
#include <winnls.h>
#include <encrypt.h>
// For setting default power scheme
#include <initguid.h>
#include <poclass.h>
#include <powrprofp.h>
// For NetGetJoinInformation & NetApiBufferFree
#include <lmjoin.h>
#include <lmapibuf.h>
// For EnableSR()
#include <srrpcapi.h>

#ifdef _WIN64
#include <wow64reg.h>
#endif

//
// CRT header files
//
#include <process.h>
#include <wchar.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <limits.h>
#ifdef UNICODE
#define _UNICODE
#endif
#include <tchar.h>

//
// Private header files
//
#include "res.h"
#include "msg.h"
#include "helpids.h"
#include "unattend.h"
#include "sif.h"
#include "watch.h"
#include "userdiff.h"
#include "setuplog.h"
#include "pidgen.h"
#include "mgdlllib.h"
#include "dynupdt.h"

#include <sfcapip.h>
#include <sfcfiles.h>
#include <excppkg.h>
#include <mscat.h>
#include <softpub.h>


#if defined(_AMD64_)
#include "amd64\spx86.h"
#elif defined(_X86_)
#include "i386\spx86.h"
#endif


//
// Custom window messages.
//
#define WM_IAMVISIBLE   (WM_APP + 0)
#define WM_SIMULATENEXT (WM_APP + 1)
#define WM_MY_PROGRESS  (WM_APP + 2)
#define WM_NEWBITMAP    (WM_APP + 3)
#define WM_MY_STATUS    (WM_APP + 4)

#define WMX_TERMINATE   (WM_APP + 5)
#define WMX_VALIDATE    (WM_APP + 6)

// Message used to end the main setup window.
#define WM_EXIT_SETUPWINDOW (WM_APP + 7)

// Billboard private messages
#define WMX_SETPROGRESSTEXT (WM_APP + 8)
#define WMX_BB_SETINFOTEXT  (WM_APP + 9)
#define WMX_BBPROGRESSGAUGE (WM_APP + 10)
#define WMX_BBTEXT          (WM_APP + 11)
#define WMX_PROGRESSTICKS   (WM_APP + 12)
//
// enum for use with WM_NEWBITMAP
//
typedef enum {
    SetupBmBackground,
    SetupBmLogo,
    SetupBmBanner           // text, not a bitmap
} SetupBm;

//
// Context for file queues in SysSetup
//
typedef struct _SYSSETUP_QUEUE_CONTEXT {
    PVOID   DefaultContext;
    BOOL    Skipped;
} SYSSETUP_QUEUE_CONTEXT, *PSYSSETUP_QUEUE_CONTEXT;

//
// Context for migrating exception packages
//
typedef struct _EXCEPTION_MIGRATION_CONTEXT {
    PDWORD  Count;
    HWND    hWndProgress;
    BOOL    AnyComponentFailed;
} EXCEPTION_MIGRATION_CONTEXT, *PEXCEPTION_MIGRATION_CONTEXT;

//
// context for file registration in syssetup
//
typedef struct _REGISTRATION_CONTEXT {
    HWND hWndParent;
    HWND hWndProgress;
} REGISTRATION_CONTEXT, *PREGISTRATION_CONTEXT;



//
// Constant for SETUPLDR. Use #ifdef since it has different names for
// different architectures.
//
#ifdef _IA64_
#define SETUPLDR                L"SETUPLDR.EFI"
#endif

#ifdef _AMD64_
#define SETUPLDR                L"SETUPLDR"
#endif

//
// Module handle for this module.
//
extern HANDLE MyModuleHandle;

//
// full path to this module
//
extern WCHAR MyModuleFileName[MAX_PATH];

//
// unattend answer table
//
extern UNATTENDANSWER UnattendAnswerTable[];

#if DBG

VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    );

#define MYASSERT(x)     if(!(x)) { AssertFail(__FILE__,__LINE__,#x); }

#else

#define MYASSERT(x)

#endif
//
// Handle to heap so we can periodically validate it.
//
#if DBG
    extern HANDLE g_hSysSetupHeap;
    #define ASSERT_HEAP_IS_VALID()  if (g_hSysSetupHeap) MYASSERT(RtlValidateHeap(g_hSysSetupHeap,0,NULL))
#else
    #define ASSERT_HEAP_IS_VALID()
#endif
//
// Product type being installed.
//
extern UINT ProductType;

//
// Boolean value indicating whether this installation
// originated with winnt/winnt32.
// And, original source path, saved away for us by winnt/winnt32.
//
extern BOOL WinntBased;
extern PCWSTR OriginalSourcePath;

//
// Boolean value indicating whether this is a remote boot setup.
//
extern BOOL RemoteBootSetup;

//
// Mask indicating the "base" CopyStyle to use. Normally 0, this is set to
// SP_COPY_SOURCE_SIS_MASTER during a remote boot setup to indicate that
// the installation source and target reside on the same single-instance
// storage volume.
//
extern ULONG BaseCopyStyle;

//
// Boolean value indicating whether we're upgrading.
//
extern BOOL Upgrade;
extern BOOL Win31Upgrade;
extern BOOL Win95Upgrade;
extern BOOL UninstallEnabled;

//
// Boolean value indicating whether we're in Setup or in appwiz.
//
extern BOOL IsSetup;

//
// Boolean value indicating whether we're doing a subset of gui-mode setup.
//
extern BOOL MiniSetup;

//
// Boolean value indicating whether we're doing a subset of gui-mode setup.
//
extern BOOL OobeSetup;

//
// Boolean value indicating whether we're doing a subset of gui-mode setup
// AND we did PnP re-enumeration.
//
extern BOOL PnPReEnumeration;

//
// Window handle of topmost setup window.
//
extern HWND SetupWindowHandle;
extern HWND MainWindowHandle;
extern HWND WizardHandle;
extern HANDLE SetupWindowThreadHandle;

//
// Source path for installation.
//
extern WCHAR SourcePath[MAX_PATH];

//
// System setup inf.
//
extern HINF SyssetupInf;

//
// Flag indicating whether this is an unattended mode install/upgrade.
//
extern BOOL Unattended;

//
// We can get into unattended mode in several ways, so we also check whether
// the "/unattend" switch was explicitly specified.
//
extern BOOL UnattendSwitch;

//
// Flag indicating whether we should run OOBE after Setup completes.  Note
// that if it is FALSE, OOBE may still be run, based on other criteria.
//
extern BOOL ForceRunOobe;

//
// Flag indicating whether we are in a special mode for OEM's to use on the
// factory floor.
//
extern BOOL ReferenceMachine;

//
// Flag indicating whether a volume was extended or not using
// ExtendOemPartition
//
extern BOOL PartitionExtended;


//
// Flag indicating if we're installing from a CD.
//
extern BOOL gInstallingFromCD;

//
// Cryptographically secure codesigning policies
//
extern DWORD PnpSeed;

//
// the original locale we started setup under.
//
extern LCID  OriginalInstallLocale;

//
// Indicates whether we need to wait at the installation
// end in unattended mode. Default is no wait.
//
extern BOOL UnattendWaitForReboot;


//
// If we are running unattended, the following mode indicates how answers
// are used.
//
typedef enum _UNATTENDMODE {
   UAM_INVALID,
   UAM_GUIATTENDED,
   UAM_PROVIDEDEFAULT,
   UAM_DEFAULTHIDE,
   UAM_READONLY,
   UAM_FULLUNATTENDED,
} UNATTENDMODE;

extern UNATTENDMODE UnattendMode;

//
// Flags indicating whether any accessibility utilities are in use.
//
extern BOOL AccessibleSetup;
extern BOOL Magnifier;
extern BOOL ScreenReader;
extern BOOL OnScreenKeyboard;

//
// String id of the string to be used for titles -- "Windows NT Setup"
//
extern UINT SetupTitleStringId;

//
// Platform name, like i386, ppc, alpha, mips
//
extern PCWSTR PlatformName;

//
// Maximum lengths for the various fields that form Pid 2.0
//
#define MAX_PID20_RPC  5
#define MAX_PID20_SITE  3
#define MAX_PID20_SERIAL_CHK  7
#define MAX_PID20_RANDOM  5


//
// Maximum lengths for the pid 3.0 fields
//
#define MAX_PID30_EDIT 5
#define MAX_PID30_RPC  5
#define MAX_PID30_SITE 3
extern WCHAR Pid30Text[5][MAX_PID30_EDIT+1];
extern WCHAR Pid30Rpc[MAX_PID30_RPC+1];
extern WCHAR Pid30Site[MAX_PID30_SITE+1];
extern BYTE DigitalProductId[DIGITALPIDMAXLEN];


//
// Maximum product id length and the Product ID.
//
//                   5    3     7     5    3 for the 3 dashes between the numbers.
// MAX_PRODUCT_ID = MPC+SITE+SERIAL+RANDOM+3
#define MAX_PRODUCT_ID  MAX_PID20_RPC+MAX_PID20_SITE+MAX_PID20_SERIAL_CHK+MAX_PID20_RANDOM + 3
extern WCHAR ProductId[MAX_PRODUCT_ID+1];
extern WCHAR ProductId20FromProductId30[MAX_PRODUCT_ID+1];

//
// Maximum computer name length and the computer name.
//
extern WCHAR ComputerName[DNS_MAX_LABEL_LENGTH+1];
extern WCHAR Win32ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
extern BOOL IsNameTruncated;
extern BOOL IsNameNonRfc;

//
// Copy disincentive name/organization strings.
//
#define MAX_NAMEORG_NAME  50
#define MAX_NAMEORG_ORG   50
extern WCHAR NameOrgName[MAX_NAMEORG_NAME+1];
extern WCHAR NameOrgOrg[MAX_NAMEORG_ORG+1];

//
// User name and password
//
#define MAX_USERNAME    20
#define MAX_PASSWORD    127
extern WCHAR UserName[MAX_USERNAME+1];
extern WCHAR UserPassword[MAX_PASSWORD+1];
extern BOOL CreateUserAccount;

//
// Administrator password.

extern WCHAR   CurrentAdminPassword[MAX_PASSWORD+1];//
extern WCHAR   AdminPassword[MAX_PASSWORD+1];
extern BOOL    EncryptedAdminPasswordSet;
extern BOOL    DontChangeAdminPassword;

#ifdef _X86_
extern BOOL FlawedPentium;
#endif

//
// This is a specification of optional directories
// and/or optional user command to execute,
// passed to us from text setup.
//
extern PWSTR OptionalDirSpec;
extern PWSTR UserExecuteCmd;
extern BOOL SkipMissingFiles;
extern PWSTR IncludeCatalog;

//
// Custom, typical, laptop, minimal.
//
extern UINT SetupMode;

//
// boolean indicating if the eula was already shown during the winnt32 setup phase
// this was passed to us from text setup.  if the eula was shown, then the pid has
// also been retreived from the user and validated
extern BOOL EulaComplete;

//
// Flag indicating if the eula was already shown during the textmode setup phase
// This will be the same as !Unattended unless UnattendMode = GuiAttended.
//
extern BOOL TextmodeEula;

//
// Global structure that contains information that will be used
// by net setup and license setup. We pass a pointer to this structure when we
// call NetSetupRequestWizardPages and LicenseSetupRequestWizardPages, then
// fill it in before we call into the net setup wizard, or liccpa.
//

extern INTERNAL_SETUP_DATA InternalSetupData;

//
// Flags indicating whether the driver and non-driver signing policies came
// from the answerfile.  (If so, then those values are in effect throughout
// GUI-mode setup and thereafter.)
//
extern BOOL AFDrvSignPolicySpecified;
extern BOOL AFNonDrvSignPolicySpecified;

//
//
// Did we log an error during SfcInitProt()?
//
extern BOOL SfcErrorOccurred;

//
// multi-sz list of files that is passed to SfcInitProt that the initial scan
// will not replace. This is used for non-signed drivers that are specified
// by F6 during textmode setup.
//
extern MULTISZ EnumPtrSfcIgnoreFiles;

//
// Parameters that are passed to the thread that drives the Finish dialog.
//
typedef struct _FINISH_THREAD_PARAMS {

    HWND  hdlg;
    DWORD ThreadId;
#ifdef _OCM
    PVOID  OcManagerContext;
#endif

} FINISH_THREAD_PARAMS, *PFINISH_THREAD_PARAMS;

DWORD
FinishThread(
    PFINISH_THREAD_PARAMS   Context
    );


//
// Miscellaneous stuff.
//
DWORD
ApplySecurityToRepairInfo(
    );

BOOL
RestoreBootTimeout(
    VOID
    );

VOID
PrepareForNetSetup(
    VOID
    );

VOID
PrepareForNetUpgrade(
    VOID
    );

VOID
pSetInstallAttributes(
    VOID
    );

DWORD
TreeCopy(
    IN PCWSTR SourceDir,
    IN PCWSTR TargetDir
    );

VOID
DelSubNodes(
    IN PCWSTR Directory
    );

VOID
Delnode(
    IN PCWSTR Directory
    );

BOOL
InitializePidVariables(
    VOID
    );

BOOL
SetPid30Variables(
    PWSTR   Buffer
    );

BOOL
ValidateCDRetailSite(
    IN PCWSTR    PidString
    );

BOOL
ValidateSerialChk(
    IN PCWSTR    PidString
    );

BOOL
ValidateOemRpc(
    IN PCWSTR    PidString
    );

BOOL
ValidateOemSerialChk(
    IN PCWSTR    PidString
    );

BOOL
ValidateOemRandom(
    IN PCWSTR    PidString
    );

BOOL
ValidateAndSetPid30(
    VOID
    );

BOOL
CreateLicenseInfoKey(
    );

BOOL
InstallNetDDE(
    VOID
    );

BOOL
CopyOptionalDirectories(
    VOID
    );

VOID
SetUpProductTypeName(
    OUT PWSTR  ProductTypeString,
    IN  UINT   BufferSizeChars
    );

VOID
RemoveHotfixData(
    VOID
    );

void
SetupCrashRecovery(
    VOID
    );

BOOL
SpSetupLoadParameter(
    IN  PCWSTR Param,
    OUT PWSTR  Answer,
    IN  UINT   AnswerBufLen
    );

//
// IsArc() is always true on non-x86 machines except AMD64 for which it is
// always false. On x86, this determination has to be made at run time.
//
#if defined(_X86_)
BOOL
IsArc(
    VOID
    );
#elif defined(_AMD64_)
#define IsArc() FALSE
#else
#define IsArc() TRUE
#endif

//
// IsEfi() is always true on IA64 machines. Therefore this determination can
// be made at compile time. When x86 EFI machines are supported, the check
// will need to be made at run time on x86.
//
// Note that EFI_NVRAM_ENABLED is defined in ia64\sources.
//
#if defined(EFI_NVRAM_ENABLED)
#define IsEfi() TRUE
#else
#define IsEfi() FALSE
#endif

VOID
DeleteLocalSource(
    VOID
    );

BOOL
ValidateAndChecksumFile(
    IN  PCTSTR   Filename,
    OUT PBOOLEAN IsNtImage,
    OUT PULONG   Checksum,
    OUT PBOOLEAN Valid
    );

HMODULE
MyLoadLibraryWithSignatureCheck(
    IN  PWSTR   ModuleName
    );

DWORD
QueryHardDiskNumber(
    IN  UCHAR   DriveLetter
    );

BOOL
ExtendPartition(
    IN WCHAR    DriveLetter,
    IN ULONG    SizeMB      OPTIONAL
    );

DWORD
RemoveStaleVolumes(
    VOID
    );


BOOL
DoFilesMatch(
    IN PCWSTR File1,
    IN PCWSTR File2
    );

UINT
MyGetDriveType(
    IN WCHAR Drive
    );

BOOL
GetPartitionInfo(
    IN  WCHAR                  Drive,
    OUT PPARTITION_INFORMATION PartitionInfo
    );

BOOL
IsErrorLogEmpty (
    VOID
    );

VOID
BuildVolumeFreeSpaceList(
    OUT DWORD VolumeFreeSpaceMB[26]
    );

BOOL
SetUpVirtualMemory(
    VOID
    );

BOOL
RestoreVirtualMemoryInfo(
    VOID
    );

BOOL
CopySystemFiles(
    VOID
    );

BOOL
UpgradeSystemFiles(
    VOID
    );

VOID
MarkFilesReadOnly(
    VOID
    );

VOID
PumpMessageQueue(
    VOID
    );

BOOL
ConfigureMsDosSubsystem(
    VOID
    );

BOOL
PerfMergeCounterNames(
    VOID
    );

DWORD
pSetupInitRegionalSettings(
    IN  HWND    Window
    );

VOID
pSetupMarkHiddenFonts(
    VOID
    );

VOID
InstallServerNLSFiles(
    );

PVOID
InitSysSetupQueueCallbackEx(
    IN HWND  OwnerWindow,
    IN HWND  AlternateProgressWindow, OPTIONAL
    IN UINT  ProgressMessage,
    IN DWORD Reserved1,
    IN PVOID Reserved2
    );

PVOID
InitSysSetupQueueCallback(
    IN HWND OwnerWindow
    );

VOID
TermSysSetupQueueCallback(
    IN PVOID SysSetupContext
    );

UINT
SysSetupQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );

UINT
RegistrationQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR  Param1,
    IN UINT_PTR  Param2
    );


VOID
SaveRepairInfo(
    IN  HWND    hWnd,
    IN  ULONG   StartAtPercent,
    IN  ULONG   StopAtPercent
    );

BOOLEAN
IsLaptop(
    VOID
    );

VOID
InitializeUniqueness(
    IN OUT HWND *Billboard
    );

#ifdef _X86_

//
// Code in i386\migwin95.c
//

BOOL
PreWin9xMigration(
    VOID
    );

BOOL
MigrateWin95Settings(
    IN HWND     hwndWizardParent,
    IN LPCWSTR  UnattendFile
    );

BOOL
Win95MigrationFileRemoval(
    void
    );

BOOL
RemoveFiles_X86(
    IN HINF InfHandle
    );

#endif // def _X86_


BOOL
RegisterActionItemListControl(
    IN BOOL Init
    );

LONG
WINAPI
MyUnhandledExceptionFilter(
    IN struct _EXCEPTION_POINTERS *ExceptionInfo
    );

#ifdef _OCM
PVOID
#else
VOID
#endif
CommonInitialization(
    VOID
    );


VOID
InitializeExternalModules(
    BOOL                DoSetupStuff,
    PVOID*              pOcManagerContext
    );

BOOL
pSetupWaitForScmInitialization();

VOID
SetUpDataBlock(
    VOID
    );


//
// Wizard control.
//
VOID
Wizard(
#ifdef _OCM
    IN PVOID OcManagerContext
#else
    VOID
#endif
    );

//
// IMPORTANT: keep this in sync with WIZPAGE SetupWizardPages[WizPageMaximum]
//
typedef enum {
    WizPageWelcome,
    WizPageEula,
    WizPagePreparing,
    WizPagePreparingAsr,
#ifdef PNP_DEBUG_UI
    WizPageInstalledHardware,
#endif // PNP_DEBUG_UI
    WizPageRegionalSettings,
    WizPageNameOrg,
    WizPageProductIdCd,
    WizPageProductIdOem,
    WizPageProductIdSelect,
    WizPageComputerName,
#ifdef DOLOCALUSER
    WizPageUserAccount,
#endif
#ifdef _X86_
    WizPagePentiumErrata,
#endif // def _X86_
    WizPageSteps1,

    WizSetupPreNet,
    WizSetupPostNet,

    WizPageCopyFiles,
    WizPageAsrLast,
    WizPageLast,
    WizPageMaximum
} WizPage;

extern HPROPSHEETPAGE WizardPageHandles[WizPageMaximum];

extern BOOL UiTest;

VOID
SetWizardButtons(
    IN HWND    hdlgPage,
    IN WizPage PageNumber
    );

VOID
WizardBringUpHelp(
    IN HWND    hdlg,
    IN WizPage PageNumber
    );

VOID
WizardKillHelp(
    IN HWND hdlg
    );

//
// Dialog procs.
//
INT_PTR
CALLBACK
WelcomeDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
EulaDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
StepsDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
PreparingDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
InstalledHardwareDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
SetupModeDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
RegionalSettingsDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
NameOrgDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
LicensingDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
ComputerNameDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
PidCDDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
Pid30OemDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
Pid30CDDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
Pid30SelectDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
PidOemDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

#ifdef DOLOCALUSER
INT_PTR
CALLBACK
UserAccountDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );
#endif

INT_PTR
CALLBACK
OptionalComponentsPageDlgProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
RepairDiskDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
CopyFilesDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
LastPageDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
DoneDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

INT_PTR
CALLBACK
SetupPreNetDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );
INT_PTR
CALLBACK
SetupPostNetDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

//
// Billboard stuff.
//
HWND
DisplayBillboard(
    IN HWND Owner,
    IN UINT MessageId,
    ...
    );

VOID
KillBillboard(
    IN HWND BillboardWindowHandle
    );

//
// Message string routines
//
PWSTR
MyLoadString(
    IN UINT StringId
    );

PWSTR
FormatStringMessageV(
    IN UINT     FormatStringId,
    IN va_list *ArgumentList
    );

PWSTR
FormatStringMessage(
    IN UINT FormatStringId,
    ...
    );

PWSTR
RetrieveAndFormatMessageV(
    IN PCWSTR   MessageString,
    IN UINT     MessageId,      OPTIONAL
    IN va_list *ArgumentList
    );

PWSTR
RetrieveAndFormatMessage(
    IN PCWSTR   MessageString,
    IN UINT     MessageId,      OPTIONAL
    ...
    );

int
MessageBoxFromMessageExV (
    IN HWND   Owner,            OPTIONAL
    IN LogSeverity  Severity,   OPTIONAL
    IN PCWSTR MessageString,
    IN UINT   MessageId,        OPTIONAL
    IN PCWSTR Caption,          OPTIONAL
    IN UINT   CaptionStringId,  OPTIONAL
    IN UINT   Style,
    IN va_list ArgumentList
    );

int
MessageBoxFromMessageEx (
    IN HWND   Owner,            OPTIONAL
    IN LogSeverity  Severity,   OPTIONAL
    IN PCWSTR MessageString,
    IN UINT   MessageId,        OPTIONAL
    IN PCWSTR Caption,          OPTIONAL
    IN UINT   CaptionStringId,  OPTIONAL
    IN UINT   Style,
    ...
    );

int
MessageBoxFromMessage(
    IN HWND   Owner,            OPTIONAL
    IN UINT   MessageId,
    IN PCWSTR Caption,          OPTIONAL
    IN UINT   CaptionStringId,  OPTIONAL
    IN UINT   Style,
    ...
    );

//
// Action-logging routines.
//
extern PCWSTR ActionLogFileName;

VOID
InitializeSetupLog(
    IN  PSETUPLOG_CONTEXT   Context
    );

VOID
TerminateSetupLog(
    IN  PSETUPLOG_CONTEXT   Context
    );

VOID
LogRepairInfo(
    IN  PCWSTR  Source,
    IN  PCWSTR  Target
    );

VOID
FatalError(
    IN UINT MessageId,
    ...
    );

BOOL
InitializeSetupActionLog(
    BOOL WipeLogFile
    );

VOID
TerminateSetupActionLog(
    VOID
    );

BOOL
LogItem(
    IN LogSeverity Severity,
    IN PCWSTR      Description
    );

BOOL
LogItem0(
    IN LogSeverity Severity,
    IN UINT        MessageId,
    ...
    );

BOOL
LogItem1(
    IN LogSeverity Severity,
    IN UINT        MajorMsgId,
    IN UINT        MinorMsgId,
    ...
    );

BOOL
LogItem2(
    IN LogSeverity Severity,
    IN UINT        MajorMsgId,
    IN PCWSTR      MajorMsgParam,
    IN UINT        MinorMsgId,
    ...
    );

BOOL
LogItem3(
    IN LogSeverity Severity,
    IN UINT        MajorMsgId,
    IN PCWSTR      MajorMsgParam1,
    IN PCWSTR      MajorMsgParam2,
    IN UINT        MinorMsgId,
    ...
    );

PCWSTR
FormatSetupMessageV (
    IN UINT     MessageId,
    IN va_list  ArgumentList
    );

BOOL
LogItemV (
    IN LogSeverity  Severity,
    IN va_list      ArgumentList
    );

LogItemN (
    IN LogSeverity  Severity,
    ...
    );

BOOL
ViewSetupActionLog(
    IN HWND     hOwnerWindow,
    IN PCWSTR   OptionalFileName    OPTIONAL,
    IN PCWSTR   OptionalHeading     OPTIONAL
    );


//
// Constant strings used for logging in various places.
//
extern PCWSTR szFALSE;
extern PCWSTR szWaitForSingleObject;
extern PCWSTR szSetGroupOfValues;
extern PCWSTR szSetArrayToMultiSzValue;
extern PCWSTR szCreateProcess;
extern PCWSTR szRegOpenKeyEx;
extern PCWSTR szRegQueryValueEx;
extern PCWSTR szRegSetValueEx;
extern PCWSTR szDeleteFile;
extern PCWSTR szRemoveDirectory;
extern PCWSTR szOpenSCManager;
extern PCWSTR szCreateService;
extern PCWSTR szChangeServiceConfig;
extern PCWSTR szOpenService;
extern PCWSTR szStartService;
extern PCWSTR szSetupInstallFromInfSection;



//
// ARC routines.
//
PWSTR
ArcDevicePathToNtPath(
    IN PCWSTR ArcPath
    );

PWSTR
NtFullPathToDosPath(
    IN PCWSTR NtPath
    );

BOOL
ChangeBootTimeout(
    IN UINT Timeout
    );

BOOL
SetNvRamVariable(
    IN PCWSTR VarName,
    IN PCWSTR VarValue
    );

PWSTR
NtPathToDosPath(
    IN PCWSTR NtPath
    );

//
// Progman/program group stuff
//
BOOL
CreateStartMenuItems(
    IN HINF InfHandle
    );

BOOL
UpgradeStartMenuItems(
    IN HINF InfHandle
    );

//
// Cryptography stuff
//
BOOL
InstallOrUpgradeCapi(
    VOID
    );


//
// Plug&Play initialization
//
HANDLE
SpawnPnPInitialization(
    VOID
    );

DWORD
PnPInitializationThread(
    IN PVOID ThreadParam
    );



//
// Printer/spooler routines
//
BOOL
MiscSpoolerInit(
    VOID
    );

BOOL
StartSpooler(
    VOID
    );

DWORD
UpgradePrinters(
    VOID
    );


//
// Name of spooler service.
//
extern PCWSTR szSpooler;

//
// Service control.
//
BOOL
MyCreateService(
    IN PCWSTR  ServiceName,
    IN PCWSTR  DisplayName,         OPTIONAL
    IN DWORD   ServiceType,
    IN DWORD   StartType,
    IN DWORD   ErrorControl,
    IN PCWSTR  BinaryPathName,
    IN PCWSTR  LoadOrderGroup,      OPTIONAL
    IN PWCHAR  DependencyList,
    IN PCWSTR  ServiceStartName,    OPTIONAL
    IN PCWSTR  Password             OPTIONAL
    );

BOOL
MyChangeServiceConfig(
    IN PCWSTR ServiceName,
    IN DWORD  ServiceType,
    IN DWORD  StartType,
    IN DWORD  ErrorControl,
    IN PCWSTR BinaryPathName,   OPTIONAL
    IN PCWSTR LoadOrderGroup,   OPTIONAL
    IN PWCHAR DependencyList,
    IN PCWSTR ServiceStartName, OPTIONAL
    IN PCWSTR Password,         OPTIONAL
    IN PCWSTR DisplayName       OPTIONAL
    );

BOOL
MyChangeServiceStart(
    IN PCWSTR ServiceName,
    IN DWORD  StartType
    );

BOOL
UpdateServicesDependencies(
    IN HINF InfHandle
    );

//
// Registry manipulation
//
typedef struct _REGVALITEM {
    PCWSTR Name;
    PVOID Data;
    DWORD Size;
    DWORD Type;
} REGVALITEM, *PREGVALITEM;

//
// Names of frequently used keys/values
//
extern PCWSTR SessionManagerKeyName;
extern PCWSTR EnvironmentKeyName;
extern PCWSTR szBootExecute;
extern PCWSTR WinntSoftwareKeyName;
extern PCWSTR szRegisteredOwner;
extern PCWSTR szRegisteredOrganization;

UINT
SetGroupOfValues(
    IN HKEY        RootKey,
    IN PCWSTR      SubkeyName,
    IN PREGVALITEM ValueList,
    IN UINT        ValueCount
    );

BOOL
CreateWindowsNtSoftwareEntry(
    IN BOOL FirstPass
    );

BOOL
CreateInstallDateEntry(
    );

BOOL
StoreNameOrgInRegistry(
    PWSTR   NameOrgName,
    PWSTR   NameOrgOrg
    );

BOOL
SetUpEvaluationSKUStuff(
    VOID
    );

BOOL
SetEnabledProcessorCount(
    VOID
    );

BOOL
SetProductIdInRegistry(
    VOID
    );

DWORD
SetCurrentProductIdInRegistry(
    VOID
    );

VOID
DeleteCurrentProductIdInRegistry(
    VOID
    );

void LogPidValues();

BOOL
SetAutoAdminLogonInRegistry(
    LPWSTR Username,
    LPWSTR Password
    );

BOOL
SetProfilesDirInRegistry(
    LPWSTR ProfilesDir
    );

BOOL
SetProductTypeInRegistry(
    VOID
    );

BOOL
SetEnvironmentVariableInRegistry(
    IN PCWSTR Name,
    IN PCWSTR Value,
    IN BOOL   SystemWide
    );

BOOL
SaveHive(
    IN HKEY   RootKey,
    IN PCWSTR Subkey,
    IN PCWSTR Filename,
    IN DWORD  Format
    );

BOOL
SaveAndReplaceSystemHives(
    VOID
    );

DWORD
FixupUserHives(
    VOID
    );

DWORD
QueryValueInHKLM (
    IN PWCH KeyName OPTIONAL,
    IN PWCH ValueName,
    OUT PDWORD ValueType,
    OUT PVOID *ValueData,
    OUT PDWORD ValueDataLength
    );

VOID
ConfigureSystemFileProtection(
    VOID
    );

VOID
RemoveRestartability (
    HWND hProgress
    );

BOOL
ResetSetupInProgress(
    VOID
    );

BOOL
RemoveRestartStuff(
    VOID
    );

BOOL
EnableEventlogPopup(
    VOID
    );

BOOL
MakeWowEntry(
    VOID
    );

BOOL
SetUpPath(
    VOID
    );

VOID
RestoreOldPathVariable(
    VOID
    );

BOOL
FixQuotaEntries(
    VOID
    );

BOOL
StampBuildNumber(
    VOID
    );

BOOL
SetProgramFilesDirInRegistry(
    VOID
    );

BOOL
RegisterOleControls(
    IN HWND     hwndParent,
    IN PVOID    InfHandle,
    IN HWND     hProgress,
    IN ULONG    StartAtPercent,
    IN ULONG    StopAtPercent,
    IN PWSTR    SectionName
    );


VOID
InitializeCodeSigningPolicies(
    IN BOOL ForGuiSetup
    );


VOID
GetDllCacheFolder(
    OUT LPWSTR CacheDir,
    IN DWORD cbCacheDir
    );


typedef enum _CODESIGNING_POLICY_TYPE {
    PolicyTypeDriverSigning,
    PolicyTypeNonDriverSigning
} CODESIGNING_POLICY_TYPE, *PCODESIGNING_POLICY_TYPE;

VOID
SetCodeSigningPolicy(
    IN  CODESIGNING_POLICY_TYPE PolicyType,
    IN  BYTE                    NewPolicy,
    OUT PBYTE                   OldPolicy  OPTIONAL
    );

DWORD
GetSeed(
    VOID
    );

//
// Ini file routines.
//
BOOL
ReplaceIniKeyValue(
    IN PCWSTR IniFile,
    IN PCWSTR Section,
    IN PCWSTR Key,
    IN PCWSTR Value
    );

BOOL
WinIniAlter1(
    VOID
    );

BOOL
SetDefaultWallpaper(
    VOID
    );

BOOL
SetShutdownVariables(
    VOID
    );

BOOL
SetLogonScreensaver(
    VOID
    );

BOOL
InstallOrUpgradeFonts(
    VOID
    );

//
// External app stuff.
//
BOOL
InvokeExternalApplication(
    IN     PCWSTR ApplicationName,  OPTIONAL
    IN     PCWSTR CommandLine,
    IN OUT PDWORD ExitCode          OPTIONAL
    );


BOOL
InvokeControlPanelApplet(
    IN PCWSTR CplSpec,
    IN PCWSTR AppletName,           OPTIONAL
    IN UINT   AppletNameStringId,
    IN PCWSTR CommandLine
    );

//
// Security/account routines.
//
BOOL
SignalLsa(
    VOID
    );

BOOL
CreateSamEvent(
    VOID
    );

BOOL
WaitForSam(
    VOID
    );

BOOL
SetAccountsDomainSid(
    IN DWORD  Seed,
    IN PCWSTR DomainName
    );

BOOL
CreateLocalUserAccount(
    IN PCWSTR UserName,
    IN PCWSTR Password,
    OUT PSID* UserSid   OPTIONAL
    );

NTSTATUS
CreateLocalAdminAccount(
    IN PCWSTR UserName,
    IN PCWSTR Password,
    OUT PSID* UserSid   OPTIONAL
    );

BOOL
SetLocalUserPassword(
    IN PCWSTR AccountName,
    IN PCWSTR OldPassword,
    IN PCWSTR NewPassword
    );

BOOL
IsEncryptedAdminPasswordPresent( VOID );

BOOL
ProcessEncryptedAdminPassword( PCWSTR AdminAccountName );

BOOL
CreatePdcAccount(
    IN PCWSTR MachineName
    );

BOOL
AdjustPrivilege(
    IN PCWSTR   Privilege,
    IN BOOL     Enable
    );

UINT
PlatformSpecificInit(
    VOID
    );

//
// Interface to new style parameter operations
//
BOOL
SpSetupProcessParameters(
    IN OUT HWND *Billboard
    );

extern WCHAR LegacySourcePath[MAX_PATH];

HWND
CreateSetupWindow(
    VOID
    );

//
// Preinstallation stuff
//
extern BOOL Preinstall;
extern BOOL AllowRollback;
extern BOOL OemSkipEula;

BOOL
InitializePreinstall(
    VOID
    );

BOOL
ExecutePreinstallCommands(
    VOID
    );

BOOL
DoInstallComponentInfs(
    IN HWND     hwndParent,
    IN HWND     hProgress,  OPTIONAL
    IN UINT     ProgressMessage,
    IN HINF     InfHandle,
    IN PCWSTR   InfSection
    );

BOOL
ProcessCompatibilityInfs(
    IN HWND     hwndParent,
    IN HWND     hProgress,  OPTIONAL
    IN UINT     ProgressMessage
    );


VOID
DoRunonce (
    );

//
//  Security Stuff
//
BOOL
SetupInstallSecurity(
    IN HWND Window,
    IN HWND ProgressWindow,
    IN ULONG StartAtPercent,
    IN ULONG StopAtPercent
    );


VOID
CallSceGenerateTemplate( VOID );

VOID
CallSceConfigureServices( VOID );

extern HANDLE SceSetupRootSecurityThreadHandle;
extern BOOL bSceSetupRootSecurityComplete;

VOID
CallSceSetupRootSecurity( VOID );

PSID
GetAdminAccountSid(
    );

VOID
GetAdminAccountName(
    PWSTR AccountName
    );

NTSTATUS
DisableLocalAdminAccount(
    VOID
    );

BOOL
SetupRunBaseWinOptions(
    IN HWND Window,
    IN HWND ProgressWindow
    );

//
//  PnP stuff.
//
BOOL
InstallPnpDevices(
    IN HWND  hwndParent,
    IN HINF  InfHandle,
    IN HWND  ProgressWindow,
    IN ULONG StartAtPercent,
    IN ULONG StopAtPercent
    );

VOID
PnpStopServerSideInstall( VOID );

VOID
PnpUpdateHAL(
    VOID
    );

#ifdef _OCM
PVOID
FireUpOcManager(
    VOID
    );

VOID
KillOcManager(
    PVOID OcManagerContext
    );
#endif

//
// Boolean value indicating whether we found any new
// optional component infs.
//
extern BOOL AnyNewOCInfs;

//
// INF caching -- used during optional components processing.
// WARNING: NOT MULTI-THREAD SAFE!
//
HINF
InfCacheOpenInf(
    IN PCWSTR FileName,
    IN PCWSTR InfType       OPTIONAL
    );

HINF
InfCacheOpenLayoutInf(
    IN HINF InfHandle
    );

VOID
InfCacheEmpty(
    IN BOOL CloseInfs
    );

//
//  Pnp stuff
//

BOOL
InstallPnpClassInstallers(
    IN HWND hwndParent,
    IN HINF InfHandle,
    IN HSPFILEQ FileQ
    );

//
// UI Stuff
//
VOID
SetFinishItemAttributes(
    IN HWND     hdlg,
    IN int      BitmapControl,
    IN HANDLE   hBitmap,
    IN int      TextControl,
    IN LONG     Weight
    );


void
pSetupDebugPrint(
    PWSTR FileName,
    ULONG LineNumber,
    PWSTR TagStr,
    PWSTR FormatStr,
    ...
    );

#define SetupDebugPrint(_fmt_)                            pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_)
#define SetupDebugPrint1(_fmt_,_arg1_)                    pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_)
#define SetupDebugPrint2(_fmt_,_arg1_,_arg2_)             pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_,_arg2_)
#define SetupDebugPrint3(_fmt_,_arg1_,_arg2_,_arg3_)      pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_,_arg2_,_arg3_)
#define SetupDebugPrint4(_fmt_,_arg1_,_arg2_,_arg3_,_arg4_) pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_,_arg2_,_arg3_,_arg4_)
#define SetupDebugPrint5(_fmt_,_arg1_,_arg2_,_arg3_,_arg4_,_arg5_) pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_,_arg2_,_arg3_,_arg4_,_arg5_)


VOID
SaveInstallInfoIntoEventLog(
    VOID
    );


#ifdef      _SETUP_PERF_
#define BEGIN_SECTION(_section_) pSetupDebugPrint(TEXT(__FILE__),__LINE__,L"BEGIN_SECTION",_section_)
#define END_SECTION(_section_) pSetupDebugPrint(TEXT(__FILE__),__LINE__,L"END_SECTION",_section_)
#define BEGIN_FUNCTION(_func_) pSetupDebugPrint(TEXT(__FILE__),__LINE__,L"BEGIN_FUNCTION",_func_)
#define END_FUNCTION(_func_) pSetupDebugPrint(TEXT(__FILE__),__LINE__,L"END_FUNCTION",_func_)
#define BEGIN_BLOCK(_block_) pSetupDebugPrint(TEXT(__FILE__),__LINE__,L"BEGIN_BLOCK",_block_)
#define END_BLOCK(_block_) pSetupDebugPrint(TEXT(__FILE__),__LINE__,L"END_BLOCK",_block_)
#else   //  ! _PERF_
#define BEGIN_SECTION(_section_) ((void)0)
#define END_SECTION(_section_) ((void)0)
#endif  //  _PERF_

//
// Service Pack DLL Prototypes
//

#define SVCPACK_DLL_NAME TEXT("svcpack.dll")
#define SVCPACK_CALLBACK_NAME ("SvcPackCallbackRoutine")

#define CALL_SERVICE_PACK(_si_,_p1_,_p2_,_p3_) if (hModSvcPack && pSvcPackCallbackRoutine) pSvcPackCallbackRoutine(_si_,_p1_,_p2_,_p3_)

#define SVCPACK_PHASE_1 1
#define SVCPACK_PHASE_2 2
#define SVCPACK_PHASE_3 3
#define SVCPACK_PHASE_4 4

typedef DWORD
(WINAPI *PSVCPACKCALLBACKROUTINE)(
    DWORD dwSetupPhase,
    DWORD dwParam1,
    DWORD dwParam2,
    DWORD dwParam3
    );

extern HMODULE hModSvcPack;
extern PSVCPACKCALLBACKROUTINE pSvcPackCallbackRoutine;

extern HINSTANCE hinstBB;
void PrepareBillBoard(HWND hwnd);
void TerminateBillBoard();
HWND GetBBhwnd();
void SetBBStep(int iStep);
VOID CenterWindowRelativeToWindow(HWND hwndtocenter, HWND hwndcenteron, BOOL bWizard);
BOOL BB_ShowProgressGaugeWnd(UINT nCmdShow);
LRESULT BB_ProgressGaugeMsg(UINT msg, WPARAM wparam, LPARAM lparam);
LRESULT ProgressGaugeMsgWrapper(UINT msg, WPARAM wparam, LPARAM lparam);
void BB_SetProgressText(LPCTSTR szText);
void BB_SetTimeEstimateText(LPTSTR szText);
void BB_SetInfoText(LPTSTR szText);
BOOL StartStopBB(BOOL bStart);


HWND
ShowHideWizardPage(
    IN BOOL bShow
    );

LRESULT
Billboard_Progress_Callback(
    IN UINT     Msg,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    );
VOID Billboard_Set_Progress_Text(LPCTSTR Text);

typedef struct _SETUPPHASE {
    DWORD   Time;
    BOOL    Win9xUpgradeOnly;
} SETUPPHASE;


void SetTimeEstimates();
DWORD CalcTimeRemaining(UINT Phase);
void SetRemainingTime(DWORD TimeInSeconds);
void UpdateTimeString(DWORD RemainungTimeMsecInThisPhase,
                      DWORD *PreviousRemainingTime);

extern UINT CurrentPhase;
extern ULONG RemainingTime;
extern SETUPPHASE SetupPhase[];

typedef enum {
    Phase_Unknown = -1,
    Phase_Initialize = 0,
    Phase_InstallSecurity,
    Phase_PrecompileInfs,
    Phase_InstallEnumDevices1,
    Phase_InstallLegacyDevices,
    Phase_InstallEnumDevices2,
    Phase_NetInstall,
    Phase_OCInstall,
    Phase_InstallComponentInfs,
    Phase_Inf_Registration,
    Phase_RunOnce_Registration,
    Phase_SecurityTempates,
    Phase_Win9xMigration,
    Phase_SFC,
    Phase_SaveRepair,
    Phase_RemoveTempFiles,
    Phase_Reboot                // no entry for this, just to make sure we don't overrun.
} SetupPhases;



#include "SetupSxs.h"
#include "SxsApi.h"

typedef struct _SIDE_BY_SIDE
{
    HINSTANCE                   Dll;
    PSXS_BEGIN_ASSEMBLY_INSTALL BeginAssemblyInstall;
    PSXS_END_ASSEMBLY_INSTALL   EndAssemblyInstall;
    PSXS_INSTALL_W              InstallW;
    PVOID                       Context;
} SIDE_BY_SIDE;

BOOL
SideBySidePopulateCopyQueue(
    SIDE_BY_SIDE*     Sxs,
    HSPFILEQ          FileQ,                    OPTIONAL
    PCWSTR            AssembliesRootSource      OPTIONAL
    );

BOOL
SideBySideFinish(
    SIDE_BY_SIDE*     Sxs,
    BOOL              fSuccess
    );

BOOL
SideBySideCreateSyssetupContext(
    VOID
    );


VOID
SetUpProcessorNaming(
    VOID
    );

BOOL
SpSetProductTypeFromParameters(
    VOID
    );

//
// imported from setupapi
//
#define SIZECHARS(x)    (sizeof((x))/sizeof(TCHAR))
#define CSTRLEN(x)      ((sizeof((x))/sizeof(TCHAR)) - 1)
#define ARRAYSIZE(x)    (sizeof((x))/sizeof((x)[0]))
#define MyFree          pSetupFree
#define MyMalloc        pSetupMalloc
#define MyRealloc       pSetupRealloc

BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    );

BOOL
DriverNodeSupportsNT(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    );

VOID
ReplaceSlashWithHash(
    IN PWSTR Str
    );

HANDLE
UtilpGetDeviceHandle(
    HDEVINFO DevInfo,
    PSP_DEVINFO_DATA DevInfoData,
    LPGUID ClassGuid,
    DWORD DesiredAccess
    );

typedef enum {
    CDRetail,
    CDOem,
    CDSelect
} CDTYPE;

extern CDTYPE  CdType;
extern DWORD GetProductFlavor();

BOOL IsSafeMode(
    VOID
    );

DWORD
SpUninstallCatalog(
    IN HCATADMIN CatAdminHandle OPTIONAL,
    IN PCWSTR CatFileName,
    IN PCWSTR CatFilePath OPTIONAL,
    IN PCWSTR AttributeName OPTIONAL,
    IN PCWSTR AttributeValue OPTIONAL,
    IN OUT PLIST_ENTRY InstalledCatalogsList OPTIONAL
    );

extern GUID DriverVerifyGuid;

#ifdef PRERELEASE
extern INT g_TestHook;
# define TESTHOOK(n)        if(g_TestHook==(n))RaiseException(EXCEPTION_NONCONTINUABLE_EXCEPTION,EXCEPTION_NONCONTINUABLE,0,NULL)
#else
# define TESTHOOK(n)
#endif

BOOL
RenameOnRestartOfGUIMode(
    IN PCWSTR pPathName,
    IN PCWSTR pPathNameNew
    );

BOOL
DeleteOnRestartOfGUIMode(
    IN PCWSTR pPathName
    );

VOID
RemoveAllPendingOperationsOnRestartOfGUIMode(
    VOID
    );

typedef struct _STRING_LIST_ENTRY
{
    LIST_ENTRY Entry;
    PTSTR String;
}
STRING_LIST_ENTRY, *PSTRING_LIST_ENTRY;

void 
FORCEINLINE
FreeStringEntry(
    PLIST_ENTRY pEntry,
    BOOL DeleteEntry
    )
{
    PSTRING_LIST_ENTRY pStringEntry = CONTAINING_RECORD(pEntry, STRING_LIST_ENTRY, Entry);
    
    if(pStringEntry->String != NULL) {
        MyFree(pStringEntry->String);
        pStringEntry->String = NULL;
    }

    if(DeleteEntry) {
        MyFree(pStringEntry);
    }
}

typedef BOOL (CALLBACK* PFN_BUILD_FILE_LIST_CALLBACK)(IN PCTSTR Directory OPTIONAL, IN PCTSTR FilePath);

void 
FORCEINLINE
FreeStringList(
    PLIST_ENTRY pListHead
    )
{
    PLIST_ENTRY pEntry;
    ASSERT(pListHead != NULL);
    pEntry = pListHead->Flink;

    while(pEntry != pListHead) {
        PLIST_ENTRY Flink = pEntry->Flink;
        FreeStringEntry(pEntry, TRUE);
        pEntry = Flink;
    }

    InitializeListHead(pListHead);
}

DWORD
BuildFileListFromDir(
    IN PCTSTR PathBase,
    IN PCTSTR Directory OPTIONAL,
    IN DWORD MustHaveAttrs OPTIONAL,
    IN DWORD MustNotHaveAttrs OPTIONAL,
    IN PFN_BUILD_FILE_LIST_CALLBACK Callback OPTIONAL,
    OUT PLIST_ENTRY ListHead
    );

PSTRING_LIST_ENTRY
SearchStringInList(
    IN PLIST_ENTRY ListHead,
    IN PCTSTR String,
    BOOL CaseSensitive
    );

DWORD
LookupCatalogAttribute(
    IN PCWSTR CatalogName,
    IN PCWSTR Directory OPTIONAL,
    IN PCWSTR AttributeName OPTIONAL,
    IN PCWSTR AttributeValue OPTIONAL,
    PBOOL Found
    );

BOOL
BuildPath (
    OUT     PTSTR PathBuffer,
    IN      DWORD PathBufferSize,
    IN      PCTSTR Path1,
    IN      PCTSTR Path2
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\storinst.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    clasinst.c

Abstract:

    Routines for the following 'built-in' class installers:

        TapeDrive
        SCSIAdapter
        CdromDrive

Author:

    Lonny McMichael 26-February-1996

--*/


#include "setupp.h"
#pragma hdrstop

//
// include common INF strings headerfile.
//
#include <infstr.h>

//
// instantiate device class GUIDs.
//
#include <initguid.h>
#include <devguid.h>

#include <ntddvol.h>

#include <ntddscsi.h> // for StorageCdromQueryCdda()
#include <ntddcdrm.h> // for StorageCdromQueryCdda()

#define _NTSCSI_USER_MODE_  // prevents all the kernel-mode stuff
#include <scsi.h>     // for StorageCdromQueryCdda()

ULONG BreakWhenGettingModePage2A = FALSE;

#ifdef UNICODE
#define _UNICODE
#endif
#include <tchar.h>

#define TCHAR_NULL TEXT('\0')

//
// Just to make sure no one is trying to use this obsolete string definition.
//
#ifdef IDS_DEVINSTALL_ERROR
    #undef IDS_DEVINSTALL_ERROR
#endif

#if (_X86_)
    #define DISABLE_IMAPI 0
#else
    #define DISABLE_IMAPI 1
#endif


//
// Define the location of the device settings tree.
//
#define STORAGE_DEVICE_SETTINGS_DATABASE TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Storage\\DeviceSettings\\")

#define REDBOOK_SETTINGS_KEY    TEXT("DigitalAudio")
#define REDBOOK_SERVICE_NAME    TEXT("redbook")
#define IMAPI_SETTINGS_KEY      TEXT("Imapi")
#define IMAPI_ENABLE_VALUE      TEXT("EnableImapi")
#define IMAPI_SERVICE_NAME      TEXT("imapi")

typedef struct STORAGE_COINSTALLER_CONTEXT {
    PWSTR DeviceDescBuffer;
    HANDLE DeviceEnumKey;
    union {
        struct {
            BOOLEAN RedbookInstalled;
            BOOLEAN ImapiInstalled;
        } CdRom;
    };
} STORAGE_COINSTALLER_CONTEXT, *PSTORAGE_COINSTALLER_CONTEXT;

typedef struct _PASS_THROUGH_REQUEST {
    SCSI_PASS_THROUGH Srb;
    SENSE_DATA SenseInfoBuffer;
    UCHAR DataBuffer[0];
} PASS_THROUGH_REQUEST, *PPASS_THROUGH_REQUEST;

#define PASS_THROUGH_NOT_READY_RETRY_INTERVAL 100

//
// Some debugging aids for us kernel types
//

#define CHKPRINT 0

#if CHKPRINT
#define ChkPrintEx(_x_) DbgPrint _x_   // use:  ChkPrintEx(( "%x", var, ... ));
#define ChkBreak()    DbgBreakPoint()
#else
#define ChkPrintEx(_x_)
#define ChkBreak()
#endif

DWORD StorageForceRedbookOnInaccurateDrives = FALSE;

BOOLEAN
OverrideFriendlyNameForTape(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    );

DWORD
RegCopyKey(
    HKEY SourceKey,
    HKEY DestinationKey
    );

BOOLEAN
StorageCopyDeviceSettings(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN HKEY             DeviceEnumKey
    );

VOID
StorageInstallCdrom(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN HANDLE           DeviceEnumKey,
    IN BOOLEAN          PreInstall
    );

BOOLEAN
StorageUpdateRedbookSettings(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN HKEY             DeviceEnumKey,
    IN PCDVD_CAPABILITIES_PAGE DeviceCapabilities OPTIONAL
    );

BOOLEAN
StorageUpdateImapiSettings(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN HKEY             DeviceEnumKey,
    IN PCDVD_CAPABILITIES_PAGE DeviceCapabilities OPTIONAL
    );

DWORD
StorageInstallFilter(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR          FilterName,
    IN DWORD            FilterType
    );

DWORD
SetServiceStart(
    IN LPCTSTR ServiceName,
    IN DWORD StartType,
    OUT DWORD *OldStartType
    );

DWORD
AddFilterDriver(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR           ServiceName,
    IN DWORD            FilterType
    );

VOID
StorageInterpretSenseInfo(
    IN     PSENSE_DATA SenseData,
    IN     UCHAR       SenseDataSize,
       OUT PDWORD      ErrorValue,  // from WinError.h
       OUT PBOOLEAN    SuggestRetry OPTIONAL,
       OUT PDWORD      SuggestRetryDelay OPTIONAL
    );


typedef struct _STORAGE_REDBOOK_SETTINGS {

    ULONG CDDASupported;
    ULONG CDDAAccurate;
    ULONG ReadSizesSupported;

} STORAGE_REDBOOK_SETTINGS, *PSTORAGE_REDBOOK_SETTINGS;

#if 0
#define BREAK ASSERT(!"Break")
#else
#define BREAK
#endif

DWORD
TapeClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )

/*++

Routine Description:

    This routine acts as the class installer for TapeDrive devices.  Now that
    we've stopped supporting legacy INFs, it presently does nothing! :-)

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/

{
    switch(InstallFunction) {

        default :
            //
            // Just do the default action.
            //
            return ERROR_DI_DO_DEFAULT;
    }
}

DWORD
ScsiClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )

/*++

Routine Description:

    This routine acts as the class installer for SCSIAdapter devices.  It
    provides special handling for the following DeviceInstaller function codes:

    DIF_ALLOW_INSTALL - Check to see if the selected driver node supports NT

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/

{
    switch(InstallFunction) {

        case DIF_ALLOW_INSTALL :
            //
            // Check to make sure the selected driver node supports NT.
            //
            if (DriverNodeSupportsNT(DeviceInfoSet, DeviceInfoData)) {
               return NO_ERROR;
            } else {
                SetupDebugPrint(L"A SCSI driver is not a Win NTdriver.\n");
               return ERROR_NON_WINDOWS_NT_DRIVER;
            }

        default :
            //
            // Just do the default action.
            //
            return ERROR_DI_DO_DEFAULT;
    }
}


DWORD
HdcClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )

/*++

Routine Description:

    This routine acts as the class installer for hard disk controllers
    (IDE controllers/channels).  It provides special handling for the
    following DeviceInstaller function codes:

    DIF_FIRSTTIMESETUP - Search through all root-enumerated devnodes, looking
                         for ones being controlled by hdc-class drivers.  Add
                         any such devices found into the supplied device
                         information set.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/

{
    switch(InstallFunction) {

        case DIF_FIRSTTIMESETUP :
            //
            // BUGBUG (lonnym): handle this!
            //

        default :
            //
            // Just do the default action.
            //
            return ERROR_DI_DO_DEFAULT;
    }
}

BOOLEAN
StorageGetCDVDCapabilities(
    IN  HDEVINFO         DeviceInfo,
    IN  PSP_DEVINFO_DATA DeviceInfoData OPTIONAL,
    IN OUT PCDVD_CAPABILITIES_PAGE CapabilitiesPage
    )
{
    PPASS_THROUGH_REQUEST passThrough;
    PCDVD_CAPABILITIES_PAGE modePage;
    DWORD allocLength;
    DWORD dataLength;
    ULONG attempt;
    BOOLEAN status = FALSE;

    HANDLE deviceHandle;

    deviceHandle = INVALID_HANDLE_VALUE;
    passThrough = NULL;
    modePage = NULL;

    ASSERT(CapabilitiesPage != NULL);

    if (BreakWhenGettingModePage2A) {
        ChkPrintEx(("CDGetCap => entering\n"));
        DbgBreakPoint();
    }


    //
    // open a handle to the device, needed to send the ioctls
    //

    deviceHandle = UtilpGetDeviceHandle(DeviceInfo,
                                        DeviceInfoData,
                                        (LPGUID)&CdRomClassGuid,
                                        GENERIC_READ | GENERIC_WRITE
                                        );

    if (deviceHandle == INVALID_HANDLE_VALUE) {
        ChkPrintEx(("CDGetCap => cannot get device handle\n"));
        goto cleanup;
    }

    //
    // determine size of allocation needed
    //

    dataLength =
        sizeof(MODE_PARAMETER_HEADER10) +    // larger of 6/10 byte
        sizeof(CDVD_CAPABILITIES_PAGE)  +    // the actual mode page
        8;                                   // extra spooge for drives that ignore DBD
    allocLength = sizeof(PASS_THROUGH_REQUEST) + dataLength;

    //
    // allocate this buffer for the ioctls
    //

    passThrough = (PPASS_THROUGH_REQUEST)MyMalloc(allocLength);

    if (passThrough == NULL) {
        ChkPrintEx(("CDGetCap => could not allocate for passThrough\n"));
        goto cleanup;
    }

    ASSERT(dataLength <= 0xff);  // one char

    //
    // send 6-byte, then 10-byte if 6-byte failed.
    // then, just parse the information
    //

    for (attempt = 1; attempt <= 2; attempt++) {

        ULONG j;
        BOOLEAN retry = TRUE;
        DWORD error;
        
        for (j=0; (j < 5) && (retry); j++) {
        
            PSCSI_PASS_THROUGH srb = &passThrough->Srb;
            PCDB cdb = (PCDB)(&srb->Cdb[0]);
            DWORD bytes;
            BOOL b;

            retry = FALSE;

            ZeroMemory(passThrough, allocLength);

            srb->TimeOutValue = 20;
            srb->Length = sizeof(SCSI_PASS_THROUGH);
            srb->SenseInfoLength = sizeof(SENSE_DATA);
            srb->SenseInfoOffset =
                FIELD_OFFSET(PASS_THROUGH_REQUEST, SenseInfoBuffer);
            srb->DataBufferOffset =
                FIELD_OFFSET(PASS_THROUGH_REQUEST, DataBuffer);
            srb->DataIn = SCSI_IOCTL_DATA_IN;
            srb->DataTransferLength = dataLength;

            if ((attempt % 2) == 1) { // settings based on 6-byte request

                srb->CdbLength = 6;
                cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
                cdb->MODE_SENSE.PageCode = MODE_PAGE_CAPABILITIES;
                cdb->MODE_SENSE.AllocationLength = (UCHAR)dataLength;
                cdb->MODE_SENSE.Dbd = 1;

            } else {                  // settings based on 10 bytes request

                srb->CdbLength = 10;
                cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
                cdb->MODE_SENSE10.PageCode = MODE_PAGE_CAPABILITIES;
                cdb->MODE_SENSE10.AllocationLength[0] = 0;
                cdb->MODE_SENSE10.AllocationLength[1] = (UCHAR)(dataLength & 0xff);
                cdb->MODE_SENSE10.Dbd = 1;

            }

            //
            // buffers are all set, send the ioctl
            //

            b = DeviceIoControl(deviceHandle,
                                IOCTL_SCSI_PASS_THROUGH,
                                passThrough,
                                allocLength,
                                passThrough,
                                allocLength,
                                &bytes,
                                NULL);

            if (!b) {

                ChkPrintEx(("CDGetCap => %s byte command failed to be sent to device\n",
                            ((attempt%2) ? "6" : "10")
                            ));
                retry = FALSE;
                continue; // try the next 'j' loop.

            }

            //
            // now see if we should retry
            //

            StorageInterpretSenseInfo(&passThrough->SenseInfoBuffer,
                                      SENSE_BUFFER_SIZE,
                                      &error,
                                      &retry,
                                      NULL);

            if (error != ERROR_SUCCESS) {
                
                ChkPrintEx(("CDGetCap => %s byte command failed (%x/%x/%x),"
                            "%s retrying\n",
                            ((attempt%2) ? "6" : "10"),
                            passThrough->SenseInfoBuffer.SenseKey,
                            passThrough->SenseInfoBuffer.AdditionalSenseCode,
                            passThrough->SenseInfoBuffer.AdditionalSenseCodeQualifier,
                            (retry ? "" : "not")
                            ));                
                
                //
                // retry will be set to either true or false to
                // have this loop (j) re-run or not....
                //

                continue;
               
            }

            //
            // else it worked!
            //
            ASSERT(retry == FALSE);
            retry = FALSE;
            ASSERT(status == FALSE);
            status = TRUE;
        }

        //
        // if unable to retrieve the page, just start the next loop.
        //

        if (!status) {
            continue; // try the next 'attempt' loop.
        }

        //
        // find the mode page data
        //
        // NOTE: if the drive fails to ignore the DBD bit,
        // we still need to install?  HCT will catch this,
        // but legacy drives need it.
        //

        (ULONG_PTR)modePage = (ULONG_PTR)passThrough->DataBuffer;
        
        if (attempt == 1) {

            PMODE_PARAMETER_HEADER h;
            h = (PMODE_PARAMETER_HEADER)passThrough->DataBuffer;

            //
            // add the size of the header
            //

            (ULONG_PTR)modePage += sizeof(MODE_PARAMETER_HEADER);
            dataLength -= sizeof(MODE_PARAMETER_HEADER);

            //
            // add the size of the block descriptor, which should
            // always be zero, but isn't on some poorly behaved drives
            //

            if (h->BlockDescriptorLength) {
                
                ASSERT(h->BlockDescriptorLength == 8);

                ChkPrintEx(("CDGetCap => %s byte command ignored DBD bit (%x)\n",
                            ((attempt%2) ? "6" : "10"),
                            h->BlockDescriptorLength
                            ));
                (ULONG_PTR)modePage += h->BlockDescriptorLength;
                dataLength -= h->BlockDescriptorLength;
            }

        } else {

            PMODE_PARAMETER_HEADER10 h;
            h = (PMODE_PARAMETER_HEADER10)passThrough->DataBuffer;

            //
            // add the size of the header
            //

            (ULONG_PTR)modePage += sizeof(MODE_PARAMETER_HEADER10);
            dataLength -= sizeof(MODE_PARAMETER_HEADER10);

            //
            // add the size of the block descriptor, which should
            // always be zero, but isn't on some poorly behaved drives
            //

            if ((h->BlockDescriptorLength[0] != 0) ||
                (h->BlockDescriptorLength[1] != 0)
                ) {
                
                ULONG_PTR bdLength = 0;
                bdLength += ((h->BlockDescriptorLength[0]) << 8);
                bdLength += ((h->BlockDescriptorLength[1]) & 0xff);

                ASSERT(bdLength == 8);
                
                ChkPrintEx(("CDGetCap => %s byte command ignored DBD bit (%x)\n",
                            ((attempt%2) ? "6" : "10"),
                            bdLength
                            ));

                (ULONG_PTR)modePage += bdLength;
                dataLength -= (DWORD)bdLength;

            }
        }

        //
        // now have the pointer to the mode page data and length of usable data
        // copy it back to requestor's buffer
        //

        ChkPrintEx(("CDGetCap => %s byte command succeeded\n",
                    (attempt%2) ? "6" : "10"));

        RtlZeroMemory(CapabilitiesPage, sizeof(CDVD_CAPABILITIES_PAGE));
        RtlCopyMemory(CapabilitiesPage, 
                      modePage,
                      min(dataLength, sizeof(CDVD_CAPABILITIES_PAGE))
                      );

        if (BreakWhenGettingModePage2A) {
            ChkPrintEx(("CDGetCap => Capabilities @ %#p\n", CapabilitiesPage));
            DbgBreakPoint();
        }

        goto cleanup; // no need to send another command


    }


    ChkPrintEx(("CDGetCap => Unable to get drive capabilities via modepage\n"));

cleanup:

    if (passThrough) {
        MyFree(passThrough);
    }
    if (deviceHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(deviceHandle);
    }

    return status;
}

BOOLEAN
ScReadRegDword(
    IN HANDLE Key,
    IN LPTSTR ValueName,
    OUT PDWORD Value
    )
{
    DWORD type;
    DWORD size = sizeof(DWORD);
    DWORD value;
    DWORD result;

    result = RegQueryValueEx(Key,
                             ValueName,
                             NULL,
                             &type,
                             (LPBYTE) &value,
                             &size);

    if(result == ERROR_SUCCESS) {
        *Value = value;
        return TRUE;
    }
    return FALSE;
}

VOID
StorageReadRedbookSettings(
    IN HANDLE Key,
    OUT STORAGE_REDBOOK_SETTINGS *Settings
    )
{
    STORAGE_REDBOOK_SETTINGS settings;

    //
    // since this key exists, query for the values
    //

    DWORD dataType;
    DWORD dataSize;
    DWORD value;
    LONG  results;

    settings.CDDASupported = FALSE;
    settings.CDDAAccurate = FALSE;
    settings.ReadSizesSupported = 0;
    
    if(ScReadRegDword(Key, TEXT("CDDASupported"), &value)) {
        settings.CDDASupported = value ? 1 : 0;
    }

    if(ScReadRegDword(Key, TEXT("CDDAAccurate"), &value)) {
        settings.CDDAAccurate = value ? 1 : 0;
    }

    if(ScReadRegDword(Key, TEXT("ReadSizesSupported"), &value)) {
        settings.ReadSizesSupported = value;
    }

    //
    // one of the three worked
    //

    ChkPrintEx(("StorageReadSettings: Query Succeeded:\n"));
    ChkPrintEx(("StorageReadSettings:     ReadSizeMask  (pre): %x\n",
                settings.ReadSizesSupported));
    ChkPrintEx(("StorageReadSettings:     CDDAAccurate  (pre): %x\n",
                settings.CDDAAccurate));
    ChkPrintEx(("StorageReadSettings:     CDDASupported (pre): %x\n",
                settings.CDDASupported));

    //
    // interpret the redbook device settings.
    //

    if (settings.ReadSizesSupported) {

        ChkPrintEx(("StorageSeed: Drive supported only some sizes "
                    " (%#08x)\n", settings.ReadSizesSupported));

        settings.CDDASupported = TRUE;
        settings.CDDAAccurate = FALSE;

    } else if (settings.CDDAAccurate) {

        ChkPrintEx(("StorageSeed: Drive is fully accurate\n"));

        settings.CDDASupported = TRUE;
        settings.ReadSizesSupported = -1;

    } else if (settings.CDDASupported) {

        ChkPrintEx(("StorageSeed: Drive lies about being accurate\n"));

        settings.CDDAAccurate = FALSE;
        settings.ReadSizesSupported = -1;

    } // values are now interpreted

    *Settings = settings;

    return;
} // end of successful open of key

DWORD
StorageCoInstaller(
    IN     DI_FUNCTION               InstallFunction,
    IN     HDEVINFO                  DeviceInfoSet,
    IN     PSP_DEVINFO_DATA          DeviceInfoData,  OPTIONAL
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    )
/*++

Routine Description:

    This routine acts as a co-installer for storage devices.  It is presently
    registered (via hivesys.inf) for CDROM, DiskDrive, and TapeDrive classes.

    The purpose of this co-installer is to save away the bus-supplied default
    DeviceDesc into the device's FriendlyName property.  The reason for this
    is that the bus can retrieve a very specific description from the device
    (e.g., via SCSI inquiry data), yet the driver node we install will often
    be something very generic (e.g., "Disk drive").
    We want to keep the descriptive name, so that it can be displayed in the
    UI (DevMgr, etc.) to allow the user to distinguish between multiple storage
    devices of the same class.

    A secondary purpose for this co-installer is to seed the ability to play
    digital audio for a given device.  The reason for this is that many cdroms
    that support digital audio do not report this ability, there are some that
    claim this ability but cannot actually do it reliably, and some that only
    work when reading N sectors at a time.  This information is seeded in the
    registry, and copied to the enum key.  If this information does not exist,
    no keys are created, and defaults are used.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

    Context - Supplies the installation context that is per-install
        request/per-coinstaller.

Return Value:

    If this function successfully completed the requested action (or did
        nothing) and wishes for the installation to continue, the return
        value is NO_ERROR.

    If this function successfully completed the requested action (or did
        nothing) and would like to be called back once installation has
        completed, the return value is ERROR_DI_POSTPROCESSING_REQUIRED.

    If an error occurred while attempting to perform the requested action,
        a Win32 error code is returned.  Installation will be aborted.

--*/

{
    PSTORAGE_COINSTALLER_CONTEXT InstallContext;

    PWSTR DeviceDescBuffer = NULL;
    DWORD DeviceDescBufferLen, Err;
    ULONG ulStatus, ulProblem;

    switch(InstallFunction) {

        case DIF_INSTALLDEVICE : {

            if(Context->PostProcessing) {
                //
                // We're 'on the way out' of an installation.  The context
                // PrivateData had better contain the string we stored on
                // the way in.
                //

                InstallContext = Context->PrivateData;
                MYASSERT(InstallContext);

                //
                // We only want to store the FriendlyName property if the
                // installation succeeded. We only want to seed redbook values
                // if the install succeeded.
                //
                
                if(Context->InstallResult == NO_ERROR) {
                    
                    BOOLEAN OverrideFriendlyName = FALSE;

                    if (IsEqualGUID(&(DeviceInfoData->ClassGuid),
                                     &GUID_DEVCLASS_TAPEDRIVE)) {
                       //
                       // This function checks if we need to use
                       // the device description, given in INF file,
                       // in UI such as Device Manager. Returns TRUE
                       // if INF description is to used. FALSE, otherwise.
                       //
                       OverrideFriendlyName = OverrideFriendlyNameForTape(
                                                      DeviceInfoSet,
                                                      DeviceInfoData);

                    } else if (IsEqualGUID(&(DeviceInfoData->ClassGuid),
                                           &GUID_DEVCLASS_CDROM)) {

                        //
                        // See if we need to install any of the filter drivers 
                        // to enable additional CD-ROM (CD-R, DVD-RAM, etc...) 
                        // features.
                        //
    
    
                        StorageInstallCdrom(DeviceInfoSet, 
                                            DeviceInfoData,
                                            InstallContext,
                                            FALSE);
                    }

                    if ((OverrideFriendlyName == FALSE) && 
                        (InstallContext->DeviceDescBuffer != NULL))  {
                       //
                       // If we need not use the INF device description
                       // write the name, generated from SCSI Inquiry data,
                       // onto FriendlyName
                       //
                       SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                                        DeviceInfoData,
                                                        SPDRP_FRIENDLYNAME,
                                                        (PBYTE) InstallContext->DeviceDescBuffer,
                                                        (lstrlen(InstallContext->DeviceDescBuffer) + 1) * sizeof(WCHAR));
                    }
                }

                //
                // Now free our installation context.
                //
                if ((InstallContext->DeviceEnumKey) != INVALID_HANDLE_VALUE) {
                    RegCloseKey(InstallContext->DeviceEnumKey);
                }

                if(InstallContext->DeviceDescBuffer) {
                    MyFree(InstallContext->DeviceDescBuffer);
                }

                MyFree(InstallContext);

                //
                // Propagate the result of the previous installer.
                //
                return Context->InstallResult;

            } else {

                //
                // We're 'on the way in' for device installation.
                // Make sure that whoever called SetupDiCallClassInstaller
                // passed in a device information element.  (Don't fail the
                // call if they didn't--that's the job of the class
                // installer/SetupDiInstallDevice.)
                //
                if(!DeviceInfoData) {
                    return NO_ERROR;
                }

                //
                // Make sure this isn't a root-enumerated device.  The root
                // enumerator clearly has nothing interesting to say about
                // the device's description beyond what the INF says.
                //
                if((CM_Get_DevNode_Status(&ulStatus, &ulProblem, DeviceInfoData->DevInst, 0) != CR_SUCCESS) ||
                   (ulStatus & DN_ROOT_ENUMERATED)) {

                    return NO_ERROR;
                }

                //
                // Allocate our context.
                //

                InstallContext = MyMalloc(sizeof(STORAGE_COINSTALLER_CONTEXT));

                if(InstallContext == NULL) {
                    return NO_ERROR;
                }

                memset(InstallContext, 0, sizeof(STORAGE_COINSTALLER_CONTEXT));
                InstallContext->DeviceEnumKey = INVALID_HANDLE_VALUE;

                //
                // open the device's instance under the enum key
                //
            
                InstallContext->DeviceEnumKey = SetupDiCreateDevRegKey(
                                                    DeviceInfoSet,
                                                    DeviceInfoData,
                                                    DICS_FLAG_GLOBAL,
                                                    0,
                                                    DIREG_DEV,
                                                    NULL,
                                                    NULL);
            
                if (InstallContext->DeviceEnumKey == INVALID_HANDLE_VALUE) {
                    ChkPrintEx(("StorageInstallCdrom: Failed to open device "
                                "registry key\n"));
                }
            
                //
                // Search the device settings database to see if there are 
                // any settings provided for this particular device.
                //
                if (InstallContext->DeviceEnumKey != INVALID_HANDLE_VALUE) {
                    StorageCopyDeviceSettings(DeviceInfoSet, 
                                              DeviceInfoData, 
                                              InstallContext->DeviceEnumKey);
                }

                //
                // See if we need to install any of the filter drivers to enable
                // additional CD-ROM (CD-R, DVD-RAM, etc...) features.
                //

                if (IsEqualGUID(&(DeviceInfoData->ClassGuid),
                                &GUID_DEVCLASS_CDROM)) {

                    StorageInstallCdrom(DeviceInfoSet, 
                                        DeviceInfoData,
                                        InstallContext,
                                        TRUE);
                }

                //
                // See if there is currently a 'FriendlyName' property.
                //

                if(SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                    DeviceInfoData,
                                                    SPDRP_FRIENDLYNAME,
                                                    NULL,
                                                    NULL,
                                                    0,
                                                    NULL) ||
                   (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
                    //
                    // Either we succeeded (which should never happen), or we
                    // failed with a return value of buffer-too-small,
                    // indicating that the property already exists.  In this
                    // case, there's nothing for us to do.
                    //
                    goto CoPreInstallDone;
                }

                //
                // Attempt to retrieve the DeviceDesc property.
                // start out with a buffer size that should always be big enough
                //

                DeviceDescBufferLen = LINE_LEN * sizeof(WCHAR);

                while(TRUE) {

                    if(!(DeviceDescBuffer = MyMalloc(DeviceDescBufferLen))) {

                        //
                        // We failed, but what we're doing is not at all 
                        // critical.  Thus, we'll go ahead and let the
                        // installation proceed.  If we're out of memory, it's
                        // going to fail for a much more important reason
                        // later anyway.
                        //

                        goto CoPreInstallDone;
                    }

                    if(SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                        DeviceInfoData,
                                                        SPDRP_DEVICEDESC,
                                                        NULL,
                                                        (PBYTE)DeviceDescBuffer,
                                                        DeviceDescBufferLen,
                                                        &DeviceDescBufferLen)) {
                        break;
                    }

                    Err = GetLastError();

                    //
                    // Free our current buffer before examining the
                    // cause of failure.
                    //

                    MyFree(DeviceDescBuffer);
                    DeviceDescBuffer = NULL;

                    if(Err != ERROR_INSUFFICIENT_BUFFER) {
                        //
                        // The failure was for some other reason than
                        // buffer-too-small.  This means we're not going to
                        // be able to get the DeviceDesc (most likely because
                        // the bus driver didn't supply us one.  There's
                        // nothing more we can do.
                        //
                        goto CoPreInstallDone;
                    }
                }

CoPreInstallDone:

                //
                // Save the device description buffer away.
                //

                InstallContext->DeviceDescBuffer = DeviceDescBuffer;

                //
                // Store the installer context in the context structure and 
                // request a post-processing callback.
                //

                Context->PrivateData = InstallContext;

                return ERROR_DI_POSTPROCESSING_REQUIRED;
            }
        }

        default :
            //
            // We should always be 'on the way in', since we never request
            // postprocessing except for DIF_INSTALLDEVICE.
            //
            MYASSERT(!Context->PostProcessing);
            return NO_ERROR;
    }
}

DWORD
VolumeClassInstaller(
    IN  DI_FUNCTION         InstallFunction,
    IN  HDEVINFO            DeviceInfoSet,
    IN  PSP_DEVINFO_DATA    DeviceInfoData OPTIONAL
    )

/*++

Routine Description:

    This routine is the class installer function for storage volumes.

Arguments:

    InstallFunction - Supplies the install function.

    DeviceInfoSet   - Supplies the device info set.

    DeviceInfoData  - Supplies the device info data.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/

{
    return ERROR_DI_DO_DEFAULT;
}

BOOLEAN
OverrideFriendlyNameForTape(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )

/*++

Routine Description:

    This routine checks the device description, given in the INF, for
    the tape being installed. If the device description is a generic
    name (Tape drive), then we use the name generated from Inquiry
    data in UI such as Device Manager. If the INF provides a specific
    name, then we use that instead.

Arguments:

    DeviceInfoSet   - Supplies the device info set.

    DeviceInfoData  - Supplies the device info data.

Return Value:

    TRUE  : If the device description given in the INF should be
            used as FriendlyName
    FALSE : If the name generated from Inquiry data should be
            used as FriendlyName instead of the name given in INF
*/
{

   SP_DRVINFO_DETAIL_DATA  drvDetData;
   SP_DRVINFO_DATA         drvData;
   DWORD                   dwSize;
   TCHAR                   szSection[LINE_LEN];
   HINF                    hInf;
   INFCONTEXT              infContext;
   BOOLEAN                 OverrideFriendlyName = FALSE;
   TCHAR                   szSectionName[LINE_LEN];

   ZeroMemory(&drvData, sizeof(SP_DRVINFO_DATA));
   drvData.cbSize = sizeof(SP_DRVINFO_DATA);
   if (!SetupDiGetSelectedDriver(DeviceInfoSet, DeviceInfoData, &drvData)) {
       return FALSE;
   }

   ZeroMemory(&drvDetData, sizeof(SP_DRVINFO_DETAIL_DATA));
   drvDetData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
   if (!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                   DeviceInfoData,
                                   &drvData,
                                   &drvDetData,
                                   drvDetData.cbSize,
                                   &dwSize) &&
       GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
       return FALSE;
   }

   hInf = SetupOpenInfFile(drvDetData.InfFileName,
                           NULL,
                           INF_STYLE_WIN4,
                           NULL);
   if (hInf == INVALID_HANDLE_VALUE) {
       return FALSE;
   }

   //
   // Get the actual device install section name
   //
   ZeroMemory(szSectionName, sizeof(szSectionName));
   SetupDiGetActualSectionToInstall(hInf,
                                    drvDetData.SectionName,
                                    szSectionName,
                                    sizeof(szSectionName) / sizeof(TCHAR),
                                    NULL,
                                    NULL
                                    );

   if (SetupFindFirstLine(hInf, szSectionName,
                          TEXT("UseInfDeviceDesc"),
                          &infContext)) {
      DWORD UseDeviceDesc = 0;
      if ((SetupGetIntField(&infContext, 1, (PINT)&UseDeviceDesc)) &&
          (UseDeviceDesc)) {

         //
         // Delete friendly name if it exists.
         // Device Description will be used here on.
         //
         SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                          DeviceInfoData,
                                          SPDRP_FRIENDLYNAME,
                                          NULL,
                                          0);

         OverrideFriendlyName = TRUE;
      }
   }

   if (OverrideFriendlyName) {
      ChkPrintEx(("Will override friendly name\n"));
   } else {
      ChkPrintEx(("Will NOT override friendly name\n"));
   }

   SetupCloseInfFile(hInf);

   return OverrideFriendlyName;
}

BOOLEAN
CopyKey(
    HKEY SourceKey,
    HKEY DestinationKey
    )
{
    DWORD index = 0;

    DWORD numberOfKeys;
    DWORD numberOfValues;

    DWORD keyNameLength;
    DWORD valueNameLength;
    DWORD valueLength;

    DWORD nameLength;

    PTCHAR name = NULL;
    PVOID data = NULL;

    LONG status = ERROR_SUCCESS;

    //
    // Determine the largest name and data length of the values in this key.
    //

    status = RegQueryInfoKey(SourceKey,
                             NULL,
                             NULL,
                             NULL,
                             &numberOfKeys,
                             &keyNameLength,
                             NULL,
                             &numberOfValues,
                             &valueNameLength,
                             &valueLength,
                             NULL,
                             NULL);

    if(status != ERROR_SUCCESS) {
        ChkPrintEx(("Error %d getting info for key %#0x\n", status, SourceKey));
        return FALSE;
    }

    //
    // Determine the longer of the two name lengths, then account for the 
    // short lengths returned by the registry code (it leaves out the 
    // terminating NUL).  
    //

    nameLength = max(valueNameLength, keyNameLength);
    nameLength += 1;

    //
    // Allocate name and data buffers
    //

    name = MyMalloc(nameLength * sizeof(TCHAR));
    if(name == NULL) {
        return FALSE;
    }

    //
    // there may not be any data to buffer.
    //

    if(valueLength != 0) {
        data = MyMalloc(valueLength);
        if(data == NULL) {
            MyFree(name);
            return FALSE;
        }
    }

    //
    // Enumerate each value in the SourceKey and copy it to the DestinationKey.
    //

    for(index = 0;
        (index < numberOfValues) && (status != ERROR_NO_MORE_ITEMS);
        index++) {

        DWORD valueDataLength;

        DWORD type;

        valueNameLength = nameLength;
        valueDataLength = valueLength;

        //
        // Read the value into the pre-allocated buffers.
        //

        status = RegEnumValue(SourceKey,
                              index,
                              name,
                              &valueNameLength,
                              NULL,
                              &type,
                              data,
                              &valueDataLength);

        if(status != ERROR_SUCCESS) {
            ChkPrintEx(("Error %d reading value %x\n", status, index));
            continue;
        }

        //
        // Now set this value in the destination key.
        // If this fails there's not much we can do but continue on to the 
        // next value.
        //

        status = RegSetValueEx(DestinationKey,
                               name,
                               0,
                               type,
                               data,
                               valueDataLength);
    }

    //
    // Free the data buffer.
    //

    MyFree(data);
    data = NULL;

    status = ERROR_SUCCESS;

    //
    // Now enumerate each key in the SourceKey, create the same key in the 
    // desination key, open a handle to each one and recurse.
    //

    for(index = 0;
        (index < numberOfKeys) && (status != ERROR_NO_MORE_ITEMS);
        index++) {

        FILETIME lastWriteTime;

        HKEY newSourceKey;
        HKEY newDestinationKey;

        keyNameLength = nameLength;

        status = RegEnumKeyEx(SourceKey,
                              index,
                              name,
                              &keyNameLength,
                              NULL,
                              NULL,
                              NULL,
                              &lastWriteTime);

        if(status != ERROR_SUCCESS) {
            ChkPrintEx(("Error %d enumerating source key %x\n", status, index));
            continue;
        }

        //
        // Open the source subkey.
        //

        status = RegOpenKeyEx(SourceKey,
                              name,
                              0L,
                              KEY_READ,
                              &newSourceKey);

        if(status != ERROR_SUCCESS) {
            ChkPrintEx(("Error %d opening source key %x\n", status, index));
            continue;
        }

        //
        // Create the destination subkey.
        //

        status = RegCreateKeyEx(DestinationKey,
                                name,
                                0L,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_WRITE,
                                NULL,
                                &newDestinationKey,
                                NULL);

        if(status != ERROR_SUCCESS) {
            ChkPrintEx(("Error %d creating dest key %x\n", status, index));
            RegCloseKey(newSourceKey);
            continue;
        }

        //
        // Recursively copy this key.
        //

        CopyKey(newSourceKey, newDestinationKey);

        RegCloseKey(newSourceKey);
        RegCloseKey(newDestinationKey);
    }

    //
    // Now free the name buffer.
    //

    MyFree(name);


    return TRUE;
}

BOOLEAN
StorageCopyDeviceSettings(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN HKEY             DeviceEnumKey
    )
{
    PTCHAR hardwareIdList = NULL;
    PTCHAR hardwareId = NULL;

    DWORD requiredSize = 0;

    HKEY settingsDatabaseKey = INVALID_HANDLE_VALUE;

    BOOLEAN settingsCopied = FALSE;
    DWORD status;

    ASSERT(DeviceInfo != NULL);
    ASSERT(DeviceInfoData != NULL);

    //
    // Open the device settings key.
    //

    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          STORAGE_DEVICE_SETTINGS_DATABASE,
                          0L,
                          KEY_READ,
                          &settingsDatabaseKey);

    if(status != ERROR_SUCCESS) {
        ChkPrintEx(("StorageCopyDeviceSettings: Error %d opening "
                    "settings database\n",
                    status));
        return FALSE;
    }

    //
    // get the hardware id's
    //

    if(SetupDiGetDeviceRegistryProperty(DeviceInfo,
                                        DeviceInfoData,
                                        SPDRP_HARDWAREID,
                                        NULL,
                                        NULL,
                                        0,
                                        &requiredSize) ||
       (requiredSize == 0)) {

        //
        // That's odd.
        //

        ChkPrintEx(("StorageCopyDeviceSettings: no hardware ids available?\n"));
        goto cleanup;
    }

    //
    // requiredSize is bytes, not characters
    //

    hardwareIdList = MyMalloc(requiredSize);
    if (hardwareIdList == NULL) {
        ChkPrintEx(("StorageCopyDeviceSettings: Couldn't allocate %d bytes "
                    "for HWIDs\n", requiredSize));
        goto cleanup;
    }

    if(!SetupDiGetDeviceRegistryProperty(DeviceInfo,
                                         DeviceInfoData,
                                         SPDRP_HARDWAREID,
                                         NULL,
                                         (PBYTE)hardwareIdList,
                                         requiredSize,
                                         NULL)) {
        ChkPrintEx(("StorageCopyDeviceSettings: failed to get "
                    "device's hardware ids %x\n",
                    GetLastError()));
        goto cleanup;
    }

    //
    // Look in the device settings database for a matching hardware ID.  When 
    // we find a match copy the contents of that key under the device's 
    // devnode key.
    //
    // The hardware IDs we get back from SetupDi are sorted from most exact
    // to least exact so we're guaranteed to find the closest match first.
    //

    hardwareId = hardwareIdList;

    while(hardwareId[0] != TCHAR_NULL) {

        HKEY deviceSettingsKey;

        LONG openStatus;

        //
        // Replace slashes with #'s so that it's compatible as a registry 
        // key name.
        //

        ReplaceSlashWithHash(hardwareId);

        openStatus = RegOpenKeyEx(settingsDatabaseKey,
                                  hardwareId,
                                  0,
                                  KEY_READ,
                                  &deviceSettingsKey);

        if (openStatus == ERROR_SUCCESS) {

            //StorageReadSettings(specialTargetHandle, &settings);
            CopyKey(deviceSettingsKey, DeviceEnumKey);

            settingsCopied = TRUE;

            RegCloseKey(deviceSettingsKey);
            break;
        }

        // get to next null, for statement will advance past it
        while (*hardwareId) {
            hardwareId += 1;
        }

        //
        // Skip the nul and go to the next tchar.
        //

        hardwareId += 1;

        RegCloseKey(deviceSettingsKey);

    } // end of loop for query'ing each id

cleanup:

    ChkPrintEx(("StorageCopyDeviceSettings: Cleaning up...\n"));

    if (settingsDatabaseKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(settingsDatabaseKey);
    }

    if (hardwareIdList != NULL) {
        MyFree(hardwareIdList);
    }

    return settingsCopied;
}

VOID
StorageInstallCdrom(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN PSTORAGE_COINSTALLER_CONTEXT InstallContext,
    IN BOOLEAN          PreInstall
    )
{
    CDVD_CAPABILITIES_PAGE buffer;
    PCDVD_CAPABILITIES_PAGE page = NULL;

    BOOLEAN installRedbook = FALSE;
    BOOLEAN installImapi = FALSE;
    BOOLEAN needRestart = FALSE;

    //
    // If this is post-installation then get the device capabilities page and 
    // provide it to the update routines.
    //

    if(PreInstall == FALSE) {

        if(StorageGetCDVDCapabilities(DeviceInfo, DeviceInfoData, &buffer)) {
            page = &buffer;
        }
    }

    //
    // Check in the registry (or query the device) and determine if we should 
    // enable the redbook (digital audio playback) driver on this device.
    //
    // If redbook was already installed the first time through then there's no 
    // need to do this step
    //

    if((PreInstall == TRUE) || 
       ((InstallContext->CdRom.RedbookInstalled == FALSE) && (page != NULL))) {

        if ((InstallContext->DeviceEnumKey) != INVALID_HANDLE_VALUE) {
            installRedbook = StorageUpdateRedbookSettings(
                                DeviceInfo, 
                                DeviceInfoData, 
                                InstallContext->DeviceEnumKey,
                                page);
        }
    }

    //
    // Check in the registry (or query the device) and determine if we should
    // enable the IMAPI driver on this device.
    //
    // If imapi was already installed the first time through then there's no 
    // need to do this step
    //

    if((PreInstall == TRUE) || 
       ((InstallContext->CdRom.ImapiInstalled == FALSE) && (page != NULL))) {

        if ((InstallContext->DeviceEnumKey) != INVALID_HANDLE_VALUE) {
            installImapi = StorageUpdateImapiSettings(DeviceInfo, 
                                                      DeviceInfoData, 
                                                      InstallContext->DeviceEnumKey,
                                                      page);
        }
    }

    //
    // If this is a pre-install pass then we can just add the services.  If it's 
    // not then first check to see that we don't do anything here that we 
    // already did in the pre-install pass.
    //

    if(PreInstall) {

        //
        // Save away what we've done during the pre-install pass.
        //

        InstallContext->CdRom.RedbookInstalled = installRedbook;
        InstallContext->CdRom.ImapiInstalled = installImapi;
    }

    //
    // If we're supposed to enable IMAPI then do so by enabling the IMAPI 
    // service and including it in the list of lower filters for this device.
    //

    if(installRedbook) {
        ChkPrintEx(("StorageInstallCdrom: Installing Upperfilter: REDBOOK\n"));
        StorageInstallFilter(DeviceInfo, 
                             DeviceInfoData, 
                             REDBOOK_SERVICE_NAME,
                             SPDRP_UPPERFILTERS);
        needRestart = TRUE;
    }

    if(installImapi) {
        ChkPrintEx(("StorageInstallCdrom: Installing Lowerfilter: IMAPI\n"));
        StorageInstallFilter(DeviceInfo,
                             DeviceInfoData,
                             IMAPI_SERVICE_NAME,
                             SPDRP_LOWERFILTERS);
        needRestart = TRUE;
    }

    if((PreInstall == FALSE) && (needRestart == TRUE)) {

        SP_PROPCHANGE_PARAMS propChange;
        
        //
        // The device is all set but we to indicate that a property change 
        // has occurred.  Set the propchange_pending flag which should cause
        // a DIF_PROPERTYCHANGE command to get sent through, which we'll use 
        // to restart the device.
        //

        ChkPrintEx(("StorageInstallCdrom: Calling class installer with DIF_PROPERTYCHANGE\n"));

        propChange.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
        propChange.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
        propChange.StateChange = DICS_PROPCHANGE;
        propChange.Scope = DICS_FLAG_GLOBAL;
        propChange.HwProfile = 0;

        SetupDiSetClassInstallParams(DeviceInfo,
                                     DeviceInfoData,
                                     &propChange.ClassInstallHeader,
                                     sizeof(SP_PROPCHANGE_PARAMS));

        SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,
                                  DeviceInfo,
                                  DeviceInfoData);
    }

    return;
}


BOOLEAN
StorageUpdateRedbookSettings(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN HKEY             DeviceEnumKey,
    IN PCDVD_CAPABILITIES_PAGE CapabilitiesPage OPTIONAL
    )
{
    STORAGE_REDBOOK_SETTINGS settings;

    HKEY redbookKey;

    DWORD setFromDevice = FALSE;

    DWORD disposition;
    DWORD status;

    settings.CDDASupported = FALSE;
    settings.CDDAAccurate = FALSE;
    settings.ReadSizesSupported = 0;

    //
    // Open the digital audio subkey of the device's enum key.  If the device 
    // hasn't been started yet then we won't create the key.  Otherwise we 
    // will create it and populate it.
    //

    if(ARGUMENT_PRESENT(CapabilitiesPage)) {

        status = RegCreateKeyEx(DeviceEnumKey, 
                                REDBOOK_SETTINGS_KEY, 
                                0L, 
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ | KEY_WRITE, 
                                NULL,
                                &redbookKey,
                                &disposition
                                );
    } else {

        status = RegOpenKeyEx(DeviceEnumKey,
                              REDBOOK_SETTINGS_KEY,
                              0L,
                              KEY_READ | KEY_WRITE,
                              &redbookKey);

        disposition = REG_OPENED_EXISTING_KEY;
    }

    if(status != ERROR_SUCCESS) {
        ChkPrintEx(("StorageUpdateRedbookSettings: couldn't open redbook key "
                    "- %d\n", status));
        return FALSE;
    }

    if(disposition == REG_OPENED_EXISTING_KEY) {

        //
        // Read the redbook settings out of the registry (if there are any) and 
        // see if they make any sense.
        //

        StorageReadRedbookSettings(redbookKey, &settings);

    } else {

        //
        // Since the DigitalAudio key didn't exist nothing could be set.  Check
        // with the device to see what it supports.
        //

        MYASSERT(CapabilitiesPage != NULL);

        settings.CDDASupported = CapabilitiesPage->CDDA;
        settings.CDDAAccurate = CapabilitiesPage->CDDAAccurate;

        //
        // If the device isn't accurate then we can't be quite sure what the valid
        // read sizes are (unless they were listed in the registry, but in that case
        // we'd never have been here).  Use zero, which is a special value for 
        // ReadSizesSupported which means "i don't know".
        //

        if((settings.CDDASupported == TRUE) &&
           (settings.CDDAAccurate == TRUE)) {
            settings.ReadSizesSupported = -1;
        }

        setFromDevice = TRUE;
    }

    //
    // Write the updated (or derived) settings to the registry.
    //

    if (settings.CDDAAccurate) {
        ChkPrintEx(("StorageUpdateRedbookSettings: "
                    "Cdrom fully supports CDDA.\n"));
    } else if (settings.ReadSizesSupported) {
        ChkPrintEx(("StorageUpdateRedbookSettings: "
                    "Cdrom only supports some sizes CDDA read.\n"));
        ChkPrintEx(("StorageUpdateRedbookSettings: "
                    "These are in the bitmask: %x.\n",
                    settings.ReadSizesSupported));
    } else if (settings.CDDASupported) {
        ChkPrintEx(("StorageUpdateRedbookSettings: "
                    "Cdrom only supports some sizes CDDA read.\n"));
        ChkPrintEx(("StorageUpdateRedbookSettings: "
                    "There is no data on which sizes (if any) "
                    "are accurate\n"));
    } else {
        ChkPrintEx(("StorageUpdateRedbookSettings: "
                    "Cdrom does not support CDDA at all.\n"));
    }

    RegSetValueEx(redbookKey,
                  L"ReadSizesSupported",
                  0,
                  REG_DWORD,
                  (BYTE*)&settings.ReadSizesSupported,
                  sizeof(DWORD)
                  );

    RegSetValueEx(redbookKey,
                  L"CDDASupported",
                  0,
                  REG_DWORD,
                  (BYTE*)&settings.CDDASupported,
                  sizeof(DWORD)
                  );

    RegSetValueEx(redbookKey,
                  L"CDDAAccurate",
                  0,
                  REG_DWORD,
                  (BYTE*)&settings.CDDAAccurate,
                  sizeof(DWORD)
                  );

    RegSetValueEx(redbookKey,
                  L"SettingsFromDevice",
                  0,
                  REG_DWORD,
                  (LPBYTE) &(setFromDevice),
                  sizeof(DWORD)
                  );

    RegCloseKey(redbookKey);

    //
    // if CDDA is supported, and one of:
    //      CDDA is accurate
    //      We have a mask of accurate settings
    //      We want to force install of redbook
    // is true, then return TRUE.
    // else, return FALSE.
    //

    if((settings.CDDASupported) && 
       ((settings.CDDAAccurate) ||
        (settings.ReadSizesSupported != 0) ||
        (StorageForceRedbookOnInaccurateDrives))) {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOLEAN
StorageUpdateImapiSettings(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN HKEY             DeviceEnumKey,
    IN PCDVD_CAPABILITIES_PAGE CapabilitiesPage OPTIONAL
    )
{
    HKEY imapiKey;

    DWORD disposition;
    DWORD status;

    //
    // must be a DWORD so we can read into it from the registry.
    //

    DWORD enableImapi = FALSE;

    //
    // Open the imapi subkey of the device's enum key.  If the device has been
    // started then we'll create the key if it didn't already exist.
    //

    if(ARGUMENT_PRESENT(CapabilitiesPage)) {
        status = RegCreateKeyEx(DeviceEnumKey, 
                                IMAPI_SETTINGS_KEY, 
                                0L, 
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ | KEY_WRITE, 
                                NULL,
                                &imapiKey,
                                &disposition
                                );
    } else {
        status = RegOpenKeyEx(DeviceEnumKey, 
                              IMAPI_SETTINGS_KEY, 
                              0L, 
                              KEY_READ | KEY_WRITE, 
                              &imapiKey
                              );

        disposition = REG_OPENED_EXISTING_KEY;
    }

    if(status != ERROR_SUCCESS) {
        ChkPrintEx(("StorageUpdateImapiSettings: couldn't open imapi key "
                    "- %d\n", status));
        return FALSE;
    }

    if(disposition == REG_OPENED_EXISTING_KEY) {

        DWORD type = REG_DWORD;
        DWORD dataSize = sizeof(DWORD);

        //
        // Check to see if the EnableImapi value is set in this key.  If it is
        // then we'll be wanting to enable the filter driver.
        //

        status = RegQueryValueEx(imapiKey,
                                 IMAPI_ENABLE_VALUE,
                                 NULL,
                                 &type,
                                 (LPBYTE) &enableImapi,
                                 &dataSize);

        if (status == ERROR_SUCCESS) {
            if(type != REG_DWORD) {
                ChkPrintEx(("StorageUpdateImapiSettings: EnableImapi value is of "
                            "type %d\n", type));
                enableImapi = FALSE;
            }
            
            RegCloseKey(imapiKey);
            
            return (BOOLEAN) enableImapi ? TRUE : FALSE;
        
        }

        //
        // else the key wasn't accessible.  fall through to query the drive
        //
    
    }

    if(ARGUMENT_PRESENT(CapabilitiesPage)) {

        //
        // query the drive to see if it supports mastering...
        //
    
        if((CapabilitiesPage->CDRWrite) || (CapabilitiesPage->CDEWrite)) {
            enableImapi = TRUE;
        }
    }

    if (enableImapi && DISABLE_IMAPI) {
        ChkPrintEx(("StorageUpdateImapiSettings: Imapi would have "
                    "been enabled"));
        enableImapi = FALSE;
    }


    if (enableImapi) {

        //
        // must add registry key listed above that suggests that
        // imapi must be enabled by default.
        //

        status = RegSetValueEx(imapiKey,
                               IMAPI_ENABLE_VALUE,
                               0,
                               REG_DWORD,
                               (BYTE*)&enableImapi,
                               sizeof(DWORD)
                               );
        
        //
        // if this failed, then the device driver won't attach itself
        // to the stack.  in this case, we don't want to enable IMAPI
        // after all...
        //

        if (status != ERROR_SUCCESS) {
            enableImapi = FALSE;
        }
    }

    RegCloseKey(imapiKey);


    return (BOOLEAN) enableImapi ? TRUE : FALSE;
}


DWORD
StorageInstallFilter(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR           FilterName,
    IN DWORD            FilterType
    )
{
    DWORD status;

    DWORD oldStartType;

    //
    // Check with the service controller and make sure that the IMAPI service
    // is set to start at system time.
    //

    status = SetServiceStart(FilterName, SERVICE_SYSTEM_START, &oldStartType);

    if(status != ERROR_SUCCESS) {
        return status;
    }

    //
    // Add the IMAPI filter to the list of lower device filters.
    //

    status = AddFilterDriver(DeviceInfo, 
                             DeviceInfoData, 
                             FilterName,
                             FilterType
                             );

    if(status != ERROR_SUCCESS) {

        //
        // if it failed, and the service was previously disabled,
        // re-disable the service.
        //

        if(oldStartType == SERVICE_DISABLED) {
            SetServiceStart(FilterName, SERVICE_DISABLED, &oldStartType);
        }

    }

    return status;
}


DWORD
SetServiceStart(
    IN LPCTSTR ServiceName,
    IN DWORD StartType,
    OUT DWORD *OldStartType
    )
{
    SC_HANDLE serviceManager;
    SC_HANDLE service;

    DWORD status;

    serviceManager = OpenSCManager(NULL, NULL, GENERIC_READ | GENERIC_WRITE);

    if(serviceManager == NULL) {
        return GetLastError();
    }

    service = OpenService(serviceManager, 
                          ServiceName, 
                          SERVICE_CHANGE_CONFIG | SERVICE_QUERY_CONFIG);

    if(service == NULL) {
        status = GetLastError();
        CloseServiceHandle(serviceManager);
        return status;
    }
    
    {
        QUERY_SERVICE_CONFIG configBuffer;
        LPQUERY_SERVICE_CONFIG config = &(configBuffer);
        DWORD configSize;

        BOOLEAN wasStarted;

        //
        // Retrieve the configuration so we can get the current service 
        // start value.  We unfortuantely need to allocate memory for the 
        // entire service configuration - the fine QueryServiceConfig API 
        // doesn't give back partial data.
        //

        memset(config, 0, sizeof(QUERY_SERVICE_CONFIG));
        configSize = sizeof(QUERY_SERVICE_CONFIG);

        //
        // Determine the number of bytes needed for the configuration.
        //

        QueryServiceConfig(service, config, 0, &configSize);
        status = GetLastError();

        if(status != ERROR_INSUFFICIENT_BUFFER) {
            CloseServiceHandle(service);
            CloseServiceHandle(serviceManager);
            return status;
        }

        //
        // Allocate the appropriately sized config buffer.
        //

        config = MyMalloc(configSize);
        if(config == NULL) {
            CloseServiceHandle(service);
            CloseServiceHandle(serviceManager);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if(!QueryServiceConfig(service, config, configSize, &configSize)) {
            status = GetLastError();

            CloseServiceHandle(service);
            CloseServiceHandle(serviceManager);
            MyFree(config);
            return status;
        }

        //
        // Record what the old start type was so that the caller can disable
        // the service again if filter-installation fails.
        //

        *OldStartType = config->dwStartType;

        //
        // If the start type doesn't need to be changed then bail out now.
        //

        if(config->dwStartType == StartType) {
            CloseServiceHandle(service);
            CloseServiceHandle(serviceManager);
            MyFree(config);
            return ERROR_SUCCESS;
        }

        //
        // Now write the configuration back to the service.
        //

        if(ChangeServiceConfig(service,
                               SERVICE_NO_CHANGE,
                               StartType,
                               SERVICE_NO_CHANGE,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL) == FALSE) {
            status = GetLastError();
        } else {
            status = ERROR_SUCCESS;
        }

        CloseServiceHandle(service);
        CloseServiceHandle(serviceManager);
        MyFree(config);
    }

    return status;
}


DWORD
AddFilterDriver(
    IN HDEVINFO         DeviceInfo,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR           ServiceName,
    IN DWORD            FilterType
    )
{

    DWORD serviceNameLength = (_tcslen(ServiceName) + 2) * sizeof(TCHAR);

    LPTSTR filterList = NULL;
    DWORD filterListSize = 0;

    DWORD type;

    DWORD status;

    ASSERT((FilterType == SPDRP_LOWERFILTERS) || 
           (FilterType == SPDRP_UPPERFILTERS));

    //
    // Query to find out the property size.  If it comes back zero then 
    // we'll just try to write the property in there.
    //

    SetupDiGetDeviceRegistryProperty(DeviceInfo,
                                     DeviceInfoData,
                                     FilterType,
                                     &type,
                                     NULL,
                                     0L,
                                     &filterListSize);

    status = GetLastError();

    if((status != ERROR_INVALID_DATA) && 
       (status != ERROR_INSUFFICIENT_BUFFER)) {

        //
        // If this succeeded with no buffer provided then there's something
        // very odd going on.
        //

        ChkPrintEx(("Unable to get filter list: %x\n", status));
        ASSERT(status != ERROR_SUCCESS);

        return status;
    }

    //
    // This error code appears to be returned if the property isn't set in the 
    // devnode.  In that event make sure propertySize is cleared.
    //

    if(status == ERROR_INVALID_DATA) {

        filterListSize = 0;

    } else if(type != REG_MULTI_SZ) {

        return ERROR_INVALID_DATA;
    }

    //
    // If the property size is zero then there's nothing to query.  Likewise, 
    // if it's equal to the size of two nul characters.
    //

    if(filterListSize >= (sizeof(TCHAR_NULL) * 2)) {

        DWORD tmp;
        LPTSTR listEnd;

        //
        // increase the filter list buffer size so that it can hold our
        // addition.  Make sure to take into account the extra nul character
        // already in the existing list.
        //

        filterListSize += serviceNameLength - sizeof(TCHAR);

        filterList = MyMalloc(filterListSize);

        if(filterList == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        memset(filterList, 0, filterListSize);

        //
        // Query the registry information again.
        //

        if(!SetupDiGetDeviceRegistryProperty(DeviceInfo,
                                             DeviceInfoData,
                                             FilterType,
                                             &type,
                                             (PBYTE) filterList,
                                             filterListSize,
                                             &tmp)) {
            status = GetLastError();
            MyFree(filterList);
            return status;
        }

        if(type != REG_MULTI_SZ) {
            MyFree(filterList);
            return ERROR_INVALID_DATA;
        }

        //
        // Compute the end of the filter list and copy the imapi filters 
        // there.
        //

        listEnd = filterList;
        listEnd += tmp / sizeof(TCHAR);
        listEnd -= 1;

        memset(listEnd, 0, serviceNameLength);
        memcpy(listEnd, ServiceName, serviceNameLength - sizeof(TCHAR_NULL));

    } else {
        filterList = MyMalloc(serviceNameLength);
        
        if(filterList == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        memset(filterList, 0, serviceNameLength);
        memcpy(filterList, ServiceName, serviceNameLength - sizeof(TCHAR_NULL));

        filterListSize = serviceNameLength;
    }

    if(!SetupDiSetDeviceRegistryProperty(DeviceInfo,
                                         DeviceInfoData,
                                         FilterType,
                                         (PBYTE) filterList,
                                         filterListSize)) {
        status = GetLastError();
    } else {
        status = ERROR_SUCCESS;
    }

    MyFree(filterList);

    return status;
}




/*++

Routine Description:

    NOTE: we default to RETRY==TRUE except for known error classes
    This is based upon classpnp's InterpretSenseInfo().

Arguments:

Return Value:


--*/
VOID
StorageInterpretSenseInfo(
    IN     PSENSE_DATA SenseData,
    IN     UCHAR       SenseDataSize,
       OUT PDWORD      ErrorValue,  // from WinError.h
       OUT PBOOLEAN    SuggestRetry OPTIONAL,
       OUT PDWORD      SuggestRetryDelay OPTIONAL // in 1/10 second intervals
    )
{
    DWORD   error;
    DWORD   retryDelay;
    BOOLEAN retry;
    UCHAR   senseKey;
    UCHAR   asc;
    UCHAR   ascq;

    if (SenseDataSize == 0) {
        retry = FALSE;
        retryDelay = 0;
        error = ERROR_IO_DEVICE;
        goto SetAndExit;

    }

    //
    // default to suggesting a retry in 1/10 of a second,
    // with a status of ERROR_IO_DEVICE.
    //
    retry = TRUE;
    retryDelay = 1;
    error = ERROR_IO_DEVICE;

    //
    // if we can't even see the sense key, just return.
    // can't use bitfields in these macros, so use next field
    // instead of RTL_SIZEOF_THROUGH_FIELD
    //

    if (SenseDataSize < FIELD_OFFSET(SENSE_DATA, Information)) {
        goto SetAndExit;
    }
    
    senseKey = SenseData->SenseKey;

    //
    // if the device succeeded the request, return success.
    //
    
    if (senseKey == 0) {
        retry = FALSE;
        retryDelay = 0;
        error = ERROR_SUCCESS;
        goto SetAndExit;
    }


    { // set the size to what's actually useful.
        UCHAR validLength;
        // figure out what we could have gotten with a large sense buffer
        if (SenseDataSize <
            RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA, AdditionalSenseLength)) {
            validLength = SenseDataSize;
        } else {
            validLength =
                RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA, AdditionalSenseLength);
            validLength += SenseData->AdditionalSenseLength;
        }
        // use the smaller of the two values.
        SenseDataSize = min(SenseDataSize, validLength);
    }

    if (SenseDataSize <
        RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA, AdditionalSenseCode)) {
        asc = SCSI_ADSENSE_NO_SENSE;
    } else {
        asc = SenseData->AdditionalSenseCode;
    }

    if (SenseDataSize <
        RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA, AdditionalSenseCodeQualifier)) {
        ascq = SCSI_SENSEQ_CAUSE_NOT_REPORTABLE; // 0x00
    } else {
        ascq = SenseData->AdditionalSenseCodeQualifier;
    }

    //
    // interpret :P
    //

    switch (senseKey & 0xf) {
    
    case SCSI_SENSE_RECOVERED_ERROR: {  // 0x01
        if (SenseData->IncorrectLength) {
            error = ERROR_INVALID_BLOCK_LENGTH;
        } else {
            error = ERROR_SUCCESS;
        }
        retry = FALSE;
        break;
    } // end SCSI_SENSE_RECOVERED_ERROR

    case SCSI_SENSE_NOT_READY: { // 0x02
        error = ERROR_NOT_READY;

        switch (asc) {

        case SCSI_ADSENSE_LUN_NOT_READY: {
            
            switch (ascq) {

            case SCSI_SENSEQ_BECOMING_READY:
            case SCSI_SENSEQ_OPERATION_IN_PROGRESS: {
                retryDelay = PASS_THROUGH_NOT_READY_RETRY_INTERVAL;
                break;
            }

            case SCSI_SENSEQ_CAUSE_NOT_REPORTABLE:
            case SCSI_SENSEQ_FORMAT_IN_PROGRESS:
            case SCSI_SENSEQ_LONG_WRITE_IN_PROGRESS: {
                retry = FALSE;
                break;
            }

            case SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED: {
                retry = FALSE;
                break;
            }
            
            } // end switch (senseBuffer->AdditionalSenseCodeQualifier)
            break;
        }

        case SCSI_ADSENSE_NO_MEDIA_IN_DEVICE: {
            error = ERROR_NOT_READY;
            retry = FALSE;
            break;
        }
        } // end switch (senseBuffer->AdditionalSenseCode)

        break;
    } // end SCSI_SENSE_NOT_READY
    
    case SCSI_SENSE_MEDIUM_ERROR: { // 0x03
        error = ERROR_CRC;
        retry = FALSE;

        //
        // Check if this error is due to unknown format
        //
        if (asc == SCSI_ADSENSE_INVALID_MEDIA) {
            
            switch (ascq) {

            case SCSI_SENSEQ_UNKNOWN_FORMAT: {
                error = ERROR_UNRECOGNIZED_MEDIA;
                break;
            }

            case SCSI_SENSEQ_CLEANING_CARTRIDGE_INSTALLED: {
                error = ERROR_UNRECOGNIZED_MEDIA;
                //error = ERROR_CLEANER_CARTRIDGE_INSTALLED;
                break;
            }
            
            } // end switch AdditionalSenseCodeQualifier

        } // end SCSI_ADSENSE_INVALID_MEDIA
        break;
    } // end SCSI_SENSE_MEDIUM_ERROR

    case SCSI_SENSE_ILLEGAL_REQUEST: { // 0x05
        error = ERROR_INVALID_FUNCTION;
        retry = FALSE;
        
        switch (asc) {

        case SCSI_ADSENSE_ILLEGAL_BLOCK: {
            error = ERROR_SECTOR_NOT_FOUND;
            break;
        }

        case SCSI_ADSENSE_INVALID_LUN: {
            error = ERROR_FILE_NOT_FOUND;
            break;
        }

        case SCSI_ADSENSE_COPY_PROTECTION_FAILURE: {
            error = ERROR_FILE_ENCRYPTED;
            //error = ERROR_SPT_LIB_COPY_PROTECTION_FAILURE;
            switch (ascq) {
                case SCSI_SENSEQ_AUTHENTICATION_FAILURE:
                    //error = ERROR_SPT_LIB_AUTHENTICATION_FAILURE;
                    break;
                case SCSI_SENSEQ_KEY_NOT_PRESENT:
                    //error = ERROR_SPT_LIB_KEY_NOT_PRESENT;
                    break;
                case SCSI_SENSEQ_KEY_NOT_ESTABLISHED:
                    //error = ERROR_SPT_LIB_KEY_NOT_ESTABLISHED;
                    break;
                case SCSI_SENSEQ_READ_OF_SCRAMBLED_SECTOR_WITHOUT_AUTHENTICATION:
                    //error = ERROR_SPT_LIB_SCRAMBLED_SECTOR;
                    break;
                case SCSI_SENSEQ_MEDIA_CODE_MISMATCHED_TO_LOGICAL_UNIT:
                    //error = ERROR_SPT_LIB_REGION_MISMATCH;
                    break;
                case SCSI_SENSEQ_LOGICAL_UNIT_RESET_COUNT_ERROR:
                    //error = ERROR_SPT_LIB_RESETS_EXHAUSTED;
                    break;
            } // end switch of ASCQ for COPY_PROTECTION_FAILURE
            break;
        }

        } // end switch (senseBuffer->AdditionalSenseCode)
        break;
        
    } // end SCSI_SENSE_ILLEGAL_REQUEST

    case SCSI_SENSE_DATA_PROTECT: { // 0x07
        error = ERROR_WRITE_PROTECT;
        retry = FALSE;
        break;
    } // end SCSI_SENSE_DATA_PROTECT

    case SCSI_SENSE_BLANK_CHECK: { // 0x08
        error = ERROR_NO_DATA_DETECTED;
        break;
    } // end SCSI_SENSE_BLANK_CHECK

    case SCSI_SENSE_NO_SENSE: { // 0x00
        if (SenseData->IncorrectLength) {    
            error = ERROR_INVALID_BLOCK_LENGTH;
            retry   = FALSE;    
        } else {
            error = ERROR_IO_DEVICE;
        }
        break;
    } // end SCSI_SENSE_NO_SENSE

    case SCSI_SENSE_HARDWARE_ERROR:  // 0x04
    case SCSI_SENSE_UNIT_ATTENTION: // 0x06
    case SCSI_SENSE_UNIQUE:          // 0x09
    case SCSI_SENSE_COPY_ABORTED:    // 0x0A
    case SCSI_SENSE_ABORTED_COMMAND: // 0x0B
    case SCSI_SENSE_EQUAL:           // 0x0C
    case SCSI_SENSE_VOL_OVERFLOW:    // 0x0D
    case SCSI_SENSE_MISCOMPARE:      // 0x0E
    case SCSI_SENSE_RESERVED:        // 0x0F
    default: {
        error = ERROR_IO_DEVICE;
        break;
    }

    } // end switch(SenseKey)

SetAndExit:

    if (ARGUMENT_PRESENT(SuggestRetry)) {
        *SuggestRetry = retry;
    }
    if (ARGUMENT_PRESENT(SuggestRetryDelay)) {
        *SuggestRetryDelay = retryDelay;
    }
    *ErrorValue = error;

    return;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\strtmenu.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    strtmenu.c

Abstract:

    Routines to manipulate menu groups and items.

    Entry points:


Author:

    Ted Miller (tedm) 5-Apr-1995
    Jaime Sasson (jaimes) 9-Aug-1995

Revision History:

    Based on various other code that has been rewritten/modified
    many times by many people.

--*/

#include "setupp.h"
#pragma hdrstop

#if 0
#define DDEDBG
#ifdef DDEDBG
#define DBGOUT(x) DbgOut x
VOID
DbgOut(
    IN PCSTR FormatString,
    ...
    )
{
    CHAR Str[256];

    va_list arglist;

    wsprintfA(Str,"SETUP (%u): ",GetTickCount());
    OutputDebugStringA(Str);

    va_start(arglist,FormatString);
    wvsprintfA(Str,FormatString,arglist);
    va_end(arglist);
    OutputDebugStringA(Str);
    OutputDebugStringA("\n");
}
#else
#define DBGOUT(x)
#endif
#endif

BOOL
RemoveMenuGroup(
    IN PCWSTR Group,
    IN BOOL   CommonGroup
    )
{
    return( DeleteGroup( Group, CommonGroup ) );
}



BOOL
RemoveMenuItem(
    IN PCWSTR Group,
    IN PCWSTR Item,
    IN BOOL   CommonGroup
    )
{
    return( DeleteItem( Group, CommonGroup, Item, TRUE ) );
}

VOID
DeleteMenuGroupsAndItems(
    IN HINF   InfHandle
    )
{
    INFCONTEXT InfContext;
    UINT LineCount,LineNo;
    PCWSTR  SectionName = L"StartMenu.ObjectsToDelete";
    PCWSTR  ObjectType;
    PCWSTR  ObjectName;
    PCWSTR  ObjectPath;
    PCWSTR  GroupAttribute;
    BOOL    CommonGroup;
    BOOL    IsMenuItem;

    //
    // Get the number of lines in the section that contains the objects to
    // be deleted. The section may be empty or non-existant; this is not an
    // error condition.
    //
    LineCount = (UINT)SetupGetLineCount(InfHandle,SectionName);
    if((LONG)LineCount <= 0) {
        return;
    }
    for(LineNo=0; LineNo<LineCount; LineNo++) {

        if(SetupGetLineByIndex(InfHandle,SectionName,LineNo,&InfContext)
        && (ObjectType = pSetupGetField(&InfContext,1))
        && (ObjectName = pSetupGetField(&InfContext,2))
        && (GroupAttribute = pSetupGetField(&InfContext,4))) {
            IsMenuItem = _wtoi(ObjectType);
            CommonGroup = _wtoi(GroupAttribute);
            ObjectPath = pSetupGetField(&InfContext,3);

            if( IsMenuItem ) {
                RemoveMenuItem( ObjectPath, ObjectName, CommonGroup );
            } else {
                ULONG   Size;
                PWSTR   Path;

                Size = lstrlen(ObjectName) + 1;
                if(ObjectPath != NULL) {
                    Size += lstrlen(ObjectPath) + 1;
                }
                Path = MyMalloc(Size * sizeof(WCHAR));
                if(!Path) {
                    SetuplogError(
                        LogSevError,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_MENU_REMGRP_FAIL,
                        ObjectPath,
                        ObjectName, NULL,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_OUTOFMEMORY,
                        NULL,NULL);
                } else {
                    if( ObjectPath != NULL ) {
                        lstrcpy( Path, ObjectPath );
                        pSetupConcatenatePaths( Path, ObjectName, Size, NULL );
                    } else {
                        lstrcpy( Path, ObjectName );
                    }
                    RemoveMenuGroup( Path, CommonGroup );
                    MyFree(Path);
                }
            }
        }
    }
}

BOOL
AddItemsToGroup(
    IN HINF   InfHandle,
    IN PCWSTR GroupDescription,
    IN PCWSTR SectionName,
    IN BOOL   CommonGroup
    )
{
    INFCONTEXT InfContext;
    UINT LineCount,LineNo;
    PCWSTR Description;
    PCWSTR Binary;
    PCWSTR CommandLine;
    PCWSTR IconFile;
    PCWSTR IconNumberStr;
    INT IconNumber;
    PCWSTR InfoTip;
    BOOL b;
    BOOL DoItem;
    WCHAR Dummy;
    PWSTR FilePart;
    PCTSTR DisplayResourceFile = NULL;
    DWORD DisplayResource = 0;

    //
    // Get the number of lines in the section. The section may be empty
    // or non-existant; this is not an error condition.
    //
    LineCount = (UINT)SetupGetLineCount(InfHandle,SectionName);
    if((LONG)LineCount <= 0) {
        return(TRUE);
    }

    b = TRUE;
    for(LineNo=0; LineNo<LineCount; LineNo++) {

        if(SetupGetLineByIndex(InfHandle,SectionName,LineNo,&InfContext)) {

            Description = pSetupGetField(&InfContext,0);
            Binary = pSetupGetField(&InfContext,1);
            CommandLine = pSetupGetField(&InfContext,2);
            IconFile = pSetupGetField(&InfContext,3);
            IconNumberStr = pSetupGetField(&InfContext,4);
            InfoTip = pSetupGetField(&InfContext,5);
            DisplayResourceFile = pSetupGetField( &InfContext, 6);
            DisplayResource = 0;
            SetupGetIntField( &InfContext, 7, &DisplayResource );

            if(Description && CommandLine ) {
                if(!IconFile) {
                    IconFile = L"";
                }
                IconNumber = (IconNumberStr && *IconNumberStr) ? wcstoul(IconNumberStr,NULL,10) : 0;

                //
                // If there's a binary name, search for it. Otherwise do the
                // item add unconditionally.
                //
                DoItem = (Binary && *Binary)
                       ? (SearchPath(NULL,Binary,NULL,0,&Dummy,&FilePart) != 0)
                       : TRUE;

                if(DoItem) {

                    b &= CreateLinkFileEx( CommonGroup ? CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS,
                                         GroupDescription,
                                         Description,
                                         CommandLine,
                                         IconFile,
                                         IconNumber,
                                         NULL,
                                         0,
                                         SW_SHOWNORMAL,
                                         InfoTip,
                                         (DisplayResourceFile && DisplayResourceFile[0]) ? DisplayResourceFile : NULL,
                                         (DisplayResourceFile && DisplayResourceFile[0]) ? DisplayResource : 0);

                }
            }
        }
    }
    return(b);
}


BOOL
DoMenuGroupsAndItems(
    IN HINF InfHandle,
    IN BOOL Upgrade
    )
{
    INFCONTEXT InfContext;
    PCWSTR GroupId,GroupDescription;
    PCWSTR GroupAttribute;
    BOOL CommonGroup;
    BOOL b;
    WCHAR  Path[MAX_PATH+1];
    PCTSTR DisplayResourceFile = NULL;
    DWORD DisplayResource = 0;

    if( Upgrade ) {
        //
        //  In the upgrade case, first delet some groups and items.
        //
        DeleteMenuGroupsAndItems( InfHandle );
    }

    //
    // Iterate the [StartMenuGroups] section in the inf.
    // Each line is the name of a group that needs to be created.
    //
    if(SetupFindFirstLine(InfHandle,L"StartMenuGroups",NULL,&InfContext)) {
        b = TRUE;
    } else {
        return(FALSE);
    }

    do {
        //
        // Fetch the identifier for the group and its name.
        //
        if((GroupId = pSetupGetField(&InfContext,0))
        && (GroupDescription = pSetupGetField(&InfContext,1))
        && (GroupAttribute = pSetupGetField(&InfContext,2))) {

            CommonGroup = ( GroupAttribute && _wtoi(GroupAttribute) );

            DisplayResourceFile = pSetupGetField( &InfContext, 3);
            DisplayResource = 0;
            SetupGetIntField( &InfContext, 4, &DisplayResource );
            //
            // Create the group.
            //
            b &= CreateGroupEx( GroupDescription, CommonGroup,
                              (DisplayResourceFile && DisplayResourceFile[0]) ? DisplayResourceFile : NULL,
                              (DisplayResourceFile && DisplayResourceFile[0]) ? DisplayResource : 0);

            //
            // Now create items within the group. We do this by iterating
            // through the section in the inf that relate to the current group.
            //
            b &= AddItemsToGroup(InfHandle,GroupDescription,GroupId,CommonGroup);
        }
    } while(SetupFindNextLine(&InfContext,&InfContext));

    //
    //  Create the items (if any) for 'Start Menu'
    //
    b &= AddItemsToGroup(InfHandle,NULL,L"StartMenuItems",FALSE);

    return(TRUE);
}


BOOL
CreateStartMenuItems(
    IN HINF InfHandle
    )
{
    return(DoMenuGroupsAndItems(InfHandle,FALSE));
}

BOOL
UpgradeStartMenuItems(
    IN HINF InfHandle
    )
{
    return(DoMenuGroupsAndItems(InfHandle,TRUE));
}

BOOL
RepairStartMenuItems(
    )
{
    HINF InfHandle;
    BOOL b;

    //
    // This function is not called through Gui mode setup.
    // but is called by winlogon to repair stuff.
    //

    InitializeProfiles(FALSE);
    InfHandle = SetupOpenInfFile(L"syssetup.inf",NULL,INF_STYLE_WIN4,NULL);
    if( InfHandle == INVALID_HANDLE_VALUE ) {
        b = FALSE;
    } else {
        b = DoMenuGroupsAndItems(InfHandle,FALSE);
        SetupCloseInfFile(InfHandle);
    }
    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\syssetup.c ===
#include "setupp.h"
#include <passrec.h>
#include <wow64reg.h>
#pragma hdrstop

//
// These three functions are imported from setupasr.c, the module containing
// the source for the Automatic System Recovery (ASR) functions.
//

//  Returns TRUE if ASR is enabled.  Otherwise, FALSE is returned.
extern BOOL
AsrIsEnabled(VOID);

// Initializes ASR data.  This is called iff the -asr switch is detected.
extern VOID
AsrInitialize(VOID);

// Launches recovery applications specified in the asr state file.
extern VOID
AsrExecuteRecoveryApps(VOID);

// Checks the system to see if we are running on the personal version of the
// operating system.
extern BOOL
AsrpIsRunningOnPersonalSKU(VOID);

//
// Handle for watching changes to the user's profile directory and the current user hive.
//
PVOID   WatchHandle;

//
// Handle to heap so we can periodically validate it.
//
#if DBG
HANDLE g_hSysSetupHeap = NULL;
#endif

//
// Product type: workstation, standalone server, dc server.
//
UINT ProductType;

//
// Set to TRUE if this is an ASR quick test
//
BOOL AsrQuickTest = FALSE;

//
// service pack dll module handle
//
HMODULE hModSvcPack;
PSVCPACKCALLBACKROUTINE pSvcPackCallbackRoutine;

//
// Boolean value indicating whether this installation
// originated with winnt/winnt32.
// And, original source path, saved away for us by winnt/winnt32.
//
BOOL WinntBased;
PCWSTR OriginalSourcePath;

//
// Boolean value indicating whether we're upgrading.
//
BOOL Upgrade;
BOOL Win31Upgrade;
BOOL Win95Upgrade;
BOOL UninstallEnabled;

//
// Boolean value indicating whether we're in Setup or in appwiz.
//
BOOL IsSetup = FALSE;

//
// Boolean value indicating whether we're doing a subset of gui-mode setup.
//
BOOL MiniSetup = FALSE;

//
// Boolean value indicating whether we're doing a subset of gui-mode setup
// AND we did PnP re-enumeration.
//
BOOL PnPReEnumeration = FALSE;

//
// Boolean value indicating whether we're doing a remote boot setup.
//
BOOL RemoteBootSetup = FALSE;

//
// During remote boot setup, BaseCopyStyle will be set to
// SP_COPY_SOURCE_SIS_MASTER to indicate that single-instance
// store links should be created instead of copying files.
//

ULONG BaseCopyStyle = 0;

//
// Support for SMS.
//
typedef DWORD (*SMSPROC) (char *, char*, char*, char*, char *, char *, char *, BOOL);
HMODULE SMSHandle = NULL;
SMSPROC InstallStatusMIF = NULL;

//
// Window handle of topmost setup window.
//
HWND SetupWindowHandle;
HWND MainWindowHandle;
HWND WizardHandle;

//
// Source path for installation.
//
WCHAR SourcePath[MAX_PATH];

//
// System setup inf.
//
HINF SyssetupInf;

//
// Save the unhandled exception filter so we can restore it when we're done.
//
LPTOP_LEVEL_EXCEPTION_FILTER    SavedExceptionFilter = NULL;

//
// Unique Id for the main Setup thread.  If any other thread has an unhandled
// exception, we just log an error and try to keep going.
//
DWORD MainThreadId;

//
// The original locale we started setup under.  If the locale changes during
// gui-setup (via the IDD_REGIONAL_SETTINGS dialog), then new threads will
// startup with the updated LCID, which may end up confusing any locale-centric
// code.  An example of this would be setupapi's string table implementation,
// which does sorting by locale.
//
LCID  OriginalInstallLocale;


//
// Flag indicating whether this is an unattended mode install/upgrade, and
// if so, what mode to run in.
// Also a flag indicating whether this is a preinstallation.
// And a flag indicating whether we are supposed to allow rollback
// once setup has been completed.
// And a flag that tells us whether to skip the eula in the preinstall case.
// And a flag that tells us whether any accessibility utilities are in use.
//
BOOL Unattended;
UNATTENDMODE UnattendMode;
BOOL Preinstall;
BOOL AllowRollback;
BOOL OemSkipEula;
BOOL AccessibleSetup;
BOOL Magnifier;
BOOL ScreenReader;
BOOL OnScreenKeyboard;
BOOL EulaComplete = FALSE;

//
// Indicates whether we need to wait at the installation
// end in unattended mode
//
BOOL UnattendWaitForReboot = FALSE;

//
// We can get into unattended mode in several ways, so we also check whether
// the "/unattend" switch was explicitly specified.
//
BOOL UnattendSwitch;

//
// Flag indicating whether we should run OOBE after Setup completes.  Note
// that if it is FALSE, OOBE may still be run, based on other criteria.
//
BOOL ForceRunOobe;

#ifdef PRERELEASE
//
// Test hooks
//

INT g_TestHook;
#endif

//
// Flag indicating whether we are in a special mode for OEM's to use on the
// factory floor.
//
BOOL ReferenceMachine;

//
// Flag indicating whether a volume was extended or not using
// ExtendOemPartition
//
BOOL PartitionExtended = FALSE;

//
// Flag indicating if the eula was already shown during the textmode setup phase
//
BOOL TextmodeEula = FALSE;

//
// Flag indicating whether to skip missing files.
//
BOOL SkipMissingFiles;

//
// Catalog file to include (facilitates easy testing)
//

PWSTR IncludeCatalog;

//
// User command to execute, if any.
//
PWSTR UserExecuteCmd;

//
// String id of the string to be used for titles -- "Windows NT Setup"
//
UINT SetupTitleStringId;

//
// Strings used with date/timezone applet
//
PCWSTR DateTimeCpl = L"timedate.cpl";
PCWSTR DateTimeParam = L"/firstboot";
PCWSTR UnattendDateTimeParam = L"/z ";

//
// Registry Constants
//
#define REGSTR_PATH_SYSPREP                 _T("Software\\Microsoft\\Sysprep")
#define REGSTR_VAL_SIDGENHISTORY            _T("SidsGeneratedHistory")

//
// Global structure that contains information that will be used
// by net setup. We pass a pointer to this structure when we call
// NetSetupRequestWizardPages, then fill it in before we call into
// the net setup wizard.
//
INTERNAL_SETUP_DATA InternalSetupData;

//
// In the initial install case, we time how long the wizard takes
// to help randomize the sid we generate.
//
DWORD PreWizardTickCount;

//
// Global structure that contains callback routines and data needed by
// the Setuplog routines.
//
SETUPLOG_CONTEXT    SetuplogContext;

//
// Did we log an error during SfcInitProt()?
//
BOOL    SfcErrorOccurred = FALSE;

//
// List of drivers that remote boot requires to be boot drivers.
//
const static PCWSTR RemoteBootDrivers[] = { L"mrxsmb", L"netbt", L"rdbss", L"tcpip", L"ipsec" };

//
// List of functions for the billboard background
//
typedef BOOL (CALLBACK* SETSTEP)(int);
typedef HWND (CALLBACK* GETBBHWND)(void);
typedef BOOL (WINAPI* INITBILLBOARD)(HWND , LPCTSTR, DWORD);
typedef BOOL (WINAPI* TERMBILLBOARD)();

HINSTANCE hinstBB = NULL;
// End billboards

VOID
CallNetworkSetupBack(
    IN PCSTR ProcName
    );


VOID
RemoveMSKeyboardPtrPropSheet (
    VOID
    );

VOID
FixWordPadReg (
    VOID
    );

VOID
ProcessRegistryFiles(
    IN  HWND    Billboard
    );

VOID
SetStartTypeForRemoteBootDrivers(
    VOID
    );

BOOL
RunMigrationDlls (
    VOID
    );

BOOL
RunSetupPrograms(
    IN PVOID InfHandle,
    PWSTR SectionName
    );

VOID
GetUnattendRunOnceAndSetRegistry(
    VOID
    );

VOID
ExecuteUserCommand (
    HWND hProgress
    );

BOOL
MigrateExceptionPackages(
    IN HWND hProgress,
    IN DWORD StartAtPercent,
    IN DWORD StopAtPercent
    );

VOID
RemoveRestartability (
    HWND hProgress
    );

PCTSTR
pGenerateRandomPassword (
    VOID
    );

DWORD GetProductFlavor();

VOID
CopyOemProgramFilesDir(
    VOID
    );

VOID
CopyOemDocumentsDir(
    VOID
    );

BOOL 
UpdateServerProfileDirectory(
    VOID
    );

VOID
SendSMSMessage(
    IN UINT MessageId,
    IN BOOL Status
    )

/*++

Routine Description:

    If setup was initiated by SMS, then report our status.

Arguments:

    MessageId - supplies the id for the message in the message table.

    Status - TRUE = "Success" or FALSE = "Failed"

Return Value:

    None.

--*/

{
    PWSTR   UnicodeBuffer;
    PSTR    AnsiBuffer;

    if(InstallStatusMIF) {
        if( UnicodeBuffer = RetrieveAndFormatMessageV( NULL, MessageId, NULL )) {
            if(AnsiBuffer = pSetupUnicodeToAnsi (UnicodeBuffer)) {

                InstallStatusMIF(
                    "setupinf",
                    "Microsoft",
                    "Windows NT",
                    "5.0",
                    "",
                    "",
                    AnsiBuffer,
                    Status
                    );

                MyFree (AnsiBuffer);
            }

            MyFree( UnicodeBuffer );
        }
    }
}

VOID
BrandIE(
    )
{
    if( Unattended && !Upgrade && !MiniSetup ) {

        typedef     BOOL (*BRANDINTRAPROC) ( LPCSTR );
        typedef     BOOL (*BRANDCLEANSTUBPROC) (HWND, HINSTANCE, LPCSTR, int);
        HMODULE     IedkHandle = NULL;
        BRANDINTRAPROC      BrandIntraProc;
        BRANDCLEANSTUBPROC  BrandCleanStubProc;
        BOOL        Success = TRUE;
        BOOL        UseOemBrandingFile = FALSE;
        CHAR BrandingFileA[MAX_PATH];
        WCHAR OemBrandingFile[MAX_PATH];
        DWORD OemDirLen = 0;
#define BUF_SIZE 4
        WCHAR Buf[BUF_SIZE];

        //
        // We need to call out to iedkcs32!BrandIntra.
        //
        // Load iedkcs32.dll, lookup BrandIntra and
        // call out to him.
        //

        if (GetPrivateProfileString(L"Branding", L"BrandIEUsingUnattended", L"",
                                    Buf, BUF_SIZE,
                                    AnswerFile)) {
            //Found the Branding section
            try {

                if( IedkHandle = LoadLibrary(L"IEDKCS32") ) {

                   BrandCleanStubProc = (BRANDCLEANSTUBPROC) GetProcAddress(IedkHandle,"BrandCleanInstallStubs");
                   BrandIntraProc =  (BRANDINTRAPROC) GetProcAddress(IedkHandle,"BrandIntra");
                   if( BrandCleanStubProc && BrandIntraProc ) {

                      if (_wcsicmp(Buf, L"YES")) {
                          //
                          // Check whether the OEM supplies an IE branding file.
                          //
                          lstrcpy(OemBrandingFile,SourcePath);

                          if (pSetupConcatenatePaths(OemBrandingFile,WINNT_OEM_DIR,MAX_PATH, &OemDirLen)) {
                              OemBrandingFile[OemDirLen-1] = L'\\';

                              if (GetPrivateProfileString(L"Branding", L"IEBrandingFile", L"",
                                            OemBrandingFile + OemDirLen,
                                            MAX_PATH - OemDirLen,
                                            AnswerFile)) {

                                  if (FileExists(OemBrandingFile, NULL))
                                      UseOemBrandingFile = TRUE;

                              }
                          } else {
                               SetupDebugPrint( L"Setup: (non-critical error) Failed call pSetupConcatenatePaths\n" );
                          }

                          if (!UseOemBrandingFile) {
                               Success = FALSE;
                               SetupDebugPrint( L"Setup: (non-critical error) Could not find the OEM branding file for IE\n" );
                          }
                      }

                      if (Success) {
                          if (!WideCharToMultiByte(
                                             CP_ACP,
                                             0,
                                             UseOemBrandingFile?OemBrandingFile:AnswerFile,
                                             -1,
                                             BrandingFileA,
                                             sizeof(BrandingFileA),
                                             NULL,
                                             NULL
                                             )) {
                               Success = FALSE;
                               SetupDebugPrint1( L"Setup: (non-critical error) Failed call WideCharToMultiByte (gle %u) \n", GetLastError() );

                          } else {

                               Success = BrandCleanStubProc( NULL, NULL, "", 0);
                               if( !Success ) {
                                  SetupDebugPrint( L"Setup: (non-critical error) Failed call BrandCleanInstallStubs \n" );
                               } else {
                                  Success = BrandIntraProc( BrandingFileA );
                                  if( !Success ) {
                                     SetupDebugPrint( L"Setup: (non-critical error) Failed call BrandIntra \n" );
                                  }
                               }
                          }
                      }

                   } else {
                      Success = FALSE;
                      SetupDebugPrint( L"Syssetup: (non-critical error) Failed GetProcAddress on BrandIntra or BrandCleanInstallStubs.\n" );
                   }

                } else {
                   Success = FALSE;
                   SetupDebugPrint( L"Syssetup: (non-critical error) Failed load of iedkcs32.dll.\n" );
                }

            } except(EXCEPTION_EXECUTE_HANDLER) {
                   Success = FALSE;
                   SetupDebugPrint( L"Setup: Exception in iedkcs32!BrandIntra\n" );
            }

            if (IedkHandle)
                FreeLibrary(IedkHandle);

            if( !Success ) {
               //
               // We failed the call (for whatever reason).  Log
               // this error.
               //
               SetuplogError(
                            LogSevError,
                            SETUPLOG_USE_MESSAGEID,
                            MSG_BRAND_IE_FAILURE,
                            NULL,NULL);
            }

        }

    }

}


VOID
SpStartAccessibilityUtilities(
    IN HWND     Billboard
    )
/*++

Routine Description:

    Installs and runs selected accessibility utilities.

Arguments:

    Billboard - window handle of "Setup is Initializing" billboard.

Returns:

    Boolean value indicating outcome.

--*/

{
    HINF    hInf;
    HINF    LayoutInf;
    HSPFILEQ FileQueue;
    PVOID   QContext;
    BOOL    b = TRUE;
    DWORD   ScanQueueResult;

    //
    // Install text-to-speech engine and SAPI 5 for the screen reader.
    //
    FileQueue = SetupOpenFileQueue();
    b = b && (FileQueue != INVALID_HANDLE_VALUE);

    if(b) {
        hInf = SetupOpenInfFile(L"sapi5.inf",NULL,INF_STYLE_WIN4,NULL);
        if(hInf && (hInf != INVALID_HANDLE_VALUE)
        && (LayoutInf = InfCacheOpenLayoutInf(hInf))) {

            SetupInstallFilesFromInfSection(
                hInf,
                LayoutInf,
                FileQueue,
                L"DefaultInstall",
                SourcePath,
                SP_COPY_NEWER
                );

            SetupCloseInfFile(hInf);
        } else {
            b = FALSE;
        }
    }

    //
    // If enqueuing went OK, now perform the copying, renaming, and deleting.
    // Then perform the rest of the install process (registry stuff, etc).
    //
    if(b) {
        QContext = InitSysSetupQueueCallbackEx(
            Billboard,
            INVALID_HANDLE_VALUE,
            0,0,NULL);

        if( QContext ) {

            if(!SetupScanFileQueue(
                   FileQueue,
                   SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE,
                   Billboard,
                   NULL,
                   NULL,
                   &ScanQueueResult)) {
                    //
                    // SetupScanFileQueue should really never
                    // fail when you don't ask it to call a
                    // callback routine, but if it does, just
                    // go ahead and commit the queue.
                    //
                    ScanQueueResult = 0;
                }


            if( ScanQueueResult != 1 ){


                b = SetupCommitFileQueue(
                    Billboard,
                    FileQueue,
                    SysSetupQueueCallback,
                    QContext
                    );
            }

            TermSysSetupQueueCallback(QContext);
        }
        else {
	    b = FALSE;
        }
    }

    if(b) {
        hInf = SetupOpenInfFile(L"sapi5.inf",NULL,INF_STYLE_WIN4,NULL);
        if(hInf && (hInf != INVALID_HANDLE_VALUE)) {

            SetupInstallFromInfSection(
                Billboard,
                hInf,
                L"DefaultInstall",
                SPINST_ALL ^ SPINST_FILES,
                NULL,
                NULL,
                0,
                NULL,
                NULL,
                NULL,
                NULL
                );

            SetupCloseInfFile(hInf);
        } else {
            b = FALSE;
        }
    }

    //
    // Delete the file queue.
    //
    if(FileQueue != INVALID_HANDLE_VALUE) {
        SetupCloseFileQueue(FileQueue);
    }
    // END OF SAPI 5 INSTALLATION.

    if(Magnifier) {
        b = b && InvokeExternalApplication(L"magnify.exe", L"", NULL);
    }

    if(OnScreenKeyboard) {
        b = b && InvokeExternalApplication(L"osk.exe", L"", NULL);
    }

    if(!b) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_ACCESSIBILITY_FAILED,
            NULL,NULL);
    }
}


VOID
FatalError(
    IN UINT MessageId,
    ...
    )

/*++

Routine Description:

    Inform the user of an error which prevents Setup from continuing.
    The error is logged as a fatal error, and a message box is presented.

Arguments:

    MessageId - supplies the id for the message in the message table.

    Additional agruments specify parameters to be inserted in the message.

Return Value:

    DOES NOT RETURN.

--*/

{
    PWSTR   Message;
    va_list arglist;
    HKEY    hKey;
    DWORD   RegData;


    va_start(arglist,MessageId);
    Message = SetuplogFormatMessageV(
        0,
        SETUPLOG_USE_MESSAGEID,
        MessageId,
        &arglist);
    va_end(arglist);

    if(Message) {

        //
        // Log the error first.
        //
        SetuplogError(
            LogSevFatalError,Message,0,NULL,NULL);

        //
        // Now tell the user.
        //
        MessageBoxFromMessage(
            MainWindowHandle,
            MSG_FATAL_ERROR,
            NULL,
            IDS_FATALERROR,
            MB_ICONERROR | MB_OK | MB_SYSTEMMODAL,
            Message
            );

    } else {
        pSetupOutOfMemory(MainWindowHandle);
    }

    SetuplogError(
        LogSevInformation,
        SETUPLOG_USE_MESSAGEID,
        MSG_LOG_GUI_ABORTED,
        NULL,NULL);
    if ( SavedExceptionFilter ) {
        SetUnhandledExceptionFilter( SavedExceptionFilter );
    }

    TerminateSetupLog(&SetuplogContext);
    ViewSetupActionLog(MainWindowHandle, NULL, NULL);

    SendSMSMessage( MSG_SMS_FAIL, FALSE );

    if ( OobeSetup ) {
        //
        // Create registry entry that tell winlogon to shutdown for the OOBE case.
        // This doesn't work for MiniSetup, because winlogon always restarts in
        // that case.
        //
        RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            L"System\\Setup",
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_SET_VALUE,
            NULL,
            &hKey,
            NULL
            );
        if ( hKey ) {
            RegData = ShutdownPowerOff;
            RegSetValueEx(
                hKey,
                L"SetupShutdownRequired",
                0,
                REG_DWORD,
                (PVOID)&RegData,
                sizeof(RegData)
                );
            RegCloseKey(hKey);
        }
    }

    ExitProcess(1);

}

LONG
WINAPI
MyUnhandledExceptionFilter(
    IN struct _EXCEPTION_POINTERS *ExceptionInfo
    )

/*++

Routine Description:

    The routine deals with any unhandled exceptions in Setup.  We log an error
    and kill the offending thread.

Arguments:

    Same as UnhandledExceptionFilter.

Return Value:

    Same as UnhandledExceptionFilter.

--*/

{
    UINT_PTR Param1, Param2;


    switch(ExceptionInfo->ExceptionRecord->NumberParameters) {
    case 1:
        Param1 = ExceptionInfo->ExceptionRecord->ExceptionInformation[0];
        Param2 = 0;
        break;
    case 2:
        Param1 = ExceptionInfo->ExceptionRecord->ExceptionInformation[0];
        Param2 = ExceptionInfo->ExceptionRecord->ExceptionInformation[1];
        break;
    default:
        Param1 = Param2 = 0;
    }

    SetupDebugPrint4( L"Setup: (critical error) Encountered an unhandled exception (%lx) at address %lx with the following parameters: %lx %lx.",
        ExceptionInfo->ExceptionRecord->ExceptionCode,
        ExceptionInfo->ExceptionRecord->ExceptionAddress,
        Param1,
        Param2
        );

#ifdef NOT_FOR_NT5
    SetuplogError(
        LogSevError | SETUPLOG_SINGLE_MESSAGE,
        SETUPLOG_USE_MESSAGEID,
        MSG_LOG_UNHANDLED_EXCEPTION,
        ExceptionInfo->ExceptionRecord->ExceptionCode,
        ExceptionInfo->ExceptionRecord->ExceptionAddress,
        Param1,
        Param2,
        NULL,NULL);
#else
    SetuplogError(
        LogSevError | SETUPLOG_SINGLE_MESSAGE,
        SETUPLOG_USE_MESSAGEID,
        MSG_LOG_UNHANDLED_EXCEPTION,
        ExceptionInfo->ExceptionRecord->ExceptionCode,
        ExceptionInfo->ExceptionRecord->ExceptionAddress,
        Param1,
        Param2,
        NULL,
        NULL
        );
#endif

#ifdef PRERELEASE
    //
    // If we're an internal build, then we want to debug this.
    //
    MessageBoxFromMessage (
        NULL,
        MSG_UNHANDLED_EXCEPTION,
        NULL,
        IDS_ERROR,
        MB_OK | MB_TASKMODAL | MB_ICONSTOP | MB_SETFOREGROUND,
        ExceptionInfo->ExceptionRecord->ExceptionCode,
        ExceptionInfo->ExceptionRecord->ExceptionAddress,
        Param1,
        Param2
        );

    return EXCEPTION_CONTINUE_EXECUTION;
#endif

    //
    // If we're running under the debugger, then pass the exception to the
    // debugger.  If the exception occurred in some thread other than the main
    // Setup thread, then kill the thread and hope that Setup can continue.
    // If the exception is in the main thread, then don't handle the exception,
    // and let Setup die.
    //
    if( GetCurrentThreadId() != MainThreadId &&
        !IsDebuggerPresent() ) {
        ExitThread( 0 );
    }

    return EXCEPTION_CONTINUE_SEARCH;
}

BOOL
ProcessUniquenessValue(
    LPTSTR lpszDLLPath
    )
{
    BOOL bRet = FALSE;

    //
    // Make sure we were passed something valid...
    //
    if ( lpszDLLPath && *lpszDLLPath )
    {
        LPWSTR pSrch;
        
        //
        // Look for the comma that separates the DLL and the entrypoint...
        //
        if ( pSrch = wcschr( lpszDLLPath, L',' ) )
        {
            CHAR szEntryPointA[MAX_PATH] = {0};

            // We found one, now NULL the string at the comma...
            //
            *(pSrch++) = L'\0';

            //
            // If there's still something after the comma, and we can convert it 
            // into ANSI for GetProcAddress, then let's proceed...
            //
            if ( *pSrch &&
                 ( 0 != WideCharToMultiByte( CP_ACP,
                                             0,
                                             pSrch,
                                             -1,
                                             szEntryPointA,
                                             ARRAYSIZE(szEntryPointA),
                                             NULL,
                                             NULL ) ) )
            {
                HMODULE hModule = NULL;

                try 
                {
                    //
                    // Load and call the entry point.
                    //
                    if ( hModule = LoadLibrary( lpszDLLPath ) )
                    {
                        FARPROC fpEntryPoint;
                        
                        if ( fpEntryPoint = GetProcAddress(hModule, szEntryPointA) )
                        {
                            //
                            // Do it, ignoring any return value/errors
                            //
                            fpEntryPoint();

                            //
                            // We made it this far, consider this a success...
                            //
                            bRet = TRUE;
                        }
                    }
                } 
                except(EXCEPTION_EXECUTE_HANDLER) 
                {
                    //
                    // We don't do anything with the exception code...
                    //
                }

                //
                // Free the library outside the try/except block in case the function faulted.
                //
                if ( hModule ) 
                {
                    FreeLibrary( hModule );
                }
            }
        }
    }

    return bRet;
}

VOID 
ProcessUniquenessKey(
    BOOL fBeforeReseal
    )
{
    HKEY   hKey;
    TCHAR  szRegPath[MAX_PATH] = {0};
    LPTSTR lpszBasePath = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\SysPrep\\");

    //
    // Build a path to the registry key we want to process...
    //
    lstrcpyn( szRegPath, lpszBasePath, ARRAYSIZE(szRegPath) );
    lstrcpyn( szRegPath + lstrlen(szRegPath), 
              fBeforeReseal ? TEXT("SysprepBeforeExecute") : TEXT("SysprepAfterExecute"),
              ARRAYSIZE(szRegPath) - lstrlen(szRegPath) );

    //
    // We want to make sure an Administrator is doing this, so get KEY_ALL_ACCESS
    //
    if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                        szRegPath,
                                        0,
                                        KEY_ALL_ACCESS,
                                        &hKey ) )
    {
        DWORD dwValues          = 0,
              dwMaxValueLen     = 0,
              dwMaxValueNameLen = 0;
        //
        // Query the key to find out some information we care about...
        //
        if ( ( ERROR_SUCCESS == RegQueryInfoKey( hKey,                  // hKey
                                                 NULL,                  // lpClass
                                                 NULL,                  // lpcClass
                                                 NULL,                  // lpReserved
                                                 NULL,                  // lpcSubKeys
                                                 NULL,                  // lpcMaxSubKeyLen
                                                 NULL,                  // lpcMaxClassLen
                                                 &dwValues,             // lpcValues
                                                 &dwMaxValueNameLen,    // lpcMaxValueNameLen
                                                 &dwMaxValueLen,        // lpcMaxValueLen
                                                 NULL,                  // lpcbSecurityDescriptor
                                                 NULL ) ) &&            // lpftLastWriteTime
             ( dwValues > 0 ) &&
             ( dwMaxValueNameLen > 0) &&
             ( dwMaxValueLen > 0 ) )
        {
            //
            // Allocate buffers large enough to hold the data we want...
            //
            LPBYTE lpData      = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, dwMaxValueLen );
            LPTSTR lpValueName = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, ( dwMaxValueNameLen + 1 ) * sizeof(TCHAR) );
            
            //
            // Make sure we could allocate our buffers... otherwise bail out
            //
            if ( lpData && lpValueName )
            {
                DWORD dwIndex   = 0;
                BOOL  bContinue = TRUE;

                //
                // Enumerate through the key values and call the DLL entrypoints...
                //
                while ( bContinue )
                {
                    DWORD dwType,
                          cbData         = dwMaxValueLen,
                          dwValueNameLen = dwMaxValueNameLen + 1;

                    bContinue = ( ERROR_SUCCESS == RegEnumValue( hKey,
                                                                 dwIndex++,
                                                                 lpValueName,
                                                                 &dwValueNameLen,
                                                                 NULL,
                                                                 &dwType,
                                                                 lpData,
                                                                 &cbData ) );

                    //
                    // Make sure we got some data of the correct format...
                    //
                    if ( bContinue && ( REG_SZ == dwType ) && ( cbData > 0 ) )
                    {
                        //
                        // Now split up the string and call the entrypoints...
                        //
                        ProcessUniquenessValue( (LPTSTR) lpData );
                    }
                }
            }

            //
            // Clean up any buffers we may have allocated...
            //
            if ( lpData )
            {
                HeapFree( GetProcessHeap(), 0, lpData );
            }

            if ( lpValueName )
            {
                HeapFree( GetProcessHeap(), 0, lpValueName );
            }
        }

        //
        // Close the key...
        //
        RegCloseKey( hKey );
    }
}

VOID
RunExternalUniqueness(
    VOID
    )

/*++
===============================================================================
Routine Description:

    This routine will call out to any external dlls that will allow
    3rd party apps to make their stuff unique.

    We'll look in 2 inf files:
    %windir%\inf\minioc.inf
    %systemroot%\sysprep\providers.inf

    In each of these files, we'll look in the [SysprepInitExecute] section
    for any entries.  The entries must look like:
    dllname,entrypoint

    We'll load the dll and call into the entry point.  Errors are ignored.

Arguments:

    None.

Return Value:

    TRUE if successful.

    FALSE if any errors encountered

===============================================================================
--*/

{
WCHAR       InfPath[MAX_PATH];
PCWSTR      DllName;
PCWSTR      EntryPointNameW;
CHAR        EntryPointNameA[MAX_PATH];
HINF        AnswerInf;
HMODULE     DllHandle;
FARPROC     MyProc;
INFCONTEXT  InfContext;
DWORD       i;
PCWSTR      SectionName = L"SysprepInitExecute";
BOOL        LineExists;
DWORD       Result;

    //
    // =================================
    // Minioc.inf
    // =================================
    //

    //
    // Build the path.
    //
    Result = GetWindowsDirectory( InfPath, MAX_PATH );
    if( Result == 0) {
        MYASSERT(FALSE);
        return;
    }
    lstrcat( InfPath, TEXT("\\inf\\minioc.inf") );

    //
    // See if he's got an entry
    // section.
    //
    AnswerInf = SetupOpenInfFile( InfPath, NULL, INF_STYLE_WIN4, NULL );
    if( AnswerInf == INVALID_HANDLE_VALUE ) {
        //
        // Try an old-style.
        //
        AnswerInf = SetupOpenInfFile( InfPath, NULL, INF_STYLE_OLDNT, NULL );
    }


    if( AnswerInf != INVALID_HANDLE_VALUE ) {
        //
        // Process each line in our section
        //
        LineExists = SetupFindFirstLine( AnswerInf, SectionName, NULL, &InfContext );

        while( LineExists ) {

                if( DllName = pSetupGetField(&InfContext, 1) ) {
                    if( EntryPointNameW = pSetupGetField(&InfContext, 2) ) {

                        DllHandle = NULL;

                        //
                        // Load and call the entry point.
                        //
                        try {
                            if( DllHandle = LoadLibrary(DllName) ) {

                                //
                                // No Unicode version of GetProcAddress(). Convert string to ANSI.
                                //
                                i = WideCharToMultiByte(CP_ACP,0,EntryPointNameW,-1,EntryPointNameA,MAX_PATH,NULL,NULL);

                                if( MyProc = GetProcAddress(DllHandle, EntryPointNameA) ) {
                                    //
                                    // Do it, ignoring any return value/errors
                                    //
                                    MyProc();
                                }
                            }
                        } except(EXCEPTION_EXECUTE_HANDLER) {
                        }

                        if( DllHandle ) {
                            FreeLibrary( DllHandle );
                        }

                    }
                }

            LineExists = SetupFindNextLine(&InfContext,&InfContext);

        }

        SetupCloseInfFile( AnswerInf );
    }

    //
    // =================================
    // Provider.inf
    // =================================
    //

    ProcessUniquenessKey( FALSE );
}



#ifdef _X86_
VOID
CleanUpHardDriveTags (
    VOID
    )
{

    WCHAR path[MAX_PATH];
    WCHAR rootPath[4] = TEXT("*:\\");
    UINT i;
    BYTE bitPosition;
    DWORD drives;
    UINT type;

    lstrcpy(path, L"*:\\");
    lstrcat(path, WINNT_WIN95UPG_DRVLTR_W);

    drives = GetLogicalDrives ();

    for (bitPosition = 0; bitPosition < 26; bitPosition++) {

        if (drives & (1 << bitPosition)) {

            *rootPath = bitPosition + L'A';
            type = GetDriveType (rootPath);

            if (type == DRIVE_FIXED) {
                *path = *rootPath;
                DeleteFile (path);
            }
        }
    }
}


#endif

HRESULT
WaitForSamService()
/*++

Routine Description:

    This procedure waits for the SAM service to start and to complete
    all its initialization.

Arguments:


Return Value:

Notes:

  acosma 10/12/2001 - code borrowed from winlogon. Waiting for 20 seconds just like winlogon.

--*/

{
    NTSTATUS Status;
    DWORD WaitStatus;
    UNICODE_STRING EventName;
    HANDLE EventHandle;
    OBJECT_ATTRIBUTES EventAttributes;
    HRESULT Hr;

    //
    // open SAM event
    //

    RtlInitUnicodeString( &EventName, L"\\SAM_SERVICE_STARTED");
    InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );

    Status = NtOpenEvent( &EventHandle,
                            SYNCHRONIZE|EVENT_MODIFY_STATE,
                            &EventAttributes );
    if ( !NT_SUCCESS(Status))
    {

        if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            //
            // SAM hasn't created this event yet, let us create it now.
            // SAM opens this event to set it.
            //

            Status = NtCreateEvent(
                           &EventHandle,
                           SYNCHRONIZE|EVENT_MODIFY_STATE,
                           &EventAttributes,
                           NotificationEvent,
                           FALSE // The event is initially not signaled
                           );

            if( Status == STATUS_OBJECT_NAME_EXISTS ||
                Status == STATUS_OBJECT_NAME_COLLISION )
            {

                //
                // second change, if the SAM created the event before we
                // do.
                //

                Status = NtOpenEvent( &EventHandle,
                                        SYNCHRONIZE|EVENT_MODIFY_STATE,
                                        &EventAttributes );

            }
        }

        if ( !NT_SUCCESS(Status))
        {
            //
            // could not make the event handle
            //
            return( Status );
        }
    }

    WaitStatus = WaitForSingleObject( EventHandle,
                                      300*1000 );  // 5 minutes

    if ( WaitStatus == WAIT_OBJECT_0 )
    {
        Hr = S_OK;
    }
    else
    {
        Hr = WaitStatus;
    }

    (VOID) NtClose( EventHandle );
    return Hr;
}

#define UPDATE_KEYS         L"UpdateKeys"
#define KEY_UPDATE_NEEDED   0
#define KEY_UPDATE_FAIL     1
#define KEY_UPDATE_SUCCESS  2
#define KEY_UPDATE_MAX      2

VOID
UpdateSecurityKeys(
    )

/*+++

    This function calls an API that generates new security keys for machines
    that have been cloned.  If the API fails, it is a fatal error.  Whether it
    succeeds or not, we record the result in the registry so that we don't
    try again if the machine is restarted.

--*/

{
    DWORD       Status;
    HKEY        hKey = NULL;
    DWORD       dwType;
    LONG        RegData = KEY_UPDATE_NEEDED;
    DWORD       cbData;


    SetupDebugPrint(L"Updating keys ...");
    RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OOBE",
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_READ | KEY_WRITE,
        NULL,
        &hKey,
        NULL
        );
    if ( hKey ) {

        cbData = sizeof(RegData);
        Status = RegQueryValueEx(
            hKey,
            UPDATE_KEYS,
            NULL,
            &dwType,
            (PVOID)&RegData,
            &cbData
            );

        if ( Status != ERROR_SUCCESS ||
             dwType != REG_DWORD ||
             RegData > KEY_UPDATE_MAX
             ) {

            RegData = KEY_UPDATE_NEEDED;
        }
    }

    switch (RegData) {

    case KEY_UPDATE_NEEDED:
#if 1
        Status = CryptResetMachineCredentials( 0 );
#else
        // To test the failure case:
        Status = ERROR_OUT_OF_PAPER;
#endif
        if ( Status != ERROR_SUCCESS ) {
            SetupDebugPrint1(L"... failed.  Error = %d", Status);
            MYASSERT( Status );
            RegData = KEY_UPDATE_FAIL;
        } else {
            SetupDebugPrint(L"... succeeded.");
            RegData = KEY_UPDATE_SUCCESS;
        }

        if ( hKey ) {
            Status = RegSetValueEx(
                hKey,
                UPDATE_KEYS,
                0,
                REG_DWORD,
                (PVOID)&RegData,
                sizeof(RegData)
                );
            MYASSERT( Status == ERROR_SUCCESS);
        }
        break;

    case KEY_UPDATE_FAIL:
        SetupDebugPrint(L"... not needed (previously failed).");
        break;

    case KEY_UPDATE_SUCCESS:
        SetupDebugPrint(L"... not needed (previously succeeded).");
        break;

    default:
        MYASSERT(0);
    }

    if (hKey) {
        RegCloseKey(hKey);
    }

    // Note: FatalError() doesn't return.
    if ( RegData == KEY_UPDATE_FAIL ) {
        FatalError( MSG_LOG_CANT_SET_SECURITY, 0, 0 );
    }
}


#ifdef _OCM
PVOID
#else
VOID
#endif
CommonInitialization(
    VOID
    )

/*++

Routine Description:

    Initialize GUI Setup. This is common to upgrades and initial installs.
    In this phase, we perform initialization tasks such as creating the
    main background window, initializing the action log (into which we will
    store error and other info), and fetch setup parameters from the
    response file.

    We also install the NT catalog file(s) and load system infs.

    Note that any errors that occur during this phase are fatal.

    NOTE: IF YOU ADD CODE TO THIS FUNCTION THAT REQUIRES A SERVICE TO RUN MAKE
        SURE THAT IT IS NOT EXECUTED IN OOBE MODE.  OOBE DELAYS THE STARTING OF
        SERVICES UNTIL THE MACHINE NAME HAS BEEN CHANGED, SO WAITING FOR A
        SERVICE TO START DURING INITIALIZATION WILL CAUSE A DEADLOCK.

Arguments:

    None.

Return Value:

#ifdef _OCM
    OC Manager context handle.
#else
    None.
#endif

--*/

{
    #define     MyAnswerBufLen (2*MAX_PATH)
    WCHAR       MyAnswerFile[MyAnswerBufLen];
    WCHAR       MyAnswer[MyAnswerBufLen];
    DWORD       rc,wowretval, Err;
    BOOL        b;
    HWND        Billboard;
    HCURSOR     hCursor;
    WCHAR       Path[MAX_PATH];
    PWSTR       Cmd;
    PWSTR       Args;
    WCHAR       PathBuffer[4*MAX_PATH];
    PWSTR       PreInstallProfilesDir;
    int         i;
    HANDLE      h;
    WCHAR       CmdLine[MAX_PATH];
#ifdef _OCM
    PVOID       OcManagerContext;
#endif
    TCHAR       paramBuffer[MAX_PATH];
    TCHAR       profilePath[MAX_PATH];
    DWORD       Size;

    //
    // Get handle to heap so we can periodically validate it.
    //
#if DBG
    g_hSysSetupHeap = GetProcessHeap();
#endif

    //
    // Hack to make mini setup restartable.
    //
    if( MiniSetup ) {
    HKEY hKeySetup;

        // OOBE will set its own restartability.
        //
        if (! OobeSetup)
        {
            BEGIN_SECTION(L"Making mini setup restartable");

            //
            // Reset the SetupType entry to 1.  We'll clear
            // it at the end of gui-mode.
            //
            rc = (DWORD)RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                      L"System\\Setup",
                                      0,
                                      KEY_SET_VALUE | KEY_QUERY_VALUE,
                                      &hKeySetup );

            if(rc == NO_ERROR) {
                //
                // Set HKLM\System\Setup\SetupType Key to SETUPTYPE_NOREBOOT
                //
                rc = 1;
                RegSetValueEx( hKeySetup,
                               TEXT( "SetupType" ),
                               0,
                               REG_DWORD,
                               (CONST BYTE *)&rc,
                               sizeof(DWORD));

                RegCloseKey(hKeySetup);
            }
            END_SECTION(L"Making mini setup restartable");
        }
    }

    //
    // Initialize the action log. This is where we log any errors or other
    // info we think might be useful to the user.
    //
    BEGIN_SECTION(L"Initializing action log");
    InitializeSetupLog(&SetuplogContext);
    MainThreadId = GetCurrentThreadId();
    OriginalInstallLocale = GetThreadLocale();
    SavedExceptionFilter = SetUnhandledExceptionFilter( MyUnhandledExceptionFilter );
    END_SECTION(L"Initializing action log");

    Win95Upgrade = (SpSetupLoadParameter(pwWin95Upgrade,
                                         paramBuffer,
                                         sizeof(paramBuffer) / sizeof(paramBuffer[0])) &&
                    !lstrcmpi(paramBuffer, pwYes));

    Upgrade = (SpSetupLoadParameter(pwNtUpgrade,
                                    paramBuffer,
                                    sizeof(paramBuffer) / sizeof(paramBuffer[0])) &&
               !lstrcmpi(paramBuffer, pwYes));

#ifdef _X86_
    if(Win95Upgrade){
        UninstallEnabled = (SpSetupLoadParameter(pwBackupImage,
                                        paramBuffer,
                                        sizeof(paramBuffer) / sizeof(paramBuffer[0])) &&
                                0xffffffff != GetFileAttributes(paramBuffer));
    }
#endif

    if (UninstallEnabled) {
        //
        // Put the boot.ini timeout to 30 seconds (or whatever the answer
        // file says it should be), so that if setup fails, the user can
        // clearly see the Cancel Setup option in the boot menu. The
        // timeout gets set back to 5 seconds during PNP detection, so
        // that PNP hung device logic still works.
        //

        RestoreBootTimeout();
    }

    if (!OobeSetup)
    {
        if(Win95Upgrade || !Upgrade){
            Size = ARRAYSIZE(profilePath);
            if(GetAllUsersProfileDirectory(profilePath, &Size)) {
                DeleteOnRestartOfGUIMode(profilePath);
            }
            else{
                SetupDebugPrint(TEXT("Cannot get All Users profile path."));
            }

            Size = ARRAYSIZE(profilePath);
            if(GetDefaultUserProfileDirectory(profilePath, &Size)) {
                DeleteOnRestartOfGUIMode(profilePath);
            }
            else{
                SetupDebugPrint(TEXT("Cannot get Default User profile path."));
            }
        }
    }

    //
    // Create the main setup background window.  We need to know which product
    // we are for the "Initializing" dialog.
    //
    SpSetProductTypeFromParameters();

#ifdef PRERELEASE
    {
        //
        // Initialize test hook failure point (internal use only, for testing restartability)
        //

        WCHAR buffer[32];

        //
        // This next function call is just to ensure the global AnswerFile value is filled in.
        // Since this is temp code, we call GetPrivateProfileString knowing some of the
        // implementation of SpSetupLoadParameter.
        //

        SpSetupLoadParameter(pwWin95Upgrade,buffer,sizeof(buffer)/sizeof(WCHAR));

        // Get the test hook that we want to fail on
        g_TestHook = GetPrivateProfileInt (L"TestHooks", L"BugCheckPoint", 0, AnswerFile);
    }
#endif

    TESTHOOK(501);

    if( !OobeSetup ) {
        WCHAR p[16];
        BEGIN_SECTION(L"Creating setup background window");
        MainWindowHandle = CreateSetupWindow();

        // Need to know this to calc the remaining time correct.
        Win95Upgrade = (SpSetupLoadParameter(pwWin95Upgrade,p,sizeof(p)/sizeof(WCHAR)) && !lstrcmpi(p,pwYes));
        // Now the billboard window is up. set the first estimate.
        RemainingTime = CalcTimeRemaining(Phase_Initialize);
        SetRemainingTime(RemainingTime);

        Billboard = DisplayBillboard(MainWindowHandle,MSG_INITIALIZING);
        hCursor = SetCursor( LoadCursor( NULL, IDC_WAIT ) );
        END_SECTION(L"Creating setup background window");
    }

    //
    // Update security keys for syspreped systems.  See RAID 432224.
    //
    if ( MiniSetup ) {
        HRESULT hrSamStatus;
        HKEY    hKey                = NULL;
        DWORD   dwValue,
                dwSize              = sizeof(dwValue);
        
        //
        // Before calling UpdateSecurityKeys make sure that LSA is properly initialized.
        //
        if ( S_OK != (hrSamStatus = WaitForSamService()) ) {
            SetuplogError(LogSevError,
                TEXT("SAM initialization has timed out or failed. (rc=%1!x!)."),
                0, 
                hrSamStatus,
                NULL,
                NULL
                );
        }

        // Determine if we have regenerated the SIDS without calling the UpdateSecurityKeys
        //
        if ( (RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGSTR_PATH_SYSPREP, 0, KEY_ALL_ACCESS, &hKey ) == NO_ERROR) &&
             (RegQueryValueEx(hKey, REGSTR_VAL_SIDGENHISTORY, NULL, NULL, (LPBYTE)&dwValue, &dwSize) == ERROR_SUCCESS) &&
             (dwValue == 1)
           )
        {
            // We've regenerated SIDS without calling UpdateSecurityKeys, lets do it now
            //
            UpdateSecurityKeys();
            RegDeleteValue(hKey,REGSTR_VAL_SIDGENHISTORY);
        }

        // Close the key that we opened
        //
        if ( hKey )
        {
            RegCloseKey(hKey);
        }
    }

    //
    // Support for SMS.
    //
    if( !MiniSetup ) {
        try {
            BEGIN_SECTION(L"Initializing SMS support");
            if( SMSHandle = LoadLibrary( TEXT("ISMIF32")) ) {

                if( InstallStatusMIF = (SMSPROC)GetProcAddress(SMSHandle,"InstallStatusMIF")) {
                    SetupDebugPrint( L"Setup: GetProcAddress on ISMIF32 succeeded." );
                } else {
                    SetupDebugPrint( L"Setup: (non-critical error): Failed GetProcAddress on ISMIF32." );
                }
            } else {
                    SetupDebugPrint( L"Setup: (non-critical error): Failed load of ismif32.dll." );
            }
            END_SECTION(L"Initializing SMS support");
        } except(EXCEPTION_EXECUTE_HANDLER) {
            SetupDebugPrint( L"Setup: Exception in ISMIF32." );
            END_SECTION(L"Initializing SMS support");
        }
    }

    //
    // Are we in safe mode?
    //
    // BUGBUG: OOBE shouldn't start in safe mode
    //
#ifdef NOT_FOR_NT5
    {
        DWORD d;
        HKEY hkey;

        d = RegOpenKeyEx(HKEY_LOCAL_MACHINE,L"System\\CurrentControlSet\\Control\\SafeBoot\\Option",0,KEY_READ,&hkey);
        if(d == NO_ERROR) {
            RegCloseKey(hkey);
            SetuplogError(
                LogSevError,
                L"Setup is running in safe-mode.  This is not supported.\r\n",
                0,NULL,NULL);
        }
    }
#endif

    //
    // Prevent power management from kicking in.
    //
    BEGIN_SECTION(L"Shutting down power management");
    SetThreadExecutionState(
        ES_CONTINUOUS | ES_SYSTEM_REQUIRED | ES_DISPLAY_REQUIRED);
    END_SECTION(L"Shutting down power management");

    //
    // Fetch our parameters. Note that this also takes care of initializing
    // uniqueness stuff, so later initialization of preinstall and unattend mode
    // don't ever have to know anything about the uniqueness stuff -- it's
    // totally transparent to them.
    //
    if (MiniSetup) {
        DWORD Err;

        //
        // Initialize unattended operation now.  In the case of MiniSetup,
        // we actually determine if we're unattended during UnattendInitialize.
        // We make that determination based on whether or not there's an
        // unattend file.
        //
        BEGIN_SECTION(L"Initialize unattended operation (mini-setup only)");
        UnattendInitialize();
        END_SECTION(L"Initialize unattended operation (mini-setup only)");

        //
        // Check to see if our unattend file specifies a test root certificate
        // to be installed via a "TestCert" entry.
        //
        BEGIN_SECTION(L"Checking for test root certificate (mini-setup only)");
        GetSystemDirectory(MyAnswerFile, MAX_PATH);
        pSetupConcatenatePaths(MyAnswerFile, WINNT_GUI_FILE, MAX_PATH, NULL);

        if(GetPrivateProfileString(WINNT_UNATTENDED,
                                   WINNT_U_TESTCERT,
                                   pwNull,
                                   MyAnswer,
                                   MyAnswerBufLen,
                                   MyAnswerFile)) {

            Err = SetupAddOrRemoveTestCertificate(MyAnswer, INVALID_HANDLE_VALUE);

            if(Err != NO_ERROR) {
                SetupDebugPrint2( L"SETUP: SetupAddOrRemoveTestCertificate(%ls) failed. Error = %d \n", MyAnswer, Err );
                SetuplogError(LogSevError,
                              SETUPLOG_USE_MESSAGEID,
                              MSG_LOG_SYSSETUP_CERT_NOT_INSTALLED,
                              MyAnswer,
                              Err,
                              NULL,
                              SETUPLOG_USE_MESSAGEID,
                              Err,
                              NULL,
                              NULL
                             );

                KillBillboard(Billboard);
                FatalError(MSG_LOG_BAD_UNATTEND_PARAM, WINNT_U_TESTCERT, WINNT_UNATTENDED);
            }
        }
        END_SECTION(L"Checking for test root certificate (mini-setup only)");

        BEGIN_SECTION(L"Reinstalling SLP files");
        GetDllCacheFolder(MyAnswer, MyAnswerBufLen);
        pSetupConcatenatePaths(MyAnswer,L"OEMBIOS.CAT",MyAnswerBufLen,NULL);
        if ( FileExists(MyAnswer, NULL) )
        {
            SetupInstallCatalog(MyAnswer);
        }
        END_SECTION(L"Reinstalling SLP files");

        PnpSeed = GetSeed();

        pSetupSetGlobalFlags(pSetupGetGlobalFlags()&~PSPGF_NO_VERIFY_INF);

        BEGIN_SECTION(L"Initializing code signing policies");
        InitializeCodeSigningPolicies(TRUE);
        END_SECTION(L"Initializing code signing policies");
    } else {
        //
        // Load up all the parameters.  Note that this also initializes the
        // unattend engine.
        //
        BEGIN_SECTION(L"Processing parameters from sif");
        if( !SpSetupProcessParameters(&Billboard) ) {
            KillBillboard(Billboard);
            FatalError(MSG_LOG_LEGACYINTERFACE,0,0);
        }
        END_SECTION(L"Processing parameters from sif");
    }

    //
    // see if we need to prop flag to supress driver prompts
    // this puts setupapi into full headless mode
    //
    if (UnattendMode == UAM_FULLUNATTENDED) {
        pSetupSetNoDriverPrompts(TRUE);
    }

    //
    // load the service pack dll if it is present
    //
    if( !MiniSetup ) {
        BEGIN_SECTION(L"Loading service pack (phase 1)");
        hModSvcPack = MyLoadLibraryWithSignatureCheck( SVCPACK_DLL_NAME );
        if (hModSvcPack) {
            pSvcPackCallbackRoutine = (PSVCPACKCALLBACKROUTINE)GetProcAddress( hModSvcPack, SVCPACK_CALLBACK_NAME );
        } else {
            DWORD LastError = GetLastError();
            if (LastError != ERROR_FILE_NOT_FOUND && LastError != ERROR_PATH_NOT_FOUND) {
                SetuplogError(LogSevWarning,
                              SETUPLOG_USE_MESSAGEID,
                              MSG_LOG_SVCPACK_DLL_LOAD_FAILED,
                              LastError, NULL,NULL
                              );
            }
        }

        CALL_SERVICE_PACK( SVCPACK_PHASE_1, 0, 0, 0 );
        END_SECTION(L"Loading service pack (phase 1)");
    }

#ifdef _X86_
    //
    // Win9x upgrade: do pre-migration work
    //

    if (Win95Upgrade && ! OobeSetup) {
        BEGIN_SECTION(L"Win9x premigration (Win9x only)");
        PreWin9xMigration();
        END_SECTION(L"Win9x premigration (Win9x only)");
    }

    //
    // Clean up drvlettr tag files from drvlettr mapping.
    //
    if( !MiniSetup ) {
        BEGIN_SECTION(L"Cleaning up hard drive tags");
        CleanUpHardDriveTags ();
        END_SECTION(L"Cleaning up hard drive tags");
    }

#endif

    TESTHOOK(518);

    //
    // Initialize preinstallation.
    //
    if( !MiniSetup ) {
        BEGIN_SECTION(L"Initializing OEM preinstall");
        InitializePreinstall();
        END_SECTION(L"Initializing OEM preinstall");
    } else {
        //
        // MiniSetup case...
        //
        //
        // Find out what platform we're on.  This will initalize
        // PlatformName.
        //
        SetUpProcessorNaming();
    }

    if( MiniSetup ) {
    //
    // MiniSetup case
    //
    DWORD   CMP_WaitNoPendingInstallEvents (IN DWORD dwTimeout);
    DWORD   rc, Type, dword;
    HKEY    hKey;
    WCHAR   Data[MAX_PATH];
    ULONG   Size = MAX_PATH;


        //
        // Mini-setup is _never_ an upgrade...
        //
        MYASSERT(!Upgrade);

        if( ProductType == PRODUCT_WORKSTATION) {
            if( GetProductFlavor() == 4) {
                SetupTitleStringId = IDS_TITLE_INSTALL_P;
            }
            else {
                SetupTitleStringId = IDS_TITLE_INSTALL_W;
            }
        }
        else
        {
            SetupTitleStringId = IDS_TITLE_INSTALL_S;
        }

        if(Unattended) {
            //
            // Initialize preinstallation.
            //
            UnattendMode = UAM_DEFAULTHIDE;
            BEGIN_SECTION(L"Initializing OEM preinstall (mini-setup only)");
            InitializePreinstall();
            END_SECTION(L"Initializing OEM preinstall (mini-setup only)");
        }

        // OOBE will have already completed PnP at this point.
        //
        if (! OobeSetup)
        {
            //
            //  Let the network component do some cleanup before we start the
            //  pnp stuff
            BEGIN_SECTION(L"Initial network setup cleanup (mini-setup only)");
            CallNetworkSetupBack("DoInitialCleanup");
            END_SECTION(L"Initial network setup cleanup (mini-setup only)");
        }

        BEGIN_SECTION(L"Opening syssetup.inf (mini-setup only)");
        SyssetupInf = SetupOpenInfFile(L"syssetup.inf",NULL,INF_STYLE_WIN4,NULL);
        END_SECTION(L"Opening syssetup.inf (mini-setup only)");

        if(SyssetupInf == INVALID_HANDLE_VALUE) {
            KillBillboard(Billboard);
            FatalError(MSG_LOG_SYSINFBAD,L"syssetup.inf",0,0);
        }

        //
        // Now go off and do the unattended locale stuff.  We need
        // to see if the user sent us any source path before we call
        // out to intl.cpl because he'll want to copy some files.
        // If there are no files, there's no need to even call
        // intl.cpl
        //

        BEGIN_SECTION(L"Unattended locale initialization (mini-setup only)");
        //
        // Pickup the answer file.
        //
        GetSystemDirectory(MyAnswerFile,MAX_PATH);
        pSetupConcatenatePaths(MyAnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);

        if( GetPrivateProfileString( TEXT("Unattended"),
                                     TEXT("InstallFilesPath"),
                                     pwNull,
                                     MyAnswer,
                                     MyAnswerBufLen,
                                     MyAnswerFile ) ) {
            if( lstrcmp( pwNull, MyAnswer ) ) {
                //
                // He sent us a source path.  We need to go ahead
                // and set SourcePath and LegacySourcePath here
                // because we'll be calling out to intl.cpl again
                // during the regional settings page.  So we might
                // as well do the forward work here.
                //
                lstrcpy( LegacySourcePath, MyAnswer );

                //
                // And this is good enough for MiniSetup.  We shouldn't
                // ever need SourcePath, but set it just to make sure.
                //
                lstrcpy( SourcePath, MyAnswer );

                wsprintf(
                    CmdLine,
                    L"/f:\"%s\" /s:\"%s\"",
                    MyAnswerFile,
                    LegacySourcePath
                    );

                InvokeControlPanelApplet(L"intl.cpl",L"",0,CmdLine);
            }
        } else {

            //
            // Set the strings from the registry.
            //

            //
            // Open HKLM\Software\Microsoft\Windows\CurrentVersion\Setup
            //
            rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup"),
                               0,
                               KEY_ALL_ACCESS,
                               &hKey );

            if(rc == NO_ERROR) {

                //
                // Retrieve the original value.
                //
                rc = RegQueryValueEx(hKey,
                                     TEXT("SourcePath"),
                                     NULL,
                                     &Type,
                                     (LPBYTE)&Data,
                                     &Size);

                if( rc == ERROR_SUCCESS ) {
                    //
                    // Got it.  Write it into SfcDisable.
                    //
                    lstrcpy( SourcePath, Data );

                    lstrcpy( LegacySourcePath, SourcePath );
                    pSetupConcatenatePaths( LegacySourcePath, PlatformName, MAX_PATH, NULL );
                }

                RegCloseKey(hKey);
            }

        }
        END_SECTION(L"Unattended local initialization (mini-setup only)");

        //
        // Now give the PnP engine time to finish before we
        // start the wizard.  Only do this if we're NOT doing
        // a -PnP though.  The only way to do that is to look
        // at the registry.  We can tell if that's been
        // requested by checking the value in:
        // HKLM\SYSTEM\SETUP\MiniSetupDoPnP.
        //
        BEGIN_SECTION(L"Waiting for PnP engine to finish");
        rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           L"SYSTEM\\SETUP",
                           0,
                           KEY_READ,
                           &hKey );

        if( rc == NO_ERROR ) {
            Size = sizeof(DWORD);
            rc = RegQueryValueEx( hKey,
                                  L"MiniSetupDoPnP",
                                  NULL,
                                  &Type,
                                  (LPBYTE)&dword,
                                  &Size );

            if( (rc == NO_ERROR) && (dword == 1) ) {
                PnPReEnumeration = TRUE;
            } else {
                //
                // Wait.
                //
                CMP_WaitNoPendingInstallEvents ( INFINITE );
                //
                // Update PnP drivers if specified from answerfile.
                //
                if ( GetPrivateProfileString( TEXT("Unattended"),
                                              TEXT("UpdateInstalledDrivers"),
                                              pwNull,
                                              MyAnswer,
                                              MyAnswerBufLen,
                                              MyAnswerFile )  )
                {
                    if ( 0 == _wcsicmp( TEXT("YES"), MyAnswer ) ) {
                        BEGIN_SECTION(L"Updating PnP Drivers");
                        UpdatePnpDeviceDrivers();
                        END_SECTION(L"Updating PnP Drivers");
                    }
                }
            }
        }
        END_SECTION(L"Waiting for PnP engine to finish");

    } else { // !MiniSetup

        //
        // fix problem with IntelliType Manager conflict.
        //
        RemoveMSKeyboardPtrPropSheet ();

        //
        // Fix Wordpad registry entry.
        //
        FixWordPadReg ();

        if(Unattended) {

            BEGIN_SECTION(L"Invoking external app (unattended only)");
            //
            // Set the current dir to %windir% -- to be consistent with
            // UserExecuteCmd
            //
            GetWindowsDirectory(PathBuffer,MAX_PATH);
            SetCurrentDirectory(PathBuffer);

            //
            // The program to execute is in 2 parts: DetachedProgram and Arguments.
            //
            if(Cmd = UnattendFetchString(UAE_PROGRAM)) {

                if(Cmd[0]) {

                    Args = UnattendFetchString(UAE_ARGUMENT);

                    ExpandEnvironmentStrings(Cmd,PathBuffer,MAX_PATH);
                    ExpandEnvironmentStrings(Args ? Args : L"",PathBuffer+MAX_PATH,3*MAX_PATH);

                    if(!InvokeExternalApplication(PathBuffer,PathBuffer+MAX_PATH,NULL)) {
                        SetuplogError(
                            LogSevError,
                            SETUPLOG_USE_MESSAGEID,
                            MSG_LOG_DETACHED_PROGRAM_FAILED,
                            PathBuffer,
                            NULL,NULL);
                    }

                    if(Args) {
                        MyFree(Args);
                    }
                }

                MyFree(Cmd);
            }
            END_SECTION(L"Invoking external app (unattended only)");
        }

        if(!Upgrade) {

            //
            // See if the user wants the profiles in a custom
            // location.
            //
            if (Unattended && UnattendAnswerTable[UAE_PROFILESDIR].Answer.String) {
                if (!SetProfilesDirInRegistry(UnattendAnswerTable[UAE_PROFILESDIR].Answer.String)) {
                    b = FALSE;
                }
            }

            //
            // In preinstall scenarios the OEM might "preload" the Default Users
            // or All Users profile with links. Currently the Profiles or Documents and Settings
            // directory is created in Winlogon as services.exe need to use it.
            //
            // We have a changed behavior with Whistler. If the OEM wants to overlay a Profiles directory on the system
            // then he needs to postfix it with $$. This is also true in the cases where he needs to provide a $$rename.txt.
            // That way winlogon will always create a true folder without .Windows appended. We then just come here and overlay
            //
            //
            if(Preinstall) {
            PSID    AdminSid = NULL;
            WCHAR   AdminAccountName[MAX_PATH];
            DWORD   dwsize;

                BEGIN_SECTION(L"Initialize user profiles (preinstall)");

                PreInstallProfilesDir = PathBuffer;

                if (Unattended && UnattendAnswerTable[UAE_PROFILESDIR].Answer.String) {
                    lstrcpy( Path, UnattendAnswerTable[UAE_PROFILESDIR].Answer.String );
                } else {
                    dwsize = MAX_PATH;
                    GetProfilesDirectory( Path, &dwsize );
                }

                lstrcpy( PreInstallProfilesDir, Path );
                lstrcat( PreInstallProfilesDir, L"$$" );


                //
                // Recreate it from scratch.
                //
                ProcessRegistryFiles( Billboard );
                InitializeProfiles( TRUE );

                //
                // Since the Profiles directory maybe (actually is) already created by Winlogon
                // we now just special case the "Documents and Settings$$" directory and merge it after InitializeProfiles.
                // This is hacky but will save the people who do a winnt.exe based PreInstall. They just
                // need to change their first directive to be a rename to the Profiles folder postfixed with a "$$".
                // WE will notice this special directory and do a merge with the current Profiles directory.
                //

                if(FileExists(PreInstallProfilesDir,NULL)) {
                    if( (Err = TreeCopy(PreInstallProfilesDir,Path)) == NO_ERROR ){
                        Delnode( PreInstallProfilesDir);
                    }else {

                        SetuplogError(LogSevWarning,
                          L"Setup (PreInstall) Failed to tree copy Profiles Dir %1 to %2 (TreeCopy failed %1!u!)\r\n",
                          0, PreInstallProfilesDir, Path, Err, NULL,NULL
                          );

                    }

                }

                END_SECTION(L"Initialize user profiles (preinstall)");
            }
        }


        if( !Preinstall ) {
            //
            //  Create/upgrade the registry
            //
            BEGIN_SECTION(L"Create/upgrade registry");
            ProcessRegistryFiles(Billboard);
            END_SECTION(L"Create/upgrade registry");

            //
            // Initialize user profiles
            //
            BEGIN_SECTION(L"Initializing user profiles");
            InitializeProfiles(TRUE);
            END_SECTION(L"Initializing user profiles");
        }



        //
        // Set fonts directory to system + read only. This causes
        // explorer to treat the directory specially and allows the font
        // folder to work.
        //
        GetWindowsDirectory(Path,MAX_PATH);
        pSetupConcatenatePaths(Path,L"FONTS",MAX_PATH,NULL);
        SetFileAttributes(Path,FILE_ATTRIBUTE_READONLY|FILE_ATTRIBUTE_SYSTEM);

        //
        // Copy some files.
        //
        if(!Upgrade) {
            BEGIN_SECTION(L"Copying System Files");
            if(!CopySystemFiles()) {
                b = FALSE;
            }
            END_SECTION(L"Copying System Files");
        } else {
            BEGIN_SECTION(L"Upgrading System Files");
            if(!UpgradeSystemFiles()) {
                b = FALSE;
            }
            END_SECTION(L"Upgrading System Files");
        }

        //
        // Install default language group
        //
        BEGIN_SECTION(L"Initializing regional settings");
        pSetupInitRegionalSettings(Billboard);
        END_SECTION(L"Initializing regional settings");
        wsprintf(
            CmdLine,
            L"/f:\"%s\" /s:\"%s\"",
            AnswerFile,
            LegacySourcePath
            );

        InvokeControlPanelApplet(L"intl.cpl",L"",0,CmdLine);

        //
        // If upgrade, start watching for changes to the user's
        // profile directory and the current user hive. These changes will
        // be propagated to the userdifr hive.
        // Need to be after InitializeProfiles so that Getspecialfolder is
        // pointing correctly.
        //
        if(Upgrade) {

            DWORD   reRet;
            MYASSERT( !OobeSetup );
            reRet = WatchStart(&WatchHandle);
            if(reRet != NO_ERROR) {
                WatchHandle = NULL;
            }
        } else {
            WatchHandle = NULL;
        }

        //
        // Start any requested accessibility utilities
        //
        SpStartAccessibilityUtilities(Billboard);

        //
        //  Let the network component do some cleanup before we start the pnp stuff
        //
        BEGIN_SECTION(L"Network setup initial cleanup");
        CallNetworkSetupBack("DoInitialCleanup");
        END_SECTION(L"Network setup initial cleanup");

        //
        // Do self registration of some components that may be needed during
        // setup.  This includes initialization of darwin.
        //
        BEGIN_SECTION(L"Registering Phase 1 Dlls");
        RegisterOleControls(MainWindowHandle,SyssetupInf,NULL,0,0,L"RegistrationPhase1");
        END_SECTION(L"Registering Phase 1 Dlls");

        // Call the Compatibility infs. ProcessCompatibilityInfs in turn calls
        // DoInstallComponentInfs with the unattend inf and section
        if( Upgrade )
        {
            BEGIN_SECTION(L"Processing compatibility infs (upgrade)");
            ProcessCompatibilityInfs( Billboard, INVALID_HANDLE_VALUE, 0 );
            END_SECTION(L"Processing compatibility infs (upgrade)");
        }


    } // else !MiniSetup

    TESTHOOK(519);

    //
    // We need to see if the user wants us to extend our partition.
    // We'll do it here in case the user gave us a partition that's
    // just big enough to fit on (i.e. we'd run out of disk space
    // later in gui-mode.  Some OEM will want this).
    //
    // Besides that, there isn't enough stuff in this function yet...
    //
    GetSystemDirectory(MyAnswerFile,MAX_PATH);
    pSetupConcatenatePaths(MyAnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);

    if( GetPrivateProfileString( TEXT("Unattended"),
                                 TEXT("ExtendOemPartition"),
                                 pwNull,
                                 MyAnswer,
                                 MyAnswerBufLen,
                                 MyAnswerFile ) ) {
        if( lstrcmp( pwNull, MyAnswer ) ) {
            //
            // Yep, he wants us to do it.  Go extend
            // the partition we installed on.
            //
            rc = wcstoul( MyAnswer, NULL, 10 );

            if( rc > 0 ) {
                //
                // 1 means size it maximally, any other non-0
                // number means extend by that many MB
                //
                BEGIN_SECTION(L"Extending partition");
                ExtendPartition( MyAnswerFile[0], (rc == 1) ? 0 : rc );
                END_SECTION(L"Extending partition");
            }
        }
    }

    if (!OobeSetup)
    {
        // OOBE will initialize external modules later.
        //
        // If OOBE is running, services.exe is waiting for OOBE to signal it
        // before initializing the Services Control Manager.  (This allows OOBE
        // to perform actions like change the computer name without affecting
        // services that rely on those actions.)  If initialization of an
        // external object waits for the SCM to start the system will deadlock.
        //
        InitializeExternalModules(
            TRUE,
            &OcManagerContext
            );

        TESTHOOK(520);
    }

    if( !OobeSetup ) {
        KillBillboard(Billboard);
        SetCursor( hCursor );
    }

#ifdef _OCM
    return(OcManagerContext);
#endif
}

VOID
InitializeExternalModules(
    BOOL                DoSetupStuff,
    PVOID*              pOcManagerContext   // optional
    )
{
    PVOID               OcManagerContext;

    pSetupWaitForScmInitialization();

    if (DoSetupStuff)
    {
        if (MiniSetup)
        {
            RunExternalUniqueness();
        }

        OcManagerContext = FireUpOcManager();
        if (NULL != pOcManagerContext)
        {
            *pOcManagerContext = OcManagerContext;
        }
    }
}


VOID
SetDefaultPowerScheme(
    VOID
    )

/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/

{
#define    AnswerBufLen (4*MAX_PATH)
WCHAR      AnswerFile[AnswerBufLen];
WCHAR      Answer[AnswerBufLen];
SYSTEM_POWER_CAPABILITIES   SysPwrCapabilities;
BOOLEAN    Enable;
NTSTATUS    Error;


    //
    // Figure out what the appropriate power scheme is and set it.
    //
    if (ProductType != PRODUCT_WORKSTATION) {
        //
        // Set to Always on (Servers)
        //
        SetupDebugPrint(L"Power scheme: server.");
        if (!SetActivePwrScheme(3, NULL, NULL)) {
            SetupDebugPrint1(L"SetActivePwrScheme failed.  Error = %d", GetLastError());
        } else {
            SetupDebugPrint(L"SetActivePwrScheme succeeded.");
        }
    } else if (IsLaptop()) {
        //
        // Set to Portable (Laptop)
        //
        SetupDebugPrint(L"Power scheme: laptop.");
        if (!SetActivePwrScheme(1, NULL, NULL)) {
            SetupDebugPrint1(L"SetActivePwrScheme failed.  Error = %d", GetLastError());
        } else {
            SetupDebugPrint(L"SetActivePwrScheme succeeded.");
        }
    } else {
        //
        // Set to Home/Office (Desktop)
        //
        SetupDebugPrint(L"Power scheme: desktop.");
        if (!SetActivePwrScheme(0, NULL, NULL)) {
            SetupDebugPrint1(L"SetActivePwrScheme failed.  Error = %d", GetLastError());
        } else {
            SetupDebugPrint(L"SetActivePwrScheme succeeded.");
        }
    }


    //
    // Now take care of any hibernation settings the user may be asking us
    // to apply via the unattend file.
    //

    //
    // Pickup the answer file.
    //
    GetSystemDirectory(AnswerFile,MAX_PATH);
    pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);

    //
    // Is Hibernation specified?
    //
    if( GetPrivateProfileString( WINNT_UNATTENDED,
                                 TEXT("Hibernation"),
                                 pwNull,
                                 Answer,
                                 AnswerBufLen,
                                 AnswerFile ) ) {

        if( _wcsicmp( L"NO", Answer ) == 0 ) {


            REGVALITEM RegistryItem[1];
            DWORD RegErr, d = 1;

            // Request the privilege to create a pagefile.  Oddly enough this is needed
            // to disable hibernation.
            //
            pSetupEnablePrivilege(SE_CREATE_PAGEFILE_NAME, TRUE);

            //
            // It is set to No.  Go ahead and disable hibernation.
            //
            Enable = FALSE;
            Error = NtPowerInformation ( SystemReserveHiberFile,
                                 &Enable,
                                 sizeof (Enable),
                                 NULL,
                                 0 );

            if (!NT_SUCCESS(Error)) {
                SetuplogError(LogSevWarning,
                          L"Setup failed to disable hibernation as specified by the answer file (NtPowerInformation failed %1!u!)\r\n",
                          0, Error, NULL,NULL
                          );
                return;
            }

            RegistryItem[0].Data = &d;
            RegistryItem[0].Size = sizeof(d);
            RegistryItem[0].Type = REG_DWORD;
            RegistryItem[0].Name = L"HibernationPreviouslyEnabled";

            RegErr = SetGroupOfValues(
                    HKEY_LOCAL_MACHINE,
                    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                    RegistryItem,
                    1
                    );

            if(RegErr != NO_ERROR){
                SetuplogError(LogSevWarning,
                          L"Setup failed to disable hibernation as specified by the answer file (SetGroupOfValues failed %1!u!)\r\n",
                          0, RegErr, NULL,NULL
                          );
            }
        }
    }
}


VOID
SetupAddAlternateComputerName(
    PWSTR AltComputerName
)
/*++

Routine Description:

    This function adds an alternate compture name on the specified transport.

Arguments:

    Transport - Transport to add the computer name on.

    AltComputerName - Alternate computer name to add

    EmulatedDomain - Emulated Domain to add computer name on

Return Value:

    None.

TransportName - type browdeb dn to get a list of transports.
                programatically, copy GetBrowserTransportList into here.
                Once I get the list, find the first one that contains "Netbt_tcpip"
                and use that string.

EmulatedDomain, just leave it null


--*/



{
#include <ntddbrow.h>
#define             LDM_PACKET_SIZE (sizeof(LMDR_REQUEST_PACKET)+(LM20_CNLEN+1)*sizeof(WCHAR))
HANDLE              BrowserHandle;
UNICODE_STRING      DeviceName;
IO_STATUS_BLOCK     IoStatusBlock;
OBJECT_ATTRIBUTES   ObjectAttributes;
NTSTATUS            Status;
PLMDR_REQUEST_PACKET RequestPacket = NULL;
LPBYTE              Where;
PLMDR_TRANSPORT_LIST TransportList = NULL,
                     TransportEntry = NULL;

extern NET_API_STATUS
BrDgReceiverIoControl(
    IN  HANDLE FileHandle,
    IN  ULONG DgReceiverControlCode,
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  ULONG DrpSize,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG Information OPTIONAL
    );

extern NET_API_STATUS
DeviceControlGetInfo(
    IN  HANDLE FileHandle,
    IN  ULONG DeviceControlCode,
    IN  PVOID RequestPacket,
    IN  ULONG RequestPacketLength,
    OUT LPVOID *OutputBuffer,
    IN  ULONG PreferedMaximumLength,
    IN  ULONG BufferHintSize,
    OUT PULONG Information OPTIONAL
    );


    //
    // Open a browser handle.
    //
    RtlInitUnicodeString( &DeviceName, DD_BROWSER_DEVICE_NAME_U);
    InitializeObjectAttributes( &ObjectAttributes,
                                &DeviceName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    Status = NtOpenFile( &BrowserHandle,
                         SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT );

    if( NT_SUCCESS(Status) ) {

        RequestPacket = MyMalloc( LDM_PACKET_SIZE );
        if( !RequestPacket ) {
            NtClose( BrowserHandle );
            return;
        }

        ZeroMemory( RequestPacket, LDM_PACKET_SIZE );

        //
        // Get a transport name.
        //
        RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;

        RequestPacket->Type = EnumerateXports;

        RtlInitUnicodeString(&RequestPacket->TransportName, NULL);
        RtlInitUnicodeString(&RequestPacket->EmulatedDomainName, NULL);

        Status = DeviceControlGetInfo( BrowserHandle,
                                       IOCTL_LMDR_ENUMERATE_TRANSPORTS,
                                       RequestPacket,
                                       LDM_PACKET_SIZE,
                                       (PVOID *)&TransportList,
                                       0xffffffff,
                                       4096,
                                       NULL );

        if( NT_SUCCESS(Status) ) {

            //
            // Nuke the transport name in the request packet just to be safe.
            //
            RequestPacket->TransportName.Buffer = NULL;

            //
            // Now figure out which entry in the transport list is the
            // one we want.
            //
            TransportEntry = TransportList;
            while( TransportEntry != NULL ) {
                _wcslwr( TransportEntry->TransportName );
                if( wcsstr(TransportEntry->TransportName, L"netbt_tcpip") ) {
                    //
                    // Got it.
                    //
                    RequestPacket->TransportName.Buffer = TransportEntry->TransportName;
                    RequestPacket->TransportName.Length = (USHORT)TransportEntry->TransportNameLength;
                    break;
                }

                //
                // Look at the next entry.
                //
                if (TransportEntry->NextEntryOffset == 0) {
                    TransportEntry = NULL;
                } else {
                    TransportEntry = (PLMDR_TRANSPORT_LIST)((PCHAR)TransportEntry+TransportEntry->NextEntryOffset);
                }
            }

            if( RequestPacket->TransportName.Buffer ) {

                //
                // Prepare a packet to send him.
                //
                RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION;
                RtlInitUnicodeString(&RequestPacket->EmulatedDomainName, NULL);
                RequestPacket->Parameters.AddDelName.Type = AlternateComputerName;
                RequestPacket->Parameters.AddDelName.DgReceiverNameLength = min( wcslen(AltComputerName)*sizeof(WCHAR),
                                                                                 LM20_CNLEN*sizeof(WCHAR));
                wcsncpy(RequestPacket->Parameters.AddDelName.Name, AltComputerName,LM20_CNLEN+1);
                RequestPacket->Parameters.AddDelName.Name[LM20_CNLEN] = (WCHAR)L'\0';
                Where = ((LPBYTE)(RequestPacket->Parameters.AddDelName.Name)) +
                        RequestPacket->Parameters.AddDelName.DgReceiverNameLength +
                        sizeof(WCHAR);

                Status = BrDgReceiverIoControl( BrowserHandle,
                                                IOCTL_LMDR_ADD_NAME_DOM,
                                                RequestPacket,
                                                (DWORD)(Where - (LPBYTE)RequestPacket),
                                                NULL,
                                                0,
                                                NULL );
            }

        }

        MyFree( RequestPacket );

        NtClose( BrowserHandle );
    }
}



BOOL
RestoreBootTimeout(
    VOID
    )
{
    WCHAR       AnswerFile[MAX_PATH];
    WCHAR       Answer[50];
    DWORD       Val;


    //
    // Pickup the answer file.
    //
    GetSystemDirectory(AnswerFile,MAX_PATH);
    pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);

    //
    // Is boot timeout specified?
    //
    if( GetPrivateProfileString( TEXT("SetupData"),
                                 WINNT_S_OSLOADTIMEOUT,
                                 pwNull,
                                 Answer,
                                 sizeof(Answer)/sizeof(TCHAR),
                                 AnswerFile ) ) {

        if( lstrcmp( pwNull, Answer ) ) {
            //
            // We got an answer.  If it's valid, then set it.
            //
            Val = wcstoul(Answer,NULL,10);
        } else {
            Val = 30;
        }
    } else {
        Val = 30;
    }

    return ChangeBootTimeout(Val);
}



VOID
PrepareForNetSetup(
    VOID
    )

/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/

{
    BOOL b = TRUE;


    //
    // Create Windows NT software key entry
    //
    // if(!MiniSetup && !CreateWindowsNtSoftwareEntry(TRUE)) {
    //     b = FALSE;
    // }
    //
    // Create InstallDate value entry in Windows NT software key.
    // This has to happen after the Date/Time wizard page was executed, when the user can
    // no longer go back to that page.
    //
    if(!CreateInstallDateEntry()) {
        b = FALSE;
    }
    if(!SetProductIdInRegistry()) {
        b = FALSE;
    }
    if(!StoreNameOrgInRegistry( NameOrgName, NameOrgOrg )) {
        b = FALSE;
    }
    if(!MiniSetup && !SetEnabledProcessorCount()) {
        b = FALSE;
    }

    if( (!MiniSetup && !SetAccountsDomainSid(0,Win32ComputerName)) ||
        (!SetComputerNameEx(ComputerNamePhysicalDnsHostname, ComputerName)) ) {

        //
        // Set account domain sid, as well as the computer name.
        // Also create the sam event that SAM will use to signal us
        // when it's finished initializing.
        // Any failures here are fatal.
        //

        FatalError(MSG_LOG_SECURITY_CATASTROPHE,0,0);
    }

    if( !RestoreBootTimeout() ){
        SetupDebugPrint( L"Setup: (non-critical error) Failed to restore boot timeout values\n" );
    }



#ifndef _WIN64
    //
    // Install netdde
    //
    if(!InstallNetDDE()) {
        b = FALSE;
    }
#endif
    SetUpDataBlock();

    //
    // In the case of MiniSetup, we're about to go into the
    // networking wizard pages.  Remember though that lots of
    // our default components have already been installed.  This
    // means that they won't be re-installed, which means the
    // related services won't be started.  Network setup isn't
    // smart enough to check to see if these services are started
    // before proceeding (which results in his failure).  To get
    // around that, we'll start the services right here.
    //
    // Currently, here's what we need to start:
    // tcpip
    // dhcp
    // dnscache
    // Netman
    // lmhosts
    // LanmanWorkstation
    //
    if( MiniSetup ) {

        SetupStartService( L"tcpip", FALSE );
        SetupStartService( L"dhcp", FALSE );
        SetupStartService( L"dnscache", FALSE );
        SetupStartService( L"Netman", FALSE );
        SetupStartService( L"lmhosts", FALSE );
        SetupStartService( L"LanmanWorkstation", TRUE );

        //
        // HACK: fix up the computername before we go off and
        // try and join a domain.
        //
        SetupAddAlternateComputerName( ComputerName );
    }


    if(!b) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_PREPARE_NET_FAILED,
            NULL,NULL);
    }
}


VOID
PrepareForNetUpgrade(
    VOID
    )
{
    BOOL b = TRUE;


    if( !RestoreBootTimeout() ){
        SetupDebugPrint( L"Setup: (non-critical error) Failed to restore boot timeout values\n" );
    }

    // if(!CreateWindowsNtSoftwareEntry(TRUE)) {
    //     b = FALSE;
    // }
    //
    // Create InstallDate value entry in Windows NT software key.
    // This has to happen after the Date/Time wizard page was executed, when the user can
    // no longer go back to that page.
    //
    if(!CreateInstallDateEntry()) {
        b = FALSE;
    }
    if(!SetEnabledProcessorCount()) {
        b = FALSE;
    }

    SetUpDataBlock();

    if(!b) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_PREPARE_NET_FAILED,
            NULL,NULL);
    }
}


VOID
ProcessShellUnattendSettings(
    VOID
    )
{
    WCHAR PathBuffer[MAX_PATH];

    if (GetSystemDirectory(PathBuffer,MAX_PATH) == 0) {
        MYASSERT(FALSE);
        return;
    }

    pSetupConcatenatePaths(PathBuffer, WINNT_GUI_FILE, MAX_PATH, NULL);

    SetupShellSettings(PathBuffer, TEXT("Shell"));
}

BOOL
SetupShellSettings(
    LPWSTR lpszUnattend,
    LPWSTR lpszSection
    )
{
    BOOL  bRet = TRUE;
    DWORD dwError;
    WCHAR Answer[MAX_PATH];

    // Check the "DefaultStartPanelOff" key to see if the user wants to have the
    // start panel off by default
    if( GetPrivateProfileString( lpszSection,
                                 TEXT("DefaultStartPanelOff"),
                                 pwNull,
                                 Answer,
                                 MAX_PATH,
                                 lpszUnattend) ) {
        if ( ( lstrcmpi( pwYes, Answer ) == 0 ) || ( lstrcmpi( pwNo, Answer ) == 0 ) ) {
            HKEY hkStartPanel;

            if ( RegCreateKey( HKEY_LOCAL_MACHINE,
                               TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\StartMenu\\StartPanel"),
                               &hkStartPanel ) == ERROR_SUCCESS ) {
                DWORD dwData;

                if ( lstrcmpi( pwYes, Answer ) == 0 )
                {
                    dwData = 1;
                }
                else
                {
                    dwData = 0;
                }

                dwError = RegSetValueEx( hkStartPanel,
                                         TEXT("DefaultStartPanelOff"),
                                         0,
                                         REG_DWORD,
                                         (BYTE*)&dwData,
                                         sizeof(dwData) );

                if (dwError != ERROR_SUCCESS)
                {
                    bRet = FALSE;
                    SetuplogError(LogSevWarning,
                                  L"SETUP: ProcessShellUnattendSettings() failed to set DefaultStartPanelOff reg value!\r\n",
                                  0, NULL, NULL);
                }

                RegCloseKey( hkStartPanel );
            }
            else
            {
                bRet = FALSE;
                SetuplogError(LogSevWarning,
                              L"SETUP: ProcessShellUnattendSettings() failed in to create StartPanel reg key!\r\n",
                              0, NULL, NULL);
            }
        }
    }

    // Check the "DefaultThemesOff" key to see if the user wants to not apply themes by default
    if( GetPrivateProfileString( lpszSection,
                                 TEXT("DefaultThemesOff"),
                                 pwNull,
                                 Answer,
                                 MAX_PATH,
                                 lpszUnattend) ) {
        if ( ( lstrcmpi( pwYes, Answer ) == 0 ) || ( lstrcmpi( pwNo, Answer ) == 0 ) ) {
            HKEY hkThemes;

            if ( RegCreateKey( HKEY_LOCAL_MACHINE,
                               TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Themes"),
                               &hkThemes ) == ERROR_SUCCESS ) {
                BOOL bYes;

                if ( lstrcmpi( pwYes, Answer ) == 0)
                {
                    bYes = TRUE;
                }
                else
                {
                    bYes = FALSE;
                }

                dwError = RegSetValueEx( hkThemes,
                                         TEXT("NoThemeInstall"),
                                         0,
                                         REG_SZ,
                                         (BYTE*)(bYes ? TEXT("TRUE") : TEXT("FALSE")),  // needs to be reg_sz "TRUE" or "FALSE" string
                                         bYes ? sizeof(TEXT("TRUE")) : sizeof(TEXT("FALSE")) );

                if (dwError != ERROR_SUCCESS)
                {
                    bRet = FALSE;
                    SetuplogError(LogSevWarning,
                                  L"SETUP: ProcessShellUnattendSettings() failed to set NoThemeInstall reg value!\r\n",
                                  0, NULL, NULL);
                }

                RegCloseKey( hkThemes );
            }
            else
            {
                bRet = FALSE;
                SetuplogError(LogSevWarning,
                              L"SETUP: ProcessShellUnattendSettings() failed in to create Themes key!\r\n",
                              0, NULL, NULL);
            }
        }
    }

    // See if the user has specified a "CustomInstalledTheme" which we will apply by default to all users
    if( GetPrivateProfileString( lpszSection,
                                 TEXT("CustomDefaultThemeFile"),
                                 pwNull,
                                 Answer,
                                 MAX_PATH,
                                 lpszUnattend) ) {
        if ( lstrcmpi( pwNull, Answer ) != 0 ) {
            HKEY hkThemes;

            if ( RegCreateKey( HKEY_LOCAL_MACHINE,
                               TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Themes"),
                               &hkThemes ) == ERROR_SUCCESS ) {
                dwError = RegSetValueEx( hkThemes,
                                         TEXT("CustomInstallTheme"),
                                         0,
                                         REG_EXPAND_SZ,
                                         (BYTE*)Answer,
                                         (lstrlen(Answer) + 1) * sizeof(TCHAR));

                if (dwError != ERROR_SUCCESS)
                {
                    bRet = FALSE;
                    SetuplogError(LogSevWarning,
                                  L"SETUP: ProcessShellUnattendSettings() failed to set CustomInstallTheme reg value!\r\n",
                                  0, NULL, NULL);
                }

                RegCloseKey( hkThemes );
            }
            else
            {
                bRet = FALSE;
                SetuplogError(LogSevWarning,
                              L"SETUP: ProcessShellUnattendSettings() failed in to create Themes key!\r\n",
                              0, NULL, NULL);
            }
        }
    }

    return bRet;
}


VOID
ConfigureSetup(
    IN HWND     hProgress,
    IN ULONG    StartAtPercent,
    IN ULONG    StopAtPercent
    )
{
    #define AnswerBufLen (4*MAX_PATH)
    UINT GaugeRange;
    BOOL b;
    DWORD dwSize;
    WCHAR TempString[MAX_PATH];
    WCHAR adminName[MAX_USERNAME+1];
    WCHAR AnswerFile[AnswerBufLen];
    WCHAR Answer[AnswerBufLen];

    OSVERSIONINFOEXW osvi;
    BOOL fPersonalSKU = FALSE;

    //
    // Determine if we are installing Personal SKU
    //

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);
    GetVersionEx((OSVERSIONINFOW*)&osvi);

    fPersonalSKU = ( osvi.wProductType == VER_NT_WORKSTATION && (osvi.wSuiteMask & VER_SUITE_PERSONAL));

    //
    // Initialize the progress indicator control.
    //
    if( !OobeSetup ) {
        GaugeRange = (17*100/(StopAtPercent-StartAtPercent));
        SendMessage(hProgress, WMX_PROGRESSTICKS, 17, 0);
        SendMessage(hProgress,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
        SendMessage(hProgress,PBM_SETPOS,GaugeRange*StartAtPercent/100,0);
        SendMessage(hProgress,PBM_SETSTEP,1,0);
    }

    MYASSERT(!Upgrade);
    b = TRUE;


    if(!MiniSetup ) {

        //
        // Create config.nt/autoexec.nt.
        //
        if( !ConfigureMsDosSubsystem() ) {
            SetupDebugPrint( L"SETUP: ConfigureMsDosSubsystem failed" );
            b = FALSE;
        }


        //
        // Make the appropriate entries for wow.
        //
        SendMessage(hProgress,PBM_STEPIT,0,0);
        if( !MakeWowEntry() ) {
            SetupDebugPrint( L"SETUP: MakeWowEntry failed" );
            b = FALSE;
        }


        SendMessage(hProgress,PBM_STEPIT,0,0);
        CallSceConfigureServices();


        //
        // Enable and start the spooler.
        //
        SendMessage(hProgress,PBM_STEPIT,0,0);
        if( !MyChangeServiceStart(szSpooler,SERVICE_AUTO_START) ) {
            SetupDebugPrint( L"SETUP: MyChangeServiceStart failed" );
            b = FALSE;
        }


        if( !StartSpooler() ) {
            SetupDebugPrint( L"SETUP: StartSpooler failed" );
            b = FALSE;
        }


        //
        // Set up program groups.
        //
        SendMessage(hProgress,PBM_STEPIT,0,0);
        if(!CreateStartMenuItems(SyssetupInf)) {
            SetupDebugPrint( L"SETUP: CreateStartMenuItems failed" );
            b = FALSE;
        }

        //
        // Change some service start values.
        //
        SendMessage(hProgress,PBM_STEPIT,0,0);
        if(!MyChangeServiceStart(L"EventLog",SERVICE_AUTO_START)) {
            SetupDebugPrint( L"SETUP: MyChangeServiceStart(EventLog) failed" );
            b = FALSE;
        }
        if(!MyChangeServiceStart(L"ClipSrv",SERVICE_DEMAND_START)) {
            SetupDebugPrint( L"SETUP: MyChangeServiceStart(ClipSrv) failed" );
            b = FALSE;
        }
        if(!MyChangeServiceStart(L"NetDDE",SERVICE_DEMAND_START)) {
            SetupDebugPrint( L"SETUP: MyChangeServiceStart(NetDDE) failed" );
            b = FALSE;
        }
        if(!MyChangeServiceStart(L"NetDDEdsdm",SERVICE_DEMAND_START)) {
            SetupDebugPrint( L"SETUP: MyChangeServiceStart(NetDDEdsdm) failed" );
            b = FALSE;
        }

        // Moved Admin Password code to wizard

        SendMessage(hProgress,PBM_STEPIT,0,0);

    }



    //
    // For OobeSetup, OOBE has just run and manage new account creation
    //

    if ( fPersonalSKU && !OobeSetup )
    {
        WCHAR    OwnerName[MAX_USERNAME+1];
        NTSTATUS OwnerCreated = STATUS_UNSUCCESSFUL;
        WCHAR    PathBuffer[MAX_PATH];

        if (LoadString(MyModuleHandle,IDS_OWNER,OwnerName,MAX_USERNAME+1))
        {
            OwnerCreated = CreateLocalAdminAccount(OwnerName,TEXT(""),NULL);

            if(OwnerCreated){
                DeleteOnRestartOfGUIMode(OwnerName);
            }

            SetupDebugPrint2(
                L"SETUP: CreateLocalAdminAccount %s NTSTATUS(%d)",
                OwnerName,
                OwnerCreated
                );
        }
        else
        {
            SetupDebugPrint( L"SETUP: Failed LoadString on IDS_OWNER" );
        }

        if (GetSystemDirectory(PathBuffer, MAX_PATH))
        {
            pSetupConcatenatePaths(
                PathBuffer,
                TEXT("oobe\\oobeinfo.ini"),
                MAX_PATH,
                NULL
                );

            WritePrivateProfileString(
                TEXT("Options"),
                TEXT("RemoveOwner"),
                (OwnerCreated == STATUS_SUCCESS) ? TEXT("1") : TEXT("0"),
                PathBuffer
                );
        }
    }

    //
    // Don't bother with the Autologon stuff if the user provided an encrypted password in the unattend file
    //

    if(  !fPersonalSKU || Win95Upgrade ){

        if( !EncryptedAdminPasswordSet ){

            if (Unattended && UnattendAnswerTable[UAE_AUTOLOGON].Answer.String &&
                lstrcmpi(UnattendAnswerTable[UAE_AUTOLOGON].Answer.String,pwYes)==0) {

                if (fPersonalSKU) {
                    if (!LoadString(MyModuleHandle,IDS_OWNER,adminName,MAX_USERNAME+1)) {
                        b = FALSE;
                    }
                } else {
                    GetAdminAccountName( adminName );
                }
                if (b && !SetAutoAdminLogonInRegistry(adminName,AdminPassword)) {
                    SetupDebugPrint( L"SETUP: SetAutoAdminLogonInRegistry failed" );
                    b = FALSE;
                }
            }
        }
    }

#ifdef DOLOCALUSER
    if(CreateUserAccount) {
        if(!CreateLocalUserAccount(UserName,UserPassword,NULL)) {
            SetupDebugPrint( L"SETUP: CreateLocalUserAccount failed" );
            b = FALSE;
        }
        else {
            DeleteOnRestartOfGUIMode(UserName);
        }
    }
#endif


    //
    // Set temp/tmp variables.
    //

    if(!MiniSetup){
        SendMessage(hProgress,PBM_STEPIT,0,0);
        lstrcpy(TempString,L"%SystemRoot%\\TEMP");
        SetEnvironmentVariableInRegistry(L"TEMP",TempString,TRUE);
        SetEnvironmentVariableInRegistry(L"TMP",TempString,TRUE);


#ifdef _X86_
        //
        // Set NPX emulation state.
        //
        if( !SetNpxEmulationState() ) {
            SetupDebugPrint( L"SETUP: SetNpxEmulationState failed" );
            b = FALSE;
        }
#endif // def _X86_


        BEGIN_SECTION(L"Loading service pack (phase 4)");
        CALL_SERVICE_PACK( SVCPACK_PHASE_4, 0, 0, 0 );
        END_SECTION(L"Loading service pack (phase 4)");
    }


    //
    // Call the network setup back to handle Internet Server issues.
    //
    BEGIN_SECTION(L"Network setup handling Internet Server issues");
    SendMessage(hProgress,PBM_STEPIT,0,0);
    CallNetworkSetupBack(NETSETUPINSTALLSOFTWAREPROCNAME);
    if (!MiniSetup && RemoteBootSetup) {
        SetStartTypeForRemoteBootDrivers();
    }
    END_SECTION(L"Network setup handling Internet Server issues");


    //
    // Stamp build number
    //
    if( !MiniSetup ) {
        SendMessage(hProgress,PBM_STEPIT,0,0);
        StampBuildNumber();

        //
        // Set some misc stuff in win.ini
        //
        if( !WinIniAlter1() ) {
            SetupDebugPrint( L"SETUP: WinIniAlter1 failed" );
            b = FALSE;
        }

        //
        // Fonts.
        //
        SendMessage(hProgress,PBM_STEPIT,0,0);
        pSetupMarkHiddenFonts();

        //
        // Set up pagefile and crashdump.
        //
        BEGIN_SECTION(L"Setting up virtual memory");

        SendMessage(hProgress,PBM_STEPIT,0,0);

        if( !SetUpVirtualMemory() ) {
            SetupDebugPrint( L"SETUP: SetUpVirtualMemory failed" );
            b = FALSE;
        }
        END_SECTION(L"Setting up virtual memory");


        if( !SetShutdownVariables() ) {
            SetupDebugPrint( L"SETUP: SetShutdownVariables failed" );
            b = FALSE;
        }

        //
        // run any programs
        //
        BEGIN_SECTION(L"Processing [RunPrograms] section");
        RunSetupPrograms(SyssetupInf,L"RunPrograms");
        END_SECTION(L"Processing [RunPrograms] section");

        //
        //Brand IE for clean unattended installs.
        //This should be called before the default user hive is saved.
        //
        BrandIE();

    } else {
        //
        // See if it's okay to reset the pagefile for the MiniSetup case.
        //
        GetSystemDirectory(AnswerFile,MAX_PATH);
        pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);
        GetPrivateProfileString( TEXT("Unattended"),
                                 TEXT("KeepPageFile"),
                                 pwNull,
                                 Answer,
                                 AnswerBufLen,
                                 AnswerFile );
        if( !lstrcmp( pwNull, Answer ) ) {

            if( !SetUpVirtualMemory() ) {
                SetupDebugPrint( L"SETUP: SetUpVirtualMemory failed" );
                b = FALSE;
            }
        }
    }

    //
    // Set the default power scheme.  Note that this must be done before saving
    // the userdef hive.
    //
    if( !OobeSetup ) {
        SendMessage(hProgress,PBM_STEPIT,0,0);
    }
    SetDefaultPowerScheme();


    //
    // There's nothing specific to preinstall about cmdlines.txt.
    // In retail cases the file simply won't exit. Calling this in
    // all cases simplifies things for some people out there.
    //
    // We need to do this here so that if the user has commands
    // that populate the user's hive, they'll get pushed down
    // into default hive.
    //
    if(!ExecutePreinstallCommands()) {
        SetupDebugPrint( L"ExecutePreinstallCommands() failed" );
    }


    //
    // Save off the userdef hive. Don't change the ordering here
    // unless you know what you're doing!
    //
    if( !MiniSetup ) {
        BEGIN_SECTION(L"Saving hives");
        dwSize = MAX_PATH;
        SendMessage(hProgress,PBM_STEPIT,0,0);
        if (GetDefaultUserProfileDirectory(TempString, &dwSize)) {
            pSetupConcatenatePaths(TempString,L"\\NTUSER.DAT",MAX_PATH,NULL);
            if(!SaveHive(HKEY_USERS,L".DEFAULT",TempString,REG_STANDARD_FORMAT)) { // standard format as it can be used for roaming
                SetupDebugPrint( L"SETUP: SaveHive failed" );
                b = FALSE;
            }
            SetFileAttributes (TempString, FILE_ATTRIBUTE_HIDDEN);
        } else {
            SetupDebugPrint( L"SETUP: GetDefaultUserProfileDirectory failed" );
            b = FALSE;
        }
        END_SECTION(L"Saving hives");
    } else {
        BEGIN_SECTION(L"Fixing up hives");
        //
        // This is the MiniSetup case.  We're going to surgically
        // place some values from the default hive into all the
        // user profiles.
        //
        FixupUserHives();
        END_SECTION(L"Fixing up hives");
    }


    //
    // Set wallpaper and screen saver.
    //
    if( !MiniSetup ) {

        SendMessage(hProgress,PBM_STEPIT,0,0);
        if( !SetDefaultWallpaper() ) {
            SetupDebugPrint( L"SETUP: SetDefaultWallpaper failed" );
            b = FALSE;
        }

        if( !SetLogonScreensaver() ) {
            SetupDebugPrint( L"SETUP: SetLogonScreensaver failed" );
            b = FALSE;
        }

        BEGIN_SECTION(L"Copying optional directories");
        if( !CopyOptionalDirectories() ) {
            SetupDebugPrint( L"SETUP: CopyOptionalDirectories failed" );
            b = FALSE;
        }
        END_SECTION(L"Copying optional directories");

        SendMessage(hProgress,PBM_STEPIT,0,0);

        if(!b) {
            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FINISH_SETUP_FAILED,
                NULL,NULL);
        }

    }
}


VOID
ConfigureUpgrade(
    IN HWND     hProgress,
    IN ULONG    StartAtPercent,
    IN ULONG    StopAtPercent
    )
{
    UINT GaugeRange;
    BOOL b;
    DWORD dwSize;
    WCHAR TempString[MAX_PATH];
    DWORD DontCare;
    DWORD VolumeFreeSpaceMB[26];
    DWORD TType, TLength, ret;
    PWSTR TData;

    //
    // Initialize the progress indicator control.
    //
    GaugeRange = (12*100/(StopAtPercent-StartAtPercent));
    SendMessage(hProgress, WMX_PROGRESSTICKS, 12, 0);
    SendMessage(hProgress,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
    SendMessage(hProgress,PBM_SETPOS,GaugeRange*StartAtPercent/100,0);
    SendMessage(hProgress,PBM_SETSTEP,1,0);

    MYASSERT(Upgrade);
    b = TRUE;


    //
    // Create config.sys/autoexec.bat/msdos.sys/io.sys, if they
    // don't already exist
    //
    SendMessage(hProgress,PBM_STEPIT,0,0);
    if(!ConfigureMsDosSubsystem()) {
        SetupDebugPrint( L"SETUP: ConfigureMsDosSubsystem failed" );
        b = FALSE;
    }

    if(!FixQuotaEntries()) {
        SetupDebugPrint( L"SETUP: FixQuotaEntries failed" );
        b = FALSE;
    }
    if(!InstallOrUpgradeFonts()) {
        SetupDebugPrint( L"SETUP: InstallOrUpgradeFonts failed" );
        b = FALSE;
    }
    pSetupMarkHiddenFonts();
    //
    //  Restore the page file information saved during textmode setup.
    //  Ignore any error, since there is nothing that the user can do.
    //
    SendMessage(hProgress,PBM_STEPIT,0,0);
    SetUpVirtualMemory();
    if(!SetShutdownVariables()) {
        SetupDebugPrint( L"SETUP: SetShutdownVariables failed" );
        b = FALSE;
    }

    //
    // Get list of free space available on each hard drive.  We don't care
    // about this, but it has the side effect of deleting all pagefiles,
    // which we do want to do.
    //
    SendMessage(hProgress,PBM_STEPIT,0,0);
    BuildVolumeFreeSpaceList(VolumeFreeSpaceMB);

    //
    // Upgrade program groups.
    //
    SendMessage(hProgress,PBM_STEPIT,0,0);
    if(!UpgradeStartMenuItems(SyssetupInf)) {
        SetupDebugPrint( L"SETUP: UpgradeStartMenuItems failed" );
        b = FALSE;
    }

    SendMessage(hProgress,PBM_STEPIT,0,0);
    if(!MyChangeServiceStart(szSpooler,SERVICE_AUTO_START)) {
        SetupDebugPrint( L"SETUP: MyChangeServiceStart failed" );
        b = FALSE;
    }

    SetUpDataBlock();
    DontCare = UpgradePrinters();
    if(DontCare != NO_ERROR) {
        SetupDebugPrint( L"SETUP: UpgradePrinters failed" );
        b = FALSE;
    }

    SendMessage(hProgress,PBM_STEPIT,0,0);
    if( !UpdateServicesDependencies(SyssetupInf) ) {
        SetupDebugPrint( L"SETUP: UpdateServicesDependencies failed" );
        b = FALSE;
    }

    //
    // Set temp/tmp variables for upgrades.
    //
    SendMessage(hProgress,PBM_STEPIT,0,0);

    // Look for Environment variable TEMP (we assume that TEMP and TMP appear together)
    // Will not be present on NT4 upgrades

    ret = QueryValueInHKLM( L"System\\CurrentControlSet\\Control\\Session Manager\\Environment",
                      L"TEMP",
                      &TType,
                      (PVOID)&TData,
                      &TLength);

    if( ret != NO_ERROR ){  //only when the TEMP variable is not defined (<=NT4 upgrades)
        lstrcpy(TempString,L"%SystemDrive%\\TEMP");  // On NT4 use %SystemDrive%
        SetEnvironmentVariableInRegistry(L"TEMP",TempString,TRUE);
        SetEnvironmentVariableInRegistry(L"TMP",TempString,TRUE);

    }



#ifdef _X86_
    //
    // Set NPX emulation state.
    //
    if(!SetNpxEmulationState()) {
        SetupDebugPrint( L"SETUP: SetNpxEmulationState failed" );
        b = FALSE;
    }
#endif // def _X86_

    SendMessage(hProgress,PBM_STEPIT,0,0);
    if(!SetProductIdInRegistry()) {
        SetupDebugPrint( L"SETUP: SetProductIdInRegistry failed" );
        b = FALSE;
    }

    if( !MiniSetup ) {
        BEGIN_SECTION(L"Loading service pack (phase 4)");
        CALL_SERVICE_PACK( SVCPACK_PHASE_4, 0, 0, 0 );
        END_SECTION(L"Loading service pack (phase 4)");
    }

    CallNetworkSetupBack(NETSETUPINSTALLSOFTWAREPROCNAME);
    if (RemoteBootSetup) {
        SetStartTypeForRemoteBootDrivers();
    }

    //
    // Stamp build number
    //

    SendMessage(hProgress,PBM_STEPIT,0,0);
    StampBuildNumber();

    //
    //  UpgradeRegistrySecurity();
    //

    //
    // Set the default power scheme.  Note that this must be done before saving
    // the userdef hive.
    //
    SendMessage(hProgress,PBM_STEPIT,0,0);
    SetDefaultPowerScheme();

    //
    // Save off the userdef hive. Don't change the ordering here
    // unless you know what you're doing!
    //
    SendMessage(hProgress,PBM_STEPIT,0,0);

    dwSize = MAX_PATH;
    if (GetDefaultUserProfileDirectory(TempString, &dwSize)) {
        pSetupConcatenatePaths(TempString,L"\\NTUSER.DAT",MAX_PATH,NULL);
        if(!SaveHive(HKEY_USERS,L".DEFAULT",TempString,REG_STANDARD_FORMAT)) { // standard format as it can be used for roaming
            SetupDebugPrint( L"SETUP: SaveHive failed" );
            b = FALSE;
        }
        SetFileAttributes (TempString, FILE_ATTRIBUTE_HIDDEN);
    } else {
        SetupDebugPrint( L"SETUP: GetDefaultUserProfileDirectory failed" );
        b = FALSE;
    }

    SendMessage(hProgress,PBM_STEPIT,0,0);

    if(!CopyOptionalDirectories()) {
        SetupDebugPrint( L"SETUP: CopyOptionalDirectories failed" );
        b = FALSE;
    }

    if(!b) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_FINISH_SETUP_FAILED,
            NULL,NULL);
    }
}


VOID
ConfigureCommon(
    IN HWND     hProgress,
    IN ULONG    StartAtPercent,
    IN ULONG    StopAtPercent
    )
{
    UINT GaugeRange;
    int i;



    //
    // Initialize the progress indicator control.
    //
    if( !OobeSetup ) {
        GaugeRange = (5*100/(StopAtPercent-StartAtPercent));
        SendMessage(hProgress, WMX_PROGRESSTICKS, 5, 0);
        SendMessage(hProgress,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
        SendMessage(hProgress,PBM_SETPOS,GaugeRange*StartAtPercent/100,0);
        SendMessage(hProgress,PBM_SETSTEP,1,0);
    }

    //
    // Install extra code pages on servers
    //
    if( !MiniSetup ) {
        SendMessage(hProgress,PBM_STEPIT,0,0);

        //
        // Process the [Shell] Section of the unattend file
        //
        ProcessShellUnattendSettings();

        if( !(ProductType == PRODUCT_WORKSTATION) ) {
            InstallServerNLSFiles(MainWindowHandle);
        }

        //
        // Do the SCE GenerateTemplate stuff
        //
        SendMessage(hProgress,PBM_STEPIT,0,0);
        BEGIN_SECTION(L"Generating security templates");
        CallSceGenerateTemplate();
        END_SECTION(L"Generating security templates");


        //
        // Try a call out to DcPromoSaveDcStateForUpgrade()...
        //
        if( ISDC(ProductType) && Upgrade ) {
        typedef     DWORD (*DCPROC) ( LPCWSTR );
        HMODULE     DCPromoHandle;
        DCPROC      MyProc;
        DWORD       Result;
        BOOL        Success = TRUE;

            //
            // We need to call out to dcpromo!DcPromoSaveDcStateForUpgrade.
            // Load dcpromo.dll, lookup DcPromoSaveDcStateForUpgrade and
            // call out to him.
            //

            try {
                if( DCPromoHandle = LoadLibrary(L"DCPROMO") ) {

                  if( MyProc = (DCPROC)GetProcAddress(DCPromoHandle,"DcPromoSaveDcStateForUpgrade")) {

                        Result = MyProc( NULL );
                        if( Result != ERROR_SUCCESS ) {
                            Success = FALSE;
                            SetupDebugPrint1( L"Setup: (non-critical error) Failed call DcPromoSaveDcStateForUpgrade (%lx.\n", Result );
                        }
                    } else {
                        Success = FALSE;
                        SetupDebugPrint( L"Syssetup: (non-critical error) Failed GetProcAddress on DcPromoSaveDcStateForUpgrade.\n" );
                    }
                } else {
                    Success = FALSE;
                    SetupDebugPrint( L"Syssetup: (non-critical error) Failed load of dcpromo.dll.\n" );
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
                Success = FALSE;
                SetupDebugPrint( L"Setup: Exception in dcpromo!DcPromoSaveDcStateForUpgrade\n" );
            }

            if( !Success ) {
                //
                // We failed the call (for whatever reason).  Treat
                // this as a fatal error.
                //
                FatalError( MSG_DCPROMO_FAILURE, 0, 0 );
            }

        }

        //
        // Fix up permissions/attributes on some files.
        //
        pSetInstallAttributes();

        //
        // Set the read-only attribute on some files.
        //
        SendMessage(hProgress,PBM_STEPIT,0,0);
        MarkFilesReadOnly();
    }


    //
    // Fix up the legacy install source.
    //
    if( !OobeSetup ) {
        SendMessage(hProgress,PBM_STEPIT,0,0);
    }
    CreateWindowsNtSoftwareEntry(FALSE);


    //
    // Now put the GuiRunOnce section into the registry.
    //
    if( !OobeSetup ) {
        SendMessage(hProgress,PBM_STEPIT,0,0);
    }
    GetUnattendRunOnceAndSetRegistry();



}


VOID
SFCCheck(
    IN HWND     hProgress,
    IN ULONG    StartAtPercent,
    IN ULONG    StopAtPercent
    )
/*++

Routine Description:

    This routine calls into WFP (WFP == SFC) to scan all files on the system to
    ensure that the files are all valid.  The routine also populates the WFP
    "dllcache", which is a local store of files on the system.

Arguments:

    hProgress      - progress window for updating a gas guage "tick count".
    StartAtPercent - where to start on the gas guage
    StopAtPercent  - Where to stop on the gas guage

Return Value:

    None.

--*/
{
    PPROTECT_FILE_ENTRY Files;
    ULONG               FileCount;
    DWORD               GaugeRange;
    WCHAR       AnswerFile[AnswerBufLen];
    WCHAR       Answer[AnswerBufLen];
    DWORD       d;
    DWORD   l;
    HKEY    hKey;
    DWORD   Size;
    DWORD   Type;


    //
    // determine how big to make the dllcache by looking at the
    // SFCQuota unattend value, otherwise use the below default.
    //



#if 0
    d = (ProductType == PRODUCT_WORKSTATION)
         ? SFC_QUOTA_DEFAULT
         : 0xffffffff;
#else
    d = 0xffffffff;
#endif

    //
    // SFCQuota unattend value?
    //

    GetSystemDirectory(AnswerFile,MAX_PATH);
    pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);
    if( GetPrivateProfileString( TEXT("SystemFileProtection"),
                                 TEXT("SFCQuota"),
                                 pwNull,
                                 Answer,
                                 AnswerBufLen,
                                 AnswerFile ) ) {
        if( lstrcmp( pwNull, Answer ) ) {
            //
            // We got an answer.  If it's valid, then set it.
            //
            d = wcstoul(Answer,NULL,16);
        }
    }

    //
    // Get the total file count
    //
    if (SfcGetFiles( &Files, &FileCount ) == STATUS_SUCCESS) {

        //
        // Initialize the progress indicator control.
        //
        GaugeRange = ((FileCount)*100/(StopAtPercent-StartAtPercent));
        SendMessage(hProgress, WMX_PROGRESSTICKS, FileCount, 0);
        SendMessage( hProgress, PBM_SETRANGE, 0, MAKELPARAM(0,GaugeRange) );
        SendMessage( hProgress, PBM_SETPOS, GaugeRange*StartAtPercent/100, 0 );
        SendMessage( hProgress, PBM_SETSTEP, 1, 0 );

        //
        // check the files
        //
        SfcInitProt(
            SFC_REGISTRY_OVERRIDE,
            SFC_DISABLE_SETUP,
            SFC_SCAN_ALWAYS,
            d,
            hProgress,
            SourcePath,
            EnumPtrSfcIgnoreFiles.Start
            );
    }

    //
    // Free our list of files that Sfc scan should ignore.
    //
    if (EnumPtrSfcIgnoreFiles.Start) {
        MultiSzFree(&EnumPtrSfcIgnoreFiles);
    }


    // also set the "allowprotectedrenames" registry key so that the next boot
    // after gui-mode setup allows any pending rename operations to occur.
    // We do this for performance reasons -- if we aren't looking at the rename
    // operations, it speeds up boot time.  We can do this for the gui-setup
    // case because we trust the copy operations occuring during gui-setup.



    //
    // Open the key
    //
    l = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                     TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager"),
                     0,
                     KEY_ALL_ACCESS,
                     &hKey );

    if(l == NO_ERROR) {
       d = 1;
       //
       // Write AllowProtectedRenames.
       //
       l = RegSetValueEx(hKey,
                       TEXT("AllowProtectedRenames"),
                       0,
                       REG_DWORD,
                       (CONST BYTE *)&d,
                       sizeof(DWORD) );


       RegCloseKey(hKey);
    }

}


VOID
ExecuteUserCommand (
    HWND hProgress
    )
{
    WCHAR PathBuffer[4*MAX_PATH];
    DWORD d;
    DWORD Result;

    //
    // Execute user-specified command, if any.
    //
    if (hProgress) {
        SendMessage(hProgress,PBM_STEPIT,0,0);
    }

    if(UserExecuteCmd) {

        //
        // Set current directory to %windir%
        //
        Result = GetWindowsDirectory(PathBuffer,sizeof(PathBuffer)/sizeof(PathBuffer[0]));
        if( Result == 0) {
            MYASSERT(FALSE);
            return;
        }
        SetCurrentDirectory(PathBuffer);

        ExpandEnvironmentStrings(
            UserExecuteCmd,
            PathBuffer,
            sizeof(PathBuffer)/sizeof(PathBuffer[0])
            );

        InvokeExternalApplication(NULL,PathBuffer,(PDWORD)&d);
    }
}


BOOL
CALLBACK
pExceptionPackageInstallationCallback(
    IN const PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData,
    IN OUT DWORD_PTR Context
    )
/*++
Routine Description:

    This callback routine creates a child process to register the specified
    exception package on the system.

Arguments:

    SetupOsComponentData - specifies component ID information
    SetupOsExceptionData - specifies component migration information
    Context              - context pointer from calling function

Return Value:

    TRUE indicates that the exception package was successfully applied.

--*/
{
    PEXCEPTION_MIGRATION_CONTEXT EMC = (PEXCEPTION_MIGRATION_CONTEXT) Context;
    DWORD RetVal;
    WCHAR Cmdline[MAX_PATH*2];
    PWSTR GuidString;

    #define COMPONENT_PACKAGE_TIMEOUT  60*1000*10  //ten minutes

    StringFromIID( &SetupOsComponentData->ComponentGuid, &GuidString);

    SetupDebugPrint5( L"Exception Package #%d\r\nComponent Data\r\n\tName: %ws\r\n\tGuid: %ws\r\n\tVersionMajor: %d\r\n\tVersionMinor: %d",
             EMC->Count,
             SetupOsComponentData->FriendlyName,
             GuidString,
             SetupOsComponentData->VersionMajor,
             SetupOsComponentData->VersionMinor);

    SetupDebugPrint2( L"ExceptionData\n\tInf: %ws\n\tCatalog: %ws",
             SetupOsExceptionData->ExceptionInfName,
             SetupOsExceptionData->CatalogFileName);

    EMC->Count += 1;

    //
    // make sure the signature of the inf validates against the supplied catalog before
    // installing the package.
    //
    RetVal = pSetupVerifyFile(
                NULL,
                SetupOsExceptionData->CatalogFileName,
                NULL,
                0,
                pSetupGetFileTitle(SetupOsExceptionData->ExceptionInfName),
                SetupOsExceptionData->ExceptionInfName,
                NULL,
                NULL,
                FALSE,
                NULL,
                NULL,
                NULL
                );

    if (RetVal == ERROR_SUCCESS) {

        //
        // Build the cmdline to install the package.
        //
        wsprintf( Cmdline,
                  L"%ws,DefaultInstall,1,N",
                  SetupOsExceptionData->ExceptionInfName);

        //
        // By specifying the last param as non-NULL, we will wait forever for this
        // package to finish installing
        //
        InvokeExternalApplicationEx( L"RUNDLL32 advpack.dll,LaunchINFSection",
                                     Cmdline,
                                     &RetVal,
                                     COMPONENT_PACKAGE_TIMEOUT,
                                     FALSE);



    }

    if (EMC->hWndProgress) {
        SendMessage(EMC->hWndProgress,PBM_STEPIT,0,0);
    }

    if (RetVal == ERROR_SUCCESS) {
        SetuplogError(
                LogSevInformation,
                SETUPLOG_USE_MESSAGEID,
                MSG_APPLY_EXCEPTION_PACKAGE,
                SetupOsComponentData->FriendlyName,
                SetupOsComponentData->VersionMajor,
                SetupOsComponentData->VersionMinor,
                NULL,NULL);
    } else {
        SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_APPLY_EXCEPTION_PACKAGE_FAILURE,
                SetupOsComponentData->FriendlyName,
                SetupOsComponentData->VersionMajor,
                SetupOsComponentData->VersionMinor,
                NULL,NULL);
        EMC->AnyComponentFailed = TRUE;
    }

    CoTaskMemFree( GuidString );

    //
    // if we hit a failure installing exception packages, we
    // continue onto the next package but we remember that this failed
    // in our context structure.
    //
    return(TRUE);
}


BOOL
CALLBACK
pExceptionPackageDeleteCallback(
    IN const PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData,
    IN OUT DWORD_PTR Context
    )
/*++

Routine Description:

    Callback routine to remove "bad packages" from the system.

    The callback looks in syssetup.inf's [OsComponentPackagesToRemove]
    section for the current GUID.  If it finds an entry for the GUID,
    it does a version check against the version in the syssetup.inf.
    If the version in syssetup.inf is newer, the exception package
    associated with that GUID is removed.  The version in syssetup.inf
    is a DWORD expressed as:
    hiword == VersionMajor
    loword == VersionMinor


Arguments:

    SetupOsComponentData - specifies component ID information
    SetupOsExceptionData - specifies component migration information
    Context              - context pointer from calling function


Return Value:

    Always TRUE.

--*/
{
    INFCONTEXT InfContext;
    PWSTR GuidString;
    DWORD VersionInInf, InstalledVersion;

    UNREFERENCED_PARAMETER(Context);

    StringFromIID( &SetupOsComponentData->ComponentGuid, &GuidString);

    //
    // see if we find the component in the syssetup inf.
    //
    if (SetupFindFirstLine( SyssetupInf,
                            L"OsComponentPackagesToRemove",
                            GuidString,
                            &InfContext)) {

        //
        // we found it, now see if it is an older version
        //
        if (SetupGetIntField( &InfContext, 1, &VersionInInf)) {
            InstalledVersion = MAKELONG(SetupOsComponentData->VersionMinor,
                                        SetupOsComponentData->VersionMajor );

            if (VersionInInf >= InstalledVersion) {
                //
                // it's an obsoleted version, so just remove it.
                //
                SetupUnRegisterOsComponent(&SetupOsComponentData->ComponentGuid);
            }
        }


    }

    CoTaskMemFree( GuidString );

    return(TRUE);

}

BOOL
MigrateExceptionPackages(
    HWND hProgress,
    DWORD StartAtPercent,
    DWORD StopAtPercent
    )
/*++

Routine Description:

    This routine enumerates the registered exception packages on the system.

    For each package on the system, a child process is started to install
    the package.

Arguments:

    hProgress      - progress window for updating a gas guage "tick count".
    StartAtPercent - indicates what % to start the gas guage at
    StopAtPercent  - indicates what % to end the gas guage at

Return Value:

    TRUE indicates that all exception packages were successfully applied.

--*/
{
    DWORD i;
    DWORD GaugeRange;
    DWORD NumberOfPackages;
    EXCEPTION_MIGRATION_CONTEXT EMC;
    HINF hInf;
    WCHAR AnswerFile[MAX_PATH];

    if (SyssetupInf == INVALID_HANDLE_VALUE) {
        //
        // we're not running in GUI-mode setup, so open a handle to the
        // syssetup.inf for the program
        //
        SyssetupInf = SetupOpenInfFile  (L"syssetup.inf",NULL,INF_STYLE_WIN4,NULL);
    }

    //
    // If the answer file tells us not to migrate exception packages,
    // then don't do it.
    //
    GetSystemDirectory(AnswerFile, MAX_PATH);
    pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);

    if (GetPrivateProfileInt(
                    TEXT("Data"),
                    TEXT("IgnoreExceptionPackages"),
                    0,
                    AnswerFile) == 1) {
        return(TRUE);
    }


    //
    // The very first thing we do is prune any known bad exceptions from
    // the list.  Just continue if this fails.
    //
    SetupEnumerateRegisteredOsComponents(
                            pExceptionPackageDeleteCallback,
                            (DWORD_PTR)NULL );

    //
    // now see how many components there are so we can scale the gas guage
    //
    if (!SetupQueryRegisteredOsComponentsOrder(&NumberOfPackages, NULL)) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_ENUM_EXCEPTION_PACKAGE_FAILURE,
            NULL,NULL);
        return(FALSE);
    }

    //
    // If there are no packages, we're done!
    //
    if (NumberOfPackages == 0) {
        return (TRUE);
    }

    if (hProgress) {

        GaugeRange = (NumberOfPackages*100/(StopAtPercent-StartAtPercent));
        SendMessage(hProgress, WMX_PROGRESSTICKS, NumberOfPackages, 0);
        SendMessage(hProgress,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
        SendMessage(hProgress,PBM_SETPOS,GaugeRange*StartAtPercent/100,0);
        SendMessage(hProgress,PBM_SETSTEP,1,0);

    }

    EMC.hWndProgress = hProgress;
    EMC.Count = 0;
    EMC.AnyComponentFailed = FALSE;

    //
    // now enumerate the packages, installing each of them in turn.
    //
    if (!SetupEnumerateRegisteredOsComponents( pExceptionPackageInstallationCallback ,
                                               (DWORD_PTR)&EMC)) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_ENUM_EXCEPTION_PACKAGE_FAILURE,
            NULL,NULL);
        return(FALSE);
    }

    return (TRUE);

}


VOID
RemoveRestartability (
    HWND hProgress
    )
{
    //
    // If install partition was extended then make sure
    // we clean up any stale volume(s)
    //
    if (PartitionExtended) {
        DWORD ErrorCode = RemoveStaleVolumes();

        if (ErrorCode != ERROR_SUCCESS) {
            //
            // TDB : Log the error code
            //
        }
    }

    //
    // Note the order of the following operations.
    // If the order were changed, there is a small window where if the system
    // were to be rebooted, setup would not restart, but the SKU stuff would
    // be inconsistent, causing a licensing bugcheck.
    //
    if (hProgress) {
        SendMessage(hProgress,PBM_STEPIT,0,0);
    }

    SetUpEvaluationSKUStuff();

    //
    // Indicate that setup is no longer in progress.
    // Do this before creating repair info! Also do it before
    // removing restart stuff. This way we will always either restart setup
    // or be able to log in.
    //
    if (hProgress) {
        SendMessage(hProgress,PBM_STEPIT,0,0);
    }

    ResetSetupInProgress();
    RemoveRestartStuff();
}

BOOL Activationrequired(VOID);
// Setup types defined in winlogon\setup.h
#define SETUPTYPE_NOREBOOT  2


BOOL
PrepareForOOBE(
    )
{
    DWORD           l;
    DWORD           d;
    HKEY            hKeySetup;
    TCHAR           Value[MAX_PATH];
    PWSTR           SpecifiedDomain = NULL;
    NETSETUP_JOIN_STATUS    JoinStatus;
    BOOL            DoIntroOnly = FALSE;
    BOOL            AutoActivate = FALSE;
    BOOL            RunOOBE = TRUE;
    WCHAR           Path[MAX_PATH];


    if((SyssetupInf != INVALID_HANDLE_VALUE) && !Activationrequired())
    {
        // If we are a select SKU
        if (SetupInstallFromInfSection(NULL,
                                       SyssetupInf,
                                       L"DEL_ACTIVATE",
                                       SPINST_PROFILEITEMS , //SPINST_ALL,
                                       NULL,
                                       NULL,
                                       0,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL) != 0)
        {
            // Success
            SetupDebugPrint( L"Setup: (Information) activation icons removed\n" );
        }
        else
        {
            // Failure
            SetupDebugPrint( L"Setup: (Information) could not remove hte activation icons\n" );
        }
    }

    if (AsrIsEnabled()) {
        //
        // We don't want to run the OOBE intro after an ASR restore
        //
        return TRUE;
    }

    if (ReferenceMachine) {
        //
        // We don't want to run OOBE if we're setting up a reference machine.
        //
        return TRUE;
    }

    if (ProductType != PRODUCT_WORKSTATION)
    {
        // Don't run OOBE.
        RunOOBE = FALSE;
        // Only run Autoactivation if not DTC and unattended and AutoActivate=Yes
        if (UnattendSwitch)
        {
            // if not DTC
            if (GetProductFlavor() != 3)
            {
                // Check for AutoActivate=Yes
                GetSystemDirectory(Path,MAX_PATH);
                pSetupConcatenatePaths(Path,WINNT_GUI_FILE,MAX_PATH,NULL);

                if( GetPrivateProfileString( TEXT("Unattended"),
                                             TEXT("AutoActivate"),
                                             pwNull,
                                             Value,
                                             sizeof(Value)/sizeof(TCHAR),
                                             Path ) )
                {
                    SetupDebugPrint( L"Setup: (Information) found AutoAvtivate in unattend file\n" );
                    AutoActivate = (lstrcmpi(Value,pwYes) == 0);
                }
            }
        }
    }

    if (!RunOOBE && !AutoActivate)
    {
        return TRUE;
    }
    // Now we either run OOBE (RunOOBE==TRUE) or we AutoActivate (AutoActivate == TRUE) or both


    //
    // Open HKLM\System\Setup
    //
    l = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      TEXT("SYSTEM\\Setup"),
                      0,
                      KEY_ALL_ACCESS,
                      &hKeySetup );

    if(l != NO_ERROR)
    {
        SetLastError(l);
        SetupDebugPrint1(
            L"SETUP: PrepareForOOBE() failed to open Setup key.  Error = %d",
            l );
        return FALSE;
    }

    //
    // Set HKLM\System\Setup\SetupType Key to SETUPTYPE_NOREBOOT
    //
    d = SETUPTYPE_NOREBOOT;
    l = RegSetValueEx(hKeySetup,
                      TEXT("SetupType"),
                      0,
                      REG_DWORD,
                      (CONST BYTE *)&d,
                      sizeof(DWORD));
    if(l != NO_ERROR)
    {
        RegCloseKey(hKeySetup);
        SetLastError(l);
        SetupDebugPrint1(
            L"SETUP: PrepareForOOBE() failed to set SetupType.  Error = %d",
            l );
        return FALSE;
    }

    if (RunOOBE)
    {
        // Set the registry to run OOBE
        //
        //
        // Set HKLM\System\Setup\OobeInProgress to (DWORD) 1
        //
        d = 1;
        l = RegSetValueEx(hKeySetup,
                          REGSTR_VALUE_OOBEINPROGRESS,
                          0,
                          REG_DWORD,
                          (CONST BYTE *)&d,
                          sizeof(DWORD));
        if(l != NO_ERROR)
        {
            RegCloseKey(hKeySetup);
            SetLastError(l);
            SetupDebugPrint2(
                L"SETUP: PrepareForOOBE() failed to set %ws.  Error = %d",
                REGSTR_VALUE_OOBEINPROGRESS,
                l );
            return FALSE;
        }

        //
        // Modify the HKLM\System\Setup\CmdLine key to run MSOOBE
        //
        ExpandEnvironmentStrings(
            TEXT("%SystemRoot%\\System32\\oobe\\msoobe.exe /f /retail"),
            Value,
            sizeof(Value)/sizeof(Value[0])
            );

    }
    else
    {
        // Set the registry to run Autoactivation
        //
        //
        // Modify the HKLM\System\Setup\CmdLine key to run Autoactivation
        //
        ExpandEnvironmentStrings(
            TEXT("%SystemRoot%\\System32\\oobe\\oobebaln.exe /s"),
            Value,
            sizeof(Value)/sizeof(Value[0])
            );
    }

    l = RegSetValueEx(hKeySetup,
                      TEXT("CmdLine"),
                      0,
                      REG_MULTI_SZ,
                      (CONST BYTE *)Value,
                      (lstrlen( Value ) + 1) * sizeof(TCHAR));
    if(l != NO_ERROR)
    {
        RegCloseKey(hKeySetup);
        SetLastError(l);
        SetupDebugPrint1(
            L"SETUP: PrepareForOOBE() failed to set CmdLine.  Error = %d",
            l );
        return FALSE;
    }

    RegCloseKey(hKeySetup);


    //
    // OOBE should do nothing but show the introductory animation if we're
    // unattended, or in a domain, unless a special unattend key is set to
    // force normal retail OOBE to run.
    // Note that we check whether the user explicity specifed the "/unattend"
    // switch.
    //
    if ( UnattendSwitch ) {

        DoIntroOnly = TRUE;

    } else {

        l = NetGetJoinInformation( NULL,
                                    &SpecifiedDomain,
                                    &JoinStatus );

        if ( SpecifiedDomain ) {
            NetApiBufferFree( SpecifiedDomain );
        }

        if ( l == NO_ERROR && JoinStatus == NetSetupDomainName ) {
            DoIntroOnly = TRUE;
        }
    }

    if ( DoIntroOnly && !ForceRunOobe ) {

        ExpandEnvironmentStrings(
            TEXT("%SystemRoot%\\System32\\oobe\\oobeinfo.ini"),
            Value,
            sizeof(Value)/sizeof(Value[0])
            );

        WritePrivateProfileString(
            TEXT("Options"),
            TEXT("IntroOnly"),
            TEXT("1"),
            Value
            );
    }

    return (TRUE);
}


BOOL
WINAPI
PrepareForAudit(
    )
{
    HKEY    hKey;
    TCHAR   szFileName[MAX_PATH + 32]   = TEXT("");
    BOOL    bRet                        = TRUE;

    SetupDebugPrint( L"SETUP: PrepareForAudit");
    // We need the path to factory.exe.
    //
    if ( ( ExpandEnvironmentStrings(TEXT("%SystemDrive%\\sysprep\\factory.exe"), szFileName, sizeof(szFileName) / sizeof(TCHAR)) == 0 ) ||
         ( szFileName[0] == TEXT('\0') ) ||
         ( GetFileAttributes(szFileName) == 0xFFFFFFFF ) )
    {
        // If this fails, there is nothing we can really do.
        //
        SetupDebugPrint1( L"SETUP: PrepareForAudit, Factory.exe not found at: %s",szFileName);
        return FALSE;
    }

    // Now make sure we are also setup as a setup program to run before we log on.
    //
    if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\Setup"), 0, KEY_ALL_ACCESS, &hKey ) == ERROR_SUCCESS )
    {
        DWORD dwVal;

        //
        // Setup the control flags for the SETUP key
        // The Setting used are:
        //      CmdLine = c:\sysprep\factory.exe -setup
        //      SetupType = 2 (No reboot)
        //      SystemSetupInProgress = 0 (no service restrictions)... assuming this is already cleared by setup.
        //      MiniSetupInProgress = 0 (Not doing a mini setup)
        //      FactoryPreInstallInProgress = 1 (Delay pnp driver installs)
        //      AuditInProgress = 1 (general key to determine if the OEM is auditing the machine)
        //

        // Cleanup setting Audit/Factory does not need and does not reset
        ResetSetupInProgress();
        RegDeleteValue(hKey,L"MiniSetupInProgress");
        RegDeleteValue(hKey,REGSTR_VALUE_OOBEINPROGRESS);

        // Now set the values which Audit/Factory needs
        lstrcat(szFileName, TEXT(" -setup"));
        if ( RegSetValueEx(hKey, TEXT("CmdLine"), 0, REG_SZ, (CONST LPBYTE) szFileName, (lstrlen(szFileName) + 1) * sizeof(TCHAR)) != ERROR_SUCCESS )
            bRet = FALSE;

        dwVal = SETUPTYPE_NOREBOOT;
        if ( RegSetValueEx(hKey, TEXT("SetupType"), 0, REG_DWORD, (CONST LPBYTE) &dwVal, sizeof(DWORD)) != ERROR_SUCCESS )
            bRet = FALSE;

        dwVal = 1;
        if ( RegSetValueEx(hKey, TEXT("FactoryPreInstallInProgress"), 0, REG_DWORD, (CONST LPBYTE) &dwVal, sizeof(DWORD)) != ERROR_SUCCESS )
            bRet = FALSE;

        dwVal = 1;
        if ( RegSetValueEx(hKey, TEXT("AuditInProgress"), 0, REG_DWORD, (CONST LPBYTE) &dwVal, sizeof(DWORD)) != ERROR_SUCCESS )
            bRet = FALSE;


        RegCloseKey(hKey);
    }
    else
        bRet = FALSE;

    return bRet;
}


VOID
RemoveFiles(
    IN HWND     hProgress
    )
{
    #define     AnswerBufLen (4*MAX_PATH)
    #define     WINNT_GUI_FILE_PNF  L"$winnt$.pnf"
    WCHAR       PathBuffer[AnswerBufLen];
    WCHAR       Answer[AnswerBufLen];
    DWORD       Result;
    DWORD       Status;


    //
    // Initialize the progress indicator control.
    //
    SendMessage(hProgress,PBM_SETRANGE,0,MAKELPARAM(0,6));
    SendMessage(hProgress,PBM_SETPOS,0,0);
    SendMessage(hProgress,PBM_SETSTEP,1,0);

    //
    // Restoring the path saved in textmode on upgrades
    //
    SendMessage(hProgress,PBM_STEPIT,0,0);
    if( Upgrade )
        RestoreOldPathVariable();

    if(!MiniSetup) {

        SendMessage(hProgress,PBM_STEPIT,0,0);


        SendMessage(hProgress,PBM_STEPIT,0,0);
#ifdef _X86_
        //
        //  Win95 migration file removal
        //
        if( Win95Upgrade ) {
            Win95MigrationFileRemoval();
        }
        RemoveFiles_X86(SyssetupInf);

        //
        // remove downloaded files in %windir%\winnt32
        //
        Result = GetWindowsDirectory(PathBuffer,MAX_PATH);
        if (Result == 0) {
        MYASSERT(FALSE);
        return;
        }
        pSetupConcatenatePaths(PathBuffer,TEXT("WINNT32"),MAX_PATH,NULL);
        Delnode(PathBuffer);

        //
        // Prepare to run OOBE after reboot
        //
        if( !PrepareForOOBE() ) {

            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_CANT_RUN_OOBE,
                GetLastError(),
                NULL,NULL);
        }
#endif

        if( Upgrade ) {
           //
           //If we upgraded from NT4-SP4, remove the files/registration
           //for sp4 uninstall. If we upgraded from NT4-SPx where x<4,
           //we don't need to remove anything from the registry.
           //
            Result = GetWindowsDirectory(PathBuffer,MAX_PATH);
            if (Result == 0) {
            MYASSERT(FALSE);
                return;
            }
            pSetupConcatenatePaths(PathBuffer, L"$ntservicepackuninstall$",MAX_PATH,NULL);
            Delnode(PathBuffer);

            RegDeleteKey(HKEY_LOCAL_MACHINE,
                         TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Windows NT 4.0 Service Pack 4"));
            RegDeleteKey(HKEY_LOCAL_MACHINE,
                         TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Windows NT 4.0 Service Pack 5"));
            RegDeleteKey(HKEY_LOCAL_MACHINE,
                         TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Windows NT 4.0 Service Pack 6"));

            // We should not have to do this.
            // Ther servick pack team needs to remember to put the correct key at
            // Software\\Microsoft\\Windows NT\\CurrentVersion\\Hotfix
            RegDeleteKey(HKEY_LOCAL_MACHINE,
                         TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Windows 2000 Service Pack 1"));
            RegDeleteKey(HKEY_LOCAL_MACHINE,
                         TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Windows 2000 Service Pack 2"));

            //Remove the files/registry keys for all the hotfixes.
            // It also implements a generic way to removing Service Pack uninstall entries
            //
            RemoveHotfixData();
        } else {
            //
            // Setup for audit mode if this is a reference machine.
            //
            if ( ReferenceMachine )
                PrepareForAudit();
        }

        DuCleanup ();

        DuInstallEndGuiSetupDrivers ();

        SendMessage(hProgress,PBM_STEPIT,0,0);
        DeleteLocalSource();
    } else {
        SendMessage(hProgress,PBM_STEPIT,0,0);
        SendMessage(hProgress,PBM_STEPIT,0,0);
        SendMessage(hProgress,PBM_STEPIT,0,0);
    }

    //
    // At this point, the net stuff is done. Re-read the product type
    // which might have been changed by them (such as changing PDC/BDC).
    //
    ProductType = InternalSetupData.ProductType;

    //
    // Call the net guys back once again to let them do any final
    // processing, such as BDC replication.
    //
    CallNetworkSetupBack(NETSETUPFINISHINSTALLPROCNAME);

    //
    // If the computer name was a non-RFC name or if it was truncated
    // to make a valid netbios name, put a warning in the log file.
    //
    if (IsNameNonRfc)
        SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_DNS_NON_RFC_NAME,
                ComputerName,
                NULL,NULL);

    if (IsNameTruncated)
        SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_DNS_NAME_TRUNCATED,
                ComputerName,
                Win32ComputerName,
                NULL,NULL);


    //
    // Delete the PNF to take care of security issue with passwords
    // Do this before we save the current system hives so that the
    // delayed delete works
    //

    GetSystemDirectory(PathBuffer,MAX_PATH);
    pSetupConcatenatePaths(PathBuffer,WINNT_GUI_FILE_PNF,MAX_PATH,NULL);
    MoveFileEx( PathBuffer, NULL, MOVEFILE_DELAY_UNTIL_REBOOT );


    //
    // Delete the SAM.sav hive file as we no longer need it. Textmode setup
    // creates this file only in upgrades as a backup. We will try to delete it in any case
    // as this file can be used by hackers for offline attacks.
    //
    GetSystemDirectory(PathBuffer,MAX_PATH);
    pSetupConcatenatePaths(PathBuffer, L"config\\sam.sav", MAX_PATH, NULL);
    DeleteFile( PathBuffer );



    //
    // Setup the Crash Recovery stuff. This is implemented as RTL APIS
    // Call them now to setup the tracking file etc. as we are past the
    // restartable phase of GUI mode and don't run the risk of having it
    // enabled for GUI mode itself. Crash Recovery tracks boot and shutdown and in
    // the event of failures in either it will by default pick the right advanced
    // boot option.
    //


    BEGIN_SECTION( L"Setting up Crash Recovery" );

    SetupCrashRecovery();

    END_SECTION( L"Setting up Crash Recovery" );

    //
    //  Save and replace the system hives.
    //  This is necessary in order to remove fragmentation and compact the
    //  system hives. Remember that any type of writes to the registry
    //  after this point won't be reflected on next boot.
    //
    SendMessage(hProgress,PBM_STEPIT,0,0);
    if( !MiniSetup ) {
        SaveAndReplaceSystemHives();
    }

    SendMessage(hProgress,PBM_STEPIT,0,0);

    //
    // Delete the \sysprep directory.
    //
    if( MiniSetup ) {
        HANDLE  hEventLog = NULL;
        Result = GetWindowsDirectory( PathBuffer, MAX_PATH );
        if (Result == 0) {
        MYASSERT(FALSE);
            return;
        }
        PathBuffer[3] = 0;
        pSetupConcatenatePaths( PathBuffer, TEXT("sysprep"), MAX_PATH, NULL );
        Delnode( PathBuffer );

        //
        // Delete the setupcl.exe so session manager won't start us for each
        // session (TS client, user switching).
        //
        Result = GetSystemDirectory( PathBuffer, MAX_PATH );
        if (Result == 0) {
        MYASSERT(FALSE);
            return;
        }
        pSetupConcatenatePaths( PathBuffer, TEXT("setupcl.exe"), MAX_PATH, NULL );
        SetFileAttributes(PathBuffer, FILE_ATTRIBUTE_NORMAL);
        DeleteFile(PathBuffer);

        //
        // Clear the Event logs.
        //
        hEventLog = OpenEventLog( NULL, TEXT("System") );
        if (hEventLog) {
            ClearEventLog( hEventLog, NULL );
            CloseEventLog( hEventLog );
        }

        hEventLog = OpenEventLog( NULL, TEXT("Application") );
        if (hEventLog) {
            ClearEventLog( hEventLog, NULL );
            CloseEventLog( hEventLog );
        }

        hEventLog = OpenEventLog( NULL, TEXT("Security") );
        if (hEventLog) {
            ClearEventLog( hEventLog, NULL );
            CloseEventLog( hEventLog );
        }
    }

    //
    // Delete certain keys out of the unattend file:
    // - AdminPassword
    // - DomainAdminPassword
    // - UserPassword
    // - DefaultPassword
    // - ProductId
    // - ProductKey
    //
    Result = GetSystemDirectory(PathBuffer,MAX_PATH);
    if (Result == 0) {
        MYASSERT(FALSE);
        return;
    }
    pSetupConcatenatePaths(PathBuffer,WINNT_GUI_FILE,MAX_PATH,NULL);

    if(Unattended) {

        // AdminPassword
        if( GetPrivateProfileString( WINNT_GUIUNATTENDED,
                                     TEXT("AdminPassword"),
                                     pwNull,
                                     Answer,
                                     AnswerBufLen,
                                     PathBuffer ) ) {
            if( lstrcmp( pwNull, Answer ) ) {
                WritePrivateProfileString( WINNT_GUIUNATTENDED,
                                           TEXT("AdminPassword"),
                                           pwNull,
                                           PathBuffer );
            }
        }


        // DomainAdminPassword
        if( GetPrivateProfileString( TEXT("Identification"),
                                     TEXT("DomainAdminPassword"),
                                     pwNull,
                                     Answer,
                                     AnswerBufLen,
                                     PathBuffer ) ) {
            if( lstrcmp( pwNull, Answer ) ) {
                WritePrivateProfileString( TEXT("Identification"),
                                           TEXT("DomainAdminPassword"),
                                           pwNull,
                                           PathBuffer );
            }
        }


        // UserPassword
        if( GetPrivateProfileString( TEXT("Win9xUpg.UserOptions"),
                                     TEXT("UserPassword"),
                                     pwNull,
                                     Answer,
                                     AnswerBufLen,
                                     PathBuffer ) ) {
            if( lstrcmp( pwNull, Answer ) ) {
                WritePrivateProfileString( TEXT("Win9xUpg"),
                                           TEXT("UserPassword"),
                                           pwNull,
                                           PathBuffer );
            }
        }


        // DefaultPassword
        if( GetPrivateProfileString( TEXT("Win9xUpg.UserOptions"),
                                     TEXT("DefaultPassword"),
                                     pwNull,
                                     Answer,
                                     AnswerBufLen,
                                     PathBuffer ) ) {
            if( lstrcmp( pwNull, Answer ) ) {
                WritePrivateProfileString( TEXT("Win9xUpg"),
                                           TEXT("DefaultPassword"),
                                           pwNull,
                                           PathBuffer );
            }
        }
    }
    // ProductId
    if( GetPrivateProfileString( pwUserData,
                                 pwProdId,
                                 pwNull,
                                 Answer,
                                 AnswerBufLen,
                                 PathBuffer ) ) {
        if( lstrcmp( pwNull, Answer ) ) {
            WritePrivateProfileString( pwUserData,
                                       pwProdId,
                                       pwNull,
                                       PathBuffer );
        }
    }

    // ProductKey
    if( GetPrivateProfileString( pwUserData,
                                 pwProductKey,
                                 pwNull,
                                 Answer,
                                 AnswerBufLen,
                                 PathBuffer ) ) {
        if( lstrcmp( pwNull, Answer ) ) {
            WritePrivateProfileString( pwUserData,
                                       pwProductKey,
                                       pwNull,
                                       PathBuffer );
        }
    }

    //
    // Sysprep disables system restore, so we need to re-enable it now that
    // we're done.
    //
    if ( MiniSetup ) {
        HINSTANCE hSrClient = LoadLibrary(L"srclient.dll");

        if (hSrClient) {
            DWORD (WINAPI *pEnableSrEx)(LPCWSTR, BOOL) = (DWORD (WINAPI *)(LPCWSTR, BOOL))GetProcAddress(hSrClient, "EnableSREx");
            if (pEnableSrEx) {
                Status = pEnableSrEx( NULL , TRUE); // TRUE - synchronous call.  Wait for SR to finish enabling.
                if ( Status != ERROR_SUCCESS ) {

                    SetupDebugPrint1( L"SETUP: EnableSREx(NULL, TRUE) failed. Error = %d", Status);
                }
            } else {
                SetupDebugPrint1( L"SETUP: Unable to find EnableSREx in srclient.dll. Error = %d", GetLastError());
            }
            FreeLibrary(hSrClient);
        } else {
            SetupDebugPrint1( L"SETUP: Unable to load srclient.dll. Error = %d", GetLastError());
        }
    }
}


VOID
SetStartTypeForRemoteBootDrivers(
    VOID
    )

/*++

Routine Description:

    This routine is called at the end of remote boot setup to change the
    start type for certain drivers to BOOT_START.

Arguments:

    None.

Returns:

    None.

--*/

{
    DWORD i;
    BOOL b;
    WCHAR imagePath[sizeof("System32\\DRIVERS\\xxxxxxxx.sys")];

    //
    // Loop through the list of boot drivers. We call MyChangeServiceConfig
    // directly instead of MyChangeServiceStart so that we can specify
    // an image path, which prevents the service controller from rejecting
    // the change (because it expects the current image path to start
    // with \SystemRoot which it doesn't).
    //

    for ( i = 0; i < (sizeof(RemoteBootDrivers) / sizeof(RemoteBootDrivers[0])); i++ ) {
        wsprintf(imagePath, L"System32\\DRIVERS\\%ws.sys", RemoteBootDrivers[i]);
        b = MyChangeServiceConfig(
                    RemoteBootDrivers[i],
                    SERVICE_NO_CHANGE,
                    SERVICE_BOOT_START,
                    SERVICE_NO_CHANGE,
                    imagePath,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );
    }
}

VOID
CallNetworkSetupBack(
    IN PCSTR ProcName
    )

{
    HMODULE NetSetupModule;
    NETSETUPINSTALLSOFTWAREPROC NetProc;
    DWORD d;
    BOOL b;

    if(NetSetupModule = LoadLibrary(L"NETSHELL")) {

        if(NetProc = (NETSETUPINSTALLSOFTWAREPROC)GetProcAddress(NetSetupModule,ProcName)) {
            SetUpDataBlock();
            NetProc(MainWindowHandle,&InternalSetupData);
        }

        //
        // We don't free the library because it might create threads
        // that are hanging around.
        //
    }
}


VOID
SetUpDataBlock(
    VOID
    )

/*++

Routine Description:

    This routine sets up the internal setup data block structure that
    we use to communicate information to the network setup wizard.
    Note that we passed a pointer to this structure when we fetched
    the net setup wizard pages but at that point the structure was completely
    uninitialized.

Arguments:

    None.

Returns:

    None.

--*/

{
    PWSTR p;
    WCHAR str[1024];

    InternalSetupData.dwSizeOf = sizeof(INTERNAL_SETUP_DATA);

    //
    // Set the mode: custom, laptop, minimal, typical
    //
    InternalSetupData.SetupMode = SetupMode;

    //
    // Set the product type: workstation, dc, etc.
    //
    InternalSetupData.ProductType = ProductType;

    //
    // Set the operation flags.
    //
    if(Win31Upgrade) {
        InternalSetupData.OperationFlags |= SETUPOPER_WIN31UPGRADE;
    }
    if(Win95Upgrade) {
        InternalSetupData.OperationFlags |= SETUPOPER_WIN95UPGRADE;
    }
    if(Upgrade) {
        InternalSetupData.OperationFlags |= SETUPOPER_NTUPGRADE;
    }
    if(Unattended) {
        InternalSetupData.OperationFlags |= SETUPOPER_BATCH;
        InternalSetupData.UnattendFile = AnswerFile;
        if(Preinstall) {
            InternalSetupData.OperationFlags |= SETUPOPER_PREINSTALL;
        }
    }
    if(MiniSetup) {
        //
        // Pretend we've got access to all the files.
        //
        InternalSetupData.OperationFlags |= SETUPOPER_ALLPLATFORM_AVAIL;

        // Let people know we are in MiniSetup
        InternalSetupData.OperationFlags |= SETUPOPER_MINISETUP;
    }


    //
    // Tell the net guys the source path.
    //
    InternalSetupData.SourcePath = SourcePath;
    InternalSetupData.LegacySourcePath = LegacySourcePath;

    //
    // If we are installing from CD then assume all platforms
    // are available.
    //
    if(SourcePath[0] && (SourcePath[1] == L':') && (SourcePath[2] == L'\\')) {

        lstrcpyn(str,SourcePath,4);
        if(GetDriveType(str) == DRIVE_CDROM) {

            InternalSetupData.OperationFlags |= SETUPOPER_ALLPLATFORM_AVAIL;
        }
    }

    //
    // Tell the net guys the wizard title they should use.
    //
    if(!InternalSetupData.WizardTitle) {
        p = NULL;
        if(LoadString(MyModuleHandle,SetupTitleStringId,str,sizeof(str)/sizeof(str[0]))) {
            p = pSetupDuplicateString(str);
        }
        InternalSetupData.WizardTitle = p ? p : L"";
    }

    //
    // Reset the two call-specific data fields.
    //
    InternalSetupData.CallSpecificData1 = InternalSetupData.CallSpecificData2 = 0;

    // Set the billboard call back function if we have a billboard
    InternalSetupData.ShowHideWizardPage = ShowHideWizardPage;
    InternalSetupData.BillboardProgressCallback = Billboard_Progress_Callback;
    InternalSetupData.BillBoardSetProgressText= Billboard_Set_Progress_Text;
}


VOID
SetFinishItemAttributes(
    IN HWND     hdlg,
    IN int      BitmapControl,
    IN HANDLE   hBitmap,
    IN int      TextControl,
    IN LONG     Weight
    )
{
    HWND    hBitmapControl, hTxt;
    HFONT   Font;
    LOGFONT LogFont;

    if( OobeSetup ) {
        return;
    }


    hBitmapControl = GetDlgItem(hdlg, BitmapControl);
    SendMessage (hBitmapControl, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);
    ShowWindow (hBitmapControl, SW_SHOW);
    if((Font = (HFONT)SendDlgItemMessage(hdlg,TextControl,WM_GETFONT,0,0))
       && GetObject(Font,sizeof(LOGFONT),&LogFont)) {

        LogFont.lfWeight = Weight;
        if(Font = CreateFontIndirect(&LogFont)) {
            SendDlgItemMessage (hdlg, TextControl, WM_SETFONT, (WPARAM)Font,
                MAKELPARAM(TRUE,0));
        }
    }
}


DWORD
FinishThread(
    PFINISH_THREAD_PARAMS   Context
    )
{
    HANDLE  hArrow, hCheck;
    HWND    hProgress;
    DWORD   DontCare;
    NTSTATUS        Status;
    SYSTEM_REGISTRY_QUOTA_INFORMATION srqi;
    ULONG           RegistryQuota = 0;
    WCHAR str[1024];

    BEGIN_SECTION(L"FinishThread");
    SetThreadLocale(OriginalInstallLocale);


    //
    // Initialize stuff.
    //
    if( !OobeSetup ) {
        hArrow = LoadImage (MyModuleHandle, MAKEINTRESOURCE(IDB_ARROW), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
        hCheck = LoadImage (MyModuleHandle, MAKEINTRESOURCE(IDB_CHECK), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
        hProgress = GetDlgItem(Context->hdlg, IDC_PROGRESS1);
    }


    if( !MiniSetup ) {
        pSetupEnablePrivilege(SE_INCREASE_QUOTA_NAME,TRUE);
        Status = NtQuerySystemInformation(SystemRegistryQuotaInformation,
            &srqi, sizeof(srqi), NULL);

        if(NT_SUCCESS(Status)) {
            RegistryQuota = srqi.RegistryQuotaAllowed;
            srqi.RegistryQuotaAllowed *= 2;
            SetupDebugPrint2(L"SETUP: Changing registry quota from %d to %d...",
                RegistryQuota, srqi.RegistryQuotaAllowed);
            Status = NtSetSystemInformation(SystemRegistryQuotaInformation,
                &srqi, sizeof(srqi));
            if (NT_SUCCESS(Status)) {
                SetupDebugPrint(L"SETUP:    ... succeeded");
            } else {
                SetupDebugPrint(L"SETUP:    ... failed");
            }
        }
    }

    //
    // Copying files
    //
    if( !OobeSetup ) {
        SetFinishItemAttributes (Context->hdlg, IDC_COPY_BMP, hArrow, IDC_COPY_TXT, FW_BOLD);
        if(!LoadString(MyModuleHandle, IDS_BB_COPY_TXT, str, SIZECHARS(str)))
        {
            *str = L'\0';
        }
        SendMessage(GetParent(Context->hdlg),WMX_SETPROGRESSTEXT,0,(LPARAM)str);
    }


    MYASSERT(Context->OcManagerContext);
    BEGIN_SECTION(L"Terminating the OC manager");
    KillOcManager(Context->OcManagerContext);
    END_SECTION(L"Terminating the OC manager");

    if( !MiniSetup ) {
        BEGIN_SECTION(L"Loading service pack (phase 3)");
        CALL_SERVICE_PACK( SVCPACK_PHASE_3, 0, 0, 0 );
        END_SECTION(L"Loading service pack (phase 3)");

        BEGIN_SECTION(L"Installing Component Infs");
        DoInstallComponentInfs(MainWindowHandle, Context->hdlg, WM_MY_PROGRESS, SyssetupInf, L"Infs.Always" );
        END_SECTION(L"Installing Component Infs");
    }

    if( !OobeSetup ) {
        SetFinishItemAttributes (Context->hdlg, IDC_COPY_BMP, hCheck, IDC_COPY_TXT, FW_NORMAL);
    }


    //
    // Configuring your computer
    //
    if( !OobeSetup ) {
        SetFinishItemAttributes (Context->hdlg, IDC_CONFIGURE_BMP, hArrow, IDC_CONFIGURE_TXT, FW_BOLD);
        if(!LoadString(MyModuleHandle, IDS_BB_CONFIGURE, str, SIZECHARS(str)))
        {
            *str = L'\0';
        }
        SendMessage(GetParent(Context->hdlg),WMX_SETPROGRESSTEXT,0,(LPARAM)str);
    }

    if( !MiniSetup ) {
        RemainingTime = CalcTimeRemaining(Phase_Inf_Registration);
        SetRemainingTime(RemainingTime);
        BEGIN_SECTION(L"Processing RegSvr Sections");
        RegisterOleControls(Context->hdlg,SyssetupInf,hProgress,0,40,L"RegistrationPhase2");
        END_SECTION(L"Processing RegSvr Sections");
    }
    RemainingTime = CalcTimeRemaining(Phase_RunOnce_Registration);
    SetRemainingTime(RemainingTime);
    BEGIN_SECTION(L"DoRunonce");
    DoRunonce();
    END_SECTION(L"DoRunonce");

    if(Upgrade) {
        BEGIN_SECTION(L"Configuring Upgrade");
        ConfigureUpgrade(hProgress,40,70);
        END_SECTION(L"Configuring Upgrade");


    } else {
        BEGIN_SECTION(L"Configuring Setup");
        ConfigureSetup(hProgress,40,70);
        END_SECTION(L"Configuring Setup");
    }

    RemainingTime = CalcTimeRemaining(Phase_SecurityTempates);
    SetRemainingTime(RemainingTime);
    BEGIN_SECTION(L"Configuring Common");
    ConfigureCommon(hProgress,70,100);
    END_SECTION(L"Configuring Common");

    if( !MiniSetup ) {
        if(WatchHandle) {
            if(WatchStop(WatchHandle) == NO_ERROR) {
                MakeUserdifr(WatchHandle);
            }
            WatchFree(WatchHandle);
        }
    }


    //
    // tell umpnpmgr to stop installing any more devices, if it was already doing so
    //
    if( (!MiniSetup) || (MiniSetup && PnPReEnumeration) ) {
        PnpStopServerSideInstall();
    }

    if (!OobeSetup)
    {
        SetFinishItemAttributes (Context->hdlg, IDC_CONFIGURE_BMP, hCheck, IDC_CONFIGURE_TXT, FW_NORMAL);
    }

#ifdef _X86_
    //
    //  Do Win95 migration, if necessary.
    //
    // !!ATTENTION!!
    //
    //  This code must run at the end of GUI mode, but before registry ACLs are applied and also
    //  before temporary files are deleted.  Every NT component must be in place before migration
    //  occurs in order for the migrated users to receive all NT-specific settings.
    //

    if (Win95Upgrade) {
        RemainingTime = CalcTimeRemaining(Phase_Win9xMigration);
        SetRemainingTime(RemainingTime);

        BEGIN_SECTION(L"Migrating Win9x settings");
        SetBBStep(5);

        SetFinishItemAttributes (Context->hdlg, IDC_UPGRADE_BMP, hArrow, IDC_UPGRADE_TXT, FW_BOLD);
        if(!LoadString(MyModuleHandle, IDS_BB_UPGRADE, str, SIZECHARS(str)))
        {
            *str = L'\0';
        }
        SendMessage(GetParent(Context->hdlg),WMX_SETPROGRESSTEXT,0,(LPARAM)str);

        if (!MigrateWin95Settings (hProgress, AnswerFile)) {
            //
            // User's machine is unstable. Fail setup, so that uninstall must kick in.
            //
            WCHAR skipFile[MAX_PATH];
            BOOL ok = FALSE;

            if (GetWindowsDirectory (skipFile, MAX_PATH)) {
                pSetupConcatenatePaths (skipFile, TEXT("nofail"), MAX_PATH, NULL);
                if (GetFileAttributes (skipFile) != 0xFFFFFFFF) {
                    ok = TRUE;
                }
            }

            if (!ok) {
                FatalError (MSG_LOG_MIGRATION_FAILED,0,0);
            }
        }

        SetFinishItemAttributes (Context->hdlg, IDC_UPGRADE_BMP, hCheck, IDC_UPGRADE_TXT, FW_NORMAL);
        END_SECTION(L"Migrating Win9x settings");
    }


#endif // def _X86_

    SetFinishItemAttributes (Context->hdlg, IDC_SAVE_BMP, hArrow, IDC_SAVE_TXT, FW_BOLD);

    //
    // The last things to set up.  Make it quick -- the gas guage may be at 100% at this point.
    //
    if( !MiniSetup ) {

        ExecuteUserCommand (NULL);
        InitializeCodeSigningPolicies (FALSE);  // NOTE: don't bother stepping the progress--this is really quick!

        SetBBStep(5);

        //
        // Saving your configuration
        //
        if(!LoadString(MyModuleHandle, IDS_BB_SAVE, str, SIZECHARS(str)))
        {
            *str = L'\0';
        }
        SendMessage(GetParent(Context->hdlg),WMX_SETPROGRESSTEXT,0,(LPARAM)str);

        //
        // Fix the security on <All Users\Application Data\Microsoft\Windows NT>
        //
        BEGIN_SECTION(L"Fix the security on <All Users\\Application Data\\Microsoft\\Windows NT>");
        InvokeExternalApplication(L"shmgrate.exe", L"Fix-HTML-Help", 0);
        END_SECTION(L"Fix the security on <All Users\\Application Data\\Microsoft\\Windows NT>");

        //
        // Do any exception package installation at this point
        //
        BEGIN_SECTION(L"Migrating exception packages");
        MigrateExceptionPackages(hProgress, 0, 10 );
        END_SECTION(L"Migrating exception packages");

        //
        // Run any nt migration dlls.
        //
        if (Upgrade) {
            RunMigrationDlls ();

        }

        //
        // Scan the system dirs to validate all protected dlls
        //
        RemainingTime = CalcTimeRemaining(Phase_SFC);
        SetRemainingTime(RemainingTime);

        BEGIN_SECTION(L"Running SFC");
        SFCCheck(hProgress,10,70);
        END_SECTION(L"Running SFC");
#ifdef PRERELEASE
        if (SfcErrorOccurred) {
//
// Hack out the fatal error so we can get the build out.
//
//            FatalError(MSG_LOG_SFC_FAILED,0,0);
        }
#endif



    } else {
        //
        // We're in MiniSetup, which means 3 things:
        // 1. If the OEM desires it, they can request a change of kernel+HAL
        //    we have to do this at the end, due to the way we upgrade HAL
        //    doing this sooner can cause other installs to crash
        //
        // 2. SFC has been run on this machine and the files have been
        //    inventoried.
        // 3. We're very concerned with execution time here.
        //
        // Given the last two items, we're just going to re-enable SFC
        // as it was before the user ran sysprep.
        //
        // 1 and 3 are contradictory, however 1 shouldn't take too long
        // and will be used in rare cases
        //

        DWORD   d;
        DWORD   l;
        HKEY    hKey;
        DWORD   Size;
        DWORD   Type;


        //
        // We want to see if the OEM wants MiniSetup to choose a different kernel+HAL
        // this has to be done after all other installation
        // due to the special way we update the kernel+HAL+dependent files
        //
        BEGIN_SECTION(L"Updating HAL (mini-setup)");
        PnpUpdateHAL();
        END_SECTION(L"Updating HAL (mini-setup)");
    }

    //
    // Only copy these folders if OEMPreinstall=yes, and it's not Mini-Setup
    //
    if (Preinstall && !MiniSetup) {
        //
        // Recursively move custom OEM \\Temp\\$PROGS directories to %Program Files%
        //
        BEGIN_SECTION(L"TreeCopy $OEM\\$PROGS");
        CopyOemProgramFilesDir();
        END_SECTION(L"TreeCopy $OEM\\$PROGS");

        //
        // Recursively move custom OEM \\Temp\\$DOCS directories to %Documents and Settings%
        //
        BEGIN_SECTION(L"TreeCopy $OEM\\$DOCS");
        CopyOemDocumentsDir();
        END_SECTION(L"TreeCopy $OEM\\$DOCS");
    }

    //
    // Call User Profile code to copy the SystemProfile under system32\config\systemprofile
    //

    if( !CopySystemProfile(Upgrade ? FALSE : TRUE) ){

        //Log the error and move on.

        SetuplogError(LogSevError,
                      L"Setup failed to migrate the SystemProfile  (CopySystemProfile failed %1!u!)\r\n",
                      0, GetLastError(), NULL,NULL
                      );

    }

    // Only do this in MiniSetup. OOBE is calling this at a different time. Real setup does not need this.
    if (MiniSetup && !OobeSetup)
    {
        RunOEMExtraTasks();
    }

    // Clean up CurrentProductId which should only be used during gui-mode.
    DeleteCurrentProductIdInRegistry();

    // Simulate OOBE's functionality of copying the default profile directory to all user profiles.
    // Only do this for MiniSetup and Server skus (server doesn't use OOBE).
    //
    if ( MiniSetup && !OobeSetup && (ProductType != PRODUCT_WORKSTATION) ) 
    {
        if ( !UpdateServerProfileDirectory() )
        {
            SetuplogError(LogSevError,
                          L"Setup failed to update user(s) profiles.  (UpdateServerProfileDirectory failed %1!u!)\r\n",
                          0, GetLastError(), NULL,NULL
                          );
        }
    }


    //
    // FROM THIS POINT ON DO NOTHING THAT IS CRITICAL TO THE OPERATION
    // OF THE SYSTEM. OPERATIONS AFTER THIS POINT ARE NOT PROTECTED BY
    // RESTARTABILITY.
    //
    RemoveRestartability (NULL);

    //
    // Update the install date time for shell's application install feature
    //
    CreateInstallDateEntry();

    //
    // Save repair info.
    //
    if(!MiniSetup) {

        RemainingTime = CalcTimeRemaining(Phase_SaveRepair);
        SetRemainingTime(RemainingTime);
        BEGIN_SECTION(L"Saving repair info");
        SaveRepairInfo( hProgress, 70, 100 );
        END_SECTION(L"Saving repair info");
    }
    SetFinishItemAttributes (Context->hdlg, IDC_SAVE_BMP, hCheck, IDC_SAVE_TXT, FW_NORMAL);

    //
    // Removing any temporary files used
    //
    RemainingTime = CalcTimeRemaining(Phase_RemoveTempFiles);
    SetRemainingTime(RemainingTime);
    BEGIN_SECTION(L"Removing Temporary Files");
    if( !OobeSetup ) {
        SetFinishItemAttributes (Context->hdlg, IDC_REMOVE_BMP, hArrow, IDC_REMOVE_TXT, FW_BOLD);
        if(!LoadString(MyModuleHandle, IDS_BB_REMOVE, str, SIZECHARS(str)))
        {
            *str = L'\0';
        }
        SendMessage(GetParent(Context->hdlg),WMX_SETPROGRESSTEXT,0,(LPARAM)str);
    }

    //
    // This call does more than just remove files. It also commits the hives and takes care of admin password stuff etc.
    //
    RemoveFiles(hProgress);

    if( !OobeSetup ) {
        SetFinishItemAttributes (Context->hdlg, IDC_REMOVE_BMP, hCheck, IDC_REMOVE_TXT, FW_NORMAL);
    }
    END_SECTION(L"Removing Temporary Files");

    //
    // Log Any failure for SceSetupRootSecurity.
    //
    if( !MiniSetup ) {
        if (bSceSetupRootSecurityComplete == TRUE) {
            SetupDebugPrint(L"SETUP: CallSceSetupRootSecurity completed");
        }
        else {
            SetuplogError( LogSevError, SETUPLOG_USE_MESSAGEID, MSG_LOG_SCE_SETUPROOT_ERROR, L"%windir%", NULL, NULL);
            if( SceSetupRootSecurityThreadHandle){
                TerminateThread( SceSetupRootSecurityThreadHandle, STATUS_TIMEOUT);
                CloseHandle( SceSetupRootSecurityThreadHandle);
            }
        }
    }

    //
    // Clean up
    //
    if( !MiniSetup ) {
        if(NT_SUCCESS(Status)) {
            SetupDebugPrint2(L"SETUP: Changing registry quota from %d to %d...",
                srqi.RegistryQuotaAllowed, RegistryQuota);
            srqi.RegistryQuotaAllowed = RegistryQuota;
            Status = NtSetSystemInformation(SystemRegistryQuotaInformation,
                &srqi, sizeof(srqi));
            if (NT_SUCCESS(Status)) {
                SetupDebugPrint(L"SETUP:    ... succeeded");
            } else {
                SetupDebugPrint(L"SETUP:    ... failed");
            }
        }


        //
        // Now save information about the upgrade/clean install
        // into the eventlog.
        //
        SaveInstallInfoIntoEventLog();
    }

    if( !OobeSetup ) {
        PostMessage(Context->hdlg,WMX_TERMINATE,0,0);
        DeleteObject(hArrow);
        DeleteObject(hCheck);
    }

    END_SECTION(L"FinishThread");
    return 0;
}


VOID
ShutdownSetup(
    VOID
    )
{
    int i;


    if (SyssetupInf) SetupCloseInfFile(SyssetupInf);

    //
    // Inform the user if there were errors, and optionally view the log.
    //
    SetuplogError(
        LogSevInformation,
        SETUPLOG_USE_MESSAGEID,
        MSG_LOG_GUI_END,
        NULL,NULL);
    if ( SavedExceptionFilter ) {
        SetUnhandledExceptionFilter( SavedExceptionFilter );
    }
    TerminateSetupLog(&SetuplogContext);

    if(SetuplogContext.WorstError >= LogSevWarning || !IsErrorLogEmpty()) {

        SendSMSMessage( MSG_SMS_MINORERRORS, TRUE );

#ifdef PRERELEASE
        if(!Unattended) {
            i = MessageBoxFromMessage(
                    MainWindowHandle,
                    MSG_SETUP_HAD_ERRORS,
                    NULL,
                    SetupTitleStringId,
                    MB_SYSTEMMODAL | MB_YESNO | MB_ICONASTERISK | MB_SETFOREGROUND,
                    SETUPLOG_ERROR_FILENAME
                    );

            if(i == IDYES) {
                ViewSetupActionLog (MainWindowHandle, NULL, NULL);
            }
        }
#endif

    } else {

        SendSMSMessage( MSG_SMS_SUCCEED, TRUE );
    }


    //
    // Note : In unattend mode only wait for reboot if
    // specifically asked for using the "WaitForReboot"
    // key
    //
    if(Unattended && UnattendWaitForReboot) {
        //
        // Count down to reboot
        //
        DialogBoxParam(
            MyModuleHandle,
            MAKEINTRESOURCE(IDD_DONE_SUCCESS),
            MainWindowHandle,
            DoneDlgProc,
            SetuplogContext.WorstError >= LogSevError ? MSG_SETUP_DONE_GENERIC
                      : (Upgrade ? MSG_UPGRADE_DONE_SUCCESS : MSG_SETUP_DONE_SUCCESS)
            );
    }

        //
        // do some wow64 syncing stuffs.
        //
#ifdef _WIN64
        Wow64SyncCLSID();
#endif

    //
    // Done.  Post a quit message to our background bitmap thread so it goes
    // away.
    //
    if (SetupWindowHandle)
    {
        // Cannot use DestroyWindow, since the window was created by a different thread.
        SendMessage(SetupWindowHandle, WM_EXIT_SETUPWINDOW, 0, 0);
    }
    if (SetupWindowThreadHandle)
    {
        // Just make sure the thread finishes before continue.
        WaitForSingleObject(SetupWindowThreadHandle, INFINITE);
        CloseHandle(SetupWindowThreadHandle);
    }

    ASSERT_HEAP_IS_VALID();
}


VOID
InstallWindowsNt(
    int  argc,
    char *argv[]
    )

/*++

Routine Description:

    Main entry point for syssetup.dll. Responsible for installing
    NT on system by calling the required components in the proper
    order.

Arguments:

    argc/argv

Returns:

    none

--*/

{
    int i;
    BOOL ValidOption = FALSE;

#ifdef _OCM
    PVOID OcManagerContext;
#endif


    //
    // Indicate that we're running in Setup, not in appwiz.
    // Nothing should come before this!
    //
    IsSetup = TRUE;

    BEGIN_SECTION(L"Installing Windows NT");
#if 1 // NOTE: Can be turned off before we ship if we don't find use for this. Give a 2 second window!

    // If debugger is not already attached to the process and we have the user pressing the Shift+F10 key,
    // launch just cmd.exe to help debug.
    //
//    MessageBox(NULL, L"Hit Shift-F10 Now.", L"Launch Command Window", MB_OK);
    Sleep(2000) ; // Hack: give user 2 seconds to press Shift+F10. Else we could go by too fast!
    if (!IsDebuggerPresent()) {
        SHORT wTemp;
        DWORD dwTemp ;

        wTemp = GetAsyncKeyState(VK_SHIFT) ;
        if (wTemp & 0x8000) { // See if the user is holding down the Shift key or held it before
            wTemp = GetAsyncKeyState(VK_F10) ;

            if (wTemp & 0x8000) { // See if the user is holding down the F10 key also or held it before?

                // InvokeExternalApplication(L"ntsd",  L" -d setup -newsetup", NULL) ; // if kd is enabled, we can do this
                // InvokeExternalApplication(L"ntsd",  L"setup -newsetup", NULL) ; // in no kd, case launch under ntsd locally
                InvokeExternalApplication(L"cmd",  L"", &dwTemp) ;

               return;
            }
        }
    }
#endif

    // Calc. the time estimates
    SetTimeEstimates();

    BEGIN_SECTION(L"Initialization");

    //
    // Tell SetupAPI not to bother backing up files and not to verify
    // that any INFs are digitally signed.
    //
    pSetupSetGlobalFlags(pSetupGetGlobalFlags()|PSPGF_NO_BACKUP|PSPGF_NO_VERIFY_INF);

    //
    // Scan Command Line for -mini or -asr flags
    //
    // -mini enables gui-mode setup but with
    // only a minimal subset of his functionality.  We're going
    // to display a few wizard pages and that's about it.
    //
    // -asr causes the Automated System Recovery (ASR) code to run.
    //
    // -asrquicktest bypasses all of Setup/PnP, and jumps to the
    // ASR disk recofiguration and recovery app code.
    //
    for(i = 0; i < argc; i++) {
        if(argv[i][0] == '-') {
            if(!_strcmpi(argv[i],"-newsetup")) {
                ValidOption = TRUE;
            }

            if(!_strcmpi(argv[i],"-mini")) {
                MiniSetup = TRUE;
                ValidOption = TRUE;
            }

            if(!_strcmpi(argv[i], "-asr")) {
                AsrInitialize();
                ValidOption = TRUE;
            }

            if(!_strcmpi(argv[i], "-asrquicktest")) {
                AsrQuickTest = TRUE;
                ValidOption = TRUE;
                AsrInitialize();
            }
        }
    }

    if( ValidOption == FALSE ){
        WCHAR TitleBuffer[1024], MessageBuffer[1024];
        LoadString(MyModuleHandle, IDS_WINNT_SETUP , TitleBuffer, SIZECHARS(TitleBuffer));
        LoadString(MyModuleHandle, IDS_MAINTOBS_MSG1 , MessageBuffer, SIZECHARS(MessageBuffer));
        MessageBox(NULL, MessageBuffer, TitleBuffer, MB_ICONINFORMATION | MB_OK);
        return;
    }

    // Check if we are in SafeMode ....
    // If so cause a popup and return.

    if( IsSafeMode() ){

        WCHAR TitleBuffer[1024], MessageBuffer[1024];
        LoadString(MyModuleHandle, IDS_WINNT_SETUP , TitleBuffer, SIZECHARS(TitleBuffer));
        LoadString(MyModuleHandle, IDS_SAFEMODENOTALLOWED , MessageBuffer, SIZECHARS(MessageBuffer));
        MessageBox(NULL, MessageBuffer, TitleBuffer, MB_ICONINFORMATION | MB_OK);
        return;
    }



    //
    // If we're running ASR quick tests, jump directly to the recovery code
    //
    if (AsrQuickTest) {
#if DBG
        g_hSysSetupHeap = GetProcessHeap();
#endif
        goto Recovery;
    }
    //
    // super bad hack becase pnp, atapi, and cdrom driver are always broken
    // we open a handle to the first cdrom drive so the drive doesn't get removed
    //

    {
        NTSTATUS Status;
        OBJECT_ATTRIBUTES ObjectAttributes;
        UNICODE_STRING UnicodeString;
        HANDLE Handle;
        IO_STATUS_BLOCK StatusBlock;


        RtlInitUnicodeString(&UnicodeString,L"\\Device\\CdRom0");
        InitializeObjectAttributes(
            &ObjectAttributes,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        SetErrorMode(SEM_FAILCRITICALERRORS);

        Status = NtCreateFile(
            &Handle,
            FILE_READ_ATTRIBUTES,
            &ObjectAttributes,
            &StatusBlock,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_OPEN,
            0,
            NULL,
            0
            );
        if (!NT_SUCCESS(Status)) {
            SetupDebugPrint1( L"Setup: Could not open the cdrom for hack, ec=0x%08x\n", Status );
        }
    }

    //
    // Initialization phase. Common to initial install and upgrade.
    //
    BEGIN_SECTION(L"Common Initialiazation");
#ifdef _OCM
    OcManagerContext =
#endif
    CommonInitialization();
    END_SECTION(L"Common Initialiazation");

    if(Upgrade || MiniSetup) {

        InitializePidVariables();
        TESTHOOK(521);

    } else {
        if(!InitializePidVariables()) {
            FatalError(MSG_SETUP_CANT_READ_PID,0,0);
        }
        //
        // Do the wizard. Time how long it takes, to later help further randomize
        // the account domain sid we're going to generate later.
        //
        PreWizardTickCount = GetTickCount();
    }

    //
    // Disable the PM engine from powering down the machine
    // while the wizard is going.
    //
    SetThreadExecutionState( ES_SYSTEM_REQUIRED |
                             ES_DISPLAY_REQUIRED |
                             ES_CONTINUOUS );

    SetUpDataBlock();
    InternalSetupData.CallSpecificData1 = 0;

    //
    // Create Windows NT software key entry on both upgrade and clean install
    //
    if(Upgrade || !MiniSetup ) {
        CreateWindowsNtSoftwareEntry(TRUE);
    }

    END_SECTION(L"Initialization");


    BEGIN_SECTION(L"Wizard");
#ifdef _OCM
    MYASSERT(OcManagerContext);
    Wizard(OcManagerContext);
    //
    // this call was moved to CopyFilesDlgProc as an optimization
    //
    //KillOcManager(OcManagerContext);
#else
    Wizard();
#endif
    END_SECTION(L"Wizard");

Recovery:

    BEGIN_SECTION(L"Recovery");
    if (AsrIsEnabled()) {
        AsrExecuteRecoveryApps();
    }
    END_SECTION(L"Recovery");

    BEGIN_SECTION(L"Shutdown");
    ShutdownSetup();
    END_SECTION(L"Shutdown");

    RemoveAllPendingOperationsOnRestartOfGUIMode();

    if (hinstBB)
    {
        FreeLibrary(hinstBB);
        hinstBB = NULL;
    }

    LogPidValues();

    END_SECTION(L"Installing Windows NT");
}


VOID
RemoveMSKeyboardPtrPropSheet (
    VOID
    )

/*++

Routine Description:

    Fixes problem with IntelliType Manager under NT 4.0 by disabling it.

Arguments:

    None.

Returns:

    None.

--*/

{
    HKEY  hkeyDir;                     // handle of the key containing the directories
    TCHAR szKbdCpPath[MAX_PATH];       // buffer for the fully-qualified path to INI file
    LONG  lRet;                        // return value from RegQueryValueEx
    DWORD dwDataType;                  // data-type returned from call to RegQueryValueEx
    DWORD BufferSize;
    PCWSTR sz_off = L"OFF";

    //
    // open the key that contains the directories of all the software for all the MS Input Devices
    //
    RegOpenKey ( HKEY_CURRENT_USER,
        L"Control Panel\\Microsoft Input Devices\\Directories", &hkeyDir );

    //
    // get the path to the MS Keyboard software
    //
    BufferSize = sizeof (szKbdCpPath);
    lRet = RegQueryValueEx ( hkeyDir, L"Keyboard", 0, &dwDataType,
        (LPBYTE)szKbdCpPath, &BufferSize);

    //
    // close the directories key now
    //
    RegCloseKey ( hkeyDir );

    // check if we were able to get the directory of the keyboard software; if not, then
    // there may be no keyboard software installed or at least we don't know where
    // to find it; if we got it OK, then use it
    if ( lRet == ERROR_SUCCESS) {

        //
        // we have the path to the INI file, so build the fully qualified path to the INI file
        //
        lstrcat ( szKbdCpPath, L"\\KBDCP.INI" );

        //
        // remove the KBDPTR32.DLL entry from the list of 32-bit property sheet DLLs now,
        // because we don't want it loading on Windows NT 4.0 or later
        WritePrivateProfileString ( L"Property Sheets 32", L"KBDPTR32.DLL",
            NULL, szKbdCpPath );

        lRet = RegOpenKey (HKEY_CURRENT_USER,
            L"Control Panel\\Microsoft Input Devices\\WindowsPointer",
            &hkeyDir);

        if (lRet == ERROR_SUCCESS) {

            RegSetValueEx (
                hkeyDir,
                L"MouseKey",
                0,
                REG_SZ,
                (LPBYTE)sz_off,
                (lstrlen(sz_off)+1) * sizeof(WCHAR)
                );

            RegCloseKey (hkeyDir);
        }
    }
}


VOID
FixWordPadReg (
    VOID
    )

/*++

Routine Description:

    Fixes problem with registry entry that associates .doc files with WordPad.

Arguments:

    None.

Returns:

    None.

--*/

{
    PCWSTR  SearchString  = L"WordPad.Document";
    PCWSTR  ReplaceString = L"WordPad.Document.1";
    LONG    Ret;
    HKEY    Key;
    DWORD   Type;
    BYTE    Data[MAX_PATH];
    DWORD   Size = MAX_PATH;

    Ret = RegOpenKeyEx (
        HKEY_CLASSES_ROOT,
        L".doc",
        0,
        KEY_ALL_ACCESS,
        &Key
        );
    if (Ret != ERROR_SUCCESS) {
        return;
    }

    Ret = RegQueryValueEx (
        Key,
        L"",
        NULL,
        &Type,
        Data,
        &Size
        );
    if (Ret != ERROR_SUCCESS ||
        lstrcmp ((PCWSTR)Data, SearchString)) {

        return;
    }

    RegSetValueEx (
        Key,
        L"",
        0,
        Type,
        (PBYTE)ReplaceString,
        (lstrlen (ReplaceString) + 1) * sizeof (WCHAR)
        );
}


VOID
ProcessRegistryFiles(
    IN  HWND    Billboard
    )

/*++

Routine Description:

    This function processes all the inf files listed in the section
    [RegistryInfs] of syssetup.inf.
    The infs listed in this section will populate/upgrade the DEFAULT
    hive and HKEY_CLASSES_ROOT.

    Note that any errors that occur during this phase are fatal.


Arguments:

    Billboard - Handle to the billboard displayed when this function was called
                If an error occurs, tyhe function will kill the billboard.

Return Value:

    None.
    This function will not return if an error occurs.

--*/

{
    ULONG      LineCount;
    ULONG      LineNo;
    PCWSTR     RegSectionName = L"RegistryInfs";
    PCWSTR     InfName;
    HINF       InfHandle;
    INFCONTEXT InfContext;
    BOOL       b;

    //
    // Get the number of lines in the section. The section may be empty
    // or non-existant; this is not an error condition.
    //
    LineCount = (UINT)SetupGetLineCount(SyssetupInf,RegSectionName);
    if((LONG)LineCount > 0) {
        for(LineNo=0; LineNo<LineCount; LineNo++) {
            if(SetupGetLineByIndex(SyssetupInf,RegSectionName,LineNo,&InfContext) &&
               ((InfName = pSetupGetField(&InfContext,1)) != NULL) ) {

                //
                // Now load the registry (win95-style!) infs.
                //
                //
                InfHandle = SetupOpenInfFile(InfName,NULL,INF_STYLE_WIN4,NULL);

                if(InfHandle == INVALID_HANDLE_VALUE) {
                    KillBillboard(Billboard);
                    FatalError(MSG_LOG_SYSINFBAD,InfName,0,0);
                }

                //
                // Process the inf just opened
                //
                b = SetupInstallFromInfSection( NULL,       // Window,
                                                InfHandle,
                                                (Upgrade)? L"Upgrade" : L"CleanInstall",
                                                SPINST_ALL & ~SPINST_FILES,
                                                NULL,
                                                NULL,
                                                0,
                                                NULL,
                                                NULL,
                                                NULL,
                                                NULL
                                              );
                if(!b) {
                    KillBillboard(Billboard);
                    FatalError(MSG_LOG_SYSINFBAD,InfName,0,0);
                }
            }
        }
    }
}


UCHAR
QueryDriveLetter(
    IN  ULONG       Signature,
    IN  LONGLONG    Offset
    )

{
    PDRIVE_LAYOUT_INFORMATION   layout;
    UCHAR                       c;
    WCHAR                       name[80], result[80], num[10];
    DWORD                       i, j;
    HANDLE                      h;
    BOOL                        b;
    DWORD                       bytes;
    PARTITION_INFORMATION       partInfo;

    layout = LocalAlloc(0, 4096);
    if (!layout) {
        return 0;
    }

    for (c = 'C'; c <= 'Z'; c++) {

        name[0] = c;
        name[1] = ':';
        name[2] = 0;

        if (QueryDosDevice(name, result, 80) < 17) {
            continue;
        }

        j = 0;
        for (i = 16; result[i]; i++) {
            if (result[i] == '\\') {
                break;
            }
            num[j++] = result[i];
        }
        num[j] = 0;

        wsprintf(name, L"\\\\.\\PhysicalDrive%s", num);

        h = CreateFile(name, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                       INVALID_HANDLE_VALUE);
        if (h == INVALID_HANDLE_VALUE) {
            continue;
        }

        b = DeviceIoControl(h, IOCTL_DISK_GET_DRIVE_LAYOUT, NULL, 0, layout,
                            4096, &bytes, NULL);
        CloseHandle(h);
        if (!b) {
            continue;
        }

        if (layout->Signature != Signature) {
            continue;
        }

        wsprintf(name, L"\\\\.\\%c:", c);

        h = CreateFile(name, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                       INVALID_HANDLE_VALUE);
        if (h == INVALID_HANDLE_VALUE) {
            continue;
        }

        b = DeviceIoControl(h, IOCTL_DISK_GET_PARTITION_INFO, NULL, 0,
                            &partInfo, sizeof(partInfo), &bytes, NULL);
        CloseHandle(h);
        if (!b) {
            continue;
        }

        if (partInfo.StartingOffset.QuadPart == Offset) {
            break;
        }
    }

    LocalFree(layout);

    return (c <= 'Z') ? c : 0;
}



MIGDLLINIT MigDllInitProc;
MIGDLLSHUTDOWN MigDllShutdownProc;
MIGDLLCLOSEW MigDllCloseProc;
MIGDLLOPENW MigDllOpenProc;
MIGDLLFREELIST MigDllFreeListProc;
MIGDLLENUMNEXTW MigDllEnumNextProc;
MIGDLLENUMFIRSTW MigDllEnumFirstProc;
MIGDLLADDDLLTOLISTW MigDllAddDllToListProc;
MIGDLLCREATELIST MigDllCreateListProc;
MIGDLLINITIALIZEDSTW MigDllInitializeDstProc;
MIGDLLAPPLYSYSTEMSETTINGSW MigDllApplySystemSettingsProc;

BOOL
LoadMigLibEntryPoints (
    HANDLE Library
    )
{

    MigDllInitProc = (MIGDLLINIT) GetProcAddress (Library, "MigDllInit");
    MigDllShutdownProc = (MIGDLLSHUTDOWN) GetProcAddress (Library, "MigDllShutdown");
    MigDllCloseProc = (MIGDLLCLOSEW) GetProcAddress (Library, "MigDllCloseW");
    MigDllOpenProc = (MIGDLLOPENW) GetProcAddress (Library, "MigDllOpenW");
    MigDllFreeListProc = (MIGDLLFREELIST) GetProcAddress (Library, "MigDllFreeList");
    MigDllEnumNextProc = (MIGDLLENUMNEXTW) GetProcAddress (Library, "MigDllEnumNextW");
    MigDllEnumFirstProc = (MIGDLLENUMFIRSTW) GetProcAddress (Library, "MigDllEnumFirstW");
    MigDllAddDllToListProc = (MIGDLLADDDLLTOLISTW) GetProcAddress (Library, "MigDllAddDllToListW");
    MigDllCreateListProc = (MIGDLLCREATELIST) GetProcAddress (Library, "MigDllCreateList");
    MigDllInitializeDstProc = (MIGDLLINITIALIZEDSTW) GetProcAddress (Library, "MigDllInitializeDstW");
    MigDllApplySystemSettingsProc = (MIGDLLAPPLYSYSTEMSETTINGSW) GetProcAddress (Library, "MigDllApplySystemSettingsW");

    if (!MigDllInitProc ||
        !MigDllShutdownProc ||
        !MigDllCloseProc ||
        !MigDllOpenProc ||
        !MigDllFreeListProc ||
        !MigDllEnumNextProc ||
        !MigDllEnumFirstProc ||
        !MigDllAddDllToListProc ||
        !MigDllCreateListProc ||
        !MigDllInitializeDstProc ||
        !MigDllApplySystemSettingsProc
        ) {

        return FALSE;
    }

    return TRUE;
}

BOOL
CallMigDllEntryPoints (
    PMIGDLLENUM Enum
    )
{
    MIGRATIONDLL dll;
    LONG rc;

    if (!MigDllOpenProc (&dll, Enum->Properties->DllPath, APPLYMODE, FALSE, SOURCEOS_WINNT)) {
        return FALSE;
    }


    __try {

        rc = ERROR_SUCCESS;
        if (!MigDllInitializeDstProc (
            &dll,
            Enum->Properties->WorkingDirectory,
            SourcePath,
            NULL,
            0
            )) {

            rc = GetLastError ();
        }

        if (rc != ERROR_SUCCESS) {
            return FALSE;
        }

        if (!MigDllApplySystemSettingsProc (
            &dll,
            Enum->Properties->WorkingDirectory,
            NULL,
            NULL,
            0
            )) {

            rc = GetLastError ();
        }

        if (rc != ERROR_SUCCESS) {
            return FALSE;
        }

    }
    __finally {
        MigDllCloseProc (&dll);
    }


    return TRUE;
}



BOOL
RunMigrationDlls (
    VOID
    )
{

    WCHAR libraryPath[MAX_PATH];
    HANDLE libHandle = NULL;
    DLLLIST list = NULL;
    MIGDLLENUM e;
    WCHAR DllInfPath[MAX_PATH];
    WCHAR DllPath[MAX_PATH];
    HINF inf;
    INFCONTEXT ic;
    MIGRATIONDLL dll;


    //
    // Build handle to library and load.
    //
    GetSystemDirectory (libraryPath, MAX_PATH);
    pSetupConcatenatePaths (libraryPath, TEXT("miglibnt.dll"), MAX_PATH, NULL);
    libHandle = LoadLibrary (libraryPath);
    if (!libHandle || libHandle == INVALID_HANDLE_VALUE) {
        return TRUE;
    }

    __try {

        if (!LoadMigLibEntryPoints (libHandle)) {
            __leave;
        }

        if (!MigDllInitProc ()) {
            __leave;
        }

        list = MigDllCreateListProc ();

        if (!list) {
            __leave;
        }


        //
        // Read in list of dlls.
        //
        GetWindowsDirectory (DllInfPath, MAX_PATH);
        pSetupConcatenatePaths (DllInfPath, TEXT("Setup\\dlls.inf"), MAX_PATH, NULL);
        inf = SetupOpenInfFile (DllInfPath, NULL, INF_STYLE_WIN4, NULL);
        if (!inf || inf == INVALID_HANDLE_VALUE) {
            __leave;
        }

        if (SetupFindFirstLine (inf, TEXT("DllsToLoad"), NULL, &ic)) {
            do {

                if (SetupGetStringField (&ic, 1, DllPath, MAX_PATH,NULL)) {

                    if (MigDllOpenProc (&dll, DllPath, APPLYMODE, FALSE, SOURCEOS_WINNT)) {

                        MigDllAddDllToListProc (list, &dll);
                        MigDllCloseProc (&dll);
                    }
                }

            } while (SetupFindNextLine (&ic, &ic));
        }


        //
        // Enumerate all migration dlls we ran on the winnt32 side and run
        // their syssetup side entry points.
        //
        if (MigDllEnumFirstProc (&e, list)) {
            do {

                CallMigDllEntryPoints (&e);

            } while (MigDllEnumNextProc (&e));
        }

    }
    __finally {

        if (list) {
            MigDllFreeListProc (list);
        }

        if (libHandle && libHandle != INVALID_HANDLE_VALUE) {

            if( MigDllShutdownProc) {
                MigDllShutdownProc ();
            }

            FreeLibrary (libHandle);
        }
    }

    return TRUE;

}


BOOL
RunSetupPrograms(
    IN PVOID InfHandle,
    PWSTR SectionName
    )

/*++

Routine Description:

    This routine executes the commands listed on [RunPrograms] section in the syssetup inf file.

    Each line is interpreted as a single command.


Arguments:

    None.

Return Value:

    Boolean value indicating outcome.

--*/

{
    WCHAR OldCurrentDir[MAX_PATH];
    WCHAR System32Dir[MAX_PATH];
    LONG LineCount,LineNo;
    PCWSTR CommandLine;
    DWORD DontCare;
    BOOL AnyError;
    INFCONTEXT InfContext;


    //
    // Set current directory to system32.
    // Preserve current directory to minimize side-effects.
    //
    if(!GetCurrentDirectory(MAX_PATH,OldCurrentDir)) {
        OldCurrentDir[0] = 0;
    }
    GetSystemDirectory(System32Dir,MAX_PATH);
    SetCurrentDirectory(System32Dir);

    //
    // Get the number of lines in the section that contains the commands to
    // be executed. The section may be empty or non-existant; this is not
    // an error condition. In that case LineCount may be -1 or 0.
    //
    AnyError = FALSE;
    LineCount = SetupGetLineCount(InfHandle,SectionName);

    for(LineNo=0; LineNo<LineCount; LineNo++) {

        if(SetupGetLineByIndex(InfHandle,SectionName,(DWORD)LineNo,&InfContext)
           && (CommandLine = pSetupGetField(&InfContext,1))) {
                if(!InvokeExternalApplication(NULL,CommandLine,&DontCare)) {
                    AnyError = TRUE;
                    SetupDebugPrint1(L"SETUP: Unable to execute the command: %ls", CommandLine);
                }
        } else {
            //
            // Strange case, inf is messed up
            //
            AnyError = TRUE;
            SetupDebugPrint(L"SETUP: Syssetup.inf is corrupt");
        }
    }

    //
    // Reset current directory and return.
    //
    if(OldCurrentDir[0]) {
        SetCurrentDirectory(OldCurrentDir);
    }

    if(AnyError) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_PROGRAM_FAIL,
            SectionName,
            NULL,NULL);
    }

    return(!AnyError);
}


VOID
GetUnattendRunOnceAndSetRegistry(
    VOID
    )
{
    HINF AnswerInf;
    WCHAR AnswerFile[MAX_PATH];
    WCHAR Buf[128];
    BOOL AnyError;
    INFCONTEXT InfContext;
    LONG LineCount,LineNo;
    PCWSTR SectionName = pwGuiRunOnce;
    PCWSTR CommandLine;
    HKEY hKey;


    GetSystemDirectory(AnswerFile,MAX_PATH);
    pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);

    AnswerInf = SetupOpenInfFile(AnswerFile,NULL,INF_STYLE_OLDNT,NULL);
    if(AnswerInf == INVALID_HANDLE_VALUE) {
        return;
    }

    if (RegOpenKey( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce", &hKey ) != ERROR_SUCCESS) {
        SetupCloseInfFile( AnswerInf );
        return;
    }

    AnyError = FALSE;
    LineCount = SetupGetLineCount(AnswerInf,SectionName);

    for(LineNo=0; LineNo<LineCount; LineNo++) {
        if(SetupGetLineByIndex(AnswerInf,SectionName,(DWORD)LineNo,&InfContext)
           && (CommandLine = pSetupGetField(&InfContext,1)))
        {
            swprintf( Buf, L"%ws%d", SectionName, LineNo );
            if (RegSetValueEx( hKey, Buf, 0, REG_EXPAND_SZ, (LPBYTE)CommandLine, (wcslen(CommandLine)+1)*sizeof(WCHAR) ) != ERROR_SUCCESS) {
                AnyError = TRUE;
            }
        } else {
            //
            // Strange case, inf is messed up
            //
            AnyError = TRUE;
        }
    }

    RegCloseKey( hKey );
    SetupCloseInfFile( AnswerInf );

    return;
}

// This function returns the product flavor as a DWORD.
// NOTE: The value has to be the same as the *_PRODUCTTYPE in winnt32.h
DWORD GetProductFlavor()
{
    DWORD ProductFlavor = 0;        // Default Professional
    OSVERSIONINFOEX osvi;
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    GetVersionEx((OSVERSIONINFO*)&osvi);
    if (osvi.wProductType == VER_NT_WORKSTATION)
    {
        if (osvi.wSuiteMask & VER_SUITE_PERSONAL)
        {
            ProductFlavor = 4;  // Personal
        }
    }
    else
    {
        ProductFlavor = 1;  // In the server case assume normal server
        if (osvi.wSuiteMask & VER_SUITE_DATACENTER)
        {
            ProductFlavor = 3;  // Datacenter
        }
        else if (osvi.wSuiteMask & VER_SUITE_ENTERPRISE)
        {
            ProductFlavor = 2;  // Advanced server
        }
    }
    return ProductFlavor;
}

void PrepareBillBoard(HWND hwnd)
{
    TCHAR szPath[MAX_PATH];
    TCHAR *p;
    WNDCLASS    wndclass;
    INITBILLBOARD pinitbb;

    hinstBB = LoadLibrary(TEXT("winntbbu.dll"));
    if (hinstBB)
    {
        *szPath = 0;
        if (GetModuleFileName (MyModuleHandle, szPath, MAX_PATH))
        {
            if(p = wcsrchr(szPath,L'\\'))
            {
                *p = 0;
            }
        }

        pinitbb = (INITBILLBOARD)GetProcAddress(hinstBB, "InitBillBoard");
        if (pinitbb)
        {
            (*pinitbb)(hwnd, szPath, GetProductFlavor());
            SetBBStep(4);
        }
    }
}

void TerminateBillBoard()
{
    TERMBILLBOARD pTermBillBoard;
    if (hinstBB)
    {
        if (pTermBillBoard = (TERMBILLBOARD)GetProcAddress(hinstBB, "TermBillBoard"))
            pTermBillBoard ();
    }
}


HWND GetBBhwnd()
{
    GETBBHWND pgetbbhwnd;
    static HWND      retHWND = NULL;
    if (retHWND == NULL)
    {
        if (hinstBB)
        {
            if (pgetbbhwnd = (GETBBHWND )GetProcAddress(hinstBB, "GetBBHwnd"))
                retHWND = pgetbbhwnd();
        }
    }
    return retHWND;
}


void SetBBStep(int iStep)
{
    static SETSTEP psetstep = NULL;
    if (psetstep == NULL)
    {
        if (hinstBB)
        {
            psetstep = (SETSTEP )GetProcAddress(hinstBB, "SetStep");
        }
    }
    if (psetstep)
        psetstep(iStep);
}

VOID
CenterWindowRelativeToWindow(
    HWND hwndtocenter,
    HWND hwndcenteron,
    BOOL bWizard
    )

/*++

Routine Description:

    Centers a dialog hwndtocenter on Windows hwndcenteron.
    if bWizard and the height of the hwndcenteron is 480 or less
    align windows to the right edge of the hwndcenteron.
    In all other cases center both ways.

Arguments:

    hwndtocenter - window handle of dialog to center
    hwndcenteron - window handle to center dialog on
    bWizard      - in low res, align dialog with the right
                   edge of hwndcenteron

Return Value:

    None.

--*/

{
    RECT  rcFrame,
          rcWindow;
    LONG  x,
          y,
          w,
          h;
    POINT point;
    HWND Parent;
    UINT uiHeight = 0;

    GetWindowRect(GetDesktopWindow(), &rcWindow);
    uiHeight = rcWindow.bottom - rcWindow.top;

    if (hwndcenteron == NULL)
        Parent = GetDesktopWindow();
    else
        Parent = hwndcenteron;

    point.x = point.y = 0;
    ClientToScreen(Parent,&point);
    GetWindowRect(hwndtocenter,&rcWindow);
    GetClientRect(Parent,&rcFrame);

    w = rcWindow.right  - rcWindow.left + 1;
    h = rcWindow.bottom - rcWindow.top  + 1;
    y = point.y + ((rcFrame.bottom - rcFrame.top  + 1 - h) / 2);


    // Anything but the wizard can stay centered horizontally.
    // or if we don't have a billboard (hwndcenteron == NULL)
    // or if the height of the desktop is more then 480
    // just center
    if (!bWizard || (hwndcenteron == NULL) || (uiHeight > 480))
    {
        x = point.x + ((rcFrame.right  - rcFrame.left + 1 - w) / 2);
    }
    else
    {
        RECT rcParentWindow;

        GetWindowRect(Parent, &rcParentWindow);
        x = point.x + rcParentWindow.right - rcParentWindow.left + 1 - w;
    }

    MoveWindow(hwndtocenter,x,y,w,h,FALSE);
}


VOID
CopyOemProgramFilesDir(
    VOID
    )

/*++

Routine Description:

    Tree copies the $OEM$\\$PROGS to %Program Files% folder.

Arguments:

    None.

Return Value:

    None.

--*/

{
    WCHAR OemDir[MAX_PATH];
    WCHAR ProgramFilesDir[MAX_PATH];
    DWORD Error = NO_ERROR;

    //
    // Build the target Program Files folder path
    //
    ExpandEnvironmentStrings(L"%ProgramFiles%",ProgramFilesDir,MAX_PATH);

    //
    // SourcePath should be initialized to $win_nt$.~ls
    //
    lstrcpy(OemDir,SourcePath);
    pSetupConcatenatePaths(OemDir,WINNT_OEM_DIR,MAX_PATH,NULL);
    pSetupConcatenatePaths(OemDir,WINNT_OEM_FILES_PROGRAMFILES,MAX_PATH,NULL);
    Error = TreeCopy(OemDir,ProgramFilesDir);
    if (!NT_SUCCESS(Error)) {
        SetuplogError(LogSevWarning,
                  L"Setup failed to TreeCopy %2 to %3 (TreeCopy failed %1!u!)\r\n",
                  0, Error, OemDir, ProgramFilesDir, Error, NULL,NULL
                  );
        return;
    }
}


VOID
CopyOemDocumentsDir(
    VOID
    )

/*++

Routine Description:

    Tree copies the $OEM$\\$DOCS to %Document and Settings% folder.

Arguments:

    None.

Return Value:

    None.

--*/

{
    WCHAR OemDir[MAX_PATH];
    WCHAR DocumentsAndSettingsDir[MAX_PATH];
    DWORD Error = NO_ERROR, dwSize = MAX_PATH;

    //
    // Make sure we can get the Documents and Settings folder
    //
    if (GetProfilesDirectory(DocumentsAndSettingsDir,&dwSize))
    {
        //
        // SourcePath should be initialized to $win_nt$.~ls
        //
        lstrcpy(OemDir,SourcePath);
        pSetupConcatenatePaths(OemDir,WINNT_OEM_DIR,MAX_PATH,NULL);
        pSetupConcatenatePaths(OemDir,WINNT_OEM_FILES_DOCUMENTS,MAX_PATH,NULL);
        Error = TreeCopy(OemDir,DocumentsAndSettingsDir);
        if (!NT_SUCCESS(Error)) {
            SetuplogError(LogSevWarning,
                      L"Setup failed to TreeCopy %2 to %3 (TreeCopy failed %1!u!)\r\n",
                      0, Error, OemDir, DocumentsAndSettingsDir, NULL,NULL
                      );
            return;
        }
    }
    else {
        SetuplogError(LogSevWarning,
                  L"SETUP: GetProfilesDirectory() failed in function CopyOemDocumentsDir()\r\n",
                  0, NULL, NULL
                  );
    }
}

BOOL
SystemMyGetUserProfileDirectory(
    IN     LPWSTR szUser,           // a user account name
    OUT    LPWSTR szUserProfileDir, // buffer to receive null terminate string
    IN OUT LPDWORD pcchSize         // input the buffer size in TCHAR, including terminating NULL
    )

/*++

Routine Description:

    This function does what the SDK function GetUserProfileDirectory does,
    except that it accepts a user account name instead of handle to a user
    token.

Return Value:

    TRUE  - Success

    FALSE - Failure

Note:

   This function is copy from msobcomm\misc.cpp exactly. We may want
   to put is to common\util.cpp.

--*/

{
    PSID          pSid = NULL;
    DWORD         cbSid = 0;
    LPWSTR        szDomainName = NULL;
    DWORD         cbDomainName = 0;
    SID_NAME_USE  eUse = SidTypeUser;
    BOOL          bRet;

    bRet = LookupAccountName(NULL,
                             szUser,
                             NULL,
                             &cbSid,
                             NULL,
                             &cbDomainName,
                             &eUse);

    if (!bRet && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {
        pSid = (PSID) LocalAlloc(LPTR, cbSid);
        szDomainName = (LPWSTR) LocalAlloc(LPTR, cbDomainName * sizeof(TCHAR));

        if (pSid && szDomainName)
        {
            bRet = LookupAccountName(NULL,
                                     szUser,
                                     pSid,
                                     &cbSid,
                                     szDomainName,
                                     &cbDomainName,
                                     &eUse);
        }

    }

    if (bRet && SidTypeUser == eUse)
    {
        bRet = GetUserProfileDirFromSid(pSid, szUserProfileDir, pcchSize);
        if (!bRet)
        {
            SetuplogError(LogSevWarning,
                          L"Setup failed to GetUserProfileDirFromSid.  (GetUserProfileDirFromSid failed %1!u!)\r\n",
                          0, GetLastError(), NULL,NULL
                          );
        }
    }
    else
    {
        if (SidTypeUser == eUse)
        {
            SetuplogError(LogSevWarning,
                          L"LookupAccountName %1 (%2!u!)\r\n", 
                          0, szUser, GetLastError(),NULL,NULL 
                          );
        }
    }

    if (pSid)
    {
        LocalFree(pSid);
        pSid = NULL;
    }

    if (szDomainName)
    {
        LocalFree(szDomainName);
        szDomainName = NULL;
    }

    return bRet;
}

BOOL
SystemResetRegistryKey(
    IN HKEY   Rootkey,
    IN PCWSTR Subkey,
    IN PCWSTR Delkey
    )
/*++

Routine Description:

    Reset a registry key by deleting the key and all subvalues
    then recreate the key

Arguments:

Return Value:

--*/

{
    HKEY hkey;
    HKEY nkey;
    DWORD rc;
    BOOL AnyErrors;
    DWORD disp;

    AnyErrors = FALSE;

    rc = RegCreateKeyEx(Rootkey, Subkey, 0L, NULL,
                    REG_OPTION_BACKUP_RESTORE,
                    KEY_CREATE_SUB_KEY, NULL, &hkey, NULL);
    if ( rc == NO_ERROR )
    {
        rc = SHDeleteKey(hkey, Delkey);
        if( (rc != NO_ERROR) && (rc != ERROR_FILE_NOT_FOUND) ) 
        {
            AnyErrors = TRUE;
        } 
        else 
        {
            rc = RegCreateKeyEx(hkey, Delkey, 0L, NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS, NULL, &nkey, &disp);
            if ( rc != NO_ERROR ) 
            {
                AnyErrors = TRUE;
            }
            else
            {
                RegCloseKey(nkey);
            }
        }
        RegCloseKey(hkey);
    } 
    else 
    {
        AnyErrors = TRUE;
    }

    return (!AnyErrors);
}


BOOL
SystemUpdateUserProfileDirectory(
    IN LPTSTR szSrcUser
    )
{

#define DUMMY_HIVE_NAME      L"$$DEFAULT_USER$$"
#define ACTIVE_SETUP_KEY     DUMMY_HIVE_NAME L"\\SOFTWARE\\Microsoft\\Active Setup"
#define ACTIVE_SETUP_SUBKEY  L"Installed Components"

    BOOL  bRet = FALSE;
    WCHAR szSrcProfileDir[MAX_PATH];
    DWORD cchSrcProfileDir = MAX_PATH;
    WCHAR szDestProfileDir[MAX_PATH];
    DWORD cchDestProfileDir = MAX_PATH;
    WCHAR szDefaultUserHivePath[MAX_PATH];
    HKEY  hHiveKey = NULL;
    DWORD rc;

    if (!SystemMyGetUserProfileDirectory(szSrcUser, szSrcProfileDir, &cchSrcProfileDir))
    {
        SetuplogError(LogSevWarning,
                      L"Setup failed to get user profile directory.  (SystemMyGetUserProfileDirectory failed %1!u!)\r\n",
                      0, GetLastError(), NULL,NULL
                      );

        goto cleanup;
    }

    if (!GetDefaultUserProfileDirectory(szDestProfileDir, &cchDestProfileDir))
    {
        SetuplogError(LogSevWarning,
                      L"Setup failed to get default user profile directory.  (GetDefaultUserProfileDirectory failed %1!u!)\r\n",
                      0, GetLastError(), NULL,NULL
                      );

        goto cleanup;
    }

    if (!CopyProfileDirectory(
        szSrcProfileDir,
        szDestProfileDir,
        CPD_FORCECOPY | CPD_SYNCHRONIZE | CPD_NOERRORUI | CPD_IGNORECOPYERRORS))
    {
        SetuplogError(LogSevWarning,
                      L"Setup failed to CopyProfileDirectory.  (CopyProfileDirectory failed %1!u!)\r\n",
                      0, GetLastError(), NULL,NULL
                      );

        goto cleanup;
    }

    //
    // Fix default user hive
    //

    pSetupEnablePrivilege(SE_RESTORE_NAME, TRUE);

    lstrcpyn(szDefaultUserHivePath, szDestProfileDir, ARRAYSIZE(szDefaultUserHivePath));
    
    pSetupConcatenatePaths(
        szDefaultUserHivePath,
        L"NTUSER.DAT",
        ARRAYSIZE(szDefaultUserHivePath),
        NULL);

    rc = RegLoadKey(
            HKEY_USERS,
            DUMMY_HIVE_NAME,
            szDefaultUserHivePath);

    if (rc != ERROR_SUCCESS)
    {
        SetuplogError(LogSevWarning,
                      L"Setup failed to load Default User hive.  (RegLoadKey failed %1!u!)\r\n",
                      0, rc, NULL,NULL
                      ); 

        goto cleanup;
    }

    //
    // The active setup component install keys of the cloned profile contains 
    // the version checking information. Remove the keys so that components will
    // run per-user initialization code properly.
    //

    if (!SystemResetRegistryKey(
            HKEY_USERS, 
            ACTIVE_SETUP_KEY,
            ACTIVE_SETUP_SUBKEY))
    {
        SetuplogError(LogSevWarning,
                      L"Setup failed to load Default User hive.  (SystemResetRegistryKey failed)\r\n",
                      0, NULL,NULL
                      ); 
    }

    RegUnLoadKey(
        HKEY_USERS,
        DUMMY_HIVE_NAME
        );

    bRet = TRUE;

cleanup:

    return bRet;
}

BOOL 
UpdateServerProfileDirectory(
    VOID
    )

/*++

Routine Description:

    Copy the customized user profile (administrator) to all user profiles.

Arguments:

    None.

Return Value:

    Boolean.

--*/

{
    BOOL bRet = FALSE;
    WCHAR szTemplateUser[MAX_PATH];

    BEGIN_SECTION(L"Updating Server Profile Directories");
    if(LoadString(MyModuleHandle,
        IDS_ADMINISTRATOR,
        szTemplateUser,
        MAX_PATH) != 0)
    {
        if ( !(bRet = SystemUpdateUserProfileDirectory(szTemplateUser)) )
        {
            SetuplogError(LogSevWarning,
                          L"Setup failed to update server profile directory.\r\n",
                          0, NULL, NULL,NULL
                          );
        }
    }
    END_SECTION(L"Updating Server Profile Directories");

    return bRet;
}


BOOL 
OpkCheckVersion(
    DWORD dwMajorVersion,
    DWORD dwQFEVersion
    )

/*++

Routine Description:

    Checks whether OPK tool with specified version numbers is allowed to run on this OS.

Arguments:

    DWORD dwMajorVersion - Major version number for tool.
    DWORD dwQFEVersion   - QFE version number for tool.

Return Value:

    TRUE  - Tool is allowed to run on this OS.
    FALSE - Tool is not allowed to run on this OS.

--*/
{
    BOOL bRet = TRUE,
         bXP  = FALSE;  // Variable is TRUE if this is 2600 XP build. It is set below.
    HKEY hKey = NULL;



    LPTSTR lpszRegPath = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\SysPrep");

    if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                        lpszRegPath,
                                        0,
                                        KEY_QUERY_VALUE,
                                        &hKey ) )
    {
        DWORD  dwType           = 0,
               cbBuildNumber    = 0;
        LPTSTR lpszBuildNumber  = NULL;

        if ( 2600 == dwMajorVersion )
        {
            bXP = TRUE;
        }

        //
        // Read the minimum allowed build number from the registry:
        //
        // 1. Get the size of the data in the registry
        // 2. Allocate a buffer
        // 3. Read the data.
        //
        if ( ( ERROR_SUCCESS == RegQueryValueEx( hKey,
                                                 bXP ? _T("XPMinVersion") : _T("NETMinVersion"),
                                                 NULL,
                                                 &dwType,
                                                 NULL,
                                                 &cbBuildNumber ) ) &&
             ( cbBuildNumber > 0 ) &&
             ( lpszBuildNumber = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, cbBuildNumber ) ) && 
             ( ERROR_SUCCESS == RegQueryValueEx( hKey,
                                                 bXP ? _T("XPMinVersion") : _T("NETMinVersion"),
                                                 NULL,
                                                 &dwType,
                                                 (LPBYTE) lpszBuildNumber,
                                                 &cbBuildNumber ) ) &&
             ( REG_SZ == dwType ) )
        {
            LPTSTR lpTemp            = NULL;
            DWORD  dwMinMajorVersion = 0,
                   dwMinQFEVersion   = 0;
            
            //
            // Parse the string that we got from the registry into major version and QFE version.
            //
            if ( lpTemp = _tcsstr( lpszBuildNumber, _T(".") ) )
            {
                *lpTemp = _T('\0');
                
                // Get the Major version of the build number
                //
                dwMinMajorVersion = _tstoi( lpszBuildNumber );
                
                // Advance past the NULL separator that we added.
                //
                lpTemp++;
                dwMinQFEVersion = _tstoi( lpTemp );
                
                //
                // Now make sure we are allowed to run
                //

                if ( dwMajorVersion < dwMinMajorVersion )
                {
                    //
                    // If major version is less than minimum allowed major version don't let it run.
                    //
                    bRet = FALSE;
                }
                else if ( dwMajorVersion == dwMinMajorVersion )
                {
                    //
                    // If major version is equal to the minimum allowed major version then check at the QFE field.
                    // 
                    if ( dwQFEVersion < dwMinQFEVersion )
                    {
                        bRet = FALSE;
                    }
                }
            }
        }

        if ( lpszBuildNumber )
        {
            HeapFree( GetProcessHeap(), 0, lpszBuildNumber );
        }
        
        RegCloseKey( hKey );
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\syssec.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    syssec.c

Abstract:

    Security installation routines.

Author:

    Vijesh Shetty (vijeshs) 6-Mar-1997

Revision History:


--*/

#include "setupp.h"
#include "scesetup.h"
#pragma hdrstop

#if DBG
    #define SEC_DEBUG  1
#else
    #define SEC_DEBUG  0
#endif


#define SECURITY_WKS_INF_FILE L"defltwk.inf"
#define SECURITY_SRV_INF_FILE L"defltsv.inf"

//
// Structure for thread parameter
//
typedef struct _SYSSEC_THREAD_PARAMS {

    HWND  Window;
    HWND  ProgressWindow;
    DWORD ThreadId;
    ULONG Sec_StartAtPercent;
    ULONG Sec_StopAtPercent;
    BOOL  SendWmQuit;

} SYSSEC_THREAD_PARAMS, *PSYSSEC_THREAD_PARAMS;

BOOL SetupSecurityGaugeUpdate(
                             IN HWND Window,
                             IN UINT NotificationCode,
                             IN UINT NotificationSpecificValue,
                             IN LPARAM lParam );



HWND SetupProgWindow;
HANDLE SceSetupRootSecurityThreadHandle = NULL;
BOOL bSceSetupRootSecurityComplete = FALSE;


DWORD
pSetupInstallSecurity(
                     IN PVOID ThreadParam
                     )
{
    BOOL b;
    BOOL Success;
    UINT i;
    UINT GaugeRange;
    PSYSSEC_THREAD_PARAMS Context;
    DWORD NumberOfTicks;
    DWORD_PTR ret;
    HINSTANCE Dll_Handle;
    FARPROC SceSystem;
    WCHAR SecurityLogPath[MAX_PATH];
    DWORD Result;


    KdPrintEx((DPFLTR_SETUP_ID,
               DPFLTR_INFO_LEVEL,
               "SETUP:            Entering Security Block. \n"));

    Context = ThreadParam;


    //
    // Assume success.
    //
    Success = TRUE;


    try{



    if ( (Dll_Handle = LoadLibrary( L"scecli.dll" )) &&
         (SceSystem = GetProcAddress(Dll_Handle,"SceSetupSystemByInfName")) ) {


        Result = GetWindowsDirectory( SecurityLogPath, MAX_PATH );
        if( Result == 0) {
            MYASSERT(FALSE);
            return FALSE;
        }
        pSetupConcatenatePaths( SecurityLogPath, L"security\\logs\\scesetup.log", (sizeof(SecurityLogPath)/sizeof(WCHAR)), NULL );

        //
        //Call for no. of ticks
        //

        if ( ret = SceSystem(ProductType ? SECURITY_SRV_INF_FILE : SECURITY_WKS_INF_FILE,
                             SecurityLogPath,
                             Upgrade ? 0 : (AREA_FILE_SECURITY | AREA_REGISTRY_SECURITY),
                             Upgrade ? (SCESETUP_QUERY_TICKS | SCESETUP_UPGRADE_SYSTEM) : SCESETUP_QUERY_TICKS,
                             SetupSecurityGaugeUpdate,
                             (PVOID)&NumberOfTicks) ) {

            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SETUP: Error in SCE while querying ticks - (%d)\n",
                       ret));

            SetuplogError(
                         LogSevError,
                         SETUPLOG_USE_MESSAGEID,
                         MSG_LOG_SCE_SETUP_ERROR,
                         NULL,
                         SETUPLOG_USE_MESSAGEID,
                         ret, NULL, NULL);
            Success = FALSE;
        } else {

            GaugeRange = (NumberOfTicks*100/(Context->Sec_StopAtPercent - Context->Sec_StartAtPercent));
            SendMessage(Context->ProgressWindow, WMX_PROGRESSTICKS, NumberOfTicks, 0);
            SendMessage(Context->ProgressWindow,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
            SendMessage(Context->ProgressWindow,PBM_SETPOS,GaugeRange*Context->Sec_StartAtPercent/100,0);
            SendMessage(Context->ProgressWindow,PBM_SETSTEP,1,0);



            if ( ret = SceSystem(ProductType ? SECURITY_SRV_INF_FILE : SECURITY_WKS_INF_FILE,
                                 SecurityLogPath,
                                 Upgrade ? 0 : (AREA_FILE_SECURITY | AREA_REGISTRY_SECURITY),
                                 Upgrade ? SCESETUP_UPGRADE_SYSTEM : SCESETUP_CONFIGURE_SECURITY,
                                 SetupSecurityGaugeUpdate,
                                 (PVOID)(Context->ProgressWindow) )) {

                KdPrintEx((DPFLTR_SETUP_ID,
                           DPFLTR_WARNING_LEVEL,
                           "SETUP: Error in SCE while setting security - (%d)\n",
                           ret));

                SetuplogError(
                             LogSevError,
                             SETUPLOG_USE_MESSAGEID,
                             MSG_LOG_SCE_SETUP_ERROR,
                             NULL,
                             SETUPLOG_USE_MESSAGEID,
                             ret, NULL, NULL);

                Success = FALSE;
            }

        }

        FreeLibrary(Dll_Handle);

    } else {

        if ( Dll_Handle )
            FreeLibrary(Dll_Handle);


        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SETUP: Error while loading SCE\n"));

        SetuplogError(
                     LogSevError,
                     SETUPLOG_USE_MESSAGEID,
                     MSG_LOG_LOAD_SECURITY_LIBRARY_FAILED,NULL,NULL);


    }

    } except(EXCEPTION_EXECUTE_HANDLER) {


        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SETUP: Exception in SCE while applying default security \n"));

        SetuplogError(
                     LogSevError,
                     SETUPLOG_USE_MESSAGEID,
                     MSG_LOG_SCE_EXCEPTION,NULL,NULL);

    }


    SendMessage(Context->ProgressWindow,PBM_SETPOS,(GaugeRange*Context->Sec_StopAtPercent/100),0);

    if ( Context->SendWmQuit ) {
        //
        //  We send WM_QUIT only if this routine was started as a separate thread.
        //  Otherwise, the WM_QUIT will be processed by the wizard, and it will make it stop.
        //
        PostThreadMessage(Context->ThreadId,WM_QUIT,Success,0);
    }

    KdPrintEx((DPFLTR_SETUP_ID,
               DPFLTR_INFO_LEVEL,
               "SETUP:            Leaving Security Block. \n"));

    return(Success);
}


BOOL
SetupInstallSecurity(
                    IN HWND Window,
                    IN HWND ProgressWindow,
                    IN ULONG StartAtPercent,
                    IN ULONG StopAtPercent
                    )

/*++

Routine Description:

    Implement Security at start of GUI Setup.

Arguments:

    Window - supplies window handle for Window that is to be the
        parent/owner for any dialogs that are created, etc.

    ProgressWindow - supplies window handle of progress bar Window
        common control. This routine manages the progress bar.

    StartAtPercent - Position where the progress window should start (0% to 100%).

    StopAtPercent - Maximum position where the progress window can be moved to (0% to 100%).


Return Value:

    Boolean value indicating whether all operations completed successfully.

--*/
{
    DWORD ThreadId;
    HANDLE ThreadHandle = NULL;
    MSG msg;
    SYSSEC_THREAD_PARAMS Context;
    BOOL Success;





    Context.ThreadId = GetCurrentThreadId();
    Context.Window = Window;
    Context.Sec_StartAtPercent = StartAtPercent;
    Context.Sec_StopAtPercent = StopAtPercent;
    Context.SendWmQuit = TRUE;
    Context.ProgressWindow = ProgressWindow;

    ThreadHandle = CreateThread(
                               NULL,
                               0,
                               pSetupInstallSecurity,
                               &Context,
                               0,
                               &ThreadId
                               );
    if (ThreadHandle) {

        CloseHandle(ThreadHandle);

        //
        // Pump the message queue and wait for the thread to finish.
        //
        do {
            GetMessage(&msg,NULL,0,0);
            if (msg.message != WM_QUIT) {
                DispatchMessage(&msg);
            }
        } while (msg.message != WM_QUIT);

        Success = (BOOL)msg.wParam;

    } else {
        //
        // Just do it synchronously.
        //
        Context.SendWmQuit = FALSE;
        Success = pSetupInstallSecurity(&Context);
    }

    return(Success);



}

BOOL
SetupSecurityGaugeUpdate(
                             IN HWND Window,
                             IN UINT NotificationCode,
                             IN UINT NotificationSpecificValue,
                             IN LPARAM lParam )
{
    SendMessage(Window,PBM_STEPIT,0,0);
    return( TRUE );
}


VOID
CallSceGenerateTemplate( VOID )
{

    HINSTANCE Dll_Handle;
    FARPROC SceCall;

    try{


        if ( (Dll_Handle = LoadLibrary( L"scecli.dll" )) &&
             (SceCall = GetProcAddress(Dll_Handle,"SceSetupBackupSecurity")) ) {

            // We don't log errors for this call

            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_INFO_LEVEL,
                       "SETUP:            SCE Generating Security Template. \n"));

            SceCall( NULL );

            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_INFO_LEVEL,
                       "SETUP:            SCE Generating Security Template. Done ! \n"));

            FreeLibrary( Dll_Handle );

        } else {

            if ( Dll_Handle )
                FreeLibrary(Dll_Handle);

            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SETUP: Error while loading SCE\n"));


            SetuplogError(
                         LogSevError,
                         SETUPLOG_USE_MESSAGEID,
                         MSG_LOG_LOAD_SECURITY_LIBRARY_FAILED,NULL,NULL);


        }
    } except(EXCEPTION_EXECUTE_HANDLER) {

        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SETUP: Exception in SCE while generating security template (non-critical) \n"));

        SetuplogError(
                     LogSevError,
                     SETUPLOG_USE_MESSAGEID,
                     MSG_LOG_SCE_EXCEPTION,NULL,NULL);

    }

    return;
}

VOID
CallSceConfigureServices( VOID )
{

    HINSTANCE Dll_Handle;
    FARPROC SceCall;

    try{


        if ( (Dll_Handle = LoadLibrary( L"scecli.dll" )) &&
             (SceCall = GetProcAddress(Dll_Handle,"SceSetupConfigureServices")) ) {

            // We don't log errors for this call

            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_INFO_LEVEL,
                       "SETUP:            SCE Configuring services. \n"));

            SceCall( ProductType );

            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_INFO_LEVEL,
                       "SETUP:            SCE Configuring services. Done ! \n"));

            FreeLibrary( Dll_Handle );

        } else {

            if ( Dll_Handle )
                FreeLibrary(Dll_Handle);

            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SETUP: Error while loading SCE\n"));


            SetuplogError(
                         LogSevError,
                         SETUPLOG_USE_MESSAGEID,
                         MSG_LOG_LOAD_SECURITY_LIBRARY_FAILED,NULL,NULL);


        }
    } except(EXCEPTION_EXECUTE_HANDLER) {

        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SETUP: Exception in SCE while configuring services (non-critical) \n"));

        SetuplogError(
                     LogSevError,
                     SETUPLOG_USE_MESSAGEID,
                     MSG_LOG_SCE_EXCEPTION,NULL,NULL);

    }

    return;
}


DWORD
pSceSetupRootSecurity( 
    IN PVOID ThreadParam
)
{

    HINSTANCE Dll_Handle;
    FARPROC SceCall;
    BOOL Success = FALSE;

    try{


        if ( (Dll_Handle = LoadLibrary( L"scecli.dll" )) &&
             (SceCall = GetProcAddress(Dll_Handle,"SceSetupRootSecurity")) ) {

            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_INFO_LEVEL,
                       "SETUP:            SCE Setup root security. \n"));

            BEGIN_SECTION(L"SceSetupRootSecurity");
            SceCall();
            Success = TRUE;

            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_INFO_LEVEL,
                       "SETUP:            SCE Setup root security. Done ! \n"));

            bSceSetupRootSecurityComplete = TRUE;
            END_SECTION(L"SceSetupRootSecurity");

            FreeLibrary( Dll_Handle );

        } else {

            if ( Dll_Handle )
                FreeLibrary(Dll_Handle);

            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_WARNING_LEVEL,
                       "SETUP: Error while loading SCE\n"));


            SetuplogError(
                         LogSevError,
                         SETUPLOG_USE_MESSAGEID,
                         MSG_LOG_LOAD_SECURITY_LIBRARY_FAILED,NULL,NULL);


        }
    } except(EXCEPTION_EXECUTE_HANDLER) {

        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SETUP: Exception in SCE while setting root security (non-critical) \n"));

        SetuplogError(
                     LogSevError,
                     SETUPLOG_USE_MESSAGEID,
                     MSG_LOG_SCE_EXCEPTION,NULL,NULL);

    }

    return( Success);
}

VOID
CallSceSetupRootSecurity( VOID )
{
    DWORD ThreadId;

    SceSetupRootSecurityThreadHandle = CreateThread(
                               NULL,
                               0,
                               pSceSetupRootSecurity,
                               0,
                               0,
                               &ThreadId
                               );
    if ( !SceSetupRootSecurityThreadHandle) {
        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "SETUP: SCE Could not start thread to setup root security(non-critical) \n"));

        SetuplogError(
                     LogSevError,
                     SETUPLOG_USE_MESSAGEID,
                     MSG_LOG_SCE_EXCEPTION,NULL,NULL);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\sif.h ===
#ifndef _SIF_H_
#define _SIF_H_

extern const WCHAR          pwGuiUnattended[];
extern const WCHAR          pwUserData[];
extern const WCHAR          pwUnattended[];
extern const WCHAR          pwAccessibility[];
extern const WCHAR          pwProgram[];
extern const WCHAR          pwArgument[];
extern const WCHAR          pwServer[];
extern const WCHAR          pwTimeZone[];
extern const WCHAR          pwGuiRunOnce[];
extern const WCHAR          pwCompatibility[];
extern const WCHAR          pwAutoLogon[];
extern const WCHAR          pwProfilesDir[];
extern const WCHAR          pwProgramFilesDir[];
extern const WCHAR          pwCommonProgramFilesDir[];
extern const WCHAR          pwProgramFilesX86Dir[];
extern const WCHAR          pwCommonProgramFilesX86Dir[];
extern const WCHAR          pwWaitForReboot[];
extern const WCHAR          pwFullName[];
extern const WCHAR          pwOrgName[];
extern const WCHAR          pwCompName[];
extern const WCHAR          pwAdminPassword[];
extern const WCHAR          pwProdId[];
extern const WCHAR          pwProductKey[];
extern const WCHAR          pwMode[];
extern const WCHAR          pwUnattendMode[];
extern const WCHAR          pwAccMagnifier[];
extern const WCHAR          pwAccReader[];
extern const WCHAR          pwAccKeyboard[];
extern const WCHAR          pwNull[];
extern const WCHAR          pwExpress[];
extern const WCHAR          pwTime[];
extern const WCHAR          pwProduct[];
extern const WCHAR          pwMsDos[];
extern const WCHAR          pwWin31Upgrade[];
extern const WCHAR          pwWin95Upgrade[];
extern const WCHAR          pwBackupImage[];
extern const WCHAR          pwServerUpgrade[];
extern const WCHAR          pwNtUpgrade[];
extern const WCHAR          pwBootPath[];
extern const WCHAR          pwLanmanNt[];
extern const WCHAR          pwServerNt[];
extern const WCHAR          pwWinNt[];
extern const WCHAR          pwNt[];
extern const WCHAR          pwInstall[];
extern const WCHAR          pwUnattendSwitch[];
extern const WCHAR          pwRunOobe[];
extern const WCHAR          pwReferenceMachine[];
extern const WCHAR          pwOptionalDirs[];
extern const WCHAR          pwUXC[];
extern const WCHAR          pwSkipMissing[];
extern const WCHAR          pwIncludeCatalog[];
extern const WCHAR          pwDrvSignPol[];
extern const WCHAR          pwNonDrvSignPol[];
extern const WCHAR          pwYes[];
extern const WCHAR          pwNo[];
extern const WCHAR          pwZero[];
extern const WCHAR          pwOne[];
extern const WCHAR          pwIgnore[];
extern const WCHAR          pwWarn[];
extern const WCHAR          pwBlock[];
extern const WCHAR          pwData[];
extern const WCHAR          pwSetupParams[];
extern const WCHAR          pwSrcType[];
extern const WCHAR          pwSrcDir[];
extern const WCHAR          pwCurrentDir[];
extern const WCHAR          pwDosDir[];
extern const WCHAR          pwGuiAttended[];
extern const WCHAR          pwProvideDefault[];
extern const WCHAR          pwDefaultHide[];
extern const WCHAR          pwReadOnly[];
extern const WCHAR          pwFullUnattended[];
extern const WCHAR          pwEulaDone[];

#define ArcPrefixLen            (lstrlen(pwArcPrefix))
#define NtPrefixLen             (lstrlen(pwNtPrefix))
#define ISUNC(sz)               ((BOOL)(sz != NULL && lstrlen(sz) > 3 && \
                                    *sz == L'\\' && *(sz+1) == L'\\'))
extern const WCHAR          pwArcType[];
extern const WCHAR          pwDosType[];
extern const WCHAR          pwUncType[];
extern const WCHAR          pwNtType[];
extern const WCHAR          pwArcPrefix[];
extern const WCHAR          pwNtPrefix[];
extern const WCHAR          pwLocalSource[];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\sif.c ===
#include "setupp.h"
#pragma hdrstop

//
// IMPORTANT: keep the following strings ENTIRELY in LOWER CASE
// Failure to do so will result in much grief and pain.
//

// Section Headings
const WCHAR pwGuiUnattended[]   = WINNT_GUIUNATTENDED;
const WCHAR pwUserData[]        = WINNT_USERDATA;
const WCHAR pwUnattended[]      = WINNT_UNATTENDED;
const WCHAR pwAccessibility[]   = WINNT_ACCESSIBILITY;
const WCHAR pwGuiRunOnce[]      = WINNT_GUIRUNONCE;
const WCHAR pwCompatibility[]   = WINNT_COMPATIBILITYINFSECTION;

// Key Headings
const WCHAR pwProgram[]         = WINNT_G_DETACHED;
const WCHAR pwArgument[]        = WINNT_G_ARGUMENTS;
const WCHAR pwServer[]          = WINNT_G_SERVERTYPE;
const WCHAR pwTimeZone[]        = WINNT_G_TIMEZONE;
const WCHAR pwAutoLogon[]       = WINNT_US_AUTOLOGON;
const WCHAR pwProfilesDir[]     = WINNT_US_PROFILESDIR;
const WCHAR pwProgramFilesDir[]             = WINNT_U_PROGRAMFILESDIR;
const WCHAR pwCommonProgramFilesDir[]       = WINNT_U_COMMONPROGRAMFILESDIR;
const WCHAR pwProgramFilesX86Dir[]          = WINNT_U_PROGRAMFILESDIR_X86;
const WCHAR pwCommonProgramFilesX86Dir[]    = WINNT_U_COMMONPROGRAMFILESDIR_X86;
const WCHAR pwWaitForReboot[]   = WINNT_U_WAITFORREBOOT;
const WCHAR pwFullName[]        = WINNT_US_FULLNAME;
const WCHAR pwOrgName[]         = WINNT_US_ORGNAME;
const WCHAR pwCompName[]        = WINNT_US_COMPNAME;
const WCHAR pwAdminPassword[]   = WINNT_US_ADMINPASS;
const WCHAR pwProdId[]          = WINNT_US_PRODUCTID;
const WCHAR pwProductKey[]      = WINNT_US_PRODUCTKEY;
const WCHAR pwMode[]            = WINNT_U_METHOD;
const WCHAR pwUnattendMode[]    = WINNT_U_UNATTENDMODE;
const WCHAR pwAccMagnifier[]    = WINNT_D_ACC_MAGNIFIER;
const WCHAR pwAccReader[]       = WINNT_D_ACC_READER;
const WCHAR pwAccKeyboard[]     = WINNT_D_ACC_KEYBOARD;

// Default Headings
const WCHAR pwNull[]            = WINNT_A_NULL;
const WCHAR pwExpress[]         = WINNT_A_EXPRESS;
const WCHAR pwTime[]            = L"(GMT-08:00) Pacific Time (US & Canada); Tijuana";

// These are used to read the parameters from textmode
const WCHAR pwProduct[]         = WINNT_D_PRODUCT;
const WCHAR pwMsDos[]           = WINNT_D_MSDOS;
const WCHAR pwWin31Upgrade[]    = WINNT_D_WIN31UPGRADE;
const WCHAR pwWin95Upgrade[]    = WINNT_D_WIN95UPGRADE;
const WCHAR pwBackupImage[]     = WINNT_D_BACKUP_IMAGE;
const WCHAR pwServerUpgrade[]   = WINNT_D_SERVERUPGRADE;
const WCHAR pwNtUpgrade[]       = WINNT_D_NTUPGRADE;
const WCHAR pwBootPath[]        = WINNT_D_BOOTPATH;
const WCHAR pwLanmanNt[]        = WINNT_A_LANMANNT;
const WCHAR pwServerNt[]        = WINNT_A_SERVERNT;
const WCHAR pwWinNt[]           = WINNT_A_WINNT;
const WCHAR pwNt[]              = WINNT_A_NT;
const WCHAR pwInstall[]         = WINNT_D_INSTALL;
const WCHAR pwUnattendSwitch[]  = WINNT_D_UNATTEND_SWITCH;
const WCHAR pwRunOobe[]         = WINNT_D_RUNOOBE;
const WCHAR pwReferenceMachine[] = WINNT_D_REFERENCE_MACHINE;
const WCHAR pwOptionalDirs[]    = WINNT_S_OPTIONALDIRS;
const WCHAR pwUXC[]             = WINNT_S_USEREXECUTE;
const WCHAR pwSkipMissing[]     = WINNT_S_SKIPMISSING;
const WCHAR pwIncludeCatalog[]  = WINNT_S_INCLUDECATALOG;
const WCHAR pwDrvSignPol[]      = WINNT_S_DRVSIGNPOL;
const WCHAR pwNonDrvSignPol[]   = WINNT_S_NONDRVSIGNPOL;
const WCHAR pwYes[]             = WINNT_A_YES;
const WCHAR pwNo[]              = WINNT_A_NO;
const WCHAR pwOne[]             = WINNT_A_ONE;
const WCHAR pwZero[]            = WINNT_A_ZERO;
const WCHAR pwIgnore[]          = WINNT_A_IGNORE;
const WCHAR pwWarn[]            = WINNT_A_WARN;
const WCHAR pwBlock[]           = WINNT_A_BLOCK;
const WCHAR pwData[]            = WINNT_DATA;
const WCHAR pwSetupParams[]     = WINNT_SETUPPARAMS;
const WCHAR pwSrcType[]         = WINNT_D_SRCTYPE;
const WCHAR pwSrcDir[]          = WINNT_D_SOURCEPATH;
const WCHAR pwCurrentDir[]      = WINNT_D_CWD;
const WCHAR pwDosDir[]          = WINNT_D_DOSPATH;
const WCHAR pwGuiAttended[]     = WINNT_A_GUIATTENDED;
const WCHAR pwProvideDefault[]  = WINNT_A_PROVIDEDEFAULT;
const WCHAR pwDefaultHide[]     = WINNT_A_DEFAULTHIDE;
const WCHAR pwReadOnly[]        = WINNT_A_READONLY;
const WCHAR pwFullUnattended[]  = WINNT_A_FULLUNATTENDED;
const WCHAR pwEulaDone[]        = WINNT_D_EULADONE;

// These are used as string constants throughout
const WCHAR pwArcType[]         = L"ARC";
const WCHAR pwDosType[]         = L"DOS";
const WCHAR pwUncType[]         = L"UNC";
const WCHAR pwNtType[]          = L"NT";
const WCHAR pwArcPrefix[]       = L"\\ArcName\\";
const WCHAR pwNtPrefix[]        = L"\\Device\\";
const WCHAR pwLocalSource[]     = L"\\$WIN_NT$.~LS";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\syspnp.c ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    syspnp.c

Abstract:

    Device installation routines.

Author:

    Jaime Sasson (jaimes) 6-Mar-1997

Revision History:


--*/

#include "setupp.h"
#pragma hdrstop

//
// Provide extern references to device (setup) class GUIDs instantiated in
// clasinst.c.
//
#include <devguid.h>

//
// Define and initialize a global variable, GUID_NULL
// (from coguid.h)
//
#include <initguid.h>

//
// UpdateDriverForPlugAndPlayDevices constants
//
#include <newdev.h>

DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

#define PNP_NEW_HW_PIPE             TEXT("\\\\.\\pipe\\PNP_New_HW_Found")
#define PNP_CREATE_PIPE_EVENT       TEXT("PNP_Create_Pipe_Event")
#define PNP_BATCH_PROCESSED_EVENT   TEXT("PNP_Batch_Processed_Event")
#define PNP_PIPE_TIMEOUT            180000

#ifdef PRERELEASE

//
// legacy-phase1 can take a long time in certain cases
//
#define PNP_LEGACY_PHASE1_TIMEOUT   2*60*1000
#define PNP_LEGACY_PHASE2_TIMEOUT   1*60*1000
#define PNP_LEGACY_PHASE3_TIMEOUT   1*60*1000
#define PNP_ENUM_TIMEOUT            1*60*1000
#define RUNONCE_TIMEOUT             1*60*1000
#define RUNONCE_THRESHOLD           20 // * RUNONCE_TIMEOUT

#else  // PRERELEASE

//
// legacy-phase1 can take a long time in certain cases
//
#define PNP_LEGACY_PHASE1_TIMEOUT   4*60*1000
#define PNP_LEGACY_PHASE2_TIMEOUT   2*60*1000
#define PNP_LEGACY_PHASE3_TIMEOUT   2*60*1000
#define PNP_ENUM_TIMEOUT            2*60*1000
#define RUNONCE_TIMEOUT             2*60*1000
#define RUNONCE_THRESHOLD           20 // * RUNONCE_TIMEOUT

#endif // PRERELEASE

//
// Declare a private INF key string recogized only by syssetup during device
// installation...
//
PWSTR  szSyssetupPnPFlags = L"SyssetupPnPFlags";
//
// ...and define the flags that are valid for this value
//
#define PNPFLAG_DONOTCALLCONFIGMG   0x00000001


#define SETUP_OEM_LDR_DEVICE        0x00000001


//
//  REVIEW 2000/11/08 seanch - Old behavior that we don't want to regress.
//           Remove the #define below, after the network guys (jameelh) fix
//           the network class installer. This should happen before beta2
//
#define BB_PNP_NETWORK_TIMEOUT  10*60*1000
#define BB_NETWORK_GUID_STRING  L"{4D36E972-E325-11CE-BFC1-08002BE10318}"

#ifdef PNP_DEBUG_UI
#define UNKNOWN_DEVICE_ICON_INDEX   18

typedef struct _LISTBOX_ITEM {
    HDEVINFO        DevInfoSet;
    SP_DEVINFO_DATA DeviceInfoData;
    INT             IconIndex;
    WCHAR           DeviceDescription[ LINE_LEN ];
} *PLISTBOX_ITEM, LISTBOX_ITEM;


typedef struct _DEVINFOSET_ELEMENT {
    struct  _DEVINFOSET_ELEMENT     *Next;
    HDEVINFO                        DevInfoSet;
    GUID                            SetGuid;
} *PDEVINFOSET_ELEMENT, DEVINFOSET_ELEMENT;


PDEVINFOSET_ELEMENT DevInfoSetList = NULL;
PWSTR               szUnknownDevice = NULL;
#endif // PNP_DEBUG_UI

BOOL                PrivilegeAlreadySet = FALSE;
//
// pnplog.txt is the file that lists the class installers
// that hang during GUI setup, so that when GUI setup is restarted,
// the offendig class installers will not be invoked again.
// This file is created during GUI setup on %SystemRoot%, and is always
// deleted during textmode setup (the file is listed on txtsetup.sif as
// "delete on upgrade").
// This file will never exist when the system first boots into GUI setup,
// immediately after the completion of textmode setup. This is
// to ensure that an old version of pnplog.txt will not affect the
// upgrade case, or a clean install of a system that is installed on
// a directory that already contains an NT system.
//
PWSTR               szPnpLogFile = L"pnplog.txt";
PWSTR               szEnumDevSection = L"EnumeratedDevices";
PWSTR               szLegacyClassesSection = L"LegacyClasses";
PWSTR               szLegacyDevSection = L"LegacyDevices";

//
// multi-sz list of files that is passed to SfcInitProt that the initial scan
// will not replace. This is used for non-signed drivers that are specified
// by F6 during textmode setup.
//
MULTISZ EnumPtrSfcIgnoreFiles = {NULL, NULL, 0};

//
// Structure for thread parameter
//
typedef struct _PNP_THREAD_PARAMS {
    HWND  Window;
    HWND  ProgressWindow;
    DWORD ThreadId;
    HINF  InfHandle;
    UINT  ProgressWindowStartAtPercent;
    UINT  ProgressWindowStopAtPercent;
    BOOL  SendWmQuit;
} PNP_THREAD_PARAMS, *PPNP_THREAD_PARAMS;

typedef struct _INF_FILE_NAME {
    struct  _INF_FILE_NAME     *Next;
    PWSTR                      InfName;
} *PINF_FILE_NAME, INF_FILE_NAME;


typedef struct _PNP_ENUM_DEV_THREAD_PARAMS {
    HDEVINFO              hDevInfo;
    SP_DEVINFO_DATA       DeviceInfoData;
    PWSTR                 pDeviceDescription;
    PWSTR                 pDeviceId;
} PNP_ENUM_DEV_THREAD_PARAMS, *PPNP_ENUM_DEV_THREAD_PARAMS;

typedef struct _PNP_PHASE1_LEGACY_DEV_THREAD_PARAMS {
    HDEVINFO              hDevInfo;
    GUID                  Guid;
    PWSTR                 pClassDescription;
    HWND                  hwndParent;
} PNP_PHASE1_LEGACY_DEV_THREAD_PARAMS, *PPNP_PHASE1_LEGACY_DEV_THREAD_PARAMS;


typedef struct _PNP_PHASE2_LEGACY_DEV_THREAD_PARAMS {
    HDEVINFO              hDevInfo;
    HSPFILEQ              FileQ;
    SP_DEVINFO_DATA       DeviceInfoData;
    PWSTR                 pClassDescription;
    PWSTR                 pDeviceId;
} PNP_PHASE2_LEGACY_DEV_THREAD_PARAMS, *PPNP_PHASE2_LEGACY_DEV_THREAD_PARAMS;


typedef struct _PNP_PHASE3_LEGACY_DEV_THREAD_PARAMS {
    HDEVINFO              hDevInfo;
    SP_DEVINFO_DATA       DeviceInfoData;
    PWSTR                 pDeviceId;
} PNP_PHASE3_LEGACY_DEV_THREAD_PARAMS, *PPNP_PHASE3_LEGACY_DEV_THREAD_PARAMS;

//
// private cfgmgr32 API that we use
//

DWORD
CMP_WaitNoPendingInstallEvents(
    IN DWORD dwTimeout
    );

//
// for run-time loading of newdev.dll
//

typedef BOOL (WINAPI *ExternalUpdateDriverForPlugAndPlayDevicesW)(
    HWND hwndParent,
    LPCWSTR HardwareId,
    LPCWSTR FullInfPath,
    DWORD InstallFlags,
    PBOOL bRebootRequired OPTIONAL
    );


//
// Private routine prototypes
//

VOID
SortClassGuidListForDetection(
    IN OUT LPGUID GuidList,
    IN     ULONG  GuidCount,
    OUT    PULONG LastBatchedDetect
    );

DWORD
pPhase1InstallPnpLegacyDevicesThread(
    PPNP_PHASE1_LEGACY_DEV_THREAD_PARAMS ThreadParams
    );

DWORD
pPhase2InstallPnpLegacyDevicesThread(
    PPNP_PHASE2_LEGACY_DEV_THREAD_PARAMS ThreadParams
    );

DWORD
pPhase3InstallPnpLegacyDevicesThread(
    PPNP_PHASE3_LEGACY_DEV_THREAD_PARAMS ThreadParams
    );

DWORD
pInstallPnpEnumeratedDeviceThread(
    PPNP_ENUM_DEV_THREAD_PARAMS ThreadParams
    );

BOOL
GetDeviceConfigFlags(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDeviceInfoData,
    DWORD* pdwConfigFlags
    );

BOOL
SetDeviceConfigFlags(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDeviceInfoData,
    DWORD dwConfigFlags
    );

BOOL
InstallOEMInfs(
    VOID
    );

#if defined(_X86_)
VOID
SfcExcludeMigratedDrivers (
    VOID
    );
#endif

BOOL
CallRunOnceAndWait();

BOOL
MarkPnpDevicesAsNeedReinstall(
    );

ULONG
SyssetupGetPnPFlags(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    IN PSP_DRVINFO_DATA pDriverInfoData
    );

BOOL
IsInstalledInfFromOem(
    IN PCWSTR InfFileName
    );

BOOL
IsInfInLayoutInf(
    IN PCWSTR InfFileName
    );


#ifdef PNP_DEBUG_UI
VOID
FreeDevInfoSetList(
    IN PDEVINFOSET_ELEMENT  DevInfoSetList
    )
/*++

Routine Description:

    This function frees each element of a device info set list.

Arguments:

    DevInfoSetList - The array of info sets that is to be freed.

Return Value:

    None.

--*/
{
    PDEVINFOSET_ELEMENT p, q;

    p = DevInfoSetList;
    while( p != NULL ) {
        if( ( p->DevInfoSet != NULL ) &&
            ( p->DevInfoSet != INVALID_HANDLE_VALUE )
          ) {
            SetupDiDestroyDeviceInfoList(p->DevInfoSet);
        }
        q = p->Next;
        MyFree( p );
        p = q;
    }
}
#endif // PNP_DEBUG_UI

#ifdef PNP_DEBUG_UI
BOOL
AddDevInfoDataToDevInfoSet(
    IN OUT PDEVINFOSET_ELEMENT*  DevInfoSetList,
    IN     PSP_DEVINFO_DATA      DeviceInfoData,
    IN     PWSTR                 DeviceId,
    IN     HWND                  hwndParent
    )
/*++

Routine Description:

    This function adds a device info data to a device info set that contains
    other device info data of the same GUID. If such info set doesn't exist,
    then one is created, and it will be added to the array of info sets passed
    as parameter.

Arguments:

    DevInfoSetList - Pointer to the array of info sets. If this function creates
                     a new info set, then it will be added to this array.


    DeviceInfoData - Device info data to be added to an info set that has elements
                     with the same GUID as the device info data.


    DeviceId - Id of the device being added to an info set.


    hwndParent - Handle to a top level window that may be used for UI purposes


Return Value:

    BOOL - This function returns TRUE if the device info data was successfully added
           to a device info set. Otherwise, it returns FALSE.

--*/
{
    BOOL                b;
    HDEVINFO            hDevInfo;
    PDEVINFOSET_ELEMENT p;

    for( p = *DevInfoSetList; p != NULL; p = p->Next ) {
        //
        //  Find an info set, whose elements have the same GUID as the device
        //  that we want to add to the list.
        //
        if( IsEqualGUID( &(p->SetGuid), &(DeviceInfoData->ClassGuid) ) ) {
            //
            //  If an info set was found, then add the device to the set.
            //
            if( !SetupDiOpenDeviceInfo( p->DevInfoSet,
                                        DeviceId,
                                        hwndParent,
                                        DIOD_INHERIT_CLASSDRVS,
                                        NULL ) ) {

                SetupDebugPrint1( L"SETUP: SetupDiOpenDeviceInfo() failed. Error = %d", GetLastError() );
                return( FALSE );
            }
            return( TRUE );
        }
    }

    //
    //  If an info set was not foud, then create one.
    //
    if((hDevInfo = SetupDiCreateDeviceInfoList(&(DeviceInfoData->ClassGuid), hwndParent))
                        == INVALID_HANDLE_VALUE) {
        SetupDebugPrint1( L"SETUP: SetupDiCreateDeviceInfoList() failed. Error = %d", GetLastError );
        return( FALSE );
    }

    //
    //  Add a device info to the info set
    //
    if( !SetupDiOpenDeviceInfo( hDevInfo,
                                DeviceId,
                                hwndParent,
                                DIOD_INHERIT_CLASSDRVS,
                                NULL ) ) {

        SetupDebugPrint1( L"SETUP: SetupDiOpenDeviceInfo() failed. Error = %d", GetLastError() );
        SetupDiDestroyDeviceInfoList(hDevInfo);
        return( FALSE );
    }
    //
    //  Add the newly created info set to the info set list
    //
    p = MyMalloc( sizeof(DEVINFOSET_ELEMENT) );
    if( p == NULL ) {
        SetupDebugPrint( L"SETUP: Out of memory - AddDevInfoDataToDevInfoSet()" );
        SetupDiDestroyDeviceInfoList(hDevInfo);
        return( FALSE );
    }

    p->DevInfoSet = hDevInfo;
    p->SetGuid = DeviceInfoData->ClassGuid;
    p->Next = *DevInfoSetList;
    *DevInfoSetList = p;

    return( TRUE );
}
#endif // PNP_DEBUG_UI

UINT
pOemF6ScanQueueCallback(
    PVOID Context,
    UINT Notification,
    UINT_PTR Param1,
    UINT_PTR Param2
    )
{
    PFILEPATHS FilePaths = (PFILEPATHS)Param1;

    //
    // Add the Target filename to the list of files that Sfc should ignore when
    // doing it's final scan at the end of GUI setup.
    //
    if (Notification == SPFILENOTIFY_QUEUESCAN_EX) {
        if (FilePaths->Target) {
            MultiSzAppendString(&EnumPtrSfcIgnoreFiles, FilePaths->Target);
        }
    }

    return NO_ERROR;
}

void
AddOemF6DriversToSfcIgnoreFilesList(
    IN HDEVINFO         hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData
    )
/*++

Routine Description:


Arguments:

    hDevInfo -

    pDeviceInfoData -

Return Value:


--*/
{
    HSPFILEQ FileQueue = INVALID_HANDLE_VALUE;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINSTALL_PARAMS DriverInstallParams;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    DWORD ScanResult;

    //
    // First check that the selected driver that we just installed is an OEM F6
    // driver.
    //
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    DriverInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);
    if (SetupDiGetSelectedDriver(hDevInfo,
                                 pDeviceInfoData,
                                 &DriverInfoData) &&
        SetupDiGetDriverInstallParams(hDevInfo,
                                      pDeviceInfoData,
                                      &DriverInfoData,
                                      &DriverInstallParams) &&
        (DriverInstallParams.Flags & DNF_OEM_F6_INF)) {
        //
        // This is an OEM F6 driver.
        //
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (!SetupDiGetDeviceInstallParams(hDevInfo,
                                           pDeviceInfoData,
                                           &DeviceInstallParams)) {
            goto clean0;
        }

        FileQueue = SetupOpenFileQueue();

        if (FileQueue == INVALID_HANDLE_VALUE) {
            goto clean0;
        }

        DeviceInstallParams.FileQueue = FileQueue;
        DeviceInstallParams.Flags |= DI_NOVCP;

        //
        // Set the device install params to use our file queue and call
        // DIF_INSTALLDEVICEFILES to build up a list of files for this device.
        //
        if (SetupDiSetDeviceInstallParams(hDevInfo,
                                          pDeviceInfoData,
                                          &DeviceInstallParams) &&
            SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES,
                                      hDevInfo,
                                      pDeviceInfoData)) {
            SetupScanFileQueue(FileQueue,
                               SPQ_SCAN_USE_CALLBACKEX,
                               NULL,
                               pOemF6ScanQueueCallback,
                               NULL,
                               &ScanResult);
        }
    }

clean0:

    if (FileQueue != INVALID_HANDLE_VALUE) {
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(hDevInfo,
                                          pDeviceInfoData,
                                          &DeviceInstallParams)) {
            DeviceInstallParams.Flags &= ~DI_NOVCP;
            DeviceInstallParams.FileQueue = INVALID_HANDLE_VALUE;

            SetupDiSetDeviceInstallParams(hDevInfo,
                                          pDeviceInfoData,
                                          &DeviceInstallParams);
        }

        SetupCloseFileQueue(FileQueue);
    }
}


BOOL
GetClassGuidForInf(
    IN  PCTSTR InfFileName,
    OUT LPGUID ClassGuid
    )
{
    TCHAR ClassName[MAX_CLASS_NAME_LEN];
    DWORD NumGuids;

    if(!SetupDiGetINFClass(InfFileName,
                           ClassGuid,
                           ClassName,
                           SIZECHARS(ClassName),
                           NULL)) {
        return FALSE;
    }

    if(pSetupIsGuidNull(ClassGuid)) {
        //
        // Then we need to retrieve the GUID associated with the INF's class name.
        // (If this class name isn't installed (i.e., has no corresponding GUID),
        // or if it matches with multiple GUIDs, then we abort.
        //
        if(!SetupDiClassGuidsFromName(ClassName, ClassGuid, 1, &NumGuids) || !NumGuids) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
InstallPnpClassInstallers(
    IN HWND hwndParent,
    IN HINF InfHandle,
    IN HSPFILEQ FileQ
    )
{
    INFCONTEXT InfContext;
    UINT LineCount,LineNo;
    PCWSTR  SectionName = L"DeviceInfsToInstall";
    PCWSTR  IfExistsSectionName = L"DeviceInfsToInstallIfExists";
    PCWSTR  InfFileName;
    GUID    InfClassGuid;
    HKEY    hClassKey;
    BOOL    b = TRUE;

    SC_HANDLE SCMHandle, ServiceHandle;
    SERVICE_STATUS ServiceStatus;


    //
    // Before we do anything else, we have to make sure that the Plug&Play service is up and
    // running, otherwise our ConfigMgr calls will fail, and we won't be able to migrate devices.
    //
    if(SCMHandle = OpenSCManager(NULL, NULL, GENERIC_READ)) {

        if(ServiceHandle = OpenService(SCMHandle, L"PlugPlay", SERVICE_QUERY_STATUS)) {

            while(TRUE) {

                if(!QueryServiceStatus(ServiceHandle, &ServiceStatus)) {
                    //
                    // Couldn't find out the status of the Plug&Play service--hope for the best
                    // and trudge on ahead.
                    //
                    SetupDebugPrint1( L"SETUP: QueryServiceStatus() failed. Error = %d", GetLastError() );
                    SetupDebugPrint( L"SETUP: Couldn't find out the status of the Plug&Play service" );
                    break;
                }

                if(ServiceStatus.dwCurrentState == SERVICE_RUNNING) {
                    //
                    // The service is up and running, we can do our business.
                    //
                    break;
                }

                //
                // The service hasn't started yet--print a message, then wait a second
                // and try again.
                //
                SetupDebugPrint( L"SETUP: PlugPlay service isn't running yet--sleeping 1 second..." );

                Sleep(1000);
            }

            CloseServiceHandle(ServiceHandle);
        }

        CloseServiceHandle(SCMHandle);
    }

    //
    // Get the number of lines in the section that contains the infs whose
    // classes are to be installed.
    // The section may be empty or non-existant; this is not an error condition.
    //
    LineCount = (UINT)SetupGetLineCount(InfHandle,SectionName);
    if((LONG)LineCount > 0) {
        for(LineNo=0; LineNo<LineCount; LineNo++) {
            if(SetupGetLineByIndex(InfHandle,SectionName,LineNo,&InfContext)
            && (InfFileName = pSetupGetField(&InfContext,1))) {
                if( !SetupDiInstallClass( hwndParent,
                                          InfFileName,
                                          DI_NOVCP | DI_FORCECOPY,
                                          FileQ ) ) {
                    SetupDebugPrint2( L"SETUP: SetupDiInstallClass() failed. Filename = %ls Error = %lx.", InfFileName, GetLastError() );
                    b = FALSE;
                }
            }
        }
    }

    //
    // Get the number of lines in the section that contains the infs whose
    // classes are to be installed if they already exist.
    // The section may be empty or non-existant; this is not an error condition.
    //
    LineCount = (UINT)SetupGetLineCount(InfHandle,IfExistsSectionName);
    if((LONG)LineCount > 0) {
        for(LineNo=0; LineNo<LineCount; LineNo++) {
            if(SetupGetLineByIndex(InfHandle,IfExistsSectionName,LineNo,&InfContext)
            && (InfFileName = pSetupGetField(&InfContext,1))) {

                //
                // Check to see if this section already exists in the registry
                //
                if (GetClassGuidForInf(InfFileName, &InfClassGuid)) {

                    if (CM_Open_Class_Key(&InfClassGuid,
                                          NULL,
                                          KEY_READ,
                                          RegDisposition_OpenExisting,
                                          &hClassKey,
                                          CM_OPEN_CLASS_KEY_INSTALLER
                                          ) == CR_SUCCESS) {

                        RegCloseKey(hClassKey);

                        //
                        // This class already exists so we need to reinstall it
                        //
                        if( !SetupDiInstallClass( hwndParent,
                                                  InfFileName,
                                                  DI_NOVCP | DI_FORCECOPY,
                                                  FileQ ) ) {
                            SetupDebugPrint2( L"SETUP: SetupDiInstallClass() failed. Filename = %ls Error = %lx.", InfFileName, GetLastError() );
                            b = FALSE;
                        }
                    }
                }
            }
        }
    }

    return( b );
}


ULONG
FindNumberOfElementsInInfoSet(
    IN HDEVINFO hDevInfo
    )
{
    SP_DEVINFO_DATA DeviceInfoData;
    ULONG           Index;
    ULONG           Error;

    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    for( Index = 0;
         SetupDiEnumDeviceInfo( hDevInfo, Index, &DeviceInfoData );
         Index++ );
    if( ( Error = GetLastError() ) != ERROR_NO_MORE_ITEMS ) {
        //
        //  We were enable to enumerated all devices in the info set.
        //  This should not have happened.
        //
        SetupDebugPrint2( L"SETUP: SetupDiEnumDeviceInfo() failed. Index = %d, Error = %d", Index, Error );
    }
    return( Index );
}

BOOL
FlushFilesToDisk(
    IN PWSTR RootPath
    )

/*++

Routine Description:

    This function flushes the cache of a particular drive, to disk.

Arguments:

    Path to the root directory of the drive whose cache is to be flushed.

Return Value:

    Returns TRUE if the operation succeeds, or FALSE otherwise.

--*/

{
    HANDLE RootHandle;
    LONG   Error;

    //
    // Enable backup privilege.
    //
    if( !PrivilegeAlreadySet ) {
        PrivilegeAlreadySet = pSetupEnablePrivilege(SE_BACKUP_NAME,TRUE) && pSetupEnablePrivilege(SE_RESTORE_NAME,TRUE);
    }
    RootHandle = CreateFile( RootPath,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_BACKUP_SEMANTICS,
                             0
                           );
    if( RootHandle == INVALID_HANDLE_VALUE ) {
        SetupDebugPrint2( L"SETUP: Failed to open %ls. Error = %d", RootPath, GetLastError() );
        return( FALSE );
    }

    //
    //  Flush the cache
    //
    Error = ( FlushFileBuffers( RootHandle ) )? ERROR_SUCCESS : GetLastError();
    CloseHandle( RootHandle );
    if( Error != ERROR_SUCCESS ) {
        SetupDebugPrint2( L"SETUP: FlushFileBuffers() failed. Root = %ls, Error = %d", RootPath, Error );
    }
    return( Error == ERROR_SUCCESS );
}


BOOL
SyssetupInstallNullDriver(
    IN HDEVINFO         hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData
    )

/*++

Routine Description:

    This function installs a the null driver for a particular device.

Arguments:

    hDevInfo    -

    pDeviceInfoData -

Return Value:

    Returns TRUE if the null driver was successfully installed.

--*/

{
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    DWORD                Error;
    PWSTR                GUIDUnknownString = L"{4D36E97E-E325-11CE-BFC1-08002BE10318}";

    Error = ERROR_SUCCESS;

    //
    //  Find out if the GUID of this device is GUID_NULL.
    //  If it is then set it to GUID_DEVCLASS_UNKNOWN, so that after the sysstem is installed,
    //  the Device Manager can include this device in the device tree.
    //
    if(IsEqualGUID(&(pDeviceInfoData->ClassGuid), &GUID_NULL)) {
        SetupDebugPrint( L"SETUP:            Setting GUID_DEVCLASS_UNKNOWN for this device" );
        if( !SetupDiSetDeviceRegistryProperty( hDevInfo,
                                               pDeviceInfoData,
                                               SPDRP_CLASSGUID,
                                               (PBYTE)GUIDUnknownString,
                                               (wcslen(GUIDUnknownString) + 1)*sizeof(WCHAR) ) ) {
            Error = GetLastError();
            if( ((LONG)Error) < 0 ) {
                //
                //  Setupapi error code, display it in hex
                //
                SetupDebugPrint1( L"SETUP:            SetupDiSetDeviceRegistryProperty(SPDRP_CLASSGUID) failed. Error = %lx", Error );
            } else {
                //
                //  win32 error code, display it in decimal
                //
                SetupDebugPrint1( L"SETUP:            SetupDiSetDeviceRegistryProperty(SPDRP_CLASSGUID) failed. Error = %d", Error );
            }
            //
            //  In case of error we just ignore the error
            //
            Error = ERROR_SUCCESS;
        }
    } else {
            WCHAR           GUIDString[ 64 ];

            pSetupStringFromGuid( &(pDeviceInfoData->ClassGuid), GUIDString, sizeof( GUIDString ) / sizeof( WCHAR ) );
            SetupDebugPrint1( L"SETUP:            GUID = %ls", GUIDString );
    }

    if( !SetupDiSetSelectedDriver( hDevInfo,
                                   pDeviceInfoData,
                                   NULL ) ) {

        Error = GetLastError();
        if( ((LONG)Error) < 0 ) {
            //
            //  Setupapi error code, display it in hex
            //
            SetupDebugPrint1( L"SETUP:            SetupDiSetSelectedDriver() failed. Error = %lx", Error );
        } else {
            //
            //  win32 error code, display it in decimal
            //
            SetupDebugPrint1( L"SETUP:            SetupDiSetSelectedDriver() failed. Error = %d", Error );
        }
        return( FALSE );
    }

    //
    // Let the class installer/co-installers know they should be quiet.
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if( !SetupDiGetDeviceInstallParams( hDevInfo,
                                        pDeviceInfoData,
                                        &DeviceInstallParams ) ) {
        Error = GetLastError();
        if( ((LONG)Error) < 0 ) {
            //
            //  Setupapi error code, display it in hex
            //
            SetupDebugPrint1( L"SETUP:            SetupDiGetDeviceInstallParams() failed. Error = %lx", Error );
        } else {
            //
            //  win32 error code, display it in decimal
            //
            SetupDebugPrint1( L"SETUP:            SetupDiGetDeviceInstallParams() failed. Error = %d", Error );
        }
    } else {

        DeviceInstallParams.Flags |= DI_QUIETINSTALL;
        DeviceInstallParams.FlagsEx |= DI_FLAGSEX_RESTART_DEVICE_ONLY;

        if( !SetupDiSetDeviceInstallParams( hDevInfo,
                                            pDeviceInfoData,
                                            &DeviceInstallParams ) ) {
            Error = GetLastError();
            if( ((LONG)Error) < 0 ) {
                //
                //  Setupapi error code, display it in hex
                //
                SetupDebugPrint1( L"SETUP:            SetupDiSetDeviceInstallParams() failed. Error = %lx", Error );
            } else {
                //
                //  win32 error code, display it in decimal
                //
                SetupDebugPrint1( L"SETUP:            SetupDiSetDeviceInstallParams() failed. Error = %d", Error );
            }
        }
    }

    //
    //  First, attempt to install the null driver without setting DI_FLAGSEX_SETFAILEDINSTALL.
    //  Installation of LEGACY_* devices should succeed in this case.
    //
    //  We do this through the class installer, in case it needs to clean-up
    //  turds from a previous installation (see RAID #266793).
    //
    if(SetupDiCallClassInstaller(DIF_INSTALLDEVICE,
                                 hDevInfo,
                                 pDeviceInfoData)) {
        //
        //  Istallation succeeded.
        //
        return( TRUE );
    }

    Error = GetLastError();
    if( ((LONG)Error) < 0 ) {
        //
        //  Setupapi error code, display it in hex
        //
        SetupDebugPrint1( L"SETUP:            SetupDiCallClassInstaller(DIF_INSTALLDEVICE) failed on first attempt. Error = %lx", Error );
    } else {
        //
        //  win32 error code, display it in decimal
        //
        SetupDebugPrint1( L"SETUP:            SetupDiCallClassInstaller(DIF_INSTALLDEVICE) failed on first attempt. Error = %d", Error );
    }
    SetupDebugPrint( L"SETUP:            Trying a second time with DI_FLAGSEX_SETFAILEDINSTALL set." );

    //
    //  The first attempt to install the null driver (without setting DI_FLAGSEX_SETFAILEDINSTALL)
    //  failed.
    //  So we set the flag and try it again.
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if( !SetupDiGetDeviceInstallParams( hDevInfo,
                                        pDeviceInfoData,
                                        &DeviceInstallParams ) ) {
        Error = GetLastError();
        if( ((LONG)Error) < 0 ) {
            //
            //  Setupapi error code, display it in hex
            //
            SetupDebugPrint1( L"SETUP:            SetupDiGetDeviceInstallParams() failed. Error = %lx", Error );
        } else {
            //
            //  win32 error code, display it in decimal
            //
            SetupDebugPrint1( L"SETUP:            SetupDiGetDeviceInstallParams() failed. Error = %d", Error );
        }
        return( FALSE );

    }
    DeviceInstallParams.FlagsEx |= DI_FLAGSEX_SETFAILEDINSTALL;
    if( !SetupDiSetDeviceInstallParams( hDevInfo,
                                        pDeviceInfoData,
                                        &DeviceInstallParams ) ) {
        Error = GetLastError();
        if( ((LONG)Error) < 0 ) {
            //
            //  Setupapi error code, display it in hex
            //
            SetupDebugPrint1( L"SETUP:            SetupDiSetDeviceInstallParams() failed. Error = %lx", Error );
        } else {
            //
            //  win32 error code, display it in decimal
            //
            SetupDebugPrint1( L"SETUP:            SetupDiSetDeviceInstallParams() failed. Error = %d", Error );
        }
        return( FALSE );
    }

    if(!SetupDiCallClassInstaller(DIF_INSTALLDEVICE,
                                  hDevInfo,
                                  pDeviceInfoData)) {

        Error = GetLastError();
        if( ((LONG)Error) < 0 ) {
            //
            //  Setupapi error code, display it in hex
            //
            SetupDebugPrint1( L"SETUP:            SetupDiCallClassInstaller(DIF_INSTALLDEVICE) failed. Error = %lx", Error );
        } else {
            //
            //  win32 error code, display it in decimal
            //
            SetupDebugPrint1( L"SETUP:            SetupDiCallClassInstaller(DIF_INSTALLDEVICE) failed. Error = %d", Error );
        }
        return( FALSE );
    }
    return( TRUE );
}

BOOL
RebuildListWithoutOldInternetDrivers(
    IN HDEVINFO         hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData
    )

/*++

Routine Description:

    This function determins whether SetupDiBuildDriverInfoList will need to be
    called again with the DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS flag set. We first
    call SetupDiBuildDriverInfoList without this flag to allow old Internet drivers
    to be included in the best driver selection. If an old Internet driver is
    selected as the best then we need to do a validity check to verify that all
    the destination files are present on the system and correctly digitally signed.
    If both of these are true then we can allow this old internet driver to stay
    the best driver since it won't prompt for source files.

    We need to do this for the case when a user is running a previous OS and they
    get a better driver from Windows Update. We can't blindly replace the Windows
    Update driver with the drivers in the new OS since they might not be better.

Arguments:


    hDevInfo -

    pDeviceInfoData -

Return Value:

    Returns TRUE if the list needs to be rebuilt with the DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS
    flag and FALSE otherwise.

    Note if this API returns FALSE it either means the best driver was not an old
    internet driver or that it was but all of it's destination files are present
    and correctly digitally signed so no file copy will need to take place.

--*/

{
    BOOL                 RebuildList = FALSE;
    SP_DRVINFO_DATA      DriverInfoData;
    SP_DRVINSTALL_PARAMS DriverInstallParams;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    HSPFILEQ             FileQueue = INVALID_HANDLE_VALUE;
    DWORD                ScanResult = 0;

    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (SetupDiGetSelectedDriver(hDevInfo, pDeviceInfoData, &DriverInfoData)) {
        DriverInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);
        if (SetupDiGetDriverInstallParams(hDevInfo,
                                          pDeviceInfoData,
                                          &DriverInfoData,
                                          &DriverInstallParams
                                          ) &&
            (DriverInstallParams.Flags & DNF_OLD_INET_DRIVER)) {

            //
            // At this point we know that the best driver is an old Internet driver.
            // Now do a validity check which will verify all the source files are
            // present and digitally signed. We will also assume we need to rebuild
            // the list at this point unless we pass the validity check below.
            //
            RebuildList = TRUE;

            FileQueue = SetupOpenFileQueue();

            if (FileQueue != INVALID_HANDLE_VALUE) {

                //
                // Tell setupapi to use our file queue.
                //
                DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
                if (SetupDiGetDeviceInstallParams(hDevInfo,
                                                  pDeviceInfoData,
                                                  &DeviceInstallParams
                                                  )) {
                    DeviceInstallParams.Flags |= DI_NOVCP;
                    DeviceInstallParams.FileQueue = FileQueue;

                    if (SetupDiSetDeviceInstallParams(hDevInfo,
                                                      pDeviceInfoData,
                                                      &DeviceInstallParams
                                                      )) {
                        if (SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES,
                                                      hDevInfo,
                                                      pDeviceInfoData
                                                      ) &&
                            SetupScanFileQueue(FileQueue,
                                               SPQ_SCAN_FILE_VALIDITY,
                                               NULL,
                                               NULL,
                                               NULL,
                                               &ScanResult
                                               ) &&
                            ((ScanResult == 1) ||
                             (ScanResult == 2))) {

                            //
                            // if ScanResult is 1 or 2 then no copying needs to
                            // take place because all the destination files are
                            // in their place and digitally signed.
                            //
                            RebuildList = FALSE;
                        }
                    }
                }

                //
                // Clear out the file queue handle from the device install params
                // so that we can close the file queue.
                //
                DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
                if (SetupDiGetDeviceInstallParams(hDevInfo,
                                                  pDeviceInfoData,
                                                  &DeviceInstallParams
                                                  )) {
                    DeviceInstallParams.Flags &= ~DI_NOVCP;
                    DeviceInstallParams.FileQueue = INVALID_HANDLE_VALUE;

                    SetupDiSetDeviceInstallParams(hDevInfo,
                                                  pDeviceInfoData,
                                                  &DeviceInstallParams
                                                  );
                }

                SetupCloseFileQueue(FileQueue);
            }
        }
    }

    return RebuildList;
}

BOOL
pDoesExistingDriverNeedBackup(
    IN HDEVINFO         hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    IN PWSTR            InfPath,
    IN DWORD            InfPathSize
    )

/*++

Routine Description:

    This function determins whether the currently install driver needs to be
    backed up or not. It does this by checking if the current driver is an
    oem driver, and verifying that it is not the same as the new driver
    we are about to install.

Arguments:


    hDevInfo -

    pDeviceInfoData -

Return Value:

    TRUE if the current driver needs to be backed up, FALSE otherwise.

--*/
{
    BOOL                    bBackupCurrentDriver = FALSE;
    HKEY                    Key = INVALID_HANDLE_VALUE;
    DWORD                   dwType, dwData;
    SP_DRVINFO_DATA         DriverInfoData;
    SP_DRVINFO_DETAIL_DATA  DriverInfoDetailData;

    if (InfPath) {
        InfPath[0] = TEXT('\0');
    }

    //
    // Open the driver key for this device.
    //
    Key = SetupDiOpenDevRegKey ( hDevInfo,
                                 pDeviceInfoData,
                                 DICS_FLAG_GLOBAL,
                                 0,
                                 DIREG_DRV,
                                 KEY_READ );

    if (Key != INVALID_HANDLE_VALUE) {
        //
        // Get the 'InfPath' value from the registry.
        //
        dwType = REG_SZ;
        dwData = InfPathSize;
        if (RegQueryValueEx(Key,
                            REGSTR_VAL_INFPATH,
                            NULL,
                            &dwType,
                            (LPBYTE)InfPath,
                            &dwData) == ERROR_SUCCESS) {
            //
            // Check if this is an oem inf
            //
            if (IsInstalledInfFromOem(InfPath)) {
                //
                // Retrieve the name of the INF associated with the selected driver
                // node.
                //
                DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
                if (SetupDiGetSelectedDriver(hDevInfo, pDeviceInfoData, &DriverInfoData)) {
                    DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
                    if (SetupDiGetDriverInfoDetail(hDevInfo,
                                                   pDeviceInfoData,
                                                   &DriverInfoData,
                                                   &DriverInfoDetailData,
                                                   sizeof(DriverInfoDetailData),
                                                   NULL) ||
                        (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
                        //
                        // If the two INFs are not the same then this means we
                        // should backup the current drivers before installing
                        // the new drivers.
                        //
                        if (lstrcmpi(pSetupGetFileTitle(DriverInfoDetailData.InfFileName),
                                     InfPath) != 0) {
                            bBackupCurrentDriver = TRUE;
                        }

                    } else {
                        SetupDebugPrint1( L"SETUP: SetupDiGetDriverInfoDetail() failed. Error = %d", GetLastError() );
                    }
                } else {
                    SetupDebugPrint1( L"SETUP: SetupDiGetSelectedDriver() failed. Error = %d", GetLastError() );
                }
            }
        }

        RegCloseKey(Key);
    }

    return bBackupCurrentDriver;
}

BOOL
SelectBestDriver(
    IN  HDEVINFO         hDevInfo,
    IN  PSP_DEVINFO_DATA pDeviceInfoData,
    OUT PBOOL            pbOemF6Driver
    )

/*++

Routine Description:

    This function selects the best driver for the specified device.
    It is assumed that SetupDiBuildDriverInfoList was called before calling
    this API.

    This API will first check the list of driver nodes for this device and
    see if any have the DNF_OEM_F6_INF flag. If they do then this INF was
    specified by the user during text mode setup by doing an F6.  We always
    want to use these drivers, even if they are not the 'best' according to
    setupapi. If there are no drivers in the list with this flag then we
    fall back to the default behavior of DIF_SELECTBESTCOMPATDRV.

Arguments:


    hDevInfo -

    pDeviceInfoData -

Return Value:

    Returns the result SetupDiCallClassInstaller with DIF_SELECTBESTCOMPATDRV.

--*/

{
    DWORD index;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINSTALL_PARAMS DriverInstallParams;
    BOOL bFoundOemF6Driver = FALSE;

    *pbOemF6Driver = FALSE;

    DriverInfoData.cbSize = sizeof(DriverInfoData);
    index = 0;

    //
    // First go through the list of drivers and see if there is an OEM F6 driver
    // in the list.
    //
    while (SetupDiEnumDriverInfo(hDevInfo,
                                 pDeviceInfoData,
                                 SPDIT_COMPATDRIVER,
                                 index++,
                                 &DriverInfoData
                                 )) {
        DriverInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);
        if (SetupDiGetDriverInstallParams(hDevInfo,
                                          pDeviceInfoData,
                                          &DriverInfoData,
                                          &DriverInstallParams
                                          ) &&
            (DriverInstallParams.Flags & DNF_OEM_F6_INF)) {

            bFoundOemF6Driver = TRUE;
            SetupDebugPrint( L"SETUP: Using Oem F6 driver for this device." );
            break;
        }
    }

    //
    //  If we found an Oem driver that was specified by F6 during text mode setup,
    //  then we will go through the list again and mark all drivers that are
    //  not OEM F6 drivers and BAD drivers. This way when we call
    //  DIF_SELECTBESTCOMPATDRV it will only select from the OEM F6 drivers.
    //
    if (bFoundOemF6Driver) {
        *pbOemF6Driver = TRUE;

        DriverInfoData.cbSize = sizeof(DriverInfoData);
        index = 0;

        while (SetupDiEnumDriverInfo(hDevInfo,
                                     pDeviceInfoData,
                                     SPDIT_COMPATDRIVER,
                                     index++,
                                     &DriverInfoData
                                     )) {
            DriverInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);
            if (SetupDiGetDriverInstallParams(hDevInfo,
                                              pDeviceInfoData,
                                              &DriverInfoData,
                                              &DriverInstallParams
                                              )) {
                //
                // If this driver node does not have the DNF_OEM_F6_INF flag
                // then set the DNF_BAD_DRIVER flag so we will skip this
                // driver later when we do DIF_SELECTBESTCOMPATDRV
                //
                if (!(DriverInstallParams.Flags & DNF_OEM_F6_INF)) {
                    DriverInstallParams.Flags |= DNF_BAD_DRIVER;

                    SetupDiSetDriverInstallParams(hDevInfo,
                                                  pDeviceInfoData,
                                                  &DriverInfoData,
                                                  &DriverInstallParams
                                                  );
                }
            }
        }
    }

    return (SetupDiCallClassInstaller( DIF_SELECTBESTCOMPATDRV,
                                       hDevInfo,
                                       pDeviceInfoData ) );
}

BOOL
SkipDeviceInstallation(
    IN HDEVINFO         hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    IN HINF             InfHandle,
    IN PCWSTR           GUIDString
    )

/*++

Routine Description:

    This function determines whether or not the installation of a particular device should be skipped.
    It should be skipped if the following conditions are met:
        - The device is already installed;
        - The GUID for the device is listed in [InstalledDevicesToSkip], in syssetup.inf

Arguments:


    hDevInfo -

    pDeviceInfoData -

    InfHandle - System setup inf handle (syssetup.inf).

    GUIDString - GUID associated to the device being checked (in string format).

Return Value:

    Returns TRUE if the installation of the device should be skipped. Otherwise, it returns FALSE.

--*/

{
    BOOL    DeviceAlreadyInstalled;
    BOOL    SafeClassInstaller = TRUE;
    WCHAR   PropertyBuffer[ MAX_PATH + 1 ];
    HKEY    Key;

    //
    //  Attempt to open the dev node's driver key
    //
    Key = SetupDiOpenDevRegKey ( hDevInfo,
                                 pDeviceInfoData,
                                 DICS_FLAG_GLOBAL,
                                 0,
                                 DIREG_DRV,
                                 MAXIMUM_ALLOWED );
    if( Key == INVALID_HANDLE_VALUE ) {
        DeviceAlreadyInstalled = FALSE;
        SetupDebugPrint( L"SETUP:            Device not yet installed." );
    } else {
        RegCloseKey( Key );
        DeviceAlreadyInstalled = TRUE;
        SetupDebugPrint( L"SETUP:            Device already installed." );
    }

    //
    // In the case of MiniSetup, we're not doing an
    // upgrade, so all we care about is if the device is
    // already installed.
    //
    if( MiniSetup ) {
        return( DeviceAlreadyInstalled );
    }

    if( DeviceAlreadyInstalled ) {
        //
        //  If the device is already installed, then check if the class installer for this
        //  device is considered safe.
        //
        SafeClassInstaller = !SetupGetLineText( NULL,
                                                InfHandle,
                                                L"InstalledDevicesToSkip",
                                                GUIDString,
                                                PropertyBuffer,
                                                sizeof( PropertyBuffer )/sizeof( WCHAR ),
                                                NULL );
    }

    return( DeviceAlreadyInstalled && !SafeClassInstaller );
}


BOOL
PrecompileInfFiles(
    IN HWND  ProgressWindow,
    IN ULONG StartAtPercent,
    IN ULONG StopAtPercent
    )
/*++

Routine Description:

    This function precompiles all the infs in %SystemRoot%\inf.
    and then builds the cache.

Arguments:

    ProgressWindow - Handle to the progress bar.

    StartAtPercent - Starting position in the progress bar.
                     It indicates that from position 0 to this position
                     the gauge is already filled.

    StopAtPercent - Ending position of the progress bar.
                    The pnp thread should not fill the progress bar beyond
                    this position

Return Value:

    Returns TRUE if at least one inf was pre-compiled. Otherwise, returns FALSE.

--*/

{
    WCHAR SavedDirectory[ MAX_PATH + 1 ];
    WCHAR InfDirectory[ MAX_PATH + 1 ];
    UINT GaugeRange;
    BOOL AlwaysFalse = FALSE;

    PINF_FILE_NAME  InfList = NULL;
    PINF_FILE_NAME  p;

    WIN32_FIND_DATA FindData;
    HANDLE  FindHandle;
    ULONG   InfCount;
    ULONG   i = 0;
    DWORD   Result;

    SetupDebugPrint( L"SETUP: Entering PrecompileInfFiles()" );

    //
    //  Save current directory
    //
    GetCurrentDirectory( sizeof(SavedDirectory)/sizeof(WCHAR), SavedDirectory );

    //
    //  Change current directory to %SystemRoot%\inf
    //
    Result = GetWindowsDirectory( InfDirectory, sizeof(InfDirectory)/sizeof(WCHAR) );
    if( Result == 0) {
        MYASSERT(FALSE);
        return FALSE;
    }
    wcscat( InfDirectory, L"\\inf" );
    SetCurrentDirectory( InfDirectory );


    //
    //  Find total number of inf files
    //
    InfCount = 0;
    FindHandle = FindFirstFile( L"*.inf", &FindData );
    if( FindHandle != INVALID_HANDLE_VALUE ) {
        do {
            //
            //  Skip directories
            //
            if( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
                continue;
            }
            p = MyMalloc( sizeof( INF_FILE_NAME ) ) ;
            if( p != NULL ) {
                p->InfName = pSetupDuplicateString( &FindData.cFileName[0] );
                p->Next = InfList;
                InfList = p;
                InfCount++;
            }
        } while( FindNextFile( FindHandle, &FindData ) );

        FindClose( FindHandle );
    } else {
        SetupDebugPrint1( L"SETUP: FindFirstFile( *.inf ) failed. Error = %d", GetLastError() );
    }

    //
    //  Initialize the gauge allow for pSetupInfCacheBuild step
    //
    GaugeRange = ((InfCount+1)*100/(StopAtPercent-StartAtPercent));
    SendMessage(ProgressWindow, WMX_PROGRESSTICKS, (InfCount+1), 0);
    SendMessage(ProgressWindow,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
    SendMessage(ProgressWindow,PBM_SETPOS,GaugeRange*StartAtPercent/100,0);
    SendMessage(ProgressWindow,PBM_SETSTEP,1,0);

    //
    //  Prcompile each inf file
    //
    for( i = 0;
         (
           //
           //  Tick the gauge after we finished pre-compiling an inf.
           //  Note that we don't tick the gauge when i == 0 (no inf was yet processed),
           //  but we do tick the gauge when i == InfCount (all infs were pre-compiled).
           //  Note also that we use the flag AlwaysFalse, to enforce that all inf will be processed,
           //  even when SendMessage(PBM_SETPBIT) returns a non-zero value.
           //
           (i != 0) &&
           SendMessage(ProgressWindow,PBM_STEPIT,0,0) &&
           AlwaysFalse
         ) ||
         (i < InfCount);
         i++
      ) {
        HINF    hInf;

        SetupDebugPrint1( L"SETUP: Pre-compiling file: %ls", InfList->InfName );

        MYASSERT(InfList);
        hInf = SetupOpenInfFile( InfList->InfName,
                                 NULL,
                                 INF_STYLE_WIN4,
                                 NULL );

        if( hInf != INVALID_HANDLE_VALUE ) {
            SetupCloseInfFile( hInf );
        } else {
            DWORD   Error;

            Error = GetLastError();
            if( ((LONG)Error) < 0 ) {
                //
                //  Setupapi error code, display it in hex
                //
                SetupDebugPrint2( L"SETUP: SetupOpenInfFile() failed. FileName = %ls, Error = %lx", InfList->InfName, Error );
            } else {
                //
                //  win32 error code, display it in decimal
                //
                SetupDebugPrint2( L"SETUP: SetupOpenInfFile() failed. FileName = %ls, Error = %d", InfList->InfName, Error );
            }
        }

        //
        // The file name is no longer needed
        //
        p = InfList;
        InfList = InfList->Next;
        if( p->InfName != NULL ) {
            MyFree( p->InfName );
        }
        MyFree( p );
    }

    SetupDebugPrint2( L"SETUP: Total inf files = %d, total precompiled: %d", InfCount, i );
    SetupDebugPrint( L"SETUP: Calling pSetupInfCacheBuild()" );

    pSetupInfCacheBuild(INFCACHEBUILD_REBUILD);

    //
    //  Make sure that at this point, the gauge area is filled up to the end of
    //  the area reserved for the pre-compilation of inf files.
    //
    SendMessage(ProgressWindow,PBM_SETPOS,GaugeRange*StopAtPercent/100,0);

    //
    //  Restore current directory
    //
    SetCurrentDirectory( SavedDirectory );

    SetupDebugPrint( L"SETUP: Leaving PrecompileInfFiles()" );

    return( i != 0 );
}


BOOL
InstallLegacyDevices(
    IN HWND hwndParent,
    IN HWND  ProgressWindow,
    IN ULONG StartAtPercent,
    IN ULONG StopAtPercent
    )
{
    ULONG               Index;
    HDEVINFO            hDevInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA     DeviceInfoData;
    ULONG               Error;
    WCHAR               GUIDString[ 64 ];
    BOOL                b = TRUE;
    HSPFILEQ            FileQ = INVALID_HANDLE_VALUE;

    LPGUID              GuidList = NULL;
    ULONG               GuidCount = 32;
    ULONG               GuidIndex;
    ULONG               LastBatchedDetect;
    ULONG               GuidLB, GuidUB;
    HDEVINFO*           InfoSetArray = NULL;
    BOOL                AlwaysFalse = FALSE;
    UINT                GaugeRange;

    HANDLE                        ThreadHandle = NULL;
    DWORD                         ThreadId;
    PPNP_PHASE1_LEGACY_DEV_THREAD_PARAMS  Phase1Context;
    PPNP_PHASE2_LEGACY_DEV_THREAD_PARAMS  Phase2Context;
    WCHAR               PnpLogPath[ MAX_PATH + 1 ];
    WCHAR               LoggedDescription[ LINE_LEN + 1 ];
    DWORD               ScanQueueResult;
    SP_DRVINFO_DATA     DriverInfoData;
    ULONG               PnPFlags;
    DWORD               Result;


    SetupDebugPrint( L"SETUP: Entering InstallLegacyDevices()" );

    //
    //  Build path to pnp log file
    //
    Result = GetWindowsDirectory( PnpLogPath, sizeof(PnpLogPath)/sizeof(WCHAR) );
    if( Result == 0) {
        MYASSERT(FALSE);
        return FALSE;
    }
    pSetupConcatenatePaths( PnpLogPath, szPnpLogFile, sizeof(PnpLogPath)/sizeof(WCHAR), NULL );

    //
    // Do the migration of legacy devices.
    // This is a quick operation and doesn't need to use the progress window.
    //
    // This is now performed before installation of true PnP devices
    //
    // PnPInitializationThread(NULL);

    GuidList = ( LPGUID )MyMalloc( sizeof( GUID ) * GuidCount );
    if( !GuidList ) {
        return( FALSE );
    }

    if ( !SetupDiBuildClassInfoList( 0,
                                     GuidList,
                                     GuidCount,
                                     &GuidCount ) ) {
        Error = GetLastError();
        if( Error != ERROR_INSUFFICIENT_BUFFER ) {
            SetupDebugPrint1( L"SETUP: SetupDiBuildClassInfoList() failed. Error = %d", Error );
            MyFree( GuidList );

            //
            //  Fill the gauge up to the end of the area reserved for legacy devices.
            //
            GaugeRange = 100;
            SendMessage(ProgressWindow,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
            SendMessage(ProgressWindow,PBM_SETPOS,GaugeRange*StopAtPercent/100,0);
            SetupDebugPrint( L"SETUP: Leaving InstallLegacyDevices()" );
            return( FALSE );
        }
        GuidList = ( LPGUID )MyRealloc( GuidList, sizeof( GUID ) * GuidCount );

        if( !SetupDiBuildClassInfoList( 0,
                                        GuidList,
                                        GuidCount,
                                        &GuidCount ) ) {
            MyFree( GuidList );
            SetupDebugPrint1( L"SETUP: SetupDiBuildClassInfoList() failed. Error = %d", Error );

            //
            //  Fill the gauge up to the end of the area reserved for legacy devices.
            //
            GaugeRange = 100;
            SendMessage(ProgressWindow,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
            SendMessage(ProgressWindow,PBM_SETPOS,GaugeRange*StopAtPercent/100,0);
            SetupDebugPrint( L"SETUP: Leaving InstallLegacyDevices()" );
            return( FALSE );
        }
    }

    //
    // Sort the class GUID list based on the detection ordering specified in syssetup.inf
    //
    SortClassGuidListForDetection(GuidList, GuidCount, &LastBatchedDetect);

    InfoSetArray = (HDEVINFO*)MyMalloc( sizeof(HDEVINFO) * GuidCount );


    //
    //  Initialize the gauge.
    //  Note that since we process the device classes twice (two big 'for
    //  loops'), we divide the area of the gauge reserved for the gauge
    //  reserved for the legacy devices in 2 pieces, one for each 'for loop'.
    //
    GaugeRange = (2*GuidCount*100/(StopAtPercent-StartAtPercent));
    SendMessage(ProgressWindow, WMX_PROGRESSTICKS, 2*GuidCount, 0);
    SendMessage(ProgressWindow,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
    SendMessage(ProgressWindow,PBM_SETPOS,GaugeRange*StartAtPercent/100,0);
    SendMessage(ProgressWindow,PBM_SETSTEP,1,0);

    //
    // On our first pass, we process all the detections that can be batched
    // together.  Then, on subsequent passes, we process any non-batchable
    // detections individually...
    //
    for(GuidLB = 0, GuidUB = LastBatchedDetect; GuidLB < GuidCount; GuidLB = ++GuidUB) {

        //
        //  First, create a file queue
        //
        FileQ = SetupOpenFileQueue();
        if( FileQ == INVALID_HANDLE_VALUE ) {
            SetupDebugPrint1( L"SETUP: Failed to create file queue. Error = %d", GetLastError() );
        }


        for( GuidIndex = GuidLB;
             (
               //
               //  Tick the gauge after we finished processing all the devices of a particular class.
               //  Note that we don't tick the gauge when GuidIndex == 0 (no device was yet processed),
               //  but we do tick the gauge when GuidIndex == GuidCount (all devices of the last class
               //  were processed).
               //  Note also that we use the flag AlwaysFalse, to enforce that all classes will be processed,
               //  even when SendMessage(PBM_SETPBIT) returns a non-zero value.
               //
               (GuidIndex != GuidLB) &&
               SendMessage(ProgressWindow,PBM_STEPIT,0,0) &&
               AlwaysFalse
             ) ||
             (GuidIndex <= GuidUB);
             GuidIndex++ ) {

            HDEVINFO    hEmptyDevInfo = INVALID_HANDLE_VALUE;
            WCHAR       ClassDescription[ LINE_LEN + 1 ];

            InfoSetArray[ GuidIndex ] = INVALID_HANDLE_VALUE;
            ClassDescription[0] = (WCHAR)'\0';
            if( !SetupDiGetClassDescription( &GuidList[ GuidIndex ],
                                             ClassDescription,
                                             sizeof(ClassDescription)/sizeof(WCHAR),
                                            NULL ) ) {
                SetupDebugPrint1( L"SETUP: SetupDiGetClassDescription() failed. Error = %lx", GetLastError() );
                ClassDescription[0] = (WCHAR)'\0';
            }
            pSetupStringFromGuid( &GuidList[ GuidIndex ], GUIDString, sizeof( GUIDString ) / sizeof( WCHAR ) );
            SetupDebugPrint1( L"SETUP: Installing legacy devices of class: %ls ", ClassDescription );
            SetupDebugPrint2( L"SETUP:     GuidIndex = %d, Guid = %ls", GuidIndex, GUIDString );
#ifndef DBG
            //
            //  Check if this class of devices is listed as a bad class
            //
            LoggedDescription[0] = L'\0';
            if( (GetPrivateProfileString( szLegacyClassesSection,
                                          GUIDString,
                                          L"",
                                          LoggedDescription,
                                          sizeof(LoggedDescription)/sizeof(WCHAR),
                                          PnpLogPath ) != 0) &&
                ( wcslen( LoggedDescription ) != 0 )
              ) {
                //
                //  Skip the installation of this class of devices
                //
                SetupDebugPrint1( L"SETUP:     Skipping installation of devices of class: %ls", ClassDescription );
                continue;
            }
#endif

            //
            //  Start the thread that actually does the initial part of the installation of the legacy devices (DIF_FIRSTTIMESETUP)
            //

            Phase1Context = MyMalloc( sizeof( PNP_PHASE1_LEGACY_DEV_THREAD_PARAMS ) );
            Phase1Context->hDevInfo = INVALID_HANDLE_VALUE;
            Phase1Context->Guid = GuidList[ GuidIndex ];
            Phase1Context->pClassDescription = pSetupDuplicateString(ClassDescription);
            Phase1Context->hwndParent = hwndParent;


            ThreadHandle = NULL;
            ThreadHandle = CreateThread( NULL,
                                         0,
                                         pPhase1InstallPnpLegacyDevicesThread,
                                         Phase1Context,
                                         0,
                                         &ThreadId );
            if(ThreadHandle) {
                DWORD   WaitResult;
                DWORD   ExitCode;
                BOOL    KeepWaiting;

                KeepWaiting = TRUE;

                while( KeepWaiting ) {
                    int Result;

                    //
                    //  REVIEW 2000/11/08 seanch - Old behavior that we don't want to regress.
                    //  Fix the network timeout after the network guys fix their class installer
                    //
                    WaitResult = WaitForSingleObject( ThreadHandle,
                                                      (_wcsicmp( GUIDString, BB_NETWORK_GUID_STRING ) == 0)? BB_PNP_NETWORK_TIMEOUT :
                                                                                                                 PNP_LEGACY_PHASE1_TIMEOUT );
                    if( WaitResult == WAIT_TIMEOUT ) {
                    HANDLE  hDialogEvent;

                        if( hDialogEvent = OpenEvent( EVENT_MODIFY_STATE, FALSE, SETUP_HAS_OPEN_DIALOG_EVENT ) ) {
                            //
                            // Setupapi is prompting the user for a file.  Don't timeout.
                            //
                            CloseHandle( hDialogEvent );
                            KeepWaiting = TRUE;
                            continue;
                        } else {
                        }

                        //
                        //  Class installer is hung
                        //
                        SetupDebugPrint1( L"SETUP:    Class Installer appears to be hung (phase1). ClassDescription = %ls", ClassDescription );

#ifdef PRERELEASE
                        //
                        //  Ask the user if he wants to skip the installation of this class of devices
                        //
                        if( !Unattended ) {
                            Result = MessageBoxFromMessage( hwndParent,
                                                            MSG_CLASS_INSTALLER_HUNG_FIRSTTIMESETUP,
                                                            NULL,
                                                            IDS_WINNT_SETUP,
                                                            MB_YESNO | MB_ICONWARNING,
                                                            ClassDescription );
                        } else {
                            Result = IDYES;
                        }
#else
                        Result = IDYES;
#endif

                        if(Result == IDYES) {
                            //
                            //  User wants to skip this class of devices.
                            //  First find out if the thread has already returned.
                            //
                            WaitResult = WaitForSingleObject( ThreadHandle, 0 );
                            if( WaitResult != WAIT_OBJECT_0 ) {
                                //
                                //  Thread hasn't returned yet. Skip the installation of this class of devices
                                //
                                KeepWaiting = FALSE;
                                SetupDebugPrint1( L"SETUP:    Skipping installation of legacy devices of class: %ls", ClassDescription );
                                b = FALSE;
                                //
                                //  Remember this class so that it won't be installed if GUI setup is
                                //  restarted
                                //
                                WritePrivateProfileString( szLegacyClassesSection,
                                                           GUIDString,
                                                           ClassDescription,
                                                           PnpLogPath );
                            } else{
                                //
                                //  Thread has already returned.
                                //  There is no need to skip the installation of this class of devices.
                                //  We assume that the user decided not to skip the installation of this class,
                                //  and next call to WaitForSingleObject will immediately return.
                                //
                            }
                        }
                    } else if( WaitResult == WAIT_OBJECT_0 ) {
                        //
                        //  Device Installation Thread completed.
                        //
                        KeepWaiting = FALSE;
                        if( GetExitCodeThread( ThreadHandle, &ExitCode ) ) {
                            if( ExitCode == ERROR_SUCCESS ) {
                                //
                                // The installation was successful
                                //
                                InfoSetArray[ GuidIndex ] = Phase1Context->hDevInfo;
                            } else {
                                //
                                // The installation was not successful.
                                // There is no need to log the error, since the thread has already done it.
                                //
                                b = FALSE;
                            }
                        } else {
                            //
                            //  Unable to retrieve exit code. Assume success.
                            //
                            InfoSetArray[ GuidIndex ] = Phase1Context->hDevInfo;
                            SetupDebugPrint1( L"SETUP:     GetExitCode() failed. Error = %d", GetLastError() );
                            SetupDebugPrint( L"SETUP:     Unable to retrieve thread exit code. Assuming devices successfully installed (phase1)." );
                        }
                        //
                        //  Deallocate all the memory that was passed to the thread.
                        //
                        MyFree(Phase1Context->pClassDescription);
                        MyFree(Phase1Context);

                    } else {
                        //
                        //  Should not occur.
                        //  In this case we don't deallocate any memory, since the thread may be running.
                        //
                        KeepWaiting = FALSE;
                        SetupDebugPrint1( L"SETUP:     WaitForSingleObject() returned %d", WaitResult );
                        b = FALSE;
                    }
                }
                //
                // The thread handle is no longer needed at this point
                //
                CloseHandle(ThreadHandle);

            } else {
                //
                // Just do it synchronously.
                //
                Error = GetLastError();
                SetupDebugPrint1( L"SETUP:    CreateThread() failed (phase1). Error = %d", Error );
                if( pPhase1InstallPnpLegacyDevicesThread(Phase1Context) != ERROR_SUCCESS ) {
                    //
                    // The installation was not successful.
                    // There is no need to log the error, since the thread has already done it.
                    //
                    b = FALSE;
                } else {
                    InfoSetArray[ GuidIndex ] = Phase1Context->hDevInfo;
                }
                //
                //  Deallocate the memory passed as argument
                //
                MyFree( Phase1Context->pClassDescription );
                MyFree( Phase1Context );
            }

            //
            //  Find out if we should install devices of this class.
            //
            if( InfoSetArray[ GuidIndex ] == INVALID_HANDLE_VALUE ) {
                //
                //  If we should not install this class of devices, then go process the next class.
                //
                continue;
            }

            //
            // Now enumerate each device information element added to this set, registering
            // and then installing the files for each one.
            //
            DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
            for( Index = 0;
                 SetupDiEnumDeviceInfo( InfoSetArray[ GuidIndex ], Index, &DeviceInfoData );
                 Index++ ) {
                WCHAR   DevInstId[ MAX_DEVICE_ID_LEN ];

                Error = ERROR_SUCCESS;

                //
                //  Make sure the device is marked as 'Do not install'
                //
                if( !pSetupDiSetDeviceInfoContext( InfoSetArray[ GuidIndex ], &DeviceInfoData, FALSE ) ) {
                    SetupDebugPrint2( L"SETUP:     pSetupDiSetDeviceInfoContext() failed. Error = %lx, Index = %d", GetLastError(), Index );
                }

                //
                // Retrieve the string id for this device
                //
                DevInstId[0] = L'\0';
                if( !SetupDiGetDeviceInstanceId( InfoSetArray[ GuidIndex ],
                                                 &DeviceInfoData,
                                                 DevInstId,
                                                 sizeof( DevInstId ) / sizeof( WCHAR ),
                                                 NULL ) ) {
                    SetupDebugPrint2( L"SETUP:     Index = %d, SetupDiGetDeviceInstanceId() failed. Error = ", Index, GetLastError() );

                }
#ifndef DBG
                //
                //  Find out if this device is marked as a bad device
                //
                LoggedDescription[0] = L'\0';
                if( (GetPrivateProfileString( szLegacyClassesSection,
                                              DevInstId,
                                              L"",
                                              LoggedDescription,
                                              sizeof(LoggedDescription)/sizeof(WCHAR),
                                              PnpLogPath ) != 0) &&
                    ( wcslen( LoggedDescription ) != 0 )
                  ) {
                    //
                    //  Skip the installation of this device
                    //
                    SetupDebugPrint1( L"SETUP:     Skipping installation of legacy device: %ls", DevInstId );
                    continue;
                }
#endif


                SetupDebugPrint2( L"SETUP:     Index = %d, DeviceId = %ls", Index, DevInstId );

                Phase2Context = MyMalloc( sizeof( PNP_PHASE2_LEGACY_DEV_THREAD_PARAMS ) );
                Phase2Context->hDevInfo = InfoSetArray[ GuidIndex ];
                Phase2Context->FileQ = FileQ;
                Phase2Context->DeviceInfoData = DeviceInfoData;
                Phase2Context->pClassDescription = pSetupDuplicateString(ClassDescription);
                Phase2Context->pDeviceId = pSetupDuplicateString(DevInstId);

                ThreadHandle = NULL;;
                ThreadHandle = CreateThread( NULL,
                                             0,
                                             pPhase2InstallPnpLegacyDevicesThread,
                                             Phase2Context,
                                             0,
                                             &ThreadId );
                if( ThreadHandle ) {
                    DWORD   WaitResult;
                    DWORD   ExitCode;
                    BOOL    KeepWaiting;

                    KeepWaiting = TRUE;
                    while( KeepWaiting ) {
                        //
                        //  REVIEW 2000/11/08 seanch - Old behavior that we don't want to regress.
                        //  Fix the network timeout after the network guys fix their class installer
                        //
                        WaitResult = WaitForSingleObject( ThreadHandle,
                                                          (_wcsicmp( GUIDString, BB_NETWORK_GUID_STRING ) == 0)? BB_PNP_NETWORK_TIMEOUT :
                                                                                                                     PNP_LEGACY_PHASE2_TIMEOUT );
                        if( WaitResult == WAIT_TIMEOUT ) {
                            int Result;
                            HANDLE  hDialogEvent;

                            if( hDialogEvent = OpenEvent( EVENT_MODIFY_STATE, FALSE, SETUP_HAS_OPEN_DIALOG_EVENT ) ) {
                                //
                                // Setupapi is prompting the user for a file.  Don't timeout.
                                //
                                CloseHandle( hDialogEvent );
                                KeepWaiting = TRUE;
                                continue;
                            } else {
                            }

                            //
                            //  Class installer is hung
                            //
                            SetupDebugPrint1( L"SETUP:    Class Installer appears to be hung (phase2). DeviceId = %ls", DevInstId );

#ifdef PRERELEASE
                            //
                            //  Ask the user if he wants to skip the installation of this device
                            //
                            if( !Unattended ) {
                                Result = MessageBoxFromMessage( hwndParent,
                                                                MSG_CLASS_INSTALLER_HUNG,
                                                                NULL,
                                                                IDS_WINNT_SETUP,
                                                                MB_YESNO | MB_ICONWARNING,
                                                                DevInstId );
                            } else {
                                Result = IDYES;
                            }
#else
                            Result = IDYES;
#endif

                            if(Result == IDYES) {
                                //
                                //  User wants to skip this class of devices.
                                //  First find out if the thread has already returned.
                                //
                                WaitResult = WaitForSingleObject( ThreadHandle, 0 );
                                if( WaitResult != WAIT_OBJECT_0 ) {
                                    //
                                    //  Thread hasn't returned yet. Skip the installation of this device
                                    //
                                    KeepWaiting = FALSE;
                                    SetupDebugPrint1( L"SETUP:    Skipping installation of legacy device (phase2). Device = %ls", DevInstId );
                                    b = FALSE;
                                    //
                                    //  Remember this device so that it won't be installed if GUI setup is
                                    //  restarted
                                    //
                                    WritePrivateProfileString( szLegacyDevSection,
                                                               DevInstId,
                                                               ClassDescription,
                                                               PnpLogPath );
                                } else{
                                    //
                                    //  Thread has already returned.
                                    //  There is no need to skip the installation of this device.
                                    //  We assume that the user decided not to skip the installation of this device,
                                    //  and next call to WaitForSingleObject will immediately return.
                                    //
                                }
                            }

                        } else if( WaitResult == WAIT_OBJECT_0 ) {
                            //
                            //  Device Installation Thread completed.
                            //  Find out the outcome of this phase of the installation.
                            //
                            KeepWaiting = FALSE;
                            if( GetExitCodeThread( ThreadHandle, &ExitCode ) ) {
                                if( ExitCode ) {
                                    //
                                    // The installation was successful
                                    //
                                } else {
                                    //
                                    // The installation was not successful.
                                    // There is no need to log the error, since the thread has already done it.
                                    //
                                    b = FALSE;
                                }
                            } else {
                                //
                                //  Unable to retrieve exit code. Assume success.
                                //
                                SetupDebugPrint1( L"SETUP:     GetExitCode() failed. Error = %d", GetLastError() );
                                SetupDebugPrint( L"SETUP:     Unable to retrieve thread exit code. Assuming device successfully installed (phase2)." );
                            }
                            //
                            //  Deallocate the memory passed to the thread.
                            //
                            MyFree(Phase2Context->pClassDescription);
                            MyFree(Phase2Context->pDeviceId);
                            MyFree(Phase2Context);

                        } else {
                            //
                            //  Should not occur.
                            //  In this case we do not deallocate the memory passed to the thread, since the thread may be running.
                            //
                            KeepWaiting = FALSE;
                            SetupDebugPrint1( L"SETUP:     WaitForSingleObject() returned %d", WaitResult );
                            b = FALSE;
                        }
                    }
                    //
                    // The thread handle is no longer needed at this point
                    //
                    CloseHandle(ThreadHandle);

                } else {
                    //
                    // Unable to create the thread. Just do it syncronously
                    //
                    Error = GetLastError();
                    SetupDebugPrint1( L"SETUP:    CreateThread() failed (phase2). Error = %d", Error );
                    if( !pPhase2InstallPnpLegacyDevicesThread(Phase2Context) ) {
                        //
                        // The installation was not successful.
                        // There is no need to log the error, since the thread has already done it.
                        //
                        SetupDebugPrint( L"SETUP:    Device not successfully installed (phase2)." );
                        b = FALSE;

                    }
                    //
                    //  Deallocate the memory that was passed as argument.
                    //
                    MyFree( Phase2Context->pClassDescription );
                    MyFree( Phase2Context->pDeviceId );
                    MyFree( Phase2Context );
                }
            }
            //
            // Find out why SetupDiEnumDeviceInfo() failed.
            //
            Error = GetLastError();
            if( Error != ERROR_NO_MORE_ITEMS ) {
                SetupDebugPrint2( L"SETUP:     Device = %d, SetupDiEnumDeviceInfo() failed. Error = %d", Index, Error );
                b = FALSE;
            } else {
                if( Index == 0 ) {
                    SetupDebugPrint1( L"SETUP:     DeviceInfoSet is empty. ClassDescription = %ls", ClassDescription );
                }
            }

        }

        //
        //  If the file queue exists, then commit it.
        //
        if( FileQ != INVALID_HANDLE_VALUE ) {
            PVOID  Context;

            //
            //  Commit file queue
            //
            if(Context = InitSysSetupQueueCallbackEx(hwndParent,
                                                     INVALID_HANDLE_VALUE,
                                                     0,
                                                     0,
                                                     NULL)) {

                WCHAR  RootPath[ MAX_PATH + 1];

                if(!SetupScanFileQueue(
                       FileQ,
                       SPQ_SCAN_FILE_VALIDITY |
                        SPQ_SCAN_PRUNE_COPY_QUEUE |
                        SPQ_SCAN_PRUNE_DELREN,
                       hwndParent,
                       NULL,
                       NULL,
                       &ScanQueueResult)) {
                        //
                        // SetupScanFileQueue should really never
                        // fail when you don't ask it to call a
                        // callback routine, but if it does, just
                        // go ahead and commit the queue.
                        //
                        ScanQueueResult = 0;
                }


                if( ScanQueueResult != 1 ){

                    if( !SetupCommitFileQueue(hwndParent,FileQ,SysSetupQueueCallback,Context) ) {
                        b = FALSE;
                    }
                }
                TermSysSetupQueueCallback(Context);
                GetWindowsDirectory(RootPath,sizeof(RootPath)/sizeof(WCHAR));
                RootPath[3] = L'\0';
                FlushFilesToDisk( RootPath );
            }
        }

        //
        //  Now that the files were already copied, call the class installer
        //  with DIF_INSTALLDEVICE so that we can complete the installation
        //  of the device.
        //
        for( GuidIndex = GuidLB;
             (
               //
               //  Tick the gauge after we finished processing all the devices of a particular class.
               //  Note that we don't tick the gauge when GuidIndex == 0 (no device was yet processed),
               //  but we do tick the gauge when GuidIndex == GuidCount (all devices of the last class
               //  were processed).
               //  Note also that we use the flag AlwaysFalse, to enforce that all classes will be processed,
               //  even when SendMessage(PBM_SETPBIT) returns a non-zero value.
               //
               (GuidIndex != GuidLB) &&
               SendMessage(ProgressWindow,PBM_STEPIT,0,0) &&
               AlwaysFalse
             ) ||
             (GuidIndex <= GuidUB);
             GuidIndex++ ) {

            SP_DEVINFO_DATA TempDeviceInfoData;

            if( InfoSetArray[ GuidIndex ] == INVALID_HANDLE_VALUE  ) {
                continue;
            }
            //
            //  REVIEW 2000/11/08 seanch - Old behavior that we don't want to regress.
            //  Remove the line below after the network guys fix their class installer
            //
            pSetupStringFromGuid( &GuidList[ GuidIndex ], GUIDString, sizeof( GUIDString ) / sizeof( WCHAR ) );

            TempDeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
            for( Index = 0;  SetupDiEnumDeviceInfo( InfoSetArray[ GuidIndex ], Index, &TempDeviceInfoData ); Index++ ) {
                WCHAR   DevInstId[ MAX_DEVICE_ID_LEN ];
                DWORD   InstallDevice;
                SP_DEVINSTALL_PARAMS DeviceInstallParams;
                PPNP_PHASE3_LEGACY_DEV_THREAD_PARAMS Phase3Context;
#ifdef PNP_DEBUG_UI
                BOOL    DeviceSuccessfullyInstalled;
#endif

                //
                // Retrieve the string id for this device
                //
                DevInstId[0] = L'\0';
                if( !SetupDiGetDeviceInstanceId( InfoSetArray[ GuidIndex ],
                                                 &TempDeviceInfoData,
                                                 DevInstId,
                                                 sizeof( DevInstId ) / sizeof( WCHAR ),
                                                 NULL ) ) {
                    SetupDebugPrint1( L"SETUP: SetupDiGetDeviceInstanceId() failed. Error = ", GetLastError() );
                }

                //
                //  Find out if we need to call DIF_INSTALLDEVICE for this device
                //
                InstallDevice = 0;
                if( !pSetupDiGetDeviceInfoContext( InfoSetArray[ GuidIndex ], &TempDeviceInfoData, &InstallDevice ) ) {
                    SetupDebugPrint2( L"SETUP: pSetupDiSetDeviceInfoContext() failed. Error = %lx, DeviceId = %ls ", GetLastError(), DevInstId );
                    continue;
                }
                if( !InstallDevice ) {
                    //
                    //  No need to install the device
                    //
                    SetupDebugPrint1( L"SETUP: Skipping device. DeviceId = %ls ", DevInstId );
                    continue;
                }

#ifndef DBG
                //
                //  Find out if this device is marked as a bad device
                //
                LoggedDescription[0] = L'\0';
                if( (GetPrivateProfileString( szLegacyClassesSection,
                                              DevInstId,
                                              L"",
                                              LoggedDescription,
                                              sizeof(LoggedDescription)/sizeof(WCHAR),
                                              PnpLogPath ) != 0) &&
                    ( wcslen( LoggedDescription ) != 0 )
                  ) {
                    //
                    //  Skip the installation of this device
                    //
                    SetupDebugPrint1( L"SETUP:    Skipping installation of legacy device: %ls", DevInstId );
                    continue;
                }
#endif

                //
                //  Retrieve information about the driver node selected above.
                //
                DriverInfoData.cbSize = sizeof( SP_DRVINFO_DATA );
                if( !SetupDiGetSelectedDriver( InfoSetArray[ GuidIndex ],
                                               &TempDeviceInfoData,
                                               &DriverInfoData ) ) {

                    SetupDebugPrint1( L"SETUP:            SetupDiGetSelectedDriver() failed. Error = %d", GetLastError() );
                    b = FALSE;
                    continue;

                }

                //
                // Retrieve syssetup PnP flags (if any) the INF specifies for this
                // device.
                //
                PnPFlags = SyssetupGetPnPFlags(InfoSetArray[ GuidIndex ],
                                               &TempDeviceInfoData,
                                               &DriverInfoData
                                              );

                SetupDebugPrint3( L"SETUP: Installing  device: %ls, GuidIndex = %d, Index = %d", DevInstId, GuidIndex, Index );
                DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
                if(!SetupDiGetDeviceInstallParams(InfoSetArray[ GuidIndex ], &TempDeviceInfoData, &DeviceInstallParams)) {
                    SetupDebugPrint1( L"SETUP: SetupDiGetDeviceInstallParams() failed. Error = %d", GetLastError() );
                    b = FALSE;
                    continue;
                }

                DeviceInstallParams.Flags &= ~DI_FORCECOPY;
                DeviceInstallParams.Flags &= ~DI_NOVCP;
                DeviceInstallParams.Flags |= DI_NOFILECOPY;
                DeviceInstallParams.FileQueue = NULL;

                if(PnPFlags & PNPFLAG_DONOTCALLCONFIGMG) {
                    //
                    // We _do not_ honor this flag for devices reported via
                    // DIF_FIRSTTIMESETUP.  The intent of this flag is to
                    // prevent us from perturbing correctly-functioning devices
                    // and potentially causing problems (e.g., moving PCI
                    // bridges or COM ports off of their boot configs).  This
                    // concern does not apply to legacy-detected devnodes.  We
                    // definitely _do_ want to bring these devices on-line now,
                    // or else devices attached to them (whether PnP or legacy)
                    // won't be found and installed.
                    //
                    SetupDebugPrint( L"SETUP: Clearing PNPFLAG_DONOTCALLCONFIGMG since this is a detected device." );

                    PnPFlags &= ~PNPFLAG_DONOTCALLCONFIGMG;
                }

                if(!SetupDiSetDeviceInstallParams(InfoSetArray[ GuidIndex ], &TempDeviceInfoData, &DeviceInstallParams)) {
                    SetupDebugPrint1( L"SETUP: SetupDiSetDeviceInstallParams() failed. Error = %d", GetLastError() );
                    b = FALSE;
                    continue;
                }

                Phase3Context = MyMalloc( sizeof( PNP_PHASE3_LEGACY_DEV_THREAD_PARAMS ) );
                Phase3Context->hDevInfo = InfoSetArray[ GuidIndex ];
                Phase3Context->DeviceInfoData = TempDeviceInfoData;
                Phase3Context->pDeviceId = pSetupDuplicateString( DevInstId );

#ifdef PNP_DEBUG_UI
                DeviceSuccessfullyInstalled = FALSE;
#endif
                ThreadHandle = NULL;
                ThreadHandle = CreateThread( NULL,
                                             0,
                                             pPhase3InstallPnpLegacyDevicesThread,
                                             Phase3Context,
                                             0,
                                             &ThreadId );
                if( ThreadHandle ) {
                    DWORD   WaitResult;
                    DWORD   ExitCode;
                    BOOL    KeepWaiting;

                    KeepWaiting = TRUE;
                    while( KeepWaiting ) {
                        //
                        //  REVIEW 2000/11/08 seanch - Old behavior that we don't want to regress.
                        //  Fix the network timeout after the network guys fix their class installer
                        //
                        WaitResult = WaitForSingleObject( ThreadHandle,
                                                          (_wcsicmp( GUIDString, BB_NETWORK_GUID_STRING ) == 0)? BB_PNP_NETWORK_TIMEOUT :
                                                                                                                     PNP_LEGACY_PHASE3_TIMEOUT );
                        if( WaitResult == WAIT_TIMEOUT ) {
                            int Result;
                            HANDLE  hDialogEvent;

                            if( hDialogEvent = OpenEvent( EVENT_MODIFY_STATE, FALSE, SETUP_HAS_OPEN_DIALOG_EVENT ) ) {
                                //
                                // Setupapi is prompting the user for a file.  Don't timeout.
                                //
                                CloseHandle( hDialogEvent );
                                KeepWaiting = TRUE;
                                continue;
                            } else {
                            }

                            //
                            //  Class installer is hung
                            //
                            SetupDebugPrint1( L"SETUP:    Class Installer appears to be hung (phase3). DeviceId = %ls", DevInstId );

#ifdef PRERELEASE
                            //
                            //  Ask the user if he wants to skip the installation of this class of devices
                            //
                            if( !Unattended ) {
                                Result = MessageBoxFromMessage( hwndParent,
                                                                MSG_CLASS_INSTALLER_HUNG,
                                                                NULL,
                                                                IDS_WINNT_SETUP,
                                                                MB_YESNO | MB_ICONWARNING,
                                                                DevInstId );
                            } else {
                                Result = IDYES;
                            }
#else
                            Result = IDYES;
#endif

                            if(Result == IDYES) {
                                //
                                //  User wants to skip this device.
                                //  First find out if the thread has already returned.
                                //
                                WaitResult = WaitForSingleObject( ThreadHandle, 0 );
                                if( WaitResult != WAIT_OBJECT_0 ) {
                                    //
                                    //  Thread hasn't returned yet. Skip the installation of this device
                                    //
                                    KeepWaiting = FALSE;
                                    SetupDebugPrint1( L"SETUP:    Skipping installation of legacy device (phase3). Device = %ls", DevInstId );
                                    b = FALSE;
                                    if( !SetupDiGetClassDescription( &GuidList[ GuidIndex ],
                                                                     LoggedDescription,
                                                                     sizeof(LoggedDescription)/sizeof(WCHAR),
                                                                     NULL ) ) {
                                        SetupDebugPrint1( L"SETUP: SetupDiGetClassDescription() failed. Error = %lx", GetLastError() );
                                        //
                                        //  Assume anything for class description, since we don't really care about it,
                                        //  for logging purposes. The class description only helps identify the problematic
                                        //  device.
                                        //
                                        wcscpy( LoggedDescription, L"1" );
                                    }
                                    //
                                    //  Remember this device so that it won't be installed if GUI setup is
                                    //  restarted
                                    //
                                    WritePrivateProfileString( szLegacyDevSection,
                                                               DevInstId,
                                                               LoggedDescription,
                                                               PnpLogPath );
                                } else{
                                    //
                                    //  Thread has already returned.
                                    //  There is no need to skip the installation of this device.
                                    //  We assume that the user decided not to skip the installation of this device,
                                    //  and next call to WaitForSingleObject will immediately return.
                                    //
                                }
                            }

                        } else if( WaitResult == WAIT_OBJECT_0 ) {
                            //
                            //  Device Installation Thread completed.
                            //  Find out the outcome of this phase of the installation.
                            //
                            KeepWaiting = FALSE;
                            if( GetExitCodeThread( ThreadHandle, &ExitCode ) ) {
                                if( ExitCode ) {
                                    //
                                    // The installation was successful
                                    //
#ifdef PNP_DEBUG_UI
                                    DeviceSuccessfullyInstalled = TRUE;
#endif
                                } else {
                                    //
                                    // The installation was not successful.
                                    // There is no need to log the error, since the thread has already done it.
                                    //
                                    b = FALSE;
                                }
                            } else {
                                //
                                //  Unable to retrieve exit code. Assume success.
                                //
                                SetupDebugPrint1( L"SETUP:     GetExitCode() failed. Error = %d", GetLastError() );
                                SetupDebugPrint( L"SETUP:     Unable to retrieve thread exit code. Assuming device successfully installed (phase3)." );
                            }
                            MyFree(Phase3Context->pDeviceId);
                            MyFree(Phase3Context);

                        } else {
                            //
                            //  Should not occur
                            //
                            KeepWaiting = FALSE;
                            SetupDebugPrint1( L"SETUP:     WaitForSingleObject() returned %d", WaitResult );
                            b = FALSE;
                        }
                    }
                    //
                    // The thread handle is no longer needed at this point
                    //
                    CloseHandle(ThreadHandle);

                } else {
                    //
                    // Unable to create the thread. Just do it syncronously.
                    //
                    Error = GetLastError();
                    SetupDebugPrint1( L"SETUP:    CreateThread() failed (phase3). Error = %d", Error );
                    if( !pPhase3InstallPnpLegacyDevicesThread(Phase3Context) ) {
                        //
                        // The installation was not successful.
                        // There is no need to log the error, since the thread has already done it.
                        //
                        b = FALSE;

                    } else {
#ifdef PNP_DEBUG_UI
                        DeviceSuccessfullyInstalled = TRUE;
#endif
                    }
                    MyFree( Phase3Context->pDeviceId );
                    MyFree( Phase3Context );
                }

#ifdef PNP_DEBUG_UI
                if( DeviceSuccessfullyInstalled ) {
                    //
                    //  Add the device to an info set that has the same class as this device.
                    //
                    if( !AddDevInfoDataToDevInfoSet( &DevInfoSetList,
                                                     &TempDeviceInfoData,
                                                     DevInstId,
                                                     hwndParent ) ) {
                        SetupDebugPrint1( L"SETUP: AddDevInfoDataToDevInfoSet() failed. DevId = %ls", DevInstId );
                        b = FALSE;
                        continue;
                    }
                }
#endif // PNP_DEBUG_UI
            }

            Error = GetLastError();
            if( Error != ERROR_NO_MORE_ITEMS ) {
                SetupDebugPrint2( L"SETUP: Device = %d, SetupDiEnumDeviceInfo() failed. Error = %d", Index, Error );
                b = FALSE;
            }
        }

        //
        //  Get rid of the file queue, if it exists
        //
        if( FileQ != INVALID_HANDLE_VALUE) {
            SetupCloseFileQueue(FileQ);
        }
    }

    //
    //  Make sure that at this point, the gauge area is filled up to the end of
    //  the area reserved for the installation of legacy devices.
    //
    SendMessage(ProgressWindow,PBM_SETPOS,GaugeRange*StopAtPercent/100,0);

    //
    //  Get rid of the list of GUIDs.
    //
    if( GuidList != NULL ) {
        MyFree( GuidList );
    }

    //
    //  Get rid of InfoSetArray, and all info sets stored on it.
    //

    if( InfoSetArray != NULL ) {
        for( GuidIndex = 0; GuidIndex < GuidCount; GuidIndex++ ) {
            if( InfoSetArray[ GuidIndex ] != INVALID_HANDLE_VALUE ) {
                SetupDiDestroyDeviceInfoList( InfoSetArray[ GuidIndex ] );
            }
        }
        MyFree( InfoSetArray );
    }
    SetupDebugPrint( L"SETUP: Leaving InstallLegacyDevices()" );
    return( b );
}



BOOL
InstallEnumeratedDevices(
    IN HWND hwndParent,
    IN HINF InfHandle,
    IN HWND  ProgressWindow,
    IN ULONG StartAtPercent,
    IN ULONG StopAtPercent
    )
/*++

Routine Description:

    This function enumerates and install all new PnP devices detected during
    GUI setup.

Arguments:

    hwndParent - Handle to a top level window that may be used for UI purposes.

    InfHandle - System setup inf handle (syssetup.inf).


Return Value:

    Returns TRUE if all enumerated hardware were installed successfully.

--*/
{
    HANDLE              hPipeEvent = NULL;
    HANDLE              hPipe = INVALID_HANDLE_VALUE;
    ULONG               Index = 0;
    ULONG               Error;
    ULONG               ulSize = 0;
    HDEVINFO            hDevInfo = INVALID_HANDLE_VALUE;
    WCHAR               szBuffer[MAX_PATH];
    BOOL                b = TRUE;
    UINT                GaugeRange = 100;
    WCHAR               RootPath[ MAX_PATH + 1];
    WCHAR               PnpLogPath[ MAX_PATH + 1];
    PAF_DRIVERS         AfDrivers;
    PAF_DRIVER_ATTRIBS  SelectedAfDriver;
    PSP_DEVINFO_DATA    pDeviceInfoData = NULL;
    ULONG               PnPFlags;
    HANDLE              hBatchEvent = NULL;
    DWORD               Result;


    SetupDebugPrint( L"SETUP: Entering InstallEnumeratedDevices()" );

    //
    //  Build path to pnp log file
    //
    Result = GetWindowsDirectory( PnpLogPath, sizeof(PnpLogPath)/sizeof(WCHAR) );
    if( Result == 0) {
        MYASSERT(FALSE);
        return FALSE;
    }
    pSetupConcatenatePaths( PnpLogPath, szPnpLogFile, sizeof(PnpLogPath)/sizeof(WCHAR), NULL );

    //
    //  Initialize RootPath with empty string
    //
    RootPath[0] = L'\0';

    //
    //  Initialize answer file table
    //

    AfDrivers = CreateAfDriverTable();

    //
    //  Attempt to create the event that will be used to signal the successfull
    //  creation of the named pipe
    //
    hPipeEvent = CreateEvent( NULL, TRUE, FALSE, PNP_CREATE_PIPE_EVENT );
    if (hPipeEvent == NULL) {
        Error = GetLastError();
        if( Error != ERROR_ALREADY_EXISTS ) {
            SetupDebugPrint1( L"SETUP: CreateEvent() failed. Error = %d", Error );
            b = FALSE;
            goto Clean0;
        }
        //
        // If umpnpmgr has already created the event, then just open the event
        //
        hPipeEvent = OpenEvent(EVENT_MODIFY_STATE,
                           FALSE,
                           PNP_CREATE_PIPE_EVENT);

        if (hPipeEvent == NULL) {
            SetupDebugPrint1( L"SETUP: OpenEvent() failed. Error = %d", GetLastError() );
            b = FALSE;
            goto Clean0;
        }
    }

    //
    //  Attempt to create the event that will be used to signal the completion of
    //  processing of the last batch of devices.
    //
    hBatchEvent = CreateEvent( NULL, TRUE, FALSE, PNP_BATCH_PROCESSED_EVENT );
    if (hBatchEvent == NULL) {
        Error = GetLastError();
        if( Error != ERROR_ALREADY_EXISTS ) {
            SetupDebugPrint1( L"SETUP: CreateEvent() failed. Error = %d", Error );
            b = FALSE;
            goto Clean0;
        }
        //
        // If umpnpmgr has already created the event, then just open the event
        //
        hBatchEvent = OpenEvent(EVENT_MODIFY_STATE,
                           FALSE,
                           PNP_BATCH_PROCESSED_EVENT);

        if (hBatchEvent == NULL) {
            SetupDebugPrint1( L"SETUP: OpenEvent() failed. Error = %d", GetLastError() );
            b = FALSE;
            goto Clean0;
        }
    }

    //
    // create the named pipe, umpnpmgr will write requests to
    // this pipe if new hardware is found
    //
    hPipe = CreateNamedPipe(PNP_NEW_HW_PIPE,
                            PIPE_ACCESS_INBOUND,
                            PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE,
                            1,                 // only one connection
                            sizeof(szBuffer),  // out buffer size
                            sizeof(szBuffer),  // in buffer size
                            PNP_PIPE_TIMEOUT,  // default timeout
                            NULL               // default security
                            );

    //
    // signal the event now
    //
    SetEvent(hPipeEvent);

    if (hPipe == INVALID_HANDLE_VALUE) {
        SetupDebugPrint1( L"SETUP: CreateNamedPipe() failed. Error = %d", GetLastError() );
        b = FALSE;
        goto Clean0;
    }

    //
    // Connect to the newly created named pipe.
    // If umpnpmgr is not already connected to the named pipe, then ConnectNamedPipe()
    // will succeed. Otherwise, it will fail with ERROR_PIPE_CONNECTED. Note however that
    // this is not an error condition.
    //
    if (ConnectNamedPipe(hPipe, NULL) ||
        ((Error = GetLastError()) == ERROR_PIPE_CONNECTED) ) {
        //
        //  REVIEW 2000/11/08 seanch - Old behavior that we don't want to regress.
        //           This is gauge related and needs to be fixed.
        //           We are assuming a total of 50 enumerated device.
        //
        BOOL    AlwaysFalse = FALSE;
        UINT    BogusValue = 50;

        //
        //  Initialize the gauge
        //  REVIEW 2000/11/08 seanch - Old behavior that we don't want to regress.
        //  Fix this - We are assuming a fixed number of devices
        //
        GaugeRange = (BogusValue*100/(StopAtPercent-StartAtPercent));
        SendMessage(ProgressWindow, WMX_PROGRESSTICKS, BogusValue, 0);
        SendMessage(ProgressWindow,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
        SendMessage(ProgressWindow,PBM_SETPOS,GaugeRange*StartAtPercent/100,0);
        SendMessage(ProgressWindow,PBM_SETSTEP,1,0);

        //
        // listen to the named pipe by submitting read
        // requests until the named pipe is broken on the
        // other end.
        //
        for( Index = 0;
             //
             //  REVIEW 2000/11/08 seanch - Old behavior that we don't want to regress.
             //  This is gauge related and needs to be fixed.
             //  We are assuming a constant number of enumerated devices
             //
             ( (Index != 0) &&
               (Index < BogusValue) &&
               SendMessage(ProgressWindow,PBM_STEPIT,0,0) &&
               AlwaysFalse
             ) ||                                               // This is a trick to force the gauge to be upgraded after a
                                                                // device is processed, and the pipe to be read.
             ReadFile( hPipe,
                       (LPBYTE)szBuffer,    // device instance id
                       sizeof(szBuffer),
                       &ulSize,
                       NULL );
             Index++ ) {

            SP_DRVINFO_DATA DriverInfoData;
            SP_DEVINSTALL_PARAMS DeviceInstallParams;
            WCHAR           GUIDString[ 64 ];
            WCHAR           ClassDescription[ LINE_LEN + 1 ];
            HANDLE                      ThreadHandle = NULL;
            DWORD                       ThreadId;
            PPNP_ENUM_DEV_THREAD_PARAMS Context;
            BOOL                        DeviceInstalled;
            WCHAR                       LoggedDescription[ LINE_LEN + 1 ];
            BOOL                        bOemF6Driver;

            if (lstrlen(szBuffer) == 0) {

                SetEvent(hBatchEvent);
                continue;
            }
            SetupDebugPrint2( L"SETUP: Index = %d, DeviceId = %ls", Index, szBuffer );
            //
            //  Check if this device is listed as a bad device
            //
            LoggedDescription[0] = L'\0';
            if( (GetPrivateProfileString( szEnumDevSection,
                                          szBuffer,
                                          L"",
                                          LoggedDescription,
                                          sizeof(LoggedDescription)/sizeof(WCHAR),
                                          PnpLogPath ) != 0) &&
                ( wcslen( LoggedDescription ) != 0 )
              ) {
#ifndef DBG
                //
                //  Skip the installation of this device
                //
                SetupDebugPrint1( L"SETUP:             Skipping installation of device %ls", szBuffer );
                continue;
#endif
            }
            BEGIN_SECTION(LoggedDescription);

            //
            //  Find out if we need to create an hDevinfo.
            //  We will need to create one if this is the first device that we are installing (Index == 0),
            //  or the class installer for the previous device (Index == Index - 1) is hung. If the class
            //  installer is hung then we cannot use the same hDevinfo, since the class installer has a lock
            //  on it. So we just create a new one.
            //  If the class installer for the previous device didn't hang, then there is no need to create
            //  a new hDevinfo, since we can re-use it. We do this for performance reasons.
            //
            if( hDevInfo == INVALID_HANDLE_VALUE ) {
                //
                // create a devinfo handle and device info data set to
                // pass to DevInstall
                //
                if((hDevInfo = SetupDiCreateDeviceInfoList(NULL, hwndParent))
                                == INVALID_HANDLE_VALUE) {
                    b = FALSE;
                    SetupDebugPrint1( L"SETUP: SetupDiCreateDeviceInfoList() failed. Error = %d", GetLastError() );
                    goto Clean0;
                }
                pDeviceInfoData = MyMalloc(sizeof(SP_DEVINFO_DATA));
                if( pDeviceInfoData == NULL ) {
                    b = FALSE;
                    SetupDebugPrint( L"SETUP: Unable to create pDeviceInfoData.  MyMalloc() failed." );
                    goto Clean0;
                }
                pDeviceInfoData->cbSize = sizeof(SP_DEVINFO_DATA);
            }

            if(!SetupDiOpenDeviceInfo(hDevInfo, szBuffer, hwndParent, 0, pDeviceInfoData)) {
                SetupDebugPrint1( L"SETUP:             SetupDiOpenDeviceInfo() failed. Error = %d", GetLastError() );
                b = FALSE;
                END_SECTION(LoggedDescription);
                continue;

            }


            //
            // Answer file support: Test the answer file to see if it has a driver
            // in its [DeviceDrivers] section.  This overrides the NT-supplied driver,
            // if one exists.
            //

            if (!SyssetupInstallAnswerFileDriver (
                    AfDrivers,
                    hDevInfo,
                    pDeviceInfoData,
                    &SelectedAfDriver
                    )) {

                //
                // No answer file driver, proceed with the standard device install
                //

                SetupDebugPrint( L"SETUP:            Device was NOT installed via answer file driver" );

                //
                //  Build a list of compatible drivers for this device
                //  (This call can be time consuming the first time it is called)
                //
                if( !SetupDiBuildDriverInfoList( hDevInfo, pDeviceInfoData, SPDIT_COMPATDRIVER ) ) {
                    SetupDebugPrint1( L"SETUP:         SetupDiBuildDriverInfoList() failed. Error = %d", GetLastError() );
                    b = FALSE;
                    continue;

                }

                //
                //  Select the best compatible driver for this device.
                //
                if( !SelectBestDriver( hDevInfo,
                                       pDeviceInfoData,
                                       &bOemF6Driver ) ) {

                    Error = GetLastError();
                    if( Error != ERROR_NO_COMPAT_DRIVERS ) {

                        SetupDebugPrint1( L"SETUP:            SetupDiCallClassInstaller(DIF_SELECTBESTCOMPATDRV) failed. Error = %d", Error );
                        b = FALSE;
                        END_SECTION(LoggedDescription);
                        continue;
                    }

                    SetupDebugPrint( L"SETUP:            Compatible driver List is empty" );
                    SetupDebugPrint( L"SETUP:            Installing the null driver for this device" );

                    //
                    //  Install the null driver for this device.
                    //  This is to avoid the "Found New Hardware" popup when the
                    //  user first logs on after the system is installed.
                    //
                    if( !SyssetupInstallNullDriver( hDevInfo, pDeviceInfoData ) ) {
                        SetupDebugPrint( L"SETUP:            Unable to install null driver" );
                    }

                    END_SECTION(LoggedDescription);
                    continue;
                }

                //
                // Check if we need to rebuild the driver list without including the
                // old Internet drivers.
                //
                if (RebuildListWithoutOldInternetDrivers(hDevInfo, pDeviceInfoData)) {

                    SetupDiDestroyDriverInfoList( hDevInfo, pDeviceInfoData, SPDIT_COMPATDRIVER );

                    //
                    // OR in the DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS flag so that we don't include
                    // old internet drivers in the list that build.
                    //
                    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
                    if (SetupDiGetDeviceInstallParams(hDevInfo,
                                                      pDeviceInfoData,
                                                      &DeviceInstallParams
                                                      ))
                    {
                        DeviceInstallParams.FlagsEx |= DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS;

                        SetupDiSetDeviceInstallParams(hDevInfo,
                                                      pDeviceInfoData,
                                                      &DeviceInstallParams
                                                      );
                    }

                    //
                    //  Build a list of compatible drivers for this device
                    //  (This call can be time consuming the first time it is called)
                    //
                    if( !SetupDiBuildDriverInfoList( hDevInfo, pDeviceInfoData, SPDIT_COMPATDRIVER ) ) {
                        SetupDebugPrint1( L"SETUP:         SetupDiBuildDriverInfoList() failed. Error = %d", GetLastError() );
                        b = FALSE;
                        continue;

                    }

                    //
                    //  Select the best compatible driver for this device.
                    //
                    if( !SelectBestDriver( hDevInfo,
                                           pDeviceInfoData,
                                           &bOemF6Driver ) ) {

                        Error = GetLastError();
                        if( Error != ERROR_NO_COMPAT_DRIVERS ) {

                            SetupDebugPrint1( L"SETUP:            SetupDiCallClassInstaller(DIF_SELECTBESTCOMPATDRV) failed. Error = %d", Error );
                            b = FALSE;
                            END_SECTION(LoggedDescription);
                            continue;
                        }

                        SetupDebugPrint( L"SETUP:            Compatible driver List is empty" );
                        SetupDebugPrint( L"SETUP:            Installing the null driver for this device" );

                        //
                        //  Install the null driver for this device.
                        //  This is to avoid the "Found New Hardware" popup when the
                        //  user first logs on after the system is installed.
                        //
                        if( !SyssetupInstallNullDriver( hDevInfo, pDeviceInfoData ) ) {
                            SetupDebugPrint( L"SETUP:            Unable to install null driver" );
                        }

                        END_SECTION(LoggedDescription);
                        continue;
                    }
                }

            } else {
                SetupDebugPrint( L"SETUP:            Device was installed via answer file driver" );
            }

            //
            //  Retrieve information about the driver node selected above.
            //
            DriverInfoData.cbSize = sizeof( SP_DRVINFO_DATA );
            if( !SetupDiGetSelectedDriver( hDevInfo,
                                           pDeviceInfoData,
                                           &DriverInfoData ) ) {

                SetupDebugPrint1( L"SETUP:            SetupDiGetSelectedDriver() failed. Error = %d", GetLastError() );
                b = FALSE;
                continue;

            }
            //
            //  Get the GUID string for this device
            //
            GUIDString[0] = (WCHAR)'\0';
            pSetupStringFromGuid( &(pDeviceInfoData->ClassGuid), GUIDString, sizeof( GUIDString ) / sizeof( WCHAR ) );

            SetupDebugPrint1( L"SETUP:            DriverType = %lx", DriverInfoData.DriverType );
            SetupDebugPrint1( L"SETUP:            Description = %ls", &(DriverInfoData.Description[0]) );
            SetupDebugPrint1( L"SETUP:            MfgName = %ls", &(DriverInfoData.MfgName[0]) );
            SetupDebugPrint1( L"SETUP:            ProviderName = %ls", &(DriverInfoData.ProviderName[0]) );
            SetupDebugPrint1( L"SETUP:            GUID = %ls", GUIDString );

            ClassDescription[0] = (WCHAR)'\0';
            if( !SetupDiGetClassDescription( &(pDeviceInfoData->ClassGuid),
                                             ClassDescription,
                                             sizeof(ClassDescription)/sizeof(WCHAR),
                                             NULL ) ) {
                SetupDebugPrint1( L"SETUP: SetupDiGetClassDescription() failed. Error = %lx", GetLastError() );
                ClassDescription[0] = (WCHAR)'\0';
            }
            SetupDebugPrint1( L"SETUP:            DeviceClass = %ls", ClassDescription );

            //
            // Retrieve syssetup PnP flags (if any) the INF specifies for this
            // device.
            //
            PnPFlags = SyssetupGetPnPFlags(hDevInfo, pDeviceInfoData, &DriverInfoData);

            if( SkipDeviceInstallation( hDevInfo,
                                        pDeviceInfoData,
                                        InfHandle,
                                        GUIDString ) ) {
                SetupDebugPrint( L"SETUP:            Skipping installation of this device" );
                END_SECTION(LoggedDescription);
                continue;
            }

            //
            // If the PnP flag was set that said we shouldn't call ConfigMgr
            // for this device, then set the appropriate flag in the device's
            // install params.
            //
            if(PnPFlags & PNPFLAG_DONOTCALLCONFIGMG) {

                DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

                if( !SetupDiGetDeviceInstallParams( hDevInfo,
                                                    pDeviceInfoData,
                                                    &DeviceInstallParams ) ) {
                    Error = GetLastError();
                    if( ((LONG)Error) < 0 ) {
                        //
                        //  Setupapi error code, display it in hex
                        //
                        SetupDebugPrint1( L"SETUP:            SetupDiGetDeviceInstallParams() failed. Error = %lx", Error );
                    } else {
                        //
                        //  win32 error code, display it in decimal
                        //
                        SetupDebugPrint1( L"SETUP:            SetupDiGetDeviceInstallParams() failed. Error = %d", Error );
                    }
                } else {

                    DeviceInstallParams.Flags |= DI_DONOTCALLCONFIGMG;

                    if( !SetupDiSetDeviceInstallParams( hDevInfo,
                                                        pDeviceInfoData,
                                                        &DeviceInstallParams ) ) {
                        Error = GetLastError();
                        if( ((LONG)Error) < 0 ) {
                            //
                            //  Setupapi error code, display it in hex
                            //
                            SetupDebugPrint1( L"SETUP:            SetupDiSetDeviceInstallParams() failed. Error = %lx", Error );
                        } else {
                            //
                            //  win32 error code, display it in decimal
                            //
                            SetupDebugPrint1( L"SETUP:            SetupDiSetDeviceInstallParams() failed. Error = %d", Error );
                        }
                    }
                }
            }

            //
            //  Start the thread that actually does the installation of the device
            //
            Context = MyMalloc( sizeof(PNP_ENUM_DEV_THREAD_PARAMS) );
            Context->hDevInfo = hDevInfo;
            Context->DeviceInfoData = *pDeviceInfoData;
            Context->pDeviceDescription = pSetupDuplicateString(&(DriverInfoData.Description[0]));
            Context->pDeviceId = pSetupDuplicateString(szBuffer);

            DeviceInstalled = FALSE;
            ThreadHandle = CreateThread( NULL,
                                         0,
                                         pInstallPnpEnumeratedDeviceThread,
                                         Context,
                                         0,
                                         &ThreadId );
            if(ThreadHandle) {
                DWORD   WaitResult;
                DWORD   ExitCode;
                BOOL    KeepWaiting;

                KeepWaiting = TRUE;
                while( KeepWaiting ) {
                    //
                    //  REVIEW 2000/11/08 seanch - Old behavior that we don't want to regress.
                    //  Fix the network timeout after the network guys fix their class installer
                    //
                    WaitResult = WaitForSingleObject( ThreadHandle,
                                                      (_wcsicmp( GUIDString, BB_NETWORK_GUID_STRING ) == 0)? BB_PNP_NETWORK_TIMEOUT :
                                                                                                                 PNP_ENUM_TIMEOUT );
                    if( WaitResult == WAIT_TIMEOUT ) {
                        int Result;
                        HANDLE  hDialogEvent;

                        if( hDialogEvent = OpenEvent( EVENT_MODIFY_STATE, FALSE, SETUP_HAS_OPEN_DIALOG_EVENT ) ) {
                            //
                            // Setupapi is prompting the user for a file.  Don't timeout.
                            //
                            CloseHandle( hDialogEvent );
                            KeepWaiting = TRUE;
                            continue;
                        } else {
                        }

                        //
                        //  Class installer is hung
                        //
                        SetupDebugPrint1( L"SETUP:    Class Installer appears to be hung. Device = %ls", &(DriverInfoData.Description[0]) );

#ifdef PRERELEASE
                        //
                        //  Ask the user if he wants to skip the installation of this device.
                        //
                        if( !Unattended ) {
                            Result = MessageBoxFromMessage( hwndParent,
                                                            MSG_CLASS_INSTALLER_HUNG,
                                                            NULL,
                                                            IDS_WINNT_SETUP,
                                                            MB_YESNO | MB_ICONWARNING,
                                                            &(DriverInfoData.Description[0]) );
                        } else {
                            Result = IDYES;
                        }
#else
                        Result = IDYES;
#endif

                        if(Result == IDYES) {
                            //
                            //  User wants to skip this device.
                            //  First find out if the thread has already returned.
                            //
                            WaitResult = WaitForSingleObject( ThreadHandle, 0 );
                            if( WaitResult != WAIT_OBJECT_0 ) {
                                //
                                //  Thread hasn't returned yet. Skip the installation of this device.
                                //
                                KeepWaiting = FALSE;
                                SetupDebugPrint1( L"SETUP:    Skipping installation of enumerated device. Device = %ls", &(DriverInfoData.Description[0]) );
                                b = FALSE;
                                //
                                //  Remember this device so that it won't be installed if GUI setup is
                                //  restarted
                                //
                                WritePrivateProfileString( szEnumDevSection,
                                                           szBuffer,
                                                           &(DriverInfoData.Description[0]),
                                                           PnpLogPath );
                                //
                                // Since the class installer is hung, we cannot re-use the hDevInfo that was passed
                                // to the class installer. So we just ignore this one. We will create a new one for
                                // the next device to be installed.
                                //
                                hDevInfo = INVALID_HANDLE_VALUE;
                                pDeviceInfoData = NULL;
                            } else{
                                //
                                //  Thread has already returned.
                                //  There is no need to skip the installation of this device.
                                //  We assume that the user decided not to skip the installation of this device,
                                //  and next call to WaitForSingleObject will immediately return.
                                //
                            }
                        }

                    } else if( WaitResult == WAIT_OBJECT_0 ) {

                        //
                        //  Device Installation Thread completed.
                        //
                        KeepWaiting = FALSE;
                        //
                        //  Deallocate memory passed to the thread.
                        //
                        MyFree( Context->pDeviceDescription );
                        MyFree( Context->pDeviceId );
                        MyFree( Context );
                        if( GetExitCodeThread( ThreadHandle, &ExitCode ) ) {
                            if( ExitCode == ERROR_SUCCESS ) {
                                //
                                // The installation was successful
                                //
                                DeviceInstalled = TRUE;
                                SetupDebugPrint( L"SETUP:            Device successfully installed." );

                            } else {
                                //
                                // The installation was not successful.
                                // There is no need to log the error, since the thread has already done it.
                                //
                                SetupDebugPrint( L"SETUP:            Device not successfully installed." );
                                b = FALSE;
                            }
                        } else {
                            //
                            //  Unable to retrieve exit code. Assume success.
                            //
                            SetupDebugPrint1( L"SETUP:            GetExitCode() failed. Error = %d", GetLastError() );
                            SetupDebugPrint( L"SETUP:            Unable to retrieve thread exit code. Assuming device successfully installed." );
                        }

                    } else {
                        //
                        //  Should not occur
                        //
                        KeepWaiting = FALSE;
                        SetupDebugPrint1( L"SETUP:            WaitForSingleObject() returned %d", WaitResult );

                        // MyFree( Context->pDeviceDescription );
                        // MyFree( Context->pDeviceId );
                        // MyFree( Context );
                        b = FALSE;

                    }
                }
                //
                //  The thread handle is no longer needed.
                //
                CloseHandle(ThreadHandle);
            } else {
                //
                // Just do it synchronously.
                //
                SetupDebugPrint1( L"SETUP:            CreateThread() failed (enumerated device). Error = %d", GetLastError() );

                if( pInstallPnpEnumeratedDeviceThread(Context) != ERROR_SUCCESS ) {
                    //
                    // The installation was not successful.
                    // There is no need to log the error, since the thread has already done it.
                    //
                    SetupDebugPrint( L"SETUP:            Device not successfully installed." );
                    b = FALSE;
                } else {
                    DeviceInstalled = TRUE;
                }
                MyFree( Context->pDeviceDescription );
                MyFree( Context->pDeviceId );
                MyFree( Context );
            }


            if( DeviceInstalled ) {

#ifdef PNP_DEBUG_UI
                //
                //  Add the device to an info set that has the same class as this device.
                //
                if( !AddDevInfoDataToDevInfoSet( &DevInfoSetList,
                                                 pDeviceInfoData,
                                                 szBuffer,
                                                 hwndParent ) ) {
                    SetupDebugPrint1( L"SETUP: AddDevInfoDataToDevInfoSet() failed. DevId = %ls", szBuffer );
                    b = FALSE;
                    continue;

                }
#endif // PNP_DEBUG_UI

                //
                // If this device came from the answer file, then change the original
                // media path from the local temp dir to the original path (typically
                // the floppy drive).
                //

                if (SelectedAfDriver) {
                    SyssetupFixAnswerFileDriverPath (
                        SelectedAfDriver,
                        hDevInfo,
                        pDeviceInfoData
                        );
                }

                //
                // If the driver we just installed was an Oem F6 driver then
                // we need to add it to the list of files that SfcInitProt
                // will leave alone during its scan.
                //
                if (bOemF6Driver) {
                    AddOemF6DriversToSfcIgnoreFilesList(hDevInfo, pDeviceInfoData);
                }
            }
            END_SECTION(LoggedDescription);
        }

        //
        // Find out why we stopped reading the pipe. If it was because the connetion
        // to the pipe was broken by umpnp, then there was nothing else to read from
        // the pipe. Otherwise, there was an error condition.
        //
        if( ( Error = GetLastError() ) != ERROR_BROKEN_PIPE ) {
            SetupDebugPrint1( L"SETUP: ReadFile( hPipe ) failed. Error = %d", GetLastError() );
            b = FALSE;
            goto Clean0;
        }

    } else {
        SetupDebugPrint1( L"SETUP: ConnectNamedPipe() failed. Error = %d", GetLastError() );
        b = FALSE;
        goto Clean0;
    }


Clean0:
    BEGIN_SECTION(L"InstallEnumeratedDevices cleanup");
    //
    // Make sure that at this point the gauge is filled up to the end of the
    // region reserved for the installation of the enumerated devices.
    //
    SendMessage(ProgressWindow,PBM_SETPOS,GaugeRange*StopAtPercent/100,0);

    if (hPipe != INVALID_HANDLE_VALUE) {
        DisconnectNamedPipe(hPipe);
        CloseHandle(hPipe);
    }
    if (hPipeEvent != NULL) {
        CloseHandle(hPipeEvent);
    }
    if (hBatchEvent != NULL) {
        CloseHandle(hBatchEvent);
    }

    if( hDevInfo != INVALID_HANDLE_VALUE ) {
        SetupDiDestroyDeviceInfoList( hDevInfo );
    }

    DestroyAfDriverTable (AfDrivers);

    if( pDeviceInfoData != NULL ) {
        MyFree( pDeviceInfoData );
    }
    SetupDebugPrint( L"SETUP: Leaving InstallEnumeratedDevices()" );
    END_SECTION(L"InstallEnumeratedDevices cleanup");
    return( b );
}


DWORD
pInstallPnpDevicesThread(
    PPNP_THREAD_PARAMS ThreadParams
    )
/*++

Routine Description:

    This is the thread that does the installation of the PnP devices.

Arguments:

    ThreadParams - Points to a structure that contains the information
                   passed to this thread.

Return Value:

    Returnd TRUE if the operation succeeds, or FALSE otherwise.

--*/

{
    BOOL b;
    PPNP_THREAD_PARAMS Context;
    ULONG StartAtPercent;
    ULONG StopAtPercent;
    ULONG DeltaPercent;

    Context = ThreadParams;

    //
    // Assume success.
    //
    b = TRUE;

    //
    // We don't want SetupAPI to do any RunOnce calls, as we'll do it manually
    //
    pSetupSetGlobalFlags(pSetupGetGlobalFlags()|PSPGF_NO_RUNONCE);

    //
    //  Initialize some variables that are related to the progress bar.
    //  We divide the progress window area reserved for pnp installation in 3 regions
    //  of equal size, and they will be used in the following steps:
    //          . Pre-compilation of infs
    //          . Installation of enumerated devices
    //          . Installation of legacy devices
    //          . Installation of enumerated devices that may have appeared after the installation of legacy devices
    //
    DeltaPercent = (Context->ProgressWindowStopAtPercent - Context->ProgressWindowStartAtPercent) / 4;
    StartAtPercent = Context->ProgressWindowStartAtPercent;
    StopAtPercent = Context->ProgressWindowStartAtPercent + DeltaPercent;

    //
    //  Pre-compile inf files
    //

    //
    // Before we can start precompiling inf files, let's "seed" the INF
    // directory with any OEM-supplied INFs that need to be present during
    // detection.  This should be really quick and doesn't require the
    // updating the progress window
    //
    RemainingTime = CalcTimeRemaining(Phase_PrecompileInfs);
    SetRemainingTime(RemainingTime);
    BEGIN_SECTION(L"Installing OEM infs");
    InstallOEMInfs();
    //
    // Add migrated drivers to the SFC exclusion list
    //
#if defined(_X86_)
    SfcExcludeMigratedDrivers ();
#endif
    END_SECTION(L"Installing OEM infs");

    BEGIN_SECTION(L"Precompiling infs");
    PrecompileInfFiles( Context->ProgressWindow,
                        StartAtPercent,
                        StopAtPercent );
    END_SECTION(L"Precompiling infs");

    //
    //  This operation is very fast, so we don't need to upgrade the progress bar.
    //
    if( !MiniSetup ) {
        BEGIN_SECTION(L"Mark PnP devices for reinstall");
        MarkPnpDevicesAsNeedReinstall();
        END_SECTION(L"Mark PnP devices for reinstall");
    }

    //
    // Do the migration of legacy devices...at the moment all that PnPInit does
    // is migrate all the device nodes who belong to the vid load order group to
    // be put into the display class.  This is the desired result.
    //
    // This is a quick operation and doesn't need to use the progress window.
    //
    PnPInitializationThread(NULL);

    //
    //  Do installation of enumerated devices
    //
    StartAtPercent += DeltaPercent;
    StopAtPercent += DeltaPercent;

    RemainingTime = CalcTimeRemaining(Phase_InstallEnumDevices1);
    SetRemainingTime(RemainingTime);
    BEGIN_SECTION(L"Installing enumerated devices");
    b = InstallEnumeratedDevices( Context->Window,
                                  Context->InfHandle,
                                  Context->ProgressWindow,
                                  StartAtPercent,
                                  StopAtPercent );

    //
    // devices installs may exist in RunOnce entries
    // they are processed as a batch, as opposed to per-device
    // during syssetup
    //
    CallRunOnceAndWait();
    END_SECTION(L"Installing enumerated devices");

    //
    //  Do the installation of legacy pnp devices.
    //
    StartAtPercent += DeltaPercent;
    StopAtPercent += DeltaPercent;

    BEGIN_SECTION(L"Installing legacy devices");
    RemainingTime = CalcTimeRemaining(Phase_InstallLegacyDevices);
    SetRemainingTime(RemainingTime);
    b = InstallLegacyDevices( Context->Window,
                              Context->ProgressWindow,
                              StartAtPercent,
                              StopAtPercent ) && b;

    //
    // devices installs may exist in RunOnce entries
    // they are processed as a batch, as opposed to per-device
    // during syssetup
    //
    CallRunOnceAndWait();
    END_SECTION(L"Installing legacy devices");


    //  Install the remaining enumerated devices that may have appeared after the
    //  installation of the legacy devices.
    //  Since this step uses the last region of the progress window,
    //  use as StopAtPercent, the value that was passed to this function,
    //  instead of the calulated value (by adding DeltaPorcent). This will
    //  ensure that at the end of this step, the gauge will be filled up
    //  completely. If we use the calculated value, then rounding error
    //  can cause the gauge not to be completelly filled up at the end of
    //  this step.
    //
    StartAtPercent += DeltaPercent;
    StopAtPercent = Context->ProgressWindowStopAtPercent;

    BEGIN_SECTION(L"Install enumerated devices triggered by legacy devices");
    RemainingTime = CalcTimeRemaining(Phase_InstallEnumDevices2);
    SetRemainingTime(RemainingTime);
    b = InstallEnumeratedDevices( Context->Window,
                                  Context->InfHandle,
                                  Context->ProgressWindow,
                                  StartAtPercent,
                                  StopAtPercent ) && b;

    //
    // devices installs may exist in RunOnce entries
    // they are processed as a batch, as opposed to per-device
    // during syssetup
    //
    // since we will not be calling RunOnce again after this
    // allow devices to call RunOnce immediately
    // (other device install threads may be still running)
    //
    pSetupSetGlobalFlags(pSetupGetGlobalFlags()&~PSPGF_NO_RUNONCE);
    CallRunOnceAndWait();
    END_SECTION(L"Install enumerated devices triggered by legacy devices");

    //
    //  Mark all non-present devices as needing re-install
    //  we do this a 2nd time in case a device "disappeared" due to the
    //  re-installation of a parent device
    //  This operation is very fast, so we don't need to upgrade the progress bar.
    //
    if( !MiniSetup ) {
        MarkPnpDevicesAsNeedReinstall();
    }

    if( Context->SendWmQuit ) {
// #if 0
        ULONG   Error = ERROR_SUCCESS;
// #endif

        //
        //  We send WM_QUIT only if this routine was started as a separate thread.
        //  Otherwise, the WM_QUIT will be processed by the wizard, and it will make it stop.
        //
//        PostThreadMessage(Context->ThreadId,WM_QUIT,b,0);
// #if 0
        do {
            if( !PostThreadMessage(Context->ThreadId,WM_QUIT,b,0) ) {
                Error = GetLastError();
                SetupDebugPrint1( L"SETUP: PostThreadMessage(WM_QUIT) failed. Error = %d", Error );
            }
        } while ( Error != ERROR_SUCCESS );
// #endif
    }

    return( b );
}


BOOL
InstallPnpDevices(
    IN HWND  hwndParent,
    IN HINF  InfHandle,
    IN HWND  ProgressWindow,
    IN ULONG StartAtPercent,
    IN ULONG StopAtPercent
    )
/*++

Routine Description:

    This function creates and starts the thread responsible for installation of
    PnP devices.

Arguments:

    hwndParent - Handle to a top level window that may be used for UI purposes

    InfHandle - System setup inf handle (syssetup.inf).

    ProgressWindow - Handle to the progress bar.

    StartAtPercent - Starting position in the progress bar.
                     It indicates that from position 0 to this position
                     the gauge is already filled.

    StopAtPercent - Ending position of the progress bar.
                    The pnp thread should not fill the progress bar beyond
                    this position

Return Value:

    Returns TRUE if all the PnP devices installed successfully.

--*/

{
    BOOL Success = TRUE;
    DWORD ThreadId;
    HANDLE ThreadHandle = NULL;
    PNP_THREAD_PARAMS Context;
    MSG msg;


    Context.ThreadId = GetCurrentThreadId();
    Context.Window = hwndParent;
    Context.ProgressWindow = ProgressWindow;
    Context.InfHandle = InfHandle;
    Context.ProgressWindowStartAtPercent = StartAtPercent;
    Context.ProgressWindowStopAtPercent = StopAtPercent;
    Context.SendWmQuit = TRUE;

    ThreadHandle = CreateThread(
                        NULL,
                        0,
                        pInstallPnpDevicesThread,
                        &Context,
                        0,
                        &ThreadId
                        );
    if(ThreadHandle) {

        CloseHandle(ThreadHandle);

        //
        // Pump the message queue and wait for the thread to finish.
        //
        do {
            GetMessage(&msg,NULL,0,0);
            if(msg.message != WM_QUIT) {
                DispatchMessage(&msg);
            }
        } while(msg.message != WM_QUIT);

        Success = (BOOL)msg.wParam;

    } else {
        //
        // Just do it synchronously.
        //
        Context.SendWmQuit = FALSE;
        Success = pInstallPnpDevicesThread(&Context);
    }

    return(Success);
}


BOOL
UpdatePnpDeviceDrivers(
    )
/*++

Routine Description:

    This function goes through all the installed devices and makes sure
    it has the latest and greatest driver.

Arguments:

Return Value:

    Returns TRUE if there are no fatal errors.

--*/

{
    BOOL                                        bRet                                = FALSE;
    HINSTANCE                                   hInstNewDev;
    ExternalUpdateDriverForPlugAndPlayDevicesW  pUpdateDriverForPlugAndPlayDevicesW = NULL;
    HDEVINFO                                    DeviceInfoSet;

    // We need the "UpdateDriverForPlugAndPlayDevices" function from newdev.dll.
    //
    if ( NULL == (hInstNewDev = LoadLibrary(L"newdev.dll")) )
    {
        SetupDebugPrint1(L"SETUP:     Failed to load newdev.dll. Error = %d", GetLastError());
        return bRet;
    }
    pUpdateDriverForPlugAndPlayDevicesW =
        (ExternalUpdateDriverForPlugAndPlayDevicesW) GetProcAddress(hInstNewDev, "UpdateDriverForPlugAndPlayDevicesW");
    if ( NULL == pUpdateDriverForPlugAndPlayDevicesW )
    {
        SetupDebugPrint1(L"SETUP:     Failed to get UpdateDriverForPlugAndPlayDevicesW. Error = %d", GetLastError());
    }
    // Create a device information set that will be the container for
    // the device interfaces.
    //
    else if ( INVALID_HANDLE_VALUE == (DeviceInfoSet = SetupDiCreateDeviceInfoList(NULL, NULL)) )
    {
        SetupDebugPrint1(L"SETUP:     Failed SetupDiCreateDeviceInfoList(). Error = %d", GetLastError());
    }
    else
    {
        HDEVINFO NewDeviceInfoSet;

        // Get the list of all present devices.
        //
        NewDeviceInfoSet = SetupDiGetClassDevsEx(NULL,
                                                 NULL,
                                                 NULL,
                                                 DIGCF_ALLCLASSES | DIGCF_PRESENT,
                                                 DeviceInfoSet,
                                                 NULL,
                                                 NULL);
        if ( INVALID_HANDLE_VALUE == NewDeviceInfoSet )
        {
            SetupDebugPrint1(L"SETUP:     Failed SetupDiGetClassDevsEx(). Error = %d", GetLastError());
        }
        else
        {
            SP_DEVINFO_DATA DeviceInfoData;
            DWORD           dwDevice;

            // Once we get this far, the default return is TRUE.
            //
            bRet = TRUE;

            // Setup the device info data structutre.
            //
            DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

            // Loop through all the devices.
            //
            for ( dwDevice = 0; SetupDiEnumDeviceInfo(NewDeviceInfoSet, dwDevice, &DeviceInfoData); dwDevice++ )
            {
                SP_DEVINSTALL_PARAMS    DeviceInstallParams;
                SP_DRVINFO_DATA         NewDriverInfoData;
                PSP_DRVINFO_DETAIL_DATA pNewDriverInfoDetailData = NULL;
                DWORD                   cbBytesNeeded = 0;
                TCHAR                   szDeviceID[MAX_DEVICE_ID_LEN];

                DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
                NewDriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

                if ( SetupDiGetDeviceInstallParams(NewDeviceInfoSet,
                                                   &DeviceInfoData,
                                                   &DeviceInstallParams) )
                {
                    DeviceInstallParams.FlagsEx |= DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS;
                    SetupDiSetDeviceInstallParams(NewDeviceInfoSet,
                                                  &DeviceInfoData,
                                                  &DeviceInstallParams);
                }

                // Build the list of possible drivers for this device.
                // Select the best compatible driver for this device.
                // Retrieve information about the driver node selected above.
                // Get driver info details.
                //
                if ( ( SetupDiBuildDriverInfoList(NewDeviceInfoSet,
                                                  &DeviceInfoData,
                                                  SPDIT_COMPATDRIVER ) ) &&

                     ( SetupDiCallClassInstaller(DIF_SELECTBESTCOMPATDRV,
                                                 NewDeviceInfoSet,
                                                 &DeviceInfoData ) ) &&

                     ( SetupDiGetSelectedDriver(NewDeviceInfoSet,
                                                &DeviceInfoData,
                                                &NewDriverInfoData ) ) &&

                     ( ( SetupDiGetDriverInfoDetail(NewDeviceInfoSet,
                                                    &DeviceInfoData,
                                                    &NewDriverInfoData,
                                                    NULL,
                                                    0,
                                                    &cbBytesNeeded) ) ||
                       ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) ) &&

                     ( cbBytesNeeded ) &&

                     ( pNewDriverInfoDetailData = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cbBytesNeeded) ) &&

                     ( pNewDriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA) ) &&

                     ( SetupDiGetDriverInfoDetail(NewDeviceInfoSet,
                                                  &DeviceInfoData,
                                                  &NewDriverInfoData,
                                                  pNewDriverInfoDetailData,
                                                  cbBytesNeeded,
                                                  NULL) ) &&

                     ( SetupDiGetDeviceRegistryProperty(NewDeviceInfoSet,
                                                        &DeviceInfoData,
                                                        SPDRP_HARDWAREID,
                                                        NULL,
                                                        (LPBYTE) szDeviceID,
                                                        sizeof(szDeviceID),
                                                        NULL) ) )

                {
                    HKEY    hDevRegKey;
                    BOOL    bUpdate = TRUE,
                            bRebootFlag;

                    // Get the device's regkey, so that we can get the
                    // version of the currently installed driver.
                    //
                    if ( INVALID_HANDLE_VALUE != (hDevRegKey = SetupDiOpenDevRegKey(NewDeviceInfoSet,
                                                               &DeviceInfoData,
                                                               DICS_FLAG_GLOBAL,
                                                               0,
                                                               DIREG_DRV,
                                                               KEY_READ)) )
                    {
                        TCHAR   szInfPath[MAX_PATH],
                                szInfName[MAX_PATH];
                        DWORD   dwSize = sizeof(szInfName),
                                dwType;

                        szInfPath[0] = L'\0';
                        GetSystemWindowsDirectory(szInfPath, sizeof(szInfPath) / sizeof(TCHAR));

                        if ( ( szInfPath[0] ) &&

                             ( pSetupConcatenatePaths(szInfPath,
                                                      L"INF",
                                                      sizeof(szInfPath) / sizeof(TCHAR),
                                                      NULL) ) &&

                             ( ERROR_SUCCESS == RegQueryValueEx(hDevRegKey,
                                                                REGSTR_VAL_INFPATH,
                                                                NULL,
                                                                &dwType,
                                                                (LPBYTE) &szInfName,
                                                                &dwSize) ) &&

                             ( pSetupConcatenatePaths(szInfPath,
                                                      szInfName,
                                                      sizeof(szInfPath) / sizeof(TCHAR),
                                                      NULL) ) &&

                             ( CSTR_EQUAL == CompareString(LOCALE_SYSTEM_DEFAULT,
                                                           NORM_IGNORECASE,
                                                           pNewDriverInfoDetailData->InfFileName,
                                                           -1,
                                                           szInfPath,
                                                           -1) ) )
                        {
                            // The inf we found is already in the %windir%\inf folder and is already
                            // installed.  So we don't want to install this inf again.
                            //
                            bUpdate = FALSE;
                        }

                        // Make sure we close the key.
                        //
                        RegCloseKey(hDevRegKey);
                    }

                    // Check to see if we have the possibility of a better driver and
                    // try to install it if we do.
                    //
                    if ( bUpdate &&
                         !pUpdateDriverForPlugAndPlayDevicesW(NULL,
                                                              szDeviceID,
                                                              pNewDriverInfoDetailData->InfFileName,
                                                              0,
                                                              &bRebootFlag) )
                    {
                        SetupDebugPrint1(L"SETUP:     Failed to install updated driver. Error = %d", GetLastError());
                        bRet = FALSE;
                    }
                }
                //else
                //{
                    //
                    // SetupDebugPrint1(L"SETUP:     No installed Driver. Error = %d", GetLastError());
                    // SetupDebugPrint(L"SETUP:     No best compatible driver.");
                    // SetupDebugPrint(L"SETUP:     Unable to get new driver info.");
                    // SetupDebugPrint1(L"SETUP:     Unable to get new driver detail data. Error = %d", GetLastError());
                    //
                //}

                // Free this if allocated.
                //
                if ( pNewDriverInfoDetailData )
                {
                    HeapFree(GetProcessHeap(), 0, pNewDriverInfoDetailData);
                }

            }

            // Make sure we clean up the list.
            //
            SetupDiDestroyDeviceInfoList(NewDeviceInfoSet);
        }

        // Make sure we clean up the list.
        //
        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
    }

    FreeLibrary(hInstNewDev);

    return bRet;
}


#ifdef PNP_DEBUG_UI
INT
CompareListboxItems(
    IN PCOMPAREITEMSTRUCT Items
    )

/*++

Routine Description:

        This routine is called in response to a WM_COMPAREITEM.
        It compares two item of type LISTBOX_ITEM.

Arguments:

        Items - Pointer to a structure that contains the information
                about the items to compare.

Return Value:

        -1 ... Item1 precedes Item2 in the sorted order.
         0 ... Item1 and Item2 are identical in the sorted order.
         1 ... Item2 precedes Item1 in the sorted order.

--*/

{
    PLISTBOX_ITEM   ListBoxItem1;
    PLISTBOX_ITEM   ListBoxItem2;

    ListBoxItem1 = (PLISTBOX_ITEM)(Items->itemData1);
    ListBoxItem2 = (PLISTBOX_ITEM)(Items->itemData2);

// SetupDebugPrint( L"SETUP: Entering CompareListboxItems()" );
// SetupDebugPrint( L"SETUP: IconIdex1 = %d, DeviceDescription1 = %ls", ListBoxItem1->IconIndex, ListBoxItem1->IconIndex );
// SetupDebugPrint( L"SETUP: IconIdex2 = %d, DeviceDescription1 = %ls", ListBoxItem2->IconIndex, ListBoxItem2->IconIndex );

    if( ( ListBoxItem1->IconIndex > ListBoxItem2->IconIndex ) ||
        ( ( ListBoxItem1->IconIndex == ListBoxItem2->IconIndex ) &&
          ( _wcsicmp( ListBoxItem1->DeviceDescription, ListBoxItem2->DeviceDescription ) > 0 )
        )
      ) {
// SetupDebugPrint( L"SETUP: Leaving CompareListboxItems(). Return value = 1" );
        return( 1 );
    } else if( ( ListBoxItem1->IconIndex < ListBoxItem2->IconIndex ) ||
               ( ( ListBoxItem1->IconIndex == ListBoxItem2->IconIndex ) &&
                 ( _wcsicmp( ListBoxItem1->DeviceDescription, ListBoxItem2->DeviceDescription ) < 0 )
               )
             ) {
// SetupDebugPrint( L"SETUP: Leaving CompareListboxItems(). Return value = -1" );
        return( -1 );
    } else {
// SetupDebugPrint( L"SETUP: Leaving CompareListboxItems(). Return value = 0" );
        return( 0 );
    }
}
#endif // PNP_DEBUG_UI


#ifdef PNP_DEBUG_UI
VOID
DrawItem(
    LPDRAWITEMSTRUCT lpdis
    )

/*++

Routine Description:

    Draw a device description in an owner drawn list box.

Arguments:

    lpdis - Pointer to the sructure that contains the item to
            be drawn in the listbox.

Return Value:

    None.

--*/

{
    HDC     hDc = lpdis->hDC;
    int     dxString, bkModeSave;
    DWORD   dwBackColor, dwTextColor;
    UINT    itemState=lpdis->itemState;
    RECT    rcItem=lpdis->rcItem;
    SIZE    size;

    PLISTBOX_ITEM   ListBoxItem;
    PWSTR           DeviceDescription;


    MYASSERT( lpdis->CtlType & ODT_LISTBOX );

    if((int)lpdis->itemID < 0) {
        return;
    }

    //
    // extract the DeviceDescription from DRAWITEM struct
    //
    ListBoxItem = (PLISTBOX_ITEM)lpdis->itemData;
    DeviceDescription = ListBoxItem->DeviceDescription;

    GetTextExtentPoint32(hDc,DeviceDescription,wcslen(DeviceDescription),&size);

    if(lpdis->itemAction != ODA_FOCUS) {

        bkModeSave = GetBkMode(hDc);

        dwBackColor = SetBkColor(hDc, GetSysColor((itemState & ODS_SELECTED) ?
                                COLOR_HIGHLIGHT : COLOR_WINDOW));
        dwTextColor = SetTextColor(hDc, GetSysColor((itemState & ODS_SELECTED) ?
                                COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT));

        //
        // fill in the background; do this before mini-icon is drawn
        //
        ExtTextOut(hDc, 0, 0, ETO_OPAQUE, &rcItem, NULL, 0, NULL);

        //
        // draw mini-icon for this device and move string accordingly
        //
        dxString = SetupDiDrawMiniIcon(
                        hDc,
                        rcItem,
                        ListBoxItem->IconIndex,
                        (itemState & ODS_SELECTED) ? MAKELONG(DMI_BKCOLOR, COLOR_HIGHLIGHT) : 0
                        );

        //
        // draw the text transparently on top of the background
        //
        SetBkMode(hDc, TRANSPARENT);
        ExtTextOut(hDc, dxString + rcItem.left, rcItem.top +
                ((rcItem.bottom - rcItem.top) - size.cy) / 2,
                0, NULL, DeviceDescription, wcslen(DeviceDescription), NULL);

        //
        // Restore hdc colors.
        //
        SetBkColor(hDc, dwBackColor);
        SetTextColor(hDc, dwTextColor);
        SetBkMode(hDc, bkModeSave);
    }

    if(lpdis->itemAction == ODA_FOCUS || (itemState & ODS_FOCUS)) {
        DrawFocusRect(hDc, &rcItem);
    }
}
#endif // PNP_DEBUG_UI


#ifdef PNP_DEBUG_UI
BOOL
CALLBACK
InstalledHardwareDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

        Dialog procedure for the installed hardware dialog.

Arguments:

        hWnd - a handle to the dialog proceedure.

        msg - the message passed from Windows.

        wParam - extra message dependent data.

        lParam - extra message dependent data.


Return Value:

        TRUE if the value was edited.  FALSE if cancelled or if no
        changes were made.

--*/
{
    NMHDR *NotifyParams;

    switch(msg) {

    case WM_INITDIALOG: {

        PDEVINFOSET_ELEMENT p;

        // SetupDebugPrint( L"SETUP: InstalledHardwareDlgProc() received WM_INITDIALOG" );
        if( UiTest ) {
            //
            //  If testing the wizard, make sure that the page is
            //  displayed
            //
            break;
        }

        szUnknownDevice = MyLoadString( IDS_DEVNAME_UNK );
        for( p = DevInfoSetList; p != NULL; p = p->Next ) {
            ULONG   Index;
            ULONG   Error;

            for( Index = 0; ; Index++ ) {
                LONG            i;
                PLISTBOX_ITEM   ListBoxItem;

                PWSTR TempString;


                ListBoxItem = MyMalloc( sizeof( LISTBOX_ITEM ) );
                if( ListBoxItem == NULL ) {
                    SetupDebugPrint( L"SETUP: Out of memory: InstalledHardwareDlgProc()" );
                    continue;
                }

                ListBoxItem->DevInfoSet = p->DevInfoSet;
                ListBoxItem->DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
                ListBoxItem->IconIndex = UNKNOWN_DEVICE_ICON_INDEX;
                *(ListBoxItem->DeviceDescription) = L'\0';
                if( szUnknownDevice != NULL ) {
                    wcscpy( ListBoxItem->DeviceDescription, szUnknownDevice );
                }

                if( SetupDiEnumDeviceInfo( p->DevInfoSet, Index, &(ListBoxItem->DeviceInfoData) ) ) {
                    ULONG   Size;

                    if( SetupDiGetDeviceRegistryProperty( ListBoxItem->DevInfoSet,
                                                          &(ListBoxItem->DeviceInfoData),
                                                          SPDRP_FRIENDLYNAME,
                                                          NULL,
                                                          (PBYTE)(ListBoxItem->DeviceDescription),
                                                          LINE_LEN * sizeof( WCHAR ), // sizeof( DeviceDescription ),
                                                          NULL ) ) {
                        SetupDebugPrint( L"SETUP:       Device = %d, Description = %ls", Index, ListBoxItem->DeviceDescription );
                    } else {
                        SetupDebugPrint( L"SETUP:       Device = %d, No friendly name", Index );
                        if( SetupDiGetDeviceRegistryProperty( ListBoxItem->DevInfoSet,
                                                              &(ListBoxItem->DeviceInfoData),
                                                              SPDRP_DEVICEDESC,
                                                              NULL,
                                                              (PBYTE)(ListBoxItem->DeviceDescription),
                                                              LINE_LEN * sizeof( WCHAR ), // sizeof( DeviceDescription ),
                                                              NULL ) ) {
                            SetupDebugPrint( L"SETUP:       Device = %d, Description = %ls", Index, ListBoxItem->DeviceDescription );
                        } else {
                            SetupDebugPrint( L"SETUP:       Device = %d, Description = Unknown device", Index );
                        }
                    }
                    if( !SetupDiLoadClassIcon( &(ListBoxItem->DeviceInfoData.ClassGuid),
                                               NULL,
                                               &(ListBoxItem->IconIndex) ) ) {
                        SetupDebugPrint( L"SETUP:       SetupDiLoadClassIcon() failed. Error = %d, Description = %ls", GetLastError(), ListBoxItem->DeviceDescription );
                    }

                } else {
                    Error = GetLastError();
                    MyFree( ListBoxItem );
                    if( Error == ERROR_NO_MORE_ITEMS ) {
                        break;
                    } else {
                        SetupDebugPrint( L"SETUP:       Device = %d, Description = Unknown device", Index );
                    }
                }

                i = SendDlgItemMessage( hdlg, IDC_LIST1, LB_ADDSTRING, 0, (LPARAM)ListBoxItem );
                SetupDebugPrint( L"SETUP: SendDlgItemMessage() returned i = %d", i );
            }
        }
        //
        //  Disable the 'Properties' button
        //
        // EnableWindow( GetDlgItem( hdlg, IDB_BUTTON_1 ), FALSE );
        break;
    }

    case WM_IAMVISIBLE:
        break;

    case WM_SIMULATENEXT:
        // Simulate the next button somehow
        PropSheet_PressButton( GetParent(hdlg), PSBTN_NEXT);
        break;

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(509);
            BEGIN_SECTION(L"Installed Hardware Page");
            // Make page visible
            SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
            SetWizardButtons(hdlg,WizPageInstalledHardware);
            if(Unattended) {
                UnattendSetActiveDlg(hdlg,IDD_HARDWARE);
            }
            break;

        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
            //
            // Allow next page to be activated.
            //
            SetWindowLong(hdlg,DWL_MSGRESULT,0);
            break;

        case PSN_KILLACTIVE:
            WizardKillHelp(hdlg);
            SetWindowLong(hdlg,DWL_MSGRESULT, FALSE);
            END_SECTION(L"Installed Hardware Page");
            break;

        case PSN_HELP:
            WizardBringUpHelp(hdlg,WizPageInstalledHardware);
            break;

        default:
            break;
        }
        break;

    case WM_DRAWITEM:

        DrawItem( (LPDRAWITEMSTRUCT)lParam );
        break;

    case WM_DESTROY:
        {
            LONG    Count;
            LONG    i;
            PLISTBOX_ITEM   ListBoxItem;

            // SetupDebugPrint( L"SETUP: InstalledHardwareDlgProc() received WM_DESTROY" );
            Count = SendDlgItemMessage( hdlg, IDC_LIST1, LB_GETCOUNT, 0, 0);
            if( Count != LB_ERR ) {
                for( i = 0; i < Count; i++ ) {
                    ListBoxItem = (PLISTBOX_ITEM)SendDlgItemMessage( hdlg, IDC_LIST1, LB_GETITEMDATA, (WPARAM)i, 0);
                    if( (LONG)ListBoxItem != LB_ERR ) {
                        MyFree( ListBoxItem );
                    } else {
                        SetupDebugPrint( L"SETUP: SendDlgItemMessage( LB_GETITEMDATA ) failed. Index = %d, Error = %d", i, GetLastError() );
                    }
                }
            } else {
                SetupDebugPrint( L"SETUP: SendDlgItemMessage( LB_GETCOUNT ) failed. Error = %d", GetLastError() );
            }
            return( FALSE );
        }

    case WM_COMPAREITEM:
        return( CompareListboxItems( (PCOMPAREITEMSTRUCT)lParam ) );

    case WM_COMMAND:

        switch( LOWORD( wParam ) ) {

        case IDC_LIST1:
            {
                switch( HIWORD( wParam )) {

                case LBN_SELCHANGE:
                    {
                        //
                        // Enable the 'Properties' button
                        //
                        EnableWindow( GetDlgItem( hdlg, IDB_BUTTON_1 ),
                                      TRUE );
                        return( FALSE );
                    }

                case LBN_DBLCLK:
                    {
                        //
                        // Simulate that the 'Properties' button was pushed
                        //
                        SendMessage( hdlg,
                                     WM_COMMAND,
                                     MAKEWPARAM( IDB_BUTTON_1, BN_CLICKED ),
                                     ( LPARAM ) GetDlgItem( hdlg, IDB_BUTTON_1 ) );
                        return( FALSE );
                    }
                }
                break;
            }
            break;

        case IDB_BUTTON_1:
            return( FALSE );
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}
#endif // PNP_DEBUG_UI


VOID
SortClassGuidListForDetection(
    IN OUT LPGUID GuidList,
    IN     ULONG  GuidCount,
    OUT    PULONG LastBatchedDetect
    )
/*++

Routine Description:

        This routine sorts the supplied list of GUID based on a (partial)
        ordering specified in the [DetectionOrder] and [NonBatchedDetection]
        sections of syssetup.inf.  This allows us to maintain a detection
        ordering similar to previous versions of NT, and also to allow for
        class installers that may depend upon the successful installation of
        devices detected by other class installers.

Arguments:

        GuidList - address of the array of GUIDs to be sorted.

        GuidCount - the number of GUIDs in the array.  This number must be > 0.

        LastBatchedDetect - Supplies the address of a variable that will
            receive the index of the last GUID in the array that may be batched
            together (i.e., all detections are run, all files queued into one
            big queue, etc.).  Any GUIDs existing at higher indices must be
            processed individually, and such processing will happen _after_ the
            batched detection is completed.

Return Value:

        none.

--*/
{
    LONG LineCount, LineIndex, GuidIndex, NextTopmost;
    PCWSTR CurGuidString;
    INFCONTEXT InfContext;
    GUID CurGuid;

    MYASSERT(GuidCount > 0);

    *LastBatchedDetect = GuidCount - 1;

    //
    // First, sort the classes in syssetup.inf's [DetectionOrder] list to the
    // front...
    //
    LineCount = SetupGetLineCount(SyssetupInf, L"DetectionOrder");
    NextTopmost = 0;

    for(LineIndex = 0; LineIndex < LineCount; LineIndex++) {

        if(!SetupGetLineByIndex(SyssetupInf, L"DetectionOrder", LineIndex, &InfContext) ||
           ((CurGuidString = pSetupGetField(&InfContext, 1)) == NULL) ||
           (pSetupGuidFromString(CurGuidString, &CurGuid) != NO_ERROR)) {

            continue;
        }

        //
        // Search through the GUID list looking for this GUID.  If found, move the GUID from
        // it's current position to the next topmost position.
        //
        for(GuidIndex = 0; GuidIndex < (LONG)GuidCount; GuidIndex++) {

            if(IsEqualGUID(&CurGuid, &(GuidList[GuidIndex]))) {

                if(NextTopmost != GuidIndex) {
                    //
                    // We should never be moving the GUID _down_ the list.
                    //
                    MYASSERT(NextTopmost < GuidIndex);

                    MoveMemory(&(GuidList[NextTopmost + 1]),
                               &(GuidList[NextTopmost]),
                               (GuidIndex - NextTopmost) * sizeof(GUID)
                              );

                    CopyMemory(&(GuidList[NextTopmost]),
                               &CurGuid,
                               sizeof(GUID)
                              );
                }

                NextTopmost++;
                break;
            }
        }
    }

    //
    // Now, move any classes in syssetup.inf's [NonBatchedDetection] list to
    // the end...
    //
    LineCount = SetupGetLineCount(SyssetupInf, L"NonBatchedDetection");

    for(LineIndex = 0; LineIndex < LineCount; LineIndex++) {

        if(!SetupGetLineByIndex(SyssetupInf, L"NonBatchedDetection", LineIndex, &InfContext) ||
           ((CurGuidString = pSetupGetField(&InfContext, 1)) == NULL) ||
           (pSetupGuidFromString(CurGuidString, &CurGuid) != NO_ERROR)) {

            continue;
        }

        //
        // Search through the GUID list looking for this GUID.  If found, move
        // the GUID from it's current position to the end of the list.
        //
        for(GuidIndex = 0; GuidIndex < (LONG)GuidCount; GuidIndex++) {

            if(IsEqualGUID(&CurGuid, &(GuidList[GuidIndex]))) {
                //
                // We found a non-batched class--decrement our index that
                // points to the last batched detection class.
                //
                (*LastBatchedDetect)--;

                //
                // Now shift all the GUIDs after this one up, and move this one
                // to the last position in the array (unless, of course, it was
                // already at the last position in the array).
                //
                if(GuidIndex < (LONG)(GuidCount - 1)) {

                    MoveMemory(&(GuidList[GuidIndex]),
                               &(GuidList[GuidIndex+1]),
                               (GuidCount - (GuidIndex+1)) * sizeof(GUID)
                              );
                    CopyMemory(&(GuidList[GuidCount-1]),
                               &CurGuid,
                               sizeof(GUID)
                              );
                }

                break;
            }
        }
    }
}


DWORD
pPhase1InstallPnpLegacyDevicesThread(
    PPNP_PHASE1_LEGACY_DEV_THREAD_PARAMS ThreadParams
    )
/*++

Routine Description:

    This thread does the initial part of the installation installation
    of legacy Pnp devices of a particular class.

    It invokes a class installer of a particular class with:

            - DIF_FIRSTTIMESETUP

    If it successds, it returns in the structure passed as argument
    a device info list that contains the detected legacy devices.

Arguments:

    ThreadParams - Points to a structure that contains the information
                   passed to this thread.

Return Value:

    Returns a Win32 error code.

--*/

{
    PPNP_PHASE1_LEGACY_DEV_THREAD_PARAMS Context;

    LPGUID                pGuid;
    PWSTR                 pClassDescription;

    HDEVINFO              hEmptyDevInfo;
    ULONG                 Error;

    //
    //  Initialize variables
    //
    Context = ThreadParams;
    Context->hDevInfo = INVALID_HANDLE_VALUE;
    pGuid = &(Context->Guid);
    pClassDescription = Context->pClassDescription;

    //
    //  Assume success
    //
    Error = ERROR_SUCCESS;

    //
    //  DIF_FIRSTTIME
    //
    if((hEmptyDevInfo = SetupDiCreateDeviceInfoList(pGuid,
                                                    Context->hwndParent))
                    == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
        SetupDebugPrint2( L"SETUP:     SetupDiCreateDeviceInfoList() failed (phase1). Error = %d, ClassDescription = %ls", Error, pClassDescription );
        goto phase1_legacy_dev_thread_exit;
    }

    if( !SetupDiCallClassInstaller( DIF_FIRSTTIMESETUP,
                                    hEmptyDevInfo,
                                    NULL ) ) {

        Error = GetLastError();
        if( Error != ERROR_DI_DO_DEFAULT ) {
            SetupDebugPrint2( L"SETUP:     SetupDiCallClassInstaller(DIF_FIRSTTIMESETUP) failed (phase1). Error = %lx, ClassDescription = %ls", Error, pClassDescription );
        } else {
            SetupDebugPrint2( L"SETUP:     SetupDiCallClassInstaller(DIF_FIRSTTIMESETUP) failed (phase1). Error = %lx, ClassDescription = %ls", Error, pClassDescription );
        }
        SetupDiDestroyDeviceInfoList(hEmptyDevInfo);
        goto phase1_legacy_dev_thread_exit;
    }
    //
    //  Save the info set after DIF_FIRSTTIMESETUP
    //
    Context->hDevInfo = hEmptyDevInfo;
    SetupDebugPrint1( L"SETUP:     SetupDiCallClassInstaller(DIF_FIRSTTIMESETUP) succeeded (phase1). ClassDescription = %ls", pClassDescription );

phase1_legacy_dev_thread_exit:
    return(Error);
}


DWORD
pPhase2InstallPnpLegacyDevicesThread(
    PPNP_PHASE2_LEGACY_DEV_THREAD_PARAMS ThreadParams
    )
/*++

Routine Description:

    This thread does a partial installation of a legacy device.
    It invokes a class installer with:

            - DIF_REGISTERDEVICE
            - DIF_ALLOW_INSTALL
            - DIF_INSTALLDEVICEFILES

    Note that the call with DIF_INSTALLDEVICEFILES only queue the files on the queue
    created by the parent of this handle.

Arguments:

    ThreadParams - Points to a structure that contains the information
                   passed to this thread.

Return Value:

    Returns TRUE is all calls to the class installer were successfull.
    Otherwise, returns FALSE.

--*/

{
    PPNP_PHASE2_LEGACY_DEV_THREAD_PARAMS Context;

    HDEVINFO              hDevInfo;
    HSPFILEQ              FileQ;
    HSPFILEQ              TempFileQ = INVALID_HANDLE_VALUE;
    PSP_DEVINFO_DATA      pDeviceInfoData;
    PWSTR                 pClassDescription;
    PWSTR                 pDeviceId;

    BOOL                  b;
    ULONG                 Error;
    SP_DEVINSTALL_PARAMS  DeviceInstallParams;
    DWORD                 ScanQueueResult;

    //
    //  Initialize variables
    //
    Context = ThreadParams;
    hDevInfo = Context->hDevInfo;
    FileQ = Context->FileQ;
    pDeviceInfoData = &(Context->DeviceInfoData);
    pClassDescription = Context->pClassDescription;
    pDeviceId = Context->pDeviceId;

    //
    //  Assume success
    //
    Error = ERROR_SUCCESS;
    b = TRUE;

    //
    // Let the class installer/co-installers know they should be quiet.
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if(!SetupDiGetDeviceInstallParams(hDevInfo, pDeviceInfoData, &DeviceInstallParams)) {
        SetupDebugPrint2( L"SETUP:         SetupDiGetDeviceInstallParams() failed (phase2). Error = %d, DeviceId = %ls", GetLastError(), pDeviceId );
        b = FALSE;
        goto phase2_legacy_dev_thread_exit;
    }

    DeviceInstallParams.Flags |= DI_QUIETINSTALL;

    if(!SetupDiSetDeviceInstallParams(hDevInfo, pDeviceInfoData, &DeviceInstallParams)) {
        SetupDebugPrint2( L"SETUP:         SetupDiSetDeviceInstallParams() failed (phase2). Error = %d, DeviceId = %ls", GetLastError(), pDeviceId );
        b = FALSE;
        goto phase2_legacy_dev_thread_exit;
    }

    //
    //  Register the device
    //
    if( !SetupDiCallClassInstaller( DIF_REGISTERDEVICE,
                                    hDevInfo,
                                    pDeviceInfoData ) ) {

        SetupDebugPrint2( L"SETUP:         SetupDiCallClassInstaller(DIF_REGISTERDEVICE) failed (phase2). Error = %lx, DeviceId = %ls", GetLastError(), pDeviceId );
        b = FALSE;
        goto phase2_legacy_dev_thread_exit;
    }

    //
    // Verify with the class installer and class-specific co-installers that the
    // driver we're about to install isn't blacklisted.
    //
    if( !SetupDiCallClassInstaller( DIF_ALLOW_INSTALL,
                                    hDevInfo,
                                    pDeviceInfoData ) ) {
        Error = GetLastError();
        if( Error != ERROR_DI_DO_DEFAULT ) {
            SetupDebugPrint2( L"SETUP: SetupDiCallClassInstaller(DIF_ALLOW_INSTALL) failed (phase2). Error = %d, DeviceId = %ls", Error, pDeviceId );
            b = FALSE;
            goto phase2_legacy_dev_thread_exit;
        }
    }

    //
    // In general, any devices being installed as a result of DIF_FIRSTTIMESETUP
    // will be using in-box drivers, and as such, will be signed.  However, it
    // is possible that a built-in class installer will report a detected device
    // that's using a 3rd-party, unsigned driver.  The ScsiAdapter class is such
    // a case.  If we _do_ encounter unsigned driver packages, we want to avoid
    // media prompting, just like we do when installing PnP-enumerated devices.
    // Unfortunately, this is complicated in the legacy case by the fact that we
    // queue all files into one big queue, then commit the queue in an all-or-
    // nothing fashion.  Thus, we don't have the same granularity that we have
    // when installing PnP-enumerated devices in a one-at-a-time fashion.
    //
    // To address this, we will first queue up all files to a "temporary" queue,
    // which we will then examine in a similar fashion to the way we handle the
    // per-device queues for PnP-enumerated devices.  If the catalog nodes
    // associated with the queue are all signed, then we'll queue up those same
    // files to our "real" queue.  If one or more catalog nodes are not signed,
    // we'll then do a queue scan based on presence checking.  If all files
    // required are present, then we'll add nothing to the "real" queue, but
    // allow the device to be subsequently installed.  If one or more required
    // files are found to be missing, we're in a bad state, because queueing
    // these files up to our "real" queue means the user will (potentially) see
    // a driver signing warning popup and/or media prompt, either of which they
    // may cancel out of.  Since the legacy device install queue is one big
    // queue containing fileops for all such device installs, cancelling its
    // committal would result in none of the files being copied for any phase2
    // install.  Thus, multimedia codecs, non-motherboard legacy COM ports, and
    // other (signed) system devices wouldn't get installed.  Since this is
    // obviously unacceptable, we instead simply skip installation for this
    // device, just as if DIF_ALLOWINSTALL had failed.  This isn't as bad as it
    // sounds, because it would be _exceedingly_ rare if a 3rd-party driver's
    // device were reported, yet all necessary files weren't present.
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if(!SetupDiGetDeviceInstallParams(hDevInfo, pDeviceInfoData, &DeviceInstallParams)) {
        SetupDebugPrint2( L"SETUP:         SetupDiGetDeviceInstallParams() failed for TempFileQueue (phase2). Error = %d, DeviceId = %ls", GetLastError(), pDeviceId );
        b = FALSE;
        goto phase2_legacy_dev_thread_exit;
    }

    //
    // Note: this code has had the following comment (and behavior) for a _long_
    // time...
    //
    //     "we may rely on this flag being set this early"
    //
    // The DI_FORCECOPY flag actually has no effect on any setupapi activity
    // except for installation of class installer files via
    // SetupDiInstallClass(Ex).  However, it's possible some class-/co-installer
    // has developed a dependency on its presence, and since it doesn't hurt
    // anything, we'll continue to set it.
    //
    DeviceInstallParams.Flags |= DI_FORCECOPY;

    TempFileQ = SetupOpenFileQueue();
    if(TempFileQ == INVALID_HANDLE_VALUE) {
        SetupDebugPrint2( L"SETUP:         SetupOpenFileQueue() failed for TempFileQueue (phase2). Error = %d, DeviceId = %ls", GetLastError(), pDeviceId );
        b = FALSE;
        goto phase2_legacy_dev_thread_exit;
    }

    DeviceInstallParams.Flags |= DI_NOVCP;
    DeviceInstallParams.FileQueue = TempFileQ;

    if(!SetupDiSetDeviceInstallParams(hDevInfo, pDeviceInfoData, &DeviceInstallParams)) {
        SetupDebugPrint2( L"SETUP:         SetupDiSetDeviceInstallParams() failed for TempFileQueue (phase2). Error = %d, DeviceId = %ls", GetLastError(), pDeviceId );
        b = FALSE;
        goto phase2_legacy_dev_thread_exit;
    }

    //
    //  Queue the device files into our temporary file queue
    //
    if(SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES,
                                 hDevInfo,
                                 pDeviceInfoData)) {
        Error = ERROR_SUCCESS;

    } else {

        Error = GetLastError();

        if(Error == ERROR_DI_DO_DEFAULT) {
            //
            // This isn't actually an error
            //
            Error = ERROR_SUCCESS;
        } else {
            SetupDebugPrint2( L"SETUP:         SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES) failed for TempFileQueue (phase2). Error = %lx, DeviceId = %ls", Error, pDeviceId );
        }
    }

    //
    // Disassociate the temporary file queue from the device information
    // element so that we can free it later...
    //
    DeviceInstallParams.Flags &= ~DI_NOVCP;
    DeviceInstallParams.FileQueue = INVALID_HANDLE_VALUE;

    if(!SetupDiSetDeviceInstallParams(hDevInfo, pDeviceInfoData, &DeviceInstallParams)) {
        SetupDebugPrint2( L"SETUP:         SetupDiSetDeviceInstallParams() failed for disassociating TempFileQueue (phase2). Error = %d, DeviceId = %ls", GetLastError(), pDeviceId );
        b = FALSE;
        goto phase2_legacy_dev_thread_exit;
    }

    if(Error == ERROR_SUCCESS) {
        SetupDebugPrint1( L"SETUP:         SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES) suceeded for TempFileQueue (phase2). DeviceId = %ls", pDeviceId );
    } else {
        b = FALSE;
        goto phase2_legacy_dev_thread_exit;
    }

    //
    // Now that we've retrieved all files operations into our temporary file
    // queue, we can "pre-verify" the catalog nodes in the queue.  If an OEM
    // INF in %windir%\Inf is unsigned, we scan the queue to see if all
    // required files are present (although not validated) in their target
    // locations.  If we're doing an upgrade, and all files are in-place, we'll
    // forego queue committal.  If we're doing a fresh-install, and all files
    // are in-place, we'll commit the empty queue on-the-spot, so that the user
    // will get the driver signing popup (based on policy), thus may
    // potentially abort the installation of this device.  If all files aren't
    // already in-place, we silently abort the device installation, as we can't
    // run the risk of queueing up potentially-cancellable fileops to the
    // "real" legacy device install queue.
    //
    if(NO_ERROR != pSetupVerifyQueuedCatalogs(TempFileQ)) {
        //
        // We only want to prune based on presence check for OEM INFs living in
        // %windir%\Inf.
        //
        SP_DRVINFO_DATA        DriverInfoData;
        SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;

        //
        // Retrieve the name of the INF associated with the selected driver
        // node.
        //
        DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
        if(!SetupDiGetSelectedDriver(hDevInfo, pDeviceInfoData, &DriverInfoData)) {
            SetupDebugPrint2( L"SETUP:         SetupDiGetSelectedDriver() failed. Error = %d, Device = %ls", GetLastError(), pDeviceId );
            b = FALSE;
            goto phase2_legacy_dev_thread_exit;
        }

        DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
        if(!SetupDiGetDriverInfoDetail(hDevInfo,
                                       pDeviceInfoData,
                                       &DriverInfoData,
                                       &DriverInfoDetailData,
                                       sizeof(DriverInfoDetailData),
                                       NULL) &&
           (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {

            SetupDebugPrint2( L"SETUP:         SetupDiGetDriverInfoDetail() failed. Error = %d, Device = %ls", GetLastError(), pDeviceId );
            b = FALSE;
            goto phase2_legacy_dev_thread_exit;
        }

        if(pSetupInfIsFromOemLocation(DriverInfoDetailData.InfFileName, TRUE) ||
           IsInfInLayoutInf(DriverInfoDetailData.InfFileName)) {
            //
            // Either the INF lives somewhere other than %windir%\Inf, or its
            // an in-box unsigned INF.  In either case, we want to
            // abort installation of this device, otherwise we risk having the
            // user cancel the queue committal, and wipe out all the other
            // detected device installs as well.
            //
            SetupDebugPrint2( L"SETUP:         Skipping unsigned driver install for detected device (phase2). DeviceId = %ls, Inf = %ls", pDeviceId, DriverInfoDetailData.InfFileName );
            b = FALSE;
            goto phase2_legacy_dev_thread_exit;

        } else {
            //
            // Note: it doesn't really matter whether we do an "all-or-nothing"
            // scan or a pruning scan here, because we're going to abort the
            // install on anything other than a fully empty (post-scan) queue.
            // We request pruning here, because that fits better with the
            // semantics of SPQ_SCAN_PRUNE_DELREN (this flag's semantics
            // don't really fit with a non-pruning scan, as discussed in RAID
            // #280543).
            //
            if(!SetupScanFileQueue(TempFileQ,
                                   SPQ_SCAN_FILE_PRESENCE |
                                   SPQ_SCAN_PRUNE_COPY_QUEUE |
                                   SPQ_SCAN_PRUNE_DELREN,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &ScanQueueResult)) {
                //
                // SetupScanFileQueue failed for some reason (rare).  We'll
                // just commit the whole file queue...
                //
                ScanQueueResult = 0;
            }

            if(ScanQueueResult != 1) {
                //
                // Abort installation of this device, otherwise we risk having
                // the user cancel the queue committal, and wipe out all the
                // other detected device installs as well.
                //
                SetupDebugPrint1( L"SETUP:         Skipping unsigned driver install for detected device due to missing files (phase2). DeviceId = %ls", pDeviceId );
                b = FALSE;
                goto phase2_legacy_dev_thread_exit;
            }

            if(!Upgrade) {

                PVOID QCBContext;

                //
                // No fileops left in queue, but we're doing a fresh install,
                // so we still want to give user driver signing popup (logging
                // the event to setupapi.log), and let them potentially abort
                // the unsigned installation...
                //
                QCBContext = InitSysSetupQueueCallbackEx(
                                 DeviceInstallParams.hwndParent,
                                 INVALID_HANDLE_VALUE,
                                 0,
                                 0,
                                 NULL
                                );

                if(!QCBContext) {
                    SetupDebugPrint1( L"SETUP:         Failed to allocate queue callback context (phase2). DeviceId = %ls", pDeviceId );
                    b = FALSE;
                    goto phase2_legacy_dev_thread_exit;
                }

                if(!SetupCommitFileQueue(DeviceInstallParams.hwndParent,
                                         TempFileQ,
                                         SysSetupQueueCallback,
                                         QCBContext)) {
                    //
                    // User elected not to proceed with the unsigned installation.
                    //
                    SetupDebugPrint2( L"SETUP:         SetupCommitFileQueue() failed (phase2). Error = %d, Device = %ls", GetLastError(), pDeviceId );
                    b = FALSE;
                }

                TermSysSetupQueueCallback(QCBContext);

                if(!b) {
                    goto phase2_legacy_dev_thread_exit;
                }
            }
        }

    } else {
        //
        // Queue the files to be copied for this device to the "real" file queue
        //
        if( FileQ != INVALID_HANDLE_VALUE ) {
            DeviceInstallParams.Flags |= DI_NOVCP;
            DeviceInstallParams.FileQueue = FileQ;
        }

        if(!SetupDiSetDeviceInstallParams(hDevInfo, pDeviceInfoData, &DeviceInstallParams)) {
            SetupDebugPrint2( L"SETUP:         SetupDiSetDeviceInstallParams() failed (phase2). Error = %d, DeviceId = %ls", GetLastError(), pDeviceId );
            b = FALSE;
            goto phase2_legacy_dev_thread_exit;
        }

        //
        //  Install the device files (queue the files)
        //
        Error = ERROR_SUCCESS;
        if( !SetupDiCallClassInstaller( DIF_INSTALLDEVICEFILES,
                                        hDevInfo,
                                        pDeviceInfoData ) &&
            ( ( Error = GetLastError() ) != ERROR_DI_DO_DEFAULT )
          ) {

            SetupDebugPrint2( L"SETUP:         SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES) failed (phase2). Error = %lx, DeviceId = %ls", Error, pDeviceId );
            b = FALSE;
            goto phase2_legacy_dev_thread_exit;
        }
        SetupDebugPrint1( L"SETUP:         SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES) suceeded (phase2). DeviceId = %ls", pDeviceId );
    }

    //
    //  Mark the device as 'Do install'
    //
    if( !pSetupDiSetDeviceInfoContext( hDevInfo, pDeviceInfoData, TRUE ) ) {
        SetupDebugPrint2( L"SETUP:         pSetupDiSetDeviceInfoContext() failed (phase2). Error = %lx, DeviceId = %ls", GetLastError(), pDeviceId );
        b = FALSE;
        goto phase2_legacy_dev_thread_exit;
    }

phase2_legacy_dev_thread_exit:

    if(TempFileQ != INVALID_HANDLE_VALUE) {
        SetupCloseFileQueue(TempFileQ);
    }

    return(b);
}


BOOL
CheckIfDeviceHasWizardPages( HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDeviceInfoData
    )
/*++

Routine Description:

    This routine invokes the class installer with
    DIF_NEWDEVICEWIZARD_FINISHINSTALL to determine if the device has wizard
    pages to display.

Arguments:

    hDevInfo - The device info set.
    pDeviceInfoData - The device that needs to be marked

Return Value:

    Returns TRUE if the device has FINISHINSTALL wizard pages, FALSE otherwise
--*/

{
    SP_NEWDEVICEWIZARD_DATA ndwd = {0};
    BOOL                    b;

    // Check if this device has wizard pages that need to be shown as
    // part of the install.  If so, we will mark the device as
    // nneding a reinstall so the UI can be display later
    //

    ndwd.ClassInstallHeader.cbSize = sizeof( SP_CLASSINSTALL_HEADER );
    ndwd.ClassInstallHeader.InstallFunction = DIF_NEWDEVICEWIZARD_FINISHINSTALL;

    // Set the install params for the function
    b = SetupDiSetClassInstallParams( hDevInfo, pDeviceInfoData,
                                        (PSP_CLASSINSTALL_HEADER) ( &ndwd ),
                                        sizeof( ndwd ) );
    if ( b ) {

        // Invoke the class installer (and co-installers)
        b = SetupDiCallClassInstaller( DIF_NEWDEVICEWIZARD_FINISHINSTALL,
                                         hDevInfo,
                                         pDeviceInfoData );
        if ( b || (ERROR_DI_DO_DEFAULT == GetLastError())) {

            // Retrieve the install params
            b = SetupDiGetClassInstallParams( hDevInfo,
                                                pDeviceInfoData,
                                                (PSP_CLASSINSTALL_HEADER)&ndwd,
                                                sizeof(ndwd),
                                                NULL );
            if ( b ) {

                // Are there any pages?
                if ( 0 == ndwd.NumDynamicPages ) {
                    b = FALSE;
                }
                else {
                    // b is already TRUE if we made it here so no need to set
                    UINT i;

                    // We don't need the pages so destroy them
                    for ( i = 0; i < ndwd.NumDynamicPages; i++ ) {
                        DestroyPropertySheetPage( ndwd.DynamicPages[i] );
                    }
                }
            }
            else {
                SetupDebugPrint1( L"SETUP: SetupDiGetClassInstallParams failed (phase3). Error = %lx", GetLastError() );
            }
        }
        else if ( ERROR_DI_DO_DEFAULT != GetLastError() ) {
            SetupDebugPrint1( L"SETUP: SetupDiCallClassInstaller(DIF_NEWDEVICEWIZARD_FINISHINSTALL) failed (phase3). Error = %lx", GetLastError() );
        }
    }
    else {
        SetupDebugPrint1( L"SETUP: SetupDiSetClassInstallParams failed. Error = %lx", GetLastError() );
    }

    return b;
}

BOOL
MarkDeviceAsNeedsReinstallIfNeeded(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDeviceInfoData
    )
/*++

Routine Description:

    This function checks if a device has wizard pages
    (DIF_NEWDEVICEWIZARD_FINISHINSTALL pages) and sets the REINSTALL
    config flag if it does.

Arguments:

    hDevInfo        - The device info set.
    pDeviceInfoData - The device whose config flags will set.

Return Value:

    Returns TRUE if successful, FALSE on error.

--*/
{
    DWORD ConfigFlags;
    BOOL b = TRUE;

    if (CheckIfDeviceHasWizardPages( hDevInfo, pDeviceInfoData ) ) {

        SetupDebugPrint( L"SETUP: Device has wizard pages, marking as need reinstall." );

        //
        // Get the config flags for the device and set the reinstall bit
        //
        if ( !( b = GetDeviceConfigFlags(hDevInfo, pDeviceInfoData, &ConfigFlags ) ) ) {
            SetupDebugPrint( L"SETUP:   GetDeviceConfigFlags failed. " );
        }

        if ( b ) {

            ConfigFlags |= CONFIGFLAG_REINSTALL;

            if ( !( b = SetDeviceConfigFlags(hDevInfo, pDeviceInfoData, ConfigFlags ) ) ) {

                SetupDebugPrint( L"SETUP:   SetDeviceConfigFlags failed. " );
            }
        }
    }

    return b;
}

DWORD
pPhase3InstallPnpLegacyDevicesThread(
    PPNP_PHASE3_LEGACY_DEV_THREAD_PARAMS ThreadParams
    )
/*++

Routine Description:

    This thread completes the installation of a legacy device.
    It invokes a class installer with:

            - DIF_REGISTER_COINSTALLERS
            - DIF_INSTALLINTERFACES
            - DIF_INSTALLDEVICE

Arguments:

    ThreadParams - Points to a structure that contains the information
                   passed to this thread.

Return Value:

    Returns TRUE if all calls to the class installer were successfull.
    Otherwise, returns FALSE.

--*/

{
    PPNP_PHASE3_LEGACY_DEV_THREAD_PARAMS Context;

    HDEVINFO                hDevInfo;
    PSP_DEVINFO_DATA        pDeviceInfoData;
    SP_DEVINSTALL_PARAMS    DeviceInstallParams;
    PWSTR                   pDeviceId;

    BOOL                    b;
    WCHAR                   DeviceDescription[MAX_PATH];
    DWORD                   Status;
    DWORD                   Problem;
    BOOL                    fNewDevice = FALSE;


    Context = ThreadParams;
    hDevInfo = Context->hDevInfo;
    pDeviceInfoData = &(Context->DeviceInfoData);
    pDeviceId = Context->pDeviceId;

    b = TRUE;

    //
    // Register any device-specific co-installers for this device.
    //
    if( !SetupDiCallClassInstaller(DIF_REGISTER_COINSTALLERS, hDevInfo, pDeviceInfoData ) ) {
        SetupDebugPrint2( L"SETUP: SetupDiCallClassInstaller(DIF_REGISTER_COINSTALLERS) failed (phase3). Error = %d, DeviceId = %ls", GetLastError(), pDeviceId );
        b = FALSE;
        goto phase3_legacy_dev_thread_exit;
    }

    //
    // Install any INF/class installer-specified interfaces.
    //
    if( !SetupDiCallClassInstaller(DIF_INSTALLINTERFACES, hDevInfo, pDeviceInfoData) ) {
        SetupDebugPrint2( L"SETUP: SetupDiCallClassInstaller(DIF_REGISTER_INSTALLINTERFACES) failed (phase3). Error = %d, DeviceId = %ls", GetLastError(), pDeviceId );
        b = FALSE;
        goto phase3_legacy_dev_thread_exit;
    }

    //
    // Before we install this device, we need to find out if it is a new
    // device or a reinstall.  If the problem CM_PROB_NOT_CONFIGURED is set
    // then we will consider it as a new device and check if it has wizard
    // pages after DIF_INSTALLDEVICE
    //
    if ( CR_SUCCESS == CM_Get_DevInst_Status(&Status,
                                             &Problem,
                                             (DEVINST)pDeviceInfoData->DevInst,
                                             0 ) && (Problem & CM_PROB_NOT_CONFIGURED) )
    {
        fNewDevice = TRUE;
    }

    //
    // Set the DI_FLAGSEX_RESTART_DEVICE_ONLY for legacy device installs. This
    // flag tells setupapi to only stop/start this one device and not all
    // devices that share the same drivers with this device.
    //
    // This is not critical if this fails since by default setupapi will just
    // stop/start all devices that share drivers with this device, including
    // the device itself. This can cause stop/start to take a little longer
    // if there are lots of devices sharing drivers with this device.
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if(SetupDiGetDeviceInstallParams(hDevInfo, pDeviceInfoData, &DeviceInstallParams)) {

        DeviceInstallParams.FlagsEx |= DI_FLAGSEX_RESTART_DEVICE_ONLY;

        SetupDiSetDeviceInstallParams(hDevInfo, pDeviceInfoData, &DeviceInstallParams);
    }

    if( !SetupDiCallClassInstaller( DIF_INSTALLDEVICE,
                                    hDevInfo,
                                    pDeviceInfoData ) ) {

        SetupDebugPrint2( L"SETUP: SetupDiCallClassInstaller(DIF_INSTALLDEVICE) failed (phase3). Error = %lx, DeviceId = %ls", GetLastError(), pDeviceId );
        b = FALSE;
        goto phase3_legacy_dev_thread_exit;
    }
    DeviceDescription[0] = L'\0';
    if( !SetupDiGetDeviceRegistryProperty( hDevInfo,
                                           pDeviceInfoData,
                                           SPDRP_DEVICEDESC,
                                           NULL,
                                           (PBYTE)DeviceDescription,
                                           sizeof( DeviceDescription ),
                                           NULL ) ) {
        SetupDebugPrint2( L"SETUP:       SetupDiGetDeviceRegistryProperty() failed. Error = %d, DeviceId = %ls", GetLastError(), pDeviceId );
    }
    SetupDebugPrint2( L"SETUP: Device installed. DeviceId = %ls, Description = %ls", pDeviceId, DeviceDescription );


    //
    // If the device has wizard pages to show (in response to
    // DIF_NEWDEVICEWIZARD_FINISHINSTALL) then it needs to be marked as need
    // reinstall so that pages get a chance to be shown at a later time
    //
    if ( fNewDevice ) {
        b = MarkDeviceAsNeedsReinstallIfNeeded( hDevInfo, pDeviceInfoData);
    }


phase3_legacy_dev_thread_exit:
    return( b );
}


BOOL
GetDeviceConfigFlags(HDEVINFO hDevInfo, PSP_DEVINFO_DATA pDeviceInfoData,
                     DWORD* pdwConfigFlags)
/*++

Routine Description:

    This function gets the configflags of a device.

Arguments:

    hDevInfo        - The device info set.
    pDeviceInfoData - The device whose config flags will be retrieved.
    pdwConfigFlags  - The buffer that will receive the current flags.

Return Value:

    Returns TRUE if successful, FALSE on error.

--*/
{
    BOOL    b = TRUE;
    DWORD   Error;

    //
    // Clear the output parameter
    //
    *pdwConfigFlags = 0;

    // Get the config flags for the device
    if( !SetupDiGetDeviceRegistryProperty( hDevInfo,
                                           pDeviceInfoData,
                                           SPDRP_CONFIGFLAGS,
                                           NULL,
                                           (PBYTE)pdwConfigFlags,
                                           sizeof( *pdwConfigFlags ),
                                           NULL ) ) {
        Error = GetLastError();
        //
        //  ERROR_INVALID_DATA is ok. It means that the device doesn't have config flags set yet.
        //
        if( Error != ERROR_INVALID_DATA ) {
            if( ((LONG)Error) < 0 ) {
                //
                //  Setupapi error code, display it in hex
                //
                SetupDebugPrint1( L"SETUP:   GetDeviceConfigFlags failed. Error = %lx", Error );
            } else {
                //
                //  win32 error code, display it in decimal
                //
                SetupDebugPrint1( L"SETUP:   GetDeviceConfigFlags failed. Error = %d", Error );
            }
            b = FALSE;
        }
    }

    return b;
}

BOOL
SetDeviceConfigFlags(HDEVINFO hDevInfo, PSP_DEVINFO_DATA pDeviceInfoData,
                     DWORD dwConfigFlags)
/*++

Routine Description:

    This function sets the configflags of a device.

Arguments:

    hDevInfo        - The device info set.
    pDeviceInfoData - The device whose config flags will set.
    dwConfigFlags   - The config flags to set.

Return Value:

    Returns TRUE if successful, FALSE on error.

--*/

{
    BOOL    b = TRUE;
    DWORD   Error;

    if( !SetupDiSetDeviceRegistryProperty( hDevInfo,
                                           pDeviceInfoData,
                                           SPDRP_CONFIGFLAGS,
                                           (PBYTE)&dwConfigFlags,
                                           sizeof( dwConfigFlags ) ) ) {
        Error = GetLastError();
        if( ((LONG)Error) < 0 ) {
            //
            //  Setupapi error code, display it in hex
            //
            SetupDebugPrint1( L"SETUP:   SetDeviceConfigFlags failed. Error = %lx", Error );
        } else {
            //
            //  win32 error code, display it in decimal
            //
            SetupDebugPrint1( L"SETUP:   SetDeviceConfigFlags failed. Error = %d", Error );
        }
        b = FALSE;
    }

    return b;
}


DWORD
pInstallPnpEnumeratedDeviceThread(
    PPNP_ENUM_DEV_THREAD_PARAMS ThreadParams
    )
/*++

Routine Description:

    This is the thread that does the installation of an enumerated PnP device.

Arguments:

    ThreadParams - Points to a structure that contains the information
                   passed to this thread.

Return Value:

    Returns a Win32 error code.

--*/

{
    PPNP_ENUM_DEV_THREAD_PARAMS Context;
    HDEVINFO                    hDevInfo;
    PSP_DEVINFO_DATA            pDeviceInfoData;
    PSP_DEVINSTALL_PARAMS       pDeviceInstallParams;
    PWSTR                       pDeviceDescription;
    PWSTR                       pDeviceId;
    ULONG                       Error;
    WCHAR                       RootPath[ MAX_PATH + 1];
    SP_DEVINSTALL_PARAMS        DeviceInstallParams;
    DWORD                       Status;
    DWORD                       Problem;
    BOOL                        fNewDevice = FALSE;
    DWORD                       ConfigFlags;
    HSPFILEQ                    FileQ;
    PVOID                       QContext;
    HSPFILEQ                    SavedFileQ;
    DWORD                       SavedFlags;
    DWORD                       ScanQueueResult;
    HWND                        hwndParent;
    SP_DRVINFO_DATA             pDriverInfoData;
    HKEY                        hClassKey;
    WCHAR                       InfPath[MAX_PATH];
    BOOL                        fCommitFileQueue = TRUE;
    BOOL                        fDriversChanged = FALSE;
    DWORD                       FileQueueFlags;

    Context = ThreadParams;

    hDevInfo = Context->hDevInfo;
    pDeviceInfoData = &(Context->DeviceInfoData);
    pDeviceInstallParams = &DeviceInstallParams;
    pDeviceDescription = Context->pDeviceDescription;
    pDeviceId = Context->pDeviceId;
    InfPath[0] = TEXT('\0');

    Error = ERROR_SUCCESS;

    //
    // Queue all files to be copied into our own file queue.
    //
    FileQ = SetupOpenFileQueue();

    if ( FileQ == (HSPFILEQ)INVALID_HANDLE_VALUE ) {
        Error = GetLastError();
        SetupDebugPrint2( L"SETUP: SetupOpenFileQueue() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
        goto enum_dev_thread_exit;
    }

    pDeviceInstallParams->cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if(!SetupDiGetDeviceInstallParams(hDevInfo, pDeviceInfoData, pDeviceInstallParams)) {
        Error = GetLastError();
        SetupDebugPrint2( L"SETUP: SetupDiGetDeviceInstallParams() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
        goto enum_dev_thread_exit;
    }

    //
    // Let the class installer/co-installers know that they should be quiet
    //
    pDeviceInstallParams->Flags |= DI_QUIETINSTALL;

    if(!SetupDiSetDeviceInstallParams(hDevInfo, pDeviceInfoData, pDeviceInstallParams)) {
        Error = GetLastError();
        SetupDebugPrint2( L"SETUP: SetupDiSetDeviceInstallParams() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
        goto enum_dev_thread_exit;
    }

    //
    // Install the class if it does not exist.
    //
    if (CM_Open_Class_Key(&pDeviceInfoData->ClassGuid,
                          NULL,
                          KEY_READ,
                          RegDisposition_OpenExisting,
                          &hClassKey,
                          CM_OPEN_CLASS_KEY_INSTALLER
                          ) != CR_SUCCESS) {

        HSPFILEQ                    ClassFileQ;
        PVOID                       ClassQContext;
        SP_DRVINFO_DETAIL_DATA      DriverInfoDetailData;

        ClassFileQ = SetupOpenFileQueue();

        if ( ClassFileQ == (HSPFILEQ)INVALID_HANDLE_VALUE ) {
            Error = GetLastError();
            SetupDebugPrint2( L"SETUP: SetupOpenFileQueue() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
            goto enum_dev_thread_exit;
        }

        //
        // First, we have to retrieve the name of the INF associated with the
        // selected driver node.
        //
        pDriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
        if (!SetupDiGetSelectedDriver(hDevInfo, pDeviceInfoData, &pDriverInfoData)) {
            Error = GetLastError();
            SetupDebugPrint2( L"SETUP: SetupDiGetSelectedDriver() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
            goto enum_dev_thread_exit;
        }

        DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
        if (!SetupDiGetDriverInfoDetail(hDevInfo,
                                 pDeviceInfoData,
                                 &pDriverInfoData,
                                 &DriverInfoDetailData,
                                 sizeof(DriverInfoDetailData),
                                 NULL) &&
            (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {

            Error = GetLastError();
            SetupDebugPrint2( L"SETUP: SetupDiGetDriverInfoDetail() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
            goto enum_dev_thread_exit;
        }

        if (!SetupDiInstallClass(NULL,
                                 DriverInfoDetailData.InfFileName,
                                 DI_NOVCP | DI_FORCECOPY,
                                 ClassFileQ)) {

            Error = GetLastError();
            SetupDebugPrint3( L"SETUP: SetupDiInstallClass(%s) failed. Error = %d, Device = %ls", DriverInfoDetailData.InfFileName, Error, pDeviceDescription );
            goto enum_dev_thread_exit;
        }

        //
        // Commit the file queue.
        //
        ClassQContext = InitSysSetupQueueCallbackEx(
            NULL,
            INVALID_HANDLE_VALUE,
            0,0,NULL);

        if( ClassQContext == NULL) {
            Error = GetLastError();
            SetupDebugPrint1( L"SETUP: InitSysSetupQueueCallbackEx() failed. Error = %d", Error );
            goto enum_dev_thread_exit;
        }

        if (!SetupCommitFileQueue(
                        NULL,
                        ClassFileQ,
                        SysSetupQueueCallback,
                        ClassQContext
                        )) {
            Error = GetLastError();
        }

        TermSysSetupQueueCallback(ClassQContext);

        if ( ClassFileQ != (HSPFILEQ)INVALID_HANDLE_VALUE ) {
            SetupCloseFileQueue( ClassFileQ );
        }

        if (Error == NO_ERROR) {
            SetupDebugPrint1( L"SETUP:            SetupDiInstallClass() succeeded. Device = %ls", pDeviceDescription );
        } else {
            //
            // We failed while installing the class so don't bother installing
            // the device.
            //
            SetupDebugPrint3( L"SETUP: SetupCommitFileQueue(%s) failed while installing Class. Error = %d, Device = %ls", DriverInfoDetailData.InfFileName, Error, pDeviceDescription );
            goto enum_dev_thread_exit;
        }

    } else {

        //
        // The class already exists.
        //
        RegCloseKey(hClassKey);
    }

    //
    // Verify with the class installer and class-specific co-installers that the
    // driver we're about to install isn't blacklisted.
    //
    if( !SetupDiCallClassInstaller(DIF_ALLOW_INSTALL,
                                   hDevInfo,
                                   pDeviceInfoData ) ) {
        Error = GetLastError();
        if( Error != ERROR_DI_DO_DEFAULT ) {
            SetupDebugPrint2( L"SETUP: SetupDiCallClassInstaller(DIF_ALLOW_INSTALL) failed. Error = %d, Device = %ls", Error, pDeviceDescription );
            goto enum_dev_thread_exit;
        }
    }
    SetupDebugPrint1( L"SETUP:            SetupDiCallClassInstaller(DIF_ALLOW_INSTALL) succeeded. Device = %ls", pDeviceDescription );

    //
    // Everything checks out.  We're ready to pre-copy the driver files for this device.
    //
    pDeviceInstallParams->cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if(!SetupDiGetDeviceInstallParams(hDevInfo, pDeviceInfoData, pDeviceInstallParams)) {
        Error = GetLastError();
        SetupDebugPrint2( L"SETUP: SetupDiGetDeviceInstallParams() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
        goto enum_dev_thread_exit;
    }

    pDeviceInstallParams->Flags |= DI_FORCECOPY;

    SavedFileQ = pDeviceInstallParams->FileQueue;
    SavedFlags = pDeviceInstallParams->Flags;

    pDeviceInstallParams->FileQueue = FileQ;
    pDeviceInstallParams->Flags |= DI_NOVCP;

    //
    // If the old, or existing, driver is an 3rd party driver and not the same
    // as the current driver we are about to install, then back up the existing
    // drivers.
    //
    if (pDoesExistingDriverNeedBackup(hDevInfo, pDeviceInfoData, InfPath, sizeof(InfPath)/sizeof(WCHAR))) {
        SetupDebugPrint1( L"SETUP:            Backing up 3rd party drivers for Device = %ls", pDeviceDescription );
        pDeviceInstallParams->FlagsEx |= DI_FLAGSEX_PREINSTALLBACKUP;
    }

    //
    // Remember the parent HWND because we may need it later...
    //
    hwndParent = pDeviceInstallParams->hwndParent;

    if(!SetupDiSetDeviceInstallParams(hDevInfo, pDeviceInfoData, pDeviceInstallParams)) {
        Error = GetLastError();
        SetupDebugPrint2( L"SETUP: SetupDiSetDeviceInstallParams() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
        goto enum_dev_thread_exit;
    }

    //
    //  Install the device files
    //
    Error = ERROR_SUCCESS;
    if( !SetupDiCallClassInstaller( DIF_INSTALLDEVICEFILES,
                                    hDevInfo,
                                    pDeviceInfoData ) &&
        ( ( Error = GetLastError() ) != ERROR_DI_DO_DEFAULT )
      ) {

        SetupDebugPrint2( L"SETUP: SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES) failed. Error = %lx, Device = %ls ", Error, pDeviceDescription );
        goto enum_dev_thread_exit;

    }
    SetupDebugPrint1( L"SETUP:            SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES) succeeded. Device = %ls", pDeviceDescription );

    //
    // Commit the file queue.
    //
    QContext = InitSysSetupQueueCallbackEx(
        NULL,
        INVALID_HANDLE_VALUE,
        0,0,NULL);

    //
    // "Pre-verify" the catalog nodes in the file queue.  If an OEM INF in
    // %windir%\Inf is unsigned, we scan the queue to see if all required files
    // are present (although not validated) in their target locations.  If
    // we're doing an upgrade, and all files are in-place, we'll forego queue
    // committal.  If we're doing a fresh install, we'll still commit the
    // queue, even if all files were present.  This will result in a driver
    // signing popup (based on policy).  We do this to prevent subversion of
    // driver signing due to someone "sneaking" all the files into place prior
    // to GUI setup.
    //
    if(NO_ERROR != pSetupVerifyQueuedCatalogs(FileQ)) {
        //
        // We only want to prune based on presence check for OEM INFs living in
        // %windir%\Inf.
        //
        SP_DRVINFO_DETAIL_DATA      DriverInfoDetailData;

        //
        // Retrieve the name of the INF associated with the selected driver
        // node.
        //
        pDriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
        if (!SetupDiGetSelectedDriver(hDevInfo, pDeviceInfoData, &pDriverInfoData)) {
            Error = GetLastError();
            SetupDebugPrint2( L"SETUP: SetupDiGetSelectedDriver() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
            goto enum_dev_thread_exit;
        }

        DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
        if (!SetupDiGetDriverInfoDetail(hDevInfo,
                                        pDeviceInfoData,
                                        &pDriverInfoData,
                                        &DriverInfoDetailData,
                                        sizeof(DriverInfoDetailData),
                                        NULL) &&
            ((Error = GetLastError()) != ERROR_INSUFFICIENT_BUFFER)) {

            SetupDebugPrint2( L"SETUP: SetupDiGetDriverInfoDetail() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
            goto enum_dev_thread_exit;
        }

        //
        // There is only one case where we want to skip commiting the file queue
        // for an unsigned drivers, and all of the following must be true:
        //
        //  - This is an upgrade.
        //  - The INF lives under %windir%\INF
        //  - The INF is NOT an in-box INF
        //  - The INF has the same name as the previous INF (if there was
        //    a previous INF)
        //  - No file copy operations (copy, delete, rename) need to be done.
        //
        if(Upgrade &&
           !pSetupInfIsFromOemLocation(DriverInfoDetailData.InfFileName, TRUE) &&
           !IsInfInLayoutInf(DriverInfoDetailData.InfFileName) &&
           ((InfPath[0] == TEXT('\0')) ||
            (lstrcmpi(InfPath, pSetupGetFileTitle(DriverInfoDetailData.InfFileName)) == 0)) &&
           SetupScanFileQueue(FileQ,
                              SPQ_SCAN_FILE_PRESENCE |
                              SPQ_SCAN_PRUNE_DELREN,
                              hwndParent,
                              NULL,
                              NULL,
                              &ScanQueueResult) &&
           (ScanQueueResult == 1)) {

            fCommitFileQueue = FALSE;
        }

    } else {
        //
        // Prun the file queue.
        //
        SetupScanFileQueue(FileQ,
                           SPQ_SCAN_FILE_VALIDITY |
                           SPQ_SCAN_PRUNE_COPY_QUEUE |
                           SPQ_SCAN_PRUNE_DELREN,
                           NULL,
                           NULL,
                           NULL,
                           &ScanQueueResult);
    }

    //
    // If this device is the computer itself (i.e., the HAL, kernel, and other
    // platform-specific files), then we shouldn't need to copy anything, since
    // all the right files were copied during textmode setup.  However, these
    // files will _not_ have been pruned from the file queue if they came from
    // HAL.INF because they're marked as COPYFLG_NOPRUNE in that INF.  This is
    // done so that doing an "update driver" from a UP HAL to an MP one works
    // properly.  (Pruning gets in the way here, since we consider the properly-
    // signed UP files on the system to be perfectly acceptable, thus don't
    // bother with copying over the MP versions.)
    //
    // In order to avoid re-copying the HAL, kernel, etc., we just always skip
    // this queue committal if the device is of class "Computer".
    //
    if(IsEqualGUID(&(pDeviceInfoData->ClassGuid), &GUID_DEVCLASS_COMPUTER)) {
        fCommitFileQueue = FALSE;
    }

    Error = ERROR_SUCCESS;

    if (fCommitFileQueue) {
        if (!SetupCommitFileQueue(
                    NULL,
                    FileQ,
                    SysSetupQueueCallback,
                    QContext
                    )) {
            Error = GetLastError();
        }
    }

    if (SetupGetFileQueueFlags(FileQ, &FileQueueFlags) &&
        (FileQueueFlags & SPQ_FLAG_FILES_MODIFIED)) {
        //
        // One of the driver files has changed for this device.  This means
        // a full restart of the device, and all other devices shareing
        // one of its drivers is in order.
        //
        fDriversChanged = TRUE;
    }

    TermSysSetupQueueCallback(QContext);

    if (Error != ERROR_SUCCESS) {
        SetupDebugPrint2( L"SETUP: SetupCommitFileQueue() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
        goto enum_dev_thread_exit;
    }

    //
    // If no driver files changed then we only need to restart this device.
    //
    if (!fDriversChanged) {
        pDeviceInstallParams->FlagsEx |= DI_FLAGSEX_RESTART_DEVICE_ONLY;
    }

    pDeviceInstallParams->FileQueue = SavedFileQ;
    pDeviceInstallParams->Flags = (SavedFlags | DI_NOFILECOPY) ;

    if(!SetupDiSetDeviceInstallParams(hDevInfo, pDeviceInfoData, pDeviceInstallParams)) {
        Error = GetLastError();
        SetupDebugPrint2( L"SETUP: SetupDiSetDeviceInstallParams() failed. Error = %d, Device = %ls", Error, pDeviceDescription );
        goto enum_dev_thread_exit;
    }

    //
    //  Make sure that the files get flushed to disk
    //
    GetWindowsDirectory(RootPath,sizeof(RootPath)/sizeof(WCHAR));
    RootPath[3] = L'\0';
    FlushFilesToDisk( RootPath );

    //
    // Register any device-specific co-installers for this device.
    //
    if( !SetupDiCallClassInstaller(DIF_REGISTER_COINSTALLERS,
                                   hDevInfo,
                                   pDeviceInfoData ) ) {
        Error = GetLastError();
        SetupDebugPrint2( L"SETUP: SetupDiCallClassInstaller(DIF_REGISTER_COINSTALLERS) failed. Error = %d, Device = %ls", Error, pDeviceDescription );
        goto enum_dev_thread_exit;
    }
    SetupDebugPrint1( L"SETUP:            SetupDiCallClassInstaller(DIF_REGISTER_COINSTALLERS) succeeded. Device = %ls", pDeviceDescription );

    //
    // Install any INF/class installer-specified interfaces.
    //
    if( !SetupDiCallClassInstaller(DIF_INSTALLINTERFACES,
                                   hDevInfo,
                                   pDeviceInfoData) ) {
        Error = GetLastError();
        SetupDebugPrint2( L"SETUP: SetupDiCallClassInstaller(DIF_REGISTER_INSTALLINTERFACES) failed. Error = %d, Device = %ls", Error, pDeviceDescription );
        goto enum_dev_thread_exit;
    }
    SetupDebugPrint1( L"SETUP:            SetupDiCallClassInstaller(DIF_INSTALLINTERFACES) succeeded. Device = %ls", pDeviceDescription );


    //
    // Before we install this device, we need to find out if it is a new
    // device or a reinstall.  If the problem CM_PROB_NOT_CONFIGURED is set
    // then we will consider it as a new device and check if it has wizard
    // pages after DIF_INSTALLDEVICE
    //
    if ( CR_SUCCESS == CM_Get_DevInst_Status(&Status,
                                             &Problem,
                                             (DEVINST)pDeviceInfoData->DevInst,
                                             0 ) && (Problem & CM_PROB_NOT_CONFIGURED) )
    {
        fNewDevice = TRUE;
    }

    //
    //  Install the device
    //
    Error = ERROR_SUCCESS;
    if( !SetupDiCallClassInstaller( DIF_INSTALLDEVICE,
                                    hDevInfo,
                                    pDeviceInfoData ) &&
        ( ( Error = GetLastError() ) != ERROR_DI_DO_DEFAULT )
      ) {

        SetupDebugPrint2( L"SETUP: SetupDiCallClassInstaller(DIF_INSTALLDEVICE) failed. Error = %lx, Device = %ls ", Error, pDeviceDescription );
        goto enum_dev_thread_exit;

    } else {
        SetupDebugPrint1( L"SETUP:            SetupDiCallClassInstaller(DIF_INSTALLDEVICE) suceeded. Device = %ls ", pDeviceDescription );
    }

    //
    // If the device has wizard pages to show (in response to
    // DIF_NEWDEVICEWIZARD_FINISHINSTALL) then it needs to be marked as need
    // reinstall so that pages get a chance to be shown at a later time
    // note that we have to do this even for a re-install
    //
    if (!MarkDeviceAsNeedsReinstallIfNeeded( hDevInfo, pDeviceInfoData) ) {
        Error = GetLastError();
    }


enum_dev_thread_exit:
    if ( FileQ != (HSPFILEQ)INVALID_HANDLE_VALUE ) {
        if(SetupDiGetDeviceInstallParams(hDevInfo, pDeviceInfoData, pDeviceInstallParams)) {

            pDeviceInstallParams->FileQueue = INVALID_HANDLE_VALUE;
            pDeviceInstallParams->Flags &= ~DI_NOVCP;

            SetupDiSetDeviceInstallParams(hDevInfo, pDeviceInfoData, pDeviceInstallParams);
        }

        SetupCloseFileQueue( FileQ );
    }

    if (Error != ERROR_SUCCESS) {
        //
        // Device installed failed, so install the NULL driver on this device.
        //
        SetupDebugPrint( L"SETUP:            Installing the null driver for this device" );

        if( !SyssetupInstallNullDriver( hDevInfo, pDeviceInfoData ) ) {
            SetupDebugPrint( L"SETUP:            Unable to install null driver" );
        }
    }

    return( Error );
}


BOOL
MarkPnpDevicesAsNeedReinstall(
    )

/*++

Routine Description:

    This function marks all non-present Pnp devices as 'need reinstall'.

Arguments:

    None.

Return Value:

    Returns TRUE if the null if all devices were marked successfull.

--*/

{
    HDEVINFO        hDevInfo;
    SP_DEVINFO_DATA DeviceInfoData;
    ULONG           Index = 0;
    BOOL            b;
    DWORD           Error;


    SetupDebugPrint( L"SETUP: Entering MarkPnpDevicesAsNeedReinstall()." );

    Error = ERROR_SUCCESS;

    //
    //  Get a list of all devices
    //
    hDevInfo = SetupDiGetClassDevs( NULL,
                                    NULL,
                                    NULL,
                                    DIGCF_ALLCLASSES );

    if( hDevInfo == INVALID_HANDLE_VALUE ) {
        Error = GetLastError();
        if( ((LONG)Error) < 0 ) {
            //
            //  Setupapi error code, display it in hex
            //
            SetupDebugPrint1( L"SETUP: SetupDiGetClassDevs(DIGCF_ALLCLASSES) failed. Error = %lx", Error );
        } else {
            //
            //  win32 error code, display it in decimal
            //
            SetupDebugPrint1( L"SETUP: SetupDiGetClassDevs(DIGCF_ALLCLASSES) failed. Error = %d", Error );
        }
        SetupDebugPrint( L"SETUP: Leaving MarkPnpDevicesAsNeedReinstall(). No devices marked." );
        return( FALSE );
    }
    //
    // Assume success
    //
    b = TRUE;

    //
    // Now enumerate each device information element added to this set, and
    // mark it as 'need reinstall' if it isn't a live devnode.
    //
    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

    for( Index = 0;
         SetupDiEnumDeviceInfo( hDevInfo, Index, &DeviceInfoData );
         Index++ ) {

        DWORD   ConfigFlags;
        ULONG   Status, Problem;

        if(CR_SUCCESS == CM_Get_DevInst_Status(&Status,
                                               &Problem,
                                               (DEVINST)DeviceInfoData.DevInst,
                                               0))
        {
            //
            // Since we were able to retrieve the devnode's status, we know that
            // it is a live devnode (not necessarily started, but at least
            // present in the hardware tree).  Thus, we don't want to mark it
            // as needing reinstall--it'll automatically get reinstalled as part
            // of our installation of all present devices (i.e., that we get
            // from the UMPNPMGR named pipe).
            //
            continue;
        }

        //
        // Get the config flags for the device and set the reinstall bit
        //
        if ( !( b = GetDeviceConfigFlags(hDevInfo, &DeviceInfoData, &ConfigFlags ) ) )
        {
            SetupDebugPrint1( L"SETUP:   GetDeviceConfigFlags failed. Index = %d", Index );
            continue;
        }

        ConfigFlags |= CONFIGFLAG_REINSTALL;

        if ( !( b = SetDeviceConfigFlags(hDevInfo, &DeviceInfoData, ConfigFlags ) ) ) {

            SetupDebugPrint1( L"SETUP:   SetDeviceConfigFlags failed. Index = %d", Index );
            continue;
        }
    }

    //
    // Find out why SetupDiEnumDeviceInfo() failed.
    //
    Error = GetLastError();
    if( Error != ERROR_NO_MORE_ITEMS ) {
        SetupDebugPrint2( L"SETUP: Device = %d, SetupDiEnumDeviceInfo() failed. Error = %d", Index, Error );
        b = FALSE;
    }
    SetupDebugPrint1( L"SETUP: Leaving MarkPnpDevicesAsNeedReinstall(). Devices marked = %d", Index );

    SetupDiDestroyDeviceInfoList( hDevInfo );
    return( b );
}

//
// devices installs may exist in RunOnce entries
// they are processed as a batch, as opposed to per-device
// during syssetup
//
BOOL
CallRunOnceAndWait(
    )

/*++

Routine Description:

    This function calls RunOnce and waits for a "reasonable" amount of time for it to complete
    if we don't return within a reasonable amount of time, we leave RunOnce going
    and continue with rest of install process
    if we underestimate timeout, we can cause a whole series of "class installer appears to have hung" messages

Arguments:

    None.

Return Value:

    Returns TRUE if we completed successfully
    FALSE should not be considered a fatal error, and can be ignored

--*/
{
    static CONST TCHAR pszPathRunOnce[] = REGSTR_PATH_RUNONCE;
    BOOL Success = FALSE;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    BOOL started;
    TCHAR cmdline[MAX_PATH];
    HKEY  hKey = NULL;
    LONG l;
    DWORD nValues = 0;
    DWORD timeout;

    SetupDebugPrint( L"SETUP: Entering CallRunOnceAndWait. ");

    try {
        //
        // First, open the key "HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce"
        // to see if we have anything to do
        //
        if((l = RegOpenKeyEx(HKEY_LOCAL_MACHINE,pszPathRunOnce,0,KEY_QUERY_VALUE,&hKey)) != ERROR_SUCCESS) {
            //
            // not considered an error
            //
            SetupDebugPrint( L"SETUP: CallRunOnceAndWait: could not open RunOnce registry, assuming no entries. ");
            Success = TRUE;
            leave;
        }

        //
        // we want to know how many items we'll be executing in RunOnce to estimate a timeout
        //
        l = RegQueryInfoKey(hKey,NULL,NULL,NULL,
                                    NULL, NULL, NULL,
                                    &nValues,
                                    NULL, NULL, NULL, NULL);
        if ( l != ERROR_SUCCESS ) {
            SetupDebugPrint( L"SETUP: CallRunOnceAndWait: could not get number of entries, assuming no entries. ");
            nValues = 0;
        }

        RegCloseKey(hKey);

        //
        // estimating timeout is a black art
        // we can try and guess for any entries in the HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce key
        // but we're in the dark if any new keys are added
        // we add '5' items to the timeout to "account" for this uncertainty. We also always run RunOnce
        //

        if (nValues == 0) {
            SetupDebugPrint( L"SETUP: CallRunOnceAndWait: calling RunOnce (no detected entries). ");
            nValues = 5;
        } else {
            SetupDebugPrint1( L"SETUP: CallRunOnceAndWait: calling RunOnce (%u known entries). ", nValues);
            nValues += 5;
        }
        if (nValues < RUNONCE_THRESHOLD) {
            timeout =  nValues * RUNONCE_TIMEOUT;
        } else {
            timeout =  RUNONCE_THRESHOLD * RUNONCE_TIMEOUT;
        }

        ZeroMemory(&StartupInfo,sizeof(StartupInfo));
        ZeroMemory(&ProcessInformation,sizeof(ProcessInformation));

        StartupInfo.cb = sizeof(StartupInfo);
        lstrcpy(cmdline,TEXT("runonce -r"));

        started = CreateProcess(NULL,       // use application name below
                      cmdline,              // command to execute
                      NULL,                 // default process security
                      NULL,                 // default thread security
                      FALSE,                // don't inherit handles
                      0,                    // default flags
                      NULL,                 // inherit environment
                      NULL,                 // inherit current directory
                      &StartupInfo,
                      &ProcessInformation);

        if(started) {

            DWORD WaitProcStatus;

            do {

                WaitProcStatus = WaitForSingleObjectEx(ProcessInformation.hProcess, timeout , TRUE);

            } while (WaitProcStatus == WAIT_IO_COMPLETION);

            if (WaitProcStatus == WAIT_TIMEOUT) {
                //
                // RunOnce is still running
                //
                SetupDebugPrint( L"SETUP: CallRunOnceAndWait: RunOnce may have hung and has been abandoned. ");

            } else if (WaitProcStatus == (DWORD)(-1)) {
                //
                // huh?
                //
                DWORD WaitProcError = GetLastError();
                SetupDebugPrint1( L"SETUP: CallRunOnceAndWait: WaitForSingleObjectEx failed. Error = %lx ", WaitProcError );

            } else {
                //
                // we ran, we waited, we returned
                //
                Success = TRUE;
            }

            CloseHandle(ProcessInformation.hThread);
            CloseHandle(ProcessInformation.hProcess);

        } else {

            DWORD CreateProcError;

            //
            // The runonce task should get picked up later by someone else (e.g., at next
            // login).
            //
            CreateProcError = GetLastError();

            SetupDebugPrint1( L"SETUP: CallRunOnceAndWait: start RunOnce failed. Error = %lx ", CreateProcError );
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetupDebugPrint( L"SETUP: CallRunOnceAndWait: Exception! ");
        Success = FALSE;
    }

    SetupDebugPrint( L"SETUP: Leaving CallRunOnceAndWait. ");

    return Success;
}

//
// obsolete function from devmgr.c. keep the export in place for backwards compatibility
//
BOOL
DevInstallW(
    HDEVINFO            hDevInfo,
    PSP_DEVINFO_DATA    pDeviceInfoData
    )
{
    UNREFERENCED_PARAMETER(hDevInfo);
    UNREFERENCED_PARAMETER(pDeviceInfoData);

    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


ULONG
SyssetupGetPnPFlags(
    IN HDEVINFO hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    IN PSP_DRVINFO_DATA pDriverInfoData
    )
{
    DWORD Err;
    BOOL b;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    HINF hInf;
    WCHAR InfSectionWithExt[255];   // MAX_SECT_NAME_LEN from setupapi\inf.h
    INFCONTEXT InfContext;
    ULONG ret = 0;

    //
    // First retrieve the name of the INF for this driver node.
    //
    DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

    if(!SetupDiGetDriverInfoDetail(hDevInfo,
                                   pDeviceInfoData,
                                   pDriverInfoData,
                                   &DriverInfoDetailData,
                                   sizeof(DriverInfoDetailData),
                                   NULL)) {
        //
        // If we failed with ERROR_INSUFFICIENT_BUFFER, that's OK.  We're
        // guaranteed to have gotten all the static fields in the driver info
        // detail structure filled in (including the INF name and section
        // name fields).
        //
        Err = GetLastError();
        MYASSERT(Err == ERROR_INSUFFICIENT_BUFFER);
        if(Err != ERROR_INSUFFICIENT_BUFFER) {
            return ret;
        }
    }

    //
    // Now open up the INF associated with this driver node.
    //
    hInf = SetupOpenInfFile(DriverInfoDetailData.InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL
                           );

    if(hInf == INVALID_HANDLE_VALUE) {
        //
        // This will fail, for example, if the INF is an old-style INF.
        //
        return ret;
    }

    //
    // Get the potentially decorated install section name.
    //
    b = SetupDiGetActualSectionToInstall(hInf,
                                         DriverInfoDetailData.SectionName,
                                         InfSectionWithExt,
                                         SIZECHARS(InfSectionWithExt),
                                         NULL,
                                         NULL
                                        );
    MYASSERT(b);
    if(!b) {
        goto clean0;
    }

    //
    // Now look to see if there's a "SyssetupPnPFlags" entry in that section.
    //
    if(!SetupFindFirstLine(hInf,
                           InfSectionWithExt,
                           szSyssetupPnPFlags,
                           &InfContext)) {
        //
        // We didn't find such a line in this section.
        //
        goto clean0;
    }

    if(!SetupGetIntField(&InfContext, 1, (PINT)&ret)) {
        //
        // We failed--ensure return value is still zero.
        //
        ret = 0;
        goto clean0;
    }

clean0:

    SetupCloseInfFile(hInf);

    return ret;
}

//
// this function will tell umpnpmgr to stop server-side installs
//
VOID
PnpStopServerSideInstall(
    VOID
    )
/*++

Routine Description:

    After phase-2, server-side installs kick in to pick up software-enumerated drivers
    Call this when it's critical that we need to stop installing

Arguments:

    None.

Return Value:

    None.
    Returns when it is safe to proceed.

--*/
{
    //
    // since when we're called there should be nobody generating new devnodes, we're pretty safe
    //
    CMP_WaitNoPendingInstallEvents(INFINITE);
}

//
// this function will update HAL+kernel from NewInf
//
VOID
PnpUpdateHAL(
    VOID
    )
/*++

Routine Description:

    At very end of MiniSetup, OEM may indicate (via Unattend) that a different HAL should be installed
    This must be done very last due to that way that HAL's need to be installed, if we do this earlier
    then an app or service may pick the wrong HAL/Kernel32/other

Arguments:

    None

Return Value:

    None.
    There is nothing meaningful that can be done if this fails

--*/
{
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA DevInfoData;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    SP_DRVINFO_DATA DrvInfoData;
    WCHAR HardwareID[MAX_PATH+2];
    WCHAR InfPath[MAX_PATH];
    WCHAR Answer[MAX_PATH];
    WCHAR AnswerFile[2*MAX_PATH];
    DWORD HardwareIdSize;
    DWORD dwLen;
    DWORD Error;
    ULONG flags = 0;
    HINSTANCE hInstNewDev = NULL;
    ExternalUpdateDriverForPlugAndPlayDevicesW pUpdateDriverForPlugAndPlayDevicesW = NULL;
    PWSTR pSrch = NULL;
    PWSTR pHwID = NULL;
    PWSTR pInfPath = NULL;
    BOOL RebootFlag = FALSE;
    SYSTEM_INFO info;

    GetSystemDirectory(AnswerFile,MAX_PATH);
    pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);

    //
    // If we determine we are only running on one processor (based on System Info)
    // allow use of UpdateUPHAL
    //
    GetSystemInfo(&info);

    Answer[0]=L'\0';
    if(info.dwNumberOfProcessors==1) {
        if( GetPrivateProfileString( WINNT_UNATTENDED,
                                     WINNT_U_UPDATEUPHAL,
                                     pwNull,
                                     Answer,
                                     MAX_PATH,
                                     AnswerFile )) {
            SetupDebugPrint1( L"SETUP:   UpdateUPHAL=\"%ls\"",Answer);
        }
    }

    if(!Answer[0]) {
        //
        // we didn't explicitly get an answer based on being UP - try catch-all
        //
        if( GetPrivateProfileString( WINNT_UNATTENDED,
                                     WINNT_U_UPDATEHAL,
                                     pwNull,
                                     Answer,
                                     MAX_PATH,
                                     AnswerFile )) {
            SetupDebugPrint1( L"SETUP:   UpdateHAL=\"%ls\"",Answer);
        }
    }
    if(!Answer[0]) {
        //
        // no update request
        //
        return;
    }

    //
    // split Answer into HardwareID & INF
    //
    pHwID = Answer;
    pSrch = wcschr(Answer,L',');
    if(pSrch == NULL) {
        SetupDebugPrint( L"SETUP:     Required Syntax: \"hwid,inffile\"");
        return;
    }
    pInfPath = pSrch+1;

    //
    // trim HardwareID & prepare as a MULTI-SZ
    //
    while(pHwID[0]==L' '||pHwID[0]==L'\t') {
        pHwID++;
    }
    while(pSrch != pHwID && (pSrch[-1]==L' '||pSrch[-1]==L'\t')) {
        pSrch--;
    }
    pSrch[0]=0;
    if(!pHwID[0]) {
        SetupDebugPrint( L"SETUP:     Required Syntax: \"hwid,inffile\"");
        return;
    }
    lstrcpy(HardwareID,pHwID);
    HardwareIdSize = wcslen(HardwareID)+1;
    HardwareID[HardwareIdSize++]=L'\0';

    //
    // now pre-process the INF, trim & allow %windir% expansion
    //
    while(pInfPath[0]==L' '||pInfPath[0]==L'\t') {
        pInfPath++;
    }
    pSrch = pInfPath+wcslen(pInfPath);
    while(pSrch != pInfPath && (pSrch[-1]==L' '||pSrch[-1]==L'\t')) {
        pSrch--;
    }
    pSrch[0]=0;
    if(!pInfPath[0]) {
        SetupDebugPrint( L"SETUP:     Required Syntax: \"hwid,inffile\"");
        return;
    }
    dwLen=ExpandEnvironmentStrings(pInfPath,InfPath,MAX_PATH);
    if(dwLen==0 || dwLen > MAX_PATH) {
        SetupDebugPrint1( L"SETUP:     Expansion of \"%ls\" failed",InfPath);
        return;
    }
    SetupDebugPrint2( L"SETUP:     Preparing to install new HAL %ls from %ls",HardwareID,InfPath);

    // we need "UpdateDriverForPlugAndPlayDevices"
    // make sure we can get this before changing hardware ID
    //
    hInstNewDev = LoadLibrary(L"newdev.dll");
    if(hInstNewDev == NULL) {
        SetupDebugPrint1( L"SETUP:     Failed to load newdev.dll. Error = %d", GetLastError() );
        goto clean0;
    }
    pUpdateDriverForPlugAndPlayDevicesW = (ExternalUpdateDriverForPlugAndPlayDevicesW)
                                            GetProcAddress(hInstNewDev,
                                                            "UpdateDriverForPlugAndPlayDevicesW");
    if(pUpdateDriverForPlugAndPlayDevicesW==NULL) {
        SetupDebugPrint1( L"SETUP:     Failed to get UpdateDriverForPlugAndPlayDevicesW. Error = %d", GetLastError() );
        goto clean0;
    }

    //
    // we enumerate the Computer class, GUID={4D36E966-E325-11CE-BFC1-08002BE10318}
    // and should find a single DevNode, which is the one we need to update
    // when we actually update, we consider this a safe thing to do
    // since it should not involve any Co-Installers
    //
    hDevInfo = SetupDiGetClassDevs(&GUID_DEVCLASS_COMPUTER,NULL,NULL,DIGCF_PRESENT|DIGCF_PROFILE);
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        SetupDebugPrint1( L"SETUP:     SetupDiGetClassDevs() failed. Error = %d", GetLastError() );
        goto clean0;
    }
    DevInfoData.cbSize = sizeof(DevInfoData);
    if(!SetupDiEnumDeviceInfo(hDevInfo,0,&DevInfoData)) {
        SetupDebugPrint1( L"SETUP:     SetupDiEnumDeviceInfo() failed. Error = %d", GetLastError() );
        SetupDiDestroyDeviceInfoList(hDevInfo);
        goto clean0;
    }

    //
    // change the harware ID
    //
    if(!SetupDiSetDeviceRegistryProperty(hDevInfo,
                                         &DevInfoData,
                                         SPDRP_HARDWAREID,
                                         (PBYTE)HardwareID,
                                         sizeof(HardwareID[0])*HardwareIdSize
                                         )) {
        SetupDebugPrint1( L"SETUP:     SetupDiSetDeviceRegistryProperty() failed. Error = %d", GetLastError() );
        SetupDiDestroyDeviceInfoList(hDevInfo);
        goto clean0;
    }
    SetupDiDestroyDeviceInfoList(hDevInfo);

    //
    // now effect an update
    //
    if(!pUpdateDriverForPlugAndPlayDevicesW(NULL,HardwareID,InfPath,INSTALLFLAG_FORCE,&RebootFlag)) {
        SetupDebugPrint1( L"SETUP:     UpdateDriverForPlugAndPlayDevices() failed. Error = %d", GetLastError() );
    } else {
        SetupDebugPrint( L"SETUP:     ... new HAL installed and will be active on reboot");
    }

clean0:

    if(hInstNewDev != NULL) {
        FreeLibrary(hInstNewDev);
    }
}

BOOL
InstallOEMInfs(
    VOID
    )
/*++

Routine Description:

    This routine will install any OEM supplied INFs (and their corresponding
    catalogs) that may have been supplied to the system during an earlier phase
    of setup.  For example, the OEM can currently supply an INF for unsupported
    hardware during the textmode phase of setup by pressing "F6".

    The list of OEM INFs to be installed is supplied to us via the answer
    file in the following format:

    [Data]
    OEMDrivers=<driver-section-1>,<driver-section-2>,...

    [driver-section-1]
    OemDriverPathName=<path> (path to the driver (may use environment variables)
    OemInfName=<inf name> name of the inf to be installed from the above
               directory (there can be one or more infs in this directory, so
               this is a comma separated list)
    OemDriverFlags=<flags>

    valid flags are:
    SETUP_OEM_LDR_DEVICE        0x00000001
     //indicates that the driver was supplied via the textmode "F6" mechanism

    This function is really just a wrapper for SetupCopyOEMInf, which does
    everything we need

Arguments:

    None.

Return Value:

    TRUE indicates that all answer file-supplied drivers were installed properly

--*/
{
    HINF hAnswerFile;
    BOOL RetVal;
    INFCONTEXT LineContext;
    DWORD FieldCount, InfNameCount;
    DWORD Field, InfCount;
    DWORD d;
    PCTSTR SectionName;
    INFCONTEXT FirstLineContext,InfLineContext;
    PCWSTR OemDriverPathName;
    PCWSTR OemInfName;
    DWORD  OemFlags;
    WCHAR FullInfPathBuffer[MAX_PATH];
    WCHAR FullInfPathBufferWithInf[MAX_PATH];

    RetVal = TRUE;

    hAnswerFile = pOpenAnswerFile();
    if (hAnswerFile == INVALID_HANDLE_VALUE) {
        //
        // if there is no answer file, then we can't continue.
        //
        RetVal = FALSE;
        goto e0;
    }

    if (!SetupFindFirstLine(hAnswerFile,WINNT_DATA,WINNT_OEMDRIVERS,&LineContext)) {
        //
        // we were successful in doing nothing
        //
        RetVal = TRUE;
        goto e1;
    }

    do {

        //
        // Each value on the line in the given section
        // is the name of another section.
        //
        FieldCount = SetupGetFieldCount(&LineContext);
        for(Field=1; Field<=FieldCount; Field++) {

            OemDriverPathName = NULL;
            OemInfName = NULL;
            OemFlags = 0;
            FullInfPathBuffer[0] = '\0';
            FullInfPathBufferWithInf[0] = '\0';

            if((SectionName = pSetupGetField(&LineContext,Field))
            && SetupFindFirstLine(hAnswerFile,SectionName,WINNT_OEMDRIVERS_PATHNAME,&FirstLineContext)) {
                //
                // the section points to a valid section, so process it.
                //
                OemDriverPathName = pSetupGetField(&FirstLineContext,1);

                if (SetupFindFirstLine(hAnswerFile,SectionName,WINNT_OEMDRIVERS_FLAGS,&FirstLineContext)) {
                    SetupGetIntField(&FirstLineContext,1,&OemFlags);
                }

                if (OemDriverPathName) {
                    ExpandEnvironmentStrings( OemDriverPathName,
                                              FullInfPathBuffer,
                                              sizeof(FullInfPathBuffer)/sizeof(WCHAR) );
                }

                if (SetupFindFirstLine(hAnswerFile,SectionName,WINNT_OEMDRIVERS_INFNAME,&InfLineContext)) {
                    InfNameCount = SetupGetFieldCount(&InfLineContext);
                    for (InfCount = 1; InfCount <= InfNameCount; InfCount++) {
                        OemInfName = pSetupGetField(&InfLineContext,InfCount);

                        if (OemDriverPathName && OemInfName) {

                            wcscpy( FullInfPathBufferWithInf, FullInfPathBuffer );
                            pSetupConcatenatePaths(
                                        FullInfPathBufferWithInf,
                                        OemInfName,
                                        sizeof(FullInfPathBufferWithInf)/sizeof(WCHAR),
                                        0 );

                            if (!SetupCopyOEMInf(
                                        FullInfPathBufferWithInf,
                                        FullInfPathBuffer,
                                        SPOST_PATH,
                                        (OemFlags & SETUP_OEM_LDR_DEVICE) ? SP_COPY_OEM_F6_INF : 0,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL)) {
                                RetVal = FALSE;
                            }

                            if (OemFlags & SETUP_OEM_LDR_DEVICE) {
                                //
                                // if this flag is set, we know that there is an
                                // additional oemXXX##.inf file in the system32
                                // directory which corresponds to the INF file we
                                // have already copied from this directory.  We need
                                // to seek out that file and remove it, since the INF
                                // file we have just copied is "better" than that file.
                                //
                                WIN32_FIND_DATA fd;
                                HANDLE hFind;
                                WCHAR OldInfBuffer[MAX_PATH];
                                PWSTR p;

                                ExpandEnvironmentStringsW(
                                            L"%SystemRoot%\\system32\\",
                                            OldInfBuffer,
                                            sizeof(OldInfBuffer)/sizeof(WCHAR));

                                p = wcsrchr( OldInfBuffer, L'\\' );
                                p += 1;

                                pSetupConcatenatePaths(
                                            OldInfBuffer,
                                            L"oem?????.inf",
                                            sizeof(OldInfBuffer)/sizeof(WCHAR),
                                            0 );


                                if ((hFind = FindFirstFile(OldInfBuffer, &fd)) != INVALID_HANDLE_VALUE) {
                                    do {
                                        wcscpy( p, fd.cFileName );

                                        if (DoFilesMatch( FullInfPathBufferWithInf, OldInfBuffer )) {
                                            SetFileAttributes(OldInfBuffer, FILE_ATTRIBUTE_NORMAL );
                                            DeleteFile( OldInfBuffer );
                                        }
                                    } while(FindNextFile( hFind, &fd ));

                                    FindClose( hFind );

                                }
                            }
                        } else {
                            RetVal = FALSE;
                        }
                    }
                }
            }
        }
    } while(SetupFindNextMatchLine(&LineContext,NULL,&LineContext));


e1:
    SetupCloseInfFile( hAnswerFile );
e0:
    return(RetVal);
}


#if defined(_X86_)

VOID
SfcExcludeMigratedDrivers (
    VOID
    )

/*++

Routine Description:

    Adds all OEM migrated boot drivers (via unsupdrv.inf) to the SFC exclusion list

Arguments:

    None

Return Value:

    None

--*/

{
    TCHAR unsupInfPath[MAX_PATH];
    TCHAR windir[MAX_PATH];
    HINF unsupdrvInf;
    INFCONTEXT ic;
    TCHAR driverId[MAX_PATH];
    TCHAR sectionFiles[MAX_PATH];
    INFCONTEXT ic2;
    TCHAR driverFilename[MAX_PATH];
    TCHAR driverSubDir[MAX_PATH];
    TCHAR driverPath[MAX_PATH];

    if (!FloppylessBootPath[0] ||
        !BuildPath (unsupInfPath, ARRAYSIZE(unsupInfPath), FloppylessBootPath, TEXT("$WIN_NT$.~BT")) ||
        !pSetupConcatenatePaths (unsupInfPath, TEXT("unsupdrv.inf"), ARRAYSIZE(unsupInfPath), NULL)) {
        return;
    }

    unsupdrvInf = SetupOpenInfFile (unsupInfPath, NULL, INF_STYLE_WIN4, NULL);
    if (unsupdrvInf == INVALID_HANDLE_VALUE) {
        return;
    }
    if (!GetWindowsDirectory (windir, ARRAYSIZE(windir))) {
        return;
    }

    if(SetupFindFirstLine (
            unsupdrvInf,
            TEXT("Devices"),
            NULL,
            &ic)) {
        do {
            if (!SetupGetStringField (&ic, 1, driverId, ARRAYSIZE(driverId), NULL)) {
                continue;
            }
            if (_sntprintf (sectionFiles, ARRAYSIZE(sectionFiles) - 1, TEXT("Files.%s"), driverId) < 0) {
                continue;
            }
            sectionFiles[ARRAYSIZE(sectionFiles) - 1] = 0;

            if(SetupFindFirstLine (
                    unsupdrvInf,
                    sectionFiles,
                    NULL,
                    &ic2)) {
                do {
                    if (!SetupGetStringField (&ic2, 1, driverFilename, ARRAYSIZE(driverFilename), NULL)) {
                        continue;
                    }
                    if (!SetupGetStringField (&ic2, 2, driverSubDir, ARRAYSIZE(driverSubDir), NULL)) {
                        continue;
                    }
                    if (_sntprintf (driverPath, ARRAYSIZE(driverPath) - 1, TEXT("%s\\%s\\%s"), windir, driverSubDir, driverFilename) < 0) {
                        continue;
                    }
                    driverPath[ARRAYSIZE(driverPath) - 1] = 0;
                    if (FileExists (driverPath, NULL)) {
                        MultiSzAppendString(&EnumPtrSfcIgnoreFiles, driverPath);
                    }
                } while (SetupFindNextLine(&ic2, &ic2));
            }

        } while (SetupFindNextLine(&ic, &ic));
    }

    SetupCloseInfFile (unsupdrvInf);
}

#endif


BOOL
IsInstalledInfFromOem(
    IN PCWSTR InfFileName
    )

/*++

Routine Description:

    Determine if an INF file is OEM-supplied (i.e., it's name is of the form
    "OEM<n>.INF").

Arguments:

    InfFileName - supplies name (may include path) of INF.  No checking is done
        to ensure INF lives in %windir%\Inf--this is caller's responsibility.

Return Value:

    If TRUE, this is an OEM INF.  If FALSE, it's an in-box INF (or possibly one
    that was illegally copied directly into %windir%\Inf).

--*/

{
    PCWSTR p = pSetupGetFileTitle(InfFileName);

    //
    // First check that the first 3 characters are OEM
    //
    if((*p != L'o') && (*p != L'O')) {
        return FALSE;
    }
    p++;
    if((*p != L'e') && (*p != L'E')) {
        return FALSE;
    }
    p++;
    if((*p != L'm') && (*p != L'M')) {
        return FALSE;
    }
    p++;

    //
    // Now make sure that all subsequent characters up to the dot (.) are
    // numeric.
    //
    while((*p != L'\0') && (*p != L'.')) {

        if((*p < L'0') || (*p > L'9')) {

            return FALSE;
        }

        p++;
    }

    //
    // Finally, verify that the last 4 characters are ".inf"
    //
    if(lstrcmpi(p, L".inf")) {

        return FALSE;
    }

    //
    // This is an OEM INF
    //
    return TRUE;
}

BOOL
IsInfInLayoutInf(
    IN PCWSTR InfFileName
    )

/*++

Routine Description:

    Determine if an INF file is shiped in-box with the operating system.
    This is acomplished by looking up the INF name in the [SourceDisksFiles]
    section of layout.inf

Arguments:

    InfFileName - supplies name (may include path) of INF.  No checking is done
        to ensure INF lives in %windir%\Inf--this is caller's responsibility.

Return Value:

    If TRUE, this is an in-box INF.  If FALSE, it's not an in-box INF, this
    could be an OEM<n>.INF or an inf illegaly copied into the INF directory.

--*/

{
    BOOL bInBoxInf = FALSE;
    HINF hInf = INVALID_HANDLE_VALUE;
    UINT SourceId;

    hInf = SetupOpenInfFile(TEXT("layout.inf"), NULL, INF_STYLE_WIN4, NULL);

    if (hInf != INVALID_HANDLE_VALUE) {

        if(SetupGetSourceFileLocation(hInf,
                                      NULL,
                                      pSetupGetFileTitle(InfFileName),
                                      &SourceId,
                                      NULL,
                                      0,
                                      NULL)) {
            bInBoxInf = TRUE;
        }

        SetupCloseInfFile(hInf);
    }

    return bInBoxInf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\unattend.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    Unattend.c

Description:

    This performs all of the automated installation GUI mode setup.
    See below for usage and modification information

Author:

    Stephane Plante (t-stepl) 4-Sep-1995

Revision History:

    15-Sep-1995 (t-stepl) rewritten in table format
    26-Feb-1996 (tedm)    massive cleanup

--*/

#include "setupp.h"
#include <pencrypt.h>
#pragma hdrstop


/*

Table-driven unattended engine
------------------------------

There are two interrelated tables.

The first table is concerned with fetching data from the parameters file
($winnt$.inf) and processing it into a format that can be accessed by the
second table. The second table is associated with the pages in the setup wizard,
and provides the unattend engine with the rules for filling in the contents
of the associated pages from the data contained in the first table.


Adding a new piece of data to the parameters file
-------------------------------------------------

In the header file there is an enumerated type called UNATTENDENTRIES.
Add an entry for your data to the end of this enum. Now add an entry to the
UNATTENDANSWER table.

Here's an explanation of an entry in the UNATTENDEDANSWER table:

{ UAE_PROGRAM,  <-This is the identifier for the data item that I want
                to fetch. It is used to index into the table array
  FALSE,        <-This is a runtime variable. Just keep it as false
  FALSE,        <-If this is true, then it is considered an error in the
                unattend script if this value is unspecified. If it is
                false, then it does not matter if the value is not
                present.
  FALSE,        <-Another runtime flag. Just keep it as false
  0,            <-This is the answer we have initially. Since it gets overwritten
                quickly, there is no reason why not to set it to 0
  pwGuiUnattended   <- This is the string which identifies the section we want
  pwProgram     <- This is the string which identifies the key we want
  pwNull        <- This identifies the default. Note: NULL means that there is
                no default and so it is a serious error if the key does not
                exist in the file. pwNull, on the other hand, means the
                empty string.
  UAT_STRING    <- What format we want the answer in. Can be as a string, boolean
                or ULONG
  NULL          <- No callback function exists, however if one did, then must
                in the form of: BOOL fnc( struct _UNATTENDANSWER *rec)
                Where the fnc returns TRUE if the answer contained in the
                record is correct, or FALSE if the answer contained in the
                record is incorrect. This callback is meant to allow the
                programmer the ability to check to see if his answer is correct.
                Note: there is no bound as to when this callback can be issued.
                As such, no code which depends on a certain state of the
                installation should be used. For the record, the first time
                that an answer is required is the time when all records are
                filled in in the theory that it is cheaper to do all of the
                disk access at once rather then doing it on a as required basis.


Adding/changing wizard pages
----------------------------

Each page contains a series of items which must be filled in by the user.
Since the user wants hands off operation, he is counting on us
to do that filling in. As such, we require information about what elements are
contained on each page. To do this, we define an array whose elements each
describe a single element on the page. Here is the example from the NameOrg
page:

UNATTENDITEM ItemNameOrg[] = {
    {   IDT_NAME,   <-This is the label that identifies the item to which we
                    will try to send messages to, using SetDlgItemText().
        0,          <-One of the reserved words which can be used for
                    information passing during a callback
        0,          <-The second such word
        NULL,       <-Callback function. When we are trying to do something
                    complicated for the item (like comparing two strings)
                    it is easier to hardcode it in C. The format for it is:
                    BOOL fnc(HWND hwnd,DWORD contextinfo,
                        struct _UNATTENDITEM *item), where contextinfo is
                    a pointer to the page that the item resides on. The
                    function returns TRUE if is succeeded and doesn't think
                    that the user should see the page. FALSE otherwise.
        &UnattendAnswerTable[UAE_FULLNAME]
                    ^- This is a pointer to the data table so that we know
                    how to fill the item. If a callback is specified, this
                    could be set to null. Note that reference is made using
                    the enum that had defined previously. This is why
                    keeping the answer data table in order is so critical.
    },
    { IDT_ORGANIZATION, 0, 0, FALSE, NULL, &UnattendAnswerTable[UAE_ORGNAME] }
};

After this table has been created (if required), then you are ready to add
an entry to the UnattendPageTable[]. In this case, order doesn't matter,
but it is general practice to keep the entries in the same order
as the pages. Here is the entry in the table for the NAMEORG page:
    {
        IDD_NAMEORG,    <- This is the page id. We search based on this key.
                        Simply use whatever resourcename you used for the
                        dialogs.dlg file
        FALSE,          <- Runtime flag. Set it as false
        FALSE,          <- Runtime flag. Set it as false
        FALSE,          <- If this flag is true, then if there is an error
                        that occured in the unattended process, then this
                        page will always be displayed for the user. Good
                        for the start and finish pages
        2,              <- The number of items in the array
        ItemNameOrg     <- The array of items
    },

Once this is done, then you can add:
    if (Unattended) {
        UnattendSetActiveDlg( hwnd, <pageid> );
    }
    break;

As the last thing in the code for the page's setactive.
This function does is that it sets the DWL_MSGRESULT based on wether or
not the user should see the page and returns that value also (TRUE -- user
should see the page, FALSE, he should not). Then you should add:

    case WM_SIMULATENEXT:
        PropSheet_PressButton(GetParent(hwnd),PSBTN_NEXT);

to the DlgProc for the page. This means that the code in PSN_WIZNEXT
case will be executed.

You can also use UnattendErrorDlg( hwnd, <pageid> ); in the PSN_WIZNEXT
case if you detect any errors. That will allow unattended operation to try
to clean itself up a bit before control returns to the user for the page.

Note however that as soon as the user hits the next or back button that
control returns to the unattended engine.
*/


//
// Initialization Callbacks
//
// These are used to verify that the entries in the answer file are valid.
//
BOOL
CheckServer(
    struct _UNATTENDANSWER *rec
    );

BOOL
CheckComputerName(
    struct _UNATTENDANSWER *rec
    );

BOOL
CheckAdminPassword(
    struct _UNATTENDANSWER *rec
    );

BOOL
CheckMode(
    struct _UNATTENDANSWER *rec
    );

//
// SetActive Callbacks
//
// When a wizard page receives a PSN_SETACTIVE notification, a callback is used
// to set the controls on that wizard page, based on the values in the answer
// file.
//
BOOL
SetPid(
    HWND hwnd,
    DWORD contextinfo,
    struct _UNATTENDITEM *item
    );

BOOL
SetSetupMode(
    HWND hwnd,
    DWORD contextinfo,
    struct _UNATTENDITEM *item
    );

BOOL
SetPentium(
    HWND hwnd,
    DWORD contextinfo,
    struct _UNATTENDITEM *item
    );

BOOL
SetLastPage(
    HWND hwnd,
    DWORD contextinfo,
    struct _UNATTENDITEM *item
    );

BOOL
SetStepsPage(
    HWND hwnd,
    DWORD contextinfo,
    struct _UNATTENDITEM *item
    );

//
// Do not change the order of these unless you know what you are doing.
// These entries must me in the same order as the UNATTENDENTRIES enum.
//

UNATTENDANSWER UnattendAnswerTable[] = {

   { UAE_PROGRAM, FALSE, FALSE, FALSE, 0,
       pwGuiUnattended, pwProgram, pwNull,
       UAT_STRING, NULL },

   { UAE_ARGUMENT, FALSE, FALSE, FALSE, 0,
       pwGuiUnattended, pwArgument, pwNull,
       UAT_STRING, NULL },

   { UAE_TIMEZONE, FALSE, TRUE, FALSE, 0,
       pwGuiUnattended, pwTimeZone, pwTime,
       UAT_STRING, NULL },

   { UAE_FULLNAME, FALSE, TRUE, FALSE, 0,
       pwUserData, pwFullName, NULL,
       UAT_STRING, NULL },

   { UAE_ORGNAME, FALSE, FALSE, FALSE, 0,
       pwUserData, pwOrgName, pwNull,
       UAT_STRING, NULL },

   { UAE_COMPNAME, FALSE, TRUE, FALSE, 0,
       pwUserData, pwCompName, NULL,
       UAT_STRING, CheckComputerName },

   { UAE_ADMINPASS, FALSE, TRUE, FALSE, 0,
       pwGuiUnattended, pwAdminPassword, NULL,
       UAT_STRING, CheckAdminPassword },

   { UAE_PRODID, FALSE, TRUE, FALSE, 0,
       pwUserData, pwProductKey, NULL,
       UAT_STRING, NULL },

   { UAE_MODE, FALSE, TRUE, FALSE, 0,
       pwUnattended, pwMode, pwExpress,
       UAT_STRING, CheckMode },

   { UAE_AUTOLOGON, FALSE, TRUE, FALSE, 0,
       pwGuiUnattended, pwAutoLogon, pwNull,
       UAT_STRING, NULL },

   { UAE_PROFILESDIR, FALSE, TRUE, FALSE, 0,
       pwGuiUnattended, pwProfilesDir, pwNull,
       UAT_STRING, NULL },

   { UAE_PROGRAMFILES, FALSE, FALSE, FALSE, 0,
       pwUnattended, pwProgramFilesDir, pwNull,
       UAT_STRING, NULL },

   { UAE_COMMONPROGRAMFILES, FALSE, FALSE, FALSE, 0,
       pwUnattended, pwCommonProgramFilesDir, pwNull,
       UAT_STRING, NULL },

   { UAE_PROGRAMFILES_X86, FALSE, FALSE, FALSE, 0,
       pwUnattended, pwProgramFilesX86Dir, pwNull,
       UAT_STRING, NULL },

   { UAE_COMMONPROGRAMFILES_X86, FALSE, FALSE, FALSE, 0,
       pwUnattended, pwCommonProgramFilesX86Dir, pwNull,
       UAT_STRING, NULL },


};

UNATTENDITEM ItemSetup[] = {
    { 0, IDC_TYPICAL, IDC_CUSTOM, SetSetupMode, &UnattendAnswerTable[UAE_MODE] }
};

UNATTENDITEM ItemNameOrg[] = {
    { IDT_NAME, 0, 0, NULL, &UnattendAnswerTable[UAE_FULLNAME] },
    { IDT_ORGANIZATION, 0, 0, NULL, &UnattendAnswerTable[UAE_ORGNAME] }
};

UNATTENDITEM ItemPidCd[] = {
    { IDT_EDIT_PID1, 0, 0, SetPid, &UnattendAnswerTable[UAE_PRODID] },
    { IDT_EDIT_PID2, 1, 0, SetPid, &UnattendAnswerTable[UAE_PRODID] },
    { IDT_EDIT_PID3, 2, 0, SetPid, &UnattendAnswerTable[UAE_PRODID] },
    { IDT_EDIT_PID4, 3, 0, SetPid, &UnattendAnswerTable[UAE_PRODID] },
    { IDT_EDIT_PID5, 4, 0, SetPid, &UnattendAnswerTable[UAE_PRODID] }
};

UNATTENDITEM ItemPidOem[] = {
    { IDT_EDIT_PID1, 0, 1, SetPid, &UnattendAnswerTable[UAE_PRODID] },
    { IDT_EDIT_PID2, 1, 1, SetPid, &UnattendAnswerTable[UAE_PRODID] },
    { IDT_EDIT_PID3, 2, 1, SetPid, &UnattendAnswerTable[UAE_PRODID] },
    { IDT_EDIT_PID4, 3, 1, SetPid, &UnattendAnswerTable[UAE_PRODID] },
    { IDT_EDIT_PID5, 4, 1, SetPid, &UnattendAnswerTable[UAE_PRODID] }
};

UNATTENDITEM ItemCompName[] = {
    { IDT_EDIT1, 0, 0, NULL, &UnattendAnswerTable[UAE_COMPNAME] },
    { IDT_EDIT2, 0, 0, NULL, &UnattendAnswerTable[UAE_ADMINPASS] },
    { IDT_EDIT3, 0, 0, NULL, &UnattendAnswerTable[UAE_ADMINPASS] }
};

#ifdef _X86_
UNATTENDITEM ItemPentium[] = {
    { 0, IDC_RADIO_1, IDC_RADIO_2, SetPentium, NULL }
};
#endif

UNATTENDITEM ItemStepsPage[] = {
    { 0, 0, 0, SetStepsPage, NULL }
};

UNATTENDITEM ItemLastPage[] = {
    { 0, 0, 0, SetLastPage, NULL }
};



UNATTENDPAGE UnattendPageTable[] = {
    { IDD_WELCOME, FALSE, FALSE, TRUE, 0, NULL },
    { IDD_PREPARING, FALSE, FALSE, FALSE, 0, NULL },
#ifdef PNP_DEBUG_UI
    { IDD_HARDWARE, FALSE, FALSE, TRUE, 0, NULL },
#endif // PNP_DEBUG_UI
    { IDD_WELCOMEBUTTONS, FALSE, FALSE, FALSE, 1, ItemSetup },
    { IDD_REGIONAL_SETTINGS, FALSE, FALSE, FALSE, 0, NULL },
    { IDD_NAMEORG, FALSE, FALSE, FALSE, 2, ItemNameOrg },
    { IDD_PID_CD, FALSE, FALSE, FALSE, 5, ItemPidCd },
    { IDD_PID_OEM, FALSE, FALSE, FALSE, 5, ItemPidOem },
    { IDD_COMPUTERNAME, FALSE, FALSE, FALSE, 3, ItemCompName },
#ifdef DOLOCALUSER
    { IDD_USERACCOUNT, FALSE, FALSE, FALSE, 0, NULL },
#endif
#ifdef _X86_
    { IDD_PENTIUM, FALSE, FALSE, FALSE, 1, ItemPentium },
#endif
    { IDD_OPTIONS, FALSE, FALSE, FALSE, 0, NULL },
    { IDD_STEPS1, FALSE, FALSE, TRUE, 1, ItemStepsPage },
    { IDD_LAST_WIZARD_PAGE, FALSE, FALSE, TRUE, 1, ItemLastPage }
};


UNATTENDWIZARD UnattendWizard = {
    FALSE, FALSE, TRUE,
    sizeof(UnattendPageTable)/sizeof(UnattendPageTable[0]),
    UnattendPageTable,
    sizeof(UnattendAnswerTable)/sizeof(UnattendAnswerTable[0]),
    UnattendAnswerTable
};

//
// Global Pointer to the Answer file
//
WCHAR AnswerFile[MAX_PATH] = TEXT("");


BOOL
GetAnswerFileSetting (
    IN      PCWSTR Section,
    IN      PCWSTR Key,
    OUT     PWSTR Buffer,
    IN      UINT BufferSize
    )

/*++

Routine Description:

  GetAnswerFileSetting uses the private profile APIs to obtain an answer file
  string from %systemroot%\system32\$winnt$.inf. It also performs %% removal,
  since $winnt$.inf is an INF, not an INI.

Arguments:

  Section - Specifies the section to retreive the value from (such as
            GuiUnattended)

  Key - Specifies the key within the section (such as TimeZone)

  Buffer - Receives the value

  BufferSize - Specifies the size, in WCHARs, of Buffer.

Return Value:

  TRUE if the setting was retrived, FALSE otherwise.

--*/

{
    PCWSTR src;
    PWSTR dest;
    WCHAR testBuf[3];

    MYASSERT (BufferSize > 2);

    if (!AnswerFile[0]) {
        GetSystemDirectory (AnswerFile, MAX_PATH);
        pSetupConcatenatePaths (AnswerFile, WINNT_GUI_FILE, MAX_PATH, NULL);

        SetEnvironmentVariable (L"UnattendFile", AnswerFile);
    }

    if (!GetPrivateProfileString (
            Section,
            Key,
            L"",
            Buffer,
            BufferSize,
            AnswerFile
            )) {
        //
        // String not present or is empty -- try again with a different
        // default. If the string is empty, we'll get back 0. If the key does
        // not exist, we'll get back 1.
        //

        MYASSERT (BufferSize == 0 || *Buffer == 0);

        return 0 == GetPrivateProfileString (
                        Section,
                        Key,
                        L"X",
                        testBuf,
                        3,
                        AnswerFile
                        );
    }

    //
    // We obtained the string. Now remove pairs of %.
    //

    if (BufferSize) {
        src = Buffer;
        dest = Buffer;

        while (*src) {
            if (src[0] == L'%' && src[1] == L'%') {
                src++;
            }

            *dest++ = *src++;
        }

        *dest = 0;
    }

    return TRUE;
}

BOOL
UnattendFindAnswer(
    IN OUT PUNATTENDANSWER ans
    )

/*++

Routine Description:

    Fills in the response from the unattend file to the key 'id' into
    the structure pointed to by 'ans'. If a non-null 'def' is specified
    and no answer exists in the file, 'def' is parsed as the answer.

Arguments:

    ans - pointer to the structure information for the answer

Return Value:

    TRUE - 'ans' structure has been filled in with an answer
    FALSE - otherwise

--*/

{
    WCHAR Buf[MAX_BUF];

    MYASSERT(AnswerFile[0]);

    if (!GetAnswerFileSetting (ans->Section, ans->Key, Buf, MAX_BUF)) {
        //
        // Setting does not exist. If there is a default, use it.
        //

        if (ans->DefaultAnswer) {
            lstrcpyn (Buf, ans->DefaultAnswer, MAX_BUF);
        } else {
            ans->Present = FALSE;
            return (!ans->Required);
        }
    }

    //
    // Assume empty string means the string does not exist. This is how the
    // original implementation worked.
    //

    if (*Buf == 0) {
        ans->Present = FALSE;
        return !ans->Required;
    }

    //
    // Found a value, or using the default
    //

    ans->Present = TRUE;

    //
    // Copy the data into the answer structure. This requires
    // switching on the type of data expected and converting it to
    // the required format. In the case of strings, it also means
    // allocating a pool of memory for the result
    //
    switch(ans->Type) {

    case UAT_STRING:
        //
        // We allocate some memory, so we must free it later
        //
        ans->Answer.String = pSetupDuplicateString(Buf);
        if(!ans->Answer.String) {
            pSetupOutOfMemory(GetActiveWindow());
            return(FALSE);
        }
        break;

    case UAT_LONGINT:
        //
        // Simply convert the number from string to long
        //
        ans->Answer.Num = _wtol(Buf);
        break;

    case UAT_BOOLEAN:
        //
        // check to see if the answer is yes
        //
        ans->Answer.Bool = ((Buf[0] == L'y') || (Buf[0] == L'Y'));
        break;

    default:
        break;
    }

    //
    // Execute any callbacks if present
    //
    if(ans->pfnCheckValid) {
        if(!ans->pfnCheckValid(ans)) {
            ans->Present = FALSE;
            ans->ParseErrors = TRUE;
            return(!ans->Required);
        }
    }

    //
    // Success.
    //
    return(TRUE);
}


VOID
UnattendInitialize(
    VOID
    )

/*++

Routine Description:

    Initialize unattended mode support by loading all answers
    from the unattend file.

Arguments:

    None.

Return Value:

    None.

--*/
{
    WCHAR   p[MAX_BUF];
    DWORD   Result;
    BOOL    Success = TRUE;
    UINT    i;


    //
    // If we haven't calculated the path to $winnt$.sif yet, do so now
    //
    if(!AnswerFile[0]) {
        GetSystemDirectory(AnswerFile,MAX_PATH);
        pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);

        SetEnvironmentVariable( L"UnattendFile", AnswerFile );
    }

    if( MiniSetup ) {
        WCHAR MyAnswerFile[MAX_PATH];

        //
        // First, see if there's a sysprep.inf on the a:\ drive.  If so, use it.
        //
        lstrcpy( MyAnswerFile, TEXT("a:\\sysprep.inf") );
        if( !FileExists( MyAnswerFile, NULL ) ) {

            //
            // Nope.  Check for a \sysprep\sysprep.inf.
            //

            Result = GetWindowsDirectory( MyAnswerFile, MAX_PATH );
            if( Result == 0) {
                MYASSERT(FALSE);
                return;
            }
            MyAnswerFile[3] = 0;
            pSetupConcatenatePaths( MyAnswerFile, TEXT("sysprep\\sysprep.inf"), MAX_PATH, NULL );
        }

        //
        // We've assumed that we're running unattended, but
        // network setup hates it when we pretend to be unattended, but
        // don't provide an answer file.  So if there is no answer file,
        // quit the facade.
        //
        Unattended = FileExists(MyAnswerFile, NULL);
        Preinstall = Unattended;

        //
        // Now either replace or delete the original unattend file.
        // We do this so that we don't erroneously pickup unattend
        // entries out of the old answer file.  However, if OOBE is
        // running, we still need the old answerfile.
        //
        if( Unattended ) {
            CopyFile( MyAnswerFile, AnswerFile, FALSE );
        } else if ( !OobeSetup ) {
            DeleteFile( AnswerFile );
        }
    }

    //
    // We need to make the product id an alias for the product key.
    //
    if ( GetPrivateProfileString(
        pwUserData, pwProdId, pwNull, p, MAX_BUF, AnswerFile)
        ) {

        if ( !WritePrivateProfileString(
            pwUserData, pwProductKey, p, AnswerFile ) ) {

            SetupDebugPrint( L"SETUP: WritePrivateProfileString failed to write the product key in UnattendInitialize()." );
        }
    }

    //
    // Now get all the answers.
    //
    MYASSERT(!UnattendWizard.Initialized);
    UnattendWizard.Initialized = TRUE;
    for(i=0; i<UnattendWizard.AnswerCount; i++) {

        //
        // Check to make sure that the table order hasn't changed
        // and load the appropriate answer
        //
        MYASSERT((UINT)UnattendWizard.Answer[i].AnswerId == i);
        Success &= UnattendFindAnswer(&UnattendWizard.Answer[i]);
    }

    UnattendWizard.ShowWizard = !Success;
}


LRESULT
SendDlgMessage (
    HWND hdlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LRESULT OldResult;
    LRESULT Result;

    OldResult = GetWindowLongPtr (hdlg, DWLP_MSGRESULT);
    SendMessage (hdlg, Message, wParam, lParam);

    Result = GetWindowLongPtr (hdlg, DWLP_MSGRESULT);
    SetWindowLongPtr (hdlg, DWLP_MSGRESULT, OldResult);

    return Result;
}


BOOL
ReturnDlgResult (
    HWND hdlg,
    LRESULT Result
    )
{
    SetWindowLongPtr (hdlg, DWLP_MSGRESULT, Result);
    return TRUE;
}

VOID
UnattendAdvanceIfValid (
    IN HWND hwnd
    )
{
    LRESULT ValidationState;

    //
    // Validate wizard page data with UI
    //

    ValidationState = SendDlgMessage (hwnd, WMX_VALIDATE, 0, TRUE);

    if (ValidationState == VALIDATE_DATA_INVALID) {
        SetWindowLongPtr (hwnd, DWLP_MSGRESULT, WIZARD_NEXT_DISALLOWED);
    } else {
        SetWindowLongPtr (hwnd, DWLP_MSGRESULT, WIZARD_NEXT_OK);
    }
}


BOOL
UnattendSetActiveDlg(
    IN HWND  hwnd,
    IN DWORD controlid
    )

/*++


Routine Description:

    Initialize unattended mode support by loading all answers
    from the unattend file.

Arguments:

    None.

Return Value:

    TRUE - Page will become active
    FALSE - Page will not become active

--*/

{
    PUNATTENDPAGE pPage;
    PUNATTENDITEM pItem;
    BOOL success;
    UINT i,j;

    MYASSERT(UnattendWizard.Initialized);

    for(i=0; i<UnattendWizard.PageCount; i++) {

        if(controlid == UnattendWizard.Page[i].PageId) {
            //
            // Found Matching Page entry
            // Check to see if we have already loaded the page
            //
            pPage = & (UnattendWizard.Page[i]);
            if(!pPage->LoadPage) {
                //
                // Set the flags that load and display the page and
                // the flag that controls wether or not to stop on this page
                //
                pPage->LoadPage = TRUE;
                pPage->ShowPage = (UnattendMode == UAM_PROVIDEDEFAULT);

                for(j=0;j<pPage->ItemCount;j++) {

                    pItem = &(pPage->Item[j]);

                    if(pItem->pfnSetActive) {
                        //
                        // If the item has a call back function then
                        // execute that function, otherwise try to load
                        // the answer into the appropriate message box
                        //
                        success = pItem->pfnSetActive(hwnd,0,pItem);
                        pPage->ShowPage |= !success;

                    } else if (!pItem->Item->Present) {
                        //
                        // The answer for this item is missing.
                        //
                        pPage->ShowPage |= pItem->Item->Required;

                    } else {
                        //
                        // Switch to set the text of the item on the screen
                        //
                        switch(pItem->Item->Type) {

                        case UAT_STRING:
                            SetDlgItemText(hwnd,pItem->ControlId,pItem->Item->Answer.String);
                            break;

                        case UAT_LONGINT:
                        case UAT_BOOLEAN:
                        case UAT_NONE:
                        default:
                            break;

                        }

                        if( UnattendMode == UAM_PROVIDEDEFAULT ||
                            UnattendMode == UAM_DEFAULTHIDE) {

                            EnableWindow(GetDlgItem(hwnd,pItem->ControlId), TRUE);
                        } else {
                            EnableWindow(GetDlgItem(hwnd,pItem->ControlId),FALSE);
                        }
                    } // if (pItem
                } // for(j

                //
                // Allow the page to become activated
                //
                SetWindowLongPtr(hwnd,DWLP_MSGRESULT,0);

                if(!pPage->ShowPage) {
                    //
                    // Perform validation, skip activation if validation succeeds.
                    //

                    if (SendDlgMessage (hwnd, WMX_VALIDATE, 0, 0) == 1) {
                        SetWindowLongPtr(hwnd,DWLP_MSGRESULT,-1);
                        return FALSE;
                    }

                    //
                    // Simulate the pressing of the next button, which causes the
                    // wizard page proc to evaluate the data in its controls, and
                    // throw up popups to the user.
                    //
                    PostMessage(hwnd,WM_SIMULATENEXT,0,0);

                } else if (!pPage->NeverSkip) {
                    //
                    // Pages which are marked as NeverSkip should not
                    // cause the unattended status to be considered
                    // unsuccessful.
                    //
                    // We can't skip this page so mark the init as
                    // unsuccessful.  If this is the first error in a fully
                    // unattended setup, notify the user.
                    //
                    if(UnattendMode == UAM_FULLUNATTENDED) {

                        SetuplogError(
                            LogSevError,
                            SETUPLOG_USE_MESSAGEID,
                            MSG_LOG_BAD_UNATTEND_PARAM,
                            pItem->Item->Key,
                            pItem->Item->Section,
                            NULL,NULL);

                        if(UnattendWizard.Successful) {
                            MessageBoxFromMessage(
                                MainWindowHandle,
                                MSG_FULLUNATTENDED_ERROR,
                                NULL,
                                IDS_ERROR,
                                MB_ICONERROR | MB_OK | MB_SYSTEMMODAL
                                );
                        }
                    }
                    UnattendWizard.Successful = FALSE;
                }
                return(TRUE);

            } else {
                //
                // The Page has already been loaded, so we don't do that again
                // If we are ShowPage is FALSE, then we don't show the page to
                // the user, otherwise we do.
                //
                if(!pPage->ShowPage && !pPage->NeverSkip) {
                    SetWindowLongPtr(hwnd,DWLP_MSGRESULT,-1);
                } else {
                    SetWindowLongPtr(hwnd,DWLP_MSGRESULT,0);
                }

                return(pPage->ShowPage);
            }
        }
    }
    //
    // We didn't find a matching id, stop at the page that called us.
    //
    SetWindowLongPtr(hwnd,DWLP_MSGRESULT,0);
    return(TRUE);
}


BOOL
UnattendErrorDlg(
    IN HWND  hwnd,
    IN DWORD controlid
    )

/*++

Routine Description:

    Called when an error occurs in a DLG. Enables all windows
    in the dialog and turns off the successful flag for the
    unattend wizard

Arguments:

Return Value:

    Boolean value indicating outcome.

--*/

{
    PUNATTENDPAGE pPage;
    PUNATTENDITEM pItem;
    BOOL success;
    BOOL stop;
    UINT i,j;

    MYASSERT(UnattendWizard.Initialized);

    for(i=0; i<UnattendWizard.PageCount; i++) {

        if(controlid == UnattendWizard.Page[i].PageId) {
            //
            // Found Matching Page entry
            //
            pPage = &UnattendWizard.Page[i];

            if(!pPage->LoadPage) {
                //
                // The Page hasn't been loaded, so it isn't correct
                //
                continue;
            }

            //
            // Always display the page from now on
            //
            pPage->ShowPage = TRUE;

            //
            // Enable all the items
            //
            for (j=0;j<pPage->ItemCount;j++) {
                pItem = &(pPage->Item[j]);
                if(pItem->pfnSetActive) {
                    //
                    // if this is present then we assume that the
                    // callback handled itself properly already
                    //
                    continue;
                }
                EnableWindow( GetDlgItem(hwnd,pItem->ControlId), TRUE);
            }
        }
    }

    UnattendWizard.Successful = FALSE;
    return(TRUE);

}


PWSTR
UnattendFetchString(
   IN UNATTENDENTRIES entry
   )

/*++

Routine Description:

    Finds the string which corresponds to 'entry' in the answer
    table and returns a pointer to a copy of that string

Arguments:

    entry - which answer do you want?

Return Value:

    NULL - if any errors occur
    string - if a normal string

    Note: if the answer is an int or a bool or some other type,
    the behavior of this function is undefined (for now it will
    return NULL -- in the future it might make sense to turn these
    into strings...)

--*/

{
    MYASSERT(UnattendWizard.Initialized);

    //
    // Sanity check to make sure that the order of the answers is
    // what we expect.
    //
    MYASSERT(UnattendWizard.Answer[entry].AnswerId == entry);

    if(!UnattendWizard.Answer[entry].Present
    || (UnattendWizard.Answer[entry].Type != UAT_STRING)) {
        //
        // There is no string to return
        //
        return NULL;
    }

    return(pSetupDuplicateString(UnattendWizard.Answer[entry].Answer.String));
}


BOOL
CheckServer(
    struct _UNATTENDANSWER *rec
    )

/*++

Routine Description:

    Callback to check that the string used for the server type is valid

Arguments:

Return Value:

    TRUE - Answer is valid
    FALSE - Answer is invalid

--*/

{
    MYASSERT(rec);

    //
    // Check to make sure that we have a string
    //
    if(rec->Type != UAT_STRING) {
        return(FALSE);
    }

    //
    // Check to see if we have one of the valid strings
    //
    if(lstrcmpi(rec->Answer.String,WINNT_A_LANMANNT)
    && lstrcmpi(rec->Answer.String,WINNT_A_SERVERNT)) {

        //
        // We don't have a valid string, so we can clean up the answer
        //
        MyFree(rec->Answer.String);
        rec->Present = FALSE;
        rec->ParseErrors = TRUE;

        return(FALSE);
    }

    return(TRUE);

}


BOOL
CheckComputerName(
    struct _UNATTENDANSWER *rec
    )

/*+

Routine Description:

    Uppercase the computer name that comes out of the unattended file.

Arguments:

Returns:

    Always TRUE.

--*/

{
    if((rec->Type == UAT_STRING) && rec->Answer.String) {
        CharUpper(rec->Answer.String);
    }

    return(TRUE);
}


BOOL
CheckAdminPassword(
    struct _UNATTENDANSWER *rec
    )

/*+

Routine Description:

    Check for the "NoChange" keyword.

Arguments:

Returns:

    Always TRUE.

--*/

{
    //Ignore the check for 'No Change' in the encrypted password case.

    if( !IsEncryptedAdminPasswordPresent() ){


        if((rec->Type == UAT_STRING) && rec->Answer.String &&
            !lstrcmpi(rec->Answer.String, L"NoChange")) {

            DontChangeAdminPassword = TRUE;
            rec->Answer.String[0] = (WCHAR)'\0';
        }
    }




    return(TRUE);
}


BOOL
CheckMode(
    struct _UNATTENDANSWER *rec
    )

/*+

Routine Description:

    Callback to check that the string used for the setup type is valid

Arguments:

Returns:

    TRUE - Answer is valid
    FALSE - Answer is invalid

--*/

{
    MYASSERT(rec);

    //
    // Check to make sure that we have a string
    //
    if(rec->Type != UAT_STRING) {
        return(FALSE);
    }

    //
    // Check to see if the string is the custom or express one
    //
    if(lstrcmpi(rec->Answer.String,WINNT_A_CUSTOM)
    && lstrcmpi(rec->Answer.String,WINNT_A_EXPRESS)) {
        //
        // Free the old string and allocate a new one
        //
        MyFree(rec->Answer.String);
        rec->Answer.String = pSetupDuplicateString(WINNT_A_EXPRESS);
        rec->ParseErrors = TRUE;
    }

    return(TRUE);
}


BOOL
SetPid(
    HWND hwnd,
    DWORD contextinfo,
    struct _UNATTENDITEM *item
    )

/*++

Routine Description:

    Callback for both the OEM and CD dialog boxes that split the
    product string into the proper location boxes.

Arguments:

Returns:

    TRUE - success
    FALSE - failure

--*/

{
    WCHAR *ptr;
    UINT length;
    WCHAR Buf[MAX_BUF];
    WCHAR szPid[MAX_BUF];

    MYASSERT(item);
    MYASSERT(item->Item);

    //
    // Check to see if we found the pid and make sure that we have a string
    //
    if(!item->Item->Present || (item->Item->Type != UAT_STRING)) {
        return(FALSE);
    }

    //
    // oem and cd installs are both the same case for pid3.0
    //
    lstrcpyn(szPid, item->Item->Answer.String, MAX_BUF);
    szPid[MAX_BUF - 1] = L'\0';
    if ( ( lstrlen( szPid ) != (4 + MAX_PID30_EDIT*5) ) ||
        ( szPid[5]  != (WCHAR)L'-' ) ||
        ( szPid[11] != (WCHAR)L'-' ) ||
        ( szPid[17] != (WCHAR)L'-' ) ||
        ( szPid[23] != (WCHAR)L'-' )
      ) {
        MyFree(item->Item->Answer.String);
        item->Item->Present = FALSE;
        return(FALSE);
    }

    if (item->Reserved1 > 5) {
        MyFree(item->Item->Answer.String);
        item->Item->Present = FALSE;
        return(FALSE);
    }

    ptr = &szPid[item->Reserved1*(MAX_PID30_EDIT+1)];
    lstrcpyn(Pid30Text[item->Reserved1], ptr, MAX_PID30_EDIT+1 );
    Pid30Text[item->Reserved1][MAX_PID30_EDIT] = (WCHAR)L'\0';

    //
    // Copy the string to a buffer, set the dialog text and return success.
    //
    lstrcpyn(Buf,ptr,MAX_PID30_EDIT+1);
    SetDlgItemText(hwnd,item->ControlId,Buf);
    return(TRUE);
}


BOOL
SetSetupMode(
    HWND hwnd,
    DWORD contextinfo,
    struct _UNATTENDITEM *item
    )
{
    MYASSERT(item);
    MYASSERT(item->Item);

    //
    // Make sure that we have a string
    //
    if(item->Item->Type != UAT_STRING) {
        return(FALSE);
    }

    //
    // Did we get a parse error? if so display something that the user can
    // see so that the problem gets corrected in the future
    //
    if(item->Item->ParseErrors) {
        PostMessage(hwnd,WM_IAMVISIBLE,0,0);
    }

    SetupMode = lstrcmpi(item->Item->Answer.String,WINNT_A_CUSTOM)
              ? SETUPMODE_TYPICAL
              : SETUPMODE_CUSTOM;

    return(!item->Item->ParseErrors);
}


#ifdef _X86_
BOOL
SetPentium(
    HWND hwnd,
    DWORD contextinfo,
    struct _UNATTENDITEM *item
    )
{
    //
    // Do nothing. The dialog procedure takes care of all the logic.
    // See i386\fpu.c.
    //
    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(contextinfo);
    UNREFERENCED_PARAMETER(item);
    return(TRUE);
}
#endif


BOOL
SetStepsPage(
    HWND hwnd,
    DWORD contextinfo,
    struct _UNATTENDITEM *item
    )
{

    return(TRUE);
}


BOOL
SetLastPage(
    HWND hwnd,
    DWORD contextinfo,
    struct _UNATTENDITEM *item
    )
{

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\userdiff.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    userdiff.h

Abstract:

    Header file for userdiff.c

Author:

    Chuck Lenzmeier (chuckl)

Revision History:

--*/

//
// Names of hive keys and hive files.
//
// NOTE: USERRUN_PATH is also in gina\userenv\userdiff.h as USERDIFF_LOCATION
//

#define USERRUN_KEY TEXT("Userdifr")
#define USERRUN_PATH TEXT("system32\\config\\userdifr")
#define USERSHIP_KEY TEXT("Userdiff")
#define USERSHIP_PATH TEXT("system32\\config\\userdiff")
#define USERTMP_PATH TEXT("system32\\config\\userdift")

//
// Names of keys and vales in userdiff.
//
// NOTE: These are also in gina\userenv\userdiff.h and gina\userenv\userdiff.c
//

#define FILES_KEY TEXT("Files")
#define HIVE_KEY TEXT("Hive")
#define ACTION_VALUE TEXT("Action")
#define ITEM_VALUE TEXT("Item")
#define KEYNAME_VALUE TEXT("KeyName")
#define VALUENAME_VALUE TEXT("ValueName")
#define VALUENAMES_VALUE TEXT("ValueNames")
#define VALUE_VALUE TEXT("Value")
#define FLAGS_VALUE TEXT("Flags")

//
// Routine exported by userdiff.c
//

DWORD
MakeUserdifr (
    IN PVOID WatchHandle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\utils.cpp ===
#include "setupp.h"
#include <activation.h>
#include <LAModes.h>
#include <licdll.h>
#pragma hdrstop


extern "C"
BOOL Activationrequired(VOID)
{
    DWORD Status = ERROR_SUCCESS;
    HRESULT hr;
    DWORD WPADaysLeft = -1;
    DWORD EvalDaysLeftDontCare = 0;
    ICOMLicenseAgent*   pLicenseAgent;
    BOOL bActivcationRequired = TRUE;

    SetupDebugPrint( L"Setup: Activationrequired" );
    hr = CoInitialize(NULL);
    if (SUCCEEDED(hr))
    {
        //CoCreate LicenseAgent
        if(SUCCEEDED(hr = CoCreateInstance(__uuidof(COMLicenseAgent),
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   __uuidof(ICOMLicenseAgent),
                                   (LPVOID*)&pLicenseAgent)))
        {
            pLicenseAgent->Initialize(
                WINDOWSBPC,
                LA_MODE_ONLINE_CH,
                NULL,
                &Status
                );

            if ( Status == ERROR_SUCCESS ) {

                hr = pLicenseAgent->GetExpirationInfo(
                        &WPADaysLeft,
                        &EvalDaysLeftDontCare
                        );
                if (SUCCEEDED(hr))
                {
                    bActivcationRequired = (WPADaysLeft != INT_MAX);
                }
                else
                {
                    SetupDebugPrint2( L"Setup: LicenseAgent->GetExpirationInfo hr =0x%lx WPADaysLeft=%d", hr, WPADaysLeft);
                }
            }
            else
            {
                SetupDebugPrint1( L"Setup: LicenseAgent->Initialize status = %d", Status);
            }
            pLicenseAgent->Release();
            pLicenseAgent = NULL;
        }
        else
        {
            SetupDebugPrint1( L"Setup: CoCreateInstance failed. hr=0x%lx", hr );
        }
        CoUninitialize();
    }
    return bActivcationRequired;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\unattend.h ===
#ifndef _UNATTEND_H_
#define _UNATTEND_H_

#define MAX_BUF MAX_INF_STRING_LENGTH

typedef enum _UNATTENDTYPE {
   UAT_STRING,
   UAT_LONGINT,
   UAT_BOOLEAN,
   UAT_NONE,
} UNATTENDTYPE;

//
// Each possible Answer from the unattended file must have a
// corresponding enumerated type present in this typedef.
// This is required since it is the method by which Pages
// can be assured that they point to the correct answer
//
typedef enum _UNATTENDENTRIES {
   UAE_PROGRAM,                 // DetachedProgram
   UAE_ARGUMENT,                // Arguments
   UAE_TIMEZONE,                // TimeZone
   UAE_FULLNAME,                // FullName
   UAE_ORGNAME,                 // OrgName
   UAE_COMPNAME,                // Computer Name
   UAE_ADMINPASS,               // Administrator Password
   UAE_PRODID,                  // Product ID
   UAE_MODE,                    // SetupMode
   UAE_AUTOLOGON,               // autoadminlogon
   UAE_PROFILESDIR,             // Profiles directory
   UAE_PROGRAMFILES,            // Program Files directory
   UAE_COMMONPROGRAMFILES,      // Program Files\Common Files directory
   UAE_PROGRAMFILES_X86,        // Program Files (x86) directory
   UAE_COMMONPROGRAMFILES_X86,  // Program Files\Common Files (x86) directory
} UNATTENDENTRIES;

#ifndef MIDL_PASS
struct _UNATTENDANSWER;
struct _UNATTENDITEM;
struct _UNATTENDPAGE;
struct _UNATTENDWIZARD;
#endif

//
// This is the callback function that checks wether or not an
// answer is valid. Called automatically by UnattendFindAnswer
//
typedef
BOOL
(* LPFNCHECKVALID)(
    struct _UNATTENDANSWER *rec
    );


//
// This is the callback function that is used to special case
// the activation code. Really useful for those dialog boxes
// which include check boxes, radio buttons, etc, etc.
//
typedef
BOOL
(* LPFNSETACTIVE)(
    HWND hwnd,
    DWORD contextinfo,
    struct _UNATTENDITEM *item
    );

//
// This structure is used to determine where and how to find
// an answer and also to determine wether or not that answer
// is present, of the correct type, etc, etc. This structure
// should never be used by anything other then the unattend
// module.
//
typedef struct _UNATTENDANSWER {
    //
    // Unique identifier for this answer.
    //
    UNATTENDENTRIES AnswerId;

    //
    // Has the answer been found in the unattend file and
    // is it known to be of the correct 'format'
    //
    BOOL Present;

    //
    // Is the answer absolutely required for setup to work?
    //
    BOOL Required;

    //
    // Was there an error in parsing the string? If so it might
    // be appropriate to display a message box notifying the
    // user of this condition
    //
    BOOL ParseErrors;

    //
    // The Answer structure. Since there are several possible
    // types, from string to numbers, a union is required
    //
    union {
        PWSTR String;
        LONG  Num;
        BOOL  Bool;
    } Answer;

    //
    // The following 3 items are the implementation dependant
    // portion of this structure. Each pointer points to
    // a string which is used in a GetPrivateProfile call.
    // Note that it is important to keep these as constant
    // pointers and that they will have to be changed when
    // an OLE model is implemented.
    //
    const PCWSTR Section;
    const PCWSTR Key;
    const PCWSTR DefaultAnswer;

    //
    // This specifies which of the members in the union is
    // the one we want ie: is it a string, an int, or a bool?
    //
    UNATTENDTYPE Type;

    //
    // This callback function is called so that the validity
    // of the answer can be determined
    //
    LPFNCHECKVALID pfnCheckValid;

} UNATTENDANSWER, *PUNATTENDANSWER;


//
// Each item on a dialog page must be represented by the following
// structure. An array of items is built and is stored in the
// structure for the page
//
typedef struct _UNATTENDITEM {
    //
    // Specifies the control id of item so that we can send
    // messages to it
    //
    DWORD ControlId;

    //
    // Reserved for special message passing
    //
    DWORD Reserved1;

    //
    // Reserved for special message passing
    //
    DWORD Reserved2;

    //
    // Callback function to call when we are trying to set active
    // the dialog. Really useful in the case radio and check boxes.
    //
    LPFNSETACTIVE pfnSetActive;

    //
    // Pointer to the answer which is associated with this item
    //
    PUNATTENDANSWER Item;

} UNATTENDITEM, *PUNATTENDITEM;


//
// Each page in the wizard must have one of the following structures
// filled out to describe its contents
//
typedef struct _UNATTENDPAGE {
    //
    // The IDD of the dialog page
    // Required so that we can correspond to a dialog box
    //
    DWORD PageId;

    //
    // RUN TIME Flag that determines if we show the page to the user
    // Is determined by wether or not the answer is present and correct
    //
    BOOL ShowPage;

    //
    // Wether or not the page has been loaded once. Since we only
    // want to copy the answer to the screen once, this acts as a
    // sentry
    //
    BOOL LoadPage;

    //
    // After we have loaded the page, should we show it no matter what?
    // Useful for the title and finish pages
    //
    BOOL NeverSkip;

    //
    // How many items we have on the page
    //
    UINT ItemCount;

    //
    // Pointer to an array of items of size ItemCount
    //
    PUNATTENDITEM Item;

} UNATTENDPAGE, *PUNATTENDPAGE;


//
// Information structure about how the unattended operation for the Wizard
// is proceeding
//
typedef struct _UNATTENDWIZARD {
    //
    // Wether or not we should show the wizard -- IGNORED since TedM
    // doesn't want to duplicated the code in PSN_WIZNEXT. Kept for
    // Future use
    //
    BOOL ShowWizard;

    //
    // Flag that indicates that we have filled the array of answers
    // specified in this structure. Since we ideally once want to do
    // this once...
    //
    BOOL Initialized;

    //
    // Wether or not the ENTIRE unattended operation was successful.
    // If he required a single input from the user, then it was not.
    // Determines if the 'finish' page is a place were the user must
    // supply some input
    //
    BOOL Successful;

    //
    // How many pages we have information about
    //
    UINT PageCount;

    //
    // Pointer to an array of pages
    //
    PUNATTENDPAGE Page;

    //
    // How many answer we have to fill
    //
    UINT AnswerCount;

    //
    // Pointer to an array of answers that are to be used
    //
    PUNATTENDANSWER Answer;

} UNATTENDWIZARD, *PUNATTENDWIZARD;


//
// Global pointer to the answer file
//
extern WCHAR AnswerFile[MAX_PATH];


//
// Constants for the wizard notification messages
//

#define WIZARD_NEXT_OK          0
#define WIZARD_NEXT_DISALLOWED  -1
#define WIZARD_ACTIVATE_PAGE    0
#define WIZARD_SKIP_PAGE        -1

#define VALIDATE_DATA_INVALID   -1
#define VALIDATE_DATA_OK        1

//
// Interface Functions
//
VOID
UnattendInitialize(
    VOID
    );

BOOL
UnattendSetActiveDlg(
    IN HWND  hwnd,
    IN DWORD controlid
    );

// For PSN_WIZNEXT/PSN_WIZFINISH only
VOID
UnattendAdvanceIfValid (
    IN HWND  hwnd
    );

BOOL
UnattendErrorDlg(
    IN HWND  hwnd,
    IN DWORD controlid
    );

PWSTR
UnattendFetchString(
    IN UNATTENDENTRIES entry
    );

// Wrapper to simply return a value in DWL_MSGRESULT, return value is always TRUE
BOOL
ReturnDlgResult (
    HWND hdlg,
    LRESULT Result
    );

// Sends message, returns DWL_MSGRESULT, preservs original value in DWL_MSGRESULT
LRESULT
SendDlgMessage (
    HWND hdlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );



//
// Types and routines for afpnp.c
//

typedef struct {
    PVOID Buffer;
    UINT Size;
} BUFFER, *PBUFFER;

typedef struct {
    PWSTR Start;
    PWSTR End;
    UINT Size;
} MULTISZ, *PMULTISZ;

typedef struct {
    PCWSTR Start;
    PCWSTR Current;
} MULTISZ_ENUM, *PMULTISZ_ENUM;

#define BUFFER_INIT {NULL,0}
#define MULTISZ_INIT {NULL,NULL,0}

typedef struct _tagAFDRIVERATTRIBS {
    BOOL Broken;
    BOOL Initialized;
    HINF InfHandle;
    PCWSTR FilePath;
    PCWSTR InfPath;
    PCWSTR OriginalInstallMedia;
    MULTISZ PnpIdList;
    PCWSTR ClassInstall32Section;       // no cleanup needed
    GUID Guid;
    struct _tagAFDRIVERATTRIBS *Next;
} AF_DRIVER_ATTRIBS, *PAF_DRIVER_ATTRIBS;

typedef struct {
    PAF_DRIVER_ATTRIBS Driver;
    BOOL WantAll;
} AF_DRIVER_ENUM, *PAF_DRIVER_ENUM;

typedef struct {
    PVOID DriverTable;
    PAF_DRIVER_ATTRIBS FirstDriver;
} AF_DRIVERS, *PAF_DRIVERS;


// Alloc or realloc depending on presense of Old (like c runtime realloc)
PVOID
MySmartAlloc (
    PCVOID Old,     OPTIONAL
    UINT Size
    );

// Free if p is not NULL
VOID
MySmartFree (
    PCVOID p
    );

// Allocs only if SizeNeeded outgrew size previously allocated in Buf
PVOID
ReusableAlloc (
    IN OUT  PBUFFER Buf,
    IN      UINT SizeNeeded
    );

// Cleans up BUFFER structs
VOID
ReusableFree (
    IN OUT  PBUFFER Buf
    );

// Adds a string to a MULTISZ alloc, growing/reallocating if necessary
PWSTR
MultiSzAppendString (
    IN OUT  PMULTISZ MultiSz,
    IN      PCWSTR String
    );

// Cleans up MULTISZ structs
VOID
MultiSzFree (
    IN OUT  PMULTISZ MultiSz
    );

// Simplifies logic surrounding multisz processing
BOOL
EnumFirstMultiSz (
    IN OUT  PMULTISZ_ENUM EnumPtr,
    IN      PCWSTR MultiSz
    );

BOOL
EnumNextMultiSz (
    IN OUT  PMULTISZ_ENUM EnumPtr
    );

// Simplifies getting string fields in loops
PCWSTR
SyssetupGetStringField (
    IN      PINFCONTEXT InfContext,
    IN      DWORD Field,
    IN OUT  PBUFFER Buf
    );


// For progress bar UI computations
INT
CountAfDrivers (
    IN      PAF_DRIVERS Drivers,
    OUT     INT *ClassInstallers        OPTIONAL
    );

// Pulls in answer file data, parses into structs
PAF_DRIVERS
CreateAfDriverTable (
    VOID
    );

VOID
DestroyAfDriverTable (
    IN      PAF_DRIVERS Drivers
    );

// Enumeration of AF_DRIVERS
BOOL
EnumFirstAfDriver (
    OUT     PAF_DRIVER_ENUM EnumPtr,
    IN      PAF_DRIVERS Drivers
    );

BOOL
EnumFirstAfDriverEx (
    OUT     PAF_DRIVER_ENUM EnumPtr,
    IN      PAF_DRIVERS Drivers,
    IN      BOOL WantAll
    );

BOOL
EnumNextAfDriver (
    IN OUT  PAF_DRIVER_ENUM EnumPtr
    );

// Builds INF list of answer file-supplied drivers for a device
BOOL
SyssetupInstallAnswerFileDriver (
    IN      PAF_DRIVERS Drivers,
    IN      HDEVINFO hDevInfo,
    IN      PSP_DEVINFO_DATA DeviceInfoData,
    OUT     PAF_DRIVER_ATTRIBS *AfDriver
    );

// Fixes the source INF path after installation completes
BOOL
SyssetupFixAnswerFileDriverPath (
    IN      PAF_DRIVER_ATTRIBS Driver,
    IN      HDEVINFO hDevInfo,
    IN      PSP_DEVINFO_DATA DeviceInfoData
    );


HINF
pOpenAnswerFile (
    VOID
    );

BOOL
GetAnswerFileSetting (
    IN      PCWSTR Section,
    IN      PCWSTR Key,
    OUT     PWSTR Buffer,
    IN      UINT BufferSize
    );

#endif // _UNATTEND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\userdiff.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    userdiff.c

Abstract:

    This module contains routines for updating the userdifr hive.

    In the following, the list of changes to be applied when a user
    logs on after an upgrade will be called UserRun.  UserRun is
    developed from three sources:

    1) The UserRun generated on the last upgrade.  This forms the
       basis for this upgrade's UserRun.

    2) The list of changes shipped with the system.  Call this
       UserShip.  The changes from all build numbers that are
       present in UserShip but not in UserRun are copied into
       UserRun.  (Note that if a build number is already present
       in UserRun, we don't copy the UserShip changes.  This
       means that changes cannot be made retroactively in UserShip.)

    3) Changes made during the current upgrade.  These changes are
       detected at run time (see watch.c).  All changes detected
       during the upgrade are added to UserRun.

Author:

    Chuck Lenzmeier (chuckl)

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop


//
// Debugging aids.
//

#if USERDIFF_DEBUG

DWORD UserdiffDebugLevel = 0;
#define dprintf(_lvl_,_x_) if ((_lvl_) <= UserdiffDebugLevel) DbgPrint _x_

#else

#define dprintf(_lvl_,_x_)

#endif

//
// Macro to calculate length of string including terminator.
//

#define SZLEN(_wcs) ((wcslen(_wcs) + 1) * sizeof(WCHAR))

//
// Context record used in this module to track registry state.
//

typedef struct _USERRUN_CONTEXT {
    BOOL UserRunLoaded;
    HKEY UserRunKey;
    HKEY BuildKey;
    HKEY FilesKey;
    HKEY HiveKey;
    ULONG FilesIndex;
    ULONG HiveIndex;
    HKEY UserShipKey;
} USERRUN_CONTEXT, *PUSERRUN_CONTEXT;

//
// Context record used in MakeUserRunEnumRoutine.
//

typedef struct _KEY_ENUM_CONTEXT {
    PUSERRUN_CONTEXT UserRunContext;
    PWCH CurrentPath;
} KEY_ENUM_CONTEXT, *PKEY_ENUM_CONTEXT;


//
// Forward declaration of local subroutines.
//

DWORD
LoadUserRun (
    OUT PUSERRUN_CONTEXT Context,
    IN PWCH UserRunPath
    );

DWORD
MergeUserShipIntoUserRun (
    IN OUT PUSERRUN_CONTEXT Context,
    IN PWCH UserShipPath
    );

DWORD
CreateAndLoadUserRun (
    OUT PUSERRUN_CONTEXT Context,
    IN PWCH UserRunPath
    );

DWORD
OpenUserRunKeys (
    IN OUT PUSERRUN_CONTEXT Context
    );

VOID
UnloadUserRun (
    IN OUT PUSERRUN_CONTEXT Context
    );

DWORD
CheckUserShipKey (
    IN PVOID Context,
    IN DWORD KeyNameLength,
    IN PWCH KeyName
    );

DWORD
MakeUserRunEnumRoutine (
    IN PVOID Context,
    IN PWATCH_ENTRY Entry
    );

DWORD
MakeAddDirectory (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Name
    );

DWORD
MakeAddValue (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Name
    );

DWORD
MakeDeleteValue (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Name
    );

DWORD
MakeAddKey (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Name
    );

DWORD
MakeDeleteKey (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Name
    );

DWORD
AddDirectory (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH FullPath,
    IN PWCH Path
    );

DWORD
AddKey (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Path
    );

DWORD
AddValueDuringAddKey (
    IN PVOID Context,
    IN DWORD ValueNameLength,
    IN PWCH ValueName,
    IN DWORD ValueType,
    IN PVOID ValueData,
    IN DWORD ValueDataLength
    );

DWORD
AddKeyDuringAddKey (
    IN PVOID Context,
    IN DWORD KeyNameLength,
    IN PWCH KeyName
    );

DWORD
AddValue (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH KeyName OPTIONAL,
    IN PWCH ValueName,
    IN DWORD ValueType,
    IN PVOID ValueData,
    IN DWORD ValueDataLength
    );

DWORD
CreateUserRunSimpleFileKey (
    IN PUSERRUN_CONTEXT Context,
    IN DWORD Action,
    IN PWCH Name
    );

DWORD
CreateUserRunKey (
    IN PUSERRUN_CONTEXT Context,
    IN BOOL IsFileKey,
    OUT PHKEY NewKeyHandle
    );

DWORD
QueryValue (
    IN PWCH KeyName OPTIONAL,
    IN PWCH ValueName,
    OUT PDWORD ValueType,
    OUT PVOID *ValueData,
    OUT PDWORD ValueDataLength
    );

VOID
SzToMultiSz (
    IN PWCH Sz,
    OUT PWCH *MultiSz,
    OUT PDWORD MultiSzLength
    );


DWORD
MakeUserdifr (
    IN PVOID WatchHandle
    )

/*++

Routine Description:

    Creates the UserRun hive based on the changes made to the current user's
    profile directory and the HKEY_CURRENT_USER key.

Arguments:

    WatchHandle - supplies the handle returned by WatchStart.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    HKEY userrunKey;
    USERRUN_CONTEXT context;
    DWORD error;
    DWORD disposition;
    WCHAR userRunPath[MAX_PATH + 1];
    WCHAR userShipPath[MAX_PATH + 1];

    //
    // Merge UserShip with UserRun.
    //
    // If both UserRun and UserShip exist, merge into UserRun those build
    // keys from UserShip that do no exist in UserRun.
    //
    // If the UserRun hive file doesn't exist, this means that no
    // upgrade has ever been run on this machine.  Copy the UserShip
    // hive file into place as UserRun.  This effectively does the
    // registry merge by using a file copy.
    //
    // In the unlikely event that neither UserRun nor UserShip exists,
    // create an empty UserRun.
    //

    //
    // Initialize the context record.
    //

    context.UserRunLoaded = FALSE;
    context.UserRunKey = NULL;
    context.BuildKey = NULL;
    context.FilesKey = NULL;
    context.HiveKey = NULL;

    //
    // Enable SeBackupPrivilege and SeRestorePrivilege.
    //

    pSetupEnablePrivilege( SE_BACKUP_NAME, TRUE );
    pSetupEnablePrivilege( SE_RESTORE_NAME, TRUE );

    //
    // Check to see whether UserRun exists.
    //

    error = GetWindowsDirectory( userRunPath, MAX_PATH );
    if( error == 0) {
        MYASSERT(FALSE);
        return ERROR_PATH_NOT_FOUND;
    }
    wcscat( userRunPath, TEXT("\\") );
    wcscpy( userShipPath, userRunPath );
    wcscat( userRunPath, USERRUN_PATH );
    wcscat( userShipPath, USERSHIP_PATH );

    if ( FileExists( userRunPath, NULL ) ) {

        //
        // UserRun exists.  Load it into the registry.  Check to see whether
        // UserShip exists.
        //

        error = LoadUserRun( &context, userRunPath );
        if ( error == NO_ERROR ) {

            if ( FileExists( userShipPath, NULL ) ) {

                //
                // UserShip also exists.  Merge UserShip into UserRun.
                //

                error = MergeUserShipIntoUserRun( &context, userShipPath );

            } else {

                //
                // UserShip doesn't exist.  Just use the existing UserRun.
                //
            }
        }

    } else {

        //
        // UserRun doesn't exist.  If UserShip exists, just copy the UserShip
        // hive file into place as UserRun.  If neither one exists, create
        // an empty UserRun.
        //

        if ( FileExists( userShipPath, NULL ) ) {

            //
            // UserShip exists.  Copy UserShip into UserRun.
            //

            if ( !CopyFile( userShipPath, userRunPath, TRUE ) ) {
                error = GetLastError();

            } else {

                //
                // Load the new UserRun.
                //

                error = LoadUserRun( &context, userRunPath );
            }

        } else {

            //
            // UserShip doesn't exist.  Create an empty UserRun.
            //

            error = CreateAndLoadUserRun( &context, userRunPath );
        }
    }

    //
    // Add changes from this upgrade to UserRun.
    //

    if ( error == NO_ERROR ) {

        error = OpenUserRunKeys( &context );
        if ( error == NO_ERROR ) {
            error = WatchEnum( WatchHandle, &context, MakeUserRunEnumRoutine );
        }
    }

    //
    // Unload the UserRun hive.
    //

    UnloadUserRun( &context );

    return error;

} // MakeUserdifr


DWORD
LoadUserRun (
    OUT PUSERRUN_CONTEXT Context,
    IN PWCH UserRunPath
    )

/*++

Routine Description:

    Loads the UserRun hive into the registry and opens the root key.

Arguments:

    Context - pointer to context record.

    UserRunPath - supplies the path to the UserRun hive file.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    DWORD error;

    //
    // Load the UserRun hive into the registry.
    //

    error = RegLoadKey( HKEY_USERS, USERRUN_KEY, UserRunPath );
    if ( error != NO_ERROR ) {
        return error;
    }

    Context->UserRunLoaded = TRUE;

    //
    // Open the UserRun root.
    //

    error = RegOpenKeyEx( HKEY_USERS,
                          USERRUN_KEY,
                          0,
                          KEY_READ | KEY_WRITE,
                          &Context->UserRunKey );

    return error;

} // LoadUserRun


DWORD
MergeUserShipIntoUserRun (
    IN OUT PUSERRUN_CONTEXT Context,
    IN PWCH UserShipPath
    )

/*++

Routine Description:

    Merges the UserShip hive into the UserRun hive.

Arguments:

    Context - pointer to context record.

    UserShipPath - supplies the path to the UserShip file.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    DWORD error;
    DWORD disposition;

    //
    // Load the UserShip hive into the registry.
    //

    error = RegLoadKey( HKEY_USERS, USERSHIP_KEY, UserShipPath );
    if ( error == NO_ERROR ) {

        //
        // Open the UserShip root.
        //

        error = RegOpenKeyEx( HKEY_USERS,
                              USERSHIP_KEY,
                              0,
                              KEY_READ | KEY_WRITE,
                              &Context->UserShipKey );
        if ( error == NO_ERROR ) {

            //
            // Enumerate the build number keys in UserShip, looking for
            // builds that aren't represented in UserRun.
            //

            error = EnumerateKey( Context->UserShipKey,
                                  Context,
                                  NULL,     // don't enumerate values
                                  CheckUserShipKey );

            //
            // Close the UserShip root.
            //

            RegCloseKey( Context->UserShipKey );
        }

        //
        // Unload the UserShip hive.
        //

        RegUnLoadKey( HKEY_USERS, USERSHIP_KEY );
    }

    return error;

} // MergeUserShipIntoUserRun


DWORD
CreateAndLoadUserRun (
    OUT PUSERRUN_CONTEXT Context,
    IN PWCH UserRunPath
    )

/*++

Routine Description:

    Create a new UserRun hive and load it into the registry.

Arguments:

    Context - pointer to context record.

    UserRunPath - supplies the path to the UserRun file.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    DWORD error;
    DWORD disposition;
    HKEY userRunKey;

    //
    // Create the UserRun key under HKEY_CURRENT_USER.
    //
    // NOTE: Trying to create this under HKEY_USERS doesn't work.
    //

    error = RegCreateKeyEx( HKEY_CURRENT_USER,
                            USERRUN_KEY,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &userRunKey,
                            &disposition );
    if ( error != NO_ERROR ) {
        return error;
    }

    //
    // Save the newly created UserRun key to a hive file.
    //

    error = RegSaveKey( userRunKey,
                        UserRunPath,
                        NULL );

    //
    // Close and delete the UserRun key.
    //

    RegCloseKey( userRunKey );

    RegDeleteKey( HKEY_CURRENT_USER, USERRUN_KEY );

    //
    // Now load UserRun back into the registry.
    //

    if ( error == NO_ERROR ) {
        error = LoadUserRun( Context, UserRunPath );
    }

    return error;

} // CreateAndLoadUserRun


DWORD
OpenUserRunKeys (
    IN OUT PUSERRUN_CONTEXT Context
    )

/*++

Routine Description:

    Opens the core keys in the UserRun hive.

Arguments:

    Context - pointer to context record.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    DWORD error;
    DWORD disposition;
    OSVERSIONINFO versionInfo;
    WCHAR buildNumber[6];

    //
    // Get the current build number.
    //

    versionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( !GetVersionEx( &versionInfo ) ) {
        return GetLastError();
    }

    wsprintf( buildNumber, TEXT("%d"), LOWORD(versionInfo.dwBuildNumber) );

    //
    // Open/create a subkey for the current build.
    //

    error = RegCreateKeyEx( Context->UserRunKey,
                            buildNumber,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE,
                            NULL,
                            &Context->BuildKey,
                            &disposition );
    if ( error != NO_ERROR ) {
        return error;
    }

    //
    // Create a Files subkey.
    //

    error = RegCreateKeyEx( Context->BuildKey,
                            FILES_KEY,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE,
                            NULL,
                            &Context->FilesKey,
                            &disposition );
    if ( error != NO_ERROR ) {
        return error;
    }

    //
    // Create a Hive subkey.
    //

    error = RegCreateKeyEx( Context->BuildKey,
                            HIVE_KEY,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE,
                            NULL,
                            &Context->HiveKey,
                            &disposition );
    if ( error != NO_ERROR ) {
        return error;
    }

    //
    // Set the FilesIndex and HiveIndex so that we append to whatever
    // information already exists for the current build.
    //

    error = RegQueryInfoKey( Context->FilesKey,
                             NULL,
                             NULL,
                             NULL,
                             &Context->FilesIndex,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL );
    if ( error != NO_ERROR ) {
        return error;
    }

    error = RegQueryInfoKey( Context->HiveKey,
                             NULL,
                             NULL,
                             NULL,
                             &Context->HiveIndex,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL );

    return error;

} // OpenUserRunKeys


VOID
UnloadUserRun (
    IN OUT PUSERRUN_CONTEXT Context
    )

/*++

Routine Description:

    Unloads the UserRun hive from the registry.

Arguments:

    Context - pointer to context record.

Return Value:

    None.

--*/

{
    //
    // Close the core keys, if they are open.
    //

    if ( Context->HiveKey != NULL ) {
        RegCloseKey( Context->HiveKey );
    }
    if ( Context->FilesKey != NULL ) {
        RegCloseKey( Context->FilesKey );
    }
    if ( Context->BuildKey != NULL ) {
        RegCloseKey( Context->BuildKey );
    }

    //
    // Close the root key, if it is open.
    //

    if ( Context->UserRunKey != NULL ) {
        RegCloseKey( Context->UserRunKey );
    }

    //
    // Unload the hive, if it has been loaded.
    //

    if ( Context->UserRunLoaded ) {
        RegUnLoadKey( HKEY_USERS, USERRUN_KEY );
    }

    return;

} // UnloadUserRun


DWORD
CheckUserShipKey (
    IN PVOID Context,
    IN DWORD KeyNameLength,
    IN PWCH KeyName
    )

/*++

Routine Description:

    Checks an enumerated key in the UserShip hive to see if a corresponding
    key is present in the UserRun hive.  If not, copies the key from UserShip
    into UserRun.

Arguments:

    Context - pointer to context record.

    KeyNameLength - length in characters of key name.

    KeyName - pointer to name of key.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PUSERRUN_CONTEXT context = Context;

    DWORD error;
    DWORD disposition;
    HKEY userRunBuildKey;
    HKEY userShipBuildKey;
    WCHAR path[MAX_PATH + 1];

    //
    // We have the name of a key in UserShip.  Try to open the
    // corresponding key in UserRun.
    //

    error = RegCreateKeyEx( context->UserRunKey,
                            KeyName,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE,
                            NULL,
                            &userRunBuildKey,
                            &disposition );
    if ( error != NO_ERROR ) {
        return error;
    }

    //
    // No error occurred.  The key was either opened or created.
    //

    if ( disposition == REG_OPENED_EXISTING_KEY ) {

        //
        // The key already existed in UserRun.  We assume that it already
        // contains the information that is in UserShip.
        //

    } else {

        //
        // The key didn't exist in UserRun.  Copy the key from UserShip
        // into UserRun.  This is done by saving the UserShip key to
        // a file, then restoring the file back under the UserRun key.
        //
        // Note that the copy operation will fail if the file already
        // exists.
        //

        error = RegOpenKeyEx( context->UserShipKey,
                              KeyName,
                              0,
                              KEY_READ,
                              &userShipBuildKey );
        if ( error == NO_ERROR ) {

            GetWindowsDirectory( path, MAX_PATH );
            wcscat( path, TEXT("\\") );
            wcscat( path, USERTMP_PATH );

            error = RegSaveKey( userShipBuildKey,
                                path,
                                NULL );
            if ( error == NO_ERROR ) {

                error = RegRestoreKey( userRunBuildKey,
                                       path,
                                       0 );

                DeleteFile( path );
            }

            RegCloseKey( userShipBuildKey );
        }
    }

    //
    // Close the UserRun key.
    //

    RegCloseKey( userRunBuildKey );

    return error;

} // CheckUserShipKey


DWORD
MakeUserRunEnumRoutine (
    IN PVOID Context,
    IN PWATCH_ENTRY Entry
    )

/*++

Routine Description:

    EnumRoutine for the MakeUserdifr operation.  Calls the appropriate
    processing routine based on the entry type (file/directory/key/value)
    and the change type (changed, new, deleted).

Arguments:

    Context - context value passed to WatchEnum.

    Entry - description of the changed entry.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PUSERRUN_CONTEXT context = Context;
    DWORD index;
    HKEY newKey;
    DWORD error;
    DWORD dword;

    //
    // Call the appropriate processing routine.
    //

    switch ( Entry->EntryType ) {

    case WATCH_DIRECTORY:

        switch ( Entry->ChangeType ) {

        case WATCH_NEW:
            dprintf( 1, ("New directory %ws\n", Entry->Name) );
            error = MakeAddDirectory( Context, Entry->Name );
            break;

        case WATCH_DELETED:
            dprintf( 1, ("Deleted directory %ws\n", Entry->Name) );
            error = CreateUserRunSimpleFileKey( Context, 2, Entry->Name );
            break;

        default:
            error = ERROR_INVALID_PARAMETER;
        }

        break;

    case WATCH_FILE:

        switch ( Entry->ChangeType ) {

        case WATCH_NEW:
        case WATCH_CHANGED:
            dprintf( 1, ("New or changed file %ws\n", Entry->Name) );
            error = CreateUserRunSimpleFileKey( Context, 3, Entry->Name );
            break;

        case WATCH_DELETED:
            dprintf( 1, ("Deleted file %ws\n", Entry->Name) );
            error = CreateUserRunSimpleFileKey( Context, 4, Entry->Name );
            break;

        default:
            error = ERROR_INVALID_PARAMETER;
        }

        break;

    case WATCH_KEY:
        switch ( Entry->ChangeType ) {

        case WATCH_NEW:
            dprintf( 1, ("New key %ws\n", Entry->Name) );
            error = MakeAddKey( Context, Entry->Name );
            break;

        case WATCH_DELETED:
            dprintf( 1, ("Deleted key %ws\n", Entry->Name) );
            error = MakeDeleteKey( Context, Entry->Name );
            break;

        default:
            error = ERROR_INVALID_PARAMETER;
        }

        break;

    case WATCH_VALUE:

        switch ( Entry->ChangeType ) {

        case WATCH_NEW:
        case WATCH_CHANGED:
            dprintf( 1, ("New or changed value %ws\n", Entry->Name) );
            error = MakeAddValue( Context, Entry->Name );
            break;

        case WATCH_DELETED:
            dprintf( 1, ("Deleted value %ws\n", Entry->Name) );
            error = MakeDeleteValue( Context, Entry->Name );
            break;

        default:
            error = ERROR_INVALID_PARAMETER;
        }

        break;

    default:

        error = ERROR_INVALID_PARAMETER;
    }

    return error;

} // MakeUserRunEnumRoutine


DWORD
MakeAddDirectory (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Name
    )

/*++

Routine Description:

    Adds entries to the UserRun hive for a new directory.

Arguments:

    Context - context value passed to WatchEnum.

    Name - name of new directory (relative to root of watched tree).


Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    WCHAR fullpath[MAX_PATH + 1];
    PWCH path;
    BOOL ok;

    //
    // Get the full path to the new directory.  "fullpath" is the full path;
    // "path" is just this directory.
    //

    ok = GetSpecialFolderPath ( CSIDL_PROGRAMS, fullpath );
    if ( !ok ) {
        return GetLastError();
    }
    wcscat( fullpath, TEXT("\\") );
    path = fullpath + wcslen(fullpath);
    wcscpy( path, Name );

    //
    // Call AddDirectory to do the recursive work.
    //

    return AddDirectory( Context, fullpath, path );

} // MakeAddDirectory


DWORD
MakeAddValue (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Name
    )

/*++

Routine Description:

    Adds an entry to the UserRun hive for a new value.

Arguments:

    Context - context value passed to WatchEnum.

    Name - name of new value (relative to HKEY_CURRENT_USER).

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    HKEY newKey;
    PWCH keyName;
    PWCH valueName;
    PWCH splitPoint;
    DWORD valueType;
    PVOID valueData;
    DWORD valueDataLength;
    DWORD error;
    DWORD dword;

    //
    // Split the name into key and value portions.
    //

    splitPoint = wcsrchr( Name, TEXT('\\') );
    if ( splitPoint != NULL ) {
        keyName = Name;
        valueName = splitPoint + 1;
        *splitPoint = 0;
    } else {
        keyName = NULL;
        valueName = Name;
    }

    //
    // Query the value data.
    //

    valueData = NULL;
    error = QueryValue( keyName, valueName, &valueType, &valueData, &valueDataLength );

    //
    // Add an entry for the value.
    //

    if ( error == NO_ERROR ) {
        error = AddValue( Context, keyName, valueName, valueType, valueData, valueDataLength );
    }

    //
    // Free the value data buffer allocated by QueryValue.
    //

    if ( valueData != NULL ) {
        MyFree( valueData );
    }

    //
    // Restore the input value name string.
    //

    if ( splitPoint != NULL ) {
        *splitPoint = TEXT('\\');
    }

    return error;

} // MakeAddValue


DWORD
MakeDeleteValue (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Name
    )

/*++

Routine Description:

    Adds an entry to the UserRun hive for a deleted value.

Arguments:

    Context - context value passed to WatchEnum.

    Name - name of deleted value (relative to HKEY_CURRENT_USER).

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    HKEY newKey;
    PWCH keyName;
    PWCH valueName;
    PWCH valueNames;
    PWCH splitPoint;
    DWORD valueNamesLength;
    DWORD error;
    DWORD dword;

    error = NO_ERROR;

    //
    // Split the name into key and value portions.  Create a MULTI_SZ
    // version of the deleted name (to match userdiff format).
    //

    splitPoint = wcsrchr( Name, TEXT('\\') );
    if ( splitPoint != NULL ) {
        keyName = Name;
        valueName = splitPoint + 1;
        *splitPoint = 0;
    } else {
        keyName = NULL;
        valueName = Name;
    }

    SzToMultiSz( valueName, &valueNames, &valueNamesLength );
    if ( valueNames == NULL ) {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Create an entry key and popuplate it.
    //

    newKey = NULL;
    if ( error == NO_ERROR ) {
        error = CreateUserRunKey( Context, FALSE, &newKey );
    }

    if ( error == NO_ERROR ) {
        dword = 4;
        error = RegSetValueEx( newKey, ACTION_VALUE, 0, REG_DWORD, (PBYTE)&dword, sizeof(DWORD) );
    }
    if ( error == NO_ERROR ) {
        error = RegSetValueEx( newKey, KEYNAME_VALUE, 0, REG_SZ, (PBYTE)keyName, SZLEN(keyName) );
    }
    if ( error == NO_ERROR ) {
        error = RegSetValueEx( newKey, VALUENAMES_VALUE, 0, REG_MULTI_SZ, (PBYTE)valueNames, valueNamesLength );
    }
    if ( error == NO_ERROR ) {
        if ( *valueNames == 0 ) {
            dword = 1;
            error = RegSetValueEx( newKey, FLAGS_VALUE, 0, REG_DWORD, (PBYTE)&dword, sizeof(DWORD) );
        }
    }

    if ( newKey != NULL ) {
        RegCloseKey( newKey );
    }

    //
    // Free the buffer allocated by SzToMultiSz.
    //

    if ( valueNames != NULL ) {
        MyFree( valueNames );
    }

    //
    // Restore the input value name string.
    //

    if ( splitPoint != NULL ) {
        *splitPoint = TEXT('\\');
    }

    return error;

} // MakeDeleteValue


DWORD
MakeAddKey (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Name
    )

/*++

Routine Description:

    Adds entries to the UserRun hive for a new key.

Arguments:

    Context - context value passed to WatchEnum.

    Name - name of new key (relative to HKEY_CURRENT_USER).

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    WCHAR path[MAX_PATH + 1];

    //
    // Copy the key name into a large buffer and call AddKey to do the
    // recursive work.
    //

    wcscpy( path, Name );
    return AddKey( Context, path );

} // MakeAddKey


DWORD
MakeDeleteKey (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Name
    )

/*++

Routine Description:

    Adds an entry to the UserRun hive for a deleted key.

Arguments:

    Context - context value passed to WatchEnum.

    Name - name of deleted key (relative to HKEY_CURRENT_USER).

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    HKEY newKey;
    DWORD error;
    DWORD dword;

    //
    // Create an entry key and popuplate it.
    //

    newKey = NULL;
    error = CreateUserRunKey( Context, FALSE, &newKey );

    if ( error == NO_ERROR ) {
        dword = 2;
        error = RegSetValueEx( newKey, ACTION_VALUE, 0, REG_DWORD, (PBYTE)&dword, sizeof(DWORD) );
    }
    if ( error == NO_ERROR ) {
        error = RegSetValueEx( newKey, KEYNAME_VALUE, 0, REG_SZ, (PBYTE)Name, SZLEN(Name) );
    }

    if ( newKey != NULL ) {
        RegCloseKey( newKey );
    }

    return error;

} // MakeDeleteKey


DWORD
AddDirectory (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH FullPath,
    IN PWCH Path
    )

/*++

Routine Description:

    Recursively adds entries to the UserRun hive for a new directory
    and its subtree.

Arguments:

    Context - context value passed to WatchEnum.

    FullPath - full path to directory.

    Path - path to directory relative to root of watched directory.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    HKEY newKey;
    DWORD error;
    DWORD dword;
    HANDLE findHandle;
    WIN32_FIND_DATA fileData;
    BOOL ok;

    //
    // Create an entry key for the directory and popuplate it.
    //

    newKey = NULL;
    error = CreateUserRunKey( Context, TRUE, &newKey );

    if ( error == NO_ERROR ) {
        dword = 1;
        error = RegSetValueEx( newKey, ACTION_VALUE, 0, REG_DWORD, (PBYTE)&dword, sizeof(DWORD) );
    }
    if ( error == NO_ERROR ) {
        error = RegSetValueEx( newKey, ITEM_VALUE, 0, REG_SZ, (PBYTE)Path, SZLEN(Path) );
    }

    if ( newKey != NULL ) {
        RegCloseKey( newKey );
    }

    if ( error == NO_ERROR ) {

        //
        // Search the directory and add file and directory entries.
        //

        wcscat( Path, TEXT("\\*") );
        findHandle = FindFirstFile( FullPath, &fileData );
        Path[wcslen(Path) - 2] = 0;

        if ( findHandle != INVALID_HANDLE_VALUE ) {

            do {

                //
                // Append the name of the current directory entry to the path.
                //

                wcscat( Path, TEXT("\\") );
                wcscat( Path, fileData.cFileName );

                //
                // If the current entry is a file, add an entry in UserRun
                // for it.  If the current entry is a directory, call
                // AddDirectory recursively to process it.
                //

                if ( FlagOff(fileData.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY) ) {
                    error = CreateUserRunSimpleFileKey( Context, 3, Path );
                } else if ((wcscmp(fileData.cFileName,TEXT(".")) != 0) &&
                           (wcscmp(fileData.cFileName,TEXT("..")) != 0)) {
                    error = AddDirectory( Context, FullPath, Path );
                }

                *wcsrchr( Path, TEXT('\\') ) = 0;

                if ( error == NO_ERROR ) {
                    ok = FindNextFile( findHandle, &fileData );
                }

            } while ( (error == NO_ERROR) && ok );

            FindClose( findHandle );

        } // findHandle != INVALID_HANDLE_VALUE

    }

    return error;

} // AddDirectory


DWORD
AddKey (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH Path
    )

/*++

Routine Description:

    Recursively adds entries to the UserRun hive for a new key
    and its subtree.

Arguments:

    Context - context value passed to WatchEnum.

    Path - path to key relative to HKEY_CURRENT_USER.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    HKEY newKey;
    DWORD error;
    DWORD dword;
    HKEY findHandle;
    KEY_ENUM_CONTEXT enumContext;

    //
    // Create an entry key for the key and popuplate it.
    //

    newKey = NULL;
    error = CreateUserRunKey( Context, FALSE, &newKey );

    if ( error == NO_ERROR ) {
        dword = 1;
        error = RegSetValueEx( newKey, ACTION_VALUE, 0, REG_DWORD, (PBYTE)&dword, sizeof(DWORD) );
    }
    if ( error == NO_ERROR ) {
        error = RegSetValueEx( newKey, KEYNAME_VALUE, 0, REG_SZ, (PBYTE)Path, SZLEN(Path) );
    }

    if ( newKey != NULL ) {
        RegCloseKey( newKey );
    }

    if ( error == NO_ERROR ) {

        //
        // Search the key and add value and key entries.
        //

        findHandle = NULL;

        error = RegOpenKeyEx( HKEY_CURRENT_USER,
                              Path,
                              0,
                              KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                              &findHandle );
        if ( error == NO_ERROR ) {

            //
            // Enumerate the values and subkeys of the key, adding entries
            // to the UserRun hive for each one.
            //

            enumContext.UserRunContext = Context;
            enumContext.CurrentPath = Path;
            error = EnumerateKey( findHandle,
                                  &enumContext,
                                  AddValueDuringAddKey,
                                  AddKeyDuringAddKey );

            RegCloseKey( findHandle );
        }
    }

    return error;

} // AddKey


DWORD
AddValueDuringAddKey (
    IN PVOID Context,
    IN DWORD ValueNameLength,
    IN PWCH ValueName,
    IN DWORD ValueType,
    IN PVOID ValueData,
    IN DWORD ValueDataLength
    )

/*++

Routine Description:

    Adds a value entry to UserRun during AddKey.

Arguments:

    Context - context value passed to EnumerateKey.

    ValueNameLength - length in characters of ValueName.

    ValueName - pointer to name of the value.

    ValueType - type of the value data.

    ValueData - pointer to value data.

    ValueDataLength - length in bytes of ValueData.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PKEY_ENUM_CONTEXT context = Context;

    //
    // Add the value entry to UserRun.
    //

    return AddValue( context->UserRunContext,
                     context->CurrentPath,
                     ValueName,
                     ValueType,
                     ValueData,
                     ValueDataLength );

} // AddValueDuringAddKey


DWORD
AddKeyDuringAddKey (
    IN PVOID Context,
    IN DWORD KeyNameLength,
    IN PWCH KeyName
    )

/*++

Routine Description:

    Adds a key entry to UserRun during AddKey.

Arguments:

    Context - context value passed to EnumerateKey.

    KeyNameLength - length in characters of KeyName.

    KeyName - pointer to name of the key.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PKEY_ENUM_CONTEXT context = Context;
    DWORD error;

    //
    // Append the key name to the path and call AddKey to do the
    // recursive work.
    //

    wcscat( context->CurrentPath, TEXT("\\") );
    wcscat( context->CurrentPath, KeyName );
    error = AddKey( context->UserRunContext, context->CurrentPath );

    //
    // Remove the key name from the path.
    //

    *wcsrchr( context->CurrentPath, TEXT('\\') ) = 0;

    return error;

} // AddKeyDuringAddKey


DWORD
AddValue (
    IN PUSERRUN_CONTEXT Context,
    IN PWCH KeyName OPTIONAL,
    IN PWCH ValueName,
    IN DWORD ValueType,
    IN PVOID ValueData,
    IN DWORD ValueDataLength
    )

/*++

Routine Description:

    Adds an entry for a new value to UserRun.

Arguments:

    Context - pointer to context record.

    KeyName - pointer to name of the key containing the value.

    ValueName - pointer to name of the value.

    ValueType - type of the value data.

    ValueData - pointer to value data.

    ValueDataLength - length in bytes of ValueData.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    HKEY newKey;
    DWORD error;
    DWORD dword;

    //
    // Create an entry key for the value and popuplate it.
    //

    newKey = NULL;
    error = CreateUserRunKey( Context, FALSE, &newKey );

    if ( error == NO_ERROR ) {
        dword = 3;
        error = RegSetValueEx( newKey, ACTION_VALUE, 0, REG_DWORD, (PBYTE)&dword, sizeof(DWORD) );
    }
    if ( error == NO_ERROR ) {
        error = RegSetValueEx( newKey, KEYNAME_VALUE, 0, REG_SZ, (PBYTE)KeyName, SZLEN(KeyName) );
    }
    if ( error == NO_ERROR ) {
        error = RegSetValueEx( newKey, VALUENAME_VALUE, 0, REG_SZ, (PBYTE)ValueName, SZLEN(ValueName) );
    }
    if ( error == NO_ERROR ) {
        error = RegSetValueEx( newKey, VALUE_VALUE, 0, ValueType, (PBYTE)ValueData, ValueDataLength );
    }

    if ( newKey != NULL ) {
        RegCloseKey( newKey );
    }

    return error;

} // AddValue


DWORD
CreateUserRunSimpleFileKey (
    IN PUSERRUN_CONTEXT Context,
    IN DWORD Action,
    IN PWCH Name
    )

/*++

Routine Description:

    Creates an entry under the Files key for the "simple" cases -- delete
    directory, add file, delete file.

Arguments:

    Context - pointer to context record.

    Action - value to store in Action value of entry.

    Name - pointer to name of the file or directory.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    HKEY newKey;
    DWORD error;

    //
    // Create an entry key and popuplate it.
    //

    newKey = NULL;
    error = CreateUserRunKey( Context, TRUE, &newKey );

    if ( error == NO_ERROR ) {
        error = RegSetValueEx( newKey, ACTION_VALUE, 0, REG_DWORD, (PBYTE)&Action, sizeof(DWORD) );
    }
    if ( error == NO_ERROR ) {
        error = RegSetValueEx( newKey, ITEM_VALUE, 0, REG_SZ, (PBYTE)Name, SZLEN(Name) );
    }

    if ( newKey != NULL ) {
        RegCloseKey( newKey );
    }

    return error;

} // CreateUserRunSimpleFileKey


DWORD
CreateUserRunKey (
    IN PUSERRUN_CONTEXT Context,
    IN BOOL IsFileKey,
    OUT PHKEY NewKeyHandle
    )

/*++

Routine Description:

    Creates an indexed key in UserRun, under either the Files key or the
    Hive key.

Arguments:

    Context - pointer to context record.

    IsFileKey - indicates whether to create the key under Files or Hive.

    NewKeyHandle - returns the handle to the new key.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    HKEY parentKeyHandle;
    DWORD index;
    WCHAR keyName[11];
    DWORD disposition;

    //
    // Get the handle to the parent key and the index for this entry.
    //

    if ( IsFileKey ) {
        parentKeyHandle = Context->FilesKey;
        index = ++Context->FilesIndex;
    } else {
        parentKeyHandle = Context->HiveKey;
        index = ++Context->HiveIndex;
    }

    //
    // Convert the index number into a string.
    //

    wsprintf( keyName, TEXT("%d"), index );

    //
    // Create the entry key.
    //

    return RegCreateKeyEx( parentKeyHandle,
                           keyName,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           NULL,
                           NewKeyHandle,
                           &disposition );

} // CreateUserRunKey


DWORD
QueryValue (
    IN PWCH KeyName OPTIONAL,
    IN PWCH ValueName,
    OUT PDWORD ValueType,
    OUT PVOID *ValueData,
    OUT PDWORD ValueDataLength
    )

/*++

Routine Description:

    Queries the data for a value.

Arguments:

    KeyName - pointer to name of the key containing the value.

    ValueName - pointer to name of the value.

    ValueType - returns the type of the value data.

    ValueData - returns a pointer to value data.  This buffer must be
        freed by the caller using MyFree.

    ValueDataLength - length in bytes of ValueData.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    HKEY hkey;
    DWORD disposition;
    DWORD error;

    //
    // Open the parent key.
    //

    if ( (KeyName == NULL) || (wcslen(KeyName) == 0) ) {
        hkey = HKEY_CURRENT_USER;
    } else {
        error = RegCreateKeyEx( HKEY_CURRENT_USER,
                                KeyName,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hkey,
                                &disposition );
        if ( error != ERROR_SUCCESS ) {
            return error;
        }
    }

    //
    // Query the value to get the length of its data.
    //

    *ValueDataLength = 0;
    *ValueData = NULL;
    error = RegQueryValueEx( hkey,
                             ValueName,
                             NULL,
                             ValueType,
                             NULL,
                             ValueDataLength );

    //
    // Allocate a buffer to hold the value data.
    //

    if ( error == NO_ERROR ) {
        *ValueData = MyMalloc( *ValueDataLength );
        if ( *ValueData == NULL ) {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // Query the value again, this time retrieving the data.
    //

    if ( error == NO_ERROR ) {
        error = RegQueryValueEx( hkey,
                                 ValueName,
                                 NULL,
                                 ValueType,
                                 *ValueData,
                                 ValueDataLength );
        if ( error != NO_ERROR ) {
            MyFree( *ValueData );
        }
    }

    //
    // Close the parent key.
    //

    if ( hkey != HKEY_CURRENT_USER ) {
        RegCloseKey( hkey );
    }

    return error;
}


VOID
SzToMultiSz (
    IN PWCH Sz,
    OUT PWCH *MultiSz,
    OUT PDWORD MultiSzLength
    )

/*++

Routine Description:

    Creates a MULTI_SZ version of a null-terminated string.  Allocates
    a buffer, copies the string to the buffer, and appends an additional
    null terminator.

Arguments:

    Sz - pointer to the string that is to be copied.

    MultiSz - returns a pointer to the MULTI_SZ version of Sz.  The caller
        must free this buffer using MyFree.  If the allocation fails,
        MultiSz will be NULL.

    MultiSzLength - returns the length in bytes of MultiSz, including the
        null terminators.

Return Value:

    None.

--*/

{
    DWORD szlen;

    //
    // Get the length of the input string and calculate the MULTI_SZ length.
    //

    szlen = wcslen(Sz);
    *MultiSzLength = (szlen + 1 + 1) * sizeof(WCHAR);

    //
    // Allocate the MULTI_SZ buffer, copy the input string, and append
    // an additional null.
    //

    *MultiSz = MyMalloc( *MultiSzLength );
    if ( *MultiSz != NULL ) {
        wcscpy( *MultiSz, Sz );
        (*MultiSz)[szlen+1] = 0;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\vdm.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    vdm.c

Abstract:

    Routines to configure the MS-DOS subsystem.

Author:

    Ted Miller (tedm) 27-Apr-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop


//
// Keywords whose presence in config.sys indicate OS/2.
//
PCSTR Os2ConfigSysKeywords[] = { "DISKCACHE", "LIBPATH",   "PAUSEONERROR",
                                 "RMSIZE",    "RUN",       "SWAPPATH",
                                 "IOPL",      "MAXWAIT",   "MEMMAN",
                                 "PRIORITY",  "PROTSHELL", "PROTECTONLY",
                                 "THREADS",   "TIMESLICE", "TRACE",
                                 "TRACEBUF",  "DEVINFO",   NULL
                               };

//
// Keywords we migrate from the user's existing DOS config.sys
// into config.nt.
//
#define NUM_DOS_KEYWORDS 4
PCSTR DosConfigSysKeywords[NUM_DOS_KEYWORDS] = { "FCBS","BREAK","LASTDRIVE","FILES" };

BOOL
DosConfigSysExists(
    IN PCWSTR Filename
    );

BOOL
CreateConfigNt(
    IN PCWSTR ConfigDos,
    IN PCWSTR ConfigTmp,
    IN PCWSTR ConfigNt
    );

PSTR
IsolateFirstField(
    IN  PSTR   Line,
    OUT PSTR  *End,
    OUT PCHAR  Terminator
    );

BOOL
ConfigureMsDosSubsystem(
    VOID
    )

/*++

Routine Description:

    Configure the 16-bit MS-DOS subsystem.
    Currently this means creating config.nt and autoexec.nt.
    It also means creating empty config.sys, autoexec.bat, io.sys and msdos.sys
    if these files don't already exist.

    On the upgrade, the only thing that we do is to create the empty files,
    if they don't already exist.

Arguments:

    None.

Return Value:

    Boolean value indicating outcome.

--*/

{
    WCHAR ConfigDos[] = L"?:\\CONFIG.SYS";
    WCHAR ConfigTmp[MAX_PATH];
    WCHAR ConfigNt[MAX_PATH];

    WCHAR AutoexecDos[] = L"?:\\AUTOEXEC.BAT";
    WCHAR AutoexecTmp[MAX_PATH];
    WCHAR AutoexecNt[MAX_PATH];

    WCHAR IoSysFile[] = L"?:\\IO.SYS";
    WCHAR MsDosSysFile[] = L"?:\\MSDOS.SYS";

    WCHAR ControlIniFile[MAX_PATH];

    BOOL b;
    DWORD Result;

    ULONG   i;
    HANDLE  FileHandle;
    PWSTR   DosFileNames[] = {
                         ConfigDos,
                         AutoexecDos,
                         IoSysFile,
                         MsDosSysFile,
                         ControlIniFile
                         };
    DWORD   DosFileAttributes[] = {
                                  FILE_ATTRIBUTE_NORMAL,
                                  FILE_ATTRIBUTE_NORMAL,
                                  FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY,
                                  FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY,
                                  FILE_ATTRIBUTE_NORMAL
                                  };
    //
    // Fill in drive letter of system partition.
    //
#ifdef _X86_
    ConfigDos[0] = x86SystemPartitionDrive;
    AutoexecDos[0] = x86SystemPartitionDrive;
    IoSysFile[0]   = x86SystemPartitionDrive;
    MsDosSysFile[0] = x86SystemPartitionDrive;
#else
    ConfigDos[0] = L'C';
    AutoexecDos[0] = L'C';
    IoSysFile[0]   = L'C';
    MsDosSysFile[0] = L'C';
#endif
    //
    //  Build path to control.ini file
    //
    Result = GetWindowsDirectory(ControlIniFile,MAX_PATH);
    if( Result == 0) {
        MYASSERT(FALSE);
        return FALSE;
    }
    pSetupConcatenatePaths(ControlIniFile,L"control.ini",MAX_PATH,NULL);

    //
    //  Create empty config.sys, autoexec.bat, io.sys, msdos.sys and control.ini
    //  if they don't exist. This is because some 16-bit apps depend on
    //  these files and SudeepB wants this moved from VDM to setup.
    //
    for( i = 0; i < sizeof( DosFileNames ) / sizeof( PWSTR ); i++ ) {
        FileHandle = CreateFile( DosFileNames[i],
                                 GENERIC_READ | GENERIC_WRITE,
                                 0,          // File is not to be shared
                                 NULL,       // No security attributes
                                 CREATE_NEW, // Create only if it doesn't exist
                                 DosFileAttributes[i],
                                 NULL );     // No extended attributes
        if( FileHandle != INVALID_HANDLE_VALUE ) {
            CloseHandle( FileHandle );
        }
    }
    if( Upgrade ) {
        return( TRUE );
    }

    //
    // Form filenames.
    //
    GetSystemDirectory(ConfigTmp,MAX_PATH);
    lstrcpy(ConfigNt,ConfigTmp);
    lstrcpy(AutoexecNt,ConfigTmp);
    lstrcpy(AutoexecTmp,ConfigTmp);
    pSetupConcatenatePaths(ConfigTmp,L"CONFIG.TMP",MAX_PATH,NULL);
    pSetupConcatenatePaths(ConfigNt,L"CONFIG.NT",MAX_PATH,NULL);
    pSetupConcatenatePaths(AutoexecTmp,L"AUTOEXEC.TMP",MAX_PATH,NULL);
    pSetupConcatenatePaths(AutoexecNt,L"AUTOEXEC.NT",MAX_PATH,NULL);

    //
    // If the temp files don't exist, we're done.
    // If they do, set their attributes so that we can delete them later.
    //
    if(!FileExists(ConfigTmp,NULL) || !FileExists(AutoexecTmp,NULL)) {
        return(TRUE);
    }
    SetFileAttributes(ConfigTmp,FILE_ATTRIBUTE_NORMAL);
    SetFileAttributes(AutoexecTmp,FILE_ATTRIBUTE_NORMAL);

    //
    // Get rid of any existing nt config files. We don't support
    // merging/upgrading them; we support only ooverwriting them.
    //
    SetFileAttributes(ConfigNt,FILE_ATTRIBUTE_NORMAL);
    SetFileAttributes(AutoexecNt,FILE_ATTRIBUTE_NORMAL);
    DeleteFile(ConfigNt);
    DeleteFile(AutoexecNt);

    //
    // If a DOS config.sys exists, merge the template config.sys
    // and the dos config.sys to form the nt config.sys.
    // Otherwise move the config.sys template over to be the
    // nt config file.
    //
    if(DosConfigSysExists(ConfigDos)) {
        b = CreateConfigNt(ConfigDos,ConfigTmp,ConfigNt);
    } else {
        b = MoveFile(ConfigTmp,ConfigNt);
    }

    //
    // We don't do anything special with autoexec.bat.
    // Just move the template over to be the nt file.
    //
    if(!MoveFile(AutoexecTmp,AutoexecNt)) {
        b = FALSE;
    }

    return(b);
}


BOOL
DosConfigSysExists(
    IN PCWSTR Filename
    )

/*++

Routine Description:

    Determine whether a given file is a DOS config.sys.

Arguments:

    Filename - supplies name of file to check.

Return Value:

    TRUE if the file exists and is not an OS/2 config.sys.
    FALSE if the file does not exist or is an OS/2 config.sys.

--*/

{
    BOOL b;
    FILE *f;
    CHAR Line[512];
    UINT i;
    PCHAR p;
    CHAR c;
    PSTR End;
    PSTR filename;

    filename = pSetupUnicodeToAnsi(Filename);
    if(!filename) {
        return(FALSE);
    }

    b = FALSE;
    if(FileExists(Filename,NULL)) {

        b = TRUE;
        if(f = fopen(filename,"rt")) {

            while(b && fgets(Line,sizeof(Line),f)) {

                if(p = IsolateFirstField(Line,&End,&c)) {
                    for(i=0; b && Os2ConfigSysKeywords[i]; i++) {

                        if(!lstrcmpiA(p,Os2ConfigSysKeywords[i])) {
                            b = FALSE;
                        }
                    }
                }
            }

            fclose(f);
        }
    }

    MyFree(filename);
    return(b);
}


BOOL
CreateConfigNt(
    IN PCWSTR ConfigDos,
    IN PCWSTR ConfigTmp,
    IN PCWSTR ConfigNt
    )

/*++

Routine Description:

    Create config.nt. This is done by merging config.tmp (copied during setup)
    and the user's existing DOS config.sys. We migrate certain lines from
    the DOS config.sys into config.nt.

Arguments:

    ConfigDos - supplies filename of DOS config.sys.

    ConfigTmp - supplies filename of template config.sys.

    ConfigNt - supplies filename of config.nt to be created.

Return Value:

    Boolean value indicating outcome.

--*/

{
    FILE *DosFile;
    FILE *NtFile;
    FILE *TmpFile;
    BOOL b;
    CHAR Line[512];
    PCHAR p;
    BOOL Found;
    BOOL SawKeyword[NUM_DOS_KEYWORDS];
    PCSTR FoundKeyword[NUM_DOS_KEYWORDS];
    PSTR FoundLine[NUM_DOS_KEYWORDS];
    UINT KeywordsFound;
    CHAR c;
    PSTR End;
    PCSTR configDos,configTmp,configNt;
    UINT i;

    //
    // Open the dos file for reading.
    // Create the nt file for writing.
    // Open the template file for reading.
    //
    b = FALSE;
    if(configDos = pSetupUnicodeToAnsi(ConfigDos)) {
        DosFile = fopen(configDos,"rt");
        MyFree(configDos);
        if(!DosFile) {
            goto err0;
        }
    } else {
        goto err0;
    }
    if(configNt = pSetupUnicodeToAnsi(ConfigNt)) {
        NtFile = fopen(configNt,"wt");
        MyFree(configNt);
        if(!NtFile) {
            goto err1;
        }
    } else {
        goto err1;
    }
    if(configTmp = pSetupUnicodeToAnsi(ConfigTmp)) {
        TmpFile = fopen(configTmp,"rt");
        MyFree(configTmp);
        if(!TmpFile) {
            goto err2;
        }
    } else {
        goto err2;
    }

    //
    // Process the DOS file. Read each line and see if it's one
    // we care about. If so, save it for later.
    //
    ZeroMemory(SawKeyword,sizeof(SawKeyword));
    KeywordsFound = 0;
    while(fgets(Line,sizeof(Line),DosFile)) {
        //
        // Isolate the first field.
        //
        if(p = IsolateFirstField(Line,&End,&c)) {

            //
            // See if we care about this line.
            //
            for(i=0; i<NUM_DOS_KEYWORDS; i++) {
                if(!SawKeyword[i] && !lstrcmpiA(p,DosConfigSysKeywords[i])) {
                    //
                    // Remember that we saw this line and save away
                    // the rest of the line for later.
                    //
                    *End = c;
                    SawKeyword[i] = TRUE;
                    FoundKeyword[KeywordsFound] = DosConfigSysKeywords[i];
                    FoundLine[KeywordsFound] = MyMalloc(lstrlenA(p)+1);
                    if(!FoundLine[KeywordsFound]) {
                        goto err3;
                    }
                    lstrcpyA(FoundLine[KeywordsFound],p);
                    KeywordsFound++;
                    break;
                }
            }
        }
    }

    //
    // Look at each line in the template file.
    // If it's a line with a value we respect, make sure the line
    // does not exist in the DOS file. If it exists in the DOS file
    // use the DOS value instead.
    //
    while(fgets(Line,sizeof(Line),TmpFile)) {

        //
        // Isolate the first field in the template line and
        // check against those we found in the DOS file.
        //
        Found = FALSE;
        if(p = IsolateFirstField(Line,&End,&c)) {
            for(i=0; i<KeywordsFound; i++) {
                if(!lstrcmpiA(FoundKeyword[i],p)) {
                    Found = TRUE;
                    break;
                }
            }
        }

        *End = c;
        if(Found) {
            //
            // Use value we found in the dos file.
            //
            fputs(FoundLine[i],NtFile);
        } else {
            //
            // Use line from template file as-is.
            //
            fputs(Line,NtFile);
        }
    }

    b = TRUE;

err3:
    for(i=0; i<KeywordsFound; i++) {
        MyFree(FoundLine[i]);
    }
    fclose(TmpFile);
err2:
    fclose(NtFile);
err1:
    fclose(DosFile);
err0:
    return(b);
}


PSTR
IsolateFirstField(
    IN  PSTR   Line,
    OUT PSTR  *End,
    OUT PCHAR  Terminator
    )

/*++

Routine Description:

    Isolate the first token in a line of config.sys. The first field
    starts at the first non-space/tab character, and is terminated
    by a space/tab, newline, or equals.

Arguments:

    Line - supplies pointer to line whose first field is desired.

    End - receives a pointer to the character that termianted the first
        field. That character will have been overwritten with a nul byte.

    Terminator - receives the character that terminated the first field,
        before we overwrote it with a nul byte.

Return Value:

    Pointer to the first field. If the line is blank, the return value
    will be NULL.

--*/

{
    PSTR p,q;

    //
    // Get start of first field.
    //
    p = Line;
    while((*p == ' ') || (*p == '\t')) {
        p++;
    }

    //
    // If line is empty or bogus, we're done.
    //
    if((*p == 0) || (*p == '\r') || (*p == '\n') || (*p == '=')) {
        return(NULL);
    }

    //
    // Find end of field.
    //
    q = p;
    while(*q && !strchr("\r\n \t=",*q)) {
        q++;
    }
    *End = q;
    *Terminator = *q;
    *q = 0;

    return(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\virtmem.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    virtmem.c

Abstract:

    Routines to configure and set up virtual memory -- pagefiles, etc.

Author:

    Ted Miller (tedm) 22-Apr-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop

//
// What's the ratio of 'beginning' pagefile size to 'max' pagefile size?
//
#define MAX_PAGEFILE_RATIO          (2)

#define MAX_PAGEFILE_SIZEMB         ((2*1024) - 2)

#define TINY_WINDIR_PAGEFILE_SIZE   (2)

//
//  Keys and values names
//
#define  szMemoryManagementKeyPath  L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management"
#define  szPageFileValueName        L"PagingFiles"
#define  szSetupPageFileKeyPath     L"SYSTEM\\Setup\\PageFile"
#define  szSetupKey                 L"SYSTEM\\Setup"
#define  szPageFileKeyName          L"PageFile"


WCHAR ExistingPagefileDrive = 0;
DWORD Zero = 0;
DWORD One = 1;
DWORD Two = 2;
DWORD Three = 3;

//
// Keep AutoReboot as the last entry as we won't be updating that key on
// upgrades.  This is for Stress so we quit setting this key on each upgrade.
//
REGVALITEM CrashDumpValues[] = {{ L"LogEvent"        ,&One,sizeof(DWORD),REG_DWORD },
                                { L"SendAlert"       ,&One,sizeof(DWORD),REG_DWORD },
                                { L"CrashDumpEnabled",&One,sizeof(DWORD),REG_DWORD },
                                { L"AutoReboot"      ,&One,sizeof(DWORD),REG_DWORD }};

VOID
LOGITEM(
    IN PCWSTR p,
    ...
    )
{
    WCHAR str[1024];
    va_list arglist;

    va_start(arglist,p);
    wvsprintf(str,p,arglist);
    va_end(arglist);

    //
    // Used to debug problem on MIPS that was the result of a chip
    // errata, when dividing 64 bit numbers with multiplies pending.
    //
    SetuplogError(
        LogSevInformation,str,0,NULL,NULL);
}


VOID
CalculatePagefileSizes(
    OUT PDWORD PagefileMinMB,
    OUT PDWORD RecommendedPagefileMB,
    OUT PDWORD CrashDumpPagefileMinMB
    )

/*++

Routine Description:

    Calculate various key sizes relating to pagefile size.

Arguments:

    PagefileMinMB - receives the minimum recommended size for a pagefile,
        in MB.

    RecommendedPagefileMB - receives the recommended size for a pagefile,
        in MB.

    CrashDumpPagefileMinMB - receives the size in MB for a pagefile to be
        used for crashdumps.

Return Value:

    None.

--*/

{
    MEMORYSTATUSEX MemoryStatusEx;
    SYSTEM_INFO SystemInfo;
    DWORD       AvailableMB;

    MemoryStatusEx.dwLength = sizeof(MEMORYSTATUSEX);
    GlobalMemoryStatusEx(&MemoryStatusEx);
    GetSystemInfo(&SystemInfo);

    //
    // Figure out how much memory we have available.
    //
    AvailableMB = (DWORD)(MemoryStatusEx.ullTotalPhys / (1024*1024));

    //
    // It's likely that our calculation is off because the BIOS may
    // be eat part of our first MB.  Let's make sure we're mod-4.
    //
    AvailableMB = (AvailableMB + 3) & (0xFFFFFFF8);

    //
    // Set minimum acceptable size for the pagefile.
    //
    *PagefileMinMB = 48;

    //
    // Min size for crash dump pagefile is also physical memory+12mb.
    //
    *CrashDumpPagefileMinMB = AvailableMB + 12;

    //
    // Calculate the recommended size for the pagefile.
    // The recommended size is (memory size * 1.5)mb.
    //
    *RecommendedPagefileMB = AvailableMB + (AvailableMB >> 1);

#if 1
    //
    // Set a Maximum of 2Gig.
    //
    if( *RecommendedPagefileMB > MAX_PAGEFILE_SIZEMB ) {
        *RecommendedPagefileMB = MAX_PAGEFILE_SIZEMB;
    }
#endif

    //
    // If we're doing an upgrade, we're going to retrieve what
    // the user was using for a pagefile size.  We'll take the
    // max of our RecommendedPagefileMB and what the user had.
    //
    if(Upgrade) {
    LONG        Error;
    HKEY        Key;
    DWORD       cbData;
    PWCHAR      Data;
    DWORD       Type;

        //
        //  Get the original page file info from
        //  HKEY_LOCAL_MACHINE\SYSTEM\Setup\PageFile
        //
        Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              szSetupPageFileKeyPath,
                              0,
                              KEY_READ,
                              &Key );

        if( Error == ERROR_SUCCESS ) {
            //
            //  Find out the size of the data to be retrieved
            //
            cbData = 0;
            Error = RegQueryValueEx( Key,
                                     szPageFileValueName,
                                     0,
                                     NULL,
                                     NULL,
                                     &cbData );

            if( Error == ERROR_SUCCESS ) {
                //
                //  Allocate a buffer for the data, and retrieve the data
                //

                Data = (PWCHAR)MyMalloc(cbData);
                if( Data ) {
                    Error = RegQueryValueEx( Key,
                                             szPageFileValueName,
                                             0,
                                             &Type,
                                             ( LPBYTE )Data,
                                             &cbData );
                    if( (Error == ERROR_SUCCESS) ) {
                        //
                        // We got the data.  Take the bigger value.
                        //
                        if( wcsstr( Data, TEXT(" ") ) ) {
                        DWORD ExistingPageFileSize = 0;

                            ExistingPageFileSize = (int)wcstoul(wcsstr( Data, TEXT(" ") ),NULL,10);
                            if( ExistingPageFileSize >= *RecommendedPagefileMB ) {
                                //
                                // The user has a bigger pagefile than we think he needs.
                                // Assume he knows better and take the bigger value.
                                //
                                *RecommendedPagefileMB = ExistingPageFileSize;

                                //
                                // Remember his drive letter too.  This tells us that
                                // the user may already have a decent pagefile and
                                // we don't need to mess with it.
                                //
                                ExistingPagefileDrive = towupper( (WCHAR)Data[0] );

                                //
                                // If it's not valid, nuke the flag.
                                //
                                if( (ExistingPagefileDrive > 'Z') ||
                                    (ExistingPagefileDrive < 'A') ) {
                                    ExistingPagefileDrive = 0;
                                }

                            }
                        }
                    }

                    MyFree( Data );
                }
            }

            RegCloseKey( Key );
        }

        //
        // Delete our record of what the user was previously using
        // for a pagefile.
        //
        Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              szSetupKey,
                              0,
                              MAXIMUM_ALLOWED,
                              &Key );
        if( Error == ERROR_SUCCESS ) {
            RegDeleteKey( Key,
                          szPageFileKeyName );
            RegCloseKey( Key );
        }
    }

}


VOID
BuildVolumeFreeSpaceList(
    OUT DWORD VolumeFreeSpaceMB[26]
    )

/*++

Routine Description:

    Build a list of free space available on each hard drive in the system.

    The space will include space taken up by a file called \pagefile.sys
    on each drive. Existing pagefiles are marked for deletion on the next boot.

Arguments:
    VolumeFreeSpaceMB - receives free space for each of the 26 drives
        potentially describable in the drive letter namespace.
        Entries for drives that do not exist are left alone, so the caller
        should zero out the array before calling this routine.

Return Value:

    None.

--*/

{
    DWORD SectorsPerCluster;
    DWORD BytesPerSector;
    DWORD FreeClusters;
    DWORD TotalClusters;
    DWORD d;
    PWCHAR p;
    ULONGLONG FreeSpace;
    INT DriveNo;
    WIN32_FIND_DATA FindData;
    WCHAR Filename[] = L"?:\\pagefile.sys";
    //
    // Space for logical drive strings. Each is x:\ + nul, and
    // there is an extra nul terminating the list.
    //
    WCHAR Buffer[(26*4)+1];

    //
    // Build up a list of free space on each available hard drive.
    //
    d = GetLogicalDriveStrings(sizeof(Buffer)/sizeof(Buffer[0]),Buffer);
    CharUpperBuff(Buffer,d);

    for(p=Buffer; *p; p+=lstrlen(p)+1) {

        DriveNo = (*p) - L'A';

        if((DriveNo >= 0) && (DriveNo < 26) && (p[1] == L':')
        && (MyGetDriveType(*p) == DRIVE_FIXED)
        && GetDiskFreeSpace(p,&SectorsPerCluster,&BytesPerSector,&FreeClusters,&TotalClusters)) {

            LOGITEM(
                L"BuildVolumeFreeSpaceList: %s, spc=%u, bps=%u, freeclus=%u, totalclus=%u\r\n",
                p,
                SectorsPerCluster,
                BytesPerSector,
                FreeClusters,
                TotalClusters
                );

            FreeSpace = UInt32x32To64(BytesPerSector * SectorsPerCluster, FreeClusters);

            LOGITEM(
                L"BuildVolumeFreeSpaceList: %s, FreeSpace = %u%u\r\n",
                p,
                (DWORD)(FreeSpace >> 32),
                (DWORD)FreeSpace
                );


            //
            // If there's already a page file here, include its size in the free space
            // for the drive. Delete the existing pagefile on the next reboot.
            //
            Filename[0] = *p;
            if(FileExists(Filename,&FindData)) {
                FreeSpace += FindData.nFileSizeLow;

                LOGITEM(
                    L"BuildVolumeFreeSpaceList: %s had %u byte pagefile, new FreeSpace = %u%u\r\n",
                    p,
                    FindData.nFileSizeLow,
                    (DWORD)(FreeSpace >> 32),
                    (DWORD)FreeSpace
                    );

                MoveFileEx(Filename,NULL,MOVEFILE_DELAY_UNTIL_REBOOT);
            }

            VolumeFreeSpaceMB[DriveNo] = (DWORD)(FreeSpace / (1024*1024));

            LOGITEM(L"BuildVolumeFreeSpaceList: Free space on %s is %u MB\r\n",p,VolumeFreeSpaceMB[DriveNo]);
        }
    }
}


BOOL
SetUpVirtualMemory(
    VOID
    )

/*++

Routine Description:

    Configure a pagefile. If setting up a server, we attempt to set up a pagefile
    suitable for use with crashdump, meaning it has to be at least the size of
    system memory, and has to go on the nt drive. Otherwise we attempt to place
    a pagefile on the nt drive if there's enough space, and if that fails, we
    place it on any drive with any space.

Arguments:

    None.

Return Value:

    Boolean value indicating outcome.

--*/

{
#define SYS_DRIVE_FREE_SPACE_BUFFER (100)
#define ALT_DRIVE_FREE_SPACE_BUFFER (25)
#define AnswerBufLen (4*MAX_PATH)

#define RECORD_VM_SETTINGS( Drive, Size, Buffer ) {                                                                              \
                                            PagefileDrive = Drive;                                                               \
                                            PagefileSizeMB = Size;                                                               \
                                            MaxPagefileSizeMB = __min( (VolumeFreeSpaceMB[PagefileDrive] - Buffer),              \
                                                                       PagefileSizeMB * MAX_PAGEFILE_RATIO );                    \
                                                                                                                                 \
                                            MaxPagefileSizeMB = __max( MaxPagefileSizeMB, PagefileSizeMB );                      \
                                                                                                                                 \
                                            if( PagefileSizeMB >= CrashDumpPagefileMinMB ) {                                     \
                                                EnableCrashDump = TRUE;                                                          \
                                            }                                                                                    \
                                           }


    DWORD VolumeFreeSpaceMB[26];
    DWORD PagefileMinMB;
    DWORD RecommendedPagefileMB;
    DWORD CrashDumpPagefileMinMB;
    WCHAR WindowsDirectory[MAX_PATH];
    UINT WindowsDriveNo,DriveNo;
    UINT PagefileDrive;
    BOOL EnableCrashDump;
    INT MaxSpaceDrive;
    DWORD PagefileSizeMB;
    DWORD MaxPagefileSizeMB;
    WCHAR PagefileTemplate[128];
    PWSTR PagefileSpec;
    DWORD d;
    BOOL b;
    BOOL UseExistingPageFile = FALSE;
    WCHAR AnswerFile[AnswerBufLen];
    WCHAR Answer[AnswerBufLen];
    WCHAR DriveName[] = L"?:\\";


    LOGITEM(L"SetUpVirtualMemory: ENTER\r\n");

    if( !GetWindowsDirectory(WindowsDirectory,MAX_PATH) ) {
        return FALSE;
    }
    WindowsDriveNo = (UINT)PtrToUlong(CharUpper((PWSTR)WindowsDirectory[0])) - (UINT)L'A';
    PagefileDrive = -1;
    EnableCrashDump = FALSE;

    //
    // Take care of some preliminaries.
    //
    CalculatePagefileSizes(
        &PagefileMinMB,
        &RecommendedPagefileMB,
        &CrashDumpPagefileMinMB
        );

    ZeroMemory(VolumeFreeSpaceMB,sizeof(VolumeFreeSpaceMB));
    BuildVolumeFreeSpaceList(VolumeFreeSpaceMB);

    //
    // Now figure out how large and where the pagefile will be.
    //

    //
    // ================================================================
    // 0.  See if the user already has a reasonable pagefile.
    // ================================================================
    //
    if( (Upgrade) &&
        (ExistingPagefileDrive) ) {

        //
        // See if there's enough room on the existing drive
        // for the pagefile.
        //
        if( VolumeFreeSpaceMB[(UINT)(ExistingPagefileDrive - L'A')] > (RecommendedPagefileMB + ALT_DRIVE_FREE_SPACE_BUFFER) ) {
            //
            // He's already got something that will work.  We're done.
            //
            LOGITEM(L"SetUpVirtualMemory: loc 0 - keep user's pagefile settings.\r\n");

            UseExistingPageFile = TRUE;

            PagefileDrive = (UINT)(ExistingPagefileDrive - L'A');
        }
    }


    //
    // ================================================================
    // 1.  See if the NT drive has enough space for the MAX pagefile
    //     size.
    // ================================================================
    //
    if(PagefileDrive == -1) {

        if( VolumeFreeSpaceMB[WindowsDriveNo] > ((RecommendedPagefileMB * MAX_PAGEFILE_RATIO) + SYS_DRIVE_FREE_SPACE_BUFFER) ) {

            LOGITEM(L"SetUpVirtualMemory: loc 1\r\n");

            //
            // Record our settings.
            //
            RECORD_VM_SETTINGS( WindowsDriveNo, RecommendedPagefileMB, SYS_DRIVE_FREE_SPACE_BUFFER );
        }
    }

    //
    // ================================================================
    // 2.  See if any drive has enough space for the MAX pagefile
    //     size.
    // ================================================================
    //
    if(PagefileDrive == -1) {

        for(DriveNo=0; DriveNo<26; DriveNo++) {

            if( (DriveNo != WindowsDriveNo) &&
                (VolumeFreeSpaceMB[DriveNo] > ((RecommendedPagefileMB * MAX_PAGEFILE_RATIO) + ALT_DRIVE_FREE_SPACE_BUFFER)) ) {

                //
                // He's got the space, but let's make sure he's not removable.
                //
                DriveName[0] = DriveNo + L'A';
                if( GetDriveType(DriveName) != DRIVE_REMOVABLE ) {

                    LOGITEM(L"SetUpVirtualMemory: loc 2 - found space on driveno %u\r\n",DriveNo);

                    //
                    // Record our settings.
                    //
                    RECORD_VM_SETTINGS( DriveNo, RecommendedPagefileMB, ALT_DRIVE_FREE_SPACE_BUFFER );

                    break;
                }
            }
        }
    }

    //
    // ================================================================
    // 3.  See if the NT drive has enough space for the recommended pagefile
    //     size.
    // ================================================================
    //
    if(PagefileDrive == -1) {

        if( VolumeFreeSpaceMB[WindowsDriveNo] > (RecommendedPagefileMB + SYS_DRIVE_FREE_SPACE_BUFFER) ) {

            LOGITEM(L"SetUpVirtualMemory: loc 3\r\n");

            //
            // Record our settings.
            //
            RECORD_VM_SETTINGS( WindowsDriveNo, RecommendedPagefileMB, SYS_DRIVE_FREE_SPACE_BUFFER );

        }
    }

    //
    // ================================================================
    // 4.  See if any drive has enough space for the recommended pagefile
    //     size.
    // ================================================================
    //
    if(PagefileDrive == -1) {

        for(DriveNo=0; DriveNo<26; DriveNo++) {

            if( (DriveNo != WindowsDriveNo) &&
                (VolumeFreeSpaceMB[DriveNo] > (RecommendedPagefileMB + ALT_DRIVE_FREE_SPACE_BUFFER)) ) {

                //
                // He's got the space, but let's make sure he's not removable.
                //
                DriveName[0] = DriveNo + L'A';
                if( GetDriveType(DriveName) != DRIVE_REMOVABLE ) {

                    LOGITEM(L"SetUpVirtualMemory: loc 4 - found space on driveno %u\r\n",DriveNo);

                    //
                    // Record our settings.
                    //
                    RECORD_VM_SETTINGS( DriveNo, RecommendedPagefileMB, ALT_DRIVE_FREE_SPACE_BUFFER );

                    break;
                }
            }
        }
    }

    //
    // ================================================================
    // 5.  See if the NT drive has enough space for the CrashDump pagefile
    //     size.
    // ================================================================
    //
    if(PagefileDrive == -1) {

        if( VolumeFreeSpaceMB[WindowsDriveNo] > (CrashDumpPagefileMinMB + SYS_DRIVE_FREE_SPACE_BUFFER) ) {

            LOGITEM(L"SetUpVirtualMemory: loc 5\r\n");

            //
            // Record our settings.
            //
            RECORD_VM_SETTINGS( WindowsDriveNo, CrashDumpPagefileMinMB, SYS_DRIVE_FREE_SPACE_BUFFER );
        }
    }

    //
    // ================================================================
    // 6.  See if any drive has enough space for the CrashDump pagefile
    //     size.
    // ================================================================
    //
    if(PagefileDrive == -1) {

        for(DriveNo=0; DriveNo<26; DriveNo++) {

            if( (DriveNo != WindowsDriveNo) &&
                (VolumeFreeSpaceMB[DriveNo] > (CrashDumpPagefileMinMB + ALT_DRIVE_FREE_SPACE_BUFFER)) ) {

                //
                // He's got the space, but let's make sure he's not removable.
                //
                DriveName[0] = DriveNo + L'A';
                if( GetDriveType(DriveName) != DRIVE_REMOVABLE ) {

                    LOGITEM(L"SetUpVirtualMemory: loc 6 - found space on driveno %u\r\n",DriveNo);

                    //
                    // Record our settings.
                    //
                    RECORD_VM_SETTINGS( DriveNo, CrashDumpPagefileMinMB, ALT_DRIVE_FREE_SPACE_BUFFER);

                    break;
                }
            }
        }
    }

    //
    // ================================================================
    // 7.  See if the NT drive has enough space for the minimum pagefile
    //     size.
    // ================================================================
    //
    if(PagefileDrive == -1) {

        if( VolumeFreeSpaceMB[WindowsDriveNo] > (PagefileMinMB + SYS_DRIVE_FREE_SPACE_BUFFER) ) {

            LOGITEM(L"SetUpVirtualMemory: loc 7\r\n");

            //
            // Record our settings.
            //
            RECORD_VM_SETTINGS( WindowsDriveNo, PagefileMinMB, SYS_DRIVE_FREE_SPACE_BUFFER );
        }
    }

    //
    // ================================================================
    // 8.  See if any drive has enough space for the minimum pagefile
    //     size.
    // ================================================================
    //
    if(PagefileDrive == -1) {

        for(DriveNo=0; DriveNo<26; DriveNo++) {

            if( (DriveNo != WindowsDriveNo) &&
                (VolumeFreeSpaceMB[DriveNo] > (PagefileMinMB + ALT_DRIVE_FREE_SPACE_BUFFER)) ) {

                //
                // He's got the space, but let's make sure he's not removable.
                //
                DriveName[0] = DriveNo + L'A';
                if( GetDriveType(DriveName) != DRIVE_REMOVABLE ) {

                    LOGITEM(L"SetUpVirtualMemory: loc 8 - found space on driveno %u\r\n",DriveNo);

                    //
                    // Record our settings.
                    //
                    RECORD_VM_SETTINGS( DriveNo, PagefileMinMB, ALT_DRIVE_FREE_SPACE_BUFFER );

                    break;
                }
            }
        }
    }

    //
    // ================================================================
    // 9.  Pick the drive with the most free space.
    // ================================================================
    //
    if(PagefileDrive == -1) {

        MaxSpaceDrive = 0;
        for(DriveNo=0; DriveNo<26; DriveNo++) {
            if(VolumeFreeSpaceMB[DriveNo] > VolumeFreeSpaceMB[MaxSpaceDrive]) {
                MaxSpaceDrive = DriveNo;
            }
        }

        if( VolumeFreeSpaceMB[MaxSpaceDrive] > ALT_DRIVE_FREE_SPACE_BUFFER ) {


            //
            // We're desperate here, so don't bother checking if he's
            // removable.
            //
            LOGITEM(L"SetUpVirtualMemory: loc 9 - MaxSpaceDrive is %u\r\n",MaxSpaceDrive);

            //
            // Record our settings.
            //
            RECORD_VM_SETTINGS( MaxSpaceDrive, VolumeFreeSpaceMB[MaxSpaceDrive] - ALT_DRIVE_FREE_SPACE_BUFFER, 0 );
        }
    }


    //
    // If we still don't have space for a pagefile, the user is out of luck.
    //
    if(PagefileDrive == -1) {

        LOGITEM(L"SetUpVirtualMemory: loc 10 -- out of luck\r\n");

        PagefileSpec = NULL;
        b = FALSE;

        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_PAGEFILE_FAIL,NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_NO_PAGING_DRIVES,
            NULL,NULL);

    } else {

        b = TRUE;

        PagefileSpec = PagefileTemplate;
        _snwprintf(
            PagefileTemplate,
            sizeof(PagefileTemplate)/sizeof(PagefileTemplate[0]),
            L"%c:\\pagefile.sys %u %u",
            PagefileDrive + L'A',
            PagefileSizeMB,
            MaxPagefileSizeMB
            );

    }

    if( b ) {
        //
        // Set pagefile in registry.  I only want to do this in the
        // case of clean installs, and on upgrades if the existing
        // pagefile wasn't big enough.  In the case of upgrades, if
        // the existing pagefile was big enough, then we will have
        // set UseExistingPageFile, which will tell us to leave the
        // registry settings as is.
        //
        if( !UseExistingPageFile ) {
            d = pSetupSetArrayToMultiSzValue(
                    HKEY_LOCAL_MACHINE,
                    szMemoryManagementKeyPath,
                    szPageFileValueName,
                    &PagefileSpec,
                    PagefileSpec ? 1 : 0
                    );

            if(d == NO_ERROR) {
                if(b) {
                    SetuplogError(
                        LogSevInformation,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_CREATED_PAGEFILE,
                        PagefileDrive+L'A',
                        PagefileSizeMB,
                        NULL,NULL);
                }
            } else {
                SetuplogError(
                    LogSevWarning,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_PAGEFILE_FAIL, NULL,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_X_RETURNED_WINERR,
                    szSetArrayToMultiSzValue,
                    d,
                    NULL,NULL);
            }



            //
            // Make sure there's at least a small pagefile
            // on the windows drive.  Ignore errors here.
            //
            if( (PagefileDrive != WindowsDriveNo) &&
                (VolumeFreeSpaceMB[WindowsDriveNo] > TINY_WINDIR_PAGEFILE_SIZE) ) {

                //
                // There's not.  Write a second string into our buffer just past
                // the first string (remember this will become a REG_MULTI_SZ
                //
                _snwprintf(
                    PagefileTemplate,
                    sizeof(PagefileTemplate)/sizeof(PagefileTemplate[0]),
                    L"%c:\\pagefile.sys %u %u",
                    WindowsDriveNo + L'A',
                    TINY_WINDIR_PAGEFILE_SIZE,
                    TINY_WINDIR_PAGEFILE_SIZE
                    );

                pSetupAppendStringToMultiSz(
                        HKEY_LOCAL_MACHINE,
                        szMemoryManagementKeyPath,
                        0,
                        szPageFileValueName,
                        PagefileTemplate,
                        TRUE
                        );
            }


            b = b && (d == NO_ERROR);
        }
    }


    //
    // Now set the crashdump.
    //
    // The proper settings are as follows:
    //
    // Server Upgrades
    // ===============
    //     existing setting          new setting
    //         0                         3
    //         1                         1
    //
    // Workstation Upgrades
    // ====================
    //     existing setting          new setting
    //         0                         3
    //         1                         1
    //
    // Server Clean Install
    // ====================
    //     new setting
    //         1 iff pagefile < MAX_PAGEFILE_SIZEMB else 2
    //
    // Workstation Clean Install
    // =========================
    //     new setting
    //         3
    //
    //
    // Where:
    // 0 - no crash dump
    // 1 - dump all memory to crash file
    // 2 - dump kernel memory to crash file
    // 3 - dump a select set of memory (amounting to 64K) to crash file
    //


    //
    // See if the user has asked us to go a particular way
    // on the crashdump settings.
    //

    GetSystemDirectory(AnswerFile,MAX_PATH);
    pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);
    GetPrivateProfileString( TEXT("Unattended"),
                             TEXT("CrashDumpSetting"),
                             pwNull,
                             Answer,
                             AnswerBufLen,
                             AnswerFile );
    if( lstrcmp( pwNull, Answer ) ) {
        d = wcstoul(Answer,NULL,10);

        if( d <= Three ) {
            CrashDumpValues[2].Data = &d;
        } else {
            CrashDumpValues[2].Data = &Three;
        }
    } else {

        //
        // No unattended values.  Set it manually.
        //



        //
        // Take care of clean installs first.
        //
        if( !Upgrade ) {
            if( ProductType == PRODUCT_WORKSTATION ) {
                CrashDumpValues[2].Data = &Three;
            } else {
                if( PagefileSizeMB >= MAX_PAGEFILE_SIZEMB ) {
                    CrashDumpValues[2].Data = &Two;
                } else {
                    CrashDumpValues[2].Data = &One;
                }
            }
        } else {
            //
            // Upgrade.
            //
            // Here, we need to go retrieve the current value to
            // see what's there now.  This will tell us how to migrate.
            //

            HKEY        Key;
            DWORD       cbData;
            DWORD       ExistingCrashDumpSetting = 0;
            DWORD       Type;

            d = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              L"System\\CurrentControlSet\\Control\\CrashControl",
                              0,
                              KEY_READ,
                              &Key );

            if( d == ERROR_SUCCESS ) {
                //
                //  Find out the size of the data to be retrieved
                //
                cbData = sizeof(DWORD);
                d = RegQueryValueEx( Key,
                                     CrashDumpValues[2].Name,
                                     0,
                                     &Type,
                                     ( LPBYTE )&ExistingCrashDumpSetting,
                                     &cbData );
                RegCloseKey( Key );
            }

            //
            // Make sure ExistingCrashDumpSetting is set.
            //
            if( d != ERROR_SUCCESS ) {
                ExistingCrashDumpSetting = (ProductType == PRODUCT_WORKSTATION) ? 0 : 1;
            }

            if( ProductType == PRODUCT_WORKSTATION ) {
                if( ExistingCrashDumpSetting == 0 ) {
                    CrashDumpValues[2].Data = &Three;
                } else {
                    CrashDumpValues[2].Data = &One;
                }
            } else {
                if( ExistingCrashDumpSetting == 0 ) {
                    CrashDumpValues[2].Data = &Three;
                } else {
                    CrashDumpValues[2].Data = &One;
                }
            }
        }
    }

#ifdef PRERELEASE
    if( Upgrade ) {
        d = SetGroupOfValues(
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\\Control\\CrashControl",
                CrashDumpValues,
                sizeof(CrashDumpValues)/sizeof(CrashDumpValues[0]) - 1
                );
    } else {
        d = SetGroupOfValues(
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\\Control\\CrashControl",
                CrashDumpValues,
                sizeof(CrashDumpValues)/sizeof(CrashDumpValues[0])
                );
    }
#else
    d = SetGroupOfValues(
            HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Control\\CrashControl",
            CrashDumpValues,
            sizeof(CrashDumpValues)/sizeof(CrashDumpValues[0])
            );
#endif

    if(d == NO_ERROR) {
        SetuplogError(
            LogSevInformation,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CRASHDUMPOK,
            NULL,NULL);
    } else {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CRASHDUMPFAIL, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_STRING,
            szSetGroupOfValues,
            d,
            NULL,NULL);

        b = FALSE;
    }


    LOGITEM(L"SetUpVirtualMemory: EXIT (%u)\r\n",b);

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\_setup_browser.cxx ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>
extern "C" {
    #include <rpcutil.h>
    #include <setup_browser.c>
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\amd64\bootini.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    bootini.c

Abstract:

    Routines relating to boot.ini.

Author:

    Ted Miller (tedm) 4-Apr-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop


BOOL
ChangeBootTimeoutBootIni(
    IN UINT Timeout
    )

/*++

Routine Description:

    Changes the boot countdown value in boot.ini.

Arguments:

    Timeout - supplies new timeout value, in seconds.

Return Value:

    None.

--*/

{

    HFILE hfile;
    ULONG FileSize;
    PUCHAR buf = NULL,p1,p2;
    BOOL b;
    CHAR TimeoutLine[256];
    CHAR szBootIni[] = "?:\\BOOT.INI";

    szBootIni[0] = (CHAR)x86SystemPartitionDrive;
    wsprintfA(TimeoutLine,"timeout=%u\r\n",Timeout);

    //
    // Open and read boot.ini.
    //

    b = FALSE;
    hfile = _lopen(szBootIni,OF_READ);
    if(hfile != HFILE_ERROR) {
        FileSize = _llseek(hfile,0,2);
        if(FileSize != (ULONG)(-1)) {
            if((_llseek(hfile,0,0) != -1)
            && (buf = MyMalloc(FileSize+1))
            && (_lread(hfile,buf,FileSize) != (UINT)(-1)))
            {
                buf[FileSize] = 0;
                b = TRUE;
            }
        }

        _lclose(hfile);
    }

    if(!b) {
        if(buf) {
            MyFree(buf);
        }

        return(FALSE);
    }

    if(!(p1 = strstr(buf,"timeout"))) {
        MyFree(buf);
        return(FALSE);
    }

    if(p2 = strchr(p1,'\n')) {
        p2++;       // skip NL.

    } else {
        p2 = buf + FileSize;
    }

    SetFileAttributesA(szBootIni,FILE_ATTRIBUTE_NORMAL);
    hfile = _lcreat(szBootIni,0);
    if(hfile == HFILE_ERROR) {
        MyFree(buf);
        return(FALSE);
    }

    //
    // Write:
    //
    // 1) the first part, start=buf, len=p1-buf
    // 2) the timeout line
    // 3) the last part, start=p2, len=buf+FileSize-p2
    //

    b =  ((_lwrite(hfile, buf, (UINT)(p1 - buf)) != (UINT)(-1))
      &&  (_lwrite(hfile, TimeoutLine,strlen(TimeoutLine)) != (UINT)(-1))
      &&  (_lwrite(hfile, p2, (UINT)(buf + FileSize - p2)) != (UINT)(-1)));

    _lclose(hfile);
    MyFree(buf);

    //
    // Make boot.ini archive, read only, and system.
    //
    SetFileAttributesA(
        szBootIni,
        FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_HIDDEN);

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\amd64\pcihal.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    pcihal.c

Abstract:

    Routines for the Pci Hal property page.

Author:

    Santosh Jodh 10-July-1998

--*/

#include "setupp.h"
#pragma hdrstop
#include <windowsx.h>

#define MSG_SIZE    2048

#define Allocate(n) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, n)
#define Release(p)  HeapFree(GetProcessHeap(), 0, (LPVOID)p)

typedef struct _PciHalPropData PCIHALPROPDATA, *PPCIHALPROPDATA;

struct _PciHalPropData {
    HKEY                LocalMachine;
    BOOLEAN             CloseKey;
    DWORD               Options;
    HDEVINFO            DeviceInfoSet;
    PSP_DEVINFO_DATA    DeviceInfoData;    
};  

const DWORD gPciPropHelpIds[] = 
{
    IDC_PCIHAL_ICON,        (DWORD)-1,              // Icon
    IDC_PCIHAL_DEVDESC,     (DWORD)-1,              // Name of PC
    IDC_PCIHAL_ENABLE,      IDH_IRQ_ENABLE,         // Enable IRQ Routing
    IDC_PCIHAL_MSSPEC,      IDH_IRQ_MSSPEC,         // Use $PIR table
    IDC_PCIHAL_REALMODE,    IDH_IRQ_REALMODE,       // Use table from Real-mode BIOS call
    IDC_PCIHAL_SETDEFAULTS, IDH_IRQ_SETDEFAULTS,    // Set defaults for options
    IDC_PCIHAL_RESULTS,     IDH_IRQ_RESULTS,        // Status information    
    0,0
};

//
// Table used to translate status codes into string ids.
//
UINT gStatus[PIR_STATUS_MAX + 1] =              {   IDS_PCIHAL_ERROR, 
                                                    IDS_PCIHAL_ENABLED, 
                                                    IDS_PCIHAL_DISABLED,
                                                    IDS_PCIHAL_NOSTATUS
                                                };
UINT gTableStatus[PIR_STATUS_TABLE_MAX] =       {   IDS_PCIHAL_TABLE_REGISTRY, 
                                                    IDS_PCIHAL_TABLE_MSSPEC,
                                                    IDS_PCIHAL_TABLE_REALMODE,
                                                    IDS_PCIHAL_TABLE_NONE,
                                                    IDS_PCIHAL_TABLE_ERROR,                                                    
                                                    IDS_PCIHAL_TABLE_BAD,
                                                    IDS_PCIHAL_TABLE_SUCCESS
                                                };
UINT gMiniportStatus[PIR_STATUS_MINIPORT_MAX] = {   IDS_PCIHAL_MINIPORT_NORMAL, 
                                                    IDS_PCIHAL_MINIPORT_COMPATIBLE, 
                                                    IDS_PCIHAL_MINIPORT_OVERRIDE, 
                                                    IDS_PCIHAL_MINIPORT_NONE,
                                                    IDS_PCIHAL_MINIPORT_ERROR,                                                    
                                                    IDS_PCIHAL_MINIPORT_NOKEY,
                                                    IDS_PCIHAL_MINIPORT_SUCCESS,
                                                    IDS_PCIHAL_MINIPORT_INVALID
                                                };

PCIHALPROPDATA  gPciHalPropData = {0};

VOID
PciHalSetControls (
    IN HWND Dialog,
    IN DWORD Options,
    IN DWORD Attributes
    )

/*++

    Routine Description:

        This routine sets the controls on the Irq Routing page to the
        specified options.

    Input Parameters:

        Dialog - Window handle for the property sheet page.

        Options -  Pci Irq Routing options to be displayed.
        
    Return Value:

        None.
        
--*/

{
    BOOL enabled = FALSE;

    //
    // Enable the buttons depending on the options.
    //
    if (Options & PIR_OPTION_ENABLED)
    {
        enabled = TRUE;
        CheckDlgButton(Dialog, IDC_PCIHAL_ENABLE, 1);
    }

    CheckDlgButton(Dialog, IDC_PCIHAL_MSSPEC, Options & PIR_OPTION_MSSPEC);
    CheckDlgButton(Dialog, IDC_PCIHAL_REALMODE, Options & PIR_OPTION_REALMODE);
    

    //
    // Gray the windows not meaningful.
    //    
    EnableWindow(GetDlgItem(Dialog, IDC_PCIHAL_ENABLE), !(Attributes & PIR_OPTION_ENABLED));
    EnableWindow(GetDlgItem(Dialog, IDC_PCIHAL_SETDEFAULTS), !(Attributes & PIR_OPTION_ENABLED));
    EnableWindow(GetDlgItem(Dialog, IDC_PCIHAL_MSSPEC), enabled && !(Attributes & PIR_OPTION_MSSPEC));
    EnableWindow(GetDlgItem(Dialog, IDC_PCIHAL_REALMODE), enabled && !(Attributes & PIR_OPTION_REALMODE));

}

LPTSTR
PciHalGetDescription (
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData
    )

/*++

    Routine Description:

        This routine allocates memory and returns the device description
        for the specified device.

    Input Parameters:

        DeviceInfoSet - For the device.

        DeviceInfoData - For the device.

    Return Value:

        Pointer to the description iff successful. Else NULL.
        
--*/

{
    LPTSTR desc;
    DWORD   size;
    
    desc = NULL;
    
    //
    // Get the size of the description for this device.
    //
    size = 0;
    SetupDiGetDeviceRegistryProperty(   DeviceInfoSet,
                                        DeviceInfoData,
                                        SPDRP_DEVICEDESC,
                                        NULL,
                                        NULL,
                                        0,
                                        &size);

    if (size != 0)
    {
        //
        // Account for the terminating NULL character.
        //
        size++;
        
        //
        // Allocate memory for the device description.
        //
        desc = Allocate(size * sizeof(TCHAR));

        if (desc != NULL)
        {

            //
            // Get the device description.
            //
            if (SetupDiGetDeviceRegistryProperty(   DeviceInfoSet,
                                                    DeviceInfoData,
                                                    SPDRP_DEVICEDESC,
                                                    NULL,
                                                    (PBYTE)desc,
                                                    size * sizeof(TCHAR),
                                                    &size) == FALSE)
            {
                Release(desc);
                desc = NULL;
            }
        }
    }

    return desc;
}

LPTSTR
PciHalGetStatus (
    IN DWORD Status,
    IN DWORD TableStatus,
    IN DWORD MiniportStatus
    )

/*++

    Routine Description:

        This routine converts the different status codes into
        a status string and returns the pointer to the string.
        The caller should free the memory when done using this
        string.

    Input Parameters:

        Status - Pci Irq Routing status.

        TableStatus - Pci Irq Routing Table status. Lower WORD
        indicates the source of the table. The upper WORD indicates
        the table processing status.

        MiniportStatus - Pci Irq Routing Miniport status. Lower
        WORD indicates the source of the miniport. The upper WORD
        indicates the miniport processing status.

    Return Value:

        Pointer to the status string iff successful. Else NULL.
        
--*/

{
    LPTSTR   status;
    TCHAR   temp[128];

    status = Allocate(MSG_SIZE * sizeof(TCHAR));
    if (status)
    {
        //
        // Get the status about Pci Irq Routing.
        //
        LoadString(MyModuleHandle, gStatus[Status], status, MSG_SIZE);        

        //
        // Get the status about the source of Pci Irq Routing Table.
        //
        if ((TableStatus & 0xFFFF) < PIR_STATUS_TABLE_MAX)
        {
            lstrcat(status, L"\r\n\r\n");
            LoadString(MyModuleHandle, gTableStatus[TableStatus & 0xFFFF], temp, sizeof(temp)/sizeof(temp[0]));
            lstrcat(status, temp);
        }

        //
        // Get the status about the Pci Irq Routing table.
        //
        TableStatus >>= 16;
        if (TableStatus < PIR_STATUS_TABLE_MAX)
        {
            lstrcat(status, L"\r\n\r\n");
            LoadString(MyModuleHandle, gTableStatus[TableStatus], temp, sizeof(temp) / sizeof(TCHAR));
            lstrcat(status, temp);
        }

        //
        // Get the status about the source of the miniport.
        //
        if ((MiniportStatus & 0xFFFF) < PIR_STATUS_MINIPORT_MAX)
        {
            lstrcat(status, L"\r\n\r\n");
            LoadString(MyModuleHandle, gMiniportStatus[MiniportStatus & 0xFFFF], temp, sizeof(temp) / sizeof(TCHAR));
            lstrcat(status, temp);
        }

        //
        // Get the status about the miniport status.
        //
        MiniportStatus >>= 16;
        if (MiniportStatus < PIR_STATUS_MINIPORT_MAX)
        {
            lstrcat(status, L"\r\n\r\n");
            LoadString(MyModuleHandle, gMiniportStatus[MiniportStatus], temp, sizeof(temp) / sizeof(TCHAR));
            lstrcat(status, temp);
        }
    }

    return status;
}

BOOL
PciHalOnInitDialog (
    IN HWND Dialog,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

    Routine Description:

        This routine initializes the property sheet page on creation.
        
    Input Paramters:

        Dialog - Window handle for the property sheet page.

        wParam - wParam of the WM_INITDIALOG message.

        lParam - Pointer to the property sheet page.
        
    Return Value:

        TRUE.
        
--*/

{   
    PPCIHALPROPDATA             pciHalPropData;
    HKEY                        hKey;
    DWORD                       size;    
    DWORD                       status;
    DWORD                       tableStatus;
    DWORD                       miniportStatus;
    DWORD                       attributes;
    HICON                       hIconOld;
    HICON                       hIconNew;
    INT                         iconIndex;
    LPTSTR                      desc;
    SP_DEVINFO_LIST_DETAIL_DATA details;
    
    pciHalPropData = (PPCIHALPROPDATA)((LPPROPSHEETPAGE)lParam)->lParam;
    //
    // Read the Pci Irq Routing options and status from the registry.
    //
    pciHalPropData->Options = 0;
    status = PIR_STATUS_MAX;
    tableStatus = PIR_STATUS_TABLE_MAX | (PIR_STATUS_TABLE_MAX << 16);
    miniportStatus = PIR_STATUS_MINIPORT_MAX | (PIR_STATUS_MINIPORT_MAX << 16);
    details.cbSize = sizeof(SP_DEVINFO_LIST_DETAIL_DATA);
    attributes = PIR_OPTION_ENABLED | PIR_OPTION_MSSPEC | PIR_OPTION_REALMODE;
    if (SetupDiGetDeviceInfoListDetail(pciHalPropData->DeviceInfoSet, &details)) {

        if (RegConnectRegistry((details.RemoteMachineName[0] == TEXT('\0'))? NULL : details.RemoteMachineName, HKEY_LOCAL_MACHINE, &pciHalPropData->LocalMachine) == ERROR_SUCCESS) {

            pciHalPropData->CloseKey = TRUE;
            if (RegOpenKeyEx(pciHalPropData->LocalMachine, REGSTR_PATH_PCIIR, 0, KEY_READ, &hKey) == ERROR_SUCCESS) 
            { 
                size = sizeof(pciHalPropData->Options);
                RegQueryValueEx(hKey, REGSTR_VAL_OPTIONS, NULL, NULL, (LPBYTE)&pciHalPropData->Options, &size);

                size = sizeof(status);
                RegQueryValueEx(hKey, REGSTR_VAL_STAT, NULL, NULL, (LPBYTE)&status, &size);

                size = sizeof(tableStatus);
                RegQueryValueEx(hKey, REGSTR_VAL_TABLE_STAT, NULL, NULL, (LPBYTE)&tableStatus, &size);

                size = sizeof(miniportStatus);
                RegQueryValueEx(hKey, REGSTR_VAL_MINIPORT_STAT, NULL, NULL, (LPBYTE)&miniportStatus, &size);

                RegCloseKey(hKey);
            }

            //
            // Gray out the controls if the user does not have READ+WRITE access to the REGSTR_PATH_PCIIR. 
            //

            if (RegOpenKeyEx(pciHalPropData->LocalMachine, REGSTR_PATH_PCIIR, 0, KEY_READ | KEY_WRITE, &hKey) == ERROR_SUCCESS) {

                RegCloseKey(hKey);
                attributes = 0;
                if (RegOpenKeyEx(pciHalPropData->LocalMachine, REGSTR_PATH_BIOSINFO L"\\PciIrqRouting", 0, KEY_READ, &hKey) == ERROR_SUCCESS) { 

                    size = sizeof(attributes);
                    RegQueryValueEx(hKey, L"Attributes", NULL, NULL, (LPBYTE)&attributes, &size);
                    RegCloseKey(hKey);
                }
            }
        }
    }

    //
    // Set the class icon.
    //
    if (SetupDiLoadClassIcon(   &pciHalPropData->DeviceInfoData->ClassGuid, 
                                &hIconNew, 
                                &iconIndex) == TRUE)
    {
        hIconOld = (HICON)SendDlgItemMessage(   Dialog, 
                                                IDC_PCIHAL_ICON, 
                                                STM_SETICON,
                                                (WPARAM)hIconNew,
                                                0);
        if (hIconOld)                                                
        {
            DestroyIcon(hIconOld);
        }
    }

    //
    // Set the device description.
    //
    desc = PciHalGetDescription(pciHalPropData->DeviceInfoSet, pciHalPropData->DeviceInfoData);
    if (desc)
    {
        SetDlgItemText(Dialog, IDC_PCIHAL_DEVDESC, desc);
        Release(desc);
    }

    //
    // Set the initial state of the controls.
    //
    PciHalSetControls(Dialog, pciHalPropData->Options, attributes);

    //
    // Display status.
    //
    desc = PciHalGetStatus(status, tableStatus, miniportStatus);
    if (desc)
    {
        SetDlgItemText(Dialog, IDC_PCIHAL_RESULTS, desc);
        Release(desc);
    }

    //
    // Let the system set the focus.
    //
    
    return TRUE;
    }

BOOL
PciHalOnCommand (
    IN HWND Dialog,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

    Routine Description:

        This routine handles the message when the user modifies something
        on the property sheet page.

    Input Parameters:

        Dialog - Window handle for the property sheet page.

        wParam - wParam of the WM_COMMAND message.

        lParam - lParam of the WM_COMMAND message.
        
    Return Value:

        TRUE if this function handles the message. Else FALSE.
    
--*/

{
    BOOL status;
    BOOL enabled;

    status = FALSE;
    
    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {
        case IDC_PCIHAL_SETDEFAULTS:

            //
            // Set the controls to the default value.
            //
            status = TRUE;
            PciHalSetControls(Dialog, PIR_OPTION_DEFAULT, 0);
            break;

        case IDC_PCIHAL_ENABLE:

            //
            // Gray out the sub-options if Irq Routing is being disabled.
            //            
            status = TRUE;
            enabled = IsDlgButtonChecked(Dialog, IDC_PCIHAL_ENABLE);
            EnableWindow(GetDlgItem(Dialog, IDC_PCIHAL_MSSPEC), enabled);
            EnableWindow(GetDlgItem(Dialog, IDC_PCIHAL_REALMODE), enabled);            
            break;

        default:
        
            break;
    }

    return status;
}

BOOL
PciHalOnNotify(
    IN HWND Dialog,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

    Routine Description:

        This routine handles the WM_NOTIFY message for the Pci Irq Routing
        property sheet page.

    Input Parameters:

        Dialog - Window handle for the property sheet page.

        wParam - wParam of the WM_NOTIFY message.

        lParam - lParam of the WM_NOTIFY message.
    
    Return Value:

        TRUE if this function handles the message. Else FALSE.
        
--*/

{
    BOOL                    status = FALSE;
    HKEY                    hKey;
    DWORD                   options;
    
    switch (((LPNMHDR)lParam)->code)
    {
        case PSN_RESET:        

            //
            // User hit cancel.
            //
            status = TRUE;

            if (RegOpenKey(gPciHalPropData.LocalMachine, REGSTR_PATH_PCIIR, &hKey) == ERROR_SUCCESS)
            {
                RegSetValueEx(  hKey, 
                                REGSTR_VAL_OPTIONS, 
                                0, 
                                REG_DWORD, 
                                (CONST BYTE *)&gPciHalPropData.Options, 
                                sizeof(gPciHalPropData.Options));
                RegCloseKey(hKey);
            }
            
            break;
            
        case PSN_APPLY:

            //
            // User hit Apply or Ok.
            //
            status = TRUE;
            
            //
            // Read the different control status and write it to the registry.
            //
            options = gPciHalPropData.Options;
            if (IsDlgButtonChecked(Dialog, IDC_PCIHAL_ENABLE) == BST_CHECKED)
            {
                options |= PIR_OPTION_ENABLED;
            }
            else
            {
                options &= ~PIR_OPTION_ENABLED;
            }

            if (IsDlgButtonChecked(Dialog, IDC_PCIHAL_MSSPEC))
            {
                options |= PIR_OPTION_MSSPEC;
            }
            else
            {
                options &= ~PIR_OPTION_MSSPEC;
            }

            if (IsDlgButtonChecked(Dialog, IDC_PCIHAL_REALMODE))
            {
                options |= PIR_OPTION_REALMODE;
            }
            else
            {
                options &= ~PIR_OPTION_REALMODE;
            }

            if (RegOpenKey(gPciHalPropData.LocalMachine, REGSTR_PATH_PCIIR, &hKey) == ERROR_SUCCESS)
            {
                RegSetValueEx(  hKey, 
                                REGSTR_VAL_OPTIONS, 
                                0, 
                                REG_DWORD, 
                                (CONST BYTE *)&options, 
                                sizeof(options));
                RegCloseKey(hKey);
            }

            //
            // Reboot if any of the options changed.
            //
            if (options != gPciHalPropData.Options)
            {
                SP_DEVINSTALL_PARAMS    deviceInstallParams;

                memset(&deviceInstallParams, 0, sizeof(deviceInstallParams));
                deviceInstallParams.cbSize = sizeof(deviceInstallParams);
                if (SetupDiGetDeviceInstallParams(  gPciHalPropData.DeviceInfoSet, 
                                                    gPciHalPropData.DeviceInfoData, 
                                                    &deviceInstallParams))
                {
                    deviceInstallParams.Flags |= DI_NEEDREBOOT;
                    SetupDiSetDeviceInstallParams(  gPciHalPropData.DeviceInfoSet, 
                                                    gPciHalPropData.DeviceInfoData, 
                                                    &deviceInstallParams);
                    
                }
            }
            
            break;

        default:

            break;
    }

    return status;
}

INT_PTR
PciHalDialogProc(
    IN HWND Dialog,
    IN UINT Message,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

    Routine Description:

        This is the DlgProc for the Pci Irq Routing property sheet page.
        
    Input Parameters:

        Standard DlgProc parameters.
        
    Return Value:

        TRUE if it handles the message. Else FALSE.
        
--*/

{
    BOOL    status = FALSE;
    PCWSTR  szHelpFile = L"devmgr.hlp";
    
    switch (Message)
    {
        case WM_INITDIALOG:

            status = PciHalOnInitDialog(Dialog, wParam, lParam);
            break;

        case WM_COMMAND:

            status = PciHalOnCommand(Dialog, wParam, lParam);
            break;

        case WM_NOTIFY:

            status = PciHalOnNotify(Dialog, wParam, lParam);
            break;

        case WM_HELP:
            
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, szHelpFile, HELP_WM_HELP, (ULONG_PTR)gPciPropHelpIds);
            status = TRUE;
            break;
            
        case WM_CONTEXTMENU:

            WinHelp((HWND)wParam, szHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)gPciPropHelpIds);
            status = TRUE;
            break;

        case WM_DESTROY:

            if (gPciHalPropData.CloseKey) {
                RegCloseKey(gPciHalPropData.LocalMachine);
                gPciHalPropData.CloseKey = FALSE;
            }
        
        default:

            break;
    }

    return status;
}

DWORD
PciHalCoInstaller(
    IN DI_FUNCTION                      InstallFunction,
    IN HDEVINFO                         DeviceInfoSet,
    IN PSP_DEVINFO_DATA                 DeviceInfoData  OPTIONAL,
    IN OUT PCOINSTALLER_CONTEXT_DATA    Context
    )
{
    BOOL                        status;
    HPROPSHEETPAGE              pageHandle;
    PROPSHEETPAGE               page;
    SP_DEVINFO_LIST_DETAIL_DATA details;
    SP_ADDPROPERTYPAGE_DATA     addPropertyPageData;

    switch (InstallFunction) {
    case DIF_ADDPROPERTYPAGE_ADVANCED:        
    case DIF_ADDREMOTEPROPERTYPAGE_ADVANCED:

        details.cbSize = sizeof(SP_DEVINFO_LIST_DETAIL_DATA);
        if (SetupDiGetDeviceInfoListDetail(DeviceInfoSet, &details)) {

            if (RegConnectRegistry((details.RemoteMachineName[0] == TEXT('\0'))? NULL : details.RemoteMachineName, HKEY_LOCAL_MACHINE, &gPciHalPropData.LocalMachine) == ERROR_SUCCESS) {

                RegCloseKey(gPciHalPropData.LocalMachine);
                status = TRUE;
                break;
            }
        }

    default:

        status = FALSE;
        break;
    }
    if (status) {

        ZeroMemory(&addPropertyPageData, sizeof(SP_ADDPROPERTYPAGE_DATA));
        addPropertyPageData.ClassInstallHeader.cbSize = 
             sizeof(SP_CLASSINSTALL_HEADER);

        if (SetupDiGetClassInstallParams(DeviceInfoSet, DeviceInfoData,
             (PSP_CLASSINSTALL_HEADER)&addPropertyPageData,
             sizeof(SP_ADDPROPERTYPAGE_DATA), NULL )) {

           if (addPropertyPageData.NumDynamicPages < MAX_INSTALLWIZARD_DYNAPAGES) {

               //
               // Initialize our globals here.
               //
               gPciHalPropData.DeviceInfoSet    = DeviceInfoSet;
               gPciHalPropData.DeviceInfoData   = DeviceInfoData;

               //
               // Initialize our property page here.
               //
               memset(&page, 0, sizeof(PROPSHEETPAGE));
               page.dwSize      = sizeof(PROPSHEETPAGE);
               page.hInstance   = MyModuleHandle;
               page.pszTemplate = MAKEINTRESOURCE(IDD_PCIHAL_PROPPAGE);
               page.pfnDlgProc  = PciHalDialogProc;
               page.lParam      = (LPARAM)&gPciHalPropData;

               pageHandle = CreatePropertySheetPage(&page);
               if (pageHandle != NULL)
               {

                   addPropertyPageData.DynamicPages[addPropertyPageData.NumDynamicPages++] = pageHandle;
                    SetupDiSetClassInstallParams(DeviceInfoSet, DeviceInfoData,
                        (PSP_CLASSINSTALL_HEADER)&addPropertyPageData,
                        sizeof(SP_ADDPROPERTYPAGE_DATA));

                    return NO_ERROR;
               }
           }
        }
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\wizard.c ===
#include "setupp.h"
#pragma hdrstop

#ifdef _OCM
#include <ocmanage.h>
#include <ocmgrlib.h>
#endif

extern BOOLEAN
AsrIsEnabled( VOID );

typedef struct _WIZPAGE {
    UINT ButtonState;
    UINT Spare;
    PROPSHEETPAGE Page;
} WIZPAGE, *PWIZPAGE;

BOOL UiTest;

//
// "Page" that is actually a signal to fetch the net pages
// and insert them there.
//
#define WizPagePlaceholderNet   (WizPageMaximum+1)
#define WizPagePlaceholderLic   (WizPageMaximum+2)
BOOL NetWizard;

#ifdef _OCM
#define WizPageOcManager        (WizPageMaximum+3)
#define WizPageOcManagerSetup   (WizPageMaximum+4)
#define WizPageOcManagerEarly   (WizPageMaximum+5)
#define WizPageOcManagerPrenet  (WizPageMaximum+6)
#define WizPageOcManagerPostnet (WizPageMaximum+7)
#define WizPageOcManagerLate    (WizPageMaximum+8)
#endif

#define MAX_LICWIZ_PAGES MAX_NETWIZ_PAGES
#define LICENSESETUPPAGEREQUESTPROCNAME "LicenseSetupRequestWizardPages"

//
// These MUST be in the same order as the items in the WizPage enum!!!
//
WIZPAGE SetupWizardPages[WizPageMaximum] = {

    //
    // Welcome page
    //
    {
       PSWIZB_NEXT,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_HIDEHEADER,                          // full-size page, no header
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_WELCOME),            // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       WelcomeDlgProc,                          // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL                                     // ref count
    }},

    //
    // EULA page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_EULA),               // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       EulaDlgProc,                             // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_EULA,                       // title
       (LPCWSTR)IDS_EULA_SUB,                   // subtitle
    }},

    //
    // Preparing Directory page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_PREPARING),          // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       PreparingDlgProc,                        // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_PREPARING_INSTALL,          // title
       (LPCWSTR)IDS_PREPARING_INSTALL_SUB,      // subtitle
    }},

    //
    // Preparing ASR page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE, NULL,   // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_PREPARING_ASR),          // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       PreparingDlgProc,                        // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_ASR,                        // title
       (LPCWSTR)IDS_ASR_SUB,                    // subtitle
    }},


#ifdef PNP_DEBUG_UI
    //
    // Installed Hardware page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       0,                                       // flags
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_HARDWARE),           // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       InstalledHardwareDlgProc,                // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL                                     // ref count
    }},
#endif // PNP_DEBUG_UI

    //
    // International settings (locale, kbd layout) page
    //
    {
        PSWIZB_NEXT | PSWIZB_BACK,
        0,
     {  sizeof(PROPSHEETPAGE),                  // size of struct
        PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE,
        NULL,                                   // hInst (filled in at run time)
        MAKEINTRESOURCE(IDD_REGIONAL_SETTINGS), // dlg template
        NULL,                                   // icon
        NULL,                                   // title
        RegionalSettingsDlgProc,                // dlg proc
        0,                                      // lparam
        NULL,                                   // callback
        NULL,                                   // ref count
        (LPCWSTR)IDS_REGIONAL_SETTINGS,
        (LPCWSTR)IDS_REGIONAL_SETTINGS_SUB
    }},

    //
    // Name/organization page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_NAMEORG),            // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       NameOrgDlgProc,                          // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_NAMEORG,                    // title
       (LPCWSTR)IDS_NAMEORG_SUB                 // subtitle
    }},

    //
    // Product id page for CD
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_PID_CD),             // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       Pid30CDDlgProc,                          // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_PID,                        // title
       (LPCWSTR)IDS_PID_SUB                     // subtitle
    }},

    //
    // Product id page for OEM
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_PID_OEM),            // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       Pid30OemDlgProc,                         // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_OEM,                        // title
       (LPCWSTR)IDS_OEM_SUB                     // subtitle
    }},

    //
    // Product id page for Select media
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_PID_SELECT),            // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       Pid30SelectDlgProc,                         // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_SELECT,                        // title
       (LPCWSTR)IDS_SELECT_SUB                     // subtitle
    }},
    //
    // Computer name page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_COMPUTERNAME),       // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       ComputerNameDlgProc,                     // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_COMPUTERNAME,               // title
       (LPCWSTR)IDS_COMPUTERNAME_SUB            // subtitle
    }},

#ifdef DOLOCALUSER
    //
    // Local user account page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_USERACCOUNT),        // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       UserAccountDlgProc,                      // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_USERNAME,                   // title
       (LPCWSTR)IDS_USERNAME_SUB                // subtitle
    }},
#endif

#ifdef _X86_
    //
    // Pentium errata page (x86 only)
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_PENTIUM),            // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       PentiumDlgProc,                          // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_FPERRATA,                   // title
       (LPCWSTR)IDS_FPERRATA_SUB                // subtitle
    }},
#endif // def _X86_

    //
    // Intermediate steps page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_STEPS1),             // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       StepsDlgProc,                            // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_WINNT_SETUP                 // title
    }},

    {
       0,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_STEPS1),             // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       SetupPreNetDlgProc,                            // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_WINNT_SETUP                 // title
    }},
    {
       0,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_STEPS1),             // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       SetupPostNetDlgProc,                            // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_WINNT_SETUP                 // title
    }},

    //
    // Copying files page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE,
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_COPYFILES3),         // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       CopyFilesDlgProc,                        // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_COPYFILES,                  // title
       (LPCWSTR)IDS_COPYFILES_SUB2,             // subtitle
    }},

    //
    // Last ASR page.
    //
    {
       PSWIZB_FINISH,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_HIDEHEADER,                          // full-size page, no header
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_LAST_ASR_PAGE),   // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       LastPageDlgProc,                         // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_WINNT_SETUP                 // title
    }},

    //
    // Last page.
    //
    {
       PSWIZB_FINISH,
       0,
     { sizeof(PROPSHEETPAGE),                   // size of struct
       PSP_HIDEHEADER,                          // full-size page, no header
       NULL,                                    // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_LAST_WIZARD_PAGE),   // dlg template
       NULL,                                    // icon
       NULL,                                    // title
       LastPageDlgProc,                         // dlg proc
       0,                                       // lparam
       NULL,                                    // callback
       NULL,                                    // ref count
       (LPCWSTR)IDS_WINNT_SETUP                 // title
    }}
};


UINT InitialWizardPages[] = { WizPageWelcome,
                              WizPageEula,
                              WizPagePreparing,
#ifdef PNP_DEBUG_UI
                              WizPageInstalledHardware,
#endif // PNP_DEBUG_UI
                              WizPageRegionalSettings,
                              WizPageNameOrg,
                              WizPageProductIdCd,
                              WizPageProductIdOem,
                              WizPageProductIdSelect,
                              WizPagePlaceholderLic,
                              WizPageComputerName,
#ifdef _OCM
                              WizPageOcManager,
                              WizPageOcManagerEarly,
#endif
#ifdef DOLOCALUSER
                              WizPageUserAccount,
#endif
#ifdef _X86_
                              WizPagePentiumErrata,
#endif
                              WizPageSteps1,
#ifdef _OCM
                              WizPageOcManagerPrenet,
#endif
                              WizSetupPreNet,
                              WizPagePlaceholderNet,
                              WizSetupPostNet,
#ifdef _OCM
                              WizPageOcManagerPostnet,
                              WizPageOcManagerLate,
                              WizPageOcManagerSetup,
#endif
                              WizPageCopyFiles,
                              WizPageLast
                            };

UINT AsrWizardPages[] =     { WizPagePreparingAsr,
#ifdef PNP_DEBUG_UI
                              WizPageInstalledHardware,
#endif //PNP_DEBUG_UI
#ifdef _OCM
                              WizPageOcManager,
                              WizPageOcManagerEarly,
                              WizPageOcManagerPrenet,
#endif
                              WizSetupPreNet,
                              WizPagePlaceholderNet,
                              WizSetupPostNet,
#ifdef _OCM
                              WizPageOcManagerPostnet,
                              WizPageOcManagerLate,
                              WizPageOcManagerSetup,
#endif
                              WizPageAsrLast
                            };

UINT UpgradeWizardPages[] = { WizPageWelcome,
                              WizPageEula,
                              WizPagePreparing,
#ifdef PNP_DEBUG_UI
                              WizPageInstalledHardware,
#endif // PNP_DEBUG_UI
                              WizPageRegionalSettings,
                              WizPageProductIdCd,
                              WizPageProductIdOem,
                              WizPageProductIdSelect,
                              WizPagePlaceholderLic,
#ifdef _OCM
                              WizPageOcManager,
                              WizPageOcManagerEarly,
#endif
#ifdef _X86_
                              WizPagePentiumErrata,
#endif
                              WizPageSteps1,
#ifdef _OCM
                              WizPageOcManagerPrenet,
#endif
                              WizSetupPreNet,
                              WizPagePlaceholderNet,
                              WizSetupPostNet,
#ifdef _OCM
                              WizPageOcManagerPostnet,
                              WizPageOcManagerLate,
                              WizPageOcManagerSetup,
#endif
                              WizPageCopyFiles,
                              WizPageLast
                            };


UINT UiTestWizardPages[] = {  WizPageWelcome,
                              WizPageEula,
                              WizPagePreparing,
#ifdef PNP_DEBUG_UI
                              WizPageInstalledHardware,
#endif // PNP_DEBUG_UI
                              WizPageRegionalSettings,
                              WizPageNameOrg,
                              WizPageProductIdCd,
                              WizPageProductIdOem,
                              WizPageProductIdSelect,
                              WizPageComputerName,
#ifdef DOLOCALUSER
                              WizPageUserAccount,
#endif
#ifdef _X86_
                              WizPagePentiumErrata,
#endif // def _X86_
                              WizPageSteps1,
                              WizPageCopyFiles,
                              WizPageLast
                           };


UINT MiniSetupWizardPages[] = {
                              WizPageWelcome,
                              WizPageEula,
                              WizPagePreparing,
                              WizPageRegionalSettings,
                              WizPageNameOrg,
                              WizPageProductIdCd,
                              WizPageProductIdOem,
                              WizPageProductIdSelect,
                              WizPagePlaceholderLic,
                              WizPageComputerName,
#ifdef _OCM
                              WizPageOcManager,
                              WizPageOcManagerEarly,
#endif
                              WizPageSteps1,
#ifdef _OCM
                              WizPageOcManagerPrenet,
#endif
                              WizPagePlaceholderNet,
#ifdef _OCM
                              WizPageOcManagerPostnet,
                              WizPageOcManagerLate,
                              WizPageOcManagerSetup,
#endif
                              WizPageCopyFiles,
                              WizPageLast
                           };





#define TIME_INITIALIZE         120
#define TIME_INSTALLSECURITY    30
#define TIME_PRECOMPILEINFS     90      // calc something with #infs and throughput
#define TIME_INSTALLDEVICES     330     // How can we calc a better number?
                                        // Also Pre compile INFs is part of Device Install page
#define TIME_INSTALLENUMDEVICES1 120
#define TIME_INSTALLLEGACYDEVICES  30
#define TIME_INSTALLENUMDEVICES2 60

#define TIME_NETINSTALL         150     // need better number
#define TIME_OCINSTALL          420     // need better number
#define TIME_INSTALLCOMPONENTINFS 240   // need better number
#define TIME_INF_REGISTRATION   300     // need better number
#define TIME_RUNONCE_REGISTRATION 120     // need better number
#define TIME_SECURITYTEMPLATE   150     // need better number
#define TIME_WIN9XMIGRATION     120     // Need better number
#define TIME_SFC                420
#define TIME_SAVEREPAIR         30
#define TIME_REMOVETEMOFILES    30

#define TIME_ALL                2190

//
// The entries in this array need to correcpond to the enum SetupPhases in setuppp.h

SETUPPHASE SetupPhase[] = {
    { TIME_INITIALIZE,          FALSE },    // Initialize
    { TIME_INSTALLSECURITY,     FALSE },    // InstallSecurity
    { TIME_PRECOMPILEINFS,      FALSE },    // PrecompileInfs
    { TIME_INSTALLENUMDEVICES1, FALSE },    // InstallDevices
    { TIME_INSTALLLEGACYDEVICES, FALSE },
    { TIME_INSTALLENUMDEVICES2, FALSE },
    { TIME_NETINSTALL,          FALSE },     // NetInstall
    { TIME_OCINSTALL,           FALSE },     // OCInstall
    { TIME_INSTALLCOMPONENTINFS, FALSE},
    { TIME_INF_REGISTRATION,    FALSE},
    { TIME_RUNONCE_REGISTRATION, FALSE },     // Registration
    { TIME_SECURITYTEMPLATE,    FALSE },     // SecurityTempates
    { TIME_WIN9XMIGRATION,      TRUE },     // Win9xMigration
    { TIME_SFC,                 FALSE },     // SFC
    { TIME_SAVEREPAIR,          FALSE },     // SaveRepair
    { TIME_REMOVETEMOFILES,     FALSE }     // RemoveTempFiles
};

UINT CurrentPhase = Phase_Unknown;
ULONG RemainingTime = 0;

#ifdef _OCM
BOOL
pOcManagerPages(
    IN     PSETUP_REQUEST_PAGES  Page,
    OUT    HPROPSHEETPAGE       *WizardPageHandles,
    IN OUT UINT                 *PageCount
    );
#endif


BOOL
GetNetworkWizardPages(
       OUT HPROPSHEETPAGE *PageHandles,
    IN OUT PUINT           PageCount
    )

/*++

Routine Description:

    This routine asks net setup for its wizard pages and passes it
    a pointer to a global structure to be used later to pass info
    back and forth between base and net setups. Net setup must not
    attempt to use any fields in there yet because they are not
    filled in yet.

Arguments:

    PropSheetHandles - receives network setup wizard page handles.

    PageCount - on input, supplies number of slots in PropSheetHandles
        array. On output, receives number of handles actually placed
        in the array.

Return Value:

    If the netsetup wizard dll could not be loaded, returns FALSE.
    Otherwise returns TRUE if no error, or does not return if error.

--*/

{
    NETSETUPPAGEREQUESTPROC PageRequestProc;
    HMODULE NetSetupModule;
    DWORD d;
    BOOL b;

    b = FALSE;
    d = NO_ERROR;

    NetSetupModule = LoadLibrary(L"NETSHELL");
    if(!NetSetupModule) {
        //
        // If the network wizard isn't around, then the legacy network inf
        // had better be.
        //
        WCHAR x[MAX_PATH];

        GetSystemDirectory(x,MAX_PATH);
        pSetupConcatenatePaths(x,L"NTLANMAN.INF",MAX_PATH,NULL);
        if(FileExists(x,NULL)) {
            return(FALSE);
        }
        d = ERROR_FILE_NOT_FOUND;
        goto c0;
    }

    PageRequestProc = (NETSETUPPAGEREQUESTPROC)GetProcAddress(
                                                    NetSetupModule,
                                                    NETSETUPPAGEREQUESTPROCNAME
                                                    );
    if(!PageRequestProc) {
        d = GetLastError();
        goto c0;
    }

    //
    // Net setup needs product type really early.
    //
    SetProductTypeInRegistry();

    //
    // Call net setup to get its pages.
    //
    InternalSetupData.dwSizeOf = sizeof(INTERNAL_SETUP_DATA);
    b = PageRequestProc(PageHandles,PageCount,&InternalSetupData);

    //
    // If we get here, d is NO_ERROR. If b is FALSE this NO_ERROR will be
    // a special case to mean "the network wizard request failed."
    // In other error cases, d will have a non-0 value.
    //

c0:
    if(!b) {
        //
        // This is fatal, something is really wrong.
        //
        FatalError(MSG_LOG_NETWIZPAGE,d,0,0);
    }

    return(TRUE);
}

BOOL
GetLicenseWizardPages(
       OUT HPROPSHEETPAGE *PageHandles,
    IN OUT PUINT           PageCount
    )

/*++

Routine Description:

    This routine asks liccpa setup for its wizard pages and passes it
    a pointer to a global structure to be used later to pass info
    back and forth between base and liccpa setups. Liccpa setup must not
    attempt to use any fields in there yet because they are not
    filled in yet.

Arguments:

    PropSheetHandles - receives liccpa setup wizard page handles.

    PageCount - on input, supplies number of slots in PropSheetHandles
        array. On output, receives number of handles actually placed
        in the array.

Return Value:

    If the liccpa dll could not be loaded, returns FALSE.
    Otherwise returns TRUE if no error, or does not return if error.

--*/

{
    NETSETUPPAGEREQUESTPROC PageRequestProc;
    HMODULE LicenseSetupModule;
    DWORD d;
    BOOL b;

    b = FALSE;
    d = NO_ERROR;

    LicenseSetupModule = LoadLibrary(L"LICCPA.CPL");
    if(!LicenseSetupModule) {
        //
        // If the license wizard isn't around, then this is a fatal error
        //
        d = ERROR_FILE_NOT_FOUND;
        goto c0;
    }

    PageRequestProc = (NETSETUPPAGEREQUESTPROC)GetProcAddress(
                                                    LicenseSetupModule,
                                                    LICENSESETUPPAGEREQUESTPROCNAME
                                                    );
    if(!PageRequestProc) {
        d = GetLastError();
        goto c0;
    }

//    //
//    // Net setup needs product type really early.
//    //
//    SetProductTypeInRegistry();

    //
    // Call liccpa setup to get its pages.
    //
    InternalSetupData.dwSizeOf = sizeof(INTERNAL_SETUP_DATA);
    b = PageRequestProc(PageHandles,PageCount,&InternalSetupData);

    //
    // If we get here, d is NO_ERROR. If b is FALSE this NO_ERROR will be
    // a special case to mean "the license wizard request failed."
    // In other error cases, d will have a non-0 value.
    //

c0:
    if(!b) {
        //
        // This is fatal, something is really wrong.
        //
        FatalError(MSG_LOG_LICWIZPAGE,d,0,0);
    }

    return(TRUE);
}

VOID
SetWizardButtons(
    IN HWND    hdlgPage,
    IN WizPage PageNumber
    )
{
    //
    // Dirty hack to hide cancel and help buttons.
    // We don't have any help buttons but some of the other
    // components whose pages are included here might; we want to make
    // sure that for us, the help button stays removed!
    //
    EnableWindow(GetDlgItem(GetParent(hdlgPage),IDCANCEL),FALSE);
    ShowWindow(GetDlgItem(GetParent(hdlgPage),IDCANCEL),SW_HIDE);

    EnableWindow(GetDlgItem(GetParent(hdlgPage),IDHELP),FALSE);
    ShowWindow(GetDlgItem(GetParent(hdlgPage),IDHELP),SW_HIDE);

    PropSheet_SetWizButtons(GetParent(hdlgPage),SetupWizardPages[PageNumber].ButtonState);
    SetWindowLongPtr(hdlgPage,DWLP_MSGRESULT,0);
}


VOID
WizardBringUpHelp(
    IN HWND    hdlg,
    IN WizPage PageNumber
    )
{
#if 0
    BOOL b;

    b = WinHelp(
            hdlg,
            L"setupnt.hlp",
            HELP_CONTEXT,
            SetupWizardPages[PageNumber].HelpContextId
            );

    if(!b) {
        MessageBoxFromMessage(
            hdlg,
            MSG_CANT_INVOKE_WINHELP,
            NULL,
            IDS_ERROR,
            MB_ICONSTOP | MB_OK
            );
    }
#else
    UNREFERENCED_PARAMETER(hdlg);
    UNREFERENCED_PARAMETER(PageNumber);
#endif
}


VOID
WizardKillHelp(
    IN HWND hdlg
    )
{
#if 0
    WinHelp(hdlg,NULL,HELP_QUIT,0);
#else
    UNREFERENCED_PARAMETER(hdlg);
#endif
}


WNDPROC OldWizDlgProc;

INT_PTR
NewWizDlgProc(
    IN HWND hdlg,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    static RECT rect;
    static BOOL Visible = TRUE;
    BOOL b = FALSE;
    //
    // Eat WM_SYSCOMMAND where wParam is SC_CLOSE.
    // Pass all other messages on.
    //
    if((msg != WM_SYSCOMMAND) || ((wParam & 0xfff0) != SC_CLOSE))
    {
        switch (msg)
        {
            // Set the progress text
            // Indicates what setup is doing.
            case WMX_SETPROGRESSTEXT:
                BB_SetProgressText((PCTSTR)lParam);
                b = TRUE;
                break;

            case WMX_BB_SETINFOTEXT:
                BB_SetInfoText((PTSTR)lParam);
                b = TRUE;
                break;

            // Enabled, disable, show, hide the progress gauge on the billboard
            // wParam should be SW_SHOW or SW_HIDE
            case WMX_BBPROGRESSGAUGE:
                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,BB_ShowProgressGaugeWnd((UINT)wParam));
                b= TRUE;
                break;

            // Start, stop the billboard text.
            // This start, stops the billboard text and shows, hides the wizard pages
    case WMX_BBTEXT:
        if (hinstBB)
        {

            if (wParam != 0)
            {
                if (Visible)
                {
                    // Get the current position of the wizard
                    // We restore this position when we need to show it.
                    GetWindowRect(hdlg, &rect);

                    SetWindowPos(hdlg,
                        GetBBhwnd(),
                        0,0,0,0,
                        SWP_NOZORDER);

                    SetActiveWindow(GetBBhwnd());

                    Visible = FALSE;
                }
            }
            else
            {
                if (!Visible)
                {
                    SetWindowPos(hdlg,
                        HWND_TOP,
                        rect.left,
                        rect.top,
                        rect.right-rect.left,
                        rect.bottom-rect.top,
                        SWP_SHOWWINDOW);
                }
                Visible = TRUE;
            }

            if (!StartStopBB((wParam != 0)))
            {
                if (!Visible)
                {
                    SetWindowPos(hdlg,
                        HWND_TOP,
                        rect.left,
                        rect.top,
                        rect.right-rect.left,
                        rect.bottom-rect.top,
                        SWP_SHOWWINDOW);
                }
                Visible = TRUE;
            }
        }
        else
        {
            if (!Visible)
            {
                SetWindowPos(hdlg,
                    HWND_TOP,
                    rect.left,
                    rect.top,
                    rect.right-rect.left,
                    rect.bottom-rect.top,
                    SWP_SHOWWINDOW);
            }
            Visible = TRUE;
        }
        return TRUE;
/*
            case WMX_BBTEXT:
                if (hinstBB)
                {

                    if (wParam != 0)
                    {
                        ShowWindow (hdlg, SW_HIDE);
                    }
                    else
                    {
                        ShowWindow (hdlg, SW_SHOW);
                    }

                    if (!StartStopBB((wParam != 0)))
                    {
                        ShowWindow (hdlg, SW_SHOW);
                    }
                }
                else
                {
                    ShowWindow (hdlg, SW_SHOW);
                }
                b = TRUE;
                break;
*/
            default:
                b = (BOOL)CallWindowProc(OldWizDlgProc,hdlg,msg,wParam,lParam);
                break;
        }
    }

    return b;
}

#ifdef _OCM
//
// Bogus global variable necessary because there's no way to get
// a value through to the PropSheetCallback.
//
PVOID _CBx;
#endif

int
CALLBACK
WizardCallback(
    IN HWND   hdlg,
    IN UINT   code,
    IN LPARAM lParam
    )
{
    DLGTEMPLATE *DlgTemplate;
    HMENU menu;

    UNREFERENCED_PARAMETER(hdlg);

    //
    // Get rid of context sensitive help control on title bar
    //
    if(code == PSCB_PRECREATE) {
        DlgTemplate = (DLGTEMPLATE *)lParam;
        DlgTemplate->style &= ~DS_CONTEXTHELP;
    } else {
        if(code == PSCB_INITIALIZED) {
            //
            // Get rid of close item on system menu.
            // Also need to process WM_SYSCOMMAND to eliminate use
            // of Alt+F4.
            //
            if(menu = GetSystemMenu(hdlg,FALSE)) {
                EnableMenuItem(menu,SC_CLOSE,MF_BYCOMMAND|MF_GRAYED);
            }

            OldWizDlgProc =  (WNDPROC)SetWindowLongPtr(hdlg,DWLP_DLGPROC,(LONG_PTR)NewWizDlgProc);

#ifdef _OCM
            // inform ocm components of the wizard dialog handle

            if (_CBx)
                OcRememberWizardDialogHandle(_CBx,hdlg);
#endif
        }
    }

    return(0);
}


VOID
Wizard(
#ifdef _OCM
    IN PVOID OcManagerContext
#else
    VOID
#endif
    )
{
    PROPSHEETHEADER psh;
    PUINT PageList;
    UINT PagesInSet;
    UINT i;
    UINT PageOrdinal;
    UINT PageCount;
    UINT NetPageCount;
    UINT LicPageCount;
#ifdef _OCM
    HPROPSHEETPAGE WizardPageHandles[MAXPROPPAGES];
#else
    HPROPSHEETPAGE WizardPageHandles[WizPageMaximum+MAX_NETWIZ_PAGES+MAX_LICWIZ_PAGES];
#endif
    BOOL b;
    INT_PTR Status;
    HDC hdc;
    WCHAR Text[500];
#ifdef _OCM
    PSETUP_REQUEST_PAGES PagesFromOcManager[WizPagesTypeMax];
    OC_PAGE_CONTROLS OcPageControls,OcDetailsControls;
    SETUP_PAGE_CONTROLS OcSetupPageControls;
#endif

    //
    // Determine which set of pages to use and how many there are in the set.
    //
    if(UiTest) {
        PageList = UiTestWizardPages;
        PagesInSet = sizeof(UiTestWizardPages)/sizeof(UiTestWizardPages[0]);
    } else {
        if(Upgrade) {
            PageList = UpgradeWizardPages;
            PagesInSet = sizeof(UpgradeWizardPages)/sizeof(UpgradeWizardPages[0]);
        } else {
            if( MiniSetup ) {
                PageList = MiniSetupWizardPages;
                PagesInSet = sizeof(MiniSetupWizardPages)/sizeof(MiniSetupWizardPages[0]);
            }
            else {
                if( AsrIsEnabled() ) {
                    PageList = AsrWizardPages;
                    PagesInSet = sizeof(AsrWizardPages)/sizeof(AsrWizardPages[0]);
                } else {
                    PageList = InitialWizardPages;
                    PagesInSet = sizeof(InitialWizardPages)/sizeof(InitialWizardPages[0]);
                }
            }
        }
    }

#ifdef _OCM
    // for callbacks

    _CBx = OcManagerContext;

    // Get pages from OC Manager components.

    if(OcManagerContext) {

        Status = OcGetWizardPages(OcManagerContext,PagesFromOcManager);
        if(Status != NO_ERROR) {
            FatalError(MSG_LOG_WIZPAGES,0,0);
        }
    } else {
        ZeroMemory(PagesFromOcManager,sizeof(PagesFromOcManager));
    }
#endif

    //
    // Create each page. Some of the pages are placeholders for external pages,
    // which are handled specially.
    //

    b = TRUE;
    PageCount = 0;
    for(i=0; b && (i<PagesInSet); i++) {

        switch(PageOrdinal = PageList[i]) {

        case WizPagePlaceholderNet:

            //
            // Fetch network pages.
            //
            NetPageCount = MAX_NETWIZ_PAGES;
            if(GetNetworkWizardPages(&WizardPageHandles[PageCount],&NetPageCount)) {
                PageCount += NetPageCount;
                NetWizard = TRUE;
            }

            break;

        case WizPagePlaceholderLic:

            if( (ProductType != PRODUCT_WORKSTATION) ) {
                //
                // Fetch license pages.
                //
                LicPageCount = MAX_LICWIZ_PAGES;
                if(GetLicenseWizardPages(&WizardPageHandles[PageCount],&LicPageCount)) {
                    PageCount += LicPageCount;
                }
            }

            break;

        case WizPagePreparing:
            //
            // We let the PnP engine run out of process
            // and asynchronously for a MiniSetup case.
            //

            //
            // If we're doing a mini Setup, then we ONLY do
            // the preparing page if the user has asked us to
            // do pnp enumeration.
            //
            if( MiniSetup && (PnPReEnumeration == FALSE)) {
                break;
            }

            goto dodefault;
            break;

        case WizPageCopyFiles:
#ifdef _X86_

            if (Win95Upgrade) {
                SetupWizardPages[PageOrdinal].Page.pszTemplate = MAKEINTRESOURCE(IDD_COPYFILES4);
            }
#endif
#ifdef _OCM
            MYASSERT(OcManagerContext);
            SetupWizardPages[PageOrdinal].Page.lParam = (LPARAM) OcManagerContext;
#endif

            goto dodefault;
            break;


#ifdef _OCM
        case WizPageWelcome:
            //
            // If there's a welcome page from an OC Manager component
            // then use it. Otherwise use the standard setup one.
            //
            if(!pOcManagerPages(PagesFromOcManager[WizPagesWelcome],WizardPageHandles,&PageCount)) {
                goto dodefault;
            }

            break;


        case WizPageLast:
            //
            // If there's a final page from an OC Manager component
            // then use it. Otherwise use the standard setup one.
            //
            if(!pOcManagerPages(PagesFromOcManager[WizPagesFinal],WizardPageHandles,&PageCount)) {
                goto dodefault;
            }

            break;

        case WizPageOcManagerEarly:

            pOcManagerPages(PagesFromOcManager[WizPagesEarly],WizardPageHandles,&PageCount);
            break;

        case WizPageOcManagerPrenet:

            pOcManagerPages(PagesFromOcManager[WizPagesPrenet],WizardPageHandles,&PageCount);
            break;

        case WizPageOcManagerPostnet:

            pOcManagerPages(PagesFromOcManager[WizPagesPostnet],WizardPageHandles,&PageCount);
            break;

        case WizPageOcManagerLate:

            pOcManagerPages(PagesFromOcManager[WizPagesLate],WizardPageHandles,&PageCount);
            break;

        case WizPageOcManager:

            if(OcManagerContext && OcSubComponentsPresent(OcManagerContext)) {
                OcPageControls.TemplateModule = MyModuleHandle;
                OcPageControls.TemplateResource = MAKEINTRESOURCE(IDD_OCM_WIZARD_PAGE);
                OcPageControls.ListBox = IDC_LISTBOX;
                OcPageControls.TipText = IDT_TIP;
                OcPageControls.DetailsButton = IDB_DETAILS;
                OcPageControls.ResetButton = 0; // unused
                OcPageControls.InstalledCountText = 0; // unused
                OcPageControls.SpaceNeededText = IDT_SPACE_NEEDED_NUM;
                OcPageControls.SpaceAvailableText = IDT_SPACE_AVAIL_NUM;
                OcPageControls.InstructionsText = IDT_INSTRUCTIONS;
                OcPageControls.HeaderText = IDS_OCPAGE_HEADER;
                OcPageControls.SubheaderText = IDS_OCPAGE_SUBHEAD;
                OcPageControls.ComponentHeaderText = IDT_COMP_TITLE;

                OcDetailsControls = OcPageControls;
                OcDetailsControls.TemplateResource = MAKEINTRESOURCE(IDD_OCM_DETAILS);

                WizardPageHandles[PageCount] = OcCreateOcPage(
                                                    OcManagerContext,
                                                    &OcPageControls,
                                                    &OcDetailsControls
                                                    );

                if(WizardPageHandles[PageCount]) {
                    PageCount++;
                } else {
                    b = FALSE;
                }
            }

            break;

        case WizPageOcManagerSetup:

            if(OcManagerContext) {
                OcSetupPageControls.TemplateModule = MyModuleHandle;
                OcSetupPageControls.TemplateResource = MAKEINTRESOURCE(IDD_OCM_PROGRESS_PAGE);
                OcSetupPageControls.ProgressBar = IDC_PROGRESS;
                OcSetupPageControls.ProgressLabel = IDT_THERM_LABEL;
                OcSetupPageControls.ProgressText = IDT_TIP;
                OcSetupPageControls.AnimationControl = IDA_EXTERNAL_PROGRAM;
                OcSetupPageControls.AnimationResource = IDA_FILECOPY;
                OcSetupPageControls.ForceExternalProgressIndicator = FALSE;
                OcSetupPageControls.AllowCancel = FALSE;
                OcSetupPageControls.HeaderText = IDS_PROGPAGE_HEADER;
                OcSetupPageControls.SubheaderText = IDS_PROGPAGE_SUBHEAD;

                if(WizardPageHandles[PageCount] = OcCreateSetupPage(OcManagerContext,&OcSetupPageControls)) {
                    PageCount++;
                } else {
                    b = FALSE;
                }
            }

            break;
#endif

            case WizPageComputerName:
            if( GetProductFlavor() == 4)
            {
                // If Personal use a different template
                SetupWizardPages[PageOrdinal].Page.pszTemplate = MAKEINTRESOURCE(IDD_COMPUTERNAME2);
            }

            goto dodefault;
            break;

        default:
        dodefault:
            {
                UINT uiStrID;
            SetupWizardPages[PageOrdinal].Page.hInstance = MyModuleHandle;

            SetupWizardPages[PageOrdinal].Page.pszTitle = (PWSTR)UIntToPtr( SetupTitleStringId );
            SetupWizardPages[PageOrdinal].Page.dwFlags |= PSP_USETITLE;

            //
            // Convert resource ids to actual strings for header title and subtitle,
            // if required for this page.
            //
            if(SetupWizardPages[PageOrdinal].Page.dwFlags & PSP_USEHEADERTITLE) {

                uiStrID = (UINT)((ULONG_PTR)SetupWizardPages[PageOrdinal].Page.pszHeaderTitle);
                if ((PageOrdinal == WizPageComputerName) &&
                    (GetProductFlavor() == 4))
                {
                    uiStrID = IDS_COMPUTERNAME2;
                }

                SetupWizardPages[PageOrdinal].Page.pszHeaderTitle = MyLoadString(uiStrID
                                                                        //(UINT)((ULONG_PTR)SetupWizardPages[PageOrdinal].Page.pszHeaderTitle)
                                                                        );

                if(!SetupWizardPages[PageOrdinal].Page.pszHeaderTitle) {
                    SetupWizardPages[PageOrdinal].Page.dwFlags &= ~PSP_USEHEADERTITLE;
                }
            }

            if(SetupWizardPages[PageOrdinal].Page.dwFlags & PSP_USEHEADERSUBTITLE) {
                uiStrID = (UINT)((ULONG_PTR)SetupWizardPages[PageOrdinal].Page.pszHeaderSubTitle);
                if ((PageOrdinal == WizPageComputerName) &&
                    (GetProductFlavor() == 4))
                {
                    uiStrID = IDS_COMPUTERNAME2_SUB;
                }
                SetupWizardPages[PageOrdinal].Page.pszHeaderSubTitle = MyLoadString(uiStrID
                                                                        //(UINT)((ULONG_PTR)SetupWizardPages[PageOrdinal].Page.pszHeaderSubTitle)
                                                                        );

                if(!SetupWizardPages[PageOrdinal].Page.pszHeaderSubTitle) {
                    SetupWizardPages[PageOrdinal].Page.dwFlags &= ~PSP_USEHEADERSUBTITLE;
                }
            }

            WizardPageHandles[PageCount] = CreatePropertySheetPage(
                                                &SetupWizardPages[PageOrdinal].Page
                                                );

            if(WizardPageHandles[PageCount]) {
                PageCount++;
            } else {
                b = FALSE;
            }
            }
            break;
        }
    }

    if(b) {

        psh.dwSize = sizeof(PROPSHEETHEADER);
        psh.dwFlags = PSH_WIZARD | PSH_USECALLBACK | PSH_WIZARD97 |
            PSH_HEADER;
        // in order to have the watermark sized correctly for all languages,
        // we must draw the bitmap ourselves rather than letting wiz97
        // take care of it for us.
            //PSH_WATERMARK | PSH_HEADER;
        psh.hwndParent = MainWindowHandle;
        psh.hInstance = MyModuleHandle;
        psh.pszCaption = NULL;
        psh.nPages = PageCount;
        psh.nStartPage = 0;
        psh.phpage = WizardPageHandles;
        psh.pfnCallback = WizardCallback;
        //psh.pszbmWatermark = MAKEINTRESOURCE(IDB_BITMAP1);
        psh.pszbmHeader = MAKEINTRESOURCE(IDB_HEADER);

        Status = PropertySheet(&psh);
        if (Status == -1) {
            FatalError(MSG_LOG_WIZPAGES,0,0);
        }

    } else {

        FatalError(MSG_LOG_WIZPAGES,0,0);
    }

    for (i = 0; i < WizPagesTypeMax ; i++) {
        MyFree(PagesFromOcManager[i]);
    }

    return;
}


#ifdef _OCM
BOOL
pOcManagerPages(
    IN     PSETUP_REQUEST_PAGES  Page,
    OUT    HPROPSHEETPAGE       *WizardPageHandles,
    IN OUT UINT                 *PageCount
    )
{
    BOOL b;

    if(Page && Page->MaxPages) {

        CopyMemory(
            &WizardPageHandles[*PageCount],
            Page->Pages,
            Page->MaxPages * sizeof(HPROPSHEETPAGE)
            );

        *PageCount += Page->MaxPages;

        b = TRUE;

    } else {

        b = FALSE;
    }

    return(b);
}
#endif


VOID
WizardUiTest(
    VOID
    )
{
    WCHAR path[MAX_PATH];

    UiTest = TRUE;

    SyssetupInf = SetupOpenInfFile(L"syssetup.inf",NULL,INF_STYLE_WIN4,NULL);
    lstrcpy(SourcePath,L"D:\\$WIN_NT$.LS");
#ifdef _OCM
    {
        PVOID OcManagerContext = FireUpOcManager();
        Wizard(OcManagerContext);
        KillOcManager(OcManagerContext);
    }
#else
    Wizard();
#endif
    SetupCloseInfFile(SyssetupInf);
}

DWORD GetPhase_InitializeEstimate ()
{
    return TIME_INITIALIZE;
}

DWORD GetPhase_InstallSecurityEstimate ()
{
    return TIME_INSTALLSECURITY;
}

DWORD GetPhase_PrecompileInfsEstimate ()
{
    return TIME_PRECOMPILEINFS;
}


DWORD GetPhase_InstallDevicesEstimate ()
{
    return TIME_INSTALLDEVICES;
}
DWORD GetPhase_InstallEnumDevices1Estimate ()
{
    return TIME_INSTALLENUMDEVICES1;
}
DWORD GetPhase_InstallLegacyDevicesEstimate ()
{
    return TIME_INSTALLLEGACYDEVICES;
}
DWORD GetPhase_InstallEnumDevices2Estimate ()
{
    return TIME_INSTALLENUMDEVICES2;
}

DWORD GetPhase_NetInstallEstimate ()
{
    return TIME_NETINSTALL;
}

DWORD GetPhase_OCInstallEstimate ()
{
    return TIME_OCINSTALL;
}

DWORD GetPhase_InstallComponentInfsEstimate ()
{
    return TIME_INSTALLCOMPONENTINFS;
}

DWORD GetPhase_Inf_RegistrationEstimate ()
{
    return TIME_INF_REGISTRATION;
}

DWORD GetPhase_RunOnce_RegistrationEstimate ()
{
    return TIME_RUNONCE_REGISTRATION;
}

DWORD GetPhase_SecurityTempatesEstimate ()
{
    return TIME_SECURITYTEMPLATE;
}

LPTSTR WinRegisteries[] = { TEXT("system.dat"),
                            TEXT("User.dat"),
                            TEXT("classes.dat"),
                            TEXT("")};

DWORD GetPhase_Win9xMigrationEstimate ()
{
    // Get the size of the registery,
    // system.dat, user.dat and classes.dat(only exiss on Millennium)
    // If the size if above 3MB, do the following
    // Substract 3MB, devide by 9000 (that should give use the through put), and add 100 seconds
    DWORD dwTime = TIME_WIN9XMIGRATION;
    DWORD dwSize = 0;
    TCHAR szRegPath[MAX_PATH];
    TCHAR szRegName[MAX_PATH];
    LPTSTR pRegName = NULL;
    UINT    index = 0;
    HANDLE          hFind;
    WIN32_FIND_DATA FindData;

    SetupDebugPrint(L"SETUP: Calculating registery size");

    if (GetWindowsDirectory(szRegPath, MAX_PATH))
    {
        pSetupConcatenatePaths (szRegPath, L"Setup\\DefHives", MAX_PATH, NULL);

        while (*WinRegisteries[index])
        {
            lstrcpy(szRegName, szRegPath);
            pSetupConcatenatePaths ( szRegName, WinRegisteries[index], MAX_PATH, NULL);
            hFind = FindFirstFile(szRegName, &FindData);
            if (hFind != INVALID_HANDLE_VALUE)
            {
                SetupDebugPrint2(L"SETUP: %s size is: %2ld",
                          szRegName,
                          FindData.nFileSizeLow
                          );
                // Don't worry about the nFileSizeHigh,
                // if that is used the registery is over 4GB
                dwSize += FindData.nFileSizeLow;
                FindClose(hFind);
            }
            index++;
        }
        // Anything below 3.000.000 byte is already in the base time
        if (dwSize > 3000000)
        {
            dwSize -= 3000000;
            // Estimated that for about 9000 bytes we need 1 second.
            dwTime += (dwSize/9000);
        }
        SetupDebugPrint1(L"SETUP: Calculated time for Win9x migration = %1ld seconds", dwTime);
    }

    return dwTime;
}

DWORD GetPhase_SFCEstimate ()
{
    return TIME_SFC;
}

DWORD GetPhase_SaveRepairEstimate ()
{
    return TIME_SAVEREPAIR;
}

DWORD GetPhase_RemoveTempFilesEstimate ()
{
    return TIME_REMOVETEMOFILES;
}

void SetTimeEstimates()
{

    SetupPhase[Phase_Initialize].Time = GetPhase_InitializeEstimate();
    SetupPhase[Phase_InstallSecurity].Time = GetPhase_InstallSecurityEstimate();
    SetupPhase[Phase_PrecompileInfs].Time = GetPhase_PrecompileInfsEstimate();
    SetupPhase[Phase_InstallEnumDevices1].Time = GetPhase_InstallEnumDevices1Estimate();
    SetupPhase[Phase_InstallLegacyDevices].Time = GetPhase_InstallLegacyDevicesEstimate();
    SetupPhase[Phase_InstallEnumDevices2].Time = GetPhase_InstallEnumDevices2Estimate();
    SetupPhase[Phase_OCInstall].Time = GetPhase_OCInstallEstimate();
    SetupPhase[Phase_InstallComponentInfs].Time = GetPhase_InstallComponentInfsEstimate();
    SetupPhase[Phase_Inf_Registration].Time = GetPhase_Inf_RegistrationEstimate();
    SetupPhase[Phase_RunOnce_Registration].Time = GetPhase_RunOnce_RegistrationEstimate();
    SetupPhase[Phase_SecurityTempates].Time = GetPhase_SecurityTempatesEstimate();
    SetupPhase[Phase_Win9xMigration].Time = GetPhase_Win9xMigrationEstimate();
    SetupPhase[Phase_SFC].Time = GetPhase_SFCEstimate();
    SetupPhase[Phase_SaveRepair].Time = GetPhase_SaveRepairEstimate();
    SetupPhase[Phase_RemoveTempFiles].Time = GetPhase_RemoveTempFilesEstimate();

}

// Returns the time remaining starting with the current "Phase"
DWORD CalcTimeRemaining(UINT Phase)
{
    UINT i;
    DWORD Time = 0;
    CurrentPhase = Phase;

    for (i = Phase; i < Phase_Reboot; i++)
    {
        // Is this a phase we always run or only when upgrading Win9x?
        if (!SetupPhase[i].Win9xUpgradeOnly)
        {
            Time += SetupPhase[i].Time;
        }
        else if (Win95Upgrade)
        {
            Time += SetupPhase[i].Time;
        }
    }
    return Time;
}

void SetRemainingTime(DWORD TimeInSeconds)
{
    DWORD Minutes;
    TCHAR MinuteString[MAX_PATH];
    TCHAR TimeLeft[MAX_PATH];
    Minutes = ((TimeInSeconds)/60) +1;
    if (Minutes > 1)
    {
        if(!LoadString(MyModuleHandle,IDS_TIMEESTIMATE_MINUTES,MinuteString, MAX_PATH))
        {
            lstrcpy(MinuteString,TEXT("Installation will complete in %d minutes or less."));
        }
        wsprintf(TimeLeft, MinuteString, Minutes);
    }
    else
    {
        if(!LoadString(MyModuleHandle,IDS_TIMEESTIMATE_LESSTHENONEMINUTE,TimeLeft, MAX_PATH))
        {
            lstrcpy(TimeLeft,TEXT("Installation will complete in less then 1 minute."));
        }
    }
    BB_SetTimeEstimateText(TimeLeft);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\watch.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    watch.c

Abstract:

    This module contains routines for watching changes to the
    current user's profile directory and the HKEY_CURRENT_USER key.

Author:

    Chuck Lenzmeier (chuckl)

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop


//
// Debugging aids.
//

#if WATCH_DEBUG

DWORD WatchDebugLevel = 0;
#define dprintf(_lvl_,_x_) if ((_lvl_) <= WatchDebugLevel) DbgPrint _x_
#define DEBUG(_x_) _x_

PWCH StartDirectoryName = TEXT("");
PWCH StartKeyName = TEXT("");
PWCH StopDirectoryName = TEXT("");
PWCH StopKeyName = TEXT("");

static PSZ Types[] = {"ACK!", "DIR  ", "FILE ", "KEY  ", "VALUE"};
static PSZ States[] = {"NONE", "CHANGED", "DELETED", "NEW", "MATCHED"};

#undef MyMalloc
#undef MyFree
#define MyMalloc MyMallocEx
#define MyFree MyFreeEx
PVOID
MyMallocEx (
    IN DWORD Size
    );
VOID
MyFreeEx (
    IN PVOID p
    );
VOID
DumpMallocStats (
    PSZ Event
    );

#else

#define dprintf(_lvl_,_x_)
#define DEBUG(_x_)
#define DumpMallocStats(_event)

#endif

//
// Additions to the change types in WatchEnum.
//

#define WATCH_NONE      0
#define WATCH_MATCHED   4


//
// Common header for container entries (directories and keys).
//

typedef struct _CONTAINER_ENTRY {
    LIST_ENTRY SiblingListEntry;
    LIST_ENTRY ContainerList;
    LIST_ENTRY ObjectList;
    struct _CONTAINER_ENTRY *Parent;
    DWORD State;
#if WATCH_DEBUG
    DWORD IsDirectory;
#endif
} CONTAINER_ENTRY, *PCONTAINER_ENTRY;

//
// Common header for object entries (files and values).
//

typedef struct _OBJECT_ENTRY {
    LIST_ENTRY SiblingListEntry;
    DWORD State;
} OBJECT_ENTRY, *POBJECT_ENTRY;

//
// Macros for manipulating containers and objects.
//

#if WATCH_DEBUG
#define SetIsDirectory(_container,_isdir) (_container)->IsDirectory = (_isdir)
#else
#define SetIsDirectory(_container,_isdir)
#endif

#define InitializeContainer(_container,_state,_parent,_isdir) { \
        InitializeListHead(&(_container)->ContainerList);       \
        InitializeListHead(&(_container)->ObjectList);          \
        (_container)->Parent = (PCONTAINER_ENTRY)(_parent);     \
        (_container)->State = (_state);                         \
        SetIsDirectory((_container),(_isdir));                  \
    }

#define InitializeObject(_object,_state) (_object)->State = (_state);

#define InsertContainer(_container,_subcontainer)                                           \
        InsertTailList(&(_container)->ContainerList,&(_subcontainer)->SiblingListEntry)

#define InsertObject(_container,_object)                                        \
        InsertTailList(&(_container)->ObjectList,&(_object)->SiblingListEntry)

#define RemoveObject(_object) RemoveEntryList(&(_object)->SiblingListEntry)
#define RemoveContainer(_container) RemoveEntryList(&(_container)->SiblingListEntry)

#define GetFirstObject(_container)                                      \
        ((_container)->ObjectList.Flink != &(_container)->ObjectList ?  \
            CONTAINING_RECORD( (_container)->ObjectList.Flink,          \
                               OBJECT_ENTRY,                            \
                               SiblingListEntry ) : NULL)

#define GetNextObject(_container,_object)                                   \
        ((_object)->SiblingListEntry.Flink != &(_container)->ObjectList ?   \
            CONTAINING_RECORD( (_object)->SiblingListEntry.Flink,           \
                               OBJECT_ENTRY,                                \
                               SiblingListEntry ) : NULL)

#define GetFirstContainer(_container)                                               \
        ((_container)->ContainerList.Flink != &(_container)->ContainerList ?        \
            CONTAINING_RECORD( (_container)->ContainerList.Flink,                   \
                               CONTAINER_ENTRY,                                     \
                               SiblingListEntry ) : NULL)

#define GetNextContainer(_container)                                                        \
        ((_container)->SiblingListEntry.Flink != &(_container)->Parent->ContainerList ?     \
            CONTAINING_RECORD( (_container)->SiblingListEntry.Flink,                        \
                               CONTAINER_ENTRY,                                             \
                               SiblingListEntry ) : NULL)

#define GetParent(_container) (_container)->Parent

#define GetEntryState(_entry) (_entry)->State
#define SetEntryState(_entry,_state) ((_entry)->State = (_state))

#if WATCH_DEBUG
#define CONTAINER_NAME(_container)                                              \
        (_container)->IsDirectory ? ((PDIRECTORY_ENTRY)(_container))->Name :    \
                                    ((PKEY_ENTRY)(_container))->Name
#define OBJECT_NAME(_container,_object)                                         \
        (_container)->IsDirectory ? ((PFILE_ENTRY)(_object))->Name :            \
                                    ((PVALUE_ENTRY)(_object))->Name
#endif

//
// Structures for entries in the watch tree.
//

typedef struct _DIRECTORY_ENTRY {
    CONTAINER_ENTRY ;
    WCHAR Name[1];
} DIRECTORY_ENTRY, *PDIRECTORY_ENTRY;

typedef struct _FILE_ENTRY {
    OBJECT_ENTRY ;
    FILETIME LastWriteTime;
    WCHAR Name[1];
} FILE_ENTRY, *PFILE_ENTRY;

typedef struct _KEY_ENTRY {
    CONTAINER_ENTRY ;
    HKEY Handle;
    WCHAR Name[1];
} KEY_ENTRY, *PKEY_ENTRY;

typedef struct _VALUE_ENTRY {
    OBJECT_ENTRY ;
    DWORD Type;
    DWORD NameLength;
    DWORD ValueDataLength;
    WCHAR Name[1];
} VALUE_ENTRY, *PVALUE_ENTRY;

//
// The root of the watch tree is allocated as a ROOT_ENTRY followed by
// a DIRECTORY_ENTRY and a KEY_ENTRY.
//

typedef struct _ROOT_ENTRY {
    PDIRECTORY_ENTRY RootDirectoryEntry;
    PKEY_ENTRY RootKeyEntry;
} ROOT_ENTRY, *PROOT_ENTRY;

//
// Macro for comparing file times.
//

#define TIMES_EQUAL(_a,_b)                              \
        (((_a).dwLowDateTime  == (_b).dwLowDateTime) && \
         ((_a).dwHighDateTime == (_b).dwHighDateTime))

typedef struct _KEY_ENUM_CONTEXT {
    PKEY_ENTRY ParentKey;
    PWCH CurrentPath;
} KEY_ENUM_CONTEXT, *PKEY_ENUM_CONTEXT;


//
// Forward declaration of local subroutines.
//

VOID
WatchFreeChildren (
    IN PCONTAINER_ENTRY Container
    );

DWORD
WatchDirStart (
    IN PROOT_ENTRY Root
    );

DWORD
WatchDirStop (
    IN PROOT_ENTRY Root
    );

DWORD
WatchKeyStart (
    IN PROOT_ENTRY Root
    );

DWORD
WatchKeyStop (
    IN PROOT_ENTRY Root
    );

DWORD
AddValueAtStart (
    IN PVOID Context,
    IN DWORD ValueNameLength,
    IN PWCH ValueName,
    IN DWORD ValueType,
    IN PVOID ValueData,
    IN DWORD ValueDataLength
    );

DWORD
AddKeyAtStart (
    IN PVOID Context,
    IN DWORD KeyNameLength,
    IN PWCH KeyName
    );

DWORD
CheckValueAtStop (
    IN PVOID Context,
    IN DWORD ValueNameLength,
    IN PWCH ValueName,
    IN DWORD ValueType,
    IN PVOID ValueData,
    IN DWORD ValueDataLength
    );

DWORD
CheckKeyAtStop (
    IN PVOID Context,
    IN DWORD KeyNameLength,
    IN PWCH KeyName
    );


DWORD
WatchStart (
    OUT PVOID *WatchHandle
    )

/*++

Routine Description:

    Starts watching.  Captures the initial state of the Start Menu directory
    and HKEY_CURRENT_USER.

Arguments:

    WatchHandle - returns a handle for calls to the other Watch routines.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PROOT_ENTRY root;
    PDIRECTORY_ENTRY rootDirectory;
    PKEY_ENTRY rootKey;
    DWORD dirSize;
    DWORD keySize;
    DWORD size;
    DWORD error;

    //
    // Calculate the size of the root entry, which includes entries for the
    // root directory and the root key.  The root directory and the root key
    // do not have names, so we don't have to allocate additional space.
    //
    // Allocate and initialize the root entry.
    //

#if !WATCH_DEBUG
    dirSize = (sizeof(DIRECTORY_ENTRY) + 7) & ~7;
    keySize = (sizeof(KEY_ENTRY) + 7) & ~7;
#else
    dirSize = (sizeof(DIRECTORY_ENTRY) + (wcslen(StartDirectoryName)*sizeof(WCHAR)) + 7) & ~7;
    keySize = (sizeof(KEY_ENTRY) + (wcslen(StartKeyName)*sizeof(WCHAR)) + 7) & ~7;
#endif

    root = MyMalloc( ((sizeof(ROOT_ENTRY) + 7) & ~7) + dirSize + keySize );
    if ( root == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    rootDirectory = (PDIRECTORY_ENTRY)(root + 1);
    rootKey = (PKEY_ENTRY)((PCHAR)rootDirectory + dirSize);

    root->RootDirectoryEntry = rootDirectory;
    root->RootKeyEntry = rootKey;

    //
    // Initialize the root directory and the root key.
    //

    InitializeContainer( rootDirectory, 0, NULL, TRUE );
    InitializeContainer( rootKey, 0, NULL, FALSE );
    rootKey->Handle = NULL;
#if !WATCH_DEBUG
    rootDirectory->Name[0] = 0;
    rootKey->Name[0] = 0;
#else
    wcscpy( rootDirectory->Name, StartDirectoryName );
    wcscpy( rootKey->Name, StartKeyName );
#endif

    //
    // Start watching the Start Menu directory and the current user key.
    //

    error = WatchDirStart( root );
    DumpMallocStats( "After WatchDirStart" );
    if ( error == NO_ERROR ) {
        error = WatchKeyStart( root );
        DumpMallocStats( "After WatchKeyStart" );
    }

    //
    // If an error occurred, free the root entry.  Otherwise, return the
    // address of the root entry as the watch handle.
    //

    if ( error != NO_ERROR ) {
        WatchFree( root );
        DumpMallocStats( "After WatchFree" );
    } else {
        *WatchHandle = root;
    }

    return error;

} // WatchStart


DWORD
WatchStop (
    IN PVOID WatchHandle
    )

/*++

Routine Description:

    Stops watching.  Compares the current state of the directory and key
    to the initial state.

Arguments:

    WatchHandle - supplies the handle returned by WatchStart.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PROOT_ENTRY root;
    DWORD error;

    root = WatchHandle;

    //
    // Stop watching the Start Menu directory and the current user key.
    // Capture the differences from the initial state.
    //

#if WATCH_DEBUG
    if ( (wcslen(StopDirectoryName) > wcslen(root->RootDirectoryEntry->Name)) ||
         (wcslen(StopKeyName) > wcslen(root->RootKeyEntry->Name)) ) {
        return ERROR_INVALID_PARAMETER;
    }
    wcscpy( root->RootDirectoryEntry->Name, StopDirectoryName );
    wcscpy( root->RootKeyEntry->Name, StopKeyName );
#endif

    error = WatchDirStop( root );
    DumpMallocStats( "After WatchDirStop" );
    if ( error == NO_ERROR ) {
        error = WatchKeyStop( root );
        DumpMallocStats( "After WatchKeyStop" );
    }

    return error;

} // WatchStop


DWORD
WatchEnum (
    IN PVOID WatchHandle,
    IN PVOID Context,
    IN PWATCH_ENUM_ROUTINE EnumRoutine
    )

/*++

Routine Description:

    Enumerates the new, changed, and deleted elements of the watched
    directory and key.  Call the EnumRoutine for each such entry.

Arguments:

    WatchHandle - handle returned by WatchStart.

    Context - context value to be passed to EnumRoutine.

    EnumRoutine - routine to call for each entry.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PROOT_ENTRY root;
    PWCH name;
    PCONTAINER_ENTRY rootContainer;
    PCONTAINER_ENTRY currentContainer;
    PCONTAINER_ENTRY container;
    POBJECT_ENTRY object;
    WATCH_ENTRY enumEntry;
    DWORD i;
    DWORD containerNameOffset;
    DWORD objectNameOffset;
    DWORD containerType;
    DWORD objectType;
    DWORD error;
    WCHAR currentPath[MAX_PATH + 1];

    root = WatchHandle;

    //
    // Loop twice -- once for the watched directory and once for
    // the watched key.
    //

    for ( i = 0; i < 2; i++ ) {

        //
        // Set up for walking the appropriate tree.
        //

        if ( i == 0 ) {
            rootContainer = (PCONTAINER_ENTRY)root->RootDirectoryEntry;
            containerType = WATCH_DIRECTORY;
            objectType = WATCH_FILE;
            containerNameOffset = FIELD_OFFSET( DIRECTORY_ENTRY, Name );
            objectNameOffset = FIELD_OFFSET( FILE_ENTRY, Name );
        } else {
            rootContainer = (PCONTAINER_ENTRY)root->RootKeyEntry;
            containerType = WATCH_KEY;
            objectType = WATCH_VALUE;
            containerNameOffset = FIELD_OFFSET( KEY_ENTRY, Name );
            objectNameOffset = FIELD_OFFSET( VALUE_ENTRY, Name );
        }

        currentContainer = rootContainer;
        wcscpy( currentPath, (PWCH)((PCHAR)rootContainer + containerNameOffset) );
        enumEntry.Name = currentPath;
        if ( wcslen(currentPath) == 0 ) {
            enumEntry.Name += 1;    // skip leading backslash
        }

        do {

            //
            // Call the EnumRoutine for each object (file/value) in the
            // container (directory/key).  All objects remaining in the
            // tree are either changed, new, or deleted.
            //

            object = GetFirstObject( currentContainer );
            while ( object != NULL ) {
                enumEntry.EntryType = objectType;
                enumEntry.ChangeType = GetEntryState( object );
                wcscat( currentPath, L"\\" );
                wcscat( currentPath, (PWCH)((PCHAR)object + objectNameOffset) );
                error = EnumRoutine( Context, &enumEntry );
                if ( error != NO_ERROR ) {
                    dprintf( 0, ("EnumRoutine returned %d\n", error) );
                    return error;
                }
                *wcsrchr(currentPath, L'\\') = 0;
                object = GetNextObject( currentContainer, object );
            }

            //
            // If the current container has subcontainers, recurse
            // into the first one.
            //

            container = GetFirstContainer( currentContainer );
            if ( container != NULL ) {

                currentContainer = container;
                wcscat( currentPath, L"\\" );
                wcscat( currentPath, (PWCH)((PCHAR)currentContainer + containerNameOffset) );

            } else {

                //
                // The container has no subcontainers.  Walk back up the
                // tree looking for a sibling container to process.
                //

                while ( TRUE ) {

                    //
                    // If the current container is the root container, we're done.
                    //

                    if ( currentContainer == rootContainer ) {
                        currentContainer = NULL;
                        break;
                    }

                    //
                    // If the current container is new or deleted, call
                    // the EnumRoutine.
                    //

                    if ( GetEntryState(currentContainer) != WATCH_MATCHED ) {
                        enumEntry.EntryType = containerType;
                        enumEntry.ChangeType = GetEntryState( currentContainer );
                        error = EnumRoutine( Context, &enumEntry );
                        if ( error != NO_ERROR ) {
                            dprintf( 0, ("EnumRoutine returned %d\n", error) );
                            return error;
                        }
                    }

                    //
                    // Strip the name of the current container off of the path.
                    //

                    *wcsrchr(currentPath, L'\\') = 0;

                    //
                    // If the parent container has more subcontainers, recurse
                    // into the next one.  Otherwise, move up to the parent
                    // container and try again.
                    //

                    container = GetNextContainer( currentContainer );
                    if ( container != NULL ) {
                        currentContainer = container;
                        wcscat( currentPath, L"\\" );
                        wcscat( currentPath, (PWCH)((PCHAR)currentContainer + containerNameOffset) );
                        break;
                    } else {
                        currentContainer = GetParent( currentContainer );
                    }
                }
            }

        } while ( currentContainer != NULL );

    } // for

    return NO_ERROR;

} // WatchEnum


VOID
WatchFree (
    IN PVOID WatchHandle
    )

/*++

Routine Description:

    Frees the watch data structures.

Arguments:

    WatchHandle - supplies the handle returned by WatchStart.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PROOT_ENTRY root;

    root = WatchHandle;

    //
    // Free the directory tree, and key tree, and the root entry.
    //

    WatchFreeChildren( (PCONTAINER_ENTRY)root->RootDirectoryEntry );
    WatchFreeChildren( (PCONTAINER_ENTRY)root->RootKeyEntry );

    MyFree( root );

    DumpMallocStats( "After WatchFree" );

    return;

} // WatchFree


VOID
WatchFreeChildren (
    IN PCONTAINER_ENTRY RootContainer
    )

/*++

Routine Description:

    Frees the children of a container (directory or key).  Note that the
    container itself is not freed.

Arguments:

    RootContainer - the container whose children are to be freed.

Return Value:

    None.

--*/

{
    PCONTAINER_ENTRY currentContainer;
    PCONTAINER_ENTRY container;
    PCONTAINER_ENTRY parent;
    POBJECT_ENTRY object;
#if WATCH_DEBUG
    WCHAR currentPath[MAX_PATH + 1];
#endif

    DEBUG( wcscpy( currentPath, CONTAINER_NAME(RootContainer) ) );

    //
    // Delete children starting at the root container.
    //

    currentContainer = RootContainer;

    do {

        //
        // Delete all objects (files or values) within the container.
        //

        object = GetFirstObject( currentContainer );
        while ( object != NULL ) {
            dprintf( 2, ("Deleting entry for object %ws\\%ws: %s\n", currentPath, OBJECT_NAME(currentContainer,object), States[GetEntryState(object)]) );
            RemoveObject( object );
            MyFree( object );
            object = GetFirstObject( currentContainer );
        }

        //
        // If the container has subcontainers, recurse into the first one.
        //

        container = GetFirstContainer( currentContainer );
        if ( container != NULL ) {

            currentContainer = container;
            DEBUG( wcscat( currentPath, L"\\" ) );
            DEBUG( wcscat( currentPath, CONTAINER_NAME(currentContainer) ) );

        } else {

            //
            // The container has no subcontainers.  Walk back up the
            // tree looking for a sibling container to process.
            //

            while ( TRUE ) {

                //
                // If the current container is the root container, we're done.
                //

                if ( currentContainer == RootContainer ) {
                    currentContainer = NULL;
                    break;
                }

                DEBUG( dprintf( 2, ("Deleting entry for container %ws: %s\n", currentPath, States[GetEntryState(currentContainer)]) ) );
                DEBUG( *wcsrchr(currentPath, L'\\') = 0 );

                //
                // Free the current container.
                //

                parent = GetParent( currentContainer );
                RemoveContainer( currentContainer );
                MyFree( currentContainer );

                //
                // If the parent container has more subcontainers,
                // recurse into the first one.  Otherwise, move up
                // to the parent container and loop back to free it.
                //

                currentContainer = GetFirstContainer( parent );
                if ( currentContainer != NULL ) {
                    DEBUG( wcscat( currentPath, L"\\" ) );
                    DEBUG( wcscat( currentPath, CONTAINER_NAME(currentContainer) ) );
                    break;
                } else {
                    currentContainer = parent;
                }
            }
        }

    } while ( currentContainer != NULL );

    return;

} // WatchFreeChildren


DWORD
WatchDirStart (
    IN PROOT_ENTRY Root
    )

/*++

Routine Description:

    Starts watching the current user's profile directory.  Captures the
    initial state of the directory tree.

Arguments:

    Root - pointer to the ROOT_ENTRY allocated by WatchStart.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PDIRECTORY_ENTRY rootDirectory;
    PDIRECTORY_ENTRY currentDirectory;
    PDIRECTORY_ENTRY newDirectory;
    PFILE_ENTRY newFile;
    WIN32_FIND_DATA fileData;
    HANDLE findHandle;
    DWORD error;
    BOOL ok;
    WCHAR currentPath[MAX_PATH + 1];

    //
    // Get the address of the root directory entry.
    //

    rootDirectory = Root->RootDirectoryEntry;
    currentDirectory = rootDirectory;

    //
    // Get the full path to the current user's profile directory.
    //

    ok = GetSpecialFolderPath ( CSIDL_PROGRAMS, currentPath );
    if ( !ok ) {
        return GetLastError();
    }
    DEBUG( if ( wcslen( rootDirectory->Name ) != 0 ) {
        wcscat( currentPath, TEXT("\\") );
        wcscat( currentPath, rootDirectory->Name );
    } )

    do {

        //
        // Look for files/directories in the current directory.
        //

        wcscat( currentPath, L"\\*" );
        dprintf( 2, ("FindFirst for %ws\n", currentPath) );
        findHandle = FindFirstFile( currentPath, &fileData );
        currentPath[wcslen(currentPath) - 2] = 0;

        if ( findHandle != INVALID_HANDLE_VALUE ) {

            do {

                if ( FlagOff(fileData.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY) ) {

                    //
                    // The entry returned is for a file.  Add it to the tree,
                    // capturing the file's LastWriteTime.
                    //

                    dprintf( 2, ("  found file %ws\\%ws\n", currentPath, fileData.cFileName) );
                    newFile = MyMalloc( (DWORD)(sizeof(FILE_ENTRY) - sizeof(WCHAR) +
                                        ((wcslen(fileData.cFileName) + 1) * sizeof(WCHAR))) );
                    if ( newFile == NULL ) {
                        FindClose( findHandle );
                        return ERROR_NOT_ENOUGH_MEMORY;
                    }

                    InitializeObject( newFile, 0 );
                    wcscpy( newFile->Name, fileData.cFileName );
                    newFile->LastWriteTime = fileData.ftLastWriteTime;
                    InsertObject( currentDirectory, newFile );

                } else if ((wcscmp(fileData.cFileName,L".") != 0) &&
                           (wcscmp(fileData.cFileName,L"..") != 0)) {

                    //
                    // The entry returned is for a directory.  Add it to the tree.
                    //

                    dprintf( 2, ("  found directory %ws\\%ws\n", currentPath, fileData.cFileName) );
                    newDirectory = MyMalloc( (DWORD)(sizeof(DIRECTORY_ENTRY) - sizeof(WCHAR) +
                                             ((wcslen(fileData.cFileName) + 1) * sizeof(WCHAR))) );
                    if ( newDirectory == NULL ) {
                        FindClose( findHandle );
                        return ERROR_NOT_ENOUGH_MEMORY;
                    }

                    InitializeContainer( newDirectory, 0, currentDirectory, TRUE );
                    wcscpy( newDirectory->Name, fileData.cFileName );
                    InsertContainer( currentDirectory, newDirectory );

                }

                //
                // Find another entry in the directory.
                //

                ok = FindNextFile( findHandle, &fileData );

            } while ( ok );

            //
            // All entries found.  Close the find handle.
            //

            FindClose( findHandle );

        } // findHandle != INVALID_HANDLE_VALUE

        //
        // If the current directory has subdirectories, recurse into the
        // first one.
        //

        newDirectory = (PDIRECTORY_ENTRY)GetFirstContainer( currentDirectory );
        if ( newDirectory != NULL ) {

            currentDirectory = newDirectory;
            wcscat( currentPath, L"\\" );
            wcscat( currentPath, currentDirectory->Name );

        } else {

            //
            // The directory has no subdirectories.  Walk back up the
            // tree looking for a sibling directory to process.
            //

            while ( TRUE ) {

                //
                // If the current directory is the root directory, we're done.
                //

                if ( currentDirectory == rootDirectory ) {
                    currentDirectory = NULL;
                    break;
                }

                //
                // Strip the name of the current directory off of the path.
                //

                *wcsrchr(currentPath, L'\\') = 0;

                //
                // If the parent directory has more subdirectories,
                // recurse into the next one.  Otherwise, move up
                // to the parent directory and try again.
                //

                newDirectory = (PDIRECTORY_ENTRY)GetNextContainer( currentDirectory );
                if ( newDirectory != NULL ) {
                    currentDirectory = newDirectory;
                    wcscat( currentPath, L"\\" );
                    wcscat( currentPath, currentDirectory->Name );
                    break;
                } else {
                    currentDirectory = (PDIRECTORY_ENTRY)GetParent( currentDirectory );
                }
            }
        }

    } while ( currentDirectory != NULL );

    return NO_ERROR;

} // WatchDirStart


DWORD
WatchDirStop (
    IN PROOT_ENTRY Root
    )

/*++

Routine Description:

    Stops watching the current user's profile directory.  Captures the
    differences between the initial state and the current state.

Arguments:

    Root - pointer to the ROOT_ENTRY allocated by WatchStart.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PDIRECTORY_ENTRY rootDirectory;
    PDIRECTORY_ENTRY currentDirectory;
    PDIRECTORY_ENTRY directory;
    PFILE_ENTRY file;
    WIN32_FIND_DATA fileData;
    HANDLE findHandle;
    DWORD error;
    BOOL ok;
    WCHAR currentPath[MAX_PATH + 1];

    //
    // Get the address of the root directory entry.
    //

    rootDirectory = Root->RootDirectoryEntry;
    currentDirectory = rootDirectory;

    //
    // Get the full path to the current user's directory.
    //

    ok = GetSpecialFolderPath ( CSIDL_PROGRAMS, currentPath );
    if ( !ok ) {
        return GetLastError();
    }
    DEBUG( if ( wcslen( rootDirectory->Name ) != 0 ) {
        wcscat( currentPath, TEXT("\\") );
        wcscat( currentPath, rootDirectory->Name );
    } )

    do {

        //
        // Look for files/directories in the current directory.
        //

        wcscat( currentPath, L"\\*" );
        dprintf( 2, ("FindFirst for %ws\n", currentPath) );
        findHandle = FindFirstFile( currentPath, &fileData );
        currentPath[wcslen(currentPath) - 2] = 0;

        if ( findHandle != INVALID_HANDLE_VALUE ) {

            do {

                if ( FlagOff(fileData.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY) ) {

                    //
                    // The entry returned is for a file.  Check to see if
                    // this file existed at the start.
                    //

                    dprintf( 2, ("  found file %ws\\%ws\n", currentPath, fileData.cFileName) );
                    ok = FALSE;
                    file = (PFILE_ENTRY)GetFirstObject( currentDirectory );
                    while ( file != NULL ) {
                        if ( _wcsicmp( file->Name, fileData.cFileName ) == 0 ) {
                            ok = TRUE;
                            break;
                        }
                        file = (PFILE_ENTRY)GetNextObject( currentDirectory, file );
                    }

                    if ( ok ) {

                        //
                        // The file existed at the start.  If its LastWriteTime
                        // hasn't changed, remove it from the watch tree.
                        // Otherwise, mark it as changed.
                        //

                        if ( TIMES_EQUAL( file->LastWriteTime, fileData.ftLastWriteTime ) ) {
                            dprintf( 2, ("  Deleting entry for unchanged file %ws\\%ws\n", currentPath, file->Name) );
                            RemoveObject( file );
                            MyFree( file );
                        } else {
                            dprintf( 1, ("  Marking entry for changed file %ws\\%ws\n", currentPath, file->Name) );
                            SetEntryState( file, WATCH_CHANGED );
                        }

                    } else {

                        //
                        // The file is new.  Add it to the tree.
                        //

                        file = MyMalloc( (DWORD)(sizeof(FILE_ENTRY) - sizeof(WCHAR) +
                                         ((wcslen(fileData.cFileName) + 1) * sizeof(WCHAR))) );
                        if ( file == NULL ) {
                            FindClose( findHandle );
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }

                        InitializeObject( file, WATCH_NEW );
                        wcscpy( file->Name, fileData.cFileName );
                        dprintf( 1, ("  Adding entry for new file %ws\\%ws\n", currentPath, file->Name) );
                        InsertObject( currentDirectory, file );
                    }

                } else if ((wcscmp(fileData.cFileName,L".") != 0) &&
                           (wcscmp(fileData.cFileName,L"..") != 0)) {

                    //
                    // The entry returned is for a directory.  Check to see if
                    // this directory existed at the start.
                    //

                    dprintf( 2, ("  found directory %ws\\%ws\n", currentPath, fileData.cFileName) );
                    ok = FALSE;
                    directory = (PDIRECTORY_ENTRY)GetFirstContainer( currentDirectory );
                    while ( directory != NULL ) {
                        if ( _wcsicmp( directory->Name, fileData.cFileName ) == 0 ) {
                            ok = TRUE;
                            break;
                        }
                        directory = (PDIRECTORY_ENTRY)GetNextContainer( directory );
                    }

                    if ( ok ) {

                        //
                        // The directory existed at the start.  Mark it as
                        // matched.  (We can't delete matched directories,
                        // as we do files, because they need to be in the
                        // tree for recursion.)
                        //

                        SetEntryState( directory, WATCH_MATCHED );

                    } else {

                        //
                        // The directory is new.  Add it to the tree.
                        //

                        directory = MyMalloc( (DWORD)(sizeof(DIRECTORY_ENTRY) - sizeof(WCHAR) +
                                            ((wcslen(fileData.cFileName) + 1) * sizeof(WCHAR))) );
                        if ( directory == NULL ) {
                            FindClose( findHandle );
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }

                        InitializeContainer( directory, WATCH_NEW, currentDirectory, TRUE );
                        wcscpy( directory->Name, fileData.cFileName );
                        dprintf( 1, ("  Adding entry for new directory %ws\\%ws\n", currentPath, directory->Name) );
                        InsertContainer( currentDirectory, directory );
                    }

                }

                //
                // Find another entry in the directory.
                //

                ok = FindNextFile( findHandle, &fileData );

            } while ( ok );

            //
            // All entries found.  Close the find handle.
            //

            FindClose( findHandle );

        } // findHandle != INVALID_HANDLE_VALUE

        //
        // Any file entries in the current directory that were not removed
        // (because they were matched), marked as changed (because the
        // file time had changed), or added (for new files) represent files
        // that have been deleted.  Mark them as such.
        //

        file = (PFILE_ENTRY)GetFirstObject( currentDirectory );
        while ( file != NULL ) {
            if ( GetEntryState(file) == WATCH_NONE ) {
                dprintf( 1, ("  Marking entry for deleted file %ws\\%ws\n", currentPath, file->Name) );
                SetEntryState( file, WATCH_DELETED );
            }
            file = (PFILE_ENTRY)GetNextObject( currentDirectory, file );
        }

        //
        // Any subdirectory entries in the current directory that were not
        // marked as matched (directory still exists) or added (new directory)
        // represent directories that have been deleted.  Mark them as such
        // and delete the entries for the their children -- we don't need
        // these entries any more.
        //

        directory = (PDIRECTORY_ENTRY)GetFirstContainer( currentDirectory );
        while ( directory != NULL ) {
            if ( GetEntryState(directory) == WATCH_NONE ) {
                dprintf( 1, ("  Marking entry for deleted directory %ws\\%ws\n", currentPath, directory->Name) );
                SetEntryState( directory, WATCH_DELETED );
                WatchFreeChildren( (PCONTAINER_ENTRY)directory );
            }
            directory = (PDIRECTORY_ENTRY)GetNextContainer( directory );
        }

        //
        // Find a subdirectory of the current directory that is marked as
        // matched.  We don't need to walk the subtrees for new or deleted
        // directories.
        //

        directory = (PDIRECTORY_ENTRY)GetFirstContainer( currentDirectory );
        while ( directory != NULL ) {
            if ( GetEntryState(directory) == WATCH_MATCHED ) {
                break;
            }
            directory = (PDIRECTORY_ENTRY)GetNextContainer( directory );
        }

        //
        // If a matched subdirectory was found, recurse into it.
        //

        if ( directory != NULL ) {

            currentDirectory = directory;
            wcscat( currentPath, L"\\" );
            wcscat( currentPath, currentDirectory->Name );

        } else {

            //
            // The directory has no matched subdirectories.  Walk back up the
            // tree looking for a sibling directory to process.
            //

            while ( TRUE ) {

                //
                // If the current directory is the root directory, we're done.
                //

                if ( currentDirectory == rootDirectory ) {
                    currentDirectory = NULL;
                    break;
                }

                //
                // Strip the name of the current directory off of the path.
                //

                *wcsrchr(currentPath, L'\\') = 0;

                //
                // If the parent directories has more matched subdirectories,
                // recurse into the next one.  Otherwise, move up to the
                // parent directory and try again.
                //

                directory = (PDIRECTORY_ENTRY)GetNextContainer( currentDirectory );
                while ( directory != NULL ) {
                    if ( GetEntryState(directory) == WATCH_MATCHED ) {
                        break;
                    }
                    directory = (PDIRECTORY_ENTRY)GetNextContainer( directory );
                }

                if ( directory != NULL ) {

                    currentDirectory = directory;
                    wcscat( currentPath, L"\\" );
                    wcscat( currentPath, currentDirectory->Name );
                    break;

                } else {

                    currentDirectory = (PDIRECTORY_ENTRY)GetParent( currentDirectory );
                }
            }
        }

    } while ( currentDirectory != NULL );

    return NO_ERROR;

} // WatchDirStop


DWORD
WatchKeyStart (
    IN PROOT_ENTRY Root
    )

/*++

Routine Description:

    Starts watching the current user key.  Captures the initial state of the
    key tree.

Arguments:

    Root - pointer to the ROOT_ENTRY allocated by WatchStart.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PKEY_ENTRY rootKey;
    PKEY_ENTRY currentKey;
    PKEY_ENTRY newKey;
    DWORD error;
    KEY_ENUM_CONTEXT context;
#if WATCH_DEBUG
    WCHAR currentPath[MAX_PATH + 1];
#endif

    //
    // Get the address of the root key entry.
    //

    rootKey = Root->RootKeyEntry;
    currentKey = rootKey;
    DEBUG( wcscpy( currentPath, rootKey->Name ) );

    do {

        //
        // Open the current key.  If the current key is the root key, then
        // just use the HKEY_CURRENT_USER predefined key.  Otherwise, open
        // the current key relative to the parent key.
        //

        if ( (currentKey == rootKey)
#if WATCH_DEBUG
             && (wcslen(currentKey->Name) == 0)
#endif
           ) {
            currentKey->Handle = HKEY_CURRENT_USER;
        } else {
            error = RegOpenKeyEx(
#if WATCH_DEBUG
                                  currentKey == rootKey ?
                                    HKEY_CURRENT_USER :
#endif
                                    ((PKEY_ENTRY)GetParent(currentKey))->Handle,
                                  currentKey->Name,
                                  0,
                                  KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                                  &currentKey->Handle );
            if ( error != NO_ERROR ) {
                goto cleanup;
            }
        }

        //
        // Enumerate the values and subkeys of the key, adding entries
        // to the watch tree for each one.
        //

        context.ParentKey = currentKey;
        DEBUG( context.CurrentPath = currentPath );
        error = EnumerateKey( currentKey->Handle,
                              &context,
                              AddValueAtStart,
                              AddKeyAtStart );
        if ( error != NO_ERROR ) {
            goto cleanup;
        }

        //
        // If the current key has subkeys, recurse into the first one.
        //

        newKey = (PKEY_ENTRY)GetFirstContainer( currentKey );
        if ( newKey != NULL ) {

            currentKey = newKey;
            DEBUG( wcscat( currentPath, L"\\" ) );
            DEBUG( wcscat( currentPath, currentKey->Name ) );

        } else {

            //
            // The key has no subkeys.  Walk back up the tree looking
            // for a sibling key to process.
            //

            while ( TRUE ) {

                //
                // Close the handle to the key.
                //

                if ( currentKey->Handle != HKEY_CURRENT_USER ) {
                    RegCloseKey( currentKey->Handle );
                }
                currentKey->Handle = NULL;

                //
                // If the current key is the root key, we're done.
                //

                if ( currentKey == rootKey ) {
                    currentKey = NULL;
                    break;
                }

                DEBUG( *wcsrchr(currentPath, L'\\') = 0 );

                //
                // If the parent key has more subkeys, recurse into the next
                // one.  Otherwise, move up to the parent key and try again.
                //

                newKey = (PKEY_ENTRY)GetNextContainer( currentKey );
                if ( newKey != NULL ) {
                    currentKey = newKey;
                    DEBUG( wcscat( currentPath, L"\\" ) );
                    DEBUG( wcscat( currentPath, currentKey->Name ) );
                    break;
                } else {
                    currentKey = (PKEY_ENTRY)GetParent( currentKey );
                }
            }
        }

    } while ( currentKey != NULL );

    return NO_ERROR;

cleanup:

    //
    // Error cleanup.  Walk back up the tree closing handles.
    //

    do {
        if ( (currentKey->Handle != NULL) && (currentKey->Handle != HKEY_CURRENT_USER) ) {
            RegCloseKey( currentKey->Handle );
        }
        currentKey->Handle = NULL;
        currentKey = (PKEY_ENTRY)GetParent( currentKey );
    } while ( currentKey != NULL );

    return error;

} // WatchKeyStart


DWORD
WatchKeyStop (
    IN PROOT_ENTRY Root
    )

/*++

Routine Description:

    Stops watching the current user key.  Captures the differences
    between the initial state and the current state.

Arguments:

    Root - pointer to the ROOT_ENTRY allocated by WatchStart.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PKEY_ENTRY rootKey;
    PKEY_ENTRY currentKey;
    PKEY_ENTRY key;
    PVALUE_ENTRY value;
    DWORD error;
    KEY_ENUM_CONTEXT context;
#if WATCH_DEBUG
    WCHAR currentPath[MAX_PATH + 1];
#endif

    //
    // Get the address of the root key entry.
    //

    rootKey = Root->RootKeyEntry;
    currentKey = rootKey;
    DEBUG( wcscpy( currentPath, rootKey->Name ) );

    do {

        //
        // Open the current key.  If the current key is the root key, then
        // just use the HKEY_CURRENT_USER predefined key.  Otherwise, open
        // the current key relative to the parent key.
        //

        if ( (currentKey == rootKey)
#if WATCH_DEBUG
             && (wcslen(currentKey->Name) == 0)
#endif
           ) {
            currentKey->Handle = HKEY_CURRENT_USER;
        } else {
            error = RegOpenKeyEx(
#if WATCH_DEBUG
                                  currentKey == rootKey ?
                                    HKEY_CURRENT_USER :
#endif
                                    ((PKEY_ENTRY)GetParent(currentKey))->Handle,
                                  currentKey->Name,
                                  0,
                                  KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                                  &currentKey->Handle );
            if ( error != NO_ERROR ) {
                goto cleanup;
            }
        }

        //
        // Enumerate the values and subkeys of the key, checking entries
        // in the watch tree for each one.
        //

        context.ParentKey = currentKey;
        DEBUG( context.CurrentPath = currentPath );
        error = EnumerateKey( currentKey->Handle,
                              &context,
                              CheckValueAtStop,
                              CheckKeyAtStop );
        if ( error != NO_ERROR ) {
            goto cleanup;
        }

        //
        // Any value entries in the current key that were not removed
        // (because they were matched), marked as changed (because the
        // value data had changed), or added (for new values) represent
        // values that have been deleted.  Mark them as such.
        //

        value = (PVALUE_ENTRY)GetFirstObject( currentKey );
        while ( value != NULL ) {
            if ( GetEntryState(value) == WATCH_NONE ) {
                dprintf( 1, ("  Marking entry for deleted value %ws\\%ws\n", currentPath, value->Name) );
                SetEntryState( value, WATCH_DELETED );
            }
            value = (PVALUE_ENTRY)GetNextObject( currentKey, value );
        }

        //
        // Any subkey entries in the current key that were not marked as
        // matched (subkey still exists) or added (new subkey) represent
        // subkeys that have been deleted.  Mark them as such and delete
        // the entries for the their children -- we don't need these
        // entries any more.
        //

        key = (PKEY_ENTRY)GetFirstContainer( currentKey );
        while ( key != NULL ) {
            if ( GetEntryState(key) == WATCH_NONE ) {
                dprintf( 1, ("  Marking entry for deleted key %ws\\%ws\n", currentPath, key->Name) );
                SetEntryState( key, WATCH_DELETED );
                WatchFreeChildren( (PCONTAINER_ENTRY)key );
            }
            key = (PKEY_ENTRY)GetNextContainer( key );
        }

        //
        // Find a subkey of the current directory that is marked as matched.
        // We don't need to walk the subtrees for new or deleted keys.
        //

        key = (PKEY_ENTRY)GetFirstContainer( currentKey );
        while ( key != NULL ) {
            if ( GetEntryState(key) == WATCH_MATCHED ) {
                break;
            }
            key = (PKEY_ENTRY)GetNextContainer( key );
        }

        //
        // If a matched subkey was found, recurse into it.
        //

        if ( key != NULL ) {

            currentKey = key;
            DEBUG( wcscat( currentPath, L"\\" ) );
            DEBUG( wcscat( currentPath, currentKey->Name ) );

        } else {

            //
            // The key has no matched subkeys.  Walk back up the
            // tree looking for a sibling key to process.
            //

            while ( TRUE ) {

                //
                // Close the handle to the key.
                //

                if ( currentKey->Handle != HKEY_CURRENT_USER ) {
                    RegCloseKey( currentKey->Handle );
                }
                currentKey->Handle = NULL;

                //
                // If the current key is the root key, we're done.
                //

                if ( currentKey == rootKey ) {
                    currentKey = NULL;
                    break;
                }

                DEBUG( *wcsrchr(currentPath, L'\\') = 0 );

                //
                // If the parent key has more matched subkeys, recurse
                // into the next one.  Otherwise, move up to the parent
                // key and try again.
                //

                key = (PKEY_ENTRY)GetNextContainer( currentKey );
                while ( key != NULL ) {
                    if ( GetEntryState(key) == WATCH_MATCHED ) {
                        break;
                    }
                    key = (PKEY_ENTRY)GetNextContainer( key );
                }

                if ( key != NULL ) {
                    currentKey = key;
                    DEBUG( wcscat( currentPath, L"\\" ) );
                    DEBUG( wcscat( currentPath, currentKey->Name ) );
                    break;
                } else {
                    currentKey = (PKEY_ENTRY)GetParent( currentKey );
                }
            }
        }

    } while ( currentKey != NULL );

    return NO_ERROR;

cleanup:

    //
    // Error cleanup.  Walk back up the tree closing handles.
    //

    do {
        if ( (currentKey->Handle != NULL) && (currentKey->Handle != HKEY_CURRENT_USER) ) {
            RegCloseKey( currentKey->Handle );
        }
        currentKey->Handle = NULL;
        currentKey = (PKEY_ENTRY)GetParent( currentKey );
    } while ( currentKey != NULL );

    return error;

} // WatchKeyStop


DWORD
EnumerateKey (
    IN HKEY KeyHandle,
    IN PVOID Context,
    IN PVALUE_ENUM_ROUTINE ValueEnumRoutine OPTIONAL,
    IN PKEY_ENUM_ROUTINE KeyEnumRoutine OPTIONAL
    )

/*++

Routine Description:

    Enumerates the values and subkeys in a key.  Calls an EnumRoutine for
    each value and subkey.

Arguments:

    KeyHandle - handle to the key to be enumerated.

    Context - context value to be passed to EnumRoutine.

    ValueEnumRoutine - routine to call for each value.  If omitted, values
        are not enumerated.

    KeyEnumRoutine - routine to call for each key.  If omitted, keys are
        not enumerated.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    DWORD error;
    DWORD keyCount;
    DWORD valueCount;
    DWORD i;
    DWORD type;
    DWORD nameLength;
    DWORD maxKeyNameLength;
    DWORD maxValueNameLength;
    DWORD dataLength;
    DWORD maxValueDataLength;
    PWCH nameBuffer;
    PVOID dataBuffer;
    FILETIME time;

    //
    // Query information about the key that is needed to query
    // its values and subkeys.
    //

    error = RegQueryInfoKey( KeyHandle,
                             NULL,
                             NULL,
                             NULL,
                             &keyCount,
                             &maxKeyNameLength,
                             NULL,
                             &valueCount,
                             &maxValueNameLength,
                             &maxValueDataLength,
                             NULL,
                             NULL );
    if ( error != NO_ERROR ) {
        return error;
    }

    if ( ValueEnumRoutine != NULL ) {

        //
        // Allocate a buffer large enough for the longest value name and
        // another buffer large enough for the longest value data.
        //

        nameBuffer = MyMalloc( (maxValueNameLength + 1) * sizeof(WCHAR) );
        if ( nameBuffer == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        dataBuffer = MyMalloc( maxValueDataLength );
        if ( dataBuffer == NULL ) {
            MyFree( nameBuffer );
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Query the key's values.
        //

        for ( i = 0; i < valueCount; i++ ) {

            nameLength = maxValueNameLength + 1;
            dataLength = maxValueDataLength;

            error = RegEnumValue( KeyHandle,
                                  i,
                                  nameBuffer,
                                  &nameLength,
                                  NULL,
                                  &type,
                                  dataBuffer,
                                  &dataLength );
            if ( error != NO_ERROR ) {
                MyFree( dataBuffer );
                MyFree( nameBuffer );
                return error;
            }

            //
            // Call the EnumRoutine.
            //

            error = ValueEnumRoutine( Context,
                                      nameLength,
                                      nameBuffer,
                                      type,
                                      dataBuffer,
                                      dataLength );
            if ( error != NO_ERROR ) {
                MyFree( dataBuffer );
                MyFree( nameBuffer );
                return error;
            }
        }

        //
        // Free the value data and value name buffers.
        //

        MyFree( dataBuffer );
        dataBuffer = NULL;
        MyFree( nameBuffer );
    }

    if ( KeyEnumRoutine != NULL) {

        //
        // Allocate a buffer large enough for the longest subkey name.
        //

        nameBuffer = MyMalloc( (maxKeyNameLength + 1) * sizeof(WCHAR) );
        if ( nameBuffer == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Query the key's subkeys.
        //

        for ( i = 0; i < keyCount; i++ ) {

            nameLength = maxKeyNameLength + 1;

            error = RegEnumKeyEx( KeyHandle,
                                  i,
                                  nameBuffer,
                                  &nameLength,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &time );
            if ( error != NO_ERROR ) {
                MyFree( nameBuffer );
                return error;
            }

            //
            // Call the EnumRoutine.
            //

            error = KeyEnumRoutine( Context,
                                    nameLength,
                                    nameBuffer );
            if ( error != NO_ERROR ) {
                MyFree( nameBuffer );
                return error;
            }
        }

        //
        // Free the key name buffer.
        //

        MyFree( nameBuffer );
    }

    return NO_ERROR;

} // EnumerateKey


DWORD
AddValueAtStart (
    IN PVOID Context,
    IN DWORD ValueNameLength,
    IN PWCH ValueName,
    IN DWORD ValueType,
    IN PVOID ValueData,
    IN DWORD ValueDataLength
    )

/*++

Routine Description:

    Adds a value entry to the watch tree during WatchKeyStart.

Arguments:

    Context - context value passed to EnumerateKey.

    ValueNameLength - length in characters of ValueName.

    ValueName - pointer to name of the value.

    ValueType - type of the value data.

    ValueData - pointer to value data.

    ValueDataLength - length in bytes of ValueData.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PKEY_ENUM_CONTEXT context = Context;
    PVALUE_ENTRY newValue;

    //
    // Add the value to the tree, capturing the value data.
    //

    dprintf( 2, ("  found value %ws\\%ws\n", context->CurrentPath, ValueName) );

    newValue = MyMalloc( sizeof(VALUE_ENTRY) - sizeof(WCHAR) +
                         ((ValueNameLength + 1) * sizeof(WCHAR)) +
                         ValueDataLength );
    if ( newValue == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    InitializeObject( newValue, 0 );
    wcscpy( newValue->Name, ValueName );
    newValue->Type = ValueType;
    newValue->NameLength = ValueNameLength;
    newValue->ValueDataLength = ValueDataLength;
    memcpy( &newValue->Name + ValueNameLength + 1, ValueData, ValueDataLength );

    InsertObject( context->ParentKey, newValue );

    return NO_ERROR;

} // AddValueAtStart


DWORD
AddKeyAtStart (
    IN PVOID Context,
    IN DWORD KeyNameLength,
    IN PWCH KeyName
    )

/*++

Routine Description:

    Adds a key entry to the watch tree during WatchKeyStart.

Arguments:

    Context - context value passed to EnumerateKey.

    KeyNameLength - length in characters of KeyName.

    KeyName - pointer to name of the key.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PKEY_ENUM_CONTEXT context = Context;
    PKEY_ENTRY newKey;

    //
    // Add the key to the tree.
    //

    dprintf( 2, ("  found key %ws\\%ws\n", context->CurrentPath, KeyName) );

    newKey = MyMalloc( sizeof(KEY_ENTRY) - sizeof(WCHAR) +
                       ((KeyNameLength + 1) * sizeof(WCHAR)) );
    if ( newKey == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    InitializeContainer( newKey, 0, context->ParentKey, FALSE );
    wcscpy( newKey->Name, KeyName );
    newKey->Handle = NULL;

    InsertContainer( context->ParentKey, newKey );

    return NO_ERROR;

} // AddKeyAtStart


DWORD
CheckValueAtStop (
    IN PVOID Context,
    IN DWORD ValueNameLength,
    IN PWCH ValueName,
    IN DWORD ValueType,
    IN PVOID ValueData,
    IN DWORD ValueDataLength
    )

/*++

Routine Description:

    Checks the watch tree for an enumerated value during WatchKeyStop.

Arguments:

    Context - context value passed to EnumerateKey.

    ValueNameLength - length in characters of ValueName.

    ValueName - pointer to name of the value.

    ValueType - type of the value data.

    ValueData - pointer to value data.

    ValueDataLength - length in bytes of ValueData.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PKEY_ENUM_CONTEXT context = Context;
    PVALUE_ENTRY value;
    BOOL ok;

    //
    // Check to see if the value existed at the start.
    //

    dprintf( 2, ("  found value %ws\\%ws\n", context->CurrentPath, ValueName) );

    ok = FALSE;
    value = (PVALUE_ENTRY)GetFirstObject( context->ParentKey );
    while ( value != NULL ) {
        if ( _wcsicmp( value->Name, ValueName ) == 0 ) {
            ok = TRUE;
            break;
        }
        value = (PVALUE_ENTRY)GetNextObject( context->ParentKey, value );
    }

    if ( ok ) {

        //
        // The value existed at the start.  If its data hasn't changed,
        // remove it from the tree.  Otherwise, mark it as changed.
        //

        if ( (value->Type == ValueType) &&
             (value->ValueDataLength == ValueDataLength) &&
             (memcmp( &value->Name + value->NameLength + 1,
                      ValueData,
                      ValueDataLength ) == 0) ) {
            dprintf( 2, ("Deleting entry for unchanged value %ws\\%ws\n", context->CurrentPath, ValueName) );
            RemoveObject( value );
            MyFree( value );
        } else {
            dprintf( 1, ("  Marking entry for changed value %ws\\%ws\n", context->CurrentPath, ValueName) );
            SetEntryState( value, WATCH_CHANGED );
        }

    } else {

        //
        // The value is new.  Add it to the tree.
        //
        // Note that we do not bother to save the value's data here,
        // even though we have it in hand.  The routines that
        // populate userdifr already have to deal with querying
        // value data, so the code is simpler this way.
        //

        value = MyMalloc( sizeof(VALUE_ENTRY) - sizeof(WCHAR) +
                          ((ValueNameLength + 1) * sizeof(WCHAR)) );
        if ( value == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        InitializeObject( value, WATCH_NEW );
        wcscpy( value->Name, ValueName );
        dprintf( 1, ("  Adding entry for new value %ws\\%ws\n", context->CurrentPath, ValueName) );

        InsertObject( context->ParentKey, value );
    }

    return NO_ERROR;

} // CheckValueAtStop


DWORD
CheckKeyAtStop (
    IN PVOID Context,
    IN DWORD KeyNameLength,
    IN PWCH KeyName
    )

/*++

Routine Description:

    Checks the watch tree for an enumerated key during WatchKeyStop.

Arguments:

    Context - context value passed to EnumerateKey.

    KeyNameLength - length in characters of KeyName.

    KeyName - pointer to name of the key.

Return Value:

    DWORD - Win32 status of the operation.

--*/

{
    PKEY_ENUM_CONTEXT context = Context;
    PKEY_ENTRY key;
    BOOL ok;

    //
    // Check to see if the subkey existed at the start.
    //

    dprintf( 2, ("  found key %ws\\%ws\n", context->CurrentPath, KeyName) );

    ok = FALSE;
    key = (PKEY_ENTRY)GetFirstContainer( context->ParentKey );
    while ( key != NULL ) {
        if ( _wcsicmp( key->Name, KeyName ) == 0 ) {
            ok = TRUE;
            break;
        }
        key = (PKEY_ENTRY)GetNextContainer( key );
    }

    if ( ok ) {

        //
        // The key existed at the start.  Mark it as matched.
        // (We can't delete matched keys, as we do values,
        // because they need to be in the tree for recursion.)
        //

        SetEntryState( key, WATCH_MATCHED );

    } else {

        //
        // The key is new.  Add it to the tree.
        //

        key = MyMalloc( sizeof(KEY_ENTRY) - sizeof(WCHAR) +
                        ((KeyNameLength + 1) * sizeof(WCHAR)) );
        if ( key == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        InitializeContainer( key, WATCH_NEW, context->ParentKey, FALSE );
        wcscpy( key->Name, KeyName );
        dprintf( 1, ("  Adding entry for new key %ws\\%ws\n", context->CurrentPath, KeyName) );
        InsertContainer( context->ParentKey, key );
    }

    return NO_ERROR;

} // CheckKeyAtStop


//
// Debug code for tracking allocates and frees.
//

#if WATCH_DEBUG

#undef MyMalloc
#undef MyFree

DWORD TotalAllocs = 0;
DWORD TotalFrees = 0;
DWORD PeakAllocs = 0;

DWORD TotalAllocated = 0;
DWORD TotalFreed = 0;
DWORD PeakAllocated = 0;

PVOID
MyMallocEx (
    DWORD Size
    )
{
    PVOID p = MyMalloc( Size + 8 );

    if ( p == NULL ) {
        dprintf( 0, ("MyMallocEx: failure allocating %d bytes\n", Size) );
        DumpMallocStats("");
        DbgBreakPoint();
        return NULL;
    }

    TotalAllocs++;
    if ( (TotalAllocs - TotalFrees) > PeakAllocs ) {
        PeakAllocs = TotalAllocs - TotalFrees;
    }
    TotalAllocated += Size;
    if ( (TotalAllocated - TotalFreed) > PeakAllocated ) {
        PeakAllocated = TotalAllocated - TotalFreed;
    }

    *(PDWORD)p = Size;
    return (PVOID)((PCHAR)p + 8);
}

VOID
MyFreeEx (
    PVOID p
    )
{
    PVOID pp = (PVOID)((PCHAR)p - 8);

    TotalFrees++;
    TotalFreed += *(PDWORD)pp;

    MyFree( pp );
}

VOID
DumpMallocStats (
    PSZ Event
    )
{
    if ( *Event != 0 ) {
        dprintf( 0, ("%s\n", Event) );
    }
    dprintf( 0, ("Allocations %d, frees %d, active allocs %d\n",
                TotalAllocs, TotalFrees, TotalAllocs - TotalFrees) );
    dprintf( 0, ("Bytes allocated %d, bytes freed %d, active bytes %d\n",
                TotalAllocated, TotalFreed, TotalAllocated - TotalFreed) );
    dprintf( 0, ("Peak allocs %d, peak bytes %d\n",
                PeakAllocs, PeakAllocated) );

    return;
}

#endif


typedef HRESULT (*PFNSHGETFOLDERPATH)(HWND hwnd, int csidl, HANDLE hToken, DWORD dwType, LPTSTR pszPath);

BOOL
GetSpecialFolderPath (
    IN INT    csidl,
    IN LPWSTR lpPath
    )
/*++

Routine Description:

    Gets the path to the requested special folder.
    (This function was copied from userenv.dll)

Arguments:

    csid   - CSIDL of the special folder
    lpPath - Path to place result in assumed to be MAX_PATH in size

Return Value:

    TRUE if successful
    FALSE if an error occurs

--*/
{
    HRESULT     hResult;
    HINSTANCE   hInstShell32;
    PFNSHGETFOLDERPATH  pfnSHGetFolderPath;


    //
    // Load the function we need
    //

    hInstShell32 = LoadLibrary(L"shell32.dll");

    if (!hInstShell32) {
        SetupDebugPrint1( L"SETUP: GetSpecialFolderPath() failed to load shell32. Error = %d.", GetLastError() );
        return FALSE;
    }


    pfnSHGetFolderPath = (PFNSHGETFOLDERPATH)GetProcAddress (hInstShell32, "SHGetFolderPathW");

    if (!pfnSHGetFolderPath) {
        SetupDebugPrint1( L"SETUP: GetSpecialFolderPath() failed to find SHGetFolderPath(). Error = %d.", GetLastError() );
        FreeLibrary (hInstShell32);
        return FALSE;
    }


    //
    // Ask the shell for the folder location
    //

    hResult = pfnSHGetFolderPath (
        NULL,
        csidl | CSIDL_FLAG_CREATE,
        (HANDLE) -1,    // this specifies .Default
        0,
        lpPath);
    if (S_OK != hResult) {
        SetupDebugPrint1( L"SETUP: GetSpecialFolderPath: SHGetFolderPath() returned %d.", hResult );
    }

    //
    // Clean up
    //

    FreeLibrary (hInstShell32);
    return (S_OK == hResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\watch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    watch.h

Abstract:

    Header file for watch.c

Author:

    Chuck Lenzmeier (chuckl)

Revision History:

--*/

//
// Enumerated entry types.
//

#define WATCH_DIRECTORY 1
#define WATCH_FILE      2
#define WATCH_KEY       3
#define WATCH_VALUE     4

//
// Enumerated change types.
//

#define WATCH_CHANGED   1
#define WATCH_DELETED   2
#define WATCH_NEW       3

//
// Structure describing an enumerated change.
//

typedef struct _WATCH_ENTRY {
    PWCH Name;
    DWORD EntryType;
    DWORD ChangeType;
} WATCH_ENTRY, *PWATCH_ENTRY;

//
// USERPROFILE is the name of the environment variable that contains
// the path the user's profile directory.
//

#define USERPROFILE TEXT("USERPROFILE")

//
// Macros for mask manipulation.
//

#define FlagOn(_mask,_flag)  (((_mask) & (_flag)) != 0)
#define FlagOff(_mask,_flag) (((_mask) & (_flag)) == 0)
#define SetFlag(_mask,_flag) ((_mask) |= (_flag))
#define ClearFlag(_mask,_flag) ((_mask) &= ~(_flag))

//
// Routines exported by watch.c
//

DWORD
WatchStart (
    OUT PVOID *WatchHandle
    );

DWORD
WatchStop (
    IN PVOID WatchHandle
    );

VOID
WatchFree (
    IN PVOID WatchHandle
    );

typedef
DWORD
(* PWATCH_ENUM_ROUTINE) (
    IN PVOID Context,
    IN PWATCH_ENTRY Entry
    );

DWORD
WatchEnum (
    IN PVOID WatchHandle,
    IN PVOID Context,
    IN PWATCH_ENUM_ROUTINE EnumRoutine
    );

typedef
DWORD
(* PVALUE_ENUM_ROUTINE) (
    IN PVOID Context,
    IN DWORD ValueNameLength,
    IN PWCH ValueName,
    IN DWORD ValueType,
    IN PVOID ValueData,
    IN DWORD ValueDataLength
    );

typedef
DWORD
(* PKEY_ENUM_ROUTINE) (
    IN PVOID Context,
    IN DWORD KeyNameLength,
    IN PWCH KeyName
    );

DWORD
EnumerateKey (
    IN HKEY KeyHandle,
    IN PVOID Context,
    IN PVALUE_ENUM_ROUTINE ValueEnumRoutine OPTIONAL,
    IN PKEY_ENUM_ROUTINE KeyEnumRoutine OPTIONAL
    );

BOOL
GetSpecialFolderPath (
    IN INT csidl,
    IN LPWSTR lpPath
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\welcome.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    welcome.c

Abstract:

    Routines for welcomong the user.

Author:

    Ted Miller (tedm) 27-July-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop

#define HARWARE_DETECTION_BOOT_TIMEOUT  5

extern BOOLEAN
AsrIsEnabled( VOID );


//
// Setup mode (custom, typical, laptop, etc)
//
UINT SetupMode = SETUPMODE_TYPICAL;

//
// Flag telling us whether we've already prepared for installation.
//
BOOL PreparedAlready;

static HBRUSH s_hbrWindow = NULL;

VOID AdjustAndPaintWatermarkBitmap(
    IN HWND hdlg,
    IN HDC hdc
    )
/*
    Function used to adjust and paint the watermark bitmap so that it will fit correctly
    into the welcome and finish window, even if it is scalled differently than
    it would look when run on a usa build.
    some code borrowed from winnt32\dll\{rsrcutil,wizard}.c
    some code borrowed from shell\comctl32\prsht.c

Arguments:

    hdlg, input handle for the window which the dialog shall be drawn into.
    hdc, input device context of the current window.

Return Value:

    none: this is an attempt to scale the bitmap correctly for the cases
      where the win2k logo will be clipped.  In order to get a chance to scale
      the bitmap, we can not let wiz97 take care of it, and thus if this function
      fails, there will be no watermark drawn.

      We treat errors in a way similarly
      to how property sheet would, which is that while we won't die hard, we
      make sure not to use any NULL resources.

*/
{
    RECT rect;
    HBITMAP hDib;
    HRSRC BlockHandle;
    HGLOBAL MemoryHandle;
    BITMAPINFOHEADER *BitmapInfoHeader;
    BITMAPINFO *BitmapInfo;
    HDC MemDC;
    UINT ColorCount;
    HPALETTE PreviousPalette;
    HBITMAP Bitmap;
    BOOLEAN b;
    PVOID Bits;
    PVOID Bits2;
    int i;

    s_hbrWindow = GetSysColorBrush(COLOR_WINDOW);

    BlockHandle = FindResource(MyModuleHandle,MAKEINTRESOURCE(IDB_BITMAP1),RT_BITMAP);
    if(!BlockHandle) {
    SetupDebugPrint1(L"SETUP: AdjustAndPaintWatermarkBitmap: Couldn't find resource, error %d\n",
            GetLastError());
        //nothing to clean up.
        return;
    }

    MemoryHandle = LoadResource(MyModuleHandle,BlockHandle);
    if(!MemoryHandle) {
    SetupDebugPrint1(L"SETUP: AdjustAndPaintWatermarkBitmap: Couldn't load resource, error %d\n",
            GetLastError());
        //nothing to clean up.
        return;
    }

    BitmapInfoHeader = LockResource(MemoryHandle);
    if(BitmapInfoHeader == NULL) {
    SetupDebugPrint1(L"SETUP: AdjustAndPaintWatermarkBitmap: Couldn't lock resource, error %d\n",
            GetLastError());
        goto c0;
    }

    // First we have to paint the background on the right side of the window
    // (this is not auto done for us because we aren't using the wizard's watermark)
    GetClientRect(hdlg,&rect);
    rect.left = BitmapInfoHeader->biWidth;
    FillRect(hdc,&rect,s_hbrWindow);

    ColorCount = (BitmapInfoHeader->biBitCount <= 8)
                ? (1 << BitmapInfoHeader->biBitCount)
                : 0;

    BitmapInfo = MyMalloc(BitmapInfoHeader->biSize + (ColorCount * sizeof(RGBQUAD)));
    if (!BitmapInfo){
    SetupDebugPrint(L"SETUP: AdjustAndPaintWatermarkBitmap: Couldn't malloc BitmapInfo.\n");
        goto c0;
    }

    CopyMemory(
        BitmapInfo,
        BitmapInfoHeader,
        BitmapInfoHeader->biSize + (ColorCount * sizeof(RGBQUAD))
        );

    BitmapInfo->bmiHeader.biHeight = rect.bottom;
    BitmapInfo->bmiHeader.biWidth = BitmapInfoHeader->biWidth;

    hDib = CreateDIBSection(NULL,BitmapInfo,DIB_RGB_COLORS,&Bits,NULL,0);
    if(!hDib) {
    SetupDebugPrint1(L"SETUP: AdjustAndPaintWatermarkBitmap: Couldn't create DIB, error %d\n",
            GetLastError());
        goto c1;
    }

    //
    // Create a "template" memory DC and select the DIB we created
    // into it. Passing NULL to CreateCompatibleDC creates a DC into which
    // any format bitmap can be selected. We don't want to use the dialog's
    // DC because if the pixel depth of the watermark bitmap differs from
    // the screen, we wouldn't be able to select the dib into the mem dc.
    //
    MemDC = CreateCompatibleDC(NULL);
    if(!MemDC) {
    SetupDebugPrint1(L"SETUP: AdjustAndPaintWatermarkBitmap: Couldn't create DC, error %d\n",
            GetLastError());
        goto c2;
    }

    if (!SelectObject(MemDC,hDib)){
    SetupDebugPrint1(L"SETUP: AdjustAndPaintWatermarkBitmap: Couldn't Select DC, error %d\n",
            GetLastError());
        goto c3;
    }

    //
    // Do the stretch operation from the source bitmap onto
    // the dib.
    //
    Bits2 = (LPBYTE)BitmapInfoHeader + BitmapInfoHeader->biSize + (ColorCount * sizeof(RGBQUAD));
    SetStretchBltMode(MemDC,COLORONCOLOR);
    i = StretchDIBits(
            MemDC,
            0,0,
            BitmapInfoHeader->biWidth,
            rect.bottom,
            0,0,
            BitmapInfoHeader->biWidth,
            BitmapInfoHeader->biHeight,
            Bits2,
            (BITMAPINFO *)BitmapInfoHeader,
            DIB_RGB_COLORS,
            SRCCOPY
            );

    if(i == GDI_ERROR) {
    SetupDebugPrint1(L"SETUP: AdjustAndPaintWatermarkBitmap: Couldn't stretch bitmap, error %d\n",
            GetLastError());
        goto c3;
    }

    i = BitBlt(hdc,0,0,BitmapInfoHeader->biWidth,rect.bottom,MemDC,0,0,SRCCOPY);
    if (0 == i){
    SetupDebugPrint1(L"SETUP: AdjustAndPaintWatermarkBitmap: Couldn't paint bitmap, error %d\n",
            GetLastError());
    }

c3:
    DeleteDC(MemDC);
c2:
    DeleteObject(hDib);
c1:
    MyFree(BitmapInfo);
c0:
    DeleteObject(MemoryHandle);


}

INT_PTR
CALLBACK
WelcomeDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Dialog procedure for first wizard page of Setup.
    It essentially just welcomes the user.

Arguments:

    Standard dialog procedure arguments.

Return Value:

    Standard dialog procedure return.

--*/

{
    HFONT   Font;
    LOGFONT LogFont;
    WCHAR   str[20];
    int     Height;
    HDC     hdc;
    NMHDR   *NotifyParams;
    PVOID   p;
    static  BOOL FirstInit=TRUE,FirstTime=TRUE;


    switch(msg) {

    case WM_INITDIALOG:

        WizardHandle = GetParent (hdlg);
        if((Font = (HFONT)SendDlgItemMessage(hdlg,IDT_STATIC_1,WM_GETFONT,0,0))
        && GetObject(Font,sizeof(LOGFONT),&LogFont)) {

            LogFont.lfWeight = FW_BOLD;
            LoadString(MyModuleHandle,IDS_WELCOME_FONT_NAME,LogFont.lfFaceName,LF_FACESIZE);
            LoadString(MyModuleHandle,IDS_WELCOME_FONT_SIZE,str,sizeof(str)/sizeof(str[0]));
            Height = (int)wcstoul(str,NULL,10);

            if(hdc = GetDC(hdlg)) {

                LogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * Height / 72);

                if(Font = CreateFontIndirect(&LogFont)) {
                    SendDlgItemMessage(hdlg,IDT_STATIC_1,WM_SETFONT,(WPARAM)Font,MAKELPARAM(TRUE,0));
                }

                ReleaseDC(hdlg,hdc);
            }
        }

        if(p = MyLoadString((ProductType == PRODUCT_WORKSTATION) ?
            IDS_WORKSTATION_WELCOME_1 : IDS_SERVER_WELCOME_1)) {
            //
            // Use this instead of SetText because we need to pass wParam
            // to the control.
            //
            SendDlgItemMessage(hdlg,IDT_STATIC_2,WM_SETTEXT,0,(LPARAM)p);
            MyFree(p);
        }

        if(p = MyLoadString((ProductType == PRODUCT_WORKSTATION) ?
            IDS_WORKSTATION_WELCOME_2 : IDS_SERVER_WELCOME_2)) {
            //
            // Use this instead of SetText because we need to pass wParam
            // to the control.
            //
            SendDlgItemMessage(hdlg,IDT_STATIC_3,WM_SETTEXT,0,(LPARAM)p);
            MyFree(p);
        }

        #define SECOND 1000
        // Don't set the timer if we have a billboard, we don't show the page.
        if (FirstInit  && !Unattended && (GetBBhwnd() == NULL)) {
            SetTimer(hdlg,1,10 * SECOND,NULL);
            FirstInit = FALSE;
        }

#if 0
        //
        // Load steps text and set.
        //
        if(Preinstall) {
            //
            // Hide some text and don't display any steps.
            //
            ShowWindow(GetDlgItem(hdlg,IDT_STATIC_3),SW_HIDE);
            EnableWindow(GetDlgItem(hdlg,IDT_STATIC_3),FALSE);
        } else {
            if(p = MyLoadString(Upgrade ? IDS_STEPS_UPGRADE : IDS_STEPS)) {
                //
                // Use this instead of SetText because we need to pass wParam
                // to the control.
                //
                SendDlgItemMessage(hdlg,IDC_LIST1,WM_SETTEXT,0,(LPARAM)p);
                MyFree(p);
            }
        }

        //
        // Set up some of the static text on this page, which uses different
        // effects (boldface, different fonts, etc).
        //
        {
            HFONT Font;
            LOGFONT LogFont;
            WCHAR str[20];
            int Height;
            HDC hdc;

            //
            // First handle the text that "introduces" the title, which is in
            // the same font as the rest of the dialog, only bold.
            //
            if((Font = (HFONT)SendDlgItemMessage(hdlg,IDT_STATIC_1,WM_GETFONT,0,0))
            && GetObject(Font,sizeof(LOGFONT),&LogFont)) {

                LogFont.lfWeight = FW_BOLD;
                if(Font = CreateFontIndirect(&LogFont)) {
                    SendDlgItemMessage(hdlg,IDT_STATIC_1,WM_SETFONT,(WPARAM)Font,MAKELPARAM(TRUE,0));
                }
            }

            //
            // Next do the title, which is in a different font, larger and in boldface.
            //
            if((Font = (HFONT)SendDlgItemMessage(hdlg,IDT_STATIC_2,WM_GETFONT,0,0))
            && GetObject(Font,sizeof(LOGFONT),&LogFont)) {

                LogFont.lfWeight = FW_BOLD;
                LoadString(MyModuleHandle,IDS_MSSERIF,LogFont.lfFaceName,LF_FACESIZE);
                LoadString(MyModuleHandle,IDS_LARGEFONTSIZE,str,sizeof(str)/sizeof(str[0]));
                Height = (int)wcstoul(str,NULL,10);

                if(hdc = GetDC(hdlg)) {

                    LogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * Height / 72);

                    if(Font = CreateFontIndirect(&LogFont)) {
                        SendDlgItemMessage(hdlg,IDT_STATIC_2,WM_SETFONT,(WPARAM)Font,MAKELPARAM(TRUE,0));
                    }

                    ReleaseDC(hdlg,hdc);
                }
            }
        }
#endif
        //
        // Center the wizard dialog on-screen.
        //
        // if we have the BB window, do the positioning on that. MainWindowHandle point to that window
        //
        if (GetBBhwnd())
            CenterWindowRelativeToWindow(GetParent(hdlg), MainWindowHandle, TRUE);
        else
            pSetupCenterWindowRelativeToParent(GetParent(hdlg));
        break;

    case WM_SIMULATENEXT:
        // Simulate the next button somehow
        PropSheet_PressButton( GetParent(hdlg), PSBTN_NEXT);
        break;

    case WMX_VALIDATE:
        // No data on this page, unattended should skip it
        return ReturnDlgResult (hdlg, VALIDATE_DATA_OK);

    case WM_TIMER:
        KillTimer(hdlg, 1);
        if (FirstTime) {
            PropSheet_PressButton( GetParent(hdlg), PSBTN_NEXT);
            FirstTime = FALSE;
        }
        break;

    case WM_CTLCOLOREDIT:
    case WM_CTLCOLORDLG:
    case WM_CTLCOLORMSGBOX:
    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLORBTN:
    case WM_CTLCOLORSCROLLBAR:
    case WM_CTLCOLORSTATIC:

    SetTextColor((HDC)wParam, GetSysColor(COLOR_WINDOWTEXT));
    SetBkColor((HDC)wParam, GetSysColor(COLOR_WINDOW));
    return (LRESULT)s_hbrWindow;

    case WM_ERASEBKGND:
    AdjustAndPaintWatermarkBitmap(hdlg,(HDC)wParam);
    break;


    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(510);
            BEGIN_SECTION(L"Welcome Page");
            SetWizardButtons(hdlg,WizPageWelcome);

            if(Preinstall) {
                //
                // Show unless OEMSkipWelcome = 1
                //
                if (GetPrivateProfileInt(pwGuiUnattended,L"OEMSkipWelcome",0,AnswerFile)) {
                    FirstTime = FALSE;
                }
                SetWindowLongPtr(
                    hdlg,
                    DWLP_MSGRESULT,
                    GetPrivateProfileInt(pwGuiUnattended,L"OEMSkipWelcome",0,AnswerFile) ? -1 : 0
                    );
            } else {
                FirstTime = FALSE;
                if(Unattended) {
                    UnattendSetActiveDlg(hdlg,IDD_WELCOME);
                }
                else if (GetBBhwnd() != NULL)
                {
                    // If we have a billoard, don't show the page.
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
                }
            }
            break;
        case PSN_WIZNEXT:
            FirstTime = FALSE;
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
            break;
        case PSN_KILLACTIVE:
            END_SECTION(L"Welcome Page");
        default:
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}


//
// global variable used for subclassing.
//
WNDPROC OldEditProc;

LRESULT
CALLBACK
EulaEditSubProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Edit control subclass routine, to avoid highlighting text when user
    tabs to the edit control.

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/

{
    //
    // For setsel messages, make start and end the same.
    //
    if((msg == EM_SETSEL) && ((LPARAM)wParam != lParam)) {
        lParam = wParam;
    }

    return(CallWindowProc(OldEditProc,hwnd,msg,wParam,lParam));
}


INT_PTR
CALLBACK
EulaDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Dialog procedure for the wizard page that displays the End User License
        Agreement.

Arguments:

    Standard dialog procedure arguments.

Return Value:

    Standard dialog procedure return.

--*/

{
    NMHDR *NotifyParams;
    HWND EditControl;
    WCHAR   EulaPath[MAX_PATH];
    static  HANDLE  hFile = NULL, hFileMapping = NULL;
    DWORD   FileSize;
    static  BYTE    *pbFile = NULL;
    static  PWSTR   EulaText = NULL;
    int     i;


    switch(msg) {

    case WM_INITDIALOG:
        //
        // If not preinstall then this was displayed at start of text mode
        // and we don't do it here.
        //
        if (EulaComplete || TextmodeEula || OemSkipEula) {
           break;
        }

        //
        // Map the file containing the licensing agreement.
        //
        GetSystemDirectory(EulaPath, MAX_PATH);
        pSetupConcatenatePaths (EulaPath, L"eula.txt", MAX_PATH, NULL);

        hFile = CreateFile (
            EulaPath,
            GENERIC_READ,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if(hFile == INVALID_HANDLE_VALUE) {
            FatalError(MSG_EULA_ERROR,0,0);
        }

        hFileMapping = CreateFileMapping (
            hFile,
            NULL,
            PAGE_READONLY,
            0, 0,
            NULL
            );
        if(hFileMapping == NULL) {
            FatalError(MSG_EULA_ERROR,0,0);
        }

        pbFile = MapViewOfFile (
            hFileMapping,
            FILE_MAP_READ,
            0, 0,
            0
            );
        if(pbFile == NULL) {
            FatalError(MSG_EULA_ERROR,0,0);
        }

        //
        // Translate the text from ANSI to Unicode.
        //
        FileSize = GetFileSize (hFile, NULL);
        if(FileSize == 0xFFFFFFFF) {
            FatalError(MSG_EULA_ERROR,0,0);
        }

        EulaText = MyMalloc ((FileSize+1) * sizeof(WCHAR));
        if(EulaText == NULL) {
            FatalError(MSG_EULA_ERROR,0,0);
        }

        MultiByteToWideChar (
            CP_ACP,
            0,
            pbFile,
            FileSize,
            EulaText,
            (FileSize+1) * sizeof(WCHAR)
            );

        EulaText[FileSize] = 0;

        EditControl = GetDlgItem(hdlg,IDT_EDIT1);
        OldEditProc = (WNDPROC)GetWindowLongPtr(EditControl,GWLP_WNDPROC);
        SetWindowLongPtr(EditControl,GWLP_WNDPROC,(LONG_PTR)EulaEditSubProc);
        SetWindowText(EditControl,(PCWSTR)EulaText);
        break;

    case WM_DESTROY:
        //
        // Clean up
        //
        if( EulaText )
            MyFree (EulaText);

        if (pbFile)
            UnmapViewOfFile (pbFile);

        if (hFileMapping)
            CloseHandle (hFileMapping);

        if (hFile)
            CloseHandle (hFile);

        break;

    case WM_SIMULATENEXT:
        PropSheet_PressButton( GetParent(hdlg), PSBTN_NEXT);
        break;

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(511);
            BEGIN_SECTION(L"Eula Page");
            SetWizardButtons(hdlg,WizPageEula);
            SetFocus(GetDlgItem(hdlg,IDYES));

            if (EulaComplete || TextmodeEula || OemSkipEula) {
                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
                END_SECTION(L"Eula Page");
            } else {
                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
                // Make sure we're initialized if we're going to show it.
                MYASSERT(EulaText);
            }

            break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
            //
            // Allow the next page to be activated.
            //
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
            break;

        case PSN_KILLACTIVE:
            if(IsDlgButtonChecked(hdlg,IDYES)) {
                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
            } else {
                //
                // Are you sure you want to exit?
                //
                i = MessageBoxFromMessage(
                        hdlg,
                        MSG_SURE_EXIT,
                        FALSE,
                        IDS_WINNT_SETUP,
                        MB_YESNO | MB_ICONQUESTION | MB_TASKMODAL | MB_DEFBUTTON2
                        );
                if(i == IDYES) {
                    FatalError(MSG_NOT_ACCEPT_EULA,0,0);
                } else {
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
                }
                END_SECTION(L"Eula Page");
            }
            break;

        default:
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}


INT_PTR
CALLBACK
StepsDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Dialog procedure for "steps" dialog page. This is the one just before
    we go into the network wizard.

    When the user clicks next to go to the next page, we have to perform
    some actions to prepare. So we put up a billboard telling the user
    that we are preparing. When preparation is done, we continue.

Arguments:

    Standard dialog procedure arguments.

Return Value:

    Standard dialog procedure return.

--*/

{
    NMHDR *NotifyParams;
    PVOID p;
    HWND billboard;
    HCURSOR OldCursor;

    switch(msg) {

    case WM_INITDIALOG:
        break;

    case WMX_VALIDATE:
        //
        // If unattended, we put up a wait cursor instead of a billboard
        //
        PropSheet_SetWizButtons(GetParent(hdlg),0);
        OldCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));

        if(!UiTest) {
            if(Upgrade) {
                PrepareForNetUpgrade();
            } else {
                PrepareForNetSetup();
            }
        }

        SetCursor (OldCursor);
        return ReturnDlgResult (hdlg, VALIDATE_DATA_OK);
#if 0
    case WM_SIMULATENEXT:
        PropSheet_PressButton( GetParent(hdlg), PSBTN_NEXT);
        break;
#endif
    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(512);
            BEGIN_SECTION(L"Pre-Network Steps Page");
            // Page does not show, hide wizard
            SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)TRUE, 0);

            SendDlgMessage (hdlg, WMX_VALIDATE, 0, TRUE);
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
            END_SECTION(L"Pre-Network Steps Page");
            break;
#if 0
        case PSN_WIZNEXT:

            UnattendAdvanceIfValid (hdlg);
            break;
#endif
        case PSN_KILLACTIVE:
            END_SECTION(L"Pre-Network Steps Page");

        default:
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

WNDPROC OldProgressProc;

BOOL
NewProgessProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (msg)
    {
        case WMX_PROGRESSTICKS:
        case PBM_DELTAPOS:
        case PBM_SETRANGE:
        case PBM_SETRANGE32:
        case PBM_STEPIT:
        case PBM_SETPOS:
        case PBM_SETSTEP:
            ProgressGaugeMsgWrapper(msg, wParam, lParam);
            break;
    }
    return (BOOL)CallWindowProc(OldProgressProc,hdlg,msg,wParam,lParam);
}


INT_PTR
CALLBACK
CopyFilesDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Dialog procedure for the wizard page where we do all the work.

Arguments:

    Standard dialog procedure arguments.

Return Value:

    Standard dialog procedure return.

--*/

{
    static BOOL WorkFinished = FALSE;
    NMHDR *NotifyParams;
    static HCURSOR hcur;
    static FINISH_THREAD_PARAMS Context;
    static HWND    hProgress;
    DWORD   ThreadId;
    HANDLE  ThreadHandle = NULL;
    UINT    GaugeRange;

    switch(msg) {

    case WM_INITDIALOG:
        //
        // Initialize the progress indicator control.
        //
        hProgress = GetDlgItem(hdlg, IDC_PROGRESS1);
        OldProgressProc = (WNDPROC)SetWindowLongPtr(hProgress,GWLP_WNDPROC,(LONG_PTR)NewProgessProc);
        GaugeRange = 100;
        SendDlgItemMessage(hdlg,IDC_PROGRESS1,PBM_SETRANGE,0,MAKELPARAM(0,GaugeRange));
        SendDlgItemMessage(hdlg,IDC_PROGRESS1,PBM_SETPOS,0,0);
        SendDlgItemMessage(hdlg,IDC_PROGRESS1,PBM_SETSTEP,1,0);

        // Do calls into the billboard to prepare the progress there.
        SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_SHOW, 0);

        #ifdef _OCM
        //
        // the lparam is really the context pointer for ocm
        //
        Context.OcManagerContext = (PVOID)((PROPSHEETPAGE *)lParam)->lParam;
        MYASSERT(Context.OcManagerContext);
        #endif

        break;

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(513);
            BEGIN_SECTION(L"Copying Files Page");
            SetWizardButtons(hdlg,WizPageCopyFiles);

            if(WorkFinished) {
                //
                // Don't activate; we've already been here before.
                // Nothing to do.
                //
                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
            } else {
                //
                // Need to prepare for installation.
                // Want next/back buttons disabled until we're done.
                //
                PropSheet_SetWizButtons(GetParent(hdlg),0);
                SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)TRUE, 0);
                PostMessage(hdlg,WM_IAMVISIBLE,0,0);
                WorkFinished = TRUE;
            }
            break;
        case PSN_KILLACTIVE:
            END_SECTION(L"Copying Files Page");

        default:
            break;
        }

        break;

    case WM_IAMVISIBLE:
        //
        // Force repainting first to make sure the page is visible.
        //
        InvalidateRect(hdlg,NULL,FALSE);
        UpdateWindow(hdlg);

        hcur = SetCursor(LoadCursor(NULL,IDC_WAIT));

        if(!UiTest) {
            Context.ThreadId = GetCurrentThreadId();
            Context.hdlg = hdlg;
            MYASSERT(Context.OcManagerContext);

            ThreadHandle = CreateThread(
                NULL,
                0,
                FinishThread,
                &Context,
                0,
                &ThreadId
                );

            if(ThreadHandle) {
                CloseHandle(ThreadHandle);
            } else {

                SetupDebugPrint1(
                    L"SETUP: CreateThread() failed for FinishThread.  Error = %d",
                    GetLastError()
                    );
            }
        }

        break;

    case WM_MY_PROGRESS:

        if(wParam) {
            SendMessage (hProgress, PBM_STEPIT, 0, 0);
        } else {
            SendMessage (hProgress, PBM_SETRANGE, 0, MAKELPARAM(0,lParam));
            SendMessage (hProgress, PBM_SETPOS, 0, 0);
        }
        break;

    case WMX_TERMINATE:
        //
        // Enable next and back buttons and move to next page.
        //
        SendMessage(GetParent(hdlg),WMX_SETPROGRESSTEXT,0,0);
        SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_HIDE, 0);
        SetCursor(hcur);
        if(!UiTest) {
            PropSheet_PressButton(GetParent(hdlg),PSBTN_NEXT);
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}


INT_PTR
CALLBACK
LastPageDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Dialog procedure for last wizard page of Setup.

Arguments:

    Standard dialog procedure arguments.

Return Value:

    Standard dialog procedure return.

--*/

{
    HFONT   Font;
    LOGFONT LogFont;
    WCHAR   str[20];
    int     Height;
    HDC     hdc;
    NMHDR   *NotifyParams;
    PVOID   p = NULL;

    switch(msg) {

    case WM_INITDIALOG:

        if((Font = (HFONT)SendDlgItemMessage(hdlg,IDT_STATIC_1,WM_GETFONT,0,0))
        && GetObject(Font,sizeof(LOGFONT),&LogFont)) {

            LogFont.lfWeight = FW_BOLD;
            LoadString(MyModuleHandle,IDS_WELCOME_FONT_NAME,LogFont.lfFaceName,LF_FACESIZE);
            LoadString(MyModuleHandle,IDS_WELCOME_FONT_SIZE,str,sizeof(str)/sizeof(str[0]));
            Height = (int)wcstoul(str,NULL,10);

            if(hdc = GetDC(hdlg)) {

                LogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * Height / 72);

                if(Font = CreateFontIndirect(&LogFont)) {
                    SendDlgItemMessage(hdlg,IDT_STATIC_1,WM_SETFONT,(WPARAM)Font,MAKELPARAM(TRUE,0));
                }

                ReleaseDC(hdlg,hdc);
            }
        }
        break;

    case WM_SIMULATENEXT:
        // Simulate the next button somehow
        PropSheet_PressButton(GetParent(hdlg),PSBTN_FINISH);
        break;

    case WM_CTLCOLOREDIT:
    case WM_CTLCOLORDLG:
    case WM_CTLCOLORMSGBOX:
    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLORBTN:
    case WM_CTLCOLORSCROLLBAR:
    case WM_CTLCOLORSTATIC:

    SetTextColor((HDC)wParam, GetSysColor(COLOR_WINDOWTEXT));
    SetBkColor((HDC)wParam, GetSysColor(COLOR_WINDOW));
    return (LRESULT)s_hbrWindow;

    case WM_ERASEBKGND:
    AdjustAndPaintWatermarkBitmap(hdlg,(HDC)wParam);
    break;

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(514);
            BEGIN_SECTION(L"Finish Page");

            if( AsrIsEnabled()) {

                if(p = MyLoadString(IDS_EMPTY_STRING)) {
                    BB_SetTimeEstimateText(p);
                    SendMessage(GetParent(hdlg), WMX_SETPROGRESSTEXT, 0, (LPARAM)p);
                    SendMessage(GetParent(hdlg), WMX_BB_SETINFOTEXT, 0, (LPARAM)p);
                    MyFree(p);
                }
                else {
                    BB_SetTimeEstimateText(TEXT(""));
                    SendMessage(GetParent(hdlg), WMX_SETPROGRESSTEXT, 0, (LPARAM)TEXT(""));
                    SendMessage(GetParent(hdlg), WMX_BB_SETINFOTEXT, 0, (LPARAM)TEXT(""));
                }

                SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, (WPARAM)SW_HIDE, 0);
                StartStopBB(FALSE);

                PostMessage(hdlg,WM_SIMULATENEXT,0,0);
                break;
            }

            SetWizardButtons(hdlg,WizPageLast);
            if (hinstBB)
            {
                PostMessage(hdlg,WM_SIMULATENEXT,0,0);
            }
            else
            {
                //
                // Don't want back button in upgrade case, since that would
                // land us in the middle of the network upgrade. In non-upgrade
                // case we only allow the user to go back if he didn't install
                // the net, to allow him to change his mind.
                //
                if(Upgrade || (InternalSetupData.OperationFlags & SETUPOPER_NETINSTALLED)) {
                    PropSheet_SetWizButtons(GetParent(hdlg),PSWIZB_FINISH);
                }
                //
                // If NoWaitAfterGuiMode is zero, turn off Unattend mode
                //

                GetPrivateProfileString (L"Unattended", L"NoWaitAfterGuiMode", L"", str, 20, AnswerFile);
                if (!lstrcmp (str, L"0")) {
                    Unattended = FALSE;
                }

                if (Unattended) {
                    if(!UnattendSetActiveDlg(hdlg,IDD_LAST_WIZARD_PAGE))
                    {
                        END_SECTION(L"Finish Page");
                    }
                }
            }
            break;
        case PSN_KILLACTIVE:
            END_SECTION(L"Finish Page");

        default:
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}


INT_PTR
CALLBACK
PreparingDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

   Dialog procedure for "preparing computer" Wizard page.
   When the user is viewing this page we are essentially preparing
   BaseWinOptions, initializing optional components stuff, and installing P&P devices.

Arguments:

    Standard dialog procedure arguments.

Return Value:

    Standard dialog procedure return.

--*/

{
    WCHAR str[1024];
    NMHDR *NotifyParams;
    HCURSOR hcur;

    switch(msg) {

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(515);
            BEGIN_SECTION(L"Installing Devices Page");
            if(PreparedAlready) {
                //
                // Don't activate; we've already been here before.
                // Nothing to do.
                //
                SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
            } else {

                if(AsrIsEnabled()) {
                    //
                    // If this is ASR, load the appropriate wizard page
                    //
                    SetWizardButtons(hdlg, WizPagePreparingAsr);
                }

                //
                // Need to prepare for installation.
                // Want next/back buttons disabled until we're done.
                //
                PropSheet_SetWizButtons(GetParent(hdlg),0);
                SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)TRUE, 0);
                PostMessage(hdlg,WM_IAMVISIBLE,0,0);
                PreparedAlready = TRUE;
            }
            break;
        case PSN_KILLACTIVE:
            END_SECTION(L"Installing Devices Page");

        default:
            break;
        }

        break;

    case WM_IAMVISIBLE:
        //
        // Force repainting first to make sure the page is visible.
        //
        InvalidateRect(hdlg,NULL,FALSE);
        UpdateWindow(hdlg);

        hcur = SetCursor(LoadCursor(NULL,IDC_WAIT));

        OldProgressProc = (WNDPROC)SetWindowLongPtr(GetDlgItem(hdlg, IDC_PROGRESS1),GWLP_WNDPROC,(LONG_PTR)NewProgessProc);
        // Do calls into the billboard to prepare the progress there.
        if(!LoadString(MyModuleHandle, IDS_BB_INSTALLING_DEVICES, str, SIZECHARS(str)))
        {
            *str = L'\0';
        }
        SendMessage(GetParent(hdlg), WMX_SETPROGRESSTEXT,0,(LPARAM)str);
        SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_SHOW, 0);

        if(!UiTest) {

            ULONG StartAtPercent = 0;
            ULONG StopAtPercent = 0;
            if (AsrIsEnabled()) {
                //
                // Update the UI
                //
                SetFinishItemAttributes(hdlg,
                    IDC_ASR_PNP_BMP,
                    LoadImage (MyModuleHandle, MAKEINTRESOURCE(IDB_ARROW), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS),
                    IDC_ASR_PNP_TXT,
                    FW_BOLD
                    );
            }

            if( !MiniSetup ){
                //
                //  Set Security use 10% of gauge
                //
                StopAtPercent  = 30;

                RemainingTime = CalcTimeRemaining(Phase_InstallSecurity);
                SetRemainingTime(RemainingTime);

                BEGIN_SECTION(L"Installing security");
                SetupInstallSecurity(hdlg,
                            GetDlgItem(hdlg, IDC_PROGRESS1),
                            StartAtPercent,
                            StopAtPercent
                            );
                END_SECTION(L"Installing security");
                CallSceSetupRootSecurity();
                SetupDebugPrint(L"SETUP: CallSceSetupRootSecurity started");

            }

            //
            //  Installation of PnP devices use the last 95% of the gauge
            //
            StartAtPercent = StopAtPercent;
            StopAtPercent  = 100;

            BEGIN_SECTION(L"Installing PnP devices");

            if (UninstallEnabled) {
                //
                // If uninstall mode, revert the timeout back to 5 seconds, so
                // PNP can reboot for failed device detections
                //

                ChangeBootTimeout (HARWARE_DETECTION_BOOT_TIMEOUT);
            }

            InstallPnpDevices(hdlg,
                              SyssetupInf,
                              GetDlgItem(hdlg,IDC_PROGRESS1),
                              StartAtPercent,
                              StopAtPercent
                             );
            END_SECTION(L"Installing PnP devices");

            if (AsrIsEnabled()) {
                //
                // Update the UI
                //
                SetFinishItemAttributes(hdlg,
                    IDC_ASR_PNP_BMP,
                    LoadImage (MyModuleHandle, MAKEINTRESOURCE(IDB_CHECK), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS),
                    IDC_ASR_PNP_TXT,
                    FW_NORMAL
                    );
            }

            if( !MiniSetup ) {
                BEGIN_SECTION(L"Loading service pack (phase 2)");
                CALL_SERVICE_PACK( SVCPACK_PHASE_2, 0, 0, 0 );
                END_SECTION(L"Loading service pack (phase 2)");
            }

            if(ScreenReader) {
                InvokeExternalApplication(L"narrator.exe", L"", NULL);
            }
        }

        SetCursor(hcur);

        SetWindowLongPtr(GetDlgItem(hdlg, IDC_PROGRESS1),GWLP_WNDPROC,(LONG_PTR)OldProgressProc );
        SendMessage(GetParent(hdlg),WMX_SETPROGRESSTEXT,0,0);
        SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_HIDE, 0);

        //
        // Enable next and back buttons and move to next page.
        //
        SetWizardButtons(hdlg,WizPagePreparing);
        if(!UiTest) {
            PropSheet_PressButton(GetParent(hdlg),PSBTN_NEXT);
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR
CALLBACK
SetupPreNetDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

{
    NMHDR *NotifyParams;
    switch(msg) {

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(516);
            // Update time remaining.
            // The network code knows how to hide the wizard pages
            // and make them visible no need to do that here.
            RemainingTime = CalcTimeRemaining(Phase_NetInstall);
            SetRemainingTime(RemainingTime);
            BEGIN_SECTION(L"Network Setup Pages");

            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
            break;
        default:
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR
CALLBACK
SetupPostNetDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

{
    NMHDR *NotifyParams;
    switch(msg) {

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(517);
            END_SECTION(L"Network Setup Pages");
            // Hide the progress bar when we get here.
            // Just to make sure. There are scenarios where the progress bar was still visible
            //
            SendMessage(GetParent(hdlg), WMX_SETPROGRESSTEXT,0,0);
            SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_HIDE, 0);

            // update the time estimate display
            // no need to make the wizard visible. The OC manager does this if needed.
            RemainingTime = CalcTimeRemaining(Phase_OCInstall);
            SetRemainingTime(RemainingTime);
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);

            if(Win32ComputerName[0]){
                SetEnvironmentVariable(L"COMPUTERNAME", Win32ComputerName);
            }
            break;
        default:
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\amd64\platform.c ===
#include "setupp.h"
#pragma hdrstop

WCHAR x86SystemPartitionDrive;

WCHAR FloppylessBootPath[MAX_PATH];

UINT
PlatformSpecificInit(
    VOID
    )
{
    //
    // Determine x86 system partition (usually but not always C:).
    //
    x86SystemPartitionDrive = x86DetermineSystemPartition();
    return(NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\amd64\spx86.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    spi386.h

Abstract:

    Header file for x86-specific stuff in system installation module.

Author:

    Ted Miller (tedm) 4-Apr-1995

Revision History:

--*/

#if defined(_AMD64_)

WCHAR
x86DetermineSystemPartition(
    VOID
    );

extern WCHAR x86SystemPartitionDrive;
extern WCHAR FloppylessBootPath[MAX_PATH];

//
// Pci Hal property page provider (pcihal.c).
//

DWORD
PciHalCoInstaller(
    IN DI_FUNCTION                      InstallFunction,
    IN HDEVINFO                         DeviceInfoSet,
    IN PSP_DEVINFO_DATA                 DeviceInfoData  OPTIONAL,
    IN OUT PCOINSTALLER_CONTEXT_DATA    Context
    );

BOOL
ChangeBootTimeoutBootIni(
    IN UINT Timeout
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\amd64\syspart.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    syspart.c

Abstract:

    Routines to determine the system partition on x86 machines.

Author:

    Ted Miller (tedm) 30-June-1994

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop


BOOL
AppearsToBeSysPart(
    IN PDRIVE_LAYOUT_INFORMATION DriveLayout,
    IN WCHAR                     Drive
    )
{
    PARTITION_INFORMATION PartitionInfo,*p;
    BOOL IsPrimary;
    unsigned i;
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;

    PWSTR BootFiles[] = { L"BOOT.INI",
                          L"NTLDR",
                          L"NTDETECT.COM",
                          NULL
                        };

    WCHAR FileName[64];

    //
    // Get partition information for this partition.
    //
    if(!GetPartitionInfo(Drive,&PartitionInfo)) {
        return(FALSE);
    }

    //
    // See if the drive is a primary partition.
    //
    IsPrimary = FALSE;
    for(i=0; i<min(DriveLayout->PartitionCount,4); i++) {

        p = &DriveLayout->PartitionEntry[i];

        if((p->PartitionType != PARTITION_ENTRY_UNUSED)
        && (p->StartingOffset.QuadPart == PartitionInfo.StartingOffset.QuadPart)
        && (p->PartitionLength.QuadPart == PartitionInfo.PartitionLength.QuadPart)) {

            IsPrimary = TRUE;
            break;
        }
    }

    if(!IsPrimary) {
        return(FALSE);
    }

    //
    // Don't rely on the active partition flag.  This could easily not be accurate
    // (like user is using os/2 boot manager, for example).
    //

    //
    // See whether nt boot files are present on this drive.
    //
    for(i=0; BootFiles[i]; i++) {

        wsprintf(FileName,L"%wc:\\%s",Drive,BootFiles[i]);

        FindHandle = FindFirstFile(FileName,&FindData);
        if(FindHandle == INVALID_HANDLE_VALUE) {
            return(FALSE);
        } else {
            FindClose(FindHandle);
        }
    }

    return(TRUE);
}


WCHAR
x86DetermineSystemPartition(
    VOID
    )

/*++

Routine Description:

    Determine the system partition on x86 machines.

    The system partition is the primary partition on the boot disk.
    Usually this is the active partition on disk 0 and usually it's C:.
    However the user could have remapped drive letters and generally
    determining the system partition with 100% accuracy is not possible.

    The one thing we can be sure of is that the system partition is on
    the physical hard disk with the arc path multi(0)disk(0)rdisk(0).
    We can be sure of this because by definition this is the arc path
    for bios drive 0x80.

    This routine determines which drive letters represent drives on
    that physical hard drive, and checks each for the nt boot files.
    The first drive found with those files is assumed to be the system
    partition.

    If for some reason we cannot determine the system partition by the above
    method, we simply assume it's C:.

Arguments:

    None.

Return Value:

    Drive letter of system partition.

--*/

{
    BOOL  GotIt;
    PWSTR NtDevicePath;
    WCHAR Drive;
    WCHAR DriveName[3];
    WCHAR Buffer[512];
    DWORD NtDevicePathLen;
    PWSTR p;
    DWORD PhysicalDriveNumber;
    HANDLE hDisk;
    BOOL b;
    DWORD DataSize;
    PVOID DriveLayout;
    DWORD DriveLayoutSize;
    DWORD hardDiskNumber;

    DriveName[1] = L':';
    DriveName[2] = 0;

    GotIt = FALSE;

    //
    // The system partition must be on multi(0)disk(0)rdisk(0)
    //
    if(NtDevicePath = ArcDevicePathToNtPath(L"multi(0)disk(0)rdisk(0)")) {

        //
        // The arc path for a disk device is usually linked
        // to partition0. Get rid of the partition part of the name.
        //
        CharLower(NtDevicePath);
        if(p = wcsstr(NtDevicePath,L"\\partition")) {
            *p = 0;
        }

        NtDevicePathLen = lstrlen(NtDevicePath);

        //
        // Determine the physical drive number of this drive.
        // If the name is not of the form \device\harddiskx then
        // something is very wrong.
        //
        if(!wcsncmp(NtDevicePath,L"\\device\\harddisk",16)) {

            PhysicalDriveNumber = wcstoul(NtDevicePath+16,NULL,10);

            wsprintf(Buffer,L"\\\\.\\PhysicalDrive%u",PhysicalDriveNumber);

            //
            // Get drive layout info for this physical disk.
            //
            hDisk = CreateFile(
                        Buffer,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );

            if(hDisk != INVALID_HANDLE_VALUE) {

                //
                // Get partition information.
                //
                DriveLayout = MyMalloc(1024);
                DriveLayoutSize = 1024;

                retry:

                b = DeviceIoControl(
                        hDisk,
                        IOCTL_DISK_GET_DRIVE_LAYOUT,
                        NULL,
                        0,
                        DriveLayout,
                        DriveLayoutSize,
                        &DataSize,
                        NULL
                        );

                if(!b && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {

                    DriveLayoutSize += 1024;
                    DriveLayout = MyRealloc(DriveLayout,DriveLayoutSize);
                    goto retry;
                }

                CloseHandle(hDisk);

                if(b) {

                    //
                    // The system partition can only be a drive that is on
                    // this disk.  We make this determination by looking at NT drive names
                    // for each drive letter and seeing if the nt equivalent of
                    // multi(0)disk(0)rdisk(0) is a prefix.
                    //
                    for(Drive=L'C'; Drive<=L'Z'; Drive++) {

                        if(MyGetDriveType(Drive) == DRIVE_FIXED) {

                            DriveName[0] = Drive;

                            if(QueryDosDevice(DriveName,Buffer,sizeof(Buffer)/sizeof(WCHAR))) {

                                if (_wcsnicmp(Buffer, L"\\device\\harddisk", 16)) {
                                    hardDiskNumber = QueryHardDiskNumber((UCHAR) Drive);
                                    if (hardDiskNumber != (DWORD) -1) {
                                        swprintf(Buffer, TEXT("\\device\\harddisk%d"),
                                                 hardDiskNumber);
                                    }
                                }

                                if(!_wcsnicmp(NtDevicePath,Buffer,NtDevicePathLen)) {

                                    //
                                    // Now look to see whether there's an nt boot sector and
                                    // boot files on this drive.
                                    //
                                    if(AppearsToBeSysPart(DriveLayout,Drive)) {
                                        GotIt = TRUE;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                MyFree(DriveLayout);
            }
        }

        MyFree(NtDevicePath);
    }

    return(GotIt ? Drive : L'C');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\i386\bootini.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    bootini.c

Abstract:

    Routines relating to boot.ini.

Author:

    Ted Miller (tedm) 4-Apr-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop


BOOL
ChangeBootTimeoutBootIni(
    IN UINT Timeout
    )

/*++

Routine Description:

    Changes the boot countdown value in boot.ini.

Arguments:

    Timeout - supplies new timeout value, in seconds.

Return Value:

    None.

--*/

{
    HFILE hfile;
    ULONG FileSize;
    PUCHAR buf = NULL,p1,p2;
    BOOL b;
    CHAR TimeoutLine[256];
    CHAR szBootIni[] = "?:\\BOOT.INI";

    szBootIni[0] = (CHAR)x86SystemPartitionDrive;

    wsprintfA(TimeoutLine,"timeout=%u\r\n",Timeout);

    //
    // Open and read boot.ini.
    //
    b = FALSE;
    hfile = _lopen(szBootIni,OF_READ);
    if(hfile != HFILE_ERROR) {

        FileSize = _llseek(hfile,0,2);
        if(FileSize != (ULONG)(-1)) {

            if((_llseek(hfile,0,0) != -1)
            && (buf = MyMalloc(FileSize+1))
            && (_lread(hfile,buf,FileSize) != (UINT)(-1)))
            {
                buf[FileSize] = 0;
                b = TRUE;
            }
        }

        _lclose(hfile);
    }

    if(!b) {
        if(buf) {
            MyFree(buf);
        }
        return(FALSE);
    }

    if(!(p1 = strstr(buf,"timeout"))) {
        MyFree(buf);
        return(FALSE);
    }

    if(p2 = strchr(p1,'\n')) {
        p2++;       // skip NL.
    } else {
        p2 = buf + FileSize;
    }

    SetFileAttributesA(szBootIni,FILE_ATTRIBUTE_NORMAL);

    hfile = _lcreat(szBootIni,0);
    if(hfile == HFILE_ERROR) {
        MyFree(buf);
        return(FALSE);
    }

    //
    // Write:
    //
    // 1) the first part, start=buf, len=p1-buf
    // 2) the timeout line
    // 3) the last part, start=p2, len=buf+FileSize-p2
    //

    b =  ((_lwrite(hfile,buf        ,p1-buf             ) != (UINT)(-1))
      &&  (_lwrite(hfile,TimeoutLine,strlen(TimeoutLine)) != (UINT)(-1))
      &&  (_lwrite(hfile,p2         ,buf+FileSize-p2    ) != (UINT)(-1)));

    _lclose(hfile);
    MyFree(buf);

    //
    // Make boot.ini archive, read only, and system.
    //
    SetFileAttributesA(
        szBootIni,
        FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_HIDDEN
        );

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\i386\fpu.c ===
#include "setupp.h"
#pragma hdrstop

//
// TRUE if we detected a flawed pentium chip.
//
BOOL FlawedPentium;

//
// TRUE if NPX emulation is forced on.
// Flag indicating what user wants to do.
//
BOOL CurrentNpxSetting;
BOOL UserNpxSetting;

//
// Name of value in HKLM\System\CurrentControlSet\Control\Session Manager
// controlling npx emulation.
//
PCWSTR NpxEmulationKey = L"System\\CurrentControlSet\\Control\\Session Manager";
PCWSTR NpxEmulationValue = L"ForceNpxEmulation";


BOOL
TestForDivideError(
    VOID
    );

int
ms_p5_test_fdiv(
    void
    );


VOID
CheckPentium(
    VOID
    )

/*++

Routine Description:

    Check all processor(s) for the Pentium floating-point devide errata.

Arguments:

    None.

Return Value:

    None. Global variables FlawedPentium, CurrentNpxSetting, and
    UserNpxSetting will be filled in.

--*/

{
    LONG rc;
    HKEY hKey;
    DWORD DataType;
    DWORD ForcedOn;
    DWORD DataSize;
    static LONG CheckedPentium = -1;

    //
    // If we didn't already check it CheckedPentium will become 0
    // with this increment.  If we already checked it then CheckedPentium
    // will become something greater than 0.
    //
    if(InterlockedIncrement(&CheckedPentium)) {
        return;
    }

    //
    // Perform division test to see whether pentium is flawed.
    //
    if(FlawedPentium = TestForDivideError()) {
        SetuplogError(
            LogSevInformation,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_FLAWED_PENTIUM,
            0,0);
    }

    //
    // Check registry to see whether npx is currently forced on. Assume not.
    //
    CurrentNpxSetting = 0;
    rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,NpxEmulationKey,0,KEY_QUERY_VALUE,&hKey);
    if(rc == NO_ERROR) {

        DataSize = sizeof(DWORD);
        rc = RegQueryValueEx(
                hKey,
                NpxEmulationValue,
                0,
                &DataType,
                (PBYTE)&ForcedOn,
                &DataSize
                );

        //
        // If the value isn't present then assume emulation
        // is not currently forced on. Otherwise the value tells us
        // whether emulation is forced on.
        //
        CurrentNpxSetting = (rc == NO_ERROR) ? ForcedOn : 0;
        if(rc == ERROR_FILE_NOT_FOUND) {
            rc = NO_ERROR;  // prevent bogus warning from being logged.
        }
        RegCloseKey(hKey);
    }

    if(rc != NO_ERROR) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_UNABLE_TO_CHECK_NPX_SETTING,
            rc,
            0,0);
    }

    //
    // For now set user's choice to the current setting.
    //
    UserNpxSetting = CurrentNpxSetting;
}


BOOL
SetNpxEmulationState(
    VOID
    )

/*++

Routine Description:

    Set state of NPX emulation based on current state of global variables
    CurrentNpxSetting and UserNpxSetting.

Arguments:

    None.

Return Value:

    Boolean value indicating outcome.

--*/

{
    LONG rc;
    HKEY hKey;
    DWORD DataType;
    DWORD ForcedOn;
    DWORD DataSize;

    //
    // Nothing to to if the setting has not changed.
    //
    if(CurrentNpxSetting == UserNpxSetting) {
        return(TRUE);
    }

    rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,NpxEmulationKey,0,KEY_SET_VALUE,&hKey);
    if(rc == NO_ERROR) {

        rc = RegSetValueEx(
                hKey,
                NpxEmulationValue,
                0,
                REG_DWORD,
                (PBYTE)&UserNpxSetting,
                sizeof(DWORD)
                );

        if(rc == NO_ERROR) {
            CurrentNpxSetting = UserNpxSetting;
        }

        RegCloseKey(hKey);
    }

    if(rc != NO_ERROR) {
        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_UNABLE_TO_SET_NPX_SETTING,
            rc,
            0,0);
    }

    return(rc == NO_ERROR);
}


BOOL
TestForDivideError(
    VOID
    )

/*++

Routine Description:

    Do a divide with a known divident/divisor pair, followed by
    a multiply to see if we get the right answer back.

Arguments:

    None.

Return Value:

    Boolean value indicating whether the computer exhibits the
    pentium fpu bug.

--*/

{
    DWORD pick;
    DWORD processmask;
    DWORD systemmask;
    DWORD i;
    BOOL rc;

    //
    // Assume no fpu bug.
    //
    rc = FALSE;

    //
    // Fetch the affinity mask, which is also effectively a list
    // of processors
    //
    GetProcessAffinityMask(GetCurrentProcess(),&processmask,&systemmask);

    //
    // Step through the mask, testing each cpu.
    // if any is bad, we treat them all as bad
    //
    for(i = 0; i < 32; i++) {

        pick = 1 << i;

        if(systemmask & pick) {

            SetThreadAffinityMask(GetCurrentThread(), pick);

            //
            // Call the critical test function
            //
            if(ms_p5_test_fdiv()) {
                rc = TRUE;
                break;
            }
        }
    }

    //
    // Reset affinity for this thread before returning.
    //
    SetThreadAffinityMask(GetCurrentThread(), processmask);
    return(rc);
}


/***
* testfdiv.c - routine to test for correct operation of x86 FDIV instruction.
*
*   Copyright (c) 1994, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Detects early steppings of Pentium with incorrect FDIV tables using
*   'official' Intel test values. Returns 1 if flawed Pentium is detected,
*   0 otherwise.
*
*/
int ms_p5_test_fdiv(void)
{
    double dTestDivisor = 3145727.0;
    double dTestDividend = 4195835.0;
    double dRslt;

    _asm {
        fld    qword ptr [dTestDividend]
        fdiv   qword ptr [dTestDivisor]
        fmul   qword ptr [dTestDivisor]
        fsubr  qword ptr [dTestDividend]
        fstp   qword ptr [dRslt]
    }

    return (dRslt > 1.0);
}



BOOL
CALLBACK
PentiumDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    NMHDR *NotifyParams;

    switch(msg) {

    case WM_INITDIALOG:
        //
        // Check the pentium.
        //
        CheckPentium();

        //
        // Set up default. If user setting is non-0, then some kind
        // of emulation is turned on (there are 2 possibilities).
        //
        CheckRadioButton(
            hdlg,
            IDC_RADIO_1,
            IDC_RADIO_2,
            UserNpxSetting ? IDC_RADIO_2 : IDC_RADIO_1
            );

        break;

    case WM_SIMULATENEXT:

        PropSheet_PressButton( GetParent(hdlg), PSBTN_NEXT);
        break;

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:
            TESTHOOK(522);
            SetWizardButtons(hdlg,WizPagePentiumErrata);

            if (FlawedPentium || UiTest) {
                if(Unattended) {
                    //
                    // This call makes the dialog activate, meaning
                    // we end up going through the PSN_WIZNEXT code below.
                    //
                    if (!UnattendSetActiveDlg(hdlg, IDD_PENTIUM))
                    {
                        break;
                    }
                    // Page becomes active, make page visible.
                    SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);

                } else {
                    SetWindowLong(hdlg,DWL_MSGRESULT, 0);
                    // Page becomes active, make page visible.
                    SendMessage(GetParent(hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
                }
            } else {
                SetWindowLong(hdlg,DWL_MSGRESULT,-1);
            }
            break;

        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
            //
            // Fetch emulation state. If user wants emulation and emulation
            // was already turned on preserve the current emulation setting.
            // Otherwise use setting 1.
            //
            if(IsDlgButtonChecked(hdlg,IDC_RADIO_2)) {
                if(!UserNpxSetting) {
                    UserNpxSetting = 1;
                }
            } else {
                UserNpxSetting = 0;
            }
            break;

        default:
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\ia64\platform.c ===
#include "setupp.h"
#pragma hdrstop


UINT
PlatformSpecificInit(
    VOID
    )
{
    return(NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\i386\pcihal.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    pcihal.c

Abstract:

    Routines for the Pci Hal property page.

Author:

    Santosh Jodh 10-July-1998

--*/

#include "setupp.h"
#pragma hdrstop
#include <windowsx.h>

#define MSG_SIZE    2048

#define Allocate(n) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, n)
#define Release(p)  HeapFree(GetProcessHeap(), 0, (LPVOID)p)

typedef struct _PciHalPropData PCIHALPROPDATA, *PPCIHALPROPDATA;

struct _PciHalPropData {
    HKEY                LocalMachine;
    BOOLEAN             CloseKey;
    DWORD               Options;
    HDEVINFO            DeviceInfoSet;
    PSP_DEVINFO_DATA    DeviceInfoData;    
};  

const DWORD gPciPropHelpIds[] = 
{
    IDC_PCIHAL_ICON,        (DWORD)-1,              // Icon
    IDC_PCIHAL_DEVDESC,     (DWORD)-1,              // Name of PC
    IDC_PCIHAL_ENABLE,      IDH_IRQ_ENABLE,         // Enable IRQ Routing
    IDC_PCIHAL_MSSPEC,      IDH_IRQ_MSSPEC,         // Use $PIR table
    IDC_PCIHAL_REALMODE,    IDH_IRQ_REALMODE,       // Use table from Real-mode BIOS call
    IDC_PCIHAL_SETDEFAULTS, IDH_IRQ_SETDEFAULTS,    // Set defaults for options
    IDC_PCIHAL_RESULTS,     IDH_IRQ_RESULTS,        // Status information    
    0,0
};

//
// Table used to translate status codes into string ids.
//
UINT gStatus[PIR_STATUS_MAX + 1] =              {   IDS_PCIHAL_ERROR, 
                                                    IDS_PCIHAL_ENABLED, 
                                                    IDS_PCIHAL_DISABLED,
                                                    IDS_PCIHAL_NOSTATUS
                                                };
UINT gTableStatus[PIR_STATUS_TABLE_MAX] =       {   IDS_PCIHAL_TABLE_REGISTRY, 
                                                    IDS_PCIHAL_TABLE_MSSPEC,
                                                    IDS_PCIHAL_TABLE_REALMODE,
                                                    IDS_PCIHAL_TABLE_NONE,
                                                    IDS_PCIHAL_TABLE_ERROR,                                                    
                                                    IDS_PCIHAL_TABLE_BAD,
                                                    IDS_PCIHAL_TABLE_SUCCESS
                                                };
UINT gMiniportStatus[PIR_STATUS_MINIPORT_MAX] = {   IDS_PCIHAL_MINIPORT_NORMAL, 
                                                    IDS_PCIHAL_MINIPORT_COMPATIBLE, 
                                                    IDS_PCIHAL_MINIPORT_OVERRIDE, 
                                                    IDS_PCIHAL_MINIPORT_NONE,
                                                    IDS_PCIHAL_MINIPORT_ERROR,                                                    
                                                    IDS_PCIHAL_MINIPORT_NOKEY,
                                                    IDS_PCIHAL_MINIPORT_SUCCESS,
                                                    IDS_PCIHAL_MINIPORT_INVALID
                                                };

PCIHALPROPDATA  gPciHalPropData = {0};

VOID
PciHalSetControls (
    IN HWND Dialog,
    IN DWORD Options,
    IN DWORD Attributes
    )

/*++

    Routine Description:

        This routine sets the controls on the Irq Routing page to the
        specified options.

    Input Parameters:

        Dialog - Window handle for the property sheet page.

        Options -  Pci Irq Routing options to be displayed.
        
    Return Value:

        None.
        
--*/

{
    BOOL enabled = FALSE;

    //
    // Enable the buttons depending on the options.
    //
    if (Options & PIR_OPTION_ENABLED)
    {
        enabled = TRUE;
        CheckDlgButton(Dialog, IDC_PCIHAL_ENABLE, 1);
    }

    CheckDlgButton(Dialog, IDC_PCIHAL_MSSPEC, Options & PIR_OPTION_MSSPEC);
    CheckDlgButton(Dialog, IDC_PCIHAL_REALMODE, Options & PIR_OPTION_REALMODE);
    

    //
    // Gray the windows not meaningful.
    //    
    EnableWindow(GetDlgItem(Dialog, IDC_PCIHAL_ENABLE), !(Attributes & PIR_OPTION_ENABLED));
    EnableWindow(GetDlgItem(Dialog, IDC_PCIHAL_SETDEFAULTS), !(Attributes & PIR_OPTION_ENABLED));
    EnableWindow(GetDlgItem(Dialog, IDC_PCIHAL_MSSPEC), enabled && !(Attributes & PIR_OPTION_MSSPEC));
    EnableWindow(GetDlgItem(Dialog, IDC_PCIHAL_REALMODE), enabled && !(Attributes & PIR_OPTION_REALMODE));

}

LPTSTR
PciHalGetDescription (
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData
    )

/*++

    Routine Description:

        This routine allocates memory and returns the device description
        for the specified device.

    Input Parameters:

        DeviceInfoSet - For the device.

        DeviceInfoData - For the device.

    Return Value:

        Pointer to the description iff successful. Else NULL.
        
--*/

{
    LPTSTR desc;
    DWORD   size;
    
    desc = NULL;
    
    //
    // Get the size of the description for this device.
    //
    size = 0;
    SetupDiGetDeviceRegistryProperty(   DeviceInfoSet,
                                        DeviceInfoData,
                                        SPDRP_DEVICEDESC,
                                        NULL,
                                        NULL,
                                        0,
                                        &size);

    if (size != 0)
    {
        //
        // Account for the terminating NULL character.
        //
        size++;
        
        //
        // Allocate memory for the device description.
        //
        desc = Allocate(size * sizeof(TCHAR));

        if (desc != NULL)
        {

            //
            // Get the device description.
            //
            if (SetupDiGetDeviceRegistryProperty(   DeviceInfoSet,
                                                    DeviceInfoData,
                                                    SPDRP_DEVICEDESC,
                                                    NULL,
                                                    (PBYTE)desc,
                                                    size * sizeof(TCHAR),
                                                    &size) == FALSE)
            {
                Release(desc);
                desc = NULL;
            }
        }
    }

    return desc;
}

LPTSTR
PciHalGetStatus (
    IN DWORD Status,
    IN DWORD TableStatus,
    IN DWORD MiniportStatus
    )

/*++

    Routine Description:

        This routine converts the different status codes into
        a status string and returns the pointer to the string.
        The caller should free the memory when done using this
        string.

    Input Parameters:

        Status - Pci Irq Routing status.

        TableStatus - Pci Irq Routing Table status. Lower WORD
        indicates the source of the table. The upper WORD indicates
        the table processing status.

        MiniportStatus - Pci Irq Routing Miniport status. Lower
        WORD indicates the source of the miniport. The upper WORD
        indicates the miniport processing status.

    Return Value:

        Pointer to the status string iff successful. Else NULL.
        
--*/

{
    LPTSTR   status;
    TCHAR   temp[128];

    status = Allocate(MSG_SIZE * sizeof(TCHAR));
    if (status)
    {
        //
        // Get the status about Pci Irq Routing.
        //
        LoadString(MyModuleHandle, gStatus[Status], status, MSG_SIZE);        

        //
        // Get the status about the source of Pci Irq Routing Table.
        //
        if ((TableStatus & 0xFFFF) < PIR_STATUS_TABLE_MAX)
        {
            lstrcat(status, L"\r\n\r\n");
            LoadString(MyModuleHandle, gTableStatus[TableStatus & 0xFFFF], temp, sizeof(temp)/sizeof(temp[0]));
            lstrcat(status, temp);
        }

        //
        // Get the status about the Pci Irq Routing table.
        //
        TableStatus >>= 16;
        if (TableStatus < PIR_STATUS_TABLE_MAX)
        {
            lstrcat(status, L"\r\n\r\n");
            LoadString(MyModuleHandle, gTableStatus[TableStatus], temp, sizeof(temp) / sizeof(TCHAR));
            lstrcat(status, temp);
        }

        //
        // Get the status about the source of the miniport.
        //
        if ((MiniportStatus & 0xFFFF) < PIR_STATUS_MINIPORT_MAX)
        {
            lstrcat(status, L"\r\n\r\n");
            LoadString(MyModuleHandle, gMiniportStatus[MiniportStatus & 0xFFFF], temp, sizeof(temp) / sizeof(TCHAR));
            lstrcat(status, temp);
        }

        //
        // Get the status about the miniport status.
        //
        MiniportStatus >>= 16;
        if (MiniportStatus < PIR_STATUS_MINIPORT_MAX)
        {
            lstrcat(status, L"\r\n\r\n");
            LoadString(MyModuleHandle, gMiniportStatus[MiniportStatus], temp, sizeof(temp) / sizeof(TCHAR));
            lstrcat(status, temp);
        }
    }

    return status;
}

BOOL
PciHalOnInitDialog (
    IN HWND Dialog,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

    Routine Description:

        This routine initializes the property sheet page on creation.
        
    Input Paramters:

        Dialog - Window handle for the property sheet page.

        wParam - wParam of the WM_INITDIALOG message.

        lParam - Pointer to the property sheet page.
        
    Return Value:

        TRUE.
        
--*/

{   
    PPCIHALPROPDATA             pciHalPropData;
    HKEY                        hKey;
    DWORD                       size;    
    DWORD                       status;
    DWORD                       tableStatus;
    DWORD                       miniportStatus;
    DWORD                       attributes;
    HICON                       hIconOld;
    HICON                       hIconNew;
    INT                         iconIndex;
    LPTSTR                      desc;
    SP_DEVINFO_LIST_DETAIL_DATA details;
    
    pciHalPropData = (PPCIHALPROPDATA)((LPPROPSHEETPAGE)lParam)->lParam;
    //
    // Read the Pci Irq Routing options and status from the registry.
    //
    pciHalPropData->Options = 0;
    status = PIR_STATUS_MAX;
    tableStatus = PIR_STATUS_TABLE_MAX | (PIR_STATUS_TABLE_MAX << 16);
    miniportStatus = PIR_STATUS_MINIPORT_MAX | (PIR_STATUS_MINIPORT_MAX << 16);
    details.cbSize = sizeof(SP_DEVINFO_LIST_DETAIL_DATA);
    attributes = PIR_OPTION_ENABLED | PIR_OPTION_MSSPEC | PIR_OPTION_REALMODE;
    if (SetupDiGetDeviceInfoListDetail(pciHalPropData->DeviceInfoSet, &details)) {

        if (RegConnectRegistry((details.RemoteMachineName[0] == TEXT('\0'))? NULL : details.RemoteMachineName, HKEY_LOCAL_MACHINE, &pciHalPropData->LocalMachine) == ERROR_SUCCESS) {

            pciHalPropData->CloseKey = TRUE;
            if (RegOpenKeyEx(pciHalPropData->LocalMachine, REGSTR_PATH_PCIIR, 0, KEY_READ, &hKey) == ERROR_SUCCESS) 
            { 
                size = sizeof(pciHalPropData->Options);
                RegQueryValueEx(hKey, REGSTR_VAL_OPTIONS, NULL, NULL, (LPBYTE)&pciHalPropData->Options, &size);

                size = sizeof(status);
                RegQueryValueEx(hKey, REGSTR_VAL_STAT, NULL, NULL, (LPBYTE)&status, &size);

                size = sizeof(tableStatus);
                RegQueryValueEx(hKey, REGSTR_VAL_TABLE_STAT, NULL, NULL, (LPBYTE)&tableStatus, &size);

                size = sizeof(miniportStatus);
                RegQueryValueEx(hKey, REGSTR_VAL_MINIPORT_STAT, NULL, NULL, (LPBYTE)&miniportStatus, &size);

                RegCloseKey(hKey);
            }

            //
            // Gray out the controls if the user does not have READ+WRITE access to the REGSTR_PATH_PCIIR. 
            //

            if (RegOpenKeyEx(pciHalPropData->LocalMachine, REGSTR_PATH_PCIIR, 0, KEY_READ | KEY_WRITE, &hKey) == ERROR_SUCCESS) {

                RegCloseKey(hKey);
                attributes = 0;
                if (RegOpenKeyEx(pciHalPropData->LocalMachine, REGSTR_PATH_BIOSINFO L"\\PciIrqRouting", 0, KEY_READ, &hKey) == ERROR_SUCCESS) { 

                    size = sizeof(attributes);
                    RegQueryValueEx(hKey, L"Attributes", NULL, NULL, (LPBYTE)&attributes, &size);
                    RegCloseKey(hKey);
                }
            }
        }
    }

    //
    // Set the class icon.
    //
    if (SetupDiLoadClassIcon(   &pciHalPropData->DeviceInfoData->ClassGuid, 
                                &hIconNew, 
                                &iconIndex) == TRUE)
    {
        hIconOld = (HICON)SendDlgItemMessage(   Dialog, 
                                                IDC_PCIHAL_ICON, 
                                                STM_SETICON,
                                                (WPARAM)hIconNew,
                                                0);
        if (hIconOld)                                                
        {
            DestroyIcon(hIconOld);
        }
    }

    //
    // Set the device description.
    //
    desc = PciHalGetDescription(pciHalPropData->DeviceInfoSet, pciHalPropData->DeviceInfoData);
    if (desc)
    {
        SetDlgItemText(Dialog, IDC_PCIHAL_DEVDESC, desc);
        Release(desc);
    }

    //
    // Set the initial state of the controls.
    //
    PciHalSetControls(Dialog, pciHalPropData->Options, attributes);

    //
    // Display status.
    //
    desc = PciHalGetStatus(status, tableStatus, miniportStatus);
    if (desc)
    {
        SetDlgItemText(Dialog, IDC_PCIHAL_RESULTS, desc);
        Release(desc);
    }

    //
    // Let the system set the focus.
    //
    
    return TRUE;
    }

BOOL
PciHalOnCommand (
    IN HWND Dialog,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

    Routine Description:

        This routine handles the message when the user modifies something
        on the property sheet page.

    Input Parameters:

        Dialog - Window handle for the property sheet page.

        wParam - wParam of the WM_COMMAND message.

        lParam - lParam of the WM_COMMAND message.
        
    Return Value:

        TRUE if this function handles the message. Else FALSE.
    
--*/

{
    BOOL status;
    BOOL enabled;

    status = FALSE;
    
    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {
        case IDC_PCIHAL_SETDEFAULTS:

            //
            // Set the controls to the default value.
            //
            status = TRUE;
            PciHalSetControls(Dialog, PIR_OPTION_DEFAULT, 0);
            break;

        case IDC_PCIHAL_ENABLE:

            //
            // Gray out the sub-options if Irq Routing is being disabled.
            //            
            status = TRUE;
            enabled = IsDlgButtonChecked(Dialog, IDC_PCIHAL_ENABLE);
            EnableWindow(GetDlgItem(Dialog, IDC_PCIHAL_MSSPEC), enabled);
            EnableWindow(GetDlgItem(Dialog, IDC_PCIHAL_REALMODE), enabled);            
            break;

        default:
        
            break;
    }

    return status;
}

BOOL
PciHalOnNotify(
    IN HWND Dialog,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

    Routine Description:

        This routine handles the WM_NOTIFY message for the Pci Irq Routing
        property sheet page.

    Input Parameters:

        Dialog - Window handle for the property sheet page.

        wParam - wParam of the WM_NOTIFY message.

        lParam - lParam of the WM_NOTIFY message.
    
    Return Value:

        TRUE if this function handles the message. Else FALSE.
        
--*/

{
    BOOL                    status = FALSE;
    HKEY                    hKey;
    DWORD                   options;
    
    switch (((LPNMHDR)lParam)->code)
    {
        case PSN_RESET:        

            //
            // User hit cancel.
            //
            status = TRUE;

            if (RegOpenKey(gPciHalPropData.LocalMachine, REGSTR_PATH_PCIIR, &hKey) == ERROR_SUCCESS)
            {
                RegSetValueEx(  hKey, 
                                REGSTR_VAL_OPTIONS, 
                                0, 
                                REG_DWORD, 
                                (CONST BYTE *)&gPciHalPropData.Options, 
                                sizeof(gPciHalPropData.Options));
                RegCloseKey(hKey);
            }
            
            break;
            
        case PSN_APPLY:

            //
            // User hit Apply or Ok.
            //
            status = TRUE;
            
            //
            // Read the different control status and write it to the registry.
            //
            options = gPciHalPropData.Options;
            if (IsDlgButtonChecked(Dialog, IDC_PCIHAL_ENABLE) == BST_CHECKED)
            {
                options |= PIR_OPTION_ENABLED;
            }
            else
            {
                options &= ~PIR_OPTION_ENABLED;
            }

            if (IsDlgButtonChecked(Dialog, IDC_PCIHAL_MSSPEC))
            {
                options |= PIR_OPTION_MSSPEC;
            }
            else
            {
                options &= ~PIR_OPTION_MSSPEC;
            }

            if (IsDlgButtonChecked(Dialog, IDC_PCIHAL_REALMODE))
            {
                options |= PIR_OPTION_REALMODE;
            }
            else
            {
                options &= ~PIR_OPTION_REALMODE;
            }

            if (RegOpenKey(gPciHalPropData.LocalMachine, REGSTR_PATH_PCIIR, &hKey) == ERROR_SUCCESS)
            {
                RegSetValueEx(  hKey, 
                                REGSTR_VAL_OPTIONS, 
                                0, 
                                REG_DWORD, 
                                (CONST BYTE *)&options, 
                                sizeof(options));
                RegCloseKey(hKey);
            }

            //
            // Reboot if any of the options changed.
            //
            if (options != gPciHalPropData.Options)
            {
                SP_DEVINSTALL_PARAMS    deviceInstallParams;

                memset(&deviceInstallParams, 0, sizeof(deviceInstallParams));
                deviceInstallParams.cbSize = sizeof(deviceInstallParams);
                if (SetupDiGetDeviceInstallParams(  gPciHalPropData.DeviceInfoSet, 
                                                    gPciHalPropData.DeviceInfoData, 
                                                    &deviceInstallParams))
                {
                    deviceInstallParams.Flags |= DI_NEEDREBOOT;
                    SetupDiSetDeviceInstallParams(  gPciHalPropData.DeviceInfoSet, 
                                                    gPciHalPropData.DeviceInfoData, 
                                                    &deviceInstallParams);
                    
                }
            }
            
            break;

        default:

            break;
    }

    return status;
}

BOOL
PciHalDialogProc(
    IN HWND Dialog,
    IN UINT Message,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

    Routine Description:

        This is the DlgProc for the Pci Irq Routing property sheet page.
        
    Input Parameters:

        Standard DlgProc parameters.
        
    Return Value:

        TRUE if it handles the message. Else FALSE.
        
--*/

{
    BOOL    status = FALSE;
    PCWSTR  szHelpFile = L"devmgr.hlp";
    
    switch (Message)
    {
        case WM_INITDIALOG:

            status = PciHalOnInitDialog(Dialog, wParam, lParam);
            break;

        case WM_COMMAND:

            status = PciHalOnCommand(Dialog, wParam, lParam);
            break;

        case WM_NOTIFY:

            status = PciHalOnNotify(Dialog, wParam, lParam);
            break;

        case WM_HELP:
            
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, szHelpFile, HELP_WM_HELP, (ULONG_PTR)gPciPropHelpIds);
            status = TRUE;
            break;
            
        case WM_CONTEXTMENU:

            WinHelp((HWND)wParam, szHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)gPciPropHelpIds);
            status = TRUE;
            break;

        case WM_DESTROY:

            if (gPciHalPropData.CloseKey) {
                RegCloseKey(gPciHalPropData.LocalMachine);
                gPciHalPropData.CloseKey = FALSE;
            }
        
        default:

            break;
    }

    return status;
}

DWORD
PciHalCoInstaller(
    IN DI_FUNCTION                      InstallFunction,
    IN HDEVINFO                         DeviceInfoSet,
    IN PSP_DEVINFO_DATA                 DeviceInfoData  OPTIONAL,
    IN OUT PCOINSTALLER_CONTEXT_DATA    Context
    )
{
    BOOL                        status;
    HPROPSHEETPAGE              pageHandle;
    PROPSHEETPAGE               page;
    SP_DEVINFO_LIST_DETAIL_DATA details;
    SP_ADDPROPERTYPAGE_DATA     addPropertyPageData;

    switch (InstallFunction) {
    case DIF_ADDPROPERTYPAGE_ADVANCED:        
    case DIF_ADDREMOTEPROPERTYPAGE_ADVANCED:

        details.cbSize = sizeof(SP_DEVINFO_LIST_DETAIL_DATA);
        if (SetupDiGetDeviceInfoListDetail(DeviceInfoSet, &details)) {

            if (RegConnectRegistry((details.RemoteMachineName[0] == TEXT('\0'))? NULL : details.RemoteMachineName, HKEY_LOCAL_MACHINE, &gPciHalPropData.LocalMachine) == ERROR_SUCCESS) {

                RegCloseKey(gPciHalPropData.LocalMachine);
                status = TRUE;
                break;
            }
        }

    default:

        status = FALSE;
        break;
    }
    if (status) {

        ZeroMemory(&addPropertyPageData, sizeof(SP_ADDPROPERTYPAGE_DATA));
        addPropertyPageData.ClassInstallHeader.cbSize = 
             sizeof(SP_CLASSINSTALL_HEADER);

        if (SetupDiGetClassInstallParams(DeviceInfoSet, DeviceInfoData,
             (PSP_CLASSINSTALL_HEADER)&addPropertyPageData,
             sizeof(SP_ADDPROPERTYPAGE_DATA), NULL )) {

           if (addPropertyPageData.NumDynamicPages < MAX_INSTALLWIZARD_DYNAPAGES) {

               //
               // Initialize our globals here.
               //
               gPciHalPropData.DeviceInfoSet    = DeviceInfoSet;
               gPciHalPropData.DeviceInfoData   = DeviceInfoData;

               //
               // Initialize our property page here.
               //
               memset(&page, 0, sizeof(PROPSHEETPAGE));
               page.dwSize      = sizeof(PROPSHEETPAGE);
               page.hInstance   = MyModuleHandle;
               page.pszTemplate = MAKEINTRESOURCE(IDD_PCIHAL_PROPPAGE);
               page.pfnDlgProc  = PciHalDialogProc;
               page.lParam      = (LPARAM)&gPciHalPropData;

               pageHandle = CreatePropertySheetPage(&page);
               if (pageHandle != NULL)
               {

                   addPropertyPageData.DynamicPages[addPropertyPageData.NumDynamicPages++] = pageHandle;
                    SetupDiSetClassInstallParams(DeviceInfoSet, DeviceInfoData,
                        (PSP_CLASSINSTALL_HEADER)&addPropertyPageData,
                        sizeof(SP_ADDPROPERTYPAGE_DATA));

                    return NO_ERROR;
               }
           }
        }
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\i386\platform.c ===
#include "setupp.h"
#pragma hdrstop


WCHAR x86SystemPartitionDrive;

WCHAR FloppylessBootPath[MAX_PATH];


UINT
PlatformSpecificInit(
    VOID
    )
{
    //
    // Determine x86 system partition (usually but not always C:).
    //
    x86SystemPartitionDrive = x86DetermineSystemPartition();
    return(NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\i386\spx86.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    spi386.h

Abstract:

    Header file for x86-specific stuff in system installation module.

Author:

    Ted Miller (tedm) 4-Apr-1995

Revision History:

--*/

#ifdef _X86_

VOID
CheckPentium(
    VOID
    );

BOOL
SetNpxEmulationState(
    VOID
    );

BOOL
CALLBACK
PentiumDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

WCHAR
x86DetermineSystemPartition(
    VOID
    );

extern WCHAR x86SystemPartitionDrive;
extern WCHAR FloppylessBootPath[MAX_PATH];

//
// Pci Hal property page provider (pcihal.c).
//

DWORD
PciHalCoInstaller(
    IN DI_FUNCTION                      InstallFunction,
    IN HDEVINFO                         DeviceInfoSet,
    IN PSP_DEVINFO_DATA                 DeviceInfoData  OPTIONAL,
    IN OUT PCOINSTALLER_CONTEXT_DATA    Context
    );

BOOL
ChangeBootTimeoutBootIni(
    IN UINT Timeout
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\i386\migwin95.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    migwin95.c

Abstract:

    This file contains the syssetup hooks for win9x->Nt5.0 migration. Most functions
    call out to the w95upgnt.dll where the real work is done.

Author:

    Jaime Sasson 30-Aug-1995

Revision History:

    29-Ian-1998  calinn    Added RemoveFiles_x86
    24-Jul-1997  marcw     Minor bug cleanup.
    03-Oct-1996  jimschm   Changed over to use migration DLLs
    22-Jan-1997  jimschm   Added Win95MigrationFileRemoval
    28-Feb-1997  jimschm   Added SourceDir to MIGRATE fn
     3-Apr-1997  jimschm   Added PreWin9xMigration

--*/

#include "setupp.h"
#pragma hdrstop

#define S_UNDO_INF          L"SF_UNDO.INF"
#define S_UNDO_PROFILESPATH L"PROFILESPATH"
#define S_UNDO_MOVEDFILES   L"MOVEDFILES"

typedef BOOL (WINAPI *MIGRATE) (HWND WizardParentWnd, LPCWSTR UnattendFile, LPCWSTR SourceDir);
typedef BOOL (WINAPI *FILEREMOVAL) (void);

static HANDLE g_Win95UpgNTLib;

BOOL
SpCreateSpoolerKey (
    VOID
    )
{
    HKEY SpoolerKey;
    LONG rc;
    DWORD DontCare;
    static DWORD NinetyFive = 95;

    //
    // For spooler: write an upgrade flag that will automatically be removed
    //

    rc = RegCreateKeyEx (
             HKEY_LOCAL_MACHINE,
             WINNT_WIN95UPG_SPOOLER,
             0,
             NULL,
             0,
             KEY_WRITE,
             NULL,
             &SpoolerKey,
             &DontCare
             );

    if (rc != ERROR_SUCCESS) {
        return FALSE;
    }

    rc = RegSetValueEx (
             SpoolerKey,
             WINNT_WIN95UPG_UPGRADE_VAL,
             0,
             REG_DWORD,
             (LPBYTE) &NinetyFive,
             sizeof (NinetyFive)
             );

    RegCloseKey (SpoolerKey);

    return rc == ERROR_SUCCESS;
}

BOOL
PreWin9xMigration(
    VOID
    )
{
    BOOL b;
    
    BEGIN_SECTION(TEXT("PreWin9xMigration"));

    b = SpCreateSpoolerKey();
    if(!b){
        SetupDebugPrint(TEXT("SpCreateSpoolerKey failed"));
    }

    END_SECTION(TEXT("PreWin9xMigration"));

    return b;
}



BOOL
MigrateWin95Settings(
    IN HWND       hwndWizardParent,
    IN LPCWSTR    UnattendFile
    )
/*++

Routine Description:

    Loads w95upgnt.dll and calls W95UpgNt_Migrate.  This function
    transfers all Win9x settings to the new NT installation, and
    is completely restartable.

Arguments:

    hwndWizardParent    Handle to the wizard window, used for (rare) UI
    UnattendFile        The full Win32 path to the unattend file, to be
                        opened via Setup APIs

Return Value:

    Returns TRUE if the module was successful, or FALSE otherwise.
    GetLastError() holds a Win32 error code if not successful.

--*/
{
    MIGRATE Migrate;
    BOOL b = FALSE;
    WCHAR buffer[2048];

    g_Win95UpgNTLib = NULL;

    //
    // See if there is a replacement path for the w95upgnt.dll.
    //
    GetPrivateProfileStringW (
        WINNT_WIN95UPG_95_DIR_W,
        WINNT_WIN95UPG_NTKEY_W,
        L"",
        buffer,
        sizeof(buffer)/sizeof(WCHAR),
        UnattendFile
        );

    if (*buffer) {

        //
        // We have a replacement dll to load.
        //
        g_Win95UpgNTLib = LoadLibrary (buffer);
    }

    if (!g_Win95UpgNTLib) {

        //
        // Either there was not a replacement, or loading that replacement failed.
        //

        g_Win95UpgNTLib = LoadLibrary (L"w95upgnt.dll");

    }


    if (!g_Win95UpgNTLib) {

        return FALSE;
    }

    Migrate = (MIGRATE) GetProcAddress (g_Win95UpgNTLib, "W95UpgNt_Migrate");
    if (Migrate) {
        b = Migrate (hwndWizardParent, UnattendFile, SourcePath);
    }

    return b;
}



BOOL
Win95MigrationFileRemoval(
    void
    )
/*++

Routine Description:

    Loads w95upgnt.dll and calls W95UpgNt_FileRemoval.  This function
    deletes all Win9x-specific files and removes temporary files including
    all migration DLLs.  It is NOT restartable.

Arguments:

    none

Return Value:

    Returns TRUE if the module was successful, or FALSE otherwise.
    GetLastError() holds a Win32 error code if not successful.

--*/
{
    FILEREMOVAL FileRemoval;
    BOOL b = FALSE;

    FileRemoval = (FILEREMOVAL) GetProcAddress (g_Win95UpgNTLib, "W95UpgNt_FileRemoval");
    if (FileRemoval)
        b = FileRemoval();

    FreeLibrary (g_Win95UpgNTLib);
    return b;
}

#define SIF_REMOVEFILESX86        L"RemoveFiles.x86"

BOOL
RemoveFiles_X86 (
    IN HINF InfHandle
    )
{
    WCHAR fullPath[MAX_PATH],fileName[MAX_PATH];
    INFCONTEXT lineContext;

    if (InfHandle == INVALID_HANDLE_VALUE) {
        return TRUE;
    }
    if (SetupFindFirstLine (
            InfHandle,
            SIF_REMOVEFILESX86,
            NULL,
            &lineContext
            )) {
        do {
            if ((SetupGetStringField (&lineContext, 1, fileName, MAX_PATH, NULL)) &&
                (GetWindowsDirectory (fullPath, MAX_PATH)) &&
                (pSetupConcatenatePaths (fullPath, fileName, MAX_PATH, NULL)) &&
                (SetFileAttributes (fullPath, FILE_ATTRIBUTE_NORMAL))
                ) {
                DeleteFile (fullPath);
            }
        }
        while (SetupFindNextLine (&lineContext, &lineContext));
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\syssetup\i386\syspart.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    syspart.c

Abstract:

    Routines to determine the system partition on x86 machines.

Author:

    Ted Miller (tedm) 30-June-1994

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop


BOOL
AppearsToBeSysPart(
    IN PDRIVE_LAYOUT_INFORMATION DriveLayout,
    IN WCHAR                     Drive
    )
{
    PARTITION_INFORMATION PartitionInfo,*p;
    BOOL IsPrimary;
    unsigned i;
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;

    PWSTR BootFiles[] = { L"BOOT.INI",
                          L"NTLDR",
                          L"NTDETECT.COM",
                          NULL
                        };

    WCHAR FileName[64];

    //
    // Get partition information for this partition.
    //
    if(!GetPartitionInfo(Drive,&PartitionInfo)) {
        return(FALSE);
    }

    //
    // See if the drive is a primary partition.
    //
    IsPrimary = FALSE;
    for(i=0; i<min(DriveLayout->PartitionCount,4); i++) {

        p = &DriveLayout->PartitionEntry[i];

        if((p->PartitionType != PARTITION_ENTRY_UNUSED)
        && (p->StartingOffset.QuadPart == PartitionInfo.StartingOffset.QuadPart)
        && (p->PartitionLength.QuadPart == PartitionInfo.PartitionLength.QuadPart)) {

            IsPrimary = TRUE;
            break;
        }
    }

    if(!IsPrimary) {
        return(FALSE);
    }

    //
    // Don't rely on the active partition flag.  This could easily not be accurate
    // (like user is using os/2 boot manager, for example).
    //

    //
    // See whether nt boot files are present on this drive.
    //
    for(i=0; BootFiles[i]; i++) {

        wsprintf(FileName,L"%wc:\\%s",Drive,BootFiles[i]);

        FindHandle = FindFirstFile(FileName,&FindData);
        if(FindHandle == INVALID_HANDLE_VALUE) {
            return(FALSE);
        } else {
            FindClose(FindHandle);
        }
    }

    return(TRUE);
}


WCHAR
x86DetermineSystemPartition(
    VOID
    )

/*++

Routine Description:

    Determine the system partition on x86 machines.

    The system partition is the primary partition on the boot disk.
    Usually this is the active partition on disk 0 and usually it's C:.
    However the user could have remapped drive letters and generally
    determining the system partition with 100% accuracy is not possible.

    The one thing we can be sure of is that the system partition is on
    the physical hard disk with the arc path multi(0)disk(0)rdisk(0).
    We can be sure of this because by definition this is the arc path
    for bios drive 0x80.

    This routine determines which drive letters represent drives on
    that physical hard drive, and checks each for the nt boot files.
    The first drive found with those files is assumed to be the system
    partition.

    If for some reason we cannot determine the system partition by the above
    method, we simply assume it's C:.

Arguments:

    None.

Return Value:

    Drive letter of system partition.

--*/

{
    BOOL  GotIt;
    PWSTR NtDevicePath;
    WCHAR Drive;
    WCHAR DriveName[3];
    WCHAR Buffer[512];
    DWORD NtDevicePathLen;
    PWSTR p;
    DWORD PhysicalDriveNumber;
    HANDLE hDisk;
    BOOL b;
    DWORD DataSize;
    PVOID DriveLayout;
    DWORD DriveLayoutSize;
    DWORD hardDiskNumber;

    WCHAR TempBuffer[MAX_PATH]; //NEC98

    DriveName[1] = L':';
    DriveName[2] = 0;

    GotIt = FALSE;

  if (!IsNEC_98) {

    //
    // The system partition must be on multi(0)disk(0)rdisk(0)
    //
    if(NtDevicePath = ArcDevicePathToNtPath(L"multi(0)disk(0)rdisk(0)")) {

        //
        // The arc path for a disk device is usually linked
        // to partition0. Get rid of the partition part of the name.
        //
        CharLower(NtDevicePath);
        if(p = wcsstr(NtDevicePath,L"\\partition")) {
            *p = 0;
        }

        NtDevicePathLen = lstrlen(NtDevicePath);

        //
        // Determine the physical drive number of this drive.
        // If the name is not of the form \device\harddiskx then
        // something is very wrong.
        //
        if(!wcsncmp(NtDevicePath,L"\\device\\harddisk",16)) {

            PhysicalDriveNumber = wcstoul(NtDevicePath+16,NULL,10);

            wsprintf(Buffer,L"\\\\.\\PhysicalDrive%u",PhysicalDriveNumber);

            //
            // Get drive layout info for this physical disk.
            //
            hDisk = CreateFile(
                        Buffer,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );

            if(hDisk != INVALID_HANDLE_VALUE) {

                //
                // Get partition information.
                //
                DriveLayout = MyMalloc(1024);
                DriveLayoutSize = 1024;

                retry:

                b = DeviceIoControl(
                        hDisk,
                        IOCTL_DISK_GET_DRIVE_LAYOUT,
                        NULL,
                        0,
                        DriveLayout,
                        DriveLayoutSize,
                        &DataSize,
                        NULL
                        );

                if(!b && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {

                    DriveLayoutSize += 1024;
                    DriveLayout = MyRealloc(DriveLayout,DriveLayoutSize);
                    goto retry;
                }

                CloseHandle(hDisk);

                if(b) {

                    //
                    // The system partition can only be a drive that is on
                    // this disk.  We make this determination by looking at NT drive names
                    // for each drive letter and seeing if the nt equivalent of
                    // multi(0)disk(0)rdisk(0) is a prefix.
                    //
                    for(Drive=L'C'; Drive<=L'Z'; Drive++) {

                        if(MyGetDriveType(Drive) == DRIVE_FIXED) {

                            DriveName[0] = Drive;

                            if(QueryDosDevice(DriveName,Buffer,sizeof(Buffer)/sizeof(WCHAR))) {

                                if (_wcsnicmp(Buffer, L"\\device\\harddisk", 16)) {
                                    hardDiskNumber = QueryHardDiskNumber((UCHAR) Drive);
                                    if (hardDiskNumber != (DWORD) -1) {
                                        swprintf(Buffer, TEXT("\\device\\harddisk%d"),
                                                 hardDiskNumber);
                                    }
                                }

                                if(!_wcsnicmp(NtDevicePath,Buffer,NtDevicePathLen)) {

                                    //
                                    // Now look to see whether there's an nt boot sector and
                                    // boot files on this drive.
                                    //
                                    if(AppearsToBeSysPart(DriveLayout,Drive)) {
                                        GotIt = TRUE;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                MyFree(DriveLayout);
            }
        }

        MyFree(NtDevicePath);
    }

  } else { //NEC98

    //
    // Do not only see "multi(0)disk(0)rdisk(0)".
    //
    if(GetWindowsDirectory(TempBuffer,MAX_PATH)) {

        Drive = *TempBuffer;
        GotIt = TRUE;

    }

  } //NEC98

    return(GotIt ? Drive : L'C');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\testtool\x.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <setupapi.h>
#include "..\inc\spapip.h"
#include <stdio.h>


NTSTATUS
MyGetFileVersion(
    IN PVOID ImageBase
    );


VOID
__cdecl
wmain(
    IN int argc,
    IN WCHAR *argv[]
    )
{
    NTSTATUS Status;
    DWORD d;
    DWORD FileSize;
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PVOID ImageBase;

    //
    // Open and map file for read.
    //
    d = OpenAndMapFileForRead(argv[1],&FileSize,&FileHandle,&MappingHandle,&ImageBase);
    if(d == NO_ERROR) {
        //
        // For some reason you have to set the low bit to make this work
        //
        MyGetFileVersion((PVOID)((ULONG)ImageBase | 1));

        UnmapAndCloseFile(FileHandle,MappingHandle,ImageBase);
    } else {
        printf("Couldn't open %ws\n",argv[1]);
    }
}




NTSTATUS
MyGetFileVersion(
    IN PVOID ImageBase
    )
{
    PIMAGE_RESOURCE_DATA_ENTRY DataEntry;
    NTSTATUS Status;
    ULONG IdPath[3];
    ULONG ResourceSize;
    struct {
        USHORT TotalSize;
        USHORT DataSize;
        USHORT Type;
        WCHAR Name[16];                     // L"VS_VERSION_INFO" + unicode nul
        VS_FIXEDFILEINFO FixedFileInfo;
    } *Resource;

    ULONG VerMS,VerLS;


    IdPath[0] = (ULONG)RT_VERSION;
    IdPath[1] = (ULONG)MAKEINTRESOURCE(VS_VERSION_INFO);
    IdPath[2] = 0;

    Status = LdrFindResource_U(ImageBase,IdPath,3,&DataEntry);
    if(!NT_SUCCESS(Status)) {
        printf("Not a PE image or no version resources\n");
        goto c0;
    }

    Status = LdrAccessResource(ImageBase,DataEntry,&Resource,&ResourceSize);
    if(!NT_SUCCESS(Status)) {
        printf("Unable to access version resources\n");
        goto c0;
    }

    if((ResourceSize >= sizeof(*Resource)) && !_wcsicmp(Resource->Name,L"VS_VERSION_INFO")) {

        VerMS = Resource->FixedFileInfo.dwFileVersionMS;
        VerLS = Resource->FixedFileInfo.dwFileVersionLS;

        printf(
            "%u.%u.%u.%u\n",
            VerMS >> 16,
            VerMS & 0xffff,
            VerLS >> 16,
            VerLS & 0xffff
            );

    } else {

        printf("Invalid version resources");
    }

c0:
    return(Status);
}






































#if 0
    LPUNKNOWN pUnkOuter;
    IShellLink *psl;
    IPersistFile *ppf;
    CShellLink *this;
    BOOL b;

    b = FALSE;

    //
    // Create an IShellLink and query for IPersistFile
    //
    if(FAILED(SHCoCreateInstance(NULL,&CLSID_ShellLink,pUnkOuter,&IID_IShellLink,&psl))) {
        goto c0;
    }
    if(FAILED(psl->lpVtbl->QueryInterface(psl,&IID_IPersistFile,&ppf))) {
        goto c1;
    }

    //
    // Load the link from disk and get a pointer to
    // the actual link data.
    //
    if(FAILED(ppf->lpVtbl->Load(ppf,argv[1],0))) {
        goto c2;
    }
    this = IToClass(CShellLink,sl,psl);

    //
    // Remove the link tracking data.
    //
    Link_RemoveExtraDataSection(this,EXP_TRACKER_SIG);

    //
    // Save the link back out.
    //
    if(FAILED(ppf->lpVtbl->Save(ppf,argv[1],TRUE))) {
        goto c2;
    }

    //
    // Success.
    //
    b = TRUE;

c2:
    //
    // Release the IPersistFile object
    //
    ppf->lpVtbl->Release(ppf);
c1:
    //
    // Release the IShellLink object
    //
    psl->lpVtbl->Release(psl);
c0:
    return(b);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\cmdcons\cmds1.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    cmds1.c

Abstract:

    This module implements miscellaneous commands.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop

BOOLEAN AllowWildCards;

NTSTATUS
RcSetFileAttributes(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    );

NTSTATUS
RcSetFileCompression(
    LPCWSTR szFileName,
    BOOLEAN bCompress
    );
    
NTSTATUS
RcGetFileAttributes(
    LPCWSTR lpFileName,
    PULONG FileAttributes
    );

BOOLEAN
pRcCmdEnumDelFiles(
    IN  LPCWSTR Directory,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT NTSTATUS *Status,
    IN  PWCHAR DosDirectorySpec
    );
  


ULONG
RcCmdType(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    LPCWSTR Arg;
    HANDLE FileHandle;
    HANDLE SectionHandle;
    PVOID ViewBase;
    ULONG FileSize;
    ULONG rc;
    ULONG cbText;
    WCHAR *pText;
    NTSTATUS Status;


    if (RcCmdParseHelp( TokenizedLine, MSG_TYPE_HELP )) {
        return 1;
    }

    //
    // There should be a token for TYPE and one for the arg.
    //
    ASSERT(TokenizedLine->TokenCount == 2);

    //
    // Get the argument and convert it into a full NT pathname.
    //
    Arg = TokenizedLine->Tokens->Next->String;
    if (!RcFormFullPath(Arg,_CmdConsBlock->TemporaryBuffer,FALSE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    if (!RcIsPathNameAllowed(_CmdConsBlock->TemporaryBuffer,TRUE,FALSE)) {
        RcMessageOut(MSG_ACCESS_DENIED);
        return 1;
    }

    //
    // Get the argument and convert it into a full NT pathname.
    //
    if (!RcFormFullPath(Arg,_CmdConsBlock->TemporaryBuffer,TRUE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    //
    // Map in the entire file.
    //
    FileHandle = NULL;
    Status = SpOpenAndMapFile(
                             _CmdConsBlock->TemporaryBuffer,
                             &FileHandle,
                             &SectionHandle,
                             &ViewBase,
                             &FileSize,
                             FALSE
                             );

    if( !NT_SUCCESS(Status) ) {
        RcNtError(Status,MSG_CANT_OPEN_FILE);
        return 1;
    }

    //
    // See if we think the file is Unicode. We think it's Unicode
    // if it's even length and starts with the Unicode text marker.
    //
    pText = ViewBase;
    cbText = FileSize;

    try {
        if( (cbText >= sizeof(WCHAR)) && (*pText == 0xfeff) && !(cbText & 1) ) {
            //
            // Assume it's already unicode.
            //
            pText = SpMemAlloc(cbText);
            RtlCopyMemory(pText,(WCHAR *)ViewBase+1,cbText-sizeof(WCHAR));
            pText[cbText/sizeof(WCHAR)] = 0;

        } else {
            //
            // It's not Unicode. Convert it from ANSI to Unicode.
            //
            // Allocate a buffer large enough to hold the maximum
            // unicode text.  This max size occurs when
            // every character is single-byte, and this size is
            // equal to exactly double the size of the single-byte text.
            //
            pText = SpMemAlloc((cbText+1)*sizeof(WCHAR));
            RtlZeroMemory(pText,(cbText+1)*sizeof(WCHAR));

            Status = RtlMultiByteToUnicodeN(
                                           pText,                  // output: newly allocated buffer
                                           cbText * sizeof(WCHAR), // max size of output
                                           &cbText,                // receives # bytes in unicode text
                                           ViewBase,               // input: ANSI text (mapped file)
                                           cbText                  // size of input
                                           );
        }
    }except(IN_PAGE_ERROR) {
        Status = STATUS_IN_PAGE_ERROR;
    }

    if( NT_SUCCESS(Status) ) {
        pRcEnableMoreMode();
        RcTextOut(pText);
        pRcDisableMoreMode();
    } else {
        RcNtError(Status,MSG_CANT_READ_FILE);
    }

    if( pText != ViewBase ) {
        SpMemFree(pText);
    }
    SpUnmapFile(SectionHandle,ViewBase);
    ZwClose(FileHandle);

    return 1;
}


ULONG
RcCmdDelete(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    WCHAR *Final;
    BOOLEAN Confirm = FALSE;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;
    PWSTR DelSpec = NULL;
    PWSTR DosDelSpec = NULL;
    WCHAR Text[2];
    PWSTR YesNo = NULL;
    ULONG rc;


    if (RcCmdParseHelp( TokenizedLine, MSG_DELETE_HELP )) {
        goto exit;
    }

    //
    // Fetch the spec for the file to be deleted and convert it
    // into a fully-qualified NT-style path.
    //
    if (!RcFormFullPath(TokenizedLine->Tokens->Next->String,_CmdConsBlock->TemporaryBuffer,TRUE)) {
        RcMessageOut(MSG_INVALID_PATH);
        goto exit;
    }

    //
    // Leave room for appending * if necessary.
    //
    DelSpec = SpMemAlloc((wcslen(_CmdConsBlock->TemporaryBuffer)+3)*sizeof(WCHAR));
    wcscpy(DelSpec,_CmdConsBlock->TemporaryBuffer);

    //
    // Do the same thing, except now we want the DOS-style name.
    // This is used for printing in case of errors.
    //
    if (!RcFormFullPath(TokenizedLine->Tokens->Next->String,_CmdConsBlock->TemporaryBuffer,FALSE)) {
        RcMessageOut(MSG_INVALID_PATH);
        goto exit;
    }

    DosDelSpec = SpMemAlloc((wcslen(_CmdConsBlock->TemporaryBuffer)+3)*sizeof(WCHAR));
    wcscpy(DosDelSpec,_CmdConsBlock->TemporaryBuffer);

    //
    // see if the user is authorized to delete this file
    //
    if (!RcIsPathNameAllowed(_CmdConsBlock->TemporaryBuffer,TRUE,FALSE)) {
        RcMessageOut(MSG_ACCESS_DENIED);
        goto exit;
    }

    if (RcDoesPathHaveWildCards(_CmdConsBlock->TemporaryBuffer)) {
        Confirm = TRUE;
        if (!AllowWildCards) {
            RcMessageOut(MSG_DEL_WILDCARD_NOT_SUPPORTED);
            goto exit;
        }
    }

    //
    // Check to see whether the target specifies a directory.
    // If so, add the * so we don't need to special-case
    // the confirmation message later.
    //
    INIT_OBJA(&Obja,&UnicodeString,DelSpec);

    Status = ZwOpenFile(
        &Handle,
        FILE_READ_ATTRIBUTES,
        &Obja,
        &IoStatusBlock,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_DIRECTORY_FILE
        );
    if( NT_SUCCESS(Status) ) {
        ZwClose(Handle);
        SpConcatenatePaths(DelSpec,L"*");
        SpConcatenatePaths(DosDelSpec,L"*");
        Confirm = TRUE;
    }

    //
    // Fetch yes/no text
    //
    YesNo = SpRetreiveMessageText(ImageBase,MSG_YESNO,NULL,0);
    if (!YesNo) {
        Confirm = FALSE;
    }

    if (!InBatchMode) {
        while( Confirm ) {
            RcMessageOut(MSG_CONFIRM_DELETE,DosDelSpec);
            if( RcLineIn(Text,2) ) {
                if( (Text[0] == YesNo[0]) || (Text[0] == YesNo[1]) ) {
                    //
                    // Wants to do it.
                    //
                    Confirm = FALSE;
                } else {
                    if( (Text[0] == YesNo[2]) || (Text[0] == YesNo[3]) ) {
                        //
                        // Doesn't want to do it.
                        //
                        goto exit;
                    }
                }
            }
        }
    }

    //
    // Trim back the DOS-style path so it's a path to the directory
    // containing the file or files to be deleted.
    //
    *wcsrchr(DosDelSpec,L'\\') = 0;

    // Perform deletion via callback.
    //
    Status = RcEnumerateFiles(TokenizedLine->Tokens->Next->String,
                             DelSpec,
                             pRcCmdEnumDelFiles,
                             DosDelSpec);

    if( !NT_SUCCESS(Status) ) {
        RcNtError(Status,MSG_FILE_ENUM_ERROR);
    }

exit:

    if (DelSpec) {
        SpMemFree(DelSpec);
    }
    if (DosDelSpec) {
        SpMemFree(DosDelSpec);
    }
    if (YesNo) {
        SpMemFree(YesNo);
    }

    return 1;
}


BOOLEAN
pRcCmdEnumDelFiles(
    IN  LPCWSTR                     Directory,
    IN  PFILE_BOTH_DIR_INFORMATION  FileInfo,
    OUT NTSTATUS                   *Status,
    IN  PWCHAR                      DosDirectorySpec
    )
{
    NTSTATUS status;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    WCHAR *p;
    FILE_DISPOSITION_INFORMATION Disposition;
    unsigned u;

    *Status = STATUS_SUCCESS;

    //
    // Skip directories
    //
    if( FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
        return(TRUE);
    }

    //
    // Form fully qualified NT path of the file to be deleted.
    //
    u = ((wcslen(Directory)+2)*sizeof(WCHAR)) + FileInfo->FileNameLength;
    p = SpMemAlloc(u);
    wcscpy(p,Directory);
    SpConcatenatePaths(p,FileInfo->FileName);

    INIT_OBJA(&Obja,&UnicodeString,p);

    status = ZwOpenFile(
                       &Handle,
                       (ACCESS_MASK)DELETE,
                       &Obja,
                       &IoStatusBlock,
                       FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                       FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                       );

    if( !NT_SUCCESS(status) ) {
        RcTextOut(DosDirectorySpec);
        RcTextOut(L"\\");
        RcTextOut(FileInfo->FileName);
        RcTextOut(L"\r\n");
        RcNtError(status,MSG_DELETE_ERROR);
        SpMemFree(p);
        return(TRUE);
    }

#undef DeleteFile
    Disposition.DeleteFile = TRUE;

    status = ZwSetInformationFile(
                                 Handle,
                                 &IoStatusBlock,
                                 &Disposition,
                                 sizeof(FILE_DISPOSITION_INFORMATION),
                                 FileDispositionInformation
                                 );

    ZwClose(Handle);

    if( !NT_SUCCESS(status) ) {
        RcTextOut(DosDirectorySpec);
        RcTextOut(L"\\");
        RcTextOut(FileInfo->FileName);
        RcTextOut(L"\r\n");
        RcNtError(status,MSG_DELETE_ERROR);
    }

    SpMemFree(p);

    return(TRUE);
}


ULONG
RcCmdRename(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    WCHAR *Arg;
    WCHAR *p,*q;
    NTSTATUS Status;
    ULONG rc;


    //
    // check for help
    //
    if (RcCmdParseHelp( TokenizedLine, MSG_RENAME_HELP )) {
        return 1;
    }

    //
    // There should be a token for RENAME and one each for the source and
    // target names.
    //
    if (TokenizedLine->TokenCount != 3) {
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }

    //
    // use the console's temporary buffer
    //
    p = _CmdConsBlock->TemporaryBuffer;

    //
    // process the SOURCE filename
    //
    Arg = TokenizedLine->Tokens->Next->String;

    //
    // Convert the SOURCE filname into a DOS path so we
    // can verify if the path is allowed by our security restrictions.
    //
    if (!RcFormFullPath(Arg,p,FALSE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    if (!RcIsPathNameAllowed(p,TRUE,FALSE)) {
        RcMessageOut(MSG_ACCESS_DENIED);
        return 1;
    }

    //
    // Convert the SOURCE filename into a fully qualified
    // NT-style path name.
    //
    if (!RcFormFullPath(Arg,p,TRUE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    //
    // using the same buffer for the TARGET name
    //
    q = p + wcslen(p) + 1;

    //
    // get the TARGET file name
    //
    Arg = TokenizedLine->Tokens->Next->Next->String;

    //
    // Verify that the TARGET filename does not contain
    // any path seperator characters or drive specifier
    // characters.
    //
    if( wcschr(Arg,L'\\') ) {
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }
    if( RcIsAlpha(Arg[0]) && (Arg[1] == L':') ) {
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }

    //
    // Convert the DESTINATION filename into a DOS path so we
    // can verify if the path is allowed by our security restrictions.
    //
    if (!RcFormFullPath(Arg,q,FALSE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    if (!RcIsPathNameAllowed(q,TRUE,FALSE)) {
        RcMessageOut(MSG_ACCESS_DENIED);
        return 1;
    }

    //
    // Convert the SOURCE filename into a fully qualified
    // NT-style path name.
    //
    if (!RcFormFullPath(Arg,q,TRUE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }
    
    //
    // OK, looks like a plain filename specification.
    // Glom it onto the end of the relevent part of the
    // source specification so we have 2 fully qualified names.
    //
    // wcscpy(q,p);
    // wcscpy(wcsrchr(q,L'\\')+1,Arg);
    
    //
    // Call worker routine to actually do the rename.
    //
    Status = SpRenameFile(p,q,TRUE);

    if( !NT_SUCCESS(Status) ) {
        RcNtError(Status,MSG_RENAME_ERROR, Arg);
    }

    return 1;
}


ULONG
RcCmdMkdir(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;
    OBJECT_ATTRIBUTES Obja;
    ULONG rc;


    if (RcCmdParseHelp( TokenizedLine, MSG_MAKEDIR_HELP )) {
        return 1;
    }

    //
    // There should be a token for MKDIR and one for the target.
    //
    ASSERT(TokenizedLine->TokenCount == 2);

    //
    // Convert the given arg into a fully qualified NT path specification.
    //
    if (!RcFormFullPath(TokenizedLine->Tokens->Next->String,_CmdConsBlock->TemporaryBuffer,FALSE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    if (!RcIsPathNameAllowed(_CmdConsBlock->TemporaryBuffer,TRUE,TRUE)) {
        RcMessageOut(MSG_ACCESS_DENIED);
        return 1;
    }

    //
    // Convert the given arg into a fully qualified NT path specification.
    //
    if (!RcFormFullPath(TokenizedLine->Tokens->Next->String,_CmdConsBlock->TemporaryBuffer,TRUE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    //
    // Create the directory.
    //
    INIT_OBJA(&Obja,&UnicodeString,_CmdConsBlock->TemporaryBuffer);

    Status = ZwCreateFile(
                         &Handle,
                         FILE_LIST_DIRECTORY | SYNCHRONIZE,
                         &Obja,
                         &IoStatusBlock,
                         NULL,
                         FILE_ATTRIBUTE_NORMAL,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_CREATE,
                         FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                         NULL,
                         0
                         );

    if( NT_SUCCESS(Status) ) {
        ZwClose(Handle);
    } else {
        RcNtError(Status,MSG_CREATE_DIR_FAILED,TokenizedLine->Tokens->Next->String);
    }

    return 1;
}


ULONG
RcCmdRmdir(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    NTSTATUS Status;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    FILE_DISPOSITION_INFORMATION Disposition;
    ULONG rc;


    if (RcCmdParseHelp( TokenizedLine, MSG_REMOVEDIR_HELP )) {
        return 1;
    }

    //
    // There should be a token for RMDIR and one for the target.
    //
    ASSERT(TokenizedLine->TokenCount == 2);

    //
    // Convert the given arg into a fully qualified NT path specification.
    //
    if (!RcFormFullPath(TokenizedLine->Tokens->Next->String,_CmdConsBlock->TemporaryBuffer,FALSE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    if (!RcIsPathNameAllowed(_CmdConsBlock->TemporaryBuffer,TRUE,TRUE)) {
        RcMessageOut(MSG_ACCESS_DENIED);
        return 1;
    }

    //
    // Convert the given arg into a fully qualified NT path specification.
    //
    if (!RcFormFullPath(TokenizedLine->Tokens->Next->String,_CmdConsBlock->TemporaryBuffer,TRUE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    INIT_OBJA(&Obja,&UnicodeString,_CmdConsBlock->TemporaryBuffer);

    Status = ZwOpenFile(
                       &Handle,
                       DELETE | SYNCHRONIZE,
                       &Obja,
                       &IoStatusBlock,
                       FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                       FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                       );

    if( !NT_SUCCESS(Status) ) {
        RcNtError(Status,MSG_RMDIR_ERROR);
        return 1;
    }

    Disposition.DeleteFile = TRUE;

    Status = ZwSetInformationFile(
                                 Handle,
                                 &IoStatusBlock,
                                 &Disposition,
                                 sizeof(FILE_DISPOSITION_INFORMATION),
                                 FileDispositionInformation
                                 );

    ZwClose(Handle);

    if( !NT_SUCCESS(Status) ) {
        RcNtError(Status,MSG_RMDIR_ERROR);
    }

    return 1;
}


ULONG
RcCmdSetFlags(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    if (RcCmdParseHelp( TokenizedLine, MSG_SETCMD_HELP )) {
        return 1;
    }
    
    if (TokenizedLine->TokenCount == 1) {
        RcTextOut( L"\r\n" );
        RcMessageOut(MSG_SET_ALLOW_WILDCARDS,AllowWildCards?L"TRUE":L"FALSE");
        RcMessageOut(MSG_SET_ALLOW_ALLPATHS,AllowAllPaths?L"TRUE":L"FALSE");
        RcMessageOut(MSG_SET_ALLOW_REMOVABLE_MEDIA,AllowRemovableMedia?L"TRUE":L"FALSE");
        RcMessageOut(MSG_SET_NO_COPY_PROMPT,NoCopyPrompt?L"TRUE":L"FALSE");
        RcTextOut( L"\r\n" );
        return 1;
    }

    //
    // should have the priviledge to use the SET command
    //
    if (TokenizedLine->TokenCount != 4) {
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }

    if (RcGetSETCommandStatus() != TRUE) {    
        RcMessageOut(MSG_SETCMD_DISABLED);
        return 1;
    }

    if (_wcsicmp(TokenizedLine->Tokens->Next->String,L"allowallpaths")==0) {
        if (_wcsicmp(TokenizedLine->Tokens->Next->Next->Next->String,L"true")==0) {
            AllowAllPaths = TRUE;
        } else {
            AllowAllPaths = FALSE;
        }
        return 1;
    }

    if (_wcsicmp(TokenizedLine->Tokens->Next->String,L"allowwildcards")==0) {
        if (_wcsicmp(TokenizedLine->Tokens->Next->Next->Next->String,L"true")==0) {
            AllowWildCards = TRUE;
        } else {
            AllowWildCards = FALSE;
        }
        return 1;
    }

    if (_wcsicmp(TokenizedLine->Tokens->Next->String,L"allowremovablemedia")==0) {
        if (_wcsicmp(TokenizedLine->Tokens->Next->Next->Next->String,L"true")==0) {
            AllowRemovableMedia = TRUE;
        } else {
            AllowRemovableMedia = FALSE;
        }
        return 1;
    }

    if (_wcsicmp(TokenizedLine->Tokens->Next->String,L"nocopyprompt")==0) {
        if (_wcsicmp(TokenizedLine->Tokens->Next->Next->Next->String,L"true")==0) {
            NoCopyPrompt = TRUE;
        } else {
            NoCopyPrompt = FALSE;
        }
        return 1;
    }

    RcMessageOut(MSG_SYNTAX_ERROR);
    return 1;
}

ULONG
RcCmdAttrib(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    NTSTATUS    Status;
    PWCHAR      AttributeString;
    ULONG       OldAttributes;
    ULONG       NewAttributes;
    BOOLEAN     SetAttribute;
    BOOLEAN     bShowHelp = TRUE;
    BOOLEAN     bChangeCompression = FALSE;

    // "attrib -h <filename>" should clear the hidden attribute
    // and not show the help
    if (TokenizedLine->TokenCount > 2){
        PWCHAR  szSecondParam = TokenizedLine->Tokens->Next->String;

        bShowHelp = !wcscmp( szSecondParam, L"/?" ); 
    }
    
    if (bShowHelp && RcCmdParseHelp( TokenizedLine, MSG_ATTRIB_HELP )) {
        return 1;
    }

    if (TokenizedLine->TokenCount != 3) {
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }
    
    //
    // Fetch the spec for the file to be attribed and convert it
    // into a fully-qualified NT-style path.
    //
    if (!RcFormFullPath(TokenizedLine->Tokens->Next->Next->String,_CmdConsBlock->TemporaryBuffer,FALSE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    //
    // see if the user is authorized to change this file
    //
    if (!RcIsPathNameAllowed(_CmdConsBlock->TemporaryBuffer,TRUE,FALSE)) {
        RcMessageOut(MSG_ACCESS_DENIED);
        return 1;
    }
   
    if (!RcFormFullPath(TokenizedLine->Tokens->Next->Next->String,_CmdConsBlock->TemporaryBuffer,TRUE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    Status = RcGetFileAttributes( _CmdConsBlock->TemporaryBuffer, &OldAttributes );
    
    if( !NT_SUCCESS(Status) ) {
        RcNtError(Status,MSG_CANT_OPEN_FILE);
        return 1;
    }

    NewAttributes = OldAttributes;
    
    for(AttributeString = TokenizedLine->Tokens->Next->String; *AttributeString; AttributeString++){
        if(*AttributeString == L'+'){
            SetAttribute = TRUE;
            AttributeString++;
        } else if(*AttributeString == L'-'){
            SetAttribute = FALSE;
            AttributeString++;
        } else {
            // attribute change should start with "+" or "-"
            if (AttributeString == TokenizedLine->Tokens->Next->String) {
                RcMessageOut(MSG_SYNTAX_ERROR);
                return 1;
            }

            // use the old state for setting or resetting (for +rsh
        }
    
        switch(*AttributeString){
            case L'h':
            case L'H':
                if (SetAttribute)
                    NewAttributes |= FILE_ATTRIBUTE_HIDDEN;
                else
                    NewAttributes &= ~FILE_ATTRIBUTE_HIDDEN;
                    
                break;
                
            case L's':
            case L'S':
                if (SetAttribute)
                    NewAttributes |= FILE_ATTRIBUTE_SYSTEM;
                else
                    NewAttributes &= ~FILE_ATTRIBUTE_SYSTEM;
                    
                break;
                
            case L'r':
            case L'R':
                if (SetAttribute)
                    NewAttributes |= FILE_ATTRIBUTE_READONLY;
                else
                    NewAttributes &= ~FILE_ATTRIBUTE_READONLY;
                    
                break;
                
            case L'a':
            case L'A':
                if (SetAttribute)
                    NewAttributes |= FILE_ATTRIBUTE_ARCHIVE;
                else
                    NewAttributes &= ~FILE_ATTRIBUTE_ARCHIVE;
                    
                break;

            case L'c':
            case L'C':
                bChangeCompression = TRUE;

                if (SetAttribute)
                    NewAttributes |= FILE_ATTRIBUTE_COMPRESSED;
                else
                    NewAttributes &= ~FILE_ATTRIBUTE_COMPRESSED;
                    
                break;            
                
            default:
                RcMessageOut(MSG_SYNTAX_ERROR);
                return 1;       
        }

        /*
        if (SetAttribute) {
            FileAttributes |= Attribute;
        } else {
            FileAttributes &= ~Attribute;
        }
        */
    }

    Status = RcSetFileAttributes( _CmdConsBlock->TemporaryBuffer, NewAttributes );
    
    if( !NT_SUCCESS(Status) ) {
        RcNtError(Status,MSG_CANT_OPEN_FILE);
    } else {
        if (bChangeCompression) {
            BOOLEAN bCompress = (NewAttributes & FILE_ATTRIBUTE_COMPRESSED) ?
                                    TRUE : FALSE;
                                    
            Status = RcSetFileCompression(_CmdConsBlock->TemporaryBuffer, bCompress);

            if ( !NT_SUCCESS(Status) )
                RcNtError(Status, MSG_ATTRIB_CANNOT_CHANGE_COMPRESSION);
        }        
    }        

    return 1;
}

NTSTATUS
RcSetFileCompression(
    LPCWSTR szFileName,
    BOOLEAN bCompress
    )
{
    NTSTATUS                Status;
    OBJECT_ATTRIBUTES       Obja;
    HANDLE                  Handle;
    IO_STATUS_BLOCK         IoStatusBlock;
    FILE_BASIC_INFORMATION  BasicInfo;
    UNICODE_STRING          FileName;
    USHORT                  uCompressionType;
    
    
    INIT_OBJA(&Obja,&FileName,szFileName);
    
    //
    // Open the file inhibiting the reparse behavior.
    //

    Status = ZwOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if (NT_SUCCESS(Status)) {
        //
        // set & reset the compression bit also
        //
        uCompressionType = bCompress ? 
                            COMPRESSION_FORMAT_DEFAULT : COMPRESSION_FORMAT_NONE;

        Status = ZwFsControlFile(
                    Handle,                     // file handle
                    NULL,                       // event handle
                    NULL,                       // APC rountine pointer
                    NULL,                       // APC context
                    &IoStatusBlock,             // IO status block
                    FSCTL_SET_COMPRESSION,      // IOCTL code
                    &uCompressionType,          // input buffer
                    sizeof(uCompressionType),   // input buffer length
                    NULL,                       // output buffer pointer
                    0);                         // output buffer length

        DbgPrint( "ZwDeviceIoControlFile() status : %X\r\n", Status);

        ZwClose(Handle);
    }        

    return Status;
}

NTSTATUS
RcSetFileAttributes(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    )

/*++

Routine Description:

    The attributes of a file can be set using SetFileAttributes.

Arguments:

    lpFileName - Supplies the file name of the file whose attributes are to
        be set.

    dwFileAttributes - Specifies the file attributes to be set for the
        file.  Any combination of flags is acceptable except that all
        other flags override the normal file attribute,
        FILE_ATTRIBUTE_NORMAL.

        FileAttributes Flags:

        FILE_ATTRIBUTE_NORMAL - A normal file should be created.

        FILE_ATTRIBUTE_READONLY - A read-only file should be created.

        FILE_ATTRIBUTE_HIDDEN - A hidden file should be created.

        FILE_ATTRIBUTE_SYSTEM - A system file should be created.

        FILE_ATTRIBUTE_ARCHIVE - The file should be marked so that it
            will be archived.

Return Value:

    NTStatus of last NT call
--*/

{
    NTSTATUS                Status;
    OBJECT_ATTRIBUTES       Obja;
    HANDLE                  Handle;
    IO_STATUS_BLOCK         IoStatusBlock;
    FILE_BASIC_INFORMATION  BasicInfo;
    UNICODE_STRING          FileName;
    USHORT                  uCompressionType;
    
    
    INIT_OBJA(&Obja,&FileName,lpFileName);
    
    //
    // Open the file ihibiting the reparse behavior.
    //

    Status = ZwOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                );

    if ( !NT_SUCCESS(Status) ) {
        //
        // Back level file systems may not support reparse points.
        // We infer this is the case when the Status is STATUS_INVALID_PARAMETER.
        //

        if ( Status == STATUS_INVALID_PARAMETER ) {
            //
            // Open the file without inhibiting the reparse behavior.
            //
       
            Status = ZwOpenFile(
                        &Handle,
                        (ACCESS_MASK)FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                        );
       
            if ( !NT_SUCCESS(Status) ) {
                return Status;
            }

        }
        else {
            return Status;
        }
    }


    //
    // Set the basic attributes
    //
    ZeroMemory(&BasicInfo,sizeof(BasicInfo));
    BasicInfo.FileAttributes = (dwFileAttributes & FILE_ATTRIBUTE_VALID_FLAGS) | FILE_ATTRIBUTE_NORMAL;

    Status = ZwSetInformationFile(
                Handle,
                &IoStatusBlock,
                &BasicInfo,
                sizeof(BasicInfo),
                FileBasicInformation
                );

    ZwClose(Handle);

    return Status;
}

NTSTATUS
RcGetFileAttributes(
    LPCWSTR lpFileName,
    PULONG FileAttributes
    )

/*++

Routine Description:

Arguments:

    lpFileName - Supplies the file name of the file whose attributes are to
        be set.

Return Value:

    Not -1 - Returns the attributes of the specified file.  Valid
        returned attributes are:

        FILE_ATTRIBUTE_NORMAL - The file is a normal file.

        FILE_ATTRIBUTE_READONLY - The file is marked read-only.

        FILE_ATTRIBUTE_HIDDEN - The file is marked as hidden.

        FILE_ATTRIBUTE_SYSTEM - The file is marked as a system file.

        FILE_ATTRIBUTE_ARCHIVE - The file is marked for archive.

        FILE_ATTRIBUTE_DIRECTORY - The file is marked as a directory.

        FILE_ATTRIBUTE_REPARSE_POINT - The file is marked as a reparse point.

        FILE_ATTRIBUTE_VOLUME_LABEL - The file is marked as a volume lable.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;
    FILE_BASIC_INFORMATION BasicInfo;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;

    INIT_OBJA(&Obja,&FileName,lpFileName);
    
    //
    // Open the file inhibiting the reparse behavior.
    //

    Status = ZwOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                );

    if ( !NT_SUCCESS(Status) ) {
        //
        // Back level file systems may not support reparse points.
        // We infer this is the case when the Status is STATUS_INVALID_PARAMETER.
        //

        if ( Status == STATUS_INVALID_PARAMETER ) {
            //
            // Open the file without inhibiting the reparse behavior.
            //
       
            Status = ZwOpenFile(
                        &Handle,
                        (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                        );
       
            if ( !NT_SUCCESS(Status) ) {
                return Status;
            }
        }
        else {
            return Status;
        }
    }


    //
    // Query the file
    //

    Status = ZwQueryInformationFile(
                 Handle,
                 &IoStatusBlock,
                 (PVOID) &BasicInfo,
                 sizeof(BasicInfo),
                 FileBasicInformation
                 );
    
    if (NT_SUCCESS(Status)) {
        *FileAttributes = BasicInfo.FileAttributes;
    }
    
    ZwClose( Handle );

    return Status;

}


ULONG
RcCmdNet(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    WCHAR *Share;
    WCHAR *User;
    WCHAR *pwch;
    WCHAR PasswordBuffer[64];
    WCHAR Drive[3];
    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;



    //
    // check for help
    //
    if (RcCmdParseHelp( TokenizedLine, MSG_NET_USE_HELP )) {
        return 1;
    }

    //
    // There should be a token for NET and USE and one each for the server\share, and possible
    // tokens for the /u:domainname\username and password.
    //
    if ((TokenizedLine->TokenCount < 3) || (TokenizedLine->TokenCount > 5)) {
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }

    //
    // The only NET command supported is USE, so verify that the second token is that.
    //
    if (_wcsicmp(TokenizedLine->Tokens->Next->String, L"USE")){
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }

    //
    // Get the first parameter to NET USE
    //
    Share = TokenizedLine->Tokens->Next->Next->String;

    if (*Share == L'\\') { // attempt at making a connection

        //
        // Verify the share name parameter
        //
        if (*(Share+1) != L'\\') {
            RcMessageOut(MSG_SYNTAX_ERROR);
            return 1;
        }


        //
        // get the user logon context
        //
        if (TokenizedLine->TokenCount > 3) {
            
            //
            // The command has the context in it, so get it.
            //
            User = TokenizedLine->Tokens->Next->Next->Next->String;

            if (*User != L'/') {
                RcMessageOut(MSG_SYNTAX_ERROR);
                return 1;
            } 

            User++;
            pwch = User;
            while ((*pwch != UNICODE_NULL) && (*pwch != L':')) {
                pwch++;
            }

            if (*pwch != L':') {
                RcMessageOut(MSG_SYNTAX_ERROR);
                return 1;
            }

            *pwch = UNICODE_NULL;
            pwch++;

            if (_wcsicmp(User, L"USER") && _wcsicmp(User, L"U")) {
                RcMessageOut(MSG_SYNTAX_ERROR);
                return 1;
            }

            User = pwch;

            //
            // Get the password
            //
            if (TokenizedLine->TokenCount == 4) {
                
                RcMessageOut( MSG_NET_USE_PROMPT_PASSWORD );
                RtlZeroMemory( PasswordBuffer, sizeof(PasswordBuffer) );
                RcPasswordIn( PasswordBuffer, 60 );

            } else {

                if (wcslen(TokenizedLine->Tokens->Next->Next->Next->Next->String) > 60) {
                    RcMessageOut(MSG_SYNTAX_ERROR);
                    return 1;
                }

                wcscpy(PasswordBuffer, TokenizedLine->Tokens->Next->Next->Next->Next->String);

                if ((PasswordBuffer[0] == L'*') && (PasswordBuffer[1] == UNICODE_NULL)) {

                    RcMessageOut( MSG_NET_USE_PROMPT_PASSWORD );
                    RtlZeroMemory( PasswordBuffer, sizeof(PasswordBuffer) );
                    RcPasswordIn( PasswordBuffer, 60 );

                } else if (PasswordBuffer[0] == L'"') {

                    pwch = &(PasswordBuffer[1]);

                    while (*pwch != UNICODE_NULL) {
                        pwch++;
                    }

                    pwch--;

                    if ((*pwch == L'"') && (pwch != &(PasswordBuffer[1]))) {
                        *pwch = UNICODE_NULL;
                    }

                    RtlMoveMemory(PasswordBuffer, &(PasswordBuffer[1]), (PtrToUlong(pwch) - PtrToUlong(PasswordBuffer)) + sizeof(WCHAR));
                
                }

            }

        } else {

            //
            // If we allow holding a current context, then we would use that here, but we currently
            // don't, so spew a syntax error message.
            //
            RcMessageOut(MSG_SYNTAX_ERROR);
            return 1;

        }

        //
        // Call worker routine to make the connection
        //
        Status = RcDoNetUse(Share, User, PasswordBuffer, Drive);
                     
        if( !NT_SUCCESS(Status) ) {
            RcNtError(Status, MSG_NET_USE_ERROR);
        } else {
            RcMessageOut(MSG_NET_USE_DRIVE_LETTER, Share, Drive);
        }

    } else { // attempt to disconnect

        //
        // Verify drive letter parameter
        //
        if ((*(Share+1) != L':') || (*(Share + 2) != UNICODE_NULL)) {
            RcMessageOut(MSG_SYNTAX_ERROR);
            return 1;
        }

        //
        // Verify /d parameter
        //
        User = TokenizedLine->Tokens->Next->Next->Next->String;
        
        if ((*User != L'/') || ((*(User + 1) != L'd') && (*(User + 1) != L'D'))) {
            RcMessageOut(MSG_SYNTAX_ERROR);
            return 1;
        }

        //
        // Call worker routine to actually do the disconnect.
        //
        Status = RcNetUnuse(Share);

        if( !NT_SUCCESS(Status) ) {
            RcNtError(Status, MSG_NET_USE_ERROR);
        }
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\cmdcons\batch.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    batch.c

Abstract:

    This module implements batch command processing.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop

ULONG InBatchMode;
HANDLE OutputFileHandle;
LARGE_INTEGER OutputFileOffset;
BOOLEAN RedirectToNULL;


#ifdef DBG

VOID
RcDumpTokenizedLine(
    PTOKENIZED_LINE Line 
    )
{
    if (Line) {
        PLINE_TOKEN  Token = Line->Tokens;
        ULONG Index        ;
        
        for(Index=0; ((Index < Line->TokenCount) && Token); Index++) {
            KdPrint(("%ws, ", Token->String));
            Token = Token->Next;
        }
        
        KdPrint(("\n"));
    } else {
        KdPrint(("Line is null!!!\n"));
    }
}

#endif
    

BOOLEAN
pRcExecuteBatchFile(
    IN PWSTR BatchFileName,
    IN PWSTR OutputFileName,
    IN BOOLEAN Quiet
    )
{
    NTSTATUS Status = 0;
    LPCWSTR Arg;
    HANDLE FileHandle = NULL;
    HANDLE SectionHandle;
    PVOID ViewBase;
    ULONG FileSize;
    ULONG rc;
    WCHAR *s;
    WCHAR *p;
    ULONG sz;
    WCHAR *pText;
    ULONG rVal;
    BOOLEAN b = FALSE;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES Obja;
    PTOKENIZED_LINE TokenizedLine;


    if (InBatchMode) {
        RcMessageOut(MSG_BATCH_BATCH);

        return FALSE;
    }        

    if (!RcFormFullPath(BatchFileName,_CmdConsBlock->TemporaryBuffer,TRUE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return FALSE;
    }
    
    Status = SpOpenAndMapFile(
        _CmdConsBlock->TemporaryBuffer,
        &FileHandle,
        &SectionHandle,
        &ViewBase,
        &FileSize,
        FALSE
        );
        
    if( !NT_SUCCESS(Status) ) {
        if (!Quiet) {
            RcNtError(Status,MSG_CANT_OPEN_FILE);
        }
        return FALSE;
    }

    pText = SpMemAlloc((FileSize+16)*sizeof(WCHAR));
    RtlZeroMemory(pText,(FileSize+16)*sizeof(WCHAR));

    Status = RtlMultiByteToUnicodeN(
        pText,
        FileSize * sizeof(WCHAR),
        &FileSize,
        ViewBase,
        FileSize
        );

    s = pText;
    sz = FileSize / sizeof(WCHAR);

    SpUnmapFile(SectionHandle,ViewBase);
    ZwClose(FileHandle);

    if (OutputFileName != NULL) {
        if (OutputFileHandle == NULL) {            
            if (!RcFormFullPath(OutputFileName,_CmdConsBlock->TemporaryBuffer, TRUE)) {
                RcMessageOut(MSG_INVALID_PATH);

                if (pText)
                	SpMemFree(pText);
                	
                return FALSE;
            }
            
            INIT_OBJA(&Obja,&UnicodeString,_CmdConsBlock->TemporaryBuffer);

            Status = ZwCreateFile(
                &OutputFileHandle,
                FILE_GENERIC_WRITE | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
				0,
                FILE_OVERWRITE_IF,
                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY,
                NULL,
                0
                );

            if (!NT_SUCCESS(Status)) {
                RcMessageOut(Status);
                OutputFileHandle = NULL;
            }

            OutputFileOffset.QuadPart = 0;
        } 
    } else {
        OutputFileHandle = NULL;
        OutputFileOffset.QuadPart = 0;
    }

    InBatchMode += 1;

	//
	// get each line and invoke dispatch command
	// on that line after tokenizing the arguments
	//
    while (sz) {  
		p = s;
		
        while (sz && (*p != L'\r')) {
            p += 1;
            sz--;
        }

        if (sz && (*p == L'\r')) {
            *p = 0;
            TokenizedLine = RcTokenizeLine(s);

            if (TokenizedLine->TokenCount) {
                rVal = RcDispatchCommand( TokenizedLine );

                if (rVal == 0 || rVal == 2) {
                    b = FALSE;
                } else {
                    b = TRUE;
                }

                RcTextOut(L"\r\n");
            } else {
                b = TRUE;
            }
            
            RcFreeTokenizedLine(&TokenizedLine);

            if (b == FALSE) {
                RcTerminateCurrentDirectories();
                RcConsoleTerminate();
            }

	        s = p + 1;
	        sz--;
	        
	        if (sz && (*s == L'\n')) {
	            s += 1;
	            sz--;
	        }
		}	    
    }
    

    SpMemFree(pText);

    InBatchMode -= 1;

    if (OutputFileHandle) {
        ZwClose(OutputFileHandle);
        OutputFileHandle = NULL;
    }

    return TRUE;
}


ULONG
RcCmdBatch(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    if (RcCmdParseHelp( TokenizedLine, MSG_BATCH_HELP )) {
        return 1;
    }

    if (TokenizedLine->TokenCount < 2) {
        RcMessageOut( MSG_SYNTAX_ERROR );
        return 1;
    }

    pRcExecuteBatchFile(
        TokenizedLine->Tokens->Next->String,
        (TokenizedLine->TokenCount == 3) ? TokenizedLine->Tokens->Next->Next->String : NULL,
        FALSE
        );

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\cmdcons\copy.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    copy.c

Abstract:

    This module implements the file copy command.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop

BOOLEAN NoCopyPrompt;
BOOLEAN AllowRemovableMedia;



NTSTATUS
pRcGetDeviceInfo(
    IN PWSTR FileName,      // must be an nt name
    IN PFILE_FS_DEVICE_INFORMATION DeviceInfo
    )
{
    BOOLEAN Removable = FALSE;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    HANDLE Handle;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    PWSTR DeviceName;
    PWSTR s;


    //
    // get the device name from the file name
    //

    DeviceName = SpDupStringW( FileName );
    if (DeviceName == NULL) {
        return STATUS_OBJECT_PATH_INVALID;
    }

    s = wcschr(DeviceName+1,L'\\');
    if (!s) {
        return STATUS_OBJECT_PATH_INVALID;
    }
    s = wcschr(s+1,L'\\');
    if (s) {
        *s = 0;
    }

    INIT_OBJA(&Obja,&UnicodeString,DeviceName);

    Status = ZwCreateFile(
        &Handle,
        FILE_GENERIC_READ | SYNCHRONIZE,
        &Obja,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN,
        FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0
        );
        
    SpMemFree(DeviceName);
    
    if(NT_SUCCESS(Status)) {
        Status = ZwQueryVolumeInformationFile(
            Handle,
            &IoStatusBlock,
            DeviceInfo,
            sizeof(FILE_FS_DEVICE_INFORMATION),
            FileFsDeviceInformation
            );
        ZwClose(Handle);
    }

    return Status;
}


NTSTATUS
RcIsFileOnRemovableMedia(
    IN PWSTR FileName      // must be an nt name
    )
{
    NTSTATUS Status;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;


    Status = pRcGetDeviceInfo( FileName, &DeviceInfo );
    if(NT_SUCCESS(Status)) {
        if ((DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA) == 0) {
            Status = STATUS_NO_MEDIA;
        }
    }
    return Status;
}


NTSTATUS
RcIsFileOnCDROM(
    IN PWSTR FileName      // must be an nt name
    )
{
    NTSTATUS Status;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;


    Status = pRcGetDeviceInfo( FileName, &DeviceInfo );
    if(NT_SUCCESS(Status)) {
        if (DeviceInfo.DeviceType != FILE_DEVICE_CD_ROM) {
            Status = STATUS_NO_MEDIA;
        }
    }
    return Status;
}


NTSTATUS
RcIsFileOnFloppy(
    IN PWSTR FileName      // must be an nt name
    )
{
    NTSTATUS Status;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;


    Status = pRcGetDeviceInfo( FileName, &DeviceInfo );
    if(NT_SUCCESS(Status)) {
        if ((DeviceInfo.Characteristics & FILE_FLOPPY_DISKETTE) == 0) {
            Status = STATUS_NO_MEDIA;
        }
    }
    return Status;
}


BOOLEAN
RcGetNTFileName(
    IN LPCWSTR DosPath,
    IN LPCWSTR NTPath
    )
{
    BOOLEAN bResult = FALSE;
    extern LPWSTR _NtDrivePrefixes[26];
    WCHAR TempBuf[MAX_PATH*2];
    ULONG len;
    ULONG len2;
    LPWSTR Prefix;
    PWSTR s = NULL;

    Prefix = _NtDrivePrefixes[RcToUpper(DosPath[0])-L'A'];

    if (!Prefix) {
        return bResult;
    }

    GetDriveLetterLinkTarget((PWSTR)Prefix, &s);

    if (s) {
        len = wcslen(s);
        len2 = wcslen(DosPath) - 2;

        if (((len + len2) * sizeof(WCHAR)) < sizeof(TempBuf)){
            RtlZeroMemory(TempBuf,sizeof(TempBuf));
            RtlCopyMemory(TempBuf+len,DosPath+2,len2*sizeof(WCHAR));
            RtlCopyMemory(TempBuf,s,len*sizeof(WCHAR));

            TempBuf[len+len2] = 0;

            wcscpy((PWSTR)NTPath,TempBuf);
            bResult = TRUE;
        }
    }        

    return bResult;
}


ULONG
RcCmdCopy(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    LPWSTR SrcFile;
    LPWSTR DstFile;
    LPWSTR SrcDosPath = NULL;
    LPWSTR SrcNtPath = NULL;
    LPWSTR DstDosPath = NULL;
    LPWSTR DstNtPath = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    HANDLE Handle;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    LPWSTR YesNo;
    WCHAR Text[3];
    LPWSTR s;
    ULONG FileCount = 0;
    IO_STATUS_BLOCK  status_block;
    FILE_BASIC_INFORMATION fileInfo;
    WCHAR * pos;
    ULONG CopyFlags = COPY_NOVERSIONCHECK;


    ASSERT(TokenizedLine->TokenCount >= 1);

    if (RcCmdParseHelp( TokenizedLine, MSG_COPY_HELP )) {
        return 1;
    }

    //
    // create a good source & destination file name
    //
    if( TokenizedLine->TokenCount == 2 ) {
        SrcFile = TokenizedLine->Tokens->Next->String;
        DstFile = NULL;
    } else {
        SrcFile = TokenizedLine->Tokens->Next->String;
        DstFile = TokenizedLine->Tokens->Next->Next->String;
    }

    if (RcDoesPathHaveWildCards(SrcFile)) {
        RcMessageOut(MSG_DIR_WILDCARD_NOT_SUPPORTED);
        goto exit;
    }
    //
    // Canonicalize the name once to get a full DOS-style path
    // we can print out, and another time to get the NT-style path
    // we'll use to actually do the work.
    //
    if (!RcFormFullPath( SrcFile, _CmdConsBlock->TemporaryBuffer, FALSE )) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    if (!RcIsPathNameAllowed(_CmdConsBlock->TemporaryBuffer,TRUE,FALSE)) {
        RcMessageOut(MSG_ACCESS_DENIED);
        goto exit;
    }

    SrcDosPath = SpDupStringW( _CmdConsBlock->TemporaryBuffer );

    if (!RcFormFullPath( SrcFile, _CmdConsBlock->TemporaryBuffer, TRUE )) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }
    SrcNtPath = SpDupStringW( _CmdConsBlock->TemporaryBuffer );

    //
    // see if the source file exists
    //
    INIT_OBJA( &Obja, &UnicodeString, SrcNtPath );

    Status = ZwOpenFile(
                       &Handle,
                       FILE_READ_ATTRIBUTES,
                       &Obja,
                       &IoStatusBlock,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       0
                       );

    if( NT_SUCCESS(Status) ) {
        // check to see if the destination is a directory
        Status = ZwQueryInformationFile( Handle,
                                         &status_block,
                                         (PVOID)&fileInfo,
                                         sizeof( FILE_BASIC_INFORMATION ),
                                         FileBasicInformation );

        ZwClose( Handle );

        if( !NT_SUCCESS(Status) ) {
            // something went wrong
            RcNtError( Status, MSG_CANT_COPY_FILE );
            goto exit;
        }

        if( fileInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
            RcMessageOut(MSG_DIR_WILDCARD_NOT_SUPPORTED);
            goto exit;
        }
    } else {
        RcMessageOut(MSG_FILE_NOT_FOUND2);
        goto exit;
    }

    //
    // create a destination file name when the user did not
    // provide one.  we use the source base file name and
    // the current drive and directory.
    //
    if ((DstFile == NULL) ||
        (wcscmp(DstFile, L".") == 0)) {
        s = wcsrchr( SrcDosPath, L'\\' );
        if( s ) {
            RcGetCurrentDriveAndDir( _CmdConsBlock->TemporaryBuffer );
            SpConcatenatePaths( _CmdConsBlock->TemporaryBuffer, s );
            DstFile = SpDupStringW( _CmdConsBlock->TemporaryBuffer );
        } else {
            RcMessageOut(MSG_INVALID_PATH);
            goto exit;
        }
    }

    //
    // create the destination paths
    //
    if (!RcFormFullPath( DstFile, _CmdConsBlock->TemporaryBuffer, FALSE )) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    if (!RcIsPathNameAllowed(_CmdConsBlock->TemporaryBuffer,FALSE,FALSE)) {
        RcMessageOut(MSG_ACCESS_DENIED);
        goto exit;
    }

    DstDosPath = SpDupStringW( _CmdConsBlock->TemporaryBuffer );

    if (!RcFormFullPath( DstFile, _CmdConsBlock->TemporaryBuffer, TRUE )) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }
    DstNtPath = SpDupStringW( _CmdConsBlock->TemporaryBuffer );

    //
    // check for removable media
    //

    if (AllowRemovableMedia == FALSE && RcIsFileOnRemovableMedia(DstNtPath) == STATUS_SUCCESS) {
        RcMessageOut(MSG_ACCESS_DENIED);
        goto exit;
    }

    //
    // see if the destination file already exists
    //
    INIT_OBJA( &Obja, &UnicodeString, DstNtPath );

    Status = ZwOpenFile(
                       &Handle,
                       FILE_READ_ATTRIBUTES,
                       &Obja,
                       &IoStatusBlock,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       0
                       );

    if( NT_SUCCESS(Status) ) {
        // the file exists!

        // check to see if the destination is a directory
        Status = ZwQueryInformationFile( Handle,
                                         &status_block,
                                         (PVOID)&fileInfo,
                                         sizeof( FILE_BASIC_INFORMATION ),
                                         FileBasicInformation );

        ZwClose( Handle );

        if( !NT_SUCCESS(Status) ) {
            // something went wrong
            RcNtError( Status, MSG_CANT_COPY_FILE );
            goto exit;
        }


        if( fileInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
            // yep, it's a directory

            // take the fully qualified source file path
            // and get the file name from it by finding the
            // last occurance of the \\ character
            pos = wcsrchr( SrcNtPath, L'\\' );

            SpMemFree( (PVOID)DstNtPath );

            // append the file name to the directory so that the copy
            // will work properly.

            if( pos != NULL ) {
                wcscat( _CmdConsBlock->TemporaryBuffer, pos );
            } else {
                wcscat( _CmdConsBlock->TemporaryBuffer, SrcNtPath );
            }

            DstNtPath = SpDupStringW( _CmdConsBlock->TemporaryBuffer );

            // now check again for the file's existence
            INIT_OBJA( &Obja, &UnicodeString, DstNtPath );

            Status = ZwOpenFile(
                               &Handle,
                               FILE_READ_ATTRIBUTES,
                               &Obja,
                               &IoStatusBlock,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               0
                               );

            if( NT_SUCCESS(Status) ) {
                ZwClose( Handle );
                //
                // Fetch yes/no text
                //
                if (InBatchMode == FALSE && NoCopyPrompt == FALSE) {
                    YesNo = SpRetreiveMessageText( ImageBase, MSG_YESNOALL, NULL, 0 );
                    if( YesNo ) {
                        s = wcsrchr( DstNtPath, L'\\' );
                        RcMessageOut( MSG_COPY_OVERWRITE, s ? s+1 : DstNtPath );
                        if( RcLineIn( Text, 2 ) ) {
                            if( (Text[0] == YesNo[0]) || (Text[0] == YesNo[1]) ) {
                                goto exit;
                            }
                        } else {
                            goto exit;
                        }
                        SpMemFree( YesNo );
                    }
                }
            }
        } else {
            //
            // If destination file was not compressed, copy it uncompressed.
            //
            
            if(!(fileInfo.FileAttributes & FILE_ATTRIBUTE_COMPRESSED)) {
                CopyFlags |= COPY_FORCENOCOMP;
            }
            
            // nope the dest wasn't a dir, ask if we should overwrite

            //
            // Fetch yes/no text
            //
            if (InBatchMode == FALSE && NoCopyPrompt == FALSE) {
                YesNo = SpRetreiveMessageText( ImageBase, MSG_YESNOALL, NULL, 0 );
                if( YesNo ) {
                    s = wcsrchr( DstNtPath, L'\\' );
                    RcMessageOut( MSG_COPY_OVERWRITE, s ? s+1 : DstNtPath );
                    if( RcLineIn( Text, 2 ) ) {
                        if( (Text[0] == YesNo[0]) || (Text[0] == YesNo[1]) ) {
                            goto exit;
                        }
                    } else {
                        goto exit;
                    }
                    SpMemFree( YesNo );
                }
            }
        }
    }

    Status = SpCopyFileUsingNames( SrcNtPath, DstNtPath, 0, CopyFlags );
    if( NT_SUCCESS(Status) ) {
        FileCount += 1;
    } else {
        RcNtError( Status, MSG_CANT_COPY_FILE );
    }

    if( FileCount ) {
        RcMessageOut( MSG_COPY_COUNT, FileCount );
    }

exit:
    if( DstFile && TokenizedLine->TokenCount == 2 ) {
        SpMemFree( DstFile );
    }
    if( SrcDosPath ) {
        SpMemFree( SrcDosPath );
    }
    if( SrcNtPath ) {
        SpMemFree( SrcNtPath );
    }
    if( DstDosPath ) {
        SpMemFree( DstDosPath );
    }
    if( DstNtPath ) {
        SpMemFree( DstNtPath );
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\cmdcons\curdir.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    curdir.c

Abstract:

    This module implements the directory commands.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop


//
// Each entry in _CurDirs always starts and ends with a \.
//

LPWSTR _CurDirs[26];
WCHAR _CurDrive;
LPWSTR _NtDrivePrefixes[26];
BOOLEAN AllowAllPaths;


VOID
RcAddDrive(
    WCHAR DriveLetter
    )
{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    WCHAR name[20];
    HANDLE Handle;
    NTSTATUS Status;

    ASSERT(_NtDrivePrefixes[(int)(DriveLetter - L'A')] == NULL);

    swprintf(name,L"\\DosDevices\\%c:", DriveLetter);

    INIT_OBJA(&Obja, &UnicodeString, name);

    Status = ZwOpenSymbolicLinkObject(&Handle, READ_CONTROL | SYMBOLIC_LINK_QUERY, &Obja);

    if (NT_SUCCESS(Status)) {
         ZwClose(Handle);
         _NtDrivePrefixes[(int)(DriveLetter - L'A')] = SpDupStringW(name);
    }
        
}



VOID
RcRemoveDrive(
    WCHAR DriveLetter
    )
{

    ASSERT(_NtDrivePrefixes[(int)(DriveLetter - L'A')] != NULL);
    
    SpMemFree(_NtDrivePrefixes[(int)(DriveLetter - L'A')]);
    _NtDrivePrefixes[(int)(DriveLetter - L'A')] = NULL;
}



VOID
RcInitializeCurrentDirectories(
    VOID
    )
{
    unsigned i;

    RtlZeroMemory( _CurDirs, sizeof(_CurDirs) );
    RtlZeroMemory( _NtDrivePrefixes, sizeof(_NtDrivePrefixes) );

    //
    // Initially, the current directory on all drives
    // is the root.
    //
    for( i=0; i<26; i++ ) {
        _CurDirs[i] = SpDupStringW(L"\\");
    }

    //
    // Now go set up the NT drive prefixes for each drive in the system.
    // For each drive letter, we see whether it exists in the \DosDevices
    // directory as a symbolic link.
    //
    for( i=0; i<26; i++ ) {    
        RcAddDrive((WCHAR)(i+L'A'));
    }

    //
    // NOTE: need to determine this by tracking the lowest
    // valid drive letter from the loop above, taking into account
    // floppy drives.
    //
    //
    _CurDrive = L'C';

    // fixed by using the drive letter for the selected install of NT
    // this is done in  in logon.c .



    return;
}


VOID
RcTerminateCurrentDirectories(
    VOID
    )
{
    unsigned i;

    for( i=0; i<26; i++ ) {
        if( _CurDirs[i] ) {
            SpMemFree(_CurDirs[i]);
            _CurDirs[i] = NULL;
        }
        if( _NtDrivePrefixes[i] ) {
            SpMemFree(_NtDrivePrefixes[i]);
            _NtDrivePrefixes[i] = NULL;
        }
    }
}


BOOLEAN
RcFormFullPath(
    IN  LPCWSTR PartialPath,
    OUT LPWSTR  FullPath,
    IN  BOOLEAN NtPath
    )

/*++

Routine Description:

    This routine is similar to the Win32 GetFullPathName() API.
    It takes an arbitrary pathspec and converts it to a full one,
    by merging in the current drive and directory if necessary.
    The output is a fully-qualified NT pathname equivalent to
    the partial spec given.

    Processing includes all your favorite Win32isms, including
    collapsing adjacent dots and slashes, stripping trailing spaces,
    handling . and .., etc.

Arguments:

    PartialPath - supplies a (dos-style) path spec of arbitrary qualification.

    FullPath - receives the equivalent fully-qualified NT path. The caller
        must ensure that this buffer is large enough.

    NtPath - if TRUE, we want a fully canonicalized NT path. Otherwise we want
        a DOS path.

Return Value:

    FALSE if failure, indicating an invalid drive spec or syntactically
    invalid path. TRUE otherwise.

--*/

{
    unsigned len;
    unsigned len2;
    LPCWSTR Prefix;
    PDISK_REGION Region;
    WCHAR Buffer[MAX_PATH*2];

    //
    // The first thing we do is to form the fully qualified path
    // by merging in the current drive and directory, if necessary.
    //
    // Check for leading drive in the form X:.
    //
    if((wcslen(PartialPath) >= 2) && (PartialPath[1] == L':') && RcIsAlpha(PartialPath[0])) {
        //
        // Got leading drive, transfer it into the target.
        //
        FullPath[0] = PartialPath[0];
        PartialPath += 2;
    } else {
        //
        // No leading drive, use current drive.
        //
        FullPath[0] = _CurDrive;
    }

    //
    // Make sure we've got a drive we think is valid.
    //
    Prefix = _NtDrivePrefixes[RcToUpper(FullPath[0])-L'A'];
    if(!Prefix) {
        return(FALSE);
    }

    FullPath[1] = L':';
    FullPath[2] = 0;

    //
    // Now deal with the path part. If the next character in the input
    // is \ then we have a rooted path, otherwise we need to merge in
    // the current directory for the drive.
    //
    if(PartialPath[0] != L'\\') {
        wcscat(FullPath,_CurDirs[RcToUpper(FullPath[0])-L'A']);
    }

    wcscat(FullPath,PartialPath);

    //
    // Disallow ending with \ except for the root.
    //
    len = wcslen(FullPath);

    if((len > 3) && (FullPath[len-1] == L'\\')) {
        FullPath[len-1] = 0;
    }

    //
    // Now that we've done this, we need to call RtlGetFullPathName_U
    // to get full win32 naming semantics, for example, stripping
    // trailing spaces, coalescing adjacent dots, processing . and .., etc.
    // We get at that API via setupdd.sys.
    //
    if(!NT_SUCCESS(SpGetFullPathName(FullPath))) {
        return(FALSE);
    }

    len = wcslen(FullPath) * sizeof(WCHAR);
    
    //
    // check if the path is too long to be 
    // handled by our routines [MAX_PATH*2] limit
    //
    // Note : RcGetNTFileName is called irrespective of whether caller
    // requested it or not to do proper error handling at the caller.
    //
    if ((len < sizeof(Buffer)) && RcGetNTFileName(FullPath, Buffer)){       
        if (NtPath)
            wcscpy(FullPath, Buffer);
    }
    else
        return FALSE;

    return TRUE;
}


VOID
RcGetCurrentDriveAndDir(
    OUT LPWSTR Output
    )
{
    ULONG len;

    Output[0] = _CurDrive;
    Output[1] = L':';
    wcscpy(Output+2,_CurDirs[_CurDrive-L'A']);

    //
    // Strip off trailing \ except in root case.
    //
    len = wcslen(Output);
    if( (len > 3) && (Output[len-1] == L'\\') ) {
        Output[len-1] = 0;
    }
}


WCHAR
RcGetCurrentDriveLetter(
    VOID
    )
{
    return(_CurDrive);
}


BOOLEAN
RcIsDriveApparentlyValid(
    IN WCHAR DriveLetter
    )
{
    return((BOOLEAN)(_NtDrivePrefixes[RcToUpper(DriveLetter)-L'A'] != NULL));
}


ULONG
RcCmdSwitchDrives(
    IN WCHAR DriveLetter
    )
{
    //
    // If there's no NT equivalent for this drive, then we can't
    // switch to it.
    //
    if( !RcIsDriveApparentlyValid(DriveLetter) ) {
        RcMessageOut(MSG_INVALID_DRIVE);
        return 1;
    }

    //
    // NOTE should we attempt to open the root of the drive,
    // so we can mimic cmd.exe's behavior of refusing to set
    // the current drive when say there's no floppy in the drive?
    // There's really no great reason to do this except that it might
    // be a little less confusing for the user.
    //
    // No.
    //

    _CurDrive = RcToUpper(DriveLetter);

    return 1;
}


ULONG
RcCmdChdir(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    unsigned u;
    WCHAR *p,*Arg;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;


    if (RcCmdParseHelp( TokenizedLine, MSG_CHDIR_HELP )) {
        return 1;
    }

    if (TokenizedLine->TokenCount == 1) {
        RcGetCurrentDriveAndDir(_CmdConsBlock->TemporaryBuffer);        
        RcRawTextOut(_CmdConsBlock->TemporaryBuffer,-1);
        return 1;
    }

    p = _CmdConsBlock->TemporaryBuffer;

    //
    // Get the argument. Special case x:, to print out the
    // current directory on that drive.
    //
    Arg = TokenizedLine->Tokens->Next->String;
    if(RcIsAlpha(Arg[0]) && (Arg[1] == L':') && (Arg[2] == 0)) {

        Arg[0] = RcToUpper(Arg[0]);
        u = Arg[0] - L'A';

        if(_NtDrivePrefixes[u] && _CurDirs[u]) {
            RcTextOut(Arg);

            //
            // Strip off the terminating \ except in root case.
            //
            wcscpy(p,_CurDirs[u]);
            u = wcslen(p);
            if((u > 1) && (p[u-1] == L'\\')) {
                p[u-1] = 0;
            }
            RcTextOut(p);
            RcTextOut(L"\r\n");

        } else {
            RcMessageOut(MSG_INVALID_DRIVE);
        }

        return 1;
    }

    //
    // Got a new directory spec. Canonicalize it to a fully qualified
    // DOS-style path. Check the drive to make sure it's legal.
    //
    if(!RcFormFullPath(Arg,p,FALSE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    if(!_NtDrivePrefixes[RcToUpper(p[0])-L'A']) {
        RcMessageOut(MSG_INVALID_DRIVE);
        return 1;
    }

    //
    // Check the directory to make sure it exists.
    //
    if(!RcFormFullPath(Arg,p,TRUE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    INIT_OBJA(&Obja,&UnicodeString,p);

    Status = ZwOpenFile(
                &Handle,
                FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE
                );

    if(!NT_SUCCESS(Status)) {
        RcNtError(Status,MSG_INVALID_PATH);
        return 1;
    }

    ZwClose(Handle);

    //
    // OK, it's a valid directory on a valid drive.
    // Form a path that starts and ends with \.
    //
    if(!RcFormFullPath(Arg,p,FALSE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }

    if (!RcIsPathNameAllowed(p,TRUE,FALSE)) {
        RcMessageOut(MSG_ACCESS_DENIED);
        return 1;
    }

    p += 2;  // skip x:
    u = wcslen(p);

    if(!u || (p[u-1] != L'\\')) {
        p[u] = L'\\';
        p[u+1] = 0;
    }

    u = RcToUpper(p[-2]) - L'A';
    if(_CurDirs[u]) {
        SpMemFree(_CurDirs[u]);
    }
    _CurDirs[u] = SpDupStringW(p);

    return 1;
}

ULONG
RcCmdSystemRoot(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    ULONG u;
    WCHAR buf[MAX_PATH];


    if (RcCmdParseHelp( TokenizedLine, MSG_SYSTEMROOT_HELP )) {
        return 1;
    }

    //
    // set the current drive to the correct one.
    //

    if (SelectedInstall == NULL) {
        return 1;
    }

    _CurDrive = SelectedInstall->DriveLetter;

    //
    // set the current dir to the correct one.
    //
    RtlZeroMemory( buf, sizeof(buf) );

    wcscat( buf, L"\\" );
    wcscat( buf, SelectedInstall->Path );
    wcscat( buf, L"\\" );

    u = RcToUpper(SelectedInstall->DriveLetter) - L'A';
    if( _CurDirs[u] ) {
        SpMemFree(_CurDirs[u]);
    }
    _CurDirs[u] = SpDupStringW( buf );

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\cmdcons\bootsect.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    bootsect.c

Abstract:

    This module implements access to the boot sector.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop

#include <boot98f.h>
#include <boot98f2.h>
#include <boot98n.h>
#include <bootetfs.h>
#include <bootf32.h>
#include <bootfat.h>
#include <bootntfs.h>

#pragma hdrstop

extern unsigned ConsoleX;

WCHAR           TemporaryBuffer[16384];
WCHAR           DriveLetterSpecified;
BOOLEAN         DidIt;

NTSTATUS
pSpBootCodeIoC(
    IN     PWSTR     FilePath,
    IN     PWSTR     AdditionalFilePath, OPTIONAL
    IN     ULONG     BytesToRead,
    IN     PUCHAR   *Buffer,
    IN     ULONG     OpenDisposition,
    IN     BOOLEAN   Write,
    IN     ULONGLONG Offset,
    IN     ULONG     BytesPerSector
    );

VOID
SpDetermineOsTypeFromBootSectorC(
    IN  PWSTR     CColonPath,
    IN  PUCHAR    BootSector,
    OUT PUCHAR   *OsDescription,
    OUT PBOOLEAN  IsNtBootcode,
    OUT PBOOLEAN  IsOtherOsInstalled,
    IN  WCHAR     DriveLetter
    );

// prototypes
ULONG
RcStampBootSectorOntoDisk(
    VOID
    );

BOOL
RcEnumDiskRegionsCallback(
    IN PPARTITIONED_DISK Disk,
    IN PDISK_REGION Region,
    IN ULONG_PTR Ignore
    );

VOID
RcLayBootCode(
    IN OUT PDISK_REGION CColonRegion
    );



ULONG
RcCmdFixBootSect(
    IN PTOKENIZED_LINE TokenizedLine
    )

/*++

Routine Description:

    Top-level routine supporting the FIXBOOT command in the setup diagnostic
    command interpreter.

    FIXBOOT writes a new bootsector onto the system partition.

Arguments:

    TokenizedLine - supplies structure built by the line parser describing
        each string on the line as typed by the user.

Return Value:

    TRUE.

--*/

{
    /*
    WCHAR   szText[2];
    PWSTR   szYesNo = NULL;
    BOOLEAN bConfirmed = FALSE;
    WCHAR   szMsg[512] = {0};
    PWSTR   szDriveSpecified = 0;
    PWSTR   szConfirmMsg = 0;
    */
    
    if (RcCmdParseHelp(TokenizedLine, MSG_FIXBOOT_HELP)) {
        return 1;
    }

    if (TokenizedLine->TokenCount == 2) {
        //
        // a drive letter is specified
        //
        DriveLetterSpecified = TokenizedLine->Tokens->Next->String[0];
//        szDriveSpecified = TokenizedLine->Tokens->Next->String;
    } else {
        DriveLetterSpecified = 0;
    }

    /*
    if (!InBatchMode) {
        szYesNo = SpRetreiveMessageText(ImageBase, MSG_YESNO, NULL, 0);
        szConfirmMsg = SpRetreiveMessageText(ImageBase, 
                                    MSG_FIXBOOT_ARE_YOU_SURE, NULL, 0);
        
        if(!szYesNo || !szConfirmMsg) {
            bConfirmed = TRUE;
        }
        
        while (!bConfirmed) {
            swprintf(szMsg, szConfirmMsg, szDriveSpecified);
            RcTextOut(szMsg);
            
            if(RcLineIn(szText,2)) {
                if((szText[0] == szYesNo[0]) || (szText[0] == szYesNo[1])) {
                    //
                    // Wants to do it.
                    //
                    bConfirmed = TRUE;
                } else {
                    if((szText[0] == szYesNo[2]) || (szText[0] == szYesNo[3])) {
                        //
                        // Doesn't want to do it.
                        //
                        break;
                    }
                }
            }
        }
    }

    if (bConfirmed)
    */
    RcStampBootSectorOntoDisk();

    return TRUE;
}

ULONG
RcStampBootSectorOntoDisk(
    VOID
    )

/*++

Routine Description:

    Setup the enumerate disk regions call, so we can do the boot sector.

Arguments:

    None.

Return Value:

    TRUE.

--*/


{
    // enumerate the partitions
    DidIt = FALSE;

    SpEnumerateDiskRegions( (PSPENUMERATEDISKREGIONS)RcEnumDiskRegionsCallback, 1 );

    if (!DidIt) {
        RcMessageOut( MSG_FIXBOOT_INVALID );
    }

    return TRUE;
}

BOOL
RcEnumDiskRegionsCallback(
    IN PPARTITIONED_DISK Disk,
    IN PDISK_REGION Region,
    IN ULONG_PTR Ignore
    )

/*++

Routine Description:

    Callback routine passed to SpEnumDiskRegions.

Arguments:

    Region - a pointer to a disk region returned by SpEnumDiskRegions
    Ignore - ignored parameter

Return Value:

    TRUE - to continue enumeration
    FALSE - to end enumeration

--*/

{
    if (Region->PartitionedSpace) {
        if (DriveLetterSpecified) {
            if( RcToUpper(DriveLetterSpecified) == RcToUpper(Region->DriveLetter) ) {
                RcMessageOut( MSG_FIXBOOT_INFO1, Region->DriveLetter );
                RcLayBootCode( Region );
                DidIt = TRUE;
                return FALSE;
            }

        } else if ((!IsNEC_98 && Region->IsSystemPartition) ||
                   (IsNEC_98 && (Region->DriveLetter == SelectedInstall->DriveLetter))) {
            DEBUG_PRINTF(( "system partition is %wc\n", Region->DriveLetter ));
            RcMessageOut( MSG_FIXBOOT_INFO1, Region->DriveLetter );
            RcLayBootCode( Region );
            DidIt = TRUE;
            return FALSE;
        }
    }

    return TRUE;
}


VOID
RcLayBootCode(
    IN OUT PDISK_REGION CColonRegion
    )

/*++

Routine Description:

    RcLayBootCode contains the code that replaces the boot sector on the
    targetted disk region.

Arguments:

    CColonRegion - the startup partition for the system.

Return Value:

    None.

--*/

{
    PUCHAR NewBootCode;
    ULONG BootCodeSize;
    PUCHAR ExistingBootCode = NULL;
    NTSTATUS Status;
    NTSTATUS rc;
    PUCHAR ExistingBootCodeOs = NULL;
    PWSTR CColonPath;
    HANDLE  PartitionHandle;
    //PWSTR BootsectDosName = L"\\bootsect.dos";
    //PWSTR OldBootsectDosName = L"\\bootsect.bak";
    //PWSTR BootSectDosFullName, OldBootSectDosFullName, p;
    BOOLEAN IsNtBootcode,OtherOsInstalled, FileExist;
    UNICODE_STRING    UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK   IoStatusBlock;
    BOOLEAN BootSectorCorrupt = FALSE;
    ULONG MirrorSector;
    ULONG BytesPerSector;
    ULONG SectorsPerTrack;
    ULONG TracksPerCylinder;
    ULONGLONG ActualSectorCount, hidden_sectors, super_area_size;
    UCHAR SysId;
    ULONGLONG HiddenSectorCount,VolumeSectorCount; //NEC98
    PUCHAR DiskArraySectorData,TmpBuffer; //NEC98
    IO_STATUS_BLOCK StatusBlock;
    UCHAR InfoBuffer[2048];
    WCHAR   szText[2];
    PWSTR   szYesNo = NULL;
    BOOLEAN bConfirmed = FALSE;
    //WCHAR   szMsg[512] = {0};
    WCHAR   szDriveSpecified[8] = {0};

    if (!InBatchMode) {
        //
        // get confirmation from user before proceeding
        // 
        szYesNo = SpRetreiveMessageText(ImageBase, MSG_YESNO, NULL, 0);
        szDriveSpecified[0] = CColonRegion->DriveLetter;
        szDriveSpecified[1] = L':';
        szDriveSpecified[2] = 0;
        
        if(!szYesNo || !szDriveSpecified[0]) {
            bConfirmed = TRUE;
        }
        
        while (!bConfirmed) {
            RcMessageOut(MSG_FIXBOOT_ARE_YOU_SURE, szDriveSpecified);
            
            if(RcLineIn(szText,2)) {
                if((szText[0] == szYesNo[0]) || (szText[0] == szYesNo[1])) {
                    //
                    // Wants to do it.
                    //
                    bConfirmed = TRUE;
                } else {
                    if((szText[0] == szYesNo[2]) || (szText[0] == szYesNo[3])) {
                        //
                        // Doesn't want to do it.
                        //
                        break;
                    }
                }
            }
        }
    }

    if (!bConfirmed)
        return;     // user did not want to proceed

    switch( CColonRegion->Filesystem ) {
        case FilesystemNewlyCreated:
            //
            // If the filesystem is newly-created, then there is
            // nothing to do, because there can be no previous
            // operating system.
            //
            return;

        case FilesystemNtfs:
            NewBootCode = (!IsNEC_98) ? NtfsBootCode : PC98NtfsBootCode; //NEC98
            BootCodeSize = (!IsNEC_98) ? sizeof(NtfsBootCode) : sizeof(PC98NtfsBootCode); //NEC98
            ASSERT(BootCodeSize == 8192);
            RcMessageOut( MSG_FIXBOOT_FS, L"NTFS" );
            break;

        case FilesystemFat:
            NewBootCode = (!IsNEC_98) ? FatBootCode : PC98FatBootCode; //NEC98
            BootCodeSize = (!IsNEC_98) ? sizeof(FatBootCode) : sizeof(PC98FatBootCode); //NEC98
            ASSERT(BootCodeSize == 512);
            RcMessageOut( MSG_FIXBOOT_FS, L"FAT" );
            break;

        case FilesystemFat32:
            //
            // Special hackage required for Fat32 because its NT boot code
            // is discontiguous.
            //
            ASSERT(sizeof(Fat32BootCode) == 1536);
            NewBootCode = (!IsNEC_98) ? Fat32BootCode : PC98Fat32BootCode; //NEC98
            BootCodeSize = 512;
            RcMessageOut( MSG_FIXBOOT_FS, L"FAT32" );
            break;

        default:
            // we assume that the boot sector is corrupt if it is
            // not a FAT or NTFS boot partition.
            BootSectorCorrupt = TRUE;
            DEBUG_PRINTF(("CMDCONS: bogus filesystem %u for C:!\n",CColonRegion->Filesystem));
            RcMessageOut( MSG_FIXBOOT_NO_VALID_FS );
    }

    //
    // Form the device path to C: and open the partition.
    //

    SpNtNameFromRegion( CColonRegion,
                        TemporaryBuffer,
                        sizeof(TemporaryBuffer),
                        PartitionOrdinalCurrent );

    CColonPath = SpDupStringW( TemporaryBuffer );

    INIT_OBJA(&Obja,&UnicodeString,CColonPath);

    Status = ZwCreateFile( &PartitionHandle,
                           FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                           &Obja,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL,
                           0 );

    if (!NT_SUCCESS(Status)) {
        DEBUG_PRINTF(("CMDCONS: unable to open the partition for C:!\n"));
        RcMessageOut( MSG_FIXBOOT_FAILED1 );
        return;
    }

    //
    // get disk geometry
    //

    rc = ZwDeviceIoControlFile( PartitionHandle,
                                NULL,
                                NULL,
                                NULL,
                                &StatusBlock,
                                IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                NULL,
                                0,
                                InfoBuffer,
                                sizeof( InfoBuffer ) );

    if (!NT_SUCCESS( rc )) {

        RcMessageOut( MSG_FIXBOOT_READ_ERROR );

    } else {
        //
        // retrieve the sector size and other info
        //
        BytesPerSector = ((DISK_GEOMETRY*)InfoBuffer)->BytesPerSector;
        TracksPerCylinder = ((DISK_GEOMETRY*)InfoBuffer)->TracksPerCylinder;
        SectorsPerTrack = ((DISK_GEOMETRY*)InfoBuffer)->SectorsPerTrack;
    }

    //
    // Enable extended DASD I/O so we can read the last sector on the
    // disk.
    //

    rc = ZwFsControlFile( PartitionHandle,
                                NULL,
                                NULL,
                                NULL,
                                &StatusBlock,
                                FSCTL_ALLOW_EXTENDED_DASD_IO,
                                NULL,
                                0,
                                NULL,
                                0 );

    ASSERT( NT_SUCCESS(rc) );

    //
    // Allocate a buffer and read in the boot sector(s) currently on the disk.
    //

    if (BootSectorCorrupt) {

        //
        // The partition is UNKNOWN or cannot be determined by the system.
        //

        //
        // We can't determine the file system type from the boot sector, so
        // we assume it's NTFS if we find a mirror sector, and FAT otherwise.
        //

        RcMessageOut( MSG_FIXBOOT_DETERMINE );
        DEBUG_PRINTF(( "BootSectorCorrupt TRUE\n" ));

        //
        // First, attempt to find an NTFS mirror boot sector.
        //

        MirrorSector = NtfsMirrorBootSector (PartitionHandle,
                                             BytesPerSector,
                                             &ExistingBootCode);

        if (MirrorSector) {

            //
            // It's NTFS - use the mirror boot sector to recover the drive.
            //

            RcMessageOut( MSG_FIXBOOT_FOUND_NTFS );

            NewBootCode = (!IsNEC_98) ? NtfsBootCode : PC98NtfsBootCode; //NEC98
            BootCodeSize = (!IsNEC_98) ? sizeof(NtfsBootCode) : sizeof(PC98NtfsBootCode); //NEC98
            ASSERT(BootCodeSize == 8192);

            CColonRegion->Filesystem = FilesystemNtfs;
            IsNtBootcode = TRUE;

        } else {

            //
            // It's FAT - create a new boot sector since there's no mirror.
            //

            RcMessageOut( MSG_FIXBOOT_FOUND_FAT );

            NewBootCode = (!IsNEC_98) ? FatBootCode : PC98FatBootCode; //NEC98
            BootCodeSize = (!IsNEC_98) ? sizeof(FatBootCode) : sizeof(PC98FatBootCode); //NEC98
            ASSERT(BootCodeSize == 512);

            CColonRegion->Filesystem = FilesystemFat;
            IsNtBootcode = FALSE;

            SpPtGetSectorLayoutInformation( CColonRegion,
                                            &hidden_sectors,
                                            &ActualSectorCount );

            //
            // No alignment requirement here
            //

            ExistingBootCode = SpMemAlloc(BytesPerSector);

            //
            // This will actually fail with STATUS_BUFFER_TOO_SMALL
            // but it will fill in the bpb info, which is what we want.
            //

            FmtFillFormatBuffer ( ActualSectorCount,
                                  BytesPerSector,
                                  SectorsPerTrack,
                                  TracksPerCylinder,
                                  hidden_sectors,
                                  ExistingBootCode,
                                  BytesPerSector,
                                  &super_area_size,
                                  NULL,
                                  0,
                                  &SysId );

        }

        Status = STATUS_SUCCESS;

    } else if( CColonRegion->Filesystem == FilesystemNtfs ) {

        //
        // The partition is NTFS.
        //

        //
        // We use the mirror sector to repair a NTFS file system
        // if we can find one.
        //

        MirrorSector = NtfsMirrorBootSector( PartitionHandle,
                                             BytesPerSector,
                                             &ExistingBootCode );

        if( !MirrorSector ) {

            //
            // Just use existing NTFS boot code.
            //
            Status = pSpBootCodeIoC( CColonPath,
                                    NULL,
                                    BootCodeSize,
                                    &ExistingBootCode,
                                    FILE_OPEN,
                                    FALSE,
                                    0,
                                    BytesPerSector );
        }

    } else {

        //
        // The partition is FAT.
        //

        //
        // Just use existing boot code since
        // there is no mirror sector on FAT.
        //

        Status = pSpBootCodeIoC( CColonPath,
                                NULL,
                                BootCodeSize,
                                &ExistingBootCode,
                                FILE_OPEN,
                                FALSE,
                                0,
                                BytesPerSector );

    }

    if( NT_SUCCESS(Status) ) {

        //
        // Determine the type of operating system the existing boot sector(s) are for
        // and whether that os is actually installed. Note that we don't need to call
        // this for NTFS.
        //

        // RcMessageOut( MSG_FIXBOOT_CHECKING_OS );

        if( BootSectorCorrupt ) {

            //
            // If the boot sector is corrupt, we don't assume
            // another OS was installed.
            //

            OtherOsInstalled = FALSE;
            ExistingBootCodeOs = NULL;

        } else if( CColonRegion->Filesystem != FilesystemNtfs ) {

            // If the file system is FAT, DOS could have been installed
            // previously.

            SpDetermineOsTypeFromBootSectorC( CColonPath,
                                             ExistingBootCode,
                                             &ExistingBootCodeOs,
                                             &IsNtBootcode,
                                             &OtherOsInstalled,
                                             CColonRegion->DriveLetter );

        } else {

            //
            // Otherwise, it's NTFS, and another OS type
            // couldn't have been installed.
            //

            IsNtBootcode = TRUE;
            OtherOsInstalled = FALSE;
            ExistingBootCodeOs = NULL;

        }

        if( NT_SUCCESS(Status) ) {

            //
            // Transfer the bpb from the existing boot sector into the boot code buffer
            // and make sure the physical drive field is set to hard disk (0x80).
            //
            // The first three bytes of the NT boot code are going to be something like
            // EB 3C 90, which is intel jump instruction to an offset in the boot sector,
            // past the BPB, to continue execution.  We want to preserve everything in the
            // current boot sector up to the start of that code.  Instead of hard coding
            // a value, we'll use the offset of the jump instruction to determine how many
            // bytes must be preserved.
            //

            RtlMoveMemory(NewBootCode+3,ExistingBootCode+3,NewBootCode[1]-1);

            if( CColonRegion->Filesystem != FilesystemFat32 ) {
                //
                // On fat32 this overwrites the BigNumFatSecs field,
                // a very bad thing to do indeed!
                //
                NewBootCode[36] = 0x80;
            }

            //
            // get Hidden sector informatin.
            //
            if( IsNEC_98 ) { //NEC98
                SpPtGetSectorLayoutInformation(
                                              CColonRegion,
                                              &HiddenSectorCount,
                                              &VolumeSectorCount    // not used
                                              );
            } //NEC98

            //
            // Write out boot code buffer, which now contains the valid bpb,
            // to the boot sector(s).
            //

            RcMessageOut( MSG_FIXBOOT_WRITING );

            Status = pSpBootCodeIoC(
                            CColonPath,
                            NULL,
                            BootCodeSize,
                            &NewBootCode,
                            FILE_OPEN,
                            TRUE,
                            0,
                            BytesPerSector
                            );


            //
            // Special case for Fat32, which has a second sector of boot code
            // at sector 12, discontiguous from the code on sector 0.
            //

            if( NT_SUCCESS(Status) && (CColonRegion->Filesystem == FilesystemFat32) ) {

                NewBootCode = (!IsNEC_98) ? Fat32BootCode + 1024
                              : PC98Fat32BootCode + 1024;                                //NEC98


                Status = pSpBootCodeIoC(
                                CColonPath,
                                NULL,
                                BootCodeSize,
                                &NewBootCode,
                                FILE_OPEN,
                                TRUE,
                                12*512,
                                BytesPerSector
                                );
            }

            //
            // Update the mirror boot sector.
            //
            if( (CColonRegion->Filesystem == FilesystemNtfs) && MirrorSector ) {

                WriteNtfsBootSector(PartitionHandle,BytesPerSector,NewBootCode,MirrorSector);

            }
        }

        if( ExistingBootCodeOs ) {
            SpMemFree(ExistingBootCodeOs);
        }
    }

    if( ExistingBootCode ) {
        SpMemFree(ExistingBootCode);
    }

    SpMemFree(CColonPath);
    ZwClose (PartitionHandle);

    //
    // Handle the error case.
    //
    if (!NT_SUCCESS(Status)) {
        RcMessageOut( MSG_FIXBOOT_FIX_ERROR );
    } else {
        RcMessageOut( MSG_FIXBOOT_DONE );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\cmdcons\cmdcons.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    cmdcons.h

Abstract:

    This is the main include file for the command console.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include <spprecmp.h>
#include <spcmdcon.h>
#include "msg1.h"



#define BUFFERSIZE (sizeof(KEY_VALUE_PARTIAL_INFORMATION)+256)

//
// Define maximum line length, which is the number of Unicode chars
// we will allow the user to type on a single line of input.
//
#define RC_MAX_LINE_LEN 500


//
// Variables and other stuff from setupdd.sys, passed to us
// in CommandConsole().
//
extern PCMDCON_BLOCK _CmdConsBlock;

//
// Base address where driver is loaded. Used to get messages
// from resources.
//
extern PVOID ImageBase;

//
// indicates we're running in batch mode
//
extern ULONG InBatchMode;
extern HANDLE OutputFileHandle;
extern BOOLEAN RedirectToNULL;
extern LARGE_INTEGER OutputFileOffset;

extern WCHAR _CurDrive;
extern LPWSTR _CurDirs[26];

//
// flags to override security
//
extern BOOLEAN AllowWildCards;
extern BOOLEAN AllowAllPaths;
extern BOOLEAN NoCopyPrompt;
extern BOOLEAN AllowRemovableMedia;


//
// Console routines.
//
VOID
RcConsoleInit(
    VOID
    );

VOID
RcConsoleTerminate(
    VOID
    );


#define RcLineIn(_b,_m) _RcLineIn(_b,_m,FALSE,FALSE)
#define RcLineInDefault(_b,_m) _RcLineIn(_b,_m,FALSE,TRUE)
#define RcPasswordIn(_b,_m) _RcLineIn(_b,_m,TRUE,FALSE)

unsigned
_RcLineIn(
    OUT PWCHAR   Buffer,
    IN  unsigned MaxLineLen,
    IN  BOOLEAN  PasswordProtect,
    IN BOOLEAN UseBuffer
    );

BOOLEAN
RcRawTextOut(
    IN LPCWSTR Text,
    IN LONG    Length
    );

BOOLEAN
RcTextOut(
    IN LPCWSTR Text
    );

VOID
pRcEnableMoreMode(
    VOID
    );

VOID
pRcDisableMoreMode(
    VOID
    );


//
// Message resource manipulation.
//

VOID
vRcMessageOut(
    IN ULONG    MessageId,
    IN va_list *arglist
    );

VOID
RcMessageOut(
    IN ULONG MessageId,
    ...
    );

VOID
RcNtError(
    IN NTSTATUS Status,
    IN ULONG    FallbackMessageId,
    ...
    );

ULONG
RcFormatDateTime(
    IN  PLARGE_INTEGER Time,
    OUT LPWSTR         Output
    );

//
// Current directory stuff.
//
VOID
RcInitializeCurrentDirectories(
    VOID
    );

VOID
RcTerminateCurrentDirectories(
    VOID
    );

VOID
RcAddDrive(
    WCHAR DriveLetter
    );

VOID
RcRemoveDrive(
    WCHAR DriveLetter
    );

BOOLEAN
RcFormFullPath(
    IN  LPCWSTR PartialPath,
    OUT LPWSTR  FullPath,
    IN  BOOLEAN NtPath
    );

BOOLEAN
RcIsPathNameAllowed(
    IN LPCWSTR FullPath,
    IN BOOLEAN RemovableMediaOk,
    IN BOOLEAN Mkdir
    );

BOOLEAN
RcGetNTFileName(
    IN LPCWSTR DosPath,
    IN LPCWSTR NTPath
    );

NTSTATUS
GetDriveLetterLinkTarget(
    IN PWSTR SourceNameStr,
    OUT PWSTR *LinkTarget
    );

VOID
RcGetCurrentDriveAndDir(
    OUT LPWSTR Output
    );

WCHAR
RcGetCurrentDriveLetter(
    VOID
    );

BOOLEAN
RcIsDriveApparentlyValid(
    IN WCHAR DriveLetter
    );

NTSTATUS
pRcGetDeviceInfo(
    IN PWSTR FileName,      // must be an nt name
    IN PFILE_FS_DEVICE_INFORMATION DeviceInfo
    );

//
// Line parsing/tokenizing stuff.
//
typedef struct _LINE_TOKEN {
    struct _LINE_TOKEN *Next;
    LPWSTR String;
} LINE_TOKEN, *PLINE_TOKEN;

typedef struct _TOKENIZED_LINE {
    //
    // Total number of tokens.
    //
    unsigned TokenCount;

    PLINE_TOKEN Tokens;

} TOKENIZED_LINE, *PTOKENIZED_LINE;

PTOKENIZED_LINE
RcTokenizeLine(
    IN LPWSTR Line
    );

VOID
RcFreeTokenizedLine(
    IN OUT PTOKENIZED_LINE *TokenizedLine
    );


//
// Command dispatching.
//

typedef
ULONG
(*PRC_CMD_ROUTINE) (
    IN PTOKENIZED_LINE TokenizedLine
    );


typedef struct _RC_CMD {
    //
    // Name of command.
    //
    LPCWSTR Name;

    //
    // Routine that carries out the command.
    //
    PRC_CMD_ROUTINE Routine;

    //
    // Arg counts. Mandatory arg count specifies the minimum number
    // of args that MUST be present (not including the command itself).
    // MaximumArgCount specifies the maximum number that are allowed
    // to be present. -1 means any number are allowed, and the command
    // itself validates the arg count.
    //
    unsigned MinimumArgCount;
    unsigned MaximumArgCount;
    unsigned Hidden;
    BOOLEAN  Enabled;

} RC_CMD, *PRC_CMD;

ULONG
RcDispatchCommand(
    IN PTOKENIZED_LINE TokenizedLine
    );

BOOLEAN
RcDisableCommand(
    IN PRC_CMD_ROUTINE  CmdToDisable
    );
    

VOID
RcHideNetCommands(
    VOID
    );

//
// Chartype stuff.
//
// Be careful when using these as they evaluate their arg more than once.
//
#define RcIsUpper(c)        (((c) >= L'A') && ((c) <= L'Z'))
#define RcIsLower(c)        (((c) >= L'a') && ((c) <= L'z'))
#define RcIsAlpha(c)        (RcIsUpper(c) || RcIsLower(c))
#define RcIsSpace(c)        (((c) == L' ') || (((c) >= L'\t') && ((c) <= L'\r')))
#define RcToUpper(c)        ((WCHAR)(RcIsLower(c) ? ((c)-(L'a'-L'A')) : (c)))

#define DEBUG_PRINTF( x ) KdPrint( x );
//define DEBUG_PRINTF( x )

typedef enum {
    RcUnknown, RcFAT, RcFAT32, RcNTFS, RcCDFS
} RcFileSystemType;

//
// Miscellaneous routines.
//
typedef
BOOLEAN
(*PENUMFILESCB) (
    IN  LPCWSTR                     Directory,
    IN  PFILE_BOTH_DIR_INFORMATION  FileInfo,
    OUT NTSTATUS                   *Status,
    IN  PVOID                       CallerContext
    );

NTSTATUS
RcEnumerateFiles(
    IN LPCWSTR      OriginalPathSpec,
    IN LPCWSTR      FullyQualifiedPathSpec,
    IN PENUMFILESCB Callback,
    IN PVOID        CallerData
    );

VOID
RcFormat64BitIntForOutput(
    IN  LONGLONG n,
    OUT LPWSTR   Output,
    IN  BOOLEAN  RightJustify
    );

// implemented in mbr.c
NTSTATUS
RcReadDiskSectors(
    IN     HANDLE  Handle,
    IN     ULONG   SectorNumber,
    IN     ULONG   SectorCount,
    IN     ULONG   BytesPerSector,
    IN OUT PVOID   AlignedBuffer
    );

NTSTATUS
RcWriteDiskSectors(
    IN     HANDLE  Handle,
    IN     ULONG   SectorNumber,
    IN     ULONG   SectorCount,
    IN     ULONG   BytesPerSector,
    IN OUT PVOID   AlignedBuffer
    );

//
// Set command helper routines
//
VOID
RcSetSETCommandStatus(
    BOOLEAN bEnabled
    );

BOOLEAN
RcGetSETCommandStatus(
    VOID
    );    
//
// Top-level routines for commands.
//
ULONG
RcCmdSwitchDrives(
    IN WCHAR DriveLetter
    );

ULONG
RcCmdFdisk(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdChdir(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdType(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdDir(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdDelete(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdSetFlags(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdRename(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdRepair(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdVerifier(
    IN PTOKENIZED_LINE TokenizedLine
    );   

ULONG
RcCmdBootCfg(
    IN PTOKENIZED_LINE TokenizedLine
    );   

ULONG
RcCmdMakeDiskRaw(
    IN PTOKENIZED_LINE TokenizedLine
    );   

BOOLEAN
pRcExecuteBatchFile(
    IN PWSTR BatchFileName,
    IN PWSTR OutputFileName,
    IN BOOLEAN Quiet
    );

ULONG
RcCmdBatch(
    IN PTOKENIZED_LINE TokenizedLine
    );

BOOLEAN
RcCmdParseHelp(
    IN PTOKENIZED_LINE TokenizedLine,
    ULONG MsgId
    );

ULONG
RcCmdMkdir(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdRmdir(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdChkdsk(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdFormat(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdCls(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdCopy(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdExpand(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdDriveMap(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdLogon(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdEnableService(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdDisableService(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdFixMBR(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdFixBootSect(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdSystemRoot(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdHelpHelp(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdAttrib(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdNet(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdListSvc(
    IN PTOKENIZED_LINE TokenizedLine
    );


//
// struct used to track NT installation information
//

typedef struct _NT_INSTALLATION {
    LIST_ENTRY      ListEntry;
    ULONG           InstallNumber;
    WCHAR           DriveLetter;
    WCHAR           Path[MAX_PATH];
    PDISK_REGION    Region;
} NT_INSTALLATION, *PNT_INSTALLATION;

//
// redults from a full depth first scan of NT installations
//
extern LIST_ENTRY   NtInstallsFullScan;
extern ULONG        InstallCountFullScan;

//
// The maximum directory depth we scan when searching for NT Installs
//
#define MAX_FULL_SCAN_RECURSION_DEPTH 10

//
// install that we're currently logged onto
//
extern PNT_INSTALLATION SelectedInstall;

//
// global to determine the selected NT install after login
//

extern PNT_INSTALLATION SelectedInstall;

//
// persistent data structure used for enumerating
// the directory tree while looking for NT installs
//
typedef struct _RC_SCAN_RECURSION_DATA_ {

    PDISK_REGION                NtPartitionRegion;
    ULONG                       RootDirLength;

} RC_SCAN_RECURSION_DATA, *PRC_SCAN_RECURSION_DATA;

typedef struct _RC_ALLOWED_DIRECTORY{
    BOOLEAN MustBeOnInstallDrive;
    PCWSTR Directory;
} RC_ALLOWED_DIRECTORY, * PRC_ALLOWED_DIRECTORY;


BOOL
RcScanDisksForNTInstallsEnum(
    IN PPARTITIONED_DISK    Disk,
    IN PDISK_REGION         NtPartitionRegion,
    IN ULONG_PTR            Context
    );


VOID
pRcCls(
    VOID
    );

NTSTATUS
RcIsFileOnRemovableMedia(
    IN PWSTR FileName      // must be an nt name
    );

NTSTATUS
RcIsFileOnCDROM(
    IN PWSTR FileName      // must be an nt name
    );

NTSTATUS
RcIsFileOnFloppy(
    IN PWSTR FileName      // must be an nt name
    );

void
RcPurgeHistoryBuffer(
    void
    );

BOOLEAN
RcDoesPathHaveWildCards(
    IN LPCWSTR FullPath
    );

BOOLEAN
RcOpenSystemHive(
    VOID
    );

BOOLEAN
RcCloseSystemHive(
    VOID
    );

BOOLEAN
RcIsArc(
    VOID
    );



NTSTATUS
RcIsNetworkDrive(
    IN PWSTR NtFileName
    );

NTSTATUS
RcDoNetUse(
    PWSTR Share,
    PWSTR User,
    PWSTR Password,
    PWSTR Drive
    );

NTSTATUS
RcNetUnuse(
    PWSTR Drive
    );

NTSTATUS
PutRdrInKernelMode(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\cmdcons\console.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    console.c

Abstract:

    This module implements the interfaces that
    provide access to the console i/o.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop

//
// Notes:
//
// This code needs to be correct for DBCS. A double-byte character takes up
// 2 character spaces on the screen. This means that there is not a one-to-one
// correlation between the unicode characters we want to work with and the
// representation on the screen. For this reason, the code in this module
// does a lot of converting into the OEM charset. When represented in the
// OEM charset, strlen(x) is exactly the number of char spaces taken up
// on the screen. (The fonts used in text mode setup are all OEM charset fonts
// so that's why we use OEM).
//


#define CURSOR                SplangGetCursorChar()
#define CONSOLE_HEADER_HEIGHT 0

unsigned ConsoleX,ConsoleY;

UCHAR ConsoleLeadByteTable[128/8];
BOOLEAN ConsoleDbcs;

#define IS_LEAD_BYTE(c)  ((c < 0x80) ? FALSE : (ConsoleLeadByteTable[(c & 0x7f) / 8] & (1 << ((c & 0x7f) % 8))))
#define SET_LEAD_BYTE(c) (ConsoleLeadByteTable[(c & 0x7f)/8] |= (1 << ((c & 0x7f) % 8)))

PUCHAR ConsoleOemString;
ULONG ConsoleMaxOemStringLen;

#define CONSOLE_ATTRIBUTE   (ATT_FG_WHITE | ATT_BG_BLACK)
#define CONSOLE_BACKGROUND  ATT_BLACK

//
// Globals used for more mode.
//
BOOLEAN pMoreMode;
unsigned pMoreLinesOut;
unsigned pMoreMaxLines;

#define CONSOLE_MORE_ATTRIBUTE   (ATT_FG_BLACK | ATT_BG_WHITE)
#define CONSOLE_MORE_BACKGROUND  ATT_WHITE



BOOLEAN
pRcLineDown(
    BOOLEAN *pbScrolled
    );


VOID
RcConsoleInit(
    VOID
    )
{
    unsigned i;

    //
    // Build lead-byte table, set ConsoleDbcs global
    //
    RtlZeroMemory(ConsoleLeadByteTable,sizeof(ConsoleLeadByteTable));

    if(ConsoleDbcs = NLS_MB_OEM_CODE_PAGE_TAG) {

        for(i=128; i<=255; i++) {

            if((NLS_OEM_LEAD_BYTE_INFO)[i]) {

                SET_LEAD_BYTE(i);
            }
        }
    }

    //
    // Get a buffer for unicode to oem translations.
    //
    ConsoleMaxOemStringLen = 2000;
    ConsoleOemString = SpMemAlloc(ConsoleMaxOemStringLen);

    //
    // Clear screen and initialize cursor location.
    //
    pRcCls();
}


VOID
RcConsoleTerminate(
    VOID
    )
{
    ASSERT(ConsoleOemString);

    SpMemFree(ConsoleOemString);
    ConsoleOemString = NULL;
    ConsoleMaxOemStringLen = 0;
}


#define MAX_HISTORY_LINES 30

typedef struct _LINE_HISTORY {
    WCHAR Line[RC_MAX_LINE_LEN];
    ULONG Length;
} LINE_HISTORY, *PLINE_HISTORY;

LINE_HISTORY LineHistory[MAX_HISTORY_LINES];
ULONG CurPos;
ULONG NextPos;


void
RcPurgeHistoryBuffer(
    void
    )
{
    CurPos = 0;
    NextPos = 0;
    ZeroMemory( LineHistory, sizeof(LineHistory) );
}


void
RcClearToEOL(
    void
    )
{
    unsigned uWidth = _CmdConsBlock->VideoVars->ScreenWidth;
    unsigned uY = ConsoleY + (ConsoleX / uWidth);
    unsigned uX = ConsoleX % uWidth; // taking care of roll over

    SpvidClearScreenRegion(uX, uY, uWidth-uX,
        1, CONSOLE_BACKGROUND);
}

void
RcClearLines(
    unsigned uX, unsigned uY, unsigned cLines
    )
/*++
Routine Description:

This routine clears the specified number of lines with blank characters
starting from X coordinate (0 based) on lines specifed by Y coordinate

Arguments:
    uX - starting X coordinate
    uY - starting Y coordinate
    cLines - number of lines to be cleared after Y coordinate

Return Value: None
--*/
{
    unsigned uWidth = _CmdConsBlock->VideoVars->ScreenWidth;

    if (uY < _CmdConsBlock->VideoVars->ScreenWidth) {
        SpvidClearScreenRegion(uX, uY, uWidth-uX,
            1, CONSOLE_BACKGROUND);

        if (cLines && (cLines <= _CmdConsBlock->VideoVars->ScreenWidth)) {
            SpvidClearScreenRegion(0, ++uY, uWidth,
                cLines, CONSOLE_BACKGROUND);
        }
    }
}


unsigned
_RcLineIn(
    OUT PWCHAR Buffer,
    IN unsigned MaxLineLen,
    IN BOOLEAN PasswordProtect,
    IN BOOLEAN UseBuffer
    )

/*++

Routine Description:

    Get a line of input from the user. The user can type at the keyboard.
    Control is very simple, the only control character accepted is backspace.
    A cursor will be drawn as the user types to indicate where the next
    character will end up on the screen. As the user types the screen will be
    scrolled if necessary.

    The string returned will be limited to MaxLineLen-1 characters and
    0-terminated.

    NOTE: this routine deals with double-byte characters correctly.

Arguments:

    Buffer - receives the line as typed by the user. The buffer must be
        large enough to hold least 2 characters, since the string returned
        will always get a nul-termination and requesting a string that
        can have at most only a terminating nul isn't too meaningful.

    MaxLineLen - supplies the number of unicode characters that will fit
        in the buffer pointed to by Buffer (including the terminating nul).
        As described above, must be > 1.

Return Value:

    Number of characters written into Buffer, not including the terminating
    nul character.

    Upon return the global ConsoleX and ConsoleY variables will be updated
    such that ConsoleX is 0 and ConsoleY indicates the next "empty" line.
    Also the cursor will be shut off.

--*/

{
    unsigned LineLen;
    ULONG c;
    WCHAR s[2];
    UCHAR Oem[3];
    BOOL Done;
    ULONG OemLen;
    int i,j;
    ULONG OrigConsoleX;
    ULONG ulOrigY;
    BOOLEAN bScrolled = FALSE;

    ASSERT(MaxLineLen > 1);
    MaxLineLen--;       // leave room for terminating nul
    LineLen = 0;
    Done = FALSE;
    s[1] = 0;

    //
    // We use ConsoleOemString as temp storage for char lengths.
    // Make sure we don't run off the end of the buffer.
    //
    if(MaxLineLen > ConsoleMaxOemStringLen) {
        MaxLineLen = ConsoleMaxOemStringLen;
    }

    //
    // Turn cursor on.
    //
    s[0] = CURSOR;
    SpvidDisplayString(s,CONSOLE_ATTRIBUTE,ConsoleX,ConsoleY);

    //
    // Get characters until user hits enter.
    //
    CurPos = NextPos;
    OrigConsoleX = ConsoleX;
    ulOrigY = ConsoleY;

    if (UseBuffer) {
        LineLen = wcslen(Buffer);
        RtlZeroMemory(ConsoleOemString,ConsoleMaxOemStringLen);
        RtlUnicodeToOemN(ConsoleOemString,ConsoleMaxOemStringLen,&OemLen,Buffer,LineLen*sizeof(WCHAR));
        SpvidDisplayOemString(ConsoleOemString,CONSOLE_ATTRIBUTE,ConsoleX,ConsoleY);
        ConsoleX += OemLen;
        RcClearToEOL();
        s[0] = CURSOR;
        SpvidDisplayString(s,CONSOLE_ATTRIBUTE,ConsoleX,ConsoleY);
        for (i=0; i<(int)wcslen(Buffer); i++) {
            RtlUnicodeToOemN(Oem,3,&OemLen,&Buffer[i],2*sizeof(WCHAR));
            ConsoleOemString[i] = (UCHAR)OemLen-1;
        }
    }

    do {

        c = SpInputGetKeypress();

        if(c & KEY_NON_CHARACTER) {
            if (c == KEY_UP || c == KEY_DOWN) {
                if (c == KEY_UP) {
                    if (CurPos == 0) {
                        i = MAX_HISTORY_LINES - 1;
                    } else {
                        i = CurPos - 1;
                    }
                    j = i;
                    while (LineHistory[i].Length == 0) {
                        i -= 1;
                        if (i < 0) {
                            i = MAX_HISTORY_LINES - 1;
                        }
                        if (i == j) break;
                    }
                }
                if (c == KEY_DOWN) {
                    if (CurPos == MAX_HISTORY_LINES) {
                        i = 0;
                    } else {
                        i = CurPos + 1;
                    }
                    j = i;
                    while (LineHistory[i].Length == 0) {
                        i += 1;
                        if (i == MAX_HISTORY_LINES) {
                            i = 0;
                        }
                        if (i == j) break;
                    }
                }

                if (LineHistory[i].Length) {
                    wcscpy(Buffer,LineHistory[i].Line);
                    LineLen = LineHistory[i].Length;
                    RtlZeroMemory(ConsoleOemString,ConsoleMaxOemStringLen);
                    RtlUnicodeToOemN(ConsoleOemString,ConsoleMaxOemStringLen,&OemLen,Buffer,LineLen*sizeof(WCHAR));
                    ConsoleX = OrigConsoleX;

                    // clear the old command
                    RcClearLines(ConsoleX, ulOrigY, ConsoleY - ulOrigY);

                    ConsoleY = ulOrigY;

                    // scroll if needed
                    if ((ConsoleX + OemLen) >= _CmdConsBlock->VideoVars->ScreenWidth) {
                        int cNumLines = (ConsoleX + OemLen) /
                                        _CmdConsBlock->VideoVars->ScreenWidth;
                        int cAvailLines = _CmdConsBlock->VideoVars->ScreenHeight -
                                            ConsoleY - 1;

                        if (cNumLines > cAvailLines) {
                            cNumLines -= cAvailLines;

                            SpvidScrollUp( CONSOLE_HEADER_HEIGHT,
                                _CmdConsBlock->VideoVars->ScreenHeight - 1,
                                cNumLines,
                                CONSOLE_BACKGROUND
                                );

                            ConsoleY -= cNumLines;
                            ulOrigY = ConsoleY;
                        }
                    }

                    SpvidDisplayOemString(ConsoleOemString,CONSOLE_ATTRIBUTE,ConsoleX,ConsoleY);

                    // clean up trailing spaces left by previous command
                    ConsoleX += OemLen;
                    //RcClearToEOL();
   	                s[0] = CURSOR;
  	
                    if (ConsoleX >= _CmdConsBlock->VideoVars->ScreenWidth) {
                        ConsoleY += (ConsoleX / _CmdConsBlock->VideoVars->ScreenWidth);
                        ConsoleY %= _CmdConsBlock->VideoVars->ScreenHeight;
                        ConsoleX %= _CmdConsBlock->VideoVars->ScreenWidth;
                    }

       	            SpvidDisplayString(s,CONSOLE_ATTRIBUTE, ConsoleX, ConsoleY);

                    CurPos = i;

                    for (i=0; i<(int)wcslen(Buffer); i++) {
                        RtlUnicodeToOemN(Oem,3,&OemLen,&Buffer[i],2*sizeof(WCHAR));
                        ConsoleOemString[i] = (UCHAR)OemLen-1;
                    }
                }
            }
        } else {
            //
            // Got a real unicode value, which could be CR, etc.
            //
            s[0] = (WCHAR)c;

            switch(s[0]) {

            case ASCI_ESC:
                LineLen = 0;
                ConsoleX = OrigConsoleX;
                CurPos = NextPos;
                // clear the extra lines from previous command if any
                RcClearLines(ConsoleX, ulOrigY, ConsoleY - ulOrigY);
                //RcClearToEOL();
                s[0] = CURSOR;
                ConsoleY = ulOrigY;
                SpvidDisplayString(s,CONSOLE_ATTRIBUTE,ConsoleX,ConsoleY);

                break;

            case ASCI_BS:

                if(LineLen) {
                    LineLen--;

                    //
                    // Write a space over the current cursor location
                    // and then back up one char and write the cursor.
                    //
                    s[0] = L' ';
                    SpvidDisplayString(s,CONSOLE_ATTRIBUTE,ConsoleX,ConsoleY);

                    OemLen = ConsoleOemString[LineLen];
                    ASSERT(OemLen <= 2);

                    if(ConsoleX) {
                        //
                        // We might have the case where the character we just erased
                        // is a double-byte character that didn't fit on the previous
                        // line because the user typed it when the cursor was at the
                        // rightmost x position.
                        //
                        if(OemLen) {
                            //
                            // No special case needed. Decrement the x position and
                            // clear out the second half of double-byte char,
                            // if necessary.
                            //
                            ConsoleX -= OemLen;
                            if(OemLen == 2) {
                                SpvidDisplayString(s,CONSOLE_ATTRIBUTE,ConsoleX+1,ConsoleY);
                            }
                        } else {
                            //
                            // Clear out the current character (which must be
                            // a double-byte character) and then hop up one line.
                            //
                            ASSERT(ConsoleX == 2);
                            SpvidDisplayString(s,CONSOLE_ATTRIBUTE,0,ConsoleY);
                            SpvidDisplayString(s,CONSOLE_ATTRIBUTE,1,ConsoleY);

                            ConsoleX = _CmdConsBlock->VideoVars->ScreenWidth-1;
                            ConsoleY--;
                        }
                    } else {
                        //
                        // The cursor is at x=0. This can't happen if
                        // there's a fill space at the end of the previous line,
                        // so we don't need to worry about handling that here.
                        //
                        ASSERT(OemLen != 3);
                        ConsoleX = _CmdConsBlock->VideoVars->ScreenWidth - OemLen;
                        ConsoleY--;

                        //
                        // Clear out second half of double-byte char if necessary.
                        //
                        if(OemLen > 1) {
                            SpvidDisplayString(s,CONSOLE_ATTRIBUTE,ConsoleX+1,ConsoleY);
                        }
                    }

                    s[0] = CURSOR;
                    SpvidDisplayString(s,CONSOLE_ATTRIBUTE,ConsoleX,ConsoleY);
                }

                ulOrigY = ConsoleY;

                break;

            case ASCI_CR:
                //
                // Erase the cursor and advance the current position one line.
                //
                s[0] = L' ';
                SpvidDisplayString(s,CONSOLE_ATTRIBUTE,ConsoleX,ConsoleY);

                ConsoleX = 0;
                pRcLineDown(0);

                //
                // We know there's room in the buffer because we accounted
                // for the terminating nul up front.
                //
                Buffer[LineLen] = 0;
                Done = TRUE;
                break;

            default:
                //
                // Plain old character. Note that it could be a double-byte char,
                // which takes up 2 char widths on the screen.
                //
                // Also disallow control chars.
                //
                if((s[0] >= L' ') && (LineLen < MaxLineLen)) {

                    //
                    // Convert to OEM, including nul byte
                    //
                    RtlUnicodeToOemN(Oem,3,&OemLen,PasswordProtect?L"*":s,2*sizeof(WCHAR));
                    OemLen--;

                    //
                    // Save the character in the caller's buffer.
                    // Also we use the ConsoleOemString buffer as temp storage space
                    // to store the length in oem chars of each char input.
                    //
                    Buffer[LineLen] = s[0];
                    ConsoleOemString[LineLen] = (UCHAR)OemLen;

                    //
                    // If the character is double-byte, then there might not be
                    // enough room on the current line for it. Check for that here.
                    //
                    if((ConsoleX+OemLen) > _CmdConsBlock->VideoVars->ScreenWidth) {

                        //
                        // Erase the cursor from the last position on the line.
                        //
                        s[0] = L' ';
                        SpvidDisplayString(
                            s,
                            CONSOLE_ATTRIBUTE,
                            _CmdConsBlock->VideoVars->ScreenWidth-1,
                            ConsoleY
                            );

                        //
                        // Adjust cursor position.
                        //
                        ConsoleX = 0;
                        // >> ulOrigY = ConsoleY;
                        bScrolled = FALSE;
                        pRcLineDown(&bScrolled);

                        //
                        // if screen scrolled then we need to adjust original Y coordinate
                        // appropriately
                        //
                        if (bScrolled && (ulOrigY > 0))
                            --ulOrigY;

                        //
                        // Special handling for this case, so backspace will
                        // work correctly.
                        //
                        ConsoleOemString[LineLen] = 0;
                    }

                    SpvidDisplayOemString(Oem,CONSOLE_ATTRIBUTE,ConsoleX,ConsoleY);
                    ConsoleX += OemLen;

                    if(ConsoleX == _CmdConsBlock->VideoVars->ScreenWidth) {
                        ConsoleX = 0;
                        // >> ulOrigY = ConsoleY;
                        bScrolled = FALSE;
                        pRcLineDown(&bScrolled);

                        //
                        // if screen scrolled then we need to adjust original Y coordinate
                        // appropriately
                        //
                        if (bScrolled && (ulOrigY > 0))
                            --ulOrigY;
                    }

                    //
                    // Now display cursor at cursor position for next character.
                    //
                    s[0] = CURSOR;
                    SpvidDisplayString(s,CONSOLE_ATTRIBUTE,ConsoleX,ConsoleY);

                    LineLen++;
                }

                break;
            }
        }
    } while(!Done);

    Buffer[LineLen] = 0;

    // save the line for future use only if its not a password
    if (LineLen && !PasswordProtect) {
        LineHistory[NextPos].Length = LineLen;
        wcscpy(LineHistory[NextPos].Line,Buffer);

        NextPos += 1;
        if (NextPos >= MAX_HISTORY_LINES) {
            NextPos = 0;
        }
    }

    return LineLen;
}


BOOLEAN
RcRawTextOut(
    IN LPCWSTR Text,
    IN LONG    Length
    )

/*++

Routine Description:

    Write a text string to the console at the current position
    (incidated by the ConsoleX and ConsoleY global variables). If the string
    is longer than will fit on the current line, it is broken up properly
    to span multiple lines. The screen is scrolled if necessary.

    This routine handles double-byte characters correctly, ensuring that
    no double-byte character is split across lines.

Arguments:

    Text - supplies the text to be output. Text strings longer than
        ConsoleMaxOemStringLen are truncated. The string need not be
        nul-terminated if Length is not -1.

    Length - supplies the number of characters to output. If -1, then
        Text is assumed to be nul-terminated and the length is
        calculated automatically.

Return Value:

    FALSE if we're in more mode and when prompted the user hit esc.
    TRUE otherwise.

    Upon return, the global variables ConsoleX and ConsoleY point at the next
    empty location on the screen.

--*/

{
    ULONG OemLen;
    ULONG len;
    ULONG i;
    UCHAR c;
    PUCHAR p;
    PUCHAR LastLead;
    BOOLEAN NewLine;
    BOOLEAN Dbcs;

    //
    // Convert the string to the OEM charset and determine the number
    // of character spaces the string will occupy on-screen, which is
    // equal to the number of bytes in the OEM representation of the string.
    // If this is not the same as the number of Unicode characters
    // in the string, then we've got a string with double-byte chars in it.
    //
    len = ((Length == -1) ? wcslen(Text) : Length);

    RtlUnicodeToOemN(
        ConsoleOemString,
        ConsoleMaxOemStringLen,
        &OemLen,
        (PVOID)Text,
        len * sizeof(WCHAR)
        );

    Dbcs = (OemLen != len);

    //
    // If we think we have a double-byte string, we better be prepared
    // to handle it properly.
    //
    if(Dbcs) {
        ASSERT(NLS_MB_OEM_CODE_PAGE_TAG);
        ASSERT(ConsoleDbcs);
    }

    //
    // Spit out the prompt in pieces until we've got all the characters
    // displayed.
    //
    ASSERT(ConsoleX < _CmdConsBlock->VideoVars->ScreenWidth);
    ASSERT(ConsoleY < _CmdConsBlock->VideoVars->ScreenHeight);
    p = ConsoleOemString;

    while(OemLen) {

        if((ConsoleX+OemLen) > _CmdConsBlock->VideoVars->ScreenWidth) {

            len = _CmdConsBlock->VideoVars->ScreenWidth - ConsoleX;

            //
            // Avoid splitting a double-byte character across lines.
            //
            if(Dbcs) {
                for(LastLead=NULL,i=0; i<len; i++) {
                    if(IS_LEAD_BYTE(p[i])) {
                        LastLead = &p[i];
                        i++;
                    }
                }
                if(LastLead == &p[len-1]) {
                    len--;
                }
            }

            NewLine = TRUE;

        } else {
            //
            // It fits on the current line, just display it.
            //
            len = OemLen;
            NewLine = ((ConsoleX+len) == _CmdConsBlock->VideoVars->ScreenWidth);
        }

        c = p[len];
        p[len] = 0;
        SpvidDisplayOemString(p,CONSOLE_ATTRIBUTE,ConsoleX,ConsoleY);
        p[len] = c;

        p += len;
        OemLen -= len;

        if(NewLine) {
            ConsoleX = 0;
            if(!pRcLineDown(0)) {
                return(FALSE);
            }
        } else {
            ConsoleX += len;
        }
    }

    return(TRUE);
}


NTSTATUS
RcBatchOut(
    IN PWSTR strW
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG OemLen;
    ULONG len;


    len = wcslen(strW);

    RtlUnicodeToOemN(
        ConsoleOemString,
        ConsoleMaxOemStringLen,
        &len,
        (PVOID)strW,
        len * sizeof(WCHAR)
        );

    Status = ZwWriteFile(
        OutputFileHandle,
        NULL,
        NULL,
        NULL,
        &IoStatusBlock,
        (PVOID)ConsoleOemString,
        len,
        &OutputFileOffset,
        NULL
        );
    if (NT_SUCCESS(Status)) {
        OutputFileOffset.LowPart += len;
    }

    return Status;
}


BOOLEAN
RcTextOut(
    IN LPCWSTR Text
    )
{
    LPCWSTR p,q;


    if (InBatchMode && OutputFileHandle) {
        if (RcBatchOut( (LPWSTR)Text ) == STATUS_SUCCESS) {
            return TRUE;
        }
    }
    if (InBatchMode && RedirectToNULL) {
        return TRUE;
    }

    p = Text;
    while(*p) {
        //
        // Locate line terminator, which is cr, lf, or nul.
        //
        q = p;
        while(*q && (*q != L'\r') && (*q != L'\n')) {
            q++;
        }

        //
        // Print this segment out.
        //
        if(!RcRawTextOut(p,(LONG)(q-p))) {
            return(FALSE);
        }

        //
        // Handle cr's and lf's.
        //
        p = q;

        while((*p == L'\n') || (*p == L'\r')) {

            if(*p == L'\n') {
                if(!pRcLineDown(0)) {
                    return(FALSE);
                }
            } else {
                if(*p == L'\r') {
                    ConsoleX = 0;
                }
            }

            p++;
        }
    }

    return(TRUE);
}


BOOLEAN
pRcLineDown(
    BOOLEAN *pbScrolled
    )
{
    WCHAR *p;
    unsigned u;
    ULONG c;
    BOOLEAN b;

    if (pbScrolled)
        *pbScrolled = FALSE;

    b = TRUE;

    ConsoleY++;
    pMoreLinesOut++;

    if(ConsoleY == _CmdConsBlock->VideoVars->ScreenHeight) {
        //
        // Reached the bottom of the screen, need to scroll.
        //
        ConsoleY--;

        SpvidScrollUp(
            CONSOLE_HEADER_HEIGHT,
            _CmdConsBlock->VideoVars->ScreenHeight-1,
            1,
            CONSOLE_BACKGROUND
            );

        if (pbScrolled)
            *pbScrolled = TRUE;
    }

    //
    // If we're in more mode and we've output the max number of lines
    // allowed before requiring user input, get that input now.
    //
    if(pMoreMode
    && (pMoreLinesOut == pMoreMaxLines)
    && (p = SpRetreiveMessageText(ImageBase,MSG_MORE_PROMPT,NULL,0))) {

        //
        // Don't bother calling the format message routine, since that
        // requires some other buffer. Just strip off cr/lf manually.
        //
        u = wcslen(p);
        while(u && ((p[u-1] == L'\r') || (p[u-1] == L'\n'))) {
            p[--u] = 0;
        }

        //
        // Display the more prompt at the bottom of the screen.
        //
        SpvidClearScreenRegion(
            0,
            _CmdConsBlock->VideoVars->ScreenHeight - 1,
            _CmdConsBlock->VideoVars->ScreenWidth,
            1,
            CONSOLE_MORE_BACKGROUND
            );

        SpvidDisplayString(
            p,
            CONSOLE_MORE_ATTRIBUTE,
            2,
            _CmdConsBlock->VideoVars->ScreenHeight - 1
            );

        //
        // We don't need the prompt any more.
        //
        SpMemFree(p);

        //
        // Wait for the user to hit space, cr, or esc.
        //
        pMoreLinesOut = 0;
        while(1) {
            c = SpInputGetKeypress();
            if(c == ASCI_CR) {
                //
                // Allow one more line before prompting user.
                //
                pMoreMaxLines = 1;
                break;
            } else {
                if(c == ASCI_ESC) {
                    //
                    // User wants to stop the current command.
                    //
                    b = FALSE;
                    break;
                } else {
                    if(c == L' ') {
                        //
                        // Allow a whole page more.
                        //
                        pMoreMaxLines = _CmdConsBlock->VideoVars->ScreenHeight
                                      - (CONSOLE_HEADER_HEIGHT + 1);
                        break;
                    }
                }
            }
        }

        SpvidClearScreenRegion(
            0,
            _CmdConsBlock->VideoVars->ScreenHeight - 1,
            _CmdConsBlock->VideoVars->ScreenWidth,
            1,
            CONSOLE_BACKGROUND
            );
    }

    return(b);
}


VOID
pRcEnableMoreMode(
    VOID
    )
{
    pMoreMode = TRUE;

    pMoreLinesOut = 0;

    //
    // The maximum number of lines we allow before prompting the user
    // is the screen height minus the header area. We also reserve
    // one line for the prompt area.
    //
    pMoreMaxLines = _CmdConsBlock->VideoVars->ScreenHeight - (CONSOLE_HEADER_HEIGHT + 1);
}


VOID
pRcDisableMoreMode(
    VOID
    )
{
    pMoreMode = FALSE;
}


ULONG
RcCmdCls(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    if (RcCmdParseHelp( TokenizedLine, MSG_CLS_HELP )) {
        return 1;
    }

    //
    // Call worker routine to actually do the work
    //
    pRcCls();

    return 1;
}


VOID
pRcCls(
    VOID
    )
{
    //
    // Initialize location and clear screen.
    //
    ConsoleX = 0;
    ConsoleY = CONSOLE_HEADER_HEIGHT;

    SpvidClearScreenRegion(0,0,0,0,CONSOLE_BACKGROUND);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\cmdcons\dir.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dir.c

Abstract:

    This module implements the dir commands.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop

//
// global external variables
//
extern LARGE_INTEGER glBias;

typedef struct _DIR_STATS {
    unsigned            FileCount;
    LONGLONG            TotalSize;
    RcFileSystemType    fsType;
} DIR_STATS, *PDIR_STATS;

BOOLEAN
pRcDirEnumProc(
    IN  LPCWSTR                     Directory,
    IN  PFILE_BOTH_DIR_INFORMATION  FileInfo,
    OUT NTSTATUS                   *Status,
    IN  PDIR_STATS                  DirStats
    );

NTSTATUS
SpSystemTimeToLocalTime (
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER LocalTime
    );

NTSTATUS
SpLocalTimeToSystemTime (
    IN PLARGE_INTEGER LocalTime,
    OUT PLARGE_INTEGER SystemTime
    );



    
ULONG
RcCmdDir(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    LPCWSTR Dir;
    LPWSTR Path;
    LPWSTR DosPath;
    LPWSTR p;
    NTSTATUS Status;
    WCHAR Drive[4];
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    HANDLE Handle;
    OBJECT_ATTRIBUTES Obja;
    DIR_STATS DirStats;
    ULONG u;
    ULONG rc;
    PFILE_FS_VOLUME_INFORMATION     VolumeInfo;
    FILE_FS_SIZE_INFORMATION        SizeInfo;
    BYTE                            bfFSInfo[sizeof(FILE_FS_ATTRIBUTE_INFORMATION) +
                                        (MAX_PATH*2)];       
    PFILE_FS_ATTRIBUTE_INFORMATION  pFSInfo = 0;


    if (RcCmdParseHelp( TokenizedLine, MSG_DIR_HELP )) {
        return 1;
    }

    //
    // If there's no argument, then we want the current directory.
    //
    Dir = (TokenizedLine->TokenCount == 2)
        ? TokenizedLine->Tokens->Next->String
        : L".";

    //
    // Canonicalize the name once to get a full DOS-style path
    // we can print out, and another time to get the NT-style path
    // we'll use to actually do the work.
    //
    if (!RcFormFullPath(Dir,_CmdConsBlock->TemporaryBuffer,FALSE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }
    DosPath = SpDupStringW(_CmdConsBlock->TemporaryBuffer);

    if (!RcFormFullPath(Dir,_CmdConsBlock->TemporaryBuffer,TRUE)) {
        RcMessageOut(MSG_INVALID_PATH);
        return 1;
    }
    Path = SpDupStringW(_CmdConsBlock->TemporaryBuffer);

    //
    // Open up the root directory of the drive so we can query
    // the volume label, serial number, and free space.
    //
    Drive[0] = DosPath[0];
    Drive[1] = L':';
    Drive[2] = L'\\';
    Drive[3] = 0;
    if (!RcFormFullPath(Drive,_CmdConsBlock->TemporaryBuffer,TRUE)) {
        DEBUG_PRINTF(( "couldn't open root of drive!" ));
        RcNtError( STATUS_NO_MEDIA_IN_DEVICE, MSG_NO_MEDIA_IN_DEVICE );
        goto c2;
    }

    INIT_OBJA(&Obja,&UnicodeString,_CmdConsBlock->TemporaryBuffer);

    Status = ZwOpenFile(
                &Handle,
                FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE
                );

    pRcEnableMoreMode();

    if(NT_SUCCESS(Status)) {
        //
        // Get the volume label and serial number.
        //
        VolumeInfo = _CmdConsBlock->TemporaryBuffer;

        Status = ZwQueryVolumeInformationFile(
                    Handle,
                    &IoStatusBlock,
                    VolumeInfo,
                    _CmdConsBlock->TemporaryBufferSize,
                    FileFsVolumeInformation
                    );

        if(NT_SUCCESS(Status)) {
            //
            // We can tell the user the volume label and serial number.
            //
            VolumeInfo->VolumeLabel[VolumeInfo->VolumeLabelLength/sizeof(WCHAR)] = 0;
            p = SpDupStringW(VolumeInfo->VolumeLabel);
            u = VolumeInfo->VolumeSerialNumber;

            RcMessageOut(
                *p ? MSG_DIR_BANNER1a : MSG_DIR_BANNER1b,
                RcToUpper(DosPath[0]),
                p
                );

            SpMemFree(p);

            RcMessageOut(MSG_DIR_BANNER2,u >> 16,u & 0xffff);
        }

        //
        // Get free space value for drive.
        //
        Status = ZwQueryVolumeInformationFile(
                    Handle,
                    &IoStatusBlock,
                    &SizeInfo,
                    sizeof(FILE_FS_SIZE_INFORMATION),
                    FileFsSizeInformation
                    );

        if(!NT_SUCCESS(Status)) {
            SizeInfo.BytesPerSector = 0;
        }
        
        //
        // Get the type of the file system so that we can handle
        // the file times properly (NT stores the date in UTC).
        //
        RtlZeroMemory(bfFSInfo, sizeof(bfFSInfo));
        pFSInfo = (PFILE_FS_ATTRIBUTE_INFORMATION) bfFSInfo;

        Status = ZwQueryVolumeInformationFile(
                        Handle, 
                        &IoStatusBlock,
                        pFSInfo,
                        sizeof(bfFSInfo),
                        FileFsAttributeInformation);
                        
        ZwClose(Handle);
    }

    //
    // Tell the user the full DOS path of the directory.
    //
    RcMessageOut(MSG_DIR_BANNER3,DosPath);

    //
    // Now go enumerate the directory.
    //
    RtlZeroMemory(&DirStats,sizeof(DIR_STATS));

    if (!NT_SUCCESS(Status)) {
        KdPrint(("SPCMDCON:Could not get volume information, Error Code:%lx\n", Status));
        DirStats.fsType = RcUnknown;  // assume FAT file system (by default)
    } else {
        if (!wcscmp(pFSInfo->FileSystemName, L"NTFS"))
            DirStats.fsType = RcNTFS;
        else if (!wcscmp(pFSInfo->FileSystemName, L"FAT"))
            DirStats.fsType = RcFAT;
        else if (!wcscmp(pFSInfo->FileSystemName, L"FAT32"))
            DirStats.fsType = RcFAT32;
        else if (!wcscmp(pFSInfo->FileSystemName, L"CDFS"))
            DirStats.fsType = RcCDFS;
        else
            DirStats.fsType = RcUnknown;
    }

    KdPrint(("SPCMDCON: RcCmdDir detected file system type (%lx)-%ws\n",
                    DirStats.fsType, pFSInfo ? pFSInfo->FileSystemName : L"None"));
    
    Status = RcEnumerateFiles(Dir,Path,pRcDirEnumProc,&DirStats);

    pRcDisableMoreMode();

    if(NT_SUCCESS(Status)) {

        RcFormat64BitIntForOutput(DirStats.TotalSize,_CmdConsBlock->TemporaryBuffer,FALSE);
        p = SpDupStringW(_CmdConsBlock->TemporaryBuffer);
        RcMessageOut(MSG_DIR_BANNER4,DirStats.FileCount,p);
        SpMemFree(p);
        if(SizeInfo.BytesPerSector) {
            RcFormat64BitIntForOutput(
                SizeInfo.AvailableAllocationUnits.QuadPart * (LONGLONG)SizeInfo.SectorsPerAllocationUnit * (LONGLONG)SizeInfo.BytesPerSector,
                _CmdConsBlock->TemporaryBuffer,
                FALSE
                );
            p = SpDupStringW(_CmdConsBlock->TemporaryBuffer);
            RcMessageOut(MSG_DIR_BANNER5,p);
            SpMemFree(p);
        }
    } else {
        RcNtError(Status,MSG_FILE_ENUM_ERROR);
    }

c2:
    SpMemFree(Path);
    SpMemFree(DosPath);
    return 1;
}


BOOLEAN
pRcDirEnumProc(
    IN  LPCWSTR                     Directory,
    IN  PFILE_BOTH_DIR_INFORMATION  FileInfo,
    OUT NTSTATUS                   *Status,
    IN  PDIR_STATS                  DirStats
    )
{
    WCHAR           LineOut[50];
    WCHAR           *p;
    NTSTATUS        timeStatus;
    LARGE_INTEGER   *pLastWriteTime = 0;
    LARGE_INTEGER   lastWriteTime;
    LARGE_INTEGER   timeBias;
    TIME_FIELDS     timeFields;
    TIME_ZONE_INFORMATION   timeZone;

    UNREFERENCED_PARAMETER(Directory);

    DirStats->FileCount++;
    DirStats->TotalSize += FileInfo->EndOfFile.QuadPart;
    lastWriteTime = FileInfo->LastWriteTime;

    // 
    // Convert the time into local time from UTC if the file
    // system is NTFS
    //       
    switch(DirStats->fsType) {
        case RcNTFS:
        case RcCDFS:
            // localtime = UTC - bias
            lastWriteTime.QuadPart -= glBias.QuadPart;       
            break;
        
        case RcFAT:
        case RcFAT32:
        default:
            break;
    }
       
    //
    // Format the date and time, which go first.
    //
    RcFormatDateTime(&lastWriteTime,LineOut);
    RcTextOut(LineOut);

    //
    // 2 spaces for separation
    //
    RcTextOut(L"  ");

    //
    // File attributes.
    //
    p = LineOut;
    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        *p++ = L'd';
    } else {
        *p++ = L'-';
    }
    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_ARCHIVE) {
        *p++ = L'a';
    } else {
        *p++ = L'-';
    }
    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_READONLY) {
        *p++ = L'r';
    } else {
        *p++ = L'-';
    }
    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_HIDDEN) {
        *p++ = L'h';
    } else {
        *p++ = L'-';
    }
    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_SYSTEM) {
        *p++ = L's';
    } else {
        *p++ = L'-';
    }
    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_COMPRESSED) {
        *p++ = L'c';
    } else {
        *p++ = L'-';
    }
    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
        *p++ = L'e';
    } else {
        *p++ = L'-';
    }
    if(FileInfo->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
        *p++ = L'p';
    } else {
        *p++ = L'-';
    }

    *p = 0;

    RcTextOut(LineOut);

    //
    // 2 spaces for separation
    //
    RcTextOut(L"  ");

    //
    // Now, put the size in there. Right justified and space padded
    // up to 8 chars. Oterwise unjustified or padded.
    //
    RcFormat64BitIntForOutput(FileInfo->EndOfFile.QuadPart,LineOut,TRUE);
    if(FileInfo->EndOfFile.QuadPart > 99999999i64) {
        RcTextOut(LineOut);
    } else {
        RcTextOut(LineOut+11);          // outputs 8 chars
    }

    RcTextOut(L" ");

    //
    // Finally, put the filename on the line. Need to 0-terminate it first.
    //
    wcsncpy(_CmdConsBlock->TemporaryBuffer,FileInfo->FileName,FileInfo->FileNameLength);
    ((WCHAR *)_CmdConsBlock->TemporaryBuffer)[FileInfo->FileNameLength] = 0;

    *Status = STATUS_SUCCESS;
    return((BOOLEAN)(RcTextOut(_CmdConsBlock->TemporaryBuffer) && RcTextOut(L"\r\n")));
}


NTSTATUS
RcEnumerateFiles(
    IN LPCWSTR      OriginalPathSpec,
    IN LPCWSTR      FullyQualifiedPathSpec,
    IN PENUMFILESCB Callback,
    IN PVOID        CallerData
    )
{
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    BOOLEAN b;
    WCHAR *p;
    WCHAR *LastComponent = NULL;
    PFILE_BOTH_DIR_INFORMATION      DirectoryInfo;
    unsigned u;
    WCHAR *NameChar;
    BOOLEAN EndsInDot;
    WCHAR *DirectoryPart;

    //
    // Determine whether the original path spec ends with a .
    // This is used below to get around a problem with specifying
    // *. as a search specifier.
    //
    u = wcslen(OriginalPathSpec);
    if(u && (OriginalPathSpec[u-1] == L'.')) {
        EndsInDot = TRUE;
    } else {
        EndsInDot = FALSE;
    }

    //
    // Determine whether the given path points at a directory.
    // If so, we'll concatenate \* on the end and fall through
    // to the common case.
    //
    b = FALSE;

    INIT_OBJA(&Obja,&UnicodeString,FullyQualifiedPathSpec);

    Status = ZwOpenFile(
                &Handle,
                FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE
                );

    if(NT_SUCCESS(Status)) {
        ZwClose(Handle);
        b = TRUE;
    }

    if(b) {
        //
        // Directory, append \*.
        //
        p = SpMemAlloc((wcslen(FullyQualifiedPathSpec)+3)*sizeof(WCHAR));

        if (p) {
            wcscpy(p,FullyQualifiedPathSpec);
            SpConcatenatePaths(p,L"*");
            EndsInDot = FALSE;
        }            
    } else {
        //
        // Not directory, pass as-is. Note that this could be an actual
        // file, or a wild-card spec.
        //
        p = SpDupStringW((PVOID)FullyQualifiedPathSpec);
    }

    //
    // Now trim back the path/file specification so we can open the containing
    // directory for enumeration.
    //
    if (p) {
        LastComponent = wcsrchr(p,L'\\');
    } else {
        return STATUS_NO_MEMORY;
    }

    if (LastComponent) {
        *LastComponent++ = 0;
    }
    
    DirectoryPart = SpMemAlloc((wcslen(p)+2)*sizeof(WCHAR));
    wcscpy(DirectoryPart,p);
    wcscat(DirectoryPart,L"\\");
    INIT_OBJA(&Obja,&UnicodeString,p);

    if (LastComponent) {
        LastComponent[-1] = L'\\';
    }
    
    UnicodeString.Length += sizeof(WCHAR);

    Status = ZwOpenFile(
                &Handle,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if(!NT_SUCCESS(Status)) {
        SpMemFree(p);
        SpMemFree(DirectoryPart);
        return(Status);
    }

    RtlInitUnicodeString(&UnicodeString,LastComponent);

    //
    // The following code is adapted from the implementation for
    // the FindFirstFile Win32 API, and provides additional DOS-like
    // wildcard matching semantics.
    //
    // Special case *.* to * since it is so common. Otherwise transmogrify
    // the input name according to the following rules:
    //
    // - Change all ? to DOS_QM
    // - Change all . followed by ? or * to DOS_DOT
    // - Change all * followed by a . into DOS_STAR
    //
    // These transmogrifications are all done in place.
    //
    if(!wcscmp(LastComponent,L"*.*")) {

        UnicodeString.Length = sizeof(WCHAR);       // trim down to just *

    } else {

        for(u=0, NameChar=UnicodeString.Buffer;
            u < (UnicodeString.Length/sizeof(WCHAR));
            u++, NameChar++) {

            if(u && (*NameChar == L'.') && (*(NameChar - 1) == L'*')) {

                *(NameChar-1) = DOS_STAR;
            }

            if((*NameChar == L'?') || (*NameChar == L'*')) {

                if(*NameChar == L'?') {
                    *NameChar = DOS_QM;
                }

                if(u && (*(NameChar-1) == L'.')) {
                    *(NameChar-1) = DOS_DOT;
                }
            }
        }

        if(EndsInDot && (*(NameChar - 1) == L'*')) {
            *(NameChar-1) = DOS_STAR;
        }
    }
       
    //
    // Finally, iterate the directory.
    //

    #define DIRINFO_BUFFER_SIZE ((2*MAX_PATH) + sizeof(FILE_BOTH_DIR_INFORMATION))
    DirectoryInfo = SpMemAlloc(DIRINFO_BUFFER_SIZE);

    b = TRUE;

    while(TRUE) {
        Status = ZwQueryDirectoryFile(
                    Handle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    DirectoryInfo,
                    DIRINFO_BUFFER_SIZE,
                    FileBothDirectoryInformation,
                    TRUE,
                    &UnicodeString,
                    b
                    );

        b = FALSE;

        //
        // Check termination condition
        //
        if(Status == STATUS_NO_MORE_FILES) {
            Status = STATUS_SUCCESS;
            break;
        }

        if(!NT_SUCCESS(Status)) {
            break;
        }

        //
        // OK, nul-terminate filename and pass info to callback.
        //
        DirectoryInfo->FileName[DirectoryInfo->FileNameLength/sizeof(WCHAR)] = 0;
        if(!Callback(DirectoryPart,DirectoryInfo,&Status,CallerData)) {
            break;
        }
    }

    ZwClose(Handle);
    SpMemFree(DirectoryPart);
    SpMemFree(DirectoryInfo);
    SpMemFree(p);
    return(Status);
}


VOID
RcFormat64BitIntForOutput(
    IN  LONGLONG n,
    OUT LPWSTR   Output,
    IN  BOOLEAN  RightJustify
    )
{
    WCHAR *p;
    LONGLONG d;
    BOOLEAN b;
    WCHAR c;

    //
    // Max signed 64-bit integer is 9223372036854775807 (19 digits).
    // The result will be space padded to the left so it's right-justified
    // if that flag is set. Otherwise it's just a plain 0-terminated string.
    //
    p = Output;
    d = 1000000000000000000i64;
    b = FALSE;
    do {
        c = (WCHAR)((n / d) % 10) + L'0';
        if(c == L'0') {
            if(!b && (d != 1)) {
                c = RightJustify ? L' ' : 0;
            }
        } else {
            b = TRUE;
        }
        if(c) {
            *p++ = c;
        }
    } while(d /= 10);
    *p = 0;
}

//
// This time conversion APIs should be moved to setupdd.sys 
// if more modules need this
//
NTSTATUS
SpSystemTimeToLocalTime (
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER LocalTime
    )
{
    NTSTATUS Status;
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfDay;

    Status = ZwQuerySystemInformation(
                SystemTimeOfDayInformation,
                &TimeOfDay,
                sizeof(TimeOfDay),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return Status;
        }

    //
    // LocalTime = SystemTime - TimeZoneBias
    //
    LocalTime->QuadPart = SystemTime->QuadPart - 
                TimeOfDay.TimeZoneBias.QuadPart;

    return STATUS_SUCCESS;
}

//
// This time conversion APIs should be moved to setupdd.sys 
// if more modules need this
//
NTSTATUS
SpLocalTimeToSystemTime (
    IN PLARGE_INTEGER LocalTime,
    OUT PLARGE_INTEGER SystemTime
    )
{

    NTSTATUS Status;
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfDay;

    Status = ZwQuerySystemInformation(
                SystemTimeOfDayInformation,
                &TimeOfDay,
                sizeof(TimeOfDay),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return Status;
        }

    //
    // SystemTime = LocalTime + TimeZoneBias
    //
    SystemTime->QuadPart = LocalTime->QuadPart + 
                TimeOfDay.TimeZoneBias.QuadPart;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\cmdcons\help.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    help.c

Abstract:

    This module implements the help system.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop



BOOLEAN
RcCmdParseHelp(
    IN PTOKENIZED_LINE TokenizedLine,
    ULONG MsgId
    )
{
    BOOL            doHelp = FALSE;
    PLINE_TOKEN     Token;
    LPCWSTR         Arg;


    if (TokenizedLine == NULL || TokenizedLine->Tokens == NULL ||
        TokenizedLine->Tokens->Next == NULL)
    {
        return FALSE;
    }

    // check for help
    Token = TokenizedLine->Tokens->Next;
    while(Token) {
        Arg = Token->String;
        if ((Arg[0] == L'/' || Arg[0] == L'-') && (Arg[1] == L'?' || Arg[1] == L'h' || Arg[1] == L'H')) {
            doHelp = TRUE;
            break;
        }
        Token = Token->Next;
    }

    if (doHelp) {
        RcMessageOut( MsgId );
        return TRUE;
    }

    return FALSE;
}

ULONG
RcCmdHelpHelp(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    RcMessageOut( MSG_HELPCOMMAND_HELP );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\cmdcons\extprog.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    extprog.c

Abstract:

    This module implements all commands that
    execute external programs.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop


#define FLG_GOT_P       0x00000100
#define FLG_GOT_R       0x00000200
#define FLG_DRIVE_MASK  0x000000ff

#define FLG_GOT_Q       0x00000100
#define FLG_GOT_FS      0x00000200
#define FLG_GOT_FAT     0x10000000
#define FLG_GOT_FAT32   0x20000000
#define FLG_GOT_NTFS    0x40000000

LPCWSTR szAutochkExe = L"AUTOCHK.EXE";
LPCWSTR szAutofmtExe = L"AUTOFMT.EXE";

BOOLEAN SawInterimMsgs;
ULONG ChkdskMessageId;

VOID
SpPtDetermineRegionSpace(
    IN PDISK_REGION pRegion
    );

LPWSTR
pRcDoesFileExist(
    IN LPCWSTR PathPart1,
    IN LPCWSTR PathPart2,   OPTIONAL
    IN LPCWSTR PathPart3    OPTIONAL
    );

NTSTATUS
pRcAutochkProgressHandler(
    IN PSETUP_FMIFS_MESSAGE Message
    );



PWSTR
RcLocateImage(
    IN PWSTR ImageName
    )
{
    LPWSTR BinaryName;
    ULONG i;
    WCHAR buf[ MAX_PATH + 1 ];
    LPWSTR p,s;
    NTSTATUS Status;


    //
    // Locate the binary. First see if we can find it
    // on the setup boot media (boot floppies, ~bt directory, etc).
    // If not, we have to try to grab it from the setup media (CD-ROM,
    // ~ls directory, etc).
    //
    BinaryName = pRcDoesFileExist(
        _CmdConsBlock->BootDevicePath,
        _CmdConsBlock->DirectoryOnBootDevice,
        ImageName
        );
    if (BinaryName) {
        return BinaryName;
    }

    //
    // look for a local $WIN_NT$.~LS source
    //

    for (i=0; i<26; i++) {
        swprintf( buf, L"\\??\\%c:",i+L'A');
        if (RcIsFileOnRemovableMedia(buf) != STATUS_SUCCESS) {
            BinaryName = pRcDoesFileExist(
                buf,
                ((!IsNEC_98) ? L"\\$win_nt$.~ls\\i386\\" : L"\\$win_nt$.~ls\\nec98\\"),
                ImageName
                );
            if (BinaryName) {
                return BinaryName;
            }
        }
    }

    if (BinaryName == NULL) {
        //
        // look for the CDROM drive letter
        //
        for (i=0; i<26; i++) {
            swprintf( buf, L"\\??\\%c:",i+L'A');
            if (RcIsFileOnCDROM(buf) == STATUS_SUCCESS) {
                BinaryName = pRcDoesFileExist(
                    buf,
                    ((!IsNEC_98) ? L"\\i386\\" : L"\\nec98\\"),
                    ImageName
                    );
                if (BinaryName) {
                    return BinaryName;
                }
            }
        }
    }

    //
    // failed to find the image on any installation media
    //

    if (InBatchMode) {
        RcMessageOut( MSG_FAILED_COULDNT_FIND_BINARY_ANYWHERE, ImageName );
        return NULL;
    }

    //
    // ask the user to type its location
    //
    RcMessageOut( MSG_COULDNT_FIND_BINARY, ImageName );

    //
    // prepend \\??\\ to it
    //
    swprintf( buf, L"\\??\\");
    RcLineIn( &(buf[4]), MAX_PATH-4 );

    //
    // append the name of the program if it exists
    //
    BinaryName = pRcDoesFileExist( buf, NULL, ImageName );
    if (BinaryName == NULL) {
        //
        // assume that if it failed, the user just specified the entire file path
        //
        BinaryName = pRcDoesFileExist( buf, NULL, NULL );
        //
        // if we still can't find it, print an error, return.
        //
        if (BinaryName == NULL) {
            RcMessageOut( MSG_FAILED_COULDNT_FIND_BINARY_ANYWHERE, ImageName );
            return NULL;
        }
    }

    return BinaryName;
}


ULONG
RcCmdChkdsk(
    IN PTOKENIZED_LINE TokenizedLine
    )

/*++

Routine Description:

    Top-level routine supporting the chkdsk command in the setup diagnostic
    command interpreter.

    Chkdsk may be specified entirely without arguments, in which case the
    current drive is implied with no switches. Optionally, the following
    switches are accepted, and passed directly to autochk.

    /p - check even if not dirty
    /r - recover (implies /p)
    x: - drive letter of drive to check

    In addition we always pass /t which causes autochk to call setup's
    IOCTL_SETUP_FMIFS_MESSAGE to communicate progress.

Arguments:

    TokenizedLine - supplies structure built by the line parser describing
        each string on the line as typed by the user.

Return Value:

    None.

--*/

{
    PLINE_TOKEN Token;
    LPCWSTR Arg;
    unsigned Flags;
    BOOLEAN b;
    BOOLEAN doHelp;
    LPWSTR ArgList,p,q,s,AutochkBinary;
    ULONG AutochkStatus;
    ULONG i;
    NTSTATUS Status = 0;
    UNICODE_STRING UnicodeString;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES Obja;
    ULONG n;
    LARGE_INTEGER Time;
    PFILE_FS_VOLUME_INFORMATION VolumeInfo;
    PFILE_FS_SIZE_INFORMATION SizeInfo;
    LPWSTR Numbers[5];
    WCHAR buf[ MAX_PATH + 1 ];

    //
    // There should be at least one token for CHKDSK itself.
    // There could be additional ones for arguments.
    //
    ASSERT(TokenizedLine->TokenCount >= 1);

    if (RcCmdParseHelp( TokenizedLine, MSG_CHKDSK_HELP )) {
        return 1;
    }

    Flags = 0;
    b = TRUE;
    doHelp = FALSE;
    Token = TokenizedLine->Tokens->Next;
    while(b && Token) {

        Arg = Token->String;

        if((Arg[0] == L'-') || (Arg[0] == L'/')) {
            switch(Arg[1]) {

            case L'p':
            case L'P':
                if(Flags & FLG_GOT_P) {
                    b = FALSE;
                } else {
                    Flags |= FLG_GOT_P;
                }
                break;

            case L'r':
            case L'R':
                if(Flags & FLG_GOT_R) {
                    b = FALSE;
                } else {
                    Flags |= FLG_GOT_R;
                }
                break;
            default:
                b = FALSE;
                break;
            }
        } else {
            //
            // Not arg, could be drive spec
            //
            if(RcIsAlpha(Arg[0]) && (Arg[1] == L':') && !Arg[2]) {
                if(Flags & FLG_DRIVE_MASK) {
                    b = FALSE;
                } else {
                    Flags |= (unsigned)RcToUpper(Arg[0]);
                }
            } else {
                b = FALSE;
            }
        }

        Token = Token->Next;
    }

    if(!b) {
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }

    //
    // Check drive.
    //
    if(!(Flags & FLG_DRIVE_MASK)) {
        Flags |= (unsigned)RcGetCurrentDriveLetter();
    }
    if(!RcIsDriveApparentlyValid((WCHAR)(Flags & FLG_DRIVE_MASK))) {
        RcMessageOut(MSG_INVALID_DRIVE);
        return 1;
    }

    //
    // find the autochk.exe image
    //

    AutochkBinary = RcLocateImage( (PWSTR)szAutochkExe );
    if (AutochkBinary == NULL) {
        return 1;
    }

    //
    // Get volume info and print initial report.
    // NOTE: we do NOT leave the handle open, even though we may need it
    // later, since that could interfere with autochk's ability to
    // check the disk!
    //
    p = SpMemAlloc(100);
    swprintf(p,L"\\DosDevices\\%c:\\",(WCHAR)(Flags & FLG_DRIVE_MASK));
    INIT_OBJA(&Obja,&UnicodeString,p);

    Status = ZwOpenFile(
                &Handle,
                FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE
                );

    SpMemFree(p);

    if(NT_SUCCESS(Status)) {

        VolumeInfo = _CmdConsBlock->TemporaryBuffer;

        Status = ZwQueryVolumeInformationFile(
                    Handle,
                    &IoStatusBlock,
                    VolumeInfo,
                    _CmdConsBlock->TemporaryBufferSize,
                    FileFsVolumeInformation
                    );

        ZwClose(Handle);

        if(NT_SUCCESS(Status)) {
            //
            // To mimic chkdsk running from cmd.exe, we want to print out
            // a nice 2 lines like
            //
            //      Volume VOLUME_LABEL created DATE TIME
            //      Volume Serial Number is xxxx-xxxx
            //
            // But, some volumes won't have labels and some file systems
            // don't support recording the volume creation time. If there's
            // no volume creation time, we don't print out the first time
            // at all. If there is a volume creation time, we are careful
            // to distinguish the cases where there's a label and where
            // there's no label.
            //
            // The serial number is always printed.
            //
            n = VolumeInfo->VolumeSerialNumber;
            if(Time.QuadPart = VolumeInfo->VolumeCreationTime.QuadPart) {
                //
                // Save values since we need to recycle the temporary buffer.
                //
                VolumeInfo->VolumeLabel[VolumeInfo->VolumeLabelLength/sizeof(WCHAR)] = 0;
                p = SpDupStringW(VolumeInfo->VolumeLabel);

                RcFormatDateTime(&Time,_CmdConsBlock->TemporaryBuffer);
                q = SpDupStringW(_CmdConsBlock->TemporaryBuffer);

                RcMessageOut(
                    *p ? MSG_CHKDSK_REPORT_1a : MSG_CHKDSK_REPORT_1b,
                    q,
                    p
                    );

                SpMemFree(q);
                SpMemFree(p);
            }

            RcMessageOut(MSG_CHKDSK_REPORT_2,n >> 16,n & 0xffff);
        }
    }

    //
    // Build argument list.
    //
    ArgList = SpMemAlloc(200);
    p = ArgList;
    *p++ = L'-';
    *p++ = L't';
    if(Flags & FLG_GOT_P) {
        *p++ = L' ';
        *p++ = L'-';
        *p++ = L'p';
    }
    if(Flags & FLG_GOT_R) {
        *p++ = L' ';
        *p++ = L'-';
        *p++ = L'r';
    }
    *p++ = L' ';
    wcscpy(p,L"\\DosDevices\\");
    p += wcslen(p);
    *p++ = (WCHAR)(Flags & FLG_DRIVE_MASK);
    *p++ = L':';
    *p = 0;

    if (!InBatchMode) {
        SpSetAutochkCallback(pRcAutochkProgressHandler);
        SawInterimMsgs = FALSE;
        ChkdskMessageId = MSG_CHKDSK_CHECKING_1;
    }
    Status = SpExecuteImage(AutochkBinary,&AutochkStatus,1,ArgList);
    if (!InBatchMode) {
        SpSetAutochkCallback(NULL);
    }

    if(NT_SUCCESS(Status)) {

        switch(AutochkStatus) {

        case 0:     // success

            if(SawInterimMsgs) {
                //
                // Success, and chkdsk actually ran.
                //
                RcMessageOut(MSG_CHKDSK_COMPLETE);
            } else {
                //
                // Success, but it doesn't seem like we actually did much.
                // Tell the user something meaningful.
                //
                RcMessageOut(MSG_VOLUME_CLEAN);
            }
            break;

        case 3:     // serious error, not fixed

            RcTextOut(L"\n");
            RcMessageOut(MSG_VOLUME_CHECKED_BUT_HOSED);
            break;

        default:    // errs fixed, also happens when no disk in drive or unsupported fs

            if(SawInterimMsgs) {
                if(Flags & FLG_GOT_R) {
                    RcMessageOut(MSG_VOLUME_CHECKED_AND_FIXED);
                } else {
                    RcMessageOut(MSG_VOLUME_CHECKED_AND_FOUND);
                }
            } else {
                RcMessageOut(MSG_CHKDSK_UNSUPPORTED_VOLUME);
            }
            break;
        }

        //
        // Get size info for additional reporting
        //
        p = SpMemAlloc(100);
        swprintf(p,L"\\DosDevices\\%c:\\",(WCHAR)(Flags & FLG_DRIVE_MASK));
        INIT_OBJA(&Obja,&UnicodeString,p);

        Status = ZwOpenFile(
                    &Handle,
                    FILE_READ_ATTRIBUTES,
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_DIRECTORY_FILE
                    );

        SpMemFree(p);

        if(NT_SUCCESS(Status)) {

            SizeInfo = _CmdConsBlock->TemporaryBuffer;

            Status = ZwQueryVolumeInformationFile(
                        Handle,
                        &IoStatusBlock,
                        SizeInfo,
                        _CmdConsBlock->TemporaryBufferSize,
                        FileFsSizeInformation
                        );

            ZwClose(Handle);

            if(NT_SUCCESS(Status)) {

                p = (LPWSTR)((UCHAR *)_CmdConsBlock->TemporaryBuffer + sizeof(FILE_FS_SIZE_INFORMATION));

                //
                // Total disk space, in K
                //
                RcFormat64BitIntForOutput(
                    ((SizeInfo->TotalAllocationUnits.QuadPart * SizeInfo->SectorsPerAllocationUnit) * SizeInfo->BytesPerSector) / 1024i64,
                    p,
                    FALSE
                    );

                Numbers[0] = SpDupStringW(p);

                //
                // Available disk space, in K
                //
                RcFormat64BitIntForOutput(
                    ((SizeInfo->AvailableAllocationUnits.QuadPart * SizeInfo->SectorsPerAllocationUnit) * SizeInfo->BytesPerSector) / 1024i64,
                    p,
                    FALSE
                    );

                Numbers[1] = SpDupStringW(p);

                //
                // Bytes per cluster
                //
                RcFormat64BitIntForOutput(
                    (LONGLONG)SizeInfo->SectorsPerAllocationUnit * (LONGLONG)SizeInfo->BytesPerSector,
                    p,
                    FALSE
                    );

                Numbers[2] = SpDupStringW(p);

                //
                // Total clusters
                //
                RcFormat64BitIntForOutput(
                    SizeInfo->TotalAllocationUnits.QuadPart,
                    p,
                    FALSE
                    );

                Numbers[3] = SpDupStringW(p);

                //
                // Available clusters
                //
                RcFormat64BitIntForOutput(
                    SizeInfo->AvailableAllocationUnits.QuadPart,
                    p,
                    FALSE
                    );

                Numbers[4] = SpDupStringW(p);

                RcMessageOut(
                    MSG_CHKDSK_REPORT_3,
                    Numbers[0],
                    Numbers[1],
                    Numbers[2],
                    Numbers[3],
                    Numbers[4]
                    );

                for(n=0; n<5; n++) {
                    SpMemFree(Numbers[n]);
                }
            }
        }
    } else {
        RcNtError(Status,MSG_VOLUME_NOT_CHECKED);
    }

    SpMemFree(ArgList);
    SpMemFree(AutochkBinary);

    return 1;
}


LPWSTR
pRcDoesFileExist(
    IN LPCWSTR PathPart1,
    IN LPCWSTR PathPart2,   OPTIONAL
    IN LPCWSTR PathPart3    OPTIONAL
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    LPWSTR p;

    wcscpy(_CmdConsBlock->TemporaryBuffer,PathPart1);
    if(PathPart2) {
        SpConcatenatePaths(_CmdConsBlock->TemporaryBuffer,PathPart2);
    }
    if(PathPart3) {
        SpConcatenatePaths(_CmdConsBlock->TemporaryBuffer,PathPart3);
    }

    INIT_OBJA(&Obja,&UnicodeString,_CmdConsBlock->TemporaryBuffer);

    Status = ZwOpenFile(
                &Handle,
                FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_NON_DIRECTORY_FILE
                );

    if(NT_SUCCESS(Status)) {
        ZwClose(Handle);
        p = SpDupStringW(_CmdConsBlock->TemporaryBuffer);
    } else {
        p = NULL;
    }

    return(p);
}


NTSTATUS
pRcAutochkProgressHandler(
    IN PSETUP_FMIFS_MESSAGE Message
    )
{
    ULONG Percent;

    //
    // We're getting called in the context of a process other than usetup.exe,
    // which means we have no access to things like the video buffer.
    // In some cases we need to attach to usetup.exe so the right thing happens
    // if we try to access the screen or get keyboard input, etc.
    //

    switch(Message->FmifsPacketType) {

    case FmIfsPercentCompleted:

        //
        // The packet is in user-mode address space, so we need to pull out
        // the percent complete value before attaching to usetup.exe.
        //
        // The bandwidth for communication between autochk and us is very
        // limited. If the drive is clean and is thus not checked, we'll see
        // only a 100% complete message. Thus we have to guess what happened
        // so we can print out something meaningful to the user if the volume
        // appears clean.
        //
        Percent = ((PFMIFS_PERCENT_COMPLETE_INFORMATION)Message->FmifsPacket)->PercentCompleted;
        if(Percent == 100) {
            //
            // Avoid printing 100% if we didn't actually do anything.
            //
            if(!SawInterimMsgs) {
                break;
            }
        } else {
            SawInterimMsgs = TRUE;
        }

        KeAttachProcess(PEProcessToPKProcess(_CmdConsBlock->UsetupProcess));

        if(!Percent) {
            RcMessageOut(ChkdskMessageId);
            ChkdskMessageId = MSG_CHKDSK_CHECKING_2;
        }

        RcMessageOut(MSG_VOLUME_PERCENT_COMPLETE,Percent);
        RcTextOut(L"\r");
        KeDetachProcess();

        break;

    default:

        KdPrint(("SPCMDCON: Unhandled fmifs message type %u\r\n",Message->FmifsPacketType));
        break;
    }

    return(STATUS_SUCCESS);
}


ULONG
RcCmdFormat(
    IN PTOKENIZED_LINE TokenizedLine
    )

/*++

Routine Description:

    Top-level routine supporting the chkdsk command in the setup diagnostic
    command interpreter.

    Chkdsk may be specified entirely without arguments, in which case the
    current drive is implied with no switches. Optionally, the following
    switches are accepted, and passed directly to autochk.

    /p - check even if not dirty
    /r - recover (implies /p)
    x: - drive letter of drive to check

    In addition we always pass /t which causes autochk to call setup's
    IOCTL_SETUP_FMIFS_MESSAGE to communicate progress.

Arguments:

    TokenizedLine - supplies structure built by the line parser describing
        each string on the line as typed by the user.

Return Value:

    None.

--*/

{
    PLINE_TOKEN Token;
    LPCWSTR Arg;
    unsigned Flags;
    BOOLEAN b;
    BOOLEAN doHelp;
    LPWSTR ArgList,p,q,s,AutofmtBinary;
    ULONG AutofmtStatus;
    ULONG i;
    NTSTATUS Status = 0;
    UNICODE_STRING UnicodeString;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES Obja;
    ULONG n;
    LARGE_INTEGER Time;
    PFILE_FS_VOLUME_INFORMATION VolumeInfo;
    PFILE_FS_SIZE_INFORMATION SizeInfo;
    LPWSTR Numbers[5];
    WCHAR buf[ MAX_PATH + 1 ];
    ULONG PartitionOrdinal = 0;
    PDISK_REGION PartitionRegion;
    PWSTR PartitionPath;
    FilesystemType FileSystemType;
    WCHAR   FullPath[MAX_PATH] = {0};
    
    //
    // There should be at least one token for FORMAT itself.
    // There could be additional ones for arguments.
    //
    ASSERT(TokenizedLine->TokenCount >= 1);

    if (RcCmdParseHelp( TokenizedLine, MSG_FORMAT_HELP )) {
        return 1;
    }

    Flags = 0;
    b = TRUE;
    doHelp = FALSE;
    Token = TokenizedLine->Tokens->Next;
    while(b && Token) {

        Arg = Token->String;

        if((Arg[0] == L'-') || (Arg[0] == L'/')) {
            switch(Arg[1]) {

            case L'q':
            case L'Q':
                if(Flags & FLG_GOT_Q) {
                    b = FALSE;
                } else {
                    Flags |= FLG_GOT_Q;
                }
                break;

            case L'f':
            case L'F':
                if (Arg[2] == L's' || Arg[2] == L'S' || Arg[3] == L':') {
                    if(Flags & FLG_GOT_FS) {
                        b = FALSE;
                    } else {
                        s = wcschr(Arg,L' ');
                        if (s) {
                            *s = 0;
                        }
                        if (_wcsicmp(&Arg[4],L"fat") == 0) {
                            Flags |= FLG_GOT_FS;
                            Flags |= FLG_GOT_FAT;
                        } else if (_wcsicmp(&Arg[4],L"fat32") == 0) {
                            Flags |= FLG_GOT_FS;
                            Flags |= FLG_GOT_FAT32;
                        } else if (_wcsicmp(&Arg[4],L"ntfs") == 0) {
                            Flags |= FLG_GOT_FS;
                            Flags |= FLG_GOT_NTFS;
                        } else {
                            b = FALSE;
                        }
                    }
                } else {
                    b = FALSE;
                }
                break;
            default:
                b = FALSE;
                break;
            }
        } else {
            //
            // Not arg, could be drive spec
            //
            if(RcIsAlpha(Arg[0]) && (Arg[1] == L':') && !Arg[2]) {
                if(Flags & FLG_DRIVE_MASK) {
                    b = FALSE;
                } else {
                    Flags |= (unsigned)RcToUpper(Arg[0]);
                }
            } else if (Arg[0] == L'\\') {
                wcscpy(FullPath, Arg);
            } else {
                b = FALSE;
            }
        }

        Token = Token->Next;
    }

    if(!b) {
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }

    //
    // Check drive.
    //
    if (FullPath[0] == UNICODE_NULL) {
        if(!(Flags & FLG_DRIVE_MASK)) {
            RcMessageOut(MSG_INVALID_DRIVE);
            return 1;
        }
        
        if(!RcIsDriveApparentlyValid((WCHAR)(Flags & FLG_DRIVE_MASK))) {
            RcMessageOut(MSG_INVALID_DRIVE);
            return 1;
        }
    }        

    //
    // we don't allow formatting removable media
    //
    if (FullPath[0] == UNICODE_NULL) {
        swprintf(TemporaryBuffer, L"\\??\\%c:",(WCHAR)(Flags & FLG_DRIVE_MASK));        
    } else {
        wcscpy(TemporaryBuffer, FullPath);
    }
    
    if (RcIsFileOnRemovableMedia(TemporaryBuffer) == STATUS_SUCCESS) {
        RcMessageOut(MSG_CANNOT_FORMAT_REMOVABLE);
        return 1;
    }

    //
    // Locate the autofmt.exe binary
    //

    AutofmtBinary = RcLocateImage( (PWSTR)szAutofmtExe );
    if (AutofmtBinary == NULL) {
        return 1;
    }

    if (!InBatchMode) {
        LPWSTR YesNo;
        WCHAR Text[3];
        YesNo = SpRetreiveMessageText( ImageBase, MSG_YESNO, NULL, 0 );
        if( YesNo ) {
            p = TemporaryBuffer;
            *p++ = (WCHAR)(Flags & FLG_DRIVE_MASK);
            *p++ = L':';
            *p = 0;
            RcMessageOut( MSG_FORMAT_HEADER, TemporaryBuffer );
            if( RcLineIn( Text, 2 ) ) {
                if( (Text[0] == YesNo[2]) || (Text[0] == YesNo[3]) ) {
                    //
                    // the answer was no
                    //
                    return 1;
                }
            }
            SpMemFree( YesNo );
        }
    }

    //
    // get the partion region
    //
    if (FullPath[0] == UNICODE_NULL) {
        p = TemporaryBuffer;
        *p++ = (WCHAR)(Flags & FLG_DRIVE_MASK);
        *p++ = L':';
        *p = 0;
        PartitionRegion = SpRegionFromDosName(TemporaryBuffer);

        //
        // Make SURE it's not partition0!  The results of formatting partition0
        // are so disasterous that this warrants a special check.
        //
        PartitionOrdinal = SpPtGetOrdinal(PartitionRegion,PartitionOrdinalCurrent);

        //
        // Get the device path of the partition to format
        //
        SpNtNameFromRegion(
            PartitionRegion,
            TemporaryBuffer,
            sizeof(TemporaryBuffer),
            PartitionOrdinalCurrent
            );
    } else {
        PartitionRegion = SpRegionFromNtName(FullPath, PartitionOrdinalCurrent);

        if (PartitionRegion) {            
            PartitionOrdinal = SpPtGetOrdinal(PartitionRegion, PartitionOrdinalCurrent);
        } else {
            PartitionOrdinal = 0;   // will err out below
        }            
        
        wcscpy(TemporaryBuffer, FullPath);
    }

    if(!PartitionOrdinal) {
        RcMessageOut(MSG_SYNTAX_ERROR);
        
        return 1;
    }

    //
    // Build argument list.
    //
    ArgList = SpMemAlloc(4096);
    p = ArgList;
    wcscpy(p,TemporaryBuffer);

    
    p += wcslen(p);
    *p++ = L' ';
    *p++ = L'-';
    *p++ = L't';
    *p++ = L' ';
    if(Flags & FLG_GOT_Q) {
        *p++ = L'-';
        *p++ = L'Q';
        *p++ = L' ';
    }
    if(Flags & FLG_GOT_FS) {
        if (Flags & FLG_GOT_FAT) {
            wcscpy(p,L"/fs:fat ");
            FileSystemType = FilesystemFat;
        } else if (Flags & FLG_GOT_FAT32) {
            wcscpy(p,L"/fs:fat32 ");
            FileSystemType = FilesystemFat32;
        } else if (Flags & FLG_GOT_NTFS) {
            wcscpy(p,L"/fs:ntfs ");
            FileSystemType = FilesystemNtfs;
        }
        p += wcslen(p);
    } else {
        FileSystemType = FilesystemNtfs;
        wcscpy(p,L"/fs:ntfs ");
        p += wcslen(p);
    }
    *p = 0;

    if (!InBatchMode) {
        SpSetAutochkCallback(pRcAutochkProgressHandler);
        SawInterimMsgs = FALSE;
        ChkdskMessageId = MSG_FORMAT_FORMATTING_1;
    }
    Status = SpExecuteImage(AutofmtBinary,&AutofmtStatus,1,ArgList);
    if (!InBatchMode) {
        SpSetAutochkCallback(NULL);
    }

    if(!NT_SUCCESS(Status)) {
        RcNtError(Status,MSG_VOLUME_NOT_FORMATTED);
    } else {
        PartitionRegion->Filesystem = FileSystemType;
        SpFormatMessage( PartitionRegion->TypeName,
                         sizeof(PartitionRegion->TypeName),
                         SP_TEXT_FS_NAME_BASE + PartitionRegion->Filesystem );
        //
        //  Reset the volume label
        //
        PartitionRegion->VolumeLabel[0] = L'\0';
        SpPtDetermineRegionSpace( PartitionRegion );        
    }

    SpMemFree(ArgList);
    SpMemFree(AutofmtBinary);

    return 1;
}


typedef struct _FDISK_REGION {
    PWSTR DeviceName;
    PDISK_REGION Region;
    ULONGLONG MaxSize;
    ULONGLONG RequiredSize;
} FDISK_REGION, *PFDISK_REGION;


BOOL
RcFdiskRegionEnum(
    IN PPARTITIONED_DISK Disk,
    IN PDISK_REGION Region,
    IN ULONG_PTR Context
    )
{
    WCHAR DeviceName[256];
    PWSTR s;
    PFDISK_REGION FDiskRegion = (PFDISK_REGION)Context;
    ULONGLONG RegionSizeMB;

    //
    // skip container partitions & continue on
    //
    if (Region && (Region->ExtendedType == EPTContainerPartition)) {
        return TRUE; 
    }
    
    SpNtNameFromRegion(Region,
        DeviceName,
        sizeof(DeviceName),
        PartitionOrdinalCurrent);
        
    s = wcsrchr(DeviceName,L'\\');
    
    if (s == NULL) {
        return TRUE;
    }

    *s = 0;

    RegionSizeMB = SpPtSectorCountToMB(Disk->HardDisk, Region->SectorCount);

    if ((RegionSizeMB > FDiskRegion->MaxSize) &&
        (RegionSizeMB >= FDiskRegion->RequiredSize) &&
        (Region->PartitionedSpace == FALSE) &&
        (_wcsicmp(DeviceName, FDiskRegion->DeviceName) == 0)){
        
        FDiskRegion->MaxSize = RegionSizeMB;
        FDiskRegion->Region = Region;

        //
        // This partition meets the criteria we were searching for,
        // return FALSE to stop the enumeration
        //

        return FALSE;
    }

    //
    // This partition does not meet the criteria, return TRUE to continue
    // the enumeration.
    //

    return TRUE;
}


ULONG
RcCmdFdisk(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    NTSTATUS        Status;
    PDISK_REGION    InstallRegion;
    PDISK_REGION    SystemPartitionRegion;
    PWCHAR          DeviceName;
    PWCHAR          Action;
    PWCHAR          Operand;
    ULONG           DesiredMB;
    FDISK_REGION    FDiskRegion;
    UNICODE_STRING  UnicodeString;
    PWCHAR          szPartitionSize = 0;
    BOOLEAN         bPrompt = TRUE;

    if (RcCmdParseHelp( TokenizedLine, MSG_FDISK_HELP )) {
        return 1;
    }

    if (TokenizedLine->TokenCount >= 3) {
        Action = TokenizedLine->Tokens->Next->String;
        DeviceName = TokenizedLine->Tokens->Next->Next->String;

        if (_wcsicmp(Action,L"/delete")==0) {
        
            if (DeviceName[1] == L':') {
                InstallRegion = SpRegionFromDosName(DeviceName);
            } else {
                InstallRegion = SpRegionFromNtName(DeviceName,0);
            }

            if (InstallRegion == NULL) {
                RcMessageOut(MSG_SYNTAX_ERROR);
                return 1;
            }

            if (InBatchMode)
                bPrompt = FALSE;
            else
                pRcCls();
            
            SpPtDoDelete(InstallRegion, DeviceName, bPrompt);

            if (bPrompt)
                pRcCls();

        } else if (_wcsicmp(Action,L"/add")==0) {        
            DesiredMB = 0;
            if (TokenizedLine->TokenCount >= 4) {
                szPartitionSize = TokenizedLine->Tokens->Next->Next->Next->String;
                RtlInitUnicodeString(&UnicodeString, szPartitionSize);
                RtlUnicodeStringToInteger(&UnicodeString, 10, &DesiredMB);
            }
            
            FDiskRegion.DeviceName = DeviceName;
            FDiskRegion.Region = NULL;
            FDiskRegion.MaxSize = 0;
            FDiskRegion.RequiredSize = DesiredMB;
            SpEnumerateDiskRegions( (PSPENUMERATEDISKREGIONS)RcFdiskRegionEnum, (ULONG_PTR)&FDiskRegion );

            if (FDiskRegion.Region) {
                // try to create the partition of the given size
                if (!SpPtDoCreate(FDiskRegion.Region,NULL,TRUE,DesiredMB,0,FALSE)) {
                    pRcCls();
                    // ask the user to give correct (aligned) size showing him the limits
                    if(!SpPtDoCreate(FDiskRegion.Region,NULL,FALSE,DesiredMB,0,FALSE)) {
                        pRcCls();
                        RcMessageOut(MSG_FDISK_INVALID_PARTITION_SIZE, szPartitionSize, DeviceName);                    
                    } else {
                        pRcCls();
                    }                        
                }
            } else {
                // could not find a region to create the partition of the specified size
                RcMessageOut(MSG_FDISK_INVALID_PARTITION_SIZE, szPartitionSize, DeviceName);
            }
        }

        RcInitializeCurrentDirectories();
        
        return 1;
    }

    pRcCls();

    Status = SpPtPrepareDisks(
        _CmdConsBlock->SifHandle,
        &InstallRegion,
        &SystemPartitionRegion,
        _CmdConsBlock->SetupSourceDevicePath,
        _CmdConsBlock->DirectoryOnSetupSource,
        FALSE
        );
    if(!NT_SUCCESS(Status)) {
        KdPrint(("SPCMDCON: SpPtPrepareDisks() failes, err=%08x\r\n",Status));
        pRcCls();
        return 1;
    }

    RcInitializeCurrentDirectories();
    pRcCls();

    return 1;
}


ULONG
RcCmdMakeDiskRaw(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    BOOLEAN Successfull = FALSE;

#ifndef OLD_PARTITION_ENGINE

    if (TokenizedLine->TokenCount > 1) {
        WCHAR           Buffer[256];
        UNICODE_STRING  UniStr;
        ULONG DriveIndex = -1;

        RtlInitUnicodeString(&UniStr, TokenizedLine->Tokens->Next->String);

        if (NT_SUCCESS(RtlUnicodeStringToInteger(&UniStr, 10, &DriveIndex))) {
            BOOLEAN Confirmed = FALSE;
            
            swprintf(Buffer, 
                    L"Convert %d drive to raw  [y/n] ? ", 
                    DriveIndex);

            RcTextOut(Buffer);
            
            if( RcLineIn(Buffer,2) ) {
                if((Buffer[0] == L'y') || (Buffer[0] == L'Y')) {
                    //
                    // Wants to do it.
                    //
                    Confirmed = TRUE;
                }
            }

            if (Confirmed) {                    
                Successfull = SpPtMakeDiskRaw(DriveIndex);       
            } else {
                Successfull = TRUE;
            }                
        }            
    }

    if (!Successfull) {
        RcTextOut(L"Either MakeDiskRaw [disk-number] syntax is wrong or the command failed");
    }
#endif    
    
    return 1;
}

NTSTATUS
RcDisplayNtInstalls(
    IN PLIST_ENTRY  NtInstalls
    )
/*++

Routine Description:

    Do a simple display of the NT Installs described in
    the NtInstalls linked list
    
Arguments:

                    
    NtInstalls   - Linked List containing description of NT installs
    
Return:

    STATUS_SUCCESS  if nt installs were successfully displayed
    
    otherwise, error status    
   

--*/
{
    PLIST_ENTRY         Next;
    PNT_INSTALLATION    NtInstall;
    
    //
    // make sure we have something to display
    //
    ASSERT(NtInstalls);
    if (!NtInstalls) {
        KdPrintEx((DPFLTR_SETUP_ID, 
           DPFLTR_ERROR_LEVEL, 
           "SPCMDCON: RcDisplayNtInstalls: incoming NT Installs list is NULL\r\n"
           ));
        return STATUS_INVALID_PARAMETER;
    }

    ASSERT(! IsListEmpty(NtInstalls));
    if(IsListEmpty(NtInstalls)) {
        KdPrintEx((DPFLTR_SETUP_ID, 
           DPFLTR_INFO_LEVEL, 
           "SPCMDCON: RcDisplayNtInstalls: incoming NT Installs list is empty\r\n"
           ));
        return STATUS_NOT_FOUND;
    }
    
    pRcEnableMoreMode();

    //
    // show how many installs we have 
    //
    RcMessageOut(MSG_BOOTCFG_SCAN_RESULTS_TITLE,
                 InstallCountFullScan
                 );
    
    //
    // iterate through the database and report
    //
    Next = NtInstalls->Flink;
    while ((UINT_PTR)Next != (UINT_PTR)NtInstalls) {
        NtInstall = CONTAINING_RECORD( Next, NT_INSTALLATION, ListEntry );
        Next = NtInstall->ListEntry.Flink;
    
        RcMessageOut(MSG_BOOTCFG_SCAN_RESULTS_ENTRY,
                     NtInstall->InstallNumber,
                     NtInstall->DriveLetter,
                     NtInstall->Path
                     );
    }
    
    pRcDisableMoreMode();

    return STATUS_SUCCESS;
}


NTSTATUS
RcPerformFullNtInstallsScan(
    VOID
    )
/*++

Routine Description:

    Convenience routine for launching a full scan for NT Installs
    
Arguments:

    none
    
Return:

    STATUS_SUCCESS      if scan was successful
    
    otherwise, error status
        
--*/
{
    PRC_SCAN_RECURSION_DATA     RecursionData;

    //
    // the list should be empty before we do this.  If
    // someone wants to rescan the disk, they should
    // empty the list first
    //
    ASSERT(IsListEmpty(&NtInstallsFullScan));
    if (! IsListEmpty(&NtInstallsFullScan)) {
        KdPrintEx((DPFLTR_SETUP_ID, 
           DPFLTR_ERROR_LEVEL, 
           "SPCMDCON: RcPerformFullNtInstallsScan: NTInstallsFullScan list is NOT empty\r\n"
           ));
        return STATUS_UNSUCCESSFUL;
    }
    ASSERT(InstallCountFullScan == 0);
    if (InstallCountFullScan != 0) {
        KdPrintEx((DPFLTR_SETUP_ID, 
           DPFLTR_ERROR_LEVEL, 
           "SPCMDCON: RcPerformFullNtInstallsScan: NTInstallsFullScan count > 0\r\n"
           ));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Let the user know what we are doing and that 
    // this could take a while
    //
    RcMessageOut(MSG_BOOTCFG_SCAN_NOTIFICATION);

    //
    // do a depth first search through directory tree
    // and store the install info
    //

    //
    // Initialize the structure that will be maintained during
    // the recursive enumeration of the directories.
    //
    RecursionData = SpMemAlloc(sizeof(RC_SCAN_RECURSION_DATA));
    RtlZeroMemory(RecursionData, sizeof(RC_SCAN_RECURSION_DATA));

    //
    // Build up a menu of partitions and free spaces.
    //
    SpEnumerateDiskRegions(RcScanDisksForNTInstallsEnum,
                           (ULONG_PTR)RecursionData
                           );

    //
    // there should be at least one install, otherwise
    // there is not point in fixing the boot config
    //
    if(InstallCountFullScan == 0) {
        
        KdPrintEx((DPFLTR_SETUP_ID, 
           DPFLTR_ERROR_LEVEL, 
           "SPCMDCON: RcPerformFullNtInstallsScan: Full Scan returned 0 hits!\r\n"
           ));

        RcMessageOut(MSG_BOOTCFG_SCAN_FAILURE);
        
        ASSERT(InstallCountFullScan > 0);

        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RcGetBootEntries(
    IN PLIST_ENTRY  BootEntries,
    IN PULONG       BootEntriesCnt  
    )
/*++

Routine Description:

   Get a list of current boot entries in the boot list
    
Arguments:

    BootEntriesCnt  - the number of boot entries displayed
              
Return:

    STATUS_SUCCESS  if successful and BootEntriesCnt is valid
    
    otherwise, error status
    
--*/
{
    NTSTATUS        status;

    ASSERT(BootEntries);
    ASSERT(IsListEmpty(BootEntries));
    if (! IsListEmpty(BootEntries)) {

        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_ERROR_LEVEL, 
                   "SPCMDCON: RcGetBootEntries: BootEntries list is not empty\r\n"
                    ));

        return STATUS_INVALID_PARAMETER;
    }

    ASSERT(BootEntriesCnt);
    if (! BootEntriesCnt) {

        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_ERROR_LEVEL, 
                   "SPCMDCON: RcGetBootEntries: BootEntriesCnt is NULL\r\n"
                    ));

        return STATUS_INVALID_PARAMETER;
    }

    //
    // get an export of the loaded boot entries
    //
    status = SpExportBootEntries(BootEntries,
                                 BootEntriesCnt
                                );
    if (! NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_ERROR_LEVEL, 
                   "SPCMDCON: RcGetBootEntries: failed to get export list: Status = %lx\r\n",
                   status
                    ));
        return status;
    }

    if (IsListEmpty(BootEntries)) {
        
        KdPrintEx((DPFLTR_SETUP_ID, 
           DPFLTR_INFO_LEVEL, 
           "SPCMDCON: RcGetBootEntries: boot entries exported list is empty\r\n"
           ));

        status = STATUS_NOT_FOUND;
    }

    return status;
}

NTSTATUS
RcDisplayBootEntries(
    IN PLIST_ENTRY  BootEntries,
    IN ULONG        BootEntriesCnt  
    )
/*++

Routine Description:

   Display the list of current boot entries in the boot list
    
Arguments:

    BootEntriesCnt  - the number of boot entries displayed
              
Return:

    STATUS_SUCCESS  if successful and BootEntriesCnt is valid
    
    otherwise, error status
    
--*/
{
    PSP_EXPORTED_BOOT_ENTRY BootEntry;
    PLIST_ENTRY             Next;
    ULONG                   i;

    ASSERT(BootEntries);
    ASSERT(! IsListEmpty(BootEntries));
    if (IsListEmpty(BootEntries)) {

        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_ERROR_LEVEL, 
                   "SPCMDCON: RcDisplayBootEntries: BootEntries list is empty\r\n"
                    ));

        return STATUS_INVALID_PARAMETER;
    }
    
    ASSERT(BootEntriesCnt > 0);
    if (BootEntriesCnt == 0) {

        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_ERROR_LEVEL, 
                   "SPCMDCON: RcDisplayBootEntries: BootEntriesCnt is 0\r\n"
                    ));

        return STATUS_INVALID_PARAMETER;
    }

    pRcEnableMoreMode();

    RcMessageOut(MSG_BOOTCFG_EXPORT_HEADER,
                 BootEntriesCnt
                 );

    i=0;
            
    Next = BootEntries->Flink;
    while ((UINT_PTR)Next != (UINT_PTR)BootEntries) {
        BootEntry = CONTAINING_RECORD( Next, SP_EXPORTED_BOOT_ENTRY, ListEntry );
        Next = BootEntry->ListEntry.Flink;
    
        RcMessageOut(MSG_BOOTCFG_EXPORT_ENTRY,
                     i+1,
                     BootEntry->LoadIdentifier,
                     BootEntry->OsLoadOptions,
                     BootEntry->DriverLetter,
                     BootEntry->OsDirectory
                    );
    
        i++;
    }

    ASSERT(i == BootEntriesCnt);

    pRcDisableMoreMode();

    return STATUS_SUCCESS;
}

RcGetAndDisplayBootEntries(
    IN  ULONG    NoEntriesMessageId,
    OUT PULONG   BootEntriesCnt       OPTIONAL
    )
/*++

Routine Description:

    Get and Display the boot entries currently in the boot list
    
Arguments:

    NoEntriesMessageId  - the message id of the message that should be
                          displayed if there are no boot entries
    BootEntriesCnt      - on exit and if not NULL, points to the # of
                          boot entries displayed                        
    
Return:

    STATUS_SUCCESS  if nt installs were successfully displayed
                    and BootEntriesCnt is valid
                    
    otherwise, error status    
   

--*/
{
    LIST_ENTRY          BootEntries;
    ULONG               cnt;
    NTSTATUS            status;

    if (BootEntriesCnt) {
        *BootEntriesCnt = 0;
    }

    InitializeListHead( &BootEntries );

    //
    // get the boot entries export 
    //
    status = RcGetBootEntries(&BootEntries,
                              &cnt
                              );

    //
    // if there are no boot entries to choose as default, return
    //
    if (status == STATUS_NOT_FOUND) {

        RcMessageOut(NoEntriesMessageId);

        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_INFO_LEVEL, 
                   "SPCMDCON: RcCmdBootCfg:(list) no boot entries found: Status = %lx\r\n",
                   status
                   ));

        return status;
    } else if (! NT_SUCCESS(status)) {

        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_INFO_LEVEL, 
                   "SPCMDCON: RcCmdBootCfg:(list) failed to get boot entries: Status = %lx\r\n",
                   status
                   ));

        return status;
    }

    status = RcDisplayBootEntries(&BootEntries,
                                  cnt
                                  );
    if (! NT_SUCCESS(status)) {

        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_INFO_LEVEL, 
                   "SPCMDCON: RcCmdBootCfg:(list) failed to display boot entries: Status = %lx\r\n",
                   status
                   ));

        return status;
    }

    status = SpFreeExportedBootEntries(&BootEntries, 
                                       cnt
                                       );
    if (! NT_SUCCESS(status)) {

        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_INFO_LEVEL, 
                   "SPCMDCON: RcCmdBootCfg:(list) failed freeing export list: Status = %lx\r\n",
                   status
                   ));

    }

    //
    // send out the boot entries count if the user wants it
    //
    if (BootEntriesCnt != NULL) {
        *BootEntriesCnt = cnt;
    }

    return status;
}


ULONG
RcCmdBootCfg(
    IN PTOKENIZED_LINE TokenizedLine
    )
/*++

Routine Description:

    Provides support for managing boot configuration
    
Arguments:

    (command console standard args)
    
Return:

    routine always returns 1 for cmdcons. 
    
    errors are handled through messaging
    
--*/
{
    PWCHAR          Action;
    PWCHAR          Operand;
    BOOLEAN         bPrompt;
    PWCHAR          DeviceName;
    PDISK_REGION    InstallRegion;
    NTSTATUS        status;
    
    pRcEnableMoreMode();
    if (RcCmdParseHelp( TokenizedLine, MSG_BOOTCFG_HELP )) {
        pRcDisableMoreMode();
        return 1;
    }
    pRcDisableMoreMode();

    bPrompt = (InBatchMode ? FALSE : TRUE);
    
    if (TokenizedLine->TokenCount >= 2) {

        Action = TokenizedLine->Tokens->Next->String;

        //
        // turn the redirect switches off in the boot config
        //
        if (_wcsicmp(Action,L"/disableredirect")==0) {

            status = SpSetRedirectSwitchMode(DisableRedirect,
                                              NULL,
                                              NULL
                                              );
            if (NT_SUCCESS(status)) {
                
                RcMessageOut(MSG_BOOTCFG_DISABLEREDIRECT_SUCCESS);

            } else {

                RcMessageOut(MSG_BOOTCFG_REDIRECT_FAILURE_UPDATING);
            
            }

            return 1;
        }

        //
        // manage the redirect switches
        //
        if (_wcsicmp(Action,L"/redirect")==0 && (TokenizedLine->TokenCount >= 3)) {
            
            PWSTR       portU;
            PCHAR       port;
            PWSTR       baudrateU;
            PCHAR       baudrate;
            ULONG       size;
            BOOLEAN     setBaudRate;

            //
            // setting the baudrate info is optional
            //
            setBaudRate = FALSE;
            baudrateU   = NULL;
            baudrate    = NULL;

            //
            // get the redirect port (or useBiosSettings)
            //
            portU = SpDupStringW(TokenizedLine->Tokens->Next->Next->String);

            //
            // convert the argument to a char string
            //
            size = wcslen(portU)+1;
            port = SpMemAlloc(size);
            ASSERT(port);

            status = RtlUnicodeToMultiByteN(
                                            port,
                                            size,
                                            NULL,
                                            portU,
                                            size*sizeof(WCHAR)
                                            );
            ASSERT(NT_SUCCESS(status));
            if (! NT_SUCCESS(status)) {
                KdPrintEx((DPFLTR_SETUP_ID, 
                           DPFLTR_INFO_LEVEL, 
                           "SPCMDCON: RcCmdBootCfg:(redirect) failed unicode conversion: Status = %lx\r\n"
                           ));
                return 1;
            }
            
            //
            // if there is another arg, take it as the baudrate
            // otherwise don't worry about including any baudrate paramters
            //
            if (TokenizedLine->TokenCount >= 4) {

                baudrateU = SpDupStringW(TokenizedLine->Tokens->Next->Next->Next->String);

                //
                // convert the argument to a char string
                //
                size = wcslen(baudrateU)+1;
                baudrate = SpMemAlloc(size);
                ASSERT(baudrate);

                status = RtlUnicodeToMultiByteN(
                                                baudrate,
                                                size,
                                                NULL,
                                                baudrateU,
                                                size*sizeof(WCHAR)
                                                );
                ASSERT(NT_SUCCESS(status));
                if (! NT_SUCCESS(status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, 
                               DPFLTR_INFO_LEVEL, 
                               "SPCMDCON: RcCmdBootCfg:(redirect) failed unicode conversion: Status = %lx\r\n",
                               status
                               ));
                    return 1;
                }

                setBaudRate = TRUE;

            } 
            
            //
            // update both the port and baudrate redirect settings
            //
            status = SpSetRedirectSwitchMode(UseUserDefinedRedirectAndBaudRate,
                                             port,
                                             (setBaudRate ? baudrate : NULL)
                                             );
            //
            // display the appropriate message based on what we set
            //
            if (NT_SUCCESS(status)) {
                if (setBaudRate) {
                    
                    RcMessageOut(MSG_BOOTCFG_ENABLE_REDIRECT_SUCCESS,
                                 portU,
                                 baudrateU
                                 );
                
                } else {

                    RcMessageOut(MSG_BOOTCFG_ENABLE_REDIRECT_PORT_SUCCESS,
                                 portU
                                 );
                
                }

            } else {
                RcMessageOut(MSG_BOOTCFG_REDIRECT_FAILURE_UPDATING);
            }

            if (baudrateU) {
                SpMemFree(baudrateU);
            }
            if (baudrate) {
                SpMemFree(baudrate);
            }
            SpMemFree(portU);
            SpMemFree(port);
            
            return 1;
        }

        //
        // List the entries in the boot list
        //
        if (_wcsicmp(Action,L"/list")==0) {

            ULONG               BootEntriesCnt;

            //
            // display the current boot list
            //
            status = RcGetAndDisplayBootEntries(MSG_BOOTCFG_LIST_NO_ENTRIES, 
                                                NULL
                                                );
            if (! NT_SUCCESS(status)) {
            
                KdPrintEx((DPFLTR_SETUP_ID, 
                           DPFLTR_INFO_LEVEL, 
                           "SPCMDCON: RcCmdBootCfg:(list) failed to list boot entries: Status = %lx\r\n",
                           status
                           ));
            
            }

            return 1;
        }

        //
        // set the default boot entry
        //
        if (_wcsicmp(Action,L"/default")==0) {

            ULONG               BootEntriesCnt;
            ULONG               InstallNumber;
            WCHAR               buffer[3];
            UNICODE_STRING      UnicodeString;
            NTSTATUS            Status;

            //
            // display the current boot list
            //
            status = RcGetAndDisplayBootEntries(MSG_BOOTCFG_DEFAULT_NO_ENTRIES, 
                                                &BootEntriesCnt
                                                );
            if (status == STATUS_NOT_FOUND) {
                
                //
                // no boot entries in the list to set as default
                // this is not an error condition, just return
                //
                return 1;
            
            } else if (! NT_SUCCESS(status)) {
            
                KdPrintEx((DPFLTR_SETUP_ID, 
                           DPFLTR_INFO_LEVEL, 
                           "SPCMDCON: RcCmdBootCfg:(default) failed to list boot entries: Status = %lx\r\n",
                           status
                           ));
            
                return 1;
            
            }

            //
            // get user's install selection
            //
            RcMessageOut(MSG_BOOTCFG_ADD_QUERY);
            RcLineIn(buffer, sizeof(buffer) / sizeof(WCHAR));
            
            if (wcslen(buffer) > 0) {
            
                RtlInitUnicodeString( &UnicodeString, buffer );
                Status = RtlUnicodeStringToInteger( &UnicodeString, 10, &InstallNumber );
                
                if (! NT_SUCCESS(Status) ||
                    !((InstallNumber >= 1) && (InstallNumber <= BootEntriesCnt))) {
            
                    RcMessageOut(MSG_BOOTCFG_INVALID_SELECTION, buffer);
            
                } else {
            
                    //
                    // the user gave us a valid install number, so try to set the default
                    //

                    status = SpSetDefaultBootEntry(InstallNumber);
                    
                    if (NT_SUCCESS(status)) {
                        
                        RcMessageOut(MSG_BOOTCFG_DEFAULT_SUCCESS);
                    
                    } else {

                        KdPrintEx((DPFLTR_SETUP_ID, 
                                   DPFLTR_ERROR_LEVEL, 
                                   "SPCMDCON: RcCmdBootCfg:(default) failed to set default: Status = %lx\r\n",
                                   status
                                   ));

                        RcMessageOut(MSG_BOOTCFG_DEFAULT_FAILURE);
                    
                    }

                }
            }

            return 1;
        }


        //
        // Scan the disks on the machine and report NT installs
        //
        if (_wcsicmp(Action,L"/scan")==0) {
    
            //
            // Ensure that we have the full scan of the disks
            //
            if (IsListEmpty(&NtInstallsFullScan)) {
                status = RcPerformFullNtInstallsScan();
                
                //
                // if there are no boot entries, then return
                //
                if (! NT_SUCCESS(status)) {

                    KdPrintEx((DPFLTR_SETUP_ID, 
                               DPFLTR_ERROR_LEVEL, 
                               "SPCMDCON: RcCmdBootCfg:(scan) full scan return 0 hits: Status = %lx\r\n",
                               status
                               ));

                    return 1;
                }
            }

            //
            // display discovered installs
            //
            status = RcDisplayNtInstalls(&NtInstallsFullScan);
            
            if (! NT_SUCCESS(status)) {
                
                KdPrintEx((DPFLTR_SETUP_ID, 
                           DPFLTR_ERROR_LEVEL, 
                           "SPCMDCON: RcCmdBootCfg:(scan) failed while displaying installs: Status = %lx\r\n",
                           status
                           ));
            
            }

            return 1;
        } 
        
        //
        // Provide support for reconstructing the boot configuration
        // 
        // This command iterates through all the existing Nt Installs
        // and prompts the user to add the installs into the boot
        // configuration
        //
        if (_wcsicmp(Action,L"/rebuild")==0) {

            ULONG               i;
            PNT_INSTALLATION    pInstall;
            WCHAR               buffer[256];
            PWSTR               LoadIdentifier;
            PWSTR               OsLoadOptions;
            BOOLEAN             writeInstall;
            BOOLEAN             writeAllInstalls;
            PLIST_ENTRY         Next;
            PNT_INSTALLATION    NtInstall;

            writeAllInstalls = FALSE;
            LoadIdentifier   = NULL;
            OsLoadOptions    = NULL;
            
            //
            // Ensure that we have the full scan of the disks
            //
            if (IsListEmpty(&NtInstallsFullScan)) {
                status = RcPerformFullNtInstallsScan();
                
                //
                // if there are no boot entries, then return
                //
                if (! NT_SUCCESS(status)) {

                    KdPrintEx((DPFLTR_SETUP_ID, 
                               DPFLTR_ERROR_LEVEL, 
                               "SPCMDCON: RcCmdBootCfg:(rebuild) full scan return 0 hits: Status = %lx\r\n",
                               status
                               ));

                    return 1;
                }
            }

            //
            // show how many installs we have 
            //
            RcMessageOut(MSG_BOOTCFG_SCAN_RESULTS_TITLE,
                         InstallCountFullScan
                         );

            //
            // For each of the discovered NT installs, ask the user
            // if they want to include it in the boot configuration
            //
            Next = NtInstallsFullScan.Flink;
            
            while ((UINT_PTR)Next != (UINT_PTR)&NtInstallsFullScan) {
                
                NtInstall = CONTAINING_RECORD( Next, NT_INSTALLATION, ListEntry );
                Next = NtInstall->ListEntry.Flink;
                
                writeInstall = TRUE;

                //
                // show the install under consideration
                //
                RcMessageOut(MSG_BOOTCFG_SCAN_RESULTS_ENTRY,
                             NtInstall->InstallNumber,
                             NtInstall->Region->DriveLetter,
                             NtInstall->Path
                            );

                //
                // if we are not in batch mode and the user doesn't want
                // to install all of the discoveries, then ask them
                // if they want to install the current one.
                //
                if (bPrompt && !writeAllInstalls) {
                
                    LPWSTR          YesNo;
                    WCHAR           Text[3];

                    //
                    // prompt user for action
                    //
                    YesNo = SpRetreiveMessageText( ImageBase, MSG_YESNOALL, NULL, 0 );
                    if( YesNo ) {
                        
                        //
                        // query the user for an (Yes, No, All) action
                        //
                        RcMessageOut(MSG_BOOTCFG_INSTALL_DISCOVERY_QUERY);
                        
                        if( RcLineIn( Text, 2 ) ) {
                            if( (Text[0] == YesNo[0]) || (Text[0] == YesNo[1]) ) {
                                writeInstall = FALSE;
                            } else if ((Text[0] == YesNo[4]) || (Text[0] == YesNo[5])) {
                                writeAllInstalls = TRUE;
                            }
                        } else {
                            writeInstall = FALSE;
                        }
                        SpMemFree( YesNo );
                    }
                }
                
                //
                // if we should write the discovery, then do it...
                //
                if (writeInstall) {
                    
                    //
                    // if we are not in batch mode, then prompt them for the necessary input
                    //
                    if (bPrompt) {
                    
                        ASSERT(LoadIdentifier == NULL);
                        ASSERT(OsLoadOptions == NULL);

                        //
                        // prompt user for load identifier
                        //
                        RcMessageOut(MSG_BOOTCFG_INSTALL_LOADIDENTIFIER_QUERY);
                        RcLineIn(buffer, sizeof(buffer)/sizeof(WCHAR));
                        LoadIdentifier = SpDupStringW(buffer);

                        //
                        // prompt user for load os load options
                        //
                        RcMessageOut(MSG_BOOTCFG_INSTALL_OSLOADOPTIONS_QUERY);
                        RcLineIn(buffer, sizeof(buffer)/sizeof(WCHAR));
                        OsLoadOptions = SpDupStringW(buffer);
                    
                    } else {
                          
                        LPWSTR   s;
                        LPWSTR   p;
                        NTSTATUS Status;
                        
                        s = SpRetreiveMessageText( ImageBase, 
                                                   MSG_BOOTCFG_BATCH_LOADID, 
                                                   NULL, 
                                                   0);
                        ASSERT(s);

                        //
                        // terminate the string at the %0
                        //
                        p = SpDupStringW(s);
                        SpMemFree(s);
                        s = wcsstr(p, L"%0");
                        
                        // make sure we found the %0
                        ASSERT(s);
                        ASSERT(s < (p + wcslen(p)));

                        if (s) {
                            // terminate at the %
                            *s = L'\0';
                        } else {
                            // otherwise just use all of p
                            NOTHING;
                        }

                        //
                        // construct the default load identifier
                        //
                        swprintf(_CmdConsBlock->TemporaryBuffer, L"%s%d", p, NtInstall->InstallNumber);
                        LoadIdentifier = SpDupStringW(_CmdConsBlock->TemporaryBuffer);
                        
                        //
                        // construct the default os load options 
                        //
                        swprintf(_CmdConsBlock->TemporaryBuffer, L"/fastdetect");
                        OsLoadOptions = SpDupStringW(_CmdConsBlock->TemporaryBuffer);

                        SpMemFree(p);

                    }
                    
#if defined(_X86_)
                    //
                    // write the discovered install into the boot list
                    //
                    status = SpAddNTInstallToBootList(_CmdConsBlock->SifHandle,
                                                     NtInstall->Region,
                                                     L"",
                                                     NtInstall->Region,
                                                     NtInstall->Path,
                                                     OsLoadOptions,
                                                     LoadIdentifier
                                                     );

#else
                    //
                    // the non-x86 case has not been tested/implemented fully
                    //
                    status = STATUS_UNSUCCESSFUL;                    
#endif 
                    
                    if (LoadIdentifier) {
                        SpMemFree(LoadIdentifier);
                    }
                    if (OsLoadOptions) {
                        SpMemFree(OsLoadOptions);
                    }
                    
                    LoadIdentifier = NULL;
                    OsLoadOptions = NULL;

                    //
                    // if adding the discovered install fails, bail out
                    //
                    if (! NT_SUCCESS(status)) {

                        KdPrintEx((DPFLTR_SETUP_ID, 
                                   DPFLTR_ERROR_LEVEL, 
                                   "SPCMDCON: RcCmdBootCfg:(rebuild) failed adding to boot list: Status = %lx\r\n",
                                   status
                                   ));

                        RcMessageOut(MSG_BOOTCFG_BOOTLIST_ADD_FAILURE);
                        break;
                    }
                }
            }
        
            return 1;
        
        }

        //
        // Provide support for reconstructing the boot configuration
        // 
        // This command displays the known NT installs and prompts
        // the user to install a single entry into the boot
        // configuration
        //
        if (_wcsicmp(Action,L"/add")==0) {

            ULONG               i;
            PNT_INSTALLATION    pInstall;
            ULONG               InstallNumber;
            WCHAR               buffer[256];
            UNICODE_STRING      UnicodeString;
            NTSTATUS            Status;
            PLIST_ENTRY         Next;
            PNT_INSTALLATION    NtInstall;

            //
            // Ensure that we have the full scan of the disks
            //
            if (IsListEmpty(&NtInstallsFullScan)) {
                status = RcPerformFullNtInstallsScan();
                
                //
                // if there are no boot entries, then return
                //
                if (! NT_SUCCESS(status)) {
                    
                    KdPrintEx((DPFLTR_SETUP_ID, 
                               DPFLTR_ERROR_LEVEL, 
                               "SPCMDCON: RcCmdBootCfg:(rebuild) full scan return 0 hits: Status = %lx\r\n",
                               status
                               ));
                    
                    return 1;
                }
            }

            //
            // display discovered installs
            //
            status = RcDisplayNtInstalls(&NtInstallsFullScan);
            if (! NT_SUCCESS(status)) {
                
                KdPrintEx((DPFLTR_SETUP_ID, 
                           DPFLTR_ERROR_LEVEL, 
                           "SPCMDCON: RcCmdBootCfg:(add) failed while displaying installs: Status = %lx\r\n",
                           status
                           ));
                
                return 1;
            }

            //
            // get user's install selection
            //
            RcMessageOut(MSG_BOOTCFG_ADD_QUERY);
            RcLineIn(buffer, sizeof(buffer) / sizeof(WCHAR));

            if (wcslen(buffer) > 0) {

                RtlInitUnicodeString( &UnicodeString, buffer );
                Status = RtlUnicodeStringToInteger( &UnicodeString, 10, &InstallNumber );
                if (! NT_SUCCESS(Status) ||
                    !((InstallNumber >= 1) && (InstallNumber <= InstallCountFullScan))) {
                    
                    RcMessageOut(MSG_BOOTCFG_INVALID_SELECTION, buffer);
                
                } else {
                    
                    PWSTR   LoadIdentifier;
                    PWSTR   OsLoadOptions;
                    ULONG   i;
                    BOOLEAN saveStatus;

                    //
                    // prompt user for load identifier
                    //
                    RcMessageOut(MSG_BOOTCFG_INSTALL_LOADIDENTIFIER_QUERY);
                    RcLineIn(buffer, sizeof(buffer)/sizeof(WCHAR));
                    LoadIdentifier = SpDupStringW(buffer);

                    //
                    // prompt user for load os load options
                    //
                    RcMessageOut(MSG_BOOTCFG_INSTALL_OSLOADOPTIONS_QUERY);
                    RcLineIn(buffer, sizeof(buffer)/sizeof(WCHAR));
                    OsLoadOptions = SpDupStringW(buffer);

                    //
                    // iterate to the InstallNumber'th node in the discover list
                    //
                    Next = NtInstallsFullScan.Flink;
                    while ((UINT_PTR)Next != (UINT_PTR)&NtInstallsFullScan) {
                        NtInstall = CONTAINING_RECORD( Next, NT_INSTALLATION, ListEntry );
                        Next = NtInstall->ListEntry.Flink;
                    
                        if (NtInstall->InstallNumber == InstallNumber) {
                            break;
                        }
                    }
                    ASSERT(NtInstall);
                    if (! NtInstall) {
                        KdPrintEx((DPFLTR_SETUP_ID, 
                                   DPFLTR_INFO_LEVEL, 
                                   "SPCMDCON: RcCmdBootCfg:(add) failed to find user specified NT Install\r\n"
                                   ));
                        RcMessageOut(MSG_BOOTCFG_ADD_NOT_FOUND);
                        return 1;
                    }

#if defined(_X86_)
                    //
                    // write the discovered install into the boot list
                    //
                    status = SpAddNTInstallToBootList(_CmdConsBlock->SifHandle,
                                                     NtInstall->Region,
                                                     L"",
                                                     NtInstall->Region,
                                                     NtInstall->Path,
                                                     OsLoadOptions,
                                                     LoadIdentifier
                                                     );

#else
                    //
                    // the non-x86 case has not been tested/implemented fully
                    //
                    status = STATUS_UNSUCCESSFUL;
#endif 
                    
                    if (LoadIdentifier) {
                        SpMemFree(LoadIdentifier);
                    }
                    if (OsLoadOptions) {
                        SpMemFree(OsLoadOptions);
                    }
                
                    if (! NT_SUCCESS(status)) {

                        KdPrintEx((DPFLTR_SETUP_ID, 
                                   DPFLTR_ERROR_LEVEL, 
                                   "SPCMDCON: RcCmdBootCfg:(add) failed adding to boot list: Status = %lx\r\n",
                                   status
                                   ));

                        RcMessageOut(MSG_BOOTCFG_BOOTLIST_ADD_FAILURE);
                    }
                }
            }
            
            return 1;
        }
    
    }

    //
    // either no args, or none recognized; default to help 
    //
    pRcEnableMoreMode();
    RcMessageOut(MSG_BOOTCFG_HELP);
    pRcDisableMoreMode();

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\cmdcons\dispatch.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module implements the basic command dispatcher.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop

ULONG
RcCmdDoHelp(
    IN PTOKENIZED_LINE TokenizedLine
    );

ULONG
RcCmdDoExit(
    IN PTOKENIZED_LINE TokenizedLine
    );
    
RC_CMD Commands[] =  {
                        { L"ATTRIB",            RcCmdAttrib,            1, 2, 0, TRUE  },
                        { L"BATCH",             RcCmdBatch,             1, 2, 0, TRUE  },
#if !defined(_DONT_HAVE_BOOTCFG_TESTERS_)
#if defined(_X86_)
                        { L"BOOTCFG",           RcCmdBootCfg,           0,-1, 0, TRUE  }, 
#endif
#endif                       
                        { L"CD",                RcCmdChdir,             0, 1, 0, TRUE  },
                        { L"CHDIR",             RcCmdChdir,             0, 1, 0, TRUE  },
                        { L"CHKDSK",            RcCmdChkdsk,            0,-1, 0, TRUE  },
                        { L"CLS",               RcCmdCls,               0, 1, 0, TRUE  },
                        { L"COPY",              RcCmdCopy,              1, 2, 0, TRUE  },
                        { L"DEL",               RcCmdDelete,            1, 1, 0, TRUE  },
                        { L"DELETE",            RcCmdDelete,            1, 1, 0, TRUE  },
                        { L"DIR",               RcCmdDir,               0, 1, 0, TRUE  },
                        { L"DISABLE",           RcCmdDisableService,    0,-1, 0, TRUE  },
                        { L"DISKPART",          RcCmdFdisk,             0, 3, 0, TRUE  },
                        { L"ENABLE",            RcCmdEnableService,     0,-1, 0, TRUE  },
                        { L"ERASE",             RcCmdDelete,            1, 1, 1, TRUE  },
                        { L"EXIT",              RcCmdDoExit,            0, 1, 0, TRUE  },                        
                        { L"EXPAND",            RcCmdExpand,            1,-1, 0, TRUE  },
                        { L"FIXBOOT",           RcCmdFixBootSect,       0, 1, 0, TRUE  },
                        { L"FIXMBR",            RcCmdFixMBR,            0, 1, 0, TRUE  },
                        { L"FORMAT",            RcCmdFormat,            1, 3, 0, TRUE  },
                        { L"HELP",              RcCmdDoHelp,            0, 1, 0, TRUE  },                        
                        { L"LISTSVC",           RcCmdListSvc,           0, 1, 0, TRUE  },
                        { L"LOGON",             RcCmdLogon,             0, 3, 0, TRUE  },
                        { L"MAP",               RcCmdDriveMap,          0, 1, 0, TRUE  },
                        { L"MD",                RcCmdMkdir,             1, 1, 0, TRUE  },
                        { L"MKDIR",             RcCmdMkdir,             1, 1, 0, TRUE  },
                        { L"MKDISKRAW",         RcCmdMakeDiskRaw,       1, 1, 1, TRUE  },
                        { L"MORE",              RcCmdType,              1, 1, 0, TRUE  },
                                                // If you change the command from NET, change it in RcHideNetCommands().
                        { L"NET",               RcCmdNet,               1, 5, 0, TRUE  }, 
                        { L"RD",                RcCmdRmdir,             1, 1, 0, TRUE  },
                        { L"REN",               RcCmdRename,            1, 2, 0, TRUE  },
                        { L"RENAME",            RcCmdRename,            1, 2, 0, TRUE  },
#if 0
                        { L"REPAIR",            RcCmdRepair,            1, 5, 0, TRUE  },
#endif                        
                        { L"RMDIR",             RcCmdRmdir,             1, 1, 0, TRUE  },
                        { L"SET",               RcCmdSetFlags,          0, 3, 1, TRUE  },
                        { L"SYSTEMROOT",        RcCmdSystemRoot,        0, 1, 0, TRUE  },
                        { L"TYPE",              RcCmdType,              1, 1, 0, TRUE  },
                        { L"VERIFIER",          RcCmdVerifier,          0,-1, 1, TRUE  }, 
                        { L"/?",                RcCmdHelpHelp,          0, 1, 1, TRUE  },
                        { L"?",                 RcCmdHelpHelp,          0, 1, 1, TRUE  }
                    };

#define NUM_CMDS (sizeof(Commands)/sizeof(Commands[0]))

//
// Special case: exit and reload
//
#define EXIT_COMMAND_NAME       L"EXIT"
#define RELOAD_COMMAND_NAME     L"RELOAD"
#define HELP_COMMAND_NAME       L"HELP"

// prototype
ULONG
GetStringTokenFromLine(
    IN OUT LPWSTR *Start,
    OUT    LPWSTR  Output  OPTIONAL
    );

PTOKENIZED_LINE
RcTokenizeLine(
    IN LPWSTR Line
    )
{
    ULONG len;
    WCHAR *p,*q;
    PTOKENIZED_LINE TokenizedLine;
    PLINE_TOKEN LineToken,PrevToken;

    //
    // Strip trailing space off the command.
    //
    len = wcslen(Line);
    while(len && RcIsSpace(Line[len-1])) {
        Line[--len] = 0;
    }

    //
    // Allocate and initialize a tokenized line structure.
    //
    TokenizedLine = SpMemAlloc(sizeof(TOKENIZED_LINE));
    RtlZeroMemory(TokenizedLine,sizeof(TOKENIZED_LINE));

    //
    // Now we go into a loop of skipping leading space and parsing in
    // the actual tokens.
    //
    PrevToken = NULL;
    p = Line;
    while(*p) {
        //
        // Skip leading space. Because we trimmed off trailing space,
        // we should never hit the end of the line before finding a
        // non-space character.
        //
        while(RcIsSpace(*p)) {
            p++;
        }
        ASSERT(*p);

        //
        // Allocate a line token structure for this string.
        //
        LineToken = SpMemAlloc(sizeof(LINE_TOKEN));
        RtlZeroMemory(LineToken,sizeof(LINE_TOKEN));

        //
        // Now we've got a string. First we make one pass over it
        // to determine the length, then allocate a buffer and
        // pull out the string into it.
        //
        q = p;
        len = GetStringTokenFromLine(&q,NULL);
        LineToken->String = SpMemAlloc((len+1)*sizeof(WCHAR));
        GetStringTokenFromLine(&p,LineToken->String);

        if(PrevToken) {
            PrevToken->Next = LineToken;
        } else {
            TokenizedLine->Tokens = LineToken;
        }
        PrevToken = LineToken;

        TokenizedLine->TokenCount++;
    }

    return(TokenizedLine);
}


ULONG
GetStringTokenFromLine(
    IN OUT LPWSTR *Start,
    OUT    LPWSTR  Output  OPTIONAL
    )
{
    WCHAR *p;
    ULONG len;
    BOOLEAN InQuote;

    len = 0;
    InQuote = FALSE;
    p = *Start;

    while(*p) {

        if(RcIsSpace(*p) && !InQuote) {
            //
            // Done.
            //
            break;
        }

        if(*p == L'\"') {
            InQuote = (BOOLEAN)(!InQuote);
        } else {
            if(Output) {
                Output[len] = *p;
            }
            len++;
        }

        p++;
    }

    if(Output) {
        Output[len] = 0;
    }

    *Start = p;
    return(len);
}


VOID
RcFreeTokenizedLine(
    IN OUT PTOKENIZED_LINE *TokenizedLine
    )
{
    PTOKENIZED_LINE p;
    PLINE_TOKEN q,n;

    p = *TokenizedLine;
    *TokenizedLine = NULL;

    q = p->Tokens;
    while(q) {
        n = q->Next;
        SpMemFree((PVOID)q->String);
        SpMemFree(q);
        q = n;
    }

    SpMemFree(p);
}


ULONG
RcDispatchCommand(
    IN PTOKENIZED_LINE TokenizedLine
    )

/*++

Routine Description:

    Top-level routine for dispatching a command.

Arguments:

Return Value:

--*/

{
    unsigned i;
    unsigned count;

    ASSERT(TokenizedLine->TokenCount);
    if(!TokenizedLine->TokenCount) {
        return(1);
    }

    /*
    //
    // Special case exit right up front.
    //
    if(!_wcsicmp(TokenizedLine->Tokens->String,EXIT_COMMAND_NAME)) {
        if (TokenizedLine->TokenCount > 1) {
            RcMessageOut(MSG_EXIT_HELP);
            return(1);
        } 
        return(0);
    }
    */

    if(!_wcsicmp(TokenizedLine->Tokens->String,RELOAD_COMMAND_NAME)) {
        return(2);
    }

    /*
    if(!_wcsicmp(TokenizedLine->Tokens->String,HELP_COMMAND_NAME)) {
        if( RcCmdDoHelp(TokenizedLine) ) {
            // if we got a 1, then the user just wanted a help index
            // otherwise we want to drop down and let the regular command
            // processing path handle a /? parameter.
            return(1);
        }
    }
    */

    //
    // See whether it's a drive designation.
    //
    if(RcIsAlpha(TokenizedLine->Tokens->String[0])
    && (TokenizedLine->Tokens->String[1] == L':')
    && (TokenizedLine->Tokens->String[2] == 0)) {

        RcCmdSwitchDrives(TokenizedLine->Tokens->String[0]);
        return(1);
    }

    //
    // Attempt to locate the command in our table.
    //
    for(i=0; i<NUM_CMDS; i++) {

        if(Commands[i].Enabled && !_wcsicmp(TokenizedLine->Tokens->String,Commands[i].Name)) {
            //
            // Validate arg count.
            //
            count = TokenizedLine->TokenCount - 1;
            if((count < Commands[i].MinimumArgCount) 
            || (count > Commands[i].MaximumArgCount)) {

                RcMessageOut(MSG_SYNTAX_ERROR);
            } else {

                return Commands[i].Routine(TokenizedLine);
            }

            return(1);
        }
    }

    RcMessageOut(MSG_UNKNOWN_COMMAND);

    return(1);
}

ULONG
RcCmdDoExit(
    IN PTOKENIZED_LINE TokenizedLine
    )
/*++    

Routine Description:

    Exit command routine

Arguments:
    Tokens for the command 
    
Return Value:
    1 if some error was found or help was asked for.
    0 if we need to exit

--*/
{
    ULONG   uResult = 0;    // will exit 
    
    if (RcCmdParseHelp( TokenizedLine, MSG_EXIT_HELP )) 
        uResult = 1;    // will not exit

    return uResult; 
}


ULONG
RcCmdDoHelp(
    IN PTOKENIZED_LINE TokenizedLine
    )
/*++    

Routine Description:

    Help command routine

Arguments:
    Tokens for the command 
    
Return Value:
    1 if some error was found or help was requested. 
    When help was reqeusted for a particular command
    the dispatched command's return value with "/?" as argument for
    the command

--*/
{
    ULONG           uResult = 1;
    int             i;
    PLINE_TOKEN     Token;

    if (!RcCmdParseHelp( TokenizedLine, MSG_HELPCOMMAND_HELP )) {
        if (TokenizedLine->TokenCount == 2) {
            // we assume that the user is typing HELP <command>.
            // we simply reverse the two tokens, getting <command> HELP
            // and overwrite HELP with /? [which fits since HELP is four chars long]

            // we then return a 0, which causes the dispatcher to drop into
            // the normal command processing path

            Token = TokenizedLine->Tokens;
            TokenizedLine->Tokens = TokenizedLine->Tokens->Next;
            TokenizedLine->Tokens->Next = Token;
            Token->Next = NULL;
            wcscpy( Token->String, L"/?" );

            uResult = RcDispatchCommand( TokenizedLine );
        } else {
            pRcEnableMoreMode();
            RcMessageOut( MSG_HELPCOMMAND_HELP );
            
            for( i=0; i < NUM_CMDS; i++ ) {
                if (Commands[i].Hidden == 0) {
                    RcTextOut( Commands[i].Name );
                    RcTextOut( L"\r\n" );
                }
            }

            pRcDisableMoreMode();
        }
    }
    
    return uResult;
}

/*++

Routine Description:

    Enables or disables the SET command

    Note : we avoid using direct SET command index
    into Commands array so that if some one changes
    the Commands array this routine still works
    
Arguments:

    bEnable - BOOLEAN inidicating whether to enable or disable
              the set command

Return Value:

    None
--*/
VOID
RcSetSETCommandStatus(
    BOOLEAN     bEnabled
    )
{
    int     iIndex;
    int     cElements = sizeof(Commands) / sizeof(RC_CMD);
    WCHAR   *szSetCmdName = L"SET";

    //
    // search through the dispatch table and trun on the 
    // help flag. This flag will indicate whether the set
    // command is enabled or not
    //
    for(iIndex = 0; iIndex < cElements; iIndex++) {
        if ( !wcscmp(Commands[iIndex].Name, szSetCmdName) ) {
            Commands[iIndex].Hidden = bEnabled ? 0 : 1;

            break;
        }
    }
}

/*++

Routine Description:

    Returns the SET command status

    Note : we avoid using direct SET command index
    into Commands array so that if some one changes
    the Commands array this routine still works
    
Arguments:

    None

Return Value:

    BOOLEAN inidicating whether the SET command is
    enabled or disabled.

--*/
BOOLEAN
RcGetSETCommandStatus(
    VOID
    )
{
    BOOLEAN bEnabled = FALSE;
    int     iIndex;
    int     cElements = sizeof(Commands) / sizeof(RC_CMD);
    WCHAR   *szSetCmdName = L"SET";

    //
    // search through the dispatch table and trun on the 
    // help flag. This flag will indicate whether the set
    // command is enabled or not
    //
    for(iIndex = 0; iIndex < cElements; iIndex++) {
        if ( !wcscmp(Commands[iIndex].Name, szSetCmdName) ) {
            bEnabled = (Commands[iIndex].Hidden == 0);

            break;
        }
    }

    return bEnabled;
}


BOOLEAN
RcDisableCommand(
        IN PRC_CMD_ROUTINE      CmdToDisable
        )
/*++

Routine Description:

        Disables the specified command and hides it.
        
Arguments:

    CmdToDisable - Command Routine to disable

Return Value:

    BOOLEAN inidicating whether the command was disabled or not.

--*/
{
        ULONG   Index;
        ULONG   NumCmds;
        BOOLEAN Result = FALSE;

        if (CmdToDisable) {
                NumCmds = sizeof(Commands) / sizeof(RC_CMD);
                
                for (Index=0; Index < NumCmds; Index++) {
                        //
                        // Note : Search the whole table as there might
                        // be aliases for the same command
                        //              
                        if (CmdToDisable == Commands[Index].Routine) {
                                Commands[Index].Hidden = TRUE;
                                Commands[Index].Enabled = FALSE;
                                Result = TRUE;
                        }
                }
        }

        return Result;
}

VOID
RcHideNetCommands(
    VOID
    )
{
    ULONG i;

    for( i=0; i < NUM_CMDS; i++ ) {
         if (wcscmp(Commands[i].Name, L"NET")) {
             Commands[i].Hidden = 0;
         }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\cmdcons\map.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    map.c

Abstract:

    This module implements the drive mapping command.

Author:

    Wesley Witt (wesw) 21-Oct-1998
    Ted Miller  (tedm) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop


LPWSTR FsTypes[] =
{
    L"     ",
    L"NEW  ",
    L"FAT16",
    L"NTFS ",
    L"FAT32",
    L"     ",
    L"     "
};



BOOL
RcDiskRegionEnum(
    IN PPARTITIONED_DISK Disk,
    IN PDISK_REGION Region,
    IN ULONG_PTR UseArcNames
    )
{
    ULONGLONG RegionSizeMB;
    WCHAR ArcName[256];

    if (!SPPT_IS_REGION_PARTITIONED(Region) ||
        (Region->ExtendedType == EPTContainerPartition)) {
        return TRUE;        
    }

    if (UseArcNames) {
        SpArcNameFromRegion(
            Region,
            ArcName,
            sizeof(ArcName),
            PartitionOrdinalCurrent,
            PrimaryArcPath
            );
    } else {
        SpNtNameFromRegion(
            Region,
            ArcName,
            sizeof(ArcName),
            PartitionOrdinalCurrent
            );
    }

    RegionSizeMB = SpPtSectorCountToMB(Disk->HardDisk, Region->SectorCount);

    RcMessageOut(
        MSG_MAP_ENTRY,
        Region->DriveLetter == 0 ? L'?' : Region->DriveLetter,
        Region->DriveLetter == 0 ? L' ' : L':',
        FsTypes[Region->Filesystem],
        (ULONG)RegionSizeMB,
        ArcName
        );

    return TRUE;
}


NTSTATUS
GetDriveLetterLinkTarget(
    IN PWSTR SourceNameStr,
    OUT PWSTR *LinkTarget
    )
{
    static WCHAR        targetNameBuffer[256];

    NTSTATUS            status;
    UNICODE_STRING      sourceName;
    UNICODE_STRING      targetName;
    OBJECT_ATTRIBUTES   oa;
    HANDLE              handle;


    RtlInitUnicodeString(&sourceName, SourceNameStr);

    InitializeObjectAttributes(&oa, &sourceName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = ZwOpenSymbolicLinkObject(&handle, READ_CONTROL | SYMBOLIC_LINK_QUERY, &oa);

    if (NT_SUCCESS(status))
    {
        RtlZeroMemory(targetNameBuffer, sizeof(targetNameBuffer));
        targetName.Buffer = targetNameBuffer;
        targetName.MaximumLength = sizeof(targetNameBuffer);

        status = ZwQuerySymbolicLinkObject(handle, &targetName, NULL);
        NtClose(handle);
    }

    if (NT_SUCCESS(status))
    {
        *LinkTarget = targetName.Buffer;
    }
    else
    {
        *LinkTarget = NULL;
    }

    return status;
}


ULONG
RcCmdDriveMap(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    ULONG i;
    LPWSTR s;
    LPWSTR p;
    WCHAR buf[128];


    if (RcCmdParseHelp( TokenizedLine, MSG_MAP_HELP )) {
        return 1;
    }

    RcTextOut( L"\r\n" );

    if (TokenizedLine->TokenCount == 2 && _wcsicmp( TokenizedLine->Tokens->Next->String, L"arc" ) == 0) {
        SpEnumerateDiskRegions( (PSPENUMERATEDISKREGIONS)RcDiskRegionEnum, 1 );
    } else {
        SpEnumerateDiskRegions( (PSPENUMERATEDISKREGIONS)RcDiskRegionEnum, 0 );
    }

    for (i=0; i<26; i++) {
        swprintf( buf, L"\\DosDevices\\%c:",i+L'A');
        if (RcIsFileOnCDROM(buf) == STATUS_SUCCESS ||
            RcIsFileOnFloppy(buf) == STATUS_SUCCESS
             || RcIsNetworkDrive(buf) == STATUS_SUCCESS
            )
        {
            GetDriveLetterLinkTarget( buf, &s );
            RcMessageOut( MSG_MAP_ENTRY2, buf[12], s );
        }
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\cmdcons\expand.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    expand.c

Abstract:

    This module implements the file expand command.

Author:

    Mike Sliger (msliger) 29-Apr-1999

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop



//
// structure tunneled thru SpExpandFile to carry info to/from callback
//
typedef struct {
    LPWSTR  FileSpec;
    BOOLEAN DisplayFiles;
    BOOLEAN MatchedAnyFiles;
    ULONG   NumberOfFilesDone;
    BOOLEAN UserAborted;
    BOOLEAN OverwriteExisting;
} EXPAND_CONTEXT;

BOOLEAN
pRcCheckForBreak( VOID );

EXPAND_CALLBACK_RESULT
pRcExpandCallback(
    EXPAND_CALLBACK_MESSAGE Message,
    PWSTR                   FileName,
    PLARGE_INTEGER          FileSize,
    PLARGE_INTEGER          FileTime,
    ULONG                   FileAttributes,
    PVOID                   UserData
    );

BOOL
pRcPatternMatch(
    LPWSTR pszString,
    LPWSTR pszPattern,
    IN BOOL fImplyDotAtEnd
    );



ULONG
RcCmdExpand(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    PLINE_TOKEN Token;
    LPWSTR Arg;
    LPWSTR SrcFile = NULL;
    LPWSTR DstFile = NULL;
    LPWSTR FileSpec = NULL;
    LPWSTR SrcNtFile = NULL;
    LPWSTR DstNtPath = NULL;
    LPWSTR s;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeString;
    HANDLE Handle;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    LPWSTR YesNo;
    WCHAR Text[3];
    IO_STATUS_BLOCK  status_block;
    FILE_BASIC_INFORMATION fileInfo;
    WCHAR * pos;
    ULONG CopyFlags = 0;
    BOOLEAN DisplayFileList = FALSE;
    BOOLEAN OverwriteExisting = NoCopyPrompt;
    EXPAND_CONTEXT Context;

    ASSERT(TokenizedLine->TokenCount >= 1);

    if (RcCmdParseHelp( TokenizedLine, MSG_EXPAND_HELP )) {
        goto exit;
    }

    //
    //  Parse command line
    //

    for( Token = TokenizedLine->Tokens->Next;
         Token != NULL;
         Token = Token->Next ) {

        Arg = Token->String;
        if(( Arg[0] == L'-' ) || ( Arg[0] == L'/' )) {
            switch( Arg[1] ) {
            case L'F':
            case L'f':
                if(( Arg[2] == L':' ) && ( FileSpec == NULL )) {
                    FileSpec = &Arg[3];
                } else {
                    RcMessageOut(MSG_SYNTAX_ERROR);
                    goto exit;
                }
                break;

            case L'D':
            case L'd':
                if ( Arg[2] == L'\0' ) {
                    DisplayFileList = TRUE;
                } else {
                    RcMessageOut(MSG_SYNTAX_ERROR);
                    goto exit;
                }
                break;

            case L'Y':
            case L'y':
                if ( Arg[2] == L'\0' ) {
                    OverwriteExisting = TRUE;
                } else {
                    RcMessageOut(MSG_SYNTAX_ERROR);
                    goto exit;
                }
                break;

            default:
                RcMessageOut(MSG_SYNTAX_ERROR);
                goto exit;
            }
        } else if( SrcFile == NULL ) {
            SrcFile = Arg;
        } else if( DstFile == NULL ) {
            DstFile = SpDupStringW( Arg );
        } else {
            RcMessageOut(MSG_SYNTAX_ERROR);
            goto exit;
        }
    }

    if(( SrcFile == NULL ) ||
        (( DstFile != NULL ) && ( DisplayFileList == TRUE ))) {

        RcMessageOut(MSG_SYNTAX_ERROR);
        goto exit;
    }

    if ( RcDoesPathHaveWildCards( SrcFile )) {
        RcMessageOut(MSG_DIR_WILDCARD_NOT_SUPPORTED);
        goto exit;
    }

    //
    // Translate the source name to the NT namespace
    //

    if (!RcFormFullPath( SrcFile, _CmdConsBlock->TemporaryBuffer, TRUE )) {
        RcMessageOut(MSG_INVALID_PATH);
        goto exit;
    }

    SrcNtFile = SpDupStringW( _CmdConsBlock->TemporaryBuffer );

    if ( !DisplayFileList ) {

        //
        // Create a destination path name when the user did not
        // provide one.  We use the current drive and directory.
        //
        if( DstFile == NULL ) {
            RcGetCurrentDriveAndDir( _CmdConsBlock->TemporaryBuffer );
            DstFile = SpDupStringW( _CmdConsBlock->TemporaryBuffer );
        }

        //
        // create the destination paths
        //
        if (!RcFormFullPath( DstFile, _CmdConsBlock->TemporaryBuffer, FALSE )) {
            RcMessageOut(MSG_INVALID_PATH);
            goto exit;
        }

        if (!RcIsPathNameAllowed(_CmdConsBlock->TemporaryBuffer,FALSE,FALSE)) {
            RcMessageOut(MSG_ACCESS_DENIED);
            goto exit;
        }

        if (!RcFormFullPath( DstFile, _CmdConsBlock->TemporaryBuffer, TRUE )) {
            RcMessageOut(MSG_INVALID_PATH);
            goto exit;
        }

        DstNtPath = SpDupStringW( _CmdConsBlock->TemporaryBuffer );

        //
        // check for removable media
        //

        if (AllowRemovableMedia == FALSE && RcIsFileOnRemovableMedia(DstNtPath) == STATUS_SUCCESS) {
            RcMessageOut(MSG_ACCESS_DENIED);
            goto exit;
        }
    }

    //
    // setup context for callbacks
    //

    RtlZeroMemory(&Context, sizeof(Context));
    Context.FileSpec = FileSpec;
    Context.DisplayFiles = DisplayFileList;
    Context.OverwriteExisting = OverwriteExisting;

    if ( DisplayFileList ) {
        pRcEnableMoreMode();
    }

    Status = SpExpandFile( SrcNtFile, DstNtPath, pRcExpandCallback, &Context );

    pRcDisableMoreMode();

    if( !NT_SUCCESS(Status) && !Context.UserAborted ) {

        RcNtError( Status, MSG_CANT_EXPAND_FILE );

    } else if (( Context.NumberOfFilesDone == 0 ) &&
               ( Context.MatchedAnyFiles == FALSE ) &&
               ( Context.FileSpec != NULL )) {

        RcMessageOut( MSG_EXPAND_NO_MATCH, Context.FileSpec, SrcFile );
    }

    if ( Context.MatchedAnyFiles ) {
        if ( DisplayFileList ) {
            RcMessageOut( MSG_EXPAND_SHOWN, Context.NumberOfFilesDone );
        } else {
            RcMessageOut( MSG_EXPAND_COUNT, Context.NumberOfFilesDone );
        }
    }

exit:

    if( SrcNtFile ) {
        SpMemFree( SrcNtFile );
    }

    if( DstFile ) {
        SpMemFree( DstFile );
    }

    if( DstNtPath ) {
        SpMemFree( DstNtPath );
    }

    return 1;
}



EXPAND_CALLBACK_RESULT
pRcExpandCallback(
    EXPAND_CALLBACK_MESSAGE Message,
    PWSTR                   FileName,
    PLARGE_INTEGER          FileSize,
    PLARGE_INTEGER          FileTime,
    ULONG                   FileAttributes,
    PVOID                   UserData
    )
{
    EXPAND_CONTEXT * Context = (EXPAND_CONTEXT * ) UserData;
    LPWSTR YesNo;
    EXPAND_CALLBACK_RESULT rc;
    WCHAR Text[3];

    switch ( Message )
    {
    case EXPAND_COPY_FILE:

        //
        // Watch for Ctl-C or ESC while processing
        //
        if ( pRcCheckForBreak() ) {
            Context->UserAborted = TRUE;
            return( EXPAND_ABORT );
        }

        //
        // See if filename matches filespec pattern, if any
        //
        if ( Context->FileSpec != NULL ) {

            //
            // To be "*.*"-friendly, we need to know if there is a real
            // dot in the last element of the string to be matched
            //

            BOOL fAllowImpliedDot = TRUE;
            LPWSTR p;

            for ( p = FileName; *p != L'\0'; p++ ) {
                if ( *p == L'.' ) {
                    fAllowImpliedDot = FALSE;
                } else if ( *p == L'\\' ) {
                    fAllowImpliedDot = TRUE;
                }
            }
            
            if ( !pRcPatternMatch( FileName,
                                   Context->FileSpec,
                                   fAllowImpliedDot )) {
                //
                // File doesn't match given spec: skip it
                //
                return( EXPAND_SKIP_THIS_FILE );
            }
        }

        Context->MatchedAnyFiles = TRUE;    // don't report "no matches"

        if ( Context->DisplayFiles ) {

            //
            // We're just listing file names, and we must do it now, because
            // we're going to tell ExpandFile to skip this one, so this will
            // be the last we here about it.
            //
            WCHAR LineOut[50];
            WCHAR *p;

            //
            // Format the date and time, which go first.
            //
            RcFormatDateTime(FileTime,LineOut);
            RcTextOut(LineOut);

            //
            // 2 spaces for separation
            //
            RcTextOut(L"  ");

            //
            // File attributes.
            //
            p = LineOut;

            *p++ = L'-';

            if(FileAttributes & FILE_ATTRIBUTE_ARCHIVE) {
                *p++ = L'a';
            } else {
                *p++ = L'-';
            }
            if(FileAttributes & FILE_ATTRIBUTE_READONLY) {
                *p++ = L'r';
            } else {
                *p++ = L'-';
            }
            if(FileAttributes & FILE_ATTRIBUTE_HIDDEN) {
                *p++ = L'h';
            } else {
                *p++ = L'-';
            }
            if(FileAttributes & FILE_ATTRIBUTE_SYSTEM) {
                *p++ = L's';
            } else {
                *p++ = L'-';
            }

            *p++ = L'-';
            *p++ = L'-';
            *p++ = L'-';
            *p = 0;

            RcTextOut(LineOut);

            //
            // 2 spaces for separation
            //
            RcTextOut(L"  ");

            //
            // Now, put the size in there. Right justified and space padded
            // up to 8 chars. Otherwise unjustified or padded.
            //
            RcFormat64BitIntForOutput(FileSize->QuadPart,LineOut,TRUE);
            if(FileSize->QuadPart > 99999999i64) {
                RcTextOut(LineOut);
            } else {
                RcTextOut(LineOut+11);          // outputs 8 chars
            }

            RcTextOut(L" ");

            //
            // Finally, put the filename on the line.
            //

            if( !RcTextOut( FileName ) || !RcTextOut( L"\r\n" )) {

                Context->UserAborted = TRUE;
                return( EXPAND_ABORT );      /* user aborted display output */
            }

            Context->NumberOfFilesDone++;

            return( EXPAND_SKIP_THIS_FILE );

        }   // end if DisplayFiles

        //
        // This file qualified, and we're not just displaying, so tell
        // ExpandFile to do it.
        //
        return( EXPAND_COPY_THIS_FILE );

    case EXPAND_COPIED_FILE:

        //
        // Notification that a file has been copied successfully.
        //

        RcMessageOut( MSG_EXPANDED, FileName);
        Context->NumberOfFilesDone++;

        return( EXPAND_NO_ERROR );

    case EXPAND_QUERY_OVERWRITE:

        //
        // Query for approval to overwrite an existing file.
        //

        if ( Context->OverwriteExisting ) {
            return( EXPAND_COPY_THIS_FILE );
        }

        rc = EXPAND_SKIP_THIS_FILE;

        YesNo = SpRetreiveMessageText( ImageBase, MSG_YESNOALLQUIT, NULL, 0 );
        if ( YesNo ) {

            RcMessageOut( MSG_COPY_OVERWRITE_QUIT, FileName );
            if( RcLineIn( Text, 2 ) ) {
                if (( Text[0] == YesNo[2] ) || ( Text[0] == YesNo[3] )) {

                    //
                    // Yes, we may overwrite this file
                    //
                    rc = EXPAND_COPY_THIS_FILE;

                } else if (( Text[0] == YesNo[4] ) || ( Text[0] == YesNo[5] )) {

                    //
                    // All, we may overwrite this file, and don't prompt again
                    //
                    Context->OverwriteExisting = TRUE;
                    rc = EXPAND_COPY_THIS_FILE;

                } else if (( Text[0] == YesNo[6] ) || ( Text[0] == YesNo[7] )) {

                    //
                    // No, and stop too.
                    //
                    Context->UserAborted = TRUE;
                    rc = EXPAND_ABORT;
                }
            }
            SpMemFree( YesNo );
        }

        return( rc );

    case EXPAND_NOTIFY_MULTIPLE:

        //
        // We're being advised that the source contains multiple files.
        // If we don't have a selective filespec, we'll abort.
        //

        if ( Context->FileSpec == NULL ) {

            RcMessageOut( MSG_FILESPEC_REQUIRED );
            Context->UserAborted = TRUE;
            return ( EXPAND_ABORT );
        }

        return ( EXPAND_CONTINUE );

    case EXPAND_NOTIFY_CANNOT_EXPAND:

        //
        // We're being advised that the source file format is not
        // recognized.  We display the file name and abort.
        //

        RcMessageOut( MSG_CANT_EXPAND_FILE, FileName );
        Context->UserAborted = TRUE;

        return ( EXPAND_ABORT );

    case EXPAND_NOTIFY_CREATE_FAILED:

        //
        // We're being advised that the current target file cannot be
        // created.  We display the file name and abort.
        //

        RcMessageOut( MSG_EXPAND_FAILED, FileName );
        Context->UserAborted = TRUE;

        return ( EXPAND_ABORT );

    default:

        //
        // Ignore any unexpected callback.
        //

        return( EXPAND_NO_ERROR );
    }
}



BOOLEAN
pRcCheckForBreak( VOID )
{
    while ( SpInputIsKeyWaiting() ) {

        ULONG Key = SpInputGetKeypress();

        switch ( Key ) {

        case ASCI_ETX:
        case ASCI_ESC:
            RcMessageOut( MSG_BREAK );
            return TRUE;

        default:
            break;
        }
    }

    return FALSE;
}



//
// pRcPatternMatch() & helpers
//

#define WILDCARD    L'*'    /* zero or more of any character */
#define WILDCHAR    L'?'    /* one of any character (does not match END) */
#define END         L'\0'   /* terminal character */
#define DOT         L'.'    /* may be implied at end ("hosts" matches "*.") */

static int __inline Lower(c)
{
    if ((c >= L'A') && (c <= L'Z'))
    {
        return(c + (L'a' - L'A'));
    }
    else
    {
        return(c);
    }
}


static int __inline CharacterMatch(WCHAR chCharacter, WCHAR chPattern)
{
    if (Lower(chCharacter) == Lower(chPattern))
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}


BOOL
pRcPatternMatch(
    LPWSTR pszString,
    LPWSTR pszPattern,
    IN BOOL fImplyDotAtEnd
    )
{
    /* RECURSIVE */

    //
    //  This function does not deal with 8.3 conventions which might
    //  be expected for filename comparisons.  (In an 8.3 environment,
    //  "alongfilename.html" would match "alongfil.htm")
    //
    //  This code is NOT MBCS-enabled
    //

    for ( ; ; )
    {
        switch (*pszPattern)
        {

        case END:

            //
            //  Reached end of pattern, so we're done.  Matched if
            //  end of string, no match if more string remains.
            //

            return(*pszString == END);

        case WILDCHAR:

            //
            //  Next in pattern is a wild character, which matches
            //  anything except end of string.  If we reach the end
            //  of the string, the implied DOT would also match.
            //

            if (*pszString == END)
            {
                if (fImplyDotAtEnd == TRUE)
                {
                    fImplyDotAtEnd = FALSE;
                }
                else
                {
                    return(FALSE);
                }
            }
            else
            {
                pszString++;
            }

            pszPattern++;

            break;

        case WILDCARD:

            //
            //  Next in pattern is a wildcard, which matches anything.
            //  Find the required character that follows the wildcard,
            //  and search the string for it.  At each occurence of the
            //  required character, try to match the remaining pattern.
            //
            //  There are numerous equivalent patterns in which multiple
            //  WILDCARD and WILDCHAR are adjacent.  We deal with these
            //  before our search for the required character.
            //
            //  Each WILDCHAR burns one non-END from the string.  An END
            //  means we have a match.  Additional WILDCARDs are ignored.
            //

            for ( ; ; )
            {
                pszPattern++;

                if (*pszPattern == END)
                {
                    return(TRUE);
                }
                else if (*pszPattern == WILDCHAR)
                {
                    if (*pszString == END)
                    {
                        if (fImplyDotAtEnd == TRUE)
                        {
                            fImplyDotAtEnd = FALSE;
                        }
                        else
                        {
                            return(FALSE);
                        }
                    }
                    else
                    {
                        pszString++;
                    }
                }
                else if (*pszPattern != WILDCARD)
                {
                    break;
                }
            }

            //
            //  Now we have a regular character to search the string for.
            //

            while (*pszString != END)
            {
                //
                //  For each match, use recursion to see if the remainder
                //  of the pattern accepts the remainder of the string.
                //  If it does not, continue looking for other matches.
                //

                if (CharacterMatch(*pszString, *pszPattern) == TRUE)
                {
                    if (pRcPatternMatch(pszString + 1, pszPattern + 1, fImplyDotAtEnd) == TRUE)
                    {
                        return(TRUE);
                    }
                }

                pszString++;
            }

            //
            //  Reached end of string without finding required character
            //  which followed the WILDCARD.  If the required character
            //  is a DOT, consider matching the implied DOT.
            //
            //  Since the remaining string is empty, the only pattern which
            //  could match after the DOT would be zero or more WILDCARDs,
            //  so don't bother with recursion.
            //

            if ((*pszPattern == DOT) && (fImplyDotAtEnd == TRUE))
            {
                pszPattern++;

                while (*pszPattern != END)
                {
                    if (*pszPattern != WILDCARD)
                    {
                        return(FALSE);
                    }

                    pszPattern++;
                }

                return(TRUE);
            }

            //
            //  Reached end of the string without finding required character.
            //

            return(FALSE);
            break;

        default:

            //
            //  Nothing special about the pattern character, so it
            //  must match source character.
            //

            if (CharacterMatch(*pszString, *pszPattern) == FALSE)
            {
                if ((*pszPattern == DOT) &&
                    (*pszString == END) &&
                    (fImplyDotAtEnd == TRUE))
                {
                    fImplyDotAtEnd = FALSE;
                }
                else
                {
                    return(FALSE);
                }
            }

            if (*pszString != END)
            {
                pszString++;
            }

            pszPattern++;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\cmdcons\logon.c ===
#include "cmdcons.h"
#pragma hdrstop

#include <crypt.h>
#include <recovery.h>
#include <ntsamp.h>
#include <spkbd.h>

static BOOL firstTime = TRUE;
static CONST PWSTR  gszSoftwareHiveName = L"software";
static CONST PWSTR  gszSoftwareHiveKey= L"\\registry\\machine\\xSOFTWARE";
static CONST PWSTR  gszSAMHiveName = L"sam";
static CONST PWSTR  gszSAMHiveKey = L"\\registry\\machine\\security";
static CONST PWSTR  gszSystemHiveName = L"system";
static CONST PWSTR  gszSystemHiveKey = L"\\registry\\machine\\xSYSTEM";
static CONST PWSTR  gszSecurityHiveName = L"security";
static CONST PWSTR  gszSecurityHiveKey = L"\\registry\\machine\\xSECURITY";

LIST_ENTRY          NtInstalls;
ULONG               InstallCount;
LIST_ENTRY          NtInstallsFullScan;
ULONG               InstallCountFullScan;

PNT_INSTALLATION    SelectedInstall;
LARGE_INTEGER       glBias;


#define IS_VALID_INSTALL(x)  (((x) > 0) && ((x) <= InstallCount))

typedef struct _KEY_CHECK_STRUCT {
    WCHAR       *szKeyName;
    BOOLEAN     bControlSet;
} KEY_CHECK_STRUCT;

//
// forward declarations
//
BOOLEAN 
LoginRequired(
    VOID
    );

BOOLEAN
RcOpenHive(
    PWSTR   szHiveName,
    PWSTR   szHiveKey
    );

BOOLEAN
RcCloseHive(
    PWSTR   szHiveKey 
    );

BOOLEAN
RcIsValidSystemHive(
    VOID
    );    
    
BOOLEAN
IsSetCommandEnabled(
    VOID
    );
    
BOOLEAN
RcDetermineCorrectControlKey(
    OUT PULONG pCorrectKey
    );
    
LARGE_INTEGER
RcGetTimeZoneBias(
    VOID
    );

VOID
RcDestroyList(
    PLIST_ENTRY ListHead
    )
{
    PLIST_ENTRY Entry = ListHead->Flink;

    if(Entry != NULL) {
        while(Entry != ListHead) {
            PLIST_ENTRY Next = Entry->Flink;
            SpMemFree(Entry);
            Entry = Next;
        }
    }

    InitializeListHead(ListHead);
}

BOOL
RcLogonDiskRegionEnum(
    IN PPARTITIONED_DISK Disk,
    IN PDISK_REGION Region,
    IN ULONG_PTR UseArcNames
    )
{
    WCHAR               buf[MAX_PATH];
    OBJECT_ATTRIBUTES   Obja;
    HANDLE              DirectoryHandle;
    NTSTATUS            Status;
    UNICODE_STRING      UnicodeString;
    IO_STATUS_BLOCK     IoStatusBlock;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;
    struct SEARCH_BUFFER {
        FILE_BOTH_DIR_INFORMATION DirInfo;
        WCHAR Names[MAX_PATH];
    } Buffer;

    UNICODE_STRING      FileName;
    LPWSTR              s;
    PNT_INSTALLATION    NtInstall;


    swprintf( buf, L"\\??\\%c:\\", Region->DriveLetter );

    INIT_OBJA( &Obja, &UnicodeString, buf );

    Status = ZwOpenFile(
        &DirectoryHandle,
        FILE_LIST_DIRECTORY | SYNCHRONIZE,
        &Obja,
        &IoStatusBlock,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
        );
    if (!NT_SUCCESS(Status)) {
        return TRUE;
    }

    DirectoryInfo = &Buffer.DirInfo;

    RtlInitUnicodeString( &FileName, L"*" );

    while (NT_SUCCESS(Status)) {
        Status = ZwQueryDirectoryFile(
            DirectoryHandle,
            NULL,
            NULL,
            NULL,
            &IoStatusBlock,
            DirectoryInfo,
            sizeof(Buffer),
            FileBothDirectoryInformation,
            TRUE,
            &FileName,
            FALSE
            );
        if (NT_SUCCESS(Status) && DirectoryInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            swprintf( buf, L"\\??\\%c:\\", Region->DriveLetter );
            wcsncat( buf, DirectoryInfo->FileName, DirectoryInfo->FileNameLength/sizeof(WCHAR) );
            wcscat( buf, L"\\system32\\config" );

            if (SpFileExists(buf, TRUE)) {
                swprintf( buf, L"\\??\\%c:\\", Region->DriveLetter );
                wcsncat( buf, DirectoryInfo->FileName, DirectoryInfo->FileNameLength/sizeof(WCHAR) );
                wcscat( buf, L"\\system32\\drivers" );

                if (SpFileExists(buf, TRUE)) {
                    NtInstall = (PNT_INSTALLATION) SpMemAlloc( sizeof(NT_INSTALLATION) );
                    if (NtInstall) {

                        RtlZeroMemory( NtInstall, sizeof(NT_INSTALLATION) );

                        NtInstall->InstallNumber = ++InstallCount;
                        NtInstall->DriveLetter = Region->DriveLetter;
                        NtInstall->Region = Region;
                        wcsncpy( NtInstall->Path, DirectoryInfo->FileName, 
                                    DirectoryInfo->FileNameLength/sizeof(WCHAR) );

                        InsertTailList( &NtInstalls, &NtInstall->ListEntry );
                    }
                }                    
            }
        }
    }

    ZwClose( DirectoryHandle );

    return TRUE;
}

BOOLEAN
RcScanForNTInstallEnum(
    IN  PCWSTR                     DirName,
    IN  PFILE_BOTH_DIR_INFORMATION FileInfo,
    OUT PULONG                     ret,
    IN  PVOID                      Pointer
    )
/*++

Routine Description:

    NOTE: this routine os of type: ENUMFILESPROC (spmisc.h)                      
                          
    This routine determines if the directory which is currently being
    enumerated is an NT install directory
    
Arguments:

    DirName     - IN: the directory in which the file to enumerate exists
    FileInfo    - IN: file attributes for the file to enumerate
    ret         - OUT: return status of this procedure
    Pointer     - IN: contains persistent recursion data
   
    
Return Value:

    A linked list of SP_DISCOVERED_NT_INSTALLS, where each structure
    refers to a discovered installation of Windows

--*/
{
    PWSTR                       FileName;
    PWSTR                       FullPath;
    PWSTR                       PartialPathName;
    BOOLEAN                     IsNtInstall;
    PRC_SCAN_RECURSION_DATA     RecursionData;

    //
    // Ignore non-directories
    //
    if(! (FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        return TRUE;    // continue processing
    }

    //
    // Build the full file or dir path
    //
    
    //
    // We have to make a copy of the directory name, because the info struct
    // we get isn't NULL-terminated.
    //
    wcsncpy(
        TemporaryBuffer,
        FileInfo->FileName,
        FileInfo->FileNameLength
        );
    (TemporaryBuffer)[FileInfo->FileNameLength / sizeof(WCHAR)] = UNICODE_NULL;
    FileName = SpDupStringW(TemporaryBuffer);

    wcscpy(TemporaryBuffer,DirName);
    SpConcatenatePaths(TemporaryBuffer,FileName);
    FullPath = SpDupStringW(TemporaryBuffer);

    SpMemFree(FileName);
    
    //
    // Get the recursion data
    //
    RecursionData = (PRC_SCAN_RECURSION_DATA)Pointer;

    //
    // get the directory component beyond the root directory
    //
    PartialPathName = FullPath + RecursionData->RootDirLength;
    
    ASSERT(PartialPathName < (FullPath + wcslen(FullPath)));
        
    //
    // Test if the directory is an NT install
    //
    IsNtInstall = SpIsNtInDirectory(RecursionData->NtPartitionRegion,
                                    PartialPathName
                                    );

    //
    // if we found an NT install, then add it to our linked list
    //
    if(IsNtInstall) {
        
        PNT_INSTALLATION    NtInstall;
        
        NtInstall = (PNT_INSTALLATION) SpMemAlloc( sizeof(NT_INSTALLATION) );
        if (NtInstall) {
        
            RtlZeroMemory( NtInstall, sizeof(NT_INSTALLATION) );
        
            NtInstall->InstallNumber = ++InstallCountFullScan;
            NtInstall->DriveLetter = RecursionData->NtPartitionRegion->DriveLetter;
            NtInstall->Region = RecursionData->NtPartitionRegion;
            
            //
            // Note: this PartialPathName contains the '\' at the beginning of the
            //       Path, while the FileName used in RcLogonDiskRegionEnum 
            //       does not
            //
            wcsncpy( NtInstall->Path, PartialPathName, sizeof(NtInstall->Path)/sizeof(WCHAR));
        
            InsertTailList( &NtInstallsFullScan, &NtInstall->ListEntry );
        }
    }

    SpMemFree(FullPath);
    
    return TRUE;    // continue processing
}

BOOL
RcScanDisksForNTInstallsEnum(
    IN PPARTITIONED_DISK    Disk,
    IN PDISK_REGION         NtPartitionRegion,
    IN ULONG_PTR            Context
    )
/*++

Routine Description:

    This routine launches the directory level scan for NT installs.
  
Arguments:

    Disk                - the disk we are scanning
    NtPartitionRegion   - the partition we are scanning
    Context             - the persistent recursion data
    
Return Value:

    TRUE    - continue scanning
    FALSE   - stop scanning
      
--*/
{
    ULONG                       EnumReturnData;
    ENUMFILESRESULT             EnumFilesResult; 
    PWSTR                       NtPartition;
    PWSTR                       DirName;
    PRC_SCAN_RECURSION_DATA     RecursionData;

    //
    // make sure this is valid partition:
    //
    //  not reserved
    //  filesystem is ntfs || fat
    //
    if (((NtPartitionRegion->Filesystem != FilesystemFat) &&
         (NtPartitionRegion->Filesystem != FilesystemFat32) &&
         (NtPartitionRegion->Filesystem != FilesystemNtfs)
         ) ||
        (NtPartitionRegion->IsReserved == 1)
        ) {
        
        KdPrintEx((DPFLTR_SETUP_ID, 
           DPFLTR_INFO_LEVEL, 
           "SPCMDCON: RcScanDisksForNTInstallsEnum: skipping filesystem type %x\r\n",
           NtPartitionRegion->Filesystem
           ));

        return TRUE;
    }

    //
    // Get our context
    //
    RecursionData = (PRC_SCAN_RECURSION_DATA)Context;

    //
    // Keep track of which partition region we are dealing with
    // so that the file enumeration routine can pass this info
    // on to SpIsNtInDirectory.
    //
    RecursionData->NtPartitionRegion = NtPartitionRegion;

    //
    // Get the device path of the nt partition.
    //
    SpNtNameFromRegion(
        NtPartitionRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    NtPartition = SpDupStringW(TemporaryBuffer);

    //
    // Begin searching at the root directory
    //
    wcscpy(TemporaryBuffer, NtPartition);
    SpConcatenatePaths(TemporaryBuffer, L"\\");
    DirName = SpDupStringW(TemporaryBuffer);

    //
    // get the length of the root directory string less the
    // directory separator.  This will be used to remove
    // the root dir component of the pathname when we pass
    // the dir name into SpIsNtInDirectory.  We need to do this
    // because SpIsNtInDirectory adds the root dir back in.
    //
    RecursionData->RootDirLength = wcslen(DirName) - 1;

    KdPrintEx((DPFLTR_SETUP_ID, 
       DPFLTR_INFO_LEVEL, 
       "SPCMDCON: SpScanDisksForNTInstalls: Scanning: %s\n",
       DirName
       ));

    //
    // Enumerate all the directories on the current partition
    //
    // Note: if the enumeration does not return with a status of NormalReturn,
    //       we do not stop the scanning process, rather we will contine on
    //       scanning any remaining disks/partitions.
    //
    EnumFilesResult = SpEnumFilesRecursiveLimited(
        DirName,
        RcScanForNTInstallEnum,
        MAX_FULL_SCAN_RECURSION_DEPTH,
        0,
        &EnumReturnData,
        RecursionData
        );
    if (EnumFilesResult != NormalReturn) {
        
        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_INFO_LEVEL, 
                   "SPCMDCON: SpScanDisksForNTInstalls: Enum Files returned non-normal result: %x\n",
                   EnumFilesResult
                   ));
    
    }

    //
    // we are done with instance of DirName
    //
    SpMemFree(DirName);

    return TRUE;

}

NTSTATUS
RcAuthorizePasswordLogon(
    IN PWSTR UserName,
    IN PWSTR UserPassword,
    IN PNT_INSTALLATION NtInstall
    )
{
#define BUFFERSIZE (sizeof(KEY_VALUE_PARTIAL_INFORMATION)+256)

    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      UnicodeString;
    NTSTATUS            Status;
    NTSTATUS            TmpStatus;
    WCHAR               KeyName[128];
    PWSTR               Hive = NULL;
    PWSTR               HiveKey = NULL;
    PUCHAR              buffer = NULL;
    PWSTR               PartitionPath = NULL;
    HANDLE              hKeySamRoot = NULL;
    HANDLE              hKeyNames = NULL;
    HANDLE              hKeyUser = NULL;
    HANDLE              hKeySystemRoot = NULL;
    HANDLE              hKeySecurityRoot = NULL;
    ULONG               ResultLength;
    ULONG               Number;
    ULONG               Rid;
    NT_OWF_PASSWORD     NtOwfPassword;
    NT_OWF_PASSWORD     UserOwfPassword;
    ULONG               i;
    BOOLEAN             NtPasswordPresent;
    BOOLEAN             NtPasswordNonNull;    
    WCHAR               PasswordBuffer[128];
    UNICODE_STRING      BootKeyPassword;
    PUNICODE_STRING     pBootKeyPassword = NULL;
    USHORT              BootKeyType = 0;
    PWCHAR              MessageText = NULL;
    UNICODE_STRING      SysKeyFileName;
    HANDLE              SysKeyHandle;
    IO_STATUS_BLOCK     IoStatusBlock;
    PWCHAR              FloppyPath = NULL;
    BOOLEAN             bSecurityHiveLoaded = FALSE;
    BOOLEAN             bSysHiveLoaded = FALSE;
    BOOLEAN             bSamHiveLoaded = FALSE;
    BOOLEAN             bClearScreen = FALSE;

    //
    // Allocate buffers.
    //

    Hive = SpMemAlloc(MAX_PATH * sizeof(WCHAR));
    HiveKey = SpMemAlloc(MAX_PATH * sizeof(WCHAR));
    buffer = SpMemAlloc(BUFFERSIZE);

    //
    // Get the name of the target patition.
    //

    SpNtNameFromRegion(
        NtInstall->Region,
        _CmdConsBlock->TemporaryBuffer,
        _CmdConsBlock->TemporaryBufferSize,
        PartitionOrdinalCurrent
        );

    PartitionPath = SpDupStringW(_CmdConsBlock->TemporaryBuffer);
    
    //
    // Load the SYSTEM hive
    //  
    bSysHiveLoaded = RcOpenSystemHive();

    if (!bSysHiveLoaded){
        //
        // Note : System hive seems to be corrupted so go ahead
        // and let the user log in so that he/she can fix
        // the problem
        //
        Status = STATUS_SUCCESS; 
        RcSetSETCommandStatus(TRUE);    // enable the set command also
        goto exit;
    }
            
        
    //
    // Now get a key to the root of the hive we just loaded.
    //

    wcscpy(HiveKey,L"\\registry\\machine\\xSYSTEM");
    
    INIT_OBJA(&Obja,&UnicodeString,HiveKey);
    Status = ZwOpenKey(&hKeySystemRoot,KEY_ALL_ACCESS,&Obja);

    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Unable to open %ws (%lx)\n",HiveKey,Status));
        goto exit;
    }

    //
    // Load the SAM hive
    //

    wcscpy(Hive,PartitionPath);
    SpConcatenatePaths(Hive,NtInstall->Path);
    SpConcatenatePaths(Hive,L"system32\\config");
    SpConcatenatePaths(Hive,L"sam");

    //
    // Form the path of the key into which we will
    // load the hive.  We'll use the convention that
    // a hive will be loaded into \registry\machine\security.
    //

    wcscpy(HiveKey,L"\\registry\\machine\\security");

    //
    // Attempt to load the key.
    //

    Status = SpLoadUnloadKey(NULL,NULL,HiveKey,Hive);

    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Unable to load hive %ws to key %ws (%lx)\n",Hive,HiveKey,Status));

        //
        // Note : SAM hive seems to be corrupted so go ahead
        // and let the user log in so that he/she can fix
        // the problem
        //
        Status = STATUS_SUCCESS;
        RcSetSETCommandStatus(TRUE);    // enable the set command also
        goto exit;
    }
    
    bSamHiveLoaded = TRUE;

    //
    // Now get a key to the root of the hive we just loaded.
    //

    INIT_OBJA(&Obja,&UnicodeString,HiveKey);
    Status = ZwOpenKey(&hKeySamRoot,KEY_ALL_ACCESS,&Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Unable to open %ws (%lx)\n",HiveKey,Status));
        goto exit;
    }

    //
    // load the "security" hive
    //
    bSecurityHiveLoaded = RcOpenHive(gszSecurityHiveName, gszSecurityHiveKey);

    if (!bSecurityHiveLoaded) {
        KdPrint(("SETUP: Unable to load hive %ws to key %ws\n", 
                    gszSecurityHiveName, gszSecurityHiveKey));

        //
        // Note : securityy hive seems to be corrupted so go ahead
        // and let the user log in so that he/she can fix
        // the problem
        //
        Status = STATUS_SUCCESS;
        RcSetSETCommandStatus(TRUE);    // enable the set command also
        goto exit;
    }  

    //
    // Now get a key to the root of the security hive we just loaded.
    //
    INIT_OBJA(&Obja,&UnicodeString,gszSecurityHiveKey);

    Status = ZwOpenKey(&hKeySecurityRoot,KEY_ALL_ACCESS,&Obja);

    if(!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Unable to open %ws (%lx)\n",gszSecurityHiveName,Status));
        goto exit;
    }
        
    if (_wcsicmp(UserName,L"administrator")==0) {

        Rid = DOMAIN_USER_RID_ADMIN;

    } else { 

        //
        // Get the key to the account data base
        //

        wcscpy(KeyName,L"SAM\\Domains\\Account\\Users\\Names\\");
        wcscat(KeyName,UserName);

        INIT_OBJA(&Obja,&UnicodeString,KeyName);
        Obja.RootDirectory = hKeySamRoot;

        Status = ZwOpenKey(&hKeyNames,KEY_READ,&Obja);
        if(!NT_SUCCESS(Status)) {
            goto exit;
        }

        //
        // Get the RID of the user
        //

        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = 0;
        UnicodeString.Buffer = _CmdConsBlock->TemporaryBuffer;

        Status = ZwQueryValueKey(
            hKeyNames,
            &UnicodeString,
            KeyValuePartialInformation,
            _CmdConsBlock->TemporaryBuffer,
            _CmdConsBlock->TemporaryBufferSize,
            &ResultLength
            );
        if(!NT_SUCCESS(Status)) {
            goto exit;
        }

        Rid = ((PKEY_VALUE_PARTIAL_INFORMATION)_CmdConsBlock->TemporaryBuffer)->Type;
    }

    while(TRUE){   
        Status = SamRetrieveOwfPasswordUser(
            Rid,
            hKeySecurityRoot,
            hKeySamRoot,
            hKeySystemRoot,
            pBootKeyPassword,
            BootKeyType,
            &NtOwfPassword,
            &NtPasswordPresent,
            &NtPasswordNonNull
            );
    
        if (NT_SUCCESS(Status)) {
            break;
        }
        
        if (Status == STATUS_SAM_NEED_BOOTKEY_PASSWORD) {

            RcMessageOut( MSG_LOGON_PROMPT_SYSKEY_PASSWORD );
            RtlZeroMemory( PasswordBuffer, sizeof(PasswordBuffer) );
            RcPasswordIn( PasswordBuffer, sizeof(PasswordBuffer) / sizeof(WCHAR) );
            RtlInitUnicodeString( &BootKeyPassword, PasswordBuffer );
            pBootKeyPassword = &BootKeyPassword;
            BootKeyType = SamBootKeyPassword;
        }
            
        if (Status == STATUS_SAM_NEED_BOOTKEY_FLOPPY){
            
            FloppyPath = SpDupStringW(L"\\Device\\Floppy0");

            MessageText = SpRetreiveMessageText(ImageBase,MSG_LOGON_PROMPT_SYSKEY_FLOPPY,NULL,0);

            bClearScreen = TRUE;
            
            if (!SpPromptForDisk(
                    MessageText,
                    FloppyPath,
                    L"StartKey.Key",
                    TRUE,             
                    FALSE,            
                    FALSE,            
                    NULL              
                    )){
                Status = STATUS_WRONG_PASSWORD;
                goto exit;
             }
             
             INIT_OBJA( &Obja, &SysKeyFileName, L"\\Device\\Floppy0\\StartKey.Key" );
 
             Status = ZwCreateFile(&SysKeyHandle,
                                   FILE_GENERIC_READ,
                                   &Obja,
                                   &IoStatusBlock,
                                   NULL,
                                   FILE_ATTRIBUTE_NORMAL,
                                   FILE_SHARE_READ,
                                   FILE_OPEN,
                                   FILE_SYNCHRONOUS_IO_NONALERT,
                                   NULL,
                                   0
                                  );

             if (NT_SUCCESS(Status))
             {
                 Status = ZwReadFile(
                            SysKeyHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            (PVOID) &PasswordBuffer[0],
                            sizeof(PasswordBuffer),
                            0,
                            NULL
                            );
                 ZwClose( SysKeyHandle );

                 if (NT_SUCCESS(Status)) {
                     BootKeyPassword.Buffer = PasswordBuffer;
                     BootKeyPassword.Length = BootKeyPassword.MaximumLength = 
                         (USHORT) IoStatusBlock.Information;
                     pBootKeyPassword = &BootKeyPassword;
                     BootKeyType = SamBootKeyDisk;
                 } else {
                     goto exit;
                 }

            } else {
                goto exit;
            }
        }

        if (!NT_SUCCESS(Status) && Status != STATUS_SAM_NEED_BOOTKEY_PASSWORD && Status != STATUS_SAM_NEED_BOOTKEY_FLOPPY) {
            goto exit;
        }
    }

    if (NtPasswordPresent && !NtPasswordNonNull && *UserPassword == 0) {
        Status = STATUS_SUCCESS;
        goto exit;
    }
    
    if (!NtPasswordPresent && *UserPassword == 0) {
        Status = STATUS_SUCCESS;
        goto exit;
    }

    RtlInitUnicodeString( &UnicodeString, UserPassword );

    Status = RtlCalculateNtOwfPassword( &UnicodeString, &UserOwfPassword );
    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    if (!RtlEqualNtOwfPassword( &NtOwfPassword, &UserOwfPassword )) {
        Status = STATUS_WRONG_PASSWORD;
    }

    //
    // now check to see if this user has admin rights
    //

exit:

    if(bClearScreen)
        pRcCls();
        
    //
    // close handles
    //
    if (hKeySamRoot)
        ZwClose(hKeySamRoot);

    if (hKeySecurityRoot)
        ZwClose(hKeySecurityRoot);

    if (hKeyNames) {
        ZwClose( hKeyNames );
    }

    if (hKeyUser) {
        ZwClose( hKeyUser );
    }

    if (hKeySystemRoot)
        ZwClose(hKeySystemRoot);

    //
    // Unload the SAM hive
    //
    if (bSamHiveLoaded) {
        TmpStatus  = SpLoadUnloadKey(NULL,NULL,HiveKey,NULL);
        if(!NT_SUCCESS(TmpStatus)) {
            KdPrint(("SETUP: warning: unable to unload key %ws (%lx)\n",HiveKey,TmpStatus));
        }
    }

    //
    // unload the security hive
    //
    if (bSecurityHiveLoaded) {
        if (!RcCloseHive(gszSecurityHiveKey))
            KdPrint(("SETUP: warning: unable to unload key %ws\n",gszSecurityHiveKey));
    }            

    //
    // unload system hive
    //    
    if (bSysHiveLoaded)
        RcCloseSystemHive();

    //
    // free memory
    //

    if (Hive) {
        SpMemFree( Hive );
    }
    
    if (HiveKey) {
        SpMemFree( HiveKey );
    }
    
    if (buffer) {
        SpMemFree( buffer );
    }
    
    if (PartitionPath) {
        SpMemFree( PartitionPath );
    }
    
    if (MessageText) {
        SpMemFree( MessageText );
    }
    
    if (FloppyPath) {
        SpMemFree( FloppyPath );
    }
    
    return Status;
}


ULONG
RcCmdLogon(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    #define MAX_FAILURES 3
    NTSTATUS Status;
    PLIST_ENTRY Next;
    PNT_INSTALLATION NtInstall;
    PNT_INSTALLATION OldSelectedNtInstall = SelectedInstall;
    ULONG InstallNumber;
    WCHAR Buffer[128];
    WCHAR UserNameBuffer[128];
    WCHAR PasswordBuffer[128];
    UNICODE_STRING UnicodeString;
    ULONG FailureCount = 0;
    ULONG u;
    BOOLEAN bRegCorrupted = FALSE;


    if (RcCmdParseHelp( TokenizedLine, MSG_LOGON_HELP )) {
        return 1;
    }

    //
    // Initialize list referring to the depth first search results
    // (These will be used via RcCmdBootCfg)
    //
    RcDestroyList(&NtInstallsFullScan);
    InstallCountFullScan = 0;

    //
    // Do a SHALLOW search for NT installs by default (at cmdcons boot)
    //
    RcDestroyList(&NtInstalls);
    InstallCount = 0;
    SpEnumerateDiskRegions( (PSPENUMERATEDISKREGIONS)RcLogonDiskRegionEnum, 0 );

    if (InstallCount == 0) {
        //
        // no nt installations on the machine so let the
        // user logon anyway
        //
        SelectedInstall = NULL;
        firstTime = FALSE;
        return 1;
    }

retry:

    RcTextOut( L"\r\n" );

    Next = NtInstalls.Flink;
    while ((UINT_PTR)Next != (UINT_PTR)&NtInstalls) {
        NtInstall = CONTAINING_RECORD( Next, NT_INSTALLATION, ListEntry );
        Next = NtInstall->ListEntry.Flink;
        swprintf( Buffer, L"%d: %c:\\", NtInstall->InstallNumber, NtInstall->DriveLetter );
        wcscat( Buffer, NtInstall->Path );
        wcscat( Buffer, L"\r\n" );
        RcTextOut( Buffer );
    }

    RcTextOut( L"\r\n" );

    if (InBatchMode) {
        if (TokenizedLine && TokenizedLine->TokenCount >= 2) {
            RtlInitUnicodeString( &UnicodeString, TokenizedLine->Tokens->Next->String );
            RtlUnicodeStringToInteger( &UnicodeString, 10, &InstallNumber );
        } else {
            InstallNumber = 1;
        }

        if(!IS_VALID_INSTALL(InstallNumber)/* InstallNumber > InstallCount*/){
            RcMessageOut( MSG_INSTALL_SELECT_ERROR );
            return 1;   // will err out
        }        
    } else {
        if (TokenizedLine && TokenizedLine->TokenCount == 2) {
            // Note : this could have been invoked only by executing a logon command
            // at the prompt
            RtlInitUnicodeString( &UnicodeString, TokenizedLine->Tokens->Next->String );
            Status = RtlUnicodeStringToInteger( &UnicodeString, 10, &InstallNumber );

            KdPrint(("SPCMDCON:Loging into %lx (%ws)\n", InstallNumber, 
                        TokenizedLine->Tokens->Next->String));
                        
            if (*TokenizedLine->Tokens->Next->String < L'0' || 
                    *TokenizedLine->Tokens->Next->String > L'9' ||
                    !NT_SUCCESS(Status) || !IS_VALID_INSTALL(InstallNumber)) {
                RcMessageOut( MSG_INSTALL_SELECT_ERROR );
                return 1;   // just err out for the command
            }
        } else {
            RtlZeroMemory( Buffer, sizeof(Buffer) );
            RcMessageOut( MSG_INSTALL_SELECT );
            if (!RcLineIn( Buffer, 2 )) {
                if( firstTime == TRUE ) {
                    return 0;
                } else {
                    return 1;
                }
            }
            if (*Buffer < L'0' || *Buffer > L'9') {
                RcMessageOut( MSG_INSTALL_SELECT_ERROR );
                goto retry;
            }
            
            RtlInitUnicodeString( &UnicodeString, Buffer );
            Status = RtlUnicodeStringToInteger( &UnicodeString, 10, &InstallNumber );
        
            if(!NT_SUCCESS(Status) || !IS_VALID_INSTALL(InstallNumber)){
                RcMessageOut( MSG_INSTALL_SELECT_ERROR );
                goto retry;
           }
        }
    }
   
    Next = NtInstalls.Flink;
    while ((UINT_PTR)Next != (UINT_PTR)&NtInstalls) {
        NtInstall = CONTAINING_RECORD( Next, NT_INSTALLATION, ListEntry );
        Next = NtInstall->ListEntry.Flink;
        if (NtInstall->InstallNumber == InstallNumber) {
            OldSelectedNtInstall = SelectedInstall;
            SelectedInstall = NtInstall;
            break;
        }
    }

    if (SelectedInstall == NULL) {
        if( firstTime == TRUE ) {
            return 0;
        } else {
            RcMessageOut( MSG_INSTALL_SELECT_ERROR );
            goto retry;         
        }
    }
      
    //
    // Note : check the SYSTEM, SAM, SECURITY hives and if corrupted then
    // allow the user to log in without asking for password 
    // so that he/she may be able correct the problem
    //
    if (RcIsValidSystemHive()) {
        if (RcOpenHive( gszSAMHiveName, gszSAMHiveKey )) {                
            RcCloseHive( gszSAMHiveKey );

            if (!RcOpenHive(gszSecurityHiveName, gszSecurityHiveKey)){
                bRegCorrupted = TRUE;
                goto success_exit;
            }

            RcCloseHive(gszSecurityHiveKey);
        } else{
            bRegCorrupted = TRUE;
            goto success_exit;
        }
    }    
    else{
        bRegCorrupted = TRUE;
        goto success_exit;
    }

    //
    // Get the bias information for displaying the file times properly
    //
    glBias = RcGetTimeZoneBias();

    KdPrint(("SPCMDCON: RcGetTimeZoneBias returned : %lx-%lx\n", 
                  glBias.HighPart, glBias.LowPart));   
    
    if (InBatchMode) {
        if (TokenizedLine && TokenizedLine->TokenCount == 3) {
            Status = RcAuthorizePasswordLogon( L"Administrator", TokenizedLine->Tokens->Next->Next->String, NtInstall );
            if(NT_SUCCESS(Status)) {
                goto success_exit;
            }
        } else {
            Status = RcAuthorizePasswordLogon( L"Administrator", L"", NtInstall );
            if(NT_SUCCESS(Status)) {
                goto success_exit;
            }
        }
    } else {       
        // Login only if required
        if (!LoginRequired())
            goto success_exit;
        
        wcscpy(UserNameBuffer,L"Administrator");
        RtlZeroMemory( PasswordBuffer, sizeof(PasswordBuffer) );        

        while (FailureCount < MAX_FAILURES) {
            //
            // get the password
            //

            RcMessageOut( MSG_LOGON_PROMPT_PASSWORD );
            RtlZeroMemory( PasswordBuffer, sizeof(PasswordBuffer) );
            RcPasswordIn(PasswordBuffer, sizeof(PasswordBuffer)/sizeof(WCHAR));

            //
            // authorize the logon attempt
            //
            Status = RcAuthorizePasswordLogon( UserNameBuffer, PasswordBuffer, NtInstall );
              
            if(NT_SUCCESS(Status)) {
                goto success_exit;
            }

            RcMessageOut( MSG_LOGON_FAILURE );
            FailureCount += 1;
        }        
    }

    RcMessageOut( MSG_LOGON_FAILUE_BAD );
    RcMessageOut( MSG_REBOOT_NOW );
    RcTextOut(L"\r\n");

    //
    // wait for the use to press ENTER
    //
    while (SpInputGetKeypress() != ASCI_CR);
        
    return 0;

success_exit:
    //
    // Enable the set command if specified  and not already
    // enabled (would be enabled if registries are corrupted)
    // 
    if (bRegCorrupted) {
        AllowAllPaths = TRUE;
        RcSetSETCommandStatus(TRUE);
    } else {
        RcSetSETCommandStatus(IsSetCommandEnabled());
    }
        
    //
    // set the current drive to the selected install.
    //
    _CurDrive = SelectedInstall->DriveLetter;

    //
    // set the current dir to the correct one.
    //
    RtlZeroMemory( Buffer, sizeof(Buffer) );

    wcscat( Buffer, L"\\" );
    wcscat( Buffer, SelectedInstall->Path );
    wcscat( Buffer, L"\\" );

    u = RcToUpper(SelectedInstall->DriveLetter) - L'A';

    if(_CurDirs[u]) {
        SpMemFree(_CurDirs[u]);
    }

    _CurDirs[u] = SpDupStringW( Buffer );
    firstTime = FALSE;
    RcPurgeHistoryBuffer();
    
    return 1;
}

/*++

Routine Description:

    Checks the "SecurityLevel" value under 
    HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Setup\RecoveryConsole to see
    if login is needed or not
    
Arguments:
    None

Return Value:

    TRUE if Login is required or FALSE otherwise 
--*/
BOOLEAN
LoginRequired(
    VOID
    )
{    
    BOOLEAN         bLogin = TRUE;
    PWSTR           szValueName = L"SecurityLevel";
    HANDLE          hKey = NULL;
    UNICODE_STRING  unicodeStr;
    NTSTATUS        status;
    BYTE            buffer[ sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                                    MAX_PATH * sizeof(WCHAR) ];
    ULONG           ulResultLen = 0;                                    
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;
    OBJECT_ATTRIBUTES   stObjAttr;
    
    PWSTR   szWinLogonKey = 
              L"\\registry\\machine\\xSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Setup\\RecoveryConsole";

    RtlZeroMemory(buffer, sizeof(buffer));
    
    //
    // Load the SOFTWARE hive
    //    
    if (RcOpenHive( gszSoftwareHiveName, gszSoftwareHiveKey )) {
        //
        // Open the key
        //        
        INIT_OBJA( &stObjAttr, &unicodeStr, szWinLogonKey );
        
        status = ZwOpenKey( &hKey, KEY_ALL_ACCESS, &stObjAttr );

        if (NT_SUCCESS(status)) {
            RtlInitUnicodeString( &unicodeStr, szValueName );
            
            //
            // read the value
            //
            status = ZwQueryValueKey( hKey,
                        &unicodeStr,                
                        KeyValuePartialInformation,
                        pKeyValueInfo,
                        sizeof(buffer),
                        &ulResultLen );

            if (NT_SUCCESS(status) && (pKeyValueInfo->Type == REG_DWORD)) {
                bLogin = !(*((PDWORD)(pKeyValueInfo->Data)) == 1);
            }            
        }    

        if (hKey)
            ZwClose(hKey);

        // close the hive
        RcCloseHive( gszSoftwareHiveKey );
    }
    
    
    return bLogin;
}


/*++

Routine Description:

    Checks the "SetCommand" value under 
    HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Setup\RecoveryConsole to see
    if SET command needs to be enabled or disabled
    
Arguments:
    None

Return Value:

    TRUE if Login is required or FALSE otherwise 
--*/
BOOLEAN
IsSetCommandEnabled(
    VOID
    )
{
    BOOLEAN         bSetEnabled = FALSE;
    PWSTR           szValueName = L"SetCommand";
    HANDLE          hKey = NULL;
    UNICODE_STRING  unicodeStr;
    NTSTATUS        status;
    BYTE            buffer[ sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                                    MAX_PATH * sizeof(WCHAR) ];
    ULONG           ulResultLen = 0;                                    
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;
    OBJECT_ATTRIBUTES   stObjAttr;
    
    PWSTR   szWinLogonKey = 
              L"\\registry\\machine\\xSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Setup\\RecoveryConsole";

    RtlZeroMemory(buffer, sizeof(buffer));
    
    //
    // Load the SOFTWARE hive
    //    
    if (RcOpenHive( gszSoftwareHiveName, gszSoftwareHiveKey )) {
        //
        // Open the key
        //        
        INIT_OBJA( &stObjAttr, &unicodeStr, szWinLogonKey );
        
        status = ZwOpenKey( &hKey, KEY_ALL_ACCESS, &stObjAttr );

        if (NT_SUCCESS(status)) {
            RtlInitUnicodeString( &unicodeStr, szValueName );
            
            //
            // read the value
            //
            status = ZwQueryValueKey( hKey,
                        &unicodeStr,                
                        KeyValuePartialInformation,
                        pKeyValueInfo,
                        sizeof(buffer),
                        &ulResultLen );

            if (NT_SUCCESS(status) && (pKeyValueInfo->Type == REG_DWORD)) {
                bSetEnabled = (*((PDWORD)(pKeyValueInfo->Data)) == 1);
            }            
        }    

        if (hKey)
            ZwClose(hKey);

        // close the hive
        RcCloseHive( gszSoftwareHiveKey );
    }
    
    
    return bSetEnabled;
}



LARGE_INTEGER
RcGetTimeZoneBias(
    VOID
    )
/*++

Routine Description:

    Reads the bias information from 
    "\\HKLM\\System\\CurrentControlSet\\Control\\TimeZoneInformation"
    key's "Bias" value. We use our own conversion routine because
    RtlSetTimeZoneInformation() updates the system time (which we
    don't want to change).

Arguments:

    none
    
Return Value:
    0   if error, otherwise value stored in the registry 
    for the key (could be zero).

--*/
{
    LARGE_INTEGER       lBias;
    OBJECT_ATTRIBUTES   stObjAttr;
    HANDLE              hKey = NULL;
    NTSTATUS            status;
    UNICODE_STRING      unicodeStr;
    unsigned            uIndex;
    ULONG               uControl = -1;
    WCHAR               szKeyName[MAX_PATH];
    BYTE                dataBuff[MAX_PATH + 
                            sizeof(KEY_VALUE_PARTIAL_INFORMATION)];
    KEY_VALUE_PARTIAL_INFORMATION   *pKeyData = 
                        (KEY_VALUE_PARTIAL_INFORMATION*)dataBuff;
    ULONG               ulResultLen = 0;         
    UNICODE_STRING      szValueName;
    DWORD               dwDaylightBias = 0;
    DWORD               dwStandardBias = 0;
    BOOLEAN             bSysHiveOpened;

    lBias.QuadPart = 0;             
    
    //
    // open the system hive & determine correct control set to use
    //
    bSysHiveOpened = RcOpenHive(gszSystemHiveName, gszSystemHiveKey);
    
    if (bSysHiveOpened && RcDetermineCorrectControlKey(&uControl)) {
            
        //
        // open the key and read the
        //            
        RtlZeroMemory(pKeyData, sizeof(dataBuff));

        swprintf(szKeyName, 
            L"\\registry\\machine\\xSYSTEM\\ControlSet%03d\\Control\\TimeZoneInformation",
            uControl);             

        INIT_OBJA(&stObjAttr, &unicodeStr, szKeyName);
        RtlInitUnicodeString(&szValueName, L"Bias");

        status = ZwOpenKey(&hKey, KEY_READ, &stObjAttr);

        if (!NT_SUCCESS(status)) {
            KdPrint(("SPCMDCON: RcGetTimeZoneBias - Couldnot open hive key: %ws(%lx)\n", 
                    szKeyName, status));
        } else {
            //
            // Query the "Bias" value under the key
            //
            status = ZwQueryValueKey( hKey,
                            &szValueName,
                            KeyValuePartialInformation,
                            pKeyData,
                            sizeof(dataBuff),
                            &ulResultLen );

            if (NT_SUCCESS(status) && (pKeyData->Type == REG_DWORD)) {
                lBias.QuadPart = Int32x32To64(*(DWORD*)(pKeyData->Data) * 60,
                                            10000000);
                
                
                RtlZeroMemory(pKeyData, sizeof(dataBuff));
                RtlInitUnicodeString(&szValueName, L"DaylightBias");

                //
                // Query the "DaylightBias" value under the key
                //
                status = ZwQueryValueKey( hKey,
                                &szValueName,
                                KeyValuePartialInformation,
                                pKeyData,
                                sizeof(dataBuff),
                                &ulResultLen );

                if (NT_SUCCESS(status) && (pKeyData->Type == REG_DWORD)) {
                    dwDaylightBias = *(DWORD*)(pKeyData->Data);        

                    if (dwDaylightBias == 0 ) {
                        //
                        // there could be a standard bias
                        //
                        RtlZeroMemory(pKeyData, sizeof(dataBuff));
                        RtlInitUnicodeString(&szValueName, L"StandardBias");

                        //
                        // Query the "StandardBias" value under the key
                        //
                        status = ZwQueryValueKey( hKey,
                                        &szValueName,
                                        KeyValuePartialInformation,
                                        pKeyData,
                                        sizeof(dataBuff),
                                        &ulResultLen );
                                        
                        if (NT_SUCCESS(status) && 
                                (pKeyData->Type == REG_DWORD)) {
                            dwStandardBias = *(DWORD*)(pKeyData->Data);
                        }                        
                    }                   
                    
                    lBias.QuadPart += Int32x32To64((dwDaylightBias + dwStandardBias) * 60,
                                                10000000);  
                } else {
                    lBias.QuadPart = 0;  // 
                }
            }

            if (!NT_SUCCESS(status))
                KdPrint(("SPCMDCON: RcGetTimeZoneBias Error:(%lx)", status));
        }
        
        if (hKey)
            ZwClose(hKey);        
    }

    if (bSysHiveOpened)
        RcCloseHive(gszSystemHiveKey);    
        
    return lBias;
}



BOOLEAN
RcIsValidSystemHive(
    VOID
    )
/*++

Routine Description:

   Verifies whether the system hive of the selected NT install
   is fine. Checks for the presence of "Control\Lsa" and 
   "Control\SessionManager" currently under ControlSet.

Arguments:

    none
    
Return Value:

   TRUE - indicates system hive is fine
   FALSE - indicates system hive is corrupted

--*/
{
    BOOLEAN             bResult = FALSE;    
    OBJECT_ATTRIBUTES   stObjAttr;
    HANDLE              hKey = NULL;
    NTSTATUS            status;
    UNICODE_STRING      unicodeStr;
    unsigned            uIndex;
    ULONG               uControl = -1;
    WCHAR               szKeyName[MAX_PATH];
    BOOLEAN             bSysHiveOpened;
    KEY_CHECK_STRUCT    aKeysToCheck[] = {
         { L"\\registry\\machine\\xSYSTEM\\ControlSet%03d\\Control\\Lsa", TRUE },
         { L"\\registry\\machine\\xSYSTEM\\ControlSet%03d\\Control\\Session Manager", TRUE } }; 
            
    //
    // open the system hive & determine correct control set to use
    //
    bSysHiveOpened = RcOpenHive(gszSystemHiveName, gszSystemHiveKey);
    
    if ( bSysHiveOpened && RcDetermineCorrectControlKey(&uControl)) {
        
        bResult = TRUE;

        //
        // open each of the key and then close it to verify its presence
        //
        for (uIndex = 0; 
                uIndex < (sizeof(aKeysToCheck) / sizeof(KEY_CHECK_STRUCT));
                uIndex++) {

            if (aKeysToCheck[uIndex].bControlSet)               
                swprintf(szKeyName, aKeysToCheck[uIndex].szKeyName, uControl);             
            else
                wcscpy(szKeyName, aKeysToCheck[uIndex].szKeyName);
                
            INIT_OBJA(&stObjAttr, &unicodeStr, szKeyName);
        
            status = ZwOpenKey(&hKey, KEY_READ, &stObjAttr);

            if (!NT_SUCCESS(status)) {
                KdPrint(("SPCMDCON: RcIsValidSystemHive - Couldnot open hive key: %ws(%lx)\n", 
                    szKeyName, status));
                    
                bResult = FALSE;
                break;
            }

            if (hKey)
                ZwClose(hKey);
        }
    }

    if (bSysHiveOpened)
        RcCloseHive(gszSystemHiveKey);
    
    return bResult;
}



BOOLEAN
RcOpenHive(
    PWSTR   szHiveName,
    PWSTR   szHiveKey
    )
/*++

Routine Description:

   Opens the requested hive of the selected NT install.

Arguments:

   szHiveName   - hive file name (just file name alone)
   szHiveKey    - the key into which the hive needs to be loaded

Return Value:

   TRUE - indicates sucess
   FALSE - indicates failure

--*/
{
    PWSTR       Hive = NULL;
    PWSTR       HiveKey = NULL;
    PUCHAR      buffer = NULL;
    PWSTR       PartitionPath = NULL;
    NTSTATUS    Status;
    BOOLEAN     bResult = FALSE;


    if ((SelectedInstall == NULL) || (szHiveName == NULL) || (szHiveKey == NULL)) {
        return FALSE;
    }

    //
    // Allocate buffers.
    //
    Hive = SpMemAlloc(MAX_PATH * sizeof(WCHAR));
    HiveKey = SpMemAlloc(MAX_PATH * sizeof(WCHAR));
    buffer = SpMemAlloc(BUFFERSIZE);

    //
    // Get the name of the target patition.
    //
    SpNtNameFromRegion(
        SelectedInstall->Region, // SelectedInstall is a global defined in cmdcons.h
        _CmdConsBlock->TemporaryBuffer,
        _CmdConsBlock->TemporaryBufferSize,
        PartitionOrdinalCurrent
        );

    PartitionPath = SpDupStringW(_CmdConsBlock->TemporaryBuffer);

    //
    // Load the hive
    //
    wcscpy(Hive,PartitionPath);
    SpConcatenatePaths(Hive,SelectedInstall->Path);
    SpConcatenatePaths(Hive,L"system32\\config");
    SpConcatenatePaths(Hive,szHiveName);

    //
    // Form the path of the key into which we will
    // load the hive.  We'll use the convention that
    // a hive will be loaded into \registry\machine\x<hivename>.
    //
    wcscpy(HiveKey, szHiveKey);

    //
    // Attempt to load the key.
    //
    Status = SpLoadUnloadKey(NULL,NULL,HiveKey,Hive);

    if (NT_SUCCESS(Status))
        bResult = TRUE;
    else
        DEBUG_PRINTF(("CMDCONS: Unable to load hive %ws to key %ws (%lx)\n",Hive,HiveKey,Status));
          

    if (Hive != NULL)
        SpMemFree( Hive );

    if (HiveKey != NULL)
        SpMemFree( HiveKey );

    if (buffer != NULL)        
        SpMemFree( buffer );

    return bResult;
}



BOOLEAN
RcCloseHive(
    PWSTR   szHiveKey 
    )
/*++

Routine Description:

   Closes the specified hive of the selected NT install.

Arguments:

   szHiveKey  - specifies the key of the hive to be unloaded

Return Value:

   TRUE - indicates sucess
   FALSE - indicates failure

--*/
{
    NTSTATUS    TmpStatus;
    BOOLEAN     bResult = FALSE;

    if (szHiveKey != NULL) {
        //
        // Unload the hive
        //
        TmpStatus = SpLoadUnloadKey( NULL, NULL, szHiveKey, NULL );

        if (NT_SUCCESS(TmpStatus)) {
            bResult = TRUE;
        } else {
            KdPrint(("CMDCONS: warning: unable to unload key %ws (%lx)\n", szHiveKey, TmpStatus));
        }            
    }            
    
    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\cmdcons\main.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    This module implements the main startup code.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop

BOOLEAN
RcOpenSoftwareHive(
    VOID
    );

//
// Pointer to block of interesting values and other stuff
// passed to us by setupdd.sys.
//
PCMDCON_BLOCK _CmdConsBlock;

//
// Address where we were loaded.
//
PVOID ImageBase;


VOID
RcPrintPrompt(
    VOID
    );

ULONG
GetTimestampForDriver(
    ULONG_PTR Module
    )
{
    PIMAGE_DOS_HEADER DosHdr;
    ULONG dwTimeStamp;

    __try {
        DosHdr = (PIMAGE_DOS_HEADER) Module;
        if (DosHdr->e_magic == IMAGE_DOS_SIGNATURE) {
            dwTimeStamp = ((PIMAGE_NT_HEADERS32) ((LPBYTE)Module + DosHdr->e_lfanew))->FileHeader.TimeDateStamp;
        } else if (DosHdr->e_magic == IMAGE_NT_SIGNATURE) {
            dwTimeStamp = ((PIMAGE_NT_HEADERS32) DosHdr)->FileHeader.TimeDateStamp;
        } else {
            dwTimeStamp = 0;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dwTimeStamp = 0;
    }

    return dwTimeStamp;
}

void
FormatTime(
    ULONG TimeStamp,
    LPWSTR  TimeBuf
    )
{
    static WCHAR   mnames[] = { L"JanFebMarAprMayJunJulAugSepOctNovDec" };
    LARGE_INTEGER  MyTime;
    TIME_FIELDS    TimeFields;


    RtlSecondsSince1970ToTime( TimeStamp, &MyTime );
    ExSystemTimeToLocalTime( &MyTime, &MyTime );
    RtlTimeToTimeFields( &MyTime, &TimeFields );

    wcsncpy( TimeBuf, &mnames[(TimeFields.Month - 1) * 3], 3 );
    swprintf(
        &TimeBuf[3],
        L" %02d, %04d @ %02d:%02d:%02d",
        TimeFields.Day,
        TimeFields.Year,
        TimeFields.Hour,
        TimeFields.Minute,
        TimeFields.Second
        );
}


BOOLEAN
LoadNonDefaultLayout(
  IN LPCWSTR BootDevicePath,
  IN LPCWSTR DirOnBootDevice,
  IN PVOID SifHandle
  )
/*++
Routine Description:

  Loads the non-default keyboard layout at users request

Arguments:

  BootDevicePath - NT/Arc boot device path
  DirOnBootDevice - Directory on boot device (e.g. i386)
  SifHandle - Handle to txtsetup.sif

Return Value:

  TRUE, if user selected a keyboard layout and its was loaded.
  Otherwise FALSE

--*/  
{
  BOOLEAN ShowMenu = FALSE;
  ULONG KeyPressed = 0;
  LARGE_INTEGER Delay;
  LONG SecondsToDelay = 5;
  WCHAR DevicePath[MAX_PATH] = {0};  

  if (BootDevicePath) {
    wcscpy(DevicePath, BootDevicePath);
    SpStringToLower(DevicePath);

    //
    // All KBD dlls are not present on floppies
    //
    if (!wcsstr(DevicePath, L"floppy")) {
      SpInputDrain();
      SpCmdConsEnableStatusText(TRUE);
      
      Delay.HighPart = -1;
      Delay.LowPart = -10000000;  

      do {
        //
        // prompt the user
        //
        SpDisplayStatusText(SP_KBDLAYOUT_PROMPT, 
              (UCHAR)(ATT_FG_BLACK | ATT_BG_WHITE),
              SecondsToDelay);

        //
        // sleep for a second
        //
        KeDelayExecutionThread(ExGetPreviousMode(), FALSE, &Delay);
        SecondsToDelay--;            

        if (SpInputIsKeyWaiting())
            KeyPressed = SpInputGetKeypress();    
      } 
      while (SecondsToDelay && KeyPressed != ASCI_CR && KeyPressed != ASCI_ESC);    

      if (KeyPressed == ASCI_CR)
        ShowMenu = TRUE;
        
      if (!ShowMenu) {
        //
        // clear status text
        //
        SpDisplayStatusOptions(DEFAULT_ATTRIBUTE, 0);  
      } else {
        //
        // allow the user to select a particular layout dll and load it
        //
        pRcCls();
        SpSelectAndLoadLayoutDll((PWSTR)DirOnBootDevice, SifHandle, TRUE);
      }

      SpCmdConsEnableStatusText(FALSE);
    }      
  }    

  return ShowMenu;
}

ULONG
CommandConsole(
    IN PCMDCON_BLOCK CmdConsBlock
    )

/*++

Routine Description:

    Top-level entry point for the command interpreter.
    Initializes global data and then goes into the processing loop.
    When the processing loop terminates, cleans up and exits.

Arguments:

    CmdConsBlock - supplies interesting values from setupdd.sys.

Return Value:

    None.

--*/

{
    PTOKENIZED_LINE TokenizedLine;
    BOOLEAN b = FALSE;
    ULONG rVal;
    WCHAR buf[64];


    SpdInitialize();

    _CmdConsBlock = CmdConsBlock;

    //
    // Make sure temporary buffer is large enough to hold a line of input
    // from the console.
    //
    ASSERT(_CmdConsBlock->TemporaryBufferSize > ((RC_MAX_LINE_LEN+1) * sizeof(WCHAR)));

    RcConsoleInit();
    RcInitializeCurrentDirectories();  
    FormatTime( GetTimestampForDriver( (ULONG_PTR)ImageBase ), buf );
    RcMessageOut( MSG_SIGNON );        

    if (LoadNonDefaultLayout(_CmdConsBlock->BootDevicePath, 
          _CmdConsBlock->DirectoryOnBootDevice, _CmdConsBlock->SifHandle)){
      pRcCls();
      RcMessageOut( MSG_SIGNON );        
    }      

    RedirectToNULL = TRUE;
    pRcExecuteBatchFile( L"\\cmdcons\\cmdcons.txt", NULL, TRUE );
    RedirectToNULL = FALSE;

    if (SelectedInstall == NULL) {
        if (RcCmdLogon( NULL ) == FALSE) {
            rVal = 0;
            goto exit;
        }
    }

    if (!RcIsNetworkDrive((PWSTR)(_CmdConsBlock->BootDevicePath))) {
        RcHideNetCommands();
    }

	//
	// Disable non ARC commands
	// 
	if (RcIsArc()) {
		RcDisableCommand(RcCmdFixBootSect);
		RcDisableCommand(RcCmdFixMBR);
	}

    do {
        RcPrintPrompt();
        RcLineIn(_CmdConsBlock->TemporaryBuffer,RC_MAX_LINE_LEN);
        TokenizedLine = RcTokenizeLine(_CmdConsBlock->TemporaryBuffer);
        if(TokenizedLine->TokenCount) {
            rVal = RcDispatchCommand(TokenizedLine);
            if (rVal == 0 || rVal == 2) {
                b = FALSE;
            } else {
                b = TRUE;
            }
            RcTextOut(L"\r\n");
        } else {
            b = TRUE;
        }
        RcFreeTokenizedLine(&TokenizedLine);
    } while(b);

exit:
    SpdTerminate();
    RcTerminateCurrentDirectories();
    RcConsoleTerminate();

    return rVal == 2 ? 1 : 0;
}


VOID
RcPrintPrompt(
    VOID
    )
{
    RcGetCurrentDriveAndDir(_CmdConsBlock->TemporaryBuffer);
    wcscat(_CmdConsBlock->TemporaryBuffer,L">");
    RcRawTextOut(_CmdConsBlock->TemporaryBuffer,-1);
}


VOID
RcNtError(
    IN NTSTATUS Status,
    IN ULONG    FallbackMessageId,
    ...
    )
{
    va_list arglist;

    //
    // Some NT errors receive special treatment.
    //
    switch(Status) {

    case STATUS_NO_SUCH_FILE:
        RcMessageOut(MSG_NO_FILES);
        return;

    case STATUS_NO_MEDIA_IN_DEVICE:
        RcMessageOut(MSG_NO_MEDIA_IN_DEVICE);
        return;

    case STATUS_ACCESS_DENIED:
    case STATUS_CANNOT_DELETE:
        RcMessageOut(MSG_ACCESS_DENIED);
        return;

    case STATUS_OBJECT_NAME_COLLISION:
        va_start(arglist,FallbackMessageId);
        vRcMessageOut(MSG_ALREADY_EXISTS,&arglist);
        va_end(arglist);
        return;

    case STATUS_OBJECT_NAME_INVALID:
        RcMessageOut(MSG_INVALID_NAME);
        return;

    case STATUS_OBJECT_NAME_NOT_FOUND:
    case STATUS_OBJECT_PATH_NOT_FOUND:
        RcMessageOut(MSG_FILE_NOT_FOUND);
        return;

    case STATUS_DIRECTORY_NOT_EMPTY:
        RcMessageOut(MSG_DIR_NOT_EMPTY);
        return;

    case STATUS_NOT_A_DIRECTORY:
        RcMessageOut(MSG_NOT_DIRECTORY);
        return;

    case STATUS_SHARING_VIOLATION:
        RcMessageOut(MSG_SHARING_VIOLATION);
        return;

    case STATUS_CONNECTION_IN_USE:
        RcMessageOut(MSG_CONNECTION_IN_USE);
        return;
    }

    //
    // Not a apecial case, print backup message.
    //
    va_start(arglist,FallbackMessageId);
    vRcMessageOut(FallbackMessageId,&arglist);
    va_end(arglist);
}


VOID
RcDriverUnLoad(
    IN PDRIVER_OBJECT DriverObject
    )
{
}


ULONG
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    //
    // All we do here is to call back into setupdd.sys, providing the address
    // of our main entry point, which it will call later. We also save away
    // our image base.
    //
    DriverObject->DriverUnload = RcDriverUnLoad;
    CommandConsoleInterface(CommandConsole);
    ImageBase = DriverObject->DriverStart;
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\cmdcons\repair.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    repair.c

Abstract:

    This module contains the code necessary for the
    repair command.

Author:

    Wesley Witt (wesw) 22-Sept-1998

Revision History:


Repair  PathtoERFiles PathtoNTSourceFiles  /NoConfirm /RepairStartup /Registry /RepairFiles

Description:        Replaces the NT4 Emergency Repair Process Screens

Arguments:

PathtoERFiles

    Path to the Emergency Repair Disk Files (Setup.log, autoexec.nt, config.nt).
    If this is not specified, the default is to prompt the user with 2 choices:
    Use a floppy, or use the repair info stored in %windir%\repair

PathtoNTSourceFiles

    Path to the NT CD source files.  By default, this is the CD-ROM if not
    specified. [Kartik Raghavan]  This path does not need to be specified if
    you are repairing the registry and/or the Startup environment.

NoConfirm

    Replace all files in setup.log whose checksums do not match without
    prompting the user.  By default, the user is prompted for each file that
    is different and whether to replace or leave intact.

Registry

    Replace all the registry files in %windir%\system32\config with the original
    copy of the registry saved after setup and located in %windir%\repair.

RepairStartup

    Repair the startup environment / bootfiles/bootsector.
    (This may already be covered in another cmd--Wes?)

Repair Files

    Compares the checksums of the files listed in setup.log to what's
    on system.  If a file doesn't match, then the user is prompted to replace
    the file with the one from the NT Source Files.  The user is not prompted
    if the /NoConfirm switch is specified.

Usage:

    Repair a:\ d:\i386 /RepairStartup
    Repair



--*/

#include "cmdcons.h"
#pragma hdrstop


#define SETUP_REPAIR_DIRECTORY      L"repair"
#define SETUP_LOG_FILENAME          L"\\setup.log"

#define FLG_NO_CONFIRM              0x00000001
#define FLG_STARTUP                 0x00000002
#define FLG_REGISTRY                0x00000004
#define FLG_FILES                   0x00000008


LONG
RcPromptForDisk(
    void
    )
{
    PWSTR TagFile = NULL;
    ULONG i;
    WCHAR DevicePath[MAX_PATH];
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    HANDLE Handle;

/*
    SpGetSourceMediaInfo(
        _CmdConsBlock->SifHandle,
        L"",
        NULL,
        &TagFile,
        NULL
        );
 */
    for (i=0; i<IoGetConfigurationInformation()->CdRomCount; i++) {
        swprintf( DevicePath, L"\\Device\\Cdrom%u", i );
        SpConcatenatePaths( DevicePath, TagFile );
        INIT_OBJA( &ObjectAttributes, &UnicodeString, DevicePath) ;
        Status = ZwCreateFile(
            &Handle,
            FILE_GENERIC_READ,
            &ObjectAttributes,
            &IoStatusBlock,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ,
            FILE_OPEN,
            0,
            NULL,
            0
            );
        if (NT_SUCCESS(Status)) {
            ZwClose(Handle);
            break;
        }
    }




    return -1;
}


ULONG
RcCmdRepair(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    ULONG i;
    PLINE_TOKEN Token;
    ULONG Flags = 0;
    BOOLEAN Rval;
#ifdef _X86_
    ULONG RepairItems[RepairItemMax] = { 0, 0, 0};
#else
    ULONG RepairItems[RepairItemMax] = { 0, 0};
#endif
    PWSTR RepairPath;
    PDISK_REGION Region;
    PWSTR tmp;
    PWSTR PathtoERFiles = NULL;
    PWSTR ErDevicePath = NULL;
    PWSTR ErDirectory = NULL;
    PWSTR PathtoNTSourceFiles = NULL;
    PWSTR SrcDevicePath = NULL;
    PWSTR SrcDirectory = NULL;


    if (RcCmdParseHelp( TokenizedLine, MSG_REPAIR_HELP )) {
        return 1;
    }

    RcMessageOut(MSG_NYI);
    return 1;

    if (TokenizedLine->TokenCount == 1) {
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }

    //
    // process the command like tokens looking for the options
    //

    for (i=1,Token=TokenizedLine->Tokens->Next; i<TokenizedLine->TokenCount; i++) {
        if (Token->String[0] == L'/' || Token->String[0] == L'-') {
            if (_wcsicmp(&Token->String[1],L"NoConfirm") == 0) {
                Flags |= FLG_NO_CONFIRM;
            } else if (_wcsicmp(&Token->String[1],L"RepairStartup") == 0) {
                Flags |= FLG_STARTUP;
            } else if (_wcsicmp(&Token->String[1],L"Registry") == 0) {
                Flags |= FLG_REGISTRY;
            } else if (_wcsicmp(&Token->String[1],L"RepairFiles") == 0) {
                Flags |= FLG_FILES;
            }
        }
    }

    if (Flags == 0) {
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }

    if (TokenizedLine->Tokens->Next->String[0] != L'/') {
        PathtoERFiles = TokenizedLine->Tokens->Next->String;
        if (TokenizedLine->TokenCount > 2 && TokenizedLine->Tokens->Next->Next->String[0] != L'/') {
            PathtoNTSourceFiles = TokenizedLine->Tokens->Next->Next->String;
        }
    }

    if (Flags & FLG_NO_CONFIRM) {
        SpDrSetRepairFast( TRUE );
    } else {
        SpDrSetRepairFast( FALSE );
    }

    if (Flags & FLG_FILES) {
        RepairItems[RepairFiles] = 1;
    }

    if (Flags & FLG_STARTUP) {
#ifdef _X86_
        RepairItems[RepairBootSect] = 1;
#endif
        RepairItems[RepairNvram] = 1;
    }

    //
    // Get the path to the repair directory
    //

    if (PathtoERFiles == NULL) {
        if (InBatchMode) {
            RcMessageOut(MSG_SYNTAX_ERROR);
            return 1;
        }
        RcMessageOut( MSG_REPAIR_ERFILES_LOCATION );
        if (!RcLineIn(_CmdConsBlock->TemporaryBuffer,_CmdConsBlock->TemporaryBufferSize)) {
            return 1;
        }
    } else {
        wcscpy(_CmdConsBlock->TemporaryBuffer,PathtoERFiles);
        PathtoERFiles = NULL;
    }

    tmp = SpMemAlloc( MAX_PATH );
    if (tmp == NULL) {
        RcMessageOut(STATUS_NO_MEMORY);
        return 1;
    }
    if (!RcFormFullPath( _CmdConsBlock->TemporaryBuffer, tmp, FALSE )) {
        RcMessageOut(MSG_INVALID_PATH);
        SpMemFree(tmp);
        return 1;
    }
    Region = SpRegionFromDosName(tmp);
    if (Region == NULL) {
        SpMemFree(tmp);
        RcMessageOut(MSG_SYNTAX_ERROR);
        return 1;
    }
    ErDirectory = SpDupStringW( &tmp[2] );
    SpNtNameFromRegion( Region, tmp, MAX_PATH, PartitionOrdinalOnDisk );
    ErDevicePath = SpDupStringW( tmp );
    PathtoERFiles = SpMemAlloc( wcslen(ErDirectory) + wcslen(ErDevicePath) + 16 );
    wcscpy( PathtoERFiles, ErDevicePath );
    wcscat( PathtoERFiles, ErDirectory );
    SpMemFree(tmp);

    //
    // get the path to the nt source files, usually the cd
    //

    if (PathtoNTSourceFiles == NULL) {

    } else {

    }

    //
    // do the repair action(s)
    //
/*
    Rval = SpDoRepair(
        _CmdConsBlock->SifHandle,


        _CmdConsBlock->BootDevicePath,
        _CmdConsBlock->DirectoryOnBootDevice,
        RepairPath,
        RepairItems
        );
*/
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\cmdcons\services.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    services.c

Abstract:

    This module implements all access to the services db.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop

#include "ntregapi.h"

// forward-decl
BOOLEAN RcFindService(
    IN LPCWSTR     ServiceName,
    OUT HANDLE*    KeyHandle
    );
BOOLEAN RcFindServiceByDisplayName(
    IN HANDLE      ServicesKey,
    IN LPCWSTR     ServiceName,
    OUT HANDLE*    KeyHandle
    );
BOOLEAN RcGetStartType(
    IN HANDLE      hKey,
    OUT DWORD       *start_type
    );
BOOLEAN RcSetStartType(
    IN HANDLE      hKey,
    OUT DWORD      start_type
    );
BOOLEAN RcPrintStartType(
    IN ULONG       msg_id,
    IN DWORD       start_type
    );

RcOpenHive(
    PWSTR   szHiveName,
    PWSTR   szHiveKey
    );

BOOLEAN
RcCloseHive(
    PWSTR   szHiveKey 
    );
    
BOOLEAN RcOpenSystemHive();
BOOLEAN RcCloseSystemHive();
BOOLEAN RcDetermineCorrectControlKey(
    OUT DWORD *    pCorrectKey
    );


ULONG
RcCmdEnableService(
    IN PTOKENIZED_LINE TokenizedLine
    )

/*++

Routine Description:

    Top-level routine supporting the enable command in the setup diagnostic
    command interpreter.

Arguments:

    TokenizedLine - supplies structure built by the line parser describing
        each string on the line as typed by the user.

Return Value:

    None.

--*/

{
    DWORD           correctKey = 0;
    DWORD           new_start_type = 4;
    DWORD           start_type = 0;
    HANDLE          hkey = 0;

    ASSERT(TokenizedLine->TokenCount >= 1);

    // there should be three tokens,
    //    enable_service
    //    the name of the service/driver to be enabled
    //    the start_type of the service

    if (RcCmdParseHelp( TokenizedLine, MSG_SERVICE_ENABLE_HELP )) {
        return 1;
    }

    if(TokenizedLine->TokenCount == 2) {
        // just display the current setting

        RcOpenSystemHive();

        if( RcFindService( TokenizedLine->Tokens->Next->String, &hkey ) ) {
            RcMessageOut( MSG_SERVICE_FOUND, TokenizedLine->Tokens->Next->String );
            if( RcGetStartType(hkey, &start_type ) ) {
                RcPrintStartType( MSG_SERVICE_CURRENT_STATE, start_type );
                RcMessageOut( MSG_START_TYPE_NOT_SPECIFIED );
            }
        } else {
            RcMessageOut( MSG_SERVICE_NOT_FOUND, TokenizedLine->Tokens->Next->String );
        }
        NtClose( hkey );

        RcCloseSystemHive();

    } else if(TokenizedLine->TokenCount == 3) {
        // change the setting
        RcOpenSystemHive();

        if( RcFindService( TokenizedLine->Tokens->Next->String, &hkey ) ) {
            RcMessageOut( MSG_SERVICE_FOUND, TokenizedLine->Tokens->Next->String );
            // we found it - open and retrieve the start type
            if( RcGetStartType(hkey, &start_type ) ) {

                if( !_wcsicmp( TokenizedLine->Tokens->Next->Next->String, L"SERVICE_BOOT_START" ) ) {
                    new_start_type = 0;
                } else if( !_wcsicmp( TokenizedLine->Tokens->Next->Next->String, L"SERVICE_SYSTEM_START" ) ) {
                    new_start_type = 1;
                } else if( !_wcsicmp( TokenizedLine->Tokens->Next->Next->String, L"SERVICE_AUTO_START" ) ) {
                    new_start_type = 2;
                } else if( !_wcsicmp( TokenizedLine->Tokens->Next->Next->String, L"SERVICE_DEMAND_START" ) ) {
                    new_start_type = 3;
                } else {
                    new_start_type = -1;
                }

                if( new_start_type == start_type ) {
                    // the service is already in the state
                    RcPrintStartType( MSG_SERVICE_SAME_STATE, start_type );
                } else if( new_start_type != -1 ) {
                    // print the old start type
                    RcPrintStartType( MSG_SERVICE_CURRENT_STATE, start_type );

                    // setup the service
                    if( RcSetStartType( hkey, new_start_type  ) ) {
                        RcPrintStartType( MSG_SERVICE_CHANGE_STATE, new_start_type );
                    }
                } else {
                    RcMessageOut( MSG_SERVICE_ENABLE_SYNTAX_ERROR );
                }
            }

            // close the key
            NtClose( hkey );

        } else {
            // we couldn't find the service - report an error
            RcMessageOut( MSG_SERVICE_NOT_FOUND, TokenizedLine->Tokens->Next->String );
        }

        RcCloseSystemHive();

    } else {
        // oops, we didn't get two or three parameters, print a help string.
        RcMessageOut( MSG_SERVICE_ENABLE_HELP );
    }

    return 1;
}

ULONG
RcCmdDisableService(
    IN PTOKENIZED_LINE TokenizedLine
    )

/*++

Routine Description:

    Top-level routine supporting the disable command in the setup diagnostic
    command interpreter.

Arguments:

    TokenizedLine - supplies structure built by the line parser describing
        each string on the line as typed by the user.

Return Value:

    None.

--*/

{
    HANDLE          hkey;
    DWORD           start_type;
    WCHAR           start_type_string[10];
    PLINE_TOKEN     Token;
    BOOL            syntaxError = FALSE;
    BOOL            doHelp = FALSE;
    LPCWSTR         Arg;


    if (RcCmdParseHelp( TokenizedLine, MSG_SERVICE_DISABLE_HELP )) {
        return 1;
    }

    RtlZeroMemory( (VOID *)&start_type_string, sizeof( WCHAR ) * 10 );

    // the command will print the old start_type of the
    // service before it asks for verification to disable it.

    if(TokenizedLine->TokenCount == 2) {

        // find the service key
        RcOpenSystemHive();
        if( RcFindService( TokenizedLine->Tokens->Next->String, &hkey ) ) {
            RcMessageOut( MSG_SERVICE_FOUND, TokenizedLine->Tokens->Next->String );
            // we found it - open and retrieve the start type
            if( RcGetStartType(hkey, &start_type ) ) {
                if( start_type != SERVICE_DISABLED ) {
                    // print the old start type
                    RcPrintStartType( MSG_SERVICE_CURRENT_STATE, start_type );
                    // disable the service
                    if( RcSetStartType( hkey, SERVICE_DISABLED  ) ) {
                        RcPrintStartType( MSG_SERVICE_CHANGE_STATE, SERVICE_DISABLED );
                    }
                } else {
                    RcMessageOut( MSG_SERVICE_ALREADY_DISABLED, TokenizedLine->Tokens->Next->String );
                }
            }
            // close the key
            NtClose( hkey );

        } else {
            // we couldn't find the service - report an error
            RcMessageOut( MSG_SERVICE_NOT_FOUND, TokenizedLine->Tokens->Next->String );
        }
        RcCloseSystemHive();

    } else {
        // oops, we didn't get two parameters, print a help string.
        RcMessageOut( MSG_SERVICE_DISABLE_HELP );
    }

    return 1;
}

BOOLEAN
RcFindService(
    IN LPCWSTR ServiceName,
    OUT PHANDLE KeyHandle
    )

/*++

Routine Description:
   Attempts to find and open the registry key for a particular
   service by its key name in

   HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services.

   If it fails, it will call RcFindServiceByDisplayName() to
   locate the service by the DisplayName string value.

Arguments:

   ServiceName - the name of the service as a wstring.

   KeyHandle - pointer to a HANDLE where the function should
               return the open registry handle.

               this handle needs to be closed when the key is no
               longer needed.

Return Value:

   TRUE indicates sucess.
   FALSE indicates that it couldn't find the service or failure.

--*/

{
    NTSTATUS                      Status;
    WCHAR                         RegPath[ MAX_PATH ];
    OBJECT_ATTRIBUTES             Obja;
    DWORD                         correctKey;

    UNICODE_STRING                ServiceString;
    HANDLE                        ServiceKeyHandle;


    // zero out the buffer
    RtlZeroMemory( (VOID * )&RegPath,
        sizeof( WCHAR ) * MAX_PATH );

    // find the correct controlset key
    if( !RcDetermineCorrectControlKey( &correctKey ) ) {
        return FALSE;
    }

    // prepend HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services to
    // the supplied parameter
    swprintf( RegPath, L"\\registry\\machine\\xSYSTEM\\ControlSet%03d\\Services\\", correctKey );
    wcscat( RegPath, ServiceName );

    // build the unicode string
    RtlInitUnicodeString( &ServiceString, RegPath );
    InitializeObjectAttributes( &Obja,&ServiceString,
        OBJ_CASE_INSENSITIVE, NULL, NULL);

    // attempt to open the key.
    Status = ZwOpenKey( &ServiceKeyHandle, KEY_ALL_ACCESS, &Obja );

    if( NT_SUCCESS( Status) ) {
        // if we suceeded, set and return
        // the handle.
        *KeyHandle = ServiceKeyHandle;
    } else {

        // build the unicode string
        swprintf( RegPath, L"\\registry\\machine\\xSYSTEM\\ControlSet%03d\\Services", correctKey );
        RtlInitUnicodeString( &ServiceString, RegPath );
        InitializeObjectAttributes( &Obja,&ServiceString,
            OBJ_CASE_INSENSITIVE, NULL, NULL);

        // open a handle to \\registry\\machine\\xSYSTEM\\ControlSet%03d\\Services
        if( NT_SUCCESS( ZwOpenKey( &ServiceKeyHandle, KEY_ALL_ACCESS, &Obja ) ) ) {
            if( !RcFindServiceByDisplayName( ServiceKeyHandle, ServiceName, KeyHandle ) ) {
                // if we failed, NULL out KeyHandle, and return FALSE.
                DEBUG_PRINTF(( "CMDCONS: failed to find key!\n" ));
                *KeyHandle = INVALID_HANDLE_VALUE;
                if( !NT_SUCCESS( NtClose( ServiceKeyHandle ) ) ) {
                    DEBUG_PRINTF(( "CMDCONS: failed to close service key handle\n" ));
                }
                return FALSE;
            }


            // we found the key!
            // close the service key handle
            if( !NT_SUCCESS( NtClose( ServiceKeyHandle ) ) ) {
                DEBUG_PRINTF(( "CMDCONS: failed to close service key handle\n" ));
            }
        } else {
            DEBUG_PRINTF(( "CMDCONS: failed to open service key handle\n" ));
            RcMessageOut( MSG_SYSTEM_MISSING_CURRENT_CONTROLS );
        }
    }

    // return true
    return TRUE;
}

// buffersizes
#define sizeof_buffer1 sizeof( KEY_FULL_INFORMATION ) + (MAX_PATH+1) * sizeof( WCHAR )
#define sizeof_buffer2 sizeof( KEY_BASIC_INFORMATION ) + (MAX_PATH+1) * sizeof( WCHAR )
#define sizeof_buffer3 sizeof( KEY_VALUE_PARTIAL_INFORMATION ) + (MAX_PATH+1) * sizeof( WCHAR )

BOOLEAN
RcFindServiceByDisplayName(
    IN HANDLE ServicesKey,
    IN LPCWSTR ServiceName,
    OUT PHANDLE KeyHandle
    )

/*++

Routine Description:
   Attempts to find and open the registry key for a particular
   service by the DisplayName string value.

Arguments:

   SevicesKey - an open handle to the correct Services Key to search under

   ServiceName - the name of the service as a wstring.

   KeyHandle - pointer to a HANDLE where the function should
               return the open registry handle.

               this handle needs to be closed when the key is no
               longer needed.


Return Value:

   TRUE indicates sucess.
   FALSE indicates that it couldn't find the service or failure.

--*/
{

    WCHAR                            ValueName[] = L"DisplayName";

    BYTE                             buffer1[ sizeof_buffer1 ];
    BYTE                             buffer2[ sizeof_buffer2 ];
    BYTE                             buffer3[ sizeof_buffer3 ];

    KEY_FULL_INFORMATION             * pKeyFullInfo;
    KEY_BASIC_INFORMATION            * pKeyBasicInfo;
    KEY_VALUE_PARTIAL_INFORMATION    * pKeyValuePartialInfo;
    ULONG                            actualBytes;
    ULONG                            loopCount;
    ULONG                            keyCount;
    OBJECT_ATTRIBUTES                Obja;
    HANDLE                           newHandle;
    UNICODE_STRING                   unicodeString;
    BOOL                             keyFound = FALSE;

    // zero out the buffer
    RtlZeroMemory( (VOID * ) &(buffer1[0]), sizeof_buffer1 );

    pKeyFullInfo= (KEY_FULL_INFORMATION*) &( buffer1[0] );
    pKeyBasicInfo = (KEY_BASIC_INFORMATION* ) &( buffer2[0] );
    pKeyValuePartialInfo = (KEY_VALUE_PARTIAL_INFORMATION* ) &(buffer3[0]);

    // do a ZwQueryKey() to find out the number of subkeys.
    if( !NT_SUCCESS( ZwQueryKey( ServicesKey,
        KeyFullInformation,
        pKeyFullInfo,
        sizeof_buffer1,
        &actualBytes ) ) ) {
        *KeyHandle = INVALID_HANDLE_VALUE;
        DEBUG_PRINTF(( "FindServiceByDisplayName: failed to get number of keys!\n" ));
        return FALSE;
    }

    keyCount = pKeyFullInfo->SubKeys;

    // loop
    for( loopCount = 0; loopCount < keyCount; loopCount++ ) {
        // zero out the buffer
        RtlZeroMemory( (VOID * ) &(buffer2[0]), sizeof_buffer2 );

        // zero out the buffer
        RtlZeroMemory( (VOID * ) &(buffer3[0]), sizeof_buffer3 );

        // do an ZwEnumerateKey() to find the name of the subkey
        ZwEnumerateKey( ServicesKey,
            loopCount,
            KeyBasicInformation,
            pKeyBasicInfo,
            sizeof_buffer2,
            &actualBytes );

        // setup the ZwOpenKey() with the name we just got back
        RtlInitUnicodeString( &unicodeString, pKeyBasicInfo->Name );
        InitializeObjectAttributes( &Obja, &unicodeString,
            OBJ_CASE_INSENSITIVE, ServicesKey, NULL);

        // do a ZwOpenKey() to open the key
        if( !NT_SUCCESS( ZwOpenKey( &newHandle, KEY_ALL_ACCESS, &Obja ) ) ) {
            DEBUG_PRINTF(( "FindServiceByDisplayName: failed to open the subkey?!\n" ));
        }

        // do a ZwQueryKeyValue() to find the key value DisplayName if it exists
        RtlInitUnicodeString( &unicodeString, ValueName );

        if( !NT_SUCCESS( ZwQueryValueKey( newHandle,
            &unicodeString,
            KeyValuePartialInformation,
            pKeyValuePartialInfo,
            sizeof_buffer3,
            &actualBytes
            )
            )
            ) {
            DEBUG_PRINTF(( "FindServiceByDisplayName: display name get failed\n" ));
        } else {
            // if the ZwQueryKeyValue() succeeded
            if( pKeyValuePartialInfo->Type != REG_SZ ) {
                DEBUG_PRINTF(( "FindServiceByDisplayName: paranoia!! mismatched key type?!\n" ));
            } else {
                // paranoia check SUCCEEDED
                // if the value matches, break out of the loop
                if( _wcsicmp( (WCHAR*)&(pKeyValuePartialInfo->Data[0]), ServiceName ) == 0 ) {
                    keyFound = TRUE;
                    break;
                }
            }
        }

        // close the key
        if( !NT_SUCCESS( ZwClose( newHandle ) ) ) {
            DEBUG_PRINTF(( "FindServiceByDisplayName: Failure closing the handle!!" ));
        }
    }

    // return the handle to the opened key.
    if( keyFound == TRUE ) {
        *KeyHandle = newHandle;
        return TRUE;
    }

    *KeyHandle = INVALID_HANDLE_VALUE;
    return FALSE;
}

BOOLEAN
RcGetStartType(
    IN HANDLE hKey,
    OUT PULONG start_type
    )

/*++

Routine Description:
   Given an open service key, gets the start_type of the service.

Arguments:

   hKey - a handle to the open service key

   start_type - integer indicating the start type of the service

               SERVICE_BOOT_START   - 0x0
               SERVICE_SYSTEM_START - 0x1
               SERVICE_AUTO_START   - 0x2
               SERVUCE_DEMAMD_START - 0x3
               SERVICE_DISABLED     - 0x4

Return Value:

   TRUE indicates sucess.
   FALSE indicates failure.

--*/

{
    BYTE                                   buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 100 ]; // just grab a bunch of bytes
    ULONG                                  resultSize;
    KEY_VALUE_PARTIAL_INFORMATION          * keyPartialInfo;
    UNICODE_STRING                         StartKey;
    WCHAR                                  KEY_NAME[] = L"Start";


    RtlZeroMemory( (VOID * )&(buffer[0]),
        sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 100 );

    keyPartialInfo = (KEY_VALUE_PARTIAL_INFORMATION*)&(buffer[0]);

    ASSERT( keyPartialInfo );

    RtlInitUnicodeString( &StartKey, KEY_NAME );

    if( !NT_SUCCESS( ZwQueryValueKey( hKey,
        &StartKey,
        KeyValuePartialInformation,
        keyPartialInfo,
        sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 100,
        &resultSize
        )
        )
        ) {
        DEBUG_PRINTF(( "CMDCONS: start type get failed\n" ));
        RcMessageOut( MSG_SERVICE_MISSING_START_KEY );
        *start_type = -1;
        return FALSE;
    }

    // paranoia check
    if( keyPartialInfo->Type != REG_DWORD ) {
        RcMessageOut( MSG_SERVICE_MISSING_START_KEY );
        DEBUG_PRINTF(( "CMDCONS: mismatched key type?!\n" ));
        *start_type = -1;
        return FALSE;
    }

    *start_type = *( (DWORD*) &(keyPartialInfo->Data[0]) );
    return TRUE;
}

BOOLEAN
RcSetStartType(
    IN HANDLE hKey,
    IN DWORD start_type
    )

/*++

Routine Description:
   Given an open service key, sets the start_type of the service.

Arguments:

   hKey - a handle to the open service key

   start_type - integer indicating the start type of the service

               SERVICE_BOOT_START   - 0x0
               SERVICE_SYSTEM_START - 0x1
               SERVICE_AUTO_START   - 0x2
               SERVUCE_DEMAMD_START - 0x3
               SERVICE_DISABLED     - 0x4

Return Value:

   TRUE indicates sucess.
   FALSE indicates failure.

--*/

{
    UNICODE_STRING                         StartKey;


    RtlInitUnicodeString( &StartKey, L"Start" );

    if( NT_SUCCESS( ZwSetValueKey( hKey,
        &StartKey,
        0,
        REG_DWORD,
        &start_type,
        sizeof( DWORD )
        )
        )
        ) {
        return TRUE;
    }

    RcMessageOut( MSG_SERVICE_MISSING_START_KEY );
    DEBUG_PRINTF(( "CMDCONS: start type get failed\n" ));
    return FALSE;
}

BOOLEAN
RcPrintStartType(
    ULONG msg_id,
    DWORD start_type
    )

/*++

Routine Description:

   Prints the start_type.

Arguments:

   start_type - integer indicating the start type of the service

               SERVICE_BOOT_START   - 0x0
               SERVICE_SYSTEM_START - 0x1
               SERVICE_AUTO_START   - 0x2
               SERVUCE_DEMAMD_START - 0x3
               SERVICE_DISABLED     - 0x4

Return Value:

   TRUE - indicates sucess
   FALSE - indicates failure

--*/

{
    switch( start_type ) {
    case 0:
        RcMessageOut( msg_id, L"SERVICE_BOOT_START" );
        break;
    case 1:
        RcMessageOut( msg_id, L"SERVICE_SYSTEM_START" );
        break;
    case 2:
        RcMessageOut( msg_id, L"SERVICE_AUTO_START" );
        break;
    case 3:
        RcMessageOut( msg_id, L"SERVICE_DEMAND_START" );
        break;
    case 4:
        RcMessageOut( msg_id, L"SERVICE_DISABLED" );
        break;
    default:
        break;
    }
    return TRUE;
}

BOOLEAN
RcOpenSystemHive(
    VOID
    )

/*++

Routine Description:

   Opens the SYSTEM hive of the selected NT install.

Arguments:

   None.

Return Value:

   TRUE - indicates sucess
   FALSE - indicates failure

--*/

{
    PWSTR Hive = NULL;
    PWSTR HiveKey = NULL;
    PUCHAR buffer = NULL;
    PWSTR PartitionPath = NULL;
    NTSTATUS Status;


    if (SelectedInstall == NULL) {
        return FALSE;
    }

    //
    // Allocate buffers.
    //

    Hive = SpMemAlloc(MAX_PATH * sizeof(WCHAR));
    HiveKey = SpMemAlloc(MAX_PATH * sizeof(WCHAR));
    buffer = SpMemAlloc(BUFFERSIZE);

    //
    // Get the name of the target patition.
    //

    SpNtNameFromRegion(
        SelectedInstall->Region, // SelectedInstall is a global defined in cmdcons.h
        _CmdConsBlock->TemporaryBuffer,
        _CmdConsBlock->TemporaryBufferSize,
        PartitionOrdinalCurrent
        );

    PartitionPath = SpDupStringW(_CmdConsBlock->TemporaryBuffer);

    //
    // Load the SYSTEM hive
    //

    wcscpy(Hive,PartitionPath);
    SpConcatenatePaths(Hive,SelectedInstall->Path);
    SpConcatenatePaths(Hive,L"system32\\config");
    SpConcatenatePaths(Hive,L"system");

    //
    // Form the path of the key into which we will
    // load the hive.  We'll use the convention that
    // a hive will be loaded into \registry\machine\x<hivename>.
    //

    wcscpy(HiveKey,L"\\registry\\machine\\xSYSTEM");

    //
    // Attempt to load the key.
    //

    Status = SpLoadUnloadKey(NULL,NULL,HiveKey,Hive);
    if(!NT_SUCCESS(Status)) {
        DEBUG_PRINTF(("CMDCONS: Unable to load hive %ws to key %ws (%lx)\n",Hive,HiveKey,Status));

        SpMemFree( Hive );
        SpMemFree( HiveKey );
        SpMemFree( buffer );

        return FALSE;
    }

    SpMemFree( Hive );
    SpMemFree( HiveKey );
    SpMemFree( buffer );

    return TRUE;
}

BOOLEAN
RcCloseSystemHive(
    VOID
    )

/*++

Routine Description:

   Closes the SYSTEM hive of the selected NT install.

Arguments:

   none.

Return Value:

   TRUE - indicates sucess
   FALSE - indicates failure

--*/

{
    PWSTR HiveKey = NULL;
    NTSTATUS TmpStatus;


    //
    // Allocate buffers.
    //

    HiveKey = SpMemAlloc(MAX_PATH * sizeof(WCHAR));
    wcscpy(HiveKey,L"\\registry\\machine\\xSYSTEM");

    //
    // Unload the SYSTEM hive
    //

    TmpStatus  = SpLoadUnloadKey(NULL,NULL,HiveKey,NULL);
    if(!NT_SUCCESS(TmpStatus)) {
        KdPrint(("CMDCONS: warning: unable to unload key %ws (%lx)\n",HiveKey,TmpStatus));
        SpMemFree( HiveKey );
        return FALSE;
    }

    SpMemFree( HiveKey );

    return TRUE;
}

BOOLEAN
RcDetermineCorrectControlKey(
    OUT PULONG pCorrectKey
    )

/*++

Routine Description:

   Parses the select node and finds the correct ControlSetXXX to use.

Arguments:

   pCorrectKey - pointer to a DWORD which will contain the number.

Return Value:

   TRUE - indicates sucess
   FALSE - indicates failure

--*/

{
    NTSTATUS                      Status;
    WCHAR                         RegPath[ MAX_PATH ];
    OBJECT_ATTRIBUTES             Obja;

    UNICODE_STRING                SelectString;
    HANDLE                        SelectKeyHandle;

    BYTE                                   buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 100 ]; // just grab a bunch of bytes
    ULONG                                  resultSize = 0;
    KEY_VALUE_PARTIAL_INFORMATION          * keyPartialInfo;
    UNICODE_STRING                         SelectValue;
    WCHAR                                  VALUE_NAME[] = L"Current";


    RtlZeroMemory( (VOID * )&(buffer[0]),
        sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 100 );

    keyPartialInfo = (KEY_VALUE_PARTIAL_INFORMATION*)&(buffer[0]);

    ASSERT( keyPartialInfo );

    *pCorrectKey = -1;

    // prepend HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services to
    // the supplied parameter
    wcscpy( RegPath, L"\\registry\\machine\\xSYSTEM\\Select" );

    // build the unicode string
    RtlInitUnicodeString( &SelectString, RegPath );
    InitializeObjectAttributes( &Obja,&SelectString,
        OBJ_CASE_INSENSITIVE, NULL, NULL);

    // we need to determine the correct ControlSet to open
    Status = ZwOpenKey( &SelectKeyHandle, KEY_ALL_ACCESS, &Obja );

    if( NT_SUCCESS( Status ) ) {
        RtlInitUnicodeString( &SelectValue, VALUE_NAME );

        Status = ZwQueryValueKey( SelectKeyHandle,
            &SelectValue,
            KeyValuePartialInformation,
            keyPartialInfo,
            sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 100,
            &resultSize
            );

        if( !NT_SUCCESS(Status) || Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
            // couldn't find correct control value!
            DEBUG_PRINTF(( "CMDCONS: failed to find correct control value!\n" ));
        } else {
            // we found a control value
            // check if it's ok
            if( keyPartialInfo->Type != REG_DWORD ) {
                // paranoia check failed
                DEBUG_PRINTF(( "CMDCONS: paranoia check failed?!\n" ));
                DEBUG_PRINTF(( "CMDCONS: mismatched key type?!\n" ));
                DEBUG_PRINTF(( "CMDCONS: key type of %d?!\n", keyPartialInfo->Type ));
                DEBUG_PRINTF(( "CMDCONS: resultsize of %d?!\n", resultSize ));
            } else {
                // parnoia check sucess
                *pCorrectKey = *( (DWORD*) &(keyPartialInfo->Data[0]) );
                Status = NtClose( SelectKeyHandle );
                if( !NT_SUCCESS ( Status ) ) {
                    DEBUG_PRINTF(( "CMDCONS: failure closing handle?!\n" ));
                }
                return TRUE;
            }
        }
    }

    // failed to find the Select node.
    RcMessageOut( MSG_SYSTEM_MISSING_CURRENT_CONTROLS );
    DEBUG_PRINTF(( "CMDCONS: failed to find select node!\n", *pCorrectKey ));

    Status = NtClose( SelectKeyHandle );
    if( !NT_SUCCESS ( Status ) ) {
        DEBUG_PRINTF(( "CMDCONS: failure closing handle?!\n" ));
    }

    return FALSE;
}


ULONG
RcCmdListSvc(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
    #define DISPLAY_BUFFER_SIZE 512
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE ServiceKeyHandle = NULL;
    ULONG ControlSetNumber;
    ULONG cb;
    ULONG KeyCount;
    ULONG i;
    HANDLE ValueHandle;
    ULONG StartType;
    PWSTR DisplayBuffer = NULL;
    PKEY_BASIC_INFORMATION bi;
    PKEY_VALUE_PARTIAL_INFORMATION pi;
    WCHAR ServiceName[64];
    PWSTR DisplayName;
    static ULONG StartTypeIds[] = { 
                                  MSG_SVCTYPE_BOOT,
                                  MSG_SVCTYPE_SYSTEM,
                                  MSG_SVCTYPE_AUTO,
                                  MSG_SVCTYPE_MANUAL,
                                  MSG_SVCTYPE_DISABLED
                                };
    static WCHAR *StartTypeStr[sizeof(StartTypeIds)/sizeof(ULONG)] = { 0 };
    static WCHAR *DefaultSvcTypes[sizeof(StartTypeIds)/sizeof(ULONG)] = 
                    { L"Boot", L"System", L"Auto", L"Manual", L"Disabled" };

    if (!StartTypeStr[0]) {
      //
      // load all the service type strings
      //
      ULONG Index;
      
      for (Index = 0; Index < sizeof(StartTypeIds)/sizeof(ULONG); Index++) {
        StartTypeStr[Index] = SpRetreiveMessageText(ImageBase, StartTypeIds[Index],
                                          NULL, 0);

        if (!StartTypeStr[Index])
          StartTypeStr[Index] = DefaultSvcTypes[Index];
      }
    }

    if (RcCmdParseHelp( TokenizedLine, MSG_LISTSVC_HELP )) {
        return 1;
    }

    if (!RcOpenSystemHive()) {
        return 1;
    }

    pRcEnableMoreMode();

    if (!RcDetermineCorrectControlKey( &ControlSetNumber ) ) {
        goto exit;
    }

    DisplayBuffer = (PWSTR) SpMemAlloc( DISPLAY_BUFFER_SIZE );
    if (DisplayBuffer == NULL) {
        goto exit;
    }

    swprintf( _CmdConsBlock->TemporaryBuffer, L"\\registry\\machine\\xSYSTEM\\ControlSet%03d\\Services\\", ControlSetNumber );
    RtlInitUnicodeString( &UnicodeString, _CmdConsBlock->TemporaryBuffer );
    InitializeObjectAttributes( &Obja, &UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL );

    Status = ZwOpenKey( &ServiceKeyHandle, KEY_ALL_ACCESS, &Obja );
    if (!NT_SUCCESS(Status)) {
        goto exit;
    }

    Status = ZwQueryKey(
        ServiceKeyHandle,
        KeyFullInformation,
        _CmdConsBlock->TemporaryBuffer,
        _CmdConsBlock->TemporaryBufferSize,
        &cb
        );
    if (!NT_SUCCESS(Status)) {
        goto exit;
    }

    KeyCount = ((KEY_FULL_INFORMATION*)_CmdConsBlock->TemporaryBuffer)->SubKeys;
    bi = (PKEY_BASIC_INFORMATION)_CmdConsBlock->TemporaryBuffer;
    pi = (PKEY_VALUE_PARTIAL_INFORMATION)_CmdConsBlock->TemporaryBuffer;

    for (i=0; i<KeyCount; i++) {

        RtlZeroMemory( DisplayBuffer, DISPLAY_BUFFER_SIZE );
        RtlZeroMemory( _CmdConsBlock->TemporaryBuffer, _CmdConsBlock->TemporaryBufferSize );

        Status = ZwEnumerateKey(
            ServiceKeyHandle,
            i,
            KeyBasicInformation,
            _CmdConsBlock->TemporaryBuffer,
            _CmdConsBlock->TemporaryBufferSize,
            &cb
            );
        if (!NT_SUCCESS(Status)) {
            goto exit;
        }

        wcsncpy( ServiceName, bi->Name, (sizeof(ServiceName)/sizeof(WCHAR))-1 );

        RtlInitUnicodeString( &UnicodeString, bi->Name );
        InitializeObjectAttributes( &Obja, &UnicodeString, OBJ_CASE_INSENSITIVE, ServiceKeyHandle, NULL );

        Status = ZwOpenKey( &ValueHandle, KEY_ALL_ACCESS, &Obja );
        if (!NT_SUCCESS(Status)) {
            goto exit;
        }

        RtlInitUnicodeString( &UnicodeString, L"Start" );

        Status = ZwQueryValueKey(
            ValueHandle,
            &UnicodeString,
            KeyValuePartialInformation,
            _CmdConsBlock->TemporaryBuffer,
            _CmdConsBlock->TemporaryBufferSize,
            &cb
            );
        if (!NT_SUCCESS(Status)) {
            ZwClose( ValueHandle );
            continue;
        }

        if (pi->Type != REG_DWORD) {
            StartType = 5;
        } else {
            StartType = *(PULONG)&(pi->Data[0]);
        }

        RtlInitUnicodeString( &UnicodeString, L"DisplayName" );

        Status = ZwQueryValueKey(
            ValueHandle,
            &UnicodeString,
            KeyValuePartialInformation,
            _CmdConsBlock->TemporaryBuffer,
            _CmdConsBlock->TemporaryBufferSize,
            &cb
            );
        if (NT_SUCCESS(Status)) {
            DisplayName = (PWSTR)&(pi->Data[0]);
        } else {
            DisplayName = NULL;
        }

        ZwClose( ValueHandle );

        if (StartType != 5) {
            swprintf( DisplayBuffer, L"%-15s  %-8s  %s\r\n",
                ServiceName,
                StartTypeStr[StartType],
                DisplayName == NULL ? L"" : DisplayName
                );
            if (!RcTextOut( DisplayBuffer )){
                goto exit;
            }
        }
    }

exit:
    if (ServiceKeyHandle) {
        ZwClose( ServiceKeyHandle );
    }
    
    RcCloseSystemHive();

    if (DisplayBuffer) {
        SpMemFree(DisplayBuffer);
    }

    pRcDisableMoreMode();

    return 1;
}

#define VERIFIER_DRV_LEVEL  L"VerifyDriverLevel"
#define VERIFIER_DRIVERS    L"VerifyDrivers"
#define VERIFIER_IO_LEVEL   L"IoVerifierLevel"
#define VERIFIER_QUERY_INFO L"Flags = %ld; IO Level = %ld\r\nDrivers = %ws\r\n"
#define MEMMGR_PATH L"\\registry\\machine\\xSYSTEM\\ControlSet%03d\\Control\\Session Manager\\Memory Management"
#define IOSYS_PATH  L"\\registry\\machine\\xSYSTEM\\ControlSet%03d\\Control\\Session Manager\\I/O System"
#define SYS_HIVE_NAME L"system"
#define SYS_HIVE_KEY  L"\\registry\\machine\\xSYSTEM"

ULONG
RcCmdVerifier(
    IN PTOKENIZED_LINE TokenizedLine
    )
{
  BOOLEAN ShowHelp = FALSE;
  WCHAR *Args[128] = {0};
  ULONG Index;
  PLINE_TOKEN CurrToken = 0;
  WCHAR Drivers[256] = {0};
  DWORD Flags = -1;
  DWORD IoLevel = -1;
  BOOLEAN DisplaySettings = FALSE;
  UNICODE_STRING UnicodeString;
  ULONG NumArgs = 0;
  BOOLEAN UseDefFlags = TRUE;
  BOOLEAN UseDefIoLevel = TRUE;
  BOOLEAN ResetSettings = FALSE;
  
  if (RcCmdParseHelp(TokenizedLine, MSG_VERIFIER_HELP)) {
    return 1;
  }

  //
  // parse the arguments
  //
  Index = 0;
  CurrToken = TokenizedLine->Tokens;
  
  do {
    Args[Index] = CurrToken->String;
    CurrToken = CurrToken->Next;
    Index++;
  }
  while ((Index < TokenizedLine->TokenCount) && 
          (Index < sizeof(Args)/sizeof(PWCHAR)) && CurrToken);   

  NumArgs = min(TokenizedLine->TokenCount, Index);          

  if (TokenizedLine->TokenCount == 2) {
    //
    // should be one of /all, /reset, /query
    //
    if (!_wcsicmp(Args[1], L"/all")) {
      wcscpy(Drivers, L"*");
      Flags = 0;
      IoLevel = 1;
    } else if (!_wcsicmp(Args[1], L"/reset")) {
      Drivers[0] = 0;
      Flags = 0;
      IoLevel = 1;
      ResetSettings = TRUE;
    } else if (!_wcsicmp(Args[1], L"/query")) {      
      DisplaySettings = TRUE;
    } else {
      ShowHelp = TRUE;
    }
  } else {
    ULONG NextArg = 1;
    
    if (!_wcsicmp(Args[NextArg], L"/flags")) {
      RtlInitUnicodeString(&UnicodeString, Args[NextArg + 1]);
      RtlUnicodeStringToInteger(&UnicodeString, 10, &Flags);
      NextArg += 2;
      UseDefFlags = FALSE;
    } 

    if (!_wcsicmp(Args[NextArg], L"/iolevel")) {
      RtlInitUnicodeString(&UnicodeString, Args[NextArg + 1]);
      RtlUnicodeStringToInteger(&UnicodeString, 10, &IoLevel);
      NextArg += 2;
      UseDefIoLevel = FALSE;        
    }

    if (!_wcsicmp(Args[NextArg], L"/driver")) {
      ULONG Len = 0;
      Drivers[0] = 0;

      for (Index = NextArg + 1; Index < NumArgs; Index++) {
        wcscat(Drivers, Args[Index]);
        wcscat(Drivers, L" ");
      }

      if (!Drivers[0])
        ShowHelp = TRUE;  // need a driver name
    } else if (!_wcsicmp(Args[NextArg], L"/all")) {
      wcscpy(Drivers, L"*");
    } else {
      ShowHelp = TRUE;
    }        
  }

  //
  // Verify the arguments
  //
  if (!ShowHelp) {
    ShowHelp = !DisplaySettings && !ResetSettings &&
      (Flags == -1) && (IoLevel == -1) && (!Drivers[0]);
  }

  if (ShowHelp) {
    RcMessageOut(MSG_VERIFIER_HELP);    
  } else {
    ULONG ControlSetNumber = 0;
    HANDLE MemMgrKeyHandle = NULL;
    HANDLE IOMgrKeyHandle = NULL;
    OBJECT_ATTRIBUTES ObjAttrs;
    BOOLEAN KeysOpened = FALSE;
    PVOID TemporaryBuffer = _CmdConsBlock->TemporaryBuffer;
    ULONG TemporaryBufferSize = _CmdConsBlock->TemporaryBufferSize;      
    NTSTATUS Status;
    BOOLEAN SysHiveOpened;

    //
    // open the system hive & determine correct control set to use
    //
    SysHiveOpened = (BOOLEAN)RcOpenHive(SYS_HIVE_NAME, SYS_HIVE_KEY);

    //
    // get the control set which we are going to manipulate
    //
    if (SysHiveOpened && RcDetermineCorrectControlKey(&ControlSetNumber)) {
      //
      // open "Memory Management" subkey under "SM"
      //
      swprintf((PWSTR)TemporaryBuffer, MEMMGR_PATH, ControlSetNumber);           

      RtlInitUnicodeString(&UnicodeString, (PWSTR)TemporaryBuffer);
      InitializeObjectAttributes(&ObjAttrs, &UnicodeString, 
            OBJ_CASE_INSENSITIVE, NULL, NULL);

      Status = ZwOpenKey(&MemMgrKeyHandle, KEY_ALL_ACCESS, &ObjAttrs);

      if (NT_SUCCESS(Status)) {
        //
        // open "I/O System" subkey under "SM"
        //
        swprintf((PWSTR)TemporaryBuffer, IOSYS_PATH, ControlSetNumber);
             
        RtlInitUnicodeString(&UnicodeString, (PWSTR)TemporaryBuffer);
        InitializeObjectAttributes(&ObjAttrs, &UnicodeString, 
              OBJ_CASE_INSENSITIVE, NULL, NULL);

        Status = ZwOpenKey(&IOMgrKeyHandle, KEY_ALL_ACCESS, &ObjAttrs);

        if (!NT_SUCCESS(Status)) {
          ULONG Disposition = 0;
          
          //
          // Create "I/O System" subkey under "SM", if it does not exist
          //
          Status = ZwCreateKey(&IOMgrKeyHandle, KEY_ALL_ACCESS, &ObjAttrs,
                        0, NULL, REG_OPTION_NON_VOLATILE, NULL);
        }                        

        if (NT_SUCCESS(Status))
          KeysOpened = TRUE;
      }
    }

    if (KeysOpened) {
      ULONG ByteCount = 0;
      ULONG KeyCount = 0;
      PKEY_VALUE_FULL_INFORMATION ValueFullInfo;
      WCHAR ValueName[256];
      ULONG Len;
           
      if (DisplaySettings) {
        //
        // Query the Flags and Drivers 
        //
        Flags = 0;
        Drivers[0] = 0;
        
        for(Index=0; ;Index++){
          Status = ZwEnumerateValueKey(
                      MemMgrKeyHandle,
                      Index,
                      KeyValueFullInformation,
                      TemporaryBuffer,
                      TemporaryBufferSize,
                      &ByteCount
                      );
                      
          if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_NO_MORE_ENTRIES)
              Status = STATUS_SUCCESS;

            break;                
          }

          ValueFullInfo = (PKEY_VALUE_FULL_INFORMATION)TemporaryBuffer;
          Len = ValueFullInfo->NameLength / sizeof(WCHAR);
          wcsncpy(ValueName, ValueFullInfo->Name, Len);
          ValueName[Len] = 0;
          
          if ((!_wcsicmp(ValueName, VERIFIER_DRV_LEVEL)) && 
               (ValueFullInfo->Type == REG_DWORD)) {
            Flags = *(PDWORD)(((PUCHAR)ValueFullInfo) + ValueFullInfo->DataOffset);
          } else if ((!_wcsicmp(ValueName, VERIFIER_DRIVERS)) &&
                     (ValueFullInfo->Type == REG_SZ)) {
            Len = ValueFullInfo->DataLength / sizeof(WCHAR);                     
            wcsncpy(Drivers, (PWSTR)(((PUCHAR)ValueFullInfo) + ValueFullInfo->DataOffset),
                      Len);
            Drivers[Len] = 0;                      
          }              
        }

        //
        // Query the IO level
        //
        for(Index=0; ;Index++){
          Status = ZwEnumerateValueKey(
                      IOMgrKeyHandle,
                      Index,
                      KeyValueFullInformation,
                      TemporaryBuffer,
                      TemporaryBufferSize,
                      &ByteCount
                      );
                      
          if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_NO_MORE_ENTRIES)
              Status = STATUS_SUCCESS;

            break;                
          }

          ValueFullInfo = (PKEY_VALUE_FULL_INFORMATION)TemporaryBuffer;
          Len = ValueFullInfo->NameLength / sizeof(WCHAR);
          wcsncpy(ValueName, ValueFullInfo->Name, Len);
          ValueName[Len] = 0;
          
          if ((!_wcsicmp(ValueName, VERIFIER_IO_LEVEL)) && 
               (ValueFullInfo->Type == REG_DWORD)) {
            IoLevel = *(PDWORD)(((PUCHAR)ValueFullInfo) + ValueFullInfo->DataOffset);
          }
        }

        if (IoLevel == 3)
          IoLevel = 2;
        else
          IoLevel = 1;
          
        //
        // format the output and display it
        //
        swprintf((PWSTR)TemporaryBuffer, VERIFIER_QUERY_INFO,
            Flags, IoLevel, Drivers);

        RcTextOut((PWSTR)TemporaryBuffer);            
      } else {
        //
        // If IO verify bit is not set, then clear IoLevel
        //
        if (!(Flags & 0x10))
          IoLevel = 0;  

        if (IoLevel == 2)
          IoLevel = 3;  // actual value stored in the registry

        if (IoLevel != 3)
          UseDefIoLevel = TRUE;

        //
        // set IO level
        //
        RtlInitUnicodeString(&UnicodeString, VERIFIER_IO_LEVEL);
        
        if (UseDefIoLevel) {
          Status = ZwDeleteValueKey(IOMgrKeyHandle, &UnicodeString);
        } else {
          Status = ZwSetValueKey(IOMgrKeyHandle, &UnicodeString, 0, REG_DWORD,
                      &IoLevel, sizeof(DWORD));                
        }

        //
        // set the DRV verification level
        //
        RtlInitUnicodeString(&UnicodeString, VERIFIER_DRV_LEVEL);        

        if (UseDefFlags) {
          Status = ZwDeleteValueKey(MemMgrKeyHandle, &UnicodeString);
        } else {
          Status = ZwSetValueKey(MemMgrKeyHandle, &UnicodeString, 0, REG_DWORD,
                    &Flags, sizeof(DWORD));                
        }

        //
        // set the drivers to be verified
        //
        RtlInitUnicodeString(&UnicodeString, VERIFIER_DRIVERS);

        if (Drivers[0]) {
          Status = ZwSetValueKey(MemMgrKeyHandle, &UnicodeString, 0, REG_SZ,
                    Drivers, (wcslen(Drivers) + 1) * sizeof(WCHAR));                
        } else {
          Status = ZwDeleteValueKey(MemMgrKeyHandle, &UnicodeString);
        }
      }
    }

    if (MemMgrKeyHandle)
      ZwClose(MemMgrKeyHandle);

    if (IOMgrKeyHandle)
      ZwClose(IOMgrKeyHandle);

    if (SysHiveOpened)
        RcCloseHive(SYS_HIVE_KEY);          
  }
  
  return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\cmdcons\mbr.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    mbr.c

Abstract:

    This module implements the FIXMBR command.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop

#include <bootmbr.h>
//
// For NEC98 boot memu code.
//
#include <x86mboot.h>


VOID
RcDetermineDisk0(
    VOID
    );

BOOL
RcDetermineDisk0Enum(
    IN PPARTITIONED_DISK Disk,
    IN PDISK_REGION Region,
    IN ULONG_PTR Context
    );

NTSTATUS
RcOpenPartition(
    IN PWSTR DiskDevicePath,
    IN ULONG PartitionNumber,
    OUT HANDLE *Handle,
    IN BOOLEAN NeedWriteAccess
    );

NTSTATUS
RcReadDiskSectors(
    IN HANDLE Handle,
    IN ULONG SectorNumber,
    IN ULONG SectorCount,
    IN ULONG BytesPerSector,
    IN OUT PVOID AlignedBuffer
    );

NTSTATUS
RcWriteDiskSectors(
    IN HANDLE Handle,
    IN ULONG SectorNumber,
    IN ULONG SectorCount,
    IN ULONG BytesPerSector,
    IN OUT PVOID AlignedBuffer
    );


#define MBRSIZE_NEC98 0x2000
#define IPL_SIGNATURE_NEC98 "IPL1"

ULONG
RcCmdFixMBR(
    IN PTOKENIZED_LINE TokenizedLine
    )

/*++

Routine Description:

    Top-level routine supporting the FIXMBR command in the setup diagnostic
    command interpreter.

    FIXMBR writes a new master boot record. It will ask before writing the boot
    record if it cannot detect a valid mbr signature.

Arguments:

    TokenizedLine - supplies structure built by the line parser describing
        each string on the line as typed by the user.

Return Value:

    None.

--*/

{
    WCHAR DeviceName[256];
    ULONG i;
    ULONG SectorCount;
    ULONG BytesPerSector;
    PUCHAR Buffer = NULL;
    UCHAR InfoBuffer[2048];
    ULONG SectorId = 0;
    HANDLE handle = 0;
    NTSTATUS rc;
    PON_DISK_MBR mbr;
    IO_STATUS_BLOCK StatusBlock;
    Int13HookerType Int13Hooker = NoHooker;
    ULONG NextSector;
    WCHAR Text[2];
    PWSTR YesNo = NULL;
    BOOL Confirm = TRUE;
    BOOL SignatureInvalid = FALSE;
    BOOL Int13Detected = FALSE;
    PREAL_DISK_MBR_NEC98 MbrNec98;


    //
    // command is only supported on X86 platforms.
    // Alpha or other RISC platforms don't use
    // mbr code
    //

#ifndef _X86_

    RcMessageOut( MSG_ONLY_ON_X86 );
    return 1;

#else

    if (RcCmdParseHelp( TokenizedLine, MSG_FIXMBR_HELP )) {
        return 1;
    }

    if (TokenizedLine->TokenCount == 2) {
        wcscpy( DeviceName, TokenizedLine->Tokens->Next->String );
    } else {
        RtlZeroMemory(DeviceName,sizeof(DeviceName));
        SpEnumerateDiskRegions( (PSPENUMERATEDISKREGIONS)RcDetermineDisk0Enum, (ULONG_PTR)DeviceName );
    }

    //
    // NEC98 does not support to fix removable media.
    //
    if (IsNEC_98 &&
        RcIsFileOnRemovableMedia((PWSTR)DeviceName) == STATUS_SUCCESS) {
        return 1;
    }

    rc = RcOpenPartition( DeviceName, 0, &handle, TRUE );
    if (!NT_SUCCESS(rc)) {
        DEBUG_PRINTF(( "failed to open partition zero!!!!!!" ));
        return 1;
    }

    //
    // get disk geometry
    //

    rc = ZwDeviceIoControlFile(
        handle,
        NULL,
        NULL,
        NULL,
        &StatusBlock,
        IOCTL_DISK_GET_DRIVE_GEOMETRY,
        NULL,
        0,
        InfoBuffer,
        sizeof( InfoBuffer )
        );
    if( !NT_SUCCESS( rc ) ) {
        RcMessageOut( MSG_FIXMBR_READ_ERROR );
        goto cleanup;
    }

    //
    // retrieve the sector size!
    //

    BytesPerSector = ((DISK_GEOMETRY*)InfoBuffer)->BytesPerSector;

    //
    // compute the sector count
    //

    SectorCount = max( 1, (!IsNEC_98
                           ? (sizeof( ON_DISK_MBR )/BytesPerSector)
                           : (MBRSIZE_NEC98/BytesPerSector) ));

    //
    // allocate a buffer twice as big as necessary
    //

    Buffer = SpMemAlloc( 2 * SectorCount * BytesPerSector );

    //
    // align the buffer
    //

    if(!IsNEC_98) {
        mbr = ALIGN( Buffer, BytesPerSector );
    } else {
        MbrNec98 = ALIGN( Buffer, BytesPerSector );
    }

    //
    // take in the sectors
    //

    rc = RcReadDiskSectors(
        handle,
        SectorId,
        SectorCount,
        BytesPerSector,
        (!IsNEC_98 ? (PVOID)mbr : (PVOID)MbrNec98)
        );
    if (!NT_SUCCESS(rc)) {
        RcMessageOut( MSG_FIXMBR_READ_ERROR );
        goto cleanup;
    }

    if ((!IsNEC_98 && U_USHORT(mbr->AA55Signature) != MBR_SIGNATURE) ||
        (IsNEC_98 &&
         ((U_USHORT(MbrNec98->AA55Signature) != MBR_SIGNATURE) ||
          _strnicmp(MbrNec98->IPLSignature,IPL_SIGNATURE_NEC98,sizeof(IPL_SIGNATURE_NEC98)-1)))
        ) {

        SignatureInvalid = TRUE;
        RcMessageOut( MSG_FIXMBR_NO_VALID_SIGNATURE );
    }

    //
    // check for weird int13 hookers
    //
    // No NEC98 supports EZ Drive.
    //
    //
    if (!IsNEC_98) {

        //
        //
        // EZDrive support: if the first entry in the partition table is
        // type 0x55, then the actual partition table is on sector 1.
        //
        // Only for x86 because on non-x86, the firmware can't see EZDrive
        // partitions.
        //
        //

        if (mbr->PartitionTable[0].SystemId == 0x55) {
            Int13Hooker = HookerEZDrive;
            SectorId = 1;
        }

        //
        // Also check for on-track.
        //

        if( mbr->PartitionTable[0].SystemId == 0x54 ) {
            Int13Hooker = HookerOnTrackDiskManager;
            SectorId = 1;
        }

        //
        // there's a define for HookerMax but we don't appear
        // to check for it in setup so I don't check for it here
        //
        //
        // If we have an int13 hooker
        //

        if (Int13Hooker != NoHooker) {
            Int13Detected = TRUE;
            RcMessageOut( MSG_FIXMBR_INT13_HOOKER );
        }

        //
        // we have a valid signature AND int 13 hooker is detected
        //

        if (Int13Detected) {

            //
            // take sector 1 in, since sector 0 is the int hooker boot code
            //

            rc = RcReadDiskSectors(
                handle,
                SectorId,
                SectorCount,
                BytesPerSector,
                mbr
                );

            //
            // sector 1 should look like a valid MBR too
            //

            if (U_USHORT(mbr->AA55Signature) != MBR_SIGNATURE) {
                SignatureInvalid = TRUE;
                RcMessageOut( MSG_FIXMBR_NO_VALID_SIGNATURE );
            }
        }
    }

    RcMessageOut( MSG_FIXMBR_WARNING_BEFORE_PROCEED );

    if (!InBatchMode) {
        YesNo = SpRetreiveMessageText(ImageBase,MSG_YESNO,NULL,0);
        if(!YesNo) {
            Confirm = FALSE;
        }
        while(Confirm) {
            RcMessageOut( MSG_FIXMBR_ARE_YOU_SURE );
            if(RcLineIn(Text,2)) {
                if((Text[0] == YesNo[0]) || (Text[0] == YesNo[1])) {
                    //
                    // Wants to do it.
                    //
                    Confirm = FALSE;
                } else {
                    if((Text[0] == YesNo[2]) || (Text[0] == YesNo[3])) {
                        //
                        // Doesn't want to do it.
                        //
                        goto cleanup;
                    }
                }
            }
        }
    }

    //
    // now we need to slap in new boot code!
    // make sure the boot code starts at the start of the sector.
    //

    if(!IsNEC_98) {
        ASSERT(&((PON_DISK_MBR)0)->BootCode == 0);
    } else {
        ASSERT(&((PREAL_DISK_MBR_NEC98)0)->BootCode == 0);
    }

    RcMessageOut( MSG_FIXMBR_DOING_IT, DeviceName );

    //
    // clobber the existing boot code
    //

    if(!IsNEC_98) {
        RtlMoveMemory(mbr,x86BootCode,sizeof(mbr->BootCode));

        //
        // put a new signature in
        //

        U_USHORT(mbr->AA55Signature) = MBR_SIGNATURE;

    } else {
        //
        // Write MBR in 1st sector.
        //
        RtlMoveMemory(MbrNec98,x86PC98BootCode,0x200);

        //
        // Write continous MBR after 3rd sector.
        //
        RtlMoveMemory((PUCHAR)MbrNec98+0x400,x86PC98BootMenu,MBRSIZE_NEC98-0x400);
    }

    //
    // write out the sector
    //

    rc = RcWriteDiskSectors(
        handle,
        SectorId,
        SectorCount,
        BytesPerSector,
        (!IsNEC_98 ? (PVOID)mbr : (PVOID)MbrNec98)
        );
    if (!NT_SUCCESS( rc )) {
        DEBUG_PRINTF(( "failed writing out new MBR." ));
        RcMessageOut( MSG_FIXMBR_FAILED );
        goto cleanup;
    }

    RcMessageOut( MSG_FIXMBR_DONE );

cleanup:

    if (handle) {
        NtClose(handle);
    }
    if (Buffer) {
        SpMemFree(Buffer);
    }
    if (YesNo) {
        SpMemFree(YesNo);
    }
    return 1;

#endif
}


BOOL
RcDetermineDisk0Enum(
    IN PPARTITIONED_DISK Disk,
    IN PDISK_REGION Region,
    IN ULONG_PTR Context
    )

/*++

Routine Description:

    Callback routine passed to SpEnumDiskRegions.

Arguments:

    Region - a pointer to a disk region returned by SpEnumDiskRegions
    Ignore - ignored parameter

Return Value:

    TRUE - to continue enumeration
    FALSE - to end enumeration

--*/

{
    WCHAR ArcName[256];
    PWSTR DeviceName = (PWSTR)Context;


    SpArcNameFromRegion(
        Region,
        ArcName,
        sizeof(ArcName),
        PartitionOrdinalCurrent,
        PrimaryArcPath
        );

    //
    // look for the one with arc path L"multi(0)disk(0)rdisk(0)"
    //

    if( wcsstr( ArcName, L"multi(0)disk(0)rdisk(0)" ) ) {

        *DeviceName = UNICODE_NULL;

        SpNtNameFromRegion(
            Region,
            DeviceName,
            MAX_PATH * sizeof(WCHAR),
            PartitionOrdinalCurrent
            );

        if (*DeviceName != UNICODE_NULL) {
            PWSTR   PartitionKey = wcsstr(DeviceName, L"Partition");

            if (!PartitionKey) {
                PartitionKey = wcsstr(DeviceName, L"partition");
            }

            //
            // partition 0 represents the start of disk
            //
            if (PartitionKey) {
                *PartitionKey = UNICODE_NULL;
                wcscat(DeviceName, L"Partition0");
            } else {
                DeviceName[wcslen(DeviceName) - 1] = L'0';  
            }                
        }            

        return FALSE;
    }

    return TRUE;
}


NTSTATUS
RcReadDiskSectors(
    IN     HANDLE  Handle,
    IN     ULONG   SectorNumber,
    IN     ULONG   SectorCount,
    IN     ULONG   BytesPerSector,
    IN OUT PVOID   AlignedBuffer
    )

/*++

Routine Description:

    Reads one or more disk sectors.

Arguments:

    Handle - supplies handle to open partition object from which
        sectors are to be read or written.  The handle must be
        opened for synchronous I/O.

Return Value:

    NTSTATUS value indicating outcome of I/O operation.

--*/

{
    LARGE_INTEGER IoOffset;
    ULONG IoSize;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    //
    // Calculate the large integer byte offset of the first sector
    // and the size of the I/O.
    //

    IoOffset.QuadPart = SectorNumber * BytesPerSector;
    IoSize = SectorCount * BytesPerSector;

    //
    // Perform the I/O.
    //

    Status = (NTSTATUS) ZwReadFile(
        Handle,
        NULL,
        NULL,
        NULL,
        &IoStatusBlock,
        AlignedBuffer,
        IoSize,
        &IoOffset,
        NULL
        );
    if (!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Unable to read %u sectors starting at sector %u\n",SectorCount,SectorNumber));
    }

    return(Status);
}


NTSTATUS
RcWriteDiskSectors(
    IN     HANDLE  Handle,
    IN     ULONG   SectorNumber,
    IN     ULONG   SectorCount,
    IN     ULONG   BytesPerSector,
    IN OUT PVOID   AlignedBuffer
    )

/*++

Routine Description:

    Writes one or more disk sectors.

Arguments:

    Handle - supplies handle to open partition object from which
        sectors are to be read or written.  The handle must be
        opened for synchronous I/O.

Return Value:

    NTSTATUS value indicating outcome of I/O operation.

--*/

{
    LARGE_INTEGER IoOffset;
    ULONG IoSize;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;

    //
    // Calculate the large integer byte offset of the first sector
    // and the size of the I/O.
    //

    IoOffset.QuadPart = SectorNumber * BytesPerSector;
    IoSize = SectorCount * BytesPerSector;

    //
    // Perform the I/O.
    //

    Status = (NTSTATUS) ZwWriteFile(
        Handle,
        NULL,
        NULL,
        NULL,
        &IoStatusBlock,
        AlignedBuffer,
        IoSize,
        &IoOffset,
        NULL
        );
    if (!NT_SUCCESS(Status)) {
        KdPrint(("SETUP: Unable to write %u sectors starting at sector %u\n",SectorCount,SectorNumber));
    }

    return(Status);
}


NTSTATUS
RcOpenPartition(
    IN  PWSTR   DiskDevicePath,
    IN  ULONG   PartitionNumber,
    OUT HANDLE *Handle,
    IN  BOOLEAN NeedWriteAccess
    )

/*++

Routine Description:

    Opens and returns a handle to the specified partition.

Arguments:

    DiskDevicePath - the path to the device.

    PartitionNumber - if the path doesn't already specify the Partition then
                    the function will open the partition specified by this number

    Handle -    where the open handle will be returned.
                The handle is opened for synchronous I/O.

    NeedWriteAccess - true to open in R/W

Return Value:

    NTSTATUS value indicating outcome of I/O operation.

--*/

{
    PWSTR PartitionPath;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Form the pathname of partition.
    //

    PartitionPath = SpMemAlloc((wcslen(DiskDevicePath) * sizeof(WCHAR)) + sizeof(L"\\partition000"));
    if(PartitionPath == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // if partition is already specified in the string, then don't bother appending
    // it
    //

    if (wcsstr( DiskDevicePath, L"Partition" ) == 0) {
        swprintf(PartitionPath,L"%ws\\partition%u",DiskDevicePath,PartitionNumber);
    } else {
        swprintf(PartitionPath,L"%ws",DiskDevicePath);
    }

    //
    // Attempt to open partition0.
    //

    INIT_OBJA(&Obja,&UnicodeString,PartitionPath);

    Status = ZwCreateFile(
        Handle,
        FILE_GENERIC_READ | (NeedWriteAccess ? FILE_GENERIC_WRITE : 0),
        &Obja,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | (NeedWriteAccess ? FILE_SHARE_WRITE : 0),
        FILE_OPEN,
        FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0
        );
    if (!NT_SUCCESS(Status)) {
        KdPrint(("CMDCONS: Unable to open %ws (%lx)\n",PartitionPath,Status));
    }

    SpMemFree(PartitionPath);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\cmdcons\util.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module implements all utility functions.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop


#include "remboot.h" 

HANDLE NetUseHandles[26] = { NULL };
BOOLEAN RdrIsInKernelMode = FALSE;

RC_ALLOWED_DIRECTORY AllowedDirs[] = {
    { FALSE, L"$WIN_NT$.~BT" },
    { FALSE, L"$WIN_NT$.~LS" },
    { FALSE, L"CMDCONS" },
    { TRUE, L"SYSTEM VOLUME INFORMATION" }
};

BOOLEAN
RcIsPathNameAllowed(
    IN LPCWSTR FullPath,
    IN BOOLEAN RemovableMediaOk,
    IN BOOLEAN Mkdir
    )

/*++

Routine Description:

    This routine verifies that the specified path name is
    allowed based on the security context that the console
    user is logged into.

Arguments:

    FullPath - specifies the full path to be verified.

Return Value:

    FALSE if failure, indicating the path is not allowed.
    TRUE otherwise.

--*/

{
    WCHAR TempBuf[MAX_PATH*2];
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE  Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    BOOL isDirectory = TRUE;

    //
    // should we bypass security?
    //

    if (AllowAllPaths) {
        return TRUE;
    }

    //
    // some special processing for dos paths
    // we must make sure that only the root and %systemdir% are allowed.
    //

    if (FullPath[1] == L':' && FullPath[2] == L'\\' && FullPath[3] == 0) {
        //
        // root directory is ok.
        //
        return TRUE;
    }

    SpStringToUpper((PWSTR)FullPath);

    if (!RcGetNTFileName((PWSTR)FullPath,TempBuf))
        return FALSE;

    INIT_OBJA(&Obja,&UnicodeString,TempBuf);

    Status = ZwOpenFile(
        &Handle,
        FILE_READ_ATTRIBUTES,
        &Obja,
        &IoStatusBlock,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_DIRECTORY_FILE
        );
    if( !NT_SUCCESS(Status) ) {
        isDirectory = FALSE;

    } else {
        ZwClose( Handle );
    }

    if (isDirectory == FALSE && wcsrchr( FullPath, L'\\' ) == ( &FullPath[2] )) {
        //
        // if the cannonicalized path has only one slash the user is trying to do something
        // to the files in the root, which we allow.
        //
        // however we do not allow users to mess with directories at the root
        //
        if (Mkdir) {
            return FALSE;
        } else {
            return TRUE;
        }
    }

    ASSERT(SelectedInstall != NULL);

    if(SelectedInstall != NULL) {
        //
        // Get the length of the first element in the path
        //
        PCWSTR sz;
        DWORD Len;
        DWORD i;
        WCHAR SelectedInstallDrive;

        sz = wcschr(FullPath + 3, L'\\');

        if(NULL == sz) {
            sz = FullPath + wcslen(FullPath);
        }

        Len = (DWORD) ((sz - FullPath) - 3);
        SelectedInstallDrive = RcToUpper(SelectedInstall->DriveLetter);

        //
        // See if path begins with the install path
        //
        if(FullPath[0] == SelectedInstallDrive && 0 == _wcsnicmp(FullPath + 3, SelectedInstall->Path, Len)) {
            return TRUE;
        }

        //
        // See if the path begins with an allowed dir
        //
        for(i = 0; i < sizeof(AllowedDirs) / sizeof(AllowedDirs[0]); ++i) {
            if((!AllowedDirs[i].MustBeOnInstallDrive || FullPath[0] == SelectedInstallDrive) &&
                0 == _wcsnicmp(FullPath + 3, AllowedDirs[i].Directory, Len)) {
                return TRUE;
            }
        }
    }

    if (RcIsFileOnRemovableMedia(TempBuf) == STATUS_SUCCESS) {
        if (RemovableMediaOk) {
            return TRUE;
        }
    }

    if (RcIsNetworkDrive(TempBuf) == STATUS_SUCCESS) {
        //
        // Context that was used for connection will do appropriate security checking.
        //
        return TRUE;
    }

    return FALSE;
}


BOOLEAN
RcDoesPathHaveWildCards(
    IN LPCWSTR FullPath
    )

/*++

Routine Description:

    This routine verifies that the specified path name is
    allowed based on the security context that the console
    user is logged into.

Arguments:

    FullPath - specifies the full path to be verified.

Return Value:

    FALSE if failure, indicating the path is not allowed.
    TRUE otherwise.

--*/

{
    if (wcsrchr( FullPath, L'*' )) {
        return TRUE;
    }

    if (wcsrchr( FullPath, L'?' )) {
        return TRUE;
    }

    return FALSE;
}

NTSTATUS
RcIsNetworkDrive(
    IN PWSTR FileName
    )

/*++

Routine Description:

    This routine returns if the FileName given is a network path.

Arguments:

    FileName - specifies the full path to be checked.

Return Value:

    Any other than STATUS_SUCCESS if failure, indicating the path is not on the network, 
    STATUS_SUCCESS otherwise.

--*/

{
    NTSTATUS Status;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;
    PWSTR BaseNtName;

    if (wcsncmp(FileName, L"\\DosDevice", wcslen(L"\\DosDevice")) == 0) {
        Status = GetDriveLetterLinkTarget( FileName, &BaseNtName );

        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    } else {
        BaseNtName = FileName;
    }

    Status = pRcGetDeviceInfo( BaseNtName, &DeviceInfo );
    if(NT_SUCCESS(Status)) {
        if (DeviceInfo.DeviceType != FILE_DEVICE_NETWORK_FILE_SYSTEM) {
            Status = STATUS_NO_MEDIA;
        }
    }

    return Status;
}


NTSTATUS
RcDoNetUse(
    PWSTR Share, 
    PWSTR User, 
    PWSTR Password, 
    PWSTR Drive
    )

/*++

Routine Description:

    This routine attempts to make a connection using the redirector to the remote server.

Arguments:

    Share - A string of the form "\\server\share"
    
    User  - A string of the form "domain\user"
    
    Password - A string containing the password information.
    
    Drive - Filled in with a string of the form "X", where X is the drive letter the share 
        has been mapped to.

Return Value:

    STATUS_SUCCESS if successful, indicating Drive contains the mapped drive letter,
    otherwise the appropriate error code.

--*/

{
    NTSTATUS Status;
    PWSTR NtDeviceName;
    ULONG ShareLength;
    WCHAR DriveLetter;
    WCHAR temporaryBuffer[128];
    PWCHAR Temp, Temp2;
    HANDLE Handle;
    ULONG EaBufferLength;
    PWSTR UserName; 
    PWSTR DomainName; 
    PVOID EaBuffer;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING UnicodeString2;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_FULL_EA_INFORMATION FullEaInfo;

    //
    // Switch the redirector to kernel-mode security if it is not.
    //
    if (!RdrIsInKernelMode) {
        Status = PutRdrInKernelMode();

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        RdrIsInKernelMode = TRUE;
    }

    //
    // Search for an open drive letter, starting at D: and working up.
    //
    wcscpy(temporaryBuffer, L"\\DosDevices\\D:");
    Temp = wcsstr(temporaryBuffer, L"D:");

    for (DriveLetter = L'D'; (Temp && (DriveLetter <= L'Z')); DriveLetter++) {
        *Temp = DriveLetter;
        
        Status = GetDriveLetterLinkTarget( temporaryBuffer, &Temp2 );

        if (!NT_SUCCESS(Status)) {
            break;
        }
    }

    if (DriveLetter > L'Z') {
        return STATUS_OBJECT_NAME_INVALID;
    }

    //
    // Build the NT device name.
    //
    ShareLength = wcslen(Share);
    NtDeviceName = SpMemAlloc(ShareLength * sizeof(WCHAR) + sizeof(L"\\Device\\LanmanRedirector\\;X:0"));   
    if (NtDeviceName == NULL) {
        return STATUS_NO_MEMORY;
    }
    wcscpy(NtDeviceName, L"\\Device\\LanmanRedirector\\;");
    temporaryBuffer[0] = DriveLetter;
    temporaryBuffer[1] = UNICODE_NULL;
    wcscat(NtDeviceName, temporaryBuffer);
    wcscat(NtDeviceName, L":0");
    wcscat(NtDeviceName, Share + 1);

    //
    // Chop the username and domainname into individual values.
    //
    wcscpy(temporaryBuffer, User);
    DomainName = temporaryBuffer;
    UserName = wcsstr(temporaryBuffer, L"\\");

    if (UserName == NULL) {
        SpMemFree(NtDeviceName);
        return STATUS_OBJECT_NAME_INVALID;
    }
    *UserName = UNICODE_NULL;
    UserName++;

    //
    // Create buffer with user credentials
    //

    EaBufferLength = FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]);
    EaBufferLength += sizeof(EA_NAME_DOMAIN);
    EaBufferLength += (wcslen(DomainName) * sizeof(WCHAR));
    if (EaBufferLength & (sizeof(ULONG) - 1)) {
        //
        // Long align the next entry
        //
        EaBufferLength += (sizeof(ULONG) - (EaBufferLength & (sizeof(ULONG) - 1)));
    }

    EaBufferLength += FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]);
    EaBufferLength += sizeof(EA_NAME_USERNAME);
    EaBufferLength += (wcslen(UserName) * sizeof(WCHAR));
    if (EaBufferLength & (sizeof(ULONG) - 1)) {
        //
        // Long align the next entry
        //
        EaBufferLength += (sizeof(ULONG) - (EaBufferLength & (sizeof(ULONG) - 1)));
    }

    EaBufferLength += FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]);
    EaBufferLength += sizeof(EA_NAME_PASSWORD);
    EaBufferLength += (wcslen(Password) * sizeof(WCHAR));

    EaBuffer = SpMemAlloc(EaBufferLength);
    if (EaBuffer == NULL) {
        SpMemFree(NtDeviceName);
        return STATUS_NO_MEMORY;
    }

    FullEaInfo = (PFILE_FULL_EA_INFORMATION)EaBuffer;

    FullEaInfo->Flags = 0;
    FullEaInfo->EaNameLength = sizeof(EA_NAME_DOMAIN) - 1;
    FullEaInfo->EaValueLength = (wcslen(DomainName)) * sizeof(WCHAR);
    strcpy(&(FullEaInfo->EaName[0]), EA_NAME_DOMAIN);
    memcpy(&(FullEaInfo->EaName[FullEaInfo->EaNameLength + 1]), DomainName, FullEaInfo->EaValueLength);
    FullEaInfo->NextEntryOffset = FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                                  FullEaInfo->EaNameLength + 1 +
                                  FullEaInfo->EaValueLength;
    if (FullEaInfo->NextEntryOffset & (sizeof(ULONG) - 1)) {
        FullEaInfo->NextEntryOffset += (sizeof(ULONG) - 
                                         (FullEaInfo->NextEntryOffset & 
                                          (sizeof(ULONG) - 1)));
    }


    FullEaInfo = (PFILE_FULL_EA_INFORMATION)(((char *)FullEaInfo) + FullEaInfo->NextEntryOffset);

    FullEaInfo->Flags = 0;
    FullEaInfo->EaNameLength = sizeof(EA_NAME_USERNAME) - 1;
    FullEaInfo->EaValueLength = (wcslen(UserName)) * sizeof(WCHAR);
    strcpy(&(FullEaInfo->EaName[0]), EA_NAME_USERNAME);
    memcpy(&(FullEaInfo->EaName[FullEaInfo->EaNameLength + 1]), UserName, FullEaInfo->EaValueLength);
    FullEaInfo->NextEntryOffset = FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                                  FullEaInfo->EaNameLength + 1 +
                                  FullEaInfo->EaValueLength;
    if (FullEaInfo->NextEntryOffset & (sizeof(ULONG) - 1)) {
        FullEaInfo->NextEntryOffset += (sizeof(ULONG) - 
                                         (FullEaInfo->NextEntryOffset & 
                                          (sizeof(ULONG) - 1)));
    }


    FullEaInfo = (PFILE_FULL_EA_INFORMATION)(((char *)FullEaInfo) + FullEaInfo->NextEntryOffset);

    FullEaInfo->Flags = 0;
    FullEaInfo->EaNameLength = sizeof(EA_NAME_PASSWORD) - 1;
    FullEaInfo->EaValueLength = (wcslen(Password)) * sizeof(WCHAR);
    strcpy(&(FullEaInfo->EaName[0]), EA_NAME_PASSWORD);
    memcpy(&(FullEaInfo->EaName[FullEaInfo->EaNameLength + 1]), Password, FullEaInfo->EaValueLength);
    FullEaInfo->NextEntryOffset = 0;

    //
    // Now make the connection
    //
    RtlInitUnicodeString(&UnicodeString, NtDeviceName);
    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    Status = ZwCreateFile(&Handle,
                          SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ,
                          FILE_OPEN_IF,
                          (FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT),
                          EaBuffer,
                          EaBufferLength
                         );

    if (NT_SUCCESS(Status) && NT_SUCCESS(IoStatusBlock.Status)) {
        //
        // Save off the handle so we can close it later if need be
        //
        NetUseHandles[DriveLetter - L'A'] = Handle;
        Drive[0] = DriveLetter;
        Drive[1] = L':';
        Drive[2] = UNICODE_NULL;

        //
        // Now create a symbolic link from the dos drive letter to the redirector
        //
        wcscpy(temporaryBuffer, L"\\DosDevices\\");
        wcscat(temporaryBuffer, Drive);
        RtlInitUnicodeString(&UnicodeString2, temporaryBuffer);

        Status = IoCreateSymbolicLink(&UnicodeString2, &UnicodeString);
        if (!NT_SUCCESS(Status)) {
            ZwClose(Handle);
            NetUseHandles[DriveLetter - L'A'] = NULL;
        } else {
            RcAddDrive(DriveLetter);
        }

    }

    SpMemFree(NtDeviceName);
    return Status;
}
        

NTSTATUS
RcNetUnuse(
    PWSTR Drive
    )

/*++

Routine Description:

    This routine closes a network connection.

Arguments:

    Drive - A string of the form "X:", where X is the drive letter returned by a previous call to 
        NetDoNetUse().

Return Value:

    STATUS_SUCCESS if successful, indicating the drive letter has been unmapped,
    otherwise the appropriate error code.

--*/

{
    NTSTATUS Status;
    WCHAR DriveLetter;
    WCHAR temporaryBuffer[128];
    UNICODE_STRING UnicodeString;

    DriveLetter = *Drive;
    if ((DriveLetter >= L'a') && (DriveLetter <= L'z')) {
        DriveLetter = L'A' + (DriveLetter - L'a');
    }

    if ((DriveLetter < L'A') | (DriveLetter > L'Z')) {
        return STATUS_OBJECT_NAME_INVALID;
    }

    if (NetUseHandles[DriveLetter - L'A'] == NULL) {
        return STATUS_OBJECT_NAME_INVALID;
    }

    if (RcGetCurrentDriveLetter() == DriveLetter) {
        return STATUS_CONNECTION_IN_USE;
    }

    wcscpy(temporaryBuffer, L"\\DosDevices\\");
    wcscat(temporaryBuffer, Drive);
    RtlInitUnicodeString(&UnicodeString, temporaryBuffer);

    Status = IoDeleteSymbolicLink(&UnicodeString);

    if (NT_SUCCESS(Status)) {
        ZwClose(NetUseHandles[DriveLetter - L'A']);
        NetUseHandles[DriveLetter - L'A'] = NULL;
        RcRemoveDrive(DriveLetter);
    }

    return Status;
}



NTSTATUS
PutRdrInKernelMode(
    VOID
    )

/*++

Routine Description:

    This routine IOCTLs down to the rdr to force it to use kernel-mode security.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS if successful, otherwise the appropriate error code.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    HANDLE Handle;

    RtlInitUnicodeString(&UnicodeString, DD_NFS_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = ZwCreateFile(
                &Handle,
                GENERIC_READ | GENERIC_WRITE,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,
                0,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );

    if (!NT_SUCCESS(Status)) {
        KdPrint(("SPCMDCON: Unable to open redirector. %x\n", Status));
        return Status;
    }

    Status = ZwDeviceIoControlFile(Handle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_LMMR_USEKERNELSEC,
                                   NULL,
                                   0,
                                   NULL,
                                   0
                                  );

    if (NT_SUCCESS(Status)) {
        Status = IoStatusBlock.Status;
    }

    ZwClose(Handle);

    return Status;
}

BOOLEAN
RcIsArc(
    VOID
    )

/*++

Routine Description:

    Run time check to determine if this is an Arc system. We attempt to read an
    Arc variable using the Hal. This will fail for Bios based systems.

Arguments:

    None

Return Value:

    True = This is an Arc system.

--*/

{
#ifdef _X86_
    ARC_STATUS ArcStatus = EBADF;
    //
    // Get the env var into the temp buffer.
    //
    UCHAR   wbuff[130];
    //
    // Get the env var into the temp buffer.
    //
    ArcStatus = HalGetEnvironmentVariable(
                    "OsLoader",
                    sizeof(wbuff),
                    wbuff
                    );

    return((ArcStatus == ESUCCESS) ? TRUE: FALSE);
#else
    return TRUE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\cmdcons\resource.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    resources.c

Abstract:

    This module implements all access to
    the resources.

Author:

    Wesley Witt (wesw) 21-Oct-1998

Revision History:

--*/

#include "cmdcons.h"
#pragma hdrstop


LPCWSTR _DateTimeFormat;


VOID
vRcMessageOut(
    IN ULONG    MessageId,
    IN va_list *arglist
    )
{
    WCHAR *p;
    NTSTATUS Status;

    //
    // Load the message
    //
    p = SpRetreiveMessageText(ImageBase,MessageId,NULL,0);
    if(!p) {
        return;
    }

    Status = SpRtlFormatMessage(
                p,
                0,
                FALSE,
                FALSE,
                FALSE,
                arglist,
                _CmdConsBlock->TemporaryBuffer,
                _CmdConsBlock->TemporaryBufferSize,
                NULL
                );

    SpMemFree(p);

    if(NT_SUCCESS(Status)) {
        RcTextOut(_CmdConsBlock->TemporaryBuffer);
    }
}


VOID
RcMessageOut(
    IN ULONG MessageId,
    ...
    )
{
    va_list arglist;

    va_start(arglist,MessageId);
    vRcMessageOut(MessageId,&arglist);
    va_end(arglist);
}


ULONG
RcFormatDateTime(
    IN  PLARGE_INTEGER Time,
    OUT LPWSTR         Output
    )
{
    TIME_FIELDS TimeFields;
    WCHAR *p,*AmPmSpec;
    LPCWSTR q;
    int i;

    //
    // Load the system date and time format string if not loaded already.
    //
    if(!_DateTimeFormat) {
        _DateTimeFormat = SpRetreiveMessageText(ImageBase,MSG_DATE_TIME_FORMAT,NULL,0);
        if(!_DateTimeFormat) {
            _DateTimeFormat = L"m/d/y h:na*";
        }
    }

    //
    // Translate the last write time to time fields.
    //
    RtlTimeToTimeFields(Time,&TimeFields);

    //
    // Format the date and time.
    //
    p = Output;
    q = _DateTimeFormat;
    AmPmSpec = NULL;

    while(*q != L'*') {

        switch(*q) {

        case L'm':
            i = TimeFields.Month;
            break;

        case L'd':
            i = TimeFields.Day;
            break;

        case L'y':
            i = TimeFields.Year;
            break;

        case L'h':
            i = TimeFields.Hour % 12;
            if(i == 0) {
                i = 12;
            }
            break;

        case L'H':
            i = TimeFields.Hour;
            break;

        case L'n':
            i = TimeFields.Minute;
            break;

        case L'a':
            i = -1;
            AmPmSpec = p++;
            break;

        default:
            i = -1;
            *p++ = *q;
            break;
        }

        if(i != -1) {

            i = i % 100;

            *p++ = (i / 10) + L'0';
            *p++ = (i % 10) + L'0';
        }

        q++;
    }

    if(AmPmSpec) {
        q++;        // q points at am specifier
        if(TimeFields.Hour >= 12) {
            q++;    // q points at pm specifier
        }

        *AmPmSpec = *q;
    }

    *p = 0;

    return (ULONG)(p - Output);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\disksig\disksig.c ===
#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MBR_DISK_SIGNATURE_BYTE_OFFSET  0x1B8

BYTE TemporaryBuffer[4096*16];


int _cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE hFile;
    DWORD Size;
    DWORD Signature;
    BOOL rVal;
    DWORD i;
    DWORD ErrorCode = ERROR_SUCCESS;

    SetErrorMode(SEM_FAILCRITICALERRORS);

    if( (argc == 2) && !_strcmpi( argv[1], "-dump" ) ) {
        //
        // Just dump the signatures.
        //
        for (i=0; i<999; i++) {
            sprintf( (LPSTR)TemporaryBuffer, "\\\\.\\PhysicalDrive%d", i );

            hFile = CreateFile( (LPSTR)TemporaryBuffer,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL );

            if (hFile != INVALID_HANDLE_VALUE) {
                //
                // NOTE: We don't use IOCTL_DISK_GET_DRIVE_LAYOUT_EX
                // since it returns cached signature value.
                //
                if (DeviceIoControl( hFile,
                            IOCTL_DISK_GET_DRIVE_GEOMETRY,
                            NULL,
                            0,
                            TemporaryBuffer,
                            sizeof(TemporaryBuffer),
                            &Size,
                            NULL)) {
                    DWORD SectorSize = ((PDISK_GEOMETRY)(TemporaryBuffer))->BytesPerSector;
                    PUCHAR Sector = (PUCHAR)TemporaryBuffer;
                    DWORD BytesRead = 0;
                    LARGE_INTEGER Offset = {0};
                   
                    //
                    // Read the boot sector (NOTE : This code doesn't handle MBR INT13 hookers)
                    //    
                    if (ReadFile(hFile, Sector, SectorSize, &BytesRead, NULL)) {                        
                        PDWORD OldSignature = (PDWORD)(Sector + MBR_DISK_SIGNATURE_BYTE_OFFSET);

                        printf( "PhysicalDrive%d=0x%08x\n", i, *OldSignature);
                    } else {
                        ErrorCode = GetLastError();
                    }                    
                } else {
                    ErrorCode = GetLastError();
                }                    

                CloseHandle( hFile );
            } else {
                ErrorCode = GetLastError();
            }                
        }
    } else if( (argc == 4) && !_strcmpi( argv[1], "-set" ) ) {
        //
        // Get the disk number.
        //
        i = strtoul( argv[2], NULL, 16 );

        //
        // Get the Signature.
        //
        Signature = strtoul( argv[3], NULL, 16 );

        sprintf( (LPSTR)TemporaryBuffer, "\\\\.\\PhysicalDrive%d", i );

        hFile = CreateFile( (LPSTR)TemporaryBuffer,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            INVALID_HANDLE_VALUE );
                            
        if (hFile != INVALID_HANDLE_VALUE) {

            if (DeviceIoControl( hFile,
                        IOCTL_DISK_GET_DRIVE_GEOMETRY,
                        NULL,
                        0,
                        TemporaryBuffer,
                        sizeof(TemporaryBuffer),
                        &Size,
                        NULL)) {
                DWORD SectorSize = ((PDISK_GEOMETRY)(TemporaryBuffer))->BytesPerSector;
                PUCHAR Sector = (PUCHAR)TemporaryBuffer;
                DWORD BytesRead = 0;
                LARGE_INTEGER Offset = {0};
               
                //
                // Read the boot sector (NOTE : This code doesn't handle MBR INT13 hookers)
                //    
                if (ReadFile(hFile, Sector, SectorSize, &BytesRead, NULL) && 
                    (BytesRead == SectorSize) &&
                    SetFilePointerEx(hFile, Offset, NULL, FILE_BEGIN)) {
                    
                    DWORD BytesWritten = 0;
                    PDWORD OldSignature = (PDWORD)(Sector + MBR_DISK_SIGNATURE_BYTE_OFFSET);

                    printf( "Setting PhysicalDrive%d Signature=0x%08x\n", i, Signature );
                    *OldSignature = Signature;

                    if (!WriteFile(hFile, Sector, SectorSize, &BytesWritten, NULL)) {
                        ErrorCode = GetLastError();
                    } else if (BytesWritten != SectorSize) {
                        ErrorCode = ERROR_IO_DEVICE;
                    }
                } else {
                    ErrorCode = GetLastError();

                    if (ErrorCode == ERROR_SUCCESS) {
                        ErrorCode = ERROR_IO_DEVICE;
                    }
                }                    
            } else {
                ErrorCode = GetLastError();
            }                

            CloseHandle( hFile );
        } else {
            ErrorCode = GetLastError();
        }            
    } else {
        printf( "Usage: %s <parameters>\n", argv[0] );
        printf( "    Where <parameters> are:\n" );
        printf( "    -dump                              dumps signatures for all disks\n" );
        printf( "    -set <disk num> <hex signature>    sets signature for specified disk\n" );
    }
    
    return ErrorCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\bootvar.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    bootvar.h

Abstract:

    Header file for functions to deal with boot.ini boot variables.

Author:

    Chuck Lenzmeier (chuckl) 6-Jan-2001
        extracted boot.ini-specific items from spboot.h

Revision History:

--*/

#ifndef _BOOTVAR_H_
#define _BOOTVAR_H_

typedef enum _BOOTVAR {
    LOADIDENTIFIER = 0,
    OSLOADER,
    OSLOADPARTITION,
    OSLOADFILENAME,
    OSLOADOPTIONS,
    SYSTEMPARTITION
    } BOOTVAR;

#define FIRSTBOOTVAR    LOADIDENTIFIER
#define LASTBOOTVAR     SYSTEMPARTITION
#define MAXBOOTVARS     LASTBOOTVAR+1

#define LOADIDENTIFIERVAR      "LoadIdentifier"
#define OSLOADERVAR            "OsLoader"
#define OSLOADPARTITIONVAR     "OsLoadPartition"
#define OSLOADFILENAMEVAR      "OsLoadFilename"
#define OSLOADOPTIONSVAR       "OsLoadOptions"
#define SYSTEMPARTITIONVAR     "SystemPartition"

#define DEFAULT_TIMEOUT 20

VOID
SpAddBootSet(
    IN PWSTR *BootSet,
    IN BOOLEAN Default,
    IN ULONG Signature
    );

VOID
SpDeleteBootSet(
    IN  PWSTR *BootSet,
    OUT PWSTR *OldOsLoadOptions  OPTIONAL
    );

BOOLEAN
SpFlushBootVars(
    );

#endif // _BOOTVAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\inc\setupdd.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    setupdd.h

Abstract:

    Public header file for setup device driver.

Author:

    Ted Miller (tedm) 11-August-1993

Revision History:

--*/


#ifndef _SETUPDD_
#define _SETUPDD_


#define DD_SETUP_DEVICE_NAME_U  L"\\Device\\Setup"


#define IOCTL_SETUP_START           CTL_CODE(FILE_DEVICE_UNKNOWN,0,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SETUP_FMIFS_MESSAGE   CTL_CODE(FILE_DEVICE_UNKNOWN,1,METHOD_BUFFERED,FILE_ANY_ACCESS)


typedef struct _SETUP_COMMUNICATION {

    union {
        ULONG     RequestNumber;
        NTSTATUS  Status;
        DWORD_PTR UnusedAlign64;
    } u;

    UCHAR Buffer[2048];

} SETUP_COMMUNICATION, *PSETUP_COMMUNICATION;


//
// Input structure for IOCTL_SETUP_START.
//

typedef struct _SETUP_START_INFO {

    //
    // Handles of events used for communication between
    // device driver and user-mode parts of text setup.
    //
    HANDLE RequestReadyEvent;
    HANDLE RequestServicedEvent;

    //
    // Base address of the user-mode process.
    // This is used by the device driver to load massages
    // from the user-mode process' resource tables.
    //
    PVOID UserModeImageBase;

    //
    // System information structure.
    //
    SYSTEM_BASIC_INFORMATION SystemBasicInfo;

    //
    // Address of a buffer in the user process' address space,
    // to be used for same communication.
    //
    PSETUP_COMMUNICATION Communication;

} SETUP_START_INFO, *PSETUP_START_INFO;


//
// Input structure for IOCTL_SETUP_FMIFS_MESSAGE
//

typedef struct _SETUP_DISPLAY_INFO {

    FMIFS_PACKET_TYPE   FmifsPacketType;
    PVOID               FmifsPacket;

} SETUP_FMIFS_MESSAGE, *PSETUP_FMIFS_MESSAGE;




typedef enum {
    SetupServiceDone,
    SetupServiceExecute,
    SetupServiceQueryDirectoryObject,
    SetupServiceFlushVirtualMemory,
    SetupServiceShutdownSystem,
    SetupServiceDeleteKey,
    SetupServiceLoadKbdLayoutDll,
    SetupServiceLockVolume,
    SetupServiceUnlockVolume,
    SetupServiceDismountVolume,
    SetupServiceSetDefaultFileSecurity,
    SetupServiceVerifyFileAccess,
    SetupServiceCreatePageFile,
    SetupServiceGetFullPathName,
    SetupServiceMax
};


typedef struct _SERVICE_EXECUTE {

    PWSTR FullImagePath;
    PWSTR CommandLine;
    ULONG ReturnStatus;

    //
    // The two nul-terminated strings follow in the buffer.
    //
    WCHAR Buffer[1];

} SERVICE_EXECUTE, *PSERVICE_EXECUTE;

typedef struct _SERVICE_DELETE_KEY {

    HANDLE KeyRootDirectory;
    PWSTR  Key;

    //
    // The nul-terminated string follows in the buffer.
    //
    WCHAR Buffer[1];

} SERVICE_DELETE_KEY, *PSERVICE_DELETE_KEY;

typedef struct _SERVICE_QUERY_DIRECTORY_OBJECT {

    HANDLE  DirectoryHandle;
    ULONG   Context;
    BOOLEAN RestartScan;

    //
    // Make sure this fits within the Buffer field of SETUP_COMMUNICATION.
    // It's an arroy of ULONGs to force alignment.
    //
    ULONG  Buffer[256];

} SERVICE_QUERY_DIRECTORY_OBJECT, *PSERVICE_QUERY_DIRECTORY_OBJECT;


typedef struct _SERVICE_FLUSH_VIRTUAL_MEMORY {

    IN PVOID BaseAddress;
    IN SIZE_T RangeLength;

} SERVICE_FLUSH_VIRTUAL_MEMORY, *PSERVICE_FLUSH_VIRTUAL_MEMORY;


typedef struct _SERVICE_LOAD_KBD_LAYOUT_DLL {

    PVOID TableAddress;
    WCHAR DllName[1];

} SERVICE_LOAD_KBD_LAYOUT_DLL, *PSERVICE_LOAD_KBD_LAYOUT_DLL;

typedef struct _SERVICE_LOCK_UNLOCK_VOLUME {

    HANDLE Handle;

} SERVICE_LOCK_UNLOCK_VOLUME, *PSERVICE_LOCK_UNLOCK_VOLUME;

typedef struct _SERVICE_DISMOUNT_VOLUME {

    HANDLE Handle;

} SERVICE_LOCK_DISMOUNT_VOLUME, *PSERVICE_DISMOUNT_VOLUME;

typedef struct _SERVICE_VERIFY_FILE_ACESS {

    ACCESS_MASK DesiredAccess;
    WCHAR       FileName[1];

} SERVICE_VERIFY_FILE_ACCESS, *PSERVICE_VERIFY_FILE_ACCESS;

typedef struct _SERVICE_DEFAULT_FILE_SECURITY {

    WCHAR FileName[1];

} SERVICE_DEFAULT_FILE_SECURITY, *PSERVICE_DEFAULT_FILE_SECURITY;

typedef struct _SERVICE_CREATE_PAGEFILE {

    LARGE_INTEGER MinSize;
    LARGE_INTEGER MaxSize;
    WCHAR FileName[1];

} SERVICE_CREATE_PAGEFILE, *PSERVICE_CREATE_PAGEFILE;

typedef struct _SERVICE_GETFULLPATHNAME {
    WCHAR *NameOut;
    WCHAR FileName[1];
} SERVICE_GETFULLPATHNAME, *PSERVICE_GETFULLPATHNAME;

#endif // ndef _SETUPDD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\bpb.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    bpb.h

Abstract:

    This module contains the declarations for packed and
    unpacked Bios Parameter Block

Author:

    Bill McJohn     [BillMc]        24-September-1993

Revision History:

    Adapted from utils\ifsutil\inc\bpb.hxx

--*/

#if !defined( _BPB_DEFN_ )
#define _BPB_DEFN_

#define cOEM    8
#define cLABEL    11
#define cSYSID    8

typedef struct _PACKED_BIOS_PARAMETER_BLOCK {
    UCHAR  BytesPerSector[2];                       //  offset = 0x000
    UCHAR  SectorsPerCluster[1];                    //  offset = 0x002
    UCHAR  ReservedSectors[2];                      //  offset = 0x003
    UCHAR  Fats[1];                                 //  offset = 0x005
    UCHAR  RootEntries[2];                          //  offset = 0x006
    UCHAR  Sectors[2];                              //  offset = 0x008
    UCHAR  Media[1];                                //  offset = 0x00A
    UCHAR  SectorsPerFat[2];                        //  offset = 0x00B
    UCHAR  SectorsPerTrack[2];                      //  offset = 0x00D
    UCHAR  Heads[2];                                //  offset = 0x00F
    UCHAR  HiddenSectors[4];                        //  offset = 0x011
    UCHAR  LargeSectors[4];                         //  offset = 0x015
} PACKED_BIOS_PARAMETER_BLOCK;                      //  sizeof = 0x019
typedef PACKED_BIOS_PARAMETER_BLOCK *PPACKED_BIOS_PARAMETER_BLOCK;

typedef struct BIOS_PARAMETER_BLOCK {
    USHORT BytesPerSector;
    UCHAR  SectorsPerCluster;
    USHORT ReservedSectors;
    UCHAR  Fats;
    USHORT RootEntries;
    USHORT Sectors;
    UCHAR  Media;
    USHORT SectorsPerFat;
    USHORT SectorsPerTrack;
    USHORT Heads;
    ULONG  HiddenSectors;
    ULONG  LargeSectors;
} BIOS_PARAMETER_BLOCK;
typedef BIOS_PARAMETER_BLOCK *PBIOS_PARAMETER_BLOCK;

#if !defined( _UCHAR_DEFINED_ )

#define _UCHAR_DEFINED_

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//
typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

#define CopyUchar1(Dst,Src) {                                \
    ((PUCHAR1)(Dst))->Uchar[0] = ((PUCHAR1)(Src))->Uchar[0]; \
}

#define CopyUchar2(Dst,Src) {                                \
    ((PUCHAR2)(Dst))->Uchar[0] = ((PUCHAR2)(Src))->Uchar[0]; \
    ((PUCHAR2)(Dst))->Uchar[1] = ((PUCHAR2)(Src))->Uchar[1]; \
}

#define CopyUchar4(Dst,Src) {                                \
    ((PUCHAR4)(Dst))->Uchar[0] = ((PUCHAR4)(Src))->Uchar[0]; \
    ((PUCHAR4)(Dst))->Uchar[1] = ((PUCHAR4)(Src))->Uchar[1]; \
    ((PUCHAR4)(Dst))->Uchar[2] = ((PUCHAR4)(Src))->Uchar[2]; \
    ((PUCHAR4)(Dst))->Uchar[3] = ((PUCHAR4)(Src))->Uchar[3]; \
}

#endif // _UCHAR_DEFINED_

//
//  This macro takes a Packed BPB and fills in its Unpacked equivalent
//
#define UnpackBios(Bios,Pbios) {                                          \
    CopyUchar2(&((Bios)->BytesPerSector),    (Pbios)->BytesPerSector   ); \
    CopyUchar1(&((Bios)->SectorsPerCluster), (Pbios)->SectorsPerCluster); \
    CopyUchar2(&((Bios)->ReservedSectors),   (Pbios)->ReservedSectors  ); \
    CopyUchar1(&((Bios)->Fats),              (Pbios)->Fats             ); \
    CopyUchar2(&((Bios)->RootEntries),       (Pbios)->RootEntries      ); \
    CopyUchar2(&((Bios)->Sectors),           (Pbios)->Sectors          ); \
    CopyUchar1(&((Bios)->Media),             (Pbios)->Media            ); \
    CopyUchar2(&((Bios)->SectorsPerFat),     (Pbios)->SectorsPerFat    ); \
    CopyUchar2(&((Bios)->SectorsPerTrack),   (Pbios)->SectorsPerTrack  ); \
    CopyUchar2(&((Bios)->Heads),             (Pbios)->Heads            ); \
    CopyUchar4(&((Bios)->HiddenSectors),     (Pbios)->HiddenSectors    ); \
    CopyUchar4(&((Bios)->LargeSectors),      (Pbios)->LargeSectors     ); \
}


//
//  This macro takes an Unpacked BPB and fills in its Packed equivalent
//
#define PackBios(Bios,Pbios) {                                            \
    CopyUchar2((Pbios)->BytesPerSector,    &((Bios)->BytesPerSector)   ); \
    CopyUchar1((Pbios)->SectorsPerCluster, &((Bios)->SectorsPerCluster)); \
    CopyUchar2((Pbios)->ReservedSectors,   &((Bios)->ReservedSectors)  ); \
    CopyUchar1((Pbios)->Fats,              &((Bios)->Fats)             ); \
    CopyUchar2((Pbios)->RootEntries,       &((Bios)->RootEntries)      ); \
    CopyUchar2((Pbios)->Sectors,           &((Bios)->Sectors)          ); \
    CopyUchar1((Pbios)->Media,             &((Bios)->Media)            ); \
    CopyUchar2((Pbios)->SectorsPerFat,     &((Bios)->SectorsPerFat)    ); \
    CopyUchar2((Pbios)->SectorsPerTrack,   &((Bios)->SectorsPerTrack)  ); \
    CopyUchar2((Pbios)->Heads,             &((Bios)->Heads)            ); \
    CopyUchar4((Pbios)->HiddenSectors,     &((Bios)->HiddenSectors)    ); \
    CopyUchar4((Pbios)->LargeSectors,      &((Bios)->LargeSectors)     ); \
}

//
//  And now, an extended BPBP:
//
typedef struct _PACKED_EXTENDED_BIOS_PARAMETER_BLOCK {
    UCHAR  IntelNearJumpCommand[1];
    UCHAR  BootStrapJumpOffset[2];
    UCHAR  OemData[cOEM];

    PACKED_BIOS_PARAMETER_BLOCK Bpb;
    UCHAR   PhysicalDrive[1];           // 0 = removable, 80h = fixed
    UCHAR   CurrentHead[1];             // not used by fs utils
    UCHAR   Signature[1];               // boot signature
    UCHAR   SerialNumber[4];            // volume serial number
    UCHAR   Label[cLABEL];              // volume label, padded with spaces
    UCHAR   SystemIdText[cSYSID];       // system ID, (e.g. FAT or HPFS)
    UCHAR   StartBootCode;              // first byte of boot code

} PACKED_EXTENDED_BIOS_PARAMETER_BLOCK, *PPACKED_EXTENDED_BIOS_PARAMETER_BLOCK;

typedef struct _EXTENDED_BIOS_PARAMETER_BLOCK {
    UCHAR  IntelNearJumpCommand;
    USHORT BootStrapJumpOffset;
    UCHAR  OemData[cOEM];

    BIOS_PARAMETER_BLOCK Bpb;
    UCHAR   PhysicalDrive;
    UCHAR   CurrentHead;
    UCHAR   Signature;
    ULONG   SerialNumber;
    UCHAR   Label[11];
    UCHAR   SystemIdText[8];

} EXTENDED_BIOS_PARAMETER_BLOCK, *PEXTENDED_BIOS_PARAMETER_BLOCK;

//
// This macro unpacks a Packed Extended BPB.
//
#define UnpackExtendedBios( Bios, Pbios ) {                                 \
    CopyUchar1( &((Bios)->IntelNearJumpCommand), (Pbios)->IntelNearJumpCommand );    \
    CopyUchar2( &((Bios)->BootStrapJumpOffset),  (Pbios)->BootStrapJumpOffset  );    \
    memcpy( (Bios)->OemData,        (Pbios)->OemData,       cOEM );         \
    UnpackBios( &((Bios)->Bpb), &((Pbios)->Bpb));                           \
    CopyUchar1( &((Bios)->PhysicalDrive),   (Pbios)->PhysicalDrive );       \
    CopyUchar1( &((Bios)->CurrentHead),     (Pbios)->CurrentHead );         \
    CopyUchar1( &((Bios)->Signature),       (Pbios)->Signature )            \
    CopyUchar4( &((Bios)->SerialNumber),    (Pbios)->SerialNumber );        \
    memcpy( (Bios)->Label,          (Pbios)->Label,        cLABEL );        \
    memcpy( (Bios)->SystemIdText,   (Pbios)->SystemIdText,  cSYSID );       \
}

//
// This macro packs a Packed Extended BPB.
//
#define PackExtendedBios( Bios, Pbios ) {                                   \
    PackBios( &((Bios)->Bpb), &((Pbios)->Bpb));                             \
    CopyUchar1( (Pbios)->IntelNearJumpCommand,  &((Bios)->IntelNearJumpCommand)  );    \
    CopyUchar2( (Pbios)->BootStrapJumpOffset,   &((Bios)->BootStrapJumpOffset)   );    \
    memcpy( (Pbios)->OemData,        (Bios)->OemData,       cOEM );         \
    CopyUchar1( (Pbios)->PhysicalDrive,     &((Bios)->PhysicalDrive ));     \
    CopyUchar1( (Pbios)->CurrentHead,       &((Bios)->CurrentHead ));       \
    CopyUchar1( (Pbios)->Signature,         &((Bios)->Signature));          \
    CopyUchar4( (Pbios)->SerialNumber,      &((Bios)->SerialNumber ));      \
    memcpy( (Pbios)->Label,           (Bios)->Label,           cLABEL );    \
    memcpy( (Pbios)->SystemIdText,    (Bios)->SystemIdText,    cSYSID );    \
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\cvf.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cvf.hxx

Abstract:

    This module contains basic declarations and definitions for
    the double-space file system format.  Note that more extensive
    description of the file system structures may be found in
    ntos\fastfat\cvf.h

Author:

    Bill McJohn     [BillMc]        24-September-1993

Revision History:

    Adapted from utils\ufat\inc\cvf.hxx

--*/

#if !defined( _CVF_DEFN_ )
#define _CVF_DEFN_

#include "bpb.h"

// Manifest constants for fixed values on a Double Space drive:
//
CONST DoubleSpaceBytesPerSector = 512;
CONST DoubleSpaceLog2BytesPerSector = 9;
CONST DoubleSpaceSectorsPerCluster = 16;
CONST DoubleSpaceLog2SectorsPerCluster = 4;
CONST DoubleSpaceReservedSectors = 16;
CONST DoubleSpaceFats = 1;
CONST DoubleSpaceSectorsInRootDir = 32;
CONST DoubleSpaceRootEntries = 512;
CONST DoubleSpaceMediaByte = 0xf8;
CONST DoubleSpaceSectorsPerTrack = 0x11;
CONST DoubleSpaceHeads = 6;
CONST DoubleSpaceHiddenSectors = 0;
CONST DoubleSpaceReservedSectors2 = 31;
CONST DSBytesPerBitmapPage = 2048;
CONST DSSectorsPerBitmapPage = 4;

CONST ULONG EIGHT_MEG = 8 * 1024L * 1024L;

CONST DbSignatureLength = 4;
CONST UCHAR FirstDbSignature[4 /* DbSignatureLength */] = { (UCHAR)0xf8, 'D', 'R', 0 };
CONST UCHAR SecondDbSignature[4 /* DbSignatureLength */] = "MDR";

#if 0
// INLINE
ULONG
ComputeMaximumCapacity(
    IN ULONG HostDriveSize
    )
/*++

Routine Description:

    This function computes the maximum capacity for a compressed
    volume file on a host volume of a given size.

Arguments:

    HostDriveSize   --  Supplies the size in bytes of the host drive.

Return Value:

    The appropriate Maximum Capacity.

--*/
{
    ULONG MaxCap;

    if( HostDriveSize < 20 * 1024L * 1024L ) {

        MaxCap = 16 * HostDriveSize;

    } else if ( HostDriveSize < 64 * 1024L * 1024L ) {

        MaxCap = 8 * HostDriveSize;

    } else {

        MaxCap = 4 * HostDriveSize;
    }

    if( MaxCap < 4 * 1024L * 1024L ) {

        MaxCap = 4 * 1024L * 1024L;

    } else if( MaxCap > 512 * 1024L * 1024L ) {

        MaxCap = 512 * 1024L * 1024L;
    }

    return MaxCap;
}
#endif

typedef struct _PACKED_CVF_HEADER {

    //
    //  First a typical start of a boot sector
    //

    UCHAR Jump[1];                                  // offset = 0x000   0
    UCHAR JmpOffset[2];
    UCHAR Oem[8];                                   // offset = 0x003   3
    PACKED_BIOS_PARAMETER_BLOCK PackedBpb;          // offset = 0x00B  11

    //
    //  Now the DblSpace extensions
    //

    UCHAR CvfFatExtensionsLbnMinus1[2];             // offset = 0x024  36
    UCHAR LogOfBytesPerSector[1];                   // offset = 0x026  38
    UCHAR DosBootSectorLbn[2];                      // offset = 0x027  39
    UCHAR DosRootDirectoryOffset[2];                // offset = 0x029  41
    UCHAR CvfHeapOffset[2];                         // offset = 0x02B  43
    UCHAR CvfFatFirstDataEntry[2];                  // offset = 0x02D  45
    UCHAR CvfBitmap2KSize[1];                       // offset = 0x02F  47
    UCHAR Reserved1[2];                             // offset = 0x030  48
    UCHAR LogOfSectorsPerCluster[1];                // offset = 0x032  50
    UCHAR Reserved2[2];                             // offset = 0x033
    UCHAR MinFile[4];                               // offset = 0x035
    UCHAR Reserved3[4];                             // offset = 0x039
    UCHAR Is12BitFat[1];                            // offset = 0x03D  61
    UCHAR CvfMaximumCapacity[2];                    // offset = 0x03E  62
    UCHAR StartBootCode;

} PACKED_CVF_HEADER;                                // sizeof = 0x040  64
typedef PACKED_CVF_HEADER *PPACKED_CVF_HEADER;

//
//  For the unpacked version we'll only define the necessary field and skip
//  the jump and oem fields.
//

typedef struct _CVF_HEADER {

    UCHAR Jump;
    USHORT JmpOffset;
 
    UCHAR Oem[8];
    BIOS_PARAMETER_BLOCK Bpb;

    USHORT CvfFatExtensionsLbnMinus1;
    UCHAR  LogOfBytesPerSector;
    USHORT DosBootSectorLbn;
    USHORT DosRootDirectoryOffset;
    USHORT CvfHeapOffset;
    USHORT CvfFatFirstDataEntry;
    UCHAR  CvfBitmap2KSize;
    UCHAR  LogOfSectorsPerCluster;
    UCHAR  Is12BitFat;
    ULONG  MinFile;
    USHORT CvfMaximumCapacity;

} CVF_HEADER;
typedef CVF_HEADER *PCVF_HEADER;

//
//  Here is NT's typical routine/macro to unpack the cvf header because DOS
//  doesn't bother to naturally align anything.
//
//      VOID
//      CvfUnpackCvfHeader (
//          IN OUT PCVF_HEADER UnpackedHeader,
//          IN PPACKED_CVF_HEADER PackedHeader
//          );
//

#define CvfUnpackCvfHeader(UH,PH) {                                                      \
                                                                                         \
    memcpy( &(UH)->Jump,        &(PH)->Jump,        1 );                                 \
    memcpy( &(UH)->JmpOffset,   &(PH)->JmpOffset,   2 );                                 \
    memcpy( &(UH)->Oem,     &(PH)->Oem,     8 );                                         \
    UnpackBios( &(UH)->Bpb, &(PH)->PackedBpb );                                          \
    CopyUchar2( &(UH)->CvfFatExtensionsLbnMinus1, &(PH)->CvfFatExtensionsLbnMinus1[0] ); \
    CopyUchar1( &(UH)->LogOfBytesPerSector,       &(PH)->LogOfBytesPerSector[0]       ); \
    CopyUchar2( &(UH)->DosBootSectorLbn,          &(PH)->DosBootSectorLbn[0]          ); \
    CopyUchar2( &(UH)->DosRootDirectoryOffset,    &(PH)->DosRootDirectoryOffset[0]    ); \
    CopyUchar2( &(UH)->CvfHeapOffset,             &(PH)->CvfHeapOffset[0]             ); \
    CopyUchar2( &(UH)->CvfFatFirstDataEntry,      &(PH)->CvfFatFirstDataEntry[0]      ); \
    CopyUchar1( &(UH)->CvfBitmap2KSize,           &(PH)->CvfBitmap2KSize[0]           ); \
    CopyUchar1( &(UH)->LogOfSectorsPerCluster,    &(PH)->LogOfSectorsPerCluster[0]    ); \
    CopyUchar1( &(UH)->Is12BitFat,                &(PH)->Is12BitFat[0]                ); \
    CopyUchar4( &(UH)->MinFile,                   &(PH)->MinFile[0]                   ); \
    CopyUchar2( &(UH)->CvfMaximumCapacity,        &(PH)->CvfMaximumCapacity[0]        ); \
}


#define CvfPackCvfHeader(PH,UH) {                                                    \
                                                                                     \
    memcpy( &(PH)->Jump,        &(UH)->Jump,        1 );                             \
    memcpy( &(PH)->JmpOffset,   &(UH)->JmpOffset,   2 );                             \
    memcpy( &(PH)->Oem,     &(UH)->Oem,     8 );                                     \
    PackBios( &(UH)->Bpb,   &(PH)->PackedBpb,  );                                    \
    CopyUchar2( (PH)->CvfFatExtensionsLbnMinus1, &(UH)->CvfFatExtensionsLbnMinus1 ); \
    CopyUchar1( (PH)->LogOfBytesPerSector,       &(UH)->LogOfBytesPerSector       ); \
    CopyUchar2( (PH)->DosBootSectorLbn,          &(UH)->DosBootSectorLbn          ); \
    CopyUchar2( (PH)->DosRootDirectoryOffset,    &(UH)->DosRootDirectoryOffset    ); \
    CopyUchar2( (PH)->CvfHeapOffset,             &(UH)->CvfHeapOffset             ); \
    CopyUchar2( (PH)->CvfFatFirstDataEntry,      &(UH)->CvfFatFirstDataEntry      ); \
    CopyUchar1( (PH)->CvfBitmap2KSize,           &(UH)->CvfBitmap2KSize           ); \
    CopyUchar1( (PH)->LogOfSectorsPerCluster,    &(UH)->LogOfSectorsPerCluster    ); \
    CopyUchar1( (PH)->Is12BitFat,                &(UH)->Is12BitFat                ); \
    CopyUchar4( (PH)->MinFile,                   &(UH)->MinFile                   ); \
    CopyUchar2( (PH)->CvfMaximumCapacity,        &(UH)->CvfMaximumCapacity        ); \
    memset( (PH)->Reserved1, 0,  2 );                                                \
    memset( (PH)->Reserved2, 0,  2 );                                                \
    memset( (PH)->Reserved3, 0,  4 );                                                \
}


//
//  The CVF FAT EXTENSIONS is a table is ULONG entries.  Each entry corresponds
//  to a FAT cluster.  The entries describe where in the CVF_HEAP to locate
//  the data for the cluster.  It indicates if the data is compressed and the
//  length of the compressed and uncompressed form.
//

typedef struct _CVF_FAT_EXTENSIONS {

    ULONG CvfHeapLbnMinus1               : 21;
    ULONG Reserved                       :  1;
    ULONG CompressedSectorLengthMinus1   :  4;
    ULONG UncompressedSectorLengthMinus1 :  4;
    ULONG IsDataUncompressed             :  1;
    ULONG IsEntryInUse                   :  1;

} CVF_FAT_EXTENSIONS;
typedef CVF_FAT_EXTENSIONS *PCVF_FAT_EXTENSIONS;


//
//  Some sizes are fixed so we'll declare them as manifest constants
//
#define CVF_MINIMUM_DISK_SIZE            (512 * 1024L)
#define CVF_FATFAILSAFE                  (1024L)
#define CVF_MIN_HEAP_SECTORS             (60)
#define CVF_RESERVED_AREA_1_SECTOR_SIZE  (1)
#define CVF_RESERVED_AREA_2_SECTOR_SIZE  (31)
#define CVF_RESERVED_AREA_4_SECTOR_SIZE  (2)


#endif // _CVF_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\dynupdt.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dynupdt.h

Abstract:

    Dynamic Update support for text setup. Portions moved from i386\win31upg.c

Author:

    Ovidiu Temereanca (ovidiut) 20-Aug-2000

Revision History:

--*/


#pragma once

//
// Globals
//

extern HANDLE g_UpdatesCabHandle;
extern PVOID g_UpdatesSifHandle;
extern HANDLE g_UniprocCabHandle;
extern PVOID g_UniprocSifHandle;

//
// Dynamic update boot driver path in NT namespace
//
extern PWSTR DynUpdtBootDriverPath;


//
// Prototypes
//


BOOLEAN
SpInitAlternateSource (
    VOID
    );

VOID
SpUninitAlternateSource (
    VOID
    );

BOOLEAN
SpInitializeUpdatesCab (
    IN      PWSTR UpdatesCab,
    IN      PWSTR UpdatesSifSection,
    IN      PWSTR UniprocCab,
    IN      PWSTR UniprocSifSection
    );

PWSTR
SpNtPathFromDosPath (
    IN      PWSTR DosPath
    );

PDISK_REGION
SpPathComponentToRegion(
    IN PWSTR PathComponent
    );

PWSTR
SpGetDynamicUpdateBootDriverPath(
    IN  PWSTR   NtBootPath,
    IN  PWSTR   NtBootDir,
    IN  PVOID   InfHandle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\dynupdt.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dynupdt.c

Abstract:

    Dynamic Update support for text setup. Portions moved from i386\win31upg.c

Author:

    Ovidiu Temereanca (ovidiut) 20-Aug-2000

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop

//
// Macros
//
#define MAX_SECTION_NAME_LENGTH 14
#define UPDATES_SECTION_NAME    L"updates"
#define UNIPROC_SECTION_NAME    L"uniproc"

//
// Globals
//

HANDLE g_UpdatesCabHandle = NULL;
PVOID g_UpdatesSifHandle = NULL;
HANDLE g_UniprocCabHandle = NULL;
PVOID g_UniprocSifHandle = NULL;


WCHAR
SpExtractDriveLetter(
    IN PWSTR PathComponent
    );


BOOLEAN
SpInitAlternateSource (
    VOID
    )
{
    PWSTR p;
    NTSTATUS Status;
    ULONG ErrorLine;
    WCHAR updatesCab[MAX_PATH];
    WCHAR updatesSif[MAX_PATH];
    WCHAR updatesSifSection[MAX_SECTION_NAME_LENGTH];
    WCHAR uniprocCab[MAX_PATH];
    WCHAR uniprocSif[MAX_PATH];
    WCHAR uniprocSifSection[MAX_SECTION_NAME_LENGTH];
    BOOLEAN bUniprocCab = FALSE;
    BOOLEAN b = FALSE;

    //
    // look if section [SetupParams] has an UpdatedSources key
    //
    p = SpGetSectionKeyIndex (WinntSifHandle, SIF_SETUPPARAMS, SIF_UPDATEDSOURCES, 0);
    if (!p) {
        return FALSE;
    }
    p = SpNtPathFromDosPath (p);
    if (!p) {
        goto exit;
    }

    wcscpy (updatesCab, p);
    wcscpy (updatesSif, updatesCab);
    p = wcsrchr (updatesSif, L'.');
    if (!p) {
        p = wcsrchr (updatesSif, 0);
    }
    wcscpy (p, L".sif");

    //
    // load the sif
    //
    Status = SpLoadSetupTextFile (
                updatesSif,
                NULL,                  // No image already in memory
                0,                     // Image size is empty
                &g_UpdatesSifHandle,
                &ErrorLine,
                FALSE,
                FALSE
                );
    if (!NT_SUCCESS (Status)) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: SpInitAlternateSource: Unable to read %ws. ErrorLine = %ld, Status = %lx \n",
            updatesSif,
            ErrorLine,
            Status
            ));
        goto exit;
    }

    wcscpy (updatesSifSection, UPDATES_SECTION_NAME);

    if (!SpSearchTextFileSection (g_UpdatesSifHandle, updatesSifSection) ||
        SpCountLinesInSection (g_UpdatesSifHandle, updatesSifSection) == 0) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            DPFLTR_ERROR_LEVEL,
            "SETUP: SpInitAlternateSource: Section [%ws] not found or empty in %ws.\n",
            updatesSifSection,
            updatesSif
            ));
        goto exit;
    }

    p = SpGetSectionKeyIndex (WinntSifHandle, SIF_SETUPPARAMS, SIF_UPDATEDSOURCES, 1);
    if (p && *p) {
        p = SpNtPathFromDosPath (p);
        if (!p) {
            goto exit;
        }

        wcscpy (uniprocCab, p);
        wcscpy (uniprocSif, uniprocCab);
        p = wcsrchr (uniprocSif, L'.');
        if (!p) {
            p = wcsstr (uniprocSif, 0);
        }
        wcscpy (p, L".sif");

        //
        // load the sif
        //
        Status = SpLoadSetupTextFile (
                    uniprocSif,
                    NULL,                  // No image already in memory
                    0,                     // Image size is empty
                    &g_UniprocSifHandle,
                    &ErrorLine,
                    FALSE,
                    FALSE
                    );
        if (!NT_SUCCESS (Status)) {
            KdPrintEx((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: SpInitAlternateSource: Unable to read %ws. ErrorLine = %ld, Status = %lx \n",
                uniprocSif,
                ErrorLine,
                Status
                ));
            goto exit;
        }

        wcscpy (uniprocSifSection, UNIPROC_SECTION_NAME);

        if (!SpSearchTextFileSection (g_UniprocSifHandle, uniprocSifSection) ||
            SpCountLinesInSection (g_UniprocSifHandle, uniprocSifSection) == 0) {
            KdPrintEx((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: SpInitAlternateSource: Section [%ws] not found or empty in %ws.\n",
                uniprocSifSection,
                uniprocSif
                ));
            goto exit;
        }
        bUniprocCab = TRUE;
    }

    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SETUP: SpInitAlternateSource: Using alternate sources: %ws\n", updatesCab));

    b = SpInitializeUpdatesCab (
            updatesCab,
            updatesSifSection,
            bUniprocCab ? uniprocCab : NULL,
            bUniprocCab ? uniprocSifSection : NULL
            );

exit:
    if (!b) {
        SpUninitAlternateSource ();
    }

    return b;
}


VOID
SpUninitAlternateSource (
    VOID
    )
{
    if (g_UpdatesSifHandle) {
        SpFreeTextFile (g_UpdatesSifHandle);
        g_UpdatesSifHandle = NULL;
    }
    if (g_UniprocSifHandle) {
        SpFreeTextFile (g_UniprocSifHandle);
        g_UniprocSifHandle = NULL;
    }
}


BOOLEAN
SpInitializeUpdatesCab (
    IN      PWSTR UpdatesCab,
    IN      PWSTR UpdatesSifSection,
    IN      PWSTR UniprocCab,
    IN      PWSTR UniprocSifSection
    )
{
    PWSTR CabFileSection;
    NTSTATUS Status;
    PWSTR DriverCabName, DriverCabPath;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    CABDATA *MyCabData, *MyList = NULL;
    DWORD i;
    BOOLEAN b = TRUE;

    INIT_OBJA (&Obja, &UnicodeString, UpdatesCab);
    Status = ZwCreateFile (&g_UpdatesCabHandle,
                           FILE_GENERIC_READ,
                           &Obja,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ,
                           FILE_OPEN,
                           0,
                           NULL,
                           0 );
    if (!NT_SUCCESS (Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open cab file %ws. Status = %lx \n", UpdatesCab, Status));
        return FALSE;
    }
    //
    // create the list entry
    //
    MyCabData = SpMemAlloc (sizeof(CABDATA));
    MyCabData->CabName = SpDupStringW (UpdatesCab);
    MyCabData->CabHandle = g_UpdatesCabHandle;
    MyCabData->CabSectionName = SpDupStringW (UpdatesSifSection);
    MyCabData->CabInfHandle = g_UpdatesSifHandle;
    MyCabData->Next = MyList;
    MyList = MyCabData;

    if (UniprocCab) {
        INIT_OBJA (&Obja, &UnicodeString, UniprocCab);
        Status = ZwCreateFile (&g_UniprocCabHandle,
                               FILE_GENERIC_READ,
                               &Obja,
                               &IoStatusBlock,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ,
                               FILE_OPEN,
                               0,
                               NULL,
                               0 );
        if (!NT_SUCCESS (Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open cab file %ws. Status = %lx \n", UniprocCab, Status));
            b = FALSE;
            goto exit;
        }
        //
        // create the list entry
        //
        MyCabData = SpMemAlloc (sizeof(CABDATA));
        MyCabData->CabName = SpDupStringW (UniprocCab);
        MyCabData->CabHandle = g_UniprocCabHandle;
        MyCabData->CabSectionName = SpDupStringW (UniprocSifSection);
        MyCabData->CabInfHandle = g_UniprocSifHandle;
        MyCabData->Next = MyList;
        MyList = MyCabData;
    }

exit:
    if (b) {
        //
        // insert it at the beginning
        //
        while (MyList && MyList->Next) {
            MyList = MyList->Next;
        }
        if (MyList) {
            MyList->Next = CabData;
            CabData = MyList;
        }
    } else {
        //
        // destroy MyList
        //
        while (MyList) {
            MyCabData = MyList->Next;
            MyList = MyCabData;
            SpMemFree (MyCabData->CabName);
            SpMemFree (MyCabData->CabSectionName);
            SpMemFree (MyCabData);
        }
    }

    return b;
}


PWSTR
SpNtPathFromDosPath (
    IN      PWSTR DosPath
    )
{
    PDISK_REGION region;
    WCHAR drive[_MAX_DRIVE];
    WCHAR dir[_MAX_DIR];
    WCHAR fname[_MAX_FNAME];
    WCHAR ext[_MAX_EXT];
    PWSTR p;

    if (!DosPath) {
        return NULL;
    }

    region = SpPathComponentToRegion (DosPath);
    if (!region) {
        return NULL;
    }

    if (DosPath[2] != L'\\') {
        return NULL;
    }

    SpNtNameFromRegion (region, TemporaryBuffer, ELEMENT_COUNT(TemporaryBuffer), PartitionOrdinalCurrent);
    wcscat (TemporaryBuffer, DosPath + 2);
    return SpDupStringW (TemporaryBuffer);
}



PDISK_REGION
SpPathComponentToRegion(
    IN PWSTR PathComponent
    )

/*++

Routine Description:

    This routine attempts to locate a region descriptor for a
    given DOS path component.  If the DOS path component does
    not start with x:, then this fails.

Arguments:

    PathComponent - supplies a component from the DOS search path,
        for which a region esacriptor is desired.

Return Value:

    Pointer to disk region; NULL if none found with drive letter
    that starts the dos component.

--*/

{
    WCHAR c;
    ULONG disk;
    PDISK_REGION region;

    c = SpExtractDriveLetter(PathComponent);
    if(!c) {
        return(NULL);
    }

    for(disk=0; disk<HardDiskCount; disk++) {

        for(region=PartitionedDisks[disk].PrimaryDiskRegions; region; region=region->Next) {
            if(region->DriveLetter == c) {
                ASSERT(region->PartitionedSpace);
                return(region);
            }
        }

        //
        // Do not see extended partition on PC98.
        //
        for(region=PartitionedDisks[disk].ExtendedDiskRegions; region; region=region->Next) {
            if(region->DriveLetter == c) {
                ASSERT(region->PartitionedSpace);
                return(region);
            }
        }
    }

    return(NULL);
}


WCHAR
SpExtractDriveLetter(
    IN PWSTR PathComponent
    )
{
    WCHAR c;

    if((wcslen(PathComponent) >= 2) && (PathComponent[1] == L':')) {

        c = RtlUpcaseUnicodeChar(PathComponent[0]);
        if((c >= L'A') && (c <= L'Z')) {
            return(c);
        }
    }

    return(0);
}


PWSTR
SpGetDynamicUpdateBootDriverPath(
    IN  PWSTR   NtBootPath,
    IN  PWSTR   NtBootDir,
    IN  PVOID   InfHandle
    )
/*++

Routine Description:

    Gets the dynamic update boot driver directory's root
    path. 

Arguments:

    NtBootPath - Boot path in NT namespace

    NtBootDir  - Boot directory under boot path (like $WIN_NT$.~BT)

    InfHandle  - Winnt.sif handle

Return Value:

    Returns the dynamic update boot driver root path if successful 
    otherwise returns NULL

--*/
{
    PWSTR   DriverDir = NULL; 

    if (NtBootPath && NtBootDir && InfHandle) {
        PWSTR   Present = SpGetSectionKeyIndex(InfHandle,
                            WINNT_SETUPPARAMS_W,
                            WINNT_SP_DYNUPDTBOOTDRIVERPRESENT_W,
                            0);

        PWSTR   Dir = SpGetSectionKeyIndex(InfHandle,
                            WINNT_SETUPPARAMS_W,
                            WINNT_SP_DYNUPDTBOOTDRIVERROOT_W,
                            0);

        if (Dir && Present && !_wcsicmp(Present, L"yes")) {
            WCHAR   Buffer[MAX_PATH];

            wcscpy(Buffer, NtBootPath);
            SpConcatenatePaths(Buffer, NtBootDir);

            //
            // NOTE : Currently ignore boot driver root path
            //
            // SpConcatenatePaths(Buffer, Dir);            

            DriverDir = SpDupStringW(Buffer);
        }
    }

    return DriverDir;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\diamond.c ===
#include "spprecmp.h"
#pragma hdrstop
#include <diamondd.h>

#define SETUP_FDI_POOL_TAG   0x44465053      // 'SPFD'

#ifdef DeleteFile
#undef DeleteFile   // we mean "DeleteFile", not "DeleteFileA"
#endif

HFDI FdiContext;
ERF FdiError;

//
// Gloabls used when copying a file.
// Setup opens the source and target files and maps the source.
// To avoid opening and closing the source and target multiple times
// and to maintain a mapped file inplementation, we'll fake the i/o calls.
// These globals remember state about the source (cabinet) and target
// files currently in use.
//
PUCHAR SpdSourceAddress;
ULONG SpdSourceFileSize;

typedef struct {
    PEXPAND_CALLBACK    Callback;
    PVOID               CallbackContext;
    LPWSTR              DestinationPath;
} EXPAND_CAB_CONTEXT;

typedef struct _DRIVER_CAB_CONTEXT {
    PCWSTR  FileName;
    PCSTR   FileNameA;
    USHORT  FileDate;
    USHORT  FileTime;
} DRIVER_CAB_CONTEXT, *PDRIVER_CAB_CONTEXT;

DRIVER_CAB_CONTEXT DriverContext;

typedef struct _MY_FILE_STATE {
    ULONG Signature;
    union {
        LONG FileOffset;
        HANDLE Handle;
    } u;
} MY_FILE_STATE, *PMY_FILE_STATE;

#define SOURCE_FILE_SIGNATURE 0x45f3ec83
#define TARGET_FILE_SIGNATURE 0x46f3ec83

MY_FILE_STATE CurrentTargetFile;

INT_PTR
DIAMONDAPI
SpdNotifyFunction(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Perameters
    );

INT_PTR
DIAMONDAPI
SpdNotifyFunctionCabinet(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Parameters
    );

INT_PTR
DIAMONDAPI
SpdNotifyFunctionDriverCab(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Perameters
    );


INT_PTR
DIAMONDAPI
SpdFdiOpen(
    IN PSTR FileName,
    IN int  oflag,
    IN int  pmode
    );

int
DIAMONDAPI
SpdFdiClose(
    IN INT_PTR Handle
    );


VOID
pSpdInitGlobals(
    IN PVOID SourceBaseAddress,
    IN ULONG SourceFileSize
    )
{
    SpdSourceAddress = SourceBaseAddress;
    SpdSourceFileSize = SourceFileSize;
}



BOOLEAN
SpdIsCabinet(
    IN PVOID SourceBaseAddress,
    IN ULONG SourceFileSize,
    OUT PBOOLEAN ContainsMultipleFiles
    )
{
    FDICABINETINFO CabinetInfo;
    INT_PTR h;
    BOOLEAN b;

    *ContainsMultipleFiles = FALSE;

    ASSERT(FdiContext);
    if(!FdiContext) {
        return(FALSE);
    }

    //
    // Save away globals for later use.
    //
    pSpdInitGlobals(SourceBaseAddress,SourceFileSize);

    //
    // 'Open' the file so we can pass a handle that will work
    // with SpdFdiRead and SpdFdiWrite.
    //
    h = SpdFdiOpen("",0,0);
    if(h == -1) {
        return(FALSE);
    }

    //
    // We don't trust diamond to be robust.
    //

    memset(&CabinetInfo, 0, sizeof(CabinetInfo));

    try {
        b = FDIIsCabinet(FdiContext,h,&CabinetInfo) ? TRUE : FALSE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }

    //
    // If spanned or more than one file inside, report it as multiple
    //

    if (b) {
        if ((CabinetInfo.cFolders > 1) || (CabinetInfo.cFiles > 1)) {
            *ContainsMultipleFiles = TRUE;
        }
    }

    //
    // 'Close' the file.
    //
    SpdFdiClose(h);

    return(b);
}



BOOLEAN
SpdIsCompressed(
    IN PVOID SourceBaseAddress,
    IN ULONG SourceFileSize
    )
{
    INT_PTR h;
    BOOLEAN b;
    BOOLEAN bMultiple;

    b = SpdIsCabinet(SourceBaseAddress,SourceFileSize,&bMultiple);

    //
    // Compressed files with more than one contained file s/b treated as
    // an uncompressed file and copied as is.  We're not prepared to uncompress
    // multiple files from one file.
    //

    if (bMultiple) {
        b = FALSE;
    }

    return(b);
}



NTSTATUS
SpdDecompressFile(
    IN PVOID  SourceBaseAddress,
    IN ULONG  SourceFileSize,
    IN HANDLE DestinationHandle
    )
{
    BOOL b;

    ASSERT(FdiContext);

    //
    // Save away globals for later use.
    //
    pSpdInitGlobals(SourceBaseAddress,SourceFileSize);

    CurrentTargetFile.Signature = TARGET_FILE_SIGNATURE;
    CurrentTargetFile.u.Handle = DestinationHandle;

    //
    // Get the copy going. Note that we pass empty cabinet filenames
    // because we've already opened the files.
    //
    b = FDICopy(FdiContext,"","",0,SpdNotifyFunction,NULL,NULL);

    return(b ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}


NTSTATUS
SpdDecompressCabinet(
    IN PVOID            SourceBaseAddress,
    IN ULONG            SourceFileSize,
    IN PWSTR            DestinationPath,
    IN PEXPAND_CALLBACK Callback,
    IN PVOID            CallbackContext
    )
{
    BOOL b;
    EXPAND_CAB_CONTEXT NotifyContext;

    ASSERT(FdiContext);

    //
    // Save away globals for later use.
    //
    pSpdInitGlobals(SourceBaseAddress,SourceFileSize);

    CurrentTargetFile.Signature = TARGET_FILE_SIGNATURE;
    CurrentTargetFile.u.Handle = INVALID_HANDLE_VALUE;

    //
    // Tunnel expand context info into SpdNotifyFunctionCabinet
    //
    NotifyContext.Callback = Callback;
    NotifyContext.CallbackContext = CallbackContext;
    NotifyContext.DestinationPath = DestinationPath;

    //
    // Get the copy going. Note that we pass empty cabinet filenames
    // because we've already opened the files.
    //
    b = FDICopy(FdiContext,"","",0,SpdNotifyFunctionCabinet,NULL,&NotifyContext);

    if ( CurrentTargetFile.u.Handle != INVALID_HANDLE_VALUE ) {

        //
        //  FDI had some error, so we need to close & destroy the target
        //  file-in-progress.  Note that FDI calls it's FDIClose callback
        //  but in our implementation, that has no effect on the target
        //  file.
        //

        FILE_DISPOSITION_INFORMATION FileDispositionDetails;
        IO_STATUS_BLOCK IoStatusBlock;

        FileDispositionDetails.DeleteFile = TRUE;

        ZwSetInformationFile( CurrentTargetFile.u.Handle,
                              &IoStatusBlock,
                              &FileDispositionDetails,
                              sizeof(FileDispositionDetails),
                              FileDispositionInformation );

        ZwClose( CurrentTargetFile.u.Handle );

        b = FALSE;  // make sure we report failure
    }

    return(b ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}


NTSTATUS
SpdDecompressFileFromDriverCab(
    IN PWSTR SourceFileName,
    IN PVOID  SourceBaseAddress,
    IN ULONG  SourceFileSize,
    IN HANDLE DestinationHandle,
    OUT PUSHORT pDate,
    OUT PUSHORT pTime
    )
{
    BOOL b;

    ASSERT(FdiContext);
    ASSERT(DriverContext.FileName == NULL);
    ASSERT(DriverContext.FileNameA == NULL);

    //
    // Save away globals for later use.
    //
    pSpdInitGlobals(SourceBaseAddress,SourceFileSize);

    CurrentTargetFile.Signature = TARGET_FILE_SIGNATURE;
    CurrentTargetFile.u.Handle = DestinationHandle;
    DriverContext.FileName = SpDupStringW(SourceFileName);

    if (!DriverContext.FileName) {
        return(STATUS_NO_MEMORY);
    }

    DriverContext.FileNameA = SpToOem((PWSTR)DriverContext.FileName);

    //
    // Get the copy going. Note that we pass empty cabinet filenames
    // because we've already opened the files.
    //
    b = FDICopy(FdiContext,"","",0,SpdNotifyFunctionDriverCab,NULL,NULL);

    ASSERT(DriverContext.FileName != NULL);
    SpMemFree( (PWSTR)DriverContext.FileName );
    DriverContext.FileName = NULL;

    if (DriverContext.FileNameA) {
        SpMemFree( (PSTR)DriverContext.FileNameA );
        DriverContext.FileNameA = NULL;
    }

    *pDate = DriverContext.FileDate;
    *pTime = DriverContext.FileTime;


    return(b ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}



INT_PTR
DIAMONDAPI
SpdNotifyFunction(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Parameters
    )
{
    switch(Operation) {

    case fdintCABINET_INFO:
    case fdintNEXT_CABINET:
    case fdintPARTIAL_FILE:

        //
        // Cabinet management functions which we don't use.
        // Return success.
        //
        return(0);

    case fdintCOPY_FILE:

        //
        // Diamond is asking us whether we want to copy the file.
        // We need to return a file handle to indicate that we do.
        //
        return((INT_PTR)&CurrentTargetFile);

    case fdintCLOSE_FILE_INFO:

        //
        // Diamond is done with the target file and wants us to close it.
        // (ie, this is the counterpart to fdint_COPY_FILE).
        // We manage our own file i/o so ignore this.
        //
        return(TRUE);
    }

    return 0;
}


INT_PTR
DIAMONDAPI
SpdNotifyFunctionCabinet(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Parameters
    )
{
    EXPAND_CAB_CONTEXT * Context = (EXPAND_CAB_CONTEXT *) Parameters->pv;
    NTSTATUS Status;
    ULONG FileNameLength;
    ULONG Disposition;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    union {
        FILE_BASIC_INFORMATION       FileBasicDetails;
        FILE_RENAME_INFORMATION      FileRenameDetails;
        FILE_DISPOSITION_INFORMATION FileDispositionDetails;
        WCHAR                        PathName[CB_MAX_FILENAME * 2];
    } U;
    HANDLE TempHandle;

    //
    // These values are retained between fdintCOPY_FILE and fdintCLOSE_FILE_INFO
    //
    static WCHAR FileName[CB_MAX_FILENAME];
    static LARGE_INTEGER FileSize;
    static LARGE_INTEGER FileTime;
    static ULONG FileAttributes;


    switch ( Operation ) {

    case fdintCOPY_FILE:

        //
        // Diamond is asking us whether we want to copy the file.
        // Convert everything we're given to the form needed to
        // call the client back to ask it about this file.
        // We need to return a file handle to indicate that we do.
        //

        Status = RtlMultiByteToUnicodeN (
            FileName,
            sizeof(FileName),
            &FileNameLength,
            Parameters->psz1,
            strlen(Parameters->psz1)
            );

        if (!NT_SUCCESS(Status)) {
            //
            // failed to translate, ignore file
            //
            return(-1);
        }

        FileName[ FileNameLength / sizeof(WCHAR) ] = L'\0';

        FileSize.LowPart = Parameters->cb;
        FileSize.HighPart = 0;

        SpTimeFromDosTime( Parameters->date,
                           Parameters->time,
                           &FileTime );

        FileAttributes = Parameters->attribs &
                                (FILE_ATTRIBUTE_ARCHIVE  |
                                 FILE_ATTRIBUTE_READONLY |
                                 FILE_ATTRIBUTE_HIDDEN   |
                                 FILE_ATTRIBUTE_SYSTEM);

        Disposition = Context->Callback( EXPAND_COPY_FILE,
                                         FileName,
                                         &FileSize,
                                         &FileTime,
                                         FileAttributes,
                                         Context->CallbackContext);

        if ( Disposition == EXPAND_ABORT ) {
            return(-1);     // tell FDI to abort
        } else if ( Disposition != EXPAND_COPY_THIS_FILE ) {
            return(0);      // tell FDI to skip this file
        }

        //
        // see if target file already exists
        //
        wcscpy( U.PathName, Context->DestinationPath );
        SpConcatenatePaths( U.PathName, FileName );

        INIT_OBJA( &Obja, &UnicodeString, U.PathName );

        Status = ZwCreateFile( &TempHandle,
                               FILE_GENERIC_READ,
                               &Obja,
                               &IoStatusBlock,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               0,                       // no sharing
                               FILE_OPEN,               // fail if not existing
                               FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY,
                               NULL,
                               0
                               );

        if ( NT_SUCCESS(Status) ) {

            //
            // Target file already exists.  Check for over-write.
            //
            Status = ZwQueryInformationFile( TempHandle,
                                             &IoStatusBlock,
                                             &U.FileBasicDetails,
                                             sizeof(FILE_BASIC_INFORMATION),
                                             FileBasicInformation );

            ZwClose( TempHandle );

            if ( NT_SUCCESS(Status) &&
               ( U.FileBasicDetails.FileAttributes & FILE_ATTRIBUTE_READONLY )) {

                //
                // target file is read-only: report error
                //
                Disposition = Context->Callback( EXPAND_NOTIFY_CREATE_FAILED,
                                                 FileName,
                                                 &FileSize,
                                                 &FileTime,
                                                 FileAttributes,
                                                 Context->CallbackContext);

                if ( Disposition != EXPAND_CONTINUE ) {
                    return(-1); // tell FDI to abort
                }

                return (0); // tell FDI to just skip this target file
            }

            //
            // ask client about overwrite
            //
            Disposition = Context->Callback( EXPAND_QUERY_OVERWRITE,
                                             FileName,
                                             &FileSize,
                                             &FileTime,
                                             FileAttributes,
                                             Context->CallbackContext);

            if ( Disposition == EXPAND_ABORT ) {
                return(-1); // tell FDI to abort
            } else if ( Disposition != EXPAND_COPY_THIS_FILE ) {
                return(0);  // tell FDI to skip this file
            }
        }       // end if target file already exists

        //
        // create temporary target file
        //
        wcscpy( U.PathName, Context->DestinationPath );
        SpConcatenatePaths( U.PathName, L"$$TEMP$$.~~~" );

        //
        // see if target file exists
        //
        INIT_OBJA( &Obja, &UnicodeString, U.PathName );

        Status = ZwCreateFile( &CurrentTargetFile.u.Handle,
                               FILE_GENERIC_WRITE,
                               &Obja,
                               &IoStatusBlock,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               0,                       // no sharing
                               FILE_OVERWRITE_IF,       // allow overwrite
                               FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY,
                               NULL,
                               0
                               );

        if ( !NT_SUCCESS(Status) ) {

            //
            // advise client we can't create this file
            //
            Disposition = Context->Callback( EXPAND_NOTIFY_CREATE_FAILED,
                                             FileName,
                                             &FileSize,
                                             &FileTime,
                                             FileAttributes,
                                             Context->CallbackContext);

            if ( Disposition != EXPAND_CONTINUE ) {
                return(-1); // tell FDI to abort
            }

            return (0); // tell FDI to just skip this target file
        }

        //
        // target file created: give the handle to FDI to expand
        //

        return( (INT_PTR) &CurrentTargetFile );     // target "handle"

    case fdintCLOSE_FILE_INFO:

        //
        // Diamond is done with the target file and wants us to close it.
        //

        ASSERT( CurrentTargetFile.Signature == TARGET_FILE_SIGNATURE );
        ASSERT( CurrentTargetFile.u.Handle != INVALID_HANDLE_VALUE );

        if (( CurrentTargetFile.Signature == TARGET_FILE_SIGNATURE ) &&
            ( CurrentTargetFile.u.Handle != INVALID_HANDLE_VALUE )) {

            //
            // set target file's true name (overwriting old file)
            //
            U.FileRenameDetails.ReplaceIfExists = TRUE;
            U.FileRenameDetails.RootDirectory = NULL;
            U.FileRenameDetails.FileNameLength = wcslen( FileName ) * sizeof(WCHAR);
            wcscpy( U.FileRenameDetails.FileName, FileName );

            Status = ZwSetInformationFile( CurrentTargetFile.u.Handle,
                                           &IoStatusBlock,
                                           &U.FileRenameDetails,
                                           sizeof(U.FileRenameDetails) +
                                               U.FileRenameDetails.FileNameLength,
                                           FileRenameInformation );

            if ( !NT_SUCCESS(Status) ) {

                //
                // Unable to change temp name to true name.  Change to delete
                // on close, close it, and tell the user it didn't work.
                //

                U.FileDispositionDetails.DeleteFile = TRUE;

                ZwSetInformationFile( CurrentTargetFile.u.Handle,
                                      &IoStatusBlock,
                                      &U.FileDispositionDetails,
                                      sizeof(U.FileDispositionDetails),
                                      FileDispositionInformation );

                ZwClose( CurrentTargetFile.u.Handle );

                CurrentTargetFile.u.Handle = INVALID_HANDLE_VALUE;

                Disposition = Context->Callback( EXPAND_NOTIFY_CREATE_FAILED,
                                                 FileName,
                                                 &FileSize,
                                                 &FileTime,
                                                 FileAttributes,
                                                 Context->CallbackContext);

                if ( Disposition != EXPAND_CONTINUE ) {
                    return(-1); // tell FDI to abort
                }

                return (TRUE);  // keep FDI going
            }

            //
            // try to set file's last-modifed time
            //
            Status = ZwQueryInformationFile( CurrentTargetFile.u.Handle,
                                             &IoStatusBlock,
                                             &U.FileBasicDetails,
                                             sizeof(U.FileBasicDetails),
                                             FileBasicInformation );

            if (NT_SUCCESS(Status) ) {

                U.FileBasicDetails.LastWriteTime = FileTime;

                ZwSetInformationFile( CurrentTargetFile.u.Handle,
                                      &IoStatusBlock,
                                      &U.FileBasicDetails,
                                      sizeof(U.FileBasicDetails),
                                      FileBasicInformation );
            }

            //
            // Note that we did not put any attributes on this file.
            // The client callback code may do that if it so desires.
            //

            ZwClose( CurrentTargetFile.u.Handle );

            CurrentTargetFile.u.Handle = INVALID_HANDLE_VALUE;

            //
            // Tell client it has been done
            //
            Disposition = Context->Callback( EXPAND_COPIED_FILE,
                                             FileName,
                                             &FileSize,
                                             &FileTime,
                                             FileAttributes,
                                             Context->CallbackContext);

            if ( Disposition == EXPAND_ABORT ) {

                return(-1); // tell FDI to abort now
            }
        }

        return(TRUE);
        break;

    default:
        //
        // Cabinet management functions which we don't use.
        // Return success.
        //
        return 0;
    }
}


INT_PTR
DIAMONDAPI
SpdNotifyFunctionDriverCab(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Parameters
    )
{
    BOOLEAN extract;
    PWSTR CabNameW;
    ULONG Size;
    ULONG StringSize;
    NTSTATUS Status;

    switch(Operation) {

    case fdintCABINET_INFO:
    case fdintNEXT_CABINET:
    case fdintPARTIAL_FILE:

        //
        // Cabinet management functions which we don't use.
        // Return success.
        //
        return(0);

    case fdintCOPY_FILE:

        //
        // Diamond is asking us whether we want to copy the file.
        // We need to return a file handle to indicate that we do.
        //

        //
        // diamond is an ansi API -- we need to convert to unicode string
        //

        extract = FALSE;
        if (DriverContext.FileNameA) {
          if (_stricmp(DriverContext.FileNameA, Parameters->psz1) == 0) {
            extract = TRUE;
          }
        } else {

            StringSize = strlen(Parameters->psz1);
            CabNameW = SpMemAlloc ((StringSize+1) * sizeof(WCHAR));
            if (!CabNameW) {
                //
                // we're out of memory, abort
                //
                return(-1);
            }

            Status = RtlMultiByteToUnicodeN (
                CabNameW,
                StringSize * sizeof(WCHAR),
                &Size,
                Parameters->psz1,
                StringSize
                );

            if (!NT_SUCCESS(Status)) {
                //
                // failed to translate, abort
                //
                SpMemFree(CabNameW);
                return(-1);
            }

            extract = FALSE;

            //
            // null terminate
            //
            CabNameW[StringSize] = 0;
            if (_wcsicmp(DriverContext.FileName, CabNameW) == 0) {
                extract = TRUE;
            }

            SpMemFree( CabNameW );
        }

        if (extract) {
            return((INT_PTR)&CurrentTargetFile);
        } else {
            return (INT_PTR)NULL;
        }

    case fdintCLOSE_FILE_INFO:

        //
        // Diamond is done with the target file and wants us to close it.
        // (ie, this is the counterpart to fdint_COPY_FILE).
        // We manage our own file i/o so ignore this
        // (first we grab the file date and time)
        //
        DriverContext.FileDate = Parameters->date;
        DriverContext.FileTime = Parameters->time;
        return(TRUE);
    }

    return 0;
}



PVOID
DIAMONDAPI
SpdFdiAlloc(
    IN ULONG NumberOfBytes
    )

/*++

Routine Description:

    Callback used by FDICopy to allocate memory.

Arguments:

    NumberOfBytes - supplies desired size of block.

Return Value:

    Returns pointer to a block of cache-aligned memory.
    Does not return if memory cannot be allocated.

--*/

{
    PVOID p;

    p = ExAllocatePoolWithTag(PagedPoolCacheAligned,NumberOfBytes,SETUP_FDI_POOL_TAG);

    if(!p) {
        SpOutOfMemory();
    }

    return(p);
}


VOID
DIAMONDAPI
SpdFdiFree(
    IN PVOID Block
    )

/*++

Routine Description:

    Callback used by FDICopy to free a memory block.
    The block must have been allocated with SpdFdiAlloc().

Arguments:

    Block - supplies pointer to block of memory to be freed.

Return Value:

    None.

--*/

{
    ExFreePool(Block);
}


INT_PTR
DIAMONDAPI
SpdFdiOpen(
    IN PSTR FileName,
    IN int  oflag,
    IN int  pmode
    )

/*++

Routine Description:

    Callback used by FDICopy to open files.

    In our implementation, the source and target files are already opened
    by the time we can get to this point so we don'tt ever actually open
    anything here.

    However diamond may 'open' the source file more than once because it
    wants 2 different states.  We support that here by using our own
    'handles' with special meaning to us.

Arguments:

    FileName - supplies name of file to be opened. Ignored.

    oflag - supplies flags for open. Ignored.

    pmode - supplies additional flags for open. Ignored.

Return Value:



--*/

{
    PMY_FILE_STATE State;

    UNREFERENCED_PARAMETER(FileName);
    UNREFERENCED_PARAMETER(oflag);
    UNREFERENCED_PARAMETER(pmode);

    //
    // Note: we only support opening the source (cabinet) file, which we
    // carefully pass in to FDICopy() as the empty string.
    //
    ASSERT(*FileName == 0);
    if(*FileName) {
        return(-1);
    }

    State = SpMemAlloc(sizeof(MY_FILE_STATE));

    State->u.FileOffset = 0;
    State->Signature = SOURCE_FILE_SIGNATURE;

    return((INT_PTR)State);
}


UINT
DIAMONDAPI
SpdFdiRead(
    IN  INT_PTR Handle,
    OUT PVOID pv,
    IN  UINT  ByteCount
    )

/*++

Routine Description:

    Callback used by FDICopy to read from a file.

    We assume that diamond is going to read only from the cabinet file.

Arguments:

    Handle - supplies handle to open file to be read from.

    pv - supplies pointer to buffer to receive bytes we read.

    ByteCount - supplies number of bytes to read.

Return Value:

    Number of bytes read or -1 if an error occurs.

--*/

{
    UINT rc;
    PMY_FILE_STATE State;
    LONG RealByteCount;

    State = (PMY_FILE_STATE)Handle;

    //
    // Assume failure.
    //
    rc = (UINT)(-1);

    //
    // Only read the source with this routine.
    //
    ASSERT(State->Signature == SOURCE_FILE_SIGNATURE);
    if(State->Signature == SOURCE_FILE_SIGNATURE) {

        RealByteCount = (LONG)ByteCount;
        if(State->u.FileOffset + RealByteCount > (LONG)SpdSourceFileSize) {
            RealByteCount = (LONG)SpdSourceFileSize - State->u.FileOffset;
        }
        if(RealByteCount < 0) {
            RealByteCount = 0;
        }

        try {

            RtlCopyMemory(
                pv,
                SpdSourceAddress + State->u.FileOffset,
                (ULONG)RealByteCount
                );

            State->u.FileOffset += RealByteCount;

            rc = RealByteCount;

        } except(EXCEPTION_EXECUTE_HANDLER) {
            ;
        }
    }

    return(rc);
}


UINT
DIAMONDAPI
SpdFdiWrite(
    IN INT_PTR Handle,
    IN PVOID pv,
    IN UINT  ByteCount
    )

/*++

Routine Description:

    Callback used by FDICopy to write to a file.

    We assume that diamond is going to write only to the target file.

Arguments:

    Handle - supplies handle to open file to be written to.

    pv - supplies pointer to buffer containing bytes to write.

    ByteCount - supplies number of bytes to write.

Return Value:

    Number of bytes written (ByteCount) or -1 if an error occurs.

--*/

{
    UINT rc;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    PMY_FILE_STATE State;

    State = (PMY_FILE_STATE)Handle;

    //
    // Assume failure.
    //
    rc = (UINT)(-1);

    //
    // Only write the target with this routine.
    //
    ASSERT(State->Signature == TARGET_FILE_SIGNATURE);
    if(State->Signature == TARGET_FILE_SIGNATURE) {

        Status = ZwWriteFile(
                    (HANDLE)State->u.Handle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    pv,
                    ByteCount,
                    NULL,
                    NULL
                    );

        if(NT_SUCCESS(Status)) {
            rc = ByteCount;
        } else {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpdFdiWrite: Status %lx writing to target file\n",Status));
        }
    }

    return(rc);
}


int
DIAMONDAPI
SpdFdiClose(
    IN INT_PTR Handle
    )

/*++

Routine Description:

    Callback used by FDICopy to close files.

    In our implementation, the source and target files are managed
    elsewhere so we don't actually need to close any files.
    However we may need to free some state information.

Arguments:

    Handle - handle of file to close.

Return Value:

    0 (success).

--*/

{
    PMY_FILE_STATE State = (PMY_FILE_STATE)Handle;

    //
    // Only 'close' the source file.
    //
    if(State->Signature == SOURCE_FILE_SIGNATURE) {
        SpMemFree(State);
    }

    return(0);
}


LONG
DIAMONDAPI
SpdFdiSeek(
    IN INT_PTR  Handle,
    IN long Distance,
    IN int  SeekType
    )

/*++

Routine Description:

    Callback used by FDICopy to seek files.

    We assume that we can seek only in the source file.

Arguments:

    Handle - handle of file to close.

    Distance - supplies distance to seek. Interpretation of this
        parameter depends on the value of SeekType.

    SeekType - supplies a value indicating how Distance is to be
        interpreted; one of SEEK_SET, SEEK_CUR, SEEK_END.

Return Value:

    New file offset.

--*/

{
    PMY_FILE_STATE State = (PMY_FILE_STATE)Handle;
    LONG rc;

    //
    // Assume failure.
    //
    rc = -1L;

    //
    // Only allow seeking in the source.
    //
    ASSERT(State->Signature == SOURCE_FILE_SIGNATURE);

    if(State->Signature == SOURCE_FILE_SIGNATURE) {

        switch(SeekType) {

        case SEEK_CUR:

            //
            // Distance is an offset from the current file position.
            //
            State->u.FileOffset += Distance;
            break;

        case SEEK_END:

            //
            // Distance is an offset from the end of file.
            //
            State->u.FileOffset = SpdSourceFileSize - Distance;
            break;

        case SEEK_SET:

            //
            // Distance is the new absolute offset.
            //
            State->u.FileOffset = (ULONG)Distance;
            break;
        }

        if(State->u.FileOffset < 0) {
            State->u.FileOffset = 0;
        }

        if(State->u.FileOffset > (LONG)SpdSourceFileSize) {
            State->u.FileOffset = SpdSourceFileSize;
        }

        //
        // Return successful status.
        //
        rc = State->u.FileOffset;
    }

    return(rc);
}


VOID
SpdInitialize(
    VOID
    )
{
    FdiContext = FDICreate(
                    SpdFdiAlloc,
                    SpdFdiFree,
                    SpdFdiOpen,
                    SpdFdiRead,
                    SpdFdiWrite,
                    SpdFdiClose,
                    SpdFdiSeek,
                    cpuUNKNOWN,
                    &FdiError
                    );

    if(FdiContext == NULL) {
        SpOutOfMemory();
    }

    RtlZeroMemory(&DriverContext, sizeof(DriverContext) );

}


VOID
SpdTerminate(
    VOID
    )
{
    FDIDestroy(FdiContext);

    FdiContext = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\graphics.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    graphics.c

Abstract:

    Bitmap display support with text mode for
    upgrade. This file has implementation for the
    three core abstractions i.e. Bitmap,
    Animated bitmap and Graphics Progress bar.

    In upgrade graphics mode, we have one primary
    graphics thread running in the foreground.
    This thread paints the background, creates
    animated bitmap(s) and updates a single
    progress bar. An upgrade specific callback
    is registered which calculates the overall
    progress.

    Although we are in graphics mode during upgrade,
    all the regular textmode output is still
    written to a buffer. When we hit some error
    or require user intervention we switch back
    to the actual textmode and copy all the cached
    information to actual video memory. One can
    switch to textmode from graphics but not
    vice-versa.

    Note : For each animated bitmap a separate
    thread is started while animating. Using lot
    of animated bitmaps can slow down the actual
    text mode setup thread.

Author:

    Vijay Jayaseelan (vijayj)  01 July 2000

Revision History:

    None

--*/

#include "spprecmp.h"
#include "ntddser.h"
#include "bootvid.h"
#include "resource.h"
#include <hdlsblk.h>
#include <hdlsterm.h>
#pragma hdrstop

////////////////////////////////////////////////////////////////
//
// Global data
//
////////////////////////////////////////////////////////////////

//
// The primary upgrade graphics thread handle
//
HANDLE  GraphicsThreadHandle = NULL;

//
// Variable which indicates that upgrade graphics
// thread needs to be stopped or not
//
BOOLEAN     StopGraphicsThread = FALSE;
KSPIN_LOCK  GraphicsThreadLock;

//
// Upgrade graphics overall progress indication
//
ULONG       ProgressPercentage = 0;
KSPIN_LOCK  ProgressLock;

//
// For synchronizing access to VGA memory
//
BOOLEAN     InVgaDisplay = FALSE;
KSPIN_LOCK  VgaDisplayLock;


////////////////////////////////////////////////////////////////
//
// Atomic operations to stop main graphics thread
//
////////////////////////////////////////////////////////////////

static
__inline
BOOLEAN
UpgradeGraphicsThreadGetStop(
    VOID
    )
/*++

Routine Description:

    Finds out whether the primary upgrade graphics thread
    needs to be stopped

Arguments:

    None.

Return Value:

    TRUE or FALSE

--*/
{
    KIRQL   OldIrql;
    BOOLEAN Result;

    KeAcquireSpinLock(&GraphicsThreadLock, &OldIrql);

    Result = StopGraphicsThread;

    KeReleaseSpinLock(&GraphicsThreadLock, OldIrql);

    return Result;
}

static
VOID
__inline
UpgradeGraphicsThreadSetStop(
    BOOLEAN Stop
    )
/*++

Routine Description:

    Sets the global synchronized state, indicating
    whether to stop the primary graphics thread.

    Note : Once the thread is stopped, it can be
    restarted.

Arguments:

    Stop : Indicates whether to stop the primary graphics
           thread or not i.e. TRUE or FALSE

Return Value:

    None.

--*/
{
    KIRQL   OldIrql;

    KeAcquireSpinLock(&GraphicsThreadLock, &OldIrql);

    StopGraphicsThread = Stop;

    KeReleaseSpinLock(&GraphicsThreadLock, OldIrql);
}


////////////////////////////////////////////////////////////////
//
// Atomic progress bar percentage routines
//
////////////////////////////////////////////////////////////////

static
__inline
ULONG
GetSetupProgress(
    VOID
    )
/*++

Routine Description:

    Gets the overall progress, in terms of percentage,
    for the textmode setup. Since multiple threads
    are touching the shared overall progress ULONG
    its protected.

Arguments:

    None.

Return Value:

    The overall progress

--*/
{
    ULONG   PercentageFill;
    KIRQL   OldIrql;

    KeAcquireSpinLock(&ProgressLock, &OldIrql);

    PercentageFill = ProgressPercentage;

    KeReleaseSpinLock(&ProgressLock, OldIrql);

    return PercentageFill;
}

static
__inline
VOID
SetSetupProgress(
    ULONG   Fill
    )
/*++

Routine Description:

    Sets the overall progress, in terms of percentage
    for the textmode setup. Since multiple threads
    are touching the shared overall progress ULONG
    its protected.

Arguments:

    Fill : The new percentage to set.

Return Value:

    None.

--*/
{
    KIRQL   OldIrql;

    KeAcquireSpinLock(&ProgressLock, &OldIrql);

    ProgressPercentage = Fill;

    KeReleaseSpinLock(&ProgressLock, OldIrql);
}

////////////////////////////////////////////////////////////////
//
// Graphics progress bar methods
//
////////////////////////////////////////////////////////////////

TM_GRAPHICS_PRGBAR_HANDLE
TextmodeGraphicsProgBarCreate(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG Length,
    IN ULONG Height,
    IN ULONG ForegroundColor,
    IN ULONG BackgroundColor,
    IN ULONG InitialFill
    )
/*++

Routine Description:

    Creates a graphics progress bar object, with the
    specified attributes.

    Note : This graphics progress bar will use solid
    fill using the current palette, while updating
    progress i.e. drawing background and foreground.

Arguments:

    X - Top left X coordinate

    Y - Top left Y coordinate

    Length - Length of the progress bar in pixels

    Heigth - Height of the progress bar in pixels

    ForegroundColor - Index in palette, indicating
                      foreground color

    BackgroundColor - Index in palette, indicating
                      background color

    IntialFill - Initial percentage that needs to
                 be filled

Return Value:

    Handle to the graphics progress bar object,
    if successful otherwise NULL

--*/
{
    TM_GRAPHICS_PRGBAR_HANDLE hPrgBar = NULL;

    if (Length > Height) {
        hPrgBar = (TM_GRAPHICS_PRGBAR_HANDLE)
                    SpMemAlloc(sizeof(TM_GRAPHICS_PRGBAR));

        if (hPrgBar) {
            RtlZeroMemory(hPrgBar, sizeof(TM_GRAPHICS_PRGBAR));

            hPrgBar->X = X;
            hPrgBar->Y = Y;
            hPrgBar->Length = Length;
            hPrgBar->Height = Height;
            hPrgBar->Fill = InitialFill;
            hPrgBar->ForegroundColor = ForegroundColor;
            hPrgBar->BackgroundColor = BackgroundColor;
        }
    }

    return hPrgBar;
}

TM_GRAPHICS_PRGBAR_HANDLE
TextmodeGraphicsProgBarCreateUsingBmps(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG Length,
    IN ULONG Height,
    IN ULONG BackgroundId,
    IN ULONG ForegroundId,
    IN ULONG InitialFill
    )
/*++

Routine Description:

    Creates a graphics progress bar object, with the
    specified attributes.

    Note : This graphics progress bar will use the
    given bitmaps to update the background and foreground.
    Both background and foreground bitmap are assumed
    to be 1 pixel wide. Background bitmap's height is
    assumed to be "Height" pixels where as foreground
    bitmap's height is assumed be to "Height - 2" pixels.

Arguments:

    X - Top left X coordinate

    Y - Top left Y coordinate

    Length - Length of the progress bar in pixels

    Heigth - Height of the bakground bitmap, in pixels

    BackgroundId - Background bitmap resource ID

    ForegroundId - Foreground bitmap resource ID

    IntialFill - Initial percentage that needs to
                 be filled

    Note : Its assumed that the foreground and background
    bitmaps are in 4bpp i.e. 16 colors format.

Return Value:

    Handle to the graphics progress bar object,
    if successful otherwise NULL

--*/
{
    TM_GRAPHICS_PRGBAR_HANDLE  hPrgBar = NULL;
    TM_BITMAP_HANDLE            hBackground = TextmodeBitmapCreate(BackgroundId);
    TM_BITMAP_HANDLE            hForeground = TextmodeBitmapCreate(ForegroundId);

    if (!hBackground && hForeground) {
        TextmodeBitmapDelete(hForeground);
    }

    if (!hForeground&& hBackground) {
        TextmodeBitmapDelete(hBackground);
    }

    if (hForeground && hBackground) {
        hPrgBar = TextmodeGraphicsProgBarCreate(X,
                        Y,
                        Length,
                        Height,
                        0,
                        0,
                        InitialFill);

        if (hPrgBar) {
            hPrgBar->Background = hBackground;
            hPrgBar->Foreground = hForeground;
        } else {
            TextmodeBitmapDelete(hForeground);
            TextmodeBitmapDelete(hBackground);
        }
    }

    return hPrgBar;
}


NTSTATUS
TextmodeGraphicsProgBarDelete(
    IN TM_GRAPHICS_PRGBAR_HANDLE hPrgBar
    )
/*++

Routine Description:

    Deletes the graphics progress bar object. Frees
    up an any allocated resources.

Arguments:

    hPrgBar - Handle to the graphics progress bar object

Return Value:

    STATUS_SUCCESS, if successful otherwise appropriate
    error code.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (hPrgBar) {
        SpMemFree(hPrgBar);
        Status = STATUS_SUCCESS;
    }

    return Status;
}

NTSTATUS
TextmodeGraphicsProgBarRefresh(
    IN TM_GRAPHICS_PRGBAR_HANDLE hPrgBar,
    IN BOOLEAN UpdateBackground
    )
/*++

Routine Description:

    Repaints the graphics progress bar

Arguments:

    hPrgBar - Handle to the graphics progress bar object

    UpgradeBackground - Indicates whether the background
                        also needs to be repainted or not.

Return Value:

    STATUS_SUCCESS, if successful, otherwise appropriate
    error code

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (hPrgBar) {
        ULONG   FillLength = hPrgBar->Fill * (hPrgBar->Length - 2) / 100;

        if (hPrgBar->Background && hPrgBar->Foreground) {
            //
            // Bitmapped progress bar
            //
            ULONG Index;

            if (UpdateBackground) {
                for (Index=0; Index < hPrgBar->Length; Index++) {
                    TextmodeBitmapDisplay(hPrgBar->Background,
                        hPrgBar->X + Index,
                        hPrgBar->Y);
                }
            }

            if (FillLength) {
                ULONG   Count = FillLength;

                for (Index=1; Index <= Count; Index++) {
                    TextmodeBitmapDisplay(hPrgBar->Foreground,
                        hPrgBar->X + Index,
                        hPrgBar->Y + 1);
                }
            }
        } else {
            //
            // Solid fill progress bar
            //
            if (UpdateBackground) {
                VgaGraphicsSolidColorFill(hPrgBar->X, hPrgBar->Y,
                    hPrgBar->X + hPrgBar->Length, hPrgBar->Y + hPrgBar->Height,
                    hPrgBar->BackgroundColor);
            }

            if (FillLength)  {
                VgaGraphicsSolidColorFill(hPrgBar->X + 1, hPrgBar->Y + 1,
                    hPrgBar->X + FillLength, hPrgBar->Y + hPrgBar->Height - 1,
                    hPrgBar->ForegroundColor);
            }
        }

        Status = STATUS_SUCCESS;
    }

    return Status;
}

NTSTATUS
TextmodeGraphicsProgBarUpdate(
    IN TM_GRAPHICS_PRGBAR_HANDLE hPrgBar,
    IN ULONG Fill
    )
/*++

Routine Description:

    Updates the progress bar fill percentage, and repaints
    if needed.

    Note : The percentage can be increasing or decreasing
    w.r.t to previous fill percentage

Arguments:

    hPrgBar - Handle to the graphics progress bar object

    Fill - The new fill percentage.

Return Value:

    STATUS_SUCCESS, if successful, otherwise appropriate
    error code

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (Fill > 100) {
        Fill = 100;
    }

    if (hPrgBar && (hPrgBar->Fill != Fill)) {
        //
        // Note : Make sure we leave one pixel at the start and end
        // in the background to emulate a bounding rectangle
        // around the current fill
        //
        ULONG OldFillLength = hPrgBar->Fill * (hPrgBar->Length - 2) / 100;
        ULONG NewFillLength = Fill * (hPrgBar->Length - 2) / 100;
        ULONG Index;

        if (OldFillLength != NewFillLength) {
            if (OldFillLength < NewFillLength) {
                //
                // increasing
                //
                if (hPrgBar->Foreground && hPrgBar->Background) {
                    for (Index = OldFillLength; Index < NewFillLength; Index++) {
                        TextmodeBitmapDisplay(hPrgBar->Foreground,
                            hPrgBar->X + Index + 1,
                            hPrgBar->Y + 1);
                    }
                } else {
                    VgaGraphicsSolidColorFill(hPrgBar->X + OldFillLength + 1, hPrgBar->Y + 1,
                        hPrgBar->X + NewFillLength, hPrgBar->Y + hPrgBar->Height - 1,
                        hPrgBar->ForegroundColor);
                }
            } else {
                //
                // decreasing
                //
                if (hPrgBar->Foreground && hPrgBar->Background) {
                    for (Index = NewFillLength; Index <= OldFillLength; Index++) {
                        TextmodeBitmapDisplay(hPrgBar->Background,
                            hPrgBar->X + Index,
                            hPrgBar->Y);
                    }
                } else {
                    VgaGraphicsSolidColorFill(hPrgBar->X + NewFillLength, hPrgBar->Y + 1,
                        hPrgBar->X + OldFillLength, hPrgBar->Y + hPrgBar->Height - 1,
                        hPrgBar->BackgroundColor);
                }
            }

            hPrgBar->Fill = Fill;
        }

        Status = STATUS_SUCCESS;
    }

    return Status;
}

////////////////////////////////////////////////////////////////
//
// Bitmap methods
//
////////////////////////////////////////////////////////////////

TM_BITMAP_HANDLE
TextmodeBitmapCreate(
    IN ULONG BitmapResourceId
    )
/*++

Routine Description:

    Creates a bitmap object using the given resource Id.

    Note : The resource is currently assumed to be present
    in usetup.exe module. The bitmap is assumed to be in
    4bpp or 16 colors format.

Arguments:

    BitmapResourceId - the bitmap resource Id.

Return Value:

    Handle to the new bitmap object, if successful,
    otherwise NULL

--*/
{
    TM_BITMAP_HANDLE    hBitmap = NULL;
    ULONG_PTR           ResourceIdPath[3];
    PUCHAR              Bitmap = NULL;
    NTSTATUS            Status;
    PIMAGE_RESOURCE_DATA_ENTRY ResourceDataEntry = NULL;

    if (BitmapResourceId) {
        ResourceIdPath[0] = 2;
        ResourceIdPath[1] = BitmapResourceId;
        ResourceIdPath[2] = 0;

        Status = LdrFindResource_U(ResourceImageBase,
                        ResourceIdPath,
                        3,
                        &ResourceDataEntry);

        if (NT_SUCCESS(Status)) {
            Status = LdrAccessResource(ResourceImageBase,
                            ResourceDataEntry,
                            &Bitmap,
                            NULL);

            if (NT_SUCCESS(Status)) {
                hBitmap = (TM_BITMAP_HANDLE)SpMemAlloc(sizeof(TM_BITMAP));

                if (hBitmap) {
                    RtlZeroMemory(hBitmap, sizeof(TM_BITMAP));

                    //
                    // All we have and need is actual bitmap data
                    //
                    hBitmap->Data = (PVOID)Bitmap;
                }
            }
        }
    }

    return hBitmap;
}

TM_BITMAP_HANDLE
TextmodeBitmapCreateFromFile(
    IN PWSTR FileName
    )
/*++

Routine Description:

    Creates a bitmap object using the given fully qualified
    NT pathname for the bitmap file.

    Note : The bitmap is assumed to be in 4bpp or 16 color
    format

Arguments:

    FileName - Fully qualified NT pathname for
               the bitmap file

Return Value:

    Handle to the new bitmap object if successful,
    otherwise NULL.

--*/
{
    TM_BITMAP_HANDLE    hBitmap = NULL;
    HANDLE              FileHandle = NULL, SectionHandle = NULL;
    PVOID               ViewBase = NULL;
    ULONG               FileSize = 0;

    if (FileName && *FileName &&
        NT_SUCCESS(SpOpenAndMapFile(FileName,
                                    &FileHandle,
                                    &SectionHandle,
                                    &ViewBase,
                                    &FileSize,
                                    FALSE))) {

        hBitmap = (TM_BITMAP_HANDLE)SpMemAlloc(sizeof(TM_BITMAP));

        if (hBitmap) {
            RtlZeroMemory(hBitmap, sizeof(TM_BITMAP));
            wcscpy(hBitmap->FileName, FileName);
            hBitmap->ViewBase = ViewBase;
            hBitmap->Data = ((PCHAR)ViewBase) + sizeof(BITMAPFILEHEADER);
            hBitmap->FileHandle = FileHandle;
            hBitmap->SectionHandle = SectionHandle;
        }
    }

    return hBitmap;
}

NTSTATUS
TextmodeBitmapDelete(
    IN TM_BITMAP_HANDLE hBitmap
    )
/*++

Routine Description:

    Delete the bitmap object and frees up any allocated
    resources.

Arguments:

    hBitmap - Handle to the bitmap object

Return Value:

    STATUS_SUCCESS, if successful, otherwise appropriate
    error code.

--*/
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    if (hBitmap) {
        if (hBitmap->SectionHandle != NULL) {
            SpUnmapFile(hBitmap->SectionHandle, hBitmap->ViewBase);
        }

        if (hBitmap->FileHandle != NULL) {
            Status = ZwClose(hBitmap->FileHandle);
        } else {
            Status = STATUS_SUCCESS;
        }

        SpMemFree(hBitmap);
    }

    return Status;
}

NTSTATUS
TextmodeBitmapDisplay(
    IN TM_BITMAP_HANDLE hBitmap,
    IN ULONG X,
    IN ULONG Y
    )
/*++

Routine Description:

    Displays the given bitmap at the specified
    coordinates.

Arguments:

    hBitmap - Handle to the bitmap object

    X - Top left X coordinate

    Y - Top left Y coordinate

Return Value:

    STATUS_SUCCESS, if successful, otherwise
    appropriate error code.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;


    if (hBitmap) {
        VgaGraphicsBitBlt(hBitmap->Data, X, Y);
        Status = STATUS_SUCCESS;
    }

    return Status;
}

////////////////////////////////////////////////////////////////
//
// Animated bitmap methods
//
////////////////////////////////////////////////////////////////

__inline
NTSTATUS
TextmodeAnimatedBitmapSetStopAnimating(
    IN TM_ANIMATED_BITMAP_HANDLE hBitmap,
    IN BOOLEAN StopAnimating
    )
/*++

Routine Description:

    Sets the (shared) attribute which indicates
    whether the animation for the animated bitmap
    needs to be stopped or not.

Arguments:

    hBitmap - Handle to the animated bitmap object

    StopAnimating - Whether to stop the animation or not

Return Value:

    STATUS_SUCCESS, if successful, otherwise appropriate
    error code.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (hBitmap) {
        InterlockedExchange(&(hBitmap->StopAnimating), (LONG)StopAnimating);
        Status = STATUS_SUCCESS;
    }

    return Status;
}


__inline
NTSTATUS
TextmodeAnimatedBitmapGetStopAnimating(
    IN TM_ANIMATED_BITMAP_HANDLE hBitmap,
    IN PBOOLEAN StopAnimating
    )
/*++

Routine Description:

    Gets the (shared) attribute which indicates whether the
    animated bitmap is currently being animated or not.

Arguments:

    hBitmap - Handle to the animated bitmap object

    StopAnimating - Place holder for boolean value indicating
                    whether animation is in progress or not.

Return Value:

    STATUS_SUCCESS, if successful, otherwise appropriate
    error code.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (hBitmap && StopAnimating) {
        *StopAnimating = (BOOLEAN)InterlockedExchange(&(hBitmap->StopAnimating),
                                    hBitmap->StopAnimating);
        Status = STATUS_SUCCESS;                                    
    }

    return Status;
}


TM_ANIMATED_BITMAP_HANDLE
TextmodeAnimatedBitmapCreate(
    IN ULONG  *ResourceIds
    )
/*++

Routine Description:

    Creates a animated bitmap, given the list of resource
    ids each bitmaps, in sequence.

    Note : The bitmap format needs to adhere to 4bpp or
           16 colors. The resource is assumed to be
           present in usetup.exe

Arguments:

    ResourceIds - Array of resource ids for the bitmaps
                  to be animated, in sequence. A "0" id
                  indicates the termination for array.

Return Value:

    Handle to the newly created animated bitmap object, if
    successful, otherwise NULL.

--*/
{
    TM_ANIMATED_BITMAP_HANDLE   hAnimatedBitmap = NULL;
    ULONG   Count = 0;
    ULONG   Index;

    if (ResourceIds) {
        for (Index = 0; ResourceIds[Index]; Index++) {
            Count++;
        }
    }

    if (Count) {
        ULONG               BitmapsLoaded = 0;
        TM_BITMAP_HANDLE    hBitmap;

        hAnimatedBitmap = (TM_ANIMATED_BITMAP_HANDLE)
                            SpMemAlloc(sizeof(TM_ANIMATED_BITMAP));

        if (hAnimatedBitmap) {
            RtlZeroMemory(hAnimatedBitmap, sizeof(TM_ANIMATED_BITMAP));

            hAnimatedBitmap->StopAnimating = FALSE;

            for (Index = 0; Index < Count; Index++) {
                hBitmap = TextmodeBitmapCreate(ResourceIds[Index]);

                if (hBitmap) {
                    hAnimatedBitmap->Bitmaps[BitmapsLoaded++] = hBitmap;
                }
            }

            if (!BitmapsLoaded) {
                SpMemFree(hAnimatedBitmap);
                hAnimatedBitmap = NULL;
            } else {
                hAnimatedBitmap->CurrentBitmap = 0; // the first bitmap
            }
        }
    }

    return hAnimatedBitmap;
}


TM_ANIMATED_BITMAP_HANDLE
TextmodeAnimatedBitmapCreateFromFiles(
    IN WCHAR    *FileNames[]
    )
/*++

Routine Description:

    Creates a animated bitmap, given the list of bitmap
    filenames, in sequence.

    Note : The bitmap format needs to adhere to 4bpp or
           16 colors.

Arguments:

    FileNames - Null terminated array of filenames for
                the bitmaps to be animated, in sequence.

Return Value:

    Handle to the newly created animated bitmap object, if
    successful, otherwise NULL.

--*/
{
    TM_ANIMATED_BITMAP_HANDLE   hAnimatedBitmap = NULL;
    ULONG   FileCount = 0;
    ULONG   Index;

    if (FileNames) {
        for (Index = 0; FileNames[Index]; Index++) {
            FileCount++;
        }
    }

    if (FileCount) {
        ULONG               BitmapsLoaded = 0;
        TM_BITMAP_HANDLE    hBitmap;

        hAnimatedBitmap = (TM_ANIMATED_BITMAP_HANDLE)
                            SpMemAlloc(sizeof(TM_ANIMATED_BITMAP));

        if (hAnimatedBitmap) {
            RtlZeroMemory(hAnimatedBitmap, sizeof(TM_ANIMATED_BITMAP));
            hAnimatedBitmap->StopAnimating = FALSE;

            for (Index = 0; Index < FileCount; Index++) {
                hBitmap = TextmodeBitmapCreateFromFile(FileNames[Index]);

                if (hBitmap) {
                    hAnimatedBitmap->Bitmaps[BitmapsLoaded++] = hBitmap;
                }
            }

            if (!BitmapsLoaded) {
                SpMemFree(hAnimatedBitmap);
                hAnimatedBitmap = NULL;
            } else {
                hAnimatedBitmap->CurrentBitmap = 0; // the first bitmap
            }
        }
    }

    return hAnimatedBitmap;
}


NTSTATUS
TextmodeAnimatedBitmapDelete(
    IN TM_ANIMATED_BITMAP_HANDLE hAnimatedBitmap
    )
/*++

Routine Description:

    Delete the given animated bitmap object and frees
    up an resource associated with the object.

    Note : This will stop the animation thread, if
    required.

Arguments:

    hAnimatedBitmap - Handle to the animated bitmap object

Return Value:

    STATUS_SUCCESS, if successful, otherwise appropriate
    error code.

--*/
{
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;

    if (hAnimatedBitmap) {
        ULONG   Index;

        //
        // First, try to terminate the thread
        //
        TextmodeAnimatedBitmapSetStopAnimating(hAnimatedBitmap, TRUE);

        //
        // Wait, till the animator thread stops
        //
        Status = ZwWaitForSingleObject(hAnimatedBitmap->ThreadHandle, FALSE, NULL);

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                "SETUP: DeleteTextmodeAnimatedBitmap() : Wait filed for %lX with %lX\n",
                hAnimatedBitmap->ThreadHandle,
                Status));
        }

        Status = STATUS_SUCCESS;

        //
        // Delete each bitmap
        //
        for (Index=0;
            (hAnimatedBitmap->Bitmaps[Index] && (Index < MAX_ANIMATED_BITMAPS));
            Index++) {

            if (NT_SUCCESS(Status)) {
                Status = TextmodeBitmapDelete(hAnimatedBitmap->Bitmaps[Index]);
            }
        }

        //
        // Free the animated bitmap
        //
        SpMemFree(hAnimatedBitmap);
    }

    return Status;
}

NTSTATUS
TextmodeAnimateBitmapAnimateNext(
    IN TM_ANIMATED_BITMAP_HANDLE hBitmap
    )
/*++

Routine Description:

    Animates rather draws the next bitmap in the sequence.

Arguments:

    hBitmap - Handle to the animated bitmap object

Return Value:

    STATUS_SUCCESS, if successful, otherwise appropriate
    error code.

--*/
{
    TM_BITMAP_HANDLE hCurrBitmap;
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (hBitmap) {
        hCurrBitmap = hBitmap->Bitmaps[hBitmap->CurrentBitmap];
        Status = TextmodeBitmapDisplay( hCurrBitmap, hBitmap->X, hBitmap->Y);

        hBitmap->CurrentBitmap++;

        if ((hBitmap->CurrentBitmap >= MAX_ANIMATED_BITMAPS) ||
            (hBitmap->Bitmaps[hBitmap->CurrentBitmap] == NULL)) {
            hBitmap->CurrentBitmap = 0; // start over again
        }
    }

    return Status;
}

NTSTATUS
TextmodeAnimatedBitmapAnimate(
    IN TM_ANIMATED_BITMAP_HANDLE hBitmap,
    IN ULONG X,
    IN ULONG Y,
    IN ULONG Speed
    )
/*++

Routine Description:

    Starts the animation for the given animated bitmap by
    drawing the bitmaps in sequence at the specified
    coordinates.

    Note : This call would create a separate system
    thread for actually animating the bitmap and would return
    immediately.

Arguments:

    hBitmap - Handle to the animated bitmap object

    X - Top left X coordinate for the animation space

    Y - Top left Y coordinate for the animation space

    Speed - Time interval between changing of bitmaps
            in animation sequence, in milliseconds.

Return Value:

    STATUS_SUCCESS, if successful, otherwise appropriate
    error code.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (hBitmap) {
        hBitmap->FlipTime = Speed;
        hBitmap->X = X;
        hBitmap->Y = Y;

        Status = PsCreateSystemThread(&(hBitmap->ThreadHandle),
                    THREAD_ALL_ACCESS,
                    NULL,
                    NtCurrentProcess(),
                    NULL,
                    TextmodeAnimatedBitmapAnimator,
                    hBitmap);
    }

    return Status;
}

VOID
TextmodeAnimatedBitmapAnimator(
    IN PVOID Context
    )
/*++

Routine Description:

    The worker routine which runs as a separate thread doing
    the actual animation for a animated bitmap.

Arguments:

    Context - Handle to the animated bitmap object type cast
              into PVOID type.

Return Value:

    None.

--*/
{
    LARGE_INTEGER               DelayTime;
    TM_ANIMATED_BITMAP_HANDLE   hBitmap = (TM_ANIMATED_BITMAP_HANDLE)Context;
    TM_BITMAP_HANDLE            hCurrBitmap = NULL;

    if (Context) {
        BOOLEAN     StopAnimating = FALSE;
        NTSTATUS    Status;

        DelayTime.HighPart = -1;                 // relative time
        DelayTime.LowPart = (ULONG)(-10000 * hBitmap->FlipTime);  // secs in 100ns interval

        Status = TextmodeAnimatedBitmapGetStopAnimating(hBitmap, &StopAnimating);

        while (NT_SUCCESS(Status) && !StopAnimating) {
            hCurrBitmap = hBitmap->Bitmaps[hBitmap->CurrentBitmap];
            TextmodeBitmapDisplay(hCurrBitmap, hBitmap->X, hBitmap->Y);
            KeDelayExecutionThread(KernelMode, FALSE, &DelayTime);

            hBitmap->CurrentBitmap++;

            if ((hBitmap->CurrentBitmap >= MAX_ANIMATED_BITMAPS) ||
                (hBitmap->Bitmaps[hBitmap->CurrentBitmap] == NULL)) {
                hBitmap->CurrentBitmap = 0; // start over again
            }

            Status = TextmodeAnimatedBitmapGetStopAnimating(hBitmap, &StopAnimating);
        }
    }

    PsTerminateSystemThread(STATUS_SUCCESS);
}

////////////////////////////////////////////////////////////////
//
//    VGA graphics methods
//
//    Note : VgaXXXX rountines are defined basically
//    to segregate the video memory update routines
//    from the other abstractions. Right now most of
//    these routine delegate the actual work to the
//    real implementation in bootvid.dll, but in
//    future if bootvid.dll goes away, all we need
//    to do is implement this interface.
//    Also note that, these routine synchronize the
//    access, so that only one thread at a time
//    updates the video memory.
//
////////////////////////////////////////////////////////////////

__inline
VOID
VgaDisplayAcquireLock(
    VOID
    )
/*++

Routine Description:

    Acquires the lock to the video memory, so that
    only one thread a time writes to the video memory.

    Note : If the lock is already held by another thread,
    then the calling thread is put to sleep. The calling
    thread wakes up after every 100 millisecond and
    checks for the lock. It falls out of sleep based on
    whether the lock is already held or not.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KIRQL   OldIrql;

    KeAcquireSpinLock(&VgaDisplayLock, &OldIrql);

    while (InVgaDisplay) {
        LARGE_INTEGER   DelayTime;

        DelayTime.HighPart = -1;                 // relative time
        DelayTime.LowPart = (ULONG)(-10000 * 100);  // 100ms interval

        KeReleaseSpinLock(&VgaDisplayLock, OldIrql);
        KeDelayExecutionThread(KernelMode, FALSE, &DelayTime);
        KeAcquireSpinLock(&VgaDisplayLock, &OldIrql);
    }

    InVgaDisplay = TRUE;

    KeReleaseSpinLock(&VgaDisplayLock, OldIrql);
}

__inline
VOID
VgaDisplayReleaseLock(
    VOID
    )
/*++

Routine Description:

    Release the video memory lock which was held.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KIRQL   OldIrql;

    KeAcquireSpinLock(&VgaDisplayLock, &OldIrql);

    InVgaDisplay = FALSE;

    KeReleaseSpinLock(&VgaDisplayLock, OldIrql);
}

NTSTATUS
VgaGraphicsInit(
    PSP_VIDEO_VARS VideoVars
    )
/*++

Routine Description:

    Initializes the video card and switches it into
    640 * 480 * 16 colors mode.


Arguments:

    VideoVars - Pointer to SP_VIDEO_VARS containing
                graphics mode index and handle to the
                display.

Return Value:

    Appropriate NTSTATUS value.

--*/
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    VIDEO_MODE VideoMode;
    
    VgaDisplayAcquireLock();
    
    //
    // Set the desired graphics mode.
    //
    VideoMode.RequestedMode = VideoVars->GraphicsModeInfo.ModeIndex;

    Status = ZwDeviceIoControlFile(VideoVars->hDisplay,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    IOCTL_VIDEO_SET_CURRENT_MODE,
                    &VideoMode,
                    sizeof(VideoMode),
                    NULL,
                    0);

    if(NT_SUCCESS(Status)) {    
        VidInitialize(FALSE);
        VidResetDisplay(FALSE);
    }        

    VgaDisplayReleaseLock();

    return Status;
}

NTSTATUS
VgaGraphicsTerminate(
    PSP_VIDEO_VARS VideoVars
    )
/*++

Routine Description:

    Terminates the 640 * 480 * 16 color mode & switches
    it back to regular text mode. Also clears the display.

Arguments:

    VideoVars - Pointer to SP_VIDEO_VARS containing
                text mode index and handle to the
                display.

Return Value:

    Appropriate NTSTATUS value.

--*/
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    VIDEO_MODE VideoMode;
    
    VgaDisplayAcquireLock();

    VidResetDisplay(FALSE);

    //
    // Switch the adapter to textmode again.
    //
    VideoMode.RequestedMode = VideoVars->VideoModeInfo.ModeIndex;

    Status = ZwDeviceIoControlFile(VideoVars->hDisplay,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    IOCTL_VIDEO_SET_CURRENT_MODE,
                    &VideoMode,
                    sizeof(VideoMode),
                    NULL,
                    0);
   
    VgaDisplayReleaseLock();

    return Status;
}

__inline
VOID
VgaGraphicsSolidColorFill(
    IN ULONG x1,
    IN ULONG y1,
    IN ULONG x2,
    IN ULONG y2,
    IN ULONG Color
    )
/*++

Routine Description:

    Fills the given rectangle with the specified
    color.

Arguments:

    x1 - Top left x coordinate

    y1 - Top left y coordinate

    x2 - Bottom right x coordinate

    y2 - Bottom right y coordinate

    Color - Index into the current palette table
            indicating the color to be filled inside
            the rectangle.

Return Value:

    None.

--*/
{
    VgaDisplayAcquireLock();

    VidSolidColorFill(x1, y1, x2, y2, Color);

    VgaDisplayReleaseLock();
}

__inline
VOID
VgaGraphicsBitBlt(
    IN PUCHAR Buffer,
    IN ULONG x,
    IN ULONG y
    )
/*++

Routine Description:

    BitBlts the given bitmap at the specified
    coordinates.

Arguments:

    Buffer - The actual bitmap date (i.e. starting
             with the color table information)

    x - Top left x coordinate
    y - Top left y coordinate

Return Value:

    None.

--*/
{
    VgaDisplayAcquireLock();

    VidBitBlt(Buffer, x, y);

    VgaDisplayReleaseLock();
}


////////////////////////////////////////////////////////////////
//
// Upgrade graphics routines
//
////////////////////////////////////////////////////////////////

__inline
BOOLEAN
QuitGraphicsThread(
    VOID
    )
/*++

Routine Description:

    Indiates whether the primary upgrade graphics thread
    needs to be stopped or not based on user input
    (ESC key).

    Note : This feature is only enable in pre-release
           builds.

Arguments:

    None.

Return Value:

    TRUE if the upgrade graphics thread needs to be stopped
    else FALSE.

--*/
{
    BOOLEAN Result = FALSE;

/*
#ifdef PRERELEASE
    Result = SpInputIsKeyWaiting() && (SpInputGetKeypress() == ASCI_ESC);
#endif
*/

    return Result;
}

NTSTATUS
UpgradeGraphicsInit(
    VOID
    )
/*++

Routine Description:

    Does the needed global initialization for the
    upgrade graphics mode.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS, if successful with initialzation,
    otherwise appropriate error code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Initialize global spin locks
    //
    KeInitializeSpinLock(&VgaDisplayLock);
    KeInitializeSpinLock(&ProgressLock);
    KeInitializeSpinLock(&GraphicsThreadLock);

    return Status;
}

NTSTATUS
UpgradeGraphicsStart(
    VOID
    )
/*++

Routine Description:

    Starts of the upgrade graphics

Arguments:

    None.

Return Value:

    STATUS_SUCCESS, if the upgrade graphics was started,
    else appropriate error code.

--*/
{
    NTSTATUS Status;

    Status = PsCreateSystemThread(&GraphicsThreadHandle,
                        THREAD_ALL_ACCESS,
                        NULL,
                        NtCurrentProcess(),
                        NULL,
                        UpgradeGraphicsThread,
                        NULL);



#ifdef _GRAPHICS_TESTING_

    Status = ZwWaitForSingleObject(GraphicsThreadHandle, FALSE, NULL);

#endif

    return Status;
}

VOID
UpgradeGraphicsThread(
    IN PVOID Context
    )
/*++

Routine Description:

    The primary upgrade graphics worker thread, which
    paints the background, updates the progress bar
    and starts the animation.

Arguments:

    Context - Ignored

Return Value:

    None.

--*/
{
    BOOLEAN                     Stop = FALSE;
    TM_GRAPHICS_PRGBAR_HANDLE   hProgBar;
    TM_ANIMATED_BITMAP_HANDLE   hAnimation = NULL;
    TM_BITMAP_HANDLE            hBitmap = NULL;
    LARGE_INTEGER               DelayTime;
    NTSTATUS                    Status;
    WCHAR                       Buffer[MAX_PATH];
    ULONG                       BitmapIds[] = {
                                    IDB_WORKING1, IDB_WORKING2,
                                    IDB_WORKING3, IDB_WORKING4,
                                    IDB_WORKING5, IDB_WORKING6,
                                    IDB_WORKING7, IDB_WORKING8,
                                    IDB_WORKING9, IDB_WORKING10,
                                    IDB_WORKING11, IDB_WORKING12,
                                    IDB_WORKING13, IDB_WORKING14,
                                    IDB_WORKING15, IDB_WORKING16,
                                    IDB_WORKING17, IDB_WORKING18,
                                    IDB_WORKING19, IDB_WORKING20,
                                    0 };

    //
    // Initialize graphics mode
    //
    Status = VgaGraphicsInit(&VideoVars);

    if (NT_SUCCESS(Status)) {
        //
        // Create the background bitmap
        //
        if (Win9xRollback) {
            hBitmap = TextmodeBitmapCreate(IDB_RESTORE_BK);
        } else {
            hBitmap = TextmodeBitmapCreate(IDB_BACKGROUND1);
        }

        if (hBitmap) {
            //
            // Create the animated bitmap
            //
            hAnimation = TextmodeAnimatedBitmapCreate(BitmapIds);

            if (hAnimation) {
                //
                // Create the bitmapped graphics progress bar
                //
                hProgBar = TextmodeGraphicsProgBarCreateUsingBmps(28, 352,
                                123, 14,
                                IDB_BACKCELL, IDB_FORECELL, 0);

                if (hProgBar) {
                    BOOLEAN Refreshed = FALSE;
                    ULONG   Fill = 0;
                    BOOLEAN Increase = TRUE;

                    //
                    // Render background
                    //
                    TextmodeBitmapDisplay(hBitmap, 0, 0);

                    //
                    // Start the animation
                    //
                    Status = TextmodeAnimatedBitmapAnimate(hAnimation, 542, 460, 100);

                    //
                    // Note : Failure to start the animation is not a critical
                    // error
                    //
                    if (!NT_SUCCESS(Status)) {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                            "SETUP:Upgrade graphics thread failed to "
                            "animate : %lx error code\r\n",
                            Status));
                    }

                    DelayTime.HighPart = -1;                 // relative time
                    DelayTime.LowPart = (ULONG)(-10000 * 500);  // 1000 msec interval

                    //
                    // Render graphics progress bar
                    //
                    TextmodeGraphicsProgBarRefresh(hProgBar, TRUE);

                    Fill = GetSetupProgress();
                    Stop = UpgradeGraphicsThreadGetStop();

                    //
                    // Continue on till user asks us to stop, or the main
                    // textmode thread encounters an error and stops us
                    //
                    while (!Stop && !QuitGraphicsThread()) {
                        //
                        // Update the graphics progress bar
                        //
                        TextmodeGraphicsProgBarUpdate(hProgBar, Fill);

                        //
                        // Sleep for 0.5 secs
                        //
                        KeDelayExecutionThread(KernelMode, FALSE, &DelayTime);

                        Fill = GetSetupProgress();
                        Stop = UpgradeGraphicsThreadGetStop();

#ifdef _GRAPHICS_TESTING_

                        if (Increase) {
                            if (Fill < 100) {
                                Fill++;
                                SetSetupProgress(Fill);
                            } else {
                                Increase = FALSE;
                            }
                        }

                        if (!Increase) {
                            if (Fill <= 0) {
                                Increase = TRUE;
                            } else {
                                Fill--;
                                SetSetupProgress(Fill);
                            }
                        }

#endif _GRAPHICS_TESTING_

                    }

                    //
                    // Was graphics thread stopped by the main
                    // textmode setup, then most probably we
                    // encountered an error or user intervention
                    // is required
                    //
                    Stop = UpgradeGraphicsThreadGetStop();

                    //
                    // Delete the graphics progress bar
                    //
                    TextmodeGraphicsProgBarDelete(hProgBar);
                }

                //
                // Stop the animation, and delete the animated
                // bitmap object
                //
                TextmodeAnimatedBitmapDelete(hAnimation);
            }

            //
            // Delete the background bitmap object
            //
            TextmodeBitmapDelete(hBitmap);
        }
    }        

    //
    // If graphics thread was stopped by user intervention
    // then we need to switch to textmode
    //
    if (!Stop) {
        spvidSpecificReInitialize();
        SP_SET_UPGRADE_GRAPHICS_MODE(FALSE);
    }

    PsTerminateSystemThread(Status);
}

VOID
GraphicsModeProgressUpdate(
    IN TM_SETUP_MAJOR_EVENT MajorEvent,
    IN TM_SETUP_MINOR_EVENT MinorEvent,
    IN PVOID Context,
    IN PVOID EventData
    )
/*++

Routine Description:

    Callback which updates the over all progress during
    upgrade graphics mode.

    Note : The single progress bar in upgrade graphics mode
           is used in place of all the various different
           progress bars which are used through out the
           textmode.

           The single progress bar is divided into ranges
           as shown below for the various major events
           across the textmode setup:

           ------------------------------------------
               Range(%)        MajorEvent
           ------------------------------------------
                00-05        InitializationEvent

                05-20        PartitioningEvent
                              (Includes chkdsk)

                20-40        Backup (if enabled)
                20-40        Uninstall (if enabled)

                20/40-90     FileCopyEvent
                              (Actual file copying)

                90-98        SavingSettingsEvent

                98-100       SetupCompleted
           ------------------------------------------

Arguments:

    MajorEvent - Indicates the major type of the event
                 which happened.

    MinorEvent - Indicates the minor type of the event
                 which happened.

    Context - Context data which was registered when
              we register for callback.

    EventData - More detailed event specific data

Return Value:

    None.

--*/
{
    static BOOLEAN Add = TRUE;
    static ULONG LastPercentage = 0;
    static ULONG BackupAllocation = 0;
    BOOLEAN SkipSpew = FALSE;
    ULONG Delta = 0;
    ULONG PercentageFill = 0;

    PercentageFill = GetSetupProgress();

    switch (MajorEvent) {
        case InitializationEvent:
            switch (MinorEvent) {
                case InitializationStartEvent:
                    PercentageFill = 2;
                    break;

                case InitializationEndEvent:
                    PercentageFill = 5;
                    break;

                default:
                    break;
            }

            break;

        case PartitioningEvent:
            switch (MinorEvent) {
                case ValidatePartitionEvent:
                    Delta = (15 * (*(PULONG)EventData)) / 200;
                    PercentageFill = 5 + Delta;

                    break;

                case FormatPartitionEvent:
                    //
                    // In cases of upgrade (we won't be formatting)
                    //
                    break;

                default:
                    break;
            }

            break;

        case FileCopyEvent:
            switch (MinorEvent) {
                case FileCopyStartEvent:
                    LastPercentage = PercentageFill = 20 + BackupAllocation;
                    break;

                case OneFileCopyEvent:
                    Delta = ((70 - BackupAllocation) * (*(PULONG)EventData)) / 100;
                    PercentageFill = 20 + Delta + BackupAllocation;

                    if ((PercentageFill - LastPercentage) > 5) {
                        LastPercentage = PercentageFill;
                    } else {
                        SkipSpew = TRUE;
                    }

                    break;

                case FileCopyEndEvent:
                    PercentageFill = 90;

                    break;

                default:
                    break;
            }

            break;

        case BackupEvent:
            switch (MinorEvent) {
                case BackupStartEvent:
                    LastPercentage = PercentageFill = 20;
                    BackupAllocation = 20;
                    break;

                case OneFileBackedUpEvent:
                    Delta = (20 * (*(PULONG)EventData)) / 100;
                    PercentageFill = 20 + Delta;

                    if ((PercentageFill - LastPercentage) > 5) {
                        LastPercentage = PercentageFill;
                    } else {
                        SkipSpew = TRUE;
                    }

                    break;

                case BackupEndEvent:
                    PercentageFill = 40;
                    break;
            }

            break;

        case UninstallEvent:
            switch (MinorEvent) {
                case UninstallStartEvent:
                    LastPercentage = PercentageFill = 20;
                    break;

                case UninstallUpdateEvent:
                    Delta = (70 * (*(PULONG)EventData)) / 100;
                    PercentageFill = 20 + Delta;

                    if ((PercentageFill - LastPercentage) > 5) {
                        LastPercentage = PercentageFill;
                    } else {
                        SkipSpew = TRUE;
                    }

                    break;

                case UninstallEndEvent:
                    PercentageFill = 90;
                    break;

                default:
                    break;
            }

            break;

        case SavingSettingsEvent:
            switch (MinorEvent) {
                case SavingSettingsStartEvent:
                    PercentageFill = 90;
                    break;

                case SaveHiveEvent:
                    if (PercentageFill < 98) {
                        if (Add) {
                            PercentageFill += 1;
                            Add = FALSE;
                        } else {
                            Add = TRUE;
                        }
                    }

                    break;

                case SavingSettingsEndEvent:
                    if (PercentageFill < 98) {
                        PercentageFill = 98;
                    }

                    break;

                default:
                    break;
            }

            break;


        case SetupCompletedEvent:
            PercentageFill = 100;

            break;

        default:
            break;
    }

    if (!SkipSpew) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,
            "Setup Event : %ld, %ld, %ld, [%ld], (%ld)\n",
            MajorEvent,
            MinorEvent,
            EventData ? *(PULONG)EventData : 0,
            Delta,
            PercentageFill
            ));
    }

    SetSetupProgress(PercentageFill);
}


NTSTATUS
SpvidSwitchToTextmode(
    VOID
    )
/*++

Routine Description:

    Switches from upgrade graphics mode to the regular
    textmode.

    Note : The actual work of switching the graphics
           back to the regular VGA textmode happens
           as a method in video specific reinitialize
           method.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS, if successful, otherwise appropirate
    error code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (SP_IS_UPGRADE_GRAPHICS_MODE() && GraphicsThreadHandle) {
        //
        // Stop the primary upgrade graphics thread
        //
        UpgradeGraphicsThreadSetStop(TRUE);

        //
        // Wait for the graphics thread to terminate
        //
        Status = ZwWaitForSingleObject(GraphicsThreadHandle, FALSE, NULL);

        //
        // Switch back to textmode
        //
        spvidSpecificReInitialize();
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\graphics.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    graphics.h

Abstract:

    Bitmap display support with text mode for
    upgrade. This file has three core abstractions
    Bitmap, Animated bitmap and Graphics 
    Progress bar.

Author:

    Vijay Jayaseelan (vijayj)  01 July 2000    

Revision History:

    None

--*/

#ifndef _GRAPHICS_H_ 
#define _GRAPHICS_H_

#include "spprecmp.h"
#pragma hdrstop

#define MAX_ANIMATED_BITMAPS 256

//
// Bitmap abstraction
//
// A textmode bitmap can be created using a resource ID
// or a fully qualified bitmap file name.
//
// Note : Since currently we support only 640 * 480 * 16 (colors)
//        VGA mode, its necessary that all the bitmap
//        resources and files adhere to this format.
//
typedef struct _TM_BITMAP {
    PVOID   ViewBase;
    PVOID   Data;
    WCHAR   FileName[MAX_PATH];
    HANDLE  FileHandle;
    HANDLE  SectionHandle;
} TM_BITMAP, *PTM_BITMAP, *TM_BITMAP_HANDLE;


//
// Bitmap methods
//
TM_BITMAP_HANDLE
TextmodeBitmapCreate(
    IN ULONG ResourceId
    );

TM_BITMAP_HANDLE
TextmodeBitmapCreateFromFile(
    IN PWSTR FileName
    );

NTSTATUS
TextmodeBitmapDelete(
    IN TM_BITMAP_HANDLE hBitmap
    );

NTSTATUS
TextmodeBitmapDisplay(
    IN TM_BITMAP_HANDLE hBitmap,
    IN ULONG X,
    IN ULONG Y
    );

//
// Animated bitmap abstraction
//
// Animated bitmap consists of multiple bitmaps of the same
// size. Each next bitmap is drawn at the same location 
// after the specified time out, creating an illusion of
// animation.
//
// Note : Since animated bitmap is just a collection of
//        regular textmode bitmap abstraction, its format
//        is also restricted as regular textmode bitmap.
//
typedef struct _TM_ANIMATED_BITMAP {
    TM_BITMAP_HANDLE    Bitmaps[MAX_ANIMATED_BITMAPS];
    ULONG               FlipTime;
    ULONG               CurrentBitmap;
    ULONG               X;
    ULONG               Y;
    HANDLE              ThreadHandle;
    LONG                StopAnimating;
} TM_ANIMATED_BITMAP, *PTM_ANIMATED_BITMAP, *TM_ANIMATED_BITMAP_HANDLE;


//
// Animated bitmap methods
//
TM_ANIMATED_BITMAP_HANDLE
TextmodeAnimatedBitmapCreate(
    IN ULONG *ResourceIds
    );

TM_ANIMATED_BITMAP_HANDLE
TextmodeAnimatedBitmapCreateFromFiles(
    IN WCHAR *FileNames[]
    );

NTSTATUS
TexmodeAnimatedBitmapDelete(
    IN TM_ANIMATED_BITMAP_HANDLE hAnimatedBitmap
    );

NTSTATUS
TextmodeAnimatedBitmapAnimate(
    IN TM_ANIMATED_BITMAP_HANDLE hAnimatedBitmap,
    IN ULONG X,
    IN ULONG Y,
    IN ULONG Speed
    );

VOID
TextmodeAnimatedBitmapAnimator(
    IN PVOID Context
    );


//
// Progress Bar abstraction
//
// Note : Progress bar can use bitmaps or solid
// fills based on the way its created. In case
// the progress bar uses bitmaps, then the 
// foreground & background bitmaps are each 1 pixel
// wide and background bitmap is assumed to be
// 2 pixels shorter than foreground bitmap.
// 
//
typedef struct _TM_GRAPHICS_PRGBAR {
    ULONG   X;
    ULONG   Y;
    ULONG   Length;
    ULONG   Height;
    ULONG   BackgroundColor;    
    ULONG   ForegroundColor;
    ULONG   Fill;
    TM_BITMAP_HANDLE Background;
    TM_BITMAP_HANDLE Foreground;
} TM_GRAPHICS_PRGBAR, *TM_GRAPHICS_PRGBAR_HANDLE;

//
// Progress bar methods
//
TM_GRAPHICS_PRGBAR_HANDLE
TextmodeGraphicsProgBarCreate(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG Length,
    IN ULONG Height,
    IN ULONG ForegroundColor,
    IN ULONG BackgroundColor,
    IN ULONG InitialFill
    );

TM_GRAPHICS_PRGBAR_HANDLE
TextmodeGraphicsProgBarCreateUsingBmps(
    IN ULONG X,
    IN ULONG Y,
    IN ULONG Length,
    IN ULONG Height,
    IN ULONG BackgroundBmpId,
    IN ULONG CellBmpId,
    IN ULONG InitialFill
    );
    

NTSTATUS
TextmodeGraphicsProgBarUpdate(
    IN TM_GRAPHICS_PRGBAR_HANDLE hPrgBar,
    IN ULONG Fill
    );

NTSTATUS
TextmodeGraphicsProgBarRefresh(
    IN TM_GRAPHICS_PRGBAR_HANDLE hPrgBar,
    IN BOOLEAN UpdateBackground
    );    

NTSTATUS
TextmodeGraphicsProgBarDelete(
    IN TM_GRAPHICS_PRGBAR_HANDLE hPrgBar
    );


//    
// Vga graphics interface
//
NTSTATUS
VgaGraphicsInit(
    PSP_VIDEO_VARS VideoVars
    );

NTSTATUS
VgaGraphicsTerminate(
    PSP_VIDEO_VARS VideoVars
    );

VOID
VgaGraphicsSolidColorFill(
    IN ULONG x1,
    IN ULONG y1,
    IN ULONG x2,
    IN ULONG y2,
    IN ULONG Color
    );

VOID
VgaGraphicsBitBlt(
    IN PUCHAR Buffer,
    IN ULONG x,
    IN ULONG y
    );

//
// Misc functions
//
NTSTATUS
UpgradeGraphicsInit(
    VOID
    );

NTSTATUS
UpgradeGraphicsStart(
    VOID
    );
    
VOID
GraphicsModeProgressUpdate(
    IN TM_SETUP_MAJOR_EVENT MajorEvent,
    IN TM_SETUP_MINOR_EVENT MinorEvent,
    IN PVOID Context,
    IN PVOID EventData
    );

VOID
UpgradeGraphicsThread(
    IN PVOID Context
    );    

//
// Indicates that graphics mode is needed for upgrade
// cases, with actual textmode running in the background
//
#define SP_IS_UPGRADE_GRAPHICS_MODE() (VideoVars.UpgradeGraphicsMode)

#define SP_SET_UPGRADE_GRAPHICS_MODE(_Value)              \
            (VideoVars.UpgradeGraphicsMode = (_Value));

//
// #define _GRAPHICS_TESTING_  TRUE            
//

#endif // for _GRAPHICS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\sparc.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    sparc.c

Abstract:

    Functions to deal with ARC paths and variables.

Author:

    Ted Miller (tedm) 22-Sep-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop

//
// Define maximum number of components in a semi-colon separated list
// of arc paths.
//
#define MAX_COMPONENTS 20

//
// We maintain a list of all arcnames in the system and their NT equivalents.
// This makes translations very easy.
//
typedef struct _ARCNAME_TRANSLATION {

    struct _ARCNAME_TRANSLATION *Next;

    PWSTR ArcPath;
    PWSTR NtPath;

} ARCNAME_TRANSLATION, *PARCNAME_TRANSLATION;

PARCNAME_TRANSLATION ArcNameTranslations;


//
// Function prototypes.
//
VOID
SppFreeComponents(
    IN PVOID *EnvVarComponents
    );

VOID
SppInitializeHardDiskArcNames(
    VOID
    );

extern PSETUP_COMMUNICATION CommunicationParams;

VOID
SpInitializeArcNames(
    PVIRTUAL_OEM_SOURCE_DEVICE  OemDevices
    )
{
    UNICODE_STRING UnicodeString;
    HANDLE DirectoryHandle;
    HANDLE ObjectHandle;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    BOOLEAN RestartScan;
    ULONG Context;
    BOOLEAN MoreEntries;
    PWSTR ArcName;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    WCHAR ArcNameDirectory[] = L"\\ArcName";
    PARCNAME_TRANSLATION Translation;

    //
    // Only call this routine once.
    //
    ASSERT(ArcNameTranslations == NULL);

    //
    // First, do hard disks specially.  For each hard disk in the system,
    // open it and check its signature against those in the firmware
    // disk information.
    //
    SppInitializeHardDiskArcNames();

    //
    // Open the \ArcName directory.
    //
    INIT_OBJA(&Obja,&UnicodeString,ArcNameDirectory);

    Status = ZwOpenDirectoryObject(&DirectoryHandle,DIRECTORY_ALL_ACCESS,&Obja);

    if(NT_SUCCESS(Status)) {

        RestartScan = TRUE;
        Context = 0;
        MoreEntries = TRUE;

        do {

            Status = SpQueryDirectoryObject(
                        DirectoryHandle,
                        RestartScan,
                        &Context
                        );

            if(NT_SUCCESS(Status)) {

                DirInfo = (POBJECT_DIRECTORY_INFORMATION)
                            ((PSERVICE_QUERY_DIRECTORY_OBJECT)&CommunicationParams->Buffer)->Buffer;

                SpStringToLower(DirInfo->Name.Buffer);

                //
                // Make sure this name is a symbolic link.
                //
                if(DirInfo->Name.Length
                && (DirInfo->TypeName.Length >= (sizeof(L"SymbolicLink") - sizeof(WCHAR)))
                && !_wcsnicmp(DirInfo->TypeName.Buffer,L"SymbolicLink",12))
                {
                    ArcName = SpMemAlloc(DirInfo->Name.Length + sizeof(ArcNameDirectory) + sizeof(WCHAR));

                    wcscpy(ArcName,ArcNameDirectory);
                    SpConcatenatePaths(ArcName,DirInfo->Name.Buffer);

                    //
                    // We have the entire arc name in ArcName.  Now open it as a symbolic link.
                    //
                    INIT_OBJA(&Obja,&UnicodeString,ArcName);

                    Status = ZwOpenSymbolicLinkObject(
                                &ObjectHandle,
                                READ_CONTROL | SYMBOLIC_LINK_QUERY,
                                &Obja
                                );

                    if(NT_SUCCESS(Status)) {

                        //
                        // Finally, query the object to get the link target.
                        //
                        UnicodeString.Buffer = TemporaryBuffer;
                        UnicodeString.Length = 0;
                        UnicodeString.MaximumLength = sizeof(TemporaryBuffer);

                        Status = ZwQuerySymbolicLinkObject(
                                    ObjectHandle,
                                    &UnicodeString,
                                    NULL
                                    );

                        if(NT_SUCCESS(Status)) {

                            //
                            // nul-terminate the returned string
                            //
                            UnicodeString.Buffer[UnicodeString.Length/sizeof(WCHAR)] = 0;

                            //
                            // Ignore this entry if it's a hard disk or hard disk partition.
                            //
                            if(_wcsnicmp(UnicodeString.Buffer,L"\\Device\\Harddisk",16)) {

                                //
                                // Create an arcname translation entry.
                                //
                                Translation = SpMemAlloc(sizeof(ARCNAME_TRANSLATION));
                                Translation->Next = ArcNameTranslations;
                                ArcNameTranslations = Translation;

                                //
                                // Leave out the \ArcName\ part.
                                //
                                Translation->ArcPath = SpNormalizeArcPath(
                                                            ArcName
                                                          + (sizeof(ArcNameDirectory)/sizeof(WCHAR))
                                                            );

                                Translation->NtPath = SpDupStringW(UnicodeString.Buffer);
                            }

                        } else {
                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to query symbolic link %ws (%lx)\n",ArcName,Status));
                        }

                        ZwClose(ObjectHandle);
                    } else {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open symbolic link %ws (%lx)\n",ArcName,Status));
                    }

                    SpMemFree(ArcName);
                }

            } else {

                MoreEntries = FALSE;
                if(Status == STATUS_NO_MORE_ENTRIES) {
                    Status = STATUS_SUCCESS;
                }
            }

            RestartScan = FALSE;

        } while(MoreEntries);

        ZwClose(DirectoryHandle);

    } else {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open \\ArcName directory (%lx)\n",Status));
    }

    //
    // Add OEM virtual device arc name translations if any at
    // the front of the list
    //
    if (NT_SUCCESS(Status) && OemDevices) {
        PVIRTUAL_OEM_SOURCE_DEVICE  CurrDevice = OemDevices;
        WCHAR   RamDeviceName[MAX_PATH];

        while (CurrDevice) {
            PARCNAME_TRANSLATION NewTranslation;

            NewTranslation = SpMemAlloc(sizeof(ARCNAME_TRANSLATION));

            if (!NewTranslation) {
                Status = STATUS_NO_MEMORY;
                break;
            }                

            //
            // create the new translation
            //            
            RamDeviceName[0] = UNICODE_NULL;
            RtlZeroMemory(NewTranslation, sizeof(ARCNAME_TRANSLATION));

            NewTranslation->ArcPath = SpDupStringW(CurrDevice->ArcDeviceName);

            swprintf(RamDeviceName, L"%ws%d", RAMDISK_DEVICE_NAME, CurrDevice->DeviceId);
            NewTranslation->NtPath = SpDupStringW(RamDeviceName);

            //
            // add the new translation at the start of the linked list
            //
            NewTranslation->Next = ArcNameTranslations;
            ArcNameTranslations = NewTranslation;

            //
            // process the next device
            //
            CurrDevice = CurrDevice->Next;
        }
    }    

    //
    // If we couldn't gather arcname translations, something is
    // really wrong with the system.
    //
    if(!NT_SUCCESS(Status)) {

        SpStartScreen(
                SP_SCRN_COULDNT_INIT_ARCNAMES,
                3,
                HEADER_HEIGHT+1,
                FALSE,
                FALSE,
                DEFAULT_ATTRIBUTE
                );
        if(KbdLayoutInitialized) {
            SpContinueScreen(
                    SP_SCRN_F3_TO_REBOOT,
                    3,
                    1,
                    FALSE,
                    DEFAULT_ATTRIBUTE
                    );
            SpDisplayStatusText(SP_STAT_F3_EQUALS_EXIT, DEFAULT_STATUS_ATTRIBUTE);
            SpInputDrain();
            while(SpInputGetKeypress() != KEY_F3);
            SpDone(0, FALSE, TRUE);
        } else {
            //
            // we haven't loaded the layout dll yet, so we can't prompt for a keypress to reboot
            //
            SpContinueScreen(
                    SP_SCRN_POWER_DOWN,
                    3,
                    1,
                    FALSE,
                    DEFAULT_ATTRIBUTE
                    );

            SpDisplayStatusText(SP_STAT_KBD_HARD_REBOOT, DEFAULT_STATUS_ATTRIBUTE);

            while(TRUE);    // Loop forever
        }
    }
}


VOID
SpFreeArcNames(
    VOID
    )
{
    PARCNAME_TRANSLATION pTrans,pNext;

    for(pTrans=ArcNameTranslations; pTrans; pTrans=pNext) {

        pNext = pTrans->Next;

        SpMemFree(pTrans->ArcPath);
        SpMemFree(pTrans->NtPath);
        SpMemFree(pTrans);
    }

    ArcNameTranslations = NULL;
}


VOID
SppInitializeHardDiskArcNames(
    VOID
    )
/*++

Routine Description:

    This routine attempts to match NT-visible hard disks to their
    firmware-visible ARC equivalents.  The basic algorithm is as
    follows:

        A match occurs when the disk's signature, checksum, and
        valid partition indicator match the values passed by
        setupldr in the ARC_DISK_INFORMATION structure.

        If no match for the NT disk is found, no arcname is
        created.  Thus, the user may not install NT onto this
        drive.  (the case where the disk will be made visible
        to NTLDR through the installation of NTBOOTDD.SYS is
        a special case that is handled separately)

        If a single match is found, we have found a simple
        ARC<->NT translation.  The arcname is created.

        If more than one match is found, we have a complicated
        ARC<->NT translation.  We assume that there is only one
        valid arcname for any disk.  (This is a safe assumption
        only when we booted via SETUPLDR, since NTLDR may load
        NTBOOTDD.SYS and cause SCSI disks that have the BIOS
        enabled to be visible through both a scsi()... name and
        a multi()... name.)  Thus this means we have two disks
        in the system whose first sector is identical.  In this
        case we do some heuristic comparisons between the ARC
        name and the NT name to attempt to resolve this.

Arguments:

    None.  All ARC name translations will be added to the global
           ArcNameTranslations list.

Return Value:

    None.

--*/

{
    PWSTR DiskName;
    ULONG disk;
    ULONG DiskCount;
    PARCNAME_TRANSLATION Translation;
    HANDLE hPartition;
    NTSTATUS Status;
    PVOID Buffer;
    IO_STATUS_BLOCK StatusBlock;
    ULONG BufferSize;
    PDISK_GEOMETRY Geometry;
    LARGE_INTEGER Offset;
    BOOLEAN ValidPartitionTable;
    ULONG Signature;
    ULONG i;
    ULONG Checksum;
    PDISK_SIGNATURE_INFORMATION DiskSignature;
    PDISK_SIGNATURE_INFORMATION DupSignature;

    //
    // Allocate buffer for disk name.
    //
    DiskName = SpMemAlloc(64 * sizeof(WCHAR));

    DiskCount = IoGetConfigurationInformation()->DiskCount;

    //
    // For each hard disk in the system, open partition 0 and read sector 0.
    //
    for(disk=0; disk<DiskCount; disk++) {

#ifdef _X86_
        BOOLEAN Matched = FALSE;
        
        enum {
            NoEZDisk,
            EZDiskDetected,
            NeedToMark
        };

        CHAR EZDiskStatus = NoEZDisk;
#endif

        swprintf(DiskName, L"\\Device\\HardDisk%u", disk);

        //
        // open the partition read-write since we may need to mark EZDISKs
        //
        Status = SpOpenPartition(DiskName,0,&hPartition,TRUE);

        if(NT_SUCCESS(Status)) {

            //
            // Initially use a 1k buffer to read partition information.
            //
            BufferSize = 1024;
            Buffer = TemporaryBuffer;

            //
            // Issue device control to get partition information.
            //
retrydevctrl:
            Status = ZwDeviceIoControlFile( hPartition,
                                            NULL,
                                            NULL,
                                            NULL,
                                            &StatusBlock,
                                            IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                            NULL,
                                            0,
                                            Buffer,
                                            BufferSize );
            if (Status==STATUS_BUFFER_TOO_SMALL) {

                //
                // Double buffer size and try again.
                //
                BufferSize = BufferSize * 2;
                ASSERT(BufferSize <= sizeof(TemporaryBuffer));

                goto retrydevctrl;
            }

            if (!NT_SUCCESS(Status)) {
                //
                // Skip this disk
                //
                goto errSkipDisk;
            }

            //
            // Read the first two sectors off the drive.
            //
            Geometry = (PDISK_GEOMETRY)Buffer;
            BufferSize = Geometry->BytesPerSector;
            Buffer = ALIGN(Buffer, BufferSize);
            Offset.QuadPart = 0;

            Status = ZwReadFile(hPartition,
                                NULL,
                                NULL,
                                NULL,
                                &StatusBlock,
                                Buffer,
                                BufferSize * 2,
                                &Offset,
                                NULL);
            if (!NT_SUCCESS(Status)) {
                //
                // Skip this disk
                //
                goto errSkipDisk;
            }

#ifdef _X86_
            //
            // Check for EZDrive disk.  If we have one, use sector 1
            // instead of sector 0.
            //
            // We do this only on x86 because the firmware doesn't know
            // about EZDrive, and so we must use sector 0 to match what
            // the firmware did.
            //
            if((BufferSize >= 512)
            && (((PUSHORT)Buffer)[510 / 2] == 0xaa55)
            && ((((PUCHAR)Buffer)[0x1c2] == 0x54) || (((PUCHAR)Buffer)[0x1c2] == 0x55))) {
                EZDiskStatus = EZDiskDetected;

ezdisk:
                //
                // we need to try sector 1
                //
                Buffer = (PUCHAR) Buffer + BufferSize;
            }
#endif

            //
            // Now we have the sector, we can compute the signature,
            // the valid partition indicator, and the checksum.
            //

            if (!IsNEC_98) { //NEC98
                Signature = ((PULONG)Buffer)[PARTITION_TABLE_OFFSET/2-1];
            } //NEC98

            if ((!IsNEC_98) ? (((PUSHORT)Buffer)[BOOT_SIGNATURE_OFFSET] != BOOT_RECORD_SIGNATURE) :
                              ((((PUSHORT)Buffer)[BufferSize/2 - 1 ] != BOOT_RECORD_SIGNATURE) ||
                               (BufferSize == 256))) { //NEC98
                ValidPartitionTable = FALSE;
            } else {
                ValidPartitionTable = TRUE;
            }


            Checksum = 0;
            for (i=0;i<128;i++) {
                Checksum += ((PULONG)Buffer)[i];
            }
            Checksum = 0-Checksum;

            //
            // Scan the list of arc disk information attempting to match
            // signatures
            //


            //
            // Dump the signature info:
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SppInitializeHardDiskArcNames : About to start searching for disk with signature: 0x%08lx\n", Signature));
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SppInitializeHardDiskArcNames : About to start searching for disk with checksum: 0x%08lx\n", Checksum));
            DiskSignature = DiskSignatureInformation;
            i = 0;
            while( DiskSignature != NULL ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "SppInitializeHardDiskArcNames : Signature Info %d\n================================================\n", i ));
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "    Signature: 0x%08lx\n", DiskSignature->Signature ));
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "     CheckSum: 0x%08lx\n", DiskSignature->CheckSum ));
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "      ArcPath: %ws\n", DiskSignature->ArcPath ));
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL,  "       xInt13: %ws\n\n", DiskSignature->xInt13 ? L"yes" : L"no" ));
                i++;
                DiskSignature = DiskSignature->Next;
            }
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "\n\n"));


            DiskSignature = DiskSignatureInformation;
            while (DiskSignature != NULL) {

                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "    SppInitializeHardDiskArcNames : Current signature: 0x%08lx\n", DiskSignature->Signature));
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "    SppInitializeHardDiskArcNames : Current checksum: 0x%08lx\n", DiskSignature->CheckSum));
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "    SppInitializeHardDiskArcNames : Current ArcPath: %ws\n", DiskSignature->ArcPath));

                if( DiskSignature->Signature == Signature ) {

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "        SppInitializeHardDiskArcNames : We matched signatures.\n"));

                    if( DiskSignature->ValidPartitionTable == ValidPartitionTable ) {

                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "            SppInitializeHardDiskArcNames : The partition is valid.\n"));

                        if( DiskSignature->CheckSum == Checksum ) {


                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "                SppInitializeHardDiskArcNames : We matched the checksum.\n"));


                            //
                            // Found the first match, check for another match
                            //
                            DupSignature = DiskSignature->Next;
                            while (DupSignature != NULL) {
                                if ((DupSignature->Signature == Signature) &&
                                    (DupSignature->ValidPartitionTable == ValidPartitionTable) &&
                                    (DupSignature->CheckSum == Checksum)) {


                                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "                    SppInitializeHardDiskArcNames : We found a second match!\n"));


                                    //
                                    // Found a second match.
                                    // For x86, we assume that \Device\HardDisk<n> will usually
                                    // correspond to multi(0)disk(0)rdisk(<n>).  On ARC, we will rely on
                                    // setupldr to guarantee uniqueness (since we can't install to anything
                                    // ARC firmware can't see, this is OK).
                                    //
#ifdef _X86_
                                    if (!IsNEC_98) { //NEC98
                                        PWSTR DupArcName;
                                        ULONG MatchLen;

                                        DupArcName = SpMemAlloc(64 * sizeof(WCHAR));
                                        MatchLen = swprintf(DupArcName, L"multi(0)disk(0)rdisk(%u)", disk);


                                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "                        SppInitializeHardDiskArcNames : 2nd match's arcname: %ws\n", DupArcName));
                                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "                        SppInitializeHardDiskArcNames : Current arcpath: %ws\n", DiskSignature->ArcPath));


                                        if(_wcsnicmp(DupArcName, DiskSignature->ArcPath, MatchLen)) {
                                            //
                                            // If our first match isn't the right one, continue searching.
                                            //
                                            DiskSignature = NULL;

                                            while(DupSignature) {

                                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "                            SppInitializeHardDiskArcNames : Current arcname: %ws\n", DupSignature->ArcPath));
                                                if(!_wcsnicmp(DupArcName, DupSignature->ArcPath, MatchLen)) {

                                                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "                                SppInitializeHardDiskArcNames : We matched the ArcPath.\n"));
                                                    DiskSignature = DupSignature;
                                                    break;

                                                } else {

                                                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "                                SppInitializeHardDiskArcNames : We didn't match the ArcPath.\n"));

                                                }
                                                DupSignature = DupSignature->Next;
                                            }

                                            if(!DiskSignature) {

                                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SppInitializeHardDiskArcNames : We have 2 matching signatures and checksums, but couldn't find any matching ArcPaths.\n"));
                                                SpBugCheck(SETUP_BUGCHECK_BOOTPATH, 1, 0, 0);
                                            }
                                        }

                                        SpMemFree(DupArcName);
                                        break;

                                    } else {
                                        SpBugCheck(SETUP_BUGCHECK_BOOTPATH, 1, 0, 0); //NEC98
                                    }
#else
                                    SpBugCheck(SETUP_BUGCHECK_BOOTPATH, 1, 0, 0);
#endif
                                }

                                DupSignature = DupSignature->Next;
                            }

                            //
                            // We have the match
                            //
#ifdef _X86_
                            Matched = TRUE;
                            Status = STATUS_SUCCESS;

                            //
                            // try to mark the EZDisk if needed; if this fails, we won't create the translation
                            //
                            if(NeedToMark == EZDiskStatus) {
                                //
                                // Need to stamp 0x55 to make this type of EZDisk detectable by other components.
                                //
                                Buffer = (PUCHAR) Buffer - BufferSize;
                                ((PUCHAR) Buffer)[0x1c2] = 0x55;
                                Offset.QuadPart = 0;
                                Status = ZwWriteFile(hPartition, NULL, NULL, NULL, &StatusBlock, Buffer, BufferSize, &Offset, NULL);

                                if(NT_SUCCESS(Status)) {
                                    //
                                    // Shutdown now to give the user a chance to reboot textmode from harddisk.
                                    // Cannot wait here since the keyboard is not yet functional.
                                    //
                                    SpDone(SP_SCRN_AUTOCHK_REQUIRES_REBOOT, TRUE, FALSE);
                                }
                            }

                            if(NT_SUCCESS(Status))
#endif
                            {
                                //
                                // create the translation
                                //
                                Translation = SpMemAlloc(sizeof(ARCNAME_TRANSLATION));
                                Translation->Next = ArcNameTranslations;
                                ArcNameTranslations = Translation;

                                Translation->ArcPath = SpDupStringW(DiskSignature->ArcPath);
                                Translation->NtPath  = SpDupStringW(DiskName);
                            }


                            break;




                        } else {
                            //
                            // checksum test.
                            //
                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "                SppInitializeHardDiskArcNames : We didn't match the checksum.\n"));
                        }
                        } else {
                            //
                            // validity test.
                            //
                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "            SppInitializeHardDiskArcNames : The partition isn't valid.\n"));
                    }
                } else {
                    //
                    // Signature test.
                    //
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "        SppInitializeHardDiskArcNames : We didn't match signatures.\n"));
                }

                DiskSignature = DiskSignature->Next;
            }

#ifdef _X86_
            if(!Matched && NoEZDisk == EZDiskStatus) {
                //
                // no match; there may be an undetected variant of EZDisk that we may need to mark
                //
                EZDiskStatus = NeedToMark;
                goto ezdisk;
            }
#endif

errSkipDisk:
            ZwClose(hPartition);
        }
    }

    SpMemFree(DiskName);
}


PWSTR
pSpArcToNtWorker(
    IN PWSTR CompleteArcPath,
    IN PWSTR ArcPathPrefix,
    IN PWSTR NtPathPrefix
    )
{
    ULONG matchLen;
    PWSTR translatedPath;
    PWSTR q,RestOfPath;

    translatedPath = NULL;
    matchLen = wcslen(ArcPathPrefix);

    //
    // We must take care the case that ArcPathPrefix has no value.
    // _wcsnicmp() will return zero, when matchLen is zero.
    //
    if(matchLen && !_wcsnicmp(ArcPathPrefix,CompleteArcPath,matchLen)) {

        translatedPath = SpMemAlloc(2048);

        wcscpy(translatedPath,NtPathPrefix);

        RestOfPath = CompleteArcPath + matchLen;

        //
        // If the next component is partition(n), convert that to partitionn.
        //
        if(!_wcsnicmp(RestOfPath,L"partition(",10)) {

            if(q = wcschr(RestOfPath+10,L')')) {

                *q = 0;

                SpConcatenatePaths(translatedPath,L"partition");
                wcscat(translatedPath,RestOfPath+10);

                *q = ')';

                RestOfPath = q+1;
            }
        }

        if(*RestOfPath) {       // avoid trailing backslash.
            SpConcatenatePaths(translatedPath,RestOfPath);
        }

        q = translatedPath;
        translatedPath = SpDupStringW(q);
        SpMemFree(q);
    }

    return(translatedPath);
}


PWSTR
pSpNtToArcWorker(
    IN PWSTR CompleteNtPath,
    IN PWSTR NtPathPrefix,
    IN PWSTR ArcPathPrefix
    )
{
    ULONG matchLen;
    PWSTR translatedPath;
    PWSTR p,RestOfPath;

    translatedPath = NULL;
    matchLen = wcslen(NtPathPrefix);

    //
    // We must take care the case that NtPathPrefix has no value.
    // _wcsnicmp() will return zero, when matchLen is zero.
    //
    if(matchLen && !_wcsnicmp(NtPathPrefix,CompleteNtPath,matchLen) && ((*(CompleteNtPath + matchLen) == L'\\') || (*(CompleteNtPath + matchLen) == L'\0'))) {

        translatedPath = SpMemAlloc(2048);

        wcscpy(translatedPath,ArcPathPrefix);

        RestOfPath = CompleteNtPath + matchLen;

        //
        // If the next component is partitionn, convert that to partition(n).
        //
        if(!_wcsnicmp(RestOfPath,L"\\partition",10)) {

            WCHAR c;

            //
            // Figure out where the partition ordinal ends.
            //
            SpStringToLong(RestOfPath+10,&p,10);

            c = *p;
            *p = 0;

            wcscat(translatedPath,L"partition(");
            wcscat(translatedPath,RestOfPath+10);
            wcscat(translatedPath,L")");

            *p = c;
            RestOfPath = p;
        }

        if(*RestOfPath) {       // avoid trailing backslash.
            SpConcatenatePaths(translatedPath,RestOfPath);
        }

        p = translatedPath;
        translatedPath = SpDupStringW(p);
        SpMemFree(p);
    }

    return(translatedPath);
}


PWSTR
SpArcToNt(
    IN PWSTR ArcPath
    )
{
    PARCNAME_TRANSLATION Translation;
    PWSTR NormalizedArcPath;
    PWSTR Result;

    NormalizedArcPath = SpNormalizeArcPath(ArcPath);
    Result = NULL;

    for(Translation=ArcNameTranslations; Translation; Translation=Translation->Next) {

        Result = pSpArcToNtWorker(
                    NormalizedArcPath,
                    Translation->ArcPath,
                    Translation->NtPath
                    );

        if(Result) {
            break;
        }
    }

#ifdef _X86_
    if(!Result && HardDisksDetermined) {

        ULONG i;

        for(i=0; i<HardDiskCount; i++) {

            //
            // The disk may not have an equivalent nt path.
            //
            if(HardDisks[i].DevicePath[0]) {

                Result = pSpArcToNtWorker(
                            NormalizedArcPath,
                            HardDisks[i].ArcPath,
                            HardDisks[i].DevicePath
                            );
            }

            if(Result) {
                break;
            }
        }
    }
#endif

    SpMemFree(NormalizedArcPath);
    return(Result);
}


PWSTR
SpNtToArc(
    IN PWSTR            NtPath,
    IN ENUMARCPATHTYPE  ArcPathType
    )
/*++

Routine Description:


    Given a pathname n the NT-namespace, return an equivalent path
    in the ARC namespace.

    On x86, we can have disks attached to scsi adapters with BIOSes.
    Those disks are accessible both via multi()-style arc names and
    scsi()-style names.  The above search returns the mutli()-style
    one first, which is fine.  But sometimes we want to find the scsi
    one.  That one is referred to as the 'secondary' arc path.
    We declare that this concept is x86-specific.

Arguments:

    NtPath - supplies NT path to translate into ARC.

    ArcPathType - see above.  This parameter is ignored
        on non-x86 platforms.

Return Value:

    Pointer to wide-character string containing arc path, or NULL
    if there is no equivalent arc path for the given nt path.

--*/
{
    PARCNAME_TRANSLATION Translation;
    PWSTR Result;

    Result = NULL;

    for(Translation=ArcNameTranslations; Translation; Translation=Translation->Next) {

        Result = pSpNtToArcWorker(
                    NtPath,
                    Translation->NtPath,
                    Translation->ArcPath
                    );

        if(Result) {
            break;
        }
    }

#ifdef _X86_
    //
    // If we are supposed to find a secondary arc path and we already
    // found a primary one, forget the primary one we found.
    //
    if((ArcPathType != PrimaryArcPath) && Result) {
        SpMemFree(Result);
        Result = NULL;
    }

    if(!Result && HardDisksDetermined) {

        ULONG i;

        for(i=0; i<HardDiskCount; i++) {
            //
            // The disk may not have an equivalent arc path.
            //
            if(HardDisks[i].ArcPath[0]) {

                Result = pSpNtToArcWorker(
                            NtPath,
                            HardDisks[i].DevicePath,
                            HardDisks[i].ArcPath
                            );
            }

            if(Result) {
                break;
            }
        }
    }
#else
    UNREFERENCED_PARAMETER(ArcPathType);
#endif

    return(Result);
}


PWSTR
SpScsiArcToMultiArc(
    IN PWSTR ArcPath
    )
/*
    Convert a "scsi(..." arcpath into a "multi(..." arcpath, if possible.

*/
{
PWSTR   p = NULL;
PWSTR   q = NULL;

    //
    // First convert the path into the device path
    //
    p = SpArcToNt( ArcPath );

    if( p ) {
        //
        // Now convert that device path into an arcpath.
        //
        q = SpNtToArc( p,
                       PrimaryArcPath );

        SpMemFree(p);
    }

    return q;
}


PWSTR
SpMultiArcToScsiArc(
    IN PWSTR ArcPath
    )
/*
    Convert a "multi(..." arcpath into a "scsi(..." arcpath, if possible.

*/
{
PWSTR   p = NULL;
PWSTR   q = NULL;

    //
    // First convert the path into the device path
    //
    p = SpArcToNt( ArcPath );

    if( p ) {
        //
        // Now convert that device path into an arcpath.
        //
        q = SpNtToArc( p,
                       SecondaryArcPath );

        SpMemFree(p);
    }

    return q;
}



VOID
SpGetEnvVarComponents(
    IN  PCHAR    EnvValue,
    OUT PCHAR  **EnvVarComponents,
    OUT PULONG   PNumComponents
    )

/*++

Routine Description:

    This routine takes an environment variable string and turns it into
    the constituent value strings:

    Example EnvValue = "Value1;Value2;Value3" is turned into:

    "Value1", "Value2", "Value3"

    The following are valid value strings:

    1. "     "                                      :one null value is found
    2. ";;;;    "                                   :five null values are found
    3. " ;Value1    ;   Value2;Value3;;;;;;;   ;"   :12 value strings are found,
                                                    :9 of which are null

    The value strings returned suppress all whitespace before and after the
    value. Embedded whitespaces are treated as valid.


Arguments:

    EnvValue:  ptr to zero terminated environment value string

    EnvVarComponents: ptr to a PCHAR * variable to receive the buffer of
                      ptrs to the constituent value strings.

    PNumComponents: ptr to a ULONG to receive the number of value strings found

Return Value:

    None.

        - *PNumComponent field gets the number of value strings found
        - if the number is non zero the *EnvVarComponents field gets the
          ptr to the buffer containing ptrs to value strings

--*/

{
    PCHAR pchStart, pchEnd, pchNext;
    PCHAR pchComponents[MAX_COMPONENTS + 1];
    ULONG NumComponents, i;
    PCHAR pch;
    PCHAR *ppch;
    ULONG size;

    ASSERT(EnvValue);

    //
    // Initialise the ptr array with nulls
    //
    for (i = 0; i < (MAX_COMPONENTS+1); i++) {
        pchComponents[i] = NULL;
    }

    *EnvVarComponents = NULL;

    //
    // Initialise ptrs to search components
    //
    pchStart      = EnvValue;
    NumComponents = 0;


    //
    // search till either pchStart reaches the end or till max components
    // is reached.
    //
    while (*pchStart && NumComponents < MAX_COMPONENTS) {

        //
        // find the beginning of next variable value
        //
        while (*pchStart!=0 && isspace(*pchStart)) {
            pchStart++;
        }

        if (*pchStart == 0) {
            break;
        }

        //
        // In the midst of a value
        //
        pchEnd = pchStart;
        while (*pchEnd!=0 && *pchEnd!=';') {
            pchEnd++;
        }

        //
        // Process the value found, remove any spaces at the end
        //
        while((pchEnd > pchStart) && isspace(*(pchEnd-1))) {
            pchEnd--;
        }

        //
        // spit out the value found
        //

        size = (ULONG)(pchEnd - pchStart);
        pch = SpMemAlloc(size+1);
        ASSERT(pch);

        strncpy (pch, pchStart, size);
        pch[size]=0;
        pchComponents[NumComponents++]=pch;

        //
        // variable value end has been reached, find the beginning
        // of the next value
        //
        if ((pchNext = strchr(pchEnd, ';')) == NULL) {
            break; // out of the big while loop because we are done
        }

        //
        // reinitialise
        //
        pchStart = pchNext + 1;

    } // end while.

    //
    // Get memory to hold an environment pointer and return that
    //
    ppch = (PCHAR *)SpMemAlloc((NumComponents+1)*sizeof(PCHAR));

    //
    // the last one is NULL because we initialised the array with NULLs
    //
    for(i = 0; i <= NumComponents; i++) {
        ppch[i] = pchComponents[i];
    }

    *EnvVarComponents = ppch;

    //
    // Update the number of elements field and return.
    //
    *PNumComponents = NumComponents;
}



VOID
SpGetEnvVarWComponents(
    IN  PCHAR    EnvValue,
    OUT PWSTR  **EnvVarComponents,
    OUT PULONG   PNumComponents
    )

/*++

Routine Description:

    This routine takes an environment variable string and turns it into
    the constituent value strings:

    Example EnvValue = "Value1;Value2;Value3" is turned into:

    "Value1", "Value2", "Value3"

    The following are valid value strings:

    1. "     "                                      :one null value is found
    2. ";;;;    "                                   :five null values are found
    3. " ;Value1    ;   Value2;Value3;;;;;;;   ;"   :12 value strings are found,
                                                    :9 of which are null

    If an invalid component (contains embedded white space) is found in the
    string then this routine attempts to resynch to the next value, no error
    is returned, and a the first part of the invalid value is returned for the
    bad component.

    1.  "    Value1;Bad   Value2; Value3"           : 2 value strings are found

    The value strings returned suppress all whitespace before and after the
    value.


Arguments:

    EnvValue:  ptr to zero terminated environment value string

    EnvVarComponents: ptr to a PWSTR * variable to receive the buffer of
                      ptrs to the constituent value strings.

    PNumComponents: ptr to a ULONG to receive the number of value strings found

Return Value:

    None.

        - *PNumComponent field gets the number of value strings found
        - if the number is non zero the *EnvVarComponents field gets the
          ptr to the buffer containing ptrs to value strings

--*/

{
    PCHAR *Components;
    ULONG Count,i;
    PWSTR *ppwstr;

    //
    // Get components.
    //
    SpGetEnvVarComponents(EnvValue,&Components,&Count);

    ppwstr = SpMemAlloc((Count+1)*sizeof(PWCHAR));
    ASSERT(ppwstr);

    for(i=0; i<Count; i++) {

        ppwstr[i] = SpToUnicode(Components[i]);
        ASSERT(ppwstr[i]);
    }

    ppwstr[Count] = NULL;

    SpFreeEnvVarComponents(Components);

    *PNumComponents = Count;
    *EnvVarComponents = ppwstr;
}


VOID
SpFreeEnvVarComponents (
    IN PVOID *EnvVarComponents
    )
/*++

Routine Description:

    This routine frees up all the components in the ptr array and frees
    up the storage for the ptr array itself too

Arguments:

    EnvVarComponents: the ptr to the PCHAR * or PWSTR * Buffer

Return Value:

    None.

--*/

{
    ASSERT(EnvVarComponents);

    SppFreeComponents(EnvVarComponents);
    SpMemFree(EnvVarComponents);
}


VOID
SppFreeComponents(
    IN PVOID *EnvVarComponents
    )

/*++

Routine Description:

   This routine frees up only the components in the ptr array, but doesn't
   free the ptr array storage itself.

Arguments:

    EnvVarComponents: the ptr to the PCHAR * or PWSTR * Buffer

Return Value:

    None.

--*/

{
    //
    // get all the components and free them
    //
    while(*EnvVarComponents) {
        SpMemFree(*EnvVarComponents++);
    }
}


PWSTR
SpNormalizeArcPath(
    IN PWSTR Path
    )

/*++

Routine Description:

    Transform an ARC path into one with no sets of empty parenthesis
    (ie, transforom all instances of () to (0).).

    The returned path will be all lowercase.

Arguments:

    Path - ARC path to be normalized.

Return Value:

    Pointer to buffer containing normalized path.
    Caller must free this buffer with SpMemFree.

--*/

{
    PWSTR p,q,r;
    PWSTR NormalizedPath;

    NormalizedPath = SpMemAlloc((wcslen(Path)+100)*sizeof(WCHAR));
    ASSERT(NormalizedPath);
    RtlZeroMemory(NormalizedPath,(wcslen(Path)+100)*sizeof(WCHAR));

    for(p=Path; q=wcsstr(p,L"()"); p=q+2) {

        r = NormalizedPath + wcslen(NormalizedPath);
        wcsncpy(r,p,(size_t)(q-p));
        wcscat(NormalizedPath,L"(0)");
    }
    wcscat(NormalizedPath,p);

    NormalizedPath = SpMemRealloc(NormalizedPath,(wcslen(NormalizedPath)+1)*sizeof(WCHAR));
    SpStringToLower(NormalizedPath);
    return(NormalizedPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spbasefile.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    spbasefile.h

Abstract:

    see also
        .\spcab.c
        .\spbasefile.c
        .\spbasefile.h
        windows\winstate\...\cablib.c
        windows\winstate\cobra\utils\main\basefile.c
        windows\winstate\cobra\utils\inc\basefile.h

Author:

    Jay Krell (a-JayK) November 2000

Revision History:

        
--*/
#pragma once

#include "windows.h"

BOOL
SpCreateDirectoryA(
    IN      PCSTR FullPath
    );

BOOL
SpCreateDirectoryW(
    IN      PCWSTR FullPath
    );

HANDLE
SpCreateFile1A(
    IN      PCSTR FileName
    );

HANDLE
SpOpenFile1A(
    IN      PCSTR FileName
    );

HANDLE
SpOpenFile1W(
    IN      PCWSTR FileName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    sources.inc.

!ENDIF

TARGETNAME=setupdd
TARGETPATH=obj
TARGETTYPE=EXPORT_DRIVER

DLLDEF=..\setupdd.def

INCLUDES=..;          \
 ..\i386;             \
 ..\..\inc;           \
 ..\..\user\$(O);     \
 ..\..\..\inc;        \
 ..\..\user;          \
 $(NET_INC_PATH);     \
 $(BASE_INC_PATH);    \
 $(DS_INC_PATH);      \
 $(DDK_INC_PATH);     \
 $(DRIVERS_INC_PATH); \
 $(PROJECT_ROOT)\ntos\inc;

SOURCES=\
 ..\diamond.c   \
 ..\graphics.c  \
 ..\dynupdt.c   \
 ..\sparc.c     \
 ..\spboot.c    \
 ..\spconfig.c  \
 ..\spcopy.c    \
 ..\spdblspc.c  \
 ..\spdisk.c    \
 ..\spdriver.c  \
 ..\spdsputl.c  \
 ..\spfatfmt.c  \
 ..\spfile.c    \
 ..\spfontup.c  \
 ..\spfsrec.c   \
 ..\spgauge.c   \
 ..\sphelp.c    \
 ..\sphw.c      \
 ..\spkbd.c     \
 ..\splddrv.c   \
 ..\spmemory.c  \
 ..\spmenu.c    \
 ..\spmsg.c     \
 ..\spnetupg.c  \
 ..\spntfix.c   \
 ..\spnttree.c  \
 ..\spntupg.c   \
 ..\sppart2.c   \
 ..\sppartit.c  \
 ..\sppart3.c   \
 ..\spswitch.c  \
 ..\spptdump.c  \
 ..\spptwrt.c   \
 ..\spreg.c     \
 ..\spres.rc    \
 ..\spsetup.c   \
 ..\spsif.c     \
 ..\spstring.c  \
 ..\spsysprp.c  \
 ..\sptarget.c  \
 ..\sptxtfil.c  \
 ..\spudp.c     \
 ..\spupgcfg.c  \
 ..\sputil.c    \
 ..\spvideo.c   \
 ..\spvidfb.c   \
 ..\spvidvga.c  \
 ..\spdrsif.c   \
 ..\spdrpset.c  \
 ..\spdrmmgr.c  \
 ..\spdr.c      \
 ..\spdrutil.c  \
 ..\spterm.c    \
 ..\spres.rc    \
 ..\spcab.c     \
 ..\spwin.c     \
 ..\spprintf.c  \

PRECOMPILED_INCLUDE=..\spprecmp.h

!IF $(IA64)
C_DEFINES= $(C_DEFINES) -DUNICODE_SETUPLDR -DEFI_NVRAM_ENABLED
!ENDIF

C_DEFINES=$(C_DEFINES) -DTRY_ALL_COMPRESSION_ALGORITHMS=0

TARGETLIBS= \
    $(PROJECT_ROOT)\ntsetup\complnce\kernel\$(O)\complnce_k.lib \
    $(SDK_LIB_PATH)\fdi.lib    \
    $(SDK_LIB_PATH)\fci.lib    \
    ..\..\spddlang\sbcs\$(O)\spddlang.lib  \
    $(BASE_LIB_PATH)\patchbc.lib    \
    $(BASE_LIB_PATH)\bootvid.lib \

#
# Definition of PRERELEASE
#

!include $(PROJECT_ROOT)\ntsetup\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\sparc.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    sparc.h

Abstract:

    Header file for functions to deal with ARC paths and variables.

Author:

    Ted Miller (tedm) 22-Sep-1993

Revision History:

--*/


#ifndef _SPARC_DEFN_
#define _SPARC_DEFN_

VOID
SpInitializeArcNames(
    PVIRTUAL_OEM_SOURCE_DEVICE  OemDevices
    );

VOID
SpFreeArcNames(
    VOID
    );

PWSTR
SpArcToNt(
    IN PWSTR ArcPath
    );

PWSTR
SpNtToArc(
    IN PWSTR            NtPath,
    IN ENUMARCPATHTYPE  ArcPathType
    );

PWSTR
SpScsiArcToMultiArc(
    IN PWSTR ArcPath
    );

PWSTR
SpMultiArcToScsiArc(
    IN PWSTR ArcPath
    );

PWSTR
SpNormalizeArcPath(
    IN PWSTR Path
    );

VOID
SpGetEnvVarComponents (
    IN  PCHAR    EnvValue,
    OUT PCHAR  **EnvVarComponents,
    OUT PULONG   PNumComponents
    );

VOID
SpGetEnvVarWComponents(
    IN  PCHAR    EnvValue,
    OUT PWSTR  **EnvVarComponents,
    OUT PULONG   PNumComponents
    );

VOID
SpFreeEnvVarComponents (
    IN PVOID *EnvVarComponents
    );

#endif // ndef _SPARC_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spbasefile.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    spbasefile.c

Abstract:

    see also
        .\spcab.c
        .\spbasefile.c
        .\spbasefile.h
        windows\winstate\...\cablib.c
        windows\winstate\cobra\utils\main\basefile.c
        windows\winstate\cobra\utils\inc\basefile.h

Author:

    Jay Krell (a-JayK) November 2000

Revision History:

--*/
#include "spprecmp.h"
#include "spstrings.h"
#include "spbasefile.h"
#include "spbasefilep.h"
#include "spwin.h"
#include "spcab.h"
#include "spcabp.h"

HANDLE
SpCreateFile1A(
    IN PCSTR FileName
    )
{
    HANDLE Handle;

    Handle = SpWin32CreateFileA(
                    FileName,
                    GENERIC_READ|GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

    if (Handle == INVALID_HANDLE_VALUE) {
        Handle = NULL;
    }

    return Handle;
}

PSTR
SpJoinPathsA(
    PCSTR a,
    PCSTR b
    )
{
// UNDONE find code elsewhere in setup that does this already
    PSTR Result = NULL;
    SIZE_T alen = 0;
    SIZE_T blen = 0;

    if (a == NULL)
        goto Exit;
    if (b == NULL)
        goto Exit;
    alen = strlen(a);
    blen = strlen(b);

    Result = SpMemAlloc((alen + blen + 2) * sizeof(*Result));
    if (Result == NULL) {
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(STATUS_NO_MEMORY);
        goto Exit;
    }

    if (alen != 0) {
        strcpy(Result, a);
        if (a[alen - 1] != '\\')
            strcat(Result, "\\");
     }
     strcat(Result, b);
Exit:
    KdPrintEx((DPFLTR_SETUP_ID, SpPointerToDbgPrintLevel(Result), "SETUP:"__FUNCTION__" exiting\n"));
    return Result;
}

HANDLE
SpOpenFile1A(
    IN PCSTR Ansi
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL     Success = FALSE;
    ANSI_STRING    AnsiString   = { 0 };
    UNICODE_STRING UnicodeString = { 0 };
    HANDLE Handle = NULL;
    
    RtlInitAnsiString(&AnsiString, Ansi);
    AnsiString.Length = AnsiString.MaximumLength; // include terminal nul

    if (!NT_SUCCESS(Status = SpAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE)))
        goto NtExit;
    Handle = SpOpenFile1W(UnicodeString.Buffer);
    if (Handle == NULL || Handle == INVALID_HANDLE_VALUE)
        goto Exit;

Exit:
    SpFreeStringW(&UnicodeString);
    KdPrintEx((
        DPFLTR_SETUP_ID,
        SpHandleToDbgPrintLevel(Handle),
        "SETUP:"__FUNCTION__"(%s) exiting %p\n", Ansi, Handle
        ));
    return Handle;
NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

HANDLE
SpOpenFile1W(
    IN PCWSTR FileName
    )
{
    HANDLE Handle;

    Handle = SpWin32CreateFileW(
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                0, // no share
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (Handle == INVALID_HANDLE_VALUE) {
        Handle = NULL;
    }

    return Handle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spbasefilep.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    spbasefilep.h

Abstract:

    see also
        .\spcab.c
        .\spbasefile.c
        .\spbasefile.h
        windows\winstate\...\cablib.c
        windows\winstate\cobra\utils\main\basefile.c
        windows\winstate\cobra\utils\inc\basefile.h

Author:

    Jay Krell (a-JayK) November 2000

Revision History:


--*/
#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spcab.h ===
/*++
Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    spcab.h

Abstract:

    Kernel mode support for cabbing files, esp. for Win9x uninstall.

Author:

    20-Oct-1999 Ovidiu Temereanca (ovidiut) - File creation.

Revision History:

    November 2000 Jay Krell (a-JayK)
        ported from windows\winstate\cobra\utils\inc\cablib.h

--*/
#pragma once

#include "spmemory.h"

// this is a bit of an interface boundary crossing hack, but only experimental at the moment
#define sptcompTYPE_MSZIP_BIG_FILES_NONE_SMALL_FILES 0x0004

//
// Types
//

typedef BOOL(NTAPI CABGETCABINETNAMESA)(
                        IN      PCSTR CabPath,
                        IN      UINT CabPathChars,
                        IN      PCSTR CabFileName,
                        IN      UINT CabFileNameChars,
                        IN      PCSTR CabDiskName,
                        IN      UINT CabDiskNameChars,
                        IN      INT CabFileNr,
                        IN OUT  PINT CabDiskNr
                        );
typedef CABGETCABINETNAMESA *PCABGETCABINETNAMESA;

typedef BOOL(NTAPI CABGETCABINETNAMESW)(
                        IN      PCWSTR CabPath,
                        IN      UINT CabPathChars,
                        IN      PCWSTR CabFileName,
                        IN      UINT CabFileNameChars,
                        IN      PCWSTR CabDiskName,
                        IN      UINT CabDiskNameChars,
                        IN      INT CabFileNr,
                        IN OUT  PINT CabDiskNr
                        );
typedef CABGETCABINETNAMESW *PCABGETCABINETNAMESW;

typedef BOOL(NTAPI CABNOTIFICATIONA)(
                        IN      PCSTR FileName
                        );
typedef CABNOTIFICATIONA *PCABNOTIFICATIONA;

typedef BOOL(NTAPI CABNOTIFICATIONW)(
                        IN      PCWSTR FileName
                        );
typedef CABNOTIFICATIONW *PCABNOTIFICATIONW;

typedef PVOID OCABHANDLE;

        struct _FCI_CAB_HANDLE;
typedef struct _FCI_CAB_HANDLE* PFCI_CAB_HANDLE;
typedef PFCI_CAB_HANDLE CCABHANDLE;

//
// API
//

CCABHANDLE
SpCabCreateCabinetA(
    IN      PCSTR CabPath,
    IN      PCSTR CabFileFormat,
    IN      PCSTR CabDiskFormat,
    IN      LONG MaxFileSize
    );

CCABHANDLE
SpCabCreateCabinetW(
    IN      PCWSTR CabPath,
    IN      PCWSTR CabFileFormat,
    IN      PCWSTR CabDiskFormat,
    IN      LONG   MaxFileSize
    );

CCABHANDLE
SpCabCreateCabinetExA(
    IN      PCABGETCABINETNAMESA CabGetCabinetNames,
    IN      LONG MaxFileSize
    );

CCABHANDLE
SpCabCreateCabinetExW(
    IN      PCABGETCABINETNAMESW CabGetCabinetNames,
    IN      LONG MaxFileSize
    );

NTSTATUS
SpCabAddFileToCabinetW(
    IN      CCABHANDLE CabHandle,
    IN      PCWSTR FileName,
    IN      PCWSTR StoredName
    );

BOOL
SpCabFlushAndCloseCabinetEx(
    IN      CCABHANDLE CabHandle,
    OUT     PUINT FileCount,        OPTIONAL
    OUT     PLONGLONG FileSize,     OPTIONAL
    OUT     PUINT CabFileCount,     OPTIONAL
    OUT     PLONGLONG CabFileSize   OPTIONAL
    );

BOOL
SpCabFlushAndCloseCabinet(
    IN      CCABHANDLE CabHandle
    );

OCABHANDLE
SpCabOpenCabinetA(
    IN      PCSTR FileName
    );

OCABHANDLE
SpCabOpenCabinetW(
    IN      PCWSTR FileName
    );

BOOL
SpCabExtractAllFilesExA(
    IN      OCABHANDLE CabHandle,
    IN      PCSTR ExtractPath,
    IN      PCABNOTIFICATIONA CabNotification   OPTIONAL
    );

BOOL
SpCabExtractAllFilesA(
    IN      OCABHANDLE CabHandle,
    IN      PCSTR ExtractPath
    );

BOOL
SpCabExtractAllFilesExW(
    IN      OCABHANDLE CabHandle,
    IN      PCWSTR ExtractPath,
    IN      PCABNOTIFICATIONW CabNotification   OPTIONAL
    );

BOOL
SpCabExtractAllFilesW(
    IN      OCABHANDLE CabHandle,
    IN      PCWSTR ExtractPath
    );

BOOL
SpCabCloseCabinet(
    IN      OCABHANDLE CabHandle
    );

VOID
SpFreeStringW(
    PUNICODE_STRING String
    );

VOID
SpFreeStringA(
    PANSI_STRING String
    );

NTSTATUS
SpConvertToNulTerminatedNtStringsA(
    PCSTR           Ansi,
    PANSI_STRING    AnsiString     OPTIONAL,
    PUNICODE_STRING UnicodeString  OPTIONAL
    );

NTSTATUS
SpConvertToNulTerminatedNtStringsW(
    PCWSTR          Unicode,
    PANSI_STRING    AnsiString     OPTIONAL,
    PUNICODE_STRING UnicodeString  OPTIONAL
    );

VOID
SpStringCopyNA(
    PSTR Dest,
    PCSTR Source,
    SIZE_T Max
    );

VOID
SpStringCopyNW(
    PWSTR  Dest,
    PCWSTR Source,
    SIZE_T Max
    );

VOID
SpMoveStringA(
    PANSI_STRING Dest,
    PANSI_STRING Source
    );

VOID
SpMoveStringW(
    PUNICODE_STRING Dest,
    PUNICODE_STRING Source
    );

BOOL
SpCabFlushAndCloseCabinet(
    IN      CCABHANDLE CabHandle
    );

BOOL
SpCabCloseCabinet(
    IN      OCABHANDLE CabHandle
    );

NTSTATUS
SpCreateDirectoryForFileA(
    IN PCSTR FilePathA,
    IN ULONG CreateFlags
    );

#define SpBoolToDbgPrintLevel(f)    ((f) ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL)
#define SpBoolToStringA(f)          ((f) ? "true" : "false")
#define SpPointerToDbgPrintLevel(p) DPFLTR_TRACE_LEVEL/*(((p) != NULL && (p) != LongToPtr(-1)) ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL)*/
#define SpHandleToDbgPrintLevel(h)  DPFLTR_TRACE_LEVEL/*(((h) != NULL && (h) != LongToPtr(-1)) ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL)*/
#define SpNtStatusToDbgPrintLevel(s) \
    ((NT_SUCCESS(s) \
     || (s) == STATUS_NO_SUCH_FILE \
     || (s) == STATUS_OBJECT_PATH_NOT_FOUND \
     || (s) == STATUS_OBJECT_NAME_NOT_FOUND \
     || (s) == STATUS_NOT_FOUND \
    ) ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL)

#define SpBooleanToStringA(x) ((x) ? "True" : "False")
#define SpBooleanToStringW(x) ((x) ? L"True" : L"False")

NTSTATUS
SpAnsiStringToUnicodeString(
    PUNICODE_STRING DestinationStringW,
    PCANSI_STRING   SourceStringA,
    BOOL            Allocate
    );

NTSTATUS
SpUnicodeStringToAnsiString(
    PANSI_STRING     DestinationStringA,
    PCUNICODE_STRING SourceStringW,
    BOOL             Allocate
    );

NTSTATUS
SpKnownSizeUnicodeToDbcsN(
    OUT PSTR    Ansi,
    IN  PCWSTR  Unicode,
    IN  SIZE_T  AnsiSize
    );

VOID
SpEnsureTrailingBackSlashA(
    IN PSTR str
    );

PCWSTR
SpGetFileNameFromPathW(
    IN PCWSTR PathSpec
    );

PSTR
SpJoinPathsA(
    PCSTR a,
    PCSTR b
    );

HANDLE
SpOpenFile1W(
    IN      PCWSTR FileName
    );

HANDLE
SpCreateFile1A(
    IN PCSTR FileName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spboot.h ===
/*++

Copyright (c) 1994-2001  Microsoft Corporation

Module Name:

    spboot.h

Abstract:

    Header file for functions to deal with boot variables.

Author:

    Sunil Pai (sunilp) 26-Oct-1993

Revision History:

--*/

#ifndef _SPBOOTVARS_DEFN_
#define _SPBOOTVARS_DEFN_

//
// Define a Unicode string type to be used for storing drive letter
// specifications in upgrade messages (useful because we may not
// have a drive letter, but rather a localizable designator stating
// that the partition is a mirror (eg. "(Mirror):"))
//
typedef WCHAR DRIVELTR_STRING[32];

//
// SP_BOOT_ENTRY is the internal representation of a boot item (or "boot set").
// EFI and ARC NVRAM entries, and boot.ini entries, are kept in this format.
// The NtBootEntry item is the structure passed to/from the NT boot entry APIs.
//
typedef struct _SP_BOOT_ENTRY {
    struct _SP_BOOT_ENTRY *Next;
    PUCHAR AllocationEnd;
    ULONG_PTR Status;
    PWSTR FriendlyName;
    ULONG_PTR FriendlyNameLength;
    PWSTR OsLoadOptions;
    ULONG_PTR OsLoadOptionsLength;
    PFILE_PATH LoaderPath;
    PWSTR LoaderPartitionNtName;
    PDISK_REGION LoaderPartitionDiskRegion;
    PWSTR LoaderFile;
    PFILE_PATH OsPath;
    PWSTR OsPartitionNtName;
    PDISK_REGION OsPartitionDiskRegion;
    PWSTR OsDirectory;
    LOGICAL Processable;
    LOGICAL FailedUpgrade;
    NT_PRODUCT_TYPE ProductType;
    ULONG MajorVersion;
    ULONG MinorVersion;
    ULONG ProductSuiteMask;
    ULONG BuildNumber;
    ULONG ServicePack;
    ULONGLONG KernelVersion;
    LCID LangId;
    PWSTR Pid20Array;
    DRIVELTR_STRING DriveLetterString;
    BOOLEAN UpgradeOnlyCompliance;
    BOOT_ENTRY NtBootEntry;
} SP_BOOT_ENTRY, *PSP_BOOT_ENTRY;

//
//
//
typedef enum {
    UseDefaultSwitches = 0,
    DisableRedirect,
    UseUserDefinedRedirect,
    UseUserDefinedRedirectAndBaudRate
} RedirectSwitchesModeEnum;

#define MAXSIZE_REDIRECT_SWITCH 128

typedef struct _REDIRECT_SWITCHES_ {

    CHAR   port[MAXSIZE_REDIRECT_SWITCH];
    CHAR   baudrate[MAXSIZE_REDIRECT_SWITCH];

} REDIRECT_SWITCHES, PREDIRECT_SWITCHES;

extern RedirectSwitchesModeEnum RedirectSwitchesMode;
extern REDIRECT_SWITCHES RedirectSwitches;

NTSTATUS
SpSetRedirectSwitchMode(
    RedirectSwitchesModeEnum  mode,
    PCHAR                   redirectSwitch,
    PCHAR                   redirectBaudRateSwitch
    );

//
// node for the linked list used to communicate the contents
// of a boot entry outside this library
//
typedef struct _SP_EXPORTED_BOOT_ENTRY_ {
    LIST_ENTRY      ListEntry;
    PWSTR           LoadIdentifier;
    PWSTR           OsLoadOptions;
    WCHAR           DriverLetter;
    PWSTR           OsDirectory;
} SP_EXPORTED_BOOT_ENTRY, *PSP_EXPORTED_BOOT_ENTRY;

NTSTATUS
SpExportBootEntries(
    PLIST_ENTRY     BootEntries,
    PULONG          BootEntryCnt
    );

NTSTATUS
SpFreeExportedBootEntries(
    PLIST_ENTRY     BootEntries,
    ULONG           BootEntryCnt
    );

NTSTATUS
SpAddNTInstallToBootList(
    IN PVOID        SifHandle,
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        SystemPartitionDirectory,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        Sysroot,
    IN PWSTR        OsLoadOptions,      OPTIONAL
    IN PWSTR        LoadIdentifier      OPTIONAL
    );

NTSTATUS
SpAddUserDefinedInstallationToBootList(
    IN PVOID        SifHandle,
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        SystemPartitionDirectory,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        Sysroot,
    IN PWSTR        OSLoadOptions,      OPTIONAL
    IN PWSTR        LoadIdentifier      OPTIONAL
    );

NTSTATUS
SpSetDefaultBootEntry(
    ULONG           BootEntryNumber
    );

#define BE_STATUS_ORDERED           0x00000001
#define BE_STATUS_NEW               0x00000002
#define BE_STATUS_DELETED           0x00000004
#define BE_STATUS_FROM_BOOT_INI     0x00000008

#define IS_BOOT_ENTRY_ACTIVE(_be) \
            (((_be)->NtBootEntry.Attributes & BOOT_ENTRY_ATTRIBUTE_ACTIVE) != 0)
#define IS_BOOT_ENTRY_WINDOWS(_be) \
            (((_be)->NtBootEntry.Attributes & BOOT_ENTRY_ATTRIBUTE_WINDOWS) != 0)
#define IS_BOOT_ENTRY_REMOVABLE_MEDIA(_be) \
            (((_be)->NtBootEntry.Attributes & BOOT_ENTRY_ATTRIBUTE_REMOVABLE_MEDIA) != 0)

#define IS_BOOT_ENTRY_ORDERED(_be) \
            (((_be)->Status & BE_STATUS_ORDERED) != 0)
#define IS_BOOT_ENTRY_NEW(_be) \
            (((_be)->Status & BE_STATUS_NEW) != 0)
#define IS_BOOT_ENTRY_DELETED(_be) \
            (((_be)->Status & BE_STATUS_DELETED) != 0)
#define IS_BOOT_ENTRY_FROM_BOOT_INI(_be) \
            (((_be)->Status & BE_STATUS_FROM_BOOT_INI) != 0)

extern PSP_BOOT_ENTRY SpBootEntries;

BOOLEAN
SpInitBootVars(
    );

VOID
SpFreeBootVars(
    );

VOID
SpUpdateRegionForBootEntries(
    VOID
    );

VOID
SpGetNtDirectoryList(
    OUT PWSTR  **DirectoryList,
    OUT PULONG   DirectoryCount
    );

VOID
SpCleanSysPartOrphan(
    VOID
    );

VOID
SpDetermineUniqueAndPresentBootEntries(
    VOID
    );

VOID
SpAddInstallationToBootList(
    IN PVOID        SifHandle,
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        SystemPartitionDirectory,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        Sysroot,
    IN BOOLEAN      BaseVideoOption,
    IN PWSTR        OldOsLoadOptions OPTIONAL
    );

VOID
SpRemoveInstallationFromBootList(
    IN  PDISK_REGION     SysPartitionRegion,   OPTIONAL
    IN  PDISK_REGION     NtPartitionRegion,    OPTIONAL
    IN  PWSTR            SysRoot,              OPTIONAL
    IN  PWSTR            SystemLoadIdentifier, OPTIONAL
    IN  PWSTR            SystemLoadOptions,    OPTIONAL
    IN  ENUMARCPATHTYPE  ArcPathType,
#if defined(REMOTE_BOOT)
    IN  BOOLEAN          RemoteBootPath,
#endif // defined(REMOTE_BOOT)
    OUT PWSTR            *OldOsLoadOptions     OPTIONAL
    );

VOID
SpPtDeleteBootSetsForRegion(
    PDISK_REGION region
    );    

#if defined(REMOTE_BOOT)
BOOLEAN
SpFlushRemoteBootVars(
    IN PDISK_REGION TargetRegion
    );
#endif // defined(REMOTE_BOOT)

//
// IsArc() is always true on non-x86 machines except AMD64 for which it is
// always false. On x86, this determination has to be made at run time.
//
#ifdef _X86_
BOOLEAN
SpIsArc(
    VOID
    );
#elif defined(_AMD64_)
#define SpIsArc() FALSE
#else
#define SpIsArc() TRUE
#endif

//
// IsEfi() is always true on IA64 machines. Therefore this determination can
// be made at compile time. When x86 EFI machines are supported, the check
// will need to be made at run time on x86.
//
// Note that EFI_NVRAM_ENABLED is defined in ia64\sources.
//
#if defined(EFI_NVRAM_ENABLED)
#if defined(_IA64_)
#define SpIsEfi() TRUE
#else
BOOLEAN
SpIsEfi(
    VOID
    );
#endif
#else
#define SpIsEfi() FALSE
#endif

PWSTR
SpGetDefaultBootEntry (
    OUT UINT *DefaultSignatureOut
    );


#ifdef _X86_
#include "i386\bootini.h"
#endif // def _X86_

#endif // ndef _SPBOOTVARS_DEFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spcab.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    spcab.c

Abstract:

    Cabinet stuff (file compression/decompression)

Author:

    Calin Negreanu (calinn) 27-Apr-2000

Revision History:

    Jay Krell (a-JayK) November 2000 -
        ported from windows\winstate\cobra\utils\cablib\cablib.c to admin\ntsetup\textmode\kernel\spcab.c
        partial nt/unicodification
        gas gauge / progress bar support
--*/

#include "spprecmp.h"
#include "fci.h"
#include "fdi.h"
#include "fcntl.h"
#include "crt/sys/stat.h"
#include "spwin.h"
#include "spcab.h"
#include "spcabp.h"
#include <stdarg.h>
#include "fci.h"
#include "spprintf.h"

/*
PathA on decompression looks like it is set wrong, like it is the full path, including the leaf,
to the .cab, when it is only supposed to be to the directory that contains the .cab.
This is ok, we don't end up using the path, because decompress to fullpaths, not relative paths.
*/

//
// NOTE: fdi opens the cab twice. And we allow that they might seek
// the handles. Thus a small amount of complexity.
//

//
// all these globals except the first should be moved into FDI_CAB_HANDLE.
//
PFDI_CAB_HANDLE g_SpCabFdiHandle;

ANSI_STRING g_CabFileFullPath;
typedef struct _SPCAB_CAB_FILE {
    ULONGLONG Position;
    HANDLE    NtHandle;
    BOOLEAN   Busy;
} SPCAB_CAB_FILE, *PSPCAB_CAB_FILE;
SPCAB_CAB_FILE g_CabFiles[2];
ULONGLONG g_CabFileSize;
ULONGLONG g_CabFileMaximumPosition;
ULONG g_CabLastPercent;
ULONG g_NumberOfOpenCabFiles;

VOID
SpUpdateCabGauge(
    ULONGLONG NewPosition
    )
{
    UINT newPercent;

    if (!RTL_SOFT_VERIFY(g_SpCabFdiHandle != NULL))
        return;
    if (!RTL_SOFT_VERIFY(g_CabFileSize != 0))
        return;

    if (NewPosition > g_CabFileMaximumPosition) {
        g_CabFileMaximumPosition = NewPosition;

        newPercent = (ULONG) (NewPosition * 100 / g_CabFileSize);
        if (newPercent != g_CabLastPercent) {

            g_CabLastPercent = newPercent;
            SpFillGauge (g_SpCabFdiHandle->Gauge, newPercent);

            SendSetupProgressEvent (
                UninstallEvent,
                UninstallUpdateEvent,
                &newPercent
                );
        }
    }
}

BOOLEAN
SpCabIsCabFileName(
    PCSTR FullPath
    )
{
    return g_CabFileFullPath.Buffer != NULL && _stricmp(FullPath, g_CabFileFullPath.Buffer) == 0;
}

PSPCAB_CAB_FILE
SpCabNewCabFile(
    HANDLE NtHandle
    )
{
    ULONG i;

    if (NtHandle == INVALID_HANDLE_VALUE)
        return NULL;

    for (i = 0 ; i < RTL_NUMBER_OF(g_CabFiles) ; ++i) {
        if (!g_CabFiles[i].Busy) {
            g_NumberOfOpenCabFiles += 1;
            g_CabFiles[i].Busy = TRUE;
            g_CabFiles[i].NtHandle = NtHandle;
            g_CabFiles[i].Position = 0;
            return &g_CabFiles[i];
        }
    }
    KdPrint(("SETUP: Ran out of CabFiles g_NumberOfOpenCabFiles:%lu\n", g_NumberOfOpenCabFiles));
    return NULL;
}

VOID
SpCabReleaseCabFile(
    PSPCAB_CAB_FILE CabFile
    )
{
    if (CabFile == NULL)
        return;
    if (!CabFile->Busy)
        return;
    RtlZeroMemory(CabFile, sizeof(*CabFile));
    g_NumberOfOpenCabFiles -= 1;
}

VOID
SpCabCleanupCabGlobals(
    )
{
    ULONG i;

    for (i = 0 ; i < RTL_NUMBER_OF(g_CabFiles) ; ++i) {
        SpCabReleaseCabFile(&g_CabFiles[i]);
    }
    ASSERT(g_NumberOfOpenCabFiles == 0);
    SpDestroyGauge(g_SpCabFdiHandle->Gauge);
    g_SpCabFdiHandle->Gauge = NULL;
    SpFreeStringA(&g_CabFileFullPath);
    g_CabFileSize = 0;
    g_CabFileMaximumPosition = 0;
    g_SpCabFdiHandle = NULL;

    SendSetupProgressEvent (UninstallEvent, UninstallEndEvent, NULL);
}

PSPCAB_CAB_FILE
SpCabFindCabFile(
    HANDLE NtHandle
    )
{
    ULONG i;

    if (NtHandle == INVALID_HANDLE_VALUE)
        return NULL;

    for (i = 0 ; i < RTL_NUMBER_OF(g_CabFiles) ; ++i) {
        if (g_CabFiles[i].NtHandle == NtHandle) {
            return &g_CabFiles[i];
        }
    }
    return NULL;
}


VOID
SpCabCloseHandle(
    HANDLE* HandlePointer
    )
{
    HANDLE Handle = *HandlePointer;

    ASSERT (Handle);    // never NULL

    if (Handle != INVALID_HANDLE_VALUE) {
        *HandlePointer = INVALID_HANDLE_VALUE;
        ZwClose(Handle);
    }
}

INT
DIAMONDAPI
pCabFilePlacedW(
    IN      PCCAB FciCabParams,
    IN      PSTR FileName,
    IN      LONG FileSize,
    IN      BOOL Continuation,
    IN      PVOID Context
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    PFCI_CAB_HANDLE CabHandle = (PFCI_CAB_HANDLE)Context;

    if (CabHandle == NULL)
        return 0;

    CabHandle->FileCount++;
    CabHandle->FileSize += FileSize;

    return 0;
}

PVOID
DIAMONDAPI
pCabAlloc(
    IN      ULONG Size
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    return SpMemAlloc(Size);
}

VOID
DIAMONDAPI
pCabFree(
    IN      PVOID Memory
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    if (Memory != NULL)
        SpMemFree(Memory);
}

INT_PTR
DIAMONDAPI
pCabOpenForWriteA(
    IN      PSTR FileName,
    IN      INT oFlag,
    IN      INT pMode,
    OUT     PINT Error,
    IN      PVOID Context
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    HANDLE FileHandle;

    // oFlag and pMode are prepared for using _open. We won't do that
    // and it's a terrible waste of time to check each individual flags
    // We'll just assert these values.
    ASSERT ((oFlag == (_O_CREAT | _O_TRUNC | _O_BINARY | _O_RDWR)) || (oFlag == (_O_CREAT | _O_EXCL | _O_BINARY | _O_RDWR)));
    ASSERT (pMode == (_S_IREAD | _S_IWRITE));

    FileHandle = SpWin32CreateFileA(
                    FileName,
                    GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_ARCHIVE,
                    NULL
                    );

    ASSERT (FileHandle);    // never NULL

    if (FileHandle == INVALID_HANDLE_VALUE) {
        *Error = SpGetLastWin32Error();
        FileHandle = (HANDLE)(LONG_PTR)-1;
        goto Exit;
    }
    *Error = 0;
Exit:
    KdPrintEx((
        DPFLTR_SETUP_ID,
        SpHandleToDbgPrintLevel(Handle),
        "SETUP:"__FUNCTION__"(%s) exiting with FileHandle: %p Status:0x%08lx Error:%d\n",
        FileName,  FileHandle, SpGetLastNtStatus(), SpGetLastWin32Error()
        ));
    return (INT_PTR)FileHandle;
}

INT_PTR
DIAMONDAPI
pCabOpenForReadA(
    IN      PSTR FileNameA,
    IN      INT oFlag,
    IN      INT pMode
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    const NTSTATUS StatusGaugeInternalError = STATUS_SUCCESS; // STATUS_INTERNAL_ERROR if
                                                              // gauge was really critical
    const NTSTATUS StatusGaugeNoMemory  = STATUS_SUCCESS; // STATUS_NO_MEMORY if
                                                              // gauge was really critical
    PSPCAB_CAB_FILE CabFile = NULL;
    PVOID Gauge = NULL;

    // oFlag and pMode are prepared for using _open. We won't do that
    // and it's a terrible waste of time to check each individual flags
    // We'll just assert these values.
    ASSERT (oFlag == _O_BINARY);

    FileHandle = SpWin32CreateFileA(
                    FileNameA,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_ARCHIVE,
                    NULL
                    );

    ASSERT (FileHandle);    // never NULL
    if (FileHandle == INVALID_HANDLE_VALUE) {
        FileHandle = (HANDLE)(LONG_PTR)-1;
        goto Exit;
    }

    if (SpCabIsCabFileName(FileNameA)) {
        ULONG CabFileSize32 = 0;

        CabFile = SpCabNewCabFile(FileHandle);
        if (CabFile == NULL) {
            Status = StatusGaugeInternalError;
            goto Exit;
        }
        if (!RTL_VERIFY(g_SpCabFdiHandle != NULL)) {
            Status = StatusGaugeInternalError;
            goto Exit;
        }
        ASSERT((g_CabFileSize == 0) == (g_SpCabFdiHandle->Gauge == NULL));

        if (g_CabFileSize == 0) {
            Status = SpGetFileSize(FileHandle, &CabFileSize32);
            //
            // 0 file size causes an unhandled divide by zero exception in the gauge code
            //
            if (NT_SUCCESS(Status) && CabFileSize32 == 0)
                Status = STATUS_UNSUCCESSFUL;
            if (!NT_SUCCESS(Status)) {
                KdPrintEx((
                    DPFLTR_SETUP_ID,
                    SpNtStatusToDbgPrintLevel(Status),
                    __FUNCTION__" SpGetFileSize(.cab:%s, FileHandle:%p) failed Status:0x%08lx\n",
                    FileNameA,
                    FileHandle,
                    Status
                    ));
                Status = STATUS_SUCCESS; // gauge is sacrificable
                goto Exit;
            }
        }
        if (g_SpCabFdiHandle->Gauge == NULL) {

            // need to update the message
            SpFormatMessage (TemporaryBuffer, sizeof(TemporaryBuffer), SP_TEXT_SETUP_IS_COPYING);

            Gauge =
                SpCreateAndDisplayGauge(CabFileSize32, 0, 15,
                    TemporaryBuffer, NULL, GF_PERCENTAGE, 0);
            if (Gauge == NULL) {
                Status = StatusGaugeNoMemory;
                goto Exit;
            }

            g_SpCabFdiHandle->Gauge = Gauge;
            Gauge = NULL;
            g_CabFileSize = CabFileSize32;

            SendSetupProgressEvent (UninstallEvent, UninstallStartEvent, NULL);
        }
        CabFile = NULL;
    }

Exit:
    if (Gauge != NULL)
        SpDestroyGauge(Gauge);
    if (CabFile != NULL)
        SpCabReleaseCabFile(CabFile);

    KdPrintEx((
        DPFLTR_SETUP_ID,
        SpHandleToDbgPrintLevel(Handle),
        __FUNCTION__"(%s) exiting with FileHandle:%p Status:0x%08lx Error:%d\n",
        FileNameA,  FileHandle, SpGetLastNtStatus(), SpGetLastWin32Error()
        ));
    return (INT_PTR)FileHandle;
}

UINT
DIAMONDAPI
pCabRead(
    IN      INT_PTR FileHandleInteger,
    IN      PVOID Buffer,
    IN      UINT Size,
    OUT     PINT Error,          OPTIONAL
    IN      PVOID ContextIgnored OPTIONAL
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    BOOL Result;
    UINT BytesRead;
    HANDLE FileHandle = (HANDLE)FileHandleInteger;
    PSPCAB_CAB_FILE CabFile = NULL;

    Result = SpWin32ReadFile(FileHandle, Buffer, Size, &BytesRead, NULL);
    if (!Result) {
        if (Error != NULL) {
            *Error = SpGetLastWin32Error();
        }
        return ((UINT)(-1));
    }

    if (CabFile = SpCabFindCabFile(FileHandle)) {
        CabFile->Position += BytesRead;

        SpUpdateCabGauge(CabFile->Position);
    }

    if (Error != NULL) {
        *Error = 0;
    }
    return BytesRead;
}

UINT
DIAMONDAPI
pCabRead1(
    IN      INT_PTR FileHandleInteger,
    IN      PVOID Buffer,
    IN      UINT Size
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    const UINT i = pCabRead(FileHandleInteger, Buffer, Size, NULL, NULL);
    return i;
}

UINT
DIAMONDAPI
pCabWrite(
    IN      INT_PTR FileHandleInteger,
    IN      PVOID Buffer,
    IN      UINT Size,
    OUT     PINT Error,
    IN      PVOID Context
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    BOOL Result;
    DWORD BytesWritten;
    HANDLE FileHandle = (HANDLE)FileHandleInteger;

    //
    // g_CabNtFileHandle is only set for reading, so..
    //
    ASSERT(SpCabFindCabFile(FileHandle) == NULL);

    Result = SpWin32WriteFile(FileHandle, Buffer, Size, &BytesWritten, NULL/*overlapped*/);
    if (!Result) {
        *Error = SpGetLastWin32Error();
        return (UINT)-1;
    }
    else if (BytesWritten != Size) {
        *Error = -1;
        return (UINT)-1;
    }
    *Error = 0;
    return Size;
}

UINT
DIAMONDAPI
pCabWrite1(
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size
    )

/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/

{
    INT ErrorIgnored;
    const PVOID ContextIgnored = NULL;

    const BOOL Result = pCabWrite(FileHandle, Buffer, Size, &ErrorIgnored, ContextIgnored);

    return Result;
}

INT
DIAMONDAPI
pCabClose(
    IN      INT_PTR FileHandleInteger,
    OUT     PINT Error,
    IN      PVOID Context
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    HANDLE Handle = (HANDLE)FileHandleInteger;
    PSPCAB_CAB_FILE CabFile = NULL;

    if (CabFile = SpCabFindCabFile(Handle)) {
        SpCabReleaseCabFile(CabFile);
    }

    SpCabCloseHandle(&Handle);
    if (Error != NULL) {
        *Error = 0;
    }
    return 0;
}

INT
DIAMONDAPI
pCabClose1(
    IN      INT_PTR FileHandleInteger
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    const INT Result = pCabClose(FileHandleInteger, NULL, NULL);
    return Result;
}

LONG
DIAMONDAPI
pCabSeek(
    IN      INT_PTR FileHandleInteger,
    IN      LONG Distance,
    IN      INT CrtSeekType,
    OUT     PINT Error,
    IN      PVOID Context
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    ULONG NewPosition = 0;
    ULONG Win32SeekType = FILE_BEGIN;
    HANDLE FileHandle = (HANDLE)FileHandleInteger;
    PSPCAB_CAB_FILE CabFile = NULL;

    CabFile = SpCabFindCabFile (FileHandle);

    switch (CrtSeekType) {
    case SEEK_SET:
        Win32SeekType = FILE_BEGIN;
        break;
    case SEEK_CUR:
        Win32SeekType = FILE_CURRENT;
        break;
    case SEEK_END:
        Win32SeekType = FILE_END;
        break;
    }

    NewPosition = SpSetFilePointer(FileHandle, Distance, NULL, Win32SeekType);

    if (NewPosition == INVALID_SET_FILE_POINTER) {
        if (Error != NULL) {
            *Error = SpGetLastWin32Error();
        }
        return -1;
    }
    if (Error != NULL) {
        *Error = 0;
    }

    if (CabFile != NULL) {
        SpUpdateCabGauge(CabFile->Position = NewPosition);
    }

    return ((LONG)(NewPosition));
}

LONG
DIAMONDAPI
pCabSeek1(
    IN      INT_PTR FileHandleInteger,
    IN      LONG Distance,
    IN      INT CrtSeekType
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    const LONG NewPosition = pCabSeek(FileHandleInteger, Distance, CrtSeekType, NULL, NULL);
    return NewPosition;
}

INT
DIAMONDAPI
pCabDeleteA(
    IN      PSTR FileName,
    OUT     PINT Error,
    IN      PVOID Context
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    if (!SpWin32DeleteFileA(FileName)) {
        *Error = SpGetLastWin32Error();
        return -1;
    }
    *Error = 0;
    return 0;
}

BOOL
DIAMONDAPI
pCabGetTempFileA(
    OUT     PSTR FileName,
    IN      INT FileNameLen,
    IN      PVOID Context
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    static LARGE_INTEGER Counter = { 0 };
    PFCI_CAB_HANDLE cabHandle;

    cabHandle = (PFCI_CAB_HANDLE) Context;
    if (cabHandle == NULL) {
        ASSERT (FALSE);
        return FALSE;
    }

    ASSERT(FileNameLen >= 256);

    FileName[FileNameLen - 1] = 0;

    //
    // Seeding the counter based on the time should increase reliability
    // in the face of crash/rerun cycles, compared to just starting it at 0.
    //
    // We should/could also/instead loop while the resulting name exists,
    // but I'm putting this in after having tested, so stick with this simpler change.
    //
    if (Counter.QuadPart == 0) {
        KeQuerySystemTime(&Counter); // NtQuerySystemTime in usermode
    }

    Counter.QuadPart += 1;

    _snprintf(FileName, FileNameLen - 1, "%hs\\spcab%I64d", cabHandle->PathA.Buffer, Counter.QuadPart);

    KdPrintEx((
        DPFLTR_SETUP_ID,
        DPFLTR_TRACE_LEVEL,
        __FUNCTION__":%s\n",
        FileName
        ));

    return TRUE;
}

BOOL
DIAMONDAPI
pCabGetNextCabinet(
     IN     PCCAB FciCabParams,
     IN     ULONG PrevCabinetSize,
     IN     PVOID Context
     )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    ASSERTMSG("We fit in a single cabinet.", FALSE);
    return FALSE;
}

LONG
DIAMONDAPI
pCabStatus(
    IN      UINT StatusType,
    IN      ULONG Size1,
    IN      ULONG Size2,
    IN      PVOID Context
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    PFCI_CAB_HANDLE CabHandle = NULL;

    if (StatusType == statusCabinet) {

        CabHandle = (PFCI_CAB_HANDLE) Context;
        if (CabHandle == NULL) {
            return 0;
        }

        CabHandle->CabCount++;
        CabHandle->CompressedSize += Size2;
    }
    return 0;
}

INT_PTR
DIAMONDAPI
pCabGetOpenInfoA(
    IN      PSTR    FileName,
    OUT     USHORT* Date,
    OUT     USHORT* Time,
    OUT     USHORT* Attributes,
    OUT     PINT    Error,
    IN      PVOID   Context
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    FILETIME LocalFileTime = { 0 };
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    BOOL     DoesFileExist = FALSE;
    WIN32_FILE_ATTRIBUTE_DATA FileAttributeData = { 0 };

    //
    // It seems like it'd be better to open the file, and if that succeeds,
    // get the information from the handle. Anyway, we just mimic the winstate code for now.
    //

    DoesFileExist = SpGetFileAttributesExA(FileName, GetFileExInfoStandard, &FileAttributeData);
    if (DoesFileExist) {

        SpFileTimeToLocalFileTime(&FileAttributeData.ftLastWriteTime, &LocalFileTime);
        SpFileTimeToDosDateTime(&LocalFileTime, Date, Time);

        /*
         * Mask out all other bits except these four, since other
         * bits are used by the cabinet format to indicate a
         * special meaning.
         */
        *Attributes = (USHORT) (FileAttributeData.dwFileAttributes & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE));

        FileHandle = SpWin32CreateFileA(
                        FileName,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

        ASSERT (FileHandle);    // never NULL
        if (FileHandle == INVALID_HANDLE_VALUE) {
            *Error = SpGetLastWin32Error();
            return -1;
        }
        *Error = 0;
        return (INT_PTR)FileHandle;
    } else {
        *Error = SpGetLastWin32Error();
        return -1;
    }
}

BOOLEAN
SpCabIsFullPath(
    PCANSI_STRING p
    )
{
    const ULONG Length = p->Length / sizeof(p->Buffer[0]);
    if (Length < 4)
        return FALSE;
    if (p->Buffer[0] == '\\' && p->Buffer[1] == '\\')
        return TRUE;
    if (p->Buffer[1] == ':' && p->Buffer[2] == '\\')
        return TRUE;
    if (   p->Buffer[0] == '\\'
        && p->Buffer[1] == '?'
        && p->Buffer[2] == '?'
        && p->Buffer[3] == '\\'
        )
        return TRUE;
    if (    p->Buffer[0] == '\\'
        && (p->Buffer[1] == 'D' || p->Buffer[1] == 'd' )
        && (p->Buffer[2] == 'E' || p->Buffer[2] == 'e' )
        && (p->Buffer[3] == 'V' || p->Buffer[3] == 'v' )
        )
        return TRUE;
    KdPrint(("SETUP: Warning: "__FUNCTION__"(%Z):FALSE\n", p));
    return FALSE;
}


VOID
pRecordDataLoss (
    VOID
    )

/*++

Routine Description:

  This routine creates a file called dataloss, so that the backup
  CABs don't get removed from the system.

Arguments:

  None.

Return Value:

  None.

--*/

{
    UNICODE_STRING  UnicodeString;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;
    NTSTATUS Status;

    //
    // We failed to create the subdirectory for this file.
    // Put a file in the ~bt directory to prevent the undo
    // directory from being removed.
    //

    wcscpy (TemporaryBuffer, NtBootDevicePath);
    SpConcatenatePaths (TemporaryBuffer, DirectoryOnBootDevice);
    SpConcatenatePaths (TemporaryBuffer, L"dataloss");

    INIT_OBJA (&obja, &UnicodeString, TemporaryBuffer);

    Status = ZwCreateFile(
                &Handle,
                FILE_GENERIC_WRITE|SYNCHRONIZE|FILE_READ_ATTRIBUTES,
                &obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                0,
                FILE_CREATE,
                FILE_SYNCHRONOUS_IO_NONALERT|FILE_NON_DIRECTORY_FILE,
                NULL,
                0
                );

    if (NT_SUCCESS(Status)) {
        ZwClose (Handle);
    }
}




INT_PTR
DIAMONDAPI
pCabNotification(
    IN      FDINOTIFICATIONTYPE FdiNotificationType,
    IN OUT  PFDINOTIFICATION FdiNotification
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    PSTR DestFileA = NULL;
    ANSI_STRING DestFileStringA = { 0 };
    UNICODE_STRING DestFileStringW = { 0 };
    HANDLE DestHandle = INVALID_HANDLE_VALUE;
    ULONG FileAttributes = 0;
    FILETIME LocalFileTime = { 0 };
    FILETIME FileTime = { 0 };
    PCAB_DATA CabData = NULL;
    INT_PTR Result = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    PCSTR psz1 = NULL;
    ANSI_STRING psz1String = { 0 };
    UNICODE_STRING NtPathString = { 0 };
    WCHAR ntPathTemp[ACTUAL_MAX_PATH];
    CHAR ntPath[ACTUAL_MAX_PATH];
    BOOLEAN b;
    
    switch (FdiNotificationType) {
    case fdintCABINET_INFO:     // General information about cabinet
        break;
    case fdintCOPY_FILE:        // File to be copied
        CabData = (PCAB_DATA)FdiNotification->pv;
        psz1 = FdiNotification->psz1;
        
        {
            RtlInitAnsiString(&psz1String, psz1);
            psz1String.Length = psz1String.MaximumLength; // include terminal nul
            Status = RtlAnsiStringToUnicodeString(&NtPathString, &psz1String, TRUE);
            if (!NT_SUCCESS(Status)) {
                KdPrintEx((
                    DPFLTR_SETUP_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SETUP: Cannot convert ansi string %s to nt\n",
                    psz1String.Buffer
                    ));
                goto NtExit;
            }

            b = SpNtNameFromDosPath (
                    NtPathString.Buffer,
                    ntPathTemp,
                    ACTUAL_MAX_PATH * sizeof (WCHAR),
                    PartitionOrdinalCurrent
                    );
            
            RtlFreeUnicodeString(&NtPathString);

            if (!b) {
                KdPrintEx((
                    DPFLTR_SETUP_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SETUP: Cannot convert path %ws to an NT path\n",
                    NtPathString.Buffer
                    ));
                goto Exit;
            }
            
            RtlInitUnicodeString(&NtPathString, ntPathTemp);
            NtPathString.Length = NtPathString.MaximumLength; // include terminal nul
            
            psz1String.Buffer = (PSTR)ntPath;
            psz1String.Length = 0;
            psz1String.MaximumLength = ACTUAL_MAX_PATH * sizeof (CHAR);
            Status = RtlUnicodeStringToAnsiString(&psz1String, &NtPathString, FALSE);
            if (!NT_SUCCESS(Status)) {
                KdPrintEx((
                    DPFLTR_SETUP_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SETUP: Cannot convert nt string %ws to ansi\n",
                    NtPathString.Buffer
                    ));
                goto NtExit;
            }
            
            psz1 = psz1String.Buffer;
        }
        
        if (SpCabIsFullPath(&psz1String)) {
            //
            // This is always the case in Win9x uninstall.
            //
            DestFileA = SpDupString(psz1);
        }
        else {
            DestFileA = SpJoinPathsA(CabData->ExtractPathA.Buffer, psz1);
        }

        if (DestFileA == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }

        if (CabData->NotificationA != NULL) {
            if (CabData->NotificationA(DestFileA)) {
                Status = SpCreateDirectoryForFileA(DestFileA, CREATE_DIRECTORY_FLAG_SKIPPABLE);

                if (!NT_SUCCESS(Status)) {
                    pRecordDataLoss();

                    Result = 0;
                    goto Exit;
                }

                DestHandle = SpCreateFile1A(DestFileA);
                ASSERT (DestHandle);    // never NULL
            }
        } else if (CabData->NotificationW != NULL) {

            RtlInitAnsiString(&DestFileStringA, DestFileA);
            DestFileStringA.Length = DestFileStringA.MaximumLength; // include terminal nul
            Status = SpAnsiStringToUnicodeString(&DestFileStringW, &DestFileStringA, TRUE);

            if (!NT_SUCCESS(Status)) {
                goto NtExit;
            }

            if (CabData->NotificationW(DestFileStringW.Buffer)) {
                //
                // Ensure the directory exists. If we can't create the
                // dir, then record data loss and skip the file.
                //

                Status = SpCreateDirectoryForFileA(DestFileA, CREATE_DIRECTORY_FLAG_SKIPPABLE);
                if (!NT_SUCCESS(Status)) {
                    pRecordDataLoss();

                    Result = 0;
                    goto Exit;
                }

                DestHandle = SpCreateFile1A(DestFileA);
                ASSERT (DestHandle);    // never NULL
            }
        } else {
            DestHandle = SpCreateFile1A(DestFileA);
            ASSERT (DestHandle);    // never NULL
        }

        Result = (INT_PTR)DestHandle;

        //
        // If SpCreateFile1A fails, then enable preservation of
        // the backup cabs, but don't fail uninstall.
        //

        if (Result == -1) {
            pRecordDataLoss();

            Result = 0;
            goto Exit;
        }

        goto Exit;

    case fdintCLOSE_FILE_INFO:  // close the file, set relevant info
        CabData = (PCAB_DATA)FdiNotification->pv;
        if (SpDosDateTimeToFileTime(FdiNotification->date, FdiNotification->time, &LocalFileTime)) {
            if (SpLocalFileTimeToFileTime(&LocalFileTime, &FileTime)) {
                //
                // error here is probably ignorable..
                //
                SpSetFileTime((HANDLE)FdiNotification->hf, &FileTime, &FileTime, &FileTime);
            }
        }
        SpCabCloseHandle((HANDLE*)(&FdiNotification->hf));

        psz1 = FdiNotification->psz1;
        RtlInitAnsiString(&psz1String, psz1);

        if (SpCabIsFullPath(&psz1String)) {
            //
            // This is always the case in Win9x uninstall.
            //
            DestFileA = SpDupString(psz1);
        }
        else {
            DestFileA = SpJoinPathsA(CabData->ExtractPathA.Buffer, psz1);
        }

        FileAttributes = (FdiNotification->attribs & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE));
        if (DestFileA != NULL) {
            //
            // error here is probably ignorable..
            //
            SpSetFileAttributesA(DestFileA, FileAttributes);
        }
        Result = TRUE;
        break;
    case fdintPARTIAL_FILE:     // First file in cabinet is continuation
        break;
    case fdintENUMERATE:        // Enumeration status
        break;
    case fdintNEXT_CABINET:     // File continued to next cabinet
        break;
    }
Exit:
    
    if (DestFileA != NULL){
        SpMemFree(DestFileA);
    }
    
    SpFreeStringW(&DestFileStringW);
    KdPrintEx((
        DPFLTR_SETUP_ID,
        SpNtStatusToDbgPrintLevel(Status),
        "SETUP:"__FUNCTION__" exiting Status:0x%08lx Error:%d\n",
        SpGetLastNtStatus(), SpGetLastWin32Error()));
    return Result;
NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

CCABHANDLE
SppCabCreateCabinet(
    PANSI_STRING    CabPathA,
    PANSI_STRING    CabFileFormatA,
    PANSI_STRING    CabDiskFormatA,
    PUNICODE_STRING CabPathW,
    PUNICODE_STRING CabFileFormatW,
    PUNICODE_STRING CabDiskFormatW,
    IN LONG         MaxFileSize
    )
/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  CabPathA - Specifies the path where the new cabinet file will be.

  CabFileFormat - Specifies (as for wsprintf) the format of the cabinet file name.

  CabDiskFormat - Specifies (as for wsprintf) the format of the cabinet disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/
{
    PFCI_CAB_HANDLE CabHandle = NULL;
    PFCI_CAB_HANDLE CabHandleRet = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    if (CabFileFormatA == NULL
        && CabFileFormatW == NULL
        ) {
        Status = STATUS_INVALID_PARAMETER;
        goto NtExit;
    }
    if (MaxFileSize < 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto NtExit;
    }

    if (MaxFileSize == 0) {
        MaxFileSize = 0x7FFFFFFF;
    }

    CabHandle = (PFCI_CAB_HANDLE)SpMemAlloc(sizeof (*CabHandle));
    if (CabHandle == NULL) {
        Status  = STATUS_NO_MEMORY;
        goto NtExit;
    }
    RtlZeroMemory(CabHandle, sizeof(*CabHandle));

#if DBG
    KeQuerySystemTime(&CabHandle->StartTime);
#endif

    SpMoveStringA(&CabHandle->PathA, CabPathA);
    SpMoveStringA(&CabHandle->FileFormatA, CabFileFormatA);
    SpMoveStringA(&CabHandle->DiskFormatA, CabDiskFormatA);
    SpMoveStringW(&CabHandle->PathW, CabPathW);
    SpMoveStringW(&CabHandle->FileFormatW, CabFileFormatW);
    SpMoveStringW(&CabHandle->DiskFormatW, CabDiskFormatW);

    // fill out the CCAB structure (other than the zeros)
    CabHandle->FciCabParams.cb = MaxFileSize;
    CabHandle->FciCabParams.cbFolderThresh = MaxFileSize;
    CabHandle->FciCabParams.iCab = 1;
    CabHandle->FciCabParams.iDisk = 1;

    if (CabHandle->PathA.Buffer != NULL && CabHandle->PathA.Buffer[0] != 0) {
        SpStringCopyNA(CabHandle->FciCabParams.szCabPath, CabHandle->PathA.Buffer, RTL_NUMBER_OF(CabHandle->FciCabParams.szCabPath) - 2);
        SpEnsureTrailingBackSlashA(CabHandle->FciCabParams.szCabPath);
    }
    if (CabHandle->DiskFormatA.Buffer != NULL && CabHandle->DiskFormatA.Buffer[0] != 0) {
        SpFormatStringA(CabHandle->FciCabParams.szDisk, RTL_NUMBER_OF(CabHandle->FciCabParams.szDisk), CabHandle->DiskFormatA.Buffer, CabHandle->FciCabParams.iDisk);
    }
    if (CabHandle->FileFormatA.Buffer != NULL && CabHandle->FileFormatA.Buffer[0] != 0) {
        SpFormatStringA(CabHandle->FciCabParams.szCab, RTL_NUMBER_OF(CabHandle->FciCabParams.szCab), CabHandle->FileFormatA.Buffer, CabHandle->FciCabParams.iCab);
    }

    CabHandle->FciHandle = FCICreate(
                                &CabHandle->FciErrorStruct,
                                pCabFilePlacedA,
                                pCabAlloc,
                                pCabFree,
                                pCabOpenForWriteA,
                                pCabRead,
                                pCabWrite,
                                pCabClose,
                                pCabSeek,
                                pCabDeleteA,
                                pCabGetTempFileA,
                                &CabHandle->FciCabParams,
                                CabHandle
                                );
    if (CabHandle->FciHandle == NULL)
        goto Exit;

    CabHandleRet = CabHandle;
    CabHandle = NULL;
Exit:
    if (CabHandle != NULL) {
        SpCabFlushAndCloseCabinet(CabHandle);
        CabHandle = NULL;
    }
    KdPrintEx((
        DPFLTR_SETUP_ID,
        SpHandleToDbgPrintLevel(CabHandleRet),
        "SETUP:"__FUNCTION__" exiting Handle:%p Status:0x%08lx Error:%d\n",
        CabHandleRet, SpGetLastNtStatus(), SpGetLastWin32Error()));
    return CabHandleRet;
NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

CCABHANDLE
SpCabCreateCabinetW(
    IN      PCWSTR CabPathW,
    IN      PCWSTR CabFileFormatW,
    IN      PCWSTR CabDiskFormatW,
    IN      LONG MaxFileSize
    )
/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  CabPathW - Specifies the path where the new cabinet file will be.

  CabFileFormat - Specifies (as for wsprintf) the format of the cabinet file name.

  CabDiskFormat - Specifies (as for wsprintf) the format of the cabinet disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/
{
    ANSI_STRING    CabPathStringA = { 0 };
    ANSI_STRING    CabFileFormatStringA = { 0 };
    ANSI_STRING    CabDiskFormatStringA = { 0 };
    UNICODE_STRING CabPathStringW = { 0 };
    UNICODE_STRING CabFileFormatStringW = { 0 };
    UNICODE_STRING CabDiskFormatStringW = { 0 };
    CCABHANDLE      CabHandle = NULL;
    NTSTATUS        Status = STATUS_SUCCESS;

    KdPrintEx((
        DPFLTR_SETUP_ID,
        DPFLTR_TRACE_LEVEL,
        __FUNCTION__"(%ls, %ls, %ls)\n", CabPathW, CabFileFormatW, CabDiskFormatW
        ));

    Status = SpConvertToNulTerminatedNtStringsW(CabPathW, &CabPathStringA, &CabPathStringW);
    if (!NT_SUCCESS(Status))
        goto NtExit;
    Status = SpConvertToNulTerminatedNtStringsW(CabFileFormatW, &CabFileFormatStringA, &CabFileFormatStringW);
    if (!NT_SUCCESS(Status))
        goto NtExit;
    Status = SpConvertToNulTerminatedNtStringsW(CabDiskFormatW, &CabDiskFormatStringA, &CabDiskFormatStringW);
    if (!NT_SUCCESS(Status))
        goto NtExit;

    CabHandle =
        SppCabCreateCabinet(
            &CabPathStringA,
            &CabFileFormatStringA,
            &CabDiskFormatStringA,
            &CabPathStringW,
            &CabFileFormatStringW,
            &CabDiskFormatStringW,
            MaxFileSize
            );

Exit:
    SpFreeStringA(&CabDiskFormatStringA);
    SpFreeStringA(&CabFileFormatStringA);
    SpFreeStringA(&CabPathStringA);
    SpFreeStringW(&CabDiskFormatStringW);
    SpFreeStringW(&CabFileFormatStringW);
    SpFreeStringW(&CabPathStringW);
    KdPrintEx((
        DPFLTR_SETUP_ID,
        SpHandleToDbgPrintLevel(CabHandle),
        "SETUP:"__FUNCTION__" exiting Handle:%p Status:0x%08lx Error:%d\n",
        CabHandle, SpGetLastNtStatus(), SpGetLastWin32Error()));
    return CabHandle;
NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

CCABHANDLE
SppCabCreateCabinetEx(
    IN      PCABGETCABINETNAMESA GetCabinetNamesA,
    IN      PCABGETCABINETNAMESW GetCabinetNamesW,
    IN      LONG MaxFileSize
    )
/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  GetCabinetNames - Specifies a callback used to decide cabinet path, cabinet name and disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/
{
    PFCI_CAB_HANDLE CabHandle = NULL;
    PFCI_CAB_HANDLE CabHandleRet = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    typedef struct FRAME {
        WCHAR szDisk[CB_MAX_DISK_NAME];
        WCHAR szCab[CB_MAX_CABINET_NAME];
        WCHAR szCabPath[CB_MAX_CAB_PATH];
    } FRAME, *PFRAME;
    PFRAME Frame = NULL;

    if (GetCabinetNamesA == NULL && GetCabinetNamesW == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto NtExit;
    }
    if (MaxFileSize < 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto NtExit;
    }
    if (MaxFileSize == 0) {
        MaxFileSize = 0x80000000;
    }

    CabHandle = (PFCI_CAB_HANDLE)SpMemAlloc(sizeof(*CabHandle));
    if (CabHandle == NULL) {
        Status  = STATUS_NO_MEMORY;
        goto NtExit;
    }
    RtlZeroMemory(CabHandle, sizeof(*CabHandle));
    CabHandle->GetCabinetNamesA = GetCabinetNamesA;
    CabHandle->GetCabinetNamesW = GetCabinetNamesW;

    // fill out the CCAB structure
    CabHandle->FciCabParams.cb = MaxFileSize;
    CabHandle->FciCabParams.cbFolderThresh = MaxFileSize;
    CabHandle->FciCabParams.iCab = 1;
    CabHandle->FciCabParams.iDisk = 1;
    if (GetCabinetNamesA != NULL) {
        if (!GetCabinetNamesA(
                CabHandle->FciCabParams.szCabPath,
                RTL_NUMBER_OF(CabHandle->FciCabParams.szCabPath),
                CabHandle->FciCabParams.szCab,
                RTL_NUMBER_OF(CabHandle->FciCabParams.szCab),
                CabHandle->FciCabParams.szDisk,
                RTL_NUMBER_OF(CabHandle->FciCabParams.szDisk),
                CabHandle->FciCabParams.iCab,
                &CabHandle->FciCabParams.iDisk
                )) {
            goto Exit;
        }
    }
    else if (GetCabinetNamesW != NULL) {
        Frame = (PFRAME)SpMemAlloc(sizeof(*Frame));
        if (Frame == NULL) {
            Status = STATUS_NO_MEMORY;
            goto NtExit;
        }
        if (!GetCabinetNamesW(
                Frame->szCabPath,
                RTL_NUMBER_OF(Frame->szCabPath),
                Frame->szCab,
                RTL_NUMBER_OF(Frame->szCab),
                Frame->szDisk,
                RTL_NUMBER_OF(Frame->szDisk),
                CabHandle->FciCabParams.iCab,
                &CabHandle->FciCabParams.iDisk
                )) {
            goto Exit;
        Status = SpKnownSizeUnicodeToDbcsN(CabHandle->FciCabParams.szCabPath, Frame->szCabPath, RTL_NUMBER_OF(CabHandle->FciCabParams.szCabPath));
        if (!NT_SUCCESS(Status))
            goto NtExit;
        Status = SpKnownSizeUnicodeToDbcsN(CabHandle->FciCabParams.szCab, Frame->szCab, RTL_NUMBER_OF(CabHandle->FciCabParams.szCab));
        if (!NT_SUCCESS(Status))
            goto NtExit;
        Status = SpKnownSizeUnicodeToDbcsN(CabHandle->FciCabParams.szDisk, Frame->szDisk, RTL_NUMBER_OF(CabHandle->FciCabParams.szDisk));
        if (!NT_SUCCESS(Status))
            goto NtExit;
        }
    }
    CabHandle->FciHandle = FCICreate(
                                &CabHandle->FciErrorStruct,
                                pCabFilePlacedA,
                                pCabAlloc,
                                pCabFree,
                                pCabOpenForWriteA,
                                pCabRead,
                                pCabWrite,
                                pCabClose,
                                pCabSeek,
                                pCabDeleteA,
                                pCabGetTempFileA,
                                &CabHandle->FciCabParams,
                                CabHandle
                                );
    if (CabHandle->FciHandle == NULL)
        goto Exit;
    CabHandleRet = CabHandle;
    CabHandle = NULL;
Exit:
    if (CabHandle != NULL) {
        SpCabFlushAndCloseCabinet(CabHandle);
        goto Exit;
    }
    if (Frame != NULL)
        SpMemFree(Frame);
    KdPrintEx((
        DPFLTR_SETUP_ID,
        SpHandleToDbgPrintLevel(CabHandleRet),
        "SETUP:"__FUNCTION__" exiting Handle:%p Status:0x%08lx Error:%d\n",
        CabHandleRet, SpGetLastNtStatus(), SpGetLastWin32Error()));
    return (CCABHANDLE)CabHandleRet;
NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

CCABHANDLE
SpCabCreateCabinetExW(
    IN      PCABGETCABINETNAMESW GetCabinetNamesW,
    IN      LONG MaxFileSize
    )
/*++

Routine Description:

  Creates a cabinet context. Caller may use this context for subsequent calls to
  CabAddFile.

Arguments:

  CabGetCabinetNames - Specifies a callback used to decide cabinet path, cabinet name and disk name.

  MaxFileSize - Specifies maximum size of the cabinet file (limited to 2GB). if 0 => 2GB

Return Value:

  a valid CCABHANDLE if successful, NULL otherwise.

--*/
{
    const PFCI_CAB_HANDLE CabHandle = SppCabCreateCabinetEx(NULL, GetCabinetNamesW, MaxFileSize);
    return CabHandle;
}

TCOMP
SpCabGetCompressionTypeForFile(
    PFCI_CAB_HANDLE CabHandle,
    IN PCWSTR FileName
    )
/*++
don't compress small files
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    TCOMP CompressionType = tcompTYPE_MSZIP;
    ULONG FileSize = 0;
    ULONG SmallFileSize = 4096;
    HANDLE FileHandle = NULL;
    UNICODE_STRING    UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes = RTL_INIT_OBJECT_ATTRIBUTES(&UnicodeString, OBJ_CASE_INSENSITIVE);
    IO_STATUS_BLOCK IoStatusBlock;

    RtlInitUnicodeString(&UnicodeString, FileName);

    if (CabHandle != NULL) {
        if (CabHandle->SmallFileCompressionType == CabHandle->CompressionType)
            return CabHandle->CompressionType;
        if (CabHandle->SmallFileSize != 0)
            SmallFileSize = CabHandle->SmallFileSize;
        CompressionType = CabHandle->CompressionType;
    }

    Status =
        ZwOpenFile(
            &FileHandle,
            FILE_GENERIC_READ | FILE_GENERIC_WRITE,
            &ObjectAttributes,
            &IoStatusBlock,
            0,
            FILE_SYNCHRONOUS_IO_NONALERT);
    if (!NT_SUCCESS(Status))
        goto Exit;

    Status = SpGetFileSize(FileHandle, &FileSize);
    if (!NT_SUCCESS(Status))
        goto Exit;

    if (FileSize < SmallFileSize)
        Status = tcompTYPE_NONE;
Exit:
    SpCabCloseHandle(&FileHandle);
    return CompressionType;
}

NTSTATUS
SpCabAddFileToCabinetW(
    IN      CCABHANDLE Handle,
    IN      PCWSTR FileNameW,
    IN      PCWSTR StoredNameW
    )
/*++

Routine Description:

  Compresses and adds a file to a cabinet context.

Arguments:

  CabHandle - Specifies cabinet context.

  FileNameW - Specifies the file to be added.

  StoredNameW - Specifies the name to be stored in the cabinet file.

  FileCount - Specifies a count of files, receives the updated count
              when cabinet files are created

  FileSize - Specifies the number of bytes used by the file, receives
             the updated size

Return Value:

  TRUE if successful, FALSE otherwise.

--*/
{
    ANSI_STRING FileNameA = { 0 };
    ANSI_STRING StoredNameA = { 0 };
    BOOL FreeStoredNameA = FALSE;
    PFCI_CAB_HANDLE CabHandle = (PFCI_CAB_HANDLE)Handle;
    NTSTATUS status = STATUS_SUCCESS;
    BOOL b;

    if (CabHandle == NULL) {
        status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (CabHandle->FciHandle == NULL) {
        status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (StoredNameW == NULL) {
        StoredNameW = FileNameW;
    }

    if (FileNameW == NULL) {
        FileNameW = StoredNameW;
    }

    status = SpConvertToNulTerminatedNtStringsW(FileNameW, &FileNameA, NULL);
    if (!NT_SUCCESS(status)) {
        goto NtExit;
    }

    if (FileNameW != StoredNameW) {
        FreeStoredNameA = FALSE;
        status = SpConvertToNulTerminatedNtStringsW(StoredNameW, &StoredNameA, NULL);
        if (!NT_SUCCESS(status)) {
            goto NtExit;
        }
    } else {
        StoredNameA = FileNameA;
    }

    b = FCIAddFile(
            CabHandle->FciHandle,
            FileNameA.Buffer,
            StoredNameA.Buffer,
            FALSE,
            pCabGetNextCabinet,
            pCabStatus,
            pCabGetOpenInfoA,
            CabHandle->CompressionType
            );

    if (!b) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            SpBoolToDbgPrintLevel(b),
            "SETUP:"__FUNCTION__" FCIAddFile failed.\n"
            ));
        status = SpGetLastNtStatus();
        goto Exit;
    }

    ASSERT (NT_SUCCESS (status));

Exit:
    KdPrintEx((
        DPFLTR_SETUP_ID,
        SpBoolToDbgPrintLevel(NT_SUCCESS (status)),
        "SETUP:"__FUNCTION__" exiting Success:%s Status:0x%08lx Error:%d\n",
        SpBoolToStringA(NT_SUCCESS (status)),
        SpGetLastNtStatus(),
        SpGetLastWin32Error()
        ));

    SpFreeStringA(&FileNameA);
    if (FreeStoredNameA) {
        SpFreeStringA(&StoredNameA);
    }

    return status;

NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(status);
    goto Exit;
}

BOOL
SpCabFlushAndCloseCabinetEx(
    IN      CCABHANDLE Handle,
    OUT     PUINT FileCount,        OPTIONAL
    OUT     PLONGLONG FileSize,     OPTIONAL
    OUT     PUINT CabFileCount,     OPTIONAL
    OUT     PLONGLONG CabFileSize   OPTIONAL
    )
/*++

Routine Description:

  Completes a cabinet file and closes its context.

Arguments:

  CabHandle - Specifies cabinet context.

  FileCount - Receives the number of files added to the cab

  FileSize - Receives the size of all files before compression

  CabFileCount - Receives the number of cabinet files created

  CabFileSize - Receives the size of all cabinet files

Return Value:

  TRUE if successful, FALSE otherwise.

--*/
{
    PFCI_CAB_HANDLE CabHandle = (PFCI_CAB_HANDLE) Handle;
    BOOL Result = FALSE;

    if (CabHandle == NULL) {
        goto Exit;
    }
    if (CabHandle->FciHandle != NULL) {
        if (!FCIFlushCabinet(
                CabHandle->FciHandle,
                FALSE,
                pCabGetNextCabinet,
                pCabStatus
                ))
            goto Exit;
    }


#if DBG
    {
        TIME_FIELDS TimeFields;
        LARGE_INTEGER EndTime = { 0 };
        LARGE_INTEGER Duration = { 0 };

        KeQuerySystemTime(&EndTime);
        Duration.QuadPart = EndTime.QuadPart - CabHandle->StartTime.QuadPart;
        RtlTimeToElapsedTimeFields(&Duration, &TimeFields);

        KdPrint((
            "SETUP: Cab %wZ\\%wZ %lu files compressed from %I64u to %I64u in %d minutes %d seconds\n",
            &CabHandle->PathW,
            &CabHandle->FileFormatW,
            (ULONG)CabHandle->FileCount,
            (ULONGLONG)CabHandle->FileSize,
            (ULONGLONG)CabHandle->CompressedSize,
            (int)TimeFields.Minute,
            (int)TimeFields.Second
            ));
    }
#endif

    SpFreeStringA(&CabHandle->PathA);
    SpFreeStringA(&CabHandle->FileFormatA);
    SpFreeStringA(&CabHandle->DiskFormatA);
    SpFreeStringW(&CabHandle->PathW);
    SpFreeStringW(&CabHandle->FileFormatW);
    SpFreeStringW(&CabHandle->DiskFormatW);

    if (CabHandle->FciHandle != NULL) {
        Result = FCIDestroy(CabHandle->FciHandle);
        CabHandle->FciHandle = NULL;
    }

    if (FileCount)
        *FileCount = CabHandle->FileCount;

    if (FileSize)
        *FileSize = CabHandle->FileSize;

    if (CabFileCount)
        *CabFileCount = CabHandle->CabCount;

    if (CabFileSize)
        *CabFileSize = CabHandle->CompressedSize;

    Result = TRUE;
Exit:
    return Result;
}

OCABHANDLE
SppCabOpenCabinet(
    IN       PCSTR FileNameA,
    IN      PCWSTR FileNameW
    )
/*++

Routine Description:

  Creates a cabinet context for an existent cabinet file.

Arguments:

  FileName - Specifies cabinet file name.

Return Value:

  a valid OCABHANDLE if successful, NULL otherwise.

--*/
{
    PFDI_CAB_HANDLE CabHandleRet = NULL;
    PFDI_CAB_HANDLE CabHandle = NULL;
    PSTR FilePtrA = NULL;
    PWSTR FilePtrW = NULL;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    ANSI_STRING LocalFileNameA = { 0 };
    UNICODE_STRING LocalFileNameW = { 0 };
    NTSTATUS Status = STATUS_SUCCESS;

    CabHandle = (PFDI_CAB_HANDLE) SpMemAlloc(sizeof(*CabHandle));
    if (CabHandle == NULL) {
        Status = STATUS_NO_MEMORY;
        goto NtExit;
    }
    RtlZeroMemory(CabHandle, sizeof (FDI_CAB_HANDLEW));

    CabHandle->FdiHandle = FDICreate(
                                pCabAlloc,
                                pCabFree,
                                pCabOpenForReadA,
                                pCabRead1,
                                pCabWrite1,
                                pCabClose1,
                                pCabSeek1,
                                cpuUNKNOWN, // ignored
                                &CabHandle->FdiErrorStruct
                                );
    if (CabHandle->FdiHandle == NULL) {
        goto Exit;
    }
    if (FileNameW != NULL) {
        Status = SpConvertToNulTerminatedNtStringsW(FileNameW, &LocalFileNameA, &LocalFileNameW);
        if (!NT_SUCCESS(Status))
            goto NtExit;
    }
    else if (FileNameA != NULL) {
        Status = SpConvertToNulTerminatedNtStringsA(FileNameA, &LocalFileNameA, &LocalFileNameW);
        if (!NT_SUCCESS(Status))
            goto NtExit;
    }
    else {
        Status = STATUS_INVALID_PARAMETER;
        goto NtExit;
    }
    FileHandle = SpOpenFile1W(LocalFileNameW.Buffer);

    ASSERT (FileHandle);    // never NULL

    if (FileHandle == INVALID_HANDLE_VALUE)
        goto Exit;
    if (!FDIIsCabinet(CabHandle->FdiHandle, (INT_PTR)FileHandle, &CabHandle->FdiCabinetInfo))
        goto Exit;
    SpCabCloseHandle(&FileHandle);
    FilePtrW = (PWSTR)SpGetFileNameFromPathW(LocalFileNameW.Buffer);
    if (FilePtrW == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto NtExit;
    }

    // ok if error, just empty string, no gauge
    RtlInitAnsiString(&g_CabFileFullPath, SpDupStringA(LocalFileNameA.Buffer));

    SpMoveStringA(&CabHandle->PathA, &LocalFileNameA);
    SpMoveStringW(&CabHandle->PathW, &LocalFileNameW);
    *FilePtrW = 0;
    Status = SpConvertToNulTerminatedNtStringsW(FilePtrW, &CabHandle->FileA, &CabHandle->FileW);
    if (!NT_SUCCESS(Status))
        goto NtExit;

    CabHandleRet = CabHandle;
    CabHandle = NULL;
Exit:
    ASSERT(g_SpCabFdiHandle == NULL);
    if (CabHandleRet != NULL) {
        g_SpCabFdiHandle = CabHandleRet;
    }

    SpCabCloseHandle(&FileHandle);
    SpFreeStringA(&LocalFileNameA);
    SpFreeStringW(&LocalFileNameW);
    if (CabHandle != NULL)
        SpCabCloseCabinet(CabHandle);
    return (OCABHANDLE)CabHandleRet;

NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

OCABHANDLE
SpCabOpenCabinetW(
    IN      PCWSTR FileName
    )
/*++

Routine Description:

  Creates a cabinet context for an existent cabinet file.

Arguments:

  FileName - Specifies cabinet file name.

Return Value:

  a valid OCABHANDLE if successful, NULL otherwise.

--*/
{
    OCABHANDLE Handle;

    KdPrint((__FUNCTION__":%ls\n", FileName));
    Handle = SppCabOpenCabinet(NULL, FileName);
    return Handle;
}

BOOL
SppCabExtractAllFilesEx(
    IN      OCABHANDLE Handle,
    PCSTR              ExtractPathA,
    PCWSTR             ExtractPathW,
    PCABNOTIFICATIONA  NotificationA   OPTIONAL,
    PCABNOTIFICATIONW  NotificationW   OPTIONAL
    )
/*++

Routine Description:

  Extracts all files from a cabinet file.

Arguments:

  CabHandle - Specifies cabinet context.

  ExtractPath - Specifies the path to extract the files to.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/
{
    PFDI_CAB_HANDLE CabHandle = (PFDI_CAB_HANDLE)Handle;
    CAB_DATA CabData = { 0 };
    BOOL Success = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;

    if (CabHandle == NULL)
        goto Exit;
    if (CabHandle->FdiHandle == NULL)
        goto Exit;

    if (ExtractPathW != NULL) {
        Status = SpConvertToNulTerminatedNtStringsW(ExtractPathW, &CabData.ExtractPathA, &CabData.ExtractPathW);
        if (!NT_SUCCESS(Status))
            goto NtExit;
    }
    else if (ExtractPathA != NULL) {
        Status = SpConvertToNulTerminatedNtStringsA(ExtractPathA, &CabData.ExtractPathA, &CabData.ExtractPathW);
        if (!NT_SUCCESS(Status))
            goto NtExit;
    }
    CabData.NotificationA = NotificationA;
    CabData.NotificationW = NotificationW;

    if (!FDICopy(
                CabHandle->FdiHandle,
                CabHandle->FileA.Buffer,
                CabHandle->PathA.Buffer,
                0,
                pCabNotification,
                NULL,
                &CabData
                ))
        goto Exit;
    Success = TRUE;
Exit:
    return Success;
NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

BOOL
SpCabExtractAllFilesExW(
    IN      OCABHANDLE        Handle,
    IN      PCWSTR            ExtractPathW,
    IN      PCABNOTIFICATIONW NotificationW   OPTIONAL
    )
/*++

Routine Description:

  Extracts all files from a cabinet file.

Arguments:

  CabHandle - Specifies cabinet context.

  ExtractPath - Specifies the path to extract the files to.

Return Value:

  TRUE if successful, FALSE otherwise.

--*/
{
    const BOOL Success = SppCabExtractAllFilesEx(Handle, NULL, ExtractPathW, NULL, NotificationW);
    return Success;
}

BOOL
SpCabCloseCabinet(
    IN      OCABHANDLE Handle
    )
/*++

Routine Description:

  Closes a cabinet file context.

Arguments:

  CabHandle - Specifies cabinet context.

Return Value:

  TRUE if successful, FALSE otherwise.

Note this function is also used internally to tear down a partially constructed
cab handle, as happens if we fail building it up.
--*/
{
    PFDI_CAB_HANDLE CabHandle = (PFDI_CAB_HANDLE)Handle;
    BOOL Success = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;

    if (CabHandle == NULL) {
        Success = TRUE;
        goto Exit;
    }
    if (CabHandle->FdiHandle != NULL) {
        if (!FDIDestroy(CabHandle->FdiHandle))
            goto Exit;
    }
    SpFreeStringA(&CabHandle->PathA);
    SpFreeStringA(&CabHandle->FileA);
    SpFreeStringW(&CabHandle->PathW);
    SpFreeStringW(&CabHandle->FileW);

    if (CabHandle == g_SpCabFdiHandle) {
        SpCabCleanupCabGlobals();
    }

    SpMemFree(CabHandle);
    Success = TRUE;
Exit:
    return Success;
}

INT
DIAMONDAPI
pCabFilePlacedA(
    IN      PCCAB FciCabParams,
    IN      PSTR FileName,
    IN      LONG FileSize,
    IN      BOOL Continuation,
    IN      PVOID Context
    )
/*++

Routine Description:

  Callback for cabinet compression/decompression. For more information see fci.h/fdi.h

--*/
{
    PFCI_CAB_HANDLE CabHandle = NULL;

    CabHandle = (PFCI_CAB_HANDLE) Context;
    if (CabHandle == NULL) {
        return 0;
    }

    CabHandle->FileCount++;
    CabHandle->FileSize += FileSize;

    return 0;
}

BOOL
SpCabFlushAndCloseCabinet(
    IN      CCABHANDLE CabHandle
    )
{
    return SpCabFlushAndCloseCabinetEx(CabHandle,NULL,NULL,NULL,NULL);
}

VOID
SpFreeStringA(
    PANSI_STRING String
    )
{
    SpFreeStringW((PUNICODE_STRING)String);
}

VOID
SpFreeStringW(
    PUNICODE_STRING String
    )
{
    if (String != NULL) {
        if (String->Buffer != NULL) {
            SpMemFree(String->Buffer);
        }
        RtlZeroMemory(String, sizeof(*String));
    }
}

NTSTATUS
SpConvertToNulTerminatedNtStringsA(
    PCSTR           Ansi,
    PANSI_STRING    OutAnsiString     OPTIONAL,
    PUNICODE_STRING OutUnicodeString  OPTIONAL
    )
/*++
Unlike assorted Rtl functions, we are sure that every string is nul terminated.
We also consistently allocate our strings.
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Length = 0;

    if (Ansi != NULL)
        Length = strlen(Ansi);

    if (OutAnsiString != NULL)
        RtlZeroMemory(OutAnsiString, sizeof(*OutAnsiString));
    if (OutUnicodeString != NULL)
        RtlZeroMemory(OutUnicodeString, sizeof(*OutUnicodeString));

    if (OutAnsiString != NULL) {
        if (!(OutAnsiString->Buffer = SpMemAlloc((Length + 1) * sizeof(OutAnsiString->Buffer[0])))) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }
        RtlCopyMemory(OutAnsiString->Buffer, Ansi, Length * sizeof(OutAnsiString->Buffer[0]));
        OutAnsiString->Buffer[Length] = 0;
        OutAnsiString->Length = (USHORT)Length * sizeof(OutAnsiString->Buffer[0]);
        OutAnsiString->MaximumLength = OutAnsiString->Length + sizeof(OutAnsiString->Buffer[0]);
    }
    if (OutUnicodeString != NULL) {
        ANSI_STRING LocalAnsiString = { 0 };

        RtlInitAnsiString(&LocalAnsiString, Ansi);
        LocalAnsiString.Length = LocalAnsiString.MaximumLength; // include terminal nul
        Status = SpAnsiStringToUnicodeString(OutUnicodeString, &LocalAnsiString, TRUE);
        if (!NT_SUCCESS(Status)) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }
        OutUnicodeString->Length -= sizeof(OutUnicodeString->Buffer[0]);
    }
    Status = STATUS_SUCCESS;
Exit:
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            SpNtStatusToDbgPrintLevel(Status),
            "SETUP:"__FUNCTION__" 0x%08lx\n",
            Status
            ));
        SpFreeStringA(OutAnsiString);
        SpFreeStringW(OutUnicodeString);
    }
    return Status;
}

NTSTATUS
SpConvertToNulTerminatedNtStringsW(
    PCWSTR          Unicode,
    PANSI_STRING    OutAnsiString     OPTIONAL,
    PUNICODE_STRING OutUnicodeString  OPTIONAL
    )
/*++
Unlike assorted Rtl functions, we are sure that every string is nul terminated.
We also consistently allocate our strings.
--*/
{
    ULONG Length = 0;
    NTSTATUS Status = STATUS_SUCCESS;

    if (Unicode != NULL)
        Length = wcslen(Unicode);

    if (OutUnicodeString != NULL) {
        if (!(OutUnicodeString->Buffer = SpMemAlloc((Length + 1) * sizeof(OutUnicodeString->Buffer[0])))) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }
        RtlCopyMemory(OutUnicodeString->Buffer, Unicode, Length * sizeof(OutUnicodeString->Buffer[0]));
        OutUnicodeString->Buffer[Length] = 0;
        OutUnicodeString->Length = (USHORT)Length * sizeof(OutUnicodeString->Buffer[0]);
        OutUnicodeString->MaximumLength = OutUnicodeString->Length + sizeof(OutUnicodeString->Buffer[0]);
    }
    if (OutAnsiString != NULL) {
        UNICODE_STRING LocalUnicodeString = { 0 };

        RtlInitUnicodeString(&LocalUnicodeString, Unicode);
        LocalUnicodeString.Length = LocalUnicodeString.MaximumLength; // include terminal nul
        Status = SpUnicodeStringToAnsiString(OutAnsiString, &LocalUnicodeString, TRUE);
        if (!NT_SUCCESS(Status)) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }
        OutAnsiString->Length -= sizeof(OutAnsiString->Buffer[0]);
    }
    Status = STATUS_SUCCESS;
Exit:
    if (!NT_SUCCESS(Status)) {
        KdPrintEx((
            DPFLTR_SETUP_ID,
            SpNtStatusToDbgPrintLevel(Status),
            "SETUP:"__FUNCTION__" 0x%08lx\n",
            Status
            ));
        SpFreeStringA(OutAnsiString);
        SpFreeStringW(OutUnicodeString);
    }
    return Status;
}

VOID
SpStringCopyNA(
    PSTR Dest,
    PCSTR Source,
    SIZE_T Max
    )
/*++
Max is a number of chars, as in RTL_NUMBER_OF.
The result is always nul terminated.
--*/
{
    SIZE_T Length = strlen(Source);
    if (Length >= Max) {
        KdPrint(("SETUP:String truncated in "__FUNCTION__".\n"));
        Length = Max - 1;
    }
    RtlCopyMemory(Dest, Source, Length * sizeof(Dest[0]));
    Dest[Length] = 0;
}

VOID
SpStringCopyNW(
    PWSTR  Dest,
    PCWSTR Source,
    SIZE_T Max
    )
/*++
Max is a number of chars, as in RTL_NUMBER_OF.
The result is always nul terminated.
--*/
{
    SIZE_T Length = wcslen(Source);
    if (Length >= Max) {
        KdPrint(("SETUP:String truncated in "__FUNCTION__".\n"));
        Length = Max - 1;
    }
    RtlCopyMemory(Dest, Source, Length * sizeof(Dest[0]));
    Dest[Length] = 0;
}

VOID
SpMoveStringA(
    PANSI_STRING Dest,
    PANSI_STRING Source
    )
{
    SpMoveStringW((PUNICODE_STRING)Dest, (PUNICODE_STRING)Source);
}

VOID
SpMoveStringW(
    PUNICODE_STRING Dest,
    PUNICODE_STRING Source
    )
{
    if (Source != NULL) {
        *Dest = *Source;
        RtlZeroMemory(Source, sizeof(*Source));
    }
}


NTSTATUS
SpCreateDirectoryForFileA(
    IN PCSTR FilePathA,
    IN ULONG CreateFlags
    )
{
    UNICODE_STRING PathW = { 0 };
    NTSTATUS Status = STATUS_SUCCESS;
    PWSTR LastBackSlash = NULL;
    PWSTR BackSlash = NULL;

    Status = SpConvertToNulTerminatedNtStringsA(FilePathA, NULL, &PathW);
    if (!NT_SUCCESS(Status))
        goto Exit;

    //
    // \device\harddiskn\partitionm\dirs..\file
    // or \device\harddiskn\partitionm\file
    // calculate \device\hardiskn\partitionm part
    //
    BackSlash = wcschr(PathW.Buffer + 1, '\\');
    if (BackSlash != NULL)
        BackSlash = wcschr(BackSlash + 1, '\\');
    if (BackSlash != NULL)
        BackSlash = wcschr(BackSlash + 1, '\\');
    if (BackSlash == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        KdPrintEx((
            DPFLTR_SETUP_ID,
            SpNtStatusToDbgPrintLevel(Status),
            "SETUP:"__FUNCTION__"(%ls) less than expected number of slashes, expected \\device\\harddiskn\\partitionm\\...\n",
            FilePathA
            ));
        goto Exit;
    }
    *BackSlash = 0;

    LastBackSlash = wcsrchr(BackSlash + 1, '\\');
    if (LastBackSlash == NULL) {
        //
        // the file is at the root of a drive, no directory to create, just
        // return success
        //
        Status = STATUS_SUCCESS;
        goto Exit;
    }
    *LastBackSlash = 0;

    if (!SpCreateDirectory (PathW.Buffer, NULL, BackSlash + 1, 0, CreateFlags)) {

        Status = STATUS_UNSUCCESSFUL;
        goto Exit;

    }

    Status = STATUS_SUCCESS;
Exit:
    SpFreeStringW(&PathW);
    return Status;
}

NTSTATUS
SpUnicodeStringToAnsiString(
    PANSI_STRING     DestinationStringA,
    PCUNICODE_STRING SourceStringW,
    BOOL             Allocate
    )
/*
This is like RtlUnicodeStringToAnsiString, but it is "setup heap correct".
The result is freed with SpMemFree instead of RtlFreeAnsiString.

I know this is inefficient.
*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ANSI_STRING RtlMemDestinationStringA = { 0 };
    if (!Allocate) {
        Status = RtlUnicodeStringToAnsiString(DestinationStringA, (PUNICODE_STRING)SourceStringW, FALSE);
        goto Exit;
    }
    Status = RtlUnicodeStringToAnsiString(&RtlMemDestinationStringA, (PUNICODE_STRING)SourceStringW, TRUE);
    if (!NT_SUCCESS(Status))
        goto Exit;
    //
    // Don't use SpDupString, we might not have a terminal nul (but usually does).
    //
    DestinationStringA->Buffer = SpMemAlloc(RtlMemDestinationStringA.MaximumLength);
    if (DestinationStringA->Buffer == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }
    DestinationStringA->MaximumLength = RtlMemDestinationStringA.MaximumLength;
    DestinationStringA->Length = RtlMemDestinationStringA.Length;
    RtlCopyMemory(DestinationStringA->Buffer, RtlMemDestinationStringA.Buffer, DestinationStringA->Length);
    if (DestinationStringA->MaximumLength >= (DestinationStringA->Length + sizeof(DestinationStringA->Buffer[0])))
        DestinationStringA->Buffer[DestinationStringA->Length / sizeof(DestinationStringA->Buffer[0])] = 0;
    Status = STATUS_SUCCESS;
Exit:
    RtlFreeAnsiString(&RtlMemDestinationStringA);
    return Status;
}

NTSTATUS
SpAnsiStringToUnicodeString(
    PUNICODE_STRING DestinationStringW,
    PCANSI_STRING   SourceStringA,
    BOOL            Allocate
    )
/*
This is like RtlAnsiStringToUnicodeString, but it is "setup heap correct".
The result is freed with SpMemFree instead of RtlFreeUnicodeString.

I know this is inefficient.
*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING RtlMemDestinationStringW = { 0 };
    if (!Allocate) {
        Status = RtlAnsiStringToUnicodeString(DestinationStringW, (PANSI_STRING)SourceStringA, FALSE);
        goto Exit;
    }
    Status = RtlAnsiStringToUnicodeString(&RtlMemDestinationStringW, (PANSI_STRING)SourceStringA, TRUE);
    if (!NT_SUCCESS(Status))
        goto Exit;
    //
    // Don't use SpDupString, we might not have a terminal nul (but usually does).
    //
    DestinationStringW->Buffer = SpMemAlloc(RtlMemDestinationStringW.MaximumLength);
    if (DestinationStringW->Buffer == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }
    DestinationStringW->MaximumLength = RtlMemDestinationStringW.MaximumLength;
    DestinationStringW->Length = RtlMemDestinationStringW.Length;
    RtlCopyMemory(DestinationStringW->Buffer, RtlMemDestinationStringW.Buffer, DestinationStringW->Length);
    if (DestinationStringW->MaximumLength >= (DestinationStringW->Length + sizeof(DestinationStringW->Buffer[0])))
        DestinationStringW->Buffer[DestinationStringW->Length / sizeof(DestinationStringW->Buffer[0])] = 0;
    Status = STATUS_SUCCESS;
Exit:
    RtlFreeUnicodeString(&RtlMemDestinationStringW);
    return Status;
}

NTSTATUS
SpKnownSizeUnicodeToDbcsN(
    OUT PSTR    Ansi,
    IN  PCWSTR  Unicode,
    IN  SIZE_T  AnsiSize
    )
/*++
based on windows\winstate\cobra\utils\...
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    AnsiString.Buffer = Ansi;
    AnsiString.Length = 0;
    AnsiString.MaximumLength = (USHORT)AnsiSize;

    RtlInitUnicodeString(&UnicodeString, Unicode);
    UnicodeString.Length = UnicodeString.MaximumLength; // include terminal nul

    Status = SpUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);
    if (!NT_SUCCESS(Status))
        goto Exit;

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

VOID
SpEnsureTrailingBackSlashA(
    PSTR Path
    )
/*++
based on windows\winstate\cobra\utils\...
--*/
{
    if (*Path == 0 || *((Path += strlen(Path)) - 1) != '\\') {
        *Path = '\\';
        *(Path + 1) = 0;
    }
}

PCWSTR
SpGetFileNameFromPathW(
    IN PCWSTR PathSpec
    )
/*++
based on windows\winstate\cobra\utils\...
--*/
{
    PCWSTR p;

    p = wcsrchr(PathSpec, L'\\');
    if (p) {
        p++;
    } else {
        p = PathSpec;
    }

    return p;
}

HANDLE
SpCreateFile1A(
    IN PCSTR FileName
    )
/*++
based on windows\winstate\cobra\utils\...
--*/
{
    HANDLE Handle;
    DWORD orgAttributes;
    WIN32_FILE_ATTRIBUTE_DATA fileAttributeData = { 0 };

    //
    // Reset the file attributes, then do a CREATE_ALWAYS. FileName is an NT path.
    //
    // We do this because some of the files are replacing have had their
    // system|hidden attributes changed, and you can get access denied if you
    // try to replace these files with mismatching attributes.
    //

    if (!SpGetFileAttributesExA (FileName, GetFileExInfoStandard, &fileAttributeData)) {
        orgAttributes = FILE_ATTRIBUTE_NORMAL;
    } else {
        orgAttributes = fileAttributeData.dwFileAttributes;
    }

    SpSetFileAttributesA (FileName, FILE_ATTRIBUTE_NORMAL);

    Handle = SpWin32CreateFileA(
                    FileName,
                    GENERIC_READ|GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

    ASSERT (Handle);    // never NULL

    if (Handle == INVALID_HANDLE_VALUE) {
        SpSetFileAttributesA (FileName, orgAttributes);
    }

    return Handle;
}

PSTR
SpJoinPathsA(
    PCSTR a,
    PCSTR b
    )
/*++
based on windows\winstate\cobra\utils\...
--*/
{
// find code elsewhere in setup that does this already..
    PSTR Result = NULL;
    SIZE_T alen = 0;
    SIZE_T blen = 0;

    if (a == NULL)
        goto Exit;
    if (b == NULL)
        goto Exit;
    alen = strlen(a);
    blen = strlen(b);

    Result = SpMemAlloc((alen + blen + 2) * sizeof(*Result));
    if (Result == NULL) {
        SpSetLastWin32ErrorAndNtStatusFromNtStatus(STATUS_NO_MEMORY);
        goto Exit;
    }

    if (alen != 0) {
        strcpy(Result, a);
        if (a[alen - 1] != '\\')
            strcat(Result, "\\");
     }
     strcat(Result, b);
Exit:
    KdPrintEx((DPFLTR_SETUP_ID, SpPointerToDbgPrintLevel(Result), "SETUP:"__FUNCTION__" exiting\n"));
    return Result;
}

HANDLE
SpOpenFile1A(
    IN PCSTR Ansi
    )
/*++
based on windows\winstate\cobra\utils\main\basefile.c
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL     Success = FALSE;
    ANSI_STRING    AnsiString   = { 0 };
    UNICODE_STRING UnicodeString = { 0 };
    HANDLE Handle = INVALID_HANDLE_VALUE;

    RtlInitAnsiString(&AnsiString, Ansi);
    AnsiString.Length = AnsiString.MaximumLength; // include terminal nul

    if (!NT_SUCCESS(Status = SpAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE)))
        goto NtExit;
    Handle = SpOpenFile1W(UnicodeString.Buffer);
    ASSERT (Handle);    // never NULL
    if (Handle == INVALID_HANDLE_VALUE)
        goto Exit;

Exit:
    SpFreeStringW(&UnicodeString);
    KdPrintEx((
        DPFLTR_SETUP_ID,
        SpHandleToDbgPrintLevel(Handle),
        "SETUP:"__FUNCTION__"(%s) exiting %p\n", Ansi, Handle
        ));
    return Handle;
NtExit:
    SpSetLastWin32ErrorAndNtStatusFromNtStatus(Status);
    goto Exit;
}

HANDLE
SpOpenFile1W(
    IN PCWSTR FileName
    )
/*++
based on windows\winstate\cobra\utils\main\basefile.c
--*/
{
    HANDLE Handle;

    Handle = SpWin32CreateFileW(
                FileName,
                GENERIC_READ|GENERIC_WRITE,
                0, // no share
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );
    ASSERT (Handle);    // never NULL

    return Handle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spcmdcon.h ===
//
// Parameter block passed to the spcmdcon.sys top-level routine.
//
typedef struct _CMDCON_BLOCK {
    PSP_VIDEO_VARS VideoVars;
    PVOID TemporaryBuffer;
    ULONG TemporaryBufferSize;
    PEPROCESS UsetupProcess;
    LPCWSTR BootDevicePath;
    LPCWSTR DirectoryOnBootDevice;
    PVOID SifHandle;
    PWSTR SetupSourceDevicePath;
    PWSTR DirectoryOnSetupSource;
} CMDCON_BLOCK, *PCMDCON_BLOCK;


//
// In its DriverEntry routine, spcmdcon.sys calls
// CommandConsoleInterface(), passing it the address of the top level
// command console routine.
//
typedef
ULONG
(*PCOMMAND_INTERPRETER_ROUTINE)(
    IN PCMDCON_BLOCK CmdConBlock
    );

VOID
CommandConsoleInterface(
    PCOMMAND_INTERPRETER_ROUTINE CmdRoutine
    );


//
// Autochk message processing callback.
//
typedef
NTSTATUS
(*PAUTOCHK_MSG_PROCESSING_ROUTINE) (
    PSETUP_FMIFS_MESSAGE SetupFmifsMessage
    );

VOID
SpSetAutochkCallback(
    IN PAUTOCHK_MSG_PROCESSING_ROUTINE AutochkCallbackRoutine
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spboot.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    spboot.c

Abstract:

    accessing and configuring boot variables.

Author:

    Sunil Pai (sunilp) 26-October-1993

Revision History:

--*/


#include "spprecmp.h"
#pragma hdrstop

#include <hdlsblk.h>
#include <hdlsterm.h>

#if defined(EFI_NVRAM_ENABLED)
#include <efi.h>
#include <efiapi.h>
#endif             
               
#include "bootvar.h"

//
// Globals to this module
//

static ULONG Timeout;
static PWSTR Default;
ULONG DefaultSignature;
static PWSTR *BootVars[MAXBOOTVARS];
static BOOLEAN CleanSysPartOrphan = FALSE;

PWSTR *CurrentNtDirectoryList = NULL;

// do NOT change the order of the elements in this array.

PCHAR NvramVarNames[MAXBOOTVARS] = {
   LOADIDENTIFIERVAR,
   OSLOADERVAR,
   OSLOADPARTITIONVAR,
   OSLOADFILENAMEVAR,
   OSLOADOPTIONSVAR,
   SYSTEMPARTITIONVAR
   };

PCHAR OldBootVars[MAXBOOTVARS];
PWSTR NewBootVars[MAXBOOTVARS];

#if defined(_X86_)
BOOLEAN IsArcChecked = FALSE;
BOOLEAN IsArcMachine;
#endif

PSP_BOOT_ENTRY SpBootEntries = NULL;
PBOOT_OPTIONS SpBootOptions = NULL;

RedirectSwitchesModeEnum RedirectSwitchesMode = UseDefaultSwitches;
REDIRECT_SWITCHES RedirectSwitches;

#ifdef _X86_
extern BOOLEAN g_Win9xBackup;
#endif



//
// Local functions.
//

PWSTR
SpArcPathFromBootSet(
    IN BOOTVAR BootVariable,
    IN ULONG   Component
    );

BOOLEAN
SpConvertArcBootEntries (
    IN ULONG MaxComponents
    );

VOID
SpCreateBootEntry(
    IN ULONG_PTR Status,
    IN PDISK_REGION BootFileRegion,
    IN PWSTR BootFilePath,
    IN PDISK_REGION OsLoadRegion,
    IN PWSTR OsLoadPath,
    IN PWSTR OsLoadOptions,
    IN PWSTR FriendlyName
    );

PCHAR
SppGetArcEnvVar(
    IN BOOTVAR Variable
    );

VOID
SpFreeBootEntries (
    VOID
    );

BOOLEAN
SppSetArcEnvVar(
    IN BOOTVAR Variable,
    IN PWSTR *VarComponents,
    IN BOOLEAN bWriteVar
    );

#if defined(EFI_NVRAM_ENABLED)

typedef struct _HARDDISK_NAME_TRANSLATION {
    struct _HARDDISK_NAME_TRANSLATION *Next;
    PWSTR VolumeName;
    PWSTR PartitionName;
} HARDDISK_NAME_TRANSLATION, *PHARDDISK_NAME_TRANSLATION;

PHARDDISK_NAME_TRANSLATION SpHarddiskNameTranslations = NULL;

BOOLEAN
SpBuildHarddiskNameTranslations (
    VOID
    );

BOOLEAN
SpFlushEfiBootEntries (
    VOID
    );

BOOLEAN
SpReadAndConvertEfiBootEntries (
    VOID
    );

ULONG
SpSafeWcslen (
    IN PWSTR String,
    IN PWSTR Max
    );

VOID
SpTranslateFilePathToRegion (
    IN PFILE_PATH FilePath,
    OUT PDISK_REGION *DiskRegion,
    OUT PWSTR *PartitionNtName,
    OUT PWSTR *PartitionRelativePath
    );

#define ADD_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_p)->_o)

#endif

//
// Function implementation
//


BOOLEAN
SpInitBootVars(
    )
/*++

Routine Description:

    Captures the state of the NVRAM Boot Variables.

Arguments:

    None.

Return Value:

--*/
{
    BOOLEAN Status = TRUE;
    BOOTVAR i;
    ULONG   Component, MaxComponents, SysPartComponents;
    PCHAR puArcString; // SGI

    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_EXAMINING_FLEXBOOT,DEFAULT_STATUS_ATTRIBUTE);

    //
    // Initialize the boot variables from the corresponding NVRAM variables
    //
#if defined(EFI_NVRAM_ENABLED)
    if (SpIsEfi()) {

        //
        // Build a list of all of the \Device\HarddiskN\PartitionM symbolic
        // links, along with their translations to \Device\HarddiskVolumeN
        // device names. This list is used to translate the
        // \Device\HarddiskVolumeN names returned by NtTranslateFilePath into
        // names that setupdd can translate to ARC names.
        //

        SpBuildHarddiskNameTranslations();
     
        //
        // Read the boot entries from NVRAM and convert them into our
        // internal format.
        //

        Status = SpReadAndConvertEfiBootEntries();

    } else
#endif
    {
        if (SpIsArc()) {
            ULONG   NumComponents;
    
            for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
                OldBootVars[i] = SppGetArcEnvVar( i );
                SpGetEnvVarWComponents( OldBootVars[i], BootVars + i, &NumComponents );
            }
            Timeout = DEFAULT_TIMEOUT;
            Default = NULL;
#if defined _X86_
        } else {
            Spx86InitBootVars( BootVars, &Default, &Timeout );
#endif
        }

        //
        // We now go back and replace all NULL OsLoadOptions with "", because we
        // validate a boot set by making sure that all components are non-NULL.
        //
        // First, find the maximum number of components in any of the other
        // boot variables, so that we can make OsLoadOptions have this many.
        // (We also disregard SYSTEMPARTITION since some machines have this component
        // sitting all by itself on a new machine.)
        //
        MaxComponents = 0;
        for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
            if(i != OSLOADOPTIONS) {
                for(Component = 0; BootVars[i][Component]; Component++);
                if (i == SYSTEMPARTITION) {
                    SysPartComponents = Component;
                } else if(Component > MaxComponents) {
                    MaxComponents = Component;
                }
            }
        }
    
        if(SysPartComponents > MaxComponents) {
            CleanSysPartOrphan = TRUE;
        }
    
        for(Component = 0; BootVars[OSLOADOPTIONS][Component]; Component++);
        if(Component < MaxComponents) {
            //
            // Then we need to add empty strings to fill it out.
            //
            BootVars[OSLOADOPTIONS] = SpMemRealloc(BootVars[OSLOADOPTIONS],
                                                   (MaxComponents + 1) * sizeof(PWSTR *));
            ASSERT(BootVars[OSLOADOPTIONS]);
            BootVars[OSLOADOPTIONS][MaxComponents] = NULL;
    
            for(; Component < MaxComponents; Component++) {
                BootVars[OSLOADOPTIONS][Component] = SpDupStringW(L"");
            }
        }

        //
        // Now convert the ARC boot sets into our internal format.
        //

        Status = SpConvertArcBootEntries(MaxComponents);
    }

    CLEAR_CLIENT_SCREEN();
    return ( Status );
}



BOOLEAN
SpFlushBootVars(
    )
/*++

Routine Description:

    Updates the NVRAM variables / boot.ini
    from the current state of the boot variables.

Arguments:

Return Value:

--*/
{
    BOOLEAN Status, OldStatus;
    BOOTVAR i, iFailPoint;
    CHAR TimeoutValue[24];

#if defined(EFI_NVRAM_ENABLED)
    if (SpIsEfi()) {

        //
        // This is an EFI machine. Write changed boot entries back to NVRAM.
        //
        Status = SpFlushEfiBootEntries();

    } else
#endif
    {
        Status = FALSE;
        if (SpIsArc()) {
            //
            // Run through all the boot variables and set the corresponding
            // NVRAM variables
    
            for(OldStatus = TRUE, i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
                Status = SppSetArcEnvVar( i, BootVars[i], OldStatus );
                if(Status != OldStatus) {
                    iFailPoint = i;
                    OldStatus = Status;
                }
            }
    
            // if we failed in writing any of the variables, then restore everything we
            // modified back to its original state.
            if(!Status) {
                for(i = FIRSTBOOTVAR; i < iFailPoint; i++) {
                    HalSetEnvironmentVariable(NvramVarNames[i], OldBootVars[i]);
                }
            }
    
            // Free all of the old boot variable strings
            for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
                SpMemFree(OldBootVars[i]);
                OldBootVars[i] = NULL;
            }
    
            //
            // Now set the timeout.
            //
            if(Status) {
    
                Status = FALSE;
                sprintf(TimeoutValue,"%u",Timeout);
    
                if((HalSetEnvironmentVariable("COUNTDOWN",TimeoutValue) == ESUCCESS)
                && (HalSetEnvironmentVariable("AUTOLOAD" ,"YES"       ) == ESUCCESS))
                {
                    Status = TRUE;
                }
            }
#if defined(_X86_)
        } else {
            Status = Spx86FlushBootVars( BootVars, Timeout, Default );
#endif
        }
    }
    return( Status );
}





VOID
SpFreeBootVars(
    )
/*++

Routine Description:

    To free any memory allocated and do other cleanup

Arguments:

    None

Return Value:

    None

--*/
{
    BOOTVAR i;

    //
    // Free internal-format boot entries.
    //
    SpFreeBootEntries();

#if defined(EFI_NVRAM_ENABLED)
    if (!SpIsEfi())
#endif
    {
        //
        // Go through the globals and free them
        //
    
        for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
            if( BootVars[i] ) {
                SpFreeEnvVarComponents( BootVars[i] );
                BootVars[i] = NULL;
            }
        }
    
        if ( Default ) {
            SpMemFree( Default );
            Default = NULL;
        }
    }

    return;
}



VOID
SpAddBootSet(
    IN PWSTR *BootSet,
    IN BOOLEAN DefaultOS,
    IN ULONG Signature
    )
/*++

Routine Description:

    To add a new system to the installed system list.  The system is added
    as the first bootset.  If is found in the currently installed boot sets
    the boot set is extracted and shifted to position 0.

Arguments:

    BootSet - A list of the boot variables to use.
    Default - Whether this system is to be the default system to boot.

Return Value:

    Component list of the value of the boot variable.

--*/
{
    BOOTVAR i;
    ULONG   MatchComponent, j;
    LONG    k;
    BOOLEAN ValidBootSet, ComponentMatched;
    PWSTR   Temp;

    ASSERT( !SpIsEfi() );

    //
    // Validate the BootSet passed in
    //

    for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
        ASSERT( BootSet[i] );
    }

    //
    // Examine all the boot sets and make sure we don't have a boot set
    // already matching.  Note that we will compare all variables in
    // tandem.  We are not interested in matches which are generated by
    // the variables not being in tandem because they are difficult to
    // shift around.
    //

    ValidBootSet = TRUE;
    ComponentMatched = FALSE;
    for( MatchComponent = 0;
         BootVars[OSLOADPARTITION][MatchComponent];
         MatchComponent++
       ) {

        //
        // Validate the boot set at the current component
        //

        for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
            ValidBootSet = ValidBootSet && BootVars[i][MatchComponent];
        }
        if( !ValidBootSet ) {
            break;
        }

        //
        // Valid Boot Set, compare the components against what we have in the
        // current BootSet
        //

        ComponentMatched = TRUE;
        for(i = FIRSTBOOTVAR; ComponentMatched && i <= LASTBOOTVAR; i++) {
            ComponentMatched = !_wcsicmp( BootSet[i], BootVars[i][MatchComponent] );
        }
        if( ComponentMatched ) {
            break;
        }
    }

    //
    // If component didn't match then prepend the BootSet to the boot sets
    // that currently exist.  It is important to prepend the BootSet, because
    // appending the BootSet doesn't guarantee a matched BootSet in the
    // environment variables.  If a match was found then we
    // have a cleanly matched set which can be exchanged with the first
    // one in the set.
    //

    if( ComponentMatched ) {

        // If the currently selected OS is to be the default:
        // Shift down all variables from position 0 to MatchComponent - 1
        // and store whatever was there at MatchComponent at position 0
        //

        if ( DefaultOS && MatchComponent != 0 ) {

            for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
                Temp = BootVars[i][MatchComponent];
                for( k = MatchComponent - 1; k >= 0; k-- ) {
                    BootVars[i][k + 1] = BootVars[i][k];
                }
                BootVars[i][0] = Temp;
            }
        }

    }
    else {
        for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {

            //
            // Find out the size of the current value
            //

            for(j = 0; BootVars[i][j]; j++) {
            }

            //
            // Realloc the current buffer to hold one more
            //

            BootVars[i] = SpMemRealloc( BootVars[i], (j + 1 + 1)*sizeof(PWSTR) );

            //
            // Shift all the variables down one and store the current value
            // at index 0;
            //

            for( k = j; k >= 0 ; k-- ) {
                BootVars[i][k+1] = BootVars[i][k];
            }
            BootVars[i][0] = SpDupStringW( BootSet[i] );
            ASSERT( BootVars[i][0] );

        }
    }

    //
    // If this has been indicated as the default then set this to be the
    // default OS after freeing the current default variable
    //

    if( DefaultOS ) {

        if( Default ) {
            SpMemFree( Default );
        }
        Default = SpMemAlloc( MAX_PATH * sizeof(WCHAR) );
        ASSERT( Default );
        wcscpy( Default, BootSet[OSLOADPARTITION] );
        wcscat( Default, BootSet[OSLOADFILENAME]  );

        DefaultSignature = Signature;
    }
    return;

}

VOID
SpDeleteBootSet(
    IN  PWSTR *BootSet,
    OUT PWSTR *OldOsLoadOptions  OPTIONAL
    )

/*++

Routine Description:

    To delete all boot sets in the list matching the boot set provided.
    Note that the information to use in comparing the bootset is provided
    by selectively providing fields in the boot set.  So in the boot set
    if the system partition is not provided it is not used in the comparison
    to see if the boot sets match.  By providing all NULL members we can
    delete all the boot sets currently present.

Arguments:

    BootSet - A list of the boot variables to use.

Return Value:

    None.

--*/
{
    ULONG   Component, j;
    BOOLEAN ValidBootSet, ComponentMatched;
    BOOTVAR i;
    PWSTR   OsPartPath;

    ASSERT( !SpIsEfi() );

    Component = 0;
    
    while(TRUE) {
        //
        // See if we have any boot sets left, if none left we are done
        //
        ValidBootSet = TRUE;
        
        for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
            ValidBootSet = ValidBootSet && BootVars[i][Component];
        }

        if( !ValidBootSet ) {
            break;
        }

        //
        // Valid Boot Set, compare the components against what we have in the
        // current BootSet.  Use only members of the BootSet which are not NULL
        //
        ComponentMatched = TRUE;
        
        for(i = FIRSTBOOTVAR; ComponentMatched && i <= LASTBOOTVAR; i++) {
            if( BootSet[i] ) {
                if((i == OSLOADPARTITION) ||
                   (i == SYSTEMPARTITION)) {
                    //
                    // Then we may have a boot set existing in tertiary ARC path form, so
                    // we first translate this path to a primary or secondary ARC path.
                    //
                    OsPartPath = SpArcPathFromBootSet(i, Component);
                    ComponentMatched = !_wcsicmp( BootSet[i], OsPartPath );
                    SpMemFree(OsPartPath);
                } else {
                    ComponentMatched = !_wcsicmp( BootSet[i], BootVars[i][Component] );
                }
            }
        }
        if( (ComponentMatched)

#ifdef PRERELEASE
            //
            // If we're being asked to delete a boot entry, and this
            // isn't the *exact* entry (i.e. it's a duplicate) that
            // also has some private OSLOADOPTIONS, then keep it around.
            //
            && !( wcsstr(BootVars[OSLOADOPTIONS][Component], L"/kernel")   ||
                  wcsstr(BootVars[OSLOADOPTIONS][Component], L"/hal")      ||
                  wcsstr(BootVars[OSLOADOPTIONS][Component], L"/pae")      ||
                  wcsstr(BootVars[OSLOADOPTIONS][Component], L"/sos") )

#endif

           ) {

            //
            // Delete all the values in the current component and advance
            // all the other components one index up
            //
            for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
                if((i == OSLOADOPTIONS) && OldOsLoadOptions && !(*OldOsLoadOptions)) {
                    //
                    // If we've been passed a pointer to OldOsLoadOptions,
                    // and haven't previously found a pertinent entry, then
                    // save this one
                    //
                    *OldOsLoadOptions = BootVars[i][Component];
                } else {
                    SpMemFree(BootVars[i][Component]);
                }

                j = Component;

                do {
                   BootVars[i][j] = BootVars[i][j+1];
                   j++;
                } while(BootVars[i][j] != NULL);
            }
        }
        else {
            Component++;
        }
    }
    
    return;
}


VOID
SpCleanSysPartOrphan(
    VOID
    )
{
    INT     Component, Orphan;
    BOOLEAN DupFound;
    PWSTR   NormalizedArcPath;

    if(!CleanSysPartOrphan) {
        return;
    }

    ASSERT( !SpIsEfi() );

    //
    // find the last SystemPartition entry
    //
    for(Orphan = 0; BootVars[SYSTEMPARTITION][Orphan]; Orphan++);

    //
    // it's position better be > 0, otherwise, just exit
    //
    if(Orphan < 2) {
        return;
    } else {
        NormalizedArcPath = SpNormalizeArcPath(BootVars[SYSTEMPARTITION][--Orphan]);
    }

    //
    // Make sure that this component is duplicated somewhere else in the
    // SystemPartition list.
    //
    for(Component = Orphan - 1, DupFound = FALSE;
        ((Component >= 0) && !DupFound);
        Component--)
    {
        DupFound = !_wcsicmp(NormalizedArcPath, BootVars[SYSTEMPARTITION][Component]);
    }

    if(DupFound) {
        SpMemFree(BootVars[SYSTEMPARTITION][Orphan]);
        BootVars[SYSTEMPARTITION][Orphan] = NULL;
    }

    SpMemFree(NormalizedArcPath);
}


PWSTR
SpArcPathFromBootSet(
    IN BOOTVAR BootVariable,
    IN ULONG   Component
    )
/*++

Routine Description:

    Given the index of a boot set, return the primary (multi) or
    secondary ("absolute" scsi) ARC path for the specified variable.
    This takes into account the NT 3.1 case where we had 'tertiary'
    ARC paths where a relative scsi ordinal was passed in via the
    /scsiordinal switch.

Arguments:

    BootVariable  - supplies the index of the variable we want to return.

    Component - supplies the index of the boot set to use.

Return Value:

    String representing the primary or secondary ARC path.  This string
    must be freed by the caller with SpMemFree.

--*/
{
    ASSERT( !SpIsEfi() );

    if(!SpIsArc()){
        PWSTR p = NULL, q = NULL, ReturnedPath = NULL, RestOfString;
        WCHAR ForceOrdinalSwitch[] = L"/scsiordinal:";
        WCHAR ScsiPrefix[] = L"scsi(";
        WCHAR OrdinalString[11];
        ULONG ScsiOrdinal, PrefixLength;
    
        //
        // Check to see if this boot set had the /scsiordinal option switch
        //
        if(BootVars[OSLOADOPTIONS][Component]) {
            wcscpy(TemporaryBuffer, BootVars[OSLOADOPTIONS][Component]);
            SpStringToLower(TemporaryBuffer);
            if(p = wcsstr(TemporaryBuffer, ForceOrdinalSwitch)) {
                p += sizeof(ForceOrdinalSwitch)/sizeof(WCHAR) - 1;
                if(!(*p)) {
                    p = NULL;
                }
            }
        }
    
        if(p) {
            //
            // We have found a scsiordinal, so use it
            //
            ScsiOrdinal = SpStringToLong(p, &RestOfString, 10);
            wcscpy(TemporaryBuffer, BootVars[BootVariable][Component]);
            SpStringToLower(TemporaryBuffer);
            if(p = wcsstr(TemporaryBuffer, ScsiPrefix)) {
                p += sizeof(ScsiPrefix)/sizeof(WCHAR) - 1;
                if(*p) {
                    q = wcschr(p, L')');
                } else {
                    p = NULL;
                }
            }
    
            if(q) {
                //
                // build the new secondary ARC path
                //
                swprintf(OrdinalString, L"%u", ScsiOrdinal);
                PrefixLength = (ULONG)(p - TemporaryBuffer);
                ReturnedPath = SpMemAlloc((PrefixLength + wcslen(OrdinalString) + wcslen(q) + 1)
                                            * sizeof(WCHAR)
                                         );
                wcsncpy(ReturnedPath, TemporaryBuffer, PrefixLength);
                ReturnedPath[PrefixLength] = L'\0';
                wcscat(ReturnedPath, OrdinalString);
                wcscat(ReturnedPath, q);
            }
        }
    
        if(!ReturnedPath) {
            //
            // We didn't find a scsiordinal, this is a multi-style path, or
            // there was some problem, so just use the boot variable as-is.
            //
            ReturnedPath = SpDupStringW(BootVars[BootVariable][Component]);
        }
    
        return ReturnedPath;
    }else{   // not x86
        //
        // Nothing to do on ARC machines.
        //
        return SpDupStringW(BootVars[BootVariable][Component]);
    }
}


#if defined(REMOTE_BOOT)
BOOLEAN
SpFlushRemoteBootVars(
    IN PDISK_REGION TargetRegion
    )
{

#if defined(EFI_NVRAM_ENABLED)
    if (SpIsEfi()) {
        //
        // Insert EFI code here.
        //
        return FALSE;

    } else
#endif
    {
        if (SpIsArc()) {
            //
            // Insert ARC code here.
            //
            return FALSE;
    
#if defined(_X86_)
        } else {
            return Spx86FlushRemoteBootVars( TargetRegion, BootVars, Default );
#endif
        }
    }
}
#endif // defined(REMOTE_BOOT)


BOOLEAN
SppSetArcEnvVar(
    IN BOOTVAR Variable,
    IN PWSTR *VarComponents,
    IN BOOLEAN bWriteVar
    )
/*++

Routine Description:

    Set the value of the arc environment variable

Arguments:

    VarName - supplies the name of the arc environment variable
        whose value is to be set.
    VarComponents - Set of components of the variable value to be set
    bWriteVar - if TRUE, then write the variable to nvram, otherwise
        just return FALSE (having put the first component in NewBootVars).

Return Value:

    TRUE if values were written to nvram / FALSE otherwise

--*/

{
    ULONG Length, NBVLen, i;
    PWSTR Temp;
    PUCHAR Value;
    ARC_STATUS ArcStatus;

    ASSERT( !SpIsEfi() );

    if( VarComponents == NULL ) {
        Temp = SpDupStringW( L"" );
        NewBootVars[Variable] = SpDupStringW( L"" );
    }
    else {
        for( i = 0, Length = 0; VarComponents[i]; i++ ) {
            Length = Length + (wcslen(VarComponents[i]) + 1) * sizeof(WCHAR);
            if(i == 0) {
                NBVLen = Length;    // we just want to store the first component
            }
        }
        Temp = SpMemAlloc( Length );
        ASSERT( Temp );
        wcscpy( Temp, L"" );
        NewBootVars[Variable] = SpMemAlloc( NBVLen );
        ASSERT( NewBootVars[Variable] );
        wcscpy( NewBootVars[Variable], L"" );
        for( i = 0; VarComponents[i]; i++ ) {
            wcscat( Temp, VarComponents[i] );
            if( VarComponents[i + 1] ) {
                wcscat( Temp, L";" );
            }

            if(i == 0) {
                wcscat( NewBootVars[Variable], VarComponents[i]);
            }
        }
    }

    if(bWriteVar) {
        Value = SpToOem( Temp );
        ArcStatus = HalSetEnvironmentVariable( NvramVarNames[ Variable ], Value );
        SpMemFree( Value );
    } else {
        ArcStatus = ENOMEM;
    }
    SpMemFree( Temp );

    return ( ArcStatus == ESUCCESS );
}


#ifdef _X86_
BOOLEAN
SpIsArc(
    VOID
    )

/*++

Routine Description:

    Run time check to determine if this is an Arc system. We attempt to read an
    Arc variable using the Hal. This will fail for Bios based systems.

Arguments:

    None

Return Value:

    True = This is an Arc system.

--*/

{
#define BUFFERLENGTH 512
    ARC_STATUS ArcStatus = EBADF;
    UCHAR   *buf;

    if (IsArcChecked) {
        return IsArcMachine;
    }

    IsArcChecked = TRUE;
    IsArcMachine = FALSE;

    //
    // Get the env var into the temp buffer.
    //
    buf = SpMemAlloc( BUFFERLENGTH );
    if( buf ) {
        ArcStatus = HalGetEnvironmentVariable(
                        NvramVarNames[ OSLOADER ],
                        BUFFERLENGTH,               //sizeof(TemporaryBuffer),
                        buf                         //(PUCHAR)TemporaryBuffer
                        );
        SpMemFree( buf );
    }
    if (ArcStatus == ESUCCESS) {
        IsArcMachine = TRUE;
    }

    return IsArcMachine;
}
#endif

VOID
SpFreeBootEntries (
    VOID
    )

/*++

Routine Description:

    Frees memory used to hold internal-format boot entries and options.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PSP_BOOT_ENTRY bootEntry;

    //
    // Free boot options. These will only be allocated on EFI machines.
    //
    if (SpBootOptions != NULL) {
        ASSERT(SpIsEfi());
        SpMemFree(SpBootOptions);
        SpBootOptions = NULL;
    }

    //
    // Free internal-format boot entries. These will be allocated on all
    // machines.
    //
    while (SpBootEntries != NULL) {

        bootEntry = SpBootEntries;
        SpBootEntries = bootEntry->Next;

        //
        // Space for some fields is allocated with the base structure.
        // If a fields address indicates that it was allocated with the
        // base structure, don't try to free it.
        //

#define IS_SEPARATE_ALLOCATION(_p)                                      \
        ((bootEntry->_p != NULL) &&                                     \
         (((PUCHAR)bootEntry->_p < (PUCHAR)bootEntry) ||                \
          ((PUCHAR)bootEntry->_p > (PUCHAR)bootEntry->AllocationEnd)))

#define FREE_IF_SEPARATE_ALLOCATION(_p)                                 \
        if (IS_SEPARATE_ALLOCATION(_p)) {                               \
            SpMemFree(bootEntry->_p);                                   \
        }

        FREE_IF_SEPARATE_ALLOCATION(FriendlyName);
        FREE_IF_SEPARATE_ALLOCATION(OsLoadOptions);
        FREE_IF_SEPARATE_ALLOCATION(LoaderPath);
        FREE_IF_SEPARATE_ALLOCATION(LoaderPartitionNtName);
        FREE_IF_SEPARATE_ALLOCATION(LoaderFile);
        FREE_IF_SEPARATE_ALLOCATION(OsPath);
        FREE_IF_SEPARATE_ALLOCATION(OsPartitionNtName);
        FREE_IF_SEPARATE_ALLOCATION(OsDirectory);
        FREE_IF_SEPARATE_ALLOCATION(Pid20Array);

        SpMemFree(bootEntry);
    }

    ASSERT(SpBootEntries == NULL);

    return;

} // SpFreeBootEntries

PCHAR
SppGetArcEnvVar(
    IN BOOTVAR Variable
    )

/*++

Routine Description:

    Query the value of an ARC environment variable.
    A buffer will be returned in all cases -- if the variable does not exist,
    the buffer will be empty.

Arguments:

    VarName - supplies the name of the arc environment variable
        whose value is desired.

Return Value:

    Buffer containing value of the environemnt variable.
    The caller must free this buffer with SpMemFree.

--*/

{
    ARC_STATUS ArcStatus;

    ASSERT( !SpIsEfi() );

    //
    // Get the env var into the temp buffer.
    //
    ArcStatus = HalGetEnvironmentVariable(
                    NvramVarNames[ Variable ],
                    sizeof(TemporaryBuffer),
                    (PCHAR) TemporaryBuffer
                    );

    if(ArcStatus != ESUCCESS) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: arc status %u getting env var %s\n",ArcStatus,NvramVarNames[Variable]));
        //
        // return empty buffer.
        //
        TemporaryBuffer[0] = 0;
    }

    return(SpDupString((PCHAR)TemporaryBuffer));
}

#ifdef _X86_
//
// NEC98
//
BOOLEAN
SpReInitializeBootVars_Nec98(
    VOID
)
{
    return SppReInitializeBootVars_Nec98( BootVars, &Default, &Timeout );
}
#endif

PWSTR
SpGetDefaultBootEntry (
    OUT UINT *DefaultSignatureOut
    )
{
    *DefaultSignatureOut = DefaultSignature;

    return Default;
}



VOID
SpDetermineUniqueAndPresentBootEntries(
    VOID
    )

/*++

Routine Description:

    This routine goes through the list of NT boot entries and marks all
    such entries that are both unique and present.

Arguments:

    None. This routine modifies entries in the SpBootEntries list as
    appropriate.

Return Value:

    None.

--*/
{
    PSP_BOOT_ENTRY BootEntry;
    PSP_BOOT_ENTRY BootEntry2;

    //
    // Initialize
    //

    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_LOOKING_FOR_WINNT,DEFAULT_STATUS_ATTRIBUTE);

    //
    // Go through all the matched boot sets and find out which NTs are
    // upgradeable/repairable. The criteria here are:
    //
    // 1. The system partition should exist and be valid.
    // 2. The OS load partition should exist.
    // 3. An NT should exist in <OSLoadPartition><OsDirectory>.
    // 4. OsLoadPartition should be a non-FT partition, or it should be a
    //    member 0 of a mirror.
    //

    for (BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {

        //
        // Initialize to false.
        //

        BootEntry->Processable = FALSE;

        //
        // If this entry has been deleted or is not an NT boot entry, skip it.
        //

        if (!IS_BOOT_ENTRY_WINDOWS(BootEntry) || IS_BOOT_ENTRY_DELETED(BootEntry)) {
            continue;
        }

        //
        // Check if the system and OS partitions are present and valid.
        //

        if ((BootEntry->LoaderPartitionDiskRegion == NULL) ||
            (BootEntry->OsPartitionDiskRegion == NULL)) {
            continue;
        }

        if (!BootEntry->LoaderPartitionDiskRegion->PartitionedSpace) {
            continue;
        }

        //
        // Check whether this directory has been covered before in the
        // boot entry list. This happens when multiple boot entries point
        // at the same tree. The comparison is done based on the system
        // partition region, the OS partition region, and the OS directory.
        //

        for ( BootEntry2 = SpBootEntries; BootEntry2 != BootEntry; BootEntry2 = BootEntry2->Next ) {
            if ((BootEntry->LoaderPartitionDiskRegion == BootEntry2->LoaderPartitionDiskRegion) &&
                (BootEntry->OsPartitionDiskRegion == BootEntry2->OsPartitionDiskRegion) &&
                (_wcsicmp(BootEntry->OsDirectory, BootEntry2->OsDirectory) == 0)) {
                break;
            }
        }
        if (BootEntry != BootEntry2) {
            //
            // This entry duplicates a previous entry. Skip it.
            //
            continue;
        }

        //
        // This boot entry is the first one to point to this OS directory.
        // Check whether an NT installation is actually present there.
        //

        if (SpIsNtInDirectory(BootEntry->OsPartitionDiskRegion, BootEntry->OsDirectory)
            // && !BootEntry->OsPartitionDiskRegion->FtPartition
            ) {
        }

        BootEntry->Processable = TRUE;
    }

    CLEAR_CLIENT_SCREEN();
    return;
}

VOID
SpRemoveInstallationFromBootList(
    IN  PDISK_REGION     SysPartitionRegion,   OPTIONAL
    IN  PDISK_REGION     NtPartitionRegion,    OPTIONAL
    IN  PWSTR            SysRoot,              OPTIONAL
    IN  PWSTR            SystemLoadIdentifier, OPTIONAL
    IN  PWSTR            SystemLoadOptions,    OPTIONAL
    IN  ENUMARCPATHTYPE  ArcPathType,
#if defined(REMOTE_BOOT)
    IN  BOOLEAN          RemoteBootPath,
#endif // defined(REMOTE_BOOT)
    OUT PWSTR            *OldOsLoadOptions     OPTIONAL
    )
{
    PWSTR   BootSet[MAXBOOTVARS];
    PWSTR   TempSysRoot = NULL;
    PWSTR   FirstBackslash;
    BOOTVAR i;
    WCHAR   Drive[] = L"?:";
    PWSTR   tmp2;
    PSP_BOOT_ENTRY bootEntry;

    //
    // Tell the user what we are doing.
    //
    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_CLEANING_FLEXBOOT,DEFAULT_STATUS_ATTRIBUTE);

    //
    // Find all boot entries that match the input specifications, and mark
    // them for deletion.
    //

    for (bootEntry = SpBootEntries; bootEntry != NULL; bootEntry = bootEntry->Next) {

        ASSERT(bootEntry->FriendlyName != NULL);
        if (IS_BOOT_ENTRY_WINDOWS(bootEntry)) {
            ASSERT(bootEntry->OsLoadOptions != NULL);
        }

        if (IS_BOOT_ENTRY_WINDOWS(bootEntry) &&
            !IS_BOOT_ENTRY_DELETED(bootEntry) &&
            ((SysPartitionRegion == NULL) ||
             (bootEntry->LoaderPartitionDiskRegion == SysPartitionRegion)) &&
            ((NtPartitionRegion == NULL) ||
             (bootEntry->OsPartitionDiskRegion == NtPartitionRegion)) &&
            ((SysRoot == NULL) ||
             ((bootEntry->OsDirectory != NULL) &&
              (_wcsicmp(bootEntry->OsDirectory, SysRoot) == 0))) &&
            ((SystemLoadIdentifier == NULL) ||
             (_wcsicmp(bootEntry->FriendlyName, SystemLoadIdentifier) == 0)) &&
            ((SystemLoadOptions == NULL) ||
             (_wcsicmp(bootEntry->OsLoadOptions, SystemLoadOptions) == 0))) {

            bootEntry->Status |= BE_STATUS_DELETED;

            if ((OldOsLoadOptions != NULL) && (*OldOsLoadOptions == NULL)) {
                *OldOsLoadOptions = SpDupStringW(bootEntry->OsLoadOptions);
            }
        }
    }

    //
    // If not on an EFI machine, then also delete matching ARC boot sets.
    //

    if (!SpIsEfi()) {
    
        //
        // Set up the boot set
        //
        for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
            BootSet[i] = NULL;
        }
    
        tmp2 = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);
    
        if( NtPartitionRegion ) {
            SpArcNameFromRegion(NtPartitionRegion,tmp2,sizeof(TemporaryBuffer)/2,PartitionOrdinalOnDisk,ArcPathType);
            BootSet[OSLOADPARTITION] = SpDupStringW(tmp2);
        }
    
        if( SysPartitionRegion ) {
            SpArcNameFromRegion(SysPartitionRegion,tmp2,sizeof(TemporaryBuffer)/2,PartitionOrdinalOnDisk,ArcPathType);
            BootSet[SYSTEMPARTITION] = SpDupStringW(tmp2);
        }
    
        BootSet[OSLOADFILENAME] = SysRoot;
        BootSet[LOADIDENTIFIER] = SystemLoadIdentifier;
        BootSet[OSLOADOPTIONS]  = SystemLoadOptions;
    
#if defined(REMOTE_BOOT)
        //
        // If this is a remote boot path, then move anything in OSLOADPARTITION
        // after (and including) the first backslash over to the OSLOADFILENAME --
        // this is the way that boot.ini is parsed when it is read, so it will
        // allow SpDeleteBootSet to match it properly.
        //
    
        if (RemoteBootPath && NtPartitionRegion &&
                (FirstBackslash = wcschr(BootSet[OSLOADPARTITION], L'\\'))) {
            wcscpy(tmp2, FirstBackslash);
            wcscat(tmp2, SysRoot);
            TempSysRoot = SpDupStringW(tmp2);
            BootSet[OSLOADFILENAME] = TempSysRoot;
            *FirstBackslash = L'\0';         // truncate BootSet[OSLOADPARTITION]
        }
#endif // defined(REMOTE_BOOT)
    
        //
        // Delete the boot set
        //
        SpDeleteBootSet(BootSet, OldOsLoadOptions);
    
        //
        // To take care of the case where the OSLOADPARTITION is a DOS drive letter
        // in the boot set, change the OSLOADPARTITION to a drive and retry
        // deletion
        //
        if( BootSet[OSLOADPARTITION] != NULL ) {
            SpMemFree(BootSet[OSLOADPARTITION]);
        }
        if( NtPartitionRegion && (ULONG)(Drive[0] = NtPartitionRegion->DriveLetter) != 0) {
            BootSet[OSLOADPARTITION] = Drive;
            SpDeleteBootSet(BootSet, OldOsLoadOptions);
        }
    
#ifdef _X86_
        //
        // If OldOsLoadOptions contains "/scsiordinal:", then remove it
        //
        if( ( OldOsLoadOptions != NULL ) &&
            ( *OldOsLoadOptions != NULL ) ) {
    
            PWSTR   p, q;
            WCHAR   SaveChar;
    
            SpStringToLower(*OldOsLoadOptions);
            p = wcsstr( *OldOsLoadOptions, L"/scsiordinal:" );
            if( p != NULL ) {
                SaveChar = *p;
                *p = (WCHAR)'\0';
                wcscpy(TemporaryBuffer, *OldOsLoadOptions);
                *p = SaveChar;
                q = wcschr( p, (WCHAR)' ' );
                if( q != NULL ) {
                    wcscat( TemporaryBuffer, q );
                }
                SpMemFree( *OldOsLoadOptions );
                *OldOsLoadOptions = SpDupStringW( ( PWSTR )TemporaryBuffer );
            }
        }
#endif
    
        //
        // Cleanup
        //
        if( BootSet[SYSTEMPARTITION] != NULL ) {
            SpMemFree(BootSet[SYSTEMPARTITION]);
        }
        if (TempSysRoot != NULL) {
            SpMemFree(TempSysRoot);
        }
    }
    return;
}


VOID
SpAddInstallationToBootList(
    IN PVOID        SifHandle,
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        SystemPartitionDirectory,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        Sysroot,
    IN BOOLEAN      BaseVideoOption,
    IN PWSTR        OldOsLoadOptions OPTIONAL
    )
/*++

Routine Description:

    Construct a boot set for the given installation
    parameters and add it to the current boot list.
    Perform modifications to the os load options if
    necessary.
          
Notes:  if this code changes, please ensure that 
    
            SpAddUserDefinedInstallationToBootList()
        
        stays in sync if appropriate.

--*/
{
    PWSTR   BootVars[MAXBOOTVARS];
    PWSTR   SystemPartitionArcName;
    PWSTR   TargetPartitionArcName;
    PWSTR   tmp;
    PWSTR   tmp2;
    PWSTR   SifKeyName;
    ULONG   Signature;
    BOOLEAN AddBaseVideo = FALSE;
    WCHAR   BaseVideoString[] = L"/basevideo";
    WCHAR   BaseVideoSosString[] = L"/sos";
    BOOLEAN AddSosToBaseVideoString;
    HEADLESS_RSP_QUERY_INFO Response;
    WCHAR   HeadlessRedirectString[] = L"/redirect";
#ifdef _X86_
    WCHAR   BootFastString[] = L"/fastdetect";
    BOOLEAN AddBootFastString = TRUE;
#endif
    ENUMARCPATHTYPE ArcPathType = PrimaryArcPath;
    WCHAR   HalString[] = L"/hal=";
    BOOLEAN OldOsLoadOptionsReplaced;
    NTSTATUS Status;
    SIZE_T Length;
    PWSTR LoadOptions;
    PWSTR LoadIdentifier;


    //
    // Tell the user what we are doing.
    //
    CLEAR_CLIENT_SCREEN();
    SpDisplayStatusText(SP_STAT_INITING_FLEXBOOT,DEFAULT_STATUS_ATTRIBUTE);

    OldOsLoadOptionsReplaced = FALSE;

    if( OldOsLoadOptions ) {
        PWSTR   p;

        tmp = SpDupStringW( OldOsLoadOptions );

        if (tmp) {
            SpStringToLower(tmp);

            if( p = wcsstr(tmp, HalString) ) {  // found /hal=
                WCHAR   SaveChar;
                PWSTR   q;

                SaveChar = *p;
                *p = L'\0';
                wcscpy( TemporaryBuffer, OldOsLoadOptions );
                q = TemporaryBuffer + wcslen( tmp );
                *q = L'\0';
                Length = wcslen( tmp );
                *p = SaveChar;
                for( ; *p && (*p != L' '); p++ ) {
                    Length++;
                }
                for( ; *p && (*p == L' '); p++ ) {
                    Length++;
                }
                if( *p ) {
                    wcscat( TemporaryBuffer, OldOsLoadOptions+Length );
                }
                OldOsLoadOptions = SpDupStringW( TemporaryBuffer );
                OldOsLoadOptionsReplaced = TRUE;
            }

            SpMemFree( tmp );
        }            
    }

    tmp2 = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);

    if (!SpIsEfi()) {
    
        //
        // Get an ARC name for the system partition.
        //
        if (SystemPartitionRegion != NULL) {
            SpArcNameFromRegion(
                SystemPartitionRegion,
                tmp2,
                sizeof(TemporaryBuffer)/2,
                PartitionOrdinalOnDisk,
                PrimaryArcPath
                );
            SystemPartitionArcName = SpDupStringW(tmp2);
        } else {
            SystemPartitionArcName = NULL;
        }
    
        //
        // Get an ARC name for the target partition.
        //
    
        //
        // If the partition is on a SCSI disk that has more than 1024 cylinders
        // and the partition has sectors located on cylinders beyond cylinder
        // 1024, the get the arc name in the secondary format. See also
        // spcopy.c!SpCreateNtbootddSys().
        //
        if(
            !SpIsArc() &&
#if defined(REMOTE_BOOT)
            !RemoteBootSetup &&
#endif // defined(REMOTE_BOOT)
    
#ifdef _X86_
            !SpUseBIOSToBoot(NtPartitionRegion, NULL, SifHandle) &&
#endif
            (HardDisks[NtPartitionRegion->DiskNumber].ScsiMiniportShortname[0]) ) {
    
            ArcPathType = SecondaryArcPath;
        } else {
            ArcPathType = PrimaryArcPath;
        }
    
        SpArcNameFromRegion(
            NtPartitionRegion,
            tmp2,
            sizeof(TemporaryBuffer)/2,
            PartitionOrdinalOnDisk,
            ArcPathType
            );
    
        TargetPartitionArcName = SpDupStringW(tmp2);
    }
    
    //
    // OSLOADOPTIONS is specified in the setup information file.
    //
    tmp = SpGetSectionKeyIndex(
                WinntSifHandle,
                SIF_SETUPDATA,
                SIF_OSLOADOPTIONSVAR,
                0
                );
    if (tmp == NULL) {
        tmp = SpGetSectionKeyIndex(
                SifHandle,
                SIF_SETUPDATA,
                SIF_OSLOADOPTIONSVAR,
                0
                );
    }

    //
    // If OsLoadOptionsVar wasn't specified, then we'll preserve any flags
    // the user had specified.
    //
    if(!tmp && OldOsLoadOptions) {
        tmp = OldOsLoadOptions;
    }

    AddSosToBaseVideoString = BaseVideoOption;
    AddBaseVideo = BaseVideoOption;

    if(tmp) {
        //
        // make sure we don't already have a /basevideo option, so we
        // won't add another
        //

        wcscpy(TemporaryBuffer, tmp);
        SpStringToLower(TemporaryBuffer);
        if(wcsstr(TemporaryBuffer, BaseVideoString)) {  // already have /basevideo
            BaseVideoOption = TRUE;
            AddBaseVideo = FALSE;
        }
        if(wcsstr(TemporaryBuffer, BaseVideoSosString)) {  // already have /sos
            AddSosToBaseVideoString = FALSE;
        }
#ifdef _X86_
        if(wcsstr(TemporaryBuffer, BootFastString)) {  // already have /bootfast
            AddBootFastString = FALSE;
        }
#endif
    }

    if(AddBaseVideo || AddSosToBaseVideoString
#ifdef _X86_
       || AddBootFastString
#endif
      ) {

        Length = ((tmp ? wcslen(tmp) + 1 : 0) * sizeof(WCHAR));
        if( AddBaseVideo ) {
            Length += sizeof(BaseVideoString);
        }
        if( AddSosToBaseVideoString ) {
            Length += sizeof( BaseVideoSosString );
        }
#ifdef _X86_
        if( AddBootFastString ) {
            Length += sizeof( BootFastString );
        }
#endif

        tmp2 = SpMemAlloc(Length);

        *tmp2 = ( WCHAR )'\0';
        if( AddBaseVideo ) {
            wcscat(tmp2, BaseVideoString);
        }
        if( AddSosToBaseVideoString ) {
            if( *tmp2 != (WCHAR)'\0' ) {
                wcscat(tmp2, L" ");
            }
            wcscat(tmp2, BaseVideoSosString);
        }
#ifdef _X86_
        if( AddBootFastString ) {
            if( *tmp2 != (WCHAR)'\0' ) {
                wcscat(tmp2, L" ");
            }
            wcscat(tmp2, BootFastString);
        }
#endif
        if(tmp) {
            if( *tmp2 != (WCHAR)'\0' ) {
                wcscat(tmp2, L" ");
            }
            wcscat(tmp2, tmp);
        }

        LoadOptions = SpDupStringW(tmp2);

        SpMemFree(tmp2);

    } else {
        LoadOptions = SpDupStringW(tmp ? tmp : L"");
    }

    //
    // Add on headless redirect parameter if we are redirecting right now.
    //

    Length = sizeof(HEADLESS_RSP_QUERY_INFO);
    Status = HeadlessDispatch(HeadlessCmdQueryInformation,
                              NULL,
                              0,
                              &Response,
                              &Length
                             );

    if (NT_SUCCESS(Status) && 
        (Response.PortType == HeadlessSerialPort) &&
        Response.Serial.TerminalAttached) {

        //
        // Before we go adding a /redirect string, we need to make
        // sure there's not already one.
        //
        if( !wcsstr(LoadOptions, HeadlessRedirectString) ) {

            Length = (wcslen(LoadOptions) + 1) * sizeof(WCHAR);
            Length += sizeof(HeadlessRedirectString);

            tmp2 = SpMemAlloc(Length);
            ASSERT(tmp2 != NULL);

            *tmp2 = UNICODE_NULL;

            wcscat(tmp2, LoadOptions);
            if (*tmp2 != UNICODE_NULL) {
                wcscat(tmp2, L" ");
            }
            wcscat(tmp2, HeadlessRedirectString);

            SpMemFree(LoadOptions);

            LoadOptions = tmp2;
        }
    }

    //
    // LOADIDENTIFIER is specified in the setup information file.
    // We need to surround it in double quotes.
    // Which value to use depends on the BaseVideo flag.
    //
    SifKeyName = BaseVideoOption ? SIF_BASEVIDEOLOADID : SIF_LOADIDENTIFIER;

    tmp = SpGetSectionKeyIndex(SifHandle,SIF_SETUPDATA,SifKeyName,0);

    if(!tmp) {
        SpFatalSifError(SifHandle,SIF_SETUPDATA,SifKeyName,0,0);
    }

    if(!SpIsArc()) {
        //
        // Need quotation marks around the description on x86.
        //
        LoadIdentifier = SpMemAlloc((wcslen(tmp)+3)*sizeof(WCHAR));
        LoadIdentifier[0] = L'\"';
        wcscpy(LoadIdentifier+1,tmp);
        wcscat(LoadIdentifier,L"\"");
    } else {
        LoadIdentifier = SpDupStringW(tmp);
    }

    //
    // Create a new internal-format boot entry.
    //
    tmp = TemporaryBuffer;
    wcscpy(tmp,SystemPartitionDirectory);
    SpConcatenatePaths(
        tmp,
#ifdef _X86_
        SpIsArc() ? L"arcldr.exe" : L"ntldr"
#elif _IA64_
        L"ia64ldr.efi"
#else
        L"osloader.exe"
#endif
        );
    tmp = SpDupStringW(tmp);

    SpCreateBootEntry(
        BE_STATUS_NEW,
        SystemPartitionRegion,
        tmp,
        NtPartitionRegion,
        Sysroot,
        LoadOptions,
        LoadIdentifier
        );

    SpMemFree(tmp);

    //
    // If not on an EFI machine, add a new ARC-style boot set.
    //
    if (!SpIsEfi()) {
    
        BootVars[OSLOADOPTIONS] = LoadOptions;
        BootVars[LOADIDENTIFIER] = LoadIdentifier;
    
        //
        // OSLOADER is the system partition path + the system partition directory +
        //          osloader.exe. (ntldr on x86 machines).
        //
        if (SystemPartitionRegion != NULL) {
            tmp = TemporaryBuffer;
            wcscpy(tmp,SystemPartitionArcName);
            SpConcatenatePaths(tmp,SystemPartitionDirectory);
            SpConcatenatePaths(
                tmp,
#ifdef _X86_
                (SpIsArc() ? L"arcldr.exe" : L"ntldr")
#elif _IA64_
                L"ia64ldr.efi"
#else
                L"osloader.exe"
#endif
                );
    
            BootVars[OSLOADER] = SpDupStringW(tmp);
        } else {
            BootVars[OSLOADER] = SpDupStringW(L"");
        }
    
        //
        // OSLOADPARTITION is the ARC name of the windows nt partition.
        //
        BootVars[OSLOADPARTITION] = TargetPartitionArcName;
    
        //
        // OSLOADFILENAME is sysroot.
        //
        BootVars[OSLOADFILENAME] = Sysroot;
    
        //
        // SYSTEMPARTITION is the ARC name of the system partition.
        //
        if (SystemPartitionRegion != NULL) {
            BootVars[SYSTEMPARTITION] = SystemPartitionArcName;
        } else {
            BootVars[SYSTEMPARTITION] = L"";
        }
    
        //
        // get the disk signature
        //
        if ((NtPartitionRegion->DiskNumber != 0xffffffff) && HardDisks[NtPartitionRegion->DiskNumber].Signature) {
            Signature = HardDisks[NtPartitionRegion->DiskNumber].Signature;
        } else {
            Signature = 0;
        }
    
        //
        // Add the boot set and make it the default.
        //
        SpAddBootSet(BootVars, TRUE, Signature);

        SpMemFree(BootVars[OSLOADER]);
    }

    //
    // Free memory allocated.
    //
    SpMemFree(LoadOptions);
    SpMemFree(LoadIdentifier);

    if (!SpIsEfi()) {
        if (SystemPartitionArcName != NULL) {
            SpMemFree(SystemPartitionArcName);
        }
        SpMemFree(TargetPartitionArcName);
    }

    if( OldOsLoadOptionsReplaced ) {
        SpMemFree( OldOsLoadOptions );
    }
}


VOID
SpCompleteBootListConfig(
    WCHAR   DriveLetter
    )
{
    if(!RepairWinnt) {
        if (!SpIsArc()) {
            Timeout = 1;
        } else {
            Timeout = 5;
            //
            // If this is a winnt setup, there will be a boot set to start
            // text setup ("Install/Upgrade Windows NT").  Remove it here.
            //
            if(WinntSetup) {

                PSP_BOOT_ENTRY bootEntry;

                for (bootEntry = SpBootEntries; bootEntry != NULL; bootEntry = bootEntry->Next) {
                    if (IS_BOOT_ENTRY_WINDOWS(bootEntry) &&
                        !IS_BOOT_ENTRY_DELETED(bootEntry) &&
                        (_wcsicmp(bootEntry->OsLoadOptions, L"WINNT32") == 0)) {
                        bootEntry->Status |= BE_STATUS_DELETED;
                    }
                }

                if (!SpIsEfi()) {
                
                    PWSTR BootVars[MAXBOOTVARS];

                    RtlZeroMemory(BootVars,sizeof(BootVars));

                    BootVars[OSLOADOPTIONS] = L"WINNT32";

                    SpDeleteBootSet(BootVars, NULL);
                }
            }
        }
    }

#ifdef _X86_
    if (g_Win9xBackup) {
        SpRemoveExtraBootIniEntry();
    }
#endif

    //
    // Flush boot vars.
    // On some machines, NVRAM update takes a few seconds,
    // so change the message to tell the user we are doing something different.
    //
    SpDisplayStatusText(SP_STAT_UPDATING_NVRAM,DEFAULT_STATUS_ATTRIBUTE);

    if(!SpFlushBootVars()) {
        if(SpIsEfi() || !SpIsArc()) {
            //
            // Fatal on x86 and EFI machines, nonfatal on arc machines.
            //
            if (SpIsEfi()) {
                SpStartScreen(SP_SCRN_CANT_INIT_FLEXBOOT_EFI,
                              3,
                              HEADER_HEIGHT+1,
                              FALSE,
                              FALSE,
                              DEFAULT_ATTRIBUTE
                              );
            } else {
                WCHAR   DriveLetterString[2];
    
                DriveLetterString[0] = DriveLetter;
                DriveLetterString[1] = L'\0';
                SpStringToUpper(DriveLetterString);
                SpStartScreen(SP_SCRN_CANT_INIT_FLEXBOOT,
                              3,
                              HEADER_HEIGHT+1,
                              FALSE,
                              FALSE,
                              DEFAULT_ATTRIBUTE,
                              DriveLetterString,
                              DriveLetterString
                              );
            }
            SpDisplayStatusText(SP_STAT_F3_EQUALS_EXIT,DEFAULT_STATUS_ATTRIBUTE);
            SpInputDrain();
            while(SpInputGetKeypress() != KEY_F3) ;
            SpDone(0,FALSE,TRUE);
        } else {
            BOOL b;

            b = TRUE;
            while(b) {
                ULONG ValidKeys[2] = { ASCI_CR, 0 };

                SpStartScreen(
                    SP_SCRN_CANT_UPDATE_BOOTVARS,
                    3,
                    HEADER_HEIGHT+1,
                    FALSE,
                    FALSE,
                    DEFAULT_ATTRIBUTE,
                    NewBootVars[LOADIDENTIFIER],
                    NewBootVars[OSLOADER],
                    NewBootVars[OSLOADPARTITION],
                    NewBootVars[OSLOADFILENAME],
                    NewBootVars[OSLOADOPTIONS],
                    NewBootVars[SYSTEMPARTITION]
                    );

                SpDisplayStatusOptions(
                    DEFAULT_STATUS_ATTRIBUTE,
                    SP_STAT_ENTER_EQUALS_CONTINUE,
                    0
                    );

                switch(SpWaitValidKey(ValidKeys,NULL,NULL)) {
                case ASCI_CR:
                    b = FALSE;
                }
            }
        }
    }

    if(SpIsArc() && !SpIsEfi()) {
        // Free all of the boot variable strings
        BOOTVAR i;

        for(i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
            SpMemFree(NewBootVars[i]);
            NewBootVars[i] = NULL;
        }
    }
}

VOID
SpPtDeleteBootSetsForRegion(
    PDISK_REGION Region
    )
/*++

Routine Description:

    This routine goes through all the valid boot entries and
    deletes the ones which point to the specified region.

Arguments:

    Region : The region whose references from boot entries need
    to be removed

Return Value:

    None.

--*/
{
    PWSTR bootSet[MAXBOOTVARS];
    ENUMARCPATHTYPE arcPathType;
    ULONG i;
    PSP_BOOT_ENTRY bootEntry;

    if (Region->PartitionedSpace) {
        BOOLEAN IsSystemPartition = SPPT_IS_REGION_SYSTEMPARTITION(Region);
        
        //
        // Find all boot entries that have the specified region as the
        // OS load partition, and mark them for deletion.
        //
        for (bootEntry = SpBootEntries; bootEntry != NULL; bootEntry = bootEntry->Next) {
            if (IS_BOOT_ENTRY_WINDOWS(bootEntry) &&
                !IS_BOOT_ENTRY_DELETED(bootEntry) &&
                (IsSystemPartition ? (bootEntry->LoaderPartitionDiskRegion == Region) :
                                     (bootEntry->OsPartitionDiskRegion == Region))) {
                bootEntry->Status |= BE_STATUS_DELETED;

                //
                // Make the regions also NULL since they might have actually
                // been deleted
                //
                bootEntry->LoaderPartitionDiskRegion = NULL;
                bootEntry->OsPartitionDiskRegion = NULL;
            }
        }

        //
        // If we're not on an EFI machine, we also have to munge the ARC
        // boot variables.
        //

        if (!SpIsEfi()) {
        
            //
            // Set up the boot set
            //
            for (i = FIRSTBOOTVAR; i <= LASTBOOTVAR; i++) {
                bootSet[i] = NULL;
            }
    
            //
            // We go through this loop twice, once for primary ARC path
            // and once for secondary. We delete any image which has
            // the OS load partition on the region we are deleting.
            //
    
            for (i = 0; i < 2; i++) {
    
                if (i == 0) {
                    arcPathType = PrimaryArcPath;
                } else {
                    arcPathType = SecondaryArcPath;
                }
    
                SpArcNameFromRegion(
                    Region,
                    TemporaryBuffer,
                    sizeof(TemporaryBuffer),
                    PartitionOrdinalOnDisk,
                    arcPathType);
    
                if ((TemporaryBuffer)[0] != L'\0') {
                    ULONG   Index = IsSystemPartition ? 
                                        SYSTEMPARTITION : OSLOADPARTITION;
                    
                    bootSet[Index] = SpDupStringW(TemporaryBuffer);
                    SpDeleteBootSet(bootSet, NULL);
                    SpMemFree(bootSet[Index]);
    
                }
            }
        }
    }
}

VOID
SpGetNtDirectoryList(
    OUT PWSTR  **DirectoryList,
    OUT PULONG   DirectoryCount
    )

/*++

Routine Description:

    Determine the list of directories into which NT may be installed.
    This is independent of the partitions onto which it may be installed.

    The determination of which directories nt might be in is based on
    boot.ini in the x86 case, or on arc firmware (OSLOADFILENAME var)
    in the arc case.

Arguments:

    DirectoryList - receives a pointer to an array of strings,
        each of which contains a possible windows nt tree.

    DirectoryCount - receives the number of elements in DirectoryList.
        This may be 0.

Return Value:

    None.  The caller must free the array in DirectoryList if
    DirectoryCount is returned as non-0.

--*/

{
    ULONG count;
    PSP_BOOT_ENTRY BootEntry;
    PSP_BOOT_ENTRY BootEntry2;
    PWSTR *DirList;

    //
    // Free any previously allocated list.
    //
    if (CurrentNtDirectoryList != NULL) {
        SpMemFree(CurrentNtDirectoryList);
    }

    //
    // Walk the boot entry list to determine how many unique NT directory names
    // exist.
    //
    count = 0;
    for (BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {
        if (!IS_BOOT_ENTRY_WINDOWS(BootEntry) || (BootEntry->OsDirectory == NULL)) {
            continue;
        }
        for (BootEntry2 = SpBootEntries; BootEntry2 != BootEntry; BootEntry2 = BootEntry2->Next) {
            if (!IS_BOOT_ENTRY_WINDOWS(BootEntry2) || (BootEntry2->OsDirectory == NULL)) {
                continue;
            }
            if (_wcsicmp(BootEntry2->OsDirectory, BootEntry->OsDirectory) == 0) {
                break;
            }
        }
        if (BootEntry2 == BootEntry) {
            count++;
        }
    }

    //
    // Allocate space for the list.
    //
    DirList = SpMemAlloc(count * sizeof(PWSTR));
    ASSERT(DirList != NULL);

    //
    // Populate the list.
    //
    count = 0;
    for (BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {
        if (!IS_BOOT_ENTRY_WINDOWS(BootEntry) || (BootEntry->OsDirectory == NULL)) {
            continue;
        }
        for (BootEntry2 = SpBootEntries; BootEntry2 != BootEntry; BootEntry2 = BootEntry2->Next) {
            if (!IS_BOOT_ENTRY_WINDOWS(BootEntry2) || (BootEntry2->OsDirectory == NULL)) {
                continue;
            }
            if (_wcsicmp(BootEntry2->OsDirectory, BootEntry->OsDirectory) == 0) {
                break;
            }
        }
        if (BootEntry2 == BootEntry) {
            DirList[count++] = BootEntry->OsDirectory;
        }
    }

    //
    // Return a pointer to the list that we allocated.
    //
    CurrentNtDirectoryList = DirList;
    *DirectoryList = DirList;
    *DirectoryCount = count;

    return;
}

BOOLEAN
SpConvertArcBootEntries (
    IN ULONG MaxComponents
    )

/*++

Routine Description:

    Convert ARC boot entries (read from boot.ini or from ARC NVRAM) into
    our internal format.

Arguments:

    MaxComponents - maximum number of elements in any NVRAM variable.

Return Value:

    BOOLEAN - FALSE if any unexpected errors occurred.

--*/

{
    LONG i;
    PDISK_REGION systemPartitionRegion;
    PDISK_REGION ntPartitionRegion;
    PWSTR loaderName;

    for (i = (LONG)MaxComponents - 1; i >= 0; i--) {

        //
        // Skip this boot set if it is not complete.
        //
        
        if ((BootVars[SYSTEMPARTITION][i] != NULL) &&
            (BootVars[OSLOADPARTITION][i] != NULL) &&
            (BootVars[OSLOADER][i] != NULL) &&
            (BootVars[OSLOADFILENAME][i] != NULL) &&
            (BootVars[OSLOADOPTIONS][i] != NULL) &&
            (BootVars[LOADIDENTIFIER][i] != NULL)) {

            //
            // Translate the SYSTEMPARTITION and OSLOADPARTITION ARC names
            // into disk region pointers. Get the loader file name from
            // OSLOADER, which contains an ARC name (same as OSLOADPARTITION)
            // and a file name.
            //
            systemPartitionRegion = SpRegionFromArcName(
                                        BootVars[SYSTEMPARTITION][i],
                                        PartitionOrdinalCurrent,
                                        NULL
                                        );

            ntPartitionRegion = SpRegionFromArcName(
                                        BootVars[OSLOADPARTITION][i],
                                        PartitionOrdinalCurrent,
                                        NULL
                                        );

            //
            // Take care of duplicate arc names for the same disk by searching
            // and validating the NT directory is present on the partition
            //
            while (ntPartitionRegion &&
                    !SpIsNtInDirectory(ntPartitionRegion, BootVars[OSLOADFILENAME][i])) {
                //                                
                // Continue to look for same name region from the current 
                // searched region
                //
                ntPartitionRegion = SpRegionFromArcName(
                                            BootVars[OSLOADPARTITION][i],
                                            PartitionOrdinalCurrent,
                                            ntPartitionRegion
                                            );
            }
                                                    
            loaderName = wcschr(BootVars[OSLOADER][i], L'\\');

            //
            // If all of the above worked, then add an internal-format boot
            // entry for this ARC boot set.
            //
            if ((systemPartitionRegion != NULL) &&
                (ntPartitionRegion != NULL) &&
                (loaderName != NULL)) {

                SpCreateBootEntry(
                    BE_STATUS_FROM_BOOT_INI,
                    systemPartitionRegion,
                    loaderName,
                    ntPartitionRegion,
                    BootVars[OSLOADFILENAME][i],
                    BootVars[OSLOADOPTIONS][i],
                    BootVars[LOADIDENTIFIER][i]
                    );
            }
        }
    }

    return TRUE;
}

VOID
SpUpdateRegionForBootEntries(
    VOID
    )
/*++

Routine Description:

    Update the region pointers for all the given boot entries.

    NOTE : The region pointers change with every commit so we
    can't cache them across commits.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PSP_BOOT_ENTRY BootEntry;

    //
    // Walk through each boot entry and update its system partition region
    // pointer and NT partition region pointer.
    //
    for (BootEntry = SpBootEntries; BootEntry != NULL; BootEntry = BootEntry->Next) {

        if (!IS_BOOT_ENTRY_DELETED(BootEntry)) {
            if (BootEntry->LoaderPartitionNtName != NULL) {
                BootEntry->LoaderPartitionDiskRegion = 
                    SpRegionFromNtName(BootEntry->LoaderPartitionNtName,
                                       PartitionOrdinalCurrent);
            } else {
                BootEntry->LoaderPartitionDiskRegion = NULL;
            }            

            if (BootEntry->OsPartitionNtName != NULL) {
                BootEntry->OsPartitionDiskRegion =
                    SpRegionFromNtName(BootEntry->OsPartitionNtName,
                                       PartitionOrdinalCurrent);
            } else {
                BootEntry->OsPartitionDiskRegion = NULL;
            }            
        }
    }

    return;

} // SpUpdateRegionForBootEntries

VOID
SpCreateBootEntry (
    IN ULONG_PTR Status,
    IN PDISK_REGION BootFileRegion,
    IN PWSTR BootFilePath,
    IN PDISK_REGION OsLoadRegion,
    IN PWSTR OsLoadPath,
    IN PWSTR OsLoadOptions,
    IN PWSTR FriendlyName
    )

/*++

Routine Description:

    Create an internal-format boot entry.

Arguments:

    Status - The status to be assigned to the boot entry. This should be either
        zero (for an entry already in NVRAM) or BE_STATUS_NEW for a new boot
        entry. Entries marked BE_STATUS_NEW are written to NVRAM at the end
        of textmode setup.

    BootFileRegion - The disk region on which the OS loader resides.

    BootFilePath - The volume-relative path to the OS loader. Must start with
        a backslash.

    OsLoadRegion - The disk region on which the OS resides.

    OsLoadPath - The volume-relative path to the OS root directory (\WINDOWS).
        Must start with a backslash.

    OsLoadOptions - Boot options for the OS. Can be an empty string.

    FriendlyName - The user-visible name for the boot entry. (This is ARC's
        LOADIDENTIFIER.)

Return Value:

    None. Only memory allocation failures are possible, and these are
        handled out-of-band.

--*/

{
    NTSTATUS status;
    ULONG requiredLength;
    ULONG osOptionsOffset;
    ULONG osLoadOptionsLength;
    ULONG osLoadPathOffset;
    ULONG osLoadPathLength;
    ULONG osOptionsLength;
    ULONG friendlyNameOffset;
    ULONG friendlyNameLength;
    ULONG bootPathOffset;
    ULONG bootPathLength;
    PSP_BOOT_ENTRY myBootEntry;
    PSP_BOOT_ENTRY previousBootEntry;
    PSP_BOOT_ENTRY nextBootEntry;
    PBOOT_ENTRY ntBootEntry;
    PWINDOWS_OS_OPTIONS osOptions;
    PFILE_PATH osLoadPath;
    PWSTR friendlyName;
    PFILE_PATH bootPath;
    PWSTR p;

    PWSTR bootFileDevice;
    PWSTR osLoadDevice;

    //
    // Get NT names for the input disk regions.
    //
    bootFileDevice = SpMemAlloc(512);
    SpNtNameFromRegion(BootFileRegion, bootFileDevice, 512, PartitionOrdinalCurrent);

    osLoadDevice = SpMemAlloc(512);
    SpNtNameFromRegion(OsLoadRegion, osLoadDevice, 512, PartitionOrdinalCurrent);

    //
    // Calculate how long the internal boot entry needs to be. This includes
    // our internal structure, plus the BOOT_ENTRY structure that the NT APIs
    // use.
    //
    // Our structure:
    //
    requiredLength = FIELD_OFFSET(SP_BOOT_ENTRY, NtBootEntry);

    //
    // Base part of NT structure:
    //
    requiredLength += FIELD_OFFSET(BOOT_ENTRY, OsOptions);

    //
    // Save offset to BOOT_ENTRY.OsOptions. Add in base part of
    // WINDOWS_OS_OPTIONS. Calculate length in bytes of OsLoadOptions
    // and add that in.
    //
    osOptionsOffset = requiredLength;
    requiredLength += FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions);
    osLoadOptionsLength = (wcslen(OsLoadOptions) + 1) * sizeof(WCHAR);
    requiredLength += osLoadOptionsLength;

    //
    // Round up to a ULONG boundary for the OS FILE_PATH in the
    // WINDOWS_OS_OPTIONS. Save offset to OS FILE_PATH. Add in base part
    // of FILE_PATH. Add in length in bytes of OS device NT name and OS
    // directory. Calculate total length of OS FILE_PATH and of
    // WINDOWS_OS_OPTIONS.
    // 
    requiredLength = ALIGN_UP(requiredLength, ULONG);
    osLoadPathOffset = requiredLength;
    requiredLength += FIELD_OFFSET(FILE_PATH, FilePath);
    requiredLength += (wcslen(osLoadDevice) + 1 + wcslen(OsLoadPath) + 1) * sizeof(WCHAR);
    osLoadPathLength = requiredLength - osLoadPathOffset;
    osOptionsLength = requiredLength - osOptionsOffset;

    //
    // Round up to a ULONG boundary for the friendly name in the BOOT_ENTRY.
    // Save offset to friendly name. Calculate length in bytes of friendly name
    // and add that in.
    //
    requiredLength = ALIGN_UP(requiredLength, ULONG);
    friendlyNameOffset = requiredLength;
    friendlyNameLength = (wcslen(FriendlyName) + 1) * sizeof(WCHAR);
    requiredLength += friendlyNameLength;

    //
    // Round up to a ULONG boundary for the boot FILE_PATH in the BOOT_ENTRY.
    // Save offset to boot FILE_PATH. Add in base part of FILE_PATH. Add in
    // length in bytes of boot device NT name and boot file. Calculate total
    // length of boot FILE_PATH.
    //
    requiredLength = ALIGN_UP(requiredLength, ULONG);
    bootPathOffset = requiredLength;
    requiredLength += FIELD_OFFSET(FILE_PATH, FilePath);
    requiredLength += (wcslen(bootFileDevice) + 1 + wcslen(BootFilePath) + 1) * sizeof(WCHAR);
    bootPathLength = requiredLength - bootPathOffset;

    //
    // Allocate memory for the boot entry.
    //
    myBootEntry = SpMemAlloc(requiredLength);
    ASSERT(myBootEntry != NULL);

    RtlZeroMemory(myBootEntry, requiredLength);

    //
    // Calculate addresses of various substructures using the saved offsets.
    //
    ntBootEntry = &myBootEntry->NtBootEntry;
    osOptions = (PWINDOWS_OS_OPTIONS)ntBootEntry->OsOptions;
    osLoadPath = (PFILE_PATH)((PUCHAR)myBootEntry + osLoadPathOffset);
    friendlyName = (PWSTR)((PUCHAR)myBootEntry + friendlyNameOffset);
    bootPath = (PFILE_PATH)((PUCHAR)myBootEntry + bootPathOffset);

    //
    // Fill in the internal-format structure.
    //
    myBootEntry->AllocationEnd = (PUCHAR)myBootEntry + requiredLength;
    myBootEntry->Status = Status | BE_STATUS_ORDERED;
    myBootEntry->FriendlyName = friendlyName;
    myBootEntry->FriendlyNameLength = friendlyNameLength;
    myBootEntry->OsLoadOptions = osOptions->OsLoadOptions;
    myBootEntry->OsLoadOptionsLength = osLoadOptionsLength;
    myBootEntry->LoaderPath = bootPath;
    myBootEntry->OsPath = osLoadPath;
    myBootEntry->LoaderPartitionDiskRegion = BootFileRegion;
    myBootEntry->OsPartitionDiskRegion = OsLoadRegion;

    //
    // Fill in the base part of the NT boot entry.
    //
    ntBootEntry->Version = BOOT_ENTRY_VERSION;
    ntBootEntry->Length = requiredLength - FIELD_OFFSET(SP_BOOT_ENTRY, NtBootEntry);
    ntBootEntry->Attributes = BOOT_ENTRY_ATTRIBUTE_ACTIVE | BOOT_ENTRY_ATTRIBUTE_WINDOWS;
    ntBootEntry->FriendlyNameOffset = (ULONG)((PUCHAR)friendlyName - (PUCHAR)ntBootEntry);
    ntBootEntry->BootFilePathOffset = (ULONG)((PUCHAR)bootPath - (PUCHAR)ntBootEntry);
    ntBootEntry->OsOptionsLength = osOptionsLength;

    //
    // Fill in the base part of the WINDOWS_OS_OPTIONS, including the
    // OsLoadOptions.
    //
    strcpy(osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE);
    osOptions->Version = WINDOWS_OS_OPTIONS_VERSION;
    osOptions->Length = osOptionsLength;
    osOptions->OsLoadPathOffset = (ULONG)((PUCHAR)osLoadPath - (PUCHAR)osOptions);
    wcscpy(osOptions->OsLoadOptions, OsLoadOptions);

    //
    // Fill in the OS FILE_PATH.
    //
    osLoadPath->Version = FILE_PATH_VERSION;
    osLoadPath->Length = osLoadPathLength;
    osLoadPath->Type = FILE_PATH_TYPE_NT;
    p = (PWSTR)osLoadPath->FilePath;
    myBootEntry->OsPartitionNtName = p;
    wcscpy(p, osLoadDevice);
    p += wcslen(p) + 1;
    myBootEntry->OsDirectory = p;
    wcscpy(p, OsLoadPath);

    //
    // Copy the friendly name.
    //
    wcscpy(friendlyName, FriendlyName);

    //
    // Fill in the boot FILE_PATH.
    //
    bootPath->Version = FILE_PATH_VERSION;
    bootPath->Length = bootPathLength;
    bootPath->Type = FILE_PATH_TYPE_NT;
    p = (PWSTR)bootPath->FilePath;
    myBootEntry->LoaderPartitionNtName = p;
    wcscpy(p, bootFileDevice);
    p += wcslen(p) + 1;
    myBootEntry->LoaderFile = p;
    wcscpy(p, BootFilePath);

    //
    // Link the new boot entry into the list, after any removable media
    // entries that are at the front of the list.
    //

    previousBootEntry = NULL;
    nextBootEntry = SpBootEntries;
    while ((nextBootEntry != NULL) &&
           IS_BOOT_ENTRY_REMOVABLE_MEDIA(nextBootEntry)) {
        previousBootEntry = nextBootEntry;
        nextBootEntry = nextBootEntry->Next;
    }
    myBootEntry->Next = nextBootEntry;
    if (previousBootEntry == NULL) {
        SpBootEntries = myBootEntry;
    } else {
        previousBootEntry->Next = myBootEntry;
    }

    //
    // Free local memory.
    //
    SpMemFree(bootFileDevice);
    SpMemFree(osLoadDevice);

    return;

} // SpCreateBootEntry

#if defined(EFI_NVRAM_ENABLED)

BOOLEAN
SpBuildHarddiskNameTranslations (
    VOID
    )

/*++

Routine Description:

    Build a list of the translations of all \Device\HarddiskN\PartitionM
    symbolic links to \Device\HarddiskVolumeN device names.

Arguments:

    None.

Return Value:

    BOOLEAN - FALSE if an unexpected error occurred.

--*/

{
    NTSTATUS status;
    OBJECT_ATTRIBUTES obja;
    UNICODE_STRING unicodeString;
    HANDLE deviceHandle;
    HANDLE diskHandle;
    HANDLE linkHandle;
    PUCHAR buffer1;
    PUCHAR buffer2;
    BOOLEAN restartScan;
    ULONG context1;
    ULONG context2;
    POBJECT_DIRECTORY_INFORMATION dirInfo1;
    POBJECT_DIRECTORY_INFORMATION dirInfo2;
    PWSTR linkName;
    PWSTR p;
    PHARDDISK_NAME_TRANSLATION translation;

    //
    // Allocate buffers for directory queries.
    //

#define BUFFER_SIZE 2048

    buffer1 = SpMemAlloc(BUFFER_SIZE);
    buffer2 = SpMemAlloc(BUFFER_SIZE);

    //
    // Open the \Device directory.
    //
    INIT_OBJA(&obja, &unicodeString, L"\\device");

    status = ZwOpenDirectoryObject(&deviceHandle, DIRECTORY_ALL_ACCESS, &obja);

    if (!NT_SUCCESS(status)) {
        ASSERT(FALSE);
        goto cleanup;
    }

    restartScan = TRUE;
    context1 = 0;

    do {

        //
        // Search the \Device directory for HarddiskN subdirectories.
        //
        status = ZwQueryDirectoryObject(
                    deviceHandle,
                    buffer1,
                    BUFFER_SIZE,
                    TRUE,
                    restartScan,
                    &context1,
                    NULL
                    );

        restartScan = FALSE;

        if (!NT_SUCCESS(status)) {
            if (status != STATUS_NO_MORE_ENTRIES) {
                ASSERT(FALSE);
                goto cleanup;
            }
            status = STATUS_SUCCESS;
            break;
        }

        //
        // We only care about directories with HarddiskN names.
        //
        dirInfo1 = (POBJECT_DIRECTORY_INFORMATION)buffer1;

        if ((dirInfo1->Name.Length < sizeof(L"harddisk")) ||
           (dirInfo1->TypeName.Length < (sizeof(L"Directory") - sizeof(WCHAR))) ||
           (_wcsnicmp(dirInfo1->TypeName.Buffer,L"Directory",wcslen(L"Directory")) != 0)) {
            continue;
        }

        SpStringToLower(dirInfo1->Name.Buffer);

        if (wcsncmp(dirInfo1->Name.Buffer, L"harddisk", wcslen(L"harddisk")) != 0) {
            continue;
        }

        p = dirInfo1->Name.Buffer + wcslen(L"Harddisk");
        if (*p == 0) {
            continue;
        }
        do {
            if ((*p < L'0') || (*p > L'9')) {
                break;
            }
            p++;
        } while (*p != 0);
        if (*p != 0) {
            continue;
        }

        //
        // We have the name of a \Device\HarddiskN directory. Open it and look
        // for PartitionM names.
        //
        InitializeObjectAttributes(
            &obja,
            &dirInfo1->Name,
            OBJ_CASE_INSENSITIVE,
            deviceHandle,
            NULL
            );
    
        status = ZwOpenDirectoryObject(&diskHandle, DIRECTORY_ALL_ACCESS, &obja);
    
        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }

        restartScan = TRUE;
        context2 = 0;
    
        do {
    
            //
            // Search the \Device\HarddiskN directory for PartitionM symbolic
            // links.
            //
            status = ZwQueryDirectoryObject(
                        diskHandle,
                        buffer2,
                        BUFFER_SIZE,
                        TRUE,
                        restartScan,
                        &context2,
                        NULL
                        );
    
            restartScan = FALSE;
    
            if (!NT_SUCCESS(status)) {
                if (status != STATUS_NO_MORE_ENTRIES) {
                    ASSERT(FALSE);
                    goto cleanup;
                }
                status = STATUS_SUCCESS;
                break;
            }
    
            //
            // We only care about symbolic links with PartitionN names.
            //
            dirInfo2 = (POBJECT_DIRECTORY_INFORMATION)buffer2;
    
            if ((dirInfo2->Name.Length < sizeof(L"partition")) ||
               (dirInfo2->TypeName.Length < (sizeof(L"SymbolicLink") - sizeof(WCHAR))) ||
               (_wcsnicmp(dirInfo2->TypeName.Buffer,L"SymbolicLink",wcslen(L"SymbolicLink")) != 0)) {
                continue;
            }
    
            SpStringToLower(dirInfo2->Name.Buffer);
    
            if (wcsncmp(dirInfo2->Name.Buffer, L"partition", wcslen(L"partition")) != 0) {
                continue;
            }
            p = dirInfo2->Name.Buffer + wcslen(L"partition");
            if ((*p == 0) || (*p == L'0')) { // skip partition0
                continue;
            }
            do {
                if ((*p < L'0') || (*p > L'9')) {
                    break;
                }
                p++;
            } while (*p != 0);
            if (*p != 0) {
                continue;
            }

            //
            // Open the \Device\HarddiskN\PartitionM symbolic link.
            //
            linkName = SpMemAlloc(sizeof(L"\\device") +
                                  dirInfo1->Name.Length +
                                  dirInfo2->Name.Length +
                                  sizeof(WCHAR));

            wcscpy(linkName, L"\\device");
            SpConcatenatePaths(linkName, dirInfo1->Name.Buffer);
            SpConcatenatePaths(linkName, dirInfo2->Name.Buffer);

            INIT_OBJA(&obja, &unicodeString, linkName);

            status = ZwOpenSymbolicLinkObject(
                        &linkHandle,
                        READ_CONTROL | SYMBOLIC_LINK_QUERY,
                        &obja
                        );

            if (!NT_SUCCESS(status)) {
                ASSERT(FALSE);
                SpMemFree(linkName);
                goto cleanup;
            }

            //
            // Query the link to get the link target.
            //
            unicodeString.Buffer = TemporaryBuffer;
            unicodeString.Length = 0;
            unicodeString.MaximumLength = sizeof(TemporaryBuffer);

            status = ZwQuerySymbolicLinkObject(
                        linkHandle,
                        &unicodeString,
                        NULL
                        );

            ZwClose(linkHandle);

            if (!NT_SUCCESS(status)) {
                ASSERT(FALSE);
                SpMemFree(linkName);
                goto cleanup;
            }

            //
            // Terminate the returned string.
            //
            TemporaryBuffer[unicodeString.Length/sizeof(WCHAR)] = 0;

            //
            // Create a translation entry.
            //
            translation = SpMemAlloc(sizeof(HARDDISK_NAME_TRANSLATION));
            translation->Next = SpHarddiskNameTranslations;
            SpHarddiskNameTranslations = translation;

            translation->PartitionName = linkName;
            translation->VolumeName = SpDupStringW(TemporaryBuffer);

        } while (TRUE);

        ZwClose(diskHandle);

    } while (TRUE);

    ASSERT(status == STATUS_SUCCESS);

cleanup:

    SpMemFree(buffer1);
    SpMemFree(buffer2);

    return (NT_SUCCESS(status) ? TRUE : FALSE);

} // SpBuildHarddiskNameTranslations

NTSTATUS
SpGetBootEntryFilePath(
    IN  ULONG       Id,
    IN  PWSTR       LoaderPartitionNtName,
    IN  PWSTR       LoaderFile,
    OUT PWSTR*      FilePath
    )
/*++

Routine Description:

    Construct a filepath including the loaderpartition name, the directory path to the
    OS loader and a filename for the boot entry specified.
     
Arguments:

    Id                      the boot entry id
    LoaderPartitionNtName   pointer to the string representing the disk partition
    LoaderFile              pointer to the string representing the path to the EFI OS loader
    FilePath                upon completion, this points to the completed filepath to the 
                            boot entry file
    
Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    WCHAR*              p;
    ULONG               FilePathSize;
    WCHAR               idString[9];
    
    //
    // use the EFI variable name as the filename
    //
        
    swprintf( idString, L"Boot%04x", Id);

    //
    // determine the size of the final filepath
    //
    // Note: FilePathSize should be a little bigger than actually needed
    // since we are including the full LoadFile string.  Also, the '\'
    // characters may be extra.
    //
    
    FilePathSize = (wcslen(LoaderPartitionNtName) * sizeof(WCHAR)) +    // partition
                   sizeof(WCHAR) +                                      // '\'
                   (wcslen(LoaderFile) * sizeof(WCHAR)) +               // path
                   sizeof(WCHAR) +                                      // '\'
                   (wcslen(idString) * sizeof(WCHAR)) +                 // new filename
                   sizeof(WCHAR);                                       // null term.

    ASSERT(FilePathSize > 0);
    if (FilePathSize <= 0) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: invalid loader partition name and/or loader path\n"));
        return STATUS_INVALID_PARAMETER;
    }

    *FilePath = SpMemAlloc(FilePathSize);
    if (!*FilePath) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to allocate memory for FilePath\n"));
        return STATUS_NO_MEMORY;
    }

    wcscpy(*FilePath, LoaderPartitionNtName);
    
    SpConcatenatePaths(*FilePath, LoaderFile);
    
    // remove the os loader filename from the path
    
    p = wcsrchr(*FilePath, L'\\');
    if (p != NULL) {
        p++;
    } else {
        // we could get here, but it would be wierd.
        p = *FilePath;
        wcscat(p, L"\\");
    }

    //
    // insert the filename
    //
    wcscpy(p, idString);

    ASSERT((wcslen(*FilePath) + 1) * sizeof(WCHAR) <= FilePathSize);

    return STATUS_SUCCESS;
}


NTSTATUS
SpGetAndWriteBootEntry(
    IN ULONG    Id,
    IN PWSTR    BootEntryPath
    )
/*++

Routine Description:

    Get the boot entry from NVRAM for the given boot entry Id.  Construct a filename
    of the form BootXXXX, where XXXX = id.  Put the file in the same directory as the
    EFI OS loader.  The directory is determined from the LoaderFile string. 
     
Arguments:

    bootEntry               pointer to a SP_BOOT_ENTRY structure of the entry to write
    BootEntryPath           pinter to the ARC/NT style reference to the boot entry filename
    
Return Value:

    NTSTATUS

--*/
{
    NTSTATUS            status;
    WCHAR               idString[9];
    HANDLE              hfile;
    OBJECT_ATTRIBUTES   oa;
    IO_STATUS_BLOCK     iostatus;
    UCHAR*              bootVar;
    ULONG               bootVarSize;
    UNICODE_STRING      uFilePath;
    UINT64              BootNumber;
    UINT64              BootSize;
    GUID                EfiBootVariablesGuid = EFI_GLOBAL_VARIABLE;

    hfile = NULL;

    //
    // Retrieve the NVRAM entry for the Id specified
    //
        
    swprintf( idString, L"Boot%04x", Id);
    
    bootVarSize = 0;

    status = HalGetEnvironmentVariableEx(idString,
                                        &EfiBootVariablesGuid,
                                        NULL,
                                        &bootVarSize,
                                        NULL);

    if (status != STATUS_BUFFER_TOO_SMALL) {
        
        ASSERT(FALSE);
        
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to get size for boot entry buffer.\n"));
    
        goto Done;

    } else {
        
        bootVar = SpMemAlloc(bootVarSize);
        if (!bootVar) {
            
            status = STATUS_NO_MEMORY;

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to allocate boot entry buffer.\n"));
            
            goto Done;
        }
         
        status = HalGetEnvironmentVariableEx(idString,
                                                &EfiBootVariablesGuid,
                                                bootVar,
                                                &bootVarSize,
                                                NULL);
        
        if (status != STATUS_SUCCESS) {

            ASSERT(FALSE);
            
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to get boot entry.\n"));
            
            goto Done;
        }
    }

    //
    // open the file 
    //

    INIT_OBJA(&oa, &uFilePath, BootEntryPath);

    status = ZwCreateFile(&hfile,
                            GENERIC_WRITE,
                            &oa,
                            &iostatus,
                            NULL,
                            FILE_ATTRIBUTE_NORMAL,
                            0,
                            FILE_OVERWRITE_IF,
                            FILE_SYNCHRONOUS_IO_NONALERT,
                            NULL,
                            0
                            );
    if ( ! NT_SUCCESS(status) ) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to create boot entry recovery file.\n"));
        
        goto Done;
    }

    //
    // Write the bits to disk using the format required
    // by base/efiutil/efinvram/savrstor.c
    //
    // [BootNumber][BootSize][BootEntry (of BootSize)]
    //

    //
    // build the header info for the boot entry block
    //

    // [header] include the boot id
    BootNumber = Id;
    status = ZwWriteFile( hfile,
                          NULL,
                          NULL,
                          NULL,
                          &iostatus,
                          &BootNumber,
                          sizeof(BootNumber),
                          NULL,
                          NULL
                          );
    if ( ! NT_SUCCESS(status) ) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed writing boot number to boot entry recovery file.\n"));
        
        goto Done;
    }

    // [header] include the boot size
    BootSize = bootVarSize;
    status = ZwWriteFile( hfile,
                          NULL,
                          NULL,
                          NULL,
                          &iostatus,
                          &BootSize,
                          sizeof(BootSize),
                          NULL,
                          NULL
                          );
    if ( ! NT_SUCCESS(status) ) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed writing boot entry size to boot entry recovery file.\n"));

        goto Done;
    }

    // boot entry bits
    status = ZwWriteFile( hfile,
                            NULL,
                            NULL,
                            NULL,
                            &iostatus,
                            bootVar,
                            bootVarSize,
                            NULL,
                            NULL
                            );
    if ( ! NT_SUCCESS(status) ) {

        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed writing boot entry to boot entry recovery file.\n"));
        
        goto Done;
    }

Done:

    //
    // We are done
    //

    if (bootVar) {
        SpMemFree(bootVar);
    }
    if (hfile) {
        ZwClose( hfile );
    }

    return status;

}


BOOLEAN
SpFlushEfiBootEntries (
    VOID
    )

/*++

Routine Description:

    Write boot entry changes back to NVRAM.

Arguments:

    None.

Return Value:

    BOOLEAN - FALSE if an unexpected error occurred.

--*/

{
    PSP_BOOT_ENTRY bootEntry;
    ULONG count;
    PULONG order;
    ULONG i;
    NTSTATUS status;
    PWSTR   BootEntryFilePath;

    ASSERT(SpIsEfi());

    //
    // Walk the list of boot entries, looking for entries that have been
    // deleted. Delete these entries from NVRAM. Do not delete entries that
    // are both new AND deleted; these are entries that have never been
    // written to NVRAM.
    //
    for (bootEntry = SpBootEntries; bootEntry != NULL; bootEntry = bootEntry->Next) {

        if (IS_BOOT_ENTRY_DELETED(bootEntry) &&
            !IS_BOOT_ENTRY_NEW(bootEntry)) {

            ASSERT(IS_BOOT_ENTRY_WINDOWS(bootEntry));

            //
            // Delete this boot entry.
            //
            status = ZwDeleteBootEntry(bootEntry->NtBootEntry.Id);
            if (!NT_SUCCESS(status)) {
                return FALSE;
            }
        } 
    }

    //
    // Walk the list of boot entries, looking for entries that have are new.
    // Add these entries to NVRAM. Do not write entries that are both new AND
    // deleted.
    //
    for (bootEntry = SpBootEntries; bootEntry != NULL; bootEntry = bootEntry->Next) {

        if (IS_BOOT_ENTRY_NEW(bootEntry) &&
            !IS_BOOT_ENTRY_DELETED(bootEntry)) {

            ASSERT(IS_BOOT_ENTRY_WINDOWS(bootEntry));

            //
            // Add this boot entry.
            //
            status = ZwAddBootEntry(&bootEntry->NtBootEntry, &bootEntry->NtBootEntry.Id);
            if (!NT_SUCCESS(status)) {
                return FALSE;
            }

            //
            // get the location we are going to store a copy of the NVRAM boot entry 
            //
            BootEntryFilePath = NULL;

            status = SpGetBootEntryFilePath(bootEntry->NtBootEntry.Id,
                                            bootEntry->LoaderPartitionNtName,
                                            bootEntry->LoaderFile,
                                            &BootEntryFilePath
                                            );
            if (!NT_SUCCESS(status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed getting boot entry filepath.\n"));
            } else {

                ASSERT(BootEntryFilePath);

                //
                // Fetch the bits from the newly created NVRAM entry and 
                // write them as a file in the the EFI load path 
                //
                status = SpGetAndWriteBootEntry(bootEntry->NtBootEntry.Id,
                                                BootEntryFilePath
                                                );
                if (!NT_SUCCESS(status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed boot entry recovery file.\n"));
                }

                //
                // We are done with the boot entry filepath
                //
                SpMemFree(BootEntryFilePath);
            }

            //
            // Remember the ID of the new boot entry as the entry to be booted
            // immediately on the next boot.
            //
            SpBootOptions->NextBootEntryId = bootEntry->NtBootEntry.Id;
        } 
    }

    //
    // Build the new boot order list. Insert all boot entries with
    // BE_STATUS_ORDERED into the list. (Don't insert deleted entries.)
    //
    count = 0;
    bootEntry = SpBootEntries;
    while (bootEntry != NULL) {
        if (IS_BOOT_ENTRY_ORDERED(bootEntry) && !IS_BOOT_ENTRY_DELETED(bootEntry)) {
            count++;
        }
        bootEntry = bootEntry->Next;
    }
    order = SpMemAlloc(count * sizeof(ULONG));
    count = 0;
    bootEntry = SpBootEntries;
    while (bootEntry != NULL) {
        if (IS_BOOT_ENTRY_ORDERED(bootEntry) && !IS_BOOT_ENTRY_DELETED(bootEntry)) {
            order[count++] = bootEntry->NtBootEntry.Id;
        }
        bootEntry = bootEntry->Next;
    }

    //
    // Write the new boot entry order list to NVRAM.
    //
    status = ZwSetBootEntryOrder(order, count);
    SpMemFree(order);
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    //
    // Write the new timeout value to NVRAM.
    //
    // Set the boot entry we added to be booted automatically on
    // the next boot, without waiting for a timeout at the boot menu.
    //
    // NB: SpCreateBootEntry() sets SpBootOptions->NextBootEntryId.
    //
    SpBootOptions->Timeout = Timeout;
    status = ZwSetBootOptions(
                SpBootOptions,
                BOOT_OPTIONS_FIELD_TIMEOUT | BOOT_OPTIONS_FIELD_NEXT_BOOT_ENTRY_ID
                );
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    return TRUE;

} // SpFlushEfiBootEntries

BOOLEAN
SpReadAndConvertEfiBootEntries (
    VOID
    )

/*++

Routine Description:

    Read boot entries from EFI NVRAM and convert them into our internal format.

Arguments:

    None.

Return Value:

    BOOLEAN - FALSE if an unexpected error occurred.

--*/

{
    NTSTATUS status;
    ULONG length;
    PBOOT_ENTRY_LIST bootEntries;
    PBOOT_ENTRY_LIST bootEntryList;
    PBOOT_ENTRY bootEntry;
    PBOOT_ENTRY bootEntryCopy;
    PSP_BOOT_ENTRY myBootEntry;
    PSP_BOOT_ENTRY previousEntry;
    PWINDOWS_OS_OPTIONS osOptions;
    LONG i;
    PULONG order;
    ULONG count;

    //
    // SpStartSetup() does not expect our caller, SpInitBootVars(), to fail.
    // So textmode is going to continue even if we have failures here.
    // Therefore we need to leave here in a consistent state. That means
    // that we MUST allocate a buffer for SpBootOptions, even if we can't
    // get the real information from the kernel.
    //

    //
    // Get the global system boot options.
    //
    length = 0;
    status = ZwQueryBootOptions(NULL, &length);
    if (status != STATUS_BUFFER_TOO_SMALL) {
        ASSERT(FALSE);
        if (status == STATUS_SUCCESS) {
            status = STATUS_UNSUCCESSFUL;
        }
    } else {
        SpBootOptions = SpMemAlloc(length);
        status = ZwQueryBootOptions(SpBootOptions, &length);
        if (status != STATUS_SUCCESS) {
            ASSERT(FALSE);
        }
    }

    if (status != STATUS_SUCCESS) {

        //
        // An unexpected error occurred reading the boot options. Create
        // a fake boot options structure.
        //

        if (SpBootOptions != NULL) {
            SpMemFree(SpBootOptions);
        }
        length = FIELD_OFFSET(BOOT_OPTIONS,HeadlessRedirection) + sizeof(WCHAR);
        SpBootOptions = SpMemAlloc(length);
        RtlZeroMemory(SpBootOptions, length);
        SpBootOptions->Version = BOOT_OPTIONS_VERSION;
        SpBootOptions->Length = length;
    }

    //
    // Get the system boot order list.
    //
    count = 0;
    status = ZwQueryBootEntryOrder(NULL, &count);

    if (status != STATUS_BUFFER_TOO_SMALL) {

        if (status == STATUS_SUCCESS) {

            //
            // There are no entries in the boot order list. Strange but
            // possible.
            //
            count = 0;

        } else {

            //
            // An unexpected error occurred. Just pretend that the boot
            // entry order list is empty.
            //
            ASSERT(FALSE);
            count = 0;
        }
    }

    if (count != 0) {
        order = SpMemAlloc(count * sizeof(ULONG));
        status = ZwQueryBootEntryOrder(order, &count);
        if (status != STATUS_SUCCESS) {

            //
            // An unexpected error occurred. Just pretend that the boot
            // entry order list is empty.
            //
            ASSERT(FALSE);
            count = 0;
        }
    }

    //
    // Get all existing boot entries.
    //
    length = 0;
    status = ZwEnumerateBootEntries(NULL, &length);

    if (status != STATUS_BUFFER_TOO_SMALL) {

        if (status == STATUS_SUCCESS) {

            //
            // Somehow there are no boot entries in NVRAM. Handle this
            // by just creating an empty list.
            //

            length = 0;

        } else {

            //
            // An unexpected error occurred. Just pretend that no boot
            // entries exist.
            //
            ASSERT(FALSE);
            length = 0;
        }
    }

    if (length == 0) {

        ASSERT(SpBootEntries == NULL);

    } else {
    
        bootEntries = SpMemAlloc(length);
        status = ZwEnumerateBootEntries(bootEntries, &length);
        if (status != STATUS_SUCCESS) {
            ASSERT(FALSE);
            return FALSE;
        }
    
        //
        // Convert the boot entries into our internal representation.
        //
        bootEntryList = bootEntries;
        previousEntry = NULL;
    
        while (TRUE) {
    
            bootEntry = &bootEntryList->BootEntry;
    
            //
            // Calculate the length of our internal structure. This includes
            // the base part of SP_BOOT_ENTRY plus the NT BOOT_ENTRY.
            //
            length = FIELD_OFFSET(SP_BOOT_ENTRY, NtBootEntry) + bootEntry->Length;
            myBootEntry = SpMemAlloc(length);
            ASSERT(myBootEntry != NULL);
    
            RtlZeroMemory(myBootEntry, length);
    
            //
            // Copy the NT BOOT_ENTRY into the allocated buffer.
            //
            bootEntryCopy = &myBootEntry->NtBootEntry;
            memcpy(bootEntryCopy, bootEntry, bootEntry->Length);
    
            //
            // Fill in the base part of the structure.
            //
            myBootEntry->Next = NULL;
            myBootEntry->AllocationEnd = (PUCHAR)myBootEntry + length - 1;
            myBootEntry->FriendlyName = ADD_OFFSET(bootEntryCopy, FriendlyNameOffset);
            myBootEntry->FriendlyNameLength = (wcslen(myBootEntry->FriendlyName) + 1) * sizeof(WCHAR);
            myBootEntry->LoaderPath = ADD_OFFSET(bootEntryCopy, BootFilePathOffset);
    
            //
            // If this is an NT boot entry, translate the file paths.
            //
            osOptions = (PWINDOWS_OS_OPTIONS)bootEntryCopy->OsOptions;
    
            if (IS_BOOT_ENTRY_WINDOWS(myBootEntry)) {
    
                PSP_BOOT_ENTRY bootEntry2;
    
                myBootEntry->OsLoadOptions = osOptions->OsLoadOptions;
                myBootEntry->OsLoadOptionsLength = (wcslen(myBootEntry->OsLoadOptions) + 1) * sizeof(WCHAR);
                myBootEntry->OsPath = ADD_OFFSET(osOptions, OsLoadPathOffset);
    
                //
                // Translate the OS FILE_PATH and the boot FILE_PATH. Note that
                // the translation can fail when the target device is not present.
                //
                SpTranslateFilePathToRegion(
                    myBootEntry->OsPath,
                    &myBootEntry->OsPartitionDiskRegion,
                    &myBootEntry->OsPartitionNtName,
                    &myBootEntry->OsDirectory
                    );
                SpTranslateFilePathToRegion(
                    myBootEntry->LoaderPath,
                    &myBootEntry->LoaderPartitionDiskRegion,
                    &myBootEntry->LoaderPartitionNtName,
                    &myBootEntry->LoaderFile
                    );    
            }
    
            //
            // Link the new entry into the list.
            //
            if (previousEntry != NULL) {
                previousEntry->Next = myBootEntry;
            } else {
                SpBootEntries = myBootEntry;
            }
            previousEntry = myBootEntry;
    
            //
            // Move to the next entry in the enumeration list, if any.
            //
            if (bootEntryList->NextEntryOffset == 0) {
                break;
            }
            bootEntryList = ADD_OFFSET(bootEntryList, NextEntryOffset);
        }
    
        //
        // Free the enumeration buffer.
        //
        SpMemFree(bootEntries);
    }

    //
    // Boot entries are returned in an unspecified order. They are currently
    // in the SpBootEntries list in the order in which they were returned.
    // Sort the boot entry list based on the boot order. Do this by walking
    // the boot order array backwards, reinserting the entry corresponding to
    // each element of the array at the head of the list.
    //

    for (i = (LONG)count - 1; i >= 0; i--) {

        for (previousEntry = NULL, myBootEntry = SpBootEntries;
             myBootEntry != NULL;
             previousEntry = myBootEntry, myBootEntry = myBootEntry->Next) {

            if (myBootEntry->NtBootEntry.Id == order[i] ) {

                //
                // We found the boot entry with this ID. If it's not already
                // at the front of the list, move it there.
                //

                myBootEntry->Status |= BE_STATUS_ORDERED;

                if (previousEntry != NULL) {
                    previousEntry->Next = myBootEntry->Next;
                    myBootEntry->Next = SpBootEntries;
                    SpBootEntries = myBootEntry;
                } else {
                    ASSERT(SpBootEntries == myBootEntry);
                }

                break;
            }
        }
    }

    if (count != 0) {
        SpMemFree(order);
    }

    return TRUE;

} // SpReadAndConvertEfiBootEntries

ULONG
SpSafeWcslen (
    IN PWSTR String,
    IN PWSTR Max
    )

/*++

Routine Description:

    Calculate the length of a null-terminated string in a safe manner,
    avoiding walking off the end of the buffer if the string is not
    properly terminated.

Arguments:

    String - Address of string.

    Max - Address of first byte beyond the maximum legal address for the
    string. In other words, the address of the first byte past the end
    of the buffer in which the string is contained.

Return Value:

    ULONG - Length of the string, in characters, not including the null
        terminator. If the string is not terminated before the end of
        the buffer, 0xffffffff is returned.

--*/

{
    PWSTR p = String;

    //
    // Walk through the string, looking for either the end of the buffer
    // or a null terminator.
    //
    while ((p < Max) && (*p != 0)) {
        p++;
    }

    //
    // If we didn't reach the end of the buffer, then we found a null
    // terminator. Return the length of the string, in characters.
    //
    if (p < Max) {
        return (ULONG)(p - String);
    }

    //
    // The string is not properly terminated. Return an error indicator.
    //
    return 0xffffffff;

} // SpSafeWcslen

VOID
SpTranslateFilePathToRegion (
    IN PFILE_PATH FilePath,
    OUT PDISK_REGION *DiskRegion,
    OUT PWSTR *PartitionNtName,
    OUT PWSTR *PartitionRelativePath
    )

/*++

Routine Description:

    Translate a FILE_PATH to a pointer to a disk region and the path
    relative to the region.

Arguments:

    FilePath - Address of FILE_PATH.

    DiskRegion - Returns the address of the disk region described by
        FilePath. NULL is returned if the matching disk region cannot
        be found.

    PartitionNtName - Returns the NT name associated with the disk region.
        NULL is returned if the file path cannot be translated into NT
        format.

    PartitionRelativePath - Returns the volume-relative path of the file
        or directory described by the FilePath. NULL is returned if the
        file path cannot be translated into NT format.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    ULONG length;
    PFILE_PATH ntFilePath;
    PWSTR p;
    PWSTR q;
    PHARDDISK_NAME_TRANSLATION translation;

    //
    // Translate the file path into NT format. (It is probably in EFI format.)
    //
    length = 0;
    status = ZwTranslateFilePath(
                FilePath,
                FILE_PATH_TYPE_NT,
                NULL,
                &length
                );
    if (status != STATUS_BUFFER_TOO_SMALL) {
        *PartitionNtName = NULL;
        *DiskRegion = NULL;
        *PartitionRelativePath = NULL;
        return;
    }
    ntFilePath = SpMemAlloc(length);
    status = ZwTranslateFilePath(
                FilePath,
                FILE_PATH_TYPE_NT,
                ntFilePath,
                &length
                );
    if (status != STATUS_SUCCESS) {
        ASSERT(FALSE);
        *PartitionNtName = NULL;
        *DiskRegion = NULL;
        *PartitionRelativePath = NULL;
        SpMemFree(ntFilePath);
        return;
    }

    //
    // NtTranslateFilePath returns a name of the form \Device\HarddiskVolumeN.
    // We need to have a name of the form \Device\HardiskN\PartitionM. (This is
    // because all of the ARC<->NT translations use the latter form.) Use the
    // translation list built by SpBuildHarddiskNameTranslations to do the
    // translation.
    //
    // If the returned name doesn't include "HarddiskVolume", or if no
    // translation is found, use the returned name and hope for the best.
    //
    p = (PWSTR)ntFilePath->FilePath;
    q = p;

    if (wcsstr(q, L"HarddiskVolume") != NULL) {
    
        for ( translation = SpHarddiskNameTranslations;
              translation != NULL;
              translation = translation->Next ) {
            if (_wcsicmp(translation->VolumeName, q) == 0) {
                break;
            }
        }
        if (translation != NULL) {
            q = translation->PartitionName;
        }
    }

    //
    // We now have the file path in NT format. Get the disk region that
    // corresponds to the NT device name. Return the obtained information.
    //
    *PartitionNtName = SpDupStringW(q);
    *DiskRegion = SpRegionFromNtName(q, PartitionOrdinalCurrent);
    p += wcslen(p) + 1;
    *PartitionRelativePath = SpDupStringW(p);

    //
    // Free local memory.
    //
    SpMemFree(ntFilePath);

    return;
}

#endif // defined(EFI_NVRAM_ENABLED)

NTSTATUS
SpAddNTInstallToBootList(
    IN PVOID        SifHandle,
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        SystemPartitionDirectory,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        Sysroot,
    IN PWSTR        OsLoadOptions,      OPTIONAL
    IN PWSTR        LoadIdentifier      OPTIONAL
    )
/*++

Routine Description:

    This routine takes the core components of a boot set and passes
    them on to SpAddUserDefinedInstallationToBootList, which does
    the real work of constructing a boot set.  After the new boot
    set is created, the boot vars are flushed - the exact implementation
    of the flush depends on the architecture.  On x86, we'll have a new
    boot.ini after this routine is done.               
     
Arguments:

    SifHandle       - pointer to the setup sif file

Return Value:

    STATUS_SUCCESS  if the NT install was successfully added to the
                    boot list
                        
    if there was an error, the status is returned

--*/
{
    NTSTATUS    status;

    //
    // create the new user defined boot set
    //
    status = SpAddUserDefinedInstallationToBootList(SifHandle,
                                                   SystemPartitionRegion,
                                                   SystemPartitionDirectory,
                                                   NtPartitionRegion,
                                                   Sysroot,
                                                   OsLoadOptions,
                                                   LoadIdentifier
                                                  );
    if (! NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_ERROR_LEVEL, 
                   "SpExportBootEntries: failed while installing new boot set: Status = %lx\n",
                   status
                   ));
        return status;
    }

    //
    // write the new boot set out
    //
    if (SpFlushBootVars() == FALSE) {

        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_ERROR_LEVEL, 
                   "SpAddDiscoveredNTInstallToBootList: failed flushing boot vars\n"
                   ));
    
        status = STATUS_UNSUCCESSFUL;

    } else {
        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
SpAddUserDefinedInstallationToBootList(
    IN PVOID        SifHandle,
    IN PDISK_REGION SystemPartitionRegion,
    IN PWSTR        SystemPartitionDirectory,
    IN PDISK_REGION NtPartitionRegion,
    IN PWSTR        Sysroot,
    IN PWSTR        OsLoadOptions,      OPTIONAL
    IN PWSTR        LoadIdentifier      OPTIONAL
    )
/*++

Routine Description:

    This routine is based on SpAddInstallationToBootList, with the major
    differences being: 
    
        there is no processing of the load options
        the user can specifiy the loadIdentifier    
    
Return Value:

    STATUS_SUCCESS  if the NT install was successfully added to the
                    boot list
                        
    if there was an error, the status is returned

--*/
{
    PWSTR                   BootVars[MAXBOOTVARS];
    PWSTR                   SystemPartitionArcName;
    PWSTR                   TargetPartitionArcName;
    PWSTR                   tmp;
    PWSTR                   tmp2;
    PWSTR                   locOsLoadOptions;
    PWSTR                   locLoadIdentifier;
    ULONG                   Signature;
    ENUMARCPATHTYPE         ArcPathType;
    NTSTATUS                status;

    status = STATUS_SUCCESS;

    ArcPathType = PrimaryArcPath;

    tmp2 = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);

    if (!SpIsEfi()) {
    
        //
        // Get an ARC name for the system partition.
        //
        if (SystemPartitionRegion != NULL) {
            
            SpArcNameFromRegion(
                SystemPartitionRegion,
                tmp2,
                sizeof(TemporaryBuffer)/2,
                PartitionOrdinalOnDisk,
                PrimaryArcPath
                );

            SystemPartitionArcName = SpDupStringW(tmp2);
        } else {
            SystemPartitionArcName = NULL;
        }
    
        //
        // Get an ARC name for the target partition.
        //
    
        //
        // If the partition is on a SCSI disk that has more than 1024 cylinders
        // and the partition has sectors located on cylinders beyond cylinder
        // 1024, the get the arc name in the secondary format. See also
        // spcopy.c!SpCreateNtbootddSys().
        //
        if(
            !SpIsArc() &&
#if defined(REMOTE_BOOT)
            !RemoteBootSetup &&
#endif // defined(REMOTE_BOOT)
    
#ifdef _X86_
            !SpUseBIOSToBoot(NtPartitionRegion, NULL, SifHandle) &&
#endif
            (HardDisks[NtPartitionRegion->DiskNumber].ScsiMiniportShortname[0]) ) {
    
            ArcPathType = SecondaryArcPath;
        } else {
            ArcPathType = PrimaryArcPath;
        }
    
        SpArcNameFromRegion(
            NtPartitionRegion,
            tmp2,
            sizeof(TemporaryBuffer)/2,
            PartitionOrdinalOnDisk,
            ArcPathType
            );
    
        TargetPartitionArcName = SpDupStringW(tmp2);
    }
    
    //
    // Tweak the load identifier if necessary
    //
    if (LoadIdentifier) {
        
        if(!SpIsArc()) {
            //
            // Need quotation marks around the description on x86.
            //
            locLoadIdentifier = SpMemAlloc((wcslen(LoadIdentifier)+3)*sizeof(WCHAR));
            locLoadIdentifier[0] = L'\"';
            wcscpy(locLoadIdentifier+1,LoadIdentifier);
            wcscat(locLoadIdentifier,L"\"");
        } else {
            locLoadIdentifier = SpDupStringW(LoadIdentifier);
        }
    
    } else {
        locLoadIdentifier = SpDupStringW(L"");
    }
    ASSERT(locLoadIdentifier);
    
    //
    // Tweak the load options if necessary
    //
    if (OsLoadOptions) {
        locOsLoadOptions = SpDupStringW(OsLoadOptions);
    } else {
        locOsLoadOptions = SpDupStringW(L"");
    }
    ASSERT(locOsLoadOptions);

    //
    // Create a new internal-format boot entry.
    //
    tmp = TemporaryBuffer;
    wcscpy(tmp,SystemPartitionDirectory);
    SpConcatenatePaths(
        tmp,
#ifdef _X86_
        SpIsArc() ? L"arcldr.exe" : L"ntldr"
#elif _IA64_
        L"ia64ldr.efi"
#else
        L"osloader.exe"
#endif
        );
    tmp = SpDupStringW(tmp);

    SpCreateBootEntry(
        BE_STATUS_NEW,
        SystemPartitionRegion,
        tmp,
        NtPartitionRegion,
        Sysroot,
        locOsLoadOptions,
        locLoadIdentifier
        );

    SpMemFree(tmp);

    //
    // If not on an EFI machine, add a new ARC-style boot set.
    //
    if (!SpIsEfi()) {
    
        BootVars[OSLOADOPTIONS]     = locOsLoadOptions;
        BootVars[LOADIDENTIFIER]    = locLoadIdentifier;
    
        //
        // OSLOADER is the system partition path + the system partition directory +
        //          osloader.exe. (ntldr on x86 machines).
        //
        if (SystemPartitionRegion != NULL) {
            tmp = TemporaryBuffer;
            wcscpy(tmp,SystemPartitionArcName);
            SpConcatenatePaths(tmp,SystemPartitionDirectory);
            SpConcatenatePaths(
                tmp,
#ifdef _X86_
                (SpIsArc() ? L"arcldr.exe" : L"ntldr")
#elif _IA64_
                L"ia64ldr.efi"
#else
                L"osloader.exe"
#endif
                );
    
            BootVars[OSLOADER] = SpDupStringW(tmp);
        } else {
            BootVars[OSLOADER] = SpDupStringW(L"");
        }
    
        //
        // OSLOADPARTITION is the ARC name of the windows nt partition.
        //
        BootVars[OSLOADPARTITION] = TargetPartitionArcName;
    
        //
        // OSLOADFILENAME is sysroot.
        //
        BootVars[OSLOADFILENAME] = Sysroot;
    
        //
        // SYSTEMPARTITION is the ARC name of the system partition.
        //
        if (SystemPartitionRegion != NULL) {
            BootVars[SYSTEMPARTITION] = SystemPartitionArcName;
        } else {
            BootVars[SYSTEMPARTITION] = L"";
        }
    
        //
        // get the disk signature
        //
        if ((NtPartitionRegion->DiskNumber != 0xffffffff) && HardDisks[NtPartitionRegion->DiskNumber].Signature) {
            Signature = HardDisks[NtPartitionRegion->DiskNumber].Signature;
        } else {
            Signature = 0;
        }
    
        //
        // Add the boot set and make it the default.
        //
        SpAddBootSet(BootVars, TRUE, Signature);

        SpMemFree(BootVars[OSLOADER]);
    }

    //
    // Free memory allocated.
    //
    if (locLoadIdentifier) {
        SpMemFree(locLoadIdentifier);
    }

    if (!SpIsEfi()) {
        if (SystemPartitionArcName) {
            SpMemFree(SystemPartitionArcName);
        }
        if (TargetPartitionArcName) {
            SpMemFree(TargetPartitionArcName);
        }
    }

    return status;
}

NTSTATUS
SpExportBootEntries(
    IN OUT PLIST_ENTRY      BootEntries,
       OUT PULONG           BootEntryCnt
    )
/*++

Routine Description:

    This routine compiles a safely exportable string represenation
    of the boot options.
    
Arguments:

    BootEntries     - returns pointing to the head of the linked list
                      containing the exported boot entries
    BootEntriesCnt  - returns with the # of boot entries exported                       
    
Return Value:

    STATUS_SUCCESS  if the boot entries were successfully exported
    
    if there was an error, the status is returned

--*/
{
    PSP_BOOT_ENTRY          bootEntry;
    PSP_EXPORTED_BOOT_ENTRY ebootEntry;

    *BootEntryCnt = 0;

    //
    // make sure we were given the list head
    //
    ASSERT(BootEntries);
    if (!BootEntries) {
        KdPrintEx((DPFLTR_SETUP_ID, 
           DPFLTR_ERROR_LEVEL, 
           "SpExportBootEntries: pointer to boot entry list is NULL\n"
           ));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // make sure the list is empty
    //
    ASSERT(IsListEmpty(BootEntries));
    if (! IsListEmpty(BootEntries)) {
        KdPrintEx((DPFLTR_SETUP_ID, 
           DPFLTR_ERROR_LEVEL, 
           "SpExportBootEntries: incoming boot entry list should be empty\n"
           ));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // for each boot entry, collect a subset of information and compile
    // it in an exportable (safe) string form
    //
    for (bootEntry = SpBootEntries; bootEntry != NULL; bootEntry = bootEntry->Next) {

        //
        // allocate the node...
        //
        ebootEntry = SpMemAlloc(sizeof(SP_EXPORTED_BOOT_ENTRY));
        ASSERT(ebootEntry);
        if (ebootEntry == NULL) {
            KdPrintEx((DPFLTR_SETUP_ID, 
                       DPFLTR_ERROR_LEVEL, 
                       "SpExportBootEntries: failed allocationg new exported boot entry\n"
                       ));
            return STATUS_NO_MEMORY;
        }
        RtlZeroMemory( ebootEntry, sizeof(SP_EXPORTED_BOOT_ENTRY) );

        //
        // map selected fields from SpBootEntries to our export
        //
        ebootEntry->LoadIdentifier  = SpDupStringW(bootEntry->FriendlyName);
        ebootEntry->OsLoadOptions   = SpDupStringW(bootEntry->OsLoadOptions);
        ebootEntry->DriverLetter    = bootEntry->OsPartitionDiskRegion->DriveLetter;
        ebootEntry->OsDirectory     = SpDupStringW(bootEntry->OsDirectory);

        InsertTailList( BootEntries, &ebootEntry->ListEntry );
        
        ++*BootEntryCnt;
    }

    if (*BootEntryCnt == 0) {
        ASSERT(IsListEmpty(BootEntries));
        if(! IsListEmpty(BootEntries)) {
            KdPrintEx((DPFLTR_SETUP_ID, 
                       DPFLTR_ERROR_LEVEL, 
                       "SpExportBootEntries: exported boot entry list should be empty\n"
                       ));
            return STATUS_UNSUCCESSFUL;
        }
    } else {
        ASSERT(! IsListEmpty(BootEntries));
        if(IsListEmpty(BootEntries)) {
            KdPrintEx((DPFLTR_SETUP_ID, 
                       DPFLTR_ERROR_LEVEL, 
                       "SpExportBootEntries: exported boot entry list should NOT be empty\n"
                       ));
            return STATUS_UNSUCCESSFUL;
        }
    }

    return STATUS_SUCCESS;

}

NTSTATUS
SpFreeExportedBootEntries(
    IN PLIST_ENTRY      BootEntries,
    IN ULONG            BootEntryCnt
    )
/*++

Routine Description:

    A convenience routine to free the exported boot entries
    
Arguments:

    BootEntries     - points to the head of the linked list
                      containing the exported boot entries
    BootEntriesCnt  - the # of boot entries exported                       
    
Return Value:

    STATUS_SUCCESS  if the exported boot entries were successfully freed
    
    if there was an error, the status is returned
                                                                        
--*/
{
    PSP_EXPORTED_BOOT_ENTRY bootEntry;
    PLIST_ENTRY             listEntry;
    ULONG                   cnt;
    NTSTATUS                status;

    cnt = 0;

    while ( !IsListEmpty(BootEntries) ) {

        listEntry  = RemoveHeadList(BootEntries);
        bootEntry = CONTAINING_RECORD(listEntry,
                                       SP_EXPORTED_BOOT_ENTRY,
                                       ListEntry
                                       );

        if (bootEntry->LoadIdentifier) {
            SpMemFree(bootEntry->LoadIdentifier);
        }
        if (bootEntry->OsLoadOptions) {
            SpMemFree(bootEntry->OsLoadOptions);
        }
        if (bootEntry->OsDirectory) {
            SpMemFree(bootEntry->OsDirectory);
        }
        
        SpMemFree(bootEntry);
        
        cnt++;
    }
    
    ASSERT(cnt == BootEntryCnt);

    if (cnt == BootEntryCnt) {
        status = STATUS_SUCCESS;
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_ERROR_LEVEL, 
                   "SpFreeExportedBootEntries: incorrect # of boot entries freed\n"
                   ));
        status = STATUS_UNSUCCESSFUL;
    }

    return status;

}

NTSTATUS
SpSetRedirectSwitchMode(
    IN RedirectSwitchesModeEnum     mode,
    IN PCHAR                        redirectSwitch,
    IN PCHAR                        redirectBaudRateSwitch
    )
/*++

Routine Description:

    This routine is used to manage how the redirect switches
    are set in the boot configuration (x86 ==> boot.ini)
    
    Depending on the mode chosen, the user may specify
    which parameters they want to set or if they just 
    want the default (legacy) behavior.
    
    NOTE:
                              
    The user specified switches are copied into globals for
    use by the Flush routines.                       
    
    The global, RedirectSwitchesMode, is set and remains set
    after this routine returns.  All subsequent FlushBootVars
    will use this mode.
                           
Arguments:

    mode                    - how we affect the redirect switches
    redirectSwitch          - the user defined redirect parameter
    redirectBaudRateSwitch  - the user defined baudrate paramtere
    
Return Value:

    STATUS_SUCCESS  if the redirect values were successfully set
    
    if there was an error, the status is returned

--*/
{
    NTSTATUS    status;

    //
    // set the mode and user defined parameters
    //
    RedirectSwitchesMode = mode;

    //
    // null the redirect switches by default
    //
    RedirectSwitches.port[0] = '\0';  
    RedirectSwitches.baudrate[0] = '\0';  
    
    //
    // get copies of the user defined switches if specified
    //
    if (redirectSwitch) {
    
        strncpy(RedirectSwitches.port,
                redirectSwitch, 
                MAXSIZE_REDIRECT_SWITCH);
    
    }

    if (redirectBaudRateSwitch) {
    
        strncpy(RedirectSwitches.baudrate,
                redirectBaudRateSwitch, 
                MAXSIZE_REDIRECT_SWITCH);
    
    }
    
    //
    // update the boot options using the specified mode
    //
    if (SpFlushBootVars() == FALSE) {

        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_ERROR_LEVEL, 
                   "SpAddDiscoveredNTInstallToBootList: failed flushing boot vars\n"
                   ));
    
        status = STATUS_UNSUCCESSFUL;

    } else {

        status = STATUS_SUCCESS;
    
    }

    return status;

}

NTSTATUS
SpSetDefaultBootEntry(
    ULONG           BootEntryNumber
    )
/*++

Routine Description:

    Set the Default boot entry to the user specified boot entry.
    
Arguments:

    BootEntryNumber - the position of the boot entry in the list
                      which is intended to become the default.
                      This number should be >= 1.
    
Return Value:

    STATUS_SUCCESS      if the default was successfully set
    
    STATUS_NOT_FOUND    if the specified boot entry was not found
                        or is missing
    
    if there was an error, the status is returned

--*/
{
    PSP_BOOT_ENTRY          bootEntry;
    NTSTATUS                status;
    ULONG                   BootEntryCount;

    //
    // Find the user specified boot entry
    //

    BootEntryCount = 1;
    
    for (bootEntry = SpBootEntries; 
         (bootEntry != NULL) && (BootEntryCount != BootEntryNumber); 
         bootEntry = bootEntry->Next) {
    
        ++BootEntryCount;
    
    }
    ASSERT(BootEntryCount == BootEntryNumber);
    ASSERT(bootEntry);

    //
    // if we have found our match, then set the Default
    //
    if ((bootEntry != NULL) &&
        (BootEntryCount == BootEntryNumber)) {

        PDISK_REGION            Region;

        //
        // point to the disk region with the sig info
        //
        Region = bootEntry->OsPartitionDiskRegion;
        ASSERT(Region);
        if (! Region) {
            KdPrintEx((DPFLTR_SETUP_ID, 
                       DPFLTR_ERROR_LEVEL, 
                       "SpSetDefaultBootEntry: new default partition region is NULL\n"
                       ));
            return STATUS_UNSUCCESSFUL;
        }
                
        //
        // Free the previous Default
        //
        if( Default ) {
            SpMemFree( Default );
        }
        Default = SpMemAlloc( MAX_PATH * sizeof(WCHAR) );
        ASSERT( Default );
        if (! Default) {
            KdPrintEx((DPFLTR_SETUP_ID, 
                       DPFLTR_ERROR_LEVEL, 
                       "SpSetDefaultBootEntry: failed to allocate new Default\n"
                       ));
            return STATUS_UNSUCCESSFUL;
        }

        //
        // fetch the arc name for the region
        //
        SpArcNameFromRegion(
            Region,
            TemporaryBuffer,
            sizeof(TemporaryBuffer)/2,
            PartitionOrdinalOnDisk,
            PrimaryArcPath
            );
        
        //
        // store the new partition and directory info
        //
        wcscpy( Default, TemporaryBuffer);
        SpConcatenatePaths(Default, bootEntry->OsDirectory);
        
        //
        // get the disk signature of the new default disk
        //
        if ((Region->DiskNumber != 0xffffffff) && HardDisks[Region->DiskNumber].Signature) {
            DefaultSignature = HardDisks[Region->DiskNumber].Signature;
        } else {
            DefaultSignature = 0;
        }

        //
        // update the boot options using the specified mode
        //
        if(SpFlushBootVars() == FALSE) {

            KdPrintEx((DPFLTR_SETUP_ID, 
                       DPFLTR_ERROR_LEVEL, 
                       "SpSetDefaultBootEntry: failed flushing boot vars\n"
                       ));

            status = STATUS_UNSUCCESSFUL;
        } else {
            status = STATUS_SUCCESS;
        }

    } else {
        KdPrintEx((DPFLTR_SETUP_ID, 
                   DPFLTR_ERROR_LEVEL, 
                   "SpSetDefaultBootEntry: failed to find specified boot entry to use as default\n"
                   ));
        status = STATUS_NOT_FOUND;
    }
    
    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spcabp.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    spcabp.h

Abstract:

    Cabinet stuff (file compression/decompression)

Author:

    Calin Negreanu (calinn) 27-Apr-2000

Revision History:

    Jay Krell (a-JayK) November 2000
        ported from windows\winstate\cobra\... to admin\ntsetup\textmode\kernel\spcab.h
--*/

#pragma once
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include <stdio.h>
#if defined(ULONG_MAX) && !defined(_INC_LIMITS)
#undef ULONG_MAX
#endif
#include <limits.h>
#if !defined(NUMBER_OF)
#define NUMBER_OF(x) (sizeof(x)/sizeof((x)[0]))
#endif
#if !defined(MAXDWORD)
#define MAXDWORD (~(DWORD)0)
#endif
#define MAX_WCHAR_PATH 260

void SpDebugMessage(int level, const char* string);
#define DEBUGMSG(x) (SpDebugMessage(x))
#define DBG_ERROR /* nothing */

#include "spcab.h"
#include "fdi.h"
#include "fci.h"

//
// This work was not quite finished, and it turns out for now (November 26, 2000),
// we don't need it.
//
#define SETUP_CABP_SMALL_FILE_OPTIMIZATION 0

#if SETUP_CABP_SMALL_FILE_OPTIMIZATION

typedef struct _SETUP_CABP_FILE_VTABLE {
    /*
    read
    write
    seek
    close
    */
    int x;
} SETUP_CABP_FILE_VTABLE, *PSETUP_CABP_FILE_VTABLE;

typedef struct _SETUP_CABP_NT_FILE_DATA {
    HANDLE NtHandle;
} SETUP_CABP_NT_FILE_DATA;

typedef struct _SETUP_CABP_SMALL_FILE_CACHE_ENTRY_KEY {
    UNICODE_STRING Path;
} SETUP_CABP_SMALL_FILE_CACHE_ENTRY_KEY, *PSETUP_CABP_SMALL_FILE_CACHE_ENTRY_KEY;

typedef struct _SETUP_CABP_SMALL_FILE_CACHE_DATA {
    UCHAR          Buffer[100];
    LONG           OpenCount;
    ULONG          Access;
    ULONG          Share;
    LONG           Size;
} SETUP_CABP_SMALL_FILE_CACHE_ENTRY, *PSETUP_CABP_SMALL_FILE_CACHE_ENTRY;

typedef struct _SETUP_CABP_SMALL_FILE_CACHE_ENTRY {
    SETUP_CABP_SMALL_FILE_CACHE_KEY  Key; // This must be first.
    SETUP_CABP_SMALL_FILE_CACHE_DATA Data
} SETUP_CABP_SMALL_FILE_CACHE_ENTRY, *PSETUP_CABP_SMALL_FILE_CACHE_ENTRY;

typedef struct _SETUP_CABP_SMALL_FILE_OPENED_DATA {
    PSETUP_CABP_SMALL_FILE_CACHE_ENTRY CacheEntry;
    LONG                               SeekPointer;
    ULONG                              Access;
    ULONG                              Share;
} SETUP_CABP_SMALL_FILE_OPENED_DATA, *PSETUP_CABP_SMALL_FILE_OPENED_DATA;

//
// returns either STATUS_SUCCESS or STATUS_SHARING_VIOLATION
// or maybe STATUS_ACCESS_DENIED in the future
//
NTSTATUS
SpAccessCheck(
    PSETUP_CABP_SMALL_FILE_CACHE_ENTRY CacheEntry,
    ACCESS_MASK                        Access,
    ULONG                              Share
    );

typedef union _SETUP_CABP_FILE_DATA {
#if SETUP_CABP_SMALL_FILE_OPTIMIZATION
    SETUP_CABP_SMALL_FILE_OPENED_DATA Small;
#endif
    SETUP_CABP_NT_FILE_DATA           Nt;
} SETUP_CABP_FILE_DATA, *PSETUP_CABP_FILE_DATA;

typedef struct _SETUP_CABP_FILE_WITH_VTABLE {
    PSETUP_CABP_FILE_VTABLE VTable;
    SETUP_CABP_FILE_DATA    Data;
} SETUP_CABP_FILE_WITH_VTABLE, *PSETUP_CABP_FILE_WITH_VTABLE;

#ifndef KERNELMODE
typedef FAST_MUTEX SETUP_CABP_LOCK;
#define SpInitializeLock ExInitializeFastMutex
#define SpAcquireLock    ExAcquireFastMutex
#define SpReleaseLock    ExReleaseFastMutex
#define SpDeleteLock     /* nothing */
#else
typedef RTL_CRITICAL_SECTION SETUP_CABP_LOCK;
#define SpInitializeLock RtlInitializeCriticalSection
#define SpAcquireLock    RtlEnterCriticalSection
#define SpReleaseLock    RtlLeaveCriticalSection
#define SpDeleteLock     RtlDeleteCriticalSection
#endif

typedef struct _SETUP_CABP_SMALL_FILE_CACHE {
    RTL_AVL_TABLE  Table;
    SETUP_CABP_LOCK Lock;
} SETUP_CABP_SMALL_FILE_CACHE;

extern SETUP_CABP_SMALL_FILE_CACHE SpSmallFileCache;

extern const SETUP_CABP_FILE_VTABLE SpSmallFileVTable;
extern const SETUP_CABP_FILE_VTABLE SpNtFileVTable;

NTSTATUS
SpConvertSmallFileToNtFile(
    ...
    );

#endif

BOOL
SpIsStatusFileNotFoundEtc(
    NTSTATUS Status
    );

VOID
SpCloseHandle(
    HANDLE* HandlePointer
    );

VOID
SpFree(
    PVOID* PointerPointer
    );


#if SETUP_CABP_SMALL_FILE_OPTIMIZATION

VOID
SpFreeSmallFileCacheEntry(
    PSETUP_CABP_SMALL_FILE_CACHE_ENTRY* SmallFileCacheEntryPointerPointer
    );

NTSTATUS
SpOpenFile(
    UNICODE_STRING                Path,
    ULONG                         Access,
    ULONG                         Share,
    ULONG                         OpenOrCreate,
    PSETUP_CABP_FILE_WITH_VTABLE* FileOut
    );

#endif

// from windows\winstate\...\cablib.c
typedef struct _FCI_CAB_HANDLE {
    ANSI_STRING    PathA;
    ANSI_STRING    FileFormatA;
    ANSI_STRING    DiskFormatA;

    UNICODE_STRING PathW;
    UNICODE_STRING FileFormatW;
    UNICODE_STRING DiskFormatW;

    PCABGETCABINETNAMESA GetCabinetNamesA;
    PCABGETCABINETNAMESW GetCabinetNamesW;

    HFCI FciHandle;
    ERF FciErrorStruct;
    CCAB FciCabParams;
    UINT FileCount;
    UINT CabCount;
    LONGLONG FileSize;
    LONGLONG CompressedSize;

    LARGE_INTEGER StartTime;
    ULONG    SmallFileSize;
    TCOMP    CompressionType;
    TCOMP    SmallFileCompressionType;
}
FCI_CAB_HANDLE , *PFCI_CAB_HANDLE,
FCI_CAB_HANDLEA, *PFCI_CAB_HANDLEA,
FCI_CAB_HANDLEW, *PFCI_CAB_HANDLEW
;

// from windows\winstate\...\cablib.c
typedef struct {
    ANSI_STRING    PathA;
    ANSI_STRING    FileA;
    UNICODE_STRING PathW;
    UNICODE_STRING FileW;

    HFDI           FdiHandle;
    ERF            FdiErrorStruct;
    FDICABINETINFO FdiCabinetInfo;
    PVOID          Gauge;
}
FDI_CAB_HANDLE , *PFDI_CAB_HANDLE ,
FDI_CAB_HANDLEA, *PFDI_CAB_HANDLEA,
FDI_CAB_HANDLEW, *PFDI_CAB_HANDLEW
;

// from windows\winstate\...\cablib.c
typedef struct {
    ANSI_STRING       ExtractPathA;
    UNICODE_STRING    ExtractPathW;
    PCABNOTIFICATIONA NotificationA;
    PCABNOTIFICATIONW NotificationW;
}
CAB_DATA , *PCAB_DATA ,
CAB_DATAA, *PCAB_DATAA,
CAB_DATAW, *PCAB_DATAW
;

// from windows\winstate\...\cablib.c
INT
DIAMONDAPI
pCabFilePlacedW(
    IN      PCCAB FciCabParams,
    IN      PSTR FileName,
    IN      LONG FileSize,
    IN      BOOL Continuation,
    IN      PVOID Context
    );

// from windows\winstate\...\cablib.c
PVOID
DIAMONDAPI
pCabAlloc (
    IN      ULONG Size
    );

// from windows\winstate\...\cablib.c
VOID
DIAMONDAPI
pCabFree (
    IN      PVOID Memory
    );

// from windows\winstate\...\cablib.c
INT_PTR
DIAMONDAPI
pCabOpenA (
    IN      PSTR FileName,
    IN      INT oFlag,
    IN      INT pMode,
    OUT     PINT Error,
    IN      PVOID Context
    );

// from windows\winstate\...\cablib.c
INT_PTR
DIAMONDAPI
pCabOpen1A (
    IN      PSTR FileName,
    IN      INT oFlag,
    IN      INT pMode
    );

// from windows\winstate\...\cablib.c
UINT
DIAMONDAPI
pCabRead (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size,
    OUT     PINT Error,
    IN      PVOID Context
    );

// from windows\winstate\...\cablib.c
UINT
DIAMONDAPI
pCabRead1 (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size
    );

// from windows\winstate\...\cablib.c
UINT
DIAMONDAPI
pCabWrite (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size,
    OUT     PINT Error,
    IN      PVOID Context
    );

// from windows\winstate\...\cablib.c
UINT
DIAMONDAPI
pCabWrite1 (
    IN      INT_PTR FileHandle,
    IN      PVOID Buffer,
    IN      UINT Size
    );

// from windows\winstate\...\cablib.c
INT
DIAMONDAPI
pCabClose (
    IN      INT_PTR FileHandle,
    OUT     PINT Error,
    IN      PVOID Context
    );

// from windows\winstate\...\cablib.c
INT
DIAMONDAPI
pCabClose1 (
    IN      INT_PTR FileHandle
    );

// from windows\winstate\...\cablib.c
LONG
DIAMONDAPI
pCabSeek (
    IN      INT_PTR FileHandle,
    IN      LONG Distance,
    IN      INT SeekType,
    OUT     PINT Error,
    IN      PVOID Context
    );

// from windows\winstate\...\cablib.c
LONG
DIAMONDAPI
pCabSeek1 (
    IN      INT_PTR FileHandle,
    IN      LONG Distance,
    IN      INT SeekType
    );

// from windows\winstate\...\cablib.c
INT
DIAMONDAPI
pCabDeleteA (
    IN      PSTR FileName,
    OUT     PINT Error,
    IN      PVOID Context
    );

// from windows\winstate\...\cablib.c
BOOL
DIAMONDAPI
pCabGetTempFileA (
    OUT     PSTR FileName,
    IN      INT FileNameLen,
    IN      PVOID Context
    );

// from windows\winstate\...\cablib.c
BOOL
DIAMONDAPI
pCabGetNextCabinetA (
     IN     PCCAB FciCabParams,
     IN     ULONG PrevCabinetSize,
     IN     PVOID Context
     );

// from windows\winstate\...\cablib.c
BOOL
DIAMONDAPI
pCabGetNextCabinetW (
     IN     PCCAB FciCabParams,
     IN     ULONG PrevCabinetSize,
     IN     PVOID Context
     );

// from windows\winstate\...\cablib.c
LONG
DIAMONDAPI
pCabStatusA (
    IN      UINT StatusType,
    IN      ULONG Size1,
    IN      ULONG Size2,
    IN      PVOID Context
    );

// from windows\winstate\...\cablib.c
LONG
DIAMONDAPI
pCabStatusW (
    IN      UINT StatusType,
    IN      ULONG Size1,
    IN      ULONG Size2,
    IN      PVOID Context
    );

// from windows\winstate\...\cablib.c
INT_PTR
DIAMONDAPI
pCabGetOpenInfoA (
    IN      PSTR FileName,
    OUT     USHORT *Date,
    OUT     USHORT *Time,
    OUT     USHORT *Attributes,
    OUT     PINT Error,
    IN      PVOID Context
    );

// from windows\winstate\...\cablib.c
INT_PTR
DIAMONDAPI
pCabNotification (
    IN      FDINOTIFICATIONTYPE FdiNotificationType,
    IN OUT  PFDINOTIFICATION FdiNotification
    );

typedef const unsigned char* PCBYTE;

INT
DIAMONDAPI
pCabFilePlacedA(
    IN      PCCAB FciCabParams,
    IN      PSTR FileName,
    IN      LONG FileSize,
    IN      BOOL Continuation,
    IN      PVOID Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\textmode\kernel\spconfig.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    spconfig.c

Abstract:

    Registry manipulation routines 
    
Author:

    Vijay Jayaseelan (vijayj@microsoft.com) 16 May 2001

Revision History:

    None.

--*/


#include "spprecmp.h"
#pragma hdrstop
#include <initguid.h>
#include <devguid.h>

//
// The following two are defined in winlogon\setup.h, but we
// cannot include setup.h so we are putting these two values here
//

#define SETUPTYPE_FULL    1
#define SETUPTYPE_UPGRADE 4

PWSTR   LOCAL_MACHINE_KEY_NAME    = L"\\registry\\machine";
PWSTR   SETUP_KEY_NAME            = L"setup";
PWSTR   ATDISK_NAME               = L"atdisk";
PWSTR   ABIOSDISK_NAME            = L"abiosdsk";
PWSTR   PRIMARY_DISK_GROUP        = L"Primary disk";
PWSTR   VIDEO_GROUP               = L"Video";
PWSTR   KEYBOARD_PORT_GROUP       = L"Keyboard Port";
PWSTR   POINTER_PORT_GROUP        = L"Pointer Port";
PWSTR   DEFAULT_EVENT_LOG         = L"%SystemRoot%\\System32\\IoLogMsg.dll";
PWSTR   CODEPAGE_NAME             = L"CodePage";
PWSTR   UPGRADE_IN_PROGRESS       = L"UpgradeInProgress";
PWSTR   VIDEO_DEVICE0             = L"Device0";
PWSTR   SESSION_MANAGER_KEY       = L"Control\\Session Manager";
PWSTR   BOOT_EXECUTE              = L"BootExecute";
PWSTR   RESTART_SETUP             = L"RestartSetup";
PWSTR   PRODUCT_OPTIONS_KEY_NAME  = L"ProductOptions";
PWSTR   PRODUCT_SUITE_VALUE_NAME  = L"ProductSuite";
PWSTR   SP_SERVICES_TO_DISABLE    = L"ServicesToDisable";
PWSTR   SP_UPPER_FILTERS          = L"UpperFilters";
PWSTR   SP_LOWER_FILTERS          = L"LowerFilters";
PWSTR   SP_MATCHING_DEVICE_ID     = L"MatchingDeviceId";
PWSTR   SP_CONTROL_CLASS_KEY      = L"Control\\Class";
PWSTR   SP_CLASS_GUID_VALUE_NAME  = L"ClassGUID";


PWSTR ProductSuiteNames[] =
{
    L"Small Business",
    L"Enterprise",
    L"BackOffice",
    L"CommunicationServer",
    L"Terminal Server",
    L"Small Business(Restricted)",
    L"EmbeddedNT",
    L"DataCenter",
    NULL, // This is a placeholder for Single User TS - not actually a suite but the bit position is defined in ntdef.h
    L"Personal",
    L"Blade"
};

#define CountProductSuiteNames (sizeof(ProductSuiteNames)/sizeof(PWSTR))

#define MAX_PRODUCT_SUITE_BYTES 1024

extern BOOLEAN DriveAssignFromA; //NEC98

NTSTATUS
SpSavePreinstallList(
    IN PVOID  SifHandle,
    IN PWSTR  SystemRoot,
    IN HANDLE hKeySystemHive
    );

NTSTATUS
SpDoRegistryInitialization(
    IN PVOID  SifHandle,
    IN PDISK_REGION TargetRegion,
    IN PWSTR  PartitionPath,
    IN PWSTR  SystemRoot,
    IN HANDLE *HiveRootKeys,
    IN PWSTR  SetupSourceDevicePath,
    IN PWSTR  DirectoryOnSourceDevice,
    IN PWSTR  SpecialDevicePath,   OPTIONAL
    IN HANDLE ControlSet
    );

NTSTATUS
SpFormSetupCommandLine(
    IN PVOID  SifHandle,
    IN HANDLE hKeySystemHive,
    IN PWSTR  SetupSourceDevicePath,
    IN PWSTR  DirectoryOnSourceDevice,
    IN PWSTR  FullTargetPath,
    IN PWSTR  SpecialDevicePath OPTIONAL
    );

NTSTATUS
SpDriverLoadList(
    IN PVOID  SifHandle,
    IN PWSTR  SystemRoot,
    IN HANDLE hKeySystemHive,
    IN HANDLE hKeyControlSet
    );

NTSTATUS
SpSaveSKUStuff(
    IN HANDLE hKeySystemHive
    );

NTSTATUS
SpWriteVideoParameters(
    IN PVOID  SifHandle,
    IN HANDLE hKeyControlSetServices
    );

NTSTATUS
SpConfigureNlsParameters(
    IN PVOID  SifHandle,
    IN HANDLE hKeyDefaultHive,
    IN HANDLE hKeyControlSetControl
    );

NTSTATUS
SpCreateCodepageEntry(
    IN PVOID  SifHandle,
    IN HANDLE hKeyNls,
    IN PWSTR  SubkeyName,
    IN PWSTR  SifNlsSectionKeyName,
    IN PWSTR  EntryName
    );

NTSTATUS
SpConfigureFonts(
    IN PVOID  SifHandle,
    IN HANDLE hKeySoftwareHive
    );

NTSTATUS
SpStoreHwInfoForSetup(
    IN HANDLE hKeyControlSetControl
    );

NTSTATUS
SpConfigureMouseKeyboardDrivers(
    IN PVOID  SifHandle,
    IN ULONG  HwComponent,
    IN PWSTR  ClassServiceName,
    IN HANDLE hKeyControlSetServices,
    IN PWSTR  ServiceGroup
    );

NTSTATUS
SpCreateServiceEntryIndirect(
    IN  HANDLE  hKeyControlSetServices,
    IN  PVOID   SifHandle,                  OPTIONAL
    IN  PWSTR   SifSectionName,             OPTIONAL
    IN  PWSTR   KeyName,
    IN  ULONG   ServiceType,
    IN  ULONG   ServiceStart,
    IN  PWSTR   ServiceGroup,               OPTIONAL
    IN  ULONG   ServiceError,
    IN  PWSTR   FileName,                   OPTIONAL
    OUT PHANDLE SubkeyHandle                OPTIONAL
    );

NTSTATUS
SpThirdPartyRegistry(
    IN PVOID hKeyControlSetServices
    );

NTSTATUS
SpGetCurrentControlSetNumber(
    IN  HANDLE SystemHiveRoot,
    OUT PULONG Number
    );

NTSTATUS
SpCreateControlSetSymbolicLink(
    IN  HANDLE  SystemHiveRoot,
    OUT HANDLE *CurrentControlSetRoot
    );

NTSTATUS
SpAppendStringToMultiSz(
    IN HANDLE hKey,
    IN PWSTR  Subkey,
    IN PWSTR  ValueName,
    IN PWSTR  StringToAdd
    );

NTSTATUS
SpGetValueKey(
    IN  HANDLE     hKeyRoot,
    IN  PWSTR      KeyName,
    IN  PWSTR      ValueName,
    IN  ULONG      BufferLength,
    OUT PUCHAR     Buffer,
    OUT PULONG     ResultLength
    );

NTSTATUS
SpPostprocessHives(
    IN PWSTR     PartitionPath,
    IN PWSTR     Sysroot,
    IN PCWSTR   *HiveNames,
    IN HANDLE   *HiveRootKeys,
    IN unsigned  HiveCount,
    IN HANDLE    hkeyCCS
    );

NTSTATUS
SpSaveSetupPidList(
    IN HANDLE hKeySystemHive
    );

NTSTATUS
SpSavePageFileInfo(
    IN HANDLE hKeyCCSetControl,
    IN HANDLE hKeySystemHive
    );

NTSTATUS
SpSetPageFileInfo(
    IN PVOID  SifHandle,
    IN HANDLE hKeyCCSetControl,
    IN HANDLE hKeySystemHive
    );

NTSTATUS
SpGetProductSuiteMask(
    IN HANDLE hKeyControlSetControl,
    OUT PULONG SuiteMask
    );

NTSTATUS
SpSetProductSuite(
    IN HANDLE hKeyControlSetControl,
    IN ULONG SuiteMask
    );

NTSTATUS
SppMigrateFtKeys(
    IN HANDLE hDestSystemHive
    );

NTSTATUS
SpMigrateSetupKeys(
    IN PWSTR  PartitionPath,
    IN PWSTR  SystemRoot,
    IN HANDLE hDestLocalMachine,
    IN PVOID  SifHandle
    );

NTSTATUS
SppDisableDynamicVolumes(
    IN HANDLE hCCSet
    );

NTSTATUS
SppCleanupKeysFromRemoteInstall(
    VOID
    );

NTSTATUS
SpDisableUnsupportedScsiDrivers(
    IN HANDLE hKeyControlSet
    );

NTSTATUS
SpAppendPathToDevicePath(
    IN HANDLE hKeySoftwareHive,
    IN PWSTR  OemPnpDriversDirPath
    );

NTSTATUS
SpAppendFullPathListToDevicePath (
    IN HANDLE hKeySoftwareHive,
    IN PWSTR  PnpDriverFullPathList
    );

NTSTATUS
SpUpdateDeviceInstanceData(
    IN HANDLE ControlSet
    );

NTSTATUS
SpCleanUpHive(
    VOID
    );

NTSTATUS
SpProcessServicesToDisable(
    IN PVOID WinntSifHandle,
    IN PWSTR SectionName,
    IN HANDLE SystemKey
    );

NTSTATUS
SpDeleteRequiredDeviceInstanceFilters(
    IN HANDLE CCSHandle
    );
    
    
#if defined(REMOTE_BOOT)
NTSTATUS
SpCopyRemoteBootKeyword(
    IN PVOID   SifHandle,
    IN PWSTR   KeywordName,
    IN HANDLE  hKeyCCSetControl
    );
#endif // defined(REMOTE_BOOT)


#define STRING_VALUE(s) REG_SZ,(s),(wcslen((s))+1)*sizeof(WCHAR)
#define ULONG_VALUE(u)  REG_DWORD,&(u),sizeof(ULONG)

//
//  List of oem inf files installed as part of the installation of third party drivers
//
extern POEM_INF_FILE   OemInfFileList;

//
//  Name of the directory where OEM files need to be copied, if a catalog file (.cat) is part of
//  the third party driver package that the user provide using the F6 or F5 key.
//
extern PWSTR OemDirName;


VOID
SpInitializeRegistry(
    IN PVOID        SifHandle,
    IN PDISK_REGION TargetRegion,
    IN PWSTR        SystemRoot,
    IN PWSTR        SetupSourceDevicePath,
    IN PWSTR        DirectoryOnSourceDevice,
    IN PWSTR        SpecialDevicePath   OPTIONAL,
    IN PDISK_REGION SystemPartitionRegion
    )

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    PWSTR pwstrTemp1,pwstrTemp2;
    int h;
    ULONG Disposition;
    LPCWSTR HiveNames[SetupHiveMax]    = { L"system",L"software",L"default",L"userdiff" };
    HANDLE  HiveRootKeys[SetupHiveMax] = { NULL     ,NULL       ,NULL      ,NULL        };
    PWSTR PartitionPath;
    HANDLE FileHandle;
    HANDLE KeyHandle;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Put up a screen telling the user what we are doing.
    //
    SpStartScreen(
        SP_SCRN_DOING_REG_CONFIG,
        0,
        8,
        TRUE,
        FALSE,
        DEFAULT_ATTRIBUTE
        );

    SpDisplayStatusText(SP_STAT_REG_LOADING_HIVES,DEFAULT_STATUS_ATTRIBUTE);

    //
    // Get the name of the target patition.
    //
    SpNtNameFromRegion(
        TargetRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    PartitionPath = SpDupStringW(TemporaryBuffer);

    // pwstrTemp2 points half way through the buffer.

    pwstrTemp1 = TemporaryBuffer;
    pwstrTemp2 = TemporaryBuffer + (sizeof(TemporaryBuffer) / sizeof(WCHAR) / 2);

    //
    // In the fresh install case, there are no hive files in the target tree.
    // We create a key in a known place (\Registry\Machine\System\$$$PROTO.HIV,
    // which is 4 levels deep because \Registry\Machine\$$$PROTO.HIV would
    // imply a hive called $$$PROTO.HIV and we don't want to get tripped up
    // by those semantics). Then we save off that empty key 3 times into
    // system32\config to form 3 empty hives.
    //
    // In the upgrade case this there are actual hives in the target tree
    // which we do NOT want to overwrite!
    //
    // If this is the ASR quick test, we don't want to recreate any of the hives
    //
    // We also want to create an empty userdiff hive in both the fresh and
    // upgrade cases.
    //
    //
    INIT_OBJA(
        &ObjectAttributes,
        &UnicodeString,
        L"\\Registry\\Machine\\System\\$$$PROTO.HIV"
        );

    Status = ZwCreateKey(
                &KeyHandle,
                KEY_ALL_ACCESS,
                &ObjectAttributes,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                &Disposition
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to create root key for protohive (%lx)\n",Status));
    } else {

        ASSERT(SetupHiveUserdiff == SetupHiveMax-1);

        if (ASRMODE_QUICKTEST_FULL != SpAsrGetAsrMode()) {
            for(h = ((NTUpgrade == UpgradeFull) ? SetupHiveUserdiff : 0);
                NT_SUCCESS(Status) && (h < SetupHiveMax);
                h++) {

                //
                // Form full pathname to the hive we want to create.
                // Then create the file.
                //
                wcscpy(pwstrTemp1,PartitionPath);
                SpConcatenatePaths(pwstrTemp1,SystemRoot);
                SpConcatenatePaths(pwstrTemp1,L"SYSTEM32\\CONFIG");
                SpConcatenatePaths(pwstrTemp1,HiveNames[h]);


                SpDeleteFile(pwstrTemp1,NULL,NULL);  // Make sure that we get rid of the file if it has attributes.

                INIT_OBJA(&ObjectAttributes,&UnicodeString,pwstrTemp1);

                Status = ZwCreateFile(
                            &FileHandle,
                            FILE_GENERIC_WRITE,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            NULL,
                            FILE_ATTRIBUTE_NORMAL,
                            0,                      // no sharing
                            FILE_OVERWRITE_IF,
                            FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                            NULL,
                            0
                            );

                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to create file %ws for protohive (%lx)\n",pwstrTemp1,Status));
                } else {
                    //
                    // Save the empty key we created above into the file
                    // we just created. This creates an empty hive.
                    // Call the Ex version to make sure the hive is in the latest format
                    //
                    Status = ZwSaveKeyEx(KeyHandle,FileHandle,REG_LATEST_FORMAT);
                    if(!NT_SUCCESS(Status)) {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to save empty key to protohive %ws (%lx)\n",pwstrTemp1,Status));
                    }

                    ZwClose(FileHandle);
                }
            }
        }

        ZwDeleteKey(KeyHandle);
        ZwClose(KeyHandle);
    }

    //
    // Now we have hives in both the upgrade and fresh install cases.
    // Load them up. We use the convention that a hive is loaded into
    // \Registry\Machine\x<hivename>.
    //
    for(h=0; NT_SUCCESS(Status) && (h<SetupHiveMax); h++) {

        swprintf(pwstrTemp1,L"%ws\\x%ws",LOCAL_MACHINE_KEY_NAME,HiveNames[h]);

        wcscpy(pwstrTemp2,PartitionPath);
        SpConcatenatePaths(pwstrTemp2,SystemRoot);
        SpConcatenatePaths(pwstrTemp2,L"SYSTEM32\\CONFIG");
        SpConcatenatePaths(pwstrTemp2,HiveNames[h]);

        Status = SpLoadUnloadKey(NULL,NULL,pwstrTemp1,pwstrTemp2);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: load hive %ws into %ws failed (%lx)\n",pwstrTemp2,pwstrTemp1,Status));
        } else {
            INIT_OBJA(&ObjectAttributes,&UnicodeString,pwstrTemp1);
            Status = ZwOpenKey(&HiveRootKeys[h],KEY_ALL_ACCESS,&ObjectAttributes);
            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: open root key %ws failed (%lx)\n",pwstrTemp1,Status));
            }
        }
    }

    //
    // Make a symbolic link such that CurrentControlSet is valid.
    // This allows references in infs to work in either the fresh install case,
    // where we're always dealing with ControlSet001, or in the upgrade case,
    // where the control set we're dealing with is dictated by the state of
    // the existing registry.
    //
    if(NT_SUCCESS(Status)) {
        Status = SpCreateControlSetSymbolicLink(HiveRootKeys[SetupHiveSystem],&KeyHandle);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to create ccs symbolic link (%lx)\n",Status));
        }
    }

    //
    // Go do registry initialization.
    //
    if(NT_SUCCESS(Status)) {

        SpDisplayStatusText(SP_STAT_REG_DOING_HIVES,DEFAULT_STATUS_ATTRIBUTE);

        Status = SpDoRegistryInitialization(
                    SifHandle,
                    TargetRegion,
                    PartitionPath,
                    SystemRoot,
                    HiveRootKeys,
                    SetupSourceDevicePath,
                    DirectoryOnSourceDevice,
                    SpecialDevicePath,
                    KeyHandle
                    );

        SpDisplayStatusText(SP_STAT_REG_SAVING_HIVES,DEFAULT_STATUS_ATTRIBUTE);

        if(NT_SUCCESS(Status)) {

#ifdef _X86_
            if (WinUpgradeType == UpgradeWin95) {
                //
                // NOTE: -- Clean this up.
                //
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "SETUP: Migrating disk registry of win9x information.\n"));
                Status = SpMigrateDiskRegistry( HiveRootKeys[SetupHiveSystem]);

                if (!NT_SUCCESS(Status)) {

                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to migrate disk registry.\n"));
                }

            }

            //
            // We've set the \\Registry\\Machine\\System\\Setup\\SystemPartition
            // value when we did the partitioning code.  Now we need to migrate
            // that value into the proto hives so they'll be there for
            // the reboot.
            //
            {
#if 0
            HANDLE  Key;
            DWORD   ResultLength;
            PWSTR   SystemPartitionString = 0;


                INIT_OBJA(&ObjectAttributes,&UnicodeString,LOCAL_MACHINE_KEY_NAME);
                Status = ZwOpenKey(&Key,KEY_READ,&ObjectAttributes);
                if(NT_SUCCESS(Status)) {

                    Status = SpGetValueKey(
                                 Key,
                                 L"System\\Setup",
                                 L"SystemPartition",
                                 sizeof(TemporaryBuffer),
                                 (PCHAR)TemporaryBuffer,
                                 &ResultLength
                                 );

                    ZwClose(Key);

                    if(NT_SUCCESS(Status)) {
                        SystemPartitionString = SpDupStringW( TemporaryBuffer );

                        if( SystemPartitionString ) {
                            Status = SpOpenSetValueAndClose( HiveRootKeys[SetupHiveSystem],
                                                             SETUP_KEY_NAME,
                                                             L"SystemPartition",
                                                             STRING_VALUE(SystemPartitionString) );

                            if(!NT_SUCCESS(Status)) {
                                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to set SystemPartitionString. (%lx)\n", Status));
                            }

                            SpMemFree(SystemPartitionString);
                        } else {
                            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to duplicate SystemPartitionString.\n"));
                        }

                    } else {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to query SystemPartition Value.\n"));
                    }
                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to Open HKLM while trying to query the SytemPartition Value.\n"));
                }
#else

                PWSTR   SystemPartitionString = 0;

                SpNtNameFromRegion( SystemPartitionRegion,
                                    TemporaryBuffer,
                                    sizeof(TemporaryBuffer),
                                    PartitionOrdinalCurrent );

                SystemPartitionString = SpDupStringW( TemporaryBuffer );

                if( SystemPartitionString ) {
                    Status = SpOpenSetValueAndClose( HiveRootKeys[SetupHiveSystem],
                                                     SETUP_KEY_NAME,
                                                     L"SystemPartition",
                                                     STRING_VALUE(SystemPartitionString) );

                    if(!NT_SUCCESS(Status)) {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to set SystemPartitionString. (%lx)\n", Status));
                    }

                    SpMemFree(SystemPartitionString);
                } else {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to duplicate SystemPartitionString.\n"));
                }

#endif
            }
#endif

            //
            //  Note that SpPostprocessHives() will always close KeyHandle
            //
            Status = SpPostprocessHives(
                        PartitionPath,
                        SystemRoot,
                        HiveNames,
                        HiveRootKeys,
                        3,
                        KeyHandle
                        );
        } else {
            //
            //  If SpDoRegistryInitialization() fails, then we need to close KeyHandle here,
            //  before we start unloading the hives.
            //
            NtClose(KeyHandle);
        }
    }

    SpDisplayStatusText(SP_STAT_REG_SAVING_HIVES,DEFAULT_STATUS_ATTRIBUTE);

    //
    // From now on, do not disturb the value of Status.
    //
    // NOTE: DO NOT WRITE ANYTHING INTO HIVES BEYOND THIS POINT!!!
    //
    // In the upgrade case we have performed a little swictheroo in
    // SpPostprocessHives() such that anything written to the system hive
    // ends up in system.sav instead of system!
    //
    for(h=0; h<SetupHiveMax; h++) {

        if(HiveRootKeys[h]) {
            ZwClose(HiveRootKeys[h]);
        }

        swprintf(pwstrTemp1,L"%ws\\x%ws",LOCAL_MACHINE_KEY_NAME,HiveNames[h]);
        SpLoadUnloadKey(NULL,NULL,pwstrTemp1,NULL);
    }

    SpMemFree(PartitionPath);

    if(!NT_SUCCESS(Status)) {

        SpDisplayScreen(SP_SCRN_REGISTRY_CONFIG_FAILED,3,HEADER_HEIGHT+1);
        SpDisplayStatusOptions(DEFAULT_STATUS_ATTRIBUTE,SP_STAT_F3_EQUALS_EXIT,0);

        SpInputDrain();
        while(SpInputGetKeypress() != KEY_F3) ;

        SpDone(0,FALSE,TRUE);
    }
}


NTSTATUS
SpDoRegistryInitialization(
    IN PVOID  SifHandle,
    IN PDISK_REGION TargetRegion,
    IN PWSTR  PartitionPath,
    IN PWSTR  SystemRoot,
    IN HANDLE *HiveRootKeys,
    IN PWSTR  SetupSourceDevicePath,
    IN PWSTR  DirectoryOnSourceDevice,
    IN PWSTR  SpecialDevicePath,   OPTIONAL
    IN HANDLE ControlSet
    )

/*++

Routine Description:

    Initialize a registry based on user selection for hardware types,
    software options, and user preferences.

    - Create a command line for GUI setup, to be used by winlogon.
    - Create/munge service list entries for device drivers being installed.
    - Initialize the keyboard layout.
    - Initialize a core set of fonts for use with Windows.
    - Store information about selected ahrdware components for use by GUI setup.

Arguments:

    SifHandle - supplies handle to loaded setup information file.

    TargetRegion - supplies region descriptor for region to which the system
        is to be installed.

    PartitionPath - supplies the NT name for the drive of windows nt.

    SystemRoot - supplies nt path of the windows nt directory.

    HiveRootKeys - supplies the handles to the root key of the system, software
                   and default hives

    HiveRootPaths - supplies the paths to the root keys of the system, software
                    and default hives.

    SetupSourceDevicePath - supplies nt path to the device setup is using for
        source media (\device\floppy0, \device\cdrom0, etc).

    DirectoryOnSourceDevice - supplies the directory on the source device
        where setup files are kept.

Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE hKeyControlSetControl;
    PWSTR FullTargetPath;
    LPWSTR p;
    BOOLEAN b;
    ULONG SuiteMask = 0;
    PWSTR AdditionalGuiPnpDrivers;


    if(NTUpgrade != UpgradeFull) {

        b = SpHivesFromInfs(
                SifHandle,
                L"HiveInfs.Fresh",
                SetupSourceDevicePath,
                DirectoryOnSourceDevice,
                HiveRootKeys[SetupHiveSystem],
                HiveRootKeys[SetupHiveSoftware],
                HiveRootKeys[SetupHiveDefault],
                HiveRootKeys[SetupHiveUserdiff]
                );

#if defined(REMOTE_BOOT)
        //
        // If this is a remote boot setup, process the AddReg.RemoteBoot
        // section in hivesys.inf and the AddReg section in winnt.sif.
        //
        if (b && RemoteBootSetup) {
            (VOID)SpHivesFromInfs(
                      SifHandle,
                      L"HiveInfs.Fresh.RemoteBoot",
                      SetupSourceDevicePath,
                      DirectoryOnSourceDevice,
                      HiveRootKeys[SetupHiveSystem],
                      HiveRootKeys[SetupHiveSoftware],
                      HiveRootKeys[SetupHiveDefault],
                      NULL
                      );
            ASSERT(WinntSifHandle != NULL);
            (VOID)SpProcessAddRegSection(
                      WinntSifHandle,
                      L"AddReg",
                      HiveRootKeys[SetupHiveSystem],
                      HiveRootKeys[SetupHiveSoftware],
                      HiveRootKeys[SetupHiveDefault],
                      NULL
                      );
        }
#endif // defined(REMOTE_BOOT)

        if(!b) {
            Status = STATUS_UNSUCCESSFUL;
            goto sdoinitreg1;
        }
    }

    //
    // Open ControlSet\Control.
    //
    INIT_OBJA(&Obja,&UnicodeString,L"Control");
    Obja.RootDirectory = ControlSet;

    Status = ZwOpenKey(&hKeyControlSetControl,KEY_ALL_ACCESS,&Obja);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open CurrentControlSet\\Control (%lx)\n",Status));
        goto sdoinitreg1;
    }

    //
    //  Save the Pid list
    //
    SpSaveSetupPidList( HiveRootKeys[SetupHiveSystem] );

    //
    // Form the setup command line.
    //

    wcscpy(TemporaryBuffer, PartitionPath);
    SpConcatenatePaths(TemporaryBuffer, SystemRoot);
    FullTargetPath = SpDupStringW(TemporaryBuffer);

    Status = SpFormSetupCommandLine(
                SifHandle,
                HiveRootKeys[SetupHiveSystem],
                SetupSourceDevicePath,
                DirectoryOnSourceDevice,
                FullTargetPath,
                SpecialDevicePath
                );
    SpMemFree(FullTargetPath);

    if(!NT_SUCCESS(Status)) {
        goto sdoinitreg3;
    }

    //
    // Save evalution time
    //
    Status = SpSaveSKUStuff(HiveRootKeys[SetupHiveSystem]);
    if(!NT_SUCCESS(Status)) {
        goto sdoinitreg3;
    }

    //
    // Set the product suite
    //

    SpGetProductSuiteMask(hKeyControlSetControl,&SuiteMask);
    //
    // Account for multiple suite bits being set in SuiteType.
    //
//    SuiteMask |= (1 << (SuiteType-1));
    //
    // there's one more problem: PERSONAL sku is identified by VER_SUITE_PERSONAL flag set
    // we want to be able to upgrade from PER to PRO, but PRO doesn't have any flag set
    // we also want to be able to upgrade from PER to PER, but in this case this bit will be set
    // in SuiteType; therefore it's safe to always clear this bit before applying the new mask
    //
    SuiteMask &= ~VER_SUITE_PERSONAL;
    SuiteMask |= SuiteType;
    SpSetProductSuite(hKeyControlSetControl,SuiteMask);

    //
    // Language/locale-specific registry initialization.
    //
    Status = SplangSetRegistryData(
                SifHandle,
                ControlSet,
                (NTUpgrade == UpgradeFull) ? NULL : HardwareComponents,
                (BOOLEAN)(NTUpgrade == UpgradeFull)
                );

    if(!NT_SUCCESS(Status)) {
        goto sdoinitreg3;
    }



    //
    // If we need to convert to ntfs, set that up here.
    // We can't use the PartitionPath since that is based on
    // *current* disk ordinal -- we need a name based on the *on-disk*
    // ordinal, since the convert occurs after a reboot. Moved it here
    // so that this is done for upgrades too.
    //
    if(ConvertNtVolumeToNtfs) {
        WCHAR   GuidVolumeName[MAX_PATH] = {0};
        PWSTR   VolumeName;

        wcscpy(TemporaryBuffer,L"autoconv ");
        VolumeName = TemporaryBuffer + wcslen(TemporaryBuffer);

        SpNtNameFromRegion(
            TargetRegion,
            VolumeName,   // append to the "autoconv " we put there
            512,                        // just need any reasonable size
            PartitionOrdinalCurrent
            );

        //
        // NOTE: Don't use volume GUIDs for file system conversion 
        // for 9x upgrades.
        // 
        if (WinUpgradeType == NoWinUpgrade) {
            //
            // Try to get hold of the \\??\Volume{a-b-c-d} format
            // volume name for the partition
            //
            Status = SpPtnGetGuidNameForPartition(VolumeName,
                            GuidVolumeName);

            //
            // If GuidVolumeName is available then use that rather
            // than \device\harddiskX\partitionY since disk ids can
            // change across reboots
            //
            if (NT_SUCCESS(Status) && GuidVolumeName[0]) {
                wcscpy(VolumeName, GuidVolumeName);
            }
        }                        

        wcscat(TemporaryBuffer, L" /fs:NTFS");

        FullTargetPath = SpDupStringW(TemporaryBuffer);

        Status = SpAppendStringToMultiSz(
                    ControlSet,
                    SESSION_MANAGER_KEY,
                    BOOT_EXECUTE,
                    FullTargetPath
                    );

        SpMemFree(FullTargetPath);
    }

    if(NTUpgrade == UpgradeFull) {

        SpSavePageFileInfo( hKeyControlSetControl,
                            HiveRootKeys[SetupHiveSystem] );


        Status = SpUpgradeNTRegistry(
                    SifHandle,
                    HiveRootKeys,
                    SetupSourceDevicePath,
                    DirectoryOnSourceDevice,
                    ControlSet
                    );
        if(!NT_SUCCESS(Status)) {
            goto sdoinitreg3;
        }

        Status = SpProcessAddRegSection(
            WinntSifHandle,
            L"compatibility",
            HiveRootKeys[SetupHiveSystem],
            NULL,
            NULL,
            NULL
            );
            
        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to process compatibility settings.\n"));
        }

        //
        // Disable all upper and lower level class filters for the services which were
        // disabled
        //
        Status = SpProcessServicesToDisable(WinntSifHandle,
                    SP_SERVICES_TO_DISABLE,
                    hKeyControlSetControl);
                        

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, 
                DPFLTR_ERROR_LEVEL, 
                "SETUP: Unable to process ServicesToDisable section (%lx).\n",
                Status));
        }

        //
        // Remove all the upper and lower device instance filter drivers for keyboard and
        // mouse class drivers
        //
        Status = SpDeleteRequiredDeviceInstanceFilters(ControlSet);

        if (!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, 
                DPFLTR_ERROR_LEVEL, 
                "SETUP: Unable to unable to delete keyboard & mouse device filter drivers (%lx).\n",
                Status));
        }

        
        //
        // Set up font entries.
        //
        Status = SpConfigureFonts(SifHandle,HiveRootKeys[SetupHiveSoftware]);
        if(!NT_SUCCESS(Status)) {
            goto sdoinitreg3;
        }

        //
        // Enable detected scsi miniports, atdisk and abios disk, if necessary
        //
        Status = SpDriverLoadList(SifHandle,SystemRoot,HiveRootKeys[SetupHiveSystem],ControlSet);
        if(!NT_SUCCESS(Status)) {
            goto sdoinitreg3;
        }

        //
        //  Disable the unsupported scsi drivers that need to be disabled
        //
        if( UnsupportedScsiHardwareToDisable != NULL ) {
            SpDisableUnsupportedScsiDrivers( ControlSet );
        }

    } else {

        if (IsNEC_98) { //NEC98
            //
            // NEC98 default drive assign for hard drive is start from A:,
            // so if it need to start from C: we should set "DriveLetter" KEY into hive.
            //
            if( !DriveAssignFromA ) {
                Status = SpOpenSetValueAndClose(HiveRootKeys[SetupHiveSystem],
                                                SETUP_KEY_NAME,
                                                L"DriveLetter",
                                                STRING_VALUE(L"C"));
            }

            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set system\\setup\\drive letter (%lx)\n",Status));
                return(Status);
            }
        } //NEC98

        //
        // Create service entries for drivers being installed
        // (ie, munge the driver load list).
        //
        Status = SpDriverLoadList(SifHandle,SystemRoot,HiveRootKeys[SetupHiveSystem],ControlSet);
        if(!NT_SUCCESS(Status)) {
            goto sdoinitreg3;
        }

        if (SpDrEnabled()) {
            Status = SpDrSetEnvironmentVariables(HiveRootKeys);
            if(!NT_SUCCESS(Status)) {
                goto sdoinitreg3;
            }
        }


        //
        // Set up the keyboard layout and nls-related stuff.
        //
        Status = SpConfigureNlsParameters(SifHandle,HiveRootKeys[SetupHiveDefault],hKeyControlSetControl);
        if(!NT_SUCCESS(Status)) {
            goto sdoinitreg3;
        }

        //
        // Set up font entries.
        //
        Status = SpConfigureFonts(SifHandle,HiveRootKeys[SetupHiveSoftware]);
        if(!NT_SUCCESS(Status)) {
            goto sdoinitreg3;
        }

        //
        // Store information used by gui setup, describing the hardware
        // selections made by the user.
        //
        Status = SpStoreHwInfoForSetup(hKeyControlSetControl);
        if(!NT_SUCCESS(Status)) {
            goto sdoinitreg3;
        }
        if( PreInstall ) {
            ULONG  u;
            PWSTR  OemPnpDriversDirPath;

            u = 1;
            SpSavePreinstallList( SifHandle,
                                  SystemRoot,
                                  HiveRootKeys[SetupHiveSystem] );

            Status = SpOpenSetValueAndClose( hKeyControlSetControl,
                                             L"Windows",
                                             L"NoPopupsOnBoot",
                                             ULONG_VALUE(u) );
            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set NoPopupOnBoot. Status = %lx \n",Status));
            }

            //
            // Add autolfn.exe to bootexecute list.
            //
            Status = SpAppendStringToMultiSz(
                        ControlSet,
                        SESSION_MANAGER_KEY,
                        BOOT_EXECUTE,
                        L"autolfn"
                        );

            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to add autolfn to BootExecute. Status = %lx \n",Status));
                goto sdoinitreg3;
            }

            //
            //  If unattended file specifies path to OEM drivers directory, then append path
            //  to HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion, DevicePath
            //
            OemPnpDriversDirPath = SpGetSectionKeyIndex(UnattendedSifHandle,
                                                        SIF_UNATTENDED,
                                                        WINNT_OEM_PNP_DRIVERS_PATH_W,
                                                        0);
            if( OemPnpDriversDirPath != NULL ) {
                Status = SpAppendPathToDevicePath( HiveRootKeys[SetupHiveSoftware], OemPnpDriversDirPath );
                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to append %ls to DevicePath. Status = %lx \n",OemPnpDriversDirPath,Status));
                    goto sdoinitreg3;
                }
            }
        }
    }

    SpSetPageFileInfo( SifHandle, hKeyControlSetControl, HiveRootKeys[SetupHiveSystem] );

    //
    // Skip migration of FTKeys in the win95 upgrade case. This is important in order to ensure that
    // drive letters are preserved. At the beginning of GUI mode, the mounted devices key will
    // be rebuilt using the data stored by win9xupg in the HKLM\System\DISK.
    //

#ifdef _X86_
    if (WinUpgradeType != UpgradeWin95) {
#endif

    //
    // Do the migration of HKEY_LOCAL_MACHINE\SYSTEM\DISK and HKEY_LOCAL_MACHINE\SYSTEM\MountedDevices
    // from the setup hive to the target hive (if these keys exist).
    //
    Status = SppMigrateFtKeys(HiveRootKeys[SetupHiveSystem]);
    if(!NT_SUCCESS(Status)) {
        goto sdoinitreg3;
    }

#ifdef _X86_
    }
#endif

    //
    // On a remote install, we do some registry cleanup before migrating
    // keys.
    //
    if (RemoteInstallSetup) {
        SppCleanupKeysFromRemoteInstall();
    }

    //
    // Do any cleanup on the system hive before we migrate it to the target
    // system hive.
    //
    SpCleanUpHive();



    //
    //  Migrate some keys from the setup hive to the target system hive.
    //
    Status = SpMigrateSetupKeys( PartitionPath, SystemRoot, ControlSet, SifHandle );
    if( !NT_SUCCESS(Status) ) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to migrate registry keys from the setup hive to the target system hive. Status = %lx\n", Status));
        goto sdoinitreg3;
    }

    //
    //  Disable Dynamic Volumes on portables and
    //  Whistler Personal
    //
    if( DockableMachine || SpIsProductSuite(VER_SUITE_PERSONAL)) {
        NTSTATUS Status1;

        Status1 = SppDisableDynamicVolumes(ControlSet);

        if( !NT_SUCCESS( Status1 ) ) {
            KdPrintEx((DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Unable to disable dynamic volumes on laptop/personal builds. Status = %lx \n",
                Status1));
        }
    }

    //
    // A side-effect of loading setupdd.sys is that Plug&Play generates a device instance
    // key for it called "Root\LEGACY_SETUPDD\0000".  Clean that up now.  (No need to check
    // the return status--if this fails it's no big deal.)
    //
    SppDeleteKeyRecursive(ControlSet,
                          L"Enum\\Root\\LEGACY_SETUPDD",
                          TRUE
                         );

    //
    // Delete the virtual RAM devices and driver keys
    //
    if (VirtualOemSourceDevices) {
        //
        // delete the root devnodes
        //
        SpDeleteRootDevnodeKeys(SifHandle,
            ControlSet,
            L"RootDevicesToDelete.clean",
            NULL);

        //
        // Remove the service
        //
        SppDeleteKeyRecursive(ControlSet,
            L"Services\\" RAMDISK_DRIVER_NAME,
            TRUE);
    }

#if defined(REMOTE_BOOT)
    //
    // Copy information that remote boot needs from the .sif to the
    // registry.
    //
    if (RemoteBootSetup) {
        (VOID)SpCopyRemoteBootKeyword(WinntSifHandle,
                                      SIF_ENABLEIPSECURITY,
                                      hKeyControlSetControl);
        (VOID)SpCopyRemoteBootKeyword(WinntSifHandle,
                                      SIF_REPARTITION,
                                      hKeyControlSetControl);
    }
#endif // defined(REMOTE_BOOT)

    //
    //  Finally, if the answer file specifies a path list to additional GUI drivers,
    //  then append this path to the DevicePath value
    //
    AdditionalGuiPnpDrivers = SpGetSectionKeyIndex (
                                    WinntSifHandle,
                                    SIF_SETUPPARAMS,
                                    WINNT_SP_DYNUPDTADDITIONALGUIDRIVERS_W,
                                    0
                                    );
    if (AdditionalGuiPnpDrivers) {
        Status = SpAppendFullPathListToDevicePath (HiveRootKeys[SetupHiveSoftware], AdditionalGuiPnpDrivers);
        if (!NT_SUCCESS(Status)) {
            KdPrintEx ((
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "SETUP: Unable to append %ls to DevicePath. Status = %lx \n",
                AdditionalGuiPnpDrivers,
                Status
                ));
            goto sdoinitreg3;
        }
    }

sdoinitreg3:

    ZwClose(hKeyControlSetControl);

sdoinitreg1:

    return(Status);
}


NTSTATUS
SpFormSetupCommandLine(
    IN PVOID  SifHandle,
    IN HANDLE hKeySystemHive,
    IN PWSTR  SetupSourceDevicePath,
    IN PWSTR  DirectoryOnSourceDevice,
    IN PWSTR  FullTargetPath,
    IN PWSTR  SpecialDevicePath   OPTIONAL
    )

/*++

Routine Description:

    Create the command line to invoke GUI setup and store it in
    HKEY_LOCAL_MACHINE\system\<ControlSet>\Setup:CmdLine.

    The command line for the command to be launched depends
    on whether NT Setup is executing within a disaster recovery
    context, or a normal context.  For the normal case, the
    command line is is as follows:

        setup -newsetup

    For Automated System Recovery (ASR), the command line is
        setup -newsetup -asr

    For the automated ASR quick test, the command line is
        setup - newsetup -asrquicktest

Arguments:

    SifHandle - handle to the master sif (txtsetup.sif)

    hKeySystemHive - supplies handle to root of the system hive
        (ie, HKEY_LOCAL_MACHINE\System).

    SetupSourceDevicePath - supplies the nt device path of the source media
        to be used during setup (\device\floppy0, \device\cdrom0, etc).

    DirectoryOnSourceDevice - supplies the directory on the source device
        where setup files are kept.

    FullTargetPath - supplies the NtPartitionName+SystemRoot path on the target device.

    SpecialDevicePath - if specified, will be passed to setup as the value for
        STF_SPECIAL_PATH.  If not specified, STF_SPECIAL_PATH will be "NO"

Return Value:

    Status value indicating outcome of operation.

--*/

{
    PWSTR OptionalDirSpec = NULL;
    PWSTR UserExecuteCmd = NULL;
    PWSTR szLanManNt = WINNT_A_LANMANNT_W;
    PWSTR szWinNt = WINNT_A_WINNT_W;
    PWSTR szYes = WINNT_A_YES_W;
    PWSTR szNo = WINNT_A_NO_W;
    PWSTR SourcePathBuffer;
    PWSTR CmdLine;
    DWORD SetupType,SetupInProgress;
    NTSTATUS Status;
    PWSTR TargetFile;
    PWSTR p;
    WCHAR *Data[1];

    //
    // Can't use TemporaryBuffer because we make subroutine calls
    // below that trash its contents.
    //
    CmdLine = SpMemAlloc(256);
    CmdLine[0] = 0;

    //
    // Construct the setup command line.  Start with the basic part.
    // We first look in winnt.sif for this data, and if it isn't there, then
    // we look in the sif handle which was input to us.
    //
    if(p = SpGetSectionKeyIndex(WinntSifHandle,SIF_SETUPDATA,SIF_SETUPCMDPREPEND,0)) {
        wcscpy(CmdLine,p);
    } else if(p = SpGetSectionKeyIndex(SifHandle,SIF_SETUPDATA,SIF_SETUPCMDPREPEND,0)) {
        wcscpy(CmdLine,p);
    }

    // If we did get some parameter read in from unattend file, add separator.
    //
    if (*CmdLine)
        wcscat(CmdLine,L" ");

    //
    // If this is ASR, append the appropriate cmd line options to GUI-mode Setup
    //
    if (SpDrEnabled()) {

        if (ASRMODE_NORMAL == SpAsrGetAsrMode()) {
            //
            // This is normal ASR mode
            //
            wcscat(CmdLine, L"setup -newsetup -asr");
        }
        else {
            //
            // This is the Full Asr QuickTest
            //
            wcscat(CmdLine, L"setup -newsetup -asrquicktest");
        }

    } else {
        wcscat( CmdLine,L"setup -newsetup" );
    }

    //
    // Put the setup source in the command line.
    // Note that the source is an NT-style name. GUI Setup handles this properly.
    //
    SourcePathBuffer = SpMemAlloc( (wcslen(SetupSourceDevicePath) +
        wcslen(DirectoryOnSourceDevice) + 2) * sizeof(WCHAR) );
    wcscpy(SourcePathBuffer,SetupSourceDevicePath);

    if (!NoLs) {

        SpConcatenatePaths(SourcePathBuffer,DirectoryOnSourceDevice);

    }

    //
    // if we were given an administrator password via a remote install,
    // we need to put this in the unattend file if appropriate.
    //
    if (NetBootAdministratorPassword) {
        SpAddLineToSection(
                    WinntSifHandle,
                    SIF_GUI_UNATTENDED,
                    WINNT_US_ADMINPASS_W,
                    &NetBootAdministratorPassword,
                    1);
    }

    SpAddLineToSection(WinntSifHandle,SIF_DATA,WINNT_D_SOURCEPATH_W,
        &SourcePathBuffer,1);

    //
    // Put a flag indicating whether this is a win3.1 upgrade.
    //
    SpAddLineToSection(WinntSifHandle,SIF_DATA,WINNT_D_WIN31UPGRADE_W,
        ( (WinUpgradeType == UpgradeWin31) ? &szYes : &szNo),1);

    //
    // Put a flag indicating whether this is a win95 upgrade.
    //
    SpAddLineToSection(WinntSifHandle,SIF_DATA,WINNT_D_WIN95UPGRADE_W,
        ( (WinUpgradeType == UpgradeWin95) ? &szYes : &szNo),1);

    //
    // Put a flag indicating whether this is an NT upgrade.
    //
    SpAddLineToSection(WinntSifHandle,SIF_DATA,WINNT_D_NTUPGRADE_W,
        ((NTUpgrade == UpgradeFull) ? &szYes : &szNo), 1);

    //
    // Put a flag indicating whether to upgrade a standard server
    // (an existing standard server, or an existing workstation to
    // a standard server)
    //
    SpAddLineToSection(WinntSifHandle,SIF_DATA,WINNT_D_SERVERUPGRADE_W,
        (StandardServerUpgrade ? &szYes : &szNo),1);

    //
    // Tell gui mode whether this is server or workstation.
    //
    SpAddLineToSection(WinntSifHandle,SIF_DATA,WINNT_D_PRODUCT_W,
        (AdvancedServer ? &szLanManNt : &szWinNt),1);

    //
    // Special path spec.
    //
    SpAddLineToSection(WinntSifHandle,SIF_DATA,WINNT_D_BOOTPATH_W,
        (SpecialDevicePath ? &SpecialDevicePath : &szNo), 1);

    //
    // Go Fetch the Optional Dir Specs...
    //
    OptionalDirSpec = SpGetSectionKeyIndex(WinntSifHandle,SIF_SETUPPARAMS,
        L"OptionalDirs",0);

    //
    // Check for commad line to execute at end of gui setup
    //
    UserExecuteCmd = SpGetSectionKeyIndex(WinntSifHandle,SIF_SETUPPARAMS,
        L"UserExecute",0);

    //
    // Unattended mode flag | script filename
    //
    SpAddLineToSection(WinntSifHandle,SIF_DATA,WINNT_D_INSTALL_W,
        ((UnattendedOperation || UnattendedGuiOperation || SpDrEnabled()) ? &szYes : &szNo), 1);

    //
    // If this is ASR, write out the Networking sections to allow
    // GUI-mode to be unattended
    //
    if (SpDrEnabled()) {
        SpAddLineToSection(WinntSifHandle,L"Networking",L"InstallDefaultComponents",&szYes,1);
        Data[0]=L"WORKGROUP";
        SpAddLineToSection(WinntSifHandle,L"Identification",L"JoinWorkgroup",Data,1);
    }

    //
    // Write the name of OEM inf files, if any.
    //
    if( OemInfFileList != NULL ) {
        PWSTR   OemDriversKeyName = WINNT_OEMDRIVERS_W; // L"OemDrivers";
        PWSTR   OemDriverPathName = WINNT_OEMDRIVERS_PATHNAME_W; // L"OemDriverPathName";
        PWSTR   OemInfName = WINNT_OEMDRIVERS_INFNAME_W;         // L"OemInfName";
        PWSTR   OemDriverFlags = WINNT_OEMDRIVERS_FLAGS_W;
        PWSTR   OemInfSectionName = L"OemInfFiles";
        PWSTR   szOne = L"1";
        PWSTR   p;
        PWSTR   *r;
        ULONG   NumberOfInfFiles;
        POEM_INF_FILE q;
        ULONG   i;

        SpAddLineToSection(WinntSifHandle, SIF_DATA, OemDriversKeyName, &OemInfSectionName, 1);

        wcscpy( TemporaryBuffer, L"%SystemRoot%" );
        SpConcatenatePaths( TemporaryBuffer, OemDirName );
        p = SpDupStringW( TemporaryBuffer );
        SpAddLineToSection(WinntSifHandle, OemInfSectionName, OemDriverPathName, &p, 1);
        SpMemFree( p );
        SpAddLineToSection(WinntSifHandle, OemInfSectionName, OemDriverFlags, &szOne, 1);

        for( q = OemInfFileList, NumberOfInfFiles = 0;
             q != NULL;
             q = q->Next, NumberOfInfFiles++ );
        r = SpMemAlloc( NumberOfInfFiles * sizeof( PWSTR ) );
        for( q = OemInfFileList, i = 0;
             q != NULL;
             r[i] = q->InfName, q = q->Next, i++ );
        SpAddLineToSection(WinntSifHandle,OemInfSectionName, OemInfName, r, NumberOfInfFiles);
        SpMemFree( r );
    }

    //
    // Before we write the answer to this, we need to know if we successfully
    // have written Winnt.sif into system32\$winnt$.inf
    //
    wcscpy(TemporaryBuffer, FullTargetPath);
    SpConcatenatePaths(TemporaryBuffer, L"system32");
    SpConcatenatePaths(TemporaryBuffer, SIF_UNATTENDED_INF_FILE);
    TargetFile = SpDupStringW(TemporaryBuffer);
    Status = SpWriteSetupTextFile(WinntSifHandle,TargetFile,NULL,NULL);
    if(NT_SUCCESS(Status)) {

        Status = SpOpenSetValueAndClose(
                    hKeySystemHive,
                   SETUP_KEY_NAME,
                   L"CmdLine",
                   STRING_VALUE(CmdLine)
                   );
    }

    //
    // Free up whatever memory we have allocated
    //
    SpMemFree(TargetFile);
    SpMemFree(CmdLine);
    SpMemFree(SourcePathBuffer);

    if(!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Set the SetupType value to the right value SETUPTYPE_FULL in the
    // case of initial install and SETUPTYPE_UPGRADE in the case of upgrade.
    //

    SetupType = (NTUpgrade == UpgradeFull) ? SETUPTYPE_UPGRADE : SETUPTYPE_FULL;
    Status = SpOpenSetValueAndClose(
                hKeySystemHive,
                SETUP_KEY_NAME,
                L"SetupType",
                ULONG_VALUE(SetupType)
                );
    if(!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Set the SystemSetupInProgress value.  Don't rely on the default hives
    // having this set
    //

    SetupInProgress = 1;
    Status = SpOpenSetValueAndClose(
                hKeySystemHive,
                SETUP_KEY_NAME,
                L"SystemSetupInProgress",
                ULONG_VALUE(SetupInProgress)
                );

    return(Status);
}


NTSTATUS
SpDriverLoadList(
    IN PVOID  SifHandle,
    IN PWSTR  SystemRoot,
    IN HANDLE hKeySystemHive,
    IN HANDLE hKeyControlSet
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE hKeyControlSetServices;
    PHARDWARE_COMPONENT ScsiHwComponent;
    // PHARDWARE_COMPONENT TempExtender;
    ULONG u;
    ULONG i;
    PHARDWARE_COMPONENT TempHw;
    PHARDWARE_COMPONENT DeviceLists[] = {
                                        BootBusExtenders,
                                        BusExtenders,
                                        InputDevicesSupport
                                        };
    PWSTR   SectionNames[] = {
                             SIF_BOOTBUSEXTENDERS,
                             SIF_BUSEXTENDERS,
                             SIF_INPUTDEVICESSUPPORT
                             };

    PWSTR   ServiceGroupNames[] = {
                                  L"Boot Bus Extender",
                                  L"System Bus Extender",
                                  NULL
                                  };
    ULONG   StartValues[] = {
                            SERVICE_BOOT_START,
                            SERVICE_BOOT_START,
                            SERVICE_DEMAND_START
                            };

    //
    // Open controlset\services.
    //
    INIT_OBJA(&Obja,&UnicodeString,L"services");
    Obja.RootDirectory = hKeyControlSet;

    Status = ZwCreateKey(
                &hKeyControlSetServices,
                KEY_ALL_ACCESS,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to open services key (%lx)\n",Status));
        return(Status);
    }

    //
    // For each non-third-party miniport driver that loaded,
    // go create a services entry for it.
    //
    if( !PreInstall ||
        ( PreinstallScsiHardware == NULL ) ) {
        ScsiHwComponent = ScsiHardware;
    } else {
        ScsiHwComponent = PreinstallScsiHardware;
    }
    for( ; ScsiHwComponent; ScsiHwComponent=ScsiHwComponent->Next) {

        if(!ScsiHwComponent->ThirdPartyOptionSelected) {

            //
            // For scsi, the shortname (idstring) is used as
            // the name of the service node key in the registry --
            // we don't look up the service entry in the [SCSI] section
            // of the setup info file.
            //
            Status = SpCreateServiceEntryIndirect(
                    hKeyControlSetServices,
                    NULL,
                    NULL,
                    ScsiHwComponent->IdString,
                    SERVICE_KERNEL_DRIVER,
                    SERVICE_BOOT_START,
                    L"SCSI miniport",
                    SERVICE_ERROR_NORMAL,
                    NULL,
                    NULL
                    );

            if(!NT_SUCCESS(Status)) {
                goto spdrvlist1;
            }

        }
    }

    //
    // If there are any atdisks out there, enable atdisk.
    // We have to enable AtDisk if Pcmcia was loaded, even
    // if atdisk doesn't exist. This will allow the user to
    // insert a pcmcia atdisk device, and have it work when
    // they boot.  In this case, however, we turn off error
    // logging, so that they won't get an annoying popup
    // when there is no atdisk device in the card slot.
    //
    // Note that atdisk.sys is always copied to the system.
    //

    Status = SpCreateServiceEntryIndirect(
                hKeyControlSetServices,
                NULL,
                NULL,
                ATDISK_NAME,
                SERVICE_KERNEL_DRIVER,
                ( AtDisksExist )? SERVICE_BOOT_START : SERVICE_DISABLED,
                PRIMARY_DISK_GROUP,
                ( AtDisksExist && !AtapiLoaded )? SERVICE_ERROR_NORMAL : SERVICE_ERROR_IGNORE,
                NULL,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        goto spdrvlist1;
    }

    //
    // If there are any abios disks out there, enable abiosdsk.
    //
    if(AbiosDisksExist) {

        Status = SpCreateServiceEntryIndirect(
                    hKeyControlSetServices,
                    NULL,
                    NULL,
                    ABIOSDISK_NAME,
                    SERVICE_KERNEL_DRIVER,
                    SERVICE_BOOT_START,
                    PRIMARY_DISK_GROUP,
                    SERVICE_ERROR_NORMAL,
                    NULL,
                    NULL
                    );

        if(!NT_SUCCESS(Status)) {
            goto spdrvlist1;
        }
    }

    //
    // For each bus enumerator driver that loaded,
    // go create a services entry for it.
    //
    for( i = 0; i < sizeof(DeviceLists) / sizeof(PDETECTED_DEVICE); i++ ) {
        for( TempHw = DeviceLists[i]; TempHw; TempHw=TempHw->Next) {

            //
            // For bus extenders and input devices, the shortname (idstring) is used as
            // the name of the service node key in the registry --
            // we don't look up the service entry in the [BusExtenders] or [InputDevicesSupport] section
            // of the setup info file.
            //
            Status = SpCreateServiceEntryIndirect(
                    hKeyControlSetServices,
                    SifHandle,
                    SectionNames[i],
                    TempHw->IdString,
                    SERVICE_KERNEL_DRIVER,
                    StartValues[i],
                    ServiceGroupNames[i],
                    SERVICE_ERROR_NORMAL,
                    NULL,
                    NULL
                    );

            if(!NT_SUCCESS(Status)) {
                goto spdrvlist1;
            }
        }
    }

    if( NTUpgrade != UpgradeFull ) {
        //
        // Set up video parameters.
        //
        Status = SpWriteVideoParameters(SifHandle,hKeyControlSetServices);

        if(!NT_SUCCESS(Status)) {
            goto spdrvlist1;
        }

        //
        // Enable the relevent keyboard and mouse drivers.  If the class drivers
        // are being replaced by third-party ones, then disable the built-in ones.
        //
        Status = SpConfigureMouseKeyboardDrivers(
                    SifHandle,
                    HwComponentKeyboard,
                    L"kbdclass",
                    hKeyControlSetServices,
                    KEYBOARD_PORT_GROUP
                    );

        if(!NT_SUCCESS(Status)) {
            goto spdrvlist1;
        }

        Status = SpConfigureMouseKeyboardDrivers(
                    SifHandle,
                    HwComponentMouse,
                    L"mouclass",
                    hKeyControlSetServices,
                    POINTER_PORT_GROUP
                    );

        if(!NT_SUCCESS(Status)) {
            goto spdrvlist1;
        }

    }
    Status = SpThirdPartyRegistry(hKeyControlSetServices);

spdrvlist1:

    ZwClose(hKeyControlSetServices);

    return(Status);
}


NTSTATUS
SpSaveSKUStuff(
    IN HANDLE hKeySystemHive
    )
{
    LARGE_INTEGER l;
    NTSTATUS Status;
    ULONG NumberOfProcessors;
    BOOLEAN OldStyleRegisteredProcessorMode;

    //
    // Do not change any of this algorithm without changing
    // SetUpEvaluationSKUStuff() in syssetup.dll (registry.c).
    //
    // Embed the evaluation time and a bool indicating whether
    // this is a server or workstation inside a random large integer.
    //
    // Evaluation time: bits 13-44
    // Product type   : bit     58
    //
    // Bit 10 == 1 : Setup works as it does before the 4.0 restriction logic
    //        == 0 : GUI Setup writes registered processors based on the
    //               contents of bits 5-9
    //
    // Bits 5 - 9  : The maximum number of processors that the system is licensed
    //               to use. The value stored is actually ~(MaxProcessors-1)
    //
    //
    // RestrictCpu is used to build protucts this place a very hard
    // limit on the number of processors
    //
    // - a value of 0 means for NTW, the hard limit is 2, and for NTS,
    //   the hard limit is 4
    //
    // - a value of 1-32 means that the hard limit is the number
    //   specified
    //
    // - a value > 32 means that the hard limit is 32 processors and GUI
    //     setup operates on registered processors as it does today
    //

    l.LowPart = SpComputeSerialNumber();
    l.HighPart = SpComputeSerialNumber();

    l.QuadPart &= 0xfbffe0000000181f;
    l.QuadPart |= ((ULONGLONG)EvaluationTime) << 13;

    if ( RestrictCpu == 0 ) {
        //
        // NTW and NTS will take this path using setupreg.hiv/setupret.hiv
        //
        OldStyleRegisteredProcessorMode = FALSE;
        //
        // new licensing model says that whistler is a 2 cpu system, not 4
        //
        NumberOfProcessors = 2;
        //NumberOfProcessors = (AdvancedServer ? 4 : 2);

    } else if ( RestrictCpu <= 32 ) {
        //
        // NTS/EE/DTC will take this path using a hive targetted at 8/16 CPU.
        //
        OldStyleRegisteredProcessorMode = FALSE;
        NumberOfProcessors = RestrictCpu;
    } else {
        OldStyleRegisteredProcessorMode = TRUE;
        NumberOfProcessors = 32;
    }

    //
    // Now NumberOfProcessors is correct. Convert it to the in registry format
    //

    NumberOfProcessors--;

    NumberOfProcessors = ~NumberOfProcessors;
    NumberOfProcessors = NumberOfProcessors << 5;
    NumberOfProcessors &= 0x000003e0;

    //
    // Store NumberOfProcessors into the registry
    //

    l.LowPart |= NumberOfProcessors;

    //
    // Tell Gui Mode to do old style registered processors
    //

    if ( OldStyleRegisteredProcessorMode ) {
        l.LowPart |= 0x00000400;
    }

    if(AdvancedServer) {
        l.HighPart |= 0x04000000;
    }

    //
    // Save in registry.
    //
    Status = SpOpenSetValueAndClose(
                hKeySystemHive,
                SETUP_KEY_NAME,
                L"SystemPrefix",
                REG_BINARY,
                &l.QuadPart,
                sizeof(ULONGLONG)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set SystemPrefix (%lx)\n",Status));
    }

    return(Status);
}


NTSTATUS
SpSetUlongValueFromSif(
    IN PVOID  SifHandle,
    IN PWSTR  SifSection,
    IN PWSTR  SifKey,
    IN ULONG  SifIndex,
    IN HANDLE hKey,
    IN PWSTR  ValueName
    )
{
    UNICODE_STRING UnicodeString;
    PWSTR ValueString;
    LONG Value;
    NTSTATUS Status;

    //
    // Look up the value.
    //
    ValueString = SpGetSectionKeyIndex(SifHandle,SifSection,SifKey,SifIndex);
    if(!ValueString) {
        SpFatalSifError(SifHandle,SifSection,SifKey,0,SifIndex);
    }

    Value = SpStringToLong(ValueString,NULL,10);

    if(Value == -1) {

        Status = STATUS_SUCCESS;

    } else {

        RtlInitUnicodeString(&UnicodeString,ValueName);

        Status = ZwSetValueKey(hKey,&UnicodeString,0,ULONG_VALUE((ULONG)Value));

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set value %ws (%lx)\n",ValueName,Status));
        }
    }

    return(Status);
}


NTSTATUS
SpConfigureMouseKeyboardDrivers(
    IN PVOID  SifHandle,
    IN ULONG  HwComponent,
    IN PWSTR  ClassServiceName,
    IN HANDLE hKeyControlSetServices,
    IN PWSTR  ServiceGroup
    )
{
    PHARDWARE_COMPONENT hw;
    NTSTATUS Status;
    ULONG val = SERVICE_DISABLED;

    Status = STATUS_SUCCESS;
    if( !PreInstall ||
        ( PreinstallHardwareComponents[HwComponent] == NULL ) ) {
        hw = HardwareComponents[HwComponent];
    } else {
        hw = PreinstallHardwareComponents[HwComponent];
    }
    for(;hw && NT_SUCCESS( Status ); hw=hw->Next) {
        if(hw->ThirdPartyOptionSelected) {

            if(IS_FILETYPE_PRESENT(hw->FileTypeBits,HwFileClass)) {

                if( !PreInstall ) {
                    //
                    // Disable the built-in class driver.
                    //
                    Status = SpOpenSetValueAndClose(
                                hKeyControlSetServices,
                                ClassServiceName,
                                L"Start",
                                ULONG_VALUE(val)
                                );
                }
            }
        } else {

            Status = SpCreateServiceEntryIndirect(
                        hKeyControlSetServices,
                        SifHandle,
                        NonlocalizedComponentNames[HwComponent],
                        hw->IdString,
                        SERVICE_KERNEL_DRIVER,
                        SERVICE_SYSTEM_START,
                        ServiceGroup,
                        SERVICE_ERROR_IGNORE,
                        NULL,
                        NULL
                        );
        }
    }
    return(Status);
}

NTSTATUS
SpWriteVideoParameters(
    IN PVOID  SifHandle,
    IN HANDLE hKeyControlSetServices
    )
{
    NTSTATUS Status;
    PWSTR KeyName;
    HANDLE hKeyDisplayService;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    ULONG x,y,b,v,i;
    PHARDWARE_COMPONENT pHw;

    if( !PreInstall ||
        ( PreinstallHardwareComponents[HwComponentDisplay] == NULL ) ) {
        pHw = HardwareComponents[HwComponentDisplay];
    } else {
        pHw = PreinstallHardwareComponents[HwComponentDisplay];
    }
    Status = STATUS_SUCCESS;
    for(;pHw && NT_SUCCESS(Status);pHw=pHw->Next) {
        //
        // Third party drivers will have values written into the miniport
        // Device0 key at the discretion of the txtsetup.oem author.
        //
        if(pHw->ThirdPartyOptionSelected) {
            continue;
            // return(STATUS_SUCCESS);
        }

        KeyName = SpGetSectionKeyIndex(
                        SifHandle,
                        NonlocalizedComponentNames[HwComponentDisplay],
                        pHw->IdString,
                        INDEX_INFKEYNAME
                        );

        //
        // If no key name is specified for this display then there's nothing to do.
        // The setup display subsystem can tell us that the mode parameters are
        // not relevent.  If so there's nothing to do.
        //
        if(!KeyName || !SpvidGetModeParams(&x,&y,&b,&v,&i)) {
            continue;
            // return(STATUS_SUCCESS);
        }

        //
        // We want to write the parameters for the display mode setup
        // is using into the relevent key in the service list.  This will force
        // the right mode for, say, a fixed-frequency monitor attached to
        // a vxl (which might default to a mode not supported by the monitor).
        //

        INIT_OBJA(&Obja,&UnicodeString,KeyName);
        Obja.RootDirectory = hKeyControlSetServices;

        Status = ZwCreateKey(
                    &hKeyDisplayService,
                    KEY_ALL_ACCESS,
                    &Obja,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    NULL
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to open/create key %ws (%lx)\n",KeyName,Status));
            return(Status);
        }

        //
        // Set the x resolution.
        //
        Status = SpOpenSetValueAndClose(
                    hKeyDisplayService,
                    VIDEO_DEVICE0,
                    L"DefaultSettings.XResolution",
                    ULONG_VALUE(x)
                    );

        if(NT_SUCCESS(Status)) {

            //
            // Set the y resolution.
            //
            Status = SpOpenSetValueAndClose(
                        hKeyDisplayService,
                        VIDEO_DEVICE0,
                        L"DefaultSettings.YResolution",
                        ULONG_VALUE(y)
                        );

            if(NT_SUCCESS(Status)) {

                //
                // Set the bits per pixel.
                //
                Status = SpOpenSetValueAndClose(
                             hKeyDisplayService,
                            VIDEO_DEVICE0,
                            L"DefaultSettings.BitsPerPel",
                            ULONG_VALUE(b)
                            );

                if(NT_SUCCESS(Status)) {

                    //
                    // Set the vertical refresh.
                    //
                    Status = SpOpenSetValueAndClose(
                                hKeyDisplayService,
                                VIDEO_DEVICE0,
                                L"DefaultSettings.VRefresh",
                                ULONG_VALUE(v)
                                );

                    if(NT_SUCCESS(Status)) {

                        //
                        // Set the interlaced flag.
                        //
                        Status = SpOpenSetValueAndClose(
                                    hKeyDisplayService,
                                    VIDEO_DEVICE0,
                                    L"DefaultSettings.Interlaced",
                                    ULONG_VALUE(i)
                                    );
                    }
                }
            }
        }

        ZwClose(hKeyDisplayService);
    }
    return(Status);
}


NTSTATUS
SpConfigureNlsParameters(
    IN PVOID  SifHandle,
    IN HANDLE hKeyDefaultHive,
    IN HANDLE hKeyControlSetControl
    )

/*++

Routine Description:

    This routine configures NLS-related stuff in the registry:

        - a keyboard layout
        - the primary ansi, oem, and mac codepages
        - the language casetable
        - the oem hal font

Arguments:

    SifHandle - supplies handle to open setup information file.

    hKeyDefaultHive - supplies handle to root of default user hive.

    hKeyControlSetControl - supplies handle to the Control subkey of
        the control set being operated on.

Return Value:

    Status value indicating outcome of operation.

--*/

{
    PHARDWARE_COMPONENT_FILE HwFile;
    PWSTR LayoutId;
    NTSTATUS Status;
    HANDLE hKeyNls;
    PWSTR OemHalFont;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    PWSTR IntlLayoutId, LayoutText, LayoutFile, SubKey;

    //
    // We don't allow third-party keyboard layouts.
    //
    ASSERT(!HardwareComponents[HwComponentLayout]->ThirdPartyOptionSelected);

    //
    // Make an entry in the keyboard layout section in the default user hive.
    // This will match an entry in HKLM\CCS\Control\Nls\Keyboard Layouts,
    // which is 'preloaded' with all the possible layouts.
    //
    if( !PreInstall ||
        (PreinstallHardwareComponents[HwComponentLayout] == NULL) ) {
        LayoutId = HardwareComponents[HwComponentLayout]->IdString;
    } else {
        LayoutId = PreinstallHardwareComponents[HwComponentLayout]->IdString;
    }
    Status = SpOpenSetValueAndClose(
                hKeyDefaultHive,
                L"Keyboard Layout\\Preload",
                L"1",
                STRING_VALUE(LayoutId)
                );

    if(!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Add 3 entries into the registry here.  our entries will be:
    // 1. HKLM\System\CurrentControlSet\Control\Keyboard Layouts\LayoutId\Layout File
    // 2. HKLM\System\CurrentControlSet\Control\Keyboard Layouts\LayoutId\Layout Id
    // 3. HKLM\System\CurrentControlSet\Control\Keyboard Layouts\LayoutId\Layout Text
    //

    wcscpy( TemporaryBuffer, L"Keyboard Layouts" );
    SpConcatenatePaths( TemporaryBuffer, LayoutId );
    SubKey = SpDupStringW(TemporaryBuffer);

    //
    // First, do the "Layout File" key.
    //
    LayoutFile = SpGetSectionKeyIndex(
                    SifHandle,              // txtsetup.sif
                    SIF_KEYBOARDLAYOUTFILES,// Files.KeyboardLayout
                    LayoutId,               // IdString
                    0                       // 0
                    );

    if(!LayoutFile) {
        SpFatalSifError(
            SifHandle,
            SIF_KEYBOARDLAYOUTFILES,
            LayoutId,
            0,
            INDEX_DESCRIPTION
            );

        //
        // Should not come here, but lets make prefix happy
        //
        return STATUS_NO_SUCH_FILE;
    }

    Status = SpOpenSetValueAndClose(
                hKeyControlSetControl,      // Handle to ControlSet\Control
                SubKey,                     // \Keyboard Layouts\LayoutId
                L"Layout File",             // ValueName
                REG_SZ,                     // ValueType
                LayoutFile,                 // Value
                (wcslen(LayoutFile)+1)*sizeof(WCHAR) // ValueSize
                );
    if(!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Next, do the "\Keyboard layouts\Layout Text" key.
    //
    LayoutText = SpGetSectionKeyIndex(
                    SifHandle,              // txtsetup.sif
                    SIF_KEYBOARDLAYOUT,     // Keyboard Layout
                    LayoutId,               // IdString
                    0                       // 0
                    );

    if(!LayoutText) {
        SpFatalSifError(
            SifHandle,
            SIF_KEYBOARDLAYOUT,
            LayoutId,
            0,
            INDEX_DESCRIPTION
            );
    }

    Status = SpOpenSetValueAndClose(
                hKeyControlSetControl,      // Handle to ControlSet\Control
                SubKey,                     // \Keyboard Layouts\LayoutId
                L"Layout Text",             // ValueName
                REG_SZ,                     // ValueType
                LayoutText,                 // Value
                (wcslen(LayoutText)+1)*sizeof(WCHAR) // ValueSize
                );
    if(!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Lastly, do the "\Keyboard layouts\Layout Id" key.
    //
    IntlLayoutId = SpGetSectionKeyIndex(
                   SifHandle,               // txtsetup.sif
                   L"KeyboardLayoutId",     // KeyboardLayoutId
                   LayoutId,                // IdString
                   0                        // 0
                   );

    //
    // There may legitimatley not be one...
    //
    if(IntlLayoutId) {
        Status = SpOpenSetValueAndClose(
                    hKeyControlSetControl,      // Handle to ControlSet\Control
                    SubKey,                     // \Keyboard Layouts\LayoutId
                    L"Layout Id",               // ValueName
                    REG_SZ,                     // ValueType
                    IntlLayoutId,               // Value
                    (wcslen(IntlLayoutId)+1)*sizeof(WCHAR) // ValueSize
                    );
        if(!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    SpMemFree(SubKey);

    //
    // Open controlset\Control\Nls.
    //
    INIT_OBJA(&Obja,&UnicodeString,L"Nls");
    Obja.RootDirectory = hKeyControlSetControl;

    Status = ZwCreateKey(
                &hKeyNls,
                KEY_ALL_ACCESS,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open controlset\\Control\\Nls key (%lx)\n",Status));
        return(Status);
    }

    //
    // Create an entry for the ansi codepage.
    //
    Status = SpCreateCodepageEntry(
                SifHandle,
                hKeyNls,
                CODEPAGE_NAME,
                SIF_ANSICODEPAGE,
                L"ACP"
                );

    if(NT_SUCCESS(Status)) {

        //
        // Create entries for the oem codepage(s).
        //
        Status = SpCreateCodepageEntry(
                    SifHandle,
                    hKeyNls,
                    CODEPAGE_NAME,
                    SIF_OEMCODEPAGE,
                    L"OEMCP"
                    );

        if(NT_SUCCESS(Status)) {

            //
            // Create an entry for the mac codepage.
            //
            Status = SpCreateCodepageEntry(
                        SifHandle,
                        hKeyNls,
                        CODEPAGE_NAME,
                        SIF_MACCODEPAGE,
                        L"MACCP"
                        );
        }
    }

    if(NT_SUCCESS(Status)) {

        //
        // Create an entry for the oem hal font.
        //

        OemHalFont = SpGetSectionKeyIndex(SifHandle,SIF_NLS,SIF_OEMHALFONT,0);
        if(!OemHalFont) {
            SpFatalSifError(SifHandle,SIF_NLS,SIF_OEMHALFONT,0,0);
        }

        Status = SpOpenSetValueAndClose(
                    hKeyNls,
                    CODEPAGE_NAME,
                    L"OEMHAL",
                    STRING_VALUE(OemHalFont)
                    );
    }

    //
    // Create an entry for the language case table.
    //
    if(NT_SUCCESS(Status)) {

        Status = SpCreateCodepageEntry(
                    SifHandle,
                    hKeyNls,
                    L"Language",
                    SIF_UNICODECASETABLE,
                    L"Default"
                    );
    }

#ifdef _X86_
    //
    // If necessary, let the win9x upgrade override the code page for GUI mode.
    //
    if (WinUpgradeType == UpgradeWin95) {
        SpWin9xOverrideGuiModeCodePage (hKeyNls);
    }
#endif

    ZwClose(hKeyNls);

    return(Status);
}


NTSTATUS
SpCreateCodepageEntry(
    IN PVOID  SifHandle,
    IN HANDLE hKeyNls,
    IN PWSTR  SubkeyName,
    IN PWSTR  SifNlsSectionKeyName,
    IN PWSTR  EntryName
    )
{
    PWSTR Filename,Identifier;
    NTSTATUS Status;
    ULONG value = 0;
    PWSTR DefaultIdentifier = NULL;

    while(Filename = SpGetSectionKeyIndex(SifHandle,SIF_NLS,SifNlsSectionKeyName,value)) {

        value++;

        Identifier = SpGetSectionKeyIndex(SifHandle,SIF_NLS,SifNlsSectionKeyName,value);
        if(!Identifier) {
            SpFatalSifError(SifHandle,SIF_NLS,SifNlsSectionKeyName,0,value);
        }

        //
        // Remember first identifier.
        //
        if(DefaultIdentifier == NULL) {
            DefaultIdentifier = Identifier;
        }

        value++;

        Status = SpOpenSetValueAndClose(
                    hKeyNls,
                    SubkeyName,
                    Identifier,
                    STRING_VALUE(Filename)
                    );

        if(!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    if(!value) {
        SpFatalSifError(SifHandle,SIF_NLS,SifNlsSectionKeyName,0,0);
    }

    Status = SpOpenSetValueAndClose(
                hKeyNls,
                SubkeyName,
                EntryName,
                STRING_VALUE(DefaultIdentifier)
                );

    return(Status);
}


NTSTATUS
SpConfigureFonts(
    IN PVOID  SifHandle,
    IN HANDLE hKeySoftwareHive
    )

/*++

Routine Description:

    Prepare a list of fonts for use with Windows.

    This routine runs down a list of fonts stored in the setup information
    file and adds each one to the registry, in the area that shadows the
    [Fonts] section of win.ini (HKEY_LOCAL_MACHINE\Software\Microsoft\
    Windows NT\CurrentVersion\Fonts).  If a particular font value entry
    already exists (e.g., if we're doing an upgrade), then it is left alone.

    Eventually it will add the correct resolution (96 or 120 dpi)
    fonts but for now it only deals with the 96 dpi fonts.

Arguments:

    SifHandle - supplies a handle to the open text setup information file.

    hKeySoftwareHive - supplies handle to root of software registry hive.

Return Value:

    Status value indicating outcome of operation.

--*/

{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    HANDLE hKey;
    PWSTR FontList;
    PWSTR FontName;
    PWSTR FontDescription;
    ULONG FontCount,font;
    ULONG KeyValueLength;

    //
    // Open HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Fonts.
    //
    INIT_OBJA(
        &Obja,
        &UnicodeString,
        L"Microsoft\\Windows NT\\CurrentVersion\\Fonts"
        );

    Obja.RootDirectory = hKeySoftwareHive;

    Status = ZwCreateKey(
                &hKey,
                KEY_ALL_ACCESS,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open Fonts key (%lx)\n",Status));
        return(Status);
    }

    //
    // For now always use the 96 dpi fonts.
    //
    FontList = L"FontListE";

    //
    // Process each line in the text setup information file section
    // for the selected font list.
    //
    FontCount = SpCountLinesInSection(SifHandle,FontList);
    if(!FontCount) {
        SpFatalSifError(SifHandle,FontList,NULL,0,0);
    }

    for(font=0; font<FontCount; font++) {

        //
        // Fetch the font description.
        //
        FontDescription = SpGetKeyName(SifHandle,FontList,font);
        if(!FontDescription) {
            SpFatalSifError(SifHandle,FontList,NULL,font,(ULONG)(-1));
        }

        //
        // Check to see if a value entry for this font already exists.  If so,
        // we want to leave it alone.
        //
        RtlInitUnicodeString(&UnicodeString,FontDescription);

        Status = ZwQueryValueKey(hKey,
                                 &UnicodeString,
                                 KeyValueFullInformation,
                                 (PVOID)NULL,
                                 0,
                                 &KeyValueLength
                                );

        if((Status == STATUS_BUFFER_OVERFLOW) || (Status == STATUS_BUFFER_TOO_SMALL)) {
            Status = STATUS_SUCCESS;
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: Font %ws already exists--entry will not be modified\n", FontDescription));
            continue;
        }

        //
        // Fetch the font filename.
        //
        FontName = SpGetSectionLineIndex(SifHandle,FontList,font,0);
        if(!FontName) {
            SpFatalSifError(SifHandle,FontList,NULL,font,0);
        }

        //
        // Set the entry.
        //
        Status = ZwSetValueKey(hKey,&UnicodeString,0,STRING_VALUE(FontName));

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set %ws to %ws (%lx)\n",FontDescription,FontName,Status));
            break;
        }
    }

    ZwClose(hKey);
    return(Status);
}


NTSTATUS
SpStoreHwInfoForSetup(
    IN HANDLE hKeyControlSetControl
    )

/*++

Routine Description:

    This routine stored information in the registry which will be used by
    GUI setup to determine which options for mouse, display, and keyboard
    are currently selected.

    The data is stored in HKEY_LOCAL_MACHINE\System\<control set>\Control\Setup
    in values pointer, video, and keyboard.

Arguments:

    hKeyControlSetControl - supplies handle to open key
        HKEY_LOCAL_MACHINE\System\<Control Set>\Control.

Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS Status;

    ASSERT(HardwareComponents[HwComponentMouse]->IdString);
    ASSERT(HardwareComponents[HwComponentDisplay]->IdString);
    ASSERT(HardwareComponents[HwComponentKeyboard]->IdString);

    Status = SpOpenSetValueAndClose(
                hKeyControlSetControl,
                SETUP_KEY_NAME,
                L"pointer",
                STRING_VALUE(HardwareComponents[HwComponentMouse]->IdString)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set control\\setup\\pointer value (%lx)\n",Status));
        return(Status);
    }

    Status = SpOpenSetValueAndClose(
                hKeyControlSetControl,
                SETUP_KEY_NAME,
                L"video",
                STRING_VALUE(HardwareComponents[HwComponentDisplay]->IdString)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set control\\setup\\video value (%lx)\n",Status));
        return(Status);
    }

    Status = SpOpenSetValueAndClose(
                hKeyControlSetControl,
                SETUP_KEY_NAME,
                L"keyboard",
                STRING_VALUE(HardwareComponents[HwComponentKeyboard]->IdString)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set control\\setup\\keyboard value (%lx)\n",Status));
        return(Status);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
SpOpenSetValueAndClose(
    IN HANDLE hKeyRoot,
    IN PWSTR  SubKeyName,  OPTIONAL
    IN PWSTR  ValueName,
    IN ULONG  ValueType,
    IN PVOID  Value,
    IN ULONG  ValueSize
    )

/*++

Routine Description:

    Open a subkey, set a value in it, and close the subkey.
    The subkey will be created if it does not exist.

Arguments:

    hKeyRoot - supplies handle to an open registry key.

    SubKeyName - supplies path relative to hKeyRoot for key in which
        the value is to be set. If this is not specified, then the value
        is set in hKeyRoot.

    ValueName - supplies the name of the value to be set.

    ValueType - supplies the data type for the value to be set.

    Value - supplies a buffer containing the value data.

    ValueSize - supplies the size of the buffer pointed to by Value.

Return Value:

    Status value indicating outcome of operation.

--*/

{
    OBJECT_ATTRIBUTES Obja;
    HANDLE hSubKey;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;

    //
    // Open or create the subkey in which we want to set the value.
    //
    hSubKey = hKeyRoot;
    if(SubKeyName) {
        //
        //  If SubKeyName is a path to the key, then we need to create
        //  the subkeys in the path, because they may not exist yet.
        //
        PWSTR   p;
        PWSTR   q;
        PWSTR   r;

        //
        //  Since this function may temporarily write to the key path (which may be a constant string,
        //  and the system will bug check if we write to it), we need to duplicate the string so that
        //  we can write to memory that we own.
        //
        p = SpDupStringW( SubKeyName );
        r = p;
        do {
            //
            //  p points to the next subkey to be created.
            //  q points to NUL character at the end of the
            //    name.
            //  r points to the beginning of the duplicated string. It will be used at the end of this
            //    routine, when we no longer need the string, so that we can free the alocated memory.
            //

            q = wcschr(p, (WCHAR)'\\');
            if( q != NULL ) {
                //
                //  Temporarily replace the '\' with the
                //  NUL character
                //
                *q = (WCHAR)'\0';
            }
            INIT_OBJA(&Obja,&UnicodeString,p);
            Obja.RootDirectory = hSubKey;

            Status = ZwCreateKey(
                        &hSubKey,
                        KEY_ALL_ACCESS,
                        &Obja,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        NULL
                        );

            if( q != NULL ) {
                //
                //  Restore the '\' in the subkey name, and make
                //  p and q point to the remainder of the path
                //  that was not processed yet.
                //
                *q = (WCHAR)'\\';
                q++;
                p = q;
            }
            //
            //  The parent of the key that we just attempted to open/create
            //  is no longer needed.
            //
            if( Obja.RootDirectory != hKeyRoot ) {
                ZwClose( Obja.RootDirectory );
            }

            if(!NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open subkey %ws (%lx)\n",SubKeyName,Status));
                return(Status);
            }

        } while( q != NULL );
        SpMemFree( r );
    }

    //
    // Set the value.
    //
    RtlInitUnicodeString(&UnicodeString,ValueName);

    Status = ZwSetValueKey(
                hSubKey,
                &UnicodeString,
                0,
                ValueType,
                Value,
                ValueSize
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set value %ws:%ws (%lx)\n",SubKeyName,ValueName,Status));
    }

    if(SubKeyName) {
        ZwClose(hSubKey);
    }

    return(Status);
}


NTSTATUS
SpGetProductSuiteMask(
    IN HANDLE hKeyControlSetControl,
    OUT PULONG SuiteMask
    )
{
    OBJECT_ATTRIBUTES Obja;
    HANDLE hSubKey;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    UCHAR Buffer[MAX_PRODUCT_SUITE_BYTES];
    ULONG BufferLength;
    ULONG ResultLength = 0;
    PWSTR p;
    PUCHAR Data;
    ULONG DataLength;
    BOOLEAN SuiteFound = FALSE;
    ULONG i,j;


    *SuiteMask = 0;

    //
    // Open or create the subkey in which we want to set the value.
    //

    INIT_OBJA(&Obja,&UnicodeString,PRODUCT_OPTIONS_KEY_NAME);
    Obja.RootDirectory = hKeyControlSetControl;

    Status = ZwCreateKey(
                &hSubKey,
                KEY_ALL_ACCESS,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open subkey (%lx)\n",Status));
        return(Status);
    }

    //
    // query the current value
    //

    INIT_OBJA(&Obja,&UnicodeString,PRODUCT_SUITE_VALUE_NAME);

    BufferLength = sizeof(Buffer);
    RtlZeroMemory( Buffer, BufferLength );

    Status = ZwQueryValueKey(
                hSubKey,
                &UnicodeString,
                KeyValuePartialInformation,
                Buffer,
                BufferLength,
                &ResultLength
                );

    if((!NT_SUCCESS(Status)) && (Status != STATUS_OBJECT_NAME_NOT_FOUND)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to query subkey (%lx)\n",Status));
        return(Status);
    }

    if (ResultLength == BufferLength) {
        //
        // the buffer is too small, this should not happen
        // unless we have too many suites
        //
        ZwClose(hSubKey);
        return STATUS_BUFFER_OVERFLOW;
    }

    if (ResultLength) {

        Data = (PUCHAR)(((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->Data);

        if (((PWSTR)Data)[0] == 0) {
            ((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->DataLength -= sizeof(WCHAR);
        }

        DataLength = ((PKEY_VALUE_PARTIAL_INFORMATION)Buffer)->DataLength;

        p = (PWSTR)Data;
        i = 0;
        while (i<DataLength) {
            for (j=0; j<CountProductSuiteNames; j++) {
                if (ProductSuiteNames[j] != NULL && wcscmp(p,ProductSuiteNames[j]) == 0) {
                    *SuiteMask |= (1 << j);
                }
            }
            if (*p < L'A' || *p > L'z') {
                i += 1;
                p += 1;
            } else {
                i += (wcslen( p ) + 1);
                p += (wcslen( p ) + 1);
            }
        }
    }

    ZwClose(hSubKey);

    return(Status);
}


NTSTATUS
SpSetProductSuite(
    IN HANDLE hKeyControlSetControl,
    IN ULONG SuiteMask
    )
{
    OBJECT_ATTRIBUTES Obja;
    HANDLE hSubKey;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    UCHAR Buffer[MAX_PRODUCT_SUITE_BYTES];
    ULONG BufferLength;
    ULONG ResultLength = 0;
    PWSTR p;
    PUCHAR Data;
    ULONG DataLength;
    BOOLEAN SuiteFound = FALSE;
    ULONG i;
    ULONG tmp;


    //
    // Open or create the subkey in which we want to set the value.
    //

    INIT_OBJA(&Obja,&UnicodeString,PRODUCT_OPTIONS_KEY_NAME);
    Obja.RootDirectory = hKeyControlSetControl;

    Status = ZwCreateKey(
                &hSubKey,
                KEY_ALL_ACCESS,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open subkey (%lx)\n",Status));
        return(Status);
    }

    RtlZeroMemory( Buffer, sizeof(Buffer) );
    tmp = SuiteMask;
    p = (PWSTR)Buffer;
    i = 0;

    while (tmp && i<CountProductSuiteNames) {
        if ((tmp&1) && ProductSuiteNames[i] != NULL) {
            wcscpy(p,ProductSuiteNames[i]);
            p += (wcslen(p) + 1);
        }
        i += 1;
        tmp >>= 1;
    }

    BufferLength = (ULONG)((ULONG_PTR)p - (ULONG_PTR)Buffer) + sizeof(WCHAR);

    //
    // Set the value.
    //

    INIT_OBJA(&Obja,&UnicodeString,PRODUCT_SUITE_VALUE_NAME);

    Status = ZwSetValueKey(
                hSubKey,
                &UnicodeString,
                0,
                REG_MULTI_SZ,
                Buffer,
                BufferLength
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set value (%lx)\n",Status));
    }

    ZwClose(hSubKey);

    return Status;
}


NTSTATUS
SpCreateServiceEntryIndirect(
    IN  HANDLE  hKeyControlSetServices,
    IN  PVOID   SifHandle,                  OPTIONAL
    IN  PWSTR   SifSectionName,             OPTIONAL
    IN  PWSTR   KeyName,
    IN  ULONG   ServiceType,
    IN  ULONG   ServiceStart,
    IN  PWSTR   ServiceGroup,               OPTIONAL
    IN  ULONG   ServiceError,
    IN  PWSTR   FileName,                   OPTIONAL
    OUT PHANDLE SubkeyHandle                OPTIONAL
    )
{
    HANDLE hKeyService;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    PWSTR pwstr;

    //
    // Look in the sif file to get the subkey name within the
    // services list, unless the key name specified by the caller
    // is the actual key name.
    //
    if(SifHandle) {
        pwstr = SpGetSectionKeyIndex(SifHandle,SifSectionName,KeyName,INDEX_INFKEYNAME);
        if(!pwstr) {
            SpFatalSifError(SifHandle,SifSectionName,KeyName,0,INDEX_INFKEYNAME);
        }
        KeyName = pwstr;
    }

    //
    // Create the subkey in the services key.
    //
    INIT_OBJA(&Obja,&UnicodeString,KeyName);
    Obja.RootDirectory = hKeyControlSetServices;

    Status = ZwCreateKey(
                &hKeyService,
                KEY_ALL_ACCESS,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open/create key for %ws service (%lx)\n",KeyName,Status));
        return (Status) ;
    }

    //
    // Set the service type.
    //
    RtlInitUnicodeString(&UnicodeString, REGSTR_VALUE_TYPE);

    Status = ZwSetValueKey(
                hKeyService,
                &UnicodeString,
                0,
                ULONG_VALUE(ServiceType)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set service %ws Type (%lx)\n",KeyName,Status));
        goto spcsie1;
    }

    //
    // Set the service start type.
    //
    RtlInitUnicodeString(&UnicodeString,L"Start");

    Status = ZwSetValueKey(
                hKeyService,
                &UnicodeString,
                0,
                ULONG_VALUE(ServiceStart)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set service %ws Start (%lx)\n",KeyName,Status));
        goto spcsie1;
    }

    if( ServiceGroup != NULL ) {
        //
        // Set the service group name.
        //
        RtlInitUnicodeString(&UnicodeString,L"Group");

        Status = ZwSetValueKey(
                    hKeyService,
                    &UnicodeString,
                    0,
                    STRING_VALUE(ServiceGroup)
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set service %ws Group (%lx)\n",KeyName,Status));
            goto spcsie1;
        }
    }

    //
    // Set the service error type.
    //
    RtlInitUnicodeString(&UnicodeString,L"ErrorControl");

    Status = ZwSetValueKey(
                hKeyService,
                &UnicodeString,
                0,
                ULONG_VALUE(ServiceError)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set service %ws ErrorControl (%lx)\n",KeyName,Status));
        goto spcsie1;
    }

    //
    // If asked to do so, set the service image path.
    //
    if(FileName) {

        pwstr = TemporaryBuffer;
        wcscpy(pwstr,L"system32\\drivers");
        SpConcatenatePaths(pwstr,FileName);

        RtlInitUnicodeString(&UnicodeString,L"ImagePath");

        Status = ZwSetValueKey(hKeyService,&UnicodeString,0,STRING_VALUE(pwstr));

        if(!NT_SUCCESS(Status)) {

            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set service %w image path (%lx)\n",KeyName,Status));
            goto spcsie1;
        }
    } else {
        if(NTUpgrade == UpgradeFull) {
            //
            // Delete imagepath on upgrade. This makes sure we are getting
            // our driver, and from the right place. Fixes Compaq's SSD stuff,
            // for example. Do something similar for PlugPlayServiceType, in case
            // we are renabling a device that the user disabled (in which case
            // the PlugPlayServiceType could cause us to fail to make up a
            // device instance for a legacy device, and cause the driver to fail
            // to load/initialize.
            //
            RtlInitUnicodeString(&UnicodeString,L"ImagePath");
            Status = ZwDeleteValueKey(hKeyService,&UnicodeString);
            if(!NT_SUCCESS(Status)) {
                if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to remove imagepath from service %ws (%lx)\n",KeyName,Status));
                }
                Status = STATUS_SUCCESS;
            }

            RtlInitUnicodeString(&UnicodeString,L"PlugPlayServiceType");
            Status = ZwDeleteValueKey(hKeyService,&UnicodeString);
            if(!NT_SUCCESS(Status)) {
                if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to remove plugplayservicetype from service %ws (%lx)\n",KeyName,Status));
                }
                Status = STATUS_SUCCESS;
            }
        }
    }

    //
    // If the caller doesn't want the handle to the service subkey
    // we just created, close the handle.  If we are returning an
    // error, always close it.
    //
spcsie1:
    if(NT_SUCCESS(Status) && SubkeyHandle) {
        *SubkeyHandle = hKeyService;
    } else {
        ZwClose(hKeyService);
    }

    //
    // Done.
    //
    return(Status);
}


NTSTATUS
SpThirdPartyRegistry(
    IN PVOID hKeyControlSetServices
    )
{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    HANDLE hKeyEventLogSystem;
    HwComponentType Component;
    PHARDWARE_COMPONENT Dev;
    PHARDWARE_COMPONENT_REGISTRY Reg;
    PHARDWARE_COMPONENT_FILE File;
    WCHAR NodeName[9];
    ULONG DriverType;
    ULONG DriverStart;
    ULONG DriverErrorControl;
    PWSTR DriverGroup;
    HANDLE hKeyService;

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\EventLog\System
    //
    INIT_OBJA(&Obja,&UnicodeString,L"EventLog\\System");
    Obja.RootDirectory = hKeyControlSetServices;

    Status = ZwCreateKey(
                &hKeyEventLogSystem,
                KEY_ALL_ACCESS,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpThirdPartyRegistry: couldn't open eventlog\\system (%lx)",Status));
        return(Status);
    }

    for(Component=0; Component<=HwComponentMax; Component++) {

        // no registry stuff applicable to keyboard layout
        if(Component == HwComponentLayout) {
            continue;
        }

        Dev = (Component == HwComponentMax)
            ? ((!PreInstall ||
                (PreinstallScsiHardware==NULL))? ScsiHardware :
                                                 PreinstallScsiHardware)
            : ((!PreInstall ||
                (PreinstallHardwareComponents[Component]==NULL))? HardwareComponents[Component] :
                                                                  PreinstallHardwareComponents[Component]);

        for( ; Dev; Dev = Dev->Next) {

            //
            // If there is no third-party option selected here, then skip
            // the component.
            //

            if(!Dev->ThirdPartyOptionSelected) {
                continue;
            }

            //
            // Iterate through the files for this device.  If a file has
            // a ServiceKeyName, create the key and add values in it
            // as appropriate.
            //

            for(File=Dev->Files; File; File=File->Next) {

                HwFileType filetype = File->FileType;
                PWSTR p;
                ULONG dw;

                //
                // If there is to be no node for this file, skip it.
                //
                if(!File->ConfigName) {
                    continue;
                }

                //
                // Calculate the node name.  This is the name of the driver
                // without the extension.
                //
                wcsncpy(NodeName,File->Filename,8);
                NodeName[8] = 0;
                if(p = wcschr(NodeName,L'.')) {
                    *p = 0;
                }

                //
                // The driver type and error control are always the same.
                //
                DriverType = SERVICE_KERNEL_DRIVER;
                DriverErrorControl = SERVICE_ERROR_NORMAL;

                //
                // The start type depends on the component.
                // For scsi, it's boot loader start.  For others, it's
                // system start.
                //
                DriverStart = (Component == HwComponentMax)
                            ? SERVICE_BOOT_START
                            : SERVICE_SYSTEM_START;

                //
                // The group depends on the component.
                //
                switch(Component) {

                case HwComponentDisplay:
                    DriverGroup = L"Video";
                    break;

                case HwComponentMouse:
                    if(filetype == HwFileClass) {
                        DriverGroup = L"Pointer Class";
                    } else {
                        DriverGroup = L"Pointer Port";
                    }
                    break;

                case HwComponentKeyboard:
                    if(filetype == HwFileClass) {
                        DriverGroup = L"Keyboard Class";
                    } else {
                        DriverGroup = L"Keyboard Port";
                    }
                    break;

                case HwComponentMax:
                    DriverGroup = L"SCSI miniport";
                    break;

                default:
                    DriverGroup = L"Base";
                    break;
                }

                //
                // Attempt to create the service entry.
                //
                Status = SpCreateServiceEntryIndirect(
                            hKeyControlSetServices,
                            NULL,
                            NULL,
                            NodeName,
                            DriverType,
                            DriverStart,
                            DriverGroup,
                            DriverErrorControl,
                            File->Filename,
                            &hKeyService
                            );

                if(!NT_SUCCESS(Status)) {
                    goto sp3reg1;
                }

                //
                // Create a default eventlog configuration.
                //
                Status = SpOpenSetValueAndClose(
                            hKeyEventLogSystem,
                            NodeName,
                            L"EventMessageFile",
                            REG_EXPAND_SZ,
                            DEFAULT_EVENT_LOG,
                            (wcslen(DEFAULT_EVENT_LOG)+1)*sizeof(WCHAR)
                            );

                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpThirdPartyRegistry: unable to set eventlog %ws EventMessageFile",NodeName));
                    ZwClose(hKeyService);
                    goto sp3reg1;
                }

                dw = 7;
                Status = SpOpenSetValueAndClose(
                                hKeyEventLogSystem,
                                NodeName,
                                L"TypesSupported",
                                ULONG_VALUE(dw)
                                );

                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpThirdPartyRegistry: unable to set eventlog %ws TypesSupported",NodeName));
                    ZwClose(hKeyService);
                    goto sp3reg1;
                }


                for(Reg=File->RegistryValueList; Reg; Reg=Reg->Next) {

                    //
                    // If the key name is null or empty, there is no key to create;
                    // use the load list node itself in this case.  Otherwise create
                    // the subkey in the load list node.
                    //

                    Status = SpOpenSetValueAndClose(
                                hKeyService,
                                (Reg->KeyName && *Reg->KeyName) ? Reg->KeyName : NULL,
                                Reg->ValueName,
                                Reg->ValueType,
                                Reg->Buffer,
                                Reg->BufferSize
                                );

                    if(!NT_SUCCESS(Status)) {

                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,
                            "SETUP: SpThirdPartyRegistry: unable to set value %ws (%lx)\n",
                            Reg->ValueName,
                            Status
                            ));

                        ZwClose(hKeyService);
                        goto sp3reg1;
                    }
                }

                ZwClose(hKeyService);
            }
        }
    }

sp3reg1:

    ZwClose(hKeyEventLogSystem);
    return(Status);
}


NTSTATUS
SpDetermineProduct(
    IN  PDISK_REGION      TargetRegion,
    IN  PWSTR             SystemRoot,
    OUT PNT_PRODUCT_TYPE  ProductType,
    OUT ULONG             *MajorVersion,
    OUT ULONG             *MinorVersion,
    OUT ULONG             *BuildNumber,          OPTIONAL
    OUT ULONG             *ProductSuiteMask,
    OUT UPG_PROGRESS_TYPE *UpgradeProgressValue,
    OUT PWSTR             *UniqueIdFromReg,      OPTIONAL
    OUT PWSTR             *Pid,                  OPTIONAL
    OUT PBOOLEAN          pIsEvalVariation       OPTIONAL,
    OUT PLCID             LangId,
    OUT ULONG             *ServicePack            OPTIONAL
    )

{
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      UnicodeString;
    NTSTATUS            Status, TempStatus;
    PWSTR               Hive,HiveKey;
    PUCHAR              buffer;

    #define BUFFERSIZE (sizeof(KEY_VALUE_PARTIAL_INFORMATION)+256)

    BOOLEAN             HiveLoaded = FALSE;
    PWSTR               PartitionPath = NULL;
    PWSTR               p;
    HANDLE              hKeyRoot = NULL, hKeyCCSet = NULL;
    ULONG               ResultLength;
    ULONG               Number;
    ULONG               i;

    //
    // Allocate buffers.
    //
    Hive = SpMemAlloc(MAX_PATH * sizeof(WCHAR));
    HiveKey = SpMemAlloc(MAX_PATH * sizeof(WCHAR));
    buffer = SpMemAlloc(BUFFERSIZE);

    //
    // Get the name of the target partition.
    //
    SpNtNameFromRegion(
        TargetRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    PartitionPath = SpDupStringW(TemporaryBuffer);

    //
    // Load the system hive
    //

    wcscpy(Hive,PartitionPath);
    SpConcatenatePaths(Hive,SystemRoot);
    SpConcatenatePaths(Hive,L"system32\\config");
    SpConcatenatePaths(Hive,L"system");

    //
    // Form the path of the key into which we will
    // load the hive.  We'll use the convention that
    // a hive will be loaded into \registry\machine\x<hivename>.
    //

    wcscpy(HiveKey,LOCAL_MACHINE_KEY_NAME);
    SpConcatenatePaths(HiveKey,L"xSystem");

    //
    // Attempt to load the key.
    //
    Status = SpLoadUnloadKey(NULL,NULL,HiveKey,Hive);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to load hive %ws to key %ws (%lx)\n",Hive,HiveKey,Status));
        goto spdp_1;
    }
    HiveLoaded = TRUE;


    //
    // Now get a key to the root of the hive we just loaded.
    //

    INIT_OBJA(&Obja,&UnicodeString,HiveKey);
    Status = ZwOpenKey(&hKeyRoot,KEY_ALL_ACCESS,&Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ws (%lx)\n",HiveKey,Status));
        goto spdp_2;
    }

    //
    // Get the unique identifier if needed.
    // This value is not always present.
    //
    if(UniqueIdFromReg) {

        *UniqueIdFromReg = NULL;

        Status = SpGetValueKey(
                     hKeyRoot,
                     SETUP_KEY_NAME,
                     SIF_UNIQUEID,
                     BUFFERSIZE,
                     buffer,
                     &ResultLength
                     );

        if(NT_SUCCESS(Status)) {
            *UniqueIdFromReg = SpDupStringW((PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data));
        }
        // no error if not found.
    }

    //
    // See if this is a failed upgrade
    //
    *UpgradeProgressValue = UpgradeNotInProgress;
    Status = SpGetValueKey(
                 hKeyRoot,
                 SETUP_KEY_NAME,
                 UPGRADE_IN_PROGRESS,
                 BUFFERSIZE,
                 buffer,
                 &ResultLength
                 );

    if(NT_SUCCESS(Status)) {
        DWORD dw;
        if( (dw = *(DWORD *)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data)) < UpgradeMaxValue ) {
            *UpgradeProgressValue = (UPG_PROGRESS_TYPE)dw;
        }
    }

    //
    // Get the key to the current control set
    //
    Status = SpGetCurrentControlSetNumber(hKeyRoot,&Number);
    if(!NT_SUCCESS(Status)) {
        goto spdp_3;
    }

    swprintf((PVOID)buffer,L"ControlSet%03d",Number);
    INIT_OBJA(&Obja,&UnicodeString,(PVOID)buffer);
    Obja.RootDirectory = hKeyRoot;

    Status = ZwOpenKey(&hKeyCCSet,KEY_READ,&Obja);
    if(!NT_SUCCESS(Status)) {
        goto spdp_3;
    }

    //
    // Get the Product type field
    //

    Status = SpGetValueKey(
                 hKeyCCSet,
                 L"Control\\ProductOptions",
                 L"ProductType",
                 BUFFERSIZE,
                 buffer,
                 &ResultLength
                 );

    if(!NT_SUCCESS(Status)) {
        goto spdp_3;
    }

    if( _wcsicmp( (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data), L"WinNT" ) == 0 ) {
        *ProductType = NtProductWinNt;
    } else if( _wcsicmp( (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data), L"LanmanNt" ) == 0 ) {
        *ProductType = NtProductLanManNt;
    } else if( _wcsicmp( (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data), L"ServerNt" ) == 0 ) {
        *ProductType = NtProductServer;
    } else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL,  "SETUP: Error, unknown ProductType = %ls.  Assuming WinNt \n",
                  (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data) ));
        *ProductType = NtProductWinNt;
    }

    *ProductSuiteMask = 0;
    Status = SpGetValueKey(
                 hKeyCCSet,
                 L"Control\\ProductOptions",
                 L"ProductSuite",
                 BUFFERSIZE,
                 buffer,
                 &ResultLength
                 );

    if(NT_SUCCESS(Status)) {

        p = (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data);
        while (p && *p) {
            for (i = 0; i < CountProductSuiteNames; i++) {
                if (ProductSuiteNames[i] != NULL && _wcsicmp( p, ProductSuiteNames[i]) == 0) {
                    *ProductSuiteMask |= (1 << i);
                    break;
                }
            }

            p = p + wcslen(p) + 1;

        }
    } else {
        Status = SpGetValueKey(
                     hKeyCCSet,
                     L"Control\\Citrix",
                     L"OemId",
                     BUFFERSIZE,
                     buffer,
                     &ResultLength
                     );

        if (NT_SUCCESS(Status)) {
            PWSTR wbuff = (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data);
            if (*wbuff != L'\0') {
                *ProductSuiteMask |= VER_SUITE_TERMINAL;
            }
        }

    }

    if (LangId) {
      PWSTR EndChar;
      PWSTR Value = 0;

      //
      // Get the install language ID
      //
      Status = SpGetValueKey(
                   hKeyCCSet,
                   L"Control\\Nls\\Language",
                   L"InstallLanguage",
                   BUFFERSIZE,
                   buffer,
                   &ResultLength
                   );

      if (!NT_SUCCESS(Status) || !buffer || !ResultLength) {
        //
        // Try to get default Language ID if we can't get install
        // language ID
        //
        Status = SpGetValueKey(
                     hKeyCCSet,
                     L"Control\\Nls\\Language",
                     L"Default",
                     BUFFERSIZE,
                     buffer,
                     &ResultLength
                     );

        if (!NT_SUCCESS(Status) || !buffer || !ResultLength)
          goto spdp_3;
      }

      Value = (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data);
      *LangId = (LANGID)SpStringToLong(Value, &EndChar, 16); // hex base
    }

    //
    // Get the Eval variation flag
    //
    if (pIsEvalVariation) {
        *pIsEvalVariation = FALSE;

        Status = SpGetValueKey(
                    hKeyCCSet,
                    L"Control\\Session Manager\\Executive",
                    L"PriorityQuantumMatrix",
                    BUFFERSIZE,
                    buffer,
                    &ResultLength);

        if (NT_SUCCESS(Status)) {
            PKEY_VALUE_PARTIAL_INFORMATION  pValInfo =
                            (PKEY_VALUE_PARTIAL_INFORMATION)buffer;

            PBYTE   pData = (PBYTE)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data);

            //
            // Note : PriorityQantumMatix Value is made up of 3 ULONGS
            // Low Install Date&Time ULONG, Eval Duration (ULONG),
            // High Install Date&Time ULONG
            //
            if (pData && pValInfo && (pValInfo->Type == REG_BINARY) &&
                            (ResultLength >= 8) && *(((ULONG *)pData) + 1)) {
                *pIsEvalVariation = TRUE;
            }
        } else {
            // discard the error (NT 3.51 and below version does not have this key)
            Status = STATUS_SUCCESS;
        }
    }

    //
    // Get the ServicePack Number
    //
    if(ServicePack) {
        *ServicePack = 0;
        Status = SpGetValueKey(
                 hKeyCCSet,
                 L"Control\\Windows",
                 L"CSDVersion",
                 BUFFERSIZE,
                 buffer,
                 &ResultLength
                 );
        if (NT_SUCCESS(Status)) {
            PKEY_VALUE_PARTIAL_INFORMATION  pValInfo =
                            (PKEY_VALUE_PARTIAL_INFORMATION)buffer;

            if (pValInfo && pValInfo->Data && (pValInfo->Type == REG_DWORD)) {
                *ServicePack = ((*(PULONG)(pValInfo->Data)) >> 8 & (0xff)) * 100
                               + ((*(PULONG)(pValInfo->Data)) & 0xff);
            }
        } else {
            // discard the error
            Status = STATUS_SUCCESS;
        }
    }

    //
    // Close the hive key
    //

    ZwClose( hKeyCCSet );
    ZwClose( hKeyRoot );
    hKeyRoot = NULL;
    hKeyCCSet = NULL;

    //
    // Unload the system hive
    //

    TempStatus  = SpLoadUnloadKey(NULL,NULL,HiveKey,NULL);
    if(!NT_SUCCESS(TempStatus)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: unable to unload key %ws (%lx)\n",HiveKey,TempStatus));
    }
    HiveLoaded = FALSE;

    //
    // Load the software hive
    //

    wcscpy(Hive,PartitionPath);
    SpConcatenatePaths(Hive,SystemRoot);
    SpConcatenatePaths(Hive,L"system32\\config");
    SpConcatenatePaths(Hive,L"software");

    //
    // Form the path of the key into which we will
    // load the hive.  We'll use the convention that
    // a hive will be loaded into \registry\machine\x<hivename>.
    //

    wcscpy(HiveKey,LOCAL_MACHINE_KEY_NAME);
    SpConcatenatePaths(HiveKey,L"x");
    wcscat(HiveKey,L"software");

    //
    // Attempt to load the key.
    //
    Status = SpLoadUnloadKey(NULL,NULL,HiveKey,Hive);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to load hive %ws to key %ws (%lx)\n",Hive,HiveKey,Status));
        goto spdp_1;
    }
    HiveLoaded = TRUE;

    //
    // Now get a key to the root of the hive we just loaded.
    //

    INIT_OBJA(&Obja,&UnicodeString,HiveKey);
    Status = ZwOpenKey(&hKeyRoot,KEY_ALL_ACCESS,&Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ws (%lx)\n",HiveKey,Status));
        goto spdp_2;
    }

    //
    // Query the version of the NT
    //

    Status = SpGetValueKey(
                 hKeyRoot,
                 L"Microsoft\\Windows NT\\CurrentVersion",
                 L"CurrentVersion",
                 BUFFERSIZE,
                 buffer,
                 &ResultLength
                 );

    //
    // Convert the version into a dword
    //

    {
        WCHAR wcsMajorVersion[] = L"0";
        WCHAR wcsMinorVersion[] = L"00";
        PWSTR Version = (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data);
        if( Version[0] && Version[1] && Version[2] ) {
            wcsMajorVersion[0] = Version[0];
            wcsMinorVersion[0] = Version[2];
            if( Version[3] ) {
                wcsMinorVersion[1] = Version[3];
            }
        }
        *MajorVersion = (ULONG)SpStringToLong( wcsMajorVersion, NULL, 10 );
        *MinorVersion = (ULONG)SpStringToLong( wcsMinorVersion, NULL, 10 );
    }

        //
        // EVAL variations on NT 5.0 are detected using MPC code
        // (This is to allow pre 5.0 RTM builds with timebomb to
        // upgrade properly
        //
    if (pIsEvalVariation && (*MajorVersion >= 5))
        *pIsEvalVariation = FALSE;

    //
    // Get build number
    //
    if(BuildNumber) {
        Status = SpGetValueKey(
                     hKeyRoot,
                     L"Microsoft\\Windows NT\\CurrentVersion",
                     L"CurrentBuildNumber",
                     BUFFERSIZE,
                     buffer,
                     &ResultLength
                     );

        *BuildNumber = NT_SUCCESS(Status)
                     ? (ULONG)SpStringToLong((PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data),NULL,10)
                     : 0;
    }



    //
    // Query the PID, if requested
    //

    if( Pid != NULL ) {
        TempStatus = SpGetValueKey(
                         hKeyRoot,
                         L"Microsoft\\Windows NT\\CurrentVersion",
                         L"ProductId",
                         BUFFERSIZE,
                         buffer,
                         &ResultLength
                         );

        if(!NT_SUCCESS(TempStatus)) {
            //
            //  If unable to read PID, assume empty string
            //
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to query PID from hive %ws. Status = (%lx)\n",Hive,TempStatus));
            *Pid = SpDupStringW( L"" );
        } else {
            *Pid = SpDupStringW( (PWSTR)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data) );
        }
    }

    //
    // Let the following do the cleaning up

spdp_3:

    if( hKeyCCSet ) {
        ZwClose( hKeyCCSet );
    }

    if( hKeyRoot ) {
        ZwClose(hKeyRoot);
    }


spdp_2:


    //
    // Unload the currently loaded hive.
    //

    if( HiveLoaded ) {
        TempStatus = SpLoadUnloadKey(NULL,NULL,HiveKey,NULL);
        if(!NT_SUCCESS(TempStatus)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: unable to unload key %ws (%lx)\n",HiveKey,TempStatus));
        }
    }

spdp_1:
    SpMemFree(PartitionPath);

    SpMemFree(Hive);
    SpMemFree(HiveKey);
    SpMemFree(buffer);

    return( Status );
#undef BUFFERSIZE
}

NTSTATUS
SpSetUpgradeStatus(
    IN  PDISK_REGION      TargetRegion,
    IN  PWSTR             SystemRoot,
    IN  UPG_PROGRESS_TYPE UpgradeProgressValue
    )
{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING    UnicodeString;
    NTSTATUS          Status, TempStatus;

    WCHAR   Hive[MAX_PATH], HiveKey[MAX_PATH];
    BOOLEAN HiveLoaded = FALSE;
    PWSTR   PartitionPath = NULL;
    HANDLE  hKeySystemHive;
    DWORD   dw;

    //
    // Get the name of the target patition.
    //
    SpNtNameFromRegion(
        TargetRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    PartitionPath = SpDupStringW(TemporaryBuffer);

    //
    // Load the system hive
    //

    wcscpy(Hive,PartitionPath);
    SpConcatenatePaths(Hive,SystemRoot);
    SpConcatenatePaths(Hive,L"system32\\config");
    SpConcatenatePaths(Hive,L"system");

    //
    // Form the path of the key into which we will
    // load the hive.  We'll use the convention that
    // a hive will be loaded into \registry\machine\x<hivename>.
    //

    wcscpy(HiveKey,LOCAL_MACHINE_KEY_NAME);
    SpConcatenatePaths(HiveKey,L"x");
    wcscat(HiveKey,L"system");

    //
    // Attempt to load the key.
    //
    Status = SpLoadUnloadKey(NULL,NULL,HiveKey,Hive);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to load hive %ws to key %ws (%lx)\n",Hive,HiveKey,Status));
        goto spus_1;
    }
    HiveLoaded = TRUE;


    //
    // Now get a key to the root of the hive we just loaded.
    //

    INIT_OBJA(&Obja,&UnicodeString,HiveKey);
    Status = ZwOpenKey(&hKeySystemHive,KEY_ALL_ACCESS,&Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ws (%lx)\n",HiveKey,Status));
        goto spus_2;
    }

    //
    // Set the upgrade status under the setup key.
    //

    dw = UpgradeProgressValue;
    Status = SpOpenSetValueAndClose(
                hKeySystemHive,
                SETUP_KEY_NAME,
                UPGRADE_IN_PROGRESS,
                ULONG_VALUE(dw)
                );

    //
    // Flush the key. Ignore the error
    //
    TempStatus = ZwFlushKey(hKeySystemHive);
    if(!NT_SUCCESS(TempStatus)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwFlushKey %ws failed (%lx)\n",HiveKey,Status));
    }


    //
    // Close the hive key
    //
    ZwClose( hKeySystemHive );
    hKeySystemHive = NULL;

    //
    // Unload the system hive
    //

    TempStatus  = SpLoadUnloadKey(NULL,NULL,HiveKey,NULL);
    if(!NT_SUCCESS(TempStatus)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: unable to unload key %ws (%lx)\n",HiveKey,TempStatus));
    }
    HiveLoaded = FALSE;

spus_2:

    //
    // Unload the currently loaded hive.
    //

    if( HiveLoaded ) {
        TempStatus = SpLoadUnloadKey(NULL,NULL,HiveKey,NULL);
        if(!NT_SUCCESS(TempStatus)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: unable to unload key %ws (%lx)\n",HiveKey,TempStatus));
        }
    }

spus_1:
    SpMemFree(PartitionPath);
    return( Status );

}


NTSTATUS
SpGetCurrentControlSetNumber(
    IN  HANDLE SystemHiveRoot,
    OUT PULONG Number
    )

/*++

Routine Description:

    This routine determines the ordinal number of the "current" control set
    as indicated by the values in a SELECT key at the root of a system hive.

Arguments:

    SystemHiveRoot - supplies an open key to the a key which is to be
        considered the root of a system hive.

    Number - If the routine is successful, recieves the ordinal number of
        the "current" control set in that system hive.

Return Value:

    NT Status value indicating outcome.

--*/

{
    NTSTATUS Status;
    UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+256];
    ULONG ResultLength;

    Status = SpGetValueKey(
                 SystemHiveRoot,
                 L"Select",
                 L"Current",
                 sizeof(buffer),
                 buffer,
                 &ResultLength
                 );

    if(NT_SUCCESS(Status)) {
        *Number = *(DWORD *)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data);
    }

    return(Status);
}


NTSTATUS
SpCreateControlSetSymbolicLink(
    IN  HANDLE  SystemHiveRoot,
    OUT HANDLE *CurrentControlSetRoot
    )

/*++

Routine Description:

    This routine creates a CurrentControlSet symbolic link, whose target
    is the appropriate ControlSetxxx key within a given system hive.

    The symbolic link is created volatile.

Arguments:

    SystemHiveRoot - supplies a handle to a key that is to be considered
        the root key of a system hive.

    CurrentControlSetRoot - if this routine is successful then this receives
        a handle to the open root key of the current control set, with
        KEY_ALL_ACCESS.

Return Value:

    NT status code indicating outcome.

--*/

{
    NTSTATUS Status;
    ULONG Number;
    HANDLE KeyHandle;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    WCHAR name[50];

    //
    // First we need to figure out which control set is the "current" one.
    // In the upgrade case we need to get it from looking at the existing
    // hive; in the fresh install case it's always 1.
    //
    if(NTUpgrade == UpgradeFull) {
        Status = SpGetCurrentControlSetNumber(SystemHiveRoot,&Number);
        if(!NT_SUCCESS(Status)) {
            return(Status);
        }
    } else {
        Number = 1;

        //
        // HACK: In the fresh install case we need to make sure that there is
        // a ControlSet001 value to link to! There won't be one when we get here
        // because we didn't run any infs yet.
        //
        RtlInitUnicodeString(&UnicodeString,L"ControlSet001");

        InitializeObjectAttributes(
            &Obja,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            SystemHiveRoot,
            NULL
            );

        Status = ZwCreateKey(
                    &KeyHandle,
                    KEY_QUERY_VALUE,
                    &Obja,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    NULL
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: can't create ControlSet001 key (%lx)\n",Status));
            return(Status);
        }

        ZwClose(KeyHandle);
    }

    //
    // Create CurrentControlSet for create-link access.
    //
    RtlInitUnicodeString(&UnicodeString,L"CurrentControlSet");

    InitializeObjectAttributes(
        &Obja,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        SystemHiveRoot,
        NULL
        );

    Status = ZwCreateKey(
                &KeyHandle,
                KEY_CREATE_LINK,
                &Obja,
                0,
                NULL,
                REG_OPTION_VOLATILE | REG_OPTION_CREATE_LINK,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: can't create CurrentControlSet symbolic key (%lx)\n",Status));
        return(Status);
    }

    //
    // Now set the value value in there. If the swprintf changes, make sure
    // the name buffer is large enough!
    //
    swprintf(name,L"\\Registry\\Machine\\xSystem\\ControlSet%03d",Number);
    RtlInitUnicodeString(&UnicodeString,L"SymbolicLinkValue");

    Status = ZwSetValueKey(KeyHandle,&UnicodeString,0,REG_LINK,name,wcslen(name)*sizeof(WCHAR));
    ZwClose(KeyHandle);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to set SymbolicLinkValue for CurrentControlSet to %ws (%lx)\n",name,Status));
    } else {
        //
        // Finally, open a handle to the key.
        //
        INIT_OBJA(&Obja,&UnicodeString,name);
        Status = ZwOpenKey(CurrentControlSetRoot,KEY_ALL_ACCESS,&Obja);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open control set root %ws (%lx)\n",name,Status));
        }
    }

    return(Status);
}


NTSTATUS
SpAppendStringToMultiSz(
    IN HANDLE hKey,
    IN PWSTR  Subkey,
    IN PWSTR  ValueName,
    IN PWSTR  StringToAdd
    )
{
    NTSTATUS Status;
    ULONG Length;
    PUCHAR Data;

    Status = SpGetValueKey(
                hKey,
                Subkey,
                ValueName,
                sizeof(TemporaryBuffer),
                (PCHAR)TemporaryBuffer,
                &Length
                );

    if(!NT_SUCCESS(Status)) {
        return(Status);
    }

    Data   = ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data;
    Length = ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->DataLength;

    //
    // Stick on end. For a multi_sz there has to be at least
    // the terminating nul, but just to be safe we'll be robust.
    //
    ASSERT(Length);
    if(!Length) {
        *(PWCHAR)Data = 0;
        Length = sizeof(WCHAR);
    }

    //
    // Append new string to end and add new terminating 0.
    //
    wcscpy((PWSTR)(Data+Length-sizeof(WCHAR)),StringToAdd);
    Length += (wcslen(StringToAdd)+1)*sizeof(WCHAR);
    *(PWCHAR)(Data+Length-sizeof(WCHAR)) = 0;

    //
    // Write back out to registry.
    //
    Status = SpOpenSetValueAndClose(
                hKey,
                Subkey,
                ValueName,
                REG_MULTI_SZ,
                Data,
                Length
                );

    return(Status);
}

NTSTATUS
SpRemoveStringFromMultiSz(
    IN HANDLE KeyHandle,
    IN PWSTR  SubKey OPTIONAL,
    IN PWSTR  ValueName,
    IN PWSTR  StringToRemove
    )
/*++

Routine Description:

    Removes the specified string from the given multi_sz value.

Arguments:

    KeyHandle - The handle to the key which contains the value or
        the SubKey.

    SubKey - The subkey name which contains the value.

    ValueName - The value name which is under the SubKey or the 
        Key reachable by KeyHandle.

    StringToRemove - The string that needs to be removed from
        from the multi_sz strings.
        
Return Value:

    Appropriate NT status error code.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    //
    // Validate parameters
    //
    if (KeyHandle && ValueName && StringToRemove) {
        HANDLE NewKeyHandle = KeyHandle;
        HANDLE SubKeyHandle = NULL;

        Status = STATUS_SUCCESS;

        //
        // Open the subkey if needed
        //
        if (SubKey) {            
            UNICODE_STRING SubKeyName;
            OBJECT_ATTRIBUTES ObjAttrs;
            
            INIT_OBJA(&ObjAttrs, &SubKeyName, SubKey);
            ObjAttrs.RootDirectory = KeyHandle;

            Status = ZwOpenKey(&SubKeyHandle,
                        KEY_ALL_ACCESS,
                        &ObjAttrs);

            if (NT_SUCCESS(Status)) {
                NewKeyHandle = SubKeyHandle;
            }
        }

        if (NT_SUCCESS(Status)) {                
            ULONG ResultLength = 0;
            PWSTR Buffer = NULL;
            ULONG BufferLength = 0;
            UNICODE_STRING ValueNameStr;

            RtlInitUnicodeString(&ValueNameStr, ValueName);
            
            Status = ZwQueryValueKey(NewKeyHandle,
                        &ValueNameStr,
                        KeyValueFullInformation,
                        NULL,
                        0,
                        &ResultLength);

            //
            // Is there something to process ?
            //
            if (ResultLength && 
                (Status == STATUS_BUFFER_OVERFLOW) || (Status == STATUS_BUFFER_TOO_SMALL)) {
                //
                // Allocate adequate buffer 
                //
                BufferLength = ResultLength + (2 * sizeof(WCHAR));
                Buffer = (PWSTR)SpMemAlloc(BufferLength);                

                if (Buffer) {
                    PKEY_VALUE_FULL_INFORMATION ValueInfo;
                    
                    //
                    // Get the current value
                    //
                    ValueInfo = (PKEY_VALUE_FULL_INFORMATION)Buffer;

                    Status = ZwQueryValueKey(NewKeyHandle,
                                &ValueNameStr,
                                KeyValueFullInformation,
                                ValueInfo,
                                BufferLength,
                                &ResultLength);

                    if (NT_SUCCESS(Status)) {
                        //
                        // Verify that its REG_MULTI_SZ or REG_SZ type
                        // NOTE : We allow REG_SZ also since in some W2K installations
                        // the string type is REG_SZ for class upperfilters & lowerfilters
                        //
                        if ((ValueInfo->Type == REG_MULTI_SZ) ||
                             (ValueInfo->Type == REG_SZ)){
                            PWSTR CurrString = (PWSTR)(((PUCHAR)ValueInfo + ValueInfo->DataOffset));
                            BOOLEAN Found = FALSE;
                            ULONG BytesToProcess = ValueInfo->DataLength;
                            ULONG BytesProcessed;
                            ULONG Length;

                            //
                            // null terminate the string (we allocated enough buffer space above)
                            //
                            CurrString[ValueInfo->DataLength/sizeof(WCHAR)] = UNICODE_NULL;
                            CurrString[(ValueInfo->DataLength/sizeof(WCHAR))+1] = UNICODE_NULL;

                            //
                            // Search for an occurrence of the string to replace
                            //
                            for (BytesProcessed = 0; 
                                (!Found && (BytesProcessed < BytesToProcess));
                                CurrString += (Length + 1), BytesProcessed += ((Length + 1) * sizeof(WCHAR))) 
                            {

                                Length = wcslen(CurrString);
                                
                                if (Length && !_wcsicmp(CurrString, StringToRemove)) {
                                    Found = TRUE;
                                }
                            } 

                            if (Found) {
                                //
                                // We found an occurrence -- allocate new buffer to selectively
                                // copy the required information from the old string
                                //
                                PWSTR   NewString = (PWSTR)(SpMemAlloc(ValueInfo->DataLength));

                                if (NewString) {
                                    PWSTR CurrDestString = NewString;
                                    
                                    RtlZeroMemory(NewString, ValueInfo->DataLength);
                                    CurrString = (PWSTR)(((PUCHAR)ValueInfo + ValueInfo->DataOffset));
                                    CurrString[ValueInfo->DataLength/sizeof(WCHAR)] = UNICODE_NULL;
                                    CurrString[(ValueInfo->DataLength/sizeof(WCHAR))+1] = UNICODE_NULL;
                                    
                                    //
                                    // Copy all the strings except the one's to skip
                                    //
                                    for (BytesProcessed = 0; 
                                        (BytesProcessed < BytesToProcess);
                                        CurrString += (Length + 1), BytesProcessed += ((Length + 1) * sizeof(WCHAR)))
                                    {                                            
                                        Length = wcslen(CurrString);                                    
                                        
                                        //                                            
                                        // copy the unmatched non-empty source string to destination
                                        //
                                        if (Length && (_wcsicmp(CurrString, StringToRemove))) {
                                            wcscpy(CurrDestString, CurrString);
                                            CurrDestString += (Length + 1);
                                        }                                        
                                    } 

                                    //
                                    // Set the string back if its not empty
                                    //
                                    if (CurrDestString != NewString) {
                                        *CurrDestString++ = UNICODE_NULL;

                                        //
                                        // Set the new value back
                                        //
                                        Status = ZwSetValueKey(NewKeyHandle,
                                                    &ValueNameStr,
                                                    0,
                                                    REG_MULTI_SZ,
                                                    NewString,
                                                    ((CurrDestString - NewString) * sizeof(WCHAR)));
                                    } else {
                                        //
                                        // Remove the empty value
                                        //
                                        Status = ZwDeleteValueKey(NewKeyHandle,
                                                    &ValueNameStr);
                                    }                                        

                                    //
                                    // done with the buffer
                                    //
                                    SpMemFree(NewString);
                                } else {
                                    Status = STATUS_NO_MEMORY;
                                }                            
                            } else {
                                Status = STATUS_OBJECT_NAME_NOT_FOUND;
                            }                        
                        } else {
                            Status = STATUS_INVALID_PARAMETER;
                        }                        
                    }                

                    SpMemFree(Buffer);
                } else {
                    Status = STATUS_NO_MEMORY;
                }                    
            }                
        }

        if (SubKeyHandle) {
            ZwClose(SubKeyHandle);
        }
    }

    return Status;
}

NTSTATUS
SpGetValueKey(
    IN  HANDLE     hKeyRoot,
    IN  PWSTR      KeyName,
    IN  PWSTR      ValueName,
    IN  ULONG      BufferLength,
    OUT PUCHAR     Buffer,
    OUT PULONG     ResultLength
    )
{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    HANDLE hKey = NULL;

    //
    // Open the key for read access
    //

    INIT_OBJA(&Obja,&UnicodeString,KeyName);
    Obja.RootDirectory = hKeyRoot;
#if 0
KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "+ [spconfig.c:%lu] KeyName %ws\n", __LINE__, KeyName ));
KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "+ [spconfig.c:%lu] ValueName %ws\n", __LINE__, UnicodeString ));

KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "+ [spconfig.c:%lu] UnicodeString %ws\n", __LINE__, UnicodeString ));
KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, "+ [spconfig.c:%lu] UnicodeString %S\n", __LINE__, UnicodeString ));
#endif

    Status = ZwOpenKey(&hKey,KEY_READ,&Obja);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpGetValueKey: couldn't open key %ws for read access (%lx)\n",KeyName, Status));
    }
    else {
        //
        // Find out the value of the Current value
        //

        RtlInitUnicodeString(&UnicodeString,ValueName);
        Status = ZwQueryValueKey(
                    hKey,
                    &UnicodeString,
                    KeyValuePartialInformation,
                    Buffer,
                    BufferLength,
                    ResultLength
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_WARNING_LEVEL, "SETUP: SpGetValueKey: couldn't query value %ws in key %ws (%lx)\n",ValueName,KeyName,Status));
        }
    }

    if( hKey ) {
        ZwClose( hKey );
    }
    return( Status );

}

NTSTATUS
SpDeleteValueKey(
    IN  HANDLE     hKeyRoot,
    IN  PWSTR      KeyName,
    IN  PWSTR      ValueName
    )
{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    HANDLE hKey = NULL;

    //
    // Open the key for read access
    //

    INIT_OBJA(&Obja,&UnicodeString,KeyName);
    Obja.RootDirectory = hKeyRoot;
    Status = ZwOpenKey(&hKey,KEY_SET_VALUE,&Obja);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpDeleteValueKey: couldn't open key %ws for write access (%lx)\n",KeyName, Status));
    }
    else {
        //
        // Find out the value of the Current value
        //

        RtlInitUnicodeString(&UnicodeString,ValueName);
        Status = ZwDeleteValueKey(
                    hKey,
                    &UnicodeString
                    );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: SpDeleteValueKey: couldn't delete value %ws in key %ws (%lx)\n",ValueName,KeyName,Status));
        }
    }

    if( hKey ) {
        ZwClose( hKey );
    }
    return( Status );

}



BOOLEAN
SpReadSKUStuff(
    VOID
    )

/*++

Routine Description:

    Read SKU differentiation data from the setup hive we are currently
    running on.

    In the unnamed key of our driver node, there is a REG_BINARY that
    tells us whether this is stepup mode, and/or whether this is an
    evaluation unit (gives us the time in minutes).

Arguments:

    None.

Return Value:

    Boolean value indicating outcome.
    If TRUE, StepUpMode and EvaluationTime globals are filled in.
    If FALSE, product may have been tampered with.

--*/

{
    NTSTATUS Status;
    PKEY_VALUE_PARTIAL_INFORMATION ValueInfo;
    PULONG Values;
    ULONG ResultLength;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HKEY Key;



    INIT_OBJA(&Obja,&UnicodeString,LOCAL_MACHINE_KEY_NAME);
    Status = ZwOpenKey(&Key,KEY_READ,&Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to open %ws (Status = %lx)\n",LOCAL_MACHINE_KEY_NAME,Status));
        return(FALSE);
    }

    Status = SpGetValueKey(
                 Key,
                 L"System\\ControlSet001\\Services\\setupdd",
                 L"",
                 sizeof(TemporaryBuffer),
                 (PCHAR)TemporaryBuffer,
                 &ResultLength
                 );

    ZwClose(Key);

    ValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer;

    //
    // This line of code depends on the setup hive setupreg.hiv
    // (see oak\bin\setupreg.ini).
    //
    if(NT_SUCCESS(Status) && (ValueInfo->Type == REG_BINARY) && (ValueInfo->DataLength == 16)) {

        Values = (PULONG)ValueInfo->Data;

        //
        // First DWORD is eval time, second is stepup boolean, third is restric cpu val, fourth is suite
        //
        EvaluationTime = Values[0];
        StepUpMode = (BOOLEAN)Values[1];
        RestrictCpu = Values[2];
        SuiteType = Values[3];

        return(TRUE);
    }

    return(FALSE);
}

VOID
SpSetDirtyShutdownFlag(
    IN  PDISK_REGION    TargetRegion,
    IN  PWSTR           SystemRoot
    )
{
    NTSTATUS            Status;
    PWSTR               HiveRootPath;
    PWSTR               HiveFilePath;
    BOOLEAN             HiveLoaded;
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      UnicodeString;
    HANDLE              HiveRootKey;
    UCHAR               buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(DISK_CONFIG_HEADER)];
    ULONG               ResultLength;
    PDISK_CONFIG_HEADER DiskHeader;

    //
    // Get the name of the target patition.
    //
    SpNtNameFromRegion(
        TargetRegion,
        TemporaryBuffer,
        sizeof(TemporaryBuffer),
        PartitionOrdinalCurrent
        );

    //
    // Form the name of the hive file.
    // This is partitionpath + sysroot + system32\config + the hive name.
    //
    SpConcatenatePaths(TemporaryBuffer, SystemRoot);
    SpConcatenatePaths(TemporaryBuffer,L"system32\\config\\system");
    HiveFilePath = SpDupStringW(TemporaryBuffer);

    //
    // Form the path of the key into which we will
    // load the hive.  We'll use the convention that
    // a hive will be loaded into \registry\machine\x<hivename>.
    //
    wcscpy(TemporaryBuffer,LOCAL_MACHINE_KEY_NAME);
    SpConcatenatePaths(TemporaryBuffer,L"x");
    wcscat(TemporaryBuffer,L"system");
    HiveRootPath = SpDupStringW(TemporaryBuffer);
    ASSERT(HiveRootPath);

    //
    // Attempt to load the key.
    //
    HiveLoaded = FALSE;
    Status = SpLoadUnloadKey(NULL,NULL,HiveRootPath,HiveFilePath);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to load hive %ws to key %ws (%lx)\n",HiveFilePath,HiveRootPath,Status));
        goto setdirty1;
    }

    HiveLoaded = TRUE;

    //
    // Now get a key to the root of the hive we just loaded.
    //
    INIT_OBJA(&Obja,&UnicodeString,HiveRootPath);
    Status = ZwOpenKey(&HiveRootKey,KEY_ALL_ACCESS,&Obja);
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open %ws (%lx)\n",HiveRootPath,Status));
        goto setdirty1;
    }

    //
    //  Make the appropriate change
    //

    Status = SpGetValueKey(
                 HiveRootKey,
                 L"DISK",
                 L"Information",
                 sizeof(TemporaryBuffer),
                 (PCHAR)TemporaryBuffer,
                 &ResultLength
                 );

    //
    //  TemporaryBuffer is 32kb long, and it should be big enough
    //  for the data.
    //
    ASSERT( Status != STATUS_BUFFER_OVERFLOW );
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to read value from registry. KeyName = Disk, ValueName = Information, Status = (%lx)\n",Status));
        goto setdirty1;
    }

    DiskHeader = ( PDISK_CONFIG_HEADER )(((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data);
    DiskHeader->DirtyShutdown = TRUE;

    Status = SpOpenSetValueAndClose( HiveRootKey,
                                     L"DISK",
                                     L"Information",
                                     REG_BINARY,
                                     DiskHeader,
                                     ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->DataLength
                                   );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to write value to registry. KeyName = Disk, ValueName = Information, Status = (%lx)\n",Status));
        goto setdirty1;
    }

setdirty1:

    //
    // Flush the hive.
    //

    if(HiveLoaded && HiveRootKey) {
        NTSTATUS stat;

        stat = ZwFlushKey(HiveRootKey);
        if(!NT_SUCCESS(stat)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: ZwFlushKey x%ws failed (%lx)\n", HiveRootPath, Status));
        }
    }

    if(HiveLoaded) {

        //
        // We don't want to disturb the value of Status
        // so use a we'll different variable below.
        //
        NTSTATUS stat;

        if(HiveRootKey!=NULL) {
            ZwClose(HiveRootKey);
            HiveRootKey = NULL;
        }

        //
        // Unload the hive.
        //
        stat = SpLoadUnloadKey(NULL,NULL,HiveRootPath,NULL);

        if(!NT_SUCCESS(stat)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: warning: unable to unload key %ws (%lx)\n",HiveRootPath,stat));
        }

        HiveLoaded = FALSE;
    }

    SpMemFree(HiveRootPath);
    SpMemFree(HiveFilePath);

    //
    //  If we fail to set the DirtyShutdown flag, then we silently fail
    //  because there is nothing that the user can do about, and the system
    //  is unlikely to boot anyway.
    //  This will occur if setup fails to:
    //
    //      - Load the system hive
    //      - Open System\Disk key
    //      - Read the value entry
    //      - Write the value entry
    //      - Unload the system hive
    //
    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: setup was unable to set DirtyShutdown flag. Status =   (%lx)\n", Status));
    }
}


NTSTATUS
SpPostprocessHives(
    IN PWSTR     PartitionPath,
    IN PWSTR     Sysroot,
    IN PCWSTR   *HiveNames,
    IN HANDLE   *HiveRootKeys,
    IN unsigned  HiveCount,
    IN HANDLE    hKeyCCS
    )
{
    NTSTATUS Status;
    ULONG u;
    unsigned h;
    PWSTR SaveHiveName;
    PWSTR HiveName;
    HANDLE SaveHiveHandle;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    OBJECT_ATTRIBUTES ObjectAttributes2;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING UnicodeString2;
    DWORD MangledVersion;
    PWSTR Value;
    PWSTR   SecurityHives[] = {
                              L"sam",
                              L"security"
                              };
    //
    // Flush all hives.
    //
    for(h=0; h<HiveCount; h++) {
        Status = ZwFlushKey(HiveRootKeys[h]);
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Warning: ZwFlushKey %ws failed (%lx)\n",HiveNames[h],Status));
        }

        SendSetupProgressEvent(SavingSettingsEvent, SaveHiveEvent, NULL);
    }

    //
    // If GUI setup is supposed to be restartable, we need to add an entry
    // to the BootExecute list, to cause sprestrt.exe to run.
    // Also, we want system.sav to have a RestartSetup=TRUE value in it,
    // but we want the actual system hive to have RestartSetup=FALSE.
    //
    if(RestartableGuiSetup) {

        Status = SpAppendStringToMultiSz(
                    hKeyCCS,
                    SESSION_MANAGER_KEY,
                    BOOT_EXECUTE,
                    L"sprestrt"
                    );



        if(NT_SUCCESS(Status)) {
            //
            // Add a RestartSetup value, set to TRUE.
            // To understand why we use a different value here in upgrade
            // and non-upgrade case, see discussion below.
            //
            u = (NTUpgrade == UpgradeFull) ? 0 : 1;
            Status = SpOpenSetValueAndClose(
                        HiveRootKeys[SetupHiveSystem],
                        SETUP_KEY_NAME,
                        RESTART_SETUP,
                        ULONG_VALUE(u)
                        );
        }
    } else {
        Status = STATUS_SUCCESS;
    }

    //
    // Do the final update of device instance data.
    //
    if((NTUpgrade == UpgradeFull)) {
        //
        // SANTOSHJ: This whole code needs to go away for BLACKCOMB.
        //
        Value = SpGetSectionKeyIndex(WinntSifHandle,
                                    SIF_DATA, WINNT_D_WIN32_VER_W, 0);
        if(Value) {
            //
            // version is bbbbllhh - build/low/high
            //
            MangledVersion = (DWORD)SpStringToLong( Value, NULL, 16 );
            if (LOWORD(MangledVersion) == 0x0105) {

                Status = SpUpdateDeviceInstanceData(hKeyCCS);
                if (!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Could not update device instance data. Status = (%lx)\n",Status));
                    return(Status);
                }
            }
        }
    }

    //
    //  At this point, we no longer need hKeyCCS, so we close the key.
    //  Note that key needs to be closed before we call ZwReplaceKey, otherwise
    //  this API will fail.
    //
    //  Note also, that the caller of this function expects this function to close this handle
    //  before it returns.
    //
    NtClose(hKeyCCS);

    if(NT_SUCCESS(Status)) {
        //
        // Save out the hives to *.sav in the initial install case,
        // or *.tmp in the upgrade case.
        //
        for(h=0; NT_SUCCESS(Status) && (h<HiveCount); h++) {
            //
            // Form full pathname of hive file.
            //
            wcscpy(TemporaryBuffer,PartitionPath);
            SpConcatenatePaths(TemporaryBuffer,Sysroot);
            SpConcatenatePaths(TemporaryBuffer,L"system32\\config");
            SpConcatenatePaths(TemporaryBuffer,HiveNames[h]);
            wcscat(TemporaryBuffer,(NTUpgrade == UpgradeFull) ? L".tmp" : L".sav");

            SaveHiveName = SpDupStringW(TemporaryBuffer);

            SpDeleteFile( SaveHiveName, NULL, NULL ); // Make sure that we get rid of the file if it has attributes.

            INIT_OBJA(&ObjectAttributes,&UnicodeString,SaveHiveName);

            Status = ZwCreateFile(
                        &SaveHiveHandle,
                        FILE_GENERIC_WRITE,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        0,                      // no sharing
                        FILE_OVERWRITE_IF,
                        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                        NULL,
                        0
                        );

            if(NT_SUCCESS(Status)) {

                //
                // call the Ex version to make sure the hive is saved in the lates format
                //
                Status = ZwSaveKeyEx(HiveRootKeys[h],SaveHiveHandle,REG_LATEST_FORMAT);
                if(!NT_SUCCESS(Status)) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: save key into %ws failed (%lx)\n",SaveHiveName,Status));
                }

                ZwClose(SaveHiveHandle);

            } else {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to create file %ws to save hive (%lx)\n",SaveHiveName,Status));
            }

            //
            // In the upgrade case, there is significant benefit to ensuring that
            // the hives are in the latest format. A hive that has been created
            // via NtSaveKeyEx(...,...,REG_LATEST_FORMAT) is guaranteed to be in the latest format.
            // Since we just did a SaveKey, xxx.tmp is in the latest format,
            // and we should use that as the xxx hive from now on. The existing
            // (old-format) hive can be retained as xxx.sav.
            //
            // NtReplaceKey does exactly what we want, but we have to make sure
            // that there is no .sav file already there, because that causes
            // NtReplaceKey to fail with STATUS_OBJECT_NAME_COLLISION.
            //
            // After NtReplaceKey is done, the hive root keys refer to the .sav
            // on-disk file but the extensionless on-disk file will be used at next
            // boot. Thus we need to be careful about how we write the restart values
            // into the hives.
            //
            if(NT_SUCCESS(Status) && (NTUpgrade == UpgradeFull)) {

                HiveName = SpDupStringW(SaveHiveName);
                wcscpy(HiveName+wcslen(HiveName)-3,L"sav");

                SpDeleteFile(HiveName,NULL,NULL);

                INIT_OBJA(&ObjectAttributes,&UnicodeString,SaveHiveName);
                INIT_OBJA(&ObjectAttributes2,&UnicodeString2,HiveName);

                Status = ZwReplaceKey(&ObjectAttributes,HiveRootKeys[h],&ObjectAttributes2);
            }

            SpMemFree(SaveHiveName);
        }
    }

    if(NT_SUCCESS(Status) && (NTUpgrade == UpgradeFull)) {
        //
        // In the upgarde case, make a backup of the security
        // hives. They need to be restored if the system is restartable.
        //

        //
        // Initialize the diamond decompression engine.
        // This needs to be done, because SpCopyFileUsingNames() uses
        // the decompression engine.
        //
        SpdInitialize();

        for( h = 0; h < sizeof(SecurityHives)/sizeof(PWSTR); h++ ) {
            PWSTR   p, q;

            wcscpy(TemporaryBuffer,PartitionPath);
            SpConcatenatePaths(TemporaryBuffer,Sysroot);
            SpConcatenatePaths(TemporaryBuffer,L"system32\\config");
            SpConcatenatePaths(TemporaryBuffer,SecurityHives[h]);
            p = SpDupStringW(TemporaryBuffer);
            wcscat(TemporaryBuffer, L".sav");
            q = SpDupStringW(TemporaryBuffer);
            Status = SpCopyFileUsingNames( p, q, 0, 0 );
            if( !NT_SUCCESS(Status) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to create backup file %ws. Status = %lx\n", q, Status));
            }
            SpMemFree(p);
            SpMemFree(q);
            if( !NT_SUCCESS(Status) ) {
                break;
            }
        }
        //
        // Terminate diamond.
        //
        SpdTerminate();
    }


    if(NT_SUCCESS(Status) && RestartableGuiSetup) {
        //
        // Set RestartSetup to FALSE in mainline hive.
        // To understand why we use a different value here in upgrade
        // and non-upgrade case, see discussion above.
        //
        u = (NTUpgrade == UpgradeFull) ? 1 : 0;
        Status = SpOpenSetValueAndClose(
                    HiveRootKeys[SetupHiveSystem],
                    SETUP_KEY_NAME,
                    RESTART_SETUP,
                    ULONG_VALUE(u)
                    );
    }

    return(Status);
}


NTSTATUS
SpSaveSetupPidList(
    IN HANDLE hKeySystemHive
    )

/*++

Routine Description:

    Save the Product Id read from setup.ini on HKEY_LOCAL_MACHINE\SYSTEM\Setup\\Pid.
    Also create the key HKEY_LOCAL_MACHINE\SYSTEM\Setup\PidList, and create
    value entries under this key that contain various Pid20 found in the other
    systems installed on this machine (the contents Pid20Array).

Arguments:

    hKeySystemHive - supplies handle to root of the system hive
        (ie, HKEY_LOCAL_MACHINE\System).


Return Value:

    Status value indicating outcome of operation.

--*/

{
    PWSTR    ValueName;
    NTSTATUS Status;
    ULONG    i;

    //
    //  First save the Pid read from setup.ini
    //
    if( PidString != NULL ) {
        Status = SpOpenSetValueAndClose( hKeySystemHive,
                                         L"Setup\\Pid",
                                         L"Pid",
                                         STRING_VALUE(PidString)
                                       );
        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to save Pid on SYSTEM\\Setup\\Pid. Status = %lx\n", Status ));
        }
    }

    //
    //  If Pid20Array is empty, then don't bother to create the Pid key
    //
    if( Pid20Array == NULL || Pid20Array[0] == NULL ) {
        return( STATUS_SUCCESS );
    }

    //
    // Can't use TemporaryBuffer because we make subroutine calls
    // below that trash its contents.
    // Note that a buffer of size MAX_PATH for a value name is more than enough.
    //
    ValueName = SpMemAlloc((MAX_PATH+1)*sizeof(WCHAR));

    for( i = 0; Pid20Array[i] != NULL; i++ ) {

        swprintf( ValueName, L"Pid_%d", i );
        Status = SpOpenSetValueAndClose( hKeySystemHive,
                                         L"Setup\\PidList",
                                         ValueName,
                                         STRING_VALUE(Pid20Array[i])
                                       );

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to open or create SYSTEM\\Setup\\PidList. ValueName = %ws, ValueData = %ws, Status = %lx\n",
                     ValueName, Pid20Array[i] ));
        }
    }
    SpMemFree(ValueName);
    return( STATUS_SUCCESS );
}


NTSTATUS
SpSavePreinstallHwInfo(
    IN PVOID  SifHandle,
    IN PWSTR  SystemRoot,
    IN HANDLE hKeyPreinstall,
    IN ULONG  ComponentIndex,
    IN PHARDWARE_COMPONENT  pHwList
    )
{
    NTSTATUS Status;
    NTSTATUS SaveStatus;
    PHARDWARE_COMPONENT TmpHw;
    PHARDWARE_COMPONENT_FILE File;
    PWSTR   OemTag = L"OemComponent";
    PWSTR   RetailClass = L"RetailClassToDisable";
    PWSTR   ClassName;
    ULONG u;
    WCHAR NodeName[9];
    PWSTR   ServiceName;

    SaveStatus = STATUS_SUCCESS;
    for( TmpHw = pHwList; TmpHw != NULL; TmpHw = TmpHw->Next ) {
        if( !TmpHw->ThirdPartyOptionSelected ) {
            u = 0;
            if( ( ComponentIndex == HwComponentKeyboard ) ||
                ( ComponentIndex == HwComponentMouse ) ) {
                ServiceName = SpGetSectionKeyIndex(SifHandle,
                                                   NonlocalizedComponentNames[ComponentIndex],
                                                   TmpHw->IdString,
                                                   INDEX_INFKEYNAME);
            } else {
                ServiceName = TmpHw->IdString;
            }

            Status = SpOpenSetValueAndClose( hKeyPreinstall,
                                             ServiceName,
                                             OemTag,
                                             ULONG_VALUE(u)
                                           );
            if( !NT_SUCCESS( Status ) ) {
                KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to save information for preinstalled retail driver %ls. Status = %lx \n", TmpHw->IdString, Status ));
                if( SaveStatus == STATUS_SUCCESS ) {
                    SaveStatus = Status;
                }
            }

        } else {
            //
            //  Find the name of the service, save it, and indicate if there is
            //  a retail class driver that needs to be disabled if the service
            //  initializes successfully.
            //
            if( IS_FILETYPE_PRESENT(TmpHw->FileTypeBits, HwFileClass) ) {
                if( ComponentIndex == HwComponentKeyboard ) {
                    ClassName = L"kbdclass";
                } else if( ComponentIndex == HwComponentMouse ) {
                    ClassName = L"mouclass";
                } else {
                    ClassName = NULL;
                }
            } else {
                ClassName = NULL;
            }
            for(File=TmpHw->Files; File; File=File->Next) {
                PWSTR p;

                //
                // If there is to be no node for this file, skip it.
                //
                if(!File->ConfigName) {
                    continue;
                }
                //
                // Calculate the node name.  This is the name of the driver
                // without the extension.
                //
                wcsncpy(NodeName,File->Filename,8);
                NodeName[8] = L'\0';
                if(p = wcschr(NodeName,L'.')) {
                    *p = L'\0';
                }
                u = 1;
                Status = SpOpenSetValueAndClose( hKeyPreinstall,
                                                 NodeName,
                                                 OemTag,
                                                 ULONG_VALUE(u)
                                               );
                if( !NT_SUCCESS( Status ) ) {
                    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to save information for preinstalled OEM driver %ls. Status = %lx \n", NodeName, Status ));
                    if( SaveStatus == STATUS_SUCCESS ) {
                        SaveStatus = Status;
                    }
                }
                if( ClassName != NULL ) {
                    Status = SpOpenSetValueAndClose( hKeyPreinstall,
                                                     NodeName,
                                                     RetailClass,
                                                     STRING_VALUE(ClassName)
                                                   );
                    if( !NT_SUCCESS( Status ) ) {
                        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Failed to save information for preinstalled OEM driver %ls. Status = %lx \n", NodeName, Status ));
                        if( SaveStatus == STATUS_SUCCESS ) {
                            SaveStatus = Status;
                        }
                    }
                }
            }
        }
    }
    return( SaveStatus );
}

NTSTATUS
SpSavePreinstallList(
    IN PVOID  SifHandle,
    IN PWSTR  SystemRoot,
    IN HANDLE hKeySystemHive
    )
{
    NTSTATUS Status;
    NTSTATUS SaveStatus;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    HANDLE hKeyPreinstall;
    ULONG   i;

    //
    // Create setup\preinstall
    //
    INIT_OBJA(&Obja,&UnicodeString,L"Setup\\Preinstall");
    Obja.RootDirectory = hKeySystemHive;

    Status = ZwCreateKey(
                &hKeyPreinstall,
                KEY_ALL_ACCESS,
                &Obja,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: unable to create Preinstall key. Status = %lx\n",Status));
        return( Status );
    }

    SaveStatus = STATUS_SUCCESS;
    for( i = 0; i < HwComponentMax; i++ ) {
        if( ( i == HwComponentComputer ) ||
            ( i == HwComponentDisplay )  ||
            ( i == HwComponentLayout ) ||
            ( PreinstallHardwareComponents[i] == NULL ) ) {
            continue;
        }

        Status = SpSavePreinstallHwInfo( SifHandle,
                                         SystemRoot,
                                         hKeyPreinstall,
                                         i,
                                         PreinstallHardwareComponents[i] );
        if( !NT_SUCCESS( Status ) ) {
            if( SaveStatus == STATUS_SUCCESS ) {
                SaveStatus = Status;
            }
        }
    }

    if( PreinstallScsiHardware != NULL ) {
        Status = SpSavePreinstallHwInfo( SifHandle,
                                         SystemRoot,
                                         hKeyPreinstall,
                                         HwComponentMax,
                                         PreinstallScsiHardware );
        if( !NT_SUCCESS( Status ) ) {
            if( SaveStatus == STATUS_SUCCESS ) {
                SaveStatus = Status;
            }
        }
    }
    ZwClose(hKeyPreinstall);
    return( SaveStatus );
}

NTSTATUS
SpSetPageFileInfo(
    IN PVOID   SifHandle,
    IN HANDLE hKeyCCSetControl,
    IN HANDLE hKeySystemHive
    )

/*++

Routine Description:

    This function replaces the original data of 'PagingFile' 
    CurrentControlSet\Session Manager\Memory Management with values from txtsetup.sif if the values don't measure up.
    The original value will have already been saved on HKEY_LOCAL_MACHINE\SYSTEM\Setup\\PageFile,
    and it will be restored at the end of GUI setup.

Arguments:

    SifHandle - handle to txtsetup.sif

    hKeyCCSetControl - supplies handle to SYSTEM\CurrentControlSet\Control

    hKeySystemHive - supplies handle to root of the system hive
        (ie, HKEY_LOCAL_MACHINE\System).


Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS Status;
    PUCHAR   Data;
    ULONG    Length;
    PWSTR    SrcKeyPath = L"Session Manager\\Memory Management";
    PWSTR    ValueName  = L"PagingFiles";

    PWSTR    Buffer;
    PWSTR    NextDstSubstring;
    ULONG    AuxLength;
    ULONG    StartPagefile,MaxPagefile;
    ULONG    OldStartPagefile,OldMaxPagefile;
    PWSTR    p;


    //
    // Read recommended pagefile size for gui-mode.
    //

    if(p = SpGetSectionKeyIndex(SifHandle,SIF_SETUPDATA,SIF_PAGEFILE,0)) {
        StartPagefile = SpStringToLong( p, NULL, 10 );
    }
    else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to retrieve initial pagefile size from txtsetup.sif\n"));
        return( STATUS_UNSUCCESSFUL );
    }
    if(p = SpGetSectionKeyIndex(SifHandle,SIF_SETUPDATA,SIF_PAGEFILE,1)) {
        MaxPagefile = SpStringToLong( p, NULL, 10 );
    }
    else {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to retrieve max pagefile size from txtsetup.sif\n"));
        return( STATUS_UNSUCCESSFUL );
    }
    KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Read pagefile from txtsetup %lx %lx\n", StartPagefile, MaxPagefile ));
    //
    //  Retrieve the original value of 'PagingFiles'
    //

    Status = SpGetValueKey( hKeyCCSetControl,
                            SrcKeyPath,
                            ValueName,
                            sizeof(TemporaryBuffer),
                            (PCHAR)TemporaryBuffer,
                            &Length );

    OldStartPagefile = 0;
    OldMaxPagefile = 0;
    NextDstSubstring = TemporaryBuffer;

    if(NT_SUCCESS(Status) && ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Type == REG_MULTI_SZ) {
        PWSTR   r;
        WCHAR   SaveChar;
        PWSTR   s=NULL;

        Data   = ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data;
        Length = ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->DataLength;

        Buffer = SpMemAlloc( Length );
    
        RtlMoveMemory( Buffer, Data, Length );

        AuxLength = wcslen( Buffer);
        // If it's not one string, then we won't change the pagefile
        if( AuxLength == 0 || *(Buffer+AuxLength+1) != (WCHAR)'\0') {
            SpMemFree( Buffer );
            return( STATUS_SUCCESS );
        }

        //
        //  Form a new value entry that contains the information regarding the
        //  paging files to be created. The paths to the paging files will be the
        //  same ones used in the system before the upgrade. 
    
        //
        //  Make a copy of the original value entry, and form the data for the new
        //  value entry in the TemporaryBuffer.
        //
    
        SpStringToLower( Buffer );
        r = wcsstr( Buffer, L"\\pagefile.sys" );
        if( r != NULL ) {
            r += wcslen( L"\\pagefile.sys" );
            SaveChar = *r;
            *r = (WCHAR)'\0';
            wcscpy( NextDstSubstring, Buffer );
            *r = SaveChar;
            OldStartPagefile = SpStringToLong( r, &s, 10 );
            if( (s != NULL) && (*s != (WCHAR)'\0') ) {
                OldMaxPagefile = max( OldStartPagefile, (ULONG)SpStringToLong( s, NULL, 10 ));
            } else {
                OldMaxPagefile = OldStartPagefile;
            }

        } else {
            wcscpy( NextDstSubstring, L"?:\\pagefile.sys" );
        }
        SpMemFree( Buffer );
        // NextDstSubstring should now point just after pagefile.sys at the null
    } else {
        wcscpy( NextDstSubstring, L"?:\\pagefile.sys" );
    }
    NextDstSubstring += wcslen( NextDstSubstring );

    //
    //  Overwrite the original value of PagingFiles
    //
    swprintf( NextDstSubstring, L" %d %d", max( OldStartPagefile, StartPagefile), max( OldMaxPagefile, MaxPagefile));
    Length = wcslen( TemporaryBuffer );
    Length++;
    (TemporaryBuffer)[ Length++ ] = UNICODE_NULL;

    Status = SpOpenSetValueAndClose( hKeyCCSetControl,
                                     SrcKeyPath,
                                     ValueName,
                                     REG_MULTI_SZ,
                                     TemporaryBuffer,
                                     Length*sizeof(WCHAR) );


    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to save pagefile.  Status = %lx\n", Status ));
    }
    return( Status );
}

NTSTATUS
SpSavePageFileInfo(
    IN HANDLE hKeyCCSetControl,
    IN HANDLE hKeySystemHive
    )

/*++

Routine Description:

    This function is only called on the upgrade case.
    The original value will be saved on HKEY_LOCAL_MACHINE\SYSTEM\Setup\\PageFile,
    and it will be restored at the end of GUI setup.

Arguments:

    hKeyCCSetControl - supplies handle to SYSTEM\CurrentControlSet\Control

    hKeySystemHive - supplies handle to root of the system hive
        (ie, HKEY_LOCAL_MACHINE\System).


Return Value:

    Status value indicating outcome of operation.

--*/

{
    NTSTATUS Status;
    PUCHAR   Data;
    ULONG    Length;
    PWSTR    SrcKeyPath = L"Session Manager\\Memory Management";
    PWSTR    ValueName  = L"PagingFiles";

    //
    //  Retrieve the original value of 'PagingFiles'
    //

    Status = SpGetValueKey( hKeyCCSetControl,
                            SrcKeyPath,
                            ValueName,
                            sizeof(TemporaryBuffer),
                            (PCHAR)TemporaryBuffer,
                            &Length );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to retrieve %ls on %ls. Status = %lx \n", ValueName, SrcKeyPath, Status ));
        return( Status );
    }

    Data   = ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->Data;
    Length = ((PKEY_VALUE_PARTIAL_INFORMATION)TemporaryBuffer)->DataLength;


    //
    //  Save the data in SYSTEM\Setup\PageFile
    //

    Status = SpOpenSetValueAndClose(
                hKeySystemHive,
                L"Setup\\PageFile",
                ValueName,
                REG_MULTI_SZ,
                Data,
                Length
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID, DPFLTR_ERROR_LEVEL, "SETUP: Unable to save %ls on SYSTEM\\Setup\\PageFile. ValueName, Status = %lx\n", Status ));
    }
    return( Status );
}

NTSTATUS
SppMigrateSetupRegNonVolatileKeys(
    IN PWSTR   PartitionPath,
    IN PWSTR   SystemRoot,
    IN HANDLE  hDestControlSet,
    IN PWSTR   KeyPath,
    IN BOOLEAN OverwriteValues,
    IN BOOLEAN OverwriteACLs
    )

/*++

Routine Description:

    This routine m