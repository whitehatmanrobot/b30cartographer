ons, rgReasons) \
    (*(pI)->lpVtbl->DidEvent)((pI), dwEventWhat, cReasons, rgReasons)
#endif /* COBJMACROS */

#endif


#ifdef __cplusplus
}
#endif

#define __OCDB_H_
#endif // __OCDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\olebind.h ===
/*****************************************************************************\
*                                                                             *
* olebind.h     Data binding interfaces for OLE                               *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1994, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#if !defined( _OLEBIND_H_ )
#define _OLEBIND_H_

#if !defined( INITGUID )
#include <olectlid.h>
#endif

DEFINE_GUID(IID_IBoundObject,
	0x9BFBBC00,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IBoundObjectSite,
	0x9BFBBC01,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);

typedef interface IBoundObject FAR* LPBOUNDOBJECT;
typedef interface ICursor FAR* LPCURSOR;

//#ifndef RUNTIME
typedef interface IBoundObjectSite FAR* LPBOUNDOBJECTSITE;
typedef interface ICursor FAR* FAR* LPLPCURSOR;
//#endif


//////////////////////////////////////////////////////////////////////////////
//
//  IBoundObject interface
//
//////////////////////////////////////////////////////////////////////////////

#undef  INTERFACE
#define INTERFACE IBoundObject

DECLARE_INTERFACE_(IBoundObject, IUnknown)
{
    //
    //  IUnknown methods
    //

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    //  IBoundObject methods
    //

	STDMETHOD(OnSourceChanged)(THIS_ DISPID dispid, BOOL fBound, BOOL FAR* lpfOwnXferOut) PURE;
	STDMETHOD(IsDirty)(THIS_ DISPID dispid) PURE;
};
//#ifndef RUNTIME
//////////////////////////////////////////////////////////////////////////////
//
//  IBoundObjectSite interface
//
//////////////////////////////////////////////////////////////////////////////

#undef  INTERFACE
#define INTERFACE IBoundObjectSite

DECLARE_INTERFACE_(IBoundObjectSite, IUnknown)
{
    //
    //  IUnknown methods
    //

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    //  IBoundObjectSite methods
    //

	STDMETHOD(GetCursor)(THIS_ DISPID dispid, LPLPCURSOR ppCursor, LPVOID FAR* ppcidOut) PURE;
};
//#endif //RUNTIME

#endif // !defined( _OLEBIND_H_ )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\oledbtyp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1994.
//
//  File:       oledbtyp.h
//
//  Contents:   Necessary type definitions for OLD-DB interfaces
//
//  Notes:	This file works around the fact that not everyone yet
//		has oleaut.h.
//		We just conditionally include the right type definitions
//		for whatever platform we're running on.
//
//  History:    25 Aug 94   Alanw	Created
//
//+---------------------------------------------------------------------------

#if !defined( _tagVARIANT_DEFINED )
//#include <oleaut.h>
#endif //!defined( _tagVARIANT_DEFINED )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MSR2C.rc
//
#include "..\\MSR2CENU\\resource.h" // strings are kept in a separate project

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        132
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\rscolumn.h ===
//---------------------------------------------------------------------------
// RowsetColumn.h : CVDRowsetColumn header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDROWSETCOLUMN__
#define __CVDROWSETCOLUMN__

#define VD_COLUMNSROWSET_MAX_OPT_COLUMNS 8

class CVDRowsetColumn
{
public:
// Construction/Destruction
	CVDRowsetColumn();
	virtual ~CVDRowsetColumn();

// Initialization
    BOOL Initialize(ULONG ulOrdinal, 
					ULONG ulCursorOrdinal, 
					DBCOLUMNINFO * pColumnInfo, 
					ULONG cbMaxBookmark,
					CURSOR_DBCOLUMNID * pBookmarkColumnID = NULL);
    
// Initialization of metadata metadata columns
	BOOL Initialize(const CURSOR_DBCOLUMNID * pCursorColumnID, 
					BOOL fDataColumn, 
					ULONG cbMaxLength, 
					CHAR * pszName, 
			        DWORD dwCursorType,
					DWORD dwNumber); 

// Position
    ULONG GetOrdinal() const {return m_ulOrdinal;}

// IRowset metadata
    DBID GetColumnID() const {return m_columnID;}
    DBTYPE GetType() const {return (DBTYPE)m_wType;}

// ICursor metadata
    BOOL GetAutoIncrement() const {return m_bool.fAutoIncrement;}
    void SetAutoIncrement(VARIANT_BOOL fAutoIncrement) {m_bool.fAutoIncrement = fAutoIncrement;}

    WCHAR * GetBaseColumnName() const {return m_pwszBaseColumnName;}
    void SetBaseColumnName(WCHAR * pBaseColumnName, ULONG ulLength)
				{ SetStringProperty(&m_pwszBaseColumnName, pBaseColumnName, ulLength); }

    WCHAR * GetBaseName() const {return m_pwszBaseName;}
    void SetBaseName(WCHAR * pBaseName, ULONG ulLength) 
				{ SetStringProperty(&m_pwszBaseName, pBaseName, ulLength); }

    DWORD GetBindType() const {return m_dwBindType;}

    BOOL GetCaseSensitive() const {return m_bool.fCaseSensitive;}
    void SetCaseSensitive(VARIANT_BOOL fCaseSensitive) {m_bool.fCaseSensitive = fCaseSensitive;}

    LCID GetCollatingOrder() const {return m_lcidCollatingOrder;}
    void SetCollatingOrder(LCID lcidCollatingOrder) {m_lcidCollatingOrder = lcidCollatingOrder;}

    CURSOR_DBCOLUMNID GetCursorColumnID() const {return m_cursorColumnID;}
    BOOL GetDataColumn() const {return m_bool.fDataColumn;}

    WCHAR * GetDefaultValue() const {return m_pwszDefaultValue;}
    void SetDefaultValue(WCHAR * pDefaultValue, ULONG ulLength)
				{ SetStringProperty(&m_pwszDefaultValue, pDefaultValue, ulLength); }

    ULONG GetEntryIDMaxLength() const {return m_cbEntryIDMaxLength;}
    BOOL GetFixed() const {return m_bool.fFixed;}

    BOOL GetHasDefault() const {return m_bool.fHasDefault;}
    void SetHasDefault(VARIANT_BOOL fHasDefault) {m_bool.fHasDefault = fHasDefault;}
    
	ULONG GetMaxLength() const {return m_cbMaxLength;}
    BOOL GetMultiValued() const {return m_bool.fMultiValued;}
    WCHAR * GetName() const {return m_pwszName;}
    BOOL GetNullable() const {return m_bool.fNullable;}
    DWORD GetNumber() const {return m_dwNumber;}
    DWORD GetScale() const {return m_dwScale;}
    BOOL GetSearchable() const {return m_bool.fSearchable;}
    DWORD GetCursorType() const {return m_dwCursorType;}
    
	BOOL GetUnique() const {return m_bool.fUnique;}
    void SetUnique(VARIANT_BOOL fUnique) {m_bool.fUnique = fUnique;}
    
	DWORD GetUpdatable() const {return m_dwUpdatable;}
    DWORD GetVersion() const {return m_dwVersion;}
    DWORD GetStatus() const {return m_dwStatus;}

// Fetching
    DWORD GetMaxStrLen() const {return m_ulMaxStrLen;}
    
public:
// Conversions
    static CURSOR_DBCOLUMNID ColumnIDToCursorColumnID(const DBID& columnID, ULONG ulCursorOrdinal);
    static CURSOR_DBVARENUM TypeToCursorType(DBTYPE wType);
    static DBTYPE CursorTypeToType(CURSOR_DBVARENUM dwCursorType);

// Fetching
    static ULONG GetCursorTypeMaxStrLen(DWORD dwCursorType, ULONG cbMaxLength);

protected:

	void SetStringProperty(WCHAR ** ppStringProp,
						   WCHAR * pNewString, 
						   ULONG ulLength);
// Position
    ULONG               m_ulOrdinal;            // IRowset ordinal position

// IRowset metadata
    DBID                m_columnID;             // column identifier
    DWORD               m_wType;                // datatype
    
// ICursor metadata
    WCHAR *             m_pwszBaseColumnName;   // base column name
    WCHAR *             m_pwszBaseName;         // base name
    DWORD               m_dwBindType;           // bind type
    LCID                m_lcidCollatingOrder;   // collating order
    CURSOR_DBCOLUMNID   m_cursorColumnID;       // column identifier
    WCHAR *             m_pwszDefaultValue;     // default value
    ULONG               m_cbEntryIDMaxLength;   // entryID maximum length
    ULONG               m_cbMaxLength;          // data maximum length
    WCHAR *             m_pwszName;             // name
    DWORD               m_dwNumber;             // number
    DWORD               m_dwScale;              // scale
    DWORD               m_dwCursorType;         // datatype
    DWORD               m_dwUpdatable;          // updateablity
    DWORD               m_dwVersion;            // version
    DWORD               m_dwStatus;             // status

// Booleans
    struct
    {
        WORD fInitialized       : 1;            // is column initialized?
        WORD fAutoIncrement     : 1;            // auto increment?
        WORD fCaseSensitive     : 1;            // case sensitive?
        WORD fDataColumn        : 1;            // data column?
        WORD fFixed             : 1;            // fixed length?
        WORD fHasDefault        : 1;            // has default value?
        WORD fMultiValued       : 1;            // multivalued?
        WORD fNullable          : 1;            // accepts NULLs?
        WORD fSearchable        : 1;            // searchable?
        WORD fUnique            : 1;            // unique?
    } m_bool;

// Fetching
    DWORD m_ulMaxStrLen;    // maximum string length for fixed data types
};


#endif //__CVDROWSETCOLUMN__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\rscolumn.cpp ===
//---------------------------------------------------------------------------
// RowsetColumn.cpp : RowsetColumn implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"         
#include "RSColumn.h"         

SZTHISFILE


//=--------------------------------------------------------------------------=
// CVDRowsetColumn - Constructor
//
CVDRowsetColumn::CVDRowsetColumn()
{
    m_ulOrdinal             = 0;

    m_wType                 = 0;
    
    m_pwszBaseColumnName    = NULL;
    m_pwszBaseName          = NULL;      
    m_dwBindType            = 0;        
    m_lcidCollatingOrder    = 0;
    m_pwszDefaultValue      = NULL;  
    m_cbEntryIDMaxLength    = 0;
    m_cbMaxLength           = 0;       
    m_pwszName              = NULL;          
    m_dwNumber              = 0;          
    m_dwScale               = 0;           
    m_dwCursorType          = 0;
    m_dwUpdatable           = 0;      
    m_dwVersion             = 0;         
    m_dwStatus              = 0;          

    m_bool.fInitialized     = FALSE;   
    m_bool.fAutoIncrement   = FALSE; 
    m_bool.fCaseSensitive   = TRUE;
    m_bool.fDataColumn      = FALSE;
    m_bool.fFixed           = FALSE;
    m_bool.fHasDefault      = FALSE;
    m_bool.fMultiValued     = FALSE;
    m_bool.fNullable        = FALSE;
    m_bool.fSearchable      = FALSE;
    m_bool.fUnique          = FALSE;

    m_ulMaxStrLen           = 0;

    memset(&m_columnID, 0, sizeof(DBID));
    memset(&m_cursorColumnID, 0, sizeof(CURSOR_DBCOLUMNID));

#ifdef _DEBUG
    g_cVDRowsetColumnCreated++;
#endif         
}

//=--------------------------------------------------------------------------=
// ~CVDRowsetColumn - Destructor
//
CVDRowsetColumn::~CVDRowsetColumn()
{
    delete [] m_pwszBaseColumnName;
    delete [] m_pwszBaseName;
    delete [] m_pwszDefaultValue;
    delete [] m_pwszName;

    if (m_columnID.eKind == DBKIND_PGUID_NAME || m_columnID.eKind == DBKIND_PGUID_PROPID)
        delete m_columnID.uGuid.pguid;

    if (m_columnID.eKind == DBKIND_GUID_NAME || m_columnID.eKind == DBKIND_NAME || m_columnID.eKind == DBKIND_PGUID_NAME)
        delete [] m_columnID.uName.pwszName;

    if (m_cursorColumnID.dwKind == CURSOR_DBCOLKIND_GUID_NAME || m_cursorColumnID.dwKind == CURSOR_DBCOLKIND_NAME)
        delete [] m_cursorColumnID.lpdbsz;

#ifdef _DEBUG
    g_cVDRowsetColumnDestroyed++;
#endif         
}

//=--------------------------------------------------------------------------=
// Initialize - Initialize rowset column object from IRowset metadata (#1)
//=--------------------------------------------------------------------------=
// This function converts and stores IRowset metadata in ICursor format
//
// Parameters:
//    ulOrdinal         - [in] original IRowset ordinal of column
//    ulCursorOrdinal   - [in] newly assigned ICursor ordinal of column
//    pColumnInfo       - [in] a pointer to an IRowset DBCOLUMNINFO structure 
//                             where to retrieve metadata
//    cbMaxBookmark     - [in] maximum size of an IRowset bookmark
//    pBookmarkColumnID - [in] a pointer to bookmark column identifier if this
//                             is a bookmark column, otherwise NULL
//
// Output:
//    BOOL  - TRUE if successful
//
// Notes:
//    This function should only be called once
//
BOOL CVDRowsetColumn::Initialize(ULONG ulOrdinal, 
								 ULONG ulCursorOrdinal, 
								 DBCOLUMNINFO * pColumnInfo, 
								 ULONG cbMaxBookmark,
								 CURSOR_DBCOLUMNID * pBookmarkColumnID)
{
    if (m_bool.fInitialized)
	{
		ASSERT(FALSE, VD_ASSERTMSG_COLALREADYINITIALIZED)
		return FALSE;
	}

    m_ulOrdinal = ulOrdinal;

// Store IRowset metadata
    m_wType     = pColumnInfo->wType;
    m_columnID  = pColumnInfo->columnid;

    // make copy of guid if necessary
    if (m_columnID.eKind == DBKIND_PGUID_NAME || m_columnID.eKind == DBKIND_PGUID_PROPID)
    {
        m_columnID.uGuid.pguid = new GUID;

		if (!m_columnID.uGuid.pguid)
			return E_OUTOFMEMORY;

        memcpy(m_columnID.uGuid.pguid, pColumnInfo->columnid.uGuid.pguid, sizeof(GUID));
    }

    // make copy of name if necessary
    if (m_columnID.eKind == DBKIND_GUID_NAME || m_columnID.eKind == DBKIND_NAME || m_columnID.eKind == DBKIND_PGUID_NAME)
    {
        const int nLength = lstrlenW(pColumnInfo->columnid.uName.pwszName);

        m_columnID.uName.pwszName = new WCHAR[nLength + 1];

		if (!m_columnID.uName.pwszName)
			return E_OUTOFMEMORY;

        memcpy(m_columnID.uName.pwszName, pColumnInfo->columnid.uName.pwszName, (nLength + 1) * sizeof(WCHAR));
    }

// Store ICursor metadata
    if (pColumnInfo->dwFlags & DBCOLUMNFLAGS_MAYDEFER)
        m_dwBindType = CURSOR_DBBINDTYPE_BOTH;
    else
        m_dwBindType = CURSOR_DBBINDTYPE_DATA;

    if (!pBookmarkColumnID)
        m_cursorColumnID = ColumnIDToCursorColumnID(pColumnInfo->columnid, ulCursorOrdinal);
    else
        m_cursorColumnID = *pBookmarkColumnID;  // use supplied bookmark column identifier
    
    if (m_dwBindType == CURSOR_DBBINDTYPE_BOTH)
        m_cbEntryIDMaxLength = sizeof(ULONG) + sizeof(ULONG) + cbMaxBookmark;
    else
        m_cbEntryIDMaxLength = 0;

// rowset types DBTYPE_GUID and DBTYPE_DBTIMESTAMP are returned as CURSOR_DBTYPE_LPWSTRs

	if (pColumnInfo->wType == DBTYPE_GUID || pColumnInfo->wType == DBTYPE_DBTIMESTAMP)
	    m_cbMaxLength = 64;
	else
	    m_cbMaxLength = pColumnInfo->ulColumnSize;

    if (pColumnInfo->pwszName)
    {
        const int nLength = lstrlenW(pColumnInfo->pwszName);

        m_pwszName = new WCHAR[nLength + 1];

		if (!m_pwszName)
			return E_OUTOFMEMORY;

        memcpy(m_pwszName, pColumnInfo->pwszName, (nLength + 1) * sizeof(WCHAR));
    }

    m_dwNumber = ulCursorOrdinal;

    m_dwScale = pColumnInfo->bScale;

    m_dwCursorType = TypeToCursorType(pColumnInfo->wType);

    if (pColumnInfo->dwFlags & DBCOLUMNFLAGS_WRITE)
        m_dwUpdatable = CURSOR_DBUPDATEABLE_UPDATEABLE;

    if (!(pColumnInfo->dwFlags & DBCOLUMNFLAGS_ISBOOKMARK))
        m_bool.fDataColumn = TRUE;

    if (pColumnInfo->dwFlags & DBCOLUMNFLAGS_ISFIXEDLENGTH)
    {
        m_bool.fFixed = TRUE;
        m_ulMaxStrLen = GetCursorTypeMaxStrLen(m_dwCursorType, m_cbMaxLength);
    }

    if (pColumnInfo->dwFlags & DBCOLUMNFLAGS_MAYBENULL)
        m_bool.fNullable = TRUE;

    m_bool.fInitialized = TRUE;

    return TRUE;
}

//=--------------------------------------------------------------------------=
// Initialize - Initialize rowset column object from meta-metadata (#2)
//=--------------------------------------------------------------------------=
// The function stores ICursor meta-metadata
//
// Parameters:
//    cursorColumnID    - [in] ICursor column identifier
//    fDataColumn       - [in] is data column?
//    cbMaxLength       - [in] maximum length of this datatype
//    pszName           - [in] column name
//    dwCursorType      - [in] datatype
//    dwNumber          - [in] ordinal position
//
// Output:
//    BOOL  - TRUE if successful
//
// Notes:
//    This function should only be called once
//
BOOL CVDRowsetColumn::Initialize(const CURSOR_DBCOLUMNID * pCursorColumnID, 
								 BOOL fDataColumn, 
								 ULONG cbMaxLength, 
								 CHAR * pszName, 
								 DWORD dwCursorType,
								 DWORD dwNumber) 
{
    if (m_bool.fInitialized)
	{
		ASSERT(FALSE, VD_ASSERTMSG_COLALREADYINITIALIZED)
		return FALSE;
	}

// Store ICursor meta-metadata
    m_dwBindType = CURSOR_DBBINDTYPE_DATA;

    m_cursorColumnID = *pCursorColumnID;

    m_cbEntryIDMaxLength = 0;

    m_cbMaxLength = cbMaxLength;

    if (pszName)
    {
        MAKE_WIDEPTR_FROMANSI(pwszName, pszName);

        const int nLength = lstrlenW(pwszName);

        m_pwszName = new WCHAR[nLength + 1];

		if (!m_pwszName)
			return E_OUTOFMEMORY;

        memcpy(m_pwszName, pwszName, (nLength + 1) * sizeof(WCHAR));
    }

    m_dwNumber = dwNumber;

    m_dwScale = 0;

    m_dwCursorType = dwCursorType;

    m_dwUpdatable = CURSOR_DBUPDATEABLE_NOTUPDATEABLE;

    m_bool.fDataColumn  = fDataColumn;
    m_bool.fFixed       = TRUE;
    m_bool.fNullable    = FALSE;

    m_bool.fInitialized = TRUE;

    return TRUE;
}

//=--------------------------------------------------------------------------=
// SetStringProperty
//=--------------------------------------------------------------------------=
// The function is called from SetBaseColumnName, SetBaseName and SetDefaultValue
//
// Parameters:
//    ppStringProp	    - [in] A ptr to the ptr that holds the string value
//    pNewString	    - [in] A pointer to the new string value
//    ulLength			- [in] the length of the string in bytes
//
// Notes:
//

void CVDRowsetColumn::SetStringProperty(WCHAR ** ppStringProp,
										WCHAR * pNewString, 
										ULONG ulLength)
{
	// free old string prop if any
    delete [] *ppStringProp;

	// if ulLength = zero then just return
	if (!ulLength)
	{
		*ppStringProp = NULL;
		return;
	}

	ASSERT_POINTER_LEN(pNewString, ulLength);
	*ppStringProp = new WCHAR[ulLength + sizeof(WCHAR)];

	if (*ppStringProp)
	{
		// init null terminator
		(*ppStringProp)[ulLength] = 0;
		// copy string over
		memcpy(*ppStringProp, pNewString, ulLength);
	}
}

//=--------------------------------------------------------------------------=
// ColumnIDToCursorColumnID - Convert rowset column ID to cursor column ID
//=--------------------------------------------------------------------------=
// Converts an IRowset DBID structure into its ICursor DBCOLUMNID equivalent 
//
// Parameters:
//    columnID          - [in] the IRowset column identifier
//    ulCursorOrdinal   - [in] the column's ordinal position in ICursor
//
// Output:
//    CURSOR_DBCOLUMNID - The ICursor CURSOR_DBCOLUMNID equivalent of columnID
//
// Notes:
//

CURSOR_DBCOLUMNID CVDRowsetColumn::ColumnIDToCursorColumnID(const DBID& columnID, ULONG ulCursorOrdinal)
{ 
    CURSOR_DBCOLUMNID cursorColumnID;

    GUID guidNumberOnly = CURSOR_GUID_NUMBERONLY;

    cursorColumnID.guid     = guidNumberOnly;
    cursorColumnID.dwKind   = CURSOR_DBCOLKIND_GUID_NUMBER;
    cursorColumnID.lNumber  = ulCursorOrdinal;

    return cursorColumnID;

// The following code is the old implementation of this function.  It caused problems with some
// cursor consumers because it tried to create a cursor column identifier as close as possible 
// to the rowset column identifier, thus utilized the problematic lpdbsz member.

/*
    CURSOR_DBCOLUMNID ID;

    switch (columnID.eKind)
    {
	    case DBKIND_GUID_NAME:
            ID.guid         = columnID.uGuid.guid;
            ID.dwKind       = CURSOR_DBCOLKIND_GUID_NAME;
            ID.lpdbsz       = columnID.uName.pwszName;
            break;

	    case DBKIND_GUID_PROPID:
            ID.guid         = columnID.uGuid.guid;
            ID.dwKind       = CURSOR_DBCOLKIND_GUID_NUMBER;
            ID.lNumber      = ulCursorOrdinal;
            break;
            
	    case DBKIND_NAME:
            ID.dwKind       = CURSOR_DBCOLKIND_NAME;
            ID.lpdbsz       = columnID.uName.pwszName;
            break;

	    case DBKIND_PGUID_NAME:
            ID.guid         = *columnID.uGuid.pguid;
            ID.dwKind       = CURSOR_DBCOLKIND_GUID_NAME;
            ID.lpdbsz       = columnID.uName.pwszName;
            break;

	    case DBKIND_PGUID_PROPID:
            ID.guid         = *columnID.uGuid.pguid;
            ID.dwKind       = CURSOR_DBCOLKIND_GUID_NUMBER;
            ID.lNumber      = ulCursorOrdinal;
            break;

	    case DBKIND_GUID:
            ID.guid         = columnID.uGuid.guid;
            ID.dwKind       = CURSOR_DBCOLKIND_GUID_NUMBER;
            ID.lNumber      = ulCursorOrdinal;
            break;

	    case DBKIND_PROPID:
            memset(&ID.guid, 0, sizeof(GUID));  // encode ordinal in guid
            ID.guid.Data1   = ulCursorOrdinal;
            ID.dwKind       = CURSOR_DBCOLKIND_GUID_NUMBER;
            ID.lNumber      = ulCursorOrdinal;
            break;
    }

    // make copy of name if necessary
    if (ID.dwKind == CURSOR_DBCOLKIND_GUID_NAME || ID.dwKind == CURSOR_DBCOLKIND_NAME)
    {
        const int nLength = lstrlenW(columnID.uName.pwszName);

        ID.lpdbsz = new WCHAR[nLength + 1];

		if (ID.lpdbsz)
			memcpy(ID.lpdbsz, columnID.uName.pwszName, (nLength + 1) * sizeof(WCHAR));
    }

    return ID;
*/
}

//=--------------------------------------------------------------------------=
// TypeToCursorType - Convert rowset datatype to cursor datatype
//=--------------------------------------------------------------------------=
// Converts a IRowset DBTYPE value into its ICursor DBVARENUM equivalent 
//
// Parameters:
//    wType     - [in] the IRowset datatype
//
// Output:
//    CURSOR_DBVARENUM - The ICursor DBVARENUM equivalent of DBTYPE
//
// Notes:
//
CURSOR_DBVARENUM CVDRowsetColumn::TypeToCursorType(DBTYPE wType)
{
    DWORD dwType = 0;

    switch (wType)
    {
        case DBTYPE_ERROR:
            dwType = CURSOR_DBTYPE_HRESULT;
            break;

        case DBTYPE_VARIANT:
            dwType = CURSOR_DBTYPE_ANYVARIANT;
            break;

        case DBTYPE_UI2:
            dwType = CURSOR_DBTYPE_UI2;
            break;

        case DBTYPE_UI4:
            dwType = CURSOR_DBTYPE_UI4;
            break;

        case DBTYPE_UI8:
            dwType = CURSOR_DBTYPE_UI8;
            break;

        case DBTYPE_BYTES:
            dwType = CURSOR_DBTYPE_BLOB;
            break;

        case DBTYPE_STR:
            dwType = VT_BSTR;
            break;

        case DBTYPE_WSTR:
            dwType = CURSOR_DBTYPE_LPWSTR;
            break;

        case DBTYPE_NUMERIC:
            dwType = CURSOR_DBTYPE_R8;
            break;

        //case DBTYPE_HCHAPTER:             <- doesn't exist in new spec
        //    break;  // no equivalent

        case DBTYPE_UDT:
            break;  // no equivalent

        case DBTYPE_DBDATE:
            dwType = CURSOR_DBTYPE_DATE;
            break;

        case DBTYPE_DBTIME:
            dwType = CURSOR_DBTYPE_DATE;
            break;

// rowset types DBTYPE_GUID and DBTYPE_DBTIMESTAMP are returned as CURSOR_DBTYPE_LPWSTRs

		case DBTYPE_GUID:
        case DBTYPE_DBTIMESTAMP:
            dwType = CURSOR_DBTYPE_LPWSTR;
            break;

        default:
            dwType = wType;
    }

    return (CURSOR_DBVARENUM)dwType;
}

//=--------------------------------------------------------------------------=
// CursorTypeToType - Convert cursor datatype to rowset datatype
//=--------------------------------------------------------------------------=
// Converts a ICursor DBVARENUM value into its IRowset DBTYPE equivalent 
//
// Parameters:
//    CURSOR_DBVARENUM - [in] the ICursor value
//
// Output:
//    DBTYPE - The IRowset DBTYPE equivalent of DBVARENUM
//
// Notes:
//
DBTYPE CVDRowsetColumn::CursorTypeToType(CURSOR_DBVARENUM dwCursorType)
{
    DBTYPE wType = 0;
    
    switch (dwCursorType)
    {
        case CURSOR_DBTYPE_HRESULT:
            wType = DBTYPE_ERROR;
            break;
        
        case CURSOR_DBTYPE_LPSTR:
            wType = DBTYPE_STR;
            break;
        
        case CURSOR_DBTYPE_LPWSTR:
            wType = DBTYPE_WSTR;
            break;
        
        case CURSOR_DBTYPE_FILETIME:
            wType = DBTYPE_DBTIMESTAMP;
            break;
        
        case CURSOR_DBTYPE_BLOB:
			wType = DBTYPE_BYTES;
            break;
        
        case CURSOR_DBTYPE_DBEXPR:
            break;  // no equivalent
        
        case CURSOR_DBTYPE_UI2:
            wType = DBTYPE_UI2;
            break;
        
        case CURSOR_DBTYPE_UI4:
            wType = DBTYPE_UI4;
            break;
        
        case CURSOR_DBTYPE_UI8:
            wType = DBTYPE_UI8;
            break;
        
        case CURSOR_DBTYPE_COLUMNID:
			wType = DBTYPE_GUID;
            break;  
        
        case CURSOR_DBTYPE_BYTES:
            wType = DBTYPE_BYTES;
            break;
        
        case CURSOR_DBTYPE_CHARS:
			wType = DBTYPE_STR;
            break;  
        
        case CURSOR_DBTYPE_WCHARS:
			wType = DBTYPE_WSTR;
            break;
        
        case CURSOR_DBTYPE_ANYVARIANT:
            wType = DBTYPE_VARIANT;
            break;

        default:
            wType = (WORD)dwCursorType;
    }

    return wType; 
}

//=--------------------------------------------------------------------------=
// GetCursorTypeMaxStrLen - Get the buffer size in characters required by 
//                          cursor data type when represented as a string
//                          (doesn't include NULL terminator)
//
// Notes:
//
//  The way these values where computed is as follows:
//
//	  (1) the maximum precision for each datatype was taken from "Precision of Numeric Data Types" in
//        appendix A of the "OLE DB Programmer's Reference, Volume 2".
//    (2) the precision was then divided by two and added to the original precision to allow space for 
//	  	  numberic symbols, like negative signs, dollar signs, commas, etc., that might be present.
//    (3) the sum was then doubled to allow for multibyte character sets.
//
//	Since this table is not appropriate for floating point datatypes, their values where computed based 
//  on the string length of the minimum/maximum possible values for these datatypes, then doubled.
//
//    datatype       minimum value			  maximum value		length
//	  --------	     -------------		      -------------		------
//	   float        1.175494351e-38		     3.402823466e+38	  15
//	   double   2.2250738585072014e-308  1.7976931348623158e+308  23
//
ULONG CVDRowsetColumn::GetCursorTypeMaxStrLen(DWORD dwCursorType, ULONG cbMaxLength)
{
    ULONG ulMaxStrLen = cbMaxLength;    // default for fixed length strings

    switch (dwCursorType)
    {
        case VT_I1:
            ulMaxStrLen = (3 + 1) * 2;
            break;

        case CURSOR_DBTYPE_I2:
            ulMaxStrLen = (5 + 2) * 2;
            break;

        case CURSOR_DBTYPE_I4:
            ulMaxStrLen = (10 + 5) * 2;
            break;

        case CURSOR_DBTYPE_I8:
            ulMaxStrLen = (19 + 9) * 2;
            break;

        case CURSOR_DBTYPE_R4:
            ulMaxStrLen = (15) * 2;
            break;

        case CURSOR_DBTYPE_R8:
            ulMaxStrLen = (23) * 2;
            break;

        case CURSOR_DBTYPE_CY:
            ulMaxStrLen = (19 + 9) * 2;
            break;

        case CURSOR_DBTYPE_DATE:
            ulMaxStrLen = (32 + 16) * 2;
            break;

        case CURSOR_DBTYPE_FILETIME:
            ulMaxStrLen = (32 + 16) * 2;
            break;

        case CURSOR_DBTYPE_BOOL:
            ulMaxStrLen = (5 + 2) * 2;
            break;

        case VT_UI1:
            ulMaxStrLen = (3 + 1) * 2;
            break;

        case CURSOR_DBTYPE_UI2:
            ulMaxStrLen = (5 + 2) * 2;
            break;

        case CURSOR_DBTYPE_UI4:
            ulMaxStrLen = (10 + 5) * 2;
            break;

        case CURSOR_DBTYPE_UI8:
            ulMaxStrLen = (20 + 10) * 2;
            break;
    }

    return ulMaxStrLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\stdafx.cpp ===
//---------------------------------------------------------------------------
// Stdafx.cpp : Source file that includes just the standard includes
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\stdafx.h ===
//---------------------------------------------------------------------------
// Stdafx.h : Include file for standard system include files
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "ipserver.h"       // Inprocess server header

#include "ARRAY_P.h"

#include "ocdb.h"           // OLE controls data bindings interfaces
#include "ocdbid.h"

#define OLEDBVER 0x0200

#include "oledb.h"          // OLE DB interfaces
#include "oledberr.h"

#include "util.h"           // useful utilities
#include "ErrorInf.h"       // for format error messages

#define VD_DLL_PREFIX		"MSR2C"

#define VD_INCLUDE_ROWPOSITION

//=--------------------------------------------------------------------------=
// object construction/destruction counters (debug only)
//
#ifdef _DEBUG
extern int g_cVDNotifierCreated;                    // CVDNotifier
extern int g_cVDNotifierDestroyed;
extern int g_cVDNotifyDBEventsConnPtCreated;        // CVDNotifyDBEventsConnPt
extern int g_cVDNotifyDBEventsConnPtDestroyed;
extern int g_cVDNotifyDBEventsConnPtContCreated;    // CVDNotifyDBEventsConnPtCont
extern int g_cVDNotifyDBEventsConnPtContDestroyed;
extern int g_cVDEnumConnPointsCreated;              // CVDEnumConnPoints
extern int g_cVDEnumConnPointsDestroyed;
extern int g_cVDRowsetColumnCreated;                // CVDRowsetColumn
extern int g_cVDRowsetColumnDestroyed;
extern int g_cVDRowsetSourceCreated;                // CVDRowsetSource
extern int g_cVDRowsetSourceDestroyed;
extern int g_cVDCursorMainCreated;                  // CVDCursorMain
extern int g_cVDCursorMainDestroyed;
extern int g_cVDCursorPositionCreated;              // CVDCursorPosition
extern int g_cVDCursorPositionDestroyed;
extern int g_cVDCursorBaseCreated;                  // CVDCursorBase
extern int g_cVDCursorBaseDestroyed;
extern int g_cVDCursorCreated;                      // CVDCursor
extern int g_cVDCursorDestroyed;
extern int g_cVDMetadataCursorCreated;              // CVDMetadataCursor
extern int g_cVDMetadataCursorDestroyed;
extern int g_cVDEntryIDDataCreated;                 // CVDEntryIDData
extern int g_cVDEntryIDDataDestroyed;
extern int g_cVDStreamCreated;                      // CVDStream
extern int g_cVDStreamDestroyed;
extern int g_cVDColumnUpdateCreated;                // CVDColumnUpdate
extern int g_cVDColumnUpdateDestroyed;
#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\rssource.cpp ===
//---------------------------------------------------------------------------
// RowsetSource.cpp : RowsetSource implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"         
#include "Notifier.h"         
#include "RSSource.h"         
#include "MSR2C.h"         

SZTHISFILE

//=--------------------------------------------------------------------------=
// CVDRowsetSource - Constructor
//
CVDRowsetSource::CVDRowsetSource()
{
	m_bool.fRowsetReleased	= FALSE;
    m_bool.fInitialized		= FALSE;

    m_pRowset				= NULL;
    m_pAccessor				= NULL;
    m_pRowsetLocate			= NULL;
    m_pRowsetScroll			= NULL;
    m_pRowsetChange			= NULL;
    m_pRowsetUpdate			= NULL;
    m_pRowsetFind			= NULL;
	m_pRowsetInfo			= NULL;
	m_pRowsetIdentity		= NULL;

#ifdef _DEBUG
    g_cVDRowsetSourceCreated++;
#endif         
}

//=--------------------------------------------------------------------------=
// ~CVDRowsetSource - Destructor
//
CVDRowsetSource::~CVDRowsetSource()
{
    if (IsRowsetValid())
    {
        RELEASE_OBJECT(m_pAccessor)
        RELEASE_OBJECT(m_pRowsetLocate)
        RELEASE_OBJECT(m_pRowsetScroll)
        RELEASE_OBJECT(m_pRowsetChange)
        RELEASE_OBJECT(m_pRowsetUpdate)
        RELEASE_OBJECT(m_pRowsetFind)
        RELEASE_OBJECT(m_pRowsetInfo)
        RELEASE_OBJECT(m_pRowsetIdentity)
        
        m_pRowset->Release();
    }

#ifdef _DEBUG
    g_cVDRowsetSourceDestroyed++;
#endif         
}

//=--------------------------------------------------------------------------=
// Initialize - Initialize rowset source object
//=--------------------------------------------------------------------------=
// This function QI's and store the IRowset pointers
//
// Parameters:
//    pRowset   - [in] original IRowset pointer
//
// Output:
//    HRESULT   - S_OK if successful
//                E_INVALIDARG bad parameter
//                E_FAIL if already initialized
//                VD_E_CANNOTGETMANDATORYINTERFACE unable to get required interface  
//
// Notes:
//    This function should only be called once
//
HRESULT CVDRowsetSource::Initialize(IRowset * pRowset)
{
    ASSERT_POINTER(pRowset, IRowset)

    if (!pRowset)
        return E_INVALIDARG;
        
    if (m_bool.fInitialized)
	{
		ASSERT(FALSE, VD_ASSERTMSG_ROWSRCALREADYINITIALIZED)
		return E_FAIL;
	}
    
    // mandatory interfaces (IAccessor is required for us)
    HRESULT hr = pRowset->QueryInterface(IID_IAccessor, (void**)&m_pAccessor);

    if (FAILED(hr))
        return VD_E_CANNOTGETMANDATORYINTERFACE;

    // mandatory interfaces (IRowsetLocate is required for us)
    hr = pRowset->QueryInterface(IID_IRowsetLocate, (void**)&m_pRowsetLocate);

    if (FAILED(hr))
    {
        m_pAccessor->Release();
        m_pAccessor = NULL;

        return VD_E_CANNOTGETMANDATORYINTERFACE;
    }

    // optional interfaces
    pRowset->QueryInterface(IID_IRowsetScroll, (void**)&m_pRowsetScroll);
    pRowset->QueryInterface(IID_IRowsetChange, (void**)&m_pRowsetChange);
    pRowset->QueryInterface(IID_IRowsetUpdate, (void**)&m_pRowsetUpdate);
    pRowset->QueryInterface(IID_IRowsetFind, (void**)&m_pRowsetFind);
    pRowset->QueryInterface(IID_IRowsetInfo, (void**)&m_pRowsetInfo);
    pRowset->QueryInterface(IID_IRowsetIdentity, (void**)&m_pRowsetIdentity);

    m_pRowset = pRowset;
    m_pRowset->AddRef();

    m_bool.fInitialized = TRUE;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\rssource.h ===
//---------------------------------------------------------------------------
// RowsetSource.h : CVDRowsetSource header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDROWSETSOURCE__
#define __CVDROWSETSOURCE__

class CVDNotifyDBEventsConnPtCont;

class CVDRowsetSource : public CVDNotifier
{
protected:
// Construction/Destruction
    CVDRowsetSource();
	virtual ~CVDRowsetSource();

// Initialization
    HRESULT Initialize(IRowset * pRowset);

public:
	BOOL IsRowsetValid(){return (m_pRowset && !m_bool.fRowsetReleased);}

	void SetRowsetReleasedFlag(){m_bool.fRowsetReleased = TRUE;}

    IRowset *           GetRowset() const {return m_pRowset;}     
    IAccessor *         GetAccessor() const {return m_pAccessor;}
    IRowsetLocate *     GetRowsetLocate() const {return m_pRowsetLocate;}
    IRowsetScroll *     GetRowsetScroll() const {return m_pRowsetScroll;}
    IRowsetChange *     GetRowsetChange() const {return m_pRowsetChange;}
    IRowsetUpdate *     GetRowsetUpdate() const {return m_pRowsetUpdate;}
    IRowsetFind *       GetRowsetFind() const {return m_pRowsetFind;}
    IRowsetInfo *       GetRowsetInfo() const {return m_pRowsetInfo;}
    IRowsetIdentity *   GetRowsetIdentity() const {return m_pRowsetIdentity;}

protected:
// Data members

    struct 
    {
		WORD fInitialized		    : 1;    // is rowset source initialized?
        WORD fRowsetReleased	    : 1;    // have we received a rowset release notification
    } m_bool;

    IRowset *       m_pRowset;          // [mandatory] interface IRowset
    IAccessor *     m_pAccessor;        // [mandatory] interface IAccessor
    IRowsetLocate * m_pRowsetLocate;    // [mandatory] interface IRowsetLocate
    IRowsetScroll * m_pRowsetScroll;    // [optional]  interface IRowsetScroll
    IRowsetChange * m_pRowsetChange;    // [optional]  interface IRowsetChange
    IRowsetUpdate * m_pRowsetUpdate;    // [optional]  interface IRowsetUpdate
    IRowsetFind *   m_pRowsetFind;      // [optional]  interface IRowsetFind
    IRowsetInfo *   m_pRowsetInfo;      // [optional]  interface IRowsetInfo
    IRowsetIdentity * m_pRowsetIdentity;// [optional]  interface IRowsetIdentity
};


#endif //__CVDROWSETSOURCE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\stream.h ===
//---------------------------------------------------------------------------
// Stream.h : CVDStream header file
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------


#ifndef __CVDSTREAM__
#define __CVDSTREAM__

#ifndef VD_DONT_IMPLEMENT_ISTREAM


interface IStreamEx : public IStream
{
public:
    virtual /* [local] */ HRESULT __stdcall CopyFrom(
        /* [unique][in] */ IStream __RPC_FAR *pstm,
        /* [in] */ ULARGE_INTEGER cb,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbWritten,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbRead) = 0;
};


class CVDStream : public IStreamEx
{
protected:
// Construction/Destruction
	CVDStream();
	virtual ~CVDStream();

public:
    static HRESULT Create(CVDEntryIDData * pEntryIDData, IStream * pStream, CVDStream ** ppVDStream, 
        CVDResourceDLL * pResourceDLL);
        
protected:
// Data members
    DWORD               m_dwRefCount;       // reference count
    CVDEntryIDData *    m_pEntryIDData;     // backwards pointer to CVDEntryIDData
    IStream *           m_pStream;          // data stream pointer
	CVDResourceDLL *	m_pResourceDLL;     // resource DLL

public:
    //=--------------------------------------------------------------------------=
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //=--------------------------------------------------------------------------=
    // IStream methods
    //
    STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD(Write)(const void *pv, ULONG cb, ULONG *pcbWritten);
    STDMETHOD(Seek)(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHOD(SetSize)(ULARGE_INTEGER libNewSize);
    STDMETHOD(CopyTo)(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHOD(Commit)(DWORD grfCommitFlags);
    STDMETHOD(Revert)(void);
    STDMETHOD(LockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(UnlockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHOD(Clone)(IStream **ppstm);

    //=--------------------------------------------------------------------------=
    // IStreamEx method
    //
    STDMETHOD(CopyFrom)(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbWritten, ULARGE_INTEGER *pcbRead);
};
         

#endif //VD_DONT_IMPLEMENT_ISTREAM

#endif //__CVDSTREAM__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\timeconv.h ===
//---------------------------------------------------------------------------
// TimeConv.h : Date time conversion routines
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#ifndef __TIMECONV_H__
#define __TIMECONV_H__

//-----------------------------------------------------------------------
// The following routines convert between differnt data/time formats
// they return TRUE if successful otherwise they return FALSE
//-----------------------------------------------------------------------

BOOL VDConvertToFileTime(DBTIMESTAMP * pDBTimeStamp, FILETIME *	pFileTime);
BOOL VDConvertToFileTime(DBDATE * pDBDate, FILETIME *	pFileTime);
BOOL VDConvertToFileTime(DATE * pDate, FILETIME * pFileTime);
BOOL VDConvertToFileTime(DBTIME * pDBTime, FILETIME * pFileTime);

BOOL VDConvertToDBTimeStamp(FILETIME *	pFileTime, DBTIMESTAMP * pDBTimeStamp);
BOOL VDConvertToDBTimeStamp(DATE * pDate, DBTIMESTAMP * pDBTimeStamp);

BOOL VDConvertToDBDate(FILETIME * pFileTime, DBDATE * pDBDate);
BOOL VDConvertToDBDate(DATE * pDate, DBDATE * pDBDate);

BOOL VDConvertToDBTime(FILETIME * pFileTime, DBTIME * pDBTime);
BOOL VDConvertToDBTime(DATE * pDate, DBTIME * pDBTime);

BOOL VDConvertToDate(FILETIME * pFileTime, DATE * pDate);
BOOL VDConvertToDate(DBTIMESTAMP * pDBTimeStamp, DATE * pDate);
BOOL VDConvertToDate(DBTIME * pDBTime, DATE * pDate);
BOOL VDConvertToDate(DBDATE * pDBDate, DATE * pDate);

#endif //__TIMECONV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\stream.cpp ===
//---------------------------------------------------------------------------
// Stream.cpp : Stream implementation
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"         

#ifndef VD_DONT_IMPLEMENT_ISTREAM

#include "Notifier.h"        
#include "RSColumn.h"
#include "RSSource.h"
#include "CursMain.h"        
#include "ColUpdat.h"
#include "CursPos.h"        
#include "EntryID.h"         
#include "fastguid.h"      
#include "Stream.h" 
#include "resource.h"         

SZTHISFILE

static const GUID IID_IStreamEx = {0xf74e27fc, 0x5a3, 0x11d0, {0x91, 0x95, 0x0, 0xa0, 0x24, 0x7b, 0x73, 0x5b}};


//=--------------------------------------------------------------------------=
// CVDStream - Constructor
//
CVDStream::CVDStream()
{
    m_dwRefCount    = 1;
    m_pEntryIDData  = NULL;
    m_pStream       = NULL;
	m_pResourceDLL  = NULL;

#ifdef _DEBUG
    g_cVDStreamCreated++;
#endif         
}

//=--------------------------------------------------------------------------=
// ~CVDStream - Destructor
//
CVDStream::~CVDStream()
{
    m_pEntryIDData->Release();

    if (m_pStream)
        m_pStream->Release();

#ifdef _DEBUG
    g_cVDStreamDestroyed++;
#endif         
}

//=--------------------------------------------------------------------------=
// Create - Create stream object
//=--------------------------------------------------------------------------=
// This function creates and initializes a new stream object
//
// Parameters:
//    pEntryIDData      - [in]  backwards pointer to CVDEntryIDData object
//    pStream           - [in]  data stream pointer
//    ppVDStream        - [out] a pointer in which to return pointer to 
//                              viaduct stream object
//    pResourceDLL      - [in]  a pointer which keeps track of resource DLL
//
// Output:
//    HRESULT - S_OK if successful
//              E_OUTOFMEMORY not enough memory to create object
//
// Notes:
//
HRESULT CVDStream::Create(CVDEntryIDData * pEntryIDData, IStream * pStream, CVDStream ** ppVDStream, 
    CVDResourceDLL * pResourceDLL)
{
    ASSERT_POINTER(pEntryIDData, CVDEntryIDData)
    ASSERT_POINTER(pStream, IStream*)
    ASSERT_POINTER(ppVDStream, CVDStream*)

    if (!pStream || !ppVDStream)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_IEntryID, pResourceDLL);
        return E_INVALIDARG;
    }

    *ppVDStream = NULL;

    CVDStream * pVDStream = new CVDStream();

    if (!pStream)
    {
        VDSetErrorInfo(IDS_ERR_OUTOFMEMORY, IID_IEntryID, pResourceDLL);
        return E_OUTOFMEMORY;
    }

    pEntryIDData->AddRef();
    pStream->AddRef();

    pVDStream->m_pEntryIDData   = pEntryIDData;
    pVDStream->m_pStream        = pStream;
    pVDStream->m_pResourceDLL   = pResourceDLL;

    *ppVDStream = pVDStream;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// IUnknown Methods
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IUnknown QueryInterface
//
HRESULT CVDStream::QueryInterface(REFIID riid, void **ppvObjOut)
{
    ASSERT_POINTER(ppvObjOut, IUnknown*)

    if (!ppvObjOut)
        return E_INVALIDARG;

    *ppvObjOut = NULL;

    switch (riid.Data1) 
    {
        QI_INTERFACE_SUPPORTED(this, IUnknown);
        QI_INTERFACE_SUPPORTED(this, IStream);
        QI_INTERFACE_SUPPORTED(this, IStreamEx);
    }                   

    if (NULL == *ppvObjOut)
        return E_NOINTERFACE;

    AddRef();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// IUnknown AddRef
//
ULONG CVDStream::AddRef(void)
{
   return ++m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// IUnknown Release
//
ULONG CVDStream::Release(void)
{
   if (1 > --m_dwRefCount)
   {
      delete this;
      return 0;
   }

   return m_dwRefCount;
}

//=--------------------------------------------------------------------------=
// IStream Methods
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// IStream Read
//
HRESULT CVDStream::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
	return m_pStream->Read(pv, cb, pcbRead);
}

//=--------------------------------------------------------------------------=
// IStream Write
//
HRESULT CVDStream::Write(const void *pv, ULONG cb, ULONG *pcbWritten)
{
	HRESULT hr = m_pStream->Write(pv, cb, pcbWritten);

    if (SUCCEEDED(hr))
        m_pEntryIDData->SetDirty(TRUE);

    return hr;
}

//=--------------------------------------------------------------------------=
// IStream Seek
//
HRESULT CVDStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    return m_pStream->Seek(dlibMove, dwOrigin, plibNewPosition);
}

//=--------------------------------------------------------------------------=
// IStream SetSize
//
HRESULT CVDStream::SetSize(ULARGE_INTEGER libNewSize)
{
    return m_pStream->SetSize(libNewSize);
}

//=--------------------------------------------------------------------------=
// IStream CopyTo
//
HRESULT CVDStream::CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    IStreamEx * pStreamEx;

    HRESULT hr = pstm->QueryInterface(IID_IStreamEx, (void**)&pStreamEx);

    if (SUCCEEDED(hr))
    {
        hr = pStreamEx->CopyFrom(m_pStream, cb, pcbWritten, pcbRead);
        pStreamEx->Release();
    }
    else
        hr = m_pStream->CopyTo(pstm, cb, pcbRead, pcbWritten);

    return hr;
}

//=--------------------------------------------------------------------------=
// IStream Commit
//
HRESULT CVDStream::Commit(DWORD grfCommitFlags)
{
    return m_pEntryIDData->Commit();
}

//=--------------------------------------------------------------------------=
// IStream Revert
//
HRESULT CVDStream::Revert(void)
{
    return m_pStream->Revert();
}

//=--------------------------------------------------------------------------=
// IStream LockRegion
//
HRESULT CVDStream::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return m_pStream->LockRegion(libOffset, cb, dwLockType);
}

//=--------------------------------------------------------------------------=
// IStream UnlockRegion
//
HRESULT CVDStream::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return m_pStream->UnlockRegion(libOffset, cb, dwLockType);
}

//=--------------------------------------------------------------------------=
// IStream Stat
//
HRESULT CVDStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    return m_pStream->Stat(pstatstg, grfStatFlag);
}

//=--------------------------------------------------------------------------=
// IStream Clone
//
HRESULT CVDStream::Clone(IStream **ppstm)
{
    ASSERT_POINTER(ppstm, IStream*)

    // check pointer
    if (!ppstm)
    {
        VDSetErrorInfo(IDS_ERR_INVALIDARG, IID_IEntryID, m_pResourceDLL);
        return E_INVALIDARG;
    }

    // init out parameter
    *ppstm = NULL;

    IStream * pStream;

    // clone stream
    HRESULT hr = m_pStream->Clone(&pStream);

    if (FAILED(hr))
    {
        VDSetErrorInfo(IDS_ERR_CLONEFAILED, IID_IEntryID, m_pResourceDLL);
        return hr;
    }

    CVDStream * pVDStream;

    // create viaduct stream object
    hr = CVDStream::Create(m_pEntryIDData, pStream, &pVDStream, m_pResourceDLL);

    // release reference on clone
    pStream->Release();

    if (FAILED(hr))
        return hr;

    *ppstm = pVDStream;

	return S_OK;
}

//=--------------------------------------------------------------------------=
// IStreamEx CopyFrom
//
HRESULT CVDStream::CopyFrom(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbWritten, ULARGE_INTEGER *pcbRead)
{
    HRESULT hr = pstm->CopyTo(m_pStream, cb, pcbRead, pcbWritten);

    if (SUCCEEDED(hr))
        m_pEntryIDData->SetDirty(TRUE);

    return hr;
}


#endif //VD_DONT_IMPLEMENT_ISTREAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\timeconv.cpp ===
//---------------------------------------------------------------------------
// TimeConv.cpp : Date time conversion routines
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "timeconv.h"
#include <math.h>
#include <limits.h>

// needed for ASSERTs and FAIL
//
SZTHISFILE

//-----------------------------------------------------------------------
// The following routines convert between differnt data/time formats
// they return TRUE if successful otherwise they return FALSE
//-----------------------------------------------------------------------

BOOL VDConvertToFileTime(DBTIMESTAMP * pDBTimeStamp, FILETIME *	pFileTime)
{
	ASSERT_POINTER(pFileTime, FILETIME);
	ASSERT_POINTER(pDBTimeStamp, DBTIMESTAMP);

	if (pFileTime		&& 
		pDBTimeStamp)
	{
		SYSTEMTIME st;
		st.wYear			= pDBTimeStamp->year;  
		st.wMonth			= pDBTimeStamp->month; 
		st.wDay				= pDBTimeStamp->day;          
		st.wDayOfWeek		= 0;   // ?       
		st.wHour			= pDBTimeStamp->hour;         
		st.wMinute			= pDBTimeStamp->minute;       
		st.wSecond			= pDBTimeStamp->second;       
		st.wMilliseconds	= (USHORT)(pDBTimeStamp->fraction / 1000000);
		return SystemTimeToFileTime(&st, pFileTime);
	}

	return FALSE;
}

BOOL VDConvertToFileTime(DBDATE * pDBDate, FILETIME *	pFileTime)
{
	ASSERT_POINTER(pFileTime, FILETIME);
	ASSERT_POINTER(pDBDate, DBDATE);

	if (pFileTime		&& 
		pDBDate)
	{
		SYSTEMTIME st;
		st.wYear			= pDBDate->year;  
		st.wMonth			= pDBDate->month; 
		st.wDay				= pDBDate->day;          
		st.wDayOfWeek		= 0;
		st.wHour			= 0;         
		st.wMinute			= 0;       
		st.wSecond			= 0;       
		st.wMilliseconds	= 0;
		return SystemTimeToFileTime(&st, pFileTime);
	}

	return FALSE;
}

BOOL VDConvertToFileTime(DBTIME * pDBTime, FILETIME * pFileTime)
{
	ASSERT_POINTER(pFileTime, FILETIME);
	ASSERT_POINTER(pDBTime, DBTIME);

	if (pFileTime		&& 
		pDBTime)
	{
		SYSTEMTIME st;
		st.wYear			= 1996; // any date will do since we
		st.wMonth			= 07; 	// are only interested in the time
		st.wDay				= 30;          
		st.wDayOfWeek		= 2;
		st.wHour			= pDBTime->hour;         
		st.wMinute			= pDBTime->minute;       
		st.wSecond			= pDBTime->second;       
		st.wMilliseconds	= 0;
		return SystemTimeToFileTime(&st, pFileTime);
	}

	return FALSE;
}

BOOL VDConvertToFileTime(DATE * pDate, FILETIME * pFileTime)
{
	ASSERT_POINTER(pDate, DATE);
	ASSERT_POINTER(pFileTime, FILETIME);

	if (pDate		&& 
		pFileTime)
	{
		WORD wFatDate;
		WORD wFatTime;
		if (VariantTimeToDosDateTime(*pDate, &wFatDate, &wFatTime))
			return DosDateTimeToFileTime(wFatDate, wFatTime, pFileTime);
	}

	return FALSE;
}

BOOL VDConvertToDBTimeStamp(FILETIME * pFileTime, DBTIMESTAMP * pDBTimeStamp)
{
	SYSTEMTIME st;
	ASSERT_POINTER(pFileTime, FILETIME);
	ASSERT_POINTER(pDBTimeStamp, DBTIMESTAMP);

	if (pFileTime		&& 
		pDBTimeStamp	&&
		FileTimeToSystemTime(pFileTime, &st))
	{
		pDBTimeStamp->year		= st.wYear;  
		pDBTimeStamp->month		= st.wMonth; 
		pDBTimeStamp->day		= st.wDay;          
		pDBTimeStamp->hour		= st.wHour;         
		pDBTimeStamp->minute	= st.wMinute;       
		pDBTimeStamp->second	= st.wSecond;       
		pDBTimeStamp->fraction	= (ULONG)st.wMilliseconds * 1000000;
		return TRUE;
	}

	return FALSE;

}

BOOL VDConvertToDBTimeStamp(DATE * pDate, DBTIMESTAMP * pDBTimeStamp)
{
	ASSERT_POINTER(pDate, DATE);
	ASSERT_POINTER(pDBTimeStamp, DBTIMESTAMP);

	if (pDate		&& 
		pDBTimeStamp)
	{
		FILETIME filetime;
		if (VDConvertToFileTime(pDate, &filetime))
			return VDConvertToDBTimeStamp(&filetime, pDBTimeStamp);
	}

	return FALSE;
}

BOOL VDConvertToDBDate(FILETIME * pFileTime, DBDATE * pDBDate)
{
	SYSTEMTIME st;
	ASSERT_POINTER(pFileTime, FILETIME);
	ASSERT_POINTER(pDBDate, DBDATE);

	if (pFileTime		&& 
		pDBDate			&&
		FileTimeToSystemTime(pFileTime, &st))
	{
		pDBDate->year		= st.wYear;  
		pDBDate->month		= st.wMonth; 
		pDBDate->day		= st.wDay;          
		return TRUE;
	}

	return FALSE;
}

BOOL VDConvertToDBDate(DATE * pDate, DBDATE * pDBDate)
{
	ASSERT_POINTER(pDate, DATE);
	ASSERT_POINTER(pDBDate, DBDATE);

	if (pDate		&& 
		pDBDate)
	{
		FILETIME filetime;
		if (VDConvertToFileTime(pDate, &filetime))
			return VDConvertToDBDate(&filetime, pDBDate);
	}

	return FALSE;
}

BOOL VDConvertToDBTime(FILETIME * pFileTime, DBTIME * pDBTime)
{
	SYSTEMTIME st;
	ASSERT_POINTER(pFileTime, FILETIME);
	ASSERT_POINTER(pDBTime, DBTIME);

	if (pFileTime		&& 
		pDBTime			&&
		FileTimeToSystemTime(pFileTime, &st))
	{
		pDBTime->hour		= st.wHour;         
		pDBTime->minute		= st.wMinute;       
		pDBTime->second		= st.wSecond;       
		return TRUE;
	}
	
	return FALSE;
}

BOOL VDConvertToDBTime(DATE * pDate, DBTIME * pDBTime)
{
	ASSERT_POINTER(pDate, DATE);
	ASSERT_POINTER(pDBTime, DBTIME);

	if (pDate		&& 
		pDBTime)
	{
		FILETIME filetime;
		if (VDConvertToFileTime(pDate, &filetime))
			return VDConvertToDBTime(&filetime, pDBTime);
	}

	return FALSE;
}

BOOL VDConvertToDate(FILETIME * pFileTime, DATE * pDate)
{
	ASSERT_POINTER(pDate, DATE);
	ASSERT_POINTER(pFileTime, FILETIME);

	if (pDate		&& 
		pFileTime)
	{
		WORD wFatDate;
		WORD wFatTime;
		if (FileTimeToDosDateTime(pFileTime, &wFatDate, &wFatTime))
			return DosDateTimeToVariantTime(wFatDate, wFatTime, pDate);
	}

	return FALSE;
}

BOOL VDConvertToDate(DBTIMESTAMP * pDBTimeStamp, DATE * pDate)
{
	ASSERT_POINTER(pDate, DATE);
	ASSERT_POINTER(pDBTimeStamp, DBTIMESTAMP);

	if (pDate		&& 
		pDBTimeStamp)
	{
		FILETIME fileTime;
		if (VDConvertToFileTime(pDBTimeStamp, &fileTime))
			return VDConvertToDate(&fileTime, pDate);
	}

	return FALSE;
}

BOOL VDConvertToDate(DBTIME * pDBTime, DATE * pDate)
{
	ASSERT_POINTER(pDate, DATE);
	ASSERT_POINTER(pDBTime, DBTIME);

	if (pDate		&& 
		pDBTime)
	{
		FILETIME fileTime;
		if (VDConvertToFileTime(pDBTime, &fileTime))
		{
			DATE date;
			if (VDConvertToDate(&fileTime, &date))
			{
				DATE dateIntegerPart;
				// return only the time (fractional part of double)
				*pDate = modf(date, &dateIntegerPart);
			}
		}
	}

	return FALSE;
}

BOOL VDConvertToDate(DBDATE * pDBDate, DATE * pDate)
{
	ASSERT_POINTER(pDate, DATE);
	ASSERT_POINTER(pDBDate, DBDATE);

	if (pDate		&& 
		pDBDate)
	{
		FILETIME fileTime;
		if (VDConvertToFileTime(pDBDate, &fileTime))
			return VDConvertToDate(&fileTime, pDate);
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\transact.h ===
//.-------------------------------------------------------------------------
//.
//.  Microsoft Windows
//.  Copyright (C) Microsoft Corporation, 1995.
//.
//.  File: transact.idl
//.
//.  Contents: The basic transaction interfaces and types.
//.
//.--------------------------------------------------------------------------


/* File created by MIDL compiler version 2.00.0102 */
/* at Tue Nov 21 16:54:32 1995
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __transact_h__
#define __transact_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ITransaction_FWD_DEFINED__
#define __ITransaction_FWD_DEFINED__
typedef interface ITransaction ITransaction;
#endif 	/* __ITransaction_FWD_DEFINED__ */


#ifndef __ITransactionDispenser_FWD_DEFINED__
#define __ITransactionDispenser_FWD_DEFINED__
typedef interface ITransactionDispenser ITransactionDispenser;
#endif 	/* __ITransactionDispenser_FWD_DEFINED__ */


#ifndef __ITransactionOptions_FWD_DEFINED__
#define __ITransactionOptions_FWD_DEFINED__
typedef interface ITransactionOptions ITransactionOptions;
#endif 	/* __ITransactionOptions_FWD_DEFINED__ */


#ifndef __ITransactionOutcomeEvents_FWD_DEFINED__
#define __ITransactionOutcomeEvents_FWD_DEFINED__
typedef interface ITransactionOutcomeEvents ITransactionOutcomeEvents;
#endif 	/* __ITransactionOutcomeEvents_FWD_DEFINED__ */


#ifndef __ITransactionCompletionEvents_FWD_DEFINED__
#define __ITransactionCompletionEvents_FWD_DEFINED__
typedef interface ITransactionCompletionEvents ITransactionCompletionEvents;
#endif 	/* __ITransactionCompletionEvents_FWD_DEFINED__ */


/* header files for imported files */

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Tue Nov 21 16:54:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */

			/* size is 0 */



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __BasicTransactionTypes_INTERFACE_DEFINED__
#define __BasicTransactionTypes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: BasicTransactionTypes
 * at Tue Nov 21 16:54:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][local] */ 


			/* size is 16 */
typedef struct  BOID
    {
    BYTE rgb[ 16 ];
    }	BOID;

#define BOID_NULL (*((BOID*)(&IID_NULL)))

#define MAX_TRAN_DESC 40		// used by XACTOPT via midl - see transact.idl 
			/* size is 16 */
typedef BOID XACTUOW;

			/* size is 4 */
typedef LONG ISOLEVEL;

#if defined(_WIN32)
			/* size is 2 */
typedef 
enum ISOLATIONLEVEL
    {	ISOLATIONLEVEL_UNSPECIFIED	= 0xffffffff,
	ISOLATIONLEVEL_CHAOS	= 0x10,
	ISOLATIONLEVEL_READUNCOMMITTED	= 0x100,
	ISOLATIONLEVEL_BROWSE	= 0x100,
	ISOLATIONLEVEL_CURSORSTABILITY	= 0x1000,
	ISOLATIONLEVEL_READCOMMITTED	= 0x1000,
	ISOLATIONLEVEL_REPEATABLEREAD	= 0x10000,
	ISOLATIONLEVEL_SERIALIZABLE	= 0x100000,
	ISOLATIONLEVEL_ISOLATED	= 0x100000
    }	ISOLATIONLEVEL;

#else
#define ISOLATIONLEVEL_UNSPECIFIED      0xFFFFFFFF
#define ISOLATIONLEVEL_CHAOS            0x00000010
#define ISOLATIONLEVEL_READUNCOMMITTED  0x00000100
#define ISOLATIONLEVEL_BROWSE           0x00000100
#define ISOLATIONLEVEL_CURSORSTABILITY  0x00001000
#define ISOLATIONLEVEL_READCOMMITTED    0x00001000
#define ISOLATIONLEVEL_REPEATABLEREAD   0x00010000
#define ISOLATIONLEVEL_SERIALIZABLE     0x00100000
#define ISOLATIONLEVEL_ISOLATED         0x00100000
#endif
			/* size is 40 */
typedef struct  XACTTRANSINFO
    {
    XACTUOW uow;
    ISOLEVEL isoLevel;
    ULONG isoFlags;
    DWORD grfTCSupported;
    DWORD grfRMSupported;
    DWORD grfTCSupportedRetaining;
    DWORD grfRMSupportedRetaining;
    }	XACTTRANSINFO;

			/* size is 36 */
typedef struct  XACTSTATS
    {
    ULONG cOpen;
    ULONG cCommitting;
    ULONG cCommitted;
    ULONG cAborting;
    ULONG cAborted;
    ULONG cInDoubt;
    ULONG cHeuristicDecision;
    FILETIME timeTransactionsUp;
    }	XACTSTATS;

			/* size is 2 */
typedef 
enum ISOFLAG
    {	ISOFLAG_RETAIN_COMMIT_DC	= 1,
	ISOFLAG_RETAIN_COMMIT	= 2,
	ISOFLAG_RETAIN_COMMIT_NO	= 3,
	ISOFLAG_RETAIN_ABORT_DC	= 4,
	ISOFLAG_RETAIN_ABORT	= 8,
	ISOFLAG_RETAIN_ABORT_NO	= 12,
	ISOFLAG_RETAIN_DONTCARE	= ISOFLAG_RETAIN_COMMIT_DC | ISOFLAG_RETAIN_ABORT_DC,
	ISOFLAG_RETAIN_BOTH	= ISOFLAG_RETAIN_COMMIT | ISOFLAG_RETAIN_ABORT,
	ISOFLAG_RETAIN_NONE	= ISOFLAG_RETAIN_COMMIT_NO | ISOFLAG_RETAIN_ABORT_NO,
	ISOFLAG_OPTIMISTIC	= 16
    }	ISOFLAG;

			/* size is 2 */
typedef 
enum XACTTC
    {	XACTTC_SYNC_PHASEONE	= 1,
	XACTTC_SYNC_PHASETWO	= 2,
	XACTTC_SYNC	= 2,
	XACTTC_ASYNC_PHASEONE	= 4
    }	XACTTC;

			/* size is 2 */
typedef 
enum XACTRM
    {	XACTRM_OPTIMISTICLASTWINS	= 1,
	XACTRM_NOREADONLYPREPARES	= 2
    }	XACTRM;

			/* size is 2 */
typedef 
enum XACTCONST
    {	XACTCONST_TIMEOUTINFINITE	= 0
    }	XACTCONST;

			/* size is 2 */
typedef 
enum XACTHEURISTIC
    {	XACTHEURISTIC_ABORT	= 1,
	XACTHEURISTIC_COMMIT	= 2,
	XACTHEURISTIC_DAMAGE	= 3,
	XACTHEURISTIC_DANGER	= 4
    }	XACTHEURISTIC;

#if defined(_WIN32)
			/* size is 2 */
typedef 
enum XACTSTAT
    {	XACTSTAT_NONE	= 0,
	XACTSTAT_OPENNORMAL	= 0x1,
	XACTSTAT_OPENREFUSED	= 0x2,
	XACTSTAT_PREPARING	= 0x4,
	XACTSTAT_PREPARED	= 0x8,
	XACTSTAT_PREPARERETAINING	= 0x10,
	XACTSTAT_PREPARERETAINED	= 0x20,
	XACTSTAT_COMMITTING	= 0x40,
	XACTSTAT_COMMITRETAINING	= 0x80,
	XACTSTAT_ABORTING	= 0x100,
	XACTSTAT_ABORTED	= 0x200,
	XACTSTAT_COMMITTED	= 0x400,
	XACTSTAT_HEURISTIC_ABORT	= 0x800,
	XACTSTAT_HEURISTIC_COMMIT	= 0x1000,
	XACTSTAT_HEURISTIC_DAMAGE	= 0x2000,
	XACTSTAT_HEURISTIC_DANGER	= 0x4000,
	XACTSTAT_FORCED_ABORT	= 0x8000,
	XACTSTAT_FORCED_COMMIT	= 0x10000,
	XACTSTAT_INDOUBT	= 0x20000,
	XACTSTAT_CLOSED	= 0x40000,
	XACTSTAT_OPEN	= 0x3,
	XACTSTAT_NOTPREPARED	= 0x7ffc3,
	XACTSTAT_ALL	= 0x7ffff
    }	XACTSTAT;

#else
#define XACTSTAT_NONE               0x00000000
#define XACTSTAT_OPENNORMAL         0x00000001
#define XACTSTAT_OPENREFUSED        0x00000002
#define XACTSTAT_PREPARING          0x00000004
#define XACTSTAT_PREPARED           0x00000008
#define XACTSTAT_PREPARERETAINING   0x00000010
#define XACTSTAT_PREPARERETAINED    0x00000020
#define XACTSTAT_COMMITTING         0x00000040
#define XACTSTAT_COMMITRETAINING    0x00000080
#define XACTSTAT_ABORTING           0x00000100
#define XACTSTAT_ABORTED            0x00000200
#define XACTSTAT_COMMITTED          0x00000400
#define XACTSTAT_HEURISTIC_ABORT    0x00000800
#define XACTSTAT_HEURISTIC_COMMIT   0x00001000
#define XACTSTAT_HEURISTIC_DAMAGE   0x00002000
#define XACTSTAT_HEURISTIC_DANGER   0x00004000
#define XACTSTAT_FORCED_ABORT       0x00008000
#define XACTSTAT_FORCED_COMMIT      0x00010000
#define XACTSTAT_INDOUBT            0x00020000
#define XACTSTAT_CLOSED             0x00040000
#define XACTSTAT_OPEN               0x00000003
#define XACTSTAT_NOTPREPARED        0x0007FFC3
#define XACTSTAT_ALL                0x0007FFFF
#endif
			/* size is 44 */
typedef struct  XACTOPT
    {
    ULONG ulTimeout;
    unsigned char szDescription[ 40 ];
    }	XACTOPT;



extern RPC_IF_HANDLE BasicTransactionTypes_v0_0_c_ifspec;
extern RPC_IF_HANDLE BasicTransactionTypes_v0_0_s_ifspec;
#endif /* __BasicTransactionTypes_INTERFACE_DEFINED__ */

#ifndef __ITransaction_INTERFACE_DEFINED__
#define __ITransaction_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransaction
 * at Tue Nov 21 16:54:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransaction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITransaction : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Commit( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfTC,
            /* [in] */ DWORD grfRM) = 0;
        
        virtual HRESULT __stdcall Abort( 
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ BOOL fAsync) = 0;
        
        virtual HRESULT __stdcall GetTransactionInfo( 
            /* [out] */ XACTTRANSINFO __RPC_FAR *pinfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ITransaction __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ITransaction __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ITransaction __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Commit )( 
            ITransaction __RPC_FAR * This,
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfTC,
            /* [in] */ DWORD grfRM);
        
        HRESULT ( __stdcall __RPC_FAR *Abort )( 
            ITransaction __RPC_FAR * This,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ BOOL fAsync);
        
        HRESULT ( __stdcall __RPC_FAR *GetTransactionInfo )( 
            ITransaction __RPC_FAR * This,
            /* [out] */ XACTTRANSINFO __RPC_FAR *pinfo);
        
    } ITransactionVtbl;

    interface ITransaction
    {
        CONST_VTBL struct ITransactionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransaction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransaction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransaction_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransaction_Commit(This,fRetaining,grfTC,grfRM)	\
    (This)->lpVtbl -> Commit(This,fRetaining,grfTC,grfRM)

#define ITransaction_Abort(This,pboidReason,fRetaining,fAsync)	\
    (This)->lpVtbl -> Abort(This,pboidReason,fRetaining,fAsync)

#define ITransaction_GetTransactionInfo(This,pinfo)	\
    (This)->lpVtbl -> GetTransactionInfo(This,pinfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ITransaction_Commit_Proxy( 
    ITransaction __RPC_FAR * This,
    /* [in] */ BOOL fRetaining,
    /* [in] */ DWORD grfTC,
    /* [in] */ DWORD grfRM);


void __RPC_STUB ITransaction_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransaction_Abort_Proxy( 
    ITransaction __RPC_FAR * This,
    /* [in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ BOOL fRetaining,
    /* [in] */ BOOL fAsync);


void __RPC_STUB ITransaction_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransaction_GetTransactionInfo_Proxy( 
    ITransaction __RPC_FAR * This,
    /* [out] */ XACTTRANSINFO __RPC_FAR *pinfo);


void __RPC_STUB ITransaction_GetTransactionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransaction_INTERFACE_DEFINED__ */


#ifndef __ITransactionDispenser_INTERFACE_DEFINED__
#define __ITransactionDispenser_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionDispenser
 * at Tue Nov 21 16:54:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransactionDispenser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITransactionDispenser : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetOptionsObject( 
            /* [out] */ ITransactionOptions __RPC_FAR *__RPC_FAR *ppOptions) = 0;
        
        virtual HRESULT __stdcall BeginTransaction( 
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ ISOLEVEL isoLevel,
            /* [in] */ ULONG isoFlags,
            /* [in] */ ITransactionOptions __RPC_FAR *pOptions,
            /* [out] */ ITransaction __RPC_FAR *__RPC_FAR *ppTransaction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionDispenserVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ITransactionDispenser __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ITransactionDispenser __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ITransactionDispenser __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetOptionsObject )( 
            ITransactionDispenser __RPC_FAR * This,
            /* [out] */ ITransactionOptions __RPC_FAR *__RPC_FAR *ppOptions);
        
        HRESULT ( __stdcall __RPC_FAR *BeginTransaction )( 
            ITransactionDispenser __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ ISOLEVEL isoLevel,
            /* [in] */ ULONG isoFlags,
            /* [in] */ ITransactionOptions __RPC_FAR *pOptions,
            /* [out] */ ITransaction __RPC_FAR *__RPC_FAR *ppTransaction);
        
    } ITransactionDispenserVtbl;

    interface ITransactionDispenser
    {
        CONST_VTBL struct ITransactionDispenserVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionDispenser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionDispenser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionDispenser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionDispenser_GetOptionsObject(This,ppOptions)	\
    (This)->lpVtbl -> GetOptionsObject(This,ppOptions)

#define ITransactionDispenser_BeginTransaction(This,punkOuter,isoLevel,isoFlags,pOptions,ppTransaction)	\
    (This)->lpVtbl -> BeginTransaction(This,punkOuter,isoLevel,isoFlags,pOptions,ppTransaction)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ITransactionDispenser_GetOptionsObject_Proxy( 
    ITransactionDispenser __RPC_FAR * This,
    /* [out] */ ITransactionOptions __RPC_FAR *__RPC_FAR *ppOptions);


void __RPC_STUB ITransactionDispenser_GetOptionsObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionDispenser_BeginTransaction_Proxy( 
    ITransactionDispenser __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *punkOuter,
    /* [in] */ ISOLEVEL isoLevel,
    /* [in] */ ULONG isoFlags,
    /* [in] */ ITransactionOptions __RPC_FAR *pOptions,
    /* [out] */ ITransaction __RPC_FAR *__RPC_FAR *ppTransaction);


void __RPC_STUB ITransactionDispenser_BeginTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionDispenser_INTERFACE_DEFINED__ */


#ifndef __ITransactionOptions_INTERFACE_DEFINED__
#define __ITransactionOptions_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionOptions
 * at Tue Nov 21 16:54:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransactionOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITransactionOptions : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SetOptions( 
            /* [in] */ XACTOPT __RPC_FAR *pOptions) = 0;
        
        virtual HRESULT __stdcall GetOptions( 
            /* [out][in] */ XACTOPT __RPC_FAR *pOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionOptionsVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ITransactionOptions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ITransactionOptions __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ITransactionOptions __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *SetOptions )( 
            ITransactionOptions __RPC_FAR * This,
            /* [in] */ XACTOPT __RPC_FAR *pOptions);
        
        HRESULT ( __stdcall __RPC_FAR *GetOptions )( 
            ITransactionOptions __RPC_FAR * This,
            /* [out][in] */ XACTOPT __RPC_FAR *pOptions);
        
    } ITransactionOptionsVtbl;

    interface ITransactionOptions
    {
        CONST_VTBL struct ITransactionOptionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionOptions_SetOptions(This,pOptions)	\
    (This)->lpVtbl -> SetOptions(This,pOptions)

#define ITransactionOptions_GetOptions(This,pOptions)	\
    (This)->lpVtbl -> GetOptions(This,pOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ITransactionOptions_SetOptions_Proxy( 
    ITransactionOptions __RPC_FAR * This,
    /* [in] */ XACTOPT __RPC_FAR *pOptions);


void __RPC_STUB ITransactionOptions_SetOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionOptions_GetOptions_Proxy( 
    ITransactionOptions __RPC_FAR * This,
    /* [out][in] */ XACTOPT __RPC_FAR *pOptions);


void __RPC_STUB ITransactionOptions_GetOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionOptions_INTERFACE_DEFINED__ */


#ifndef __ITransactionOutcomeEvents_INTERFACE_DEFINED__
#define __ITransactionOutcomeEvents_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionOutcomeEvents
 * at Tue Nov 21 16:54:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransactionOutcomeEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITransactionOutcomeEvents : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Committed( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT __stdcall Aborted( 
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT __stdcall HeuristicDecision( 
            /* [in] */ DWORD dwDecision,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT __stdcall Indoubt( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionOutcomeEventsVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ITransactionOutcomeEvents __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ITransactionOutcomeEvents __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Committed )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
        HRESULT ( __stdcall __RPC_FAR *Aborted )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
        HRESULT ( __stdcall __RPC_FAR *HeuristicDecision )( 
            ITransactionOutcomeEvents __RPC_FAR * This,
            /* [in] */ DWORD dwDecision,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ HRESULT hr);
        
        HRESULT ( __stdcall __RPC_FAR *Indoubt )( 
            ITransactionOutcomeEvents __RPC_FAR * This);
        
    } ITransactionOutcomeEventsVtbl;

    interface ITransactionOutcomeEvents
    {
        CONST_VTBL struct ITransactionOutcomeEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionOutcomeEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionOutcomeEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionOutcomeEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionOutcomeEvents_Committed(This,fRetaining,pNewUOW,hr)	\
    (This)->lpVtbl -> Committed(This,fRetaining,pNewUOW,hr)

#define ITransactionOutcomeEvents_Aborted(This,pboidReason,fRetaining,pNewUOW,hr)	\
    (This)->lpVtbl -> Aborted(This,pboidReason,fRetaining,pNewUOW,hr)

#define ITransactionOutcomeEvents_HeuristicDecision(This,dwDecision,pboidReason,hr)	\
    (This)->lpVtbl -> HeuristicDecision(This,dwDecision,pboidReason,hr)

#define ITransactionOutcomeEvents_Indoubt(This)	\
    (This)->lpVtbl -> Indoubt(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ITransactionOutcomeEvents_Committed_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This,
    /* [in] */ BOOL fRetaining,
    /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionOutcomeEvents_Committed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionOutcomeEvents_Aborted_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This,
    /* [in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ BOOL fRetaining,
    /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionOutcomeEvents_Aborted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionOutcomeEvents_HeuristicDecision_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This,
    /* [in] */ DWORD dwDecision,
    /* [in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionOutcomeEvents_HeuristicDecision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionOutcomeEvents_Indoubt_Proxy( 
    ITransactionOutcomeEvents __RPC_FAR * This);


void __RPC_STUB ITransactionOutcomeEvents_Indoubt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionOutcomeEvents_INTERFACE_DEFINED__ */


#ifndef __ITransactionCompletionEvents_INTERFACE_DEFINED__
#define __ITransactionCompletionEvents_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITransactionCompletionEvents
 * at Tue Nov 21 16:54:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_ITransactionCompletionEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ITransactionCompletionEvents : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Committed( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT __stdcall Aborted( 
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT __stdcall HeuristicDecision( 
            /* [in] */ DWORD dwDecision,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ HRESULT hr) = 0;
        
        virtual HRESULT __stdcall Indoubt( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransactionCompletionEventsVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            ITransactionCompletionEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            ITransactionCompletionEvents __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            ITransactionCompletionEvents __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *Committed )( 
            ITransactionCompletionEvents __RPC_FAR * This,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
        HRESULT ( __stdcall __RPC_FAR *Aborted )( 
            ITransactionCompletionEvents __RPC_FAR * This,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
            /* [in] */ HRESULT hr);
        
        HRESULT ( __stdcall __RPC_FAR *HeuristicDecision )( 
            ITransactionCompletionEvents __RPC_FAR * This,
            /* [in] */ DWORD dwDecision,
            /* [in] */ BOID __RPC_FAR *pboidReason,
            /* [in] */ HRESULT hr);
        
        HRESULT ( __stdcall __RPC_FAR *Indoubt )( 
            ITransactionCompletionEvents __RPC_FAR * This);
        
    } ITransactionCompletionEventsVtbl;

    interface ITransactionCompletionEvents
    {
        CONST_VTBL struct ITransactionCompletionEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransactionCompletionEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransactionCompletionEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransactionCompletionEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransactionCompletionEvents_Committed(This,fRetaining,pNewUOW,hr)	\
    (This)->lpVtbl -> Committed(This,fRetaining,pNewUOW,hr)

#define ITransactionCompletionEvents_Aborted(This,pboidReason,fRetaining,pNewUOW,hr)	\
    (This)->lpVtbl -> Aborted(This,pboidReason,fRetaining,pNewUOW,hr)

#define ITransactionCompletionEvents_HeuristicDecision(This,dwDecision,pboidReason,hr)	\
    (This)->lpVtbl -> HeuristicDecision(This,dwDecision,pboidReason,hr)

#define ITransactionCompletionEvents_Indoubt(This)	\
    (This)->lpVtbl -> Indoubt(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall ITransactionCompletionEvents_Committed_Proxy( 
    ITransactionCompletionEvents __RPC_FAR * This,
    /* [in] */ BOOL fRetaining,
    /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionCompletionEvents_Committed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionCompletionEvents_Aborted_Proxy( 
    ITransactionCompletionEvents __RPC_FAR * This,
    /* [in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ BOOL fRetaining,
    /* [in] */ XACTUOW __RPC_FAR *pNewUOW,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionCompletionEvents_Aborted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionCompletionEvents_HeuristicDecision_Proxy( 
    ITransactionCompletionEvents __RPC_FAR * This,
    /* [in] */ DWORD dwDecision,
    /* [in] */ BOID __RPC_FAR *pboidReason,
    /* [in] */ HRESULT hr);


void __RPC_STUB ITransactionCompletionEvents_HeuristicDecision_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall ITransactionCompletionEvents_Indoubt_Proxy( 
    ITransactionCompletionEvents __RPC_FAR * This);


void __RPC_STUB ITransactionCompletionEvents_Indoubt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransactionCompletionEvents_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0011
 * at Tue Nov 21 16:54:32 1995
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


#define XACT_E_FIRST                    0x8004D000
#define XACT_E_LAST                     0x8004D01E
#define XACT_S_FIRST                    0x0004D000
#define XACT_S_LAST                     0x0004D009

#define XACT_E_ABORTED                  0x8004D019
#define XACT_E_ALREADYOTHERSINGLEPHASE  0x8004D000
#define XACT_E_ALREADYINPROGRESS        0x8004D018
#define XACT_E_CANTRETAIN               0x8004D001
#define XACT_E_COMMITFAILED             0x8004D002
#define XACT_E_COMMITPREVENTED          0x8004D003
#define XACT_E_CONNECTION_DENIED        0x8004D01D
#define XACT_E_CONNECTION_DOWN          0x8004D01C
#define XACT_E_HEURISTICABORT           0x8004D004
#define XACT_E_HEURISTICCOMMIT          0x8004D005
#define XACT_E_HEURISTICDAMAGE          0x8004D006
#define XACT_E_HEURISTICDANGER          0x8004D007
#define XACT_E_INDOUBT                  0x8004D016
#define XACT_E_INVALIDCOOKIE            0x8004D015
#define XACT_E_ISOLATIONLEVEL           0x8004D008
#define XACT_E_LOGFULL                  0x8004D01A
#define XACT_E_NOASYNC                  0x8004D009
#define XACT_E_NOENLIST                 0x8004D00A
#define XACT_E_NOIMPORTOBJECT           0x8004D014
#define XACT_E_NOISORETAIN              0x8004D00B
#define XACT_E_NORESOURCE               0x8004D00C
#define XACT_E_NOTCURRENT               0x8004D00D
#define XACT_E_NOTIMEOUT                0x8004D017
#define XACT_E_NOTRANSACTION            0x8004D00E
#define XACT_E_NOTSUPPORTED             0x8004D00F
#define XACT_E_REENLISTTIMEOUT          0x8004D01E
#define XACT_E_TMNOTAVAILABLE           0x8004D01B
#define XACT_E_UNKNOWNRMGRID            0x8004D010
#define XACT_E_WRONGSTATE               0x8004D011
#define XACT_E_WRONGUOW                 0x8004D012
#define XACT_E_XTIONEXISTS              0x8004D013

#define XACT_S_ABORTING                 0x0004D008
#define XACT_S_ALLNORETAIN              0x0004D007
#define XACT_S_ASYNC                    0x0004D000
#define XACT_S_DEFECT                   0x0004D001
#define XACT_S_OKINFORM                 0x0004D004
#define XACT_S_MADECHANGESCONTENT       0x0004D005
#define XACT_S_MADECHANGESINFORM        0x0004D006
#define XACT_S_READONLY                 0x0004D002
#define XACT_S_SINGLEPHASE              0x0004D009
#define XACT_S_SOMENORETAIN             0x0004D003


extern RPC_IF_HANDLE __MIDL__intf_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0011_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif

///////////////////////////////////////////////////////////////////////
//
// IID definitions for interfaces defined in this header file
//

#if !defined(_transact_iid_) && defined(INITGUID)
#define      _transact_iid_
const IID IID_ITransaction = {0x0fb15084,0xaf41,0x11ce,{0xbd,0x2b,0x20,0x4c,0x4f,0x4f,0x50,0x20}};
const IID IID_ITransactionDispenser = {0x3A6AD9E1,0x23B9,0x11cf,{0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD}};
const IID IID_ITransactionOptions = {0x3A6AD9E0,0x23B9,0x11cf,{0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD}};
const IID IID_ITransactionOutcomeEvents = {0x3A6AD9E2,0x23B9,0x11cf,{0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD}};
const IID IID_ITransactionCompletionEvents = {0xB38D5220,0x23CE,0x11cf,{0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD}};
#endif

///////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\util.cpp ===
//=--------------------------------------------------------------------------=
// Util.C
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains routines that we will find useful.
//
#include "stdafx.h"   // not really used here, but NT Build env. doesn't like
                      // some files in a dir to have pre-comp hdrs & some not

#include "IPServer.H"

#include "Globals.H"
#include "Util.H"


SZTHISFILE


//=---------------------------------------------------------------------------=
// overloaded new
//=---------------------------------------------------------------------------=
// for the retail case, we'll just use the win32 Local* heap management
// routines for speed and size
//
// Parameters:
//    size_t         - [in] what size do we alloc
//
// Output:
//    VOID *         - new memoery.
//
// Notes:
//
void * _cdecl operator new
(
    size_t    size
)
{
    return malloc(size);
}


//=---------------------------------------------------------------------------=
// overloaded delete
//=---------------------------------------------------------------------------=
// retail case just uses win32 Local* heap mgmt functions
//
// Parameters:
//    void *        - [in] free me!
//
// Notes:
//
void _cdecl operator delete ( void *ptr)
{

    free(ptr);
}

//=--------------------------------------------------------------------------=
// MakeWideFromAnsi
//=--------------------------------------------------------------------------=
// given a string, make a BSTR out of it.
//
// Parameters:
//    LPSTR         - [in]
//    BYTE          - [in]
//
// Output:
//    LPWSTR        - needs to be cast to final desired result
//
// Notes:
//
LPWSTR MakeWideStrFromAnsi
(
    LPSTR psz,
    BYTE  bType
)
{
    LPWSTR pwsz;
    int i;

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length of the required BSTR
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate the widestr, +1 for terminating null
    //
    switch (bType) {
      case STR_BSTR:
        pwsz = (LPWSTR) SysAllocStringLen(NULL, i);
        break;
      case STR_OLESTR:
        pwsz = (LPWSTR) g_pMalloc->Alloc(i * sizeof(WCHAR));
        break;
      default:
        FAIL("Bogus String Type.  Somebody needs to learn how to program");
    }

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}

//=--------------------------------------------------------------------------=
// MakeWideStrFromResId
//=--------------------------------------------------------------------------=
// given a resource ID, load it, and allocate a wide string for it.
//
// Parameters:
//    WORD            - [in] resource id.
//    BYTE            - [in] type of string desired.
//
// Output:
//    LPWSTR          - needs to be cast to desired string type.
//
// Notes:
//
/*LPWSTR MakeWideStrFromResourceId
(
    WORD    wId,
    BYTE    bType
)
{
    int i;

    char szTmp[512];

    // load the string from the resources.
    //
    i = LoadString(GetResourceHandle(), wId, szTmp, 512);
    if (!i) return NULL;

    return MakeWideStrFromAnsi(szTmp, bType);
}
*/
//=--------------------------------------------------------------------------=
// MakeWideStrFromWide
//=--------------------------------------------------------------------------=
// given a wide string, make a new wide string with it of the given type.
//
// Parameters:
//    LPWSTR            - [in]  current wide str.
//    BYTE              - [in]  desired type of string.
//
// Output:
//    LPWSTR
//
// Notes:
//
LPWSTR MakeWideStrFromWide
(
    LPWSTR pwsz,
    BYTE   bType
)
{
    LPWSTR pwszTmp;
    int i;

    if (!pwsz) return NULL;

    // just copy the string, depending on what type they want.
    //
    switch (bType) {
      case STR_OLESTR:
        i = lstrlenW(pwsz);
        pwszTmp = (LPWSTR)g_pMalloc->Alloc((i * sizeof(WCHAR)) + 1);
        if (!pwszTmp) return NULL;
        memcpy(pwszTmp, pwsz, (sizeof(WCHAR) * i) + 1);
        break;

      case STR_BSTR:
        pwszTmp = (LPWSTR)SysAllocString(pwsz);
        break;
    }

    return pwszTmp;
}

//=--------------------------------------------------------------------------=
// StringFromGuidA
//=--------------------------------------------------------------------------=
// returns an ANSI string from a CLSID or GUID
//
// Parameters:
//    REFIID               - [in]  clsid to make string out of.
//    LPSTR                - [in]  buffer in which to place resultant GUID.
//
// Output:
//    int                  - number of chars written out.
//
// Notes:
//
int StringFromGuidA
(
    REFIID   riid,
    LPSTR    pszBuf
)
{
    return wsprintf((char *)pszBuf, "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}", riid.Data1, 
            riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], 
            riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7]);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\version.h ===
#define rmj		1
#define rmm		4212	// 1st 2 digits for month (e.g. July/96 = 31)
						// last 2 digits for day of month 
						// e.g. August 12, 1996 = 3212
#define rup		0		// zero unless multiple builds on same day
#define szVerName	""
#define szVerUser	"SHERIDAN"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2cenu\version.h ===
#define rmj		1
#define rmm		4212	// 1st 2 digits for month (e.g. July/96 = 31)
						// last 2 digits for day of month 
						// e.g. August 12, 1996 = 3212
#define rup		0		// zero unless multiple builds on same day
#define szVerName	""
#define szVerUser	"SHERIDAN"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\versstr.h ===
//----------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       versstr.h
//
//  Contents:   Defines required for Mac & Win Version resource for Forms3 components.
//
//----------------------------------------------------------------------------

#include "version.h"

// The following hack to build both the file version stamps
// from the same data was stolen from DART,
#if (rmm < 10)
#define rmmpad "0"
#else
#define rmmpad
#endif

#define _RELEASE_BUILD 1

#if defined(_RELEASE_BUILD) && DBG == 0
#define VER_STR1(a,b,c)     #a ".0"
#else
#  if defined(VER_ASYCPICT_FORMAT)
#define VER_STR1(a,b,c)     #a "." rmmpad #b "." #c ".0"
#  else
#define VER_STR1(a,b,c)     #a ".00." rmmpad #b "." #c
#  endif
#endif

#if defined(VER_ASYCPICT_FORMAT)
#define VER_VERSION         rmj, rmm, rup, 0
#else
#define VER_VERSION         rmj, 0, rmm, rup
#endif

#define VER_STR2(a,b,c)     VER_STR1(a,b,c)

#define VER_VERSION_STR     VER_STR2(rmj,rmm,rup)
#define VER_COMMENT         szVerName

#ifdef VER_PRIVATE_BUILD_STR
#define VER_PRIVATE_BUILD_FLG   VS_FF_PRIVATEBUILD | VS_FF_SPECIALBUILD
#else
#define VER_PRIVATE_BUILD_FLG   0
#endif

#if DBG==1
#define VER_DEBUG_BUILD_FLG     VS_FF_DEBUG
#else
#define VER_DEBUG_BUILD_FLG     0
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2cenu\versstr.h ===
//----------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       versstr.h
//
//  Contents:   Defines required for Mac & Win Version resource for Forms3 components.
//
//----------------------------------------------------------------------------

#include "version.h"

// The following hack to build both the file version stamps
// from the same data was stolen from DART,
#if (rmm < 10)
#define rmmpad "0"
#else
#define rmmpad
#endif

#define _RELEASE_BUILD 1

#if defined(_RELEASE_BUILD) && DBG == 0
#define VER_STR1(a,b,c)     #a ".0"
#else
#  if defined(VER_ASYCPICT_FORMAT)
#define VER_STR1(a,b,c)     #a "." rmmpad #b "." #c ".0"
#  else
#define VER_STR1(a,b,c)     #a ".00." rmmpad #b "." #c
#  endif
#endif

#if defined(VER_ASYCPICT_FORMAT)
#define VER_VERSION         rmj, rmm, rup, 0
#else
#define VER_VERSION         rmj, 0, rmm, rup
#endif

#define VER_STR2(a,b,c)     VER_STR1(a,b,c)

#define VER_VERSION_STR     VER_STR2(rmj,rmm,rup)
#define VER_COMMENT         szVerName

#ifdef VER_PRIVATE_BUILD_STR
#define VER_PRIVATE_BUILD_FLG   VS_FF_PRIVATEBUILD | VS_FF_SPECIALBUILD
#else
#define VER_PRIVATE_BUILD_FLG   0
#endif

#if DBG==1
#define VER_DEBUG_BUILD_FLG     VS_FF_DEBUG
#else
#define VER_DEBUG_BUILD_FLG     0
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2c\util.h ===
//=--------------------------------------------------------------------------=
// Util.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains utilities that we will find useful.
//
#ifndef _UTIL_H_

#include "globals.h"
//=--------------------------------------------------------------------------=
// miscellaneous [useful] numerical constants
//=--------------------------------------------------------------------------=
// the length of a guid once printed out with -'s, leading and trailing bracket,
// plus 1 for NULL
//
#define GUID_STR_LEN    40


//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(g_hHeap, 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(g_hHeap, 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given and ANSI String, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPSTR pszA;
//  pszA = MyGetAnsiStringRoutine();
//  MAKE_WIDEPTR_FROMANSI(pwsz, pszA);
//  MyUseWideStringRoutine(pwsz);
//  ...
//
// similarily for MAKE_ANSIPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname = (lstrlen(ansistr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, ansistr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()

#define MAKE_MBCSPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (lstrlenW(widestr) + 1) * sizeof(char); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname * 2); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname * 2, NULL, NULL); \
    LPSTR ptrname = (LPSTR)__TempBuffer##ptrname.GetBuffer()

#define GET_MBCSLEN_FROMWIDE(widestr) \
	WideCharToMultiByte(CP_ACP, 0, widestr, -1, NULL, 0, NULL, NULL)

#define STR_BSTR   0
#define STR_OLESTR 1
#define BSTRFROMANSI(x)    (BSTR)MakeWideStrFromAnsi((LPSTR)(x), STR_BSTR)
#define OLESTRFROMANSI(x)  (LPOLESTR)MakeWideStrFromAnsi((LPSTR)(x), STR_OLESTR)
#define BSTRFROMRESID(x)   (BSTR)MakeWideStrFromResourceId(x, STR_BSTR)
#define OLESTRFROMRESID(x) (LPOLESTR)MakeWideStrFromResourceId(x, STR_OLESTR)
#define COPYOLESTR(x)      (LPOLESTR)MakeWideStrFromWide(x, STR_OLESTR)
#define COPYBSTR(x)        (BSTR)MakeWideStrFromWide(x, STR_BSTR)

LPWSTR MakeWideStrFromAnsi(LPSTR, BYTE bType);
LPWSTR MakeWideStrFromResourceId(WORD, BYTE bType);
LPWSTR MakeWideStrFromWide(LPWSTR, BYTE bType);

// takes a GUID, and a pointer to a buffer, and places the string form of the
// GUID in said buffer.
//
int StringFromGuidA(REFIID, LPSTR);

#define _UTIL_H_
#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2cenu\msr2cenu.cpp ===
//---------------------------------------------------------------------------
// MSR2CENU.cpp	implements DllMain
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#include "windows.h"

// DllMain
//
BOOL WINAPI DllMain(HINSTANCE hinstDll, DWORD dwReason, LPVOID lpvReserved)
{

	switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
	}

	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2cenu\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Viaduct2.rc
//
#define IDS_ERR_SOURCE                  900
#define IDS_ERR_INVALIDARG              1000
#define IDS_ERR_OUTOFMEMORY             1003
#define IDS_ERR_CANTCOERCE              1007
#define IDS_ERR_BADBOOKMARK             1015

// Viaduct2 additions
#define IDS_ERR_NOINTERFACE             2000
#define IDS_ERR_CANTCREATEMETACURSOR    2001
#define IDS_ERR_BUFFERTOOSMALL          2002
#define IDS_ERR_BADCOLUMNID             2003
#define IDS_ERR_COLUMNUNAVAILABLE       2004
#define IDS_ERR_BADCURSORBINDINFO       2005
#define IDS_ERR_ROWTOOSHORT             2006
#define IDS_ERR_ROWSETRELEASED          2007
#define IDS_ERR_RESTARTPOSFAILED        2008
#define IDS_ERR_CREATEACCESSORFAILED    2009
#define IDS_ERR_GETNEXTROWSFAILED       2010
#define IDS_ERR_GETDATAFAILED           2011
#define IDS_ERR_RESYNCHFAILED           2012
#define IDS_ERR_INVALIDBMSTATUS			2013
#define IDS_ERR_BADFETCHINFO			2014
#define IDS_ERR_GETROWSATFAILED			2015
#define IDS_ERR_UPDATEINPROGRESS        2016
#define IDS_ERR_SCROLLFAILED            2017
#define IDS_ERR_GETAPPROXPOSFAILED      2018
#define IDS_ERR_INVALIDSEEKFLAGS		2019
#define IDS_ERR_FINDFAILED              2020
#define IDS_ERR_BADFRACTION             2021
#define IDS_ERR_DELETEDROW              2022
#define IDS_ERR_ACTIONCANCELLED         2023
#define IDS_ERR_DELETEROWSFAILED        2024
#define IDS_ERR_STATEERROR              2025
#define IDS_ERR_INSERTROWFAILED         2026
#define IDS_ERR_UNDOFAILED              2027
#define IDS_ERR_SETDATAFAILED           2028
#define IDS_ERR_BADENTRYID              2029
#define IDS_ERR_GETROWSBYBOOKMARKFAILED 2030
#define IDS_ERR_CLONEFAILED             2031
#define IDS_ERR_STATFAILED              2032

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        132
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\datacab\viaduct\msr2cenu\common.inc ===
SOURCES_USED=$(ROOT)\common.inc

!if $(ALPHA)
MSC_WARNING_LEVEL = /W3 /WX
!endif

!ifndef MSC_WARNING_LEVEL
MSC_WARNING_LEVEL = /W3 /WX
!endif

C_DEFINES = \
    /D_WCTYPE_INLINE_DEFINED \
!if $(FREEBUILD)
    /D_ATL_MIN_CRT \
!else
    /D_DEBUG \
!endif
    /DSTRICT

!if !$(FREEBUILD)
USE_RTTI=1
MSC_OPTIMIZATION=/Od
#USER_CPP_FLAGS=/zmf
WATCOM_OPTS=/ei /zt16 /zm /zff /zgf
LINKER_NOICF=1      # ICF is s-l-o-w
!else
MSC_OPTIMIZATION=/Oxs
#USER_CPP_FLAGS=/zmf
WATCOM_OPTS=/ei /zt16 /ox /oe /zm /zff /zgf
!endif

MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Ob1 /Oi

NOT_LEAN_AND_MEAN=1

USE_NOLIBS=1
UMTYPE=windows

# Use NT 4.0/Win95 functionality only

WIN32_IE_VERSION=0x0400
WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400
SUBSYSTEM_VERSION=4.00

!ifdef WIN16

# Win 16 Specific Environment.
!ifndef __MSVC_ENV__
__WATCOM_ENV__=1
!endif
C_DEFINES = $(C_DEFINES) /DINC_WIN16X /DWRAP_RECTL /DFULL_DEBUG

FULL_DEBUG=1

!else

!if !$(FREEBUILD)
DEBUG_CRTS=1
!endif

# Win 32 Environment.
C_DEFINES = $(C_DEFINES) /D_MT



!endif

!if $(386)
NO_NTDLL=1
!else
# USE_NTDLL=1
!endif

CHECKED_ALT_DIR=1

#
# The IE build lab sets this flag for debug builds so we get full debug
#   on IE drops. The NT build lab wants debug lite builds and therefore
#   does not set it.
#
!ifdef MSHTML_FULL_DEBUG
!message MSHTML_FULL_DEBUG was defined. Building full debug.
FULL_DEBUG=1
!endif

!ifdef USE_ICECAP
C_DEFINES = $(C_DEFINES) /DPRODUCT_PROF
!endif

!ifdef USE_PERFTEST
C_DEFINES = $(C_DEFINES) /DPRODUCT_PERFTEST
!endif

!ifdef USE_PERFBUG
C_DEFINES = $(C_DEFINES) /DPRODUCT_PERFBUG
!endif

!ifdef USE_PERFTAGS
!if $(FREEBUILD)
C_DEFINES = $(C_DEFINES) /DPERFTAGS
!message PERFTAGS was defined
!endif
!endif

!ifdef USE_MSHTML_INCREMENTAL_LINKING
!if !$(FREEBUILD) && $(USE_MSHTML_INCREMENTAL_LINKING)
NTDEBUG=ntsd
NTDEBUGTYPE=windbg
NTDBGFILES=1
!undef USE_MAPSYM
USE_INCREMENTAL_LINKING=1
LINKER_FLAGS=$(LINKER_FLAGS) -INCREMENTAL:YES
USE_PDB_TO_COMPILE=1
TARGETPDB=TDC
!message USE_MSHTML_INCREMENTAL_LINKING was defined
!message $(TARGETPDB) was defined
!endif
!else
# Compatibility with existing usage before use_mshtml_incremental_linking
!ifdef USE_INCREMENTAL_LINKING
!message DOING IT THE OLD WAY
LINKER_FLAGS = -INCREMENTAL:YES
USE_PDB_TO_COMPILE=1
!else
USE_MAPSYM=1
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\digest\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef REZ  // Mac resource compiler (mrc) defines REZ
#define RC_INVOKED
#endif

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
	#include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// Tab Control styles
#ifndef TCS_MULTILINE // new in later versions of Win32
#define TCS_MULTILINE       0x0200
#endif

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0xFFFFL


// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
	// -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#ifdef _MAC
#define AFX_IDS_ABOUT                   0xF010
#endif
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2A0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2A0
#define AFX_IDP_DAO_DFX_BIND                    0xF2A1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2A2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2A3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2A4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2A5

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723
#ifdef _MAC
#define AFX_IDD_PREVIEW_SHORTTOOLBAR    30731
#endif

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
	// AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\digest\cache.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    cache.cxx

Abstract:

    Credential cache object for digest sspi package.

Author:

    Adriaan Canter (adriaanc) 01-Aug-1998

--*/

#include "include.hxx"


//-----------------CCredCache Private Functions --------------------------------


//--------------------------------------------------------------------
// CCredCache::Lock
//--------------------------------------------------------------------
BOOL CCredCache::Lock()
{
    BOOL  bRet;
    DWORD dwError;

    dwError = WaitForSingleObject(_hMutex, INFINITE);

    switch (dwError)
    {
        // Mutex is signalled. We own the mutex. Fall through.
        case WAIT_OBJECT_0:

        // The thread owning the mutex failed to release it
        // before terminating. We still own the mutex.
        case WAIT_ABANDONED:
            bRet = TRUE;
            break;

        // Fall through.
        case WAIT_FAILED:

        // Fail.
        default:
            bRet = FALSE;
    }
    return bRet;
}


//--------------------------------------------------------------------
// CCredCache::Unlock
//--------------------------------------------------------------------
BOOL CCredCache::Unlock()
{
    BOOL  bRet;

    bRet = ReleaseMutex(_hMutex);

    return bRet;
}


//--------------------------------------------------------------------
// CCredCache::GetPtrToObject
//--------------------------------------------------------------------
LPDWORD CCredCache::GetPtrToObject(DWORD dwObject)
{
    return _pMMFile->GetHeaderData(dwObject);
}



//--------------------------------------------------------------------
// CCredCache::SearchCredList
//--------------------------------------------------------------------
CCred* CCredCache::SearchCredList(CSess *pSess, LPSTR szHost,
    LPSTR szRealm, LPSTR szUser, BOOL fMatchHost)
{
    CList CredList;
    CCred *pMatch = NULL;

    if (!pSess->dwCred)
        goto exit;

    CredList.Init(&pSess->dwCred);
    while (pMatch = (CCred*) CredList.GetNext())
    {
        if ((!szRealm || !lstrcmpi(szRealm, CCred::GetRealm(pMatch)))
            && (!szUser  || !lstrcmpi(szUser, CCred::GetUser(pMatch))))
        {
            if (!fMatchHost)
                break;

            CNonce *pNonce;
            CList NonceList;
            NonceList.Init(&pMatch->dwNonce);
            while (pNonce = (CNonce*) NonceList.GetNext())
            {
                if (CNonce::IsHostMatch(pNonce, szHost))
                    goto exit;
            }

            pMatch = NULL;
            break;
        }
    }
exit:
    return pMatch;
}

//--------------------------------------------------------------------
// CCredCache::UpdateInfoList
//--------------------------------------------------------------------
CCredInfo* CCredCache::UpdateInfoList(CCredInfo *pInfo, CCredInfo *pHead)
{
    CCredInfo *pList, *pCur;
    BOOL fUpdate = TRUE;

    if (!pHead)
        return (pInfo);

    pList = pCur = pHead;

    while (pCur)
    {
        // Do entry usernames match ?
        if (!strcmp(pInfo->szUser, pCur->szUser))
        {
            // Is the new entry timestamp greater?
            if (pInfo->tStamp > pCur->tStamp)
            {
                // De-link existing entry.
                if (pCur->pPrev)
                    pCur->pPrev->pNext = pCur->pNext;
                else
                    pList = pCur->pNext;

                if (pCur->pNext)
                    pCur->pNext->pPrev = pCur->pPrev;

                // Delete existing entry.
                delete pCur;
            }
            else
            {
                // Found a match but time stamp
                // of existing entry was greater.
                fUpdate = FALSE;
            }
            break;
        }
        pCur = pCur->pNext;
    }

    // If we superceded an existing matching entry
    // or found no matching entries, prepend to list.
    if (fUpdate)
    {
        pInfo->pNext = pList;
        if (pList)
            pList->pPrev = pInfo;
        pList = pInfo;
    }

    return pList;
}

//-----------------CCredCache Public Functions --------------------------------


//--------------------------------------------------------------------
// CCredCache::GetHeapPtr
//--------------------------------------------------------------------
DWORD_PTR CCredCache::GetHeapPtr()
{
    return _pMMFile->GetMapPtr();
}

//--------------------------------------------------------------------
// CCredCache::IsTrustedHost
// BUGBUG - no limits on szCtx
//--------------------------------------------------------------------
BOOL CCredCache::IsTrustedHost(LPSTR szCtx, LPSTR szHost)
{
    CHAR szBuf[MAX_PATH];
    CHAR szRegPath[MAX_PATH];

    DWORD dwType, dwError, cbBuf = MAX_PATH;
    BOOL fRet = FALSE;
    HKEY hHosts = (HKEY) INVALID_HANDLE_VALUE;

    memcpy(szRegPath, DIGEST_HOSTS_REG_KEY, sizeof(DIGEST_HOSTS_REG_KEY) - 1);
    memcpy(szRegPath + sizeof(DIGEST_HOSTS_REG_KEY) - 1, szCtx, strlen(szCtx) + 1);


    if ((dwError = RegCreateKey(HKEY_CURRENT_USER, szRegPath, &hHosts)) == ERROR_SUCCESS)
    {
        if ((dwError = RegQueryValueEx(hHosts, szHost, NULL, &dwType, (LPBYTE) szBuf, &cbBuf)) == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }
    }

    if (hHosts != INVALID_HANDLE_VALUE)
        RegCloseKey(hHosts);

    return fRet;
}

//--------------------------------------------------------------------
// CCredCache::SetTrustedHostInfo
//--------------------------------------------------------------------
BOOL CCredCache::SetTrustedHostInfo(LPSTR szCtx, CParams *pParams)
{
    CHAR szRegPath[MAX_PATH], *szUrlBuf = NULL, *szHostBuf = NULL;
    DWORD dwZero = 0, dwError = ERROR_SUCCESS, cbUrlBuf, cbHostBuf;
    BOOL fRet = FALSE;
    HKEY hHosts = (HKEY) INVALID_HANDLE_VALUE;

    // Form path to trusted host reg key.
    memcpy(szRegPath, DIGEST_HOSTS_REG_KEY, sizeof(DIGEST_HOSTS_REG_KEY) - 1);
    memcpy(szRegPath + sizeof(DIGEST_HOSTS_REG_KEY) - 1, szCtx, strlen(szCtx) + 1);

    // Open top-level reg key.
    if ((dwError = RegCreateKey(HKEY_CURRENT_USER, szRegPath, &hHosts)) != ERROR_SUCCESS)
        goto exit;

    // First set authenticating host in registry.
    LPSTR szHost;
    szHost = pParams->GetParam(CParams::HOST);
    DIGEST_ASSERT(szHost);

    if ((dwError = RegSetValueEx(hHosts, szHost, NULL, REG_DWORD,
        (LPBYTE) &dwZero, sizeof(DWORD))) != ERROR_SUCCESS)
        goto exit;

    // Now check the domain header for any additional trusted hosts.
    LPSTR szDomain, pszUrl;
    DWORD cbDomain, cbUrl;
    pszUrl = NULL;
    pParams->GetParam(CParams::DOMAIN, &szDomain, &cbDomain);
    if (!szDomain)
    {
        fRet = TRUE;
        goto exit;
    }

    // Parse the domain header for urls. Crack each url to get the
    // host and set the host value in the registry.

    // First attempt to load shlwapi. If this fails then we simply do not have
    // domain header support.
    if (!g_hShlwapi)
    {
        g_hShlwapi = LoadLibrary(SHLWAPI_DLL_SZ);
        if (!g_hShlwapi)
        {
            dwError = ERROR_DLL_INIT_FAILED;
            goto exit;
        }
    }

    // Attempt to get addresses of UrlUnescape and UrlGetPart
    PFNURLUNESCAPE pfnUrlUnescape;
    PFNURLGETPART  pfnUrlGetPart;
    pfnUrlUnescape = (PFNURLUNESCAPE) GetProcAddress(g_hShlwapi, "UrlUnescapeA");
    pfnUrlGetPart  = (PFNURLGETPART)  GetProcAddress(g_hShlwapi, "UrlGetPartA");
    if (!(pfnUrlUnescape && pfnUrlGetPart))
    {
        dwError = ERROR_INVALID_FUNCTION;
        goto exit;
    }

    // Strtok through string to get each url (ws and tab delimiters)
    pszUrl = NULL;
    while (pszUrl = strtok((pszUrl ? NULL : szDomain), " \t"))
    {
        // Allocate a buffer for the url since we will first unescape it.
        // Also allocate buffer for host which will be returned from
        // call to shlwapi. Unescaped url and host buffer sizes are
        // bounded by length of original url.
        cbUrl        = strlen(pszUrl) + 1;
        cbUrlBuf     = cbHostBuf = cbUrl;
        szUrlBuf     = new CHAR[cbUrlBuf];
        szHostBuf    = new CHAR[cbHostBuf];
        if (!(szUrlBuf && szHostBuf))
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        // Copy strtoked url to buffer.
        memcpy(szUrlBuf, pszUrl, cbUrl);

        // Unescape the url
        if (S_OK == pfnUrlUnescape(szUrlBuf, NULL, NULL, URL_UNESCAPE_INPLACE))
        {
            // If unescape is successful, parse host from url.
            if (S_OK == pfnUrlGetPart(szUrlBuf, szHostBuf, &cbHostBuf, URL_PART_HOSTNAME, 0))
            {
                // If parse is successful, set host in registry.
                if ((dwError = RegSetValueEx(hHosts, szHostBuf, NULL, REG_DWORD,
                    (LPBYTE) &dwZero, sizeof(DWORD))) != ERROR_SUCCESS)
                    goto exit;
            }
        }
        delete [] szUrlBuf;
        delete [] szHostBuf;
        szUrlBuf = szHostBuf = NULL;
    }

    fRet = TRUE;

// Cleanup.
exit:

    DIGEST_ASSERT(dwError == ERROR_SUCCESS);

    if (hHosts != INVALID_HANDLE_VALUE)
        RegCloseKey(hHosts);

    if (szUrlBuf)
        delete [] szUrlBuf;

    if (szHostBuf)
        delete [] szHostBuf;

    return fRet;
}


//--------------------------------------------------------------------
// CCredCache::MapHandleToSession
//--------------------------------------------------------------------
// BUGBUG - don't walk the sessionlist, just obfuscate the ptr in handle.
CSess *CCredCache::MapHandleToSession(DWORD_PTR dwSess)
{
    // BUGBUG - if locking fails, return error directly,
    // no last error.
    CSess *pSess = NULL;
    if (!Lock())
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        goto exit;
    }

    _pSessList->Seek();

    while (pSess = (CSess*) _pSessList->GetNext())
    {
        if ((CSess*) (dwSess + (DWORD_PTR) _pMMFile->GetMapPtr()) == pSess)
            break;
    }

    Unlock();
exit:
    return pSess;
}

//--------------------------------------------------------------------
// CCredCache::MapSessionToHandle
//--------------------------------------------------------------------
DWORD CCredCache::MapSessionToHandle(CSess* pSess)
{
    DWORD dwSess = 0;

    if (!Lock())
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        goto exit;
    }

    dwSess = (DWORD) ((DWORD_PTR) pSess - _pMMFile->GetMapPtr());
    Unlock();

exit:
    return dwSess;
}



// BUGBUG - init mutex issues.
//--------------------------------------------------------------------
// CCredCache::CCredCache
//--------------------------------------------------------------------
CCredCache::CCredCache()
{
    Init();
}

//--------------------------------------------------------------------
// CCredCache::~CCredCache
//--------------------------------------------------------------------
CCredCache::~CCredCache()
{
    DeInit();
}

//--------------------------------------------------------------------
// CCredCache::Init
//--------------------------------------------------------------------
DWORD CCredCache::Init()
{
    BOOL fFirstProc;
    CHAR szMutexName[MAX_PATH];
    DWORD cbMutexName = MAX_PATH;

    _dwSig = SIG_CACH;

    // IE5# 89288
    // Get mutex name based on user
    if ((_dwStatus = CMMFile::MakeUserObjectName(szMutexName, 
        &cbMutexName, MAKE_MUTEX_NAME)) != ERROR_SUCCESS)
        return _dwStatus;
        
    // Create/Open mutex.
    _hMutex = CreateMutex(NULL, FALSE, szMutexName);

    // BUGBUG - this goes at a higher level.
    // BUGBUG - also watch out for failure to create mutex
    // and then unlocking it.
    if (_hMutex)
    {
        // Created/opened mutex. Flag if we're first process.
        fFirstProc = (GetLastError() != ERROR_ALREADY_EXISTS);
    }
    else
    {
        // Failed to create/open mutex.
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        goto exit;
    }

    // Acquire mutex.
    if (!Lock())
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        return _dwStatus;
    }

    // Open or create memory map.
    _pMMFile = new CMMFile(CRED_CACHE_HEAP_SIZE,
        CRED_CACHE_ENTRY_SIZE);

    if (!_pMMFile)
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    _dwStatus = _pMMFile->Init();
    if (_dwStatus != ERROR_SUCCESS)
    {
        DIGEST_ASSERT(FALSE);
        goto exit;
    }

    g_pHeap = GetHeapPtr();

    // Initialize session list.
    // BUGBUG - check return codes on failure.
    _pSessList     = new CList();

    DIGEST_ASSERT(_pSessList);
    _pSessList->Init(GetPtrToObject(CRED_CACHE_SESSION_LIST));


exit:

    // Relase mutex.
    Unlock();

    return _dwStatus;
}

//--------------------------------------------------------------------
// CCredCache::DeInit
//--------------------------------------------------------------------
DWORD CCredCache::DeInit()
{
    // bugbug - assert session list is null and destroy.
    // bugbug - release lock before closing handle.
    if (!Lock())
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        goto exit;
    }

    delete _pMMFile;
    _dwStatus = CloseHandle(_hMutex);
    Unlock();

exit:
    return _dwStatus;
}


//--------------------------------------------------------------------
// CCredCache::LogOnToCache
//--------------------------------------------------------------------
CSess *CCredCache::LogOnToCache(LPSTR szAppCtx, LPSTR szUserCtx, BOOL fHTTP)
{
    CSess *pSessNew = NULL;
    BOOL fLocked = FALSE;

    // Obtain mutex.
    if (!Lock())
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        goto exit;
    }

    fLocked = TRUE;

    // For non-http clients, find or create the single
    // global session which all non-http clients use.
    if (!fHTTP)
    {
        CSess * pSess;
        pSess = NULL;
        _pSessList->Seek();
        while (pSess = (CSess*) _pSessList->GetNext())
        {
            if (!pSess->fHTTP)
            {
                // Found the session.
                pSessNew = pSess;
                _dwStatus = ERROR_SUCCESS;
                goto exit;
            }
        }
        if (!pSessNew)
        {
            // Create the non-http gobal session.
            pSessNew = CSess::Create(_pMMFile, NULL, NULL, FALSE);
        }
    }
    else
    {
        // Create a session context; add to list.
        pSessNew = CSess::Create(_pMMFile, szAppCtx, szUserCtx, TRUE);
    }

    if (!pSessNew)
    {
        // This reflects running out of space in the memmap
        // file. Shouldn't happen in practice.
        DIGEST_ASSERT(FALSE);
        _dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }


    // Push this session on to the session list.
    _pSessList->Insert(pSessNew);

    _dwStatus = ERROR_SUCCESS;

exit:

    // Release mutex.
    if(fLocked)
        Unlock();
    return pSessNew;
}

//--------------------------------------------------------------------
// CCredCache::LogOffFromCache
//--------------------------------------------------------------------
DWORD CCredCache::LogOffFromCache(CSess *pSess)
{
    CList CredList;
    CCred *pCred;

    // Obtain mutex.
    if (!Lock())
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        goto exit;
    }

    if (pSess->fHTTP)
    {
        // Purge all credentials for this session.
        // BUGBUG - not needed.
        // CredList.Init((CEntry **) &pSess->pCred);

        // Flush all credentials for this session
        // This will also delete nonces.
        FlushCreds(pSess, NULL);

        // Finally, free the session.
        _pSessList->DeLink(pSess);
        CEntry::Free(_pMMFile, pSess);
    }

    _dwStatus = ERROR_SUCCESS;
    // Release mutex.
    Unlock();

exit:
    return _dwStatus;
}



//--------------------------------------------------------------------
// CCredCache::CreateCred
//--------------------------------------------------------------------
CCred* CCredCache::CreateCred(CSess *pSess, CCredInfo *pInfo)
{
    CCred* pCred = NULL, *pCredList;
    CList CredList;

    // Obtain mutex.
    if (!Lock())
    {
        _dwStatus = GetLastError();
        goto exit;
    }

    // First check to see if any credential in this session matches realm.
    pCred = SearchCredList(pSess, NULL, pInfo->szRealm, NULL, FALSE);
    if (pCred)
    {
        CredList.Init(&pSess->dwCred);
        CredList.DeLink(pCred);
        CCred::Free(_pMMFile, pSess, pCred);
    }

    // Create a credential.
    // BUGBUG - this could fail, transact any cred update.
    pCred = CCred::Create(_pMMFile, pInfo->szHost, pInfo->szRealm,
        pInfo->szUser, pInfo->szPass, pInfo->szNonce, pInfo->szCNonce);

    DIGEST_ASSERT(pCred);

    // Insert into head of session's credential list.
    if (!CSess::GetCred(pSess))
        CSess::SetCred(pSess, pCred);
    else
    {
        CredList.Init(&pSess->dwCred);
        CredList.Insert(pCred);
    }

    _dwStatus = ERROR_SUCCESS;

    // Relase mutex.
    Unlock();

exit:
    return pCred;
}

//--------------------------------------------------------------------
// CCredCache::FindCred
//--------------------------------------------------------------------
CCredInfo* CCredCache::FindCred(CSess *pSessIn, LPSTR szHost,
    LPSTR szRealm, LPSTR szUser, LPSTR szNonce,
    LPSTR szCNonce, DWORD dwFlags)
{
    CCred *pCred;
    CCredInfo *pInfo = NULL;
    BOOL fLocked = FALSE;

    // Obtain mutex.
    if (!Lock())
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        goto exit;
    }

    fLocked = TRUE;

    // If finding a credential for preauthentication.
    if (dwFlags & FIND_CRED_PREAUTH)
    {
        // First search this session's credential list for a match,
        // filtering on the host field in available nonces.
        pCred = SearchCredList(pSessIn, szHost, szRealm, szUser, TRUE);

        // If a credential is found the nonce is also required.
        // We do not attempt to search other sessions for a nonce
        // because nonce counts must remain in sync. See note below.
        if (pCred)
        {
            // Increment this credential's nonce count.
            CNonce *pNonce;
            pNonce = CCred::GetNonce(pCred, szHost, SERVER_NONCE);
            if (pNonce)
            {
                pNonce->cCount++;
                pInfo = new CCredInfo(pCred, szHost);
                if (!pInfo || pInfo->dwStatus != ERROR_SUCCESS)
                {
                    DIGEST_ASSERT(FALSE);
                    _dwStatus = ERROR_NOT_ENOUGH_MEMORY;
                    goto exit;
                }
            }
        }
    }

    // Otherwise if finding a credential for response to challenge.
    else if (dwFlags & FIND_CRED_AUTH)
    {
        // First search this session's credential list for a match,
        // ignoring the host field in available nonces.
        pCred = SearchCredList(pSessIn, NULL, szRealm, szUser, FALSE);

        // If a credential was found.
        if (pCred)
        {
            // Update the credential's nonce value if extant.
            // SetNonce will update any existing nonce entry
            // or create a new one if necessary.
            CCred::SetNonce(_pMMFile, pCred, szHost, szNonce, SERVER_NONCE);

            // BUGBUG - if credential contains a client nonce for a host,
            // (for MD5-sess) and is challenged for MD5, we don't revert
            // the credential's client nonce to null, so that on subsequent
            // auths we will default to MD5. Fix is to delete client nonce
            // in this case. Not serious problem though since we don't expect this.
            if (szCNonce)
                CCred::SetNonce(_pMMFile, pCred, szHost, szCNonce, CLIENT_NONCE);

            // Increment this credential's nonce count.
            CNonce *pNonce;
            pNonce = CCred::GetNonce(pCred, szHost, SERVER_NONCE);
            pNonce->cCount++;

            // Create and return the found credential.
            pInfo = new CCredInfo(pCred, szHost);
            if (!pInfo || pInfo->dwStatus != ERROR_SUCCESS)
            {
                DIGEST_ASSERT(FALSE);
                _dwStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }
        }

        // If no credential was found and the username has been specified
        // also search other sessions for the latest matching credential.
        else if (szUser)
        {
            CSess* pSessCur;
            _pSessList->Seek();
            CCred* pMatch;
            while (pSessCur = (CSess*) _pSessList->GetNext())
            {
                // We've already searched the session passed in.
                if (pSessIn == pSessCur)
                    continue;

                // Are this session's credentials shareable?
                if (CSess::CtxMatch(pSessIn, pSessCur))
                {
                    // Find latest credential based on time stamp.
                    CCred *pCredList;
                    pMatch = SearchCredList(pSessCur, NULL, szRealm, szUser, FALSE);
                    if (pMatch && ((!pCred || (pMatch->tStamp > pCred->tStamp))))
                    {
                        pCred = pMatch;
                    }
                }
            }

            // If we found a credential in another session, duplicate it
            // and add it to the passed in session's credential list.
            // NOTE : WHEN CREATING THE CREDENTIAL DO NOT DUPLICATE
            // THE NONCE, OTHERWISE NONCE COUNTS WILL BE INCORRECT.
            // USE THE NONCE SUPPLIED IN THE CHALLENGE.
            if (pCred)
            {
                // Create a cred info from the found credential
                // and the nonce received from the challenge.
                pInfo = new CCredInfo(szHost, CCred::GetRealm(pCred),
                    CCred::GetUser(pCred), CCred::GetPass(pCred),
                    szNonce, szCNonce);

                if (!pInfo || pInfo->dwStatus != ERROR_SUCCESS)
                {
                    DIGEST_ASSERT(FALSE);
                    _dwStatus = ERROR_NOT_ENOUGH_MEMORY;
                    goto exit;
                }

                // Create the credential in the session list.
                pCred = CreateCred(pSessIn, pInfo);

                // Increment this credential's nonce count
                CNonce *pNonce;
                pNonce = CCred::GetNonce(pCred, szHost, SERVER_NONCE);
                pNonce->cCount++;
            }
        }
    }

    // Otherwise we are prompting for UI.
    else if (dwFlags & FIND_CRED_UI)
    {
        // First search this session's credential list for a match,
        // ignoring the host field in available nonces.
        pCred = SearchCredList(pSessIn, NULL, szRealm, szUser, FALSE);

        if (pCred)
        {
            // Create and return the found credential.
            pInfo = new CCredInfo(szHost, CCred::GetRealm(pCred),
                CCred::GetUser(pCred), CCred::GetPass(pCred),
                szNonce, szCNonce);

            if (!pInfo || pInfo->dwStatus != ERROR_SUCCESS)
            {
                DIGEST_ASSERT(FALSE);
                _dwStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }
        }
        else
        {
            // No credential found in this session's list. Search
            // the credentials in other sessions and assemble a list
            // of available credentials. If multiple credentials
            // are found for a user, select the latest based on
            // time stamp.
            CSess* pSessCur;
            _pSessList->Seek();
            while (pSessCur = (CSess*) _pSessList->GetNext())
            {
                // We've already searched the session passed in.
                if (pSessIn == pSessCur)
                    continue;

                // Are this session's credentials shareable?
                if (CSess::CtxMatch(pSessIn, pSessCur))
                {
                    pCred = SearchCredList(pSessCur, NULL, szRealm, szUser, FALSE);

                    if (pCred)
                    {
                        // Found a valid credential.
                        CCredInfo *pNew;
                        pNew = new CCredInfo(szHost, CCred::GetRealm(pCred),
                            CCred::GetUser(pCred), CCred::GetPass(pCred),
                            szNonce, szCNonce);

                        if (!pNew || pNew->dwStatus != ERROR_SUCCESS)
                        {
                            DIGEST_ASSERT(FALSE);
                            _dwStatus = ERROR_NOT_ENOUGH_MEMORY;
                            goto exit;
                        }

                        // Update list based on timestamps.
                        pInfo = UpdateInfoList(pNew, pInfo);

                    }
                }
            }
        }
    }

    _dwStatus = ERROR_SUCCESS;

exit:

    // Clean up allocated cred infos if
    // we failed for some reason.
    // bugbug - clean this up.
    if (_dwStatus != ERROR_SUCCESS)
    {
        CCredInfo *pNext;
        while (pInfo)
        {
            pNext = pInfo->pNext;
            delete pInfo;
            pInfo = pNext;
        }
        pInfo = NULL;
    }

    // Relase mutex.
    if(fLocked)
        Unlock();

    // Return any CCredInfo found, possibly a list or NULL.
    return pInfo;
}

//--------------------------------------------------------------------
// CCredCache::FlushCreds
//--------------------------------------------------------------------
VOID CCredCache::FlushCreds(CSess *pSess, LPSTR szRealm)
{
    CSess    *pSessCur;
    CCred    *pCred;
    CList    CredList;

    // Obtain mutex.
    if (!Lock())
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        return;
    }

    // BUGBUG - don't scan through all sessions.
    // BUGBUG - abstract cred deletion.
    // Flush all credentials if no session specified
    // or only the credentials of the indicated session.
    _pSessList->Seek();
    while (pSessCur = (CSess*) _pSessList->GetNext())
    {
        if (pSess && (pSessCur != pSess))
            continue;

        CredList.Init(&pSessCur->dwCred);
        while (pCred = (CCred*) CredList.GetNext())
        {
            // If a realm is specified, only delete
            // credentials with that realm.
            if (!szRealm || (!strcmp(szRealm, CCred::GetRealm(pCred))))
                CCred::Free(_pMMFile, pSessCur, pCred);
        }
    }

    // Release mutex.
    Unlock();
}


//--------------------------------------------------------------------
// CCredCache::GetStatus
//--------------------------------------------------------------------
DWORD CCredCache::GetStatus()
{
    return _dwStatus;
}














=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\digest\digest.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    digest.cxx

Abstract:

    Parses http digest challenges and generates http digest
    authorization headers for digest sspi package.

Author:

    Adriaan Canter (adriaanc) 01-Aug-1998

--*/
#include "include.hxx"


// HTTP related defines
#define HEADER_IDX          0
#define REALM_IDX           1
#define HOST_IDX            2
#define URL_IDX             3
#define METHOD_IDX          4
#define USER_IDX            5
#define PASS_IDX            6
#define NONCE_IDX           7
#define NC_IDX              8
#define HWND_IDX            9
#define NUM_BUFF            10

// POP related defines.
#define POP_USER_IDX             1
#define POP_PASS_IDX             2
#define NUM_EXTENDED_POP_BUFFERS 3

// Used for generating response line.
#define FLAG_QUOTE          0x1
#define FLAG_TERMINATE      0x2

//--------------------------------------------------------------------
// CDigest:: ToHex
//
// Routine Description:
// 
// Convert binary data to ASCII hex representation
//
// Arguments:
//
//  pSrc - binary data to convert
//  cSrc - length of binary data
//  pDst - buffer receiving ASCII representation of pSrc
//
//--------------------------------------------------------------------
VOID CDigest::ToHex(LPBYTE pSrc, UINT   cSrc, LPSTR  pDst)
{
    UINT x;
    UINT y;

// BUGBUG - character case issue ?
#define TOHEX(a) ((a)>=10 ? 'a'+(a)-10 : '0'+(a))

    for ( x = 0, y = 0 ; x < cSrc ; ++x )
    {
        UINT v;
        v = pSrc[x]>>4;
        pDst[y++] = TOHEX( v );
        v = pSrc[x]&0x0f;
        pDst[y++] = TOHEX( v );
    }
    pDst[y] = '\0';
}

//--------------------------------------------------------------------
// AddDigestHeader
//--------------------------------------------------------------------
BOOL AddDigestHeader(LPSTR szHeader, LPDWORD pcbHeader, 
                     LPSTR szValue, LPSTR szData,  
                     DWORD cbAlloced, DWORD dwFlags)
{
    DWORD cbValue, cbData, cbRequired;
    
    cbValue = strlen(szValue);
    cbData = strlen(szData);

    cbRequired = *pcbHeader 
        + cbValue + cbData + sizeof('=') + 2 * sizeof('\"') + sizeof(", ") - 1;

    if (cbRequired > cbAlloced)
        return FALSE;

    memcpy(szHeader + *pcbHeader, szValue, cbValue);
    (*pcbHeader) += cbValue;

    memcpy(szHeader + *pcbHeader, "=", sizeof('='));
    (*pcbHeader) += sizeof('=');

    if (dwFlags & FLAG_QUOTE)
    {
        memcpy(szHeader + *pcbHeader, "\"", sizeof('\"'));
        (*pcbHeader) += sizeof('\"');
    }

    memcpy(szHeader + *pcbHeader, szData, cbData);
    (*pcbHeader) += cbData;

    if (dwFlags & FLAG_QUOTE)
    {
        memcpy(szHeader + *pcbHeader, "\"", sizeof('\"'));
        (*pcbHeader) += sizeof('\"');
    }

    if (!(dwFlags & FLAG_TERMINATE))
    {
         memcpy(szHeader + *pcbHeader, ", ", sizeof(", "));
        (*pcbHeader) += (sizeof(", ") - 1);
    }
    else     
    {
        *(szHeader + *pcbHeader) = '\0';
    }
    return TRUE;
}




//--------------------------------------------------------------------
// CDigest::CDigest()
//--------------------------------------------------------------------
CDigest::CDigest()
{}


//--------------------------------------------------------------------
// CDigest::MakeCNonce
//--------------------------------------------------------------------
LPSTR CDigest::MakeCNonce()
{
    DWORD        dwRand;
    static DWORD dwCounter;
    LPSTR        szCNonce; 

    szCNonce = new CHAR[SIZE_MD5_DIGEST+1];
    if (!szCNonce)
    {
        DIGEST_ASSERT(FALSE);
        return NULL;
    }

    dwRand = (GetTickCount() * rand()) + dwCounter++;

    MD5_CTX md5ctx;
    MD5Init  (&md5ctx);
    MD5Update(&md5ctx, (LPBYTE) &dwRand, sizeof(DWORD));
    MD5Final (&md5ctx);    

    ToHex(md5ctx.digest, sizeof(md5ctx.digest), szCNonce);

    return szCNonce;
}


//--------------------------------------------------------------------
// CDigest::ParseChallenge
//--------------------------------------------------------------------
DWORD CDigest::ParseChallenge(CSess * pSess, PSecBufferDesc pSecBufDesc, 
    CParams **ppParams, DWORD fContextReq)
{
    // SecBufferDesc looks like
    //
    // [ulversion][cbuffers][pbuffers]
    //                             |
    //  --------------------------
    //  |
    //  |--> [cbBuffer][buffertype][lpvoid][cbBuffer]...
    //

    DWORD cbQop, cbAlgo, dwError = ERROR_SUCCESS;
    CHAR *szQop, *szAlgo, *ptr;

    HWND *phWnd;
    LPDWORD pcNC;
    LPSTR szHeader, szRealm, szHost, szUrl,
          szMethod, szUser,  szPass, szNonce;
    
    BOOL fPreAuth = FALSE, fCredsSupplied = FALSE;

    // Identify buffer components.

    // Legacy client.
    if (!pSess->fHTTP)
    {
        szHeader    = (LPSTR) pSecBufDesc->pBuffers[HEADER_IDX].pvBuffer;
        szRealm     = NULL;
        szHost      = "";
        szUrl       = "";
        szMethod    = "AUTHENTICATE";

        if (pSecBufDesc->cBuffers == NUM_EXTENDED_POP_BUFFERS)
            szUser = (LPSTR) pSecBufDesc->pBuffers[POP_USER_IDX].pvBuffer;
        else
            szUser = NULL;

        if (pSecBufDesc->cBuffers == NUM_EXTENDED_POP_BUFFERS)
            szPass = (LPSTR) pSecBufDesc->pBuffers  [POP_PASS_IDX].pvBuffer;
        else
            szPass = NULL;
            
        szNonce     = NULL;
        phWnd       = NULL;        
    }
    // Current client. Leave room for extra
    // param (pRequest).
    else if (pSess->fHTTP 
        && (pSecBufDesc->cBuffers == NUM_BUFF
            || pSecBufDesc->cBuffers == NUM_BUFF+1))
    {
        szHeader    = (LPSTR) pSecBufDesc->pBuffers[HEADER_IDX].pvBuffer;
        szRealm     = (LPSTR) pSecBufDesc->pBuffers [REALM_IDX].pvBuffer;
        szHost      = (LPSTR) pSecBufDesc->pBuffers  [HOST_IDX].pvBuffer;
        szUrl       = (LPSTR) pSecBufDesc->pBuffers   [URL_IDX].pvBuffer;
        szMethod    = (LPSTR) pSecBufDesc->pBuffers[METHOD_IDX].pvBuffer;
        szUser      = (LPSTR) pSecBufDesc->pBuffers  [USER_IDX].pvBuffer;
        szPass      = (LPSTR) pSecBufDesc->pBuffers  [PASS_IDX].pvBuffer;
        szNonce     = (LPSTR) pSecBufDesc->pBuffers [NONCE_IDX].pvBuffer;
        pcNC        =(DWORD*) pSecBufDesc->pBuffers [   NC_IDX].pvBuffer;
        phWnd       = (HWND*) pSecBufDesc->pBuffers  [HWND_IDX].pvBuffer; 
    }
    else
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    // Validate parameters.
    dwError = ERROR_INVALID_PARAMETER;
    if (szHost && szUrl && szMethod)
    {
        // Auth or UI prompt to challenge for any user.
        if (szHeader && !szRealm && !szUser && !szPass && !szNonce)
            dwError = ERROR_SUCCESS;

        // Auth or UI prompt to challenge for particular user.
        else if (szHeader && !szRealm && szUser && !szPass && !szNonce)
            dwError = ERROR_SUCCESS;

        // Auth to challenge with creds supplied.
        else if (szHeader && !szRealm && szUser 
            && szPass && !szNonce && (fContextReq & ISC_REQ_USE_SUPPLIED_CREDS))
        {
            fCredsSupplied = TRUE;
            dwError = ERROR_SUCCESS;
        }
        // Preauth with realm supplied for any user.
        else if (!szHeader && szRealm && !szUser && !szPass && !szNonce)
        {
            fPreAuth = TRUE;
            dwError = ERROR_SUCCESS;
        }
        
        // Preauth with realm supplied for a particular user.
        else if (!szHeader && szRealm && szUser && !szPass && !szNonce)
        {
            fPreAuth = TRUE;
            dwError = ERROR_SUCCESS;
        }
        
        // Preauth with realm and creds supplied.
        else if (!szHeader && szRealm && szUser && 
            szPass && szNonce && pcNC && (fContextReq & ISC_REQ_USE_SUPPLIED_CREDS))
        {
            fPreAuth = TRUE;
            fCredsSupplied = TRUE;
            dwError = ERROR_SUCCESS;
        }
    }

    // Fail if buffers did not fall into one
    // of the acceptable formats.
    if (dwError != ERROR_SUCCESS)
        goto exit;

    // Construct the params object.
    *ppParams = new CParams(szHeader);
    if (!*ppParams)
    {
        DIGEST_ASSERT(FALSE);
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }
        

    // Flag if this is preauth and/or if 
    // credentials are supplied.
    (*ppParams)->SetPreAuth(fPreAuth);
    (*ppParams)->SetCredsSupplied(fCredsSupplied);

    // Only set algorithm if auth to challenge or UI prompting.
    if (!(*ppParams)->IsPreAuth())
    {
        // Algorithm should be MD5 or MD5-sess, default to MD5 if not specified.
        if (!(*ppParams)->GetParam(CParams::ALGORITHM, &szAlgo, &cbAlgo))
        {
            (*ppParams)->SetParam(CParams::ALGORITHM, "MD5", sizeof("MD5") - 1);
            (*ppParams)->SetMd5Sess(FALSE);
        }
        else if (szAlgo && !lstrcmpi(szAlgo, "Md5-sess"))
        {
            (*ppParams)->SetMd5Sess(TRUE);
        }        
        else if (szAlgo && !lstrcmpi(szAlgo, "MD5"))
        {
            (*ppParams)->SetMd5Sess(FALSE);
        }
        else
        {
            // Not md5 or md5-sess
            // DIGEST_ASSERT(FALSE);
            dwError = ERROR_INVALID_PARAMETER;
            goto exit;
        }
    }

    // If this is an imap/pop client we require
    // md5-sess specified in the challenge.
    if (!pSess->fHTTP && !(*ppParams)->IsMd5Sess())
    {
        DIGEST_ASSERT(FALSE);
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }        

    // Always set host, url, method (required). User and pass optional.
    if (!   (*ppParams)->SetParam(CParams::HOST,   szHost,   szHost   ? strlen(szHost)   : 0)
        || !(*ppParams)->SetParam(CParams::URL,    szUrl,    szUrl    ? strlen(szUrl)    : 0)
        || !(*ppParams)->SetParam(CParams::METHOD, szMethod, szMethod ? strlen(szMethod) : 0)
        || !(*ppParams)->SetParam(CParams::USER,   szUser,   szUser   ? strlen(szUser)   : 0)
        || !(*ppParams)->SetParam(CParams::PASS,   szPass,   szPass   ? strlen(szPass)   : 0))
    {
        DIGEST_ASSERT(FALSE);
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    // BUGBUG - do cleanup locally on failure.
    
    // If not preauthenticating we are authenticating in response
    // to a challenge or prompting for UI.
    if (!(*ppParams)->IsPreAuth())
    {
        // Check to see that qop=auth is specified
        (*ppParams)->GetParam(CParams::QOP, &szQop, &cbQop);
        if (!(szQop && (*ppParams)->FindToken(szQop, cbQop+1, AUTH_SZ, AUTH_LEN, NULL)))
        {
            DIGEST_ASSERT(FALSE);
            dwError = ERROR_INVALID_PARAMETER;
            goto exit;
        }
        
        // Save off any hWnd for UI (only needed for challenges).
        if (fContextReq & ISC_REQ_PROMPT_FOR_CREDS)
        {
            (*ppParams)->SetHwnd(phWnd);
        }
    }
    // Otherwise we are attempting to preauthenticate.
    else
    {
        // Set the realm for preauth.
        if (!(*ppParams)->SetParam(CParams::REALM, szRealm, strlen(szRealm)))
        {
            DIGEST_ASSERT(FALSE);
            dwError = ERROR_INVALID_PARAMETER;
            goto exit;
        }

        // Also set the nonce if preauth + use supplied creds.
        if (fContextReq & ISC_REQ_USE_SUPPLIED_CREDS)
        {
            (*ppParams)->SetNC(pcNC);
            if (!(*ppParams)->SetParam(CParams::NONCE, szNonce, strlen(szNonce)))
            {
                DIGEST_ASSERT(FALSE);
                dwError = ERROR_INVALID_PARAMETER;
                goto exit;
            }
        }
    }

exit:
    return dwError;
}



//--------------------------------------------------------------------
// CDigest::GenerateResponse
//--------------------------------------------------------------------
DWORD CDigest::GenerateResponse(CSess *pSess, CParams *pParams, 
    CCredInfo *pInfo, PSecBufferDesc pSecBufDesc)
{
    // bugbug - psz's on these.
    LPSTR   szBuf, szMethod, szUrl, szNonce, szCNonce, szCNonceSess, szOpaque;
    DWORD *pcbBuf, cbMethod, cbUrl, cbNonce, cbCNonce, cbCNonceSess, cbOpaque;
    DWORD dwError, cbAlloced;
    BOOL fSess = FALSE;
    
    szBuf = (LPSTR) pSecBufDesc->pBuffers[0].pvBuffer;
    pcbBuf = &(pSecBufDesc->pBuffers[0].cbBuffer);

    cbAlloced = *pcbBuf;
    *pcbBuf = 0;

    szCNonce = NULL;
    
    if (!cbAlloced)
    {
        // Modern clients better pass in
        // the size of the output buffer.
        if (pSess->fHTTP)
        {
            DIGEST_ASSERT(FALSE);
            dwError = ERROR_INVALID_PARAMETER;
            goto quit;
        }
        else
            // Legacy clients like OE don't, so
            // we allow up to 64k.
            cbAlloced = PACKAGE_MAXTOKEN;
    }

    CHAR szA1[SIZE_MD5_DIGEST + 1],
         szA2[SIZE_MD5_DIGEST + 1],
         szH [SIZE_MD5_DIGEST + 1];


    MD5_CTX md5a1, md5a2, md5h;

    // Get method and request-uri.
    pParams->GetParam(CParams::METHOD, &szMethod, &cbMethod);
    if (pSess->fHTTP)
        pParams->GetParam(CParams::URL,    &szUrl,    &cbUrl);
    else
    {
        // request-uri is empty string for legacy clients.
        szUrl = "";
        cbUrl = 0;
    }


    // Must have both method and request-uri.
    if (!szMethod || !szUrl)
    {
        DIGEST_ASSERT(FALSE);
        dwError = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    // Opaque is optional.
    pParams->GetParam(CParams::_OPAQUE, &szOpaque, &cbOpaque);

    // Unless we are preauthenticating it is possible that
    // the credential does not have a nonce value if the
    // credential was established via ApplyControlToken.
    // In this case we use the nonce received in the challenge.
    if (pInfo->szNonce)
    {
        szNonce = pInfo->szNonce;
        cbNonce = strlen(szNonce);
    }
    else if (!pParams->GetParam(CParams::NONCE, &szNonce, &cbNonce))
    {
        DIGEST_ASSERT(FALSE);
        dwError = ERROR_INVALID_PARAMETER;
        goto quit;
    }    

    // Existance of a client nonce in the credential
    // implies md5-sess. Otherwise we need to create one.
    if (pInfo->szCNonce)
    {
        szCNonceSess = pInfo->szCNonce;
        cbCNonceSess = SIZE_MD5_DIGEST;

        if (pInfo->cCount == 1)
            szCNonce = pInfo->szCNonce;
        else
            szCNonce = MakeCNonce();

        cbCNonce = SIZE_MD5_DIGEST;
        fSess = TRUE;
    }
    // No client nonce means we simply
    // generate one now.
    else
    {
        szCNonce = MakeCNonce();
        cbCNonce = SIZE_MD5_DIGEST;
        szCNonceSess = NULL;
        cbCNonceSess = 0;
        fSess = FALSE;
    }
        
    // Encode nonce count.
    // BUGBUG - wsprintf returns strlen
    // and are any cruntime deps.
    CHAR szNC[16];
    DWORD cbNC;    
    wsprintf(szNC, "%08x", pInfo->cCount);
    cbNC = strlen(szNC);    
    
    // 1) Md5(user:realm:pass) or
    //    Md5(Md5(user:realm:pass):nonce:cnoncesess)
    MD5Init  (&md5a1);
    MD5Update(&md5a1, (LPBYTE) pInfo->szUser, strlen(pInfo->szUser));
    MD5Update(&md5a1, (LPBYTE) ":", 1);
    MD5Update(&md5a1, (LPBYTE) pInfo->szRealm, strlen(pInfo->szRealm));
    MD5Update(&md5a1, (LPBYTE) ":", 1);
    MD5Update(&md5a1, (LPBYTE) pInfo->szPass, strlen(pInfo->szPass));

    if (fSess)
    {
        // Md5(Md5(user:realm:pass):nonce:cnoncesess)
        MD5Final (&md5a1);
        ToHex(md5a1.digest, sizeof(md5a1.digest), szA1);
        MD5Init  (&md5a1);
        MD5Update(&md5a1, (LPBYTE) szA1, SIZE_MD5_DIGEST);
        MD5Update(&md5a1, (LPBYTE) ":", 1);
        MD5Update(&md5a1, (LPBYTE) szNonce, cbNonce);
        MD5Update(&md5a1, (LPBYTE) ":", 1);
        MD5Update(&md5a1, (LPBYTE) szCNonceSess, cbCNonceSess);
    }

    MD5Final (&md5a1);

    ToHex(md5a1.digest, sizeof(md5a1.digest), szA1);

    // 2) Md5(method:url)
    MD5Init  (&md5a2);
    MD5Update(&md5a2, (LPBYTE) szMethod, cbMethod);
    MD5Update(&md5a2, (LPBYTE) ":", 1);
    MD5Update(&md5a2, (LPBYTE) szUrl, cbUrl);
    MD5Final (&md5a2);

    ToHex(md5a2.digest, sizeof(md5a2.digest), szA2);

    // 3) Md5(A1:nonce:nc:cnonce:qop:A2)
    MD5Init  (&md5h);
    MD5Update(&md5h, (LPBYTE) szA1, SIZE_MD5_DIGEST);
    MD5Update(&md5h, (LPBYTE)  ":",    1);
    MD5Update(&md5h, (LPBYTE) szNonce, cbNonce);
    MD5Update(&md5h, (LPBYTE)  ":",    1);
    MD5Update(&md5h, (LPBYTE) szNC,    cbNC);
    MD5Update(&md5h, (LPBYTE)  ":",    1);
    MD5Update(&md5h, (LPBYTE) szCNonce, cbCNonce);
    MD5Update(&md5h, (LPBYTE)  ":",    1);
    MD5Update(&md5h, (LPBYTE) AUTH_SZ, AUTH_LEN);
    MD5Update(&md5h, (LPBYTE)  ":",    1);
    MD5Update(&md5h, (LPBYTE) szA2, SIZE_MD5_DIGEST);
    MD5Final (&md5h);
    
    ToHex(md5h.digest, sizeof(md5h.digest), szH);

    
    // http digest.
    if (pSess->fHTTP)
    {
        if (   AddDigestHeader(szBuf, pcbBuf, "Digest username", 
               pInfo->szUser, cbAlloced, FLAG_QUOTE)

            && AddDigestHeader(szBuf, pcbBuf, "realm", 
               pInfo->szRealm, cbAlloced, FLAG_QUOTE)

            && AddDigestHeader(szBuf, pcbBuf, "qop", 
               "auth", cbAlloced, FLAG_QUOTE)

            && AddDigestHeader(szBuf, pcbBuf, 
               "algorithm", (pInfo->szCNonce ? "MD5-sess" : "MD5"), cbAlloced, FLAG_QUOTE)

            && AddDigestHeader(szBuf, pcbBuf, "uri", szUrl, cbAlloced, FLAG_QUOTE)

            && AddDigestHeader(szBuf, pcbBuf, "nonce", szNonce, cbAlloced, FLAG_QUOTE)

            && AddDigestHeader(szBuf, pcbBuf, "nc", szNC, cbAlloced, 0)
        
            && AddDigestHeader(szBuf, pcbBuf, "cnonce", szCNonce, cbAlloced, FLAG_QUOTE)

            && (!szOpaque || AddDigestHeader(szBuf, pcbBuf, "opaque", szOpaque, cbAlloced, FLAG_QUOTE))

            && AddDigestHeader(szBuf, pcbBuf, 
                "response", szH, cbAlloced, FLAG_QUOTE | FLAG_TERMINATE)
           )
        {
            dwError = ERROR_SUCCESS;
        }
        else
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            *pcbBuf = 0;
        }
    }
    else
    {
        if (   AddDigestHeader(szBuf, pcbBuf, "Digest username", 
               pInfo->szUser, cbAlloced, FLAG_QUOTE)

            && AddDigestHeader(szBuf, pcbBuf, "realm", 
               pInfo->szRealm, cbAlloced, FLAG_QUOTE)

            && AddDigestHeader(szBuf, pcbBuf, "qop", 
               "auth", cbAlloced, FLAG_QUOTE)

            && AddDigestHeader(szBuf, pcbBuf, 
               "algorithm", (pInfo->szCNonce ? "MD5-sess" : "MD5"), cbAlloced, FLAG_QUOTE)

            && AddDigestHeader(szBuf, pcbBuf, "nonce", szNonce, cbAlloced, FLAG_QUOTE)
        
            && AddDigestHeader(szBuf, pcbBuf, "cnonce", szCNonce, cbAlloced, FLAG_QUOTE)

            && AddDigestHeader(szBuf, pcbBuf, 
                "response", szH, cbAlloced, FLAG_QUOTE | FLAG_TERMINATE)
            )
        {
            dwError = ERROR_SUCCESS;
        }
        else
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            *pcbBuf = 0;
        }
    }        

quit:
    if (szCNonce && szCNonce != pInfo->szCNonce)
        delete szCNonce;
        
    return dwError;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\digest\cred.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    cred.cxx

Abstract:

    Shared memory data structures for digest sspi package.


Author:

    Adriaan Canter (adriaanc) 01-Aug-1998

--*/

#include "include.hxx"


//////////////////////////////////////////////////////////////////////
//
//                      CEntry Functions
//
//////////////////////////////////////////////////////////////////////


//--------------------------------------------------------------------
// CEntry::Free 
// BUGBUG - inline this.
//--------------------------------------------------------------------
DWORD CEntry::Free(CMMFile *pMMFile, CEntry *pEntry)
{
    BOOL bFree = pMMFile->FreeEntry(pEntry);
    return (bFree ? ERROR_SUCCESS : ERROR_INTERNAL_ERROR);
}

//--------------------------------------------------------------------
// CEntry::GetNext
//--------------------------------------------------------------------
CEntry* CEntry::GetNext(CEntry *pEntry)
{
    if (pEntry->dwNext)
        return (CEntry*) OFFSET_TO_POINTER(g_pHeap, pEntry->dwNext);
    return NULL;
}

//--------------------------------------------------------------------
// CEntry::GetPrev
//--------------------------------------------------------------------
CEntry* CEntry::GetPrev(CEntry *pEntry)
{
    if (pEntry->dwPrev)
        return (CEntry*) OFFSET_TO_POINTER(g_pHeap, pEntry->dwPrev);
    return NULL;
}


//////////////////////////////////////////////////////////////////////
//
//                      CSess Functions
//
//////////////////////////////////////////////////////////////////////



//--------------------------------------------------------------------
// CSess::Create
//--------------------------------------------------------------------
CSess* CSess::Create(CMMFile *pMMFile, 
    LPSTR szAppCtx, LPSTR szUserCtx, BOOL fHTTP)
{
    DIGEST_ASSERT(pMMFile);

    // Unaligned Sess lengths.
    DWORD cbAppCtx  = szAppCtx  ?  strlen(szAppCtx)  + 1 : 0;
    DWORD cbUserCtx = szUserCtx ?  strlen(szUserCtx) + 1 : 0;

    // Aligned Sess lengths.
    DWORD cbStructAligned  = ROUNDUPDWORD(sizeof(CSess));
    DWORD cbAppCtxAligned  = ROUNDUPDWORD(cbAppCtx);
    DWORD cbUserCtxAligned = ROUNDUPDWORD(cbUserCtx);

    // Total number of required bytes (aligned).
    DWORD cbEntryAligned = cbStructAligned 
        + cbAppCtxAligned + cbUserCtxAligned;

    // Allocate from mem map.
    CSess *pSess = (CSess*) pMMFile->AllocateEntry(cbEntryAligned);

    if (!pSess)
    {
        DIGEST_ASSERT(FALSE);
        goto exit;
    }
    
    DWORD cbCurrentOffset;
    cbCurrentOffset = cbStructAligned;

    pSess->dwAppCtx = pSess->dwUserCtx = 0;
    
    // AppCtx
    if (szAppCtx)
    {
        memcpy(OFFSET_TO_POINTER(pSess, cbCurrentOffset), szAppCtx, cbAppCtx);
        pSess->dwAppCtx = cbCurrentOffset;
        cbCurrentOffset += cbAppCtxAligned;
    }
        
    // UserCtx
    if (szUserCtx)
    {
        memcpy(OFFSET_TO_POINTER(pSess, cbCurrentOffset), szUserCtx, cbUserCtx);
        pSess->dwUserCtx = cbCurrentOffset;
    }

    // No need to advance cbCurrentOffset.
    
    pSess->cbSess = cbEntryAligned;
    pSess->dwCred = 0;
    pSess->dwSig = SIG_SESS;
    pSess->fHTTP = fHTTP;
    pSess->dwPrev = 0;
    pSess->dwNext = 0;

exit:

    return pSess;
}

//--------------------------------------------------------------------
// CSess::GetAppCtx
//--------------------------------------------------------------------
LPSTR CSess::GetAppCtx(CSess *pSess)
{
    if (pSess->dwAppCtx)
        return (LPSTR) OFFSET_TO_POINTER(pSess, pSess->dwAppCtx);
    else
        return NULL;
}
 
//--------------------------------------------------------------------
// CSess::GetUserCtx
//--------------------------------------------------------------------
LPSTR CSess::GetUserCtx(CSess *pSess)
{
    if (pSess->dwUserCtx)
        return (LPSTR) OFFSET_TO_POINTER(pSess, pSess->dwUserCtx);
    else
        return NULL;
}
        
//--------------------------------------------------------------------
// CSess::GetCtx
// Allocates a context string in local heap.
//--------------------------------------------------------------------
LPSTR CSess::GetCtx(CSess *pSess)
{
    DIGEST_ASSERT(pSess);

    LPSTR szAppCtx, szUserCtx, szCtx;
    DWORD cbAppCtx, cbUserCtx, cbCtx;

    szAppCtx  = GetAppCtx(pSess);
    szUserCtx = GetUserCtx(pSess);
    
    cbAppCtx  = szAppCtx  ? strlen(szAppCtx) : 0;
    cbUserCtx = szUserCtx ? strlen(szUserCtx) : 0;

    cbCtx = cbAppCtx + sizeof(':') + cbUserCtx + sizeof('\0');

    szCtx = new CHAR[cbCtx];
    if (!szCtx)
    {
        DIGEST_ASSERT(FALSE);
        return NULL;
    }
    
    // "appctx:userctx\0"
    // bugbug - macro for sizeof -1
    memcpy(szCtx, szAppCtx, cbAppCtx);
    memcpy(szCtx + cbAppCtx, ":", sizeof(":") - 1);
    memcpy(szCtx + cbAppCtx + sizeof(":") - 1, szUserCtx, cbUserCtx);
    memcpy(szCtx + cbAppCtx + sizeof(":") - 1 + cbUserCtx, "\0", sizeof("\0") - 1);

    return szCtx;
}

//--------------------------------------------------------------------
// CSess::CtxMatch
//--------------------------------------------------------------------
BOOL CSess::CtxMatch(CSess *pSess1, CSess *pSess2)
{
    DIGEST_ASSERT(pSess1 && pSess2);
    
    LPSTR szAppCtx1, szAppCtx2, szUserCtx1, szUserCtx2;
    
    szAppCtx1   = CSess::GetAppCtx(pSess1);
    szAppCtx2   = CSess::GetAppCtx(pSess2);
    szUserCtx1  = CSess::GetUserCtx(pSess1);
    szUserCtx2  = CSess::GetUserCtx(pSess2);

    // If both AppCtx values are NULL or
    // are equal to same string.
    if ((!szAppCtx1 && !szAppCtx2)
        || ((szAppCtx1 && szAppCtx2) 
            && !strcmp(szAppCtx1, szAppCtx2)))
    {
        // And both UserCtx values are NULL or
        // are equal to same string.
        if ((!szUserCtx1 && !szUserCtx2)
            || ((szUserCtx1 && szUserCtx2) 
                && !strcmp(szUserCtx1, szUserCtx2)))
        
        {
            // Credentials are shareable.
            return TRUE;
        }
    }
    // Otherwise creds are not shareable.
    return FALSE;
}

//--------------------------------------------------------------------
// CSess::GetCred
//--------------------------------------------------------------------
CCred *CSess::GetCred(CSess* pSess)
{
    if (!pSess->dwCred)
        return NULL;
    return (CCred*) OFFSET_TO_POINTER(g_pHeap, pSess->dwCred);
}

//--------------------------------------------------------------------
// CSess::SetCred
//--------------------------------------------------------------------
CCred *CSess::SetCred(CSess* pSess, CCred* pCred)
{
    if (!pCred)
        pSess->dwCred = 0;
    else
        pSess->dwCred = POINTER_TO_OFFSET(g_pHeap, pCred);

    return pCred;
}


//////////////////////////////////////////////////////////////////////
//
//                      CList Functions
//
//////////////////////////////////////////////////////////////////////


//--------------------------------------------------------------------
// CList::CList
//--------------------------------------------------------------------
CList::CList()
{
    _pHead = NULL;
    _pCur = NULL;
    _pdwOffset = NULL;
}


//--------------------------------------------------------------------
// CList::Init
//--------------------------------------------------------------------
CEntry* CList::Init(LPDWORD pdwOffset)
{
    DIGEST_ASSERT(pdwOffset)

    _pdwOffset = pdwOffset;

    if (*pdwOffset)
    {    
        _pHead = (CEntry*) OFFSET_TO_POINTER(g_pHeap, *pdwOffset);
        _pCur = _pHead;
    }
    return _pHead;
}


//--------------------------------------------------------------------
// CList::Seek
//--------------------------------------------------------------------
CEntry* CList::Seek()
{
//    DIGEST_ASSERT(_pHead);
    _pHead = (CEntry*) OFFSET_TO_POINTER(g_pHeap, *_pdwOffset);
    _pCur = _pHead;
    return _pCur;
}

//--------------------------------------------------------------------
// CList::GetNext
//--------------------------------------------------------------------
CEntry* CList::GetNext()
{
    if (! *_pdwOffset)
        return NULL;

    CEntry *pEntry = _pCur;

    if (_pCur)
        _pCur = _pCur->dwNext ? 
            (CEntry*) OFFSET_TO_POINTER(g_pHeap, _pCur->dwNext) : NULL;

    return pEntry;
}

//--------------------------------------------------------------------
// CList::GetPrev
//--------------------------------------------------------------------
CEntry* CList::GetPrev()
{
    if (! *_pdwOffset)
        return NULL;

    CEntry *pEntry = _pCur;

    if (_pCur)
        _pCur = _pCur->dwPrev ?
            (CEntry*) OFFSET_TO_POINTER(g_pHeap, _pCur->dwPrev) : NULL;

    return pEntry;
}

//--------------------------------------------------------------------
// CList::Insert
//--------------------------------------------------------------------
CEntry* CList::Insert(CEntry *pEntry)
{
    // BUGBUG - assert pnext pprev are null
    DIGEST_ASSERT(pEntry 
        && (pEntry->dwPrev == pEntry->dwNext == 0));

    if (!_pHead)
    {
        _pHead = pEntry;
    }
    else
    {
        pEntry->dwNext = POINTER_TO_OFFSET(g_pHeap, _pHead);        
        _pHead->dwPrev = POINTER_TO_OFFSET(g_pHeap, pEntry);
        _pHead = pEntry;
    }

    *_pdwOffset = POINTER_TO_OFFSET(g_pHeap, pEntry);

    return pEntry;
}

//--------------------------------------------------------------------
// CList::DeLink
//--------------------------------------------------------------------
CEntry* CList::DeLink(CEntry *pEntry)
{        
    DIGEST_ASSERT(pEntry);

    if (pEntry == _pHead)
    {
        _pHead = (CEntry*) OFFSET_TO_POINTER(g_pHeap, pEntry->dwNext);
        *_pdwOffset = POINTER_TO_OFFSET(g_pHeap, _pHead);
    }
    else
    {
        CEntry *pPrev;
        pPrev = (CEntry*) OFFSET_TO_POINTER(g_pHeap, pEntry->dwPrev);
        pPrev->dwNext = pEntry->dwNext;
    }

    if (pEntry->dwNext)
    {
        CEntry *pNext;
        pNext = (CEntry*) OFFSET_TO_POINTER(g_pHeap, pEntry->dwNext);
        pNext->dwPrev = pEntry->dwPrev;
    }

    if (_pCur == pEntry)
    {
        _pCur = (CEntry*) OFFSET_TO_POINTER(g_pHeap, pEntry->dwNext);
    }


    return pEntry;
}


//////////////////////////////////////////////////////////////////////
//
//                      CCred Functions
//
//////////////////////////////////////////////////////////////////////


//--------------------------------------------------------------------
// CCred::Create
//--------------------------------------------------------------------
CCred* CCred::Create(CMMFile *pMMFile,
    LPSTR szHost, LPSTR szRealm, LPSTR szUser, 
    LPSTR szPass, LPSTR szNonce, LPSTR szCNonce)
{
    // BUGBUG - assert strings non-null. Nonce can be NULL.
    DIGEST_ASSERT(pMMFile && szRealm && szUser && szPass);
    
    // Unaligned string sizes.
    DWORD cbRealm = szRealm ?  strlen(szRealm)  + 1 : 0;
    DWORD cbUser  = szUser  ?  strlen(szUser)   + 1 : 0;
    DWORD cbPass  = szPass  ?  strlen(szPass)   + 1 : 0;

    
    // Aligned string sizes.
    DWORD cbStructAligned   = ROUNDUPDWORD(sizeof(CCred));
    DWORD cbRealmAligned    = ROUNDUPDWORD(cbRealm);
    DWORD cbUserAligned     = ROUNDUPDWORD(cbUser);
    DWORD cbPassAligned     = ROUNDUPDWORD(cbPass);

    // Total number of required bytes (aligned).
    DWORD cbEntryAligned = cbStructAligned 
        + cbRealmAligned 
        + cbUserAligned 
        + cbPassAligned;

    // Allocate cred and nonce from memmap
    // BUGBUG - MASKING PNONCE
    // BUGBUG - no, I'm not.
    CCred  *pCred;
    CNonce *pNonce, *pCNonce;
    pNonce = pCNonce = NULL;
    
    // Allocate a credential.
    pCred = (CCred*) pMMFile->AllocateEntry(cbEntryAligned);
    if (!pCred)
    {
        DIGEST_ASSERT(FALSE);
        goto exit;
    }
    
        
    DWORD cbCurrentOffset;
    cbCurrentOffset = cbStructAligned;
   
    // Realm.
    memcpy(OFFSET_TO_POINTER(pCred, cbCurrentOffset), szRealm, cbRealm);
    pCred->dwRealm = cbCurrentOffset;
    cbCurrentOffset += cbRealmAligned;
    
    // User
    memcpy(OFFSET_TO_POINTER(pCred, cbCurrentOffset), szUser, cbUser);
    pCred->dwUser = cbCurrentOffset;
    cbCurrentOffset += cbUserAligned;

    // Pass
    memcpy(OFFSET_TO_POINTER(pCred, cbCurrentOffset), szPass, cbPass);
    pCred->dwPass = cbCurrentOffset;

        
    pCred->cbCred = cbEntryAligned;
    pCred->tStamp = GetTickCount();
    pCred->dwSig = SIG_CRED;
    pCred->dwPrev = NULL;
    pCred->dwNext = NULL;

    pCred->dwNonce = 0;
    pCred->dwCNonce = 0;

    // Allocate nonce and client nonce if specified.
    if (szNonce)
        CCred::SetNonce(pMMFile, pCred, szHost, szNonce, SERVER_NONCE);
        
    if (szCNonce)
        CCred::SetNonce(pMMFile, pCred, szHost, szCNonce, CLIENT_NONCE);
exit:

    return pCred;
}

//--------------------------------------------------------------------
// CCred::GetRealm
//--------------------------------------------------------------------
LPSTR CCred::GetRealm(CCred* pCred)
{
    DIGEST_ASSERT(pCred);
    if (pCred->dwRealm)
        return (LPSTR) OFFSET_TO_POINTER(pCred, pCred->dwRealm);
    else
        return NULL;
}
        
//--------------------------------------------------------------------
// CCred::GetUser
//--------------------------------------------------------------------
LPSTR CCred::GetUser(CCred* pCred)
{
    DIGEST_ASSERT(pCred);
    if (pCred->dwUser)
        return (LPSTR) OFFSET_TO_POINTER(pCred, pCred->dwUser);
    else
        return NULL;
}

//--------------------------------------------------------------------
// CCred::GetPass
//--------------------------------------------------------------------
LPSTR CCred::GetPass(CCred* pCred)
{
    DIGEST_ASSERT(pCred);
    if (pCred->dwPass)
        return (LPSTR) OFFSET_TO_POINTER(pCred, pCred->dwPass);
    else
        return NULL;
}

//--------------------------------------------------------------------
// CCred::SetNonce
//--------------------------------------------------------------------
VOID CCred::SetNonce(CMMFile *pMMFile, CCred* pCred, 
    LPSTR szHost, LPSTR szNonce, DWORD dwType)
{
    DIGEST_ASSERT(pCred && szNonce);

    // First determine if a nonce for the specified host
    // already exists and delete it if it does.
    CList NonceList;
    NonceList.Init(dwType == SERVER_NONCE ? 
        &pCred->dwNonce : &pCred->dwCNonce);

    CNonce *pNonce;
    while (pNonce = (CNonce*) NonceList.GetNext())
    {
        if (CNonce::IsHostMatch(pNonce, szHost))
        {
            NonceList.DeLink(pNonce);
            CEntry::Free(pMMFile, pNonce);
            break;
        }        
    }
        
    // Create a CNonce object and insert it into the list.
    pNonce = CNonce::Create(pMMFile, szHost, szNonce);
    if (pNonce)
    {
        NonceList.Seek();
        NonceList.Insert(pNonce);    
    }
    else
    {
        DIGEST_ASSERT(FALSE);
    }
    
}


//--------------------------------------------------------------------
// CCred::GetNonce
//--------------------------------------------------------------------
CNonce *CCred::GetNonce(CCred* pCred, LPSTR szHost, DWORD dwType)
{
    CNonce *pNonce;
    CList NonceList;
    NonceList.Init(dwType == SERVER_NONCE ? 
        &pCred->dwNonce : &pCred->dwCNonce);

    while (pNonce = (CNonce*) NonceList.GetNext())
    {
        if (CNonce::IsHostMatch(pNonce, szHost))
            break;
    }
    return pNonce;
}

//--------------------------------------------------------------------
// CCred::Free
//--------------------------------------------------------------------
VOID CCred::Free(CMMFile *pMMFile, CSess *pSess, CCred *pCred)
{
    CNonce *pNonce;
    CList NonceList;

    // Free up server nonce.
    NonceList.Init(&pCred->dwNonce);
    while (pNonce = (CNonce*) NonceList.GetNext())
    {
        NonceList.DeLink(pNonce);
        CEntry::Free(pMMFile, pNonce);
    }

    // Free up client nonce.
    NonceList.Init(&pCred->dwCNonce);
    while (pNonce = (CNonce*) NonceList.GetNext())
    {
        NonceList.DeLink(pNonce);
        CEntry::Free(pMMFile, pNonce);
    }

    // Remove credential from session's list.
    CList CredList;
    CredList.Init(&pSess->dwCred);
    CredList.DeLink(pCred);
    CEntry::Free(pMMFile, pCred);
}


//////////////////////////////////////////////////////////////////////
//
//                      CNonce Functions
//
//////////////////////////////////////////////////////////////////////


//--------------------------------------------------------------------
// CNonce::Create
//--------------------------------------------------------------------
CNonce* CNonce::Create(CMMFile *pMMFile, LPSTR szHost, LPSTR szNonce)
{
    DIGEST_ASSERT(pMMFile && szNonce);

    // Unaligned string sizes.
    DWORD cbNonce = szNonce ?  strlen(szNonce)  + 1 : 0;
    DWORD cbHost = szHost ?  strlen(szHost)  + 1 : 0;
    
    // Aligned string sizes.
    DWORD cbStructAligned   = ROUNDUPDWORD(sizeof(CNonce));
    DWORD cbNonceAligned    = ROUNDUPDWORD(cbNonce);
    DWORD cbHostAligned    = ROUNDUPDWORD(cbHost);

    // Total number of required bytes (aligned).
    DWORD cbEntryAligned = cbStructAligned 
        + cbHostAligned
        + cbNonceAligned;

    // Allocate from mem map.
    CNonce *pNonce = (CNonce*) pMMFile->AllocateEntry(cbEntryAligned);

    // Failed to allocate. 
    if (!pNonce)
    {
        DIGEST_ASSERT(FALSE);
        goto exit;
    }
    
    DWORD cbCurrentOffset;
    cbCurrentOffset = cbStructAligned;
   
    // Host.
    if (szHost)
    {
        memcpy(OFFSET_TO_POINTER(pNonce, cbCurrentOffset), szHost, cbHost);
        pNonce->dwHost = cbCurrentOffset;
        cbCurrentOffset += cbHostAligned;
    }
    else
    {
        pNonce->dwHost = 0;
    }

    // Nonce.
    memcpy(OFFSET_TO_POINTER(pNonce, cbCurrentOffset), szNonce, cbNonce);
    pNonce->dwNonce = cbCurrentOffset;
    cbCurrentOffset += cbNonceAligned;
    
    pNonce->cbNonce = cbEntryAligned;
    pNonce->cCount  = 0;

    pNonce->dwSig = SIG_NONC;
    pNonce->dwPrev = 0;
    pNonce->dwNext = 0;

exit:

    return pNonce;
}


//--------------------------------------------------------------------
// CNonce::GetNonce
//--------------------------------------------------------------------
LPSTR CNonce::GetNonce(CNonce* pNonce)
{
    if (pNonce && pNonce->dwNonce)
        return (LPSTR) OFFSET_TO_POINTER(pNonce, pNonce->dwNonce);
    else
        return NULL;
}

//--------------------------------------------------------------------
// CNonce::GetCount
// bugbug - what if no nonce?
//--------------------------------------------------------------------
DWORD CNonce::GetCount(CNonce* pNonce)
{
    DIGEST_ASSERT(pNonce);
    return pNonce->cCount;
}


//--------------------------------------------------------------------
// CNonce::IsHostMatch
//--------------------------------------------------------------------
BOOL CNonce::IsHostMatch(CNonce *pNonce, LPSTR szHost)
{
    if (szHost)
    {
        if (pNonce->dwHost 
            && !strcmp(szHost, (LPSTR) OFFSET_TO_POINTER(pNonce, pNonce->dwHost)))
            return TRUE;
        return FALSE;
    }

    if (!pNonce->dwHost)
        return TRUE;
    return FALSE;
}


//////////////////////////////////////////////////////////////////////
//
//                  CCredInfo Functions
//
//////////////////////////////////////////////////////////////////////


//--------------------------------------------------------------------
// CCredInfo::CCredInfo
//--------------------------------------------------------------------
CCredInfo::CCredInfo(CCred* pCred, LPSTR szHost)
{
    DIGEST_ASSERT(pCred 
        && (pCred->dwPass > pCred->dwUser) 
        && (pCred->dwUser > pCred->dwRealm));
    
    CCredInfo::szHost   = NewString(szHost);
    szRealm   = NewString(CCred::GetRealm(pCred));
    szUser    = NewString(CCred::GetUser(pCred));
    szPass    = NewString(CCred::GetPass(pCred));

    // Get server nonce. This is always required.
    // BUGBUG - what about pre-loading?
    CNonce *pNonce;
    pNonce = CCred::GetNonce(pCred, szHost, SERVER_NONCE);
    if (!pNonce)
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        return;
    }
    szNonce = NewString(CNonce::GetNonce(pNonce));
    cCount = pNonce->cCount;
    
    pNonce = CCred::GetNonce(pCred, szHost, CLIENT_NONCE);
    if (pNonce)
        szCNonce = NewString(CNonce::GetNonce(pNonce));
    else
        szCNonce = NULL;

    tStamp = pCred->tStamp;
    pPrev = NULL;
    pNext = NULL;
    dwStatus = ERROR_SUCCESS;

}    

//--------------------------------------------------------------------
// CCredInfo::CCredInfo
// BUGBUG - special casing for NULLs, especially szNonce.
//--------------------------------------------------------------------
CCredInfo::CCredInfo(LPSTR szHost, LPSTR szRealm, LPSTR szUser, 
    LPSTR szPass, LPSTR szNonce, LPSTR szCNonce)
{       
    CCredInfo::szHost    = NewString(szHost);
    CCredInfo::szRealm   = NewString(szRealm);
    CCredInfo::szUser    = NewString(szUser);
    CCredInfo::szPass    = NewString(szPass);
    CCredInfo::szNonce   = NewString(szNonce);
    CCredInfo::szCNonce  = NewString(szCNonce);

    cCount = 0;
    tStamp = 0;
    pPrev = NULL;
    pNext = NULL;
    
    dwStatus = ERROR_SUCCESS;
}

//--------------------------------------------------------------------
// CCredInfo::~CCredInfo
//--------------------------------------------------------------------
CCredInfo::~CCredInfo()
{       
    if (szHost)
        delete [] szHost;
    if (szRealm)
        delete [] szRealm;
    if (szUser)
        delete [] szUser;
    if (szPass)
        delete [] szPass;
    if (szNonce)
        delete [] szNonce;
    if (szCNonce)
        delete [] szCNonce;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\digest\digestui.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    digestui.cxx

Abstract:

    Authentication UI for digest sspi package.

Author:

    Adriaan Canter (adriaanc) 01-Aug-1998

History

    Sudeep Bharati (sudeepb) 24-Sep-1998
    Added support for ms specific header additions for Trustmarks
    Added support for Passport specific header additions for custom text,
    Trustmarks support and Register me button. Passport specific support
    also adds some rules on the typed in username.

    Adriaan Canter (adriaanc) 16-Dec-1998
    Expunged all Passport code.

--*/
#include "include.hxx"
#include "resource.h"
#include "exdisp.h"

HANDLE		    hDigest;

// BUGBUG - DISABLE DROP DOWN IF NO CREDS.
//--------------------------------------------------------------------
// DigestErrorDlg
//--------------------------------------------------------------------
DWORD DigestErrorDlg(LPSTR szCtx, LPSTR szHost, LPSTR szRealm,
   LPSTR szUser, LPSTR szNonce, LPSTR szCNonce, CCredInfo *pInfoIn,
   CCredInfo **ppInfoOut, HWND hWnd)
{
    INT nResult = 0;
    DWORD dwError = ERROR_SUCCESS;
    LPTSTR  lpRes;
    DigestDlgParams DlgPrms;

    // Parameters to be passed to DigestAuthDialogProc.
    DlgPrms.szCtx   = szCtx;
    DlgPrms.szHost  = szHost;
    DlgPrms.szRealm = szRealm;
    DlgPrms.szUser  = szUser;
    DlgPrms.szNonce = szNonce;
    DlgPrms.szCNonce = szCNonce;
    DlgPrms.pInfoIn = pInfoIn;


    LPARAM lpParam = (LPARAM) &DlgPrms;
    if (WaitForSingleObject (hDigest, INFINITE) != WAIT_OBJECT_0) {
	    dwError = ERROR_NOT_READY;
	    goto quit;
    }

    lpRes = MAKEINTRESOURCE(IDD_DIGEST);


    nResult = (INT)DialogBoxParam(g_hModule,
			     lpRes,
                             hWnd,
                             DigestAuthDialogProc,
                             (LPARAM) lpParam);


    if (nResult == FALSE || nResult == -1)
    {
        dwError = ERROR_CANCELLED;
        *ppInfoOut = NULL;
        goto quit;
    }

    // *ppInfoOut points to a CCredInfo created in the
    // DigestAuthDialog proc.
    *ppInfoOut = DlgPrms.pInfoOut;

quit:
    // delete DlgPrms.szCtx; biaow: we should NOT delete here; the caller will take care of this
    return dwError;
}



//--------------------------------------------------------------------
// DigestAuthDialogProc
//--------------------------------------------------------------------
INT_PTR CALLBACK DigestAuthDialogProc(HWND hwnd, UINT msg,
    WPARAM wparam, LPARAM lparam)
{
    static CCredInfo *pList = NULL;
    static HWND hCtrlText,hCtrlVerify;

    PDigestDlgParams pDlgPrms;
    USHORT len;
    LPSTR   p,q;

    CHAR szUser[MAX_USERNAME_LEN + 1];
    CHAR szPass[MAX_PASSWORD_LEN + 1];

    BOOL fCreated    = FALSE;
    BOOL fPersisted = FALSE;

    BSTR bstr;
    CHAR szTextTemp [MAX_LOGIN_TEXT];
    CHAR szText [MAX_LOGIN_TEXT];

    switch (msg)
    {
        // Dialog is being initialized.
        case WM_INITDIALOG:
        {
            ReleaseMutex (hDigest);

            // pDlgPrms->pInfoIn can be NULL or point
            // to one or more CCredInfo structs.
            pDlgPrms = (DigestDlgParams *) lparam;
            DIGEST_ASSERT(pDlgPrms);

            SetWindowLongPtr(hwnd, DWLP_USER, lparam);

            SetForegroundWindow(hwnd);

	    // Take Care of Host field

	    hCtrlText = GetDlgItem (hwnd, IDD_LOGIN_TEXT1);
	    len = (USHORT)GetWindowText (hCtrlText,szTextTemp,MAX_LOGIN_TEXT);
	    if (len == 0) {
		DIGEST_ASSERT(FALSE);
		EndDialog (hwnd, FALSE);
		return TRUE;
	    }
	    if ((p = strchr (szTextTemp, '%')) == NULL) {
		DIGEST_ASSERT(FALSE);
		EndDialog (hwnd, FALSE);
		return TRUE;
	    }
	    *p++ = '\0';
	    strcpy (szText, szTextTemp);
	    if (pDlgPrms->szHost)
		strcat (szText,pDlgPrms->szHost);
	    else {
		if (len = (USHORT)LoadString (g_hModule,IDS_STRING_UDOMAIN,
				     szUser,MAX_USERNAME_LEN))
		    strcat (szText,szUser);
	    }
	    strcat (szText, p);
	    if (!SetWindowText (hCtrlText,szText)) {
		DIGEST_ASSERT(FALSE);
		EndDialog (hwnd, FALSE);
		return TRUE;
	    }


	    // Take care of Realm and Hint fields. Remember Passport has
	    // hard coded text for this second line.
		hCtrlText = GetDlgItem (hwnd, IDD_LOGIN_TEXT2);
		len = (USHORT)GetWindowText (hCtrlText,szTextTemp,MAX_LOGIN_TEXT);
		if (len == 0) {
		    DIGEST_ASSERT(FALSE);
		    EndDialog (hwnd, FALSE);
		    return TRUE;
		}
		if ((p = strchr (szTextTemp, '%')) == NULL) {
			DIGEST_ASSERT(FALSE);
			EndDialog (hwnd, FALSE);
			return TRUE;
		}
		*p++ = '\0';
		strcpy (szText, szTextTemp);
		if (pDlgPrms->szRealm)
        {
			DWORD dwAvailBuf = MAX_LOGIN_TEXT - strlen(szText);
            strncpy(szText + strlen(szText), pDlgPrms->szRealm, dwAvailBuf - 1);
            szText[MAX_LOGIN_TEXT - 1] = 0;
            // strcat (szText,pDlgPrms->szRealm);
        }
		else {
		    if (len = (USHORT)LoadString (g_hModule,IDS_STRING_UREALM,
					 szUser,MAX_USERNAME_LEN))
			strcat (szText,szUser);
		}

		strcat (szText,p);

		if (!SetWindowText (hCtrlText,szText)) {
			DIGEST_ASSERT(FALSE);
			EndDialog (hwnd, FALSE);
			return TRUE;
		}

            // Determine if credential persistence is available.
            if (g_dwCredPersistAvail == CRED_PERSIST_UNKNOWN)
                g_dwCredPersistAvail = InetInitCredentialPersist();

            // If credential persist not available, hide checkbox.
            if (g_dwCredPersistAvail == CRED_PERSIST_NOT_AVAIL)
                ShowWindow(GetDlgItem(hwnd, IDC_SAVE_PASSWORD), SW_HIDE);


            // Find any persisted credential.
            if (g_dwCredPersistAvail
                && ((InetGetCachedCredentials(pDlgPrms->szCtx, pDlgPrms->szRealm,
                    szUser, szPass) == ERROR_SUCCESS)))
            {
                // Retrieved a set of credentials. If a username was passed
                // in check to see that the persisted username matches.
                if (!pDlgPrms->szUser || !strcmp(pDlgPrms->szUser, szUser))
                {
                    // No username passed in or usernames match.
                    // Create a CCredInfo and insert it into head of list.
                    pList = new CCredInfo(pDlgPrms->szHost, pDlgPrms->szRealm, szUser, szPass,
                        pDlgPrms->szNonce, pDlgPrms->szCNonce);
                    if (!pList || pList->dwStatus != ERROR_SUCCESS)
                    {
                        DIGEST_ASSERT(FALSE);
                        return FALSE;
                    }
                    // Insert it at the beginning of the list.
                    pList->pNext = pDlgPrms->pInfoIn;
                    if (pDlgPrms->pInfoIn)
                        pDlgPrms->pInfoIn->pPrev = pList;

                    fPersisted = TRUE;
                    fCreated = TRUE;
                }
            }

            // If we did not retrieve a persisted credential, check to see
            // if we need to create a dummy credential.
            if (!fPersisted)
            {
                // Create a dummy credential if a username was passed in
                // but a credential was not retrieved from memory.
                if (pDlgPrms->szUser && !pDlgPrms->pInfoIn)
                {
                    pList = new CCredInfo(pDlgPrms->szHost, pDlgPrms->szRealm, pDlgPrms->szUser, NULL,
                        pDlgPrms->szNonce, pDlgPrms->szCNonce);
                    fCreated = TRUE;
                }
                else
                {
                    // Otherwise, just point to the creds
                    // retrieved from memory.
                    pList = pDlgPrms->pInfoIn;
                }

            }
            else
            {
                // A persisted credential was created and inserted
                // into the beginning of the list. The list may
                // contain a CCredInfo with a matching user.
                // remove any (at most one) duplicate entry.
                CCredInfo *pCur;
                pCur = pList->pNext;
                while (pCur)
                {
                    if (!strcmp(pCur->szUser, pList->szUser))
                    {
                        pCur->pPrev->pNext = pCur->pNext;
                        if (pCur->pNext)
                            pCur->pNext->pPrev = pCur->pPrev;

                        break;
                    }
                    pCur = pCur->pNext;
                }
            }

            // The list is now in the correct format:
            // 1) pList may be NULL
            // 2) pList may have a dummy credential for username with no password.
            // 3) pList may have one credential for username with password.
            // 4) pList may have one or more credentials for different usernames.

            // Limit drop-down if no items in list.
            if (!pList)
            {
                SendMessage(GetDlgItem(hwnd, IDC_COMBO1), CB_ADDSTRING, 0, (LPARAM) (LPCSTR) "");
            }

            // Populate the combo box with the list contents.
            CCredInfo *pCur;
            pCur = pList;
            while (pCur)
            {
                SendMessage(GetDlgItem(hwnd, IDC_COMBO1), CB_ADDSTRING, 0, (LPARAM) (LPCSTR) pCur->szUser);
                pCur = pCur->pNext;
            }

            // If the first item in the combo box was created (user given or persisted)
            // set it as the default and set it's password in the password control.
            // Indicate if credentials are from persisted store.

            // Default to 0th item.
            SendMessage(GetDlgItem(hwnd, IDC_COMBO1), CB_SETCURSEL, 0, 0);

            // Set password field if extant.
            if (pList)
                SetWindowText (GetDlgItem(hwnd,IDC_PASSWORD_FIELD), pList->szPass);

            // Indicate if credentials from persisted store.
            if (fPersisted)
                CheckDlgButton(hwnd, IDC_SAVE_PASSWORD, BST_CHECKED);

            SetFocus(GetDlgItem(hwnd, IDC_COMBO1));

            // Return FALSE since we are always setting the keyboard focus.
            return FALSE;
        }

        // WM comands from action on dialog.
        case WM_COMMAND:
        {
            WORD wID               = LOWORD(wparam);
            WORD wNotificationCode = HIWORD(wparam);
            HWND hWndCtrl          = (HWND) lparam;

            pDlgPrms = (DigestDlgParams*) GetWindowLongPtr(hwnd, DWLP_USER);
            DIGEST_ASSERT(pDlgPrms);

            // User has selected something on the combo-box.
            switch(wNotificationCode)
            {
                // User has selected a drop-down item.
                case CBN_SELCHANGE:
                {
                    // Get the index of the selected item.
                    DWORD nIndex;
                    nIndex = (DWORD)SendMessage(GetDlgItem(hwnd, IDC_COMBO1), CB_GETCURSEL, 0, 0);
                    if (nIndex == -1)
                    {
                        SendMessage(GetDlgItem(hwnd, IDC_COMBO1), CB_SETCURSEL, 0, 0);
                        return FALSE;
                    }

                    // Point to the indexed CCredInfo entry
                    CCredInfo *pCur;
                    pCur = pList;
                    for (DWORD i = 0; i < nIndex ; i++)
                        pCur = pCur->pNext;

                    // Set password of the indexed CCredInfo struct.
                    SetWindowText (GetDlgItem(hwnd,IDC_PASSWORD_FIELD), pCur ? pCur->szPass : "");

                    // User may have selected username with persisted credentials.
                    if (g_dwCredPersistAvail)
                    {
                        // If selected CCredInfo has a user with persisted credentials
                        if ((InetGetCachedCredentials(pDlgPrms->szCtx, pDlgPrms->szRealm,
                            szUser, szPass) == ERROR_SUCCESS)
                            && !strcmp(pCur->szUser, szUser))
                        {
                            // Indicate that this user has persisted creds for the realm.
                            CheckDlgButton(hwnd, IDC_SAVE_PASSWORD, BST_CHECKED);
                        }
                        else
                        {
                            // Otherwise Indicate that this user does not have persisted
                            // creds for the realm.
                            CheckDlgButton(hwnd, IDC_SAVE_PASSWORD, BST_UNCHECKED);
                        }
                    }
                }
                return FALSE;
            }

            // User has clicked OK or Cancel button.
            switch (wID)
            {
                case IDOK:
                {
                    CCredInfo *pOut;

                    // User has clicked on OK button.

                    // Get the username and password into the output CCredInfo.
                    GetWindowText(GetDlgItem(hwnd,IDC_COMBO1), szUser, MAX_USERNAME_LEN);
                    GetWindowText(GetDlgItem(hwnd,IDC_PASSWORD_FIELD), szPass, MAX_PASSWORD_LEN);


                    // If save box checked, persist credentials.
                    if (IsDlgButtonChecked(hwnd, IDC_SAVE_PASSWORD) == BST_CHECKED)
                    {
                        InetSetCachedCredentials(pDlgPrms->szCtx, pDlgPrms->szRealm,
                            szUser, szPass);
                    }
                    else
                    {
                        // Otherwise the button is not checked. Check to see if we should
                        // remove the credentials from persisted store.
                        if (g_dwCredPersistAvail)
                        {
                            // If current and original credentials are for same user,
                            // remove the credentials.
                            CHAR szUserPersist[MAX_USERNAME_LEN], szPassPersist[MAX_PASSWORD_LEN];
                            if ((InetGetCachedCredentials(pDlgPrms->szCtx, pDlgPrms->szRealm,
                                szUserPersist, szPassPersist) == ERROR_SUCCESS)
                                && !strcmp(szUser, szUserPersist))
                            {
                                InetRemoveCachedCredentials(pDlgPrms->szCtx, pDlgPrms->szRealm);
                            }
                        }
                    }

                    // Allocate a new CCredInfo struct to return.
                    pOut = new CCredInfo(pDlgPrms->szHost, pDlgPrms->szRealm, szUser, szPass,
                        pDlgPrms->szNonce, pDlgPrms->szCNonce);
                    if (!pOut)
                    {
                        DIGEST_ASSERT(FALSE);
                    }
                    pDlgPrms->pInfoOut = pOut;
                    EndDialog(hwnd, TRUE);
                    break;
                }
                case IDCANCEL:
                {
                    // User has canceled dialog - no action.
                    EndDialog(hwnd, FALSE);
                    break;
                }
            }
            return FALSE;
        }
    }
    return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\digest\digesta.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    digesta.cxx

Abstract:

    sspi ansi interface for digest package.

Author:

    Adriaan Canter (adriaanc) 01-Aug-1998

--*/
#include "include.hxx"


static SecurityFunctionTableA

    SecTableA =
    {
        SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
        EnumerateSecurityPackagesA,
        NULL,                          // QueryCredentialsAttributesA
        AcquireCredentialsHandleA,
        FreeCredentialsHandle,
        NULL,                          // SspiLogonUserA
        InitializeSecurityContextA,
        AcceptSecurityContext,
        CompleteAuthToken,
        DeleteSecurityContext,
        ApplyControlToken,
        QueryContextAttributesA,
        ImpersonateSecurityContext,
        RevertSecurityContext,
        MakeSignature,
        VerifySignature,
        FreeContextBuffer,
        QuerySecurityPackageInfoA,
        NULL,                          // Reserved3
        NULL,                          // Reserved4
        NULL,                          // ExportSecurityContext
        NULL,                          // ImportSecurityContextA
        NULL,                          // Reserved7
        NULL,                          // Reserved8
        NULL,                          // QuerySecurityContextToken
        NULL,                          // EncryptMessage
        NULL                           // DecryptMessage
    };



//--------------------------------------------------------------------------
//
//  Function:   InitSecurityInterfaceA
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" PSecurityFunctionTableA SEC_ENTRY
InitSecurityInterfaceA(VOID)
{
    PSecurityFunctionTableA pSecTableA = &SecTableA;
    return pSecTableA;
}


//--------------------------------------------------------------------------
//
//  Function:   AcquireCredentialsHandleA
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
// HEINOUS SSPI HACK here: AcquireCredentialsHandle is called with the package
// name ("Digest") as the package identifier. When AcquireCredentialsHandle returns
// to the caller PCredHandle->dwLower is set by security.dll to be the index of
// the package returned. EnumerateSecurityPackages. This is how SSPI resolves the
// correct provider dll when subsequent calls are made through the dispatch table
// (PSecurityFunctionTale). Any credential *or* context handle handed out by the
// package must have the dwLower member set to this index so that subsequent calls
// can resolve the dll from the handle.
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandleA(
    LPSTR                       pszPrincipal,       // Name of principal
    LPSTR                       pszPackageName,     // Name of package
    DWORD                       dwCredentialUse,    // Flags indicating use
    VOID SEC_FAR *              pvLogonId,          // Pointer to logon ID
    VOID SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    VOID SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    SECURITY_STATUS ssResult;

    // Outbound credentials only.
    if (!(dwCredentialUse & SECPKG_CRED_OUTBOUND)
        || (dwCredentialUse & SECPKG_CRED_INBOUND))
    {
        DIGEST_ASSERT(FALSE);
        ssResult = SEC_E_UNKNOWN_CREDENTIALS;
        goto exit;
    }

    // Logon to cache.

    // Logon to the cache and get the session context.
    CSess *pSess;
    PSEC_WINNT_AUTH_IDENTITY_EXA pSecIdExA;
    PSEC_WINNT_AUTH_IDENTITY     pSecId;

    // HTTP clients will pass in this structure.
    pSecIdExA = (PSEC_WINNT_AUTH_IDENTITY_EXA) pAuthData;

    // Non-HTTP clients (OE4, OE5) will pass in this structure.
    pSecId    = (PSEC_WINNT_AUTH_IDENTITY)     pAuthData;

    // Check for HTTP client application logon.
    if (pAuthData
        && (pSecIdExA->Version == sizeof(SEC_WINNT_AUTH_IDENTITY_EXA))
        && pSecIdExA->User
        && pSecIdExA->UserLength == sizeof(DIGEST_PKG_DATA))
    {
        DIGEST_PKG_DATA *pPkgData;
        pPkgData = (DIGEST_PKG_DATA*) pSecIdExA->User;
        pSess = g_pCache->LogOnToCache(pPkgData->szAppCtx,
            pPkgData->szUserCtx, TRUE);
    }
    // Check for non-HTTP client application logon.
    else
    {
        // Find or create the single non-HTTP session.
        pSess = g_pCache->LogOnToCache(NULL, NULL, FALSE);

        // If user+pass+realm (domain) is passed in, create and
        // attach a matching credential to this session.
        if (pAuthData
            && pSecId->User
            && pSecId->UserLength
            && pSecId->Domain
            && pSecId->DomainLength
            && pSecId->Password
            && pSecId->PasswordLength)
        {
            // Create a credential with the information passed in.
            CCred *pCred;
            CCredInfo *pInfo;
            pInfo = new CCredInfo(NULL, (LPSTR) pSecId->Domain,
                (LPSTR) pSecId->User, (LPSTR) pSecId->Password, NULL, NULL);
            if (pInfo)
            {
                pCred = g_pCache->CreateCred(pSess, pInfo);
                delete pInfo;
            }
        }
    }

    // BUGBUG - return better error codes.
    if (!pSess)
    {
        DIGEST_ASSERT(FALSE);
        ssResult = SEC_E_INTERNAL_ERROR;
        goto exit;
    }

    // Hand out the session handle.
    phCredential->dwUpper = g_pCache->MapSessionToHandle(pSess);

    // ***** phCredential->dwLower will be set by security.dll *****

    ssResult = SEC_E_OK;

exit:
    return ssResult;
}



//--------------------------------------------------------------------------
//
//  Function:   FreeCredentialsHandle
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
FreeCredentialsHandle(PCredHandle phCredential)
{
    // bugbug - asserted.
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    SECURITY_STATUS ssResult;

    // Get the session context from the handle.
    CSess *pSess;

    pSess = g_pCache->MapHandleToSession(phCredential->dwUpper);
    if (!pSess)
    {
        DIGEST_ASSERT(FALSE);
        ssResult = SEC_E_UNKNOWN_CREDENTIALS;
        goto exit;
    }

    // Logoff from the cache.
    if (g_pCache->LogOffFromCache(pSess) != ERROR_SUCCESS)
    {
        DIGEST_ASSERT(FALSE);
        ssResult = SEC_E_INTERNAL_ERROR;
        goto exit;
    }
        ssResult = SEC_E_OK;
exit:
    return ssResult;
}


//--------------------------------------------------------------------------
//
//  Function:   InitializeSecurityContextA
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
InitializeSecurityContextA(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    LPSTR                       pszTargetName,      // Name of target
    DWORD                       fContextReq,        // Context Requirements
    DWORD                       Reserved1,          // Reserved, MBZ
    DWORD                       TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    DWORD                       Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    DWORD         SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    LPSTR szHost, szRealm, szUser, szPass, szNonce;
    DWORD cbHost, cbRealm, cbUser, cbPass, cbNonce;

    LPSTR szCtx = NULL;
    SECURITY_STATUS ssResult = SEC_E_OK;

    // Client nonce NULL except for md5-sess.
    LPSTR szCNonce = NULL;

    CSess       *pSess;
    CCred       *pCred;
    CParams     *pParams  = NULL;
    CCredInfo   *pInfo = NULL;

    // Rude credential flush for all apps.
    if (!phCredential && (fContextReq & ISC_REQ_NULL_SESSION))
    {
        g_pCache->FlushCreds(NULL, NULL);
        ssResult = SEC_E_OK;
        goto exit;
    }

    // Get the session pointer from the handle.
    pSess = g_pCache->MapHandleToSession(phCredential->dwUpper);
    if (!pSess)
    {
        DIGEST_ASSERT(FALSE);
        ssResult = SEC_E_UNKNOWN_CREDENTIALS;
        goto exit;
    }

    // Legacy conn. oriented client may require a continue
    // message on null buffer input.
    if (!pSess->fHTTP && !pInput && pOutput)
    {
        *((LPDWORD) (pOutput->pBuffers[0].pvBuffer)) = 0;
        pOutput->pBuffers[0].cbBuffer = sizeof(DWORD);
        ssResult = SEC_I_CONTINUE_NEEDED;
        goto exit;
    }

    // Flush creds for indicated session.
    if (fContextReq & ISC_REQ_NULL_SESSION)
    {
        g_pCache->FlushCreds(pSess, NULL);
        ssResult = SEC_E_OK;
        goto exit;
    }

    DIGEST_ASSERT(phCredential && pInput && pOutput);

    // Parse the challenge to a params object.
    if (CDigest::ParseChallenge(pSess, pInput,
        &pParams, fContextReq) != ERROR_SUCCESS)
    {
        // DIGEST_ASSERT(FALSE);
        ssResult = SEC_E_INVALID_TOKEN;
        goto exit;
    }

    // Get host, realm (required) and any nonce, user & pass.
    pParams->GetParam(CParams::HOST,  &szHost, &cbHost);
    pParams->GetParam(CParams::REALM, &szRealm, &cbRealm);
    pParams->GetParam(CParams::NONCE,  &szNonce, &cbNonce);
    pParams->GetParam(CParams::USER,  &szUser, &cbUser);
    pParams->GetParam(CParams::PASS,  &szPass, &cbPass);


    // If prompting UI is indicated.
    if (fContextReq & ISC_REQ_PROMPT_FOR_CREDS)
    {
        CCredInfo *pInfoIn, *pInfoOut;

        // Attempt to get one or more cred infos
        pInfoIn = g_pCache->FindCred(pSess, szHost, szRealm,
            szUser, NULL, NULL, FIND_CRED_UI);

        // Get the persistence key from pSess
        szCtx = CSess::GetCtx(pSess);
        DIGEST_ASSERT(szCtx);

        // If this is prompting for UI specifying md5-sess,
        // create a client nonce to associate with cred.
        if (pParams->IsMd5Sess())
            szCNonce = CDigest::MakeCNonce();

        pParams->GetParam(CParams::HOST,  &szHost, &cbHost);

        // Prompt with authentication dialog.
        if (DigestErrorDlg(szCtx, szHost, szRealm,
            szUser, szNonce, szCNonce,
            pInfoIn, &pInfoOut, pParams->GetHwnd()) == ERROR_SUCCESS)
        {
            DIGEST_ASSERT(pInfoOut);

            // Create the credential.
            pCred = g_pCache->CreateCred(pSess, pInfoOut);

            // Record that the host is trusted.
            if (pSess->fHTTP)
                CCredCache::SetTrustedHostInfo(szCtx, pParams);

        }
        else
        {
            ssResult = SEC_E_NO_CREDENTIALS;
            goto exit;
        }

        // Retrieve the credentials just created.
        pInfo = g_pCache->FindCred(pSess, szHost, szRealm,
            pInfoOut->szUser, szNonce, szCNonce, FIND_CRED_AUTH);

        // Clean up one or more cred infos.
        // BUGBUG - null out pointers after freeing.
        while (pInfoIn)
        {
            CCredInfo *pNext;
            pNext = pInfoIn->pNext;
            delete pInfoIn;
            pInfoIn = pNext;
        }

        if (pInfoOut)
            delete pInfoOut;

        if (szCNonce)
            delete szCNonce;

        if (!pInfo)
        {
            ssResult = SEC_E_NO_CREDENTIALS;
            goto exit;
        }

    }

    // Otherwise we are attempting to authenticate. We may be either
    // authenticating in response to a challenge or pre-authenticating.
    else
    {
        // Get the persistence key from pSess
        szCtx = CSess::GetCtx(pSess);
        DIGEST_ASSERT(szCtx);

        // For HTTP sessions we check the trusted host list unless
        // 1) credentials are supplied, or 2) a context has been passed
        // in which specifically instructs to ignore the host list.
        if (pSess->fHTTP && !pParams->IsPreAuth() && !pParams->AreCredsSupplied())
        {
            if (!phContext || !(phContext->dwUpper & DIGEST_PKG_FLAGS_IGNORE_TRUSTED_HOST_LIST))
            {
                if (!CCredCache::IsTrustedHost(szCtx, szHost))
                {
                    ssResult = SEC_E_NO_CREDENTIALS;
                    goto exit;
                }
            }
        }

        // If preauthenticating.
        if (pParams->IsPreAuth())
        {
            // If using supplied credentials.
            if (pParams->AreCredsSupplied())
            {
                // Create a cred info using supplied values. Include passed-in NC.
                pInfo = new CCredInfo(szHost, szRealm, szUser, szPass, szNonce, szCNonce);
                pInfo->cCount = pParams->GetNC();

                if (!(pInfo && pInfo->dwStatus == ERROR_SUCCESS))
                {
                    DIGEST_ASSERT(FALSE);
                    ssResult = SEC_E_INTERNAL_ERROR;
                    goto exit;
                }
            }
            // Otherwise attempt to find cred info in cache.
            else
            {
                // Attempt to find the credentials from realm and any user.
                pInfo = g_pCache->FindCred(pSess, szHost, szRealm,
                    szUser, NULL, NULL, FIND_CRED_PREAUTH);
            }

            // Return if no credentials exist.
            if (!pInfo)
            {
                ssResult = SEC_E_NO_CREDENTIALS;
                goto exit;
            }
        }
        // Otherwise auth in response to challenge.
        else
        {
            // Check if logoff is requested.
            CHAR* szLogoff;
            szLogoff = pParams->GetParam(CParams::LOGOFF);
            if (szLogoff && !lstrcmpi(szLogoff, "TRUE"))
            {
                g_pCache->FlushCreds(NULL, szRealm);
                ssResult = SEC_E_CONTEXT_EXPIRED;
                goto exit;
            }

            // If a context is passed in examine the stale header unless specifically
            // directed not to.
            if (pSess->fHTTP
                && phContext
                && !pParams->AreCredsSupplied()
                && !(phContext->dwUpper & DIGEST_PKG_FLAGS_IGNORE_STALE_HEADER))
            {
                CHAR* szStale;
                DWORD cbStale;
                pParams->GetParam(CParams::STALE, &szStale, &cbStale);
                if (!szStale || !lstrcmpi(szStale, "FALSE"))
                {
                    ssResult = SEC_E_NO_CREDENTIALS;
                    goto exit;
                }
            }

            // If this is authenticating specifying md5-sess,
            // create a client nonce to associate with cred.
            if (pParams->IsMd5Sess())
                szCNonce = CDigest::MakeCNonce();

            // If credentials are supplied, create an entry in
            // the credential cache. We search as usual subsequently.
            if (pParams->AreCredsSupplied())
            {
                // Create a cred info using supplied values.
                pInfo = new CCredInfo(szHost, szRealm, szUser, szPass, szNonce, szCNonce);

                if (!(pInfo && pInfo->dwStatus == ERROR_SUCCESS))
                {
                    DIGEST_ASSERT(FALSE);
                    ssResult = SEC_E_INTERNAL_ERROR;
                    goto exit;
                }

                pCred = g_pCache->CreateCred(pSess, pInfo);
                delete pInfo;
            }

            // Attempt to find the credentials from realm and any user.
            pInfo = g_pCache->FindCred(pSess, szHost, szRealm,
                szUser, szNonce, szCNonce, FIND_CRED_AUTH);

            // Return if no credentials exist.
            if (!pInfo)
            {
                ssResult = SEC_E_NO_CREDENTIALS;
                goto exit;
            }
        }
    }

    // We should now have the appropriate cred info. Generate the response.
    DIGEST_ASSERT(pInfo);
    if (CDigest::GenerateResponse(pSess, pParams,
        pInfo, pOutput) != ERROR_SUCCESS)
    {
        DIGEST_ASSERT(FALSE);
        ssResult = SEC_E_INTERNAL_ERROR;
        goto exit;
    }

    // Delete cred info if allocated.
    // bugbug - move further down.
    if (pInfo)
        delete pInfo;

    ssResult = SEC_E_OK;

exit:

    if ((ssResult != SEC_E_OK) &&
        (ssResult != SEC_I_CONTINUE_NEEDED))
        pOutput->pBuffers[0].cbBuffer = 0;

    // BUGBUG - delete pInfo if not NULL.
    // Delete persistence key if allocated.
    if (szCtx)
        delete szCtx;

    // Identify the new context.
    if (phNewContext && phCredential)
        phNewContext->dwLower = phCredential->dwLower;

    // Delete the params object.
    if (pParams)
        delete pParams;

    return ssResult;
}



//--------------------------------------------------------------------------
//
//  Function:   AcceptSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
AcceptSecurityContext(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSecBufferDesc              pInput,             // Input buffer
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               TargetDataRep,      // Target Data Rep
    PCtxtHandle                 phNewContext,       // (out) New context handle
    PSecBufferDesc              pOutput,            // (inout) Output buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attributes
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    // BUGBUG - don't need initglobals.
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    return(SEC_E_UNSUPPORTED_FUNCTION);
}






//--------------------------------------------------------------------------
//
//  Function:   DeleteSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
DeleteSecurityContext(
    PCtxtHandle                 phContext           // Context to delete
    )
{
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    return SEC_E_UNSUPPORTED_FUNCTION;
}



//--------------------------------------------------------------------------
//
//  Function:   ApplyControlToken
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
ApplyControlToken(
    PCtxtHandle                 phContext,          // Context to modify
    PSecBufferDesc              pInput              // Input token to apply
    )
{
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    SECURITY_STATUS ssResult;

    // Current flags used are
    // DIGEST_PKG_FLAG_IGNORE_TRUSTED_HOST_LIST
    // DIGEST_PKG_FLAG_IGNORE_STALE_HEADER
    phContext->dwUpper |= *((LPDWORD) (pInput->pBuffers[0].pvBuffer));

    ssResult = SEC_E_OK;
    return ssResult;
}




//--------------------------------------------------------------------------
//
//  Function:   EnumerateSecurityPackagesA
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackagesA(DWORD SEC_FAR *pcPackages,
    PSecPkgInfoA SEC_FAR *ppSecPkgInfo)
{

    SECURITY_STATUS ssResult;
    // BUGBUG - ALLOW ASSERTS?
    ssResult = QuerySecurityPackageInfoA(PACKAGE_NAME, ppSecPkgInfo);
    if (ssResult == SEC_E_OK)
    {
        *pcPackages = 1;
    }
    return ssResult;
}



//--------------------------------------------------------------------------
//
//  Function:   QuerySecurityPackageInfoA
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfoA(LPSTR szPackageName,
    PSecPkgInfoA SEC_FAR *ppSecPkgInfo)
{
    // BUGBUG - ALLOW ASSERTS?
    PSecPkgInfoA pSecPkgInfo;
    DWORD cbSecPkgInfo;
    SECURITY_STATUS ssResult;
    LPSTR pCur;


    if (strcmp(szPackageName, PACKAGE_NAME))
    {
        ssResult = SEC_E_SECPKG_NOT_FOUND;
        goto exit;
    }

    cbSecPkgInfo = sizeof(SecPkgInfoA)
        + sizeof(PACKAGE_NAME)
        + sizeof(PACKAGE_COMMENT);

    pSecPkgInfo = (PSecPkgInfoA) LocalAlloc(0,cbSecPkgInfo);

    if (!pSecPkgInfo)
    {
        ssResult = SEC_E_INSUFFICIENT_MEMORY;
        goto exit;
    }

    pSecPkgInfo->fCapabilities = PACKAGE_CAPABILITIES;
    pSecPkgInfo->wVersion      = PACKAGE_VERSION;
    pSecPkgInfo->wRPCID        = PACKAGE_RPCID;
    pSecPkgInfo->cbMaxToken    = PACKAGE_MAXTOKEN;

    pCur  = (LPSTR) (pSecPkgInfo) + sizeof(SecPkgInfoA);

    pSecPkgInfo->Name = pCur;
    memcpy(pSecPkgInfo->Name, PACKAGE_NAME, sizeof(PACKAGE_NAME));
    pCur += sizeof(PACKAGE_NAME);

    pSecPkgInfo->Comment = pCur;
    memcpy(pSecPkgInfo->Comment, PACKAGE_COMMENT, sizeof(PACKAGE_COMMENT));

    *ppSecPkgInfo = pSecPkgInfo;

    ssResult = SEC_E_OK;

exit:
    return ssResult;
}



//--------------------------------------------------------------------------
//
//  Function:   FreeContextBuffer
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
FreeContextBuffer(void SEC_FAR *pvContextBuffer)
{
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    LocalFree(pvContextBuffer);
    return SEC_E_OK;
}



//--------------------------------------------------------------------------
//
//  Function:   CompleteAuthToken
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
CompleteAuthToken(
    PCtxtHandle                 phContext,          // Context to complete
    PSecBufferDesc              pToken              // Token to complete
    )
{
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    return SEC_E_UNSUPPORTED_FUNCTION;
}



//--------------------------------------------------------------------------
//
//  Function:   ImpersonateSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
ImpersonateSecurityContext(
    PCtxtHandle                 phContext           // Context to impersonate
    )
{
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    return SEC_E_UNSUPPORTED_FUNCTION;
}



//--------------------------------------------------------------------------
//
//  Function:   RevertSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
RevertSecurityContext(
    PCtxtHandle                 phContext           // Context from which to re
    )
{
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    return SEC_E_UNSUPPORTED_FUNCTION;
}


//--------------------------------------------------------------------------
//
//  Function:   QueryContextAttributesA
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
QueryContextAttributesA(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    return SEC_E_UNSUPPORTED_FUNCTION;
}


//--------------------------------------------------------------------------
//
//  Function:   MakeSignature
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [phContext]     -- context to use
//              [fQOP]          -- quality of protection to use
//              [pMessage]      -- message
//              [MessageSeqNo]  -- sequence number of message
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
MakeSignature(  PCtxtHandle         phContext,
                ULONG               fQOP,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo)
{
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    return SEC_E_UNSUPPORTED_FUNCTION;
}


//--------------------------------------------------------------------------
//
//  Function:   VerifySignature
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [phContext]     -- Context performing the unseal
//              [pMessage]      -- Message to verify
//              [MessageSeqNo]  -- Sequence number of this message
//              [pfQOPUsed]     -- quality of protection used
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
VerifySignature(PCtxtHandle     phContext,
                PSecBufferDesc  pMessage,
                ULONG           MessageSeqNo,
                ULONG *         pfQOP)
{
    if (!InitGlobals())
        return SEC_E_INTERNAL_ERROR;

    return SEC_E_UNSUPPORTED_FUNCTION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\digest\digestw.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    digestw.cxx

Abstract:

    sspi wide char interface for digest package.
    
Author:

    Adriaan Canter (adriaanc) 01-Aug-1998

--*/
#include "include.hxx"

static SecurityFunctionTableW

    SecTableW = 
    {
        SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
        EnumerateSecurityPackagesW,
        NULL,                          // QueryCredentialsAttributesA
        AcquireCredentialsHandleW,
        FreeCredentialsHandle,
        NULL,                          // SspiLogonUserA
        InitializeSecurityContextW,
        AcceptSecurityContext,
        CompleteAuthToken,
        DeleteSecurityContext,
        ApplyControlToken,
        QueryContextAttributesW,
        ImpersonateSecurityContext,
        RevertSecurityContext,
        MakeSignature,
        VerifySignature,
        FreeContextBuffer,
        QuerySecurityPackageInfoW,
        NULL,                          // Reserved3
        NULL,                          // Reserved4
        NULL,                          // ExportSecurityContext
        NULL,                          // ImportSecurityContextA
        NULL,                          // Reserved7
        NULL,                          // Reserved8
        NULL,                          // QuerySecurityContextToken
        NULL,                          // EncryptMessage
        NULL                           // DecryptMessage
    };

//--------------------------------------------------------------------------
//
//  Function:   InitSecurityInterfaceW
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" PSecurityFunctionTableW SEC_ENTRY
InitSecurityInterfaceW(VOID)
{
    PSecurityFunctionTableW pSecTableW = &SecTableW;
    return pSecTableW;
}

//--------------------------------------------------------------------------
//
//  Function:   AcquireCredentialsHandleW
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
// HEINOUS SSPI HACK here: AcquireCredentialsHandle is called with the package
// name ("Digest") as the package identifier. When AcquireCredentialsHandle returns
// to the caller PCredHandle->dwLower is set by security.dll to be the index of
// the package returned. EnumerateSecurityPackages. This is how SSPI resolves the 
// correct provider dll when subsequent calls are made through the dispatch table 
// (PSecurityFunctionTale). Any credential *or* context handle handed out by the 
// package must have the dwLower member set to this index so that subsequent calls 
// can resolve the dll from the handle.
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandleW(
    LPWSTR                      wszPrincipal,       // Name of principal
    LPWSTR                      wszPackageName,     // Name of package
    DWORD                       dwCredentialUse,    // Flags indicating use
    VOID SEC_FAR *              pvLogonId,          // Pointer to logon ID
    VOID SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    VOID SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    return SEC_E_UNSUPPORTED_FUNCTION;

#if 0
    SECURITY_STATUS ssResult;

    DWORD wcbPrincipal, cbPrincipal, wcbPackageName, cbPackageName;
    
    wcbPrincipal = wszPrincipal ? wcslen(wszPrincipal) : 0;
    cbPrincipal = wcbPrincipal / sizeof(WCHAR);

    wcbPackageName = wszPackageName ? wcslen(wszPackageName) : 0;
    cbPackageName = wcbPackageName / sizeof(WCHAR);
    
    LPSTR szPrincipal;
    LPSTR szPackageName;

    szPrincipal = new CHAR[cbPrincipal]; 
    szPackageName = new CHAR[cbPackageName]; 
    
    WideCharToMultiByte(CP_ACP,0, wszPrincipal, wcbPrincipal, 
        szPrincipal, cbPrincipal, NULL,NULL);

    WideCharToMultiByte(CP_ACP,0, wszPackageName, wcbPackageName, 
        szPackageName, cbPackageName, NULL,NULL);

    ssResult = AcquireCredentialsHandleA(
        szPrincipal,       // Name of principal
        szPackageName,     // Name of package
        dwCredentialUse,    // Flags indicating use
        pvLogonId,          // Pointer to logon ID
        pAuthData,          // Package specific data
        pGetKeyFn,          // Pointer to GetKey() func
        pvGetKeyArgument,   // Value to pass to GetKey()
        phCredential,       // (out) Cred Handle
        ptsExpiry           // (out) Lifetime (optional)
        );

    delete szPrincipal;
    delete szPackageName;
    
    return ssResult;
#endif // 0
}

//--------------------------------------------------------------------------
//
//  Function:   InitializeSecurityContextA
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
InitializeSecurityContextW(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    LPWSTR                      wszTargetName,      // Name of target
    DWORD                       fContextReq,        // Context Requirements
    DWORD                       Reserved1,          // Reserved, MBZ
    DWORD                       TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    DWORD                       Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    DWORD         SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    return SEC_E_UNSUPPORTED_FUNCTION;

#if 0
    SECURITY_STATUS ssResult;

    DWORD wcbTargetName, cbTargetName;    
    wcbTargetName = wszTargetName ? wcslen(wszTargetName) : 0;
    cbTargetName = wcbTargetName / sizeof(WCHAR);

    
    LPSTR szTargetName;

    szTargetName = new CHAR[cbTargetName]; 
    
    WideCharToMultiByte(CP_ACP,0, wszTargetName, wcbTargetName, 
        szTargetName, cbTargetName, NULL,NULL);


    ssResult = InitializeSecurityContextA(
        phCredential,       // Cred to base context
        phContext,          // Existing context (OPT)
        szTargetName,      // Name of target
        fContextReq,        // Context Requirements
        Reserved1,          // Reserved, MBZ
        TargetDataRep,      // Data rep of target
        pInput,             // Input Buffers
        Reserved2,          // Reserved, MBZ
        phNewContext,       // (out) New Context handle
        pOutput,            // (inout) Output Buffers
        pfContextAttr,      // (out) Context attrs
        ptsExpiry           // (out) Life span (OPT)
    );

    delete szTargetName;
    return ssResult;

#endif // 0
}


//--------------------------------------------------------------------------
//
//  Function:   EnumerateSecurityPackagesW
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackagesW(DWORD SEC_FAR *pcPackages, 
    PSecPkgInfoW SEC_FAR *ppSecPkgInfo)
{
    SECURITY_STATUS ssResult;

    ssResult = QuerySecurityPackageInfoW(PACKAGE_NAMEW, ppSecPkgInfo);
    if (ssResult == SEC_E_OK)
    {
        *pcPackages = 1;
    }

    return ssResult;
}



//--------------------------------------------------------------------------
//
//  Function:   QuerySecurityPackageInfoW
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfoW(LPWSTR wszPackageName, 
    PSecPkgInfoW SEC_FAR *ppSecPkgInfo)
{
    PSecPkgInfoW pSecPkgInfo;
    SECURITY_STATUS ssResult;
    LPWSTR pwCur;

    if (wcscmp(wszPackageName, PACKAGE_NAMEW))
    {
        ssResult = SEC_E_SECPKG_NOT_FOUND;
        goto exit;
    }

    DWORD wcbSecPkgInfo, wcbstruct, wcbname, wcbcomment;
    
    wcbstruct = sizeof(SecPkgInfoW);
    wcbname = sizeof(PACKAGE_NAMEW);
    wcbcomment = sizeof(PACKAGE_COMMENTW);
    wcbSecPkgInfo = wcbstruct + wcbname + wcbcomment;
    
    pSecPkgInfo = (PSecPkgInfoW) LocalAlloc(0,wcbSecPkgInfo);

    if (!pSecPkgInfo)
    {
        ssResult = SEC_E_INSUFFICIENT_MEMORY;
        goto exit;
    }
    
    pSecPkgInfo->fCapabilities = PACKAGE_CAPABILITIES;
    pSecPkgInfo->wVersion      = PACKAGE_VERSION;
    pSecPkgInfo->wRPCID        = PACKAGE_RPCID;
    pSecPkgInfo->cbMaxToken    = PACKAGE_MAXTOKEN;

    pwCur  = (LPWSTR) ((LPBYTE) (pSecPkgInfo) + sizeof(SecPkgInfoW));

    pSecPkgInfo->Name = pwCur;
    memcpy(pSecPkgInfo->Name, PACKAGE_NAMEW, sizeof(PACKAGE_NAMEW));
    pwCur = (LPWSTR) ((LPBYTE) (pwCur) + sizeof(PACKAGE_NAMEW));

    pSecPkgInfo->Comment = pwCur;
    memcpy(pSecPkgInfo->Comment, PACKAGE_COMMENTW, sizeof(PACKAGE_COMMENTW));
    
    *ppSecPkgInfo = pSecPkgInfo;

    ssResult = SEC_E_OK;

exit:
    return ssResult;
}


//--------------------------------------------------------------------------
//
//  Function:   QueryContextAttributesW
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C" SECURITY_STATUS SEC_ENTRY
QueryContextAttributesW(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    return SEC_E_UNSUPPORTED_FUNCTION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\digest\init.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    init.c

Abstract:

    Dll initialization for sspi digest package.

Author:

    Adriaan Canter (adriaanc) 01-Aug-1998

--*/

#include "include.hxx"
#include "digestui.hxx"
#include "resource.h"

// Serializes access to all globals in module
CRITICAL_SECTION DllCritSect;

// Per process credential cache.
CCredCache *g_pCache = NULL;

// Per process cache init flag
BOOL g_fCredCacheInit = FALSE;

// Global module handle.
HMODULE g_hModule = NULL;

// Global handle to shlwapi.
HMODULE g_hShlwapi = NULL;

// Status of cred persist services on machine.
DWORD g_dwCredPersistAvail = CRED_PERSIST_UNKNOWN;

DWORD_PTR g_pHeap = NULL;

//--------------------------------------------------------------------
// DigestServicesExist
//--------------------------------------------------------------------
BOOL DigestServicesExist()
{
    INIT_SECURITY_INTERFACE addrProcISI = NULL;
    PSecurityFunctionTable pFuncTbl     = NULL;

    PSecPkgInfoA    pSecPkgInfo;
    SECURITY_STATUS ssResult;
    DWORD           cPackages;

    OSVERSIONINFO   VerInfo;
    CHAR            szDLL[MAX_PATH];
    HINSTANCE       hSecLib;

    BOOL fDigest = FALSE;

    // Get the OS version.
    VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    GetVersionEx (&VerInfo);

    // Load the appropriate dll.
    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        lstrcpy (szDLL, SSP_SPM_NT_DLL);
    else if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
        lstrcpy (szDLL, SSP_SPM_WIN95_DLL);
    else
        goto exit;

    hSecLib = LoadLibrary (szDLL);
    if (!hSecLib)
        goto exit;

    // Get the dispatch table.
    addrProcISI = (INIT_SECURITY_INTERFACE) GetProcAddress( hSecLib,
                    SECURITY_ENTRYPOINT_ANSI);
    pFuncTbl = (*addrProcISI)();

    if (!pFuncTbl)
        goto exit;

    // Enumerate security pkgs and determine if digest is installed.
    ssResult = (*(pFuncTbl->EnumerateSecurityPackagesA))(&cPackages, &pSecPkgInfo);

    if (ssResult == SEC_E_OK)
    {
        for (DWORD i = 0; i < cPackages; i++)
        {
            if (lstrcmpi(pSecPkgInfo[i].Name, "Digest") == 0)
            {
                fDigest = TRUE;
                break;
            }
        }
    }
exit:
    return fDigest;
}


//--------------------------------------------------------------------
// DLLInstall
//--------------------------------------------------------------------
STDAPI
DllInstall
(
    IN BOOL      bInstall,   // Install or Uninstall
    IN LPCWSTR   pwStr
)
{
    HKEY hKey;
    DWORD dwError, dwRegDisp, cbSP = MAX_PATH;
    CHAR *ptr, *ptrNext, szSP[MAX_PATH];
    BOOL bHKLM = FALSE;

    // Determine if full install (provide client digest sspi svcs)
    // or just passport install (server pkg delegating to client)
    if (!pwStr || !*pwStr || (!wcscmp(pwStr, L"HKLM")))
    {
        bHKLM = TRUE;
    }

    // Add "digest.dll" to comma delimited Service Providers list in
    // HKLM\System\CurrentControlSet\Control\SecurityProviders only if
    // no digest security providers currently exist.
    if (bInstall && bHKLM && !DigestServicesExist())
    {
        // Open or create SecurityProviders key.
        dwError =  RegCreateKeyEx(HKEY_LOCAL_MACHINE,
            SECURITY_PROVIDERS_REG_KEY, 0, NULL,
                0, KEY_READ | KEY_WRITE, NULL, &hKey, &dwRegDisp);

        // Successfully opened/created key.
        if (dwError == ERROR_SUCCESS)
        {
            cbSP = MAX_PATH;
            dwError = RegQueryValueEx(hKey, SECURITY_PROVIDERS_SZ,
                NULL, NULL, (LPBYTE) szSP, &cbSP);

            // SecurityProviders value might not be
            // found which is ok since we will create it.
            if (dwError == ERROR_SUCCESS || dwError == ERROR_FILE_NOT_FOUND)
            {
                // Value not found same as value existed but no string.
                if (dwError == ERROR_FILE_NOT_FOUND)
                {
                    ptr = NULL;
                    cbSP = 0;
                }
                // Otherwise if value found -> check if "digest.dll" exists.
                else
                {
                    // We can use the handy FindToken from the CParams object
                    // to determine if a token occurs in a comma delmited list.
                    if (!CParams::FindToken(szSP, cbSP, "digest.dll",
                        sizeof("digest.dll") - 1, &ptr))
                    {
                        ptr = NULL;
                    }
                }

                // Only add "digest.dll" if doesn't already exist.
                if (!ptr)
                {
                    // If we found value/data append "digest.dll"
                    if (cbSP > 1)
                        strcat(szSP, ", digest.dll");

                    // Otherwise "digest.dll" is only data
                    else
                        memcpy(szSP, "digest.dll", sizeof("digest.dll"));

                    // Write the value back.
                    dwError = RegSetValueEx(hKey, SECURITY_PROVIDERS_SZ, 0,
                        REG_SZ, (LPBYTE) szSP, strlen(szSP));
                }
            }

            // Close SecurityProviders reg key.
            RegCloseKey(hKey);
        }
    }

    // Remove "digest.dll" from the comma delimited Service Providers list in
    // HKLM\System\CurrentControlSet\Control\SecurityProviders
    if (!bInstall && bHKLM)
    {
        // Open the Security Providers reg key.
        dwError =  RegOpenKeyEx(HKEY_LOCAL_MACHINE,
            SECURITY_PROVIDERS_REG_KEY, NULL, KEY_READ | KEY_WRITE, &hKey);
        if (dwError == ERROR_SUCCESS)
        {
            // Get the SecurityProviders value data string.
            dwError = RegQueryValueEx(hKey, SECURITY_PROVIDERS_SZ,
                NULL, NULL, (LPBYTE) szSP, &cbSP);

            if (dwError == ERROR_SUCCESS)
            {
                // Only remove "digest.dll" if exists.
                if (!CParams::FindToken(szSP, cbSP, "digest.dll",
                    sizeof("digest.dll") - 1, &ptr))
                {
                    ptr = NULL;
                }

                if (ptr)
                {
                    // Point to next item in list, might be '\0'
                    ptrNext = ptr + sizeof("digest.dll") - 1;

                    // Digest.dll is only entry.
                    if ((ptr == szSP) && cbSP == sizeof("digest.dll"))
                    {
                        *szSP = '\0';
                    }
                    // "digest.dll" is last entry.
                    else if (*ptrNext == '\0')
                    {
                        *(ptr - (sizeof (", ") - 1)) = '\0';
                    }
                    else if (*ptrNext == ',' && *(ptrNext+1) == ' ')
                    {
                        ptrNext+=2;
                        memcpy(ptr, ptrNext, (size_t)(cbSP - (ptrNext - szSP)));
                    }

                    dwError = RegSetValueEx(hKey, SECURITY_PROVIDERS_SZ, 0,
                        REG_SZ, (LPBYTE) szSP, *szSP ? strlen(szSP) : 1);
                }
            }
            RegCloseKey(hKey);
        }
    }

    return S_OK;
}

//--------------------------------------------------------------------
// MakeFullAccessSA
//--------------------------------------------------------------------

//Commenting this function as it doesn't seem to be used anywhere in the sources
/*
SECURITY_ATTRIBUTES *MakeFullAccessSA (void)
{
    static SECURITY_ATTRIBUTES sa;
    static BYTE SDBuf[SECURITY_DESCRIPTOR_MIN_LENGTH];

    // Don't bother on Win95/Win98 which don't support security.
    OSVERSIONINFO versionInfo;
    versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);
    if (!GetVersionEx(&versionInfo)
        || (versionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS))
        return NULL;

    // Create a security descriptor with ACE to allow full access to all.
    SECURITY_DESCRIPTOR* pSD = (SECURITY_DESCRIPTOR*) SDBuf;
    if (!InitializeSecurityDescriptor (pSD, SECURITY_DESCRIPTOR_REVISION))
        return NULL;
    if (!SetSecurityDescriptorDacl (pSD, TRUE, NULL, FALSE))
        return NULL;

    // Initialize the security attributes.
    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = pSD;
    sa.bInheritHandle = TRUE;
    return &sa;
}*/
//--------------------------------------------------------------------
// NewString
//--------------------------------------------------------------------
LPSTR NewString(LPSTR szString)
{
    if (!szString)
        return NULL;
    DWORD cbString = strlen(szString);

    LPSTR szNew = new CHAR[cbString+1];
    if (!szNew)
    {
        DIGEST_ASSERT(FALSE);
        return NULL;
    }

    memcpy(szNew, szString, cbString+1);
    return szNew;
}

//--------------------------------------------------------------------
// InitGlobals
//--------------------------------------------------------------------
BOOL InitGlobals()
{
    // Return success if we've already
    // initialized.
    if (g_fCredCacheInit)
        return TRUE;

    // Serialize per-process calls.
    LOCK_GLOBALS();

    // Recheck global flag in the case
    // the cache was initialized while
    // this thread was descheduled.
    if (g_fCredCacheInit)
    {
        goto exit;
    }

    // Global cred persist status.
    g_dwCredPersistAvail = CRED_PERSIST_UNKNOWN;

    // Create the credential cache.
    g_pCache = new CCredCache();

    if (!g_pCache || g_pCache->GetStatus() != ERROR_SUCCESS)
    {
        g_fCredCacheInit = FALSE;
        goto exit;
    }

    g_fCredCacheInit = TRUE;

exit:
    UNLOCK_GLOBALS();

    return g_fCredCacheInit;
}


//--------------------------------------------------------------------
// DllMain
//--------------------------------------------------------------------
#if defined(__cplusplus)
extern "C"
#endif
BOOL
WINAPI
DllMain(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(DllHandle );

    switch (Reason)
    {
        // Process attach.
        case DLL_PROCESS_ATTACH:
        {

            // BUGBUG - DislableThreadLibraryCalls and
            // don't do any work.
            g_hModule = (HMODULE) DllHandle;
            InitializeCriticalSection( &DllCritSect );

            if ((hDigest = CreateMutex (NULL,
                FALSE,
                NULL)) == NULL)

                return FALSE;

            break;
        }

        // Process detatch.
        // Deinitialize the credential cache.
        // Delete the critical section.
        case DLL_PROCESS_DETACH:
        {
            if (g_pCache)
                delete g_pCache;

            DeleteCriticalSection( &DllCritSect );
            CloseHandle (hDigest);
            break;

        }
    }
    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\digest\params.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    params.cxx

Abstract:

    Header and parameter parser for digest sspi package.

Author:

    Adriaan Canter (adriaanc) 01-Aug-1998

--*/
#include "include.hxx"


// Static parameter map - this must
// agree with PARAM_INDEX.
// BUGBUG - declare const.
LPSTR CParams::szParamMap[] =
{
    HOST_SZ,
    USER_SZ,
    PASS_SZ,
    URL_SZ,
    METHOD_SZ,
    NONCE_SZ,
    OPAQUE_SZ,
    REALM_SZ,
    DOMAIN_SZ,
    STALE_SZ,
    ALGORITHM_SZ,
    QOP_SZ,
    MS_LOGOFF_SZ
};

//--------------------------------------------------------------------
// CParams::TrimQuotes
// Inplace trim of one leading and one trailing quote.
// BUGBUG -ppsz
//--------------------------------------------------------------------
VOID CParams::TrimQuotes(LPSTR *psz, LPDWORD pcb)
{
    if (*pcb && (**psz == '"'))
    {
        (*psz)++;
        (*pcb)--;
    }
    if (*pcb && (*(*psz + *pcb - 1) == '"'))
        (*pcb)--;
}

//--------------------------------------------------------------------
// CParams::TrimWhiteSpace
//   Inplace trim of leading and trailing whitespace.
//--------------------------------------------------------------------
VOID CParams::TrimWhiteSpace(LPSTR *psz, LPDWORD pcb)
{
    DWORD cb = *pcb;
    CHAR* beg = *psz;
    CHAR* end = beg + cb - 1;

    while ((cb != 0) && ((*beg == ' ') || (*beg == '\t')))
    {
        beg++;
        cb--;
    }

    while ((cb != 0) && ((*end == ' ') || (*end == '\t')))
    {
        end--;
        cb--;
    }

    *psz = beg;
    *pcb = cb;
}

//--------------------------------------------------------------------
// CParams::GetDelimitedToken
// Inplace strtok based on one delimiter. Ignores delimiter scoped by quotes.
// bugbug - IN/OUT
//--------------------------------------------------------------------
BOOL CParams::GetDelimitedToken(LPSTR* pszBuf,   LPDWORD pcbBuf,
                                LPSTR* pszTok,   LPDWORD pcbTok,
                                CHAR   cDelim)
{
    CHAR *pEnd;
    BOOL fQuote = FALSE,
         fRet   = FALSE;

    *pcbTok = 0;
    *pszTok = *pszBuf;

    pEnd = *pszBuf + *pcbBuf - 1;

    while (*pcbBuf)
    {
        if ( ((**pszBuf == cDelim) && !fQuote)
            || (**pszBuf =='\r')
            || (**pszBuf =='\n')
            || (**pszBuf =='\0'))
        {
            fRet = TRUE;
            break;
        }

        if (**pszBuf == '"')
            fQuote = !fQuote;

        (*pszBuf)++;
        (*pcbBuf)--;
    }

    // bugbug - OFF BY ONE WHEN NOT TERMINATING WITH A COMMA.
    if (fRet)
    {
        *pcbBuf = (DWORD)(pEnd - *pszBuf);
        *pcbTok = (DWORD)(*pszBuf - *pszTok);

        if (**pszBuf == cDelim)
            (*pszBuf)++;
    }

    return fRet;
}


//--------------------------------------------------------------------
// CParams::GetKeyValuePair
// Inplace retrieval of key and value from a buffer of form key = <">value<">
//--------------------------------------------------------------------
BOOL CParams::GetKeyValuePair(LPSTR  szB,    DWORD cbB,
                              LPSTR* pszK,   LPDWORD pcbK,
                              LPSTR* pszV,   LPDWORD pcbV)
{
    if (GetDelimitedToken(&szB, &cbB, pszK, pcbK, '='))
    {
        TrimWhiteSpace(pszK, pcbK);

        if (cbB)
        {
            *pszV = szB;
            *pcbV = cbB;
            TrimWhiteSpace(pszV, pcbV);
        }
        else
        {
            *pszV = NULL;
            *pcbV = 0;
        }
        return TRUE;
    }

    else
    {
        *pszK  = *pszV  = NULL;
        *pcbK  = *pcbV = 0;
    }
    return FALSE;
}


//--------------------------------------------------------------------
// CParams::CParams
// BUGBUG - SET A dwstatus variable.
//--------------------------------------------------------------------
CParams::CParams(LPSTR szBuffer)
{
    LPSTR szData, szTok, szKey, szValue;
    DWORD cbData, cbTok, cbKey, cbValue;

    // Zero set the entry array.
    memset(_Entry, 0, sizeof(_Entry));

    _hWnd = 0;
    _cNC  = 0;
    _fPreAuth       = FALSE;
    _fCredsSupplied = FALSE;

    // May be created with NULL buffer.
    if (!szBuffer)
    {
        _szBuffer = 0;
        _cbBuffer = 0;
        return;
    }

    _cbBuffer = strlen(szBuffer) + 1;
    _szBuffer = new CHAR[_cbBuffer];
    if (_szBuffer)
    {
        memcpy(_szBuffer, szBuffer, _cbBuffer);
    }
    else
    {
        DIGEST_ASSERT(FALSE);
        return;
    }

    szData = _szBuffer;
    cbData  = _cbBuffer;

    DWORD Idx;
    while (GetDelimitedToken(&szData, &cbData, &szTok, &cbTok, ','))
    {
        if (GetKeyValuePair(szTok, cbTok, &szKey, &cbKey, &szValue, &cbValue))
        {
            TrimQuotes(&szValue, &cbValue);

            for (Idx = METHOD; Idx < MAX_PARAMS; Idx++)
            {
                if (!_strnicmp(szKey, szParamMap[Idx], cbKey)
                    && !szParamMap[Idx][cbKey])
                {
                    if (szValue)
                    {
                        *(szValue + cbValue) = '\0';
                    }

                    _Entry[Idx].szParam = szParamMap[Idx];
                    _Entry[Idx].szValue = szValue;
                    _Entry[Idx].cbValue = cbValue;
                }
            }
        }
    }
}

//--------------------------------------------------------------------
// CParams::~CParams
// BUGBUG [] for deletes
//--------------------------------------------------------------------
CParams::~CParams()
{

    for (DWORD Idx = 0; Idx < MAX_PARAMS; Idx++)
    {
        if (_Entry[Idx].fAllocated)
            delete _Entry[Idx].szValue;
    }
    if (_szBuffer)
        delete _szBuffer;
}

//--------------------------------------------------------------------
// CParams::GetParam
//--------------------------------------------------------------------
LPSTR CParams::GetParam(PARAM_INDEX Idx)
{
    return _Entry[Idx].szValue;

}

//--------------------------------------------------------------------
// CParams::GetParam
//--------------------------------------------------------------------
BOOL CParams::GetParam(PARAM_INDEX Idx, LPSTR *pszValue, LPDWORD pcbValue)
{
    *pszValue = _Entry[Idx].szValue;

    if (!*pszValue)
        return FALSE;

    *pcbValue = _Entry[Idx].cbValue;

    return TRUE;
}


//--------------------------------------------------------------------
// CParams::SetParam
// BUGBUG - []
// AND FIGURE OUT IF EVER CALLED WITH null, 0
//--------------------------------------------------------------------
BOOL CParams::SetParam(PARAM_INDEX Idx, LPSTR szValue, DWORD cbValue)
{
    if (_Entry[Idx].fAllocated && _Entry[Idx].szValue)
        delete _Entry[Idx].szValue;

    if (szValue && cbValue)
    {
        _Entry[Idx].szValue = new CHAR[cbValue + 1];

        if (!_Entry[Idx].szValue)
        {
            DIGEST_ASSERT(FALSE);
            return FALSE;
        }

        memcpy(_Entry[Idx].szValue, szValue, cbValue);
        *(_Entry[Idx].szValue + cbValue) = '\0';
    }

    _Entry[Idx].cbValue = cbValue;
    _Entry[Idx].szParam = szParamMap[Idx];
    _Entry[Idx].fAllocated = TRUE;

    return TRUE;
}

//--------------------------------------------------------------------
// CParams::GetHwnd
//--------------------------------------------------------------------
HWND CParams::GetHwnd()
{
    return _hWnd;
}

//--------------------------------------------------------------------
// CParams::SetHwnd
//--------------------------------------------------------------------
BOOL CParams::SetHwnd(HWND* phWnd)
{
    _hWnd = phWnd ? *phWnd : GetActiveWindow();
    return TRUE;
}

//--------------------------------------------------------------------
// CParams::SetNC
//--------------------------------------------------------------------
VOID CParams::SetNC(DWORD* pcNC)
{
    _cNC = *pcNC;
}

//--------------------------------------------------------------------
// CParams::GetNC
//--------------------------------------------------------------------
DWORD CParams::GetNC()
{
    return _cNC;
}

//--------------------------------------------------------------------
// CParams::SetPreAuth
//--------------------------------------------------------------------
VOID CParams::SetPreAuth(BOOL fPreAuth)
{
    _fPreAuth = fPreAuth;
}

//--------------------------------------------------------------------
// CParams::IsPreAuth
//--------------------------------------------------------------------
BOOL CParams::IsPreAuth()
{
    return _fPreAuth;
}

//--------------------------------------------------------------------
// CParams::SetMd5Sess
//--------------------------------------------------------------------
VOID CParams::SetMd5Sess(BOOL fMd5Sess)
{
    _fMd5Sess = fMd5Sess;
}

//--------------------------------------------------------------------
// CParams::IsMd5Sess
//--------------------------------------------------------------------
BOOL CParams::IsMd5Sess()
{
    return _fMd5Sess;
}

//--------------------------------------------------------------------
// CParams::SetCredsSupplied
//--------------------------------------------------------------------
VOID CParams::SetCredsSupplied(BOOL fCredsSupplied)
{
    _fCredsSupplied = fCredsSupplied;
}

//--------------------------------------------------------------------
// CParams::AreCredsSupplied
//--------------------------------------------------------------------
BOOL CParams::AreCredsSupplied()
{
    return _fCredsSupplied;
}


//--------------------------------------------------------------------
// CParams::FindToken
// Returns TRUE if non-ws token is found in comma delmited string.
//--------------------------------------------------------------------
BOOL CParams::FindToken(LPSTR szBuf, DWORD cbBuf, LPSTR szMatch, DWORD cbMatch, LPSTR *pszPtr)
{
    LPSTR ptr = szBuf, szTok;
    DWORD cb  = cbBuf, cbTok;

    while (GetDelimitedToken(&ptr, &cb, &szTok, &cbTok, ','))
    {
        TrimWhiteSpace(&szTok, &cbTok);
        if (!_strnicmp(szTok, szMatch, cbMatch) && (cbTok == cbMatch))
        {
            if (pszPtr)
                *pszPtr = szTok;
            return TRUE;
        }
    }
    return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\digest\mmfile.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    mmfile.cxx

Abstract:

    Generic shared memory allocator.

Author:

    Adriaan Canter (adriaanc) 01-Aug-1998

--*/
#include "include.hxx"

//--------------------------------------------------------------------
// CMMFile::CMMFile()
//--------------------------------------------------------------------
CMMFile::CMMFile(DWORD cbHeap, DWORD cbEntry)
    : _cbHeap(cbHeap), _cbEntry(cbEntry)
{
    // BUGBUG - assert this.
    // Heap size must be multiple of entry size
    // and entry size must be multiple of 2.
    if ((_cbHeap % _cbEntry) || _cbEntry % 2)
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    // Max entries and total bytes in bitmap.
    _nMaxEntries = _cbHeap / _cbEntry;
    _cbBitMap = _nMaxEntries / NUM_BITS_IN_BYTE;

    // Total DWORDs in bitmap and total
    // bytes in shared memory.
    _nBitMapDwords = _cbBitMap / sizeof(DWORD);
    _cbTotal = sizeof(MEMMAP_HEADER) + _cbBitMap + _cbHeap;

    _pHeader  = NULL;
    _pBitMap  = NULL;
    _pHeap    = NULL;

    // BUGBUG - _hFile -> INVALID_HANDLE_VALUE
    _hFile    = NULL;
    _dwSig    = SIG_CMMF;
    _dwStatus = ERROR_SUCCESS;

exit:
    return;
}

//--------------------------------------------------------------------
// CMMFile::~CMMFile
//--------------------------------------------------------------------
CMMFile::~CMMFile()
{
    // BUGBUG - protected
    DeInit();
}

//--------------------------------------------------------------------
// Init
//--------------------------------------------------------------------
DWORD CMMFile::Init()
{
    BOOL fFirstProc = FALSE;
    LPVOID pv;
    HANDLE hHandle = (HANDLE) -1;
    CHAR szMapName[MAX_PATH];
    DWORD cbMapName = MAX_PATH;

    // IE5# 89288 
    // Get map name based on user
    if ((_dwStatus = MakeUserObjectName(szMapName, 
        &cbMapName, MAKE_MAP_NAME)) != ERROR_SUCCESS)
        return _dwStatus;

    // BUGBUG - security attributes and -1->INVALID_HANDLE_VALUE
    // Create the file mapping handle.
    _hFile = CreateFileMapping(
        hHandle,               // 0xffffffff file handle -> backed by paging file.
        NULL,                  // Security attributes.
        PAGE_READWRITE         // Generic read+write.
        | SEC_RESERVE,         // Reserve only, don't commit.
        0,                     // dwMaximumSizeHigh
        _cbTotal,              // dwMaximumSizeLow
        szMapName              // Map name.
        );

    // BUGBUG -> COMMENT HERE
    _dwStatus = GetLastError();

    // Check for success (can already exist) or failure.
    if (_dwStatus == ERROR_SUCCESS)
        fFirstProc = TRUE;
    else if (_dwStatus != ERROR_ALREADY_EXISTS)
    {
        DIGEST_ASSERT(FALSE);
        goto exit;
    }

    // bugbug - file_map_write logic.
    // Create file mapping view.
    pv = MapViewOfFileEx(
        _hFile,               // File mapping handle.
        FILE_MAP_WRITE,       // Read and write access.
        0,                    // High 32 bit offset
        0,                    // Low 32 bit offset
        0,                    // Map entire file.
        NULL                  // System chooses base addr.
        );

    if(!pv)
    {
        _dwStatus = GetLastError();
        DIGEST_ASSERT(FALSE);
        goto exit;
    }

    // Calculate pointers to bitmap and heap.
    _pHeader = (LPMEMMAP_HEADER) pv;
    _pBitMap = (LPDWORD) ((LPBYTE) pv + sizeof(MEMMAP_HEADER));
    _pHeap   = ((LPBYTE) _pBitMap + _cbBitMap);

    // Initialize MM file if first process.
    if (fFirstProc)
    {
        // Commit header + bitmap.
        if (!VirtualAlloc(_pHeader, sizeof(MEMMAP_HEADER) + _cbBitMap,
            MEM_COMMIT, PAGE_READWRITE))
        {
            _dwStatus = GetLastError();
            goto exit;
        }

        //BUGBUG - zero out first.
        // Set signature.
        memcpy(_pHeader->szSig, MMF_SIG_SZ, MMF_SIG_SIZE);

        // Zero out the rest of the header + bitmap.
        memset((LPBYTE) _pHeader + MMF_SIG_SIZE, 0,
            sizeof(MEMMAP_HEADER) - MMF_SIG_SIZE + _cbBitMap);
    }

    _dwStatus = ERROR_SUCCESS;

exit:

    return _dwStatus;
}

//--------------------------------------------------------------------
// DeInit
//--------------------------------------------------------------------
DWORD CMMFile::DeInit()
{
    // BUGBUG - should always close _hFile
    if (!UnmapViewOfFile((LPVOID) _pHeader))
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        goto exit;
    }

    if (!CloseHandle(_hFile))
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        goto exit;
    }

    _dwStatus = ERROR_SUCCESS;

    exit:

    return _dwStatus;
}



//--------------------------------------------------------------------
// CMMFile::CheckNextNBits
//
//    Determines if the next N bits are unset.
//
// Arguments:
//
//     [IN/OUT]
//     DWORD &nArrayIndex, DWORD &dwMask
//
//     [IN]
//     DWORD nBitsRequired
//
//     [OUT]
//     DWORD &nBitsFound
//
// Return Value:
//
//     TRUE if the next N bits were found unset.
//     FALSE otherwise.
//
// Notes:
//    This function assumes that the range of bits to be checked lie
//    within a valid area of the bit map.
//--------------------------------------------------------------------
BOOL CMMFile::CheckNextNBits(DWORD& nArrayIndex,   DWORD& dwStartMask,
                             DWORD  nBitsRequired, DWORD& nBitsFound)
{
    DWORD i;
    DWORD nIdx = nArrayIndex;
    DWORD dwMask = dwStartMask;
    BOOL fFound = FALSE;
    LPDWORD BitMap = &_pBitMap[nIdx];

    nBitsFound = 0;

    // Check if the next nBitsRequired bits are unset
    for (i = 0; i < nBitsRequired; i++)
    {
        // Is this bit unset?
        if ((*BitMap & dwMask) == 0)
        {
            // Have sufficient unset bits been found?
            if (++nBitsFound == nBitsRequired)
            {
                // Found sufficient bits. Success.
                fFound = TRUE;
                goto exit;
            }
        }

        // Ran into a set bit. Fail.
        else
        {
            // Indicate the array and bit index
            // of the set bit encountered.
            nArrayIndex = nIdx;
            dwStartMask = dwMask;
            goto exit;
        }

        // Left rotate the bit mask.
        dwMask <<= 1;
        if (dwMask == 0x0)
        {
            dwMask = 0x1;
            BitMap = &_pBitMap[++nIdx];
        }

    } // Loop nBitsRequired times.


exit:
    return fFound;
}


//--------------------------------------------------------------------
// CMMFile::SetNextNBits
//
//    Given an array index and bit mask, sets the next N bits.
//
// Arguments:
//    [IN]
//    DWORD nIdx, DWORD dwMask, DWORD nBitsRequired
//
// Return Value:
//
//    TRUE if the next N bits were found unset, and successfully set.
//    FALSE if unable to set all the required bits.
//
// Notes:
//    This function assumes that the range of bits to be set lie
//    within a valid area of the bit map. If the function returns
//    false, no bits are set.
//--------------------------------------------------------------------
BOOL CMMFile::SetNextNBits(DWORD nIdx, DWORD dwMask,
                           DWORD nBitsRequired)
{
    DWORD i, j, nBitsSet = 0;
    LPDWORD BitMap = &_pBitMap[nIdx];

    for (i = 0; i < nBitsRequired; i++)
    {
        // Check that this bit is not already set.
        if (*BitMap & dwMask)
        {
            // Fail. Unset the bits we just set and exit.
            for (j = nBitsSet; j > 0; j--)
            {
                DIGEST_ASSERT((*BitMap & dwMask) == 0);

                // Right rotate the bit mask.
                dwMask >>= 1;
                if (dwMask == 0x0)
                {
                    dwMask = 0x80000000;
                    BitMap = &_pBitMap[--nIdx];
                }
                *BitMap &= ~dwMask;
            }
            return FALSE;
        }

        *BitMap |= dwMask;
        nBitsSet++;

        // Left rotate the bit mask.
        dwMask <<= 1;
        if (dwMask == 0x0)
        {
            dwMask = 0x1;
            BitMap = &_pBitMap[++nIdx];
        }

    }

    // Success.
    return TRUE;
}


//--------------------------------------------------------------------
// CMMFile::GetAndSetNextFreeEntry
//
//    Computes the first available free entry index.
//
// Arguments:
//
//    DWORD nBitsRequired
//
// Return Value:
//
//   Next available free entry Index.
//--------------------------------------------------------------------
DWORD CMMFile::GetAndSetNextFreeEntry(DWORD nBitsRequired)
{
    DWORD nReturnBit = 0xFFFFFFFF;

    // Align if 4k or greater
    BOOL fAlign = (nBitsRequired >= NUM_BITS_IN_DWORD ? TRUE : FALSE);

    // Scan DWORDS from the beginning of the byte array.
    DWORD nArrayIndex = 0;
    while (nArrayIndex < _nBitMapDwords)
    {
        // Process starting from this DWORD if alignment is not required
        // and there are free bits, or alignment is required and all bits
        // are free.
        if (_pBitMap[nArrayIndex] !=  0xFFFFFFFF
            && (!fAlign || (fAlign && _pBitMap[nArrayIndex] == 0)))
        {
            DWORD nBitIndex = 0;
            DWORD dwMask = 0x1;
            LPDWORD BitMap = &_pBitMap[nArrayIndex];

            // Find a candidate slot.
            while (nBitIndex < NUM_BITS_IN_DWORD)
            {
                // Found first bit of a candidate slot.
                if ((*BitMap & dwMask) == 0)
                {
                    // Calculate leading bit value.
                    DWORD nLeadingBit = NUM_BITS_IN_DWORD * nArrayIndex + nBitIndex;

                    // Don't exceed max number of entries.
                    if (nLeadingBit + nBitsRequired > _nMaxEntries)
                    {
                        // Overstepped last internal entry
                        goto exit;
                    }

                    // If we just need one bit, then we're done.
                    if (nBitsRequired == 1)
                    {
                        *BitMap |= dwMask;
                        nReturnBit = nLeadingBit;
                        _pHeader->nEntries += 1;
                        goto exit;
                    }

                    // Additional bits required.
                    DWORD nBitsFound;
                    DWORD nIdx = nArrayIndex;

                    // Check the next nBitsRequired bits. Set them if free.
                    if (CheckNextNBits(nIdx, dwMask, nBitsRequired, nBitsFound))
                    {
                        if (SetNextNBits(nIdx, dwMask, nBitsRequired))
                        {
                            // Return the offset of the leading bit.
                            _pHeader->nEntries += nBitsRequired;
                            nReturnBit = nLeadingBit;
                            goto exit;
                        }
                        // Bad news.
                        else
                        {
                            // The bits are free, but we couldn't set them. Fail.
                            DIGEST_ASSERT(FALSE);
                            goto exit;
                        }
                    }
                    else
                    {
                        // This slot has insufficient contiguous free bits.
                        // Update the array index. We break back to looping
                        // over the bits in the DWORD where the interrupting
                        // bit was found.
                        nArrayIndex = nIdx;
                        nBitIndex = (nBitIndex + nBitsFound) % NUM_BITS_IN_DWORD;
                        break;
                    }

                } // Found a free leading bit.
                else
                {
                    // Continue looking at bits in this DWORD.
                    nBitIndex++;
                    dwMask <<= 1;
                }

            } // Loop over bits in DWORD.

        } // If we found a candidate DWORD.

        nArrayIndex++;

    } // Loop through all DWORDS.
exit:
    return nReturnBit;
}

//--------------------------------------------------------------------
// CMMFile::AllocateEntry
//
// Routine Description:
//
//    Member function that returns an free entry from the cache list. If
//    none is available free, it grows the map file, makes more free
//    entries.
//
// Arguments:
//
//    DWORD cbBytes : Number of bytes requested
//    DWORD cbOffset: Offset from beginning of bit map where allocation is
//                    requested.
//
// Return Value:
//
//
//--------------------------------------------------------------------
LPMAP_ENTRY CMMFile::AllocateEntry(DWORD cbBytes)
{
    LPMAP_ENTRY NewEntry;

    // BUGBUG - ASSERT THIS.
    // Validate cbBytes
    if (cbBytes > MAX_ENTRY_SIZE)
    {
        return NULL;
    }

    // Find and mark off a set of contiguous bits
    // spanning the requested number of bytes.
    DWORD nBlocksRequired = NUMBLOCKS(ROUNDUPBLOCKS(cbBytes), _cbEntry);
    DWORD FreeEntryIndex = GetAndSetNextFreeEntry(nBlocksRequired);

    // Failed to find space.
    if( FreeEntryIndex == 0xFFFFFFFF )
    {
        DIGEST_ASSERT(FALSE);
        return NULL;
    }

    // Cast the memory.
    NewEntry = (LPMAP_ENTRY)
        (_pHeap + _cbEntry * FreeEntryIndex);

    if (!VirtualAlloc(NewEntry, nBlocksRequired * _cbEntry,
        MEM_COMMIT, PAGE_READWRITE))
    {
        DIGEST_ASSERT(FALSE);
        _dwStatus = GetLastError();
        return NULL;
    }

    // Mark the allocated space.
    NewEntry->dwSig = SIG_ALLOC;

    // Set the number of blocks in the entry.
    NewEntry->nBlocks = nBlocksRequired;

    return NewEntry;
}

//--------------------------------------------------------------------
// Routine Description:
//
//    Attempts to reallocate an entry at the location given.
//
// Arguments:
//
//    LPMAP_ENTRY pEntry: Pointer to location in file map.
//    DWORD cbBytes : Number of bytes requested
//
// Return Value:
//
//    Original value of pEntry if successful. pEntry->nBlocks is set to
//    the new value, but all other fields in the entry are unmodified.
//    If insufficient contiguous bits are found at the end of the original
//    entry, NULL is returned, indicating failure. In this case the entry
//    remains unmodified.
//
//--------------------------------------------------------------------
// BUGBUG -> remove ?
BOOL CMMFile::ReAllocateEntry(LPMAP_ENTRY pEntry, DWORD cbBytes)
{
    // Validate cbBytes
    if (cbBytes > MAX_ENTRY_SIZE)
    {
        DIGEST_ASSERT(FALSE);
        return FALSE;
    }

    // Validate pEntry.
    DWORD cbEntryOffset = (DWORD)((DWORD_PTR) pEntry - (DWORD_PTR) _pBitMap);
    if ((cbEntryOffset == 0)
        || (cbEntryOffset & (_cbEntry-1))
        || (cbEntryOffset >= _cbTotal))
    {
        DIGEST_ASSERT(FALSE);
        return FALSE;
    }

    // Calculate number of blocks required for this entry.
    DWORD nBlocksRequired = NUMBLOCKS(ROUNDUPBLOCKS(cbBytes), _cbEntry);

    // Sufficient space in current slot?
    if (nBlocksRequired <= pEntry->nBlocks)
    {
        // We're done.
        return TRUE;
    }
    else
    {
        // Determine if additional free bits are
        // available at the end of this entry.
        // If not, return NULL.

        // Determine the array and bit indicese of the first
        // free bit immediately following the last set bit of
        // the entry.
        DWORD nTrailingIndex = cbEntryOffset / _cbEntry + pEntry->nBlocks;
        DWORD nArrayIndex = nTrailingIndex / NUM_BITS_IN_DWORD;
        DWORD nBitIndex = nTrailingIndex % NUM_BITS_IN_DWORD;
        DWORD dwMask = 0x1 << nBitIndex;
        DWORD nAdditionalBlocksRequired = nBlocksRequired - pEntry->nBlocks;
        DWORD nBlocksFound;

        // Don't exceed the number of internal entries.
        if (nTrailingIndex + nAdditionalBlocksRequired
            > _nMaxEntries)
        {
            // Overstepped last internal entry. Here we should fail
            // by returning NULL. Note - DO NOT attempt to grow the
            // map file at this point. The caller does not expect this.
            return FALSE;
        }

        if (CheckNextNBits(nArrayIndex, dwMask,
            nAdditionalBlocksRequired, nBlocksFound))
        {
            // We were able to grow the entry.
            SetNextNBits(nArrayIndex, dwMask, nAdditionalBlocksRequired);
            pEntry->nBlocks = nBlocksRequired;
            _pHeader->nEntries += nAdditionalBlocksRequired;
            return TRUE;
        }
        else
            // Couldn't grow the entry.
            return FALSE;
    }
}


//--------------------------------------------------------------------
// CMMFile::FreeEntry
//    This public member function frees up a file cache entry.
//
// Arguments:
//
//    UrlEntry : pointer to the entry that being freed.
//
// Return Value:
//
//    TRUE - if the entry is successfully removed from the cache.
//    FALSE - otherwise.
//
//--------------------------------------------------------------------
BOOL CMMFile::FreeEntry(LPMAP_ENTRY Entry)
{
    DWORD nIndex, nArrayIndex,
        nOffset, nBlocks, BitMask;

    LPDWORD BitMap;

    // Validate the pointer passed in.
    if(((LPBYTE) Entry < _pHeap)
        || ((LPBYTE) Entry >= (_pHeap + _cbEntry * _nMaxEntries)))
    {
        DIGEST_ASSERT(FALSE);
        return FALSE;
    }

    // Compute and check offset (number of bytes from start).
    nOffset = (DWORD)((DWORD_PTR)Entry - (DWORD_PTR)_pHeap);
    if( nOffset % _cbEntry )
    {
        // Pointer does not point to a valid entry.
        DIGEST_ASSERT(FALSE);
        return FALSE;
    }

    nBlocks = Entry->nBlocks;

    if (nBlocks > (MAX_ENTRY_SIZE / _cbEntry))
    {
        DIGEST_ASSERT(FALSE);
        return FALSE;
    }

    // Compute indicese
    nIndex = nOffset / _cbEntry;
    nArrayIndex = nIndex / NUM_BITS_IN_DWORD;

    // Unmark the index bits in the map.
    BitMap = &_pBitMap[nArrayIndex];
    BitMask = 0x1 << (nIndex % NUM_BITS_IN_DWORD);
    for (DWORD i = 0; i < nBlocks; i++)
    {
        // Check we don't free unset bits
        if (!(*BitMap & BitMask))
        {
            DIGEST_ASSERT(FALSE);
            return FALSE;
        }

        *BitMap &= ~BitMask;
        BitMask <<= 1;
        if (BitMask == 0x0)
        {
            BitMask = 0x1;
            BitMap = &_pBitMap[++nArrayIndex];
        }
    }

    // Mark the freed space.
    ResetEntryData(Entry, SIG_FREE, nBlocks);

    // Reduce the count of allocated entries.
    // INET_ASSERT (_HeaderInfo->NumUrlEntriesAlloced  > 0);
    _pHeader->nEntries -= nBlocks;

    return TRUE;
}

//--------------------------------------------------------------------
// CMMFile::SetHeaderData
//--------------------------------------------------------------------
VOID CMMFile::SetHeaderData(DWORD dwHeaderIndex, DWORD dwHeaderValue)
{
    _pHeader->dwHeaderData[dwHeaderIndex] = dwHeaderValue;
}

//--------------------------------------------------------------------
// CMMFile::GetHeaderData
//--------------------------------------------------------------------
LPDWORD CMMFile::GetHeaderData(DWORD dwHeaderIndex)
{
    return &_pHeader->dwHeaderData[dwHeaderIndex];
}

//--------------------------------------------------------------------
// CMMFile::ResetEntryData
//--------------------------------------------------------------------
VOID CMMFile::ResetEntryData(LPMAP_ENTRY Entry,
    DWORD dwResetValue, DWORD nBlocks)
{
    for (DWORD i = 0; i < (_cbEntry * nBlocks) / sizeof(DWORD); i++)
    {
        *((DWORD*) Entry + i) = dwResetValue;
    }
}

//--------------------------------------------------------------------
// CMMFile::GetMapPtr
//--------------------------------------------------------------------
DWORD_PTR CMMFile::GetMapPtr()
{
    return (DWORD_PTR) _pHeader;
}


//--------------------------------------------------------------------
// CMMFile::GetStatus
//--------------------------------------------------------------------
DWORD CMMFile::GetStatus()
{
    return _dwStatus;
}

//--------------------------------------------------------------------
// CMMFile::MakeUserObjectName
// Added in fix for IE5# 89288 
// (inet\digest\init.cxx:MakeFullAccessSA:  NULL DACL is no protection)
// 
// Generates either of the names
// <Local\>SSPIDIGESTMMMAP:username
// <Local\>SSPIDIGESTMUTEX:username 
// where Local\ is prepended on NT, username from GetUserName
//--------------------------------------------------------------------
DWORD CMMFile::MakeUserObjectName(LPSTR szName, LPDWORD pcbName, 
    DWORD dwFlags)
{
    DWORD cbLocal, cbRequired, 
        cbUserName = MAX_PATH, dwError = ERROR_SUCCESS;
    CHAR szUserName[MAX_PATH];
        
    DWORD cbNameFixed = (DWORD)((dwFlags == MAKE_MUTEX_NAME ? 
        sizeof(SZ_MUTEXNAME) - 1 :  sizeof(SZ_MAPNAME) - 1));

    // Get platform info.
    OSVERSIONINFO osInfo;
    osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osInfo))
    {
        dwError = GetLastError();
        goto exit;
    }

    // Prepend "Local\" if on >= NT5
    if ((osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        && (osInfo.dwMajorVersion >= 5))
    {
        // We will prepend "Local\"
        cbLocal = sizeof("Local\\") - 1;
    }
    else
    {
        // We will not prepend "Local\"
        cbLocal = 0;
    }

    // Get username. Default to "anyuser" if not present.
    if (!GetUserName(szUserName, &cbUserName))
    {
        cbUserName = sizeof("anyuser");
        memcpy(szUserName, "anyuser", cbUserName);
    }
    
    // Required size for name
    // eg <Local\>SSPIDIGESTMUTEX:username
    cbRequired = cbLocal + cbNameFixed + cbUserName;
    if (cbRequired > *pcbName)
    {
        *pcbName = cbRequired;
        dwError = ERROR_INSUFFICIENT_BUFFER;
        goto exit;
    }
    
    // <Local\> 
    // (cbLocal may be 0)
    memcpy(szName, "Local\\", cbLocal);
        
    // <Local\>SSPIDIGESTMUTEX:
    memcpy(szName + cbLocal, 
        (dwFlags == MAKE_MUTEX_NAME ? SZ_MUTEXNAME : SZ_MAPNAME), 
        cbNameFixed);

    // <Local\> SSPIDIGESTMUTEX:username
    // cbUsername includes null terminator.
    memcpy(szName + cbLocal + cbNameFixed,
        szUserName, cbUserName);

    *pcbName = cbRequired;

exit:
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\digest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by digest.rc
//
#define IDS_STRING_UDOMAIN              1
#define IDS_STRING_UREALM		2
#define IDD_DIGEST                      101
#define IDI_SECURITY                    110
#define IDC_USERNAME_FIELD              1000
#define IDC_PASSWORD_FIELD              1001
#define IDC_URL_FIELD                   1002
#define IDC_HOST_FIELD                  1002
#define IDC_REALM_FIELD                 1003
#define IDC_COMBO1                      1006
#define IDC_HOST                        1008
#define IDC_SAVE_PASSWORD               1024
#define IDD_LOGIN_TEXT1                 1048
#define IDD_LOGIN_TEXT2                 1049


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\digest\md5c.c ===
/*
 ***********************************************************************
 ** md5.c                                                             **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 1/91 SRD,AJ,BSK,JT Reference C Version                   **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

//  Portions copyright (c) 1992 Microsoft Corp.
//  All rights reserved



#include <nt.h>
#define UINT4   ULONG

#include "md5.h"


/* Constants for Transform routine.
 */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

static void TransformMD5 PROTO_LIST ((UINT4 *, UINT4 *));

static unsigned char PADDING[64] = {
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/* F, G and H are basic MD5 functions */
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

/* ROTATE_LEFT rotates x left n bits.
 */
#if CT_COMPILER == CT_MPW

/* MPW doesn't compile the macro correctly, so use a procedure. */
static UINT4 RotateLeft (UINT4, unsigned int);
#define ROTATE_LEFT RotateLeft

#else
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
#endif

/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s, ac) \
  {(a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) \
  {(a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) \
  {(a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) \
  {(a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
  }

void MD5Init (mdContext)
MD5_CTX *mdContext;
{
  mdContext->i[0] = mdContext->i[1] = (UINT4)0;

  /* Load magic initialization constants.
   */
  mdContext->buf[0] = (UINT4)0x67452301;
  mdContext->buf[1] = (UINT4)0xefcdab89;
  mdContext->buf[2] = (UINT4)0x98badcfe;
  mdContext->buf[3] = (UINT4)0x10325476;
}

void MD5Update (mdContext, inBuf, inLen)
MD5_CTX *mdContext;
const unsigned char *inBuf;
unsigned int inLen;
{
  UINT4 in[16];
  int mdi;
  unsigned int i, ii;

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3f);

  /* update number of bits */
  if ((mdContext->i[0] + ((UINT4)inLen << 3)) < mdContext->i[0])
    mdContext->i[1]++;
  mdContext->i[0] += ((UINT4)inLen << 3);
  mdContext->i[1] += ((UINT4)inLen >> 29);

  while (inLen--) {
    /* add new character to buffer, increment mdi */
    mdContext->in[mdi++] = *inBuf++;

    /* transform if necessary */
    if (mdi == 0x40) {
      for (i = 0, ii = 0; i < 16; i++, ii += 4)
        in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
                (((UINT4)mdContext->in[ii+2]) << 16) |
                (((UINT4)mdContext->in[ii+1]) << 8) |
                ((UINT4)mdContext->in[ii]);
      TransformMD5 (mdContext->buf, in);
      mdi = 0;
    }
  }
}

void MD5Final (mdContext)
MD5_CTX *mdContext;
{
  UINT4 in[16];
  int mdi;
  unsigned int i, ii;
  unsigned int padLen;

  /* save number of bits */
  in[14] = mdContext->i[0];
  in[15] = mdContext->i[1];

  /* compute number of bytes mod 64 */
  mdi = (int)((mdContext->i[0] >> 3) & 0x3f);

  /* pad out to 56 mod 64 */
  padLen = (mdi < 56) ? (56 - mdi) : (120 - mdi);
  MD5Update (mdContext, PADDING, padLen);

  /* append length in bits and transform */
  for (i = 0, ii = 0; i < 14; i++, ii += 4)
    in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
            (((UINT4)mdContext->in[ii+2]) << 16) |
            (((UINT4)mdContext->in[ii+1]) << 8) |
            ((UINT4)mdContext->in[ii]);
  TransformMD5 (mdContext->buf, in);

  /* store buffer in digest */
  for (i = 0, ii = 0; i < 4; i++, ii += 4) {
    mdContext->digest[ii] = (unsigned char)(mdContext->buf[i] & 0xff);
    mdContext->digest[ii+1] =
      (unsigned char)((mdContext->buf[i] >> 8) & 0xff);
    mdContext->digest[ii+2] =
      (unsigned char)((mdContext->buf[i] >> 16) & 0xff);
    mdContext->digest[ii+3] =
      (unsigned char)((mdContext->buf[i] >> 24) & 0xff);
  }
}

/* Basic MD5 step. Transforms buf based on in.
 */
static void TransformMD5 (buf, in)
UINT4 *buf;
UINT4 *in;
{
  UINT4 a = buf[0], b = buf[1], c = buf[2], d = buf[3];

  /* Round 1 */
  FF ( a, b, c, d, in[ 0], S11, 0xd76aa478); /* 1 */
  FF ( d, a, b, c, in[ 1], S12, 0xe8c7b756); /* 2 */
  FF ( c, d, a, b, in[ 2], S13, 0x242070db); /* 3 */
  FF ( b, c, d, a, in[ 3], S14, 0xc1bdceee); /* 4 */
  FF ( a, b, c, d, in[ 4], S11, 0xf57c0faf); /* 5 */
  FF ( d, a, b, c, in[ 5], S12, 0x4787c62a); /* 6 */
  FF ( c, d, a, b, in[ 6], S13, 0xa8304613); /* 7 */
  FF ( b, c, d, a, in[ 7], S14, 0xfd469501); /* 8 */
  FF ( a, b, c, d, in[ 8], S11, 0x698098d8); /* 9 */
  FF ( d, a, b, c, in[ 9], S12, 0x8b44f7af); /* 10 */
  FF ( c, d, a, b, in[10], S13, 0xffff5bb1); /* 11 */
  FF ( b, c, d, a, in[11], S14, 0x895cd7be); /* 12 */
  FF ( a, b, c, d, in[12], S11, 0x6b901122); /* 13 */
  FF ( d, a, b, c, in[13], S12, 0xfd987193); /* 14 */
  FF ( c, d, a, b, in[14], S13, 0xa679438e); /* 15 */
  FF ( b, c, d, a, in[15], S14, 0x49b40821); /* 16 */

  /* Round 2 */
  GG ( a, b, c, d, in[ 1], S21, 0xf61e2562); /* 17 */
  GG ( d, a, b, c, in[ 6], S22, 0xc040b340); /* 18 */
  GG ( c, d, a, b, in[11], S23, 0x265e5a51); /* 19 */
  GG ( b, c, d, a, in[ 0], S24, 0xe9b6c7aa); /* 20 */
  GG ( a, b, c, d, in[ 5], S21, 0xd62f105d); /* 21 */
  GG ( d, a, b, c, in[10], S22,  0x2441453); /* 22 */
  GG ( c, d, a, b, in[15], S23, 0xd8a1e681); /* 23 */
  GG ( b, c, d, a, in[ 4], S24, 0xe7d3fbc8); /* 24 */
  GG ( a, b, c, d, in[ 9], S21, 0x21e1cde6); /* 25 */
  GG ( d, a, b, c, in[14], S22, 0xc33707d6); /* 26 */
  GG ( c, d, a, b, in[ 3], S23, 0xf4d50d87); /* 27 */
  GG ( b, c, d, a, in[ 8], S24, 0x455a14ed); /* 28 */
  GG ( a, b, c, d, in[13], S21, 0xa9e3e905); /* 29 */
  GG ( d, a, b, c, in[ 2], S22, 0xfcefa3f8); /* 30 */
  GG ( c, d, a, b, in[ 7], S23, 0x676f02d9); /* 31 */
  GG ( b, c, d, a, in[12], S24, 0x8d2a4c8a); /* 32 */

  /* Round 3 */
  HH ( a, b, c, d, in[ 5], S31, 0xfffa3942); /* 33 */
  HH ( d, a, b, c, in[ 8], S32, 0x8771f681); /* 34 */
  HH ( c, d, a, b, in[11], S33, 0x6d9d6122); /* 35 */
  HH ( b, c, d, a, in[14], S34, 0xfde5380c); /* 36 */
  HH ( a, b, c, d, in[ 1], S31, 0xa4beea44); /* 37 */
  HH ( d, a, b, c, in[ 4], S32, 0x4bdecfa9); /* 38 */
  HH ( c, d, a, b, in[ 7], S33, 0xf6bb4b60); /* 39 */
  HH ( b, c, d, a, in[10], S34, 0xbebfbc70); /* 40 */
  HH ( a, b, c, d, in[13], S31, 0x289b7ec6); /* 41 */
  HH ( d, a, b, c, in[ 0], S32, 0xeaa127fa); /* 42 */
  HH ( c, d, a, b, in[ 3], S33, 0xd4ef3085); /* 43 */
  HH ( b, c, d, a, in[ 6], S34,  0x4881d05); /* 44 */
  HH ( a, b, c, d, in[ 9], S31, 0xd9d4d039); /* 45 */
  HH ( d, a, b, c, in[12], S32, 0xe6db99e5); /* 46 */
  HH ( c, d, a, b, in[15], S33, 0x1fa27cf8); /* 47 */
  HH ( b, c, d, a, in[ 2], S34, 0xc4ac5665); /* 48 */

  /* Round 4 */
  II ( a, b, c, d, in[ 0], S41, 0xf4292244); /* 49 */
  II ( d, a, b, c, in[ 7], S42, 0x432aff97); /* 50 */
  II ( c, d, a, b, in[14], S43, 0xab9423a7); /* 51 */
  II ( b, c, d, a, in[ 5], S44, 0xfc93a039); /* 52 */
  II ( a, b, c, d, in[12], S41, 0x655b59c3); /* 53 */
  II ( d, a, b, c, in[ 3], S42, 0x8f0ccc92); /* 54 */
  II ( c, d, a, b, in[10], S43, 0xffeff47d); /* 55 */
  II ( b, c, d, a, in[ 1], S44, 0x85845dd1); /* 56 */
  II ( a, b, c, d, in[ 8], S41, 0x6fa87e4f); /* 57 */
  II ( d, a, b, c, in[15], S42, 0xfe2ce6e0); /* 58 */
  II ( c, d, a, b, in[ 6], S43, 0xa3014314); /* 59 */
  II ( b, c, d, a, in[13], S44, 0x4e0811a1); /* 60 */
  II ( a, b, c, d, in[ 4], S41, 0xf7537e82); /* 61 */
  II ( d, a, b, c, in[11], S42, 0xbd3af235); /* 62 */
  II ( c, d, a, b, in[ 2], S43, 0x2ad7d2bb); /* 63 */
  II ( b, c, d, a, in[ 9], S44, 0xeb86d391); /* 64 */

  buf[0] += a;
  buf[1] += b;
  buf[2] += c;
  buf[3] += d;
}

#if CT_COMPILER == CT_MPW
static UINT4 RotateLeft (x, n)
UINT4 x;
unsigned int n;
{
  return (((x) << (n)) | ((x) >> (32-(n))));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\digest\test\poptest.cxx ===
#include <windows.h>

#define SECURITY_WIN32

#include <sspi.h>
#include <issperr.h>
#include <security.h>

#define SSP_SPM_NT_DLL      "security.dll"
#define SSP_SPM_WIN95_DLL   "secur32.dll"

#define MAX_OUTPUT_BUFFER   4096

SEC_WINNT_AUTH_IDENTITY SecId;
HINSTANCE hSecLib;
PSecurityFunctionTable pFuncTbl = NULL;

// Preliminary func calls.
VOID InitializeSecurityInterface(BOOL fDirect);
BOOL HaveDigest();

// 3 Main SSPI calls.

// AcquireCredentialsHandle
SECURITY_STATUS ACH(PCredHandle phCred);

// InitializeSecurityContext
SECURITY_STATUS ISC(PCredHandle phCred, 
                    PCtxtHandle phCtxt, 
                    PCtxtHandle phNewCtxt, 
                    DWORD fContextReq,
                    LPSTR szChallenge,
                    LPSTR szResponse,
                    LPSTR szUser,
                    LPSTR szPass);

// FreeCredentialsHandle
SECURITY_STATUS FCH(PCredHandle phCred);

//--------------------------------------
// main
//--------------------------------------
INT main()
{        
    DWORD dwReturn = 0;
    SECURITY_STATUS ssResult;

    // Get (global) dispatch table.
    InitializeSecurityInterface(FALSE);
 
    // Check to see if we have digest.
    if (!HaveDigest())
    {
        dwReturn = 1;
        goto exit;
    }
    
    // Credential handle and pointer.
    CredHandle  hCred;
    CtxtHandle  hCtxt;
    
    // **** Call AcquireCredentialsHandle with no credential ***
    ACH(&hCred);

    // Challenge and response buffers. As usual, we dump into an
    // output buffer allocated on the stack.
    LPSTR szChallenge;
    CHAR szResponse[MAX_OUTPUT_BUFFER];

    
    // First call to ISC is with zero input, expecting a 0 DWORD output buffer, as 
    // we expect with POP clients
    szChallenge = NULL;

    // Make first call to ISC with null input - expect DWORD 0 output.
    ssResult = ISC( &hCred,                     // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt,                     // Output context.
                    0,                          // flags auth from cache, but not meaningful here.
                    szChallenge,                // NULL Server challenge header.
                    szResponse,                 // Response buffer.
                    NULL,                       // No user needed.
                    NULL);                      // No pass needed.
    
    
    // Expect 0 DWORD output and SEC_I_CONTINUE_NEEDED.
    if (ssResult != SEC_I_CONTINUE_NEEDED)
    {
        DebugBreak();
    }


    // Free cred handle.
    FCH(&hCred);
    
    // Re-acquire cred handle.
    ACH(&hCred);    

    // Now setup challenge from server for realm "Microsoft Passport" which will use the 
    // credentials user="jpoley@microsoft.com", pass = "jpoley"
    szChallenge = "realm=\"Microsoft Passport\", algorithm = \"MD5-sess\", qop=\"auth\", nonce=\"0123456789abcdef\"";
               
    // Authenticate using user = "jpoley@microsoft.com", pass = "jpoley"
    ssResult = ISC( &hCred,                     // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt,                     // Output context.
                    ISC_REQ_USE_SUPPLIED_CREDS, // Use the credentials supplied.
                    szChallenge,                // Server challenge header.
                    szResponse,                 // Response buffer,
                    "jpoley@microsoft.com",     // user
                    "jpoley"                    // pass
                    );
        

    // We have just successfully authenticated for jpoley@microsoft.com. In doing so,
    // we have created a credential for jpoley@microsoft.com in the digest cred cache.
    if (ssResult != SEC_E_OK)
    {
        DebugBreak();
    }
                    
                    
    // Free cred handle.
    FCH(&hCred);
    
    // Re-acquire cred handle.
    ACH(&hCred);    


    // Quick confirmation that we have a credential for "jpoley@microsoft.com,
    // we'll attempt to auth to a "Microsoft Passport" challenge without supplying
    // any creds - this should pull jpoley creds from 
    // the cache and authomatically generate an auth header.
    ssResult = ISC( &hCred,                     // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt,                     // Output context.
                    0,                          // auth from cache
                    szChallenge,                // Server challenge header.
                    szResponse,                 // Response buffer,
                    NULL,                       // Not passing user
                    NULL                        // Not passing in pass
                    );
    
    
    // Should have authed successfully.
    if (ssResult != SEC_E_OK)
    {
        DebugBreak();
    }
    
    
    // Free cred handle.
    FCH(&hCred);
    
    // Re-acquire cred handle.
    ACH(&hCred);    

    // Now setup a challange from server for realm "Microsoft Passport (we'll use
    // the previouse one but this time we wish to authyenticate on behalf of a new
    // user "alex@microsoft.com" and we DON'T HAVE A PASSWORD.

    szChallenge = "realm=\"Microsoft Passport\", algorithm = \"MD5-sess\", qop=\"auth\", nonce=\"0123456789abcdef\"";
               
    // Authenticate
    ssResult = ISC( &hCred,                     // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt,                     // Output context.
                    0,                          // Auth from cache.
                    szChallenge,                // Server challenge header.
                    szResponse,                 // Response buffer,
                    "alex@microsoft.com",       // user
                    NULL                        // No password!
                    );
        
    // We didn't have any credentials, so we better not have succeeded.
    if (ssResult != SEC_E_NO_CREDENTIALS)
    {
        DebugBreak();
    }
    
    // Free cred handle.
    FCH(&hCred);
    
    // Re-acquire cred handle.
    ACH(&hCred);    

    // Prompt for credentials for alex@microsoft.com. Since the challenge contains the
    // realm "Microsoft Passport", the credential created here will overwrite the
    // credential created for jpoley@microsoft.com, and generate the authorization string.
    ssResult = ISC( &hCred,                     // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt,                     // Output context.
                    ISC_REQ_PROMPT_FOR_CREDS,   // prompt for creds for alex@microsoft.com
                    szChallenge,                // Server challenge header.
                    szResponse,                 // Response buffer.
                    "alex@microsoft.com",       // user to prompt for.
                    NULL                        // Again, no password, we're prompting.
                    );


    // We should have succeeded in collecting creds for alex@microsoft.com and
    // generating the authorization string.
    if (ssResult != SEC_E_OK)
    {
        DebugBreak();
    }

    
    // Free cred handle.
    FCH(&hCred);
    
    // Re-acquire cred handle.
    ACH(&hCred);    
    
    
    // Quick confirmation that we have a credential for "alex@microsoft.com"
    // we'll attempt to auth to a "Microsoft Passport" challenge without supplying
    // any creds - this should pull alex creds from 
    // the cache and authomatically generate an auth header.
    ssResult = ISC( &hCred,                     // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt,                     // Output context.
                    0,                          // auth from cache
                    szChallenge,                // Server challenge header.
                    szResponse,                 // Response buffer,
                    NULL,                       // Not passing user
                    NULL                        // Not passing in pass
                    );
   
    
    // Should have authed successfully.
    if (ssResult != SEC_E_OK)
    {
        DebugBreak();
    }
    
    
    // Free cred handle.
    FCH(&hCred);
    
    if (hSecLib)
        FreeLibrary(hSecLib);

exit:
    return dwReturn;
}


// Main SSPI calls.


//--------------------------------------
// ACH
//--------------------------------------
SECURITY_STATUS ACH(PCredHandle phCred)
{
    SECURITY_STATUS ssResult;
   
    // ***** SSPI CALL *****
    ssResult = (*(pFuncTbl->AcquireCredentialsHandleA))
        (NULL,                 // pszPrinciple         NULL
        "Digest",              // pszPackageName       (Package name)
        SECPKG_CRED_OUTBOUND,  // dwCredentialUse      (client call)
        NULL,                  // pvLogonID            (not used)
        NULL,                  // pAuthData            (not used)
        NULL,                  // pGetKeyFn            (not used)
        0,                     // pvGetKeyArgument     (not used)
        phCred,                // phCredential         (credential returned)
        NULL);                 // PTimeStamp           (not used)
    
    return ssResult;
}

//--------------------------------------
// ISC
//--------------------------------------
SECURITY_STATUS ISC(PCredHandle phCred, 
               PCtxtHandle phCtxt, 
               PCtxtHandle phNewCtxt, 
               DWORD fContextReq,
               LPSTR szChallenge,
               LPSTR szResponse,
               LPSTR szUser,
               LPSTR szPass)

{


// If the client is not passing in user/pass
// (ie, normal operation) then the count of 
// buffers passed in is always 1.
#define SEC_BUFFER_NUM_NORMAL_BUFFERS       1

// These are the indicese specifically expected
// by the digest package 
#define SEC_BUFFER_CHALLENGE_INDEX          0
#define SEC_BUFFER_USERNAME_INDEX           1
#define SEC_BUFFER_PASSWORD_INDEX           2
#define SEC_BUFFER_NUM_EXTENDED_BUFFERS     3

    SECURITY_STATUS ssResult;    
    
    // Input buffers and descriptor.
    SecBuffer sbIn[SEC_BUFFER_NUM_EXTENDED_BUFFERS];    
    SecBufferDesc sbdIn;
    PSecBufferDesc psbdIn;

    // Calling with challenge; expect SEC_E_OK or SEC_E_NO_CREDENTIALS
    if (szChallenge)
    {        
        // Setup the challenge input buffer always (0th buffer)
        sbIn[SEC_BUFFER_CHALLENGE_INDEX].pvBuffer = szChallenge;
        sbIn[SEC_BUFFER_CHALLENGE_INDEX].cbBuffer = strlen(szChallenge);
        sbIn[SEC_BUFFER_CHALLENGE_INDEX].BufferType   = SECBUFFER_TOKEN;

        // If we have a user, setup the user buffer (1st buffer)
        sbIn[SEC_BUFFER_USERNAME_INDEX].pvBuffer = szUser ? szUser : NULL;
        sbIn[SEC_BUFFER_USERNAME_INDEX].cbBuffer = szUser ? strlen(szUser) : NULL;
        sbIn[SEC_BUFFER_USERNAME_INDEX].BufferType   = SECBUFFER_TOKEN;
        
        // If we have a password, setup the password buffer (2nd buffer for
        // a total of 3 buffers passed in (challenge + user + pass)
        sbIn[SEC_BUFFER_PASSWORD_INDEX].pvBuffer = szPass ? szPass : NULL;
        sbIn[SEC_BUFFER_PASSWORD_INDEX].cbBuffer = szPass ? strlen(szPass) : NULL;
        sbIn[SEC_BUFFER_PASSWORD_INDEX].BufferType   = SECBUFFER_TOKEN;
                
        sbdIn.pBuffers = sbIn;
    
        // If either or both user and pass passed in, set num input buffers to 3
        // (SEC_BUFFER_NUM_EXTENDED_BUFFERS)
        if (szUser || szPass)
            sbdIn.cBuffers = SEC_BUFFER_NUM_EXTENDED_BUFFERS;

        // else we're just passing in the one challenge buffer (0th buffer as usual)
        else
            sbdIn.cBuffers = SEC_BUFFER_NUM_NORMAL_BUFFERS;

        psbdIn = &sbdIn;

    }
    else
    {
        // Calling withOUT challenge; expect SEC_I_CONTINUE_NEEDED;
        psbdIn = NULL;
    }

    // Output buffer and descriptor.
    SecBuffer sbOut[1];    
    SecBufferDesc sbdOut;
    
    sbOut[0].pvBuffer = szResponse;
    sbOut[0].cbBuffer = MAX_OUTPUT_BUFFER;
    sbOut[0].BufferType   = SECBUFFER_TOKEN;
    sbdOut.pBuffers = sbOut;
    sbdOut.cBuffers = 1;

    // ***** SSPI CALL *****
    ssResult = (*(pFuncTbl->InitializeSecurityContextA))
        (phCred,            // phCredential    (from AcquireCredentialsHandle)
         phCtxt,            // phContext       (NULL on first call, phNewCtxt on subsequent calls).
         NULL,              // pszTargetName   (not used)
         fContextReq,       // fContextReq     (auth from cache, prompt or auth using supplied creds)
         0,                 // Reserved1       (not used)
         0,                 // TargetDataRep   (not used)
         psbdIn,            // PSecBufDesc     (input buffer descriptor)
         0,                 // Reserved2       (not used)
         phNewCtxt,         // phNewContext    (should be passed back as phCtxt on subsequent calls)
         &sbdOut,           // pOutput         (output buffer descriptor)
         NULL,              // pfContextAttr   (pfContextAttr, not used)
         NULL);             // ptsExpiry       (not used)

    return ssResult;
}



//--------------------------------------
// FCH
//--------------------------------------
SECURITY_STATUS FCH(PCredHandle phCred)
{
    SECURITY_STATUS ssResult;
   
    // ***** SSPI CALL *****
    ssResult = (*(pFuncTbl->FreeCredentialsHandle))(phCred);
    
    return ssResult;
}


// Utility calls.



//--------------------------------------
// InitializeSecurityInterface
//--------------------------------------
VOID InitializeSecurityInterface(BOOL fDirect)
{
    INIT_SECURITY_INTERFACE	addrProcISI = NULL;
    OSVERSIONINFO   VerInfo;
    CHAR szDLL[MAX_PATH];

    if (!fDirect)
    {
        VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

        GetVersionEx (&VerInfo);
        if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            lstrcpy (szDLL, SSP_SPM_NT_DLL);
        }
        else if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
        {
            lstrcpy (szDLL, SSP_SPM_WIN95_DLL);
        }
    }
    else
    {
        strcpy(szDLL, "d:\\nt\\private\\inet\\digest\\objd\\i386\\digest.dll");
    }
    
    hSecLib = LoadLibrary (szDLL);
    
    addrProcISI = (INIT_SECURITY_INTERFACE) GetProcAddress( hSecLib, 
                    SECURITY_ENTRYPOINT_ANSI);       
        
    pFuncTbl = (*addrProcISI)();
}


//--------------------------------------
// HaveDigest
//--------------------------------------
BOOL HaveDigest()
{    
    SECURITY_STATUS ssResult;
    DWORD cPackages;
    PSecPkgInfoA pSecPkgInfo;
    BOOL fHaveDigest;

    // ***** SSPI call *****
    ssResult = (*(pFuncTbl->EnumerateSecurityPackagesA))(&cPackages, &pSecPkgInfo);

    // Check if we have digest.
    fHaveDigest = FALSE;
    if (ssResult == SEC_E_OK)
    {
        for (DWORD i = 0; i < cPackages; i++)
        {
            if (strcmp(pSecPkgInfo[i].Name, "Digest") == 0)
            {
                fHaveDigest = TRUE;
                break;
            }
        }
    }
    return fHaveDigest;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\digest\persist.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    persist.cxx

Abstract:

Author:

    Adriaan Canter (adriaanc) 13-Jan-1998

Revision History:

    13-Jan-1998 adriaanc
        Created
    01-Aug-1998 adriaanc
        revised for digest.

--*/

#include "include.hxx"

typedef HRESULT (*PFNPSTORECREATEINSTANCE)(IPStore**, PST_PROVIDERID*, VOID*, DWORD);

// Globals

// PWL related variables.
static HMODULE MhmodWNET                                     = NULL;
static PFWNETGETCACHEDPASSWORD pfWNetGetCachedPassword       = NULL;
static PFWNETCACHEPASSWORD pfWNetCachePassword               = NULL;
static PFWNETREMOVECACHEDPASSWORD pfWNetRemoveCachedPassword = NULL;

// Pstore related variables.
static WCHAR c_szDigestCacheCredentials[]            = L"DigestCacheCredentials";
static PFNPSTORECREATEINSTANCE pPStoreCreateInstance = NULL;


// Webcheck is currently using this GUID for pstore:
// {14D96C20-255B-11d1-898F-00C04FB6BFC4}
// static const GUID GUID_PStoreType = { 0x14d96c20, 0x255b, 0x11d1, { 0x89, 0x8f, 0x0, 0xc0, 0x4f, 0xb6, 0xbf, 0xc4 } };

// Wininet and digest use this GUID for pstore:
// {5E7E8100-9138-11d1-945A-00C04FC308FF}
static const GUID GUID_PStoreType =
{ 0x5e7e8100, 0x9138, 0x11d1, { 0x94, 0x5a, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0xff } };


// Private function prototypes.

// PWL private function prototypes.
DWORD PWLSetCachedCredentials(LPSTR szKey, DWORD cbKey, LPSTR szCred, DWORD cbCred);
DWORD PWLGetCachedCredentials  (LPSTR szKey, DWORD cbKey, LPSTR cbCred, LPDWORD pcbCred);
DWORD PWLRemoveCachedCredentials  (LPSTR szKey, DWORD cbKey);

BOOL LoadWNet(VOID);


// PStore private function prototypes.
DWORD PStoreSetCachedCredentials(LPSTR szKey, DWORD cbKey, LPSTR szCred, DWORD cbCred, BOOL fRemove=FALSE);
DWORD PStoreGetCachedCredentials(LPSTR szKey, DWORD cbKey, LPSTR szCred, LPDWORD pcbCred);
DWORD PStoreRemoveCachedCredentials(LPSTR szKey, DWORD cbKey);

STDAPI CreatePStore (IPStore **ppIPStore);
STDAPI ReleasePStore(IPStore  *pIPStore);

// Find platform type.
DWORD PlatformType()
{
    OSVERSIONINFO versionInfo;
    versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);
    if (GetVersionEx(&versionInfo))
        return versionInfo.dwPlatformId;

    return VER_PLATFORM_WIN32_WINDOWS;
}


//--------------------------------------------------------------------
// IsPersistenceDisabled
//--------------------------------------------------------------------
BOOL IsPersistenceDisabled()
{
    CHAR szBuf[MAX_PATH];

    DWORD dwType, dwError, dwOut = MAX_PATH, cbBuf = MAX_PATH;
    BOOL fRet = FALSE;
    HKEY hSettings = (HKEY) INVALID_HANDLE_VALUE;

    if ((dwError = RegCreateKey(HKEY_CURRENT_USER, INTERNET_SETTINGS_KEY, &hSettings)) == ERROR_SUCCESS)
    {
        if ((dwError = RegQueryValueEx(hSettings, DISABLE_PASSWORD_CACHE_VALUE, NULL, &dwType, (LPBYTE) szBuf, &cbBuf)) == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }
    }

    if (hSettings != INVALID_HANDLE_VALUE)
        RegCloseKey(hSettings);

    return fRet;
}




/*--------------------------- Top Level APIs ---------------------------------*/



//--------------------------------------------------------------------
//  InetInitCredentialPersist
//--------------------------------------------------------------------
DWORD InetInitCredentialPersist()
{
    HRESULT hr;
    IPStore *pIPStore = NULL;
    DWORD dwDisable, dwAvail;
    HINSTANCE hInstPStoreC = 0;
    BOOL fPersistDisabled = FALSE;

    // we should have the digest lock at this point.
    // AuthLock();

    // First check to see if persistence is disabled via registry.
    if (IsPersistenceDisabled())
    {
        // Persistence disabled via registry.
        dwAvail= CRED_PERSIST_NOT_AVAIL;
        goto quit;
    }

    // We use PWL for Win95; this should be available.
    if (PlatformType() == VER_PLATFORM_WIN32_WINDOWS)
    {
        dwAvail = CRED_PERSIST_AVAIL;
        goto quit;
    }

    // If is WinNt, check if PStore is installed.
    hInstPStoreC = LoadLibrary(PSTORE_MODULE);
    if (!hInstPStoreC)
    {
        dwAvail = CRED_PERSIST_NOT_AVAIL;
        goto quit;
    }
    else
    {
        // Get CreatePStoreInstance function pointer.
        pPStoreCreateInstance = (PFNPSTORECREATEINSTANCE)
            GetProcAddress(hInstPStoreC, "PStoreCreateInstance");

        if (!pPStoreCreateInstance)
        {
            dwAvail = CRED_PERSIST_NOT_AVAIL;
            goto quit;
        }
    }

    // Create an IPStore.
    hr = CreatePStore(&pIPStore);

    // Succeeded in creating an IPStore.
    if (SUCCEEDED(hr) && pIPStore)
    {
        ReleasePStore(pIPStore);
        dwAvail = CRED_PERSIST_AVAIL;
    }
    else
    {
        // Failed to create an IPStore.
        dwAvail = CRED_PERSIST_NOT_AVAIL;
    }

quit:
    g_dwCredPersistAvail = dwAvail;

    //AuthUnlock();

    return g_dwCredPersistAvail;
}


//--------------------------------------------------------------------
// InetSetCachedCredentials
//--------------------------------------------------------------------
DWORD InetSetCachedCredentials  (LPSTR szCtx,
                                 LPSTR szRealm,
                                 LPSTR szUser,
                                 LPSTR szPass)
{
    DWORD cbKey, cbCred, dwError;

    CHAR szKey [MAX_AUTH_FIELD_LENGTH],
         szCred[MAX_AUTH_FIELD_LENGTH];


    DIGEST_ASSERT(szCtx && *szCtx && szRealm
        && szUser && *szUser && szPass);

    // Check if credential persistence is available.
    if ((g_dwCredPersistAvail == CRED_PERSIST_UNKNOWN)
        && (InetInitCredentialPersist() == CRED_PERSIST_NOT_AVAIL))
    {
        dwError = ERROR_OPEN_FAILED;
        goto quit;
    }


    // Form key and credential strings.
    strcpy(szKey, szCtx);
    strcat(szKey, "/");
    DWORD dwAvailBuf = MAX_AUTH_FIELD_LENGTH - strlen(szKey);
    strncpy(szKey + strlen(szKey), szRealm, dwAvailBuf - 1);
    szKey[MAX_AUTH_FIELD_LENGTH-1]= 0;
    cbKey = strlen(szKey) + 1;
//    cbKey  = wsprintf(szKey, "%s/%s", szCtx, szRealm) + 1;
    cbCred = wsprintf(szCred,"%s:%s", szUser, szPass) + 1;

    // Store credentials.
    if (PlatformType() == VER_PLATFORM_WIN32_WINDOWS)
    {
        // Store credentials using PWL.
        dwError = PWLSetCachedCredentials(szKey, cbKey, szCred, cbCred);
    }
    else
    {
        // Store credentials using PStore.
        dwError = PStoreSetCachedCredentials(szKey, cbKey, szCred, cbCred);
    }

quit:

    return dwError;
}


//--------------------------------------------------------------------
//  InetGetCachedCredentials
//--------------------------------------------------------------------
DWORD InetGetCachedCredentials  (LPSTR szCtx,
                                 LPSTR szRealm,
                                 LPSTR szUser,
                                 LPSTR szPass)

{
    DWORD cbKey, cbCred, nUser, dwError;

    CHAR szKey [MAX_AUTH_FIELD_LENGTH],
         szCred[MAX_AUTH_FIELD_LENGTH],
         *ptr;

    DIGEST_ASSERT(szCtx && *szCtx && szRealm && szUser && szPass);

    // Check if credential persistence is available.
    if ((g_dwCredPersistAvail == CRED_PERSIST_UNKNOWN)
        && (InetInitCredentialPersist() == CRED_PERSIST_NOT_AVAIL))
    {
        dwError = ERROR_OPEN_FAILED;
        goto quit;
    }


    // Key string is host/realm
    strcpy(szKey, szCtx);
    strcat(szKey, "/");
    DWORD dwAvailBuf = MAX_AUTH_FIELD_LENGTH - strlen(szKey);
    strncpy(szKey + strlen(szKey), szRealm, dwAvailBuf - 1);
    szKey[MAX_AUTH_FIELD_LENGTH-1]= 0;
    cbKey = strlen(szKey) + 1;
    // cbKey  = wsprintf(szKey, "%s/%s", szCtx, szRealm) + 1;
    cbCred = MAX_AUTH_FIELD_LENGTH;

    if (PlatformType() == VER_PLATFORM_WIN32_WINDOWS)
    {
        // Store credentials using PWL.
        if ((dwError = PWLGetCachedCredentials(szKey, cbKey,
            szCred, &cbCred)) != WN_SUCCESS)
            goto quit;
    }
    else
    {
        // Store credentials using PStore.
        if ((dwError = PStoreGetCachedCredentials(szKey, cbKey,
            szCred, &cbCred)) != ERROR_SUCCESS)
            goto quit;
    }

    // Should have retrieved credentials in form of username:password.
    ptr = strchr(szCred, ':');

    // Should never happen since username & password are required.
    if (!ptr || (ptr == szCred))
    {
        dwError = ERROR_OPEN_FAILED;
        goto quit;
    }

    // Copy username & null terminate.
    nUser = (DWORD)(ptr - szCred);
    memcpy(szUser, szCred, nUser);
    szUser[nUser] = '\0';

    // Copy password with null terminator.
    memcpy(szPass, ptr+1, cbCred - nUser);

quit:

    return dwError;
}


//--------------------------------------------------------------------
//  InetRemoveCachedCredentials
//--------------------------------------------------------------------
DWORD InetRemoveCachedCredentials (LPSTR szCtx, LPSTR szRealm)
{
    DWORD cbKey, dwError;
    CHAR szKey[MAX_AUTH_FIELD_LENGTH];

    DIGEST_ASSERT(szCtx && *szCtx && szRealm);

    // Check if credential persistence is available.
    if ((g_dwCredPersistAvail == CRED_PERSIST_UNKNOWN)
        && (InetInitCredentialPersist() == CRED_PERSIST_NOT_AVAIL))
    {
        dwError = ERROR_OPEN_FAILED;
        goto quit;
    }

    // Form key string.
    strcpy(szKey, szCtx);
    strcat(szKey, "/");
    DWORD dwAvailBuf = MAX_AUTH_FIELD_LENGTH - strlen(szKey);
    strncpy(szKey + strlen(szKey), szRealm, dwAvailBuf - 1);
    szKey[MAX_AUTH_FIELD_LENGTH-1]= 0;
    cbKey = strlen(szKey) + 1;
//    cbKey  = wsprintf(szKey, "%s/%s", szCtx, szRealm) + 1;

    if (PlatformType() == VER_PLATFORM_WIN32_WINDOWS)
    {
        // Remove credentials from PWL.
        dwError = PWLRemoveCachedCredentials(szKey, cbKey);
    }
    else
    {
        // Remove credentials from PStore.
        dwError =  PStoreRemoveCachedCredentials(szKey, cbKey);
    }

quit:
    return dwError;
}


/*--------------------------- PWL Functions ---------------------------------*/



//--------------------------------------------------------------------
//  PWLSetCachedCredentials
//--------------------------------------------------------------------
DWORD PWLSetCachedCredentials(LPSTR szKey, DWORD cbKey,
                              LPSTR szCred, DWORD cbCred)
{
    DWORD dwError;

    // Load WNet.
    if (!LoadWNet())
        return ERROR_OPEN_FAILED;

    // Store credentials.
    dwError =  (*pfWNetCachePassword)(szKey, (WORD) cbKey, szCred, (WORD) cbCred, PCE_WWW_BASIC, 0);

    return dwError;
}




//--------------------------------------------------------------------
// PWLGetCachedCredentials
//--------------------------------------------------------------------
DWORD PWLGetCachedCredentials  (LPSTR szKey, DWORD cbKey,
                                LPSTR szCred, LPDWORD pcbCred)
{
    DWORD dwError;

    // Load WNet.
    if (!LoadWNet())
        return ERROR_OPEN_FAILED;

    // Retrieve credentials.
    dwError = (*pfWNetGetCachedPassword) (szKey, (WORD) cbKey, szCred,
                                          (LPWORD) pcbCred, PCE_WWW_BASIC);

    return dwError;
}



//--------------------------------------------------------------------
// PWLRemoveCachedCredentials
//--------------------------------------------------------------------
DWORD PWLRemoveCachedCredentials  (LPSTR szKey, DWORD cbKey)
{
    DWORD dwError;

    // Load WNet.
    if (!LoadWNet())
        return ERROR_OPEN_FAILED;

    dwError = (*pfWNetRemoveCachedPassword) (szKey, (WORD) cbKey, PCE_WWW_BASIC);

    return dwError;
}


// PWL utility functions.


//--------------------------------------------------------------------
//  LoadWNet
//--------------------------------------------------------------------
BOOL LoadWNet(VOID)
{
    BOOL fReturn;

    // we should have the digest lock at this point.
    //AuthLock();

    // MPR.DLL already loaded.
    if (MhmodWNET)
    {
        fReturn = TRUE;
        goto quit;
    }

    // Load MPR.DLL
    MhmodWNET = LoadLibrary(WNETDLL_MODULE);

    // Fail if not loaded.
    if (MhmodWNET)
    {
        fReturn = TRUE;
    }
    else
    {
        fReturn = FALSE;
        goto quit;
    }

    pfWNetGetCachedPassword    = (PFWNETGETCACHEDPASSWORD)    GetProcAddress(MhmodWNET, WNETGETCACHEDPASS);
    pfWNetCachePassword        = (PFWNETCACHEPASSWORD)        GetProcAddress(MhmodWNET, WNETCACHEPASS);
    pfWNetRemoveCachedPassword = (PFWNETREMOVECACHEDPASSWORD) GetProcAddress(MhmodWNET, WNETREMOVECACHEDPASS);

    // Ensure we have all function pointers.
    if (!(pfWNetGetCachedPassword
          && pfWNetCachePassword
          && pfWNetRemoveCachedPassword))
    {
        fReturn = FALSE;
    }

quit:
    //AuthUnlock();

    return fReturn;
}



/*------------------------- PStore Functions -------------------------------*/



//--------------------------------------------------------------------
// PStoreSetCachedCredentials
//--------------------------------------------------------------------
DWORD PStoreSetCachedCredentials(LPSTR szKey, DWORD cbKey,
                                 LPSTR szCred, DWORD cbCred,
                                 BOOL fRemove)
{
    DIGEST_ASSERT(pPStoreCreateInstance);

    HRESULT         hr;
    DWORD           dwError;

    PST_TYPEINFO    typeInfo;
    PST_PROMPTINFO  promptInfo = {0};

    GUID itemType    = GUID_PStoreType;
    GUID itemSubtype = GUID_NULL;

    WCHAR wszKey[MAX_AUTH_FIELD_LENGTH];

    IPStore *       pStore = NULL;

    // PST_TYPEINFO data.
    typeInfo.cbSize = sizeof(typeInfo);
    typeInfo.szDisplayName = c_szDigestCacheCredentials;

    // PST_PROMPTINFO data (no prompting desired).
    promptInfo.cbSize        = sizeof(promptInfo);
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp       = NULL;
    promptInfo.szPrompt      = NULL;

    // Create a PStore interface.
    hr = CreatePStore(&pStore);
    if (!SUCCEEDED(hr))
        goto quit;

    DIGEST_ASSERT(pStore != NULL);

    // Create a type in HKCU.
    hr = pStore->CreateType(PST_KEY_CURRENT_USER, &itemType, &typeInfo, 0);
    if (!((SUCCEEDED(hr)) || (hr == PST_E_TYPE_EXISTS)))
        goto quit;

    // Create subtype.
    hr = pStore->CreateSubtype(PST_KEY_CURRENT_USER, &itemType,
                               &itemSubtype, &typeInfo, NULL, 0);

    if (!((SUCCEEDED(hr)) || (hr == PST_E_TYPE_EXISTS)))
        goto quit;

    // Convert key to wide char.
    MultiByteToWideChar(CP_ACP, 0, szKey, -1, wszKey, MAX_AUTH_FIELD_LENGTH);

    // Valid credentials are written; No credentials imples
    // that the key and credentials are to be deleted.
    if (szCred && cbCred && !fRemove)
    {
        // Write key and credentials to PStore.
        hr = pStore->WriteItem(PST_KEY_CURRENT_USER,
                               &itemType,
                               &itemSubtype,
                               wszKey,
                               cbCred,
                               (LPBYTE) szCred,
                               &promptInfo,
                               PST_CF_NONE,
                               0);
    }
    else
    {
        // Delete key and credentials from PStore.
        hr = pStore->DeleteItem(PST_KEY_CURRENT_USER,
                                &itemType,
                                &itemSubtype,
                                wszKey,
                                &promptInfo,
                                0);

    }

quit:

    // Release the interface, convert error and return.
    ReleasePStore(pStore);

    if (SUCCEEDED(hr))
        dwError = ERROR_SUCCESS;
    else
        dwError = ERROR_OPEN_FAILED;

    return dwError;
}


//--------------------------------------------------------------------
//  PStoreGetCachedCredentials
//--------------------------------------------------------------------
DWORD PStoreGetCachedCredentials(LPSTR szKey, DWORD cbKey,
                                 LPSTR szCred, LPDWORD pcbCred)
{
    DIGEST_ASSERT(pPStoreCreateInstance);

    HRESULT          hr ;
    DWORD            dwError;
    LPBYTE           pbData;

    PST_PROMPTINFO   promptInfo  = {0};

    GUID             itemType    = GUID_PStoreType;
    GUID             itemSubtype = GUID_NULL;

    IPStore*         pStore      = NULL;

    WCHAR wszKey[MAX_AUTH_FIELD_LENGTH];


    // PST_PROMPTINFO data (no prompting desired).
    promptInfo.cbSize        = sizeof(promptInfo);
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp       = NULL;
    promptInfo.szPrompt      = NULL;

    // Create a PStore interface.
    hr = CreatePStore(&pStore);
    if (!SUCCEEDED(hr))
        goto quit;

    DIGEST_ASSERT(pStore != NULL);

    // Convert key to wide char.
    MultiByteToWideChar(CP_ACP, 0, szKey, -1, wszKey, MAX_AUTH_FIELD_LENGTH);

    // Read the credentials from PStore.
    hr = pStore->ReadItem(PST_KEY_CURRENT_USER,
                          &itemType,
                          &itemSubtype,
                          wszKey,
                          pcbCred,
                          (LPBYTE*) &pbData,
                          &promptInfo,
                          0);

    // Copy credentials and free buffer allocated by ReadItem.
    if (SUCCEEDED(hr))
    {
        memcpy(szCred, pbData, *pcbCred);
        CoTaskMemFree(pbData);
        //hr = S_OK;
    }

quit:

    // Release the interface, convert error and return.
    ReleasePStore(pStore);

    if (SUCCEEDED(hr))
        dwError = ERROR_SUCCESS;
    else
        dwError = ERROR_OPEN_FAILED;

    return dwError;
}

//--------------------------------------------------------------------
//  PStoreRemoveCachedCredentials
//--------------------------------------------------------------------
DWORD PStoreRemoveCachedCredentials(LPSTR szKey, DWORD cbKey)
{
    // Pass in TRUE to remove credentials.
    return PStoreSetCachedCredentials(szKey, cbKey, NULL, 0, TRUE);
}

// PStore utility functions

//--------------------------------------------------------------------
//  CreatePStore
//--------------------------------------------------------------------
STDAPI CreatePStore(IPStore **ppIPStore)
{
    HRESULT hr;
    DWORD dwError;


    hr = pPStoreCreateInstance (ppIPStore,
                                  NULL,
                                  NULL,
                                  0);

  if (SUCCEEDED(hr))
        dwError = ERROR_SUCCESS;
    else
        dwError = ERROR_OPEN_FAILED;

    return dwError;
}


//--------------------------------------------------------------------
//  ReleasePStore
//--------------------------------------------------------------------
STDAPI ReleasePStore(IPStore *pIPStore)
{
    HRESULT hr;

    if (pIPStore)
    {
        pIPStore->Release();
        hr = S_OK;
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\digest\test\test.cxx ===
#include <windows.h>

#define SECURITY_WIN32

#include <sspi.h>
#include <issperr.h>
#include <security.h>

#define SSP_SPM_NT_DLL      "security.dll"
#define SSP_SPM_WIN95_DLL   "secur32.dll"


struct DIGEST_PKG_DATA
{
    LPSTR szAppCtx;
    LPSTR szUserCtx;
};

#define SIG_DIGEST 'HTUA'

DIGEST_PKG_DATA PkgData;
SEC_WINNT_AUTH_IDENTITY_EXA SecIdExA;




PSecurityFunctionTable	g_pFuncTbl = NULL;

HINSTANCE hSecLib;

//----------------------------------------------------------------------------
// InitializeSecurityInterface
//----------------------------------------------------------------------------
VOID InitializeSecurityInterface(BOOL fDirect)
{
    INIT_SECURITY_INTERFACE	addrProcISI = NULL;
    OSVERSIONINFO   VerInfo;
    CHAR szDLL[MAX_PATH];

    if (!fDirect)
    {
        VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

        GetVersionEx (&VerInfo);
        if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            lstrcpy (szDLL, SSP_SPM_NT_DLL);
        }
        else if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
        {
            lstrcpy (szDLL, SSP_SPM_WIN95_DLL);
        }
    }
    else
    {
        strcpy(szDLL, "digest.dll");
    }
    
    hSecLib = LoadLibrary (szDLL);
    
    addrProcISI = (INIT_SECURITY_INTERFACE) GetProcAddress( hSecLib, 
                    SECURITY_ENTRYPOINT_ANSI);       
        
    g_pFuncTbl = (*addrProcISI)();
}


//----------------------------------------------------------------------------
// HaveDigest
//----------------------------------------------------------------------------
BOOL HaveDigest()
{    
    SECURITY_STATUS ssResult;
    DWORD cPackages;
    PSecPkgInfoA pSecPkgInfo;
    BOOL fHaveDigest;

    // ***** SSPI call *****
    ssResult = (*(g_pFuncTbl->EnumerateSecurityPackagesA))(&cPackages, &pSecPkgInfo);

    // Check if we have digest.
    fHaveDigest = FALSE;
    if (ssResult == SEC_E_OK)
    {
        for (DWORD i = 0; i < cPackages; i++)
        {
            if (strcmp(pSecPkgInfo[i].Name, "Digest") == 0)
            {
                fHaveDigest = TRUE;
                break;
            }
        }
    }
    return fHaveDigest;
}

//----------------------------------------------------------------------------
// LogonToDigestPkg
//----------------------------------------------------------------------------
SECURITY_STATUS LogonToDigestPkg(LPSTR szAppCtx, LPSTR szUserCtx, PCredHandle phCred)
{
    SECURITY_STATUS ssResult;
   
    // Logon with szAppCtx = szUserCtx = NULL.
    PkgData.szAppCtx = PkgData.szUserCtx = NULL;
    memset(&SecIdExA, 0, sizeof(SEC_WINNT_AUTH_IDENTITY_EXA));

    PkgData.szAppCtx = szAppCtx;
    PkgData.szUserCtx = szUserCtx;

    SecIdExA.Version = sizeof(SEC_WINNT_AUTH_IDENTITY_EXA);
    SecIdExA.User = (unsigned char*) &PkgData;
    SecIdExA.UserLength = sizeof(DIGEST_PKG_DATA);


    // ***** SSPI CALL *****
    ssResult = (*(g_pFuncTbl->AcquireCredentialsHandleA))
        (NULL,                // pszPrinciple         NULL
        "Digest",             // pszPackageName       (Package name)
        SECPKG_CRED_OUTBOUND,  // dwCredentialUse      (Credentials aren't pulled from OS)
        NULL,                 // pvLogonID            (not used)
        &SecIdExA,            // pAuthData            ptr to g_PkgData
        NULL,                 // pGetKeyFn            (not used)
        0,                    // pvGetKeyArgument     (not used)
        phCred,               // phCredential         (credential returned)
        NULL);                // PTimeStamp           (not used)
    
    return ssResult;
}


//----------------------------------------------------------------------------
// LogoffOfDigestPkg
//----------------------------------------------------------------------------
SECURITY_STATUS LogoffOfDigestPkg(PCredHandle phCred)
{
    SECURITY_STATUS ssResult;
   
    // ***** SSPI CALL *****
    ssResult = (*(g_pFuncTbl->FreeCredentialsHandle))(phCred);
    
    return ssResult;
}


//----------------------------------------------------------------------------
// Authenticate
//----------------------------------------------------------------------------
SECURITY_STATUS
DoAuthenticate(PCredHandle phCred, 
               PCtxtHandle phCtxt, 
               PCtxtHandle phNewCtxt, 
               DWORD fContextReq,
               LPSTR szHeader,
               LPSTR szRealm,
               LPSTR szHost, 
               LPSTR szUrl, 
               LPSTR szMethod,    
               LPSTR szUser, 
               LPSTR szPass, 
               LPSTR szNonce,
               HWND  hWnd,
               LPSTR szResponse)
{
    SECURITY_STATUS ssResult;    
    
    // Input buffers and descriptor.
    SecBuffer sbIn[10];    
    SecBufferDesc sbdIn;
    sbdIn.pBuffers = sbIn;
    sbdIn.cBuffers = 10;
    
    sbIn[0].pvBuffer    = szHeader;           // Challenge header
    sbIn[1].pvBuffer    = szRealm;            // realm if preauth
    sbIn[2].pvBuffer    = szHost;             // host
    sbIn[3].pvBuffer    = szUrl;              // url
    sbIn[4].pvBuffer    = szMethod;           // http method
    sbIn[5].pvBuffer    = szUser;             // username (optional)
    sbIn[6].pvBuffer    = szPass;             // password (optional, not used currently)    
    sbIn[7].pvBuffer    = szNonce;            // nonce
    sbIn[8].pvBuffer    = NULL;               // nonce count not passed in.
    sbIn[9].pvBuffer    = &hWnd;              // window handle.


    // Output buffer and descriptor.
    SecBuffer sbOut[1];
    SecBufferDesc sbdOut;
    sbdOut.pBuffers = sbOut;
    sbdOut.cBuffers = 1;
        
    // Set output buffer.
    sbOut[0].pvBuffer = szResponse;

    // ***** SSPI CALL *****
    ssResult = (*(g_pFuncTbl->InitializeSecurityContextA))
        (phCred,            // phCredential    (from AcquireCredentialsHandle)
         phCtxt,            // phContext       (NULL on first call, phNewCtxt on subsequent calls).
         NULL,              // pszTargetName   (not used)
         fContextReq,       // fContextReq     (auth from cache, prompt or auth using supplied creds)
         0,                 // Reserved1       (not used)
         0,                 // TargetDataRep   (not used)
         &sbdIn,            // PSecBufDesc     (input buffer descriptor)
         0,                 // Reserved2       (not used)
         phNewCtxt,         // phNewContext    (should be passed back as phCtxt on subsequent calls)
         &sbdOut,           // pOutput         (output buffer descriptor)
         NULL,              // pfContextAttr   (pfContextAttr, not used)
         NULL);             // ptsExpiry       (not used)

    return ssResult;
}

VOID PrimeCredCache(CredHandle CredHandle, LPSTR szRealm, LPSTR szUser, LPSTR szPass)
{
    DWORD ssResult;
    CtxtHandle hCtxt;

    SecBufferDesc sbdIn;
    SecBuffer     sbIn[3];
    
    hCtxt.dwLower = CredHandle.dwLower;
    hCtxt.dwUpper = CredHandle.dwUpper;

    sbIn[0].pvBuffer = szRealm;
    sbIn[0].cbBuffer = strlen(szRealm);
    sbIn[1].pvBuffer = szUser;
    sbIn[1].cbBuffer = strlen(szUser);
    sbIn[2].pvBuffer = szPass;
    sbIn[2].cbBuffer = strlen(szPass);

    sbdIn.cBuffers = 3;
    sbdIn.pBuffers = sbIn;

    ssResult = (*(g_pFuncTbl->ApplyControlToken))(&hCtxt, &sbdIn);

}

//----------------------------------------------------------------------------
// main
//----------------------------------------------------------------------------
#ifdef UNIX
#define main prog_main

int main(int argc, char **argv);

int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR pszCmdLine, int nCmdShow) {
    extern int __argc;
    extern char **__argv;
    return main(__argc, __argv);
}
int main(int argc, char **argv)
#else
INT main()
#endif
{        

#define IDENTITY_1 "Alice"
#define IDENTITY_2 "Bob"

    DWORD dwReturn = 0;
    SECURITY_STATUS ssResult;

    // Get (global) dispatch table.
    InitializeSecurityInterface(TRUE);
 
    // Check to see if we have digest.
    if (!HaveDigest())
    {
        dwReturn = 1;
        goto exit;
    }
    
    // Credential handle and pointer.
    CredHandle  hCred1, hCred2, hCred3; 
    CtxtHandle  hCtxt1, hCtxt2, hCtxt3;

    // Three apps logon using the same keys (appctx, userctx, both NULL);
    // These sessions will be used for authentication.
    LogonToDigestPkg(NULL, IDENTITY_1, &hCred1);
    LogonToDigestPkg(NULL, IDENTITY_1, &hCred2);
    LogonToDigestPkg(NULL, IDENTITY_1, &hCred3);

    // Three more apps also logon using the same keys.
    // we will prime the password cache with credentials for these apps
    // and expect to be able to share the credentials via the auth dialog.
    CredHandle hCred4, hCred5, hCred6;

    LogonToDigestPkg(NULL, IDENTITY_1, &hCred4);
    LogonToDigestPkg(NULL, IDENTITY_1, &hCred5);
    LogonToDigestPkg(NULL, IDENTITY_1, &hCred6);
    
    PrimeCredCache(hCred4, "testrealm@foo.com", "Wilma", "password");
    PrimeCredCache(hCred5, "testrealm@foo.com", "Betty", "passwordxxxx");
    PrimeCredCache(hCred6, "testrealm@foo.com", "Pebbles", "passwordxxxxx");

    // Finally, three more apps also logon using a different logon key (identity)
    // we will prime the password cache with credentials for these apps
    // Because of the different logon key we should never see these creds.
    CredHandle hCred7, hCred8, hCred9;
    
    LogonToDigestPkg(NULL, IDENTITY_2, &hCred7);
    LogonToDigestPkg(NULL, IDENTITY_2, &hCred8);
    LogonToDigestPkg(NULL, IDENTITY_2, &hCred9);
    
    PrimeCredCache(hCred7, "testrealm@foo.com", "Fred", "password");
    PrimeCredCache(hCred8, "testrealm@foo.com", "Barney",  "passwordxxxx");
    PrimeCredCache(hCred9, "testrealm@foo.com", "Bam Bam", "passwordxxxxxxxx");
    
    
    
    //------------------------------------------------------------------------------------------------------------- 
    // App 1 makes a request from a server, does not have credentials and must prompt
    // before finally succeeding.
    
    // Challenge from server.
    LPSTR szChallenge;
//    szChallenge = "realm=\"testrealm@foo.com\", ms-message = \"foo\", ms-message-lang = \"bar\", ms-trustmark = \"baz\", stale = FALSE, qop=\"auth,auth-int\", nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"";
    szChallenge = "realm=\"testrealm@foo.com\",  stale = FALSE, qop=\"auth,auth-int\", nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"";

    // Package will dump response into this buffer.
    CHAR szResponse[4096];
                
    // First try at authenticating.
    ssResult = 
    DoAuthenticate( &hCred1,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt1,                    // Output context.
                    0,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz/boz/bif.html",    // Url.
                    "GET",                      // Method.
                    NULL,                       // no Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hwnd for auth.
                    szResponse);                // Response buffer.
        
    // Expect to not have credentials the first time - prompt.
    if (ssResult == SEC_E_NO_CREDENTIALS)
    {
        ssResult = 
        DoAuthenticate( &hCred1,                    // Cred from logging on.
                        &hCtxt1,                    // Ctxt from previous call
                        &hCtxt1,                    // Output context (same as from previous).
                        ISC_REQ_PROMPT_FOR_CREDS,   // prompt
                        szChallenge,                // Server challenge
                        NULL,                       // No realm
                        "www.foo.com",              // Host
                        "/bar/baz/boz/bif.html",    // Url
                        "GET",                      // Method
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        GetDesktopWindow(),         // desktop window
                        szResponse);                // Response buffer

    }


    //------------------------------------------------------------------------------------------------------------- 
    // App 2 makes a request to the same server and gets challenged for the same realm. First auth attempt will
    // not be successful since this is the first challenge this session, so it will have to prompt for credentials.
    // When prompting, because it shares credentials with App1, the drop-down will contain App1's credentials.
    ssResult = 
    DoAuthenticate( &hCred2,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt2,                    // Output context.
                    0,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz/boz/bif.html",    // Url.
                    "GET",                      // Method.
                    NULL,                       // no Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hwnd for auth.
                    szResponse);                // Response buffer.
    
    // Generate the confirmation dialog and auth. User can choose App1's creds or enter new credentials.
    if (ssResult == SEC_E_NO_CREDENTIALS)
    {
        ssResult = 
        DoAuthenticate( &hCred2,                    // Cred from logging on.
                        &hCtxt2,                    // Ctxt from previous call
                        &hCtxt2,                    // Output context (same as from previous).
                        ISC_REQ_PROMPT_FOR_CREDS,   // prompt
                        szChallenge,                // Server challenge
                        NULL ,                      // No realm
                        "www.foo.com",              // Host
                        "/bar/baz/boz/bif.html",    // Url
                        "GET",                      // Method
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        GetDesktopWindow(),         // desktop window
                        szResponse);                // Response buffer

    }
    

    //------------------------------------------------------------------------------------------------------------- 
    // App 3 makes a request to the same server and gets challenged for the same realm. First auth attempt will
    // not be successful since this is the first challenge this session, so it will have to prompt for credentials.
    // When prompting, because it shares credentials with App1 and App2 the drop-down could show two choices if
    // App2 entered new credentials (or just one if App2 chose to use App1's credential).
    ssResult = 
    DoAuthenticate( &hCred3,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt3,                    // Output context.
                    0,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz/boz/bif.html",    // Url.
                    "GET",                      // Method.
                    NULL,                       // no Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hwnd for auth.
                    szResponse);                // Response buffer.
    
    // Generate the confirmation dialog and auth. User can choose App1's creds or enter new credentials.
    if (ssResult == SEC_E_NO_CREDENTIALS)
    {
        ssResult = 
        DoAuthenticate( &hCred3,                    // Cred from logging on.
                        &hCtxt3,                    // Ctxt from previous call
                        &hCtxt3,                    // Output context (same as from previous).
                        ISC_REQ_PROMPT_FOR_CREDS,   // prompt
                        szChallenge,                // Server challenge
                        NULL ,                      // No realm
                        "www.foo.com",              // Host
                        "/bar/baz/boz/bif.html",    // Url
                        "GET",                      // Method
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        GetDesktopWindow(),         // desktop window
                        szResponse);                // Response buffer

    }
    

    
    
    //------------------------------------------------------------------------------------------------------------- 
    // App2 preauthenticates to "testrealm@foo.com" for a new url. Note that the credential that will be used
    // for preauthentication is whatever App2 chose or entered previously. The same would be true for 
    // App1 or App3.
    ssResult = 
    DoAuthenticate( &hCred2,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt2,                    // Output context.
                    0,                          // auth (preauth)
                    NULL,                       // No challenge header
                    "testrealm@foo.com",        // Realm for preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz.gif",             // Url
                    "GET",                      // Method.
                    NULL,                       // no sername
                    NULL,                       // no password.
                    NULL,                       // no nonce
                    NULL,                       // no hwnd
                    szResponse);                // Response buffer.
    
    //------------------------------------------------------------------------------------------------------------- 
    // App3 made another request to the same server but did not preauthenticate. It got challenged for the
    // same realm and can authenticate without prompting because it has credentials for that realm.
    szChallenge = "realm=\"testrealm@foo.com\", stale = TRUE, qop=\"auth,auth-int\", nonce=\"abcdefge8b11d0f600bfb0c093\", opaque=\"efghijklmnopc403ebaf9f0171e9517f40e41\"";

    ssResult = 
    DoAuthenticate( &hCred3,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt3,                    // Output context.
                    0,                          // auth
                    szChallenge,                // Challenge from server.
                    NULL,                       // no realm
                    "www.foo.com",              // Host.
                    "/bar/baz.htm",             // Url
                    "GET",                      // Method.
                    NULL,                       // no username
                    NULL,                       // no password
                    NULL,                       // no nonce
                    NULL,                       // no hwnd
                    szResponse);                // Response buffer.
    
    
    //------------------------------------------------------------------------------------------------------------- 
    // App1 authenticates for an md5-sess challenge.

    szChallenge = "realm=\"testrealm@foo.com\", algorithm=\"md5-sess\", stale = TRUE, qop=\"auth,auth-int\", nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"";

    ssResult = 
    DoAuthenticate( &hCred1,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt1,                    // Output context.
                    0,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz/boz/bif.html",    // Url.
                    "GET",                      // Method.
                    NULL,                       // no Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hwnd for auth.
                    szResponse);                // Response buffer.



    //------------------------------------------------------------------------------------------------------------- 
    // App1 preauthenticates for 10 documents using md5-sess


    DWORD i;
    CHAR szBuf[1024];
    for (i = 0; i < 10; i++)
    {
        wsprintf(szBuf, "/bar/baz/boz/%x.html", i);
        ssResult = 
        DoAuthenticate( &hCred1,                    // Cred from logging on.
                        NULL,                       // Ctxt not specified first time.
                        &hCtxt1,                    // Output context.
                        0,                          // auth from cache.
                        NULL,                       // Server challenge header.
                        "testrealm@foo.com",        // realm.
                        "www.foo.com",              // Host.
                        szBuf,                      // Url.
                        "GET",                      // Method.
                        NULL,                       // no Username
                        NULL,                       // no Password.
                        NULL,                       // no nonce
                        NULL,                       // don't need hwnd for auth.
                        szResponse);                // Response buffer.

    }

    //------------------------------------------------------------------------------------------------------------- 
    // App1 received a new md5-sess challenge.

    szChallenge = "realm=\"testrealm@foo.com\", algorithm=\"md5-sess\", stale = TRUE, qop=\"auth,auth-int\", nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"";

    ssResult = 
    DoAuthenticate( &hCred1,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt1,                    // Output context.
                    0,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz/boz/bif.html",    // Url.
                    "GET",                      // Method.
                    NULL,                       // no Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hwnd for auth.
                    szResponse);                // Response buffer.


    //------------------------------------------------------------------------------------------------------------- 
    // App1 preauths using new md5-sess

    for (i = 0; i < 10; i++)
    {
        wsprintf(szBuf, "/bar/baz/boz/%x.html", i);
        ssResult = 
        DoAuthenticate( &hCred1,                    // Cred from logging on.
                        NULL,                       // Ctxt not specified first time.
                        &hCtxt1,                    // Output context.
                        0,                          // auth from cache.
                        NULL,                       // Server challenge header.
                        "testrealm@foo.com",        // realm.
                        "www.foo.com",              // Host.
                        szBuf,                      // Url.
                        "GET",                      // Method.
                        NULL,                       // no Username
                        NULL,                       // no Password.
                        NULL,                       // no nonce
                        NULL,                       // don't need hwnd for auth.
                        szResponse);                // Response buffer.

    }

    
szChallenge = "realm=\"Microsoft.Passport\", algorithm=MD5-sess, qop=\"auth\", nonce=ykjOzYDMxMzY4kjOEFkUSVkTB5kM6QUQSJVROFkTyojM6QzY0QGNhJmNjVDNhFGZiZjM3I2MiFWO3MDZyQTNyY2M";

    ssResult = 
    DoAuthenticate( &hCred1,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt1,                    // Output context.
                    0,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "darrenan2",              // Host.
                    "/passport/protected/test.asp",    // Url.
                    "GET",                      // Method.
                    "darrenan2",                // Given Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hwnd for auth.
                    szResponse);                // Response buffer.

    ssResult = 
    DoAuthenticate( &hCred1,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt1,                    // Output context.
                    ISC_REQ_PROMPT_FOR_CREDS,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "darrenan2",              // Host.
                    "/passport/protected/test.asp",    // Url.
                    "GET",                      // Method.
                    "darrenan2",                // Given username.
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hwnd for auth.
                    szResponse);                // Response buffer.



    
    
    // Logoff all three sessions
    ssResult = LogoffOfDigestPkg(&hCred1);
    ssResult = LogoffOfDigestPkg(&hCred2);
    ssResult = LogoffOfDigestPkg(&hCred3);
    ssResult = LogoffOfDigestPkg(&hCred4);
    ssResult = LogoffOfDigestPkg(&hCred5);
    ssResult = LogoffOfDigestPkg(&hCred6);
    ssResult = LogoffOfDigestPkg(&hCred7);
    ssResult = LogoffOfDigestPkg(&hCred8);
    ssResult = LogoffOfDigestPkg(&hCred9);
    
    if (hSecLib)
        FreeLibrary(hSecLib);

exit:
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\digest\test\stress\library.cxx ===
#include <windows.h>
#include <stdio.h>
#include <process.h>

#define SECURITY_WIN32
#include <security.h>
#include <sspi.h>
#include <issperr.h>

#include "main.hxx"

#define SSP_SPM_NT_DLL      "security.dll"
#define SSP_SPM_WIN95_DLL   "secur32.dll"

PSecurityFunctionTable	g_pFuncTbl = NULL;

HINSTANCE hSecLib;

LPSTR
issperr2str( SECURITY_STATUS error );

struct DIGEST_PKG_DATA
{
    LPSTR szAppCtx;
    LPSTR szUserCtx;
};

#define SIG_DIGEST 'HTUA'

DIGEST_PKG_DATA PkgData;
SEC_WINNT_AUTH_IDENTITY_EXA SecIdExA;

//----------------------------------------------------------------------------
// InitializeSecurityInterface
//----------------------------------------------------------------------------
VOID InitializeSecurityInterface(BOOL fDirect)
{
    INIT_SECURITY_INTERFACE	addrProcISI = NULL;
    OSVERSIONINFO   VerInfo;
    CHAR szDLL[MAX_PATH];

    if (!fDirect)
    {
        VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

        GetVersionEx (&VerInfo);
        if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            lstrcpy (szDLL, SSP_SPM_NT_DLL);
        }
        else if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
        {
            lstrcpy (szDLL, SSP_SPM_WIN95_DLL);
        }
    }
    else
    {
        strcpy(szDLL, "digest.dll");
    }
    
    hSecLib = LoadLibrary (szDLL);
    
    addrProcISI = (INIT_SECURITY_INTERFACE) GetProcAddress( hSecLib, 
                    SECURITY_ENTRYPOINT_ANSI);       
        
    g_pFuncTbl = (*addrProcISI)();
}


//----------------------------------------------------------------------------
// HaveDigest
//----------------------------------------------------------------------------
BOOL HaveDigest()
{    
    SECURITY_STATUS ssResult;
    DWORD cPackages;
    PSecPkgInfoA pSecPkgInfo;
    BOOL fHaveDigest;

    // ***** SSPI call *****
    ssResult = (*(g_pFuncTbl->EnumerateSecurityPackagesA))(&cPackages, &pSecPkgInfo);

    // Check if we have digest.
    fHaveDigest = FALSE;
    if (ssResult == SEC_E_OK)
    {
        for (DWORD i = 0; i < cPackages; i++)
        {
            if (strcmp(pSecPkgInfo[i].Name, "Digest") == 0)
            {
                fHaveDigest = TRUE;
                break;
            }
        }
    }
    return fHaveDigest;
}

//----------------------------------------------------------------------------
// LogonToDigestPkg
//----------------------------------------------------------------------------
SECURITY_STATUS LogonToDigestPkg(LPSTR szAppCtx, LPSTR szUserCtx, PCredHandle phCred)
{
    SECURITY_STATUS ssResult;
   
    // Logon with szAppCtx = szUserCtx = NULL.
    PkgData.szAppCtx = PkgData.szUserCtx = NULL;
    memset(&SecIdExA, 0, sizeof(SEC_WINNT_AUTH_IDENTITY_EXA));

    PkgData.szAppCtx = szAppCtx;
    PkgData.szUserCtx = szUserCtx;

    SecIdExA.Version = sizeof(SEC_WINNT_AUTH_IDENTITY_EXA);
    SecIdExA.User = (unsigned char*) &PkgData;
    SecIdExA.UserLength = sizeof(DIGEST_PKG_DATA);


    // ***** SSPI CALL *****
    dprintf(API,"AcquireCredentialsHandleA(\n"
				"PackageName: %s\n"
				"dwCredentialUse: %s\n"
				"pAuthData: %#x\n"
				"phCredential: %#x\n",
				"Digest",             // pszPackageName       (Package name)
				"OUTBOUND",  // dwCredentialUse      (Credentials aren't pulled from OS)
				&SecIdExA,            // pAuthData            ptr to g_PkgData
				phCred               // phCredential         (credential returned)
				);

    ssResult = (*(g_pFuncTbl->AcquireCredentialsHandleA))
        (NULL,                // pszPrinciple         NULL
        "Digest",             // pszPackageName       (Package name)
        SECPKG_CRED_OUTBOUND,  // dwCredentialUse      (Credentials aren't pulled from OS)
        NULL,                 // pvLogonID            (not used)
        &SecIdExA,            // pAuthData            ptr to g_PkgData
        NULL,                 // pGetKeyFn            (not used)
        0,                    // pvGetKeyArgument     (not used)
        phCred,               // phCredential         (credential returned)
        NULL);                // PTimeStamp           (not used)
    
	dprintf(API,"AcquireCredentialHandle(%s,%s) returns [%d,%d]\n",
				szAppCtx,
				szUserCtx,
				phCred->dwUpper,
				phCred->dwLower);

    return ssResult;
}


//----------------------------------------------------------------------------
// LogoffOfDigestPkg
//----------------------------------------------------------------------------
SECURITY_STATUS LogoffOfDigestPkg(PCredHandle phCred)
{
    SECURITY_STATUS ssResult;
   
    // ***** SSPI CALL *****
    ssResult = (*(g_pFuncTbl->FreeCredentialsHandle))(phCred);
    
	dprintf(API,"FreeCredentialsHandle([%d,%d]) returns %s\n", 
				phCred->dwUpper,
				phCred->dwLower,
				issperr2str(ssResult));
    return ssResult;
}


//----------------------------------------------------------------------------
// Authenticate
//----------------------------------------------------------------------------
SECURITY_STATUS
DoAuthenticate(PCredHandle phCred, 
               PCtxtHandle phCtxt, 
               PCtxtHandle phNewCtxt, 
               DWORD fContextReq,
               LPSTR szHeader,
               LPSTR szRealm,
               LPSTR szHost, 
               LPSTR szUrl, 
               LPSTR szMethod,    
               LPSTR szUser, 
               LPSTR szPass, 
               LPSTR szNonce,
               HWND  hWnd,
               LPSTR szResponse,
               DWORD cbResponse)
{
    SECURITY_STATUS ssResult;    
    
	ISC_PARAMS	ISC_Params;
	HANDLE hThread = NULL;
	DWORD dwRet;
	int i,j;

	BOOL fPersist = FALSE;

	TCHAR szUsername[256];
	TCHAR szPassword[256];

	dprintf(ENTRY_EXIT, "ENTER: DoAuthenticate ...\n");
	dprintf(INFO,
			"DoAuthenticate(\n"
			"szHeader %s \n"
			"szRealm %s \n"
			"szHost %s \n"
			"szUrl %s \n"
			"szMethod %s \n"
			"szUser %s \n"
			"szPass %s \n"
			"szNonce %s \n"
			,
           szHeader,
           szRealm,
           szHost, 
           szUrl, 
           szMethod,    
           szUser, 
           szPass, 
           szNonce);


	memset( (LPVOID)&ISC_Params, 0, sizeof(ISC_PARAMS) );

	ISC_Params.phCred = phCred;
	ISC_Params.phCtxt = phCtxt;
	ISC_Params.phNewCtxt = phNewCtxt;
	ISC_Params.fContextReq = fContextReq;
	ISC_Params.szHeader = szHeader;
	ISC_Params.szRealm = szRealm;
	ISC_Params.szHost = szHost;
	ISC_Params.szUrl = szUrl;
	ISC_Params.szMethod = szMethod;
	ISC_Params.szUser = szUser;
	ISC_Params.szPass = szPass;
	ISC_Params.szNonce = szNonce;
	ISC_Params.hWnd = hWnd;
	ISC_Params.szResponse = szResponse;
	ISC_Params.cbResponse = cbResponse;

	i = rand() % 10;

	j = rand() % 10;

	sprintf(szUsername,"user%d_%d@msn.com",i,j);
	sprintf(szPassword,"pass%d_%d",i,j);

	if( ( rand() % 100 ) > 50 )
		fPersist = TRUE;

	if( ISC_Params.fContextReq & ISC_REQ_PROMPT_FOR_CREDS ) {
		//
		// we need to start the UI thread
		//
		hThread = (HANDLE) _beginthread(fnUiThread,0,(LPVOID)&ISC_Params);
		//fnUiThread((LPVOID)&ISC_Params);

		SetUIUserNameAndPassword(szUsername,szPassword, fPersist);

		printf("Waiting for UI thread to complete\n");
		dwRet = WaitForSingleObject( hThread, INFINITE );
	} else {
		fnUiThread((LPVOID)&ISC_Params);
	}

	ssResult = ISC_Params.ss;
    // ***** SSPI CALL *****
//    ssResult = (*(g_pFuncTbl->InitializeSecurityContextA))
//        (phCred,            // phCredential    (from AcquireCredentialsHandle)
//         phCtxt,            // phContext       (NULL on first call, phNewCtxt on subsequent calls).
//         NULL,              // pszTargetName   (not used)
//         NULL,              // fContextReq     (not used)
//         0,                 // Reserved1       (not used)
//         0,                 // TargetDataRep   (not used)
//         &sbdIn,            // PSecBufDesc     (input buffer descriptor)
//         0,                 // Reserved2       (not used)
//         phNewCtxt,         // phNewContext    (should be passed back as phCtxt on subsequent calls)
//         &sbdOut,           // pOutput         (output buffer descriptor)
//         &fContextAttr,     // pfContextAttr   (auth from cache, prompt or auth using supplied creds)
//         NULL);             // ptsExpiry       (not used)

    return ssResult;
}

void __cdecl fnUiThread( LPVOID lpData )
{
	LPISC_PARAMS lpIscParams = (LPISC_PARAMS) lpData;


	lpIscParams -> ss =
	_InitializeSecurityContext(
				   lpIscParams -> phCred, 
				   lpIscParams -> phCtxt, 
				   lpIscParams -> phNewCtxt, 
				   lpIscParams -> fContextReq,
				   lpIscParams -> szHeader,
				   lpIscParams -> szRealm,
				   lpIscParams -> szHost, 
				   lpIscParams -> szUrl, 
				   lpIscParams -> szMethod,    
				   lpIscParams -> szUser, 
				   lpIscParams -> szPass, 
				   lpIscParams -> szNonce,
				   lpIscParams -> hWnd,
				   lpIscParams -> szResponse,
				   lpIscParams -> cbResponse);

	return;

}

SECURITY_STATUS
_InitializeSecurityContext(PCredHandle phCred, 
               PCtxtHandle phCtxt, 
               PCtxtHandle phNewCtxt, 
               DWORD fContextReq,
               LPSTR szHeader,
               LPSTR szRealm,
               LPSTR szHost, 
               LPSTR szUrl, 
               LPSTR szMethod,    
               LPSTR szUser, 
               LPSTR szPass, 
               LPSTR szNonce,
               HWND  hWnd,
               LPSTR szResponse,
               DWORD cbResponse)
{
    SECURITY_STATUS ssResult;    
    
    // Input buffers and descriptor.
    SecBuffer sbIn[10];    
    SecBufferDesc sbdIn;
    sbdIn.pBuffers = sbIn;
    sbdIn.cBuffers = 10;
    
	dprintf(API,"InitializeSecurityContext(\n"
				"Cred: [%d(%#x),%d(%#x)]\n"
				"Ctxt: [%d(%#x),%d(%#x)]\n"
				"New Ctxt: [%d(%#x),%d(%#x)]\n",
				(phCred?(phCred->dwUpper):0), 
				(phCred?(phCred->dwUpper):0), 
				   (phCred?(phCred->dwLower):0), 
				   (phCred?(phCred->dwLower):0), 
				   (phCtxt?(phCtxt->dwUpper):0), 
				   (phCtxt?(phCtxt->dwUpper):0), 
				   (phCtxt?(phCtxt->dwLower):0), 
				   (phCtxt?(phCtxt->dwLower):0), 
				   (phNewCtxt?(phNewCtxt->dwUpper):0), 
				   (phNewCtxt?(phNewCtxt->dwUpper):0), 
				   (phNewCtxt?(phNewCtxt->dwLower):0),
				   (phNewCtxt?(phNewCtxt->dwLower):0));

    sbIn[0].pvBuffer    = szHeader;           // Challenge header
    sbIn[1].pvBuffer    = szRealm;            // realm if preauth
    sbIn[2].pvBuffer    = szHost;             // host
    sbIn[3].pvBuffer    = szUrl;              // url
    sbIn[4].pvBuffer    = szMethod;           // http method
    sbIn[5].pvBuffer    = szUser;             // username (optional)
    sbIn[6].pvBuffer    = szPass;             // password (optional, not used currently)    
    sbIn[7].pvBuffer    = szNonce;            // nonce
    sbIn[8].pvBuffer    = NULL;               // nonce count not passed in.
    sbIn[9].pvBuffer    = &hWnd;              // window handle.


    // Output buffer and descriptor.
    SecBuffer sbOut[1];
    SecBufferDesc sbdOut;
    sbdOut.pBuffers = sbOut;
    sbdOut.cBuffers = 1;
        
    // Set output buffer.
    sbOut[0].pvBuffer = szResponse;
    sbOut[0].cbBuffer = cbResponse;

    // ***** SSPI CALL *****
    ssResult = (*(g_pFuncTbl->InitializeSecurityContextA))
        (phCred,            // phCredential    (from AcquireCredentialsHandle)
         phCtxt,            // phContext       (NULL on first call, phNewCtxt on subsequent calls).
         NULL,              // pszTargetName   (not used)
         fContextReq ,      // fContextReq     (auth from cache, prompt or auth using supplied creds)(not used)
         0,                 // Reserved1       (not used)
         0,                 // TargetDataRep   (not used)
         &sbdIn,            // PSecBufDesc     (input buffer descriptor)
         0,                 // Reserved2       (not used)
         phNewCtxt,         // phNewContext    (should be passed back as phCtxt on subsequent calls)
         &sbdOut,           // pOutput         (output buffer descriptor)
         NULL,				// pfContextAttr   (not used)
         NULL);             // ptsExpiry       (not used)

#ifdef _DEBUG
	fprintf(stderr,"ISC returned result : %s(%d), buffer : \n %s \n", 
					issperr2str(ssResult),ssResult,sbOut[0].pvBuffer );
#endif

    return ssResult;
}

VOID PrimeCredCache(CredHandle CredHandle, LPSTR szRealm, LPSTR szUser, LPSTR szPass)
{
    DWORD ssResult;
    CtxtHandle hCtxt;

    SecBufferDesc sbdIn;
    SecBuffer     sbIn[3];
    
    hCtxt.dwLower = CredHandle.dwLower;
    hCtxt.dwUpper = CredHandle.dwUpper;

    sbIn[0].pvBuffer = szRealm;
    sbIn[0].cbBuffer = strlen(szRealm);
    sbIn[1].pvBuffer = szUser;
    sbIn[1].cbBuffer = strlen(szUser);
    sbIn[2].pvBuffer = szPass;
    sbIn[2].cbBuffer = strlen(szPass);

    sbdIn.cBuffers = 3;
    sbdIn.pBuffers = sbIn;

    ssResult = (*(g_pFuncTbl->ApplyControlToken))(&hCtxt, &sbdIn);

}

//----------------------------------------------------------------------------
// main
//----------------------------------------------------------------------------
#ifdef UNIX
#define main prog_main

int _main(int argc, char **argv);

int _WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR pszCmdLine, int nCmdShow) {
    extern int __argc;
    extern char **__argv;
    return main(__argc, __argv);
}
int _main(int argc, char **argv)
#else
INT _main()
#endif
{        

#define IDENTITY_1 "Alice"
#define IDENTITY_2 "Bob"

    DWORD dwReturn = 0;
    SECURITY_STATUS ssResult;

    // Get (global) dispatch table.
    InitializeSecurityInterface(TRUE);
 
    // Check to see if we have digest.
    if (!HaveDigest())
    {
        dwReturn = 1;
        goto exit;
    }
    
    // Credential handle and pointer.
    CredHandle  hCred1, hCred2, hCred3; 
    CtxtHandle  hCtxt1, hCtxt2, hCtxt3;

    // Three apps logon using the same keys (appctx, userctx, both NULL);
    // These sessions will be used for authentication.
    LogonToDigestPkg(NULL, IDENTITY_1, &hCred1);
    LogonToDigestPkg(NULL, IDENTITY_1, &hCred2);
    LogonToDigestPkg(NULL, IDENTITY_1, &hCred3);

    // Three more apps also logon using the same keys.
    // we will prime the password cache with credentials for these apps
    // and expect to be able to share the credentials via the auth dialog.
    CredHandle hCred4, hCred5, hCred6;

    LogonToDigestPkg(NULL, IDENTITY_1, &hCred4);
    LogonToDigestPkg(NULL, IDENTITY_1, &hCred5);
    LogonToDigestPkg(NULL, IDENTITY_1, &hCred6);
    
    PrimeCredCache(hCred4, "testrealm@foo.com", "Wilma", "password");
    PrimeCredCache(hCred5, "testrealm@foo.com", "Betty", "passwordxxxx");
    PrimeCredCache(hCred6, "testrealm@foo.com", "Pebbles", "passwordxxxxx");

    // Finally, three more apps also logon using a different logon key (identity)
    // we will prime the password cache with credentials for these apps
    // Because of the different logon key we should never see these creds.
    CredHandle hCred7, hCred8, hCred9;
    
    LogonToDigestPkg(NULL, IDENTITY_2, &hCred7);
    LogonToDigestPkg(NULL, IDENTITY_2, &hCred8);
    LogonToDigestPkg(NULL, IDENTITY_2, &hCred9);
    
    PrimeCredCache(hCred7, "testrealm@foo.com", "Fred", "password");
    PrimeCredCache(hCred8, "testrealm@foo.com", "Barney",  "passwordxxxx");
    PrimeCredCache(hCred9, "testrealm@foo.com", "Bam Bam", "passwordxxxxxxxx");
    
    
    
    //------------------------------------------------------------------------------------------------------------- 
    // App 1 makes a request from a server, does not have credentials and must prompt
    // before finally succeeding.
    
    // Challenge from server.
    LPSTR szChallenge;
    szChallenge = "realm=\"testrealm@foo.com\", stale = FALSE, qop=\"auth,auth-int\", nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"";

    // Package will dump response into this buffer.
    CHAR szResponse[4096];
                
    // First try at authenticating.
    ssResult = 
    DoAuthenticate( &hCred1,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt1,                    // Output context.
                    0,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz/boz/bif.html",    // Url.
                    "GET",                      // Method.
                    NULL,                       // no Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hwnd for auth.
                    szResponse,                // Response buffer.
                    4096);
        
    // Expect to not have credentials the first time - prompt.
    if (ssResult == SEC_E_NO_CREDENTIALS)
    {
        ssResult = 
        DoAuthenticate( &hCred1,                    // Cred from logging on.
                        &hCtxt1,                    // Ctxt from previous call
                        &hCtxt1,                    // Output context (same as from previous).
                        ISC_REQ_PROMPT_FOR_CREDS,   // prompt
                        szChallenge,                // Server challenge
                        NULL,                       // No realm
                        "www.foo.com",              // Host
                        "/bar/baz/boz/bif.html",    // Url
                        "GET",                      // Method
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        GetDesktopWindow(),         // desktop window
                        szResponse,                // Response buffer
                        4096);

    }

    // We now have credentials and this will generate the output string.
    if (ssResult == SEC_E_OK)
    {
        ssResult = 
        DoAuthenticate( &hCred1,                    // Cred from logging on.
                        &hCtxt1,                    // Ctxt not specified first time.
                        &hCtxt1,                    // Output context.
                        0,                          // auth
                        szChallenge,                // Server challenge.
                        NULL,                       // no realm
                        "www.foo.com",              // Host.
                        "/bar/baz/boz/bif.html",    // Url.
                        "GET",                      // Method.
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        NULL,                       // no hwnd
                        szResponse,                // Should have the response buffer now.
                        4096);
    }          

    //------------------------------------------------------------------------------------------------------------- 
    // App 2 makes a request to the same server and gets challenged for the same realm. First auth attempt will
    // not be successful since this is the first challenge this session, so it will have to prompt for credentials.
    // When prompting, because it shares credentials with App1, the drop-down will contain App1's credentials.
    ssResult = 
    DoAuthenticate( &hCred2,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt2,                    // Output context.
                    0,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz/boz/bif.html",    // Url.
                    "GET",                      // Method.
                    NULL,                       // no Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hwnd for auth.
                    szResponse,                // Response buffer.
                    4096);
    
    // Generate the confirmation dialog. User can choose App1's creds or enter new credentials.
    if (ssResult == SEC_E_NO_CREDENTIALS)
    {
        ssResult = 
        DoAuthenticate( &hCred2,                    // Cred from logging on.
                        &hCtxt2,                    // Ctxt from previous call
                        &hCtxt2,                    // Output context (same as from previous).
                        ISC_REQ_PROMPT_FOR_CREDS,   // prompt
                        szChallenge,                // Server challenge
                        NULL ,                      // No realm
                        "www.foo.com",              // Host
                        "/bar/baz/boz/bif.html",    // Url
                        "GET",                      // Method
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        GetDesktopWindow(),         // desktop window
                        szResponse,                // Response buffer
                        4096);

    }
    

    // App 2 now has credentials and can authenticate successfully.
    if (ssResult == SEC_E_OK)
    {
        ssResult = 
        DoAuthenticate( &hCred2,                    // Cred from logging on.
                        &hCtxt2,                    // Ctxt not specified first time.
                        &hCtxt2,                    // Output context.
                        0,                          // auth
                        szChallenge,                // Server challenge.
                        NULL,                       // no realm
                        "www.foo.com",              // Host.
                        "/bar/baz/boz/bif.html",    // Url.
                        "GET",                      // Method.
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        NULL,                       // no hwnd
                        szResponse,                // Should have the response buffer now.
                        4096);
    }          

    //------------------------------------------------------------------------------------------------------------- 
    // App 3 makes a request to the same server and gets challenged for the same realm. First auth attempt will
    // not be successful since this is the first challenge this session, so it will have to prompt for credentials.
    // When prompting, because it shares credentials with App1 and App2 the drop-down could show two choices if
    // App2 entered new credentials (or just one if App2 chose to use App1's credential).
    ssResult = 
    DoAuthenticate( &hCred3,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt3,                    // Output context.
                    0,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz/boz/bif.html",    // Url.
                    "GET",                      // Method.
                    NULL,                       // no Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hwnd for auth.
                    szResponse,                // Response buffer.
                    4096);
    
    // Generate the confirmation dialog. User can choose App1's creds or enter new credentials.
    if (ssResult == SEC_E_NO_CREDENTIALS)
    {
        ssResult = 
        DoAuthenticate( &hCred3,                    // Cred from logging on.
                        &hCtxt3,                    // Ctxt from previous call
                        &hCtxt3,                    // Output context (same as from previous).
                        ISC_REQ_PROMPT_FOR_CREDS,   // prompt
                        szChallenge,                // Server challenge
                        NULL ,                      // No realm
                        "www.foo.com",              // Host
                        "/bar/baz/boz/bif.html",    // Url
                        "GET",                      // Method
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        GetDesktopWindow(),         // desktop window
                        szResponse,                // Response buffer
                        4096);

    }
    

    // App 3 now has credentials and can authenticate successfully.
    if (ssResult == SEC_E_OK)
    {
        ssResult = 
        DoAuthenticate( &hCred3,                    // Cred from logging on.
                        &hCtxt3,                    // Ctxt not specified first time.
                        &hCtxt3,                    // Output context.
                        0,                          // auth
                        szChallenge,                // Server challenge.
                        NULL,                       // no realm
                        "www.foo.com",              // Host.
                        "/bar/baz/boz/bif.html",    // Url.
                        "GET",                      // Method.
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        NULL,                       // no hwnd
                        szResponse,                // Should have the response buffer now.
                        4096);
    }          
    
    
    //------------------------------------------------------------------------------------------------------------- 
    // App2 preauthenticates to "testrealm@foo.com" for a new url. Note that the credential that will be used
    // for preauthentication is whatever App2 chose or entered previously. The same would be true for 
    // App1 or App3.
    ssResult = 
    DoAuthenticate( &hCred2,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt2,                    // Output context.
                    0,                          // auth (preauth)
                    NULL,                       // No challenge header
                    "testrealm@foo.com",        // Realm for preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz.gif",             // Url
                    "GET",                      // Method.
                    NULL,                       // no sername
                    NULL,                       // no password.
                    NULL,                       // no nonce
                    NULL,                       // no hwnd
                    szResponse,                // Response buffer.
                    4096);
    
    //------------------------------------------------------------------------------------------------------------- 
    // App3 made another request to the same server but did not preauthenticate. It got challenged for the
    // same realm and can authenticate without prompting because it has credentials for that realm.
    szChallenge = "realm=\"testrealm@foo.com\", stale = TRUE, qop=\"auth,auth-int\", nonce=\"abcdefge8b11d0f600bfb0c093\", opaque=\"efghijklmnopc403ebaf9f0171e9517f40e41\"";

    ssResult = 
    DoAuthenticate( &hCred3,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt3,                    // Output context.
                    0,                          // auth
                    szChallenge,                // Challenge from server.
                    NULL,                       // no realm
                    "www.foo.com",              // Host.
                    "/bar/baz.htm",             // Url
                    "GET",                      // Method.
                    NULL,                       // no username
                    NULL,                       // no password
                    NULL,                       // no nonce
                    NULL,                       // no hwnd
                    szResponse,                // Response buffer.
                    4096);
    
    
    
    
    // Logoff all three sessions
    ssResult = LogoffOfDigestPkg(&hCred1);
    ssResult = LogoffOfDigestPkg(&hCred2);
    ssResult = LogoffOfDigestPkg(&hCred3);
    ssResult = LogoffOfDigestPkg(&hCred4);
    ssResult = LogoffOfDigestPkg(&hCred5);
    ssResult = LogoffOfDigestPkg(&hCred6);
    ssResult = LogoffOfDigestPkg(&hCred7);
    ssResult = LogoffOfDigestPkg(&hCred8);
    ssResult = LogoffOfDigestPkg(&hCred9);
    
    if (hSecLib)
        FreeLibrary(hSecLib);

exit:
    return dwReturn;
}
    
LPSTR
issperr2str( SECURITY_STATUS error )
{

#define CASE(x) if( x == error ) \
						return #x;


//	switch( error ) {

		CASE ( SEC_E_INSUFFICIENT_MEMORY )

		//
		// MessageId: SEC_E_INVALID_HANDLE
		//
		// MessageText:
		//
		//  The handle specified is invalid
		//
		CASE ( SEC_E_INVALID_HANDLE )

		//
		// MessageId: SEC_E_UNSUPPORTED_FUNCTION
		//
		// MessageText:
		//
		//  The function requested is not supported
		//
		CASE ( SEC_E_UNSUPPORTED_FUNCTION )

		//
		// MessageId: SEC_E_TARGET_UNKNOWN
		//
		// MessageText:
		//
		//  The specified target is unknown or unreachable
		//
		CASE ( SEC_E_TARGET_UNKNOWN )

		//
		// MessageId: SEC_E_INTERNAL_ERROR
		//
		// MessageText:
		//
		//  The Local Security Authority cannot be contacted
		//
		CASE ( SEC_E_INTERNAL_ERROR )

		//
		// MessageId: SEC_E_SECPKG_NOT_FOUND
		//
		// MessageText:
		//
		//  The requested security package does not exist
		//
		CASE ( SEC_E_SECPKG_NOT_FOUND )

		//
		// MessageId: SEC_E_NOT_OWNER
		//
		// MessageText:
		//
		//  The caller is not the owner of the desired credentials
		//
		CASE ( SEC_E_NOT_OWNER )

		//
		// MessageId: SEC_E_CANNOT_INSTALL
		//
		// MessageText:
		//
		//  The security package failed to initialize, and cannot be installed
		//
		CASE ( SEC_E_CANNOT_INSTALL )

		//
		// MessageId: SEC_E_INVALID_TOKEN
		//
		// MessageText:
		//
		//  The token supplied to the function is invalid
		//
		CASE ( SEC_E_INVALID_TOKEN )

		//
		// MessageId: SEC_E_CANNOT_PACK
		//
		// MessageText:
		//
		//  The security package is not able to marshall the logon buffer,
		//  so the logon attempt has failed
		//
		CASE ( SEC_E_CANNOT_PACK )

		//
		// MessageId: SEC_E_QOP_NOT_SUPPORTED
		//
		// MessageText:
		//
		//  The per-message Quality of Protection is not supported by the
		//  security package
		//
		CASE ( SEC_E_QOP_NOT_SUPPORTED )

		//
		// MessageId: SEC_E_NO_IMPERSONATION
		//
		// MessageText:
		//
		//  The security context does not allow impersonation of the client
		//
		CASE ( SEC_E_NO_IMPERSONATION )

		//
		// MessageId: SEC_E_LOGON_DENIED
		//
		// MessageText:
		//
		//  The logon attempt failed
		//
		CASE ( SEC_E_LOGON_DENIED )

		//
		// MessageId: SEC_E_UNKNOWN_CREDENTIALS
		//
		// MessageText:
		//
		//  The credentials supplied to the package were not
		//  recognized
		//
		CASE ( SEC_E_UNKNOWN_CREDENTIALS )

		//
		// MessageId: SEC_E_NO_CREDENTIALS
		//
		// MessageText:
		//
		//  No credentials are available in the security package
		//
		CASE ( SEC_E_NO_CREDENTIALS )

		//
		// MessageId: SEC_E_MESSAGE_ALTERED
		//
		// MessageText:
		//
		//  The message supplied for verification has been altered
		//
		CASE ( SEC_E_MESSAGE_ALTERED )

		//
		// MessageId: SEC_E_OUT_OF_SEQUENCE
		//
		// MessageText:
		//
		//  The message supplied for verification is out of sequence
		//
		CASE ( SEC_E_OUT_OF_SEQUENCE )

		//
		// MessageId: SEC_E_NO_AUTHENTICATING_AUTHORITY
		//
		// MessageText:
		//
		//  No authority could be contacted for authentication.
		//
		CASE ( SEC_E_NO_AUTHENTICATING_AUTHORITY )

		//
		// MessageId: SEC_I_CONTINUE_NEEDED
		//
		// MessageText:
		//
		//  The function completed successfully, but must be called
		//  again to complete the context
		//
		CASE ( SEC_I_CONTINUE_NEEDED )

		//
		// MessageId: SEC_I_COMPLETE_NEEDED
		//
		// MessageText:
		//
		//  The function completed successfully, but CompleteToken
		//  must be called
		//
		CASE ( SEC_I_COMPLETE_NEEDED )

		//
		// MessageId: SEC_I_COMPLETE_AND_CONTINUE
		//
		// MessageText:
		//
		//  The function completed successfully, but both CompleteToken
		//  and this function must be called to complete the context
		//
		CASE ( SEC_I_COMPLETE_AND_CONTINUE )

		//
		// MessageId: SEC_I_LOCAL_LOGON
		//
		// MessageText:
		//
		//  The logon was completed, but no network authority was
		//  available.  The logon was made using locally known information
		//
		CASE ( SEC_I_LOCAL_LOGON )

		//
		// MessageId: SEC_E_BAD_PKGID
		//
		// MessageText:
		//
		//  The requested security package does not exist
		//
		CASE ( SEC_E_BAD_PKGID )

		//
		// MessageId: SEC_E_CONTEXT_EXPIRED
		//
		// MessageText:
		//
		//  The context has expired and can no longer be used.
		//
		CASE ( SEC_E_CONTEXT_EXPIRED )

		//
		// MessageId: SEC_E_INCOMPLETE_MESSAGE
		//
		// MessageText:
		//
		//  The supplied message is incomplete.  The signature was not verified.
		//
		CASE ( SEC_E_INCOMPLETE_MESSAGE )

		//
		// Provided for backwards compatibility
		//

		CASE ( SEC_E_NO_SPM )
		CASE ( SEC_E_NOT_SUPPORTED )

//		default:

			return "Unknown SSPI Error ";
//			break;

//	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\javahlp\sources.inc ===
!IF 0
Java VM help files.
!ENDIF

TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=

SOURCES=

MISCFILES =             \
    javaperm.hlp \
    javasec.hlp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\digest\test\stress\monkey.cpp ===
#include <process.h>
#include <windows.h>
//#include <winbase.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <assert.h>
#include <shlwapi.h>
#include <conio.h>
//#include <shlwapip.h>
#include "resource.h"
#include "lists.hxx"

//#define DBG
#define DEBUG
#define _DEBUG


#include "main.hxx"

#define MAX_HANDLES 255
////////////////////////////////////////
//
//      G L O B A L S
//
//
////////////////////////////////////////
CSessionAttributeList * g_pSessionAttributeList = NULL;
CSessionList * g_pSessionList = NULL;


DWORD   dwThreads = 0;
int             iNumIterations = 0;
unsigned uSeed = 0;

DWORD dwDebugLogCategory;
DWORD dwConsoleLogCategory;
DWORD dwDebugBreakCategory;
DWORD dwUIDialogMode = MODE_ALL;
BOOL fLogToDebugTerminal = FALSE;
BOOL fLogToConsole = TRUE;
BOOL fDebugBreak = FALSE;

#define MALLOC( x ) malloc(sizeof(x))

#define FIND_FUNCTION_KERNEL( x, y ) ( x##_P = (FN##x) GetProcAddress( hModule, #x ));
#define FIND_FUNCTION( x , y ) ( x##_P = (FN##x) GetProcAddress( hModule, y ));
#define IS_ARG(c) ( c == '-' )

//
// ACTION
//              A routine which takes a LPVOID as input, 
//              performs some action
//              and returns another LPVOID
//
typedef LPVOID ( WINAPI * ACTION)(LPVOID);

BOOL Test();

////////////////////////////////////////////////////////////////////////////////////
//
//		D E C L A R A T I O N S
//
////////////////////////////////////////////////////////////////////////////////////
typedef enum {
	MODE_NONE = -1,
	MODE_BUSY,
	MODE_FREE,
	MODE_CAPTURED
} MODE;

/*
CONTEXT_RECORD CAPTURED_CTX = { { 0xcabdcabd, 0xcabdcabd };
CONTEXT_RECORD FREE_CTX =	{{ 0, 0 };
CONTEXT_RECORD BUSY_CTX =	{{ 0xb00bb00b, 0xb00bb00b };
*/

CredHandle CAPTURED_CRED = { 0xcabdcabd, 0xcabdcabd };
CredHandle FREE_CRED =	{ 0, 0 };
CredHandle BUSY_CRED =	{ 0xb00bb00b, 0xb00bb00b };


typedef struct _CONTEXT_RECORD {

	// handle to the credential
	CredHandle hCred;

	// App ctx associated with this credential
	LPSTR		szAppCtx;

	// User Ctx associated with this credential
	LPSTR		szUserCtx;

	// Timestamp
	DWORD		dwTickCount;

	// MODE
	MODE		Mode;

} CONTEXT_RECORD, * LPCONTEXT_RECORD;

// forward declarations
class CSessionAttribute;

#define MAX_APP_CONTEXT_LENGTH	32
#define MAX_USER_CONTEXT_LENGTH MAX_APP_CONTEXT_LENGTH
typedef struct _CREDENTIAL_STRUCT {

	// username
	LPSTR szUserName;

	// password
	LPSTR szPassword;

	// realm
	LPSTR szRealm;

} CREDENTIAL_STRUCT, *LPCREDENTIAL_STRUCT;

typedef struct _HANDLE_RECORD {
	
	DWORD dwSignature;
	
	CONTEXT_RECORD hCredArray[MAX_HANDLES];

	int Count; // count of handles in use.
	
	CRITICAL_SECTION Lock;

} HANDLE_RECORD, *LPHANDLE_RECORD;

#define CTXHANDLE_ARRAY_SIGNATURE		'xtch' // 'hctx'

#define IS_VALID_CTXHANDLE_ARRAY(x)	{ assert( x -> dwSignature == CTXHANDLE_ARRAY_SIGNATURE ); }

#define IDENTITY_1		"Application_1"

// bugbug: The values of the CredHandles in these structures should match
// the corresponding *_CRED structure values.
//
#ifdef NEW_LOOKUP

    MODE ModeCaptured = MODE_CAPTURED;
    MODE ModeFree = MODE_FREE;
    MODE ModeBusy = MODE_BUSY;

    #define CAPTURED_CTX_REC	ModeCaptured

    #define FREE_CTX_REC	ModeFree

    #define BUSY_CTX_REC	ModeBusy

#else
    CONTEXT_RECORD CAPTURED_CTX_REC = {
									    { 0xcabdcabd, 0xcabdcabd },
									    NULL, 
									    NULL};

    CONTEXT_RECORD FREE_CTX_REC =	{
									    { 0, 0 }, 
									    NULL, 
									    NULL};

    CONTEXT_RECORD BUSY_CTX_REC =	{
									    { 0xb00bb00b, 0xb00bb00b }, 
									    NULL, 
									    NULL};
#endif // ifdef NEW_LOOKUP

BOOL operator==(const CredHandle op1, const CredHandle op2)
{
	return (( op1.dwUpper == op2.dwUpper ) && ( op1.dwUpper == op2.dwUpper ));
}

BOOL operator!=(const CredHandle op1, const CredHandle op2)
{
	return (( op1.dwUpper != op2.dwUpper ) || ( op1.dwUpper != op2.dwUpper ));
}

BOOL operator==(const CONTEXT_RECORD op1, const CONTEXT_RECORD op2)
{
	// we only compare the CredHandle
	return (op1.hCred == op2.hCred );
}

BOOL operator!=(const CONTEXT_RECORD op1, const CONTEXT_RECORD op2)
{
	// we only compare the CredHandle
	return (op1.hCred != op2.hCred );
}

typedef struct {

	// a string in the DWORD
	DWORD   dwSignature;

	// handles to contexts
	HANDLE_RECORD  * hCredentialHandles;

	// count of iterations
	int iCount;

} CONTEXT_DATA, * LPCONTEXT_DATA;

#define CONTEXT_SIGNATURE       'tnoc'
#define IS_VALID_CONTEXT(s) { assert ( s -> dwSignature == CONTEXT_SIGNATURE ); }
#define SET_CONTEXT_SIGNATURE(s) { s -> dwSignature = CONTEXT_SIGNATURE; }

//
// contexts passed to threads, and RegisterWaits() etc.
//

typedef struct _CALLBACK_CONTEXT {
	
	DWORD dwSignature;
	LPCONTEXT_DATA lpContext;
	LPHANDLE lpThreadHandle;
	LPHANDLE lpHandle;

} CALLBACK_CONTEXT, * LPCALLBACK_CONTEXT;

#define CALLBACK_CONTEXT_SIGNATURE	'kblc' // clbk
#define IS_VALID_CALLBACK_CONTEXT(x) ( assert( s -> dwSignature ) == CALLBACK_CONTEXT_SIGNATURE )

#ifdef NEW_LOOKUP
LPCONTEXT_RECORD
FindFreeSlot( 
			 HANDLE_RECORD * hArray, 
			 LPCONTEXT_RECORD hMode);
#else
LPCONTEXT_RECORD
FindFreeSlot( 
			 HANDLE_RECORD * hArray, 
			 LPCONTEXT_RECORD hMode);
#endif

LPHANDLE_RECORD
new_handle_record(DWORD dwSignature);

LPCALLBACK_CONTEXT
new_callback_context();

LPVOID
WINAPI fnAppLogon(
			LPVOID lpvData);

LPVOID
WINAPI fnAppLogonExclusive(
			LPVOID lpvData);

LPVOID
WINAPI fnAppLogonShared(
			LPVOID lpvData);

LPVOID
WINAPI fnAppLogoff(
			LPVOID lpvData);

LPVOID
WINAPI fnInit(
			LPVOID lpvData);

LPVOID
WINAPI fnPopulateCredentials(
			LPVOID lpvData);

LPVOID
WINAPI fnAuthChallenge(
			LPVOID lpvData);

LPVOID
WINAPI fnAuthChallengeAny(
			LPVOID lpvData);

LPVOID
WINAPI fnAuthChallengeUser(
			LPVOID lpvData);

LPVOID
WINAPI fnAuthChallengeUserPassword(
			LPVOID lpvData);

LPVOID
WINAPI fnUiPrompt(
			LPVOID lpvData);

LPVOID
WINAPI fnUiPromptAny(
			LPVOID lpvData);

LPVOID
WINAPI fnUiPromptUser(
			LPVOID lpvData);

LPVOID
WINAPI fnFlushCredentials(
			LPVOID lpvData);

LPVOID
WINAPI fnFlushCredentialsGlobal(
			LPVOID lpvData);

LPVOID
WINAPI fnFlushCredentialsSession(
			LPVOID lpvData);

BOOL
SetUIUserNameAndPassword(
						 LPSTR szUsername,
						 LPSTR szPassword,
						 BOOL fPersist);

//DWORD WINAPI fnRegisterWaitCallback( PVOID pvData );

//
//      Enum Type for STATE
//
typedef enum _State 
			{
				STATE_INVALID,

				STATE_NONE,

				STATE_INIT,

				STATE_APP_LOGON,

				    STATE_APP_LOGON_EXCLUSIVE,

				    STATE_APP_LOGON_SHARED,

				STATE_APP_LOGOFF,

				STATE_POPULATE_CREDENTIALS,

				STATE_AUTH_CHALLENGE,

				    STATE_AUTH_CHALLENGE_ANY,

				    STATE_AUTH_CHALLENGE_USER,

				    STATE_AUTH_CHALLENGE_USER_PASS,

				STATE_PREAUTH_CHALLENGE_ANY,

				STATE_PREAUTH_CHALLENGE_USER,

				STATE_PREAUTH_CHALLENGE_USER_PASS,

				STATE_UI_PROMPT,

				    STATE_UI_PROMPT_ANY,

				    STATE_UI_PROMPT_USER,

				STATE_FLUSH_CREDENTIALS,

				    STATE_FLUSH_CREDENTIALS_GLOBAL,

				    STATE_FLUSH_CREDENTIALS_SESSION,

                STATE_NUKE_TRUSTED_HOSTS,

				STATE_STATISTICS,

				STATE_STALL,

				STATE_DONE

			 }  STATE;


//
//      STATE Table definition
//
typedef struct _STATE_TABLE {

	//
	// The current state we are in
	//
	STATE CurrentState;
	
	//
	// THe next state which we will transition to
	//
	STATE NextState;

	//
	// Action ( function ) to be performed in the "CurrentState"
	//
	ACTION  Action;

	//
	// prob of going from CurrentState to NextState if there 
	// are two or more such transitions from the same state
	// present in the table
	//
	DWORD   dwProbability; 

} STATE_TABLE, *LPSTATE_TABLE;

STATE_TABLE TRANSITION_TABLE[] =
	{
		// transitions out of STATE_INIT
		{
			STATE_INIT, STATE_APP_LOGON,
			fnInit,
			50
		},
		// transitions out of STATE_INIT
		{
			STATE_INIT, STATE_FLUSH_CREDENTIALS,
			fnInit,
			100
		},
		// transitions out of STATE_APP_LOGON
		{
			STATE_APP_LOGON, STATE_UI_PROMPT,
			fnAppLogon,
			60
		},
		{
			STATE_APP_LOGON, STATE_POPULATE_CREDENTIALS,
			fnAppLogon,
			70
		},
		{
			STATE_APP_LOGON, STATE_AUTH_CHALLENGE,
			fnAppLogon,
			100
		},
		// transitions out of STATE_POPULATE_CREDENTIALS
		{
			STATE_POPULATE_CREDENTIALS, STATE_INIT,
			fnPopulateCredentials,
			30
		},
		{
			STATE_POPULATE_CREDENTIALS, STATE_APP_LOGOFF,
			fnPopulateCredentials,
			60
		},
		{
			STATE_POPULATE_CREDENTIALS, STATE_UI_PROMPT,
			fnPopulateCredentials,
			100
		},
		// transitions out of STATE_AUTH_CHALLENGE
		{
			STATE_AUTH_CHALLENGE, STATE_APP_LOGON,
			fnAuthChallenge,
			100
		},
		// transitions out of STATE_UI_PROMPT
		{
			STATE_UI_PROMPT, STATE_INIT,
			fnUiPrompt,
			100
		},
		// transitions out of STATE_FLUSH_CREDENTIALS
		{
			STATE_FLUSH_CREDENTIALS, STATE_APP_LOGON,
			fnFlushCredentials,
			100
		},
		// transitions out of STATE_APP_LOGOFF
		{
			STATE_APP_LOGOFF, STATE_APP_LOGON,
			fnAppLogoff,
			100
		},
		// transitions out of STATE_INVALID
		{
			STATE_INVALID, STATE_INVALID,
			NULL,
			100
		},
		// transitions out of STATE_DONE
		{
			STATE_DONE, STATE_INVALID,
			NULL,
			100
		}
	};

STATE_TABLE	APP_LOGON_TRANSITION_TABLE[] =
{

		// transitions out of STATE_INIT
		{
			STATE_INIT, STATE_APP_LOGON_SHARED,
			fnInit,
			50
		},
		{
			STATE_INIT, STATE_APP_LOGON_EXCLUSIVE,
			fnInit,
			100
		},
		// transitions out of STATE_APP_LOGON_EXCLUSIVE
		{
			STATE_APP_LOGON_EXCLUSIVE, STATE_DONE,
			fnAppLogonExclusive,
			50
		},
		{
			STATE_APP_LOGON_SHARED, STATE_DONE,
			fnAppLogonShared,
			100
		},
		// transitions out of STATE_DONE
		{
			STATE_DONE, STATE_DONE,
			NULL,
			100
		}
};

STATE_TABLE	AUTH_CHALLENGE_TRANSITION_TABLE[] =
{

		// transitions out of STATE_INIT
		{
			STATE_INIT, STATE_AUTH_CHALLENGE_ANY,
			fnInit,
			30
		},
		{
			STATE_INIT, STATE_AUTH_CHALLENGE_USER,
			fnInit,
			70
		},
		{
			STATE_INIT, STATE_AUTH_CHALLENGE_USER_PASS,
			fnInit,
			100
		},
		// transitions out of STATE_AUTH_CHALLENGE_ANY
		{
			STATE_AUTH_CHALLENGE_ANY, STATE_DONE,
			fnAuthChallengeAny,
			50
		},
		// transitions out of STATE_AUTH_CHALLENGE_USER
		{
			STATE_AUTH_CHALLENGE_USER, STATE_DONE,
			fnAuthChallengeUser,
			100
		},
		// transitions out of STATE_AUTH_CHALLENGE_USER_PASS
		{
			STATE_AUTH_CHALLENGE_USER_PASS, STATE_DONE,
			fnAuthChallengeUserPassword,
			100
		},
		// transitions out of STATE_DONE
		{
			STATE_DONE, STATE_DONE,
			NULL,
			100
		}
};

STATE_TABLE	UI_PROMPT_TRANSITION_TABLE[] =
{

		// transitions out of STATE_INIT
		{
			STATE_INIT, STATE_UI_PROMPT_ANY,
			fnInit,
			50
		},
		{
			STATE_INIT, STATE_UI_PROMPT_USER,
			fnInit,
			100
		},
		// transitions out of STATE_UI_PROMPT_ANY
		{
			STATE_UI_PROMPT_ANY, STATE_DONE,
			fnUiPromptAny,
			100
		},
		// transitions out of STATE_UI_PROMPT_USER
		{
			STATE_UI_PROMPT_USER, STATE_DONE,
			fnUiPromptUser,
			100
		},
		// transitions out of STATE_DONE
		{
			STATE_DONE, STATE_DONE,
			NULL,
			100
		}
};

STATE_TABLE	FLUSH_CREDENTIALS_TRANSITION_TABLE[] =
{

		// transitions out of STATE_INIT
		{
			STATE_INIT, STATE_FLUSH_CREDENTIALS_SESSION,
			fnInit,
			50
		},
		{
			STATE_INIT, STATE_FLUSH_CREDENTIALS_GLOBAL,
			fnInit,
			100
		},
		// transitions out of STATE_FLUSH_CREDENTIALS_SESSION
		{
			STATE_FLUSH_CREDENTIALS_SESSION, STATE_DONE,
			fnFlushCredentialsSession,
			100
		},
		// transitions out of STATE_FLUSH_CREDENTIALS_GLOBAL
		{
			STATE_FLUSH_CREDENTIALS_GLOBAL, STATE_DONE,
			fnFlushCredentialsGlobal,
			100
		},
		// transitions out of STATE_DONE
		{
			STATE_DONE, STATE_DONE,
			NULL,
			100
		}
};

VOID WINAPI fnRegisterWaitCallback(
					PVOID pvData,
					BOOLEAN  fAlertable);

VOID WINAPI fnTimerCallback(
					PVOID pvData,
					BOOLEAN  fAlertable);


LPCONTEXT_DATA
new_context();

DWORD
TuringMachine(
	STATE_TABLE     StateTable[],
	STATE           InitialState,
	LPVOID          lpvData);

//WAITORTIMERCALLBACKFUNC fnRegisterWaitCallback;

//extern HANDLE RegisterWaitForSingleObject( HANDLE, WAITORTIMERCALLBACKFUNC, PVOID, DWORD);
STATE
NEXT_STATE( STATE_TABLE Table[], STATE CurrentState );

ACTION
GET_STATE_ACTION( STATE_TABLE Table[], STATE CurrentState );

LPSTR
MapState( STATE State );

void
usage(void);

int __cdecl _sprintf( char * buffer, char * format, va_list );

LPVOID
WINAPI DefaultAction(
			LPVOID lpvData);

#ifdef NEW_LOOKUP
LPCONTEXT_RECORD
FindFreeSlot( HANDLE_RECORD * hArray, MODE * Mode )
{
	// hMode is for doing a context-sensitive search
	//
	// If hMode == FREE_CTX, 
	//	begin
	//			find a free-slot;
	//			mark it busy
	//			return the slot;
	//	end
	// else
	//	if hMode == BUSY_CTX
	//		begin
	//			find a busy-slot
	//			return slot
	//		end
	//	else
	//		/* this means that a search is being requested */
	//		find a record corresponding to hMode
	//		return it
	//

	int i;
	HANDLE hTemp = NULL, hOrig = NULL;
	LPCONTEXT_RECORD phRet = NULL;
	int Cnt=0;


	dprintf( ENTRY_EXIT, "Enter: FindFreeSlot( %#X, %s )\n",
				hArray, 
				((*Mode == MODE_FREE)
					?"FREE"
					:((*Mode == MODE_BUSY)
					?"BUSY"
					:"CAPTURED")));

	EnterCriticalSection( &hArray -> Lock );

	for( i = 0; (i < MAX_HANDLES) && (Cnt <= hArray -> Count); i ++, Cnt++ ) {


		if(		// requesting a free slot
			(
				( *Mode == MODE_FREE )
			&&	( hArray -> hCredArray[i].Mode == MODE_FREE ) 
			) 
		||		// requesting any slot having valid credentials
			(
				( *Mode == MODE_BUSY ) 
			&&	( hArray -> hCredArray[i].Mode == MODE_BUSY ) 
			//&&	( hArray -> hCredArray[i].Mode != MODE_FREE ) 
			//&&	( hArray -> hCredArray[i].Mode != MODE_CAPTURED )
			)
		//||		// doing a context sensitive search
		//	(	// bugbug: what happens when szAppCtx stored is zero ?
		//		//( hArray -> hCredArray[i].Mode != MODE_FREE )
		//		( hArray -> hCredArray[i].Mode == MODE_BUSY )
		//	&&	( hMode -> szAppCtx && *hMode -> szAppCtx )
		//	&&	!strcmp( hArray -> hCredArray[i].szAppCtx, hMode -> szAppCtx )
		//	)
		) {
			// capture the handle if the handle requested is a free handle
			if( *Mode == MODE_FREE )
				hArray -> hCredArray[i].Mode = MODE_CAPTURED;

			phRet = &hArray -> hCredArray[i];
			break;
		}
	}

	LeaveCriticalSection( &hArray -> Lock );

	if(( i == MAX_HANDLES ) || (Cnt > hArray -> Count) )
		phRet = NULL;
	else {
		++ hArray -> Count;
	}
	
	
	if( phRet != NULL ) {
		dprintf( ENTRY_EXIT, "Exit: FindFreeSlot returns [%#x,%#x]\n",
			phRet->hCred.dwUpper,
			phRet->hCred.dwLower);
	} else {
		dprintf( ENTRY_EXIT, "Exit: FindFreeSlot returns %#x\n",phRet);
	}

	return phRet;
}
#else
LPCONTEXT_RECORD
FindFreeSlot( HANDLE_RECORD * hArray, LPCONTEXT_RECORD hMode )
{
	// hMode is for doing a context-sensitive search
	//
	// If hMode == FREE_CTX, 
	//	begin
	//			find a free-slot;
	//			mark it busy
	//			return the slot;
	//	end
	// else
	//	if hMode == BUSY_CTX
	//		begin
	//			find a busy-slot
	//			return slot
	//		end
	//	else
	//		/* this means that a search is being requested */
	//		find a record corresponding to hMode
	//		return it
	//

	int i;
	HANDLE hTemp = NULL, hOrig = NULL;
	LPCONTEXT_RECORD phRet = NULL;
	int Cnt=0;


	dprintf( ENTRY_EXIT, "Enter: FindFreeSlot( %#X, %#X )\n",hArray, hMode );

	EnterCriticalSection( &hArray -> Lock );

	for( i = 0; (i < MAX_HANDLES) && (Cnt <= hArray -> Count); i ++, Cnt++ ) {


		if(		// requesting a free slot
			(
				( hMode -> hCred == FREE_CRED )
			&&	( hArray -> hCredArray[i].hCred == hMode -> hCred ) 
			) 
		||		// requesting any slot having valid credentials
			(
				( hMode -> hCred == BUSY_CRED ) 
			&&	( hArray -> hCredArray[i].hCred != FREE_CRED ) 
			&&	( hArray -> hCredArray[i].hCred != CAPTURED_CRED )
			)
		||		// doing a context sensitive search
			(	// bugbug: what happens when szAppCtx stored is zero ?
				( hArray -> hCredArray[i].hCred != FREE_CRED )
			&&	( hMode -> szAppCtx && *hMode -> szAppCtx )
			&&	!strcmp( hArray -> hCredArray[i].szAppCtx, hMode -> szAppCtx )
			)
		) {
			// capture the handle if the handle requested is a free handle
			if( hMode->hCred == FREE_CRED )
				hArray -> hCredArray[i].hCred = CAPTURED_CRED;

			phRet = &hArray -> hCredArray[i];
			break;
		}
	}

	LeaveCriticalSection( &hArray -> Lock );

	if(( i == MAX_HANDLES ) || (Cnt > hArray -> Count) )
		phRet = NULL;
	else {
		++ hArray -> Count;
	}
	
	
	if( phRet != NULL ) {
		dprintf( ENTRY_EXIT, "Exit: FindFreeSlot returns %#x(%#x)\n",phRet,*phRet);
	} else {
		dprintf( ENTRY_EXIT, "Exit: FindFreeSlot returns %#x\n",phRet);
	}

	return phRet;
}
#endif

int __cdecl dprintf(DWORD dwCategory, char * format, ...) {

    va_list args;
    char buf[1024];
    char * ptr = buf;
	DWORD dwThreadId = GetCurrentThreadId();
    int n;

    ptr += sprintf(buf,"< %d:%#x > ", uSeed, dwThreadId );
    va_start(args, format);
    n = vsprintf(ptr, format, args);
    va_end(args);

	if(
			(fLogToDebugTerminal ) 
		&&	(dwCategory >= dwDebugLogCategory)
	)
	    OutputDebugString(buf);

	if(
		( fLogToConsole)
		&& ( dwCategory >= dwConsoleLogCategory)
	)
		printf("%s", buf );

	if(
			fDebugBreak
		&& ( dwCategory >= dwDebugBreakCategory ) 
	) {
		DebugBreak();
	}
    return n;
}

void
usage()
{
	dprintf( INFO, "thrdtest \n"
			" -n<number-of-iterations> \n"
			" -s: Directly Load the DLL \n"
			" -d<Level>: What to log to debug terminal (default: NO logging)\n"
			" -c<Level>: What to log to console (Default: INFO)\n"
			"		<Level>:	INFO %d\n"
			"					ENTRY_EXIT %d\n"
			"					STATISTICS %d\n"
			"					API %d\n"
			"					ERROR %d\n"
			"					FATAL %d\n",
			INFO,
			ENTRY_EXIT,
			STATISTICS,
			API,
			ERROR,
			FATAL
		);

	exit(0);
}

LPVOID
WINAPI fnEndMonkey(
			LPVOID lpvData)
{

	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

    dprintf( ENTRY_EXIT, "ENTER: fnEndMonkey : %X\n", lpvData );

	dprintf( INFO, "\n\n\n Statistics ...................................\n");
    dprintf( ENTRY_EXIT, "EXIT: fnEndMonkey : %X\n", lpvData );

	return lpvData;
}
LPCONTEXT_DATA
new_context()
{
	LPCONTEXT_DATA lpContext;

	lpContext = (LPCONTEXT_DATA) MALLOC( CONTEXT_DATA );

	if( !lpContext ) {
		dprintf( ERROR, "Error allocating context \n");
		exit(0);
	}

	ZeroMemory( lpContext, sizeof(CONTEXT_DATA) );

	lpContext -> dwSignature = CONTEXT_SIGNATURE;

	return lpContext;
}

LPHANDLE_RECORD
new_handle_record(DWORD dwSignature)
{
	LPHANDLE_RECORD lpContext;

	dprintf( ENTRY_EXIT, "Enter: new_handle_record \n");
	lpContext = (LPHANDLE_RECORD) MALLOC( HANDLE_RECORD );

	if( !lpContext ) {
		dprintf( ERROR, "Error allocating handle record \n");
		exit(0);
	}

	ZeroMemory( lpContext, sizeof(HANDLE_RECORD) );

	for(int i=0; i < MAX_HANDLES; i++ ) {
		lpContext->hCredArray[i].Mode = MODE_FREE;
		lpContext->hCredArray[i].dwTickCount = 0;
		lpContext->hCredArray[i].hCred.dwUpper = 0;
		lpContext->hCredArray[i].hCred.dwLower = 0;
		lpContext->hCredArray[i].szAppCtx = NULL;
		lpContext->hCredArray[i].szUserCtx = NULL;
	}		
	lpContext -> dwSignature = dwSignature;

	InitializeCriticalSection( &lpContext->Lock);
	//lpContext -> dwSignature = CONTEXT_SIGNATURE;

	dprintf( ENTRY_EXIT, "Exit: new_handle_record \n");

	return lpContext;
}

LPCALLBACK_CONTEXT
new_callback_context()
{
	LPCALLBACK_CONTEXT lpContext;

	dprintf( ENTRY_EXIT, "Enter: new_callback_context \n");
	lpContext = (LPCALLBACK_CONTEXT) MALLOC( CALLBACK_CONTEXT );

	if( !lpContext ) {
		dprintf( ERROR, "Error allocating callback context \n");
		exit(0);
	}

	ZeroMemory( lpContext, sizeof(CALLBACK_CONTEXT) );
	lpContext -> dwSignature = CALLBACK_CONTEXT_SIGNATURE;

	dprintf( ENTRY_EXIT, "Exit: new_callback_context \n");

	return lpContext;
}

int
__cdecl main( int ac, char * av[] )
{
	DWORD dwError;


	LPCONTEXT_DATA lpContext;
	//ZeroMemory( (LPVOID)&_Context, sizeof(CONTEXT_DATA) );
	HMODULE hModule = NULL;
	BOOL fExpectingIterations = FALSE;
	BOOL fUseDigestDllOnly = FALSE;
	BOOL fExpectingSeedValue = FALSE;
	BOOL fTest = FALSE;

	dwDebugLogCategory = ERROR;
	dwConsoleLogCategory = INFO;

	uSeed = (unsigned )time(NULL)	;

	for( ac--, av++; ac; ac--, av++) {

		  if(IS_ARG(**av)) {
				switch(*++*av) {

				case 'n' : 
					if( *++*av) {
						iNumIterations = atoi(*av);
					} else
						fExpectingIterations = TRUE;
					break;

				case 's' :
						fUseDigestDllOnly = TRUE;
						break;

				case 'd' :
						fLogToDebugTerminal = TRUE;
						if( *++*av) {
							dwDebugLogCategory = (DWORD)atoi(*av);
						} else
							dwDebugLogCategory = ERROR;
						break;

				case 'c' :
						if( *++*av) {
							dwConsoleLogCategory = (DWORD)atoi(*av);
						} else
							dwConsoleLogCategory = INFO;
						break;

				case 'b' :
						fDebugBreak = TRUE;
						if( *++*av) {
							dwDebugBreakCategory = (DWORD)atoi(*av);
						} else
							dwDebugBreakCategory = ERROR;
						break;

				case 'r' :
					if( *++*av) {
						uSeed = atol(*av);
					} else
						fExpectingSeedValue = TRUE;
					break;

				case 't' :
					fTest = TRUE;
					break;

				case 'i' :
					dwUIDialogMode = MODE_IE_ONLY;

					break;

				case '?':
				case 'h':
				default:
						usage();
						exit(0);
						break;

				} // switch
		} else {
			if( fExpectingIterations ) {
				 if( *av ) {
					iNumIterations = atoi(*av);
					fExpectingIterations = FALSE;
				 }  
			} else
			if( fExpectingSeedValue ) {
				 if( *av ) {
					uSeed = atol(*av);
					fExpectingSeedValue = FALSE;
				 }  
			} else
				usage();

		} // if IS_ARG
   } // for



	if( fExpectingIterations )
		iNumIterations = -1; // infinite

	dprintf( INFO, "Monkey Circus Starts ... \n");

	    // Get (global) dispatch table.
    InitializeSecurityInterface(fUseDigestDllOnly );
 
    // Check to see if we have digest.
    if (!HaveDigest())
    {
        goto cleanup;
    }

	if( fTest ) {
		Test();
		goto cleanup;
	}

	//
	// initialize global session lists
	//
#ifdef AI
	g_pSessionAttributeList = new CSessionAttributeList();
	g_pSessionList = new CSessionList();
#endif

	lpContext = new_context();
	
	lpContext -> hCredentialHandles = new_handle_record( CTXHANDLE_ARRAY_SIGNATURE );

	srand( uSeed );

	dwError = TuringMachine(
					TRANSITION_TABLE,
					STATE_INIT,
					(LPVOID) lpContext
				 );

cleanup:

	dprintf( INFO, "Monkey circus ending ...\n");

	if( hModule )
		FreeLibrary( hModule );

	return 0;
}

DWORD
TuringMachine(
	STATE_TABLE     StateTable[],                           
	STATE           InitialState,
	LPVOID          lpvData)
{                                                                               

	LPCONTEXT_DATA lpContext = ( LPCONTEXT_DATA ) lpvData;
	BOOL fDone = FALSE;
	STATE CurrentState;
	STATE NextState;
	ACTION Action;
	LPVOID  lpNewContext;



	CurrentState = InitialState;

#define MAP_STATE(s) MapState(s)

	
	while(
			( !fDone ) 
		&&      ( lpContext -> iCount != iNumIterations)
	) {

		//fnStatistics( lpvData );

		NextState = NEXT_STATE( StateTable, CurrentState );

#ifdef DEBUG
		dprintf( INFO, "Current State : %s, Next : %s\n", MAP_STATE( CurrentState ), MAP_STATE( NextState ) );
#endif

		// increment the count of iterations thru the monkey

		++ lpContext -> iCount;
		

		
		switch(  CurrentState ) {

			case STATE_INIT : 
			case STATE_STATISTICS:
			case STATE_STALL:

			case STATE_APP_LOGON:
			case STATE_APP_LOGON_EXCLUSIVE:
			case STATE_APP_LOGON_SHARED:

			case STATE_APP_LOGOFF:

			case STATE_POPULATE_CREDENTIALS:

			case STATE_AUTH_CHALLENGE:

			case STATE_AUTH_CHALLENGE_ANY:

			case STATE_AUTH_CHALLENGE_USER:

			case STATE_AUTH_CHALLENGE_USER_PASS:

			case STATE_PREAUTH_CHALLENGE_ANY:

			case STATE_PREAUTH_CHALLENGE_USER:

			case STATE_PREAUTH_CHALLENGE_USER_PASS:
			
			case STATE_UI_PROMPT:
			case STATE_UI_PROMPT_ANY:
			case STATE_UI_PROMPT_USER:

			case STATE_FLUSH_CREDENTIALS:
			case STATE_FLUSH_CREDENTIALS_GLOBAL:
			case STATE_FLUSH_CREDENTIALS_SESSION:
				Action = GET_STATE_ACTION( StateTable, CurrentState );
				lpNewContext = (LPVOID) Action((LPVOID)lpContext);
				break;

			case STATE_INVALID :
			case STATE_DONE :
				fDone = TRUE;
				goto finish;
				break;

			default:
				dprintf( INFO, "BUGBUG: Reached default state \n");
				break;
				//break;
				;

		}

		CurrentState = NextState;
		NextState = STATE_INVALID;
		
	}

	//scanf("%d",&i);
finish:

	return ERROR_SUCCESS;
}

STATE
NEXT_STATE( STATE_TABLE Table[], STATE CurrentState )
{
	STATE NextState = STATE_INVALID;
	
	int i;
	DWORD   dwRand, 
			dwPreviousStateProbability = 0,
			dwProbability = 0;
	BOOL fFound = FALSE;

	// first generate a random number between 0 & 100 ( 0 .. 99 )
	i = (int)(rand() % 100);
	dwRand = (DWORD) i;

#ifdef _DEBUGG
	for( i=0; Table[i].Action; i++ ) {
		dprintf( INFO, "--- \t %s %s %X %d\n",
			MAP_STATE( Table[i].CurrentState ),
			MAP_STATE( Table[i].NextState ),
			Table[i].Action,
			Table[i].dwProbability );
	}
#endif

	//
	// BUGBUG: We assume that the transition table entries are ordered in the ascending order of probabilities
	for( i = 0; Table[i].Action; i++ ) {

		if( Table[i].CurrentState != CurrentState )
			continue;

		dwProbability = Table[i].dwProbability;
		NextState = Table[i].NextState;

#ifdef _DEBUGG
		dprintf( INFO, "RAND: %d CurrentState: %s Considering Next State %s, prob %d\n",
					dwRand, MAP_STATE( CurrentState ), MAP_STATE( NextState ), Table[i].dwProbability );
#endif

		if( 
				( Table[i].CurrentState == CurrentState )
			&&      (
					( Table[i].dwProbability == 100 )
				||      ( 
						( dwRand <= Table[i].dwProbability )
					&&      ( dwRand > dwPreviousStateProbability )
					)
				)
		) {
			fFound = TRUE;
#ifdef _DEBUGG
		dprintf( INFO, ">> RAND: %d Selected Next State %s, prob %d\n",
					dwRand, MAP_STATE( NextState ), Table[i].dwProbability );
#endif
			break;
		}

		dwPreviousStateProbability = Table[i].dwProbability;
	}

	return fFound?NextState:STATE_INVALID;
}


ACTION
GET_STATE_ACTION( STATE_TABLE Table[], STATE CurrentState )
{
	STATE NextState = STATE_INVALID;
	ACTION Action = DefaultAction;
	int i;

	for( i = 0; Table[i].Action; i++ ) {
		if( Table[i].CurrentState == CurrentState )
			Action = Table[i].Action;
	}

	return Action;
}


LPSTR
MapState( STATE State )
{
#define MAP_STRING( x ) case x : return #x; break;

	switch( State )
	{
				MAP_STRING( STATE_INVALID )
				
				MAP_STRING( STATE_NONE )
				
				MAP_STRING( STATE_INIT )
				
				MAP_STRING( STATE_STATISTICS )
				
				MAP_STRING( STATE_STALL )
				
				MAP_STRING( STATE_DONE )

				MAP_STRING( STATE_APP_LOGON )

				MAP_STRING( STATE_APP_LOGON_EXCLUSIVE )

				MAP_STRING( STATE_APP_LOGON_SHARED )

				MAP_STRING( STATE_APP_LOGOFF )

				MAP_STRING( STATE_POPULATE_CREDENTIALS )

				MAP_STRING( STATE_AUTH_CHALLENGE )

				MAP_STRING( STATE_AUTH_CHALLENGE_ANY )

				MAP_STRING( STATE_AUTH_CHALLENGE_USER )

				MAP_STRING( STATE_AUTH_CHALLENGE_USER_PASS )

				MAP_STRING( STATE_PREAUTH_CHALLENGE_ANY )

				MAP_STRING( STATE_PREAUTH_CHALLENGE_USER )

				MAP_STRING( STATE_PREAUTH_CHALLENGE_USER_PASS )

				MAP_STRING( STATE_UI_PROMPT )

				MAP_STRING( STATE_UI_PROMPT_USER )

				MAP_STRING( STATE_UI_PROMPT_ANY )
				
				MAP_STRING( STATE_FLUSH_CREDENTIALS )

				MAP_STRING( STATE_FLUSH_CREDENTIALS_GLOBAL )

				MAP_STRING( STATE_FLUSH_CREDENTIALS_SESSION )

				default:
					return "???"; 
					break;
	}

}

LPVOID
WINAPI DefaultAction(
			LPVOID lpvData)
{

    dprintf( ENTRY_EXIT, "DefaultAction : %X\n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnInit(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	dprintf( ENTRY_EXIT, "Enter: fnInit %#x \n", lpvData );


	dprintf( ENTRY_EXIT, "Exit: fnInit %#x \n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnAppLogoff(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;
	DWORD dwError = ERROR_SUCCESS;
	SECURITY_STATUS ss;

	dprintf( ENTRY_EXIT, "Enter: fnAppLogoff %#x \n", lpvData );

	lpCtxRecord = FindFreeSlot( lpContext -> hCredentialHandles, &BUSY_CTX_REC );

	if( lpCtxRecord != NULL ) {

		ss = LogoffOfDigestPkg(&lpCtxRecord -> hCred);
		if(!SEC_SUCCESS(ss) ) {
			dprintf(ERROR,"FreeCredentialHandle failed %s\n",
								issperr2str(ss));
		}

		lpCtxRecord -> hCred = FREE_CRED;
		lpCtxRecord ->szAppCtx = NULL;
		lpCtxRecord ->szUserCtx = NULL;
		lpCtxRecord->Mode = MODE_FREE;
	}


	dprintf( ENTRY_EXIT, "Exit: fnAppLogoff %#x \n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnAppLogon(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;
	DWORD dwError = ERROR_SUCCESS;

	dprintf( ENTRY_EXIT, "Enter: fnAppLogon %#x \n", lpvData );

	dwError = TuringMachine(
					APP_LOGON_TRANSITION_TABLE,
					STATE_INIT,
					lpvData
				 );

	dprintf( ENTRY_EXIT, "Exit: fnAppLogon %#x \n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnAppLogonExclusive(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;
	SECURITY_STATUS ss;

	dprintf( ENTRY_EXIT, "Enter: fnAppLogonExclusive %#x \n", lpvData );

	lpCtxRecord = FindFreeSlot( lpContext -> hCredentialHandles, &FREE_CTX_REC );

	if( lpCtxRecord != NULL ) {
		lpCtxRecord -> szAppCtx = NULL;
		lpCtxRecord -> szUserCtx = IDENTITY_1;

		//
		// BUGBUG: Need to ensure new usernames every time
		//
		ss = LogonToDigestPkg(NULL, IDENTITY_1, &lpCtxRecord -> hCred);
		if(!SEC_SUCCESS(ss) ) {
			dprintf(ERROR,"AcquireCredentialHandle(%s,%s) failed (%s)\n",
					lpCtxRecord -> szAppCtx,
					lpCtxRecord -> szUserCtx,
					issperr2str(ss));
			//
			// Since we failed, Release the slot
			//
			lpCtxRecord->Mode = MODE_FREE;
		} else {
			lpCtxRecord->Mode = MODE_BUSY;
		}
	}

	dprintf( ENTRY_EXIT, "Exit: fnAppLogonExclusive %#x \n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnAppLogonShared(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;

	SECURITY_STATUS ss;

	dprintf( ENTRY_EXIT, "Enter: fnAppLogonShared %#x \n", lpvData );

	lpCtxRecord = FindFreeSlot( lpContext -> hCredentialHandles, &FREE_CTX_REC );

	if( lpCtxRecord != NULL ) {
		lpCtxRecord -> szAppCtx = NULL;
		lpCtxRecord -> szUserCtx = NULL;

		ss = LogonToDigestPkg(NULL, NULL, &lpCtxRecord -> hCred);
		if(!SEC_SUCCESS(ss) ) {
			dprintf(ERROR,"AcquireCredentialHandle(%s,%s) failed (%s)\n",
					lpCtxRecord -> szAppCtx,
					lpCtxRecord -> szUserCtx,
					issperr2str(ss));
			//
			// Since we failed, Release the slot
			//
			lpCtxRecord->Mode = MODE_FREE;
		} else {
			lpCtxRecord->Mode = MODE_BUSY;
		}
	}

	dprintf( ENTRY_EXIT, "Exit: fnAppLogonShared %#x \n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnPopulateCredentials(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;

	dprintf( ENTRY_EXIT, "Enter: fnPopulateCredentials %#x \n", lpvData );

	lpCtxRecord = FindFreeSlot( lpContext -> hCredentialHandles, &BUSY_CTX_REC );

	if( lpCtxRecord != NULL ) {
		// realm 1
		PrimeCredCache(lpCtxRecord -> hCred, "testrealm1@foo.com", "user1_1@msn.com", "pass1_1");
		PrimeCredCache(lpCtxRecord -> hCred, "testrealm1@foo.com", "user2_1@msn.com", "pass2_1");
		PrimeCredCache(lpCtxRecord -> hCred, "testrealm1@foo.com", "user3_1@msn.com", "pass3_1");

		// realm 2
		PrimeCredCache(lpCtxRecord -> hCred, "testrealm2@foo.com", "user1_2@msn.com", "pass1_2");

		// realm 3
		PrimeCredCache(lpCtxRecord -> hCred, "testrealm3@foo.com", "user1_3@msn.com", "pass1_3");
	}

	dprintf( ENTRY_EXIT, "Exit: fnPopulateCredentials %#x \n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnAuthChallenge(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;
	DWORD dwError = ERROR_SUCCESS;

	dprintf( ENTRY_EXIT, "Enter: fnAuthChallenge %#x \n", lpvData );

	dwError = TuringMachine(
					AUTH_CHALLENGE_TRANSITION_TABLE,
					STATE_INIT,
					lpvData
				 );

	dprintf( ENTRY_EXIT, "Exit: fnAuthChallenge %#x \n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnAuthChallengeAny(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;

	dprintf( ENTRY_EXIT, "Enter: fnAuthChallengeAny %#x \n", lpvData );

	lpCtxRecord = FindFreeSlot( lpContext -> hCredentialHandles, &BUSY_CTX_REC );
	SECURITY_STATUS ss;

	if( lpCtxRecord != NULL ) {
		//LPSTR szChallenge;
		//szChallenge = "realm=\"testrealm@foo.com\", stale = FALSE, qop=\"auth,auth-int\", nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"";
		TCHAR szChallenge[512];
		DWORD cbChallenge=512;
		GenerateServerChallenge(szChallenge,cbChallenge);

		// Package will dump response into this buffer.
		CHAR szResponse[4096];
		CtxtHandle hCtxt = {0,0};
		
		memset((LPVOID)szResponse,0,4096);
		// First try at authenticating.
		ss = DoAuthenticate( &lpCtxRecord -> hCred,                    // Cred from logging on.
						NULL,                       // Ctxt not specified first time.
						&hCtxt,                    // Output context.
						ISC_REQ_USE_SUPPLIED_CREDS, // auth from cache.
						szChallenge,                // Server challenge header.
						NULL,                       // no realm since not preauth.
						"www.foo.com",              // Host.
						"/bar/baz/boz/bif.html",    // Url.
						"GET",                      // Method.
						NULL,                       // no Username
						NULL,                       // no Password.
						NULL,                       // no nonce
						NULL,                       // don't need hdlg for auth.
						szResponse,                // Response buffer.
                        4096);
	}

	if(!SEC_SUCCESS(ss) ) {
		dprintf(ERROR,"ISC(use-supplied-cred) Failed %s \n", issperr2str(ss) );
	}

	dprintf( ENTRY_EXIT, "Exit: fnAuthChallengeAny %#x \n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnAuthChallengeUser(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;

	dprintf( ENTRY_EXIT, "Enter: fnAuthChallengeUser %#x \n", lpvData );

	lpCtxRecord = FindFreeSlot( lpContext -> hCredentialHandles, &BUSY_CTX_REC );
	
	SECURITY_STATUS ss;

	if( lpCtxRecord != NULL ) {
		//LPSTR szChallenge;
		//szChallenge = "realm=\"testrealm@foo.com\", stale = FALSE, qop=\"auth,auth-int\", nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"";
		TCHAR szChallenge[512];
		DWORD cbChallenge=512;
		GenerateServerChallenge(szChallenge,cbChallenge);

		// Package will dump response into this buffer.
		CHAR szResponse[4096];
                
		CtxtHandle hCtxt = {0,0};
		
		memset((LPVOID)szResponse,0,4096);
		// First try at authenticating.
		ss = DoAuthenticate( &lpCtxRecord -> hCred,  // Cred from logging on.
						NULL,                       // Ctxt not specified first time.
						&hCtxt,                    // Output context.
						ISC_REQ_USE_SUPPLIED_CREDS,  // auth from cache.
						szChallenge,                // Server challenge header.
						NULL,                       // no realm since not preauth.
						"www.foo.com",              // Host.
						"/bar/baz/boz/bif.html",    // Url.
						"GET",                      // Method.
						"user1_1@msn.com",                       // no Username
						NULL,                       // no Password.
						NULL,                       // no nonce
						NULL,                       // don't need hdlg for auth.
						szResponse,                // Response buffer.
                        4096);
	}

	if(!SEC_SUCCESS(ss) ) {
		dprintf(ERROR,"ISC(use-supplied-cred) Failed %s \n", issperr2str(ss) );
	}

	dprintf( ENTRY_EXIT, "Exit: fnAuthChallengeUser %#x \n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnAuthChallengeUserPassword(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;

	dprintf( ENTRY_EXIT, "Enter: fnAuthChallengeUserPassword %#x \n", lpvData );

	lpCtxRecord = FindFreeSlot( lpContext -> hCredentialHandles, &BUSY_CTX_REC );

	SECURITY_STATUS ss;

	if( lpCtxRecord != NULL ) {
		//LPSTR szChallenge;
		//szChallenge = "realm=\"testrealm@foo.com\", stale = FALSE, qop=\"auth,auth-int\", nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"";
		TCHAR szChallenge[512];
		DWORD cbChallenge=512;
		GenerateServerChallenge(szChallenge,cbChallenge);

		// Package will dump response into this buffer.
		CHAR szResponse[4096];
                
		CtxtHandle hCtxt = {0,0};
		
		memset((LPVOID)szResponse,0,4096);
		// First try at authenticating.
		ss =
		DoAuthenticate( &lpCtxRecord -> hCred,                    // Cred from logging on.
						NULL,                       // Ctxt not specified first time.
						&hCtxt,                    // Output context.
						ISC_REQ_USE_SUPPLIED_CREDS, // auth from cache.
						szChallenge,                // Server challenge header.
						NULL,                       // no realm since not preauth.
						"www.foo.com",              // Host.
						"/bar/baz/boz/bif.html",    // Url.
						"GET",                      // Method.
						"user1_1@msn.com",                       // no Username
						"pass1_1",                       // no Password.
						NULL,                       // no nonce
						NULL,                       // don't need hdlg for auth.
						szResponse,                // Response buffer.
                        4096);
	}

	if(!SEC_SUCCESS(ss) ) {
		dprintf(ERROR,"ISC(use-supplied-cred) Failed %s \n", issperr2str(ss) );
        DebugBreak();
	}

	dprintf( ENTRY_EXIT, "Exit: fnAuthChallengeUserPassword %#x \n", lpvData );

	return lpvData;
}

BOOL
SetUIUserNameAndPassword(
						 LPSTR szUsername,
						 LPSTR szPassword,
						 BOOL fPersist)
{

#define DIALOGCLASS	32770
#define IDB_OK_BUTTON 1
#define ODS(s) dprintf(FATAL,s);

	LPSTR m_szMainCaption = "Enter Network Password";
	HWND hdlg;
	DWORD dwTime;
	DWORD dwCount=0;
	dwTime = GetTickCount();
	//Use this to get the hdlg for the dialog window

	hdlg =::FindWindow(MAKEINTATOM(32770),(LPCTSTR)m_szMainCaption);
	while ((NULL==hdlg) && (GetTickCount() - dwTime <= 10000)) {
		//dprintf(FATAL,"Cannot find dialog window: %d\n",GetLastError());
		// return FALSE;
		hdlg =::FindWindow(MAKEINTATOM(32770),(LPCTSTR)m_szMainCaption);
	}

	if( hdlg == NULL ) {
		dprintf(FATAL,"Cannot find dialog window: %d\n",GetLastError());
		//DebugBreak();
		 return FALSE;
	}


	dprintf(INFO,"Found window.....\n");
	//Use this after you've got the handle to the main dialog window.
	//This will look for the edit control and enter text.


	if( fPersist ) {
		dprintf(INFO,"************ PASSWORD WILL BE PERSISTED ****************\n");
	}

	HWND	hwnd = NULL;
	int	iEditId = 0;

	UI_CONTROL uiControl;

	uiControl.szUserName = szUsername;
	uiControl.szPassword = szPassword;
	uiControl.fPersist = fPersist;
	uiControl.dwCount = 0;
	uiControl.hOK = NULL;
	uiControl.hPassword = NULL;
	uiControl.hPasswordSave = NULL;
	uiControl.hUserName = NULL;

	Sleep(3000);
#if 1
	uiControl.hOK = GetDlgItem(hdlg,IDB_OK_BUTTON);
	uiControl.hPassword = GetDlgItem(hdlg,IDC_PASSWORD_FIELD);
	uiControl.hPasswordSave = GetDlgItem(hdlg,IDC_SAVE_PASSWORD);
	uiControl.hUserName = GetDlgItem(hdlg,IDC_COMBO1);
#else
		EnumChildWindows(hdlg, EnumerateWindowCallback, (LPARAM)&uiControl);
#endif
	dprintf(INFO,"EnumWindows Returned :\n");
	dprintf(INFO,"hUsername %#x, hPassword %#x, hPasswordSave %#x, hOK %#x\n",
		uiControl.hUserName,
		uiControl.hPassword,
		uiControl.hPasswordSave,
		uiControl.hOK);

	//getch();

	

	if (uiControl.hPasswordSave != NULL) {
		hdlg = uiControl.hPasswordSave;
		printf("\n");
		dprintf(INFO,"=============== Found SAVE_PASSWORD check box field\n");

		if(!(uiControl.fPersist)) {
			dprintf(INFO,"DONT WANNA PERSIST @@@@@ !\n");
		} else {
			//Sleep(2000);//not required remove later
			if(!::PostMessage(hdlg, BM_CLICK, (WPARAM)0, (LPARAM)0)) {
				ODS("FAILED: to send message to SAVE_PASSWORD check Box");
				//DebugBreak();
			} else {
				ODS("sent message successfullly to SAVE_PASSWORD Edit Control\n");
			}
		//	Sleep(2000);
		}
		++ uiControl.dwCount;
	} 

	//getch();

	if (uiControl.hUserName != NULL) {
		hdlg = uiControl.hUserName;
		dprintf(INFO,"Sending Message To USERNAME field (%#x)\n",hdlg);

#if 0
		SendMessage(
				hdlg,
				CB_SHOWDROPDOWN,
				(WPARAM) TRUE, 
				(LPARAM) 0);
#endif
		//Sleep(2000);//not required remove later
		if(!::SendMessage(hdlg, WM_SETTEXT, (WPARAM) 0, (LPARAM)(LPCTSTR) szUsername)) {
			ODS("FAILED: to send message to Edit Box\n");
			//DebugBreak();
		} else {
			ODS("sent message successfullly to USERNAME Edit Control\n");
		}
		++ uiControl.dwCount;
	}

	//getch();

	if (uiControl.hPassword != NULL) {
		hdlg = uiControl.hPassword;
		printf("\n");
		dprintf(INFO,"Sending Message To PASSWORD field (%#X)\n",hdlg);
		//Sleep(2000);//not required remove later

		if(!::SendMessage(hdlg, WM_SETTEXT, 0, (LPARAM)(LPCTSTR) szPassword)) {
			ODS("FAILED: to send message to Edit Box");
			//DebugBreak();
		} else {
			ODS("sent message successfullly to PASSWORD Edit Control\n");
		}
		++ uiControl.dwCount;
	}

	dprintf(INFO,"Clicking on OK button (%#X) in dialog \n",uiControl.hOK );
	Sleep(2000);

	SendMessage(uiControl.hOK, BM_CLICK, 0, 0);
	//PostMessage(hdlg, 
	//			WM_COMMAND, 
	//			MAKEWPARAM(IDB_OK_BUTTON,BN_CLICKED), 
	//			MAKELPARAM(,0));


	return TRUE;
}

LPVOID
WINAPI fnUiPrompt(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;
	DWORD dwError = ERROR_SUCCESS;

	dprintf( ENTRY_EXIT, "Enter: fnUiPrompt %#x \n", lpvData );

	dwError = TuringMachine(
					UI_PROMPT_TRANSITION_TABLE,
					STATE_INIT,
					lpvData
				 );

	dprintf( ENTRY_EXIT, "Exit: fnUiPrompt %#x \n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnUiPromptUser(
			LPVOID lpvData)
{
		//LPSTR szChallenge;
		//szChallenge = "realm=\"testrealm@foo.com\", stale = FALSE, qop=\"auth,auth-int\", nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"";
		TCHAR szChallenge[512];
		DWORD cbChallenge=512;
		GenerateServerChallenge(szChallenge,cbChallenge);

    // Package will dump response into this buffer.
    CHAR szResponse[4096];
                
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;

	dprintf( ENTRY_EXIT, "Enter: fnUiPromptUser %#x \n", lpvData );

	lpCtxRecord = FindFreeSlot( lpContext -> hCredentialHandles, &BUSY_CTX_REC );

	CtxtHandle hCtxt = {0,0};

	SECURITY_STATUS ssResult;

	memset((LPVOID)szResponse,0,4096);
    // First try at authenticating.
    ssResult = 
    DoAuthenticate( &lpCtxRecord -> hCred,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt,                    // Output context.
                    0,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz/boz/bif.html",    // Url.
                    "GET",                      // Method.
                    "user1_1@msn.com",                       //  Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hdlg for auth.
					szResponse,                // Response buffer.
                    4096);
        
    // Expect to not have credentials the first time - prompt.
    if (ssResult == SEC_E_NO_CREDENTIALS)
    {
		memset((LPVOID)szResponse,0,4096);
        ssResult = 
        DoAuthenticate( &lpCtxRecord -> hCred,                    // Cred from logging on.
                        &hCtxt,                    // Ctxt from previous call
                        &hCtxt,                    // Output context (same as from previous).
                        ISC_REQ_PROMPT_FOR_CREDS,   // prompt
                        szChallenge,                // Server challenge
                        NULL,                       // No realm
                        "www.foo.com",              // Host
                        "/bar/baz/boz/bif.html",    // Url
                        "GET",                      // Method
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        GetDesktopWindow(),         // desktop window
						szResponse,                // Response buffer.
                        4096);

    }

    // We now have credentials and this will generate the output string.
	//
	// BUGBUG: 
	//		THis has just been fixed by AdriaanC, so we put in a hack here
	//		We will only prompt if the string has not been generated yet.	
	// 
    if (
			(ssResult == SEC_E_OK)
		&&	(!*szResponse)
    ) {
		memset((LPVOID)szResponse,0,4096);
        ssResult = 
        DoAuthenticate( &lpCtxRecord -> hCred,                    // Cred from logging on.
                        &hCtxt,                    // Ctxt not specified first time.
                        &hCtxt,                    // Output context.
                        0,                          // auth
                        szChallenge,                // Server challenge.
                        NULL,                       // no realm
                        "www.foo.com",              // Host.
                        "/bar/baz/boz/bif.html",    // Url.
                        "GET",                      // Method.
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        NULL,                       // no hdlg
						szResponse,                // Response buffer.
                        4096);
    }          

	return lpvData;
}



LPVOID
WINAPI fnUiPromptAny(
			LPVOID lpvData)
{
		//LPSTR szChallenge;
		//szChallenge = "realm=\"testrealm@foo.com\", stale = FALSE, qop=\"auth,auth-int\", nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"";
		TCHAR szChallenge[512];
		DWORD cbChallenge=512;
		GenerateServerChallenge(szChallenge,cbChallenge);

    // Package will dump response into this buffer.
    CHAR szResponse[4096];
                
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;

	dprintf( ENTRY_EXIT, "Enter: fnUiPromptAny %#x \n", lpvData );

	lpCtxRecord = FindFreeSlot( lpContext -> hCredentialHandles, &BUSY_CTX_REC );

	CtxtHandle hCtxt = {0,0};

	SECURITY_STATUS ssResult;

	memset((LPVOID)szResponse,0,4096);
    // First try at authenticating.
    ssResult = 
    DoAuthenticate( &lpCtxRecord -> hCred,       // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    &hCtxt,                    // Output context.
                    0,                          // auth from cache.
                    szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    "www.foo.com",              // Host.
                    "/bar/baz/boz/bif.html",    // Url.
                    "GET",                      // Method.
                    NULL,                       // no Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hdlg for auth.
					szResponse,                // Response buffer.
                    4096);
        
    // Expect to not have credentials the first time - prompt.
    if (ssResult == SEC_E_NO_CREDENTIALS)
    {
		memset((LPVOID)szResponse,0,4096);
        ssResult = 
        DoAuthenticate( &lpCtxRecord -> hCred,                    // Cred from logging on.
                        &hCtxt,                    // Ctxt from previous call
                        &hCtxt,                    // Output context (same as from previous).
                        ISC_REQ_PROMPT_FOR_CREDS,   // prompt
                        szChallenge,                // Server challenge
                        NULL,                       // No realm
                        "www.foo.com",              // Host
                        "/bar/baz/boz/bif.html",    // Url
                        "GET",                      // Method
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        GetDesktopWindow(),         // desktop window
						szResponse,                // Response buffer.
                        4096);

    }


    // We now have credentials and this will generate the output string.

	//
	// BUGBUG: 
	//		THis has just been fixed by AdriaanC, so we put in a hack here
	//		We will only prompt if the string has not been generated yet.	
	// 
    if (
			(ssResult == SEC_E_OK)
		&&	(!*szResponse)
    ) {
		memset((LPVOID)szResponse,0,4096);
        ssResult = 
        DoAuthenticate( &lpCtxRecord -> hCred,                    // Cred from logging on.
                        &hCtxt,                    // Ctxt not specified first time.
                        &hCtxt,                    // Output context.
                        0,                          // auth
                        szChallenge,                // Server challenge.
                        NULL,                       // no realm
                        "www.foo.com",              // Host.
                        "/bar/baz/boz/bif.html",    // Url.
                        "GET",                      // Method.
                        NULL,                       // no username
                        NULL,                       // no password
                        NULL,                       // no nonce
                        NULL,                       // no hdlg
						szResponse,                // Response buffer.
                        4096);
    }          

	return lpvData;
}

LPVOID
WINAPI fnFlushCredentials(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;
	DWORD dwError = ERROR_SUCCESS;

	dprintf( ENTRY_EXIT, "Enter: fnFlushCredentials %#x \n", lpvData );

	dwError = TuringMachine(
					FLUSH_CREDENTIALS_TRANSITION_TABLE,
					STATE_INIT,
					lpvData
				 );

	dprintf( ENTRY_EXIT, "Exit: fnFlushCredentials %#x \n", lpvData );

	return lpvData;
}

LPVOID
WINAPI fnFlushCredentialsGlobal(
			LPVOID lpvData)
{
	dprintf( ENTRY_EXIT, "Enter: fnFlushCredentialsGlobal %#x \n", lpvData );

	SECURITY_STATUS ssResult;

    ssResult = 
    DoAuthenticate( NULL,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    NULL,                    // Output context.
                    ISC_REQ_NULL_SESSION,                          // auth from cache.
                    NULL,//szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    NULL,//"www.foo.com",              // Host.
                    NULL,//"/bar/baz/boz/bif.html",    // Url.
                    NULL,//"GET",                      // Method.
                    NULL,//"user1",                       // no Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hdlg for auth.
						NULL,                // Response buffer.
                        0);
        
	dprintf( ENTRY_EXIT, "Exit: fnFlushCredentialsGlobal %#x \n", lpvData );

	return lpvData;
}



LPVOID
WINAPI fnFlushCredentialsSession(
			LPVOID lpvData)
{
	LPCONTEXT_DATA lpContext = (LPCONTEXT_DATA) lpvData;

	LPCONTEXT_RECORD lpCtxRecord = NULL;

	dprintf( ENTRY_EXIT, "Enter: fnFlushCredentialsSession %#x \n", lpvData );

	lpCtxRecord = FindFreeSlot( lpContext -> hCredentialHandles, &BUSY_CTX_REC );



	SECURITY_STATUS ssResult;

    ssResult = 
    DoAuthenticate( &lpCtxRecord->hCred,                    // Cred from logging on.
                    NULL,                       // Ctxt not specified first time.
                    NULL,//&hCtxt,                    // Output context.
                    ISC_REQ_NULL_SESSION,                          // auth from cache.
                    NULL,//szChallenge,                // Server challenge header.
                    NULL,                       // no realm since not preauth.
                    NULL,//"www.foo.com",              // Host.
                    NULL,//"/bar/baz/boz/bif.html",    // Url.
                    NULL,//"GET",                      // Method.
                    NULL,//"user1",                       // no Username
                    NULL,                       // no Password.
                    NULL,                       // no nonce
                    NULL,                       // don't need hdlg for auth.
                    NULL,
                    0);//szResponse);                // Response buffer.
        
	return lpvData;
}


BOOL
GenerateServerChallenge(
						LPSTR szChallenge,
						DWORD cbChallenge)
{
	int i;
	TCHAR *	szAlgorithm = NULL,
			* szQop = NULL,
			* szNonce = NULL,
			* szOpaque = NULL,
			* szRealm = NULL,
			* szPtr = NULL,
			* szMs_message = NULL,
			* szMs_reserved = NULL,
			* szMs_trustmark = NULL;

	//
	// BUGBUG: we want to make sure that this generates a string which will fit
	// in the given buffer.
	//

	dprintf(ENTRY_EXIT,"ENTER: GenerateServerChallenge\n" );

	i = rand() % 100;

	if( i < 50 ) {
		szAlgorithm = _T("MD5");
	} else {
		szAlgorithm = _T("MD5-Sess");
	}

	i = rand() % 100;

	if((i >= 0) && ( i < 20 )) {
		szRealm = _T("testrealm1@foo.com");
	} else
	if(( i >= 20 ) && ( i < 40)) {
		szRealm = _T("testrealm2@foo.com");
	} else
	if(( i >= 40 ) && ( i < 60)) {
		szRealm = _T("testrealm3@foo.com");
	} else {
		szRealm = _T("testrealm@foo.com");
	}
#if 0
	i = rand() % 100;

	if( i < 50 ) {
		szMs_message = _T("\"This is a test microsoft message\"");
	} else {
		szMs_message = NULL;
	}

	i = rand() % 100;

	if( i < 30 ) {
		szMs_trustmark = _T("\"http://www.bbbonline.org\"");
	} else
	if(( i >= 30 ) && (i < 80)) {
		szMs_trustmark = _T("\"http://www.truste.org\"");
	} else {
		szMs_trustmark = NULL;
	}

	i = rand() % 100;

	if( i < 30 ) {
		szMs_reserved = _T("\"MSEXT::CAPTION=%Enter Network Password%REGISTER=%http://www.microsoft.com%\"");
	} 
	 //else
	 //if(( i >= 30 ) && (i < 80)) {
		 //szMs_trustmark = _T("\"http://www.truste.org\"");
	 //} else {
		 //szMs_trustmark = NULL;
	 //}

#endif

	szQop = _T("auth");
	szOpaque = _T("101010101010");
	szNonce = _T("abcdef0123456789");

	szPtr = szChallenge;

	szPtr += sprintf(szChallenge,"realm=\"%s\", qop=\"%s\", algorithm=\"%s\", nonce=\"%s\", opaque=\"%s\"",
								szRealm,
								szQop,
								szAlgorithm,
								szNonce,
								szOpaque);

#if 0
	if( szMs_message && *szMs_message ) {
		szPtr += sprintf(szPtr,", ms-message=%s, ms-message-lang=\"EN\"",
									szMs_message);
	}
		
	if( szMs_trustmark && *szMs_trustmark ) {
		szPtr += sprintf(szPtr,", ms-trustmark=%s",
									szMs_trustmark);
	}

	if( szMs_reserved && *szMs_reserved ) {
		szPtr += sprintf(szPtr,", ms-reserved=%s",
									szMs_reserved);
	}

	i = rand() % 100;

	if( i < 50 ) {
		szPtr += sprintf( szPtr,", MS-Logoff=\"TRUE\"");
	}

#endif
	dprintf(ENTRY_EXIT,"EXIT: GenerateServerChallenge returns \n%s\n", szChallenge );
		
	return TRUE;
}

#define IDENTITY_1 "app1"
#define IDENTITY_2	"app2"

BOOL Test()
{
 	CSessionAttributeList * g_pSessionAttributeList = NULL;
	CSessionList * g_pSessionList = NULL;
	CSession * pSession = NULL;
	CSessionAttribute * pSessionAttribute = NULL;

    CredHandle  hCred1, hCred2, hCred3; 

	SECURITY_STATUS ssResult;

	g_pSessionAttributeList = new CSessionAttributeList();
	g_pSessionList = new CSessionList();

	pSessionAttribute = g_pSessionAttributeList -> getNewSession( FALSE );

	if( !pSessionAttribute ) {
		goto cleanup;
	}


	LogonToDigestPkg( 
					pSessionAttribute ->getAppCtx() , 
					pSessionAttribute->getUserCtx(), 
					&hCred1);

	pSession = new CSession( hCred1 );
	pSession -> setAttribute( pSessionAttribute );


	g_pSessionList->put( pSession );

	pSession = NULL;
	pSessionAttribute = NULL;

	//
	// now get shared SessionAttribute
	//
	pSessionAttribute = g_pSessionAttributeList -> getNewSession( TRUE );

	LogonToDigestPkg( 
					pSessionAttribute ->getAppCtx() , 
					pSessionAttribute->getUserCtx(), 
					&hCred2);

	pSession = new CSession( hCred2 );
	pSession -> setAttribute( pSessionAttribute );
	g_pSessionList -> put( pSession);

	LogonToDigestPkg( 
					pSessionAttribute ->getAppCtx() , 
					pSessionAttribute->getUserCtx(), 
					&hCred3);

	pSession = new CSession( hCred3 );
	pSession -> setAttribute( pSessionAttribute );
	g_pSessionList -> put( pSession);

	//
	// lets add a credential to this session
	//
	pSession -> addCredential( "testrealm@foo.com", "user1", "pass1" );
	pSession -> addCredential( "testrealm@foo.com", "user1", "pass11" );
	// add one more
	pSession -> addCredential( "testrealm@foo.com", "user2", "pass2" );

	// add one more
	pSession -> addCredential( "testrealm@foo.com", "user3", "pass3" );

	// replace
	pSession -> addCredential( "testrealm@foo.com", "user3", "pass31" );
	// replace
	pSession -> addCredential( "testrealm@foo.com", "user2", "pass21" );
	pSession -> addCredential( "testrealm@foo.com", "user2", "pass22" );

cleanup:
	return FALSE;
}

BOOL CALLBACK EnumerateWindowCallback1(HWND hdlg, LPARAM lParam)
{
	int iEditId = 0;
	BOOL fRet = TRUE;

	LPUI_CONTROL lpuiControl = (LPUI_CONTROL) lParam;

	LPTSTR szUsername = lpuiControl->szUserName;
	LPTSTR szPassword = lpuiControl->szPassword;

	dprintf(ENTRY_EXIT,"ENTER: EnumChildProc(hdlg=%#x,lParam=%#x)\n",hdlg,lParam);

	dprintf(ENTRY_EXIT,"UI_CONTROL( %s %s %d %s %#x ) \n",
						szUsername,
						szPassword,
						lpuiControl->dwCount,
						(lpuiControl->fPersist?"TRUE":"FALSE"),
						lpuiControl->hOK);


	iEditId =::GetDlgCtrlID(hdlg);
	dprintf(INFO,"The iEditId is %d!\n", iEditId);

	if (iEditId == IDC_SAVE_PASSWORD) {
		printf("\n");
		dprintf(INFO,"=============== Found SAVE_PASSWORD check box field\n");

		if(lpuiControl->dwCount == 3) {
			dprintf(INFO,"Already sent message to this control\n");
			goto done;;
		}

		if(!(lpuiControl -> fPersist)) {
			dprintf(INFO,"DONT WANNA PERSIST @@@@@ !\n");
		} else {
			//Sleep(2000);//not required remove later
			if(!::PostMessage(hdlg, BM_CLICK, (WPARAM)0, (LPARAM)0)) {
				ODS("FAILED: to send message to SAVE_PASSWORD check Box");
				DebugBreak();
			} else {
				ODS("sent message successfullly to SAVE_PASSWORD Edit Control\n");
			}
		//	Sleep(2000);
		}
		++ lpuiControl->dwCount;
	} else
	if (iEditId == IDC_COMBO1)	{
		printf("\n");
		dprintf(INFO,"Found USERNAME field\n");

		if(lpuiControl->dwCount == 3) {
			dprintf(INFO,"Already sent message to this control\n");
			goto done;;
		}
#if 0
		SendMessage(
				hdlg,
				CB_SHOWDROPDOWN,
				(WPARAM) TRUE, 
				(LPARAM) 0);
#endif
		//Sleep(2000);//not required remove later
		if(!::SendMessage(hdlg, WM_SETTEXT, (WPARAM) 0, (LPARAM)(LPCTSTR) szUsername)) {
			ODS("FAILED: to send message to Edit Box\n");
			DebugBreak();
		} else {
			ODS("sent message successfullly to USERNAME Edit Control\n");
		}
		++ lpuiControl->dwCount;
	} else
	if (iEditId == IDC_PASSWORD_FIELD) {
		printf("\n");
		dprintf(INFO,"Found PASSWORD field\n");
		//Sleep(2000);//not required remove later

		if(lpuiControl->dwCount == 3) {
			dprintf(INFO,"Already sent message to this control\n");
			goto done;;
		}

		if(!::SendMessage(hdlg, WM_SETTEXT, 0, (LPARAM)(LPCTSTR) szPassword)) {
			ODS("FAILED: to send message to Edit Box");
			DebugBreak();
		} else {
			ODS("sent message successfullly to PASSWORD Edit Control\n");
		}
		++ lpuiControl->dwCount;
	} else 
	if( iEditId == IDB_OK_BUTTON ) {
		lpuiControl->hOK = hdlg;
	}


	if( lpuiControl -> dwCount == 3 ) {

		if( lpuiControl->hOK ) {
			dprintf(INFO,"ALL WINDOWS FOUND, OK BUTTON FOUND, ABORT\n");
			fRet = FALSE;
			goto done;;
		} 
	}

done:

	dprintf(ENTRY_EXIT,"EXIT: EnumChileProc() returning %s\n",fRet?"TRUE":"FALSE");

	return fRet;
}

BOOL CALLBACK EnumerateWindowCallback(HWND hdlg, LPARAM lParam)
{
	int iEditId = 0;
	BOOL fRet = TRUE;

	LPUI_CONTROL lpuiControl = (LPUI_CONTROL) lParam;
	

	dprintf(ENTRY_EXIT,"ENTER: EnumChildProc(hdlg=%#x,lParam=%#x)\n",hdlg,lParam);

	dprintf(ENTRY_EXIT,"UI_CONTROL( %s %s %d %s %#x ) \n",
						lpuiControl->szUserName,
						lpuiControl->szPassword,
						lpuiControl->dwCount,
						(lpuiControl->fPersist?"TRUE":"FALSE"),
						lpuiControl->hOK);


	if ( (iEditId =::GetDlgCtrlID(hdlg)) == 0)
	{
		dprintf(INFO,"GetDlgCtrlID(hdlg) failed. GetLastError returned %d!\n", GetLastError());
		return FALSE;
	}

	dprintf(INFO,"The iEditId is %d!\n", iEditId);

	if (iEditId == IDC_SAVE_PASSWORD) {
		printf("\n");
		dprintf(INFO,"=============== Found SAVE_PASSWORD check box field\n");

		if(lpuiControl->hPasswordSave != NULL) {
			dprintf(INFO,"Already found window to this control\n");
			goto done;;
		}


		lpuiControl->hPasswordSave = hdlg;
		++ lpuiControl->dwCount;
	} else
	if (iEditId == IDC_COMBO1)	{
		printf("\n");
		dprintf(INFO,"Found USERNAME field\n");

		if(lpuiControl->hUserName != NULL) {
			dprintf(INFO,"Already found window to this control\n");
			goto done;;
		}

		lpuiControl->hUserName = hdlg;
		++ lpuiControl->dwCount;
	} else
	if (iEditId == IDC_PASSWORD_FIELD) {
		printf("\n");
		dprintf(INFO,"Found PASSWORD field\n");
		//Sleep(2000);//not required remove later

		if(lpuiControl->hPassword != NULL) {
			dprintf(INFO,"Already found window to this control\n");
			goto done;;
		}

		lpuiControl->hPassword = hdlg;

		++ lpuiControl->dwCount;
	} else 
	if( iEditId == IDB_OK_BUTTON ) {
		lpuiControl->hOK = hdlg;
		++ lpuiControl->dwCount;
	}


	if( lpuiControl -> dwCount == 4 ) {

		//if( lpuiControl->hOK ) {
			dprintf(INFO,"ALL WINDOWS FOUND, OK BUTTON FOUND, ABORT\n");
			fRet = FALSE;
			goto done;
		//} 
	}

done:

	dprintf(ENTRY_EXIT,"EXIT: EnumChileProc() returning %s\n",fRet?"TRUE":"FALSE");

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\commonmk.inc ===
.SUFFIXES: .hdl .pdl

.pdl{$O}.hdl:
    $(C_PREPROCESSOR) $< | pdlparse - $(MAKEDIR)\$O\$(@B) $< $(MAKEDIR)\$O

!if 0
#
# .pdl -> .hdl
#
.pdl.hdl:
        $(CC) $(NOLOGO) @<< | $(PDLPARSE) <<
/I$(INCLUDEPATH:;=
/I)
$(CFLAGS: =
)
$(PCHCXXFLAGS: =
)
/c
/E
$<
<<$(KEEPFLAGS)
- $(TYPEDIR)\$(@B) $(@B).pdl $(TYPEDIR)
<<$(KEEPFLAGS)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\browseinfo\makefile.inc ===
# We want to do this so that our rule for createing the bsc file
# will win over the makefile.def rule.  We do much funkier things
NO_BROWSER_FILE=1

!ifdef MSHTML_BROWSER_INFO 
!  if "$(NOLINK)" == ""

# this is a wild nmake hack to always run a command
# I picked this up from makefile.def where the do a 
# build -O to make _objects.mac.
!if [-perl gensbrlists.pl .. $O]
!endif

!include $O\sbrlist.inc

..\$O\mshtml.bsc: $(SBRLIST) 
    -bscmake -nologo -o $@ @<<
$(SBRLIST: =
)
<<NOKEEP

!  else

..\$O\mshtml.bsc: 

!  endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\btools\nfparse\nfinit.cxx ===
#include "../pdlparse/headers.hxx"

extern "C"
HINSTANCE MwMainwinInitLite(int argc, char *argv[], void *lParam);

extern "C" 
HINSTANCE mainwin_init(int argc, char *argv[])
{ 
    return MwMainwinInitLite( argc, argv, NULL ); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\btools\ascparse\ascinit.cxx ===
#include "headers.hxx"

extern "C"
HINSTANCE MwMainwinInitLite(int argc, char *argv[], void *lParam);

extern "C" 
HINSTANCE mainwin_init(int argc, char *argv[])
{ 
    return MwMainwinInitLite( argc, argv, NULL ); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\common.inc ===
#
SOURCES_USED=$(ROOT)\common.inc

TREE_SYNC=1
NDHACKS=1
ACCURATEZOOM=1
#IE6_WYSIWYG_OM=1
#DLOAD1=1

NO_DEBUG_HOOK=1
ADORNERS=1
FOCUS_ADORNER=1
#FOCUS_BEHAVIOR=1
#EDIT_BEHAVIOR=1
#VIEW_SERVICES=1
#MULTI_FORMAT=1
MULTI_LAYOUT=1
#HTML_LAYOUT=1
#VSTUDIO7EDIT=1
#ND_ASSERT=1
#CICERO=1
FORMSMODE=0
#SLOWALLOC=1
#MARKCODE=1

CONDITIONAL_INCLUDES= \
    winwlm.h \
    rpcerr.h \
    rpcmac.h \
    macname1.h \
    macpub.h \
    macapi.h \
    macname2.h \
    macocidl.h \
    maccontrols.h \
    mainwin.h \
    w16toff.hxx \
    print.h \
    regmsg16.h \
    urlmki.h \
    help.h \
    pgstup16.hxx \
    page.h \
    icapexp.h \
    ccolorsync.h \
    folders.h \
    pixmap.h \
    pngfilt.ic \

COREINCLUDES=\
    $(ROOT)\src\f3\include; \
    $(ROOT)\src\core\include; \
    $(ROOT)\src\core\cdutil; \
    $(ROOT)\src\site\display; \
    $(ROOT)\src\intl\include; \
    $(ROOT)\external\inc; \
    $(ROOT)\types\$(O); \
    $(SHELL_INC_PATH);

SITEINCLUDES=\
    $(ROOT)\src\f3\include; \
    $(ROOT)\src\site\include; \
    $(ROOT)\src\site\base; \
    $(ROOT)\src\site\builtin; \
    $(ROOT)\src\site\dbind; \
    $(ROOT)\src\site\display; \
    $(ROOT)\src\site\download; \
    $(ROOT)\src\site\layout; \
    $(ROOT)\src\site\miscelem; \
    $(ROOT)\src\site\miscsite; \
    $(ROOT)\src\site\ole; \
    $(ROOT)\src\site\print; \
    $(ROOT)\src\site\style; \
    $(ROOT)\src\site\table; \
    $(ROOT)\src\site\text; \
    $(ROOT)\src\site\util; \
    $(ROOT)\src\site\view; \
    $(ROOT)\src\site\acc; \
    $(ROOT)\src\other\include; \
    $(ROOT)\src\other\htmldlg; \
    $(ROOT)\src\other\htmlapp; \
    $(ROOT)\src\dlay\dl; \
    $(ROOT)\src\core\include; \
    $(ROOT)\src\core\cdutil; \
    $(ROOT)\src\intl\include; \
    $(ROOT)\src\intl\idl\$(O); \
    $(ROOT)\external\inc; \
    $(ROOT)\external\inc\msls; \
    $(ROOT)\types\$(O); \
    $(ROOT)\imgfilt; \
    $(SHELL_INC_PATH);

!if !defined(WARNING_LEVEL)
WARNING_LEVEL=W4
!endif

MSC_WARNING_LEVEL=-$(WARNING_LEVEL) -WX
IA64_WARNING_LEVEL=-$(WARNING_LEVEL:W4=W3) -WX
AMD64_WARNING_LEVEL=-$(WARNING_LEVEL:W4=W3) -WX -D_M_AMD64

C_DEFINES = $(C_DEFINES) \
    /D_WCTYPE_INLINE_DEFINED \
    /DNASHVILLE \
    /DSTRICT \
    /DUNICODE \
    /D_UNICODE \
    /DOLEDBVER=0x0200 \

!if !$(FREEBUILD)
USE_RTTI=1
MSC_OPTIMIZATION=/Od
#USER_CPP_FLAGS=/zmf
WATCOM_OPTS=/ei /zt16 /zm /zff /zgf
LINKER_NOICF=1      # ICF is s-l-o-w
USE_DEBUGLIB=1
!if $(386) && !defined(UNIX)
USE_STACK_SPEW=1
!endif
!else
MSC_OPTIMIZATION=/Oxs
#USER_CPP_FLAGS=/zmf
WATCOM_OPTS=/ei /zt16 /ox /oe /zm /zff /zgf
!endif

!if defined(MSHTML_COD_FILES)
USER_C_FLAGS=$(USER_C_FLAGS) /Fc
!endif

!if !$(FREEBUILD) && defined(MSHTML_NO_INLINE)
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Ob0 /Oi
!else
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Ob1 /Oi
!endif

NOT_LEAN_AND_MEAN=1

UMTYPE=windows

USE_NOLIBS=1
USE_MSVCRT=1

# Use NT 4.0/Win95 functionality only

WIN32_IE_VERSION=0x0400
WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400
SUBSYSTEM_VERSION=4.00

!if $(386)
NO_NTDLL=1
!else
# USE_NTDLL=1
!endif

# By default, don't generate a .bsc file
NO_BROWSER_FILE=1

!ifdef MSHTML_BROWSER_INFO
USER_ENV_BROWSER_INFO=1
BROWSER_INFO = 1;
!endif

!ifdef HTML_LAYOUT
C_DEFINES = $(C_DEFINES) /DHTML_LAYOUT
!endif

!ifdef NDHACKS
C_DEFINES = $(C_DEFINES) /DNDHACKS
!endif

!ifdef ND_ASSERT
C_DEFINES = $(C_DEFINES) /DND_ASSERT
!endif

!ifdef TREE_SYNC
C_DEFINES = $(C_DEFINES) /DTREE_SYNC
!endif

!ifdef IE6_WYSIWYG_OM
C_DEFINES = $(C_DEFINES) /DIE6_WYSIWYG_OM
!endif

!ifdef DLOAD1
C_DEFINES = $(C_DEFINES) /DDLOAD1
!endif

!ifdef ACCURATEZOOM
C_DEFINES = $(C_DEFINES) /DACCURATEZOOM
!endif


!ifdef MULTI_FORMAT
C_DEFINES = $(C_DEFINES) /DMULTI_FORMAT
!endif

!ifdef MULTI_LAYOUT
C_DEFINES = $(C_DEFINES) /DMULTI_LAYOUT
!endif

!ifdef VIEW_SERVICES
C_DEFINES = $(C_DEFINES) /DVIEW_SERVICES
!endif

!ifdef DISABLE_MEASURING
C_DEFINES = $(C_DEFINES) /DDISABLE_MEASURING
!endif

!ifdef NEW_FILTERS
C_DEFINES = $(C_DEFINES) /DNEW_FILTERS
!endif

!ifdef ADORNERS
C_DEFINES = $(C_DEFINES) /DADORNERS
!endif

!ifdef FOCUS_ADORNER
C_DEFINES = $(C_DEFINES) /DFOCUS_ADORNER
!endif

!ifdef FOCUS_BEHAVIOR
C_DEFINES = $(C_DEFINES) /DFOCUS_BEHAVIOR
!endif

!ifdef EDIT_BEHAVIOR
C_DEFINES = $(C_DEFINES) /DEDIT_BEHAVIOR
!endif

!ifdef SLOWALLOC
!message SLOWALLOC was defined
C_DEFINES = $(C_DEFINES) /DSLOWALLOC
!endif

!ifdef MARKCODE
!message MARKCODE was defined
C_DEFINES = $(C_DEFINES) /DMARKCODE
!endif

!if defined(USE_ICECAP) || defined(USING_ICECAP4_ICEPICK)
C_DEFINES = $(C_DEFINES) /DPRODUCT_PROF
!if defined(USING_ICECAP4_ICEPICK)
C_DEFINES = $(C_DEFINES) /DICECAP4
PERFLIBS=$(ROOT)\external\lib\icecap.lib
!endif
!endif

!ifdef USE_PERFTAGS
!if $(FREEBUILD)
C_DEFINES = $(C_DEFINES) /DPERFTAGS
!message PERFTAGS was defined
USE_DEBUGLIB=1
!endif
!endif

!if !$(FREEBUILD) && !defined(UNIX)
C_DEFINES = $(C_DEFINES) /DPERFMETER
!message PERFMETER was defined
USE_DEBUGLIB=1
!endif

!ifdef USE_STACK_SPEW
C_DEFINES = $(C_DEFINES) /DUSE_STACK_SPEW
!message USE_STACK_SPEW was defined
!endif

!if "$(BUILD_ALT_DIR)"=="m" && "$(USE_PERFTAGS_IN_METER_BUILD)"=="1"
C_DEFINES = $(C_DEFINES:PERFMETER=PERFMETER /DPERFTAGS)
!message PERFTAGS was defined in METER build
USE_DEBUGLIB=1
!endif

!if "$(BUILD_ALT_DIR)"=="m"
USE_DEBUGLIB=1
!endif

!if $(FREEBUILD) && "$(BUILD_ALT_DIR)"!="m" && "$(USE_SWITCHES_IN_RETAIL_BUILD)"=="1"
C_DEFINES = $(C_DEFINES) /DUSESWITCHES
!message USESWITCHES was defined in RETAIL build
!endif

!if !$(FREEBUILD) || "$(OBJCNTCHK)"=="1"
C_DEFINES = $(C_DEFINES) /DOBJCNTCHK
!message OBJCNTCHK was defined
!endif

TRIRTMAIN=_DllMainStartup

!if defined(USE_STACK_SPEW) && defined(USE_DEBUGLIB)
TRIRTMAIN=_DllMainStartupDebugChkStk
!endif

!if defined(USE_STACK_SPEW) && !defined(USE_DEBUGLIB)
TRIRTMAIN=_DllMainStartupChkStk
!endif

!if !defined(USE_STACK_SPEW) && defined(USE_DEBUGLIB)
TRIRTMAIN=_DllMainStartupDebug
!endif

!ifdef USE_MSHTML_INCREMENTAL_LINKING
!if !$(FREEBUILD) && $(USE_MSHTML_INCREMENTAL_LINKING)
NTDEBUG=ntsd
NTDEBUGTYPE=windbg
NTDBGFILES=1
!undef USE_MAPSYM
USE_INCREMENTAL_LINKING=1
LINKER_FLAGS=$(LINKER_FLAGS) -INCREMENTAL:YES
USE_PDB_TO_COMPILE=1
TARGETPDB=MSHTML
!message USE_MSHTML_INCREMENTAL_LINKING was defined
!message $(TARGETPDB) was defined
!endif
!else
# Compatibility with existing usage before use_mshtml_incremental_linking
!ifdef USE_INCREMENTAL_LINKING
!message DOING IT THE OLD WAY
LINKER_FLAGS = -INCREMENTAL:YES
USE_PDB_TO_COMPILE=1
!else
USE_MAPSYM=1
!endif
!endif

#
# Linker flags
#

!if "$(BUILD_PRODUCT)" == "IE"
USE_WIN98OPT=1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\btools\pdlparse\pdlinit.cxx ===
#include "headers.hxx"

extern "C"
HINSTANCE MwMainwinInitLite(int argc, char *argv[], void *lParam);

extern "C" 
HINSTANCE mainwin_init(int argc, char *argv[])
{ 
    return MwMainwinInitLite( argc, argv, NULL ); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\btools\ascparse\ascparse.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1997
//
//  File:       ascparse.cxx
//
//  Contents:   Tool to build .hsc files from .asc files.
//
//              Does the work of precomputing hash tables for associative
//              arrays of strings.
//
//----------------------------------------------------------------------------

#define INCMSG(x)
#include "headers.hxx"

#ifndef X_LIMITS_H_
#define X_LIMITS_H_
#include <limits.h>
#endif

#ifndef X_PLATFORM_H_
#define X_PLATFORM_H_
#include <platform.h>
#endif

#ifndef X_MSHTMDBG_H_
#define X_MSHTMDBG_H_
#undef PERFMETER
#include <mshtmdbg.h>
#endif

#define ASCPARSE

// The following macro definitions allow us to use assoc.cxx
// without bringing in the whole CORE directory

#ifndef X_TCHAR_H_
#define X_TCHAR_H_
#include "tchar.h"
#endif

#define THR(x) (x)
#define RRETURN(x) return(x)
#define _MemAlloc(cb) malloc(cb)
#define _MemAllocClear(cb) calloc(1,cb)
#define _MemFree(x) free(x)
#define MemAlloc(mt,cb) _MemAlloc(cb)
#define MemAllocClear(mt,cb) _MemAllocClear(cb)
#define MemFree(x) _MemFree(x)
#define MemRealloc(mt, ppv, cb) _MemRealloc(ppv, cb)
#define _tcsequal(x,y) (!_tcscmp(x,y))
#define Assert(x) if (!(x)) { fprintf(stderr, "%s", #x); exit(1); }
#define Verify(x) if (!(x)) { fprintf(stderr, "%s", #x); exit(1); }
#define ARRAY_SIZE(x)   (sizeof(x) / sizeof(x[0]))

HRESULT 
_MemRealloc(void **ppv, size_t cb)
{
    void *pv;

    if (*ppv == NULL)
    {
        *ppv = _MemAlloc(cb);
        if (*ppv == NULL)
            return E_OUTOFMEMORY;
    }
    else
    {       
        pv = realloc(*ppv, cb);
        if (pv == NULL)
            return E_OUTOFMEMORY;
        *ppv = pv;
    }
    return S_OK;
};

void GetSuffix(LPCSTR pAssocString, LPSTR pSuffix, int nNumber)
{
    pSuffix[0] = '\0'; // NULL terminate the suffix
    // check if the First Character is a Captial letter.
    if ( islower(pAssocString[0]) )
        return;

    _itoa(nNumber, pSuffix, 10);
}

#include "assoc.cxx"

// end of stubs


#define MAX_WORD 64
#define MAX_LINE 4096

class CAscParser
{
public:
    CAscParser() { memset(this, 0, sizeof(*this)); }
    
    class CAscEntry {
    public:
        CAscEntry() { memset(this, 0, sizeof(*this)); }
        CAscEntry *_pEntryNext;
        char _achString[MAX_WORD];
        int  _number;
        char _achNumber[MAX_WORD];
        char _achStringName[MAX_WORD];
        char _achAssoc[MAX_WORD];
        char _achEnum[MAX_WORD];
        BOOL _fNoassoc;
        BOOL _fNostring;
        BOOL _fNoenum;
        const CAssoc *_pAssoc;
    };

    HRESULT ProcessAscFile(char *pchInputFile, char *pchOutputFile);
    char _achAssocArray[MAX_WORD];
    char _achAssocPrefix[MAX_WORD];
    char _achEnumType[MAX_WORD];
    char _achEnumPrefix[MAX_WORD];
    char _achStringNamePrefix[MAX_WORD];
    BOOL _fInsensitive;
    BOOL _fReversible;
    CAscEntry *_pEntryFirst;
    CAscEntry *_pEntryLast;
};
    
static BOOL ReadLine(FILE *fp, char *pchBuf, int cchBuf, int *pcchRead);
static void SkipSpace(char **ppch);
static void SkipNonspace(char **ppch);
static void ChopComment(char *pch);
static void GetWord(char **ppch, char **ppchWord);


int __cdecl
main  ( int argc, char *argv[] )
{
    HRESULT hr = E_FAIL;
    CAscParser np;
    
    if (argc != 3)
        goto Cleanup;

    hr = np.ProcessAscFile(argv[1], argv[2]);

Cleanup:

    if (hr)
        printf ( "Error %lx building ASC file\n", hr);
    exit(hr);
}

HRESULT
CAscParser::ProcessAscFile(char *pchInputFile, char *pchOutputFile)
{
    HRESULT hr;
    FILE   *fpInput = NULL;
    FILE   *fpOutput = NULL;
    char    achBuf[MAX_LINE];
    char   *pch;
    char   *pchWord;
    CAscEntry *pEntryNew;
    CAscEntry *pEntry;
    CAssocArray nt;

    nt.Init();
    _fReversible = FALSE;

    // open input file
    fpInput = fopen(pchInputFile, "r");
    if (!fpInput)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // open output file
    fpOutput = fopen(pchOutputFile, "w");
    if (!fpOutput)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // phase 1: read the header section
    hr = E_FAIL;
    
    for (;;)
    {
        if (!ReadLine(fpInput, achBuf, MAX_LINE, NULL))
            goto Cleanup;
        pch = achBuf;
        ChopComment(pch);
        GetWord(&pch, &pchWord);
        if (!*pchWord)
            continue;
        if (!strcmp(pchWord, "assocarray"))
        {
            GetWord(&pch, &pchWord);
            strcpy(_achAssocArray, pchWord);
            GetWord(&pch, &pchWord);
            strcpy(_achAssocPrefix, pchWord);
        }
        else
        if (!strcmp(pchWord, "enum"))
        {
            GetWord(&pch, &pchWord);
            strcpy(_achEnumType, pchWord);
            GetWord(&pch, &pchWord);
            strcpy(_achEnumPrefix, pchWord);
        }
        else
        if (!strcmp(pchWord, "string"))
        {
            GetWord(&pch, &pchWord);
            strcpy(_achStringNamePrefix, pchWord);
        }
        else
        if (!strcmp(pchWord, "case-insensitive"))
        {
            _fInsensitive = TRUE;
        }
        else
        if (!strcmp(pchWord, "case-sensitive"))
        {
            _fInsensitive = FALSE;
        }
        else
        if (!strcmp(pchWord, "reversible"))
        {
            _fReversible = TRUE;
        }
        else
        if (!strcmp(pchWord, "start"))
            break;
    }
    
    // phase 2: read the assoc table section
    hr = S_OK;
    
    while (ReadLine(fpInput, achBuf, MAX_LINE, NULL))
    {
        pch = achBuf;
        
        ChopComment(pch);
        GetWord(&pch, &pchWord);
        if (!*pchWord)
            continue;

        // allocate
        pEntryNew = new CAscEntry;
        if (!pEntryNew)
            return E_OUTOFMEMORY;

        // link up
        if (!_pEntryLast)
        {
            pEntryNew->_number = 0;
            _pEntryLast = _pEntryFirst = pEntryNew;
        }
        else
        {
            pEntryNew->_number = _pEntryLast->_number+1;
            _pEntryLast->_pEntryNext = pEntryNew;
            _pEntryLast = pEntryNew;
        }

        // fill in assoc
        strcpy(pEntryNew->_achString, pchWord);

        // fill in other fields
        for (;;)
        {
            GetWord(&pch, &pchWord);
            if (!*pchWord)
                break;

            if (!strcmp(pchWord, "number"))
            {
                GetWord(&pch, &pchWord);
                if (*pchWord == '=')
                {
                    for (pEntry = _pEntryFirst; pEntry; pEntry = pEntry->_pEntryNext)
                    {
                        if (!strcmp(pchWord+1, pEntry->_achString))
                        {
                            break;
                        }
                    }
                    
                    if (!pEntry)
                    {
                        hr = E_FAIL;
                        goto Cleanup;
                    }
                    
                    pEntryNew->_number = pEntry->_number;
                    strcpy(pEntryNew->_achNumber, pEntry->_achNumber);
                }
                else if (*pchWord >= '0' && *pchWord <= '9' || *pchWord == '-')
                {
                    pEntryNew->_number = atol(pchWord);
                    *pEntryNew->_achNumber = '\0';
                }
                else
                {
                    pEntryNew->_number = 0;
                    strcpy(pEntryNew->_achNumber, pchWord);
                }
            }
            else
            if (!strcmp(pchWord, "string"))
            {
                GetWord(&pch, &pchWord);
                strcpy(pEntryNew->_achStringName, pchWord);
            }
            else
            if (!strcmp(pchWord, "enum"))
            {
                GetWord(&pch, &pchWord);
                strcpy(pEntryNew->_achEnum, pchWord);
            }
            else
            if (!strcmp(pchWord, "assoc"))
            {
                GetWord(&pch, &pchWord);
                strcpy(pEntryNew->_achAssoc, pchWord);
            }
            else
            if (!strcmp(pchWord, "noassoc"))
            {
                pEntryNew->_fNoassoc = TRUE;
            }
            else
            if (!strcmp(pchWord, "nostring"))
            {
                pEntryNew->_fNostring = TRUE;
            }
            else
            if (!strcmp(pchWord, "noenum"))
            {
                pEntryNew->_fNoenum = TRUE;
            }
        }
    }

    // compute assocs
    for (pEntry = _pEntryFirst; pEntry; pEntry = pEntry->_pEntryNext)
    {
        if (!pEntry->_fNoassoc)
        {
            WCHAR awch[MAX_WORD];
            WCHAR *pwch = awch;
            char *pch = pEntry->_achString;
            DWORD len;
            DWORD hash;
            const CAssoc *passoc;
            
            do { *pwch++ = *pch; } while (*pch++);

            len = _tcslen(awch);
            
            if (_fInsensitive)
                hash = HashStringCi(awch, len, 0);
            else
                hash = HashString(awch, len, 0);

            passoc = nt.AddAssoc((DWORD_PTR)pEntry, awch, len, hash);
            if (!passoc)
            {
                hr = E_FAIL;
                goto Cleanup;
            }
            pEntry->_pAssoc = passoc;
        }
    }
            
    // phase 3: output header decls enums
    fprintf(fpOutput, "// %s\n", pchOutputFile);
    fprintf(fpOutput, "// Generated by ascparse.exe from %s\n", pchInputFile);
    fprintf(fpOutput, "// Do not modify by hand!\n");
    fprintf(fpOutput, "\n#ifndef _cxx_\n\n");

    // assocarray and hash
    fprintf(fpOutput, "class CAssoc;\n");
    fprintf(fpOutput, "class CAssocArray;\n\n");
    
    fprintf(fpOutput, "extern const CAssoc * const %s_HashTable[%d];\n", _achAssocArray, nt._mHash);
    if (_fReversible)
    {
        fprintf(fpOutput, "extern const CAssoc * const %s_RevSearch[];\n", _achAssocArray);
    }
    fprintf(fpOutput, "extern const CAssocArray %s;\n\n", _achAssocArray);
    
    // enums
    if (*_achEnumType)
    {
        fprintf(fpOutput, "enum %s\n{\n", _achEnumType);
        for (pEntry = _pEntryFirst; pEntry; pEntry = pEntry->_pEntryNext)
        {
            if (!pEntry->_fNoenum)
            {
                if (*pEntry->_achEnum)
                {
                    fprintf(fpOutput, "    %s = %d,\n", pEntry->_achEnum, pEntry->_number);
                }
                else
                {
                    fprintf(fpOutput, "    %s%s = %d,\n", _achEnumPrefix, pEntry->_achString, pEntry->_number);
                }
            }
        }
        fprintf(fpOutput, "    %s_FORCE_LONG = LONG_MAX\n", _achEnumType);
        fprintf(fpOutput, "};\n\n");
    }
    
    // assocs
    for (pEntry = _pEntryFirst; pEntry; pEntry = pEntry->_pEntryNext)
    {
        if (!pEntry->_fNoassoc)
        {
            if (!*pEntry->_achAssoc)
            {
                char suffix[32];
                GetSuffix(pEntry->_achString, suffix, pEntry->_number); 
                fprintf(fpOutput, "extern const CAssoc %s%s%s;\n",
                    _achAssocPrefix, pEntry->_achString, suffix);
            }
            else
            {
                fprintf(fpOutput, "extern const CAssoc %s;\n",
                    pEntry->_achAssoc);
            }
        }
    }
    
    fprintf(fpOutput, "\n\n");

    // strings
    for (pEntry = _pEntryFirst; pEntry; pEntry = pEntry->_pEntryNext)
    {
        if (!pEntry->_fNostring)
        {
            if (!pEntry->_fNoassoc && (*_achStringNamePrefix || *pEntry->_achStringName))
            {
                if (*pEntry->_achStringName)
                {
                    fprintf(fpOutput, "#define %s ",
                        pEntry->_achStringName);
                }
                else
                {
                    fprintf(fpOutput, "#define %s%s ",
                        _achStringNamePrefix, pEntry->_achString);
                }
                
                if (!*pEntry->_achAssoc)
                {
                    char suffix[32];
                    GetSuffix(pEntry->_achString, suffix, pEntry->_number); 
                    fprintf(fpOutput, "(%s%s%s._ach)\n",
                        _achAssocPrefix, pEntry->_achString, suffix);
                }
                else
                {
                    fprintf(fpOutput, "(%s._ach)\n",
                        pEntry->_achAssoc);
                }
            }
            else
            {
                if (*pEntry->_achStringName)
                {
                    fprintf(fpOutput, "#define %s (_T(\"%s\"))\n",
                        pEntry->_achStringName, pEntry->_achString);
                }
                else if (*_achStringNamePrefix)
                {
                    fprintf(fpOutput, "#define *%s%s (_T(\"%s\"))\n",
                        _achStringNamePrefix, pEntry->_achString, pEntry->_achString);
                }
            }
        }
    }

    // end of header section; start of cxx section
    fprintf(fpOutput, "\n#else _cxx_\n\n");
    fprintf(fpOutput, "\n#undef _cxx_\n\n");

    
    // phase 4: output assocs
    for (pEntry = _pEntryFirst; pEntry; pEntry = pEntry->_pEntryNext)
    {
        if (!pEntry->_fNoassoc)
        {
            if (!*pEntry->_achAssoc)
            {
                char suffix[32];
                GetSuffix(pEntry->_achString, suffix, pEntry->_number); 
                fprintf(fpOutput, "const CAssoc %s%s%s\t\t\t= ",
                    _achAssocPrefix, pEntry->_achString, suffix);
            }
            else
            {
                fprintf(fpOutput, "const CAssoc %s = ",
                    pEntry->_achAssoc);
            }
            if (*pEntry->_achNumber)
            {
                fprintf(fpOutput, "{ %12s, 0x%08x, _T(\"%s\") };\n",
                    pEntry->_achNumber, pEntry->_pAssoc->_hash, pEntry->_achString);
            }
            else
            {
                fprintf(fpOutput, "{ %5d, 0x%08x, _T(\"%s\") };\n",
                    pEntry->_number, pEntry->_pAssoc->_hash, pEntry->_achString);
            }
        }
    }

    // phase 5: output table
    // output hash table
    fprintf(fpOutput, "\n\nconst CAssoc * const %s_HashTable[%d] =\n{\n", _achAssocArray, nt._mHash);
    {
        int i;
        int c;
        int s;
        int d;
        
        const CAssoc * const *ppAssoc;
        for (ppAssoc = nt._pHashTable, c=nt._mHash; c; ppAssoc++, c--)
        {
            if (!*ppAssoc)
            {
                fprintf(fpOutput, "        NULL,\n");
            }
            else
            {
                i = (*ppAssoc)->Hash() % nt._mHash;
                s = ((*ppAssoc)->Hash() & nt._sHash) + 1;
                d = 0;
                while (nt._pHashTable + i != ppAssoc)
                {
                    if (i < s)
                        i += nt._mHash;
                    i -= s;
                    d++;
                }
                    
                fprintf(fpOutput, "/*%2d */ ",d);
                
                pEntry = (CAscEntry*)(*ppAssoc)->Number();
                
                if (!*pEntry->_achAssoc)
                {
                    char suffix[32];
                    GetSuffix(pEntry->_achString, suffix, pEntry->_number); 
                    fprintf(fpOutput, "&%s%s%s,\n",
                        _achAssocPrefix, pEntry->_achString, suffix);
                }
                else
                {
                    char suffix[32];
                    GetSuffix(pEntry->_achAssoc, suffix, pEntry->_number); 
                    fprintf(fpOutput, "&%s%s,\n",
                        pEntry->_achAssoc, suffix);
                }

            }
        }
    }

    fprintf(fpOutput, "};\n\n");

    // phase 6: output table for reverse search (if requested)
    if (_fReversible)
    {
        CAscParser::CAscEntry *    pFound;
        CAscParser::CAscEntry *    pEntry;
        int nCurrMin;
        int nPrevMin;
        int nCurrVal;

        fprintf(fpOutput, "const CAssoc * const %s_RevSearch[] =\n{\n", _achAssocArray);

        // find and print the entries in order from numeric min to max
        nPrevMin = 0;
        for(;;)
        {
            // find the next entry

            nCurrMin = INT_MAX;
            pFound = NULL;

            for (pEntry = _pEntryFirst; pEntry; pEntry = pEntry->_pEntryNext)
            {
                if (*pEntry->_achNumber)
                {
                    nCurrVal = atol(pEntry->_achNumber);
                }
                else
                {
                    nCurrVal = pEntry->_number;
                }

                if (nCurrVal > nPrevMin && nCurrVal < nCurrMin)
                {
                    nCurrMin = nCurrVal;
                    pFound = pEntry;
                }
            }

            // break out once we've done everything
            if (pFound == NULL)
            {
                break;
            }

            // output a pointer to the assoc
            if (!*pFound->_achAssoc)
            {
                char suffix[32];
                GetSuffix(pFound->_achString, suffix, pFound->_number); 
                fprintf(fpOutput, "\t&%s%s%s,\n",
                    _achAssocPrefix, pFound->_achString, suffix);
            }
            else
            {
                fprintf(fpOutput, "\t%s,\n", pFound->_achAssoc);
            }

            nPrevMin = nCurrMin;
        }

        fprintf(fpOutput, "};\n\n");
    }

    // output assoc table struct itself
    fprintf(fpOutput, "const CAssocArray %s = {\n", _achAssocArray);
    fprintf(fpOutput, "    %s_HashTable,\n", _achAssocArray);
    fprintf(fpOutput, "    %d,\n", nt._cHash);
    fprintf(fpOutput, "    %d,\n", nt._mHash);
    fprintf(fpOutput, "    %d,\n", nt._sHash);
    fprintf(fpOutput, "    %d,\n", nt._cHash);
    fprintf(fpOutput, "    %d,\n", nt._iSize);
    fprintf(fpOutput, "    TRUE,\n");
    fprintf(fpOutput, "};\n\n");
        
    fprintf(fpOutput, "\n#endif _cxx_\n\n");
    
    
Cleanup:
    nt.Deinit();
    
    if (fpInput)
        fclose(fpInput);
    if (fpOutput)
        fclose(fpOutput);

    return hr;
}

static
BOOL
ReadLine(FILE *fp, char *pchBuf, int cchBuf, int *pcchRead)
{
    int cchRead;
    
    if (!fgets(pchBuf, cchBuf, fp))
        return FALSE;

    cchRead = strlen(pchBuf);
    if (!cchRead)
        return FALSE;

    if (pcchRead)
        *pcchRead = cchRead;
        
    return TRUE;
}

static
void
SkipSpace(char **ppch)
{
    char *pch = *ppch;
    while (*pch && (*pch == ' ' || *pch == '\t' || *pch == '\r' || *pch == '\n'))
        pch++;
    *ppch = pch;
}


static
void
SkipNonspace(char **ppch)
{
    char *pch = *ppch;
    while (*pch && (*pch != ' ' && *pch != '\t' && *pch != '\r' && *pch != '\n'))
        pch++;
    *ppch = pch;
}

static
void
ChopComment(char *pch)
{
    while (*pch)
    {
        if (*pch == '/' && *(pch+1) == '/')
        {
            *pch = '\0';
            return;
        }
        pch++;
    }
}

static
void
GetWord(char **ppch, char **ppchWord)
{
    SkipSpace(ppch);
    *ppchWord = *ppch;
    SkipNonspace(ppch);
    if (**ppch)
    {
        **ppch = '\0';
        if (*ppch - *ppchWord > MAX_WORD)
            *(*ppchWord + MAX_WORD-1) = '\0';
        (*ppch)++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\btools\nfparse\nfparse.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1997
//
//  File:       nfparse.cxx
//
//  Contents:   Tool to build .nfh files from .nfi files.
//
//----------------------------------------------------------------------------

#ifndef X_STDLIB_H_
#define X_STDLIB_H_
#include <stdlib.h>
#endif

#ifndef X_STDIO_H_
#define X_STDIO_H_
#include <stdio.h>
#endif

#ifndef X_STDDEF_H_
#define X_STDDEF_H_
#include <stddef.h>
#endif

#ifndef X_SEARCH_H_
#define X_SEARCH_H_
#include <search.h>
#endif

#ifndef X_STRING_H_
#define X_STRING_H_
#include <string.h>
#endif

#ifndef X_CTYPE_H_
#define X_CTYPE_H_
#include <ctype.h>
#endif

#ifndef X_LIMITS_H_
#define X_LIMITS_H_
#include <limits.h>
#endif

#ifndef X_STDARG_H_
#define X_STDARG_H_
#include <stdarg.h>
#endif

//  Allow assignment within conditional
#pragma warning ( disable : 4706 )


#define MAX_WORD 256
#define MAX_LINE 4096
#define TRUE     1
#define FALSE    0
#define BOOL     int
#define ERROR    int
#define E_FAIL   1
#define S_OK     0

char achBlanks[] = "                                                                                    "
                   "                                                                                    "
                   "                                                                                    "
                   "                                                                                    "
                   "                                                                                    ";

class CNotificationParser
{
public:
    CNotificationParser() { memset(this, 0, sizeof(*this)); }
    
    class CNotification {
    public:
        CNotification() { memset(this, 0, sizeof(*this)); }
        void MakeSC( CNotification *pN );
        void MarkFirstChance();

        CNotification * _pNextN;

        char            _achType[MAX_WORD];

        //
        //  Targets
        //

        unsigned        _fSelf:1;
        unsigned        _fAncestors:1;
        unsigned        _fDescendents:1;
        unsigned        _fTree:1;

        //
        //  Categories
        //

        unsigned        _fTextChange:1;
        unsigned        _fTreeChange:1;
        unsigned        _fLayoutChange:1;
        unsigned        _fActiveX:1;
        unsigned        _fLayoutElements:1;
        unsigned        _fPositionedElements:1;
        unsigned        _fBubbleUpViewTree:1;
        unsigned        _fAllElements:1;
        unsigned        _fFrameSites:1;

        //
        //  Properties
        //

        unsigned        _fSendUntilHandled:1;
        unsigned        _fLazyRange:1;
        unsigned        _fCleanChange:1;
        unsigned        _fSynchronousOnly:1;
        unsigned        _fDoNotBlock:1;
        unsigned        _fAutoOnly:1;
        unsigned        _fZParentsOnly:1;
        unsigned        _fSecondChanceAvail:1;
        unsigned        _fSecondChance:1;
        
        //
        //  Arguments
        //

        unsigned        _fElement:1;
        unsigned        _fSI:1;
        unsigned        _fCElements:1;
        unsigned        _fCp:1;
        unsigned        _fCch:1;
        unsigned        _fTreeNode:1;
        unsigned        _fData:1;
        unsigned        _fFlags:1;
    };

    char *  _pchInput;
    char *  _pchOutput;

    FILE *  _fpOutput;
    FILE *  _fpInput;
    FILE *  _fpLog;

    ERROR  Parse();
    BOOL   Validate(CNotification * pN);
    BOOL   ReadLine(char *pchBuf, int cchBuf, int *pcchRead);
    void   SkipSpace(char **ppch);
    void   SkipNonspace(char **ppch);
    void   ChopComment(char *pch);
    BOOL   GetWord(char **ppch, char **ppchWord);
    char * NameOf(char * pchInput, char * pchOutput);
    void   WriteArg(unsigned fFlag, char * pchArg, char * pchPad, int * pcArgs);
    void   WriteFlag(unsigned fFlag, char * pchFlag, int * pcFlags);
    void   ReportError(const char * pchError, ...);
};


ERROR __cdecl
main  ( int argc, char *argv[] )
{
    CNotificationParser np;
    ERROR               err = E_FAIL;
    
    if (argc != 3)
    {
        printf("nfparse: Usage <Notification File> <HeaderFile>\n");
        goto Cleanup;
    }


    np._pchInput  = argv[1];
    np._pchOutput = argv[2];

    err = np.Parse();

Cleanup:

    exit(err);
}


ERROR
CNotificationParser::Parse()
{
    char                achBuf[MAX_LINE];
    char                achTemp[MAX_WORD];
    char *              pch;
    char *              pchWord  = NULL;
    CNotification *     pFirstN  = NULL;
    CNotification **    ppN      = &pFirstN;
    CNotification *     pN       = NULL;
    int                 i;
    int                 cch;
    ERROR               err;

    // open input file
    _fpInput = fopen(_pchInput, "r");
    if (!_fpInput)
    {
        err = E_FAIL;
        goto Cleanup;
    }

    // open output file
    _fpOutput = fopen(_pchOutput, "w");
    if (!_fpOutput)
    {
        err = E_FAIL;
        goto Cleanup;
    }

    // open log file
    strcpy(achBuf, _pchOutput);
    strcat(achBuf, "LOG");
    _fpLog = fopen(achBuf, "w");
    if (!_fpLog)
    {
        err = E_FAIL;
        goto Cleanup;
    }

    // phase 1: read the file
    err = E_FAIL;

    while (ReadLine(achBuf, MAX_LINE, NULL))
    {
        pch = achBuf;

        ChopComment(pch);

        while (GetWord(&pch, &pchWord))
        {
            if (!strcmp(pchWord, "type"))
            {
                if (*ppN == NULL)
                {
                    *ppN = new CNotification();
                    if (!*ppN)
                        goto Cleanup;
                    pN  = *ppN;
                    ppN = &pN->_pNextN;
                }

                if (!GetWord(&pch, &pchWord))
                {
                    ReportError("Missing notification type");
                    goto Cleanup;
                }
                strncpy(pN->_achType, pchWord, MAX_WORD-1);
            }

            else
            if (!strcmp(pchWord, "targets"))
            {
                if (!pN)
                {
                    ReportError("Notification does not start with 'type:'");
                    goto Cleanup;
                }

                while (GetWord(&pch, &pchWord))
                {
                    if (!strcmp(pchWord, "self"))
                    {
                        pN->_fSelf = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "ancestors"))
                    {
                        pN->_fAncestors = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "descendents"))
                    {
                        pN->_fDescendents = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "tree-level"))
                    {
                        pN->_fTree = TRUE;
                    }
                }
            }

            else
            if (!strcmp(pchWord, "categories"))
            {
                if (!pN)
                {
                    ReportError("Notification does not start with 'type:'");
                    goto Cleanup;
                }

                while (GetWord(&pch, &pchWord))
                {
                    if (!strcmp(pchWord, "text-change"))
                    {
                        pN->_fTextChange = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "tree-change"))
                    {
                        pN->_fTreeChange = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "layout-change"))
                    {
                        pN->_fLayoutChange = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "activex"))
                    {
                        pN->_fActiveX = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "layout-elements"))
                    {
                        pN->_fLayoutElements = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "positioned-elements"))
                    {
                        pN->_fPositionedElements = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "bubble-up-view-tree"))
                    {
                        pN->_fBubbleUpViewTree = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "all-elements"))
                    {
                        pN->_fAllElements = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "frame-sites"))
                    {
                        pN->_fFrameSites = TRUE;
                    }
                }
            }

            else
            if (!strcmp(pchWord, "properties"))
            {
                if (!pN)
                {
                    ReportError("Notification does not start with 'type:'");
                    goto Cleanup;
                }

                while (GetWord(&pch, &pchWord))
                {
                    if (!strcmp(pchWord, "send-until-handled"))
                    {
                        pN->_fSendUntilHandled = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "lazy-range"))
                    {
                        pN->_fLazyRange = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "clean-change"))
                    {
                        pN->_fCleanChange = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "synchronous-only"))
                    {
                        pN->_fSynchronousOnly = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "dont-block"))
                    {
                        pN->_fDoNotBlock = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "auto-only"))
                    {
                        pN->_fAutoOnly = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "zparents-only"))
                    {
                        pN->_fZParentsOnly = TRUE;
                    }
                    else
                    if (!strcmp(pchWord, "second-chance"))
                    {
                        pN->_fSecondChanceAvail = TRUE;
                    }
                }
            }

            else
            if (!strcmp(pchWord, "arguments"))
            {
                if (!pN)
                {
                    ReportError("Notification does not start with 'type:'");
                    goto Cleanup;
                }

                while (GetWord(&pch, &pchWord))
                {
                    if (!strcmp(pchWord, "element"))
                        pN->_fElement = 1;
                    else
                    if (!strcmp(pchWord, "si"))
                        pN->_fSI = 1;
                    else
                    if (!strcmp(pchWord, "celements"))
                        pN->_fCElements = 1;
                    else
                    if (!strcmp(pchWord, "cp"))
                        pN->_fCp = 1;
                    else
                    if (!strcmp(pchWord, "cch"))
                        pN->_fCch = 1;
                    else
                    if (!strcmp(pchWord, "tree-node"))
                        pN->_fTreeNode = 1;
                    else
                    if (!strcmp(pchWord, "data"))
                        pN->_fData = 1;
                    else
                    if (!strcmp(pchWord, "flags"))
                        pN->_fFlags = 1;
                }
            }

            else
            {
                ReportError("Unknown keyword (%s)", pchWord);
                goto Cleanup;
            }
        }
    }


    // phase 2: validate the notifications
    for (pN = pFirstN; pN; pN = pN->_pNextN)
    {
        if (!Validate(pN))
        {
            ReportError("Notification %s is invalid", pN->_achType);
            goto Cleanup;
        }
    }

    // phase 3: expand second chance notifications
    for (pN = pFirstN; pN; pN = pN->_pNextN)
    {
        if (pN->_fSecondChanceAvail)
        {
            CNotification *     pNNew = new CNotification();
            if (!pNNew)
                goto Cleanup;

            pNNew->MakeSC( pN );

            pN->MarkFirstChance();

            pNNew->_pNextN = pN->_pNextN;
            pN->_pNextN = pNNew;
            pN = pNNew;
        }
    }
    
            
    // phase 4: output the file
    fprintf(_fpOutput, "//-----------------------------------------------------------------------------\n");
    fprintf(_fpOutput, "//\n");
    fprintf(_fpOutput, "// WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING\n");
    fprintf(_fpOutput, "//\n");
    fprintf(_fpOutput, "// %s\n", _pchOutput);
    fprintf(_fpOutput, "// Generated by NFPARSE.EXE from %s\n", _pchInput);
    fprintf(_fpOutput, "// DO NOT MODIFY BY HAND\n");
    fprintf(_fpOutput, "//\n");
    fprintf(_fpOutput, "// WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING\n");
    fprintf(_fpOutput, "//\n");
    fprintf(_fpOutput, "//-----------------------------------------------------------------------------\n\n");

    // generate the enums
    fprintf(_fpOutput, "#if defined(_NOTIFYTYPE_ENUM_)\n\n");

    for (i=0, pN = pFirstN; pN; pN = pN->_pNextN, i++)
    {
        sprintf(achTemp, "    NTYPE_%s", _strupr(pN->_achType));
        cch = 32 - strlen(achTemp);
        if (cch < 0)
            cch = 0;

        fprintf(_fpOutput, "%s", achTemp);

        strncpy(achTemp, achBlanks, cch);
        achTemp[cch] = '\0';

        fprintf(_fpOutput, "%s = 0x%08X,\n", achTemp, (long)i);
    }

    fprintf(_fpOutput, "#undef _NOTIFYTYPE_ENUM_\n\n");

    fprintf(_fpOutput, "\n");

    // generate the flag table
    fprintf(_fpOutput, "#elif defined(_NOTIFYTYPE_TABLE_)\n\n");

    for (pN = pFirstN; pN; pN = pN->_pNextN)
    {
        int cFlags = 0;

        sprintf(achTemp, "/* NTYPE_%s", _strupr(pN->_achType));
        cch = 32 - strlen(achTemp);
        if (cch < 0)
            cch = 0;

        fprintf(_fpOutput, "%s", achTemp);

        strncpy(achTemp, achBlanks, cch);
        achTemp[cch] = '\0';

        fprintf(_fpOutput, "%s*/", achTemp);

        WriteFlag(pN->_fSelf,               "NFLAGS_SELF",              &cFlags);
        WriteFlag(pN->_fAncestors,          "NFLAGS_ANCESTORS",         &cFlags);
        WriteFlag(pN->_fDescendents,        "NFLAGS_DESCENDENTS",       &cFlags);
        WriteFlag(pN->_fTree,               "NFLAGS_TREELEVEL",         &cFlags);

        WriteFlag(pN->_fTextChange,         "NFLAGS_TEXTCHANGE",        &cFlags);
        WriteFlag(pN->_fTreeChange,         "NFLAGS_TREECHANGE",        &cFlags);
        WriteFlag(pN->_fLayoutChange,       "NFLAGS_LAYOUTCHANGE",      &cFlags);
        WriteFlag(pN->_fActiveX,            "NFLAGS_FOR_ACTIVEX",       &cFlags);
        WriteFlag(pN->_fLayoutElements,     "NFLAGS_FOR_LAYOUTS",       &cFlags);
        WriteFlag(pN->_fPositionedElements, "NFLAGS_FOR_POSITIONED",    &cFlags);
        WriteFlag(pN->_fBubbleUpViewTree,   "NFLAGS_BUBBLE_UP_VIEW_TREE", &cFlags);
        WriteFlag(pN->_fAllElements,        "NFLAGS_FOR_ALLELEMENTS",   &cFlags);
        WriteFlag(pN->_fFrameSites,         "NFLAGS_FOR_FRAMESITES",    &cFlags);
        
        WriteFlag(pN->_fSendUntilHandled,   "NFLAGS_SENDUNTILHANDLED",  &cFlags);
        WriteFlag(pN->_fLazyRange,          "NFLAGS_LAZYRANGE",         &cFlags);
        WriteFlag(pN->_fCleanChange,        "NFLAGS_CLEANCHANGE",       &cFlags);
        WriteFlag(pN->_fSynchronousOnly,    "NFLAGS_SYNCHRONOUSONLY",   &cFlags);
        WriteFlag(pN->_fDoNotBlock,         "NFLAGS_DONOTBLOCK",        &cFlags);
        WriteFlag(pN->_fAutoOnly,           "NFLAGS_AUTOONLY",          &cFlags);
        WriteFlag(pN->_fZParentsOnly,       "NFLAGS_ZPARENTSONLY",      &cFlags);
        WriteFlag(pN->_fSecondChance,       "NFLAGS_SC",                &cFlags);
        WriteFlag(pN->_fSecondChanceAvail,  "NFLAGS_SC_AVAILABLE",      &cFlags);

        fprintf(_fpOutput, ",\n");
    }

    fprintf(_fpOutput, "#undef _NOTIFYTYPE_TABLE_\n\n");

    fprintf(_fpOutput, "\n");

    // generate the names
    fprintf(_fpOutput, "#elif defined(_NOTIFYTYPE_NAMES_)\n\n");

    for (pN = pFirstN; pN; pN = pN->_pNextN)
    {
        fprintf(_fpOutput, "        case NTYPE_%s:\n", _strupr(pN->_achType));
        fprintf(_fpOutput, "            pch = _T(\"%s\");\n", _strupr(pN->_achType));
        fprintf(_fpOutput, "            break;\n");
    }

    fprintf(_fpOutput, "#undef _NOTIFYTYPE_NAMES_\n\n");

    fprintf(_fpOutput, "\n");

    // generate the prototypes
    fprintf(_fpOutput, "#elif defined(_NOTIFYTYPE_PROTO_)\n\n");

    for (pN = pFirstN; pN; pN = pN->_pNextN)
    {
        int cArgs = 0;

        fprintf(_fpOutput, "        void %s(\n", NameOf(pN->_achType, achTemp));

        WriteArg(pN->_fElement,   "CElement *  pElement",      "             ", &cArgs);
        WriteArg(pN->_fSI,        "long        siElement",     "             ", &cArgs);
        WriteArg(pN->_fCElements, "long        cElements",     "             ", &cArgs);
        WriteArg(pN->_fCp,        "long        cp",            "             ", &cArgs);
        WriteArg(pN->_fCch,       "long        cch",           "             ", &cArgs);
        WriteArg(pN->_fTreeNode,  "CTreeNode * pNode  = NULL", "             ", &cArgs);
        WriteArg(pN->_fData,      "void *      pvData = NULL", "             ", &cArgs);
        WriteArg(pN->_fFlags,     "DWORD       grfFlags = 0",  "             ", &cArgs);

        fprintf(_fpOutput, ");\n\n");
    }

    fprintf(_fpOutput, "#undef _NOTIFYTYPE_PROTO_\n\n");

    fprintf(_fpOutput, "\n");

    // generate the inlines
    fprintf(_fpOutput, "#elif defined(_NOTIFYTYPE_INLINE_)\n\n");

    for (pN = pFirstN; pN; pN = pN->_pNextN)
    {
        int cArgs = 0;

        fprintf(_fpOutput, "inline void\nCNotification::%s(\n", NameOf(pN->_achType, achTemp));
        WriteArg(pN->_fElement,   "CElement *  pElement",  "    ", &cArgs);
        WriteArg(pN->_fSI,        "long        siElement", "    ", &cArgs);
        WriteArg(pN->_fCElements, "long        cElements", "    ", &cArgs);
        WriteArg(pN->_fCp,        "long        cp",        "    ", &cArgs);
        WriteArg(pN->_fCch,       "long        cch",       "    ", &cArgs);
        WriteArg(pN->_fTreeNode,  "CTreeNode * pNode",     "    ", &cArgs);
        WriteArg(pN->_fData,      "void *      pvData",    "    ", &cArgs);
        WriteArg(pN->_fFlags,     "DWORD       grfFlags",  "    ", &cArgs);
        fprintf(_fpOutput, ")\n{\n");

        if (    pN->_fElement
            &&  !pN->_fSI
            &&  !pN->_fCp
            &&  !pN->_fTreeChange)
            fprintf(_fpOutput, "    Assert(pElement);\n");

        cArgs = 0;

        fprintf(_fpOutput, "    Initialize%s%s(NTYPE_%s,\n",
                            pN->_fSI
                                ? "Si"
                                : "",
                            pN->_fCp
                                ? "Cp"
                                : "",
                            _strupr(pN->_achType));

        WriteArg(pN->_fElement, "pElement", "               ", &cArgs);

        if (pN->_fSI)
        {
            WriteArg(pN->_fSI,        "siElement", "               ", &cArgs);
            WriteArg(pN->_fCElements, "cElements", "               ", &cArgs);
        }

        if (pN->_fCp)
        {
            WriteArg(1, (pN->_fCp
                              ? "cp"
                              : "-1"),      "               ", &cArgs);
            WriteArg(1, (pN->_fCch
                              ? "cch"
                              : "-1"),      "               ", &cArgs);
        }

        WriteArg(1, (pN->_fTreeNode
                          ? "pNode"
                          : "NULL"),   "               ", &cArgs);
        WriteArg(1, (pN->_fData
                          ? "pvData"
                          : "NULL"),   "               ", &cArgs);
        WriteArg(1, (pN->_fFlags
                          ? "grfFlags"
                          : "0"),      "               ", &cArgs);

        fprintf(_fpOutput, ");\n");
        fprintf(_fpOutput, "}\n\n");
    }

    fprintf(_fpOutput, "#undef _NOTIFYTYPE_INLINE_\n\n");

    fprintf(_fpOutput, "\n");

    fprintf(_fpOutput, "#endif\n\n");

    err = S_OK;

Cleanup:

    if (err)
        ReportError("Could not build %s\n", _pchOutput);

    if (_fpInput)
        fclose(_fpInput);
    if (_fpOutput)
        fclose(_fpOutput);
    if (_fpLog)
        fclose(_fpLog);

    return err;
}

BOOL
CNotificationParser::Validate(CNotification * pN)
{
    ERROR err = E_FAIL;

    if (!*pN->_achType)
    {
        ReportError("Notification is missing 'type:'");
        goto Cleanup;
    }

    if (    !pN->_fSelf
        &&  !pN->_fAncestors
        &&  !pN->_fDescendents
        &&  !pN->_fTree)
    {
        ReportError("Notification is missing targets");
        goto Cleanup;
    }

    if (    pN->_fAncestors
        &&  pN->_fDescendents)
    {
        ReportError("Notification is sent to both ancestors and descendents");
        goto Cleanup;
    }

    if (    !pN->_fTextChange
        &&  !pN->_fTreeChange
        &&  !pN->_fLayoutChange
        &&  !pN->_fActiveX
        &&  !pN->_fLayoutElements
        &&  !pN->_fBubbleUpViewTree
        &&  !pN->_fPositionedElements
        &&  !pN->_fAllElements
        &&  !pN->_fFrameSites)
    {
        ReportError("Notification is missing categories");
        goto Cleanup;
    }

    if (    !pN->_fElement
        &&  !pN->_fSI
        &&  !pN->_fCp
        &&  !pN->_fTreeNode)
    {
        ReportError("Notification requires either 'element', 'si', 'cp', or 'tree-node'");
        goto Cleanup;
    }

    if (    pN->_fCElements
        &&  !pN->_fSI)
    {
        ReportError("Notification has 'celement' without 'si'");
        goto Cleanup;
    }

    if (    pN->_fCch
        &&  !pN->_fCp)
    {
        ReportError("Notification has 'cch' without 'cp'");
        goto Cleanup;
    }

    if (    pN->_fSecondChanceAvail
        &&  (   pN->_fSelf && strcmp( pN->_achType, "ELEMENT_EXITTREE" )
            ||  pN->_fAncestors
            ||  pN->_fTree))
    {
        ReportError("Second chance only implemented for descendents and ELEMENT_EXITTREE");
        goto Cleanup;
    }

    err = S_OK;

Cleanup:
    return (err == S_OK);
}

char *
CNotificationParser::NameOf(char * pchInput, char * pchOutput)
{
    char *  pch = pchOutput;
    int     fMakeUpper = 1;

    while (*pchInput)
    {
        if (*pchInput == '_')
        {
            fMakeUpper = 1;
        }
        else
        {
            *pchOutput++ = (fMakeUpper
                                ? (char)toupper(*pchInput)
                                : (char)tolower(*pchInput));
            fMakeUpper = 0;
        }

        pchInput++;
    }

    *pchOutput = '\0';
    return pch;
}

void
CNotificationParser::WriteArg(unsigned fFlag, char * pchArg, char * pchPad, int * pcArgs)
{
    if (fFlag)
    {
        if (*pcArgs)
            fprintf(_fpOutput, ",\n");

        fprintf(_fpOutput, "%s", pchPad);

        (*pcArgs)++;

        fprintf(_fpOutput, "%s", pchArg);
    }
}

void
CNotificationParser::WriteFlag(unsigned fFlag, char * pchFlag, int * pcFlags)
{
    char    ach[MAX_WORD];
    int     cch = strlen(pchFlag);

    if (fFlag)
    {
        fprintf(_fpOutput, (*pcFlags
                                ? " | "
                                : "   "));

        fprintf(_fpOutput, "%s", pchFlag);
        (*pcFlags)++;
    }
    else
    {
        strncpy(ach, achBlanks, cch);
        ach[cch] = '\0';
        fprintf(_fpOutput, "   ");
        fprintf(_fpOutput, "%s", ach);
    }
}

BOOL
CNotificationParser::ReadLine(char *pchBuf, int cchBuf, int *pcchRead)
{
    int cchRead;
    
    if (!fgets(pchBuf, cchBuf, _fpInput))
        return FALSE;

    cchRead = strlen(pchBuf);
    if (!cchRead)
        return FALSE;

    if (pcchRead)
        *pcchRead = cchRead;
        
    return TRUE;
}

inline BOOL
IsDelim(char ch)
{
    return (    ch == ' '
            ||  ch == '\t'
            ||  ch == '\r'
            ||  ch == '\n'
            ||  ch == ','
            ||  ch == ':'
            ||  ch == ';');
}

void
CNotificationParser::SkipSpace(char **ppch)
{
    char *pch = *ppch;
    while (*pch && IsDelim(*pch))
        pch++;
    *ppch = pch;
}


void
CNotificationParser::SkipNonspace(char **ppch)
{
    char *pch = *ppch;
    while (*pch && !IsDelim(*pch))
        pch++;
    *ppch = pch;
}

void
CNotificationParser::ChopComment(char *pch)
{
    while (*pch)
    {
        if (*pch == '/' && *(pch+1) == '/')
        {
            *pch = '\0';
            return;
        }
        pch++;
    }
}

BOOL
CNotificationParser::GetWord(char **ppch, char **ppchWord)
{
    SkipSpace(ppch);
    *ppchWord = *ppch;
    SkipNonspace(ppch);
    if (**ppch)
    {
        if (*ppch - *ppchWord > MAX_WORD)
            *ppch = *ppchWord + MAX_WORD - 1;
        **ppch = '\0';
        (*ppch)++;
    }

    return **ppchWord;
}

void
CNotificationParser::ReportError(const char * pchError, ...)
{
    char    ach[MAX_LINE];
    va_list ap;

    va_start(ap, pchError);
    vsprintf(ach, pchError, ap);
    va_end(ap);

    printf("%s(0) : error NF0000: %s\n", _pchInput, ach);
    if (_fpLog)
        fprintf(_fpLog, "%s(0) : error NF0000: %s\n", _pchInput, ach);
}

void 
CNotificationParser::CNotification::MakeSC( CNotification *pN ) 
{ 
    memcpy( this, pN, sizeof(CNotification) );

    strncat(_achType, "_2", MAX_WORD-1);

    _fSecondChanceAvail = FALSE;
    _fSecondChance = TRUE;
}

void 
CNotificationParser::CNotification::MarkFirstChance() 
{ 
    strncat(_achType, "_1", MAX_WORD-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\btools\tldiff\icomp.cxx ===
#include <assert.h>
#include <iostream.h>
#include "IComp.Hxx"

extern bool fgMethodAttribute;
extern bool fgMethodParameter;

bool CompareBuffer( char* pBuff1, char* pBuff2, unsigned long nLen);
bool CompareBufferNoCase( char* pBuff1, char* pBuff2, unsigned long nLen);
void WriteLine(HANDLE file, char* pBuff, int nLen);
void TokenizeAttributes( char* pBuf, unsigned long nCnt, CAutoArray<ATTRINFO>* pList );

extern unsigned long g_ulAppRetVal;
extern bool fgParamNames;
extern bool fgParamTypes;
extern bool fgParamNameCase;
extern bool fgParamTypeCase;

CCompareInterface::CCompareInterface( char* pCurBuf, 
                                      char* pRefBuf, 
                                      HANDLE fileDiff, 
                                      char* pszIntName, 
                                      BLOCK_TYPE blockType, 
                                      char* pszMethodAttr)
{
	_pCurBuf = pCurBuf;
	_pRefBuf = pRefBuf;
	_fileDiff = fileDiff;
	_pszIntName = pszIntName;
	_blockType = blockType;
    _pszMethodAttr = pszMethodAttr;

	_pCurList = new CAutoArray<LINEINFO>;
	_pRefList = new CAutoArray<LINEINFO>;


	CreateLineIndex(_pCurList, _pCurBuf);
	CreateLineIndex(_pRefList, _pRefBuf);

	_bFirstTime = true;
}

CCompareInterface::~CCompareInterface()
{
	delete _pCurList;
	delete _pRefList;
}

void CCompareInterface::FindAdditionsAndChanges( )
{
	long lIdx;
	long lTmp;
	LINEINFO lineCur;
	LINEINFO lineRef;

    bool bRetVal = false;
	
	//check for additions and alterations
	for ( lIdx = 0; lIdx< (int)_pCurList->Size(); lIdx++)
	{
		_pCurList->GetAt( lIdx, &lineCur );

		//get the real name of the method or property
		char* pszMethodName = new char[lineCur.ulParamStart-lineCur.ulMethodNameStart+1];

		for (lTmp=lineCur.ulMethodNameStart; lTmp<(long)lineCur.ulParamStart; lTmp++)
		{
			pszMethodName[lTmp-lineCur.ulMethodNameStart] = _pCurBuf[lTmp];
		}
		pszMethodName[lTmp-lineCur.ulMethodNameStart] = 0;

		lstrcpy( _szLogBuff, _pszIntName);
		lstrcat( _szLogBuff, "::" );
		lstrcat( _szLogBuff, pszMethodName );

		for ( lTmp=0; lTmp<_pRefList->Size(); lTmp++ )
		{
			_pRefList->GetAt( lTmp, &lineRef );
			
			//compare the names of two methods to find if they are comparable
			//in respect to other aspects of their declarations.
			if ((!lineRef.fUsed)&&
                ( CompareBuffer( pszMethodName, 
                                    &_pRefBuf[lineRef.ulMethodNameStart], 
                                    max( lineCur.ulParamStart-lineCur.ulMethodNameStart, lineRef.ulParamStart-lineRef.ulMethodNameStart) )))
			{
                // if the names are the same, now compare the return values. If they are not the same, then the method is
                // modified from its original version.
                if ( !CompareBuffer( &_pCurBuf[lineCur.ulNameStart], 
                                     &_pRefBuf[lineRef.ulNameStart], 
                                     max( lineCur.ulMethodNameStart-lineCur.ulNameStart, lineRef.ulMethodNameStart-lineRef.ulNameStart) ))
                {
                    bRetVal = true;
                }

				//compare attribute block 
				if (( fgMethodAttribute ) && 
                    ((lineCur.ulAttrEnd-lineCur.ulAttrStart != lineRef.ulAttrEnd-lineRef.ulAttrStart) || 
					 ( !CompareBuffer(	&_pCurBuf[lineCur.ulAttrStart], &_pRefBuf[lineRef.ulAttrStart], 							
					    				max(lineCur.ulAttrEnd-lineCur.ulAttrStart, lineRef.ulAttrEnd-lineRef.ulAttrStart))))  )
				{
                    // since we know the attributes have changed, analyze the type of change
                    CompareMethodAttributes( &lineRef, &lineCur );
				}

				//compare parameter block 
				if (( fgMethodParameter ) && 
                    ((lineCur.ulParamEnd-lineCur.ulParamStart != lineRef.ulParamEnd-lineRef.ulParamStart) ||
                     ( !CompareBuffer(	&_pCurBuf[lineCur.ulParamStart], &_pRefBuf[lineRef.ulParamStart], 
										max(lineCur.ulParamEnd-lineCur.ulParamStart, lineRef.ulParamEnd-lineRef.ulParamStart)))) )
				{
                    CompareMethodParameters( &lineRef, &lineCur );
				}

				//we have found the method that matches, move on to the next
				//method name on the current block.
				lineRef.fUsed = true;
				_pRefList->Set( lTmp, lineRef );
				break;
			}
		}

		//write the results that were found from this comparison, 
		//if this was a different line
		if ( bRetVal || (lTmp == _pRefList->Size()) )
		{
			char* pszBuff = new char[128];

            EnsureTitle( TRUE );

            if ( bRetVal )
            {
                lstrcpy( pszBuff, _szLogBuff );
                lstrcat( pszBuff, " - Return value or call type has changed " );
                WriteLine( _fileDiff, pszBuff, -1);
                bRetVal = false;
                g_ulAppRetVal |= CHANGE_RETVALCHANGE;
            }
	
			if (lTmp == _pRefList->Size())	//this is a new nethod
			{
				lstrcpy( pszBuff, _szLogBuff );
				lstrcat( pszBuff, " - Is a new method " );
				WriteLine(_fileDiff, pszBuff,-1);

				if ( _blockType== BLK_DISPINT )
					g_ulAppRetVal |= CHANGE_METHODONDISPINT;
				else
					g_ulAppRetVal |= CHANGE_METHODONINT;
			}
			delete [] pszBuff;
		}
		
		delete [] pszMethodName;
	}
}

//----------------------------------------------------------------------------
//  bMode == TRUE  --> Addition / Change
//----------------------------------------------------------------------------
void
CCompareInterface::EnsureTitle( BOOL bAddition )
{
    char szBuff[256];

    if ( _bFirstTime )
    {
        //write the header.
        if ( _blockType== BLK_DISPINT )
            lstrcpy( szBuff, "\nDispinterface " );
        else
            lstrcpy( szBuff, "\nInterface " );
        
        lstrcat( szBuff, _pszIntName );
        lstrcat( szBuff, "\n------------------------------------\n");
        if ( bAddition )
        {
            lstrcat( szBuff, "Additions / Changes:" );
        }
        
        WriteLine( _fileDiff, szBuff, -1);
        
        _bFirstTime = false;
    }
}
//
//	Walk through the unmarked elements of the reference block index. These are the
//	entries that do not exist in the current block.
//
void CCompareInterface::FindRemovals( )
{
	long lIdx;
	long lTmp;
	LINEINFO	lineRef;
	char* szBuff = new char[128];
	bool bFirstRemoval = true;

	for ( lIdx=0; lIdx< (int)_pRefList->Size(); lIdx++ )
	{
		//get the record
		_pRefList->GetAt( lIdx, &lineRef);

		//is the record marked ?
		if (!lineRef.fUsed)
		{
			//get the real name of the interface
			char* pszMethodName = new char[lineRef.ulParamStart-lineRef.ulMethodNameStart+1];
			int nIdx;
			
			for (lTmp=lineRef.ulMethodNameStart, nIdx=0; lTmp<(long)lineRef.ulParamStart; lTmp++, nIdx++)
			{
				pszMethodName[nIdx] = _pRefBuf[lTmp];
			}

            pszMethodName[nIdx] = 0;		//terminate the string

            // if this is the first removal, then add the word Removals
            EnsureTitle( FALSE );

			//write the header.
			if ( _blockType== BLK_DISPINT )
				g_ulAppRetVal |= CHANGE_REMOVEFROMDISPINT;
			else
				g_ulAppRetVal |= CHANGE_REMOVEFROMINT;

			if ( bFirstRemoval)
			{
				WriteLine( _fileDiff, "Removals : ", -1);
				bFirstRemoval = false;
			}

			lstrcpy( szBuff, _pszIntName);
			lstrcat( szBuff, "::");
			lstrcat( szBuff, pszMethodName);
			lstrcat( szBuff, " has been removed.");
			WriteLine( _fileDiff, szBuff, -1);

			delete [] pszMethodName;
		}
	}

	delete [] szBuff;
}

void CCompareInterface::CreateLineIndex( CAutoArray<LINEINFO>* pList, char* pBuf )
{
	LINEINFO lineinfo = {0};

	unsigned long ulIdx=0;
	unsigned long ulLastSpace = 0;
	char chSearch = '[';				//initially look for the opening attribute char.
	unsigned int uBrCnt = 0;
	unsigned int uParCnt = 0;

	//go until the end of the buffer, it is null terminated.
	while ( pBuf[ulIdx] != 0)
	{
		if ( pBuf[ulIdx] == chSearch )
		{
			//depending on what we were looking for, 
			//we can decide what to look for next.
			switch (chSearch)
			{
				case '[':
					uBrCnt++;
					if ( uBrCnt == 1 )
					{
						lineinfo.ulAttrStart = ulIdx;
						chSearch = ']';
					}
					break;

				case ']':
					uBrCnt --;
					if ( uBrCnt == 0 )
					{
						lineinfo.ulAttrEnd = ulIdx;
						lineinfo.ulNameStart = ulIdx+2;
						chSearch = '(';
					}
					break;

				case '(':
					uParCnt++;
					if (uParCnt==1)
					{
						lineinfo.ulNameEnd = ulIdx-1;
						lineinfo.ulParamStart = ulIdx;
						lineinfo.ulMethodNameStart = ulLastSpace+1;
						chSearch = ')';
					}
					break;

				case ')':
					uParCnt--;
					if ( uParCnt == 0 )
					{
						lineinfo.ulParamEnd = ulIdx;
						chSearch = '[';
						
						//completed the cycle, add this record to the list
						pList->Append(lineinfo);
					}
					break;
			}
		}
		else
		{
			switch ( pBuf[ulIdx] )
			{
				case '(':
					uParCnt++;
					break;

				case ')':
					uParCnt--;
					break;

				case '[':
					uBrCnt++;
					break;

				case ']':
					uBrCnt--;
					break;
	
				case ' ':
					ulLastSpace = ulIdx;
					break;
			}
		}

		ulIdx++;
	}
}

/*----------------------------------------------------------------------------

  ----------------------------------------------------------------------------*/
void 
CCompareInterface::CompareMethodAttributes( LINEINFO* pRef, 
                                            LINEINFO* pCur )
{
    long                    l, 
                            k;
    long                    curBase = (pCur->ulAttrStart)+1;
    long                    refBase = (pRef->ulAttrStart)+1;
    ATTRINFO                attrRef; 
    ATTRINFO                attrCur;

    CAutoArray<ATTRINFO>*   pCurList = new CAutoArray<ATTRINFO>;
	CAutoArray<ATTRINFO>*   pRefList = new CAutoArray<ATTRINFO>;

    TokenizeAttributes( &_pRefBuf[refBase], pRef->ulAttrEnd-refBase, pRefList );
    TokenizeAttributes( &_pCurBuf[curBase], pCur->ulAttrEnd-curBase, pCurList );

    //let's find the ones that are new
    for ( l=0; l < pCurList->Size(); l++ )      
    {
        pCurList->GetAt( l, &attrCur);

        for ( k=0; k < pRefList->Size(); k++ )
        {
            pRefList->GetAt( k, &attrRef );

            if ( (!attrRef.fUsed ) && 
                  CompareBuffer( &_pCurBuf[curBase + attrCur.ulAttrStart], 
                                &_pRefBuf[refBase + attrRef.ulAttrStart],
                                max( attrCur.ulAttrLength, attrRef.ulAttrLength)) )
            {
                // found the same attribute in the reference attributes, it is not a new
                // attribute
                attrRef.fUsed = true;
                pRefList->Set( k, attrRef );

                attrCur.fUsed = true;
                pCurList->Set( l, attrCur );
                break;
            }
        }
        
        if ( k == pRefList->Size() )
        {
            // this is a new attribute. 
            // if we find this attribute name in the list, then we are breaking the compat
            if ( IsAttributeBreaker( _pszMethodAttr,
                                        _pCurBuf+curBase+attrCur.ulAttrStart, 
                                        attrCur.ulAttrLength ) )
            {
                EnsureTitle(TRUE);
                WriteAttrChangeString( _pCurBuf, 
                                        curBase+attrCur.ulAttrStart, 
                                        attrCur.ulAttrLength, 
                                        "' attribute was added"); 
            }
        }
    }

    // Whatever is left in the reference array as not used are removals.
    for ( l=0; l < pRefList->Size(); l++ )      
    {
        pRefList->GetAt( l, &attrRef);

        if ( !attrRef.fUsed )
        {
            // if we find this attribute name in the list, then we are breaking the compat
            if ( IsAttributeBreaker( _pszMethodAttr, 
                                        _pRefBuf+refBase+attrRef.ulAttrStart, 
                                        attrRef.ulAttrLength ) )
            {
                // breaker attribute
                EnsureTitle(TRUE);
                WriteAttrChangeString( _pRefBuf, 
                                        refBase+attrRef.ulAttrStart, 
                                        attrRef.ulAttrLength, 
                                        "' attribute was removed");
            }
        }
    }

    delete pCurList;
    delete pRefList;
}

//----------------------------------------------------------------------------
// The attribute list contains the buffer that is read from the INI file.
// Each attribute name is a string that is terminated by a NULL character. At 
// the very end, after the last attribute, there is an additional NULL.
//----------------------------------------------------------------------------
BOOL 
CCompareInterface::IsAttributeBreaker( char * pszAttrList, char * pszAttr, unsigned long ulAttrLen )
{
    unsigned long   ulStrLen;
    unsigned long   ulIdx = 0;    // index to the big buffer.

    // until we reach the very end.
    // if we can not get into the loop below, it means that there are no 
    // attributes that are considered breaking
    while (pszAttrList[ulIdx] != NULL)
    {
        ulStrLen = lstrlen(&pszAttrList[ulIdx]);

        // if the lengths and the contents are the same, then this attribute
        // is a breaker attribute
        if ((ulStrLen == ulAttrLen) && 
             (CompareBuffer(&pszAttrList[ulIdx], pszAttr, ulStrLen)))
        {
            return TRUE;
        }

        // increment the index, to point to the next string in the buffer
        ulIdx += ulStrLen + 1;
    }

    // if we reach here, it means that we could not find the attribute in the list
    // this is NOT a breaker attribute
    return FALSE;
}

void 
CCompareInterface::WriteAttrChangeString(char* pBuf,
                                         unsigned long ulAttrStart, 
                                         unsigned long ulAttrLength, 
                                         char* szChangeType)
{
    unsigned long   k;
    char            szBuff[256];
    char *          pszAttrName = new char[ulAttrLength+1];

    //copy the attribute name into the buffer
    for (k = 0; k < ulAttrLength; k++)
        pszAttrName[k] = *(pBuf + ulAttrStart + k);

    pszAttrName[k] = 0; //terminate

    lstrcpy(szBuff, _szLogBuff);
    lstrcat(szBuff, " - '");
    lstrcat(szBuff, pszAttrName);
    lstrcat(szBuff, szChangeType);

    WriteLine(_fileDiff, szBuff, -1);
    g_ulAppRetVal |= CHANGE_ATTRCHANGE;
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
void 
CCompareInterface::CompareMethodParameters( LINEINFO* pRef, LINEINFO* pCur)
{
    long                    l;
    long                    k;
    long                    curBase = (pCur->ulParamStart)+1;
    long                    refBase = (pRef->ulParamStart)+1;

    PARAMINFO               paramRef;
    PARAMINFO               paramCur;

    CAutoArray<PARAMINFO>*  pCurList = NULL; 
	CAutoArray<PARAMINFO>*  pRefList = NULL; 

    bool                    bNameChange, 
                            bTypeChange,
                            bReplaced;
    char                    szBuff[512] = {0};
    char                    szType[64] = {0};
    char                    szName[64] = {0};


    pCurList = new CAutoArray<PARAMINFO>;
    pRefList = new CAutoArray<PARAMINFO>;

    assert( pCurList );
    assert( pRefList );

    // start by tokenizing the parameters
    TokenizeParameters( &_pRefBuf[refBase], pRef->ulParamEnd-refBase, pRefList);
    TokenizeParameters( &_pCurBuf[curBase], pCur->ulParamEnd-curBase, pCurList);

    // parameters have to match one to one.
    for ( l=0; l<pRefList->Size(); l++ )
    {
        bTypeChange = bNameChange = bReplaced = false;

        pCurList->GetAt( l, &paramCur);
        pRefList->GetAt( l, &paramRef);

        // is this parameter touched before, because of a replacement catch?
        // if that is the case we should only check if the reference parameter was replaced
        if ( paramCur.fUsed )
        {
            bTypeChange = bNameChange = true;
            goto ReplaceCheck;
        }

        // compare the types
        if ( fgParamTypes )
        {
            //
            // Only go through comparison if the type does not contain a _MIDL_ word in it.
            //
            char szTypeRef[64] = {0};
            lstrcpyn( szTypeRef, 
                        _pRefBuf+refBase+paramRef.ulTypeStart, 
                        max(63, paramRef.ulTypeLength));
            
            if ( !strstr(szTypeRef, "_MIDL_") )
            {
                // if the lengths are different bail out immediately, without text comparison.
                if ( paramRef.ulTypeLength == paramCur.ulTypeLength ) 
                {
                    //compare the contents, check if we want case sensitive or not.            
                    if ( fgParamTypeCase )
                        bTypeChange = !CompareBuffer(   _pRefBuf+refBase+paramRef.ulTypeStart, 
                                                        _pCurBuf+curBase+paramCur.ulTypeStart,
                                                        max( paramRef.ulTypeLength, paramCur.ulTypeLength) );
                    else
                        bTypeChange = !CompareBufferNoCase( _pRefBuf+refBase+paramRef.ulTypeStart, 
                                                            _pCurBuf+curBase+paramCur.ulTypeStart,
                                                            max( paramRef.ulTypeLength, paramCur.ulTypeLength) );
                }
                else 
                    bTypeChange = true;
            }
            else
            {
                // if one of the types contains a _MIDL_, then the other MUST too.
                char szTypeCur[64] = {0};
                lstrcpyn( szTypeCur, 
                            _pCurBuf+curBase+paramCur.ulTypeStart, 
                            max(63, paramCur.ulTypeLength));

                // if the string does NOT contain _MIDL_ than there was a change.
                if ( !strstr(szTypeCur, "_MIDL_") )
                {
                    bTypeChange = true;
                }
            }
        }


        if ( fgParamNames )
        {
            char szNameRef[64] = {0};
            
            //
            // If the name of one parameter contains a _MIDL_ keyword, then only make sure the
            // other name contains the _MIDL_ too. No need to match strings.
            //
            lstrcpyn( szNameRef, _pRefBuf+refBase+paramRef.ulNameStart, max(63, paramRef.ulNameLength));

            if (!strstr(szNameRef, "_MIDL_"))
            {
                // if the lengths are different bail out immediately, without text comparison.
                if ( paramRef.ulNameLength == paramCur.ulNameLength ) 
                {
                    //compare the contents, check if we want case sensitive or not.            
                    if ( fgParamNameCase )
                        bNameChange = !CompareBuffer(   _pRefBuf+refBase+paramRef.ulNameStart, 
                                                        _pCurBuf+curBase+paramCur.ulNameStart,
                                                        max( paramRef.ulNameLength, paramCur.ulNameLength) );
                    else
                        bNameChange = !CompareBuffer(   _pRefBuf+refBase+paramRef.ulNameStart, 
                                                        _pCurBuf+curBase+paramCur.ulNameStart,
                                                        max( paramRef.ulNameLength, paramCur.ulNameLength) );
                }
                else 
                    bNameChange = true;
            }
            else
            {
                char szNameCur[64] = {0};

                // only make sure the current name also has the _MIDL_ keyword.
                lstrcpyn( szNameCur, _pCurBuf+curBase+paramCur.ulNameStart, max(63, paramCur.ulNameLength));

                if (!strstr( szNameCur, "_MIDL_"))
                {
                    bNameChange = true;
                }
            }
        }

ReplaceCheck:
        // if there was a change in the parameter, find out if this parameter is moved to another location
        // in the parameter list. We look for an exact match in this case, since this is only additional 
        // information
        if ( bNameChange || bTypeChange )
        {
            PARAMINFO   paramTmp;

            for ( k=0; k< pCurList->Size(); k++ )
            {
                pCurList->GetAt( k, &paramTmp );

                if ( ( !paramTmp.fUsed ) && 
                     ( paramTmp.ulParamLength == paramCur.ulParamLength ) &&
                     ( CompareBuffer( _pRefBuf+refBase+paramRef.ulTypeStart, 
                                        _pCurBuf+curBase+paramTmp.ulTypeStart, 
                                            paramTmp.ulParamLength) ) )
                {
                    // we have found the parameter at another location.
                    bReplaced = true;

                    // we will only report the replacement, to simplify
                    bTypeChange = false;
                    bNameChange = false;

                    // mark the parameter in the current list as touched, so that 
                    // whatever parameter we check in the reference list does not get
                    // processed against this. ( perf. )
                    paramTmp.fUsed = true;
                    pCurList->Set( k, paramTmp );
                }
            }
        }
    
        // if we found the parameter  at the same location 
        if ( bReplaced || bNameChange || bTypeChange )
        {
            EnsureTitle(TRUE);

            g_ulAppRetVal |= CHANGE_PARAMCHANGE;

            // we copy the type and the name. The lengths are +1 since the function requires
            // us to calculate the NULL character too.

            lstrcpyn( szType, _pRefBuf+refBase+paramRef.ulTypeStart, paramRef.ulTypeLength+1 );

            if ( paramRef.ulNameStart )
                lstrcpyn( szName, _pRefBuf+refBase+paramRef.ulNameStart, paramRef.ulNameLength+1 );

            // fill the string with ' - Parameter xx', so that we can add the change type
            lstrcpy( szBuff, _szLogBuff);
            lstrcat( szBuff, " - Parameter " );
            lstrcat( szBuff, szType );
            lstrcat( szBuff, " ");
            lstrcat( szBuff, szName );

            // if replaced, then name and type change flags are false.
            if ( bReplaced  )
            {
                // output replacement information
                lstrcat( szBuff, " has been replaced" );
            }
            else 
            {
                // was this parameter removed
                if ( bNameChange && bTypeChange )
                {
                    // output information that shows the name change
                    lstrcat( szBuff, " has been removed");
                }
                else
                {
                    if ( bNameChange )
                    {
                        // output information that shows the name change
                        lstrcat( szBuff, " name has been modified");

                        // for name only changes, mark the parameter as used.
                        paramCur.fUsed = true;
                        pCurList->Set( l, paramCur );
                    }
            
                    if ( bTypeChange )
                    {
                        // output information that shows the type change.
                        lstrcat( szBuff, " type has been modified");
                    }
                }
            }

            WriteLine(_fileDiff, szBuff, -1);
        }
        else
        {
            // mark the parameter, everything is OK, move on.
            paramCur.fUsed = true;
            pCurList->Set( l, paramCur );
        }
    }

    // find the parameters that were added.
    for ( l=0; l<pCurList->Size(); l++ )
    {
        pCurList->GetAt( l, &paramCur);

        // if this parameter was not used, then it means that it was added.
        if ( !paramCur.fUsed )
        {
            EnsureTitle(TRUE);

            g_ulAppRetVal |= CHANGE_PARAMCHANGE;

            // copy the parameter name as a whole
            lstrcpyn( szName, _pCurBuf+curBase+paramCur.ulTypeStart, paramCur.ulParamLength+1 );

            // fill the string with ' - Parameter xx', so that we can add the change type
            lstrcpy( szBuff, _szLogBuff);
            lstrcat( szBuff, " - Parameter " );
            lstrcat( szBuff, szName );
            lstrcat( szBuff, " was added");
            WriteLine( _fileDiff, szBuff, -1);

        }
    }

    delete pCurList;
    delete pRefList;
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
void 
CCompareInterface::TokenizeParameters(  char* pBuf, 
                                        unsigned long nCnt, 
                                        CAutoArray<PARAMINFO>* pList )
{
    unsigned long   i,j;
    PARAMINFO       paramInfo;
    bool            bInBracket = false;

    paramInfo.ulTypeStart = 0;

    for( i=0; i<=nCnt ; i++ )
    {
        // since we are coming from left, and going right, we will first see the 
        // opening and then the closing bracket
        if ( pBuf[i] == '[' ) 
            bInBracket = true;
        if ( pBuf[i] == ']' )
            bInBracket = false;

        // if we reached a comma that was not inside a bracket, or reached the end
        // and the end is an opening parenthesis
        if ( ((pBuf[i] == ',') && !bInBracket ) || ( i == nCnt ) )
        {
            paramInfo.ulParamLength = i - paramInfo.ulTypeStart;
            paramInfo.fUsed = false;

            // digest the type and name here ! ! !
            for ( j = paramInfo.ulTypeStart+paramInfo.ulParamLength-1; j > 0 ; j-- )
            {
                // go from the end of the parameter, towards the beginning, 
                // searching for a space character, or the beginning of the parameter block
                if ( *(pBuf + j) == ' ') 
                {
                    paramInfo.ulNameStart = j + 1;
                    paramInfo.ulTypeLength = j - paramInfo.ulTypeStart;
                    paramInfo.ulNameLength = paramInfo.ulTypeStart + paramInfo.ulParamLength - paramInfo.ulNameStart;
                    break;
                }
            }

            // we could not find a parameter when we parsed through, it means a void..
            // double check for void 
            if (( j==0 ) && ( *pBuf == 'v' ) && (*(pBuf+1) == 'o'))
            {
                paramInfo.ulTypeStart = 0;
                paramInfo.ulTypeLength = 4;
                paramInfo.ulParamLength = 4;
                paramInfo.ulNameStart = 0;
                paramInfo.ulNameLength = 0;

                pList->Append( paramInfo );
            }
            else
            {
                // we should never ever reach zero.
                if ( j==0 )
                    assert( false );

                pList->Append( paramInfo );
    
                // skip over the comma
                i++;

                // the name starts next to the space
                paramInfo.ulTypeStart = i+1;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\btools\pdlparse\parser.cxx ===
extern BOOL gbWin16Mode;

UINT CPDLParser::CountTags ( TokenDescriptor *tokdesc )
{
    UINT uCount;
    TagDescriptor *pTagDescriptor;
    for ( uCount = 0, pTagDescriptor = tokdesc -> Tags ; pTagDescriptor -> szTag != NULL;
        uCount++, pTagDescriptor++ );
    return uCount;
}

CPDLParser::CPDLParser()
{
    fpHComPlusFile = NULL;
    fpCComPlusFile = NULL;
    fpHDLFile = NULL;
    fpHeaderFile = NULL;
    fpIDLFile = NULL;
    fpLOGFile = NULL;
    fpHTMFile = NULL;
    fpHTMIndexFile = NULL;
    fpDISPIDFile = NULL;
    fpMaxLenFile = NULL;
    pRuntimeList = new CTokenList;
    pDynamicTypeList = new CTokenList;
    pDynamicEventTypeList = new CTokenList;
    Init();
}
                  

void
CPDLParser::SplitTag ( char *pStr, int nLen, char **pTag, int *pnTagLen,
    char **pValue, int *pnValueLen )
{
    *pTag = pStr;
    for ( *pnTagLen = 0 ; *pnTagLen < nLen ; pStr++, (*pnTagLen)++ )
    {
        if ( *pStr == ':' )
        {
            *pValue = pStr + 1;
            *pnValueLen = nLen - *pnTagLen -1;
            return;
        }
    }
    *pnValueLen = 0;
}



BOOL
CPDLParser::LookupToken ( LPCSTR pTokenName, int nTokenLen,
    TokenDescriptor **ppTokenDescriptor, DESCRIPTOR_TYPE *pnTokenDes )
{
    INT i;
    for ( i = 0 ;
        i < NUM_DESCRIPTOR_TYPES ; i++ )
    {
        if (strlen(AllDescriptors[i]->szTokenName) == (UINT)nTokenLen &&
            !_strnicmp(AllDescriptors[i]->szTokenName, pTokenName, nTokenLen))
        {
            *ppTokenDescriptor = AllDescriptors [ i ];
            *pnTokenDes = (DESCRIPTOR_TYPE)i;
            return TRUE;
        }
    }
    return FALSE;
}

BOOL CPDLParser::GetElem ( char **pStr,
                          char **pElem,
                          int *pnLen,
                          BOOL fBreakOnOpenParenthesis, /* = FALSE */
                          BOOL fBreakOnCloseParenthesis, /* = FALSE */
                          BOOL fBreakOnCommas /* = FALSE */ )
{
    *pnLen = 0;

    while ( isspace ( **pStr ) )
    {
        (*pStr)++;
    }
    *pElem = *pStr;
    if (( fBreakOnOpenParenthesis && **pStr == ')' ) ||
        ( fBreakOnCloseParenthesis &&  **pStr == '('  ) ||
        (fBreakOnCommas &&  **pStr == ',' ))
    {
        (*pnLen)++;
        (*pStr)++;
        goto Cleanup;
    }
    while ( **pStr && !isspace ( **pStr ))
    {
        if (( fBreakOnOpenParenthesis && **pStr == ')' ) ||
            ( fBreakOnCloseParenthesis &&  **pStr == '('  ) ||
            (fBreakOnCommas &&  **pStr == ',' ))
        {
            // Break but leave the pStr pointing at the bracket - we'll pick it up in the
            // next call
            break;
        }

        // Convert curly braces to parens

        if (**pStr == '{')
            **pStr = '(';
        else if (**pStr == '}')
            **pStr = ')';

        (*pnLen)++;
        (*pStr)++;
    }
Cleanup:
    return *pnLen == 0 ? FALSE : TRUE;
}

BOOL CPDLParser::ParseInputFile ( BOOL fDebugging )
{
    BOOL fReturn = TRUE;
    DESCRIPTOR_TYPE nThisDescriptor;
    char szLineBuffer [ MAX_LINE_LEN+1 ];
    char szErrorText [ MAX_LINE_LEN+1 ];
    char *pStr = szLineBuffer;
    char *pElem; int nElemLen;
    TokenDescriptor *pThisDescriptor;
    Token *pNewToken;
    Token *pParentToken = NULL;
    BOOL fGotParentToken = FALSE;
    CString szType;

    fprintf ( fpLOGFile, "Parsing input file\n" );

    for(;;)
    {
        if ( !GetStdInLine ( szLineBuffer, sizeof ( szLineBuffer  ) ) )
            break;

        pStr = szLineBuffer;

        fprintf ( fpLOGFile, "Read Line:%s\n", szLineBuffer );
        // Get the type e..g. enum, eval etc.
        if ( !GetElem ( &pStr, &pElem, &nElemLen ) )
        {
            // Couldn't get the name
            fprintf ( fpLOGFile, "Skipping\n" );
            continue;
        }


        if ( !LookupToken ( pElem, nElemLen, &pThisDescriptor, &nThisDescriptor ) )
        {
            fprintf ( fpLOGFile, "Unknown token\n" );
            continue;
        }

        fprintf ( fpLOGFile, "Processing a %s declaration\n",
            (LPCSTR)AllDescriptors [ nThisDescriptor ] -> szTokenName );

        // If it's a child token and we haven't got a parent
        if ( !pThisDescriptor->fIsParentToken &&
            !fGotParentToken )
        {
            ReportError ( "Child Token Without Parent\n" );
            goto error;
        }

        if ( pThisDescriptor->fIsParentToken )
        {
            fGotParentToken = TRUE;
        }


        INT nTag;
        char *pTag; char *pValue;
        int nTagLen; int nValueLen;
        BOOL fVarArg = FALSE;

        if ( nThisDescriptor == TYPE_METHOD )
        {
            // Look for optional vararg first

            if ( !GetElem ( &pStr, &pElem, &nElemLen ) )
            {
                // Couldn't get the return type
                continue;
            }

            if ( ! ( pNewToken = pParentToken -> AddChildToken ( nThisDescriptor ) ) )
            {
                ReportError ( "Memory Allocation Error\n" );
                goto error;
            }

            if ( !pNewToken->TagValues.AddTag ( METHOD_RETURNTYPE, pElem, nElemLen ) )
            {
                ReportError ( "Memory Allocation Error\n" );
                goto error;
            }

            // Name is next
            if ( !GetElem ( &pStr, &pElem, &nElemLen ) )
            {
                // Couldn't get the name
                continue;
            }

            if ( !pNewToken->TagValues.AddTag ( METHOD_NAME, pElem, nElemLen ) )
            {
                ReportError ( "Memory Allocation Error\n" );
                goto error;
            }

            // Methods need special handling due to the parameter list
            // Put all tokens before the "(" in the TagValues
            // Treat each arg in the param list as a unique token and add
            // to the pArgList for this token
            // Put all the tokens after the ")" in the TagValues
            // We allow either a comma-seperated arg list, but if we
            // don't get commas we break the arg intelligently
            //
            UINT bInParams = FALSE;
            BOOL bCreatedArgToken = FALSE;

            Token *pCurrentToken;

            TokenDescriptor *pDescriptor = pThisDescriptor;
            pCurrentToken = pNewToken;
            fVarArg = FALSE;

            // Set the fBreakOnParenthesis Flag to make parenthis stop GetElem
            while ( GetElem ( &pStr, &pElem, &nElemLen, TRUE, TRUE, TRUE ) )
            {
                if ( nElemLen == 1 && *pElem == '(' )
                {
                    if ( bInParams )
                    {
                        sprintf ( szErrorText, "Syntax Error %s On %s\n", pStr, szLineBuffer );
                        ReportError ( szErrorText );
                        goto error;
                    }
                    bInParams = TRUE;
                    // Switch to method arg descriptor
                    pDescriptor = &MethodArgDescriptor;
                }
                else if ( nElemLen == 1 && *pElem == ')' )
                {
                    if ( !bInParams )
                    {
                        sprintf ( szErrorText, "Syntax Error %s On %s\n", pStr, szLineBuffer );
                        ReportError ( szErrorText );
                        goto error;
                    }
                    bInParams = FALSE;
                    // Switch back to method descriptor
                    pDescriptor = pThisDescriptor;
                    pCurrentToken = pNewToken;
                }
                else if ( nElemLen == 1 && *pElem == ',' )
                {
                    // Reset flag so new arg token gets created for next arg
                    bCreatedArgToken = FALSE;
                }
                else
                {

                    // Split out the prefix:value
                    SplitTag ( pElem, nElemLen, &pTag, &nTagLen,
                        &pValue, &nValueLen );

                    // Match the tag
                    if ( !pDescriptor->LookupTagName ( pTag, nTagLen, &nTag ) )
                    {
                        pTag [ nTagLen ] = '\0';
                        sprintf ( szErrorText, "Unknown tag: %s On %s\n", pTag, szLineBuffer );
                        ReportError ( szErrorText );
                        goto error;
                    }

                    // If we've already got an entry for this tag, and we've seen
                    // at least the arg tag, start a new arg
                    if ( bInParams && pCurrentToken -> IsSet ( METHODARG_ARGNAME ) &&
                        ( nTag == METHODARG_IN || nTag == METHODARG_OUT ) &&
                        ( pCurrentToken -> IsSet ( METHODARG_IN ) ||
                        pCurrentToken -> IsSet ( METHODARG_IN ) ) )
                    {
                        // Start a new arg
                        bCreatedArgToken = FALSE;
                    }
                    if ( bInParams && bCreatedArgToken == FALSE )
                    {
                        // Create the arg list if needed
                        pCurrentToken = pNewToken -> AddChildToken ( TYPE_METHOD_ARG );
                        if ( pCurrentToken == NULL )
                        {
                            ReportError ( "Memory allocation error\n" );
                            goto error;
                        }
                        bCreatedArgToken = TRUE;
                    }

                    // Add the tag either to the main method token array or to the current
                    // arg 's array
                    if ( !pCurrentToken->TagValues.AddTag ( nTag, pValue, nValueLen ) )
                    {
                        ReportError ( "Memory allocation error\n" );
                        goto error;
                    }

                    // Last argument a SAFEARRAY, if so then vararg
                    fVarArg = (strncmp(pValue, "SAFEARRAY(VARIANT)", 18) == 0);
                }

                // method is a vararg because last parameter is a safearray.
                if ( fVarArg && !pNewToken->TagValues.AddTag ( METHOD_VARARG, "vararg", 6 ) )
                {
                    ReportError ( "Memory allocation error\n" );
                    goto error;
                }
            }
        }
        else if ( nThisDescriptor == TYPE_REFPROP ||  nThisDescriptor == TYPE_REFMETHOD )
        {
            // Now get the Class::Name & split it out
            if ( !GetElem ( &pStr, &pElem, &nElemLen ) )
            {
                // Couldn't get the name
                continue;
            }

            // Split out the prefix:value
            SplitTag ( pElem, nElemLen, &pTag, &nTagLen,
                &pValue, &nValueLen );

            pNewToken = pParentToken -> AddChildToken ( nThisDescriptor );

            if ( pNewToken == NULL )
            {
                ReportError ( "Memory Allocation Error\n" );
                goto error;
            }

            if ( !pNewToken->TagValues.AddTag (
                (nThisDescriptor == TYPE_REFPROP) ? (INT)REFPROP_CLASSNAME : (INT)REFMETHOD_CLASSNAME,
                pTag, nTagLen ) )
            {
                ReportError ( "Memory Allocation Error\n" );
                goto error;
            }
            if ( !pNewToken->TagValues.AddTag (
                nThisDescriptor == TYPE_REFPROP ? (INT)REFPROP_PROPERTYNAME : (INT)REFMETHOD_METHODNAME,
                pValue, nValueLen ) )
            {
                ReportError ( "Memory Allocation Error\n" );
                goto error;
            }

        }
        else
        {
            // Now get the name
            if ( !GetElem ( &pStr, &pElem, &nElemLen ) )
            {
                // Couldn't get the name
                continue;
            }

            // If it's a child token, add it to the runtime list, else add it as a child
            // of the current parent
            if ( pThisDescriptor->fIsParentToken )
            {
                pNewToken = pRuntimeList -> AddNewToken ( nThisDescriptor );
                pParentToken = pNewToken;
            }
            else
            {
                pNewToken = pParentToken -> AddChildToken ( nThisDescriptor );
            }

            if ( pNewToken == NULL )
            {
                ReportError ( "Memory Allocation Error\n" );
                goto error;
            }

            // First tag is always the name
            if ( !pNewToken->TagValues.AddTag ( NAME_TAG, pElem, nElemLen ) )
            {
                ReportError ( "Memory Allocation Error\n" );
                goto error;
            }

            // Split out all the token:value pairs
            while ( GetElem ( &pStr, &pElem, &nElemLen ) )
            {
                // Split out the prefix:value
                SplitTag ( pElem, nElemLen, &pTag, &nTagLen,
                    &pValue, &nValueLen );

                // Match the tag
                if ( !pThisDescriptor->LookupTagName ( pTag, nTagLen, &nTag ) )
                {
                    pTag [ nTagLen ] = '\0';
                    sprintf ( szErrorText, "Unknown tag: %s On %s\n", pTag, szLineBuffer );
                    ReportError ( szErrorText );
                    goto error;
                }

                if ( !pNewToken->TagValues.AddTag ( nTag, pValue, nValueLen ) )
                {
                    ReportError ( "Memory Allocation Error\n" );
                    goto error;
                }
            }
        }
        // Perform any cleanup
        switch ( nThisDescriptor )
        {
        case TYPE_EVAL:
            // For enums we calculate and store in the token the enum mask
            // We also number the enum values sequentialy
            pNewToken -> CalculateEnumMask ( pParentToken );
            break;

        case TYPE_ENUM:
            // Add data types to the dynamic type array
            szType = pNewToken -> GetTagValue ( ENUM_NAME );
            AddType ( szType, "Enum" );
            AddEventType ( szType, "VTS_I4" );
            szType += "*";
            AddEventType ( szType, "VTS_PI4" );
            break;

        case TYPE_CLASS:
        case TYPE_INTERFACE:
        case TYPE_EVENT:
            szType = pNewToken -> GetTagValue ( NAME_TAG );
            szType += "*";
            AddType ( szType, "object" );
            AddEventType ( szType, "VTS_DISPATCH" );
            szType += "*";
            AddType ( szType, "object" );
            AddEventType ( szType, "VTS_DISPATCH" );
            break;
            
        }
    }

    // Add an IUnknown to make implicit ref's match up
    pNewToken = pRuntimeList -> AddNewToken ( TYPE_INTERFACE );
    pNewToken->TagValues.AddTag ( INTERFACE_NAME, "IUnknown", -1 );

    // Add an IDispatch to make implicit ref's match up
    pNewToken = pRuntimeList -> AddNewToken ( TYPE_INTERFACE );
    pNewToken->TagValues.AddTag ( INTERFACE_NAME, "IDispatch", -1 );

    pNewToken = pRuntimeList -> AddNewToken ( TYPE_EVENT );
    pNewToken->TagValues.AddTag ( EVENT_NAME, "IDispatch", -1 );

    // Patch up the refprops & refmethods
    if ( !PatchInterfaceRefTypes() )
    {
        goto error;
    }

    // Patch Properties that are of object type
    if ( !PatchPropertyTypes() )
    {
        goto error;
    }

    if ( !PatchInterfaces() )
    {
        goto error;
    }

    goto cleanup;

error:
    fReturn = FALSE;

cleanup:
    return fReturn;
}


BOOL CPDLParser::PatchInterfaceRefTypes ( void )
{
    CTokenListWalker WholeTree ( pRuntimeList );
    Token *pChildToken;
    Token *pInterfaceToken;
    CString szClassName;

    // For each RefProp or Refmethod, we replace the arg list with a copy of the referenced property/method
    // and change the type of the ref'd item appropriatly
    while ( pInterfaceToken = WholeTree.GetNext( TYPE_INTERFACE ) )
    {
        CTokenListWalker ChildList ( pInterfaceToken );
        while ( pChildToken = ChildList.GetNext() )
        {
            if ( pChildToken -> GetType() == TYPE_REFPROP )
            {
                szClassName = pChildToken -> GetTagValue ( REFPROP_CLASSNAME );

                if ( !CloneToken ( pChildToken, TYPE_PROPERTY,
                    REFPROP_CLASSNAME, REFPROP_PROPERTYNAME ) )
                {
                    char szErrorText [ MAX_LINE_LEN+1 ];

                    sprintf ( szErrorText, "Interface %s Invalid RefProp %s:%s\n" ,
                        pInterfaceToken -> GetTagValue ( INTERFACE_NAME ),
                        pChildToken -> GetTagValue ( REFPROP_CLASSNAME ),
                        pChildToken -> GetTagValue ( REFPROP_PROPERTYNAME ) );
                    ReportError ( szErrorText );

                    return FALSE;
                }

                // Remember the class that was refprop'd.
                pChildToken -> AddTag ( PROPERTY_REFDTOCLASS, (LPCSTR)szClassName );
            }
            else if ( pChildToken -> GetType() == TYPE_REFMETHOD )
            {
                szClassName = pChildToken -> GetTagValue ( REFMETHOD_CLASSNAME );

                if ( !CloneToken ( pChildToken, TYPE_METHOD,
                    REFMETHOD_CLASSNAME, REFMETHOD_METHODNAME ) )
                {
                    char szErrorText [ MAX_LINE_LEN+1 ];

                    sprintf ( szErrorText, "Interface %s Invalid RefMethod %s:%s\n" ,
                        pInterfaceToken -> GetTagValue ( INTERFACE_NAME ),
                        pChildToken -> GetTagValue ( REFMETHOD_CLASSNAME ),
                        pChildToken -> GetTagValue ( REFMETHOD_METHODNAME ) );
                    ReportError ( szErrorText );

                    return FALSE;
                }

                // Remember the class that was refprop'd.
                pChildToken -> AddTag ( METHOD_REFDTOCLASS, (LPCSTR)szClassName );
            }
        }
    }
    return TRUE;
}


BOOL CPDLParser::CloneToken ( Token *pChildToken, DESCRIPTOR_TYPE Type, INT nClassName, INT nTagName )
{
    CTokenListWalker SubTree ( pRuntimeList );
    Token *pRefdClassToken;
    Token *pRefdChild;

    pRefdClassToken = SubTree.GetNext( TYPE_CLASS, pChildToken -> GetTagValue ( nClassName ) );
    if ( pRefdClassToken == NULL )
    {
        // Couldn't find the refd class
        return FALSE;
    }
    // Found the refd class, find the refd property
    CTokenListWalker RefdChildList ( pRefdClassToken );
    pRefdChild = RefdChildList.GetNext ( Type,
        pChildToken -> GetTagValue ( nTagName ) );
    if ( pRefdChild == NULL )
    {
        // Couldn't find the refd property
        return FALSE;
    }
    else
    {
        pChildToken -> Clone ( pRefdChild );
    }
    return TRUE;
}



BOOL CPDLParser::GetTypeDetails ( char *szTypeName, CString& szHandler, CString &szFnPrefix,
    StorageType *pStorageType /* = NULL */ )
{
    if ( !LookupType ( szTypeName, szHandler, szFnPrefix, pStorageType ) )
        return FALSE;
    return TRUE;
}

BOOL CPDLParser::IsSpecialProperty(Token *pClassToken)
{
    CString szInterf;
    Token *pInterf;

    szInterf = pClassToken->GetTagValue(CLASS_INTERFACE);
    pInterf = FindInterface(szInterf);
    if (pInterf)
        return (PrimaryTearoff(pInterf) || pInterf->IsSet(INTERFACE_ABSTRACT));
    else
        return TRUE;
}

BOOL CPDLParser::GeneratePropMethodImplementation ( void )
{
    Token *pClassToken;
    Token *pChildToken;
    CString szFnPrefix;
    CString szHandler;
    CString szOffsetOf;
    CString szAType;
    CString szHandlerArgs;
    char szErrorText [ MAX_LINE_LEN+1 ];

    // Only generate def's for this file
    CTokenListWalker TokenList ( pRuntimeList, _pszPDLFileName );

    // Generate propdescs for every property token in every class ( in this file )
    while ( pClassToken = TokenList.GetNext( TYPE_CLASS ) )
    {
        if (!IsSpecialProperty(pClassToken))
        {
            fprintf ( fpHDLFile, "\n//    Property get/set method implementation for class %s\n", (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ) );
            fprintf ( fpHDLFile, "\n" );

            CTokenListWalker ChildList ( pClassToken );
            while ( pChildToken = ChildList.GetNext() )
            {
                if ( pChildToken->nType == TYPE_METHOD ||
                    pChildToken->nType == TYPE_IMPLEMENTS ||
                    pChildToken -> IsSet ( PROPERTY_ABSTRACT ) ||
                    pChildToken -> IsSet ( PROPERTY_BASEIMPLEMENTATION ) )
                {
                    continue;
                }

                // If propdesc for nameOnly then we wont need a handler for this property
                // another property that matches this will do the handling.
                if ( _stricmp(pChildToken->GetTagValue(PROPERTY_NOPROPDESC), "nameonly") == 0 )
                    continue;

                if ( !GetTypeDetails ( pChildToken->GetTagValue ( PROPERTY_TYPE ),
                    szHandler, szFnPrefix ) )
                {
                    sprintf ( szErrorText ,"Invalid Type:%s in Class:%s Property:%s\n",
                        (LPCSTR)pChildToken->GetTagValue ( PROPERTY_TYPE ),
                        (LPCSTR)pClassToken->GetTagValue(CLASS_NAME),
                        (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ) );
                    ReportError ( szErrorText );
                    return FALSE;
                }

                if ( pChildToken -> IsSet ( PROPERTY_CAA ) )
                {
                    szOffsetOf = "(GetAttrArray())";
                }
                else
                {
                    szOffsetOf = "(this)";
                }
                szAType = pChildToken->GetTagValue ( PROPERTY_ATYPE );
                // Generate set implementation
                if ( pChildToken -> IsSet ( PROPERTY_SET ) )
                {
                    szHandlerArgs = "HANDLEPROP_SET | HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16)";
                    GenerateMethodImp ( pClassToken, pChildToken, TRUE,
                        szHandler, szHandlerArgs, szOffsetOf, szAType );
                }
                // Generate Get implementation
                if ( pChildToken -> IsSet ( PROPERTY_GET )  )
                {
                    szHandlerArgs = "HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16)";
                    GenerateMethodImp ( pClassToken, pChildToken, FALSE,
                        szHandler, szHandlerArgs, szOffsetOf, szAType );
                }
            }
        }

        fprintf ( fpHDLFile, "\n" );

        // Whip thru all tearoffs.
        Token  *pLastTearoff = NULL;
        BOOL    fMostDerivedOnly;
        while ((pLastTearoff = NextTearoff((LPCSTR)pClassToken->GetTagValue(CLASS_NAME), pLastTearoff)))
        {
            LPSTR       szInterface = (LPSTR)pLastTearoff->GetTagValue(TEAROFF_INTERFACE);

            // If the tearoff is the primary interface of the coclass then we'll
            // not stack the derived interfaces but generate separate 
            fMostDerivedOnly = (_stricmp(szInterface, (LPSTR)pClassToken->GetTagValue(CLASS_INTERFACE)) == 0 &&
                                _stricmp(szInterface, "IHTMLDocument2"));

            if ( !GenerateTearoffTable(pClassToken, pLastTearoff, szInterface, fMostDerivedOnly))
                return FALSE;
        }
    }
    return TRUE;
}


BOOL CPDLParser::FindTearoffMethod(Token *pTearoff, LPCSTR pszTearoffMethod, LPSTR pszUseTearoff)
{
    Token *pChildToken;

    CTokenListWalker ChildList(pTearoff);
    while (pChildToken = ChildList.GetNext())
    {
        if (pChildToken->GetType() == TYPE_TEAROFFMETHOD)
        {
            if (strcmp((LPCSTR)pChildToken->GetTagValue(TEAROFFMETHOD_NAME),
                       pszTearoffMethod) == 0)
            {
                // Check if there is a class name in the method, if it is then
                // extract it explicity.
              	strcpy(pszUseTearoff, (LPCSTR)pChildToken->GetTagValue(TEAROFFMETHOD_MAPTO));

                return TRUE;
            }
        }
    }

    // Call the super:: implementation except for the primary tearoff the base
    // implementation of each method if not specified is the current class.
    strcpy(pszUseTearoff, pTearoff->IsSet(TEAROFF_BASEIMPL) ?
                            (LPCSTR)pTearoff->GetTagValue(TEAROFF_BASEIMPL) : "");
    strcat(pszUseTearoff, pszTearoffMethod);

    return FALSE;
}

// We exploit the Linker's Case insensitive feature to do Tearoffs in Win16.
// This function takes a Tearoff Method and generates a name that is different
// in case from the Real Tearoff Method. We have to follow certain rules so that
// the compiler doesn't complain about undefined symbols and the linker puts in
// the correct address anyhow.
void GenerateWin16TearoffName(LPSTR szWin16Name, LPSTR pszTearoffMethod, LPSTR szClassName = NULL)
{
    strcpy(szWin16Name, pszTearoffMethod);
    // if the Tearoff has a put_ or get_ prefix then we capitalize the PUT_
    // or GET_
    if ( !strncmp(szWin16Name, "put_", 4) )
    {
        strncpy(szWin16Name, "PUT_", 4);
        return;
    }
    if ( !strncmp(szWin16Name, "get_", 4) )
    {
        strncpy(szWin16Name, "GET_", 4);
        return;
    }

    // Check if there is a class name in the method, if it is super
    // then let it be else extract that and copy it to szClassName.
    char *p = strstr(szWin16Name, "::");

    if ( p && strncmp(szWin16Name, "super::",7) )
    {
        strcpy(pszTearoffMethod, p+2);
        if ( szClassName )
        {
            *p = '\0';
            strcpy(szClassName, szWin16Name);
        }
        strcpy(szWin16Name, pszTearoffMethod);
    }

    // lower case the name.
    _strlwr(szWin16Name);
    // make sure the generated name is different from the original one.
    if ( !strcmp( pszTearoffMethod, szWin16Name) )
    {
        char *p = strstr(szWin16Name, "::");

        // Ok, the Method name is all lower case, so we upper case the
        // name after the First char. We also need to skip past the Class Name
        // if any. Upper casing the whole name gave some other problems.
        if ( p != NULL )
            _strupr(p+2);
        else
            _strupr(szWin16Name+1);
    }

}

BOOL CPDLParser::GenerateTearoffTable ( Token *pClassToken, Token *pTearoff, LPCSTR pszInterface, BOOL fMostDerived )
{
    fprintf ( fpHDLFile, "//    Tear-off table for class %s\n",
        pClassToken -> GetTagValue ( CLASS_NAME ) );

    if (IsSpecialTearoff(pTearoff))
    {
        fprintf ( fpHDLFile, "BEGIN_TEAROFF_TABLE_PROPDESC(%s, %s)\n",
            pClassToken -> GetTagValue ( CLASS_NAME ),
            pszInterface );
    }
    else
    {
        fprintf ( fpHDLFile, "BEGIN_TEAROFF_TABLE(%s, %s)\n",
            pClassToken -> GetTagValue ( CLASS_NAME ),
            pszInterface );
    }

    // Walk the interface heirarchy, starting at this classes primary
    // interface, generate a fn table for each interface encountered
    // started with IDispatch methods above. Generate methods in interface order - deepest
    // first

    if ( !GenerateTearOffMethods ( pClassToken -> GetTagValue ( CLASS_NAME ), pTearoff, pszInterface, fMostDerived) )
        return FALSE;

    fprintf ( fpHDLFile, "END_TEAROFF_TABLE()\n\n" );

    return TRUE;
}


Token *CPDLParser::GetSuperClassTokenPtr ( Token *pClassToken )
{
    Token *pSuperToken = NULL;
    if ( pClassToken -> IsSet ( CLASS_SUPER ) )
    {
        CTokenListWalker WholeList ( pRuntimeList );
        pSuperToken = WholeList.GetNext ( TYPE_CLASS,
            pClassToken -> GetTagValue ( CLASS_SUPER ) );
    }
    return pSuperToken;
}

BOOL CPDLParser::HasClassGotProperties ( Token *pClassToken )
{
    Token *pSuperClass;
    CTokenListWalker PropList ( pClassToken );

    if ( PropList.GetNext ( TYPE_PROPERTY ) )
        return TRUE;
    else
    {
        pSuperClass = GetSuperClassTokenPtr ( pClassToken );
        if ( pSuperClass )
            return HasClassGotProperties ( pSuperClass );
        else
            return FALSE;
    }
}


BOOL CPDLParser::PrimaryTearoff (Token *pInterface)
{
    return !pInterface->IsSet(INTERFACE_NOPRIMARYTEAROFF);
}


Token * CPDLParser::NextTearoff (LPCSTR szClassname, Token *pLastTearoff /*= NULL*/)
{
    CTokenListWalker    ThisFilesList(pRuntimeList, _pszPDLFileName);
    Token              *pTearoffToken;
    BOOL                fNextOne = FALSE;

    while (pTearoffToken = ThisFilesList.GetNext(TYPE_TEAROFF))
    {
        if (_stricmp(szClassname, (LPSTR)pTearoffToken->GetTagValue(TEAROFF_NAME)) == 0)
        {
            // The correct class.
            if (pLastTearoff)
            {
                // Return this one.
                if (!fNextOne)
                {
                    fNextOne = pLastTearoff == pTearoffToken;
                    continue;                   // Get the next and then stop.
                }
            }

            break;
        }
    }

    return pTearoffToken;
}


Token* CPDLParser::FindTearoff (LPCSTR szClassname, LPCSTR szInterface)
{
    Token  *pLastTearoff = NULL;

    while (pLastTearoff = NextTearoff(szClassname, pLastTearoff))
    {
        if (!_stricmp(szInterface, (LPSTR)pLastTearoff->GetTagValue(TEAROFF_INTERFACE)))
        {
            break;
        }
    }

    return pLastTearoff;
}


BOOL CPDLParser::GenerateClassIncludes (void)
{
    Token              *pClassToken;
    CTokenListWalker    ThisFilesList(pRuntimeList, _pszPDLFileName);

    // Walk the class statments for this file only
    fprintf(fpLOGFile, "*** Looking for \"%s\"\n",_pszPDLFileName);

    while (pClassToken = ThisFilesList.GetNext(TYPE_CLASS))
    {
        LPCSTR   szClassname = (LPCSTR)pClassToken->GetTagValue(CLASS_NAME);

        fprintf(fpHDLFile, "#ifdef _%s_\n\n", szClassname);

        // Write out inline cached get helpers
        fprintf(fpHDLFile,
                "\n//  Cascaded Property get method prototypes for class %s\n\npublic:\n",
                szClassname);

        GenerateGetAAXPrototypes(pClassToken);

        fprintf(fpHDLFile,
                "\n//    Property get/set method declarations for class %s\n",
                szClassname);

        // Always add a propdesc declaration for non-abstract classes, remember
        // abstract class haven't got a propertydesc array.

        // TODO: TerryLu - Need to add code here to handle the shared keyword
        if ((!pClassToken->IsSet(CLASS_ABSTRACT)) || 
            (_stricmp(pClassToken->GetTagValue(CLASS_NAME), "CElement") == 0))
        {
            if(_stricmp(pClassToken->GetTagValue(CLASS_NAME), "CElement") != 0)
            {
                fprintf(fpHDLFile, 
                        "    static const HDLDESC %s::s_apHdlDescs;\n",
                        szClassname);
            }
            fprintf(fpHDLFile, 
                    "    static const CAssocVTable * const s_AssocVTablePtr[];\n");
            fprintf(fpHDLFile,
                    "    static const CAssocArrayVTable s_StringTable;\n");
            fprintf(fpHDLFile,
                    "    static const CPtrBagVTableAggregate s_StringTableAggregate;\n");
            if(_stricmp(pClassToken->GetTagValue(CLASS_NAME), "COmWindowProxy") == 0)
            {
                fprintf(fpHDLFile, "static const VTABLEDESC * const COmWindowProxy::s_COmWindowProxyDocument;\n");
            }

        }

        CString szInterface;
        Token *pInterface;
        BOOL fOk;

        Token *pTearoff = NULL;
        while ((pTearoff = NextTearoff(szClassname, pTearoff)))
        {
            szInterface = pTearoff->GetTagValue(TEAROFF_INTERFACE);
            pInterface = FindInterface(szInterface);

            if (pInterface)
            {
                CTokenListWalker    ChildList(pInterface);
                Token *pChildToken = ChildList.GetNext();
                if (pChildToken)
                {
                    fOk = FALSE;

                    do
                    {
                        if (pChildToken->GetType() == TYPE_PROPERTY && !pChildToken->IsSet(PROPERTY_ABSTRACT) && !pChildToken->IsSet(PROPERTY_BASEIMPLEMENTATION))
                        {
                            fOk = TRUE;
                            break;
                        }
                    } while (pChildToken = ChildList.GetNext());

                    if (fOk)
                    {
                        fprintf(fpHDLFile, "    static const PROPERTYDESC * const %s::s_ppropdescsInVtblOrder%s [];\n",
                            szClassname, (LPSTR)pTearoff->GetTagValue(TEAROFF_INTERFACE));
                    }
                }
            }
        }

        // Generate a CPC if, we have an eventset && it is unique to us
        if ( IsUniqueCPC ( pClassToken ) )
        {
            fprintf(fpHDLFile,
                    "    static const CONNECTION_POINT_INFO %s::s_acpi[];\n",
                    szClassname);
        }

        GeneratePropMethodDecl(pClassToken);

        if (pClassToken->IsSet(CLASS_EVENTS))
        {
            if (!GenerateEventFireDecl(pClassToken))
            {
                return FALSE;
            }
        }

        // Whip thru all tearoffs.
        Token  *pLastTearoff = NULL;
        while ((pLastTearoff = NextTearoff(szClassname, pLastTearoff)))
        {
            // Need static tearoff table decl
            if (IsSpecialTearoff(pLastTearoff))
            {
                fprintf(fpHDLFile, "    DECLARE_TEAROFF_TABLE_PROPDESC(%s)\n",
                        pLastTearoff->GetTagValue(TEAROFF_INTERFACE));
            }
            else
            {
                fprintf(fpHDLFile, "    DECLARE_TEAROFF_TABLE(%s)\n",
                        pLastTearoff->GetTagValue(TEAROFF_INTERFACE));
            }
        }

        GenerateThunkContext(pClassToken);

        fprintf(fpHDLFile, "\n#endif // _%s_\n\n", szClassname);
        fprintf(fpHDLFile, "#undef _%s_\n\n", szClassname);
    }

    return TRUE;
}

// Work out if this class has a unique connection point info structure - 
// or can we use its super ??
BOOL CPDLParser::IsUniqueCPC ( Token *pClassToken )
{
    BOOL                fDoIt = FALSE;
    Token               *pClass;
    CString             szSuperClass, szThisEvents, szThatEvents;

    if ( !pClassToken->IsSet(CLASS_NOCPC) && pClassToken->IsSet ( CLASS_EVENTS ) )
    {
        szThisEvents = pClassToken->GetTagValue(CLASS_EVENTS);
        fDoIt = TRUE;
        for ( pClass = pClassToken ; pClass ; )
        {
            if ( pClass->IsSet ( CLASS_SUPER ) )
            {
                szSuperClass = pClass -> GetTagValue ( CLASS_SUPER );
                pClass = FindClass ( szSuperClass );
                if ( pClass && pClass->IsSet ( CLASS_EVENTS ) && !pClass->IsSet(CLASS_NOCPC) )
                {
                    szThatEvents = pClass->GetTagValue(CLASS_EVENTS);
                    if ( szThatEvents == szThisEvents )
                    {
                        // Do we have non-primary events #1 and is the super non-primary events
                        // the same as ours?  If not, then we are unique.
                        if (pClassToken->IsSet(CLASS_NONPRIMARYEVENTS1))
                        {
                            szThisEvents = pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS1);
                            szThatEvents = pClass->GetTagValue(CLASS_NONPRIMARYEVENTS1);
                            if (szThatEvents != szThisEvents)
                            {
                                // We're unique.
                                break;
                            }
                            // Do we have non-primary events #2 and is the super non-primary events
                            // the same as ours?  If not, then we are unique.
                            if (pClassToken->IsSet(CLASS_NONPRIMARYEVENTS2))
                            {
                                szThisEvents = pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS2);
                                szThatEvents = pClass->GetTagValue(CLASS_NONPRIMARYEVENTS2);
                                if (szThatEvents != szThisEvents)
                                {
                                    // We're unique.
                                    break;
                                }
                                // Do we have non-primary events #3 and is the super non-primary events
                                // the same as ours?  If not, then we are unique.
                                if (pClassToken->IsSet(CLASS_NONPRIMARYEVENTS3))
                                {
                                    szThisEvents = pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS3);
                                    szThatEvents = pClass->GetTagValue(CLASS_NONPRIMARYEVENTS3);
                                    if (szThatEvents != szThisEvents)
                                    {
                                        // We're unique.
                                        break;
                                    }
                                    // Do we have non-primary events #4 and is the super non-primary events
                                    // the same as ours?  If not, then we are unique.
                                    if (pClassToken->IsSet(CLASS_NONPRIMARYEVENTS4))
                                    {
                                        szThisEvents = pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS4);
                                        szThatEvents = pClass->GetTagValue(CLASS_NONPRIMARYEVENTS4);
                                        if (szThatEvents != szThisEvents)
                                        {
                                            // We're unique.
                                            break;
                                        }
                                    }
                                }
                            }
                            // else fall through to below which set's fDoIt to FALSE.
                        }                        
                        
                        fDoIt = FALSE;
                        break;
                    }
                    break;
                }
            }
            else
                break;
        }
    }
    return fDoIt;
}

BOOL CPDLParser::GenerateEventFireDecl ( Token *pClassToken )
{
    Token *pEventToken;

    fprintf ( fpHDLFile, "//    Event fire method declarations for events %s\n",
        pClassToken -> GetTagValue ( CLASS_EVENTS ) );

    // Find the event declaration
    CTokenListWalker WholeList ( pRuntimeList ) ;
    pEventToken = WholeList.GetNext ( TYPE_EVENT, pClassToken -> GetTagValue ( CLASS_EVENTS ) );
    if ( pEventToken == NULL )
    {
        return FALSE;
    }

    return GenerateEventDecl ( pClassToken, pEventToken );
}

BOOL CPDLParser::IsElementEvent(Token *pEventInterface)
{
    CTokenListWalker WholeList(pRuntimeList);
    CString szEvent;
    CString szElementEvent;

    if (!pEventInterface)
        return FALSE;

    szEvent = pEventInterface->GetTagValue(EVENT_NAME);
    if (_stricmp((LPCSTR)szEvent, "HTMLObjectElementEvents") == 0)
        return TRUE;

    szElementEvent = "HTMLElementEvents";
    while (pEventInterface)
    {
        if (szElementEvent == szEvent)
            return TRUE;

        szEvent = pEventInterface->GetTagValue(EVENT_SUPER);
        WholeList.Reset();
        pEventInterface = WholeList.GetNext(TYPE_EVENT, szEvent);
    }

    return FALSE;
}

BOOL CPDLParser::GenerateEventDecl ( Token *pClassToken, Token *pEventToken )
{
/* TLL: Don't spit out any arguments.  Currently the only argument for event is eventObject which is computed
    Token *pArgToken;
*/
    Token *pChildToken;
    char szErrorText [ MAX_LINE_LEN+1 ];
    CTokenListWalker ChildList ( pEventToken );
    CString szNameUpper;
    CString szNameLower;
    BOOL fDocEvents = (_stricmp(pClassToken->GetTagValue(CLASS_EVENTS), "HTMLDocumentEvents") == 0) ||
                      (_stricmp(pClassToken->GetTagValue(CLASS_EVENTS), "HTMLProtectedElementEvents") == 0) ||
                      (_stricmp(pClassToken->GetTagValue(CLASS_EVENTS), "HTMLNamespaceEvents") == 0);
    BOOL fWindowEvents = _stricmp(pClassToken->GetTagValue(CLASS_EVENTS), "HTMLWindowEvents") == 0;
    BOOL fElementEvents = !fDocEvents && !fWindowEvents && IsElementEvent(pEventToken); 

    while ( pChildToken = ChildList.GetNext() )
    {
        if (!fElementEvents && !fDocEvents && !fWindowEvents &&
            (_stricmp(pClassToken->GetTagValue(CLASS_EVENTS), "DWebBridgeEvents") != 0))
        {
            sprintf ( szErrorText, "Need to modify GenerateEventDecl() in parser.cpp to pass in Doc ptr to FireEvent for class:%s\n",
                (LPCSTR)pClassToken->GetTagValue(CLASS_NAME) );
            ReportError ( szErrorText );
            return FALSE;
        }
        if ( pChildToken -> GetType() == TYPE_METHOD &&
            !pChildToken -> IsSet ( METHOD_ABSTRACT ) )
        {
            szNameUpper = pChildToken -> GetTagValue ( METHOD_NAME );
            szNameLower = szNameUpper;
            szNameUpper.ToUpper();

            if (!FindEventProp(pClassToken, (LPCSTR)szNameLower))
                continue;

            // Method
            
            fprintf ( fpHDLFile, "    %s Fire_%s(",
                pChildToken->IsSet(METHOD_CANCELABLE) ? "BOOL" : "void",
                pChildToken -> GetTagValue ( METHOD_NAME ) );

            CTokenListWalker ArgListWalker ( pChildToken );
            BOOL fFirst = TRUE;

/* TLL: Don't spit out any arguments.  Currently the only argument for event is eventObject which is computed
            while ( pArgToken = ArgListWalker.GetNext() )
            {
                if ( !fFirst )
                    fprintf ( fpHDLFile, "," );
                fprintf ( fpHDLFile, "%s %s",
                    (LPCSTR)pArgToken -> GetTagValue ( METHODARG_TYPE ),
                    (LPCSTR)pArgToken -> GetTagValue ( METHODARG_ARGNAME ));
                fFirst = FALSE;
            }
*/
            if ( pChildToken->IsSet(METHOD_BUBBLING) )
            {
                if ( !fFirst )
                    fprintf ( fpHDLFile, "," );
                fprintf ( fpHDLFile, "CTreeNode * pNodeContext = NULL");
                fprintf ( fpHDLFile, ", long lSubDivision = -1");
            }

            fprintf ( fpHDLFile, ")\n    {\n        " );

            if ( pChildToken->IsSet(METHOD_CANCELABLE) )
            {
                fprintf ( fpHDLFile, "return !!" );
            }

            if (fElementEvents)
            {
                fprintf(fpHDLFile, "FireEvent(&s_propdesc%s%s%s",
                    (LPCSTR)pClassToken->GetTagValue(CLASS_NAME),
                    (LPCSTR)szNameLower,
                    pChildToken->IsSet(METHOD_BUBBLING) ? ", TRUE, pNodeContext, lSubDivision" : "");
            }
            else
            {
                fprintf(fpHDLFile, "FireEvent(%sDISPID_EVMETH_%s, DISPID_EVPROP_%s, _T(\"%s\")",
                    fDocEvents ? "Doc(), " : (fWindowEvents ? "_pDoc, " : ""),
                    (LPCSTR)szNameUpper,
                    (LPCSTR)szNameUpper,
                    (LPCSTR)szNameLower+2);
            }

/* TLL: Don't spit out any arguments.  Currently the only argument for event is eventObject which is computed
            ArgListWalker.Reset();
            if ( ArgListWalker.GetTokenCount() > 0 )
            {
                while ( pArgToken = ArgListWalker.GetNext() )
                {
                    // Locate the vts type for this type
                    CString szVTSType;

                    if ( !LookupEventType ( szVTSType, pArgToken -> GetTagValue ( METHODARG_TYPE ) ) )
                    {
                        sprintf ( szErrorText, "Unknown Type %s in %s::Fire%s event declaration\n",
                            (LPCSTR) pArgToken -> GetTagValue ( METHODARG_TYPE ),
                            pEventToken -> GetTagValue ( EVENT_NAME ),
                            pChildToken -> GetTagValue ( METHOD_NAME ) );
                        ReportError ( szErrorText );
                        return FALSE;
                    }
                    fprintf ( fpHDLFile, " %s", (LPCSTR)szVTSType );
                    fFirst = FALSE;
                }
                ArgListWalker.Reset();
                while ( pArgToken = ArgListWalker.GetNext() )
                {
                    fprintf ( fpHDLFile, ", %s",
                        pArgToken -> GetTagValue ( METHODARG_ARGNAME ) );
                }
            }
            else
            {
                fprintf ( fpHDLFile, " VTS_NONE" );
            }
*/
            fprintf ( fpHDLFile, ");\n    }\n" );
        }
        else if ( pChildToken -> GetType() == TYPE_PROPERTY )
        {
            // Property in event set - should never happen if we
            // check the child/parent relationships at parse time
            sprintf ( szErrorText, "events %s - invalid to have a property in event set\n",
                (LPCSTR)pClassToken -> GetTagValue ( EVENT_NAME ) );
            ReportError ( szErrorText );
            return FALSE;
        }
    }
    return TRUE;
}


LPCSTR CPDLParser::ConvertType(LPCSTR szType, BOOL fComPlus /* = FALSE*/, LPSTR pCPString /* = 0*/, BOOL *pfInterfaceFound /* = 0*/)
{
    if (!fComPlus)
    {
        if (_stricmp(szType, "SAFEARRAY(VARIANT)") == 0)
            return("SAFEARRAY*");
        else
            return(szType);
    }
    else
    {
        BOOL	fInterfFound;

        if (!pfInterfaceFound)
        {
            pfInterfaceFound = &fInterfFound;
        }

        *pfInterfaceFound = FALSE;

        if (_stricmp(szType, "BSTR") == 0)
            return("String");
        else if (_stricmp(szType, "VARIANT_BOOL") == 0)
            return("Boolean");
        else if (_stricmp(szType, "VARIANT") == 0)
            return("Variant");
        else if (_stricmp(szType, "IDispatch") == 0 || _stricmp(szType, "IUnknown") == 0)
            return("Object");
        else if (_stricmp(szType, "SAFEARRAY(VARIANT)") == 0)
            return("String");		// ***TLL*** COM+: Need to make it a safearray
        else if (pCPString)
        {
            CString pInterf;
            
            pInterf = szType;

            if (FindInterface(pInterf))
            {
                strcpy(pCPString, szType);
                strcat(pCPString, "COMPLUS");
                *pfInterfaceFound = TRUE;
                return 0;
            }
            else
            {
                return(szType);
            }
        }
        else
            return(szType);
    }
}

void CPDLParser::GeneratePropMethodDecl ( Token *pClassToken )
{
    CTokenListWalker ChildList ( pClassToken );

    CString szProp;
    Token *pArgToken;
    Token *pChildToken;
    char szContextThunk[] = "ContextThunk_";
    LPCSTR   pCtxt;

    while ( pChildToken = ChildList.GetNext() )
    {
        char    szTemp[256];
        LPSTR   pMethodName;
        BOOL    fNameOnly;

        fNameOnly = _stricmp(pChildToken->GetTagValue(METHOD_NOPROPDESC), "nameonly") == 0;

        if ( pChildToken -> GetType() == TYPE_METHOD  && !fNameOnly )
        {
            // Method
            fprintf ( fpHDLFile, "    " );
            if ( pChildToken -> IsSet ( METHOD_VIRTUAL ) )
            {
                //fprintf ( fpHDLFile, "virtual " );
                fprintf ( fpHDLFile, "DECLARE_TEAROFF_METHOD_(" );
            }
            else
                fprintf ( fpHDLFile, "NV_DECLARE_TEAROFF_METHOD_(" );

           	pMethodName = pChildToken->IsSet(METHOD_SZINTERFACEEXPOSE) ?
                            (LPSTR)pChildToken->GetTagValue(METHOD_SZINTERFACEEXPOSE) :
                            (LPSTR)pChildToken->GetTagValue(METHOD_NAME);

            GenerateWin16TearoffName(szTemp, pMethodName);

            pCtxt = pChildToken->IsSet(METHOD_THUNKCONTEXT) ||
                    pChildToken->IsSet(METHOD_THUNKNODECONTEXT)
                      ? szContextThunk : "";

            //fprintf ( fpHDLFile, "%s STDMETHODCALLTYPE %s(",
            fprintf ( fpHDLFile, "%s, %s%s, %s, (",
                pChildToken -> GetTagValue ( METHOD_RETURNTYPE ),
                pCtxt, pMethodName, szTemp );

            CTokenListWalker ArgListWalker ( pChildToken );
            BOOL fFirst = TRUE;
            while ( pArgToken = ArgListWalker.GetNext() )
            {
                if ( !fFirst )
                    fprintf ( fpHDLFile, "," );
                fprintf ( fpHDLFile, "%s %s",
                    ConvertType((LPCSTR)pArgToken -> GetTagValue ( METHODARG_TYPE )),
                    (LPCSTR)pArgToken -> GetTagValue ( METHODARG_ARGNAME ) );
                fFirst = FALSE;
            }
            fprintf ( fpHDLFile, "));\n" );
        }
        else
        {
            fNameOnly = _stricmp(pChildToken->GetTagValue(PROPERTY_NOPROPDESC), "nameonly") == 0;

            // Base has provided prototoype
            if ( pChildToken -> IsSet ( PROPERTY_BASEIMPLEMENTATION )
                || (!pChildToken->IsSet(PROPERTY_ABSTRACT) && IsSpecialProperty(pClassToken))
                )
            {
                continue;
            }
            // Property
            szProp = "";
            // Through the index/indextype & index1/indextype1 pdl tags
            // you can provide up to two additional args for the property definition
            if ( pChildToken -> IsSet ( PROPERTY_INDEX ) )
            {
                szProp += pChildToken -> GetTagValue ( PROPERTY_INDEXTYPE );
                szProp += " ";
                szProp += pChildToken -> GetTagValue ( PROPERTY_INDEX );
            }
            if ( pChildToken -> IsSet ( PROPERTY_INDEX1 ) )
            {
                if ( szProp [ 0 ] != '\0' )
                    szProp += ",";
                szProp += pChildToken -> GetTagValue ( PROPERTY_INDEXTYPE1 );
                szProp += " ";
                szProp += pChildToken -> GetTagValue ( PROPERTY_INDEX1 );
            }
            if ( szProp [ 0 ] != '\0' )
                szProp += ",";

           	pMethodName = pChildToken->IsSet(PROPERTY_SZINTERFACEEXPOSE) ?
                            (LPSTR)pChildToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE) :
                            (LPSTR)pChildToken->GetTagValue(PROPERTY_NAME);

            pCtxt = pChildToken->IsSet(PROPERTY_THUNKCONTEXT) ||
                    pChildToken->IsSet(PROPERTY_THUNKNODECONTEXT) 
                    ? szContextThunk : "";

            if ( pChildToken -> IsSet ( PROPERTY_SET ) && !fNameOnly )
            {
                fprintf ( fpHDLFile, "    " );
                if ( pChildToken -> IsSet ( PROPERTY_VIRTUAL ) )
                {
                    fprintf ( fpHDLFile, "DECLARE_TEAROFF_METHOD(%sput_%s, PUT_%s, (%s%s v));\n",
                        pCtxt,
                        pMethodName,
                        pMethodName,
                        (LPCSTR)szProp,
                        (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_ATYPE ));
                }
                else
                {
                    fprintf ( fpHDLFile, "NV_DECLARE_TEAROFF_METHOD(%sput_%s, PUT_%s, (%s%s v));\n",
                        pCtxt,
                        pMethodName,
                        pMethodName,
                        (LPCSTR)szProp,
                        (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_ATYPE ));
                }

            }
            if ( pChildToken -> IsSet ( PROPERTY_GET ) && !fNameOnly)
            {
                fprintf ( fpHDLFile, "    " );
                if ( pChildToken -> IsSet ( PROPERTY_VIRTUAL ) )
                {
                    fprintf ( fpHDLFile, "DECLARE_TEAROFF_METHOD(%sget_%s, GET_%s, (%s%s*p));\n",
                        pCtxt,
                        pMethodName,
                        pMethodName,
                        (LPCSTR)szProp,
                        (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_ATYPE ));
                }
                else
                {
                    fprintf ( fpHDLFile, "NV_DECLARE_TEAROFF_METHOD(%sget_%s, GET_%s, (%s%s*p));\n",
                        pCtxt,
                        pMethodName,
                        pMethodName,
                        (LPCSTR)szProp,
                        (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_ATYPE ));
                }
            }
        }
    }

}

BOOL CPDLParser::IsStoredAsString( Token *pChildToken )
{
    CString szJunk1, szJunk2;
    StorageType stHowStored;

    GetTypeDetails ( pChildToken->GetTagValue ( PROPERTY_TYPE ),
        szJunk1, szJunk2, &stHowStored );

    return stHowStored == STORAGETYPE_STRING ? TRUE : FALSE;
}


void CPDLParser::GenerateGetAAXPrototypes ( Token *pClassToken )
{
    CTokenListWalker ChildList ( pClassToken );

    Token *pChildToken;

    if (  pClassToken -> IsSet ( CLASS_NOAAMETHODS ) )
        return;

    while ( pChildToken = ChildList.GetNext() )
    {
        // Generate a GetAA prototype even if the automation Get method is not generated
        if ( pChildToken -> GetType() != TYPE_METHOD &&
             pChildToken -> IsSet ( PROPERTY_CAA ) &&
             _stricmp(pChildToken->GetTagValue(PROPERTY_NOPROPDESC), "nameonly"))
        {
            BOOL fIsString = IsStoredAsString(pChildToken);

            //setaahr method
            if (pChildToken -> IsSet ( PROPERTY_SETAAHR ) )
            {
                fprintf ( fpHDLFile, "    HRESULT SetAA%s(%s);\n",
                    (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_NAME ),
                    (LPCSTR)(fIsString?"LPCTSTR": (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_TYPE ) )
                    );
            }

            //get method. If the property refers to a cascaded format - don't generate a GetAA - this would just
            // encourage mis-use. Always want to force use of GetCascadedXX variant
            if ( !pChildToken -> IsSet ( PROPERTY_CASCADED ) ||
                pChildToken -> IsSet ( PROPERTY_GETAA ) )
            {
                fprintf ( fpHDLFile, "    %s GetAA%s() const;\n",
                    (LPCSTR)(fIsString?"LPCTSTR":(LPCSTR)pChildToken -> GetTagValue ( PROPERTY_TYPE )),
                    (LPCSTR)(pChildToken->GetTagValue ( PROPERTY_NAME )) );
            }
        }
    }
}


void CPDLParser::GenerateGetAAXImplementations( Token *pClassToken )
{
    CTokenListWalker ChildList ( pClassToken );

    Token *pChildToken;

    if (  pClassToken -> IsSet ( CLASS_NOAAMETHODS ) )
        return;

    while ( pChildToken = ChildList.GetNext() )
    {
        // Generate a GetAA prototype even if the automation Get method is not generated
        if ( pChildToken -> GetType() != TYPE_METHOD &&
             pChildToken -> IsSet ( PROPERTY_CAA ) &&
             _stricmp(pChildToken->GetTagValue(PROPERTY_NOPROPDESC), "nameonly"))
        {
            BOOL fIsString = IsStoredAsString(pChildToken);

            //setaahr method
            if (pChildToken -> IsSet ( PROPERTY_SETAAHR ) )
            {
                if (!strcmp((LPCSTR)pChildToken ->GetTagValue(PROPERTY_TYPE), "VARIANT_BOOL"))
                {
                    fprintf ( fpHDLFile, "HRESULT %s::SetAA%s(VARIANT_BOOL pv)\n{\n    DWORD  dwTemp = pv;\n    RRETURN( THR( CAttrArray::SetSimple(GetAttrArray(), &s_propdesc%s%s.a, dwTemp) ) );\n}\n",
                        (LPCSTR)pClassToken -> GetTagValue ( CLASS_NAME ),
                        (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_NAME ),
                        (LPCSTR)pClassToken -> GetTagValue ( CLASS_NAME ),
                        (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_NAME )
                        );
                }
                else
                {
                    fprintf ( fpHDLFile, "HRESULT %s::SetAA%s(%s pv)\n{\n    RRETURN( THR( CAttrArray::Set%s(GetAttrArray(), &s_propdesc%s%s.a, %spv) ) );\n}\n",
                        (LPCSTR)pClassToken -> GetTagValue ( CLASS_NAME ),
                        (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_NAME ),
                        (LPCSTR)( fIsString?"LPCTSTR":(LPCSTR)pChildToken ->GetTagValue(PROPERTY_TYPE) ),
                        (LPCSTR)(fIsString?"String":"Simple"),
                        (LPCSTR)pClassToken -> GetTagValue ( CLASS_NAME ),
                        (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_NAME ),
                        (LPCSTR)(fIsString?"":"*(DWORD*) &")
                        );
                }
            }

            //get method. Don't generate a GetAA - they already have a GetCascadedX
            if ( !pChildToken -> IsSet ( PROPERTY_CASCADED ) ||
                pChildToken -> IsSet ( PROPERTY_GETAA ) )
            {
                Token      *pExposeToken = NULL;
                CString     szClass;

                if (pChildToken -> IsSet ( PROPERTY_NOPROPDESC ))
                {
                    pExposeToken = FindMatchingEntryWOPropDesc(pClassToken, pChildToken);
                }

                if (!pExposeToken)
                    pExposeToken = pChildToken;

                if (strlen( pExposeToken -> GetTagValue ( PROPERTY_REFDTOCLASS )))
                    szClass = pExposeToken -> GetTagValue ( PROPERTY_REFDTOCLASS );
                else
                    szClass = (LPCSTR)pClassToken -> GetTagValue ( CLASS_NAME );

#ifdef UNIX // IEUNIX: On Unix, converting DWORD* to short* would cause value changed. So we cast it from DWORD to short. 
                if (!fIsString)
                {
                    LPCSTR pPropType = (LPCSTR)pChildToken->GetTagValue( PROPERTY_TYPE);
                    if ( !_stricmp(pPropType , "short") || !_stricmp(pPropType, "WORD") || !_stricmp(pPropType, "BYTE") )
                    {
                        fprintf ( fpHDLFile, "%s %s::GetAA%s() const \n{\n    DWORD v;\n    CAttrArray::FindSimple( *GetAttrArray(), &s_propdesc%s%s.a, &v);\n    return (%s)v;\n}\n",
                            pPropType,
                            (LPCSTR)pClassToken -> GetTagValue ( CLASS_NAME ),
                            (LPCSTR)(pChildToken->GetTagValue ( PROPERTY_NAME )),
                            (LPCSTR)szClass,
                            (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_NAME ),
                            pPropType );
                        continue;
                    }
                }
#endif
                fprintf ( fpHDLFile, "%s %s::GetAA%s() const \n{\n    %s v;\n    CAttrArray::Find%s( *GetAttrArray(), &s_propdesc%s%s.a, &v);\n    return *(%s*)&v;\n}\n",
                    (LPCSTR)(fIsString?"LPCTSTR":(LPCSTR)pChildToken -> GetTagValue ( PROPERTY_TYPE )),
                    (LPCSTR)pClassToken -> GetTagValue ( CLASS_NAME ),
                    (LPCSTR)(pChildToken->GetTagValue ( PROPERTY_NAME )) ,
                    (LPCSTR)(fIsString?"LPCTSTR":"DWORD" ),
                    (LPCSTR)(fIsString?"String":"Simple"),
                    (LPCSTR)szClass,
                    (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_NAME ),
                    (LPCSTR)(fIsString?"LPCTSTR":(LPCSTR)pChildToken -> GetTagValue ( PROPERTY_TYPE ) ) );
            }
        }
    }
}

BOOL CPDLParser::GenerateIDispatchTearoff ( LPCSTR szClassName, Token *pTearoff, LPCSTR pszInterface, BOOL fMostDerived)
{
    char    szTearoffMethod[128];
    char    szTemp[128];

    fprintf ( fpHDLFile, "    //  IDispatch methods\n");

    FindTearoffMethod(pTearoff, "GetTypeInfoCount", szTearoffMethod);
    GenerateWin16TearoffName(szTemp, szTearoffMethod);
    fprintf ( fpHDLFile, "    TEAROFF_METHOD(%s, %s, %s, (unsigned int *))\n", 
        szClassName, szTearoffMethod, szTemp);

    FindTearoffMethod(pTearoff, "GetTypeInfo", szTearoffMethod);
    GenerateWin16TearoffName(szTemp, szTearoffMethod);
    fprintf ( fpHDLFile, "    TEAROFF_METHOD(%s, %s, %s, (unsigned int, unsigned long, ITypeInfo **))\n", 
        szClassName, szTearoffMethod, szTemp);

    FindTearoffMethod(pTearoff, "GetIDsOfNames", szTearoffMethod);
    GenerateWin16TearoffName(szTemp, szTearoffMethod);
    fprintf ( fpHDLFile, "    TEAROFF_METHOD(%s, %s, %s, (REFIID, LPOLESTR *, unsigned int, LCID, DISPID *))\n", 
        szClassName, szTearoffMethod, szTemp);

    {
        CString szIHTMLElement, szInterface;
        szIHTMLElement = "IHTMLElement";
        szInterface = pszInterface;

        if(!FindTearoffMethod(pTearoff, "Invoke", szTearoffMethod) &&
           IsSuperInterface(szIHTMLElement, FindInterface(szInterface)))
        {
            strcpy(szTearoffMethod, pTearoff->IsSet(TEAROFF_BASEIMPL) ?
                            (LPCSTR)pTearoff->GetTagValue(TEAROFF_BASEIMPL) : "");
            strcat(szTearoffMethod, "ContextThunk_Invoke");
        }
    }

    GenerateWin16TearoffName(szTemp, szTearoffMethod);
    fprintf ( fpHDLFile, "    TEAROFF_METHOD(%s, %s, %s, (DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, unsigned int *))\n", 
        szClassName, szTearoffMethod, szTemp);

    return TRUE;

}

BOOL CPDLParser::IsSpecialTearoff(Token *pTearoff)
{
    CString szInterface;
    Token *pInterface;
    Token *pChildToken;

    szInterface = pTearoff->GetTagValue(TEAROFF_INTERFACE);
    pInterface = FindInterface(szInterface);
    
    if (!pInterface || pInterface->IsSet(INTERFACE_ABSTRACT))
        return FALSE;

    CTokenListWalker    ChildList(pInterface);
    pChildToken = ChildList.GetNext();

    if (pChildToken)
    {
        do
        {
            if (pChildToken->GetType() == TYPE_PROPERTY && !pChildToken->IsSet(PROPERTY_ABSTRACT) && !pChildToken->IsSet(PROPERTY_BASEIMPLEMENTATION))
            {
                return TRUE;
            }
        } while (pChildToken = ChildList.GetNext());
    }

    return FALSE;
}

BOOL CPDLParser::FindTearoffProperty(Token *pPropertyToken, LPSTR szTearoffMethod, 
                                     LPSTR szTearOffClassName, LPSTR szPropArgs, BOOL fPropGet)
{
    if (pPropertyToken->IsSet(PROPERTY_ABSTRACT) || pPropertyToken->IsSet(PROPERTY_BASEIMPLEMENTATION))
        return FALSE;

    strcpy(szTearoffMethod, fPropGet ? "get_" : "put_");
    strcpy(szPropArgs, fPropGet ? "void" : (LPCSTR)pPropertyToken->GetTagValue(PROPERTY_ATYPE));
    strcpy(szTearOffClassName, "CBase");

    if (!strcmp(pPropertyToken->GetTagValue(PROPERTY_ATYPE), "VARIANT"))
    {
        if (fPropGet)
        {
            strcat(szTearoffMethod, "Property");
        }
        else if (pPropertyToken->IsSet(PROPERTY_DATAEVENT))
            strcat(szTearoffMethod, "DataEvent");
        else
            strcat(szTearoffMethod, "Variant");
    }
    else if (!strcmp(pPropertyToken->GetTagValue(PROPERTY_ATYPE), "BSTR"))
    {
        if (!strcmp(pPropertyToken->GetTagValue(PROPERTY_TYPE), "url"))
        {
            strcat(szTearoffMethod, "Url");
            strcpy(szPropArgs, (LPCSTR)pPropertyToken->GetTagValue(PROPERTY_ATYPE));
        }
        else if (!strcmp(pPropertyToken->GetTagValue(PROPERTY_TYPE), "CStyleComponent"))
        {
            strcat(szTearoffMethod, "StyleComponent");
            strcpy(szPropArgs, (LPCSTR)pPropertyToken->GetTagValue(PROPERTY_ATYPE));
        }
        else
            strcat(szTearoffMethod, (fPropGet ? "Property" : "String"));
    }
    else if (!strcmp(pPropertyToken->GetTagValue(PROPERTY_ATYPE), "VARIANT_BOOL"))
        strcat(szTearoffMethod, (fPropGet ? "Property" : "Bool"));
    else if (!strcmp(pPropertyToken->GetTagValue(PROPERTY_ATYPE), "long"))
        strcat(szTearoffMethod, fPropGet ? "Property" : "Long");
    else if (!strcmp(pPropertyToken->GetTagValue(PROPERTY_ATYPE), "short"))
        strcat(szTearoffMethod, fPropGet ? "Property" : "Short");
    else
    {
        char szError[124];
        sprintf(szError, "%s: This property of new type needs a function prototype (in cdbase.hxx) and a body defn. in (baseprop.cxx)",
                (LPCSTR)pPropertyToken->GetTagValue(PROPERTY_NAME));
        ReportError (szError);
        return FALSE;
    }

    return TRUE;
}

BOOL CPDLParser::GeneratePropDescsInVtblOrder(Token *pClassToken, int *pNumVtblPropDescs)
{
    CString szPrimaryInterf;
    CString szInterface;
    LPCSTR  szClassName = pClassToken->GetTagValue(CLASS_NAME);
    BOOL    fOk;
    BOOL    fNameOnly;
    int i = 0, j;

    szPrimaryInterf = pClassToken->GetTagValue(CLASS_INTERFACE);
    Token *pPrimaryInterf = FindInterface(szPrimaryInterf);
    Token *pInterface;
    Token *pChildToken;
    Token *apInterface[5];
    
    *pNumVtblPropDescs = 0;
    Token *pTearoff = NULL;

    while ((pTearoff = NextTearoff(szClassName, pTearoff)))
    {
        szInterface = pTearoff->GetTagValue(TEAROFF_INTERFACE);
        pInterface = FindInterface(szInterface);
        
        if (!pInterface || pInterface->IsSet(INTERFACE_ABSTRACT))
            continue;

        i = 0;
        apInterface[i++] = pInterface;
        while (i < 5 && apInterface[i-1]->IsSet(INTERFACE_SUPER) && 
               _stricmp(apInterface[i-1]->GetTagValue(INTERFACE_SUPER), "IDispatch") &&
               _stricmp(apInterface[i-1]->GetTagValue(INTERFACE_SUPER), "IUnknown"))
        {
            szInterface = apInterface[i-1]->GetTagValue(INTERFACE_SUPER);
            apInterface[i++] = FindInterface(szInterface);
        }

        if (i >= 5)
        {
            ReportError("Super Chain More than 5, Need to increase limit in PdlParser");
            return FALSE;
        }

        fOk = FALSE;

        CTokenListWalker    ChildList(pInterface);
        pChildToken = ChildList.GetNext();

        if (pChildToken)
        {
            do
            {
                if (pChildToken->GetType() == TYPE_PROPERTY && !pChildToken->IsSet(PROPERTY_ABSTRACT) && !pChildToken->IsSet(PROPERTY_BASEIMPLEMENTATION))
                {
                    fOk = TRUE;
                    break;
                }
            } while (pChildToken = ChildList.GetNext());

            if (fOk)
            {
                fprintf(fpHDLFile, "\nconst PROPERTYDESC * const %s::s_ppropdescsInVtblOrder%s[] = {\n", szClassName,
                        (LPSTR)pTearoff->GetTagValue(TEAROFF_INTERFACE));

                for (j = i-1; j >= 0; j--)
                {
                    pInterface = apInterface[j];
                    CTokenListWalker    ChildLst(pInterface);
                    pChildToken = ChildLst.GetNext();

                    do
                    {
                        char    szErrorText[MAX_LINE_LEN + 1];
                        Token  *pExposeToken = NULL;

                        if (pChildToken->GetType() == TYPE_METHOD)
                        {
                            if (pChildToken->IsSet(METHOD_NOPROPDESC))
                            {
                                fNameOnly = _stricmp(pChildToken->GetTagValue(METHOD_NOPROPDESC), "nameonly") == 0;

                                pExposeToken = FindMatchingEntryWOPropDesc(pClassToken, pChildToken, fNameOnly);
                                if (!pExposeToken)
                                {
                                    sprintf(szErrorText,
                                            "Function member marked as nopropdesc can not find exact signature match in new interface:%s in Class:%s\n",
                                            (LPCSTR)pChildToken->GetTagValue(METHOD_NAME),
                                            szClassName);
                                    ReportError(szErrorText);
                                    return FALSE;
                                }
                            }
                            else
                                pExposeToken = pChildToken;

                            fprintf(fpHDLFile, "    (PROPERTYDESC *)&s_methdesc%s%s,\n", pExposeToken->GetTagValue((int)METHOD_REFDTOCLASS), pExposeToken->GetTagValue(METHOD_NAME));
                            if (pPrimaryInterf == pInterface)
                                (*pNumVtblPropDescs)++;
                        }
                        else
                        {
                            if (pChildToken->IsSet(PROPERTY_SET) || pChildToken->IsSet(PROPERTY_GET))
                            {
                                BOOL    fDoAgain = TRUE;

    DoAgain:
                                if (pChildToken->IsSet(PROPERTY_NOPROPDESC))
                                {
                                    fNameOnly = _stricmp(pChildToken->GetTagValue(PROPERTY_NOPROPDESC), "nameonly") == 0;

                                    pExposeToken = FindMatchingEntryWOPropDesc(pClassToken, pChildToken, fNameOnly);
                                    if (!pExposeToken)
                                    {
                                        sprintf(szErrorText,
                                                "Function member marked as nopropdesc can not find exact signature match in new interface:%s in Class:%s\n",
                                                (LPCSTR)pChildToken->GetTagValue(PROPERTY_NAME),
                                                szClassName);
                                        ReportError(szErrorText);
                                        return FALSE;
                                    }
                                }
                                else
                                    pExposeToken = pChildToken;

                                pExposeToken = pExposeToken ? pExposeToken : pChildToken;

                                fprintf(fpHDLFile, "    (const PROPERTYDESC *)&s_propdesc%s%s,\n",
                                        pExposeToken->GetTagValue((int)PROPERTY_REFDTOCLASS),
                                        pExposeToken->GetTagValue(PROPERTY_NAME));
                                if (pPrimaryInterf == pInterface)
                                    (*pNumVtblPropDescs)++;

                                // If property is getter and setter both then generate another propdesc (but just once).
                                if (fDoAgain && pChildToken->IsSet(PROPERTY_SET) && pChildToken->IsSet(PROPERTY_GET))
                                {
                                    fDoAgain = FALSE;
                                    goto DoAgain;
                                }
                            }
                        }

                    } while (pChildToken = ChildLst.GetNext());
                }

                fprintf(fpHDLFile, "};\n\n");
            }
        }
    }

    return TRUE;
}

BOOL CPDLParser::GenerateTearOffMethods (LPCSTR szClassName, Token *pTearoff, LPCSTR szInterfaceName, BOOL fMostDerived)
{
    Token              *pInterfaceToken;
    Token              *pChildToken;
    char                szText[MAX_LINE_LEN+1];
    CTokenListWalker    WholeList(pRuntimeList);
#if 0
if (strcmp(_pszPDLFileName, "div.pdl") == 0 || strcmp(szInterfaceName, "IHTMLDivElement") == 0)
__asm { int 3 };
#endif

    // Find the interface decl
    do
    {
        pInterfaceToken = WholeList.GetNext(TYPE_INTERFACE, szInterfaceName);

        if (pInterfaceToken == NULL)
        {
            // if the deepest is IDispatch output that tearoff
            if (_stricmp(szInterfaceName, "IDispatch"))
            {
                // but IUnknowns are OK so return true
                if (_stricmp(szInterfaceName, "IUnknown"))
                {
                    // its something we don't recognise so output error msg
                    sprintf(szText, "interface:%s unknown\n", (LPCSTR)szInterfaceName);
                    ReportError(szText);
                    return FALSE;
                }
                else
                    return TRUE;
            }
            else
            {
                return GenerateIDispatchTearoff(szClassName, pTearoff, szInterfaceName, fMostDerived);
            }
       }
    } while (!pInterfaceToken->IsSet(INTERFACE_GUID));

    // If we only want most derived then we're done otherwise continue recursing.
    if (!fMostDerived)
    {
        // Generate the interfaces super tear off methods first
        if (pInterfaceToken->IsSet(INTERFACE_SUPER))
        {
            GenerateTearOffMethods(szClassName, pTearoff, pInterfaceToken->GetTagValue(INTERFACE_SUPER));
        }
    }
    else
    {
        // fMostDerived is only set for the primary interface, which we don't want stacked ontop of its
        // derivations. so all we want to do is dump in the dispatch and go on.
        GenerateIDispatchTearoff(szClassName, pTearoff, szInterfaceName, fMostDerived);
    }

       // generate the fn prototypes cast to generic fn pts in the
    // tearoff table
    CTokenListWalker    ChildList(pInterfaceToken);
    CString             szProp;
    Token              *pArgToken;

    fprintf ( fpHDLFile, "    //  %s methods\n", szInterfaceName);

    while (pChildToken = ChildList.GetNext())
    {
        char szTemp[256];
        char szTearOffClassName[256];
        char szContextThunk[] = "ContextThunk_";
        LPCSTR   pCtxt;

        if (pChildToken->GetType() == TYPE_METHOD)
        {
            CTokenListWalker    ArgListWalker(pChildToken);
            BOOL                fFirstArg = TRUE;
            char                szTearoffMethod[128];
            LPCSTR              pMethodName;

            pMethodName = pChildToken->IsSet(METHOD_SZINTERFACEEXPOSE) ?
                            (LPSTR)pChildToken->GetTagValue(METHOD_SZINTERFACEEXPOSE) :
                            (LPSTR)pChildToken->GetTagValue(METHOD_NAME);

            FindTearoffMethod(pTearoff,
                              pMethodName,
                              szTearoffMethod);

            strcpy(szTearOffClassName, szClassName);
            GenerateWin16TearoffName(szTemp, szTearoffMethod, szTearOffClassName);


            pCtxt = pChildToken->IsSet(METHOD_THUNKCONTEXT) ||
                    pChildToken->IsSet(METHOD_THUNKNODECONTEXT)
                      ? szContextThunk : "";


            // Method
            fprintf(fpHDLFile, "    TEAROFF_METHOD(%s, %s%s, %s, (", szTearOffClassName, pCtxt, szTearoffMethod, szTemp);

            // All automated methods MUST have an HRESULT for the return type.
            if (_stricmp("HRESULT", (LPCSTR)pChildToken->GetTagValue(METHOD_RETURNTYPE)))
            {
                ReportError("Automated method must have HRESULT for return value\n");
                return FALSE;
            }

            // Output each argument.
            while (pArgToken = ArgListWalker.GetNext())
            {
                if (!fFirstArg)
                    fprintf(fpHDLFile, ",");

                fprintf(fpHDLFile, "%s", ConvertType((LPCSTR)pArgToken->GetTagValue(METHODARG_TYPE)));

                fFirstArg = FALSE;
            }

            fprintf(fpHDLFile, "))\n");
        }
        else
        {
            char    szPropName[128];
            char    szTearoffMethod[128];
            char    szPropArgs[64];
            LPCSTR  pMethodName;

            // Property
            szProp = "";

            pMethodName = pChildToken->IsSet(PROPERTY_SZINTERFACEEXPOSE) ?
                            (LPSTR)pChildToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE) :
                            (LPSTR)pChildToken->GetTagValue(PROPERTY_NAME);

            // Through the index/indextype & index1/indextype1 pdl tags
            // you can provide up to two additional args for the property definition
            pChildToken->AddParam(szProp, PROPERTY_INDEX, pChildToken->GetTagValue(PROPERTY_INDEXTYPE));
            pChildToken->AddParam(szProp, PROPERTY_INDEX1, pChildToken->GetTagValue(PROPERTY_INDEXTYPE1));
            if (szProp[0] != '\0')
                szProp += ",";

            pCtxt = pChildToken->IsSet(PROPERTY_THUNKCONTEXT) ||
                    pChildToken->IsSet(PROPERTY_THUNKNODECONTEXT) 
                    ? szContextThunk : "";

            if ( pChildToken->IsSet(PROPERTY_SET))
            {
                strcpy(szPropName, "put_");
                strcat(szPropName, pMethodName);

                if (FindTearoffMethod(pTearoff, szPropName, szTearoffMethod))
                {
                    strcpy(szPropArgs, (LPCSTR)pChildToken->GetTagValue(PROPERTY_ATYPE));
                    strcpy(szTearOffClassName, szClassName);
                }
                else if (!FindTearoffProperty(pChildToken, szTearoffMethod, szTearOffClassName, szPropArgs, FALSE))
                {
                    FindTearoffMethod(pTearoff, szPropName, szTearoffMethod);
                    strcpy(szPropArgs, (LPCSTR)pChildToken->GetTagValue(PROPERTY_ATYPE));
                    strcpy(szTearOffClassName, szClassName);
                }

                GenerateWin16TearoffName(szTemp, szTearoffMethod, szTearOffClassName);

                fprintf(fpHDLFile, "    TEAROFF_METHOD(%s, %s%s, %s, (%s%s))    // property set_%s\n",
                        szTearOffClassName,
                        pCtxt,
                        szTearoffMethod,
                        szTemp,
                        (LPCSTR)szProp,
                        (LPCSTR)szPropArgs,
                        (LPCSTR)pChildToken->GetTagValue(PROPERTY_NAME));
            }
            if (pChildToken->IsSet(PROPERTY_GET))
            {
                strcpy(szPropName, "get_");
                strcat(szPropName, pMethodName);
                if (FindTearoffMethod(pTearoff, szPropName, szTearoffMethod))
                {
                    strcpy(szPropArgs, (LPCSTR)pChildToken->GetTagValue(PROPERTY_ATYPE));
                    strcpy(szTearOffClassName, szClassName);
                }
                else if (!FindTearoffProperty(pChildToken, szTearoffMethod, szTearOffClassName, szPropArgs, TRUE))
                {
                    FindTearoffMethod(pTearoff, szPropName, szTearoffMethod);
                    strcpy(szPropArgs, (LPCSTR)pChildToken->GetTagValue(PROPERTY_ATYPE));
                    strcpy(szTearOffClassName, szClassName);
                }

                GenerateWin16TearoffName(szTemp, szTearoffMethod, szTearOffClassName);
                fprintf(fpHDLFile, "    TEAROFF_METHOD(%s, %s%s, %s, (%s%s *))    // property get_%s\n",
                        szTearOffClassName,
                        pCtxt,
                        szTearoffMethod,
                        szTemp,
                        (LPCSTR)szProp,
                        (LPCSTR)szPropArgs,
                        (LPCSTR)pChildToken->GetTagValue(PROPERTY_NAME));
            }
        }
    }

    return TRUE;
}

void CPDLParser::GenerateMethodImp ( Token *pClassToken,
    Token *pChildToken, BOOL fIsSet, CString &szHandler,
    CString &szHandlerArgs, CString &szOffsetOf, CString &szAType )
{
#if COLLECT_STATISTICS==1
    // Collect statistics on total property code turds.
    CollectStatistic(NUM_PROPTURDS, GetStatistic(NUM_PROPTURDS) + 1);
#endif

    char *szHandlerMethodPrefix;
    char *szAutomationMethodPrefix;
    if ( fIsSet )
    {
        szHandlerMethodPrefix = "Set";
        szAutomationMethodPrefix = "put_";
    }
    else
    {
        szHandlerMethodPrefix = "Get";
        szAutomationMethodPrefix = "get_";
    }


    // Allow enums with an ATYPE of BSTR to be automated with the string handler
    if ( szHandler == "Enum" && szAType == "BSTR" )
    {
        szHandler = "EnumString";

#if COLLECT_STATISTICS==1
    // Collect statistics on number of enum code turds.
    CollectStatistic(NUM_EMUMTURDS, GetStatistic(NUM_EMUMTURDS) + 1);
#endif
    }

    fprintf ( fpHDLFile,
        "STDMETHODIMP %s::%s%s(%s%s)\n{\n",
        (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
        (LPCSTR)szAutomationMethodPrefix,
        (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ),
        (LPCSTR)szAType,
        fIsSet ? " v" : " * p" );


    if ( pChildToken -> IsSet ( PROPERTY_PRECALLFUNCTION ) )
    {
        CString szfn;
        szfn = pChildToken -> GetTagValue ( PROPERTY_PRECALLFUNCTION ) ;
        // Give the super a chance to reject the call
        fprintf ( fpHDLFile, "    HRESULT hr;\n" );
        if ( szfn == "super" )
        {
            fprintf ( fpHDLFile, "    hr = super::%s%s(%s);\n",
                szAutomationMethodPrefix,
                (LPCSTR)pChildToken->GetTagValue ( PROPERTY_PRECALLFUNCTION ),
                fIsSet ? "v" : "p" );
        }
        else
        {
            fprintf ( fpHDLFile, "    hr = %s%s(%s);\n",
                szAutomationMethodPrefix,
                (LPCSTR)szfn,
                fIsSet ? "v" : "p" );
        }
        fprintf ( fpHDLFile, "    if ( hr )\n        return hr;\n" );
    }

    if ( fIsSet && pChildToken -> IsSet ( PROPERTY_SETDESIGNMODE ) )
    {
        fprintf ( fpHDLFile, "    if ( !IsDesignMode() )\n        return SetErrorInfo(CTL_E_SETNOTSUPPORTEDATRUNTIME);\n" );
    }

    if ( szAType == "VARIANT" )
    {
        fprintf ( fpHDLFile, "    return SetErrorInfo(s_propdesc%s%s.a.Handle%sProperty(%s, %s, this, CVOID_CAST%s));\n}\n",
            (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
            (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ),
            (LPCSTR)szHandler,
            (LPCSTR)szHandlerArgs,
            fIsSet ? "&v" : "p",
            (LPCSTR)szOffsetOf );
    }
    else if ( pChildToken -> IsSet ( PROPERTY_SUBOBJECT ) )
    {
        fprintf ( fpHDLFile, "    return %s::CreateSubObject ( GetElementPtr(), (PROPERTYDESC *)&s_propdesc%s%s,\n        ",
            (LPCSTR)pChildToken->GetTagValue ( PROPERTY_SUBOBJECT ),
            (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
            (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ));
        if ( pChildToken -> IsSet ( PROPERTY_PARAM1 ) )
        {
            fprintf ( fpHDLFile, "%s, ",
                (LPCSTR)pChildToken->GetTagValue ( PROPERTY_PARAM1 ) );
        }

        fprintf ( fpHDLFile, "p );\n}\n" );
    }
    else
    {
        if ( szHandler == "Num" || szHandler == "Enum" )
        {
            fprintf ( fpHDLFile,"    return s_propdesc%s%s.b.%sNumberProperty(%s, this, CVOID_CAST%s);\n}\n",
                (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ),
                (LPCSTR)szHandlerMethodPrefix,
                fIsSet ? "v" : "p",
                (LPCSTR)szOffsetOf );
        }
        else
        {
            fprintf ( fpHDLFile, "    return s_propdesc%s%s.b.%s%sProperty(%s, this, CVOID_CAST%s);\n}\n",
                (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ),
                (LPCSTR)szHandlerMethodPrefix,
                (LPCSTR)szHandler,
                fIsSet ? "v" : "p",
                (LPCSTR)szOffsetOf );
        }
    }
}


void CPDLParser::GenerateCPPEnumDefs ( void )
{
    Token *pToken;
    char *pEValText;

    // Only generate def's for this file
    CTokenListWalker TokenList ( pRuntimeList, _pszPDLFileName );

    fprintf ( fpHDLFile, "\n#ifndef _PROPDESCS_EXTERNAL\n\n" );

    // Generate propdescs for every property token in every class ( in this file )
    while ( pToken = TokenList.GetNext( TYPE_ENUM ) )
    {
        fprintf ( fpHDLFile, "EXTERN_C const ENUMDESC s_enumdesc%s = \n{ %u, %u, {\n",
            pToken->GetTagValue ( ENUM_NAME ) ,
            pToken->GetChildTokenCount(),
            pToken->uEnumMask );

        CTokenListWalker ChildList ( pToken );

        while ( pToken = ChildList.GetNext() )
        {
            // If a string is specified use it
            if ( pToken->IsSet ( EVAL_STRING ) )
            {
                pEValText = pToken->GetTagValue ( EVAL_STRING );
            }
            else
            {
                pEValText = pToken->GetTagValue ( EVAL_NAME );
            }
            fprintf ( fpHDLFile, "    { _T(\"%s\"),%s},\n",
                pEValText,
                pToken->GetTagValue ( EVAL_VALUE ) );
        }
        fprintf ( fpHDLFile, "} };\n\n" );
    }

    fprintf ( fpHDLFile, "#endif     // _PROPDESCS_EXTERNAL\n" );
}

void CPDLParser::GenerateInterfaceDISPIDs ( void )
{
    Token *pInterfaceToken;
    Token *pChildToken;
    CString szName;

    // Generate DISPID's for all interface methods that are not
    // ref'd to a class
    // Only generate def's for this file
    CTokenListWalker TokenList ( pRuntimeList, _pszPDLFileName );
    while ( pInterfaceToken = TokenList.GetNext( TYPE_INTERFACE ) )
    {
        szName = pInterfaceToken->GetTagValue ( INTERFACE_NAME );
        if ( szName == "IDispatch" )
            continue;
        fprintf ( fpHDLFile, "//    DISPIDs for class%s\n\n",
            (LPCSTR)pInterfaceToken->GetTagValue ( INTERFACE_NAME ) );
        CTokenListWalker ChildList ( pInterfaceToken );
        while ( pChildToken = ChildList.GetNext() )
        {
            if ( pChildToken -> GetType() == TYPE_METHOD &&
                !strlen( pChildToken -> GetTagValue ( METHOD_REFDTOCLASS ) ) &&
                pChildToken -> IsSet ( METHOD_DISPID ) )
            {
                Token   *pChildMatch = NULL;
                CString  szClassName;
                Token   *pClass;

                szClassName = pInterfaceToken -> GetTagValue( METHOD_REFDTOCLASS );
                pClass = FindClass ( szClassName );

                if (pClass)
                {
                    if (pChildToken->IsSet(METHOD_NOPROPDESC))
                    {
                        pChildMatch = FindMatchingEntryWOPropDesc(pClass, pChildToken);
                    }
                }

                if (!pChildMatch)
                    pChildMatch = pChildToken;

                fprintf ( fpHDLFile, "#define DISPID_%s_%s     %s\n",
                    (LPCSTR)pInterfaceToken->GetTagValue ( INTERFACE_NAME ),
                    (LPCSTR)pChildMatch->GetTagValue ( METHOD_NAME ),
                    (LPCSTR)pChildMatch->GetTagValue ( METHOD_DISPID ) );
            }
        }
    }

}

void CPDLParser::GenerateEventDISPIDs ( FILE *fp, BOOL fPutDIID )
{
    Token *pEventToken;
    Token *pChildToken;
    CString szName,szDISPName;
    int i,nLength;
    BOOL fPutComment;

    // Generate DISPID's for all interface methods that are not
    // ref'd to a class
    // Only generate def's for this file
    CTokenListWalker TokenList ( pRuntimeList, _pszPDLFileName );
    while ( pEventToken = TokenList.GetNext( TYPE_EVENT ) )
    {
        szName = pEventToken->GetTagValue ( EVENT_NAME );
        if ( szName == "IDispatch" || szName == "IUnknown" )
            continue;
        szName.ToUpper();

        fPutComment = FALSE;

        CTokenListWalker ChildList ( pEventToken );
        while ( pChildToken = ChildList.GetNext() )
        {
            if ( pChildToken -> GetType() == TYPE_METHOD &&
                !strlen( pChildToken -> GetTagValue ( METHOD_REFDTOCLASS ) ) &&
                pChildToken -> IsSet ( METHOD_DISPID ) )
            {
                if ( !fPutComment )
                {
                    fprintf ( fp, "//    DISPIDs for event set %s\n\n",
                        (LPCSTR)pEventToken->GetTagValue ( EVENT_NAME ) );
                    fPutComment = TRUE;
                }
                szDISPName = pChildToken->GetTagValue ( METHOD_NAME );
                szDISPName.ToUpper();
                fprintf ( fp, "#define DISPID_%s_%s ",
                    (LPCSTR)szName,
                    (LPCSTR)szDISPName );

                for ( i = 0, nLength = max ( 0, 49-szDISPName.Length()-szName.Length() ); i < nLength ; i++ )
                {
                    fprintf ( fp, " " );
                }

                fprintf ( fp, "%s\n",
                    (LPCSTR)pChildToken->GetTagValue ( METHOD_DISPID ) );
            }
        }
        if ( fPutDIID )
        {
            fprintf ( fp, "\nEXTERN_C const GUID DIID_%s;\n",
                pEventToken->GetTagValue ( EVENT_NAME ));
        }
        if ( fPutComment )
           fprintf ( fp, "\n" );
    }
}

void CPDLParser::GenerateExternalInterfaceDISPIDs ( void )
{
    Token *pInterfaceToken;
    Token *pChildToken;
    CString szName,szDISPName;
    int i,nLength;
    BOOL fPutComment;

    // Generate DISPID's for all interface methods that are not
    // ref'd to a class
    // Only generate def's for this file
    CTokenListWalker TokenList ( pRuntimeList, _pszPDLFileName );
    while ( pInterfaceToken = TokenList.GetNext( TYPE_INTERFACE ) )
    {
        szName = pInterfaceToken->GetTagValue ( INTERFACE_NAME );
        if ( szName == "IDispatch" || szName == "IUnknown" )
            continue;
        szName.ToUpper();

        fPutComment = FALSE;

        CTokenListWalker ChildList ( pInterfaceToken );
        while ( pChildToken = ChildList.GetNext() )
        {
            Token      *pChildMatch = NULL;
            CString     szClassName;
            Token      *pClass;

            if ( !fPutComment )
            {
                fprintf ( fpDISPIDFile, "//    DISPIDs for interface %s\n\n",
                    (LPCSTR)pInterfaceToken->GetTagValue ( INTERFACE_NAME ) );
                fPutComment = TRUE;
            }
            if ( pChildToken -> GetType() == TYPE_METHOD )
            {
                szDISPName = pChildToken->GetTagValue ( METHOD_NAME );

                szClassName = pChildToken -> GetTagValue( METHOD_REFDTOCLASS );
                pClass = FindClass ( szClassName );
                if (pClass)
                {
                    if (pChildToken->IsSet(METHOD_NOPROPDESC))
                    {
                        if (pChildToken->IsSet(METHOD_SZINTERFACEEXPOSE))
                            szDISPName = pChildToken->GetTagValue(METHOD_SZINTERFACEEXPOSE);

                        pChildMatch = FindMatchingEntryWOPropDesc(pClass, pChildToken);
                    }
                }

                if (!pChildMatch)
                    pChildMatch = pChildToken;
            }
            else
            {
                // Property

                szDISPName = pChildToken->GetTagValue ( PROPERTY_NAME );

                szClassName = pChildToken -> GetTagValue( PROPERTY_REFDTOCLASS );
                pClass = FindClass ( szClassName );
                if (pClass)
                {
                    if (pChildToken->IsSet(PROPERTY_NOPROPDESC))
                    {
                        if (pChildToken->IsSet(PROPERTY_SZINTERFACEEXPOSE))
                            szDISPName = pChildToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE);

                        pChildMatch = FindMatchingEntryWOPropDesc(pClass, pChildToken);
                    }
                }

                if (!pChildMatch)
                    pChildMatch = pChildToken;
            }
            szDISPName.ToUpper();
            
            fprintf ( fpDISPIDFile, "#define DISPID_%s_%s ",
                (LPCSTR)szName,
                (LPCSTR)szDISPName );

            for ( i = 0, nLength = max ( 0, 49-szDISPName.Length()-szName.Length() ); i < nLength ; i++ )
            {
                fprintf ( fpDISPIDFile, " " );
            }

            fprintf ( fpDISPIDFile, "%s\n",
                (LPCSTR)pChildMatch->GetTagValue ( PROPERTY_DISPID ) );
        }
        if ( fPutComment )
            fprintf ( fpDISPIDFile, "\n" );
    }
}



void CPDLParser::GenerateClassDISPIDs ( void )
{
    Token *pClassToken;
    Token *pChildToken;
    CString szCoClassName;

    // Only generate def's for this file
    CTokenListWalker TokenList ( pRuntimeList, _pszPDLFileName );

    // Generate propdescs for every property token in every class ( in this file )
    while ( pClassToken = TokenList.GetNext( TYPE_CLASS ) )
    {
        fprintf ( fpHDLFile, "//    DISPIDs for class %s\n\n", (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ) );

        if ( pClassToken -> IsSet ( CLASS_GUID ) )
        {
            pClassToken -> GetTagValueOrDefault ( szCoClassName,
                CLASS_COCLASSNAME, pClassToken -> GetTagValue ( CLASS_NAME ) );
            fprintf ( fpHDLFile, "EXTERN_C const GUID CLSID_%s;\n",
                (LPCSTR)szCoClassName );
        }
        CTokenListWalker ChildList ( pClassToken );
        while ( pChildToken = ChildList.GetNext() )
        {
            Token *pChildMatch = pChildToken;

            if ( pChildMatch->nType == TYPE_PROPERTY && pChildMatch->IsSet ( PROPERTY_DISPID ) )
            {
                if (pChildMatch->IsSet(PROPERTY_NOPROPDESC))
                {
                    pChildMatch = FindMatchingEntryWOPropDesc(pClassToken, pChildMatch);
                    if (!pChildMatch)
                        pChildMatch = pChildToken;
                }

                fprintf ( fpHDLFile, "#define DISPID_%s_%s     %s\n",
                    (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                    (LPCSTR)pChildMatch->GetTagValue ( PROPERTY_NAME ),
                    (LPCSTR)pChildMatch->GetTagValue ( PROPERTY_DISPID ) );

            }
            else if ( pChildMatch->nType == TYPE_METHOD && pChildMatch->IsSet ( METHOD_DISPID ) )
            {
                if (pChildMatch->IsSet(METHOD_NOPROPDESC))
                {
                    pChildMatch = FindMatchingEntryWOPropDesc(pClassToken, pChildMatch);
                    if (!pChildMatch)
                        pChildMatch = pChildToken;
                }

                fprintf ( fpHDLFile, "#define DISPID_%s_%s     %s\n",
                    (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                    (LPCSTR)pChildMatch->GetTagValue ( METHOD_NAME ),
                    (LPCSTR)pChildMatch->GetTagValue ( METHOD_DISPID ) );
            }
        }
    }
}

void CPDLParser::GeneratePropdescExtern ( Token *pClassToken, BOOL fRecurse )
{
    Token *pChild;
    Token *pSuperClassToken;
    CTokenListWalker ChildList ( pClassToken );

    // Add the supers definitions first.  Recurse to the super of this super!!
    // Notice that the fRecurse if used by abstract classes to only extern the
    // PropertyDesc which are generated for the actual class.
    pSuperClassToken = fRecurse ? GetSuperClassTokenPtr ( pClassToken ) : NULL;
    if ( pSuperClassToken )
        GeneratePropdescExtern ( pSuperClassToken );

    // Don't generate any EXTERN_C for abstract class reference.  The EXTERN_C
    // is only in the hdl that contains both the PROPERTYDESC the EXTERN_C for
    // the abstract class (e.g., bodyroot.hdl).
    if ( fRecurse && pClassToken -> IsSet ( CLASS_ABSTRACT ) )
        return;

    fprintf ( fpHeaderFile, "\n#ifndef _%s_PROPDESCS_\n", pClassToken -> GetTagValue ( CLASS_NAME ) );
    // Walk the super class propdescs looking for properties

    while ( pChild = ChildList.GetNext() )
    {
        if ( pChild->GetType() == TYPE_PROPERTY )
        {
            StorageType stHowStored;
            CString szHandler;
            CString szFnPrefix;


            szHandler = "";
            szFnPrefix = "";
            // Check for missing handler later
            GetTypeDetails ( pChild->GetTagValue ( PROPERTY_TYPE ),
                szHandler, szFnPrefix, &stHowStored );

            if ( !ComputePROPDESC_STRUCT ( fpHeaderFile, pClassToken, pChild, szHandler, szFnPrefix ) )
                return;       // Bad error reported...leave

            fprintf ( fpHeaderFile, " s_propdesc%s%s;\n",
                pClassToken -> GetTagValue ( CLASS_NAME ),
                pChild -> GetTagValue ( PROPERTY_NAME ) );
        }
        else if ( pChild->GetType() == TYPE_METHOD )
        {
            fprintf ( fpHeaderFile, "EXTERN_C const PROPERTYDESC_METHOD s_methdesc%s%s;\n",
                pClassToken -> GetTagValue ( CLASS_NAME ),
                pChild -> GetTagValue ( METHOD_NAME ) );
        }
    }

    fprintf ( fpHeaderFile, "\n#endif\n" );
}

BOOL CPDLParser::GeneratePropdescReference ( Token *pClassToken, 
                                            BOOL fDerivedClass, 
                                            PropdescInfo *pPI, 
                                            int *pnPI, 
                                            BOOL &bHookToCElement,
                                            int *pnSharedEntries )
{
    Token          *pChild;

    if (!pClassToken)
        return TRUE;

    CTokenListWalker ChildList ( pClassToken );

    // If the class superclass if CElement, we want to hook to CElement's hash table
    // If this is not the case, we want to do what we used to do and repeat
    // the super class properties in the subclasses.
    if(GetSuperClassTokenPtr ( pClassToken ) && 
       (strcmp(GetSuperClassTokenPtr ( pClassToken ) ->GetTagValue ( CLASS_NAME ),
               "CElement") == 0))
    {
        bHookToCElement = TRUE;
    }

    if ( !GeneratePropdescReference ( GetSuperClassTokenPtr ( pClassToken ), 
                                       FALSE, pPI, pnPI, 
                                       bHookToCElement, pnSharedEntries ) )
    {
        return FALSE;
    }
        
    if (fDerivedClass)
    {
        ChildList.Reset();
    }

    // Walk the super class propdescs looking for properties
    while ( pChild = ChildList.GetNext() )
    {
        if ( pChild->GetType() == TYPE_PROPERTY )
        {
            if ( !pChild->IsSet ( PROPERTY_INTERNAL ) && !pChild->IsSet ( PROPERTY_ABSTRACT ) &&
                     !pChild->IsSet( PROPERTY_NOPROPDESC ) &&
                    (!pChild->IsSet ( PROPERTY_NOPERSIST ) || 
                        ( pChild->IsSet ( PROPERTY_NOPERSIST ) && pClassToken->IsSet( CLASS_KEEPNOPERSIST ) ) ) )
            {
                if(bHookToCElement && (strcmp(pClassToken -> GetTagValue ( CLASS_NAME ), "CElement") == 0))
                {
                    *pnSharedEntries += 1;
                }
                else
                {
                    pPI[*pnPI].Set(pClassToken -> GetTagValue ( CLASS_NAME ),            
                                   pChild -> GetTagValue ( PROPERTY_NAME )  ,
                                   fDerivedClass,
                                   pChild->GetTagValue ( PROPERTY_SZATTRIBUTE ),
                                   PDLPARSE_BELONGSTOPARSE);
                    *pnPI += 1;
                }
            }
        }
    }

    return TRUE;
}

BOOL CPDLParser::GenerateCPC ( Token *pThisClassToken)
{
    if ( IsUniqueCPC ( pThisClassToken ) )
    {
        fprintf ( fpHDLFile, "\nconst CONNECTION_POINT_INFO %s::s_acpi[] = {\n",
           pThisClassToken -> GetTagValue ( CLASS_NAME ) );

        fprintf ( fpHDLFile, "    CPI_ENTRY(IID_IPropertyNotifySink, DISPID_A_PROPNOTIFYSINK)\n" );
        fprintf ( fpHDLFile, "    CPI_ENTRY(DIID_%s, DISPID_A_EVENTSINK)\n",
            pThisClassToken->GetTagValue( CLASS_EVENTS ) );
        if (pThisClassToken->IsSet(CLASS_NONPRIMARYEVENTS1))
        {
            fprintf(fpHDLFile, "    CPI_ENTRY(DIID_%s, DISPID_A_EVENTSINK)\n",
                    pThisClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS1));
        }
        if (pThisClassToken->IsSet(CLASS_NONPRIMARYEVENTS2))
        {
            fprintf(fpHDLFile, "    CPI_ENTRY(DIID_%s, DISPID_A_EVENTSINK)\n",
                    pThisClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS2));
        }
        if (pThisClassToken->IsSet(CLASS_NONPRIMARYEVENTS3))
        {
            fprintf(fpHDLFile, "    CPI_ENTRY(DIID_%s, DISPID_A_EVENTSINK)\n",
                    pThisClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS3));
        }
        if (pThisClassToken->IsSet(CLASS_NONPRIMARYEVENTS4))
        {
            fprintf(fpHDLFile, "    CPI_ENTRY(DIID_%s, DISPID_A_EVENTSINK)\n",
                    pThisClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS4));
        }
        fprintf ( fpHDLFile, "    CPI_ENTRY(IID_ITridentEventSink, DISPID_A_EVENTSINK)\n" );
        fprintf ( fpHDLFile, "    CPI_ENTRY(IID_IDispatch, DISPID_A_EVENTSINK)\n" );
        fprintf ( fpHDLFile, "    CPI_ENTRY_NULL\n};\n" );
    }

    return TRUE;
}


#ifdef COMPLUS_SHIM

void
CPDLParser::GenComPlusInheritance (Token *pClass, CString & inheritanceCStr)
{
    // Any other interface to expose in the coclass which is part of the primary
    // interface?
    CString				primaryInterfCStr;
    CTokenListWalker    ChildWalker(pClass);
    Token              *pChildToken;
    BOOL				fFirstInterf;

    // Get the primary interface, if one exists.
    if (pClass->IsSet(CLASS_INTERFACE))
    {
        primaryInterfCStr = pClass->GetTagValue(CLASS_INTERFACE);
        inheritanceCStr = "public ICOMCookie, public ";
        inheritanceCStr += primaryInterfCStr;
        inheritanceCStr += "COMPLUS";
        fFirstInterf = FALSE;
    }
    else
    {
        inheritanceCStr = "";
        fFirstInterf = TRUE;
    }

    while (pChildToken = ChildWalker.GetNext())
    {
        if (pChildToken->GetType() == TYPE_IMPLEMENTS)
        {
            Token      *pInterf;
            CString     szInterface;

            szInterface = pChildToken->GetTagValue(IMPLEMENTS_NAME);
            pInterf = FindInterface(szInterface);
            if (pInterf)
            {
                // Is the interface a local one if not then don't check, we
                // only need to check where interfaces are actually used.
                if (FindInterfaceLocally(szInterface))
                {
                    // If the super isn't specified and it's not a primary interface
                    // then error the super is required for non-primary interfaces.
                    if (_stricmp((LPSTR)pClass->GetTagValue(CLASS_INTERFACE),
                                 (LPSTR)pInterf->GetTagValue(INTERFACE_NAME)) &&
                        !pInterf->IsSet(INTERFACE_SUPER) &&
                        !IsPrimaryInterface(szInterface))
                    {
                        char szErrorText [ MAX_LINE_LEN+1 ];

                        sprintf(szErrorText, "Interface %s missing super key.\n",
                                (LPSTR)pInterf->GetTagValue(INTERFACE_NAME));
                        ReportError(szErrorText);

                        return;
                    }
                }

                // If an implements is a primary interface then don't inherit again we did that at the beginning.
                if (primaryInterfCStr != szInterface)
                {
                    if (fFirstInterf)
                    {
                        fFirstInterf = FALSE;
                    }
                    else
                    {
                        inheritanceCStr += ",";
                    }

                    inheritanceCStr += " public ";
                    inheritanceCStr += pInterf->GetTagValue(INTERFACE_NAME);
                    inheritanceCStr += "COMPLUS";
                }
            }
        }
    }
}
#endif    // COMPLUS_SHIM

void
CPDLParser::GenerateVTableArray (Token *pThisClassToken, BOOL *pbHashTableExists )
{
    Token          *pDerivedClass;
    PropdescInfo    rgPI[400];          // Max. number of method/prop for interface.
    int             nPI = 0;
    UINT            uVTblIndex = 0;
    CString         szInterf;
    Token          *pInterf;
    BOOL            bHookToCElement = FALSE;
    int             nSharedEntries = 0;

    *pbHashTableExists = FALSE;

    // Abstract classes don't need the vtable unless they name is CElement
    // TODO: Terry, Implement the shared keywork here.
    if ( (pThisClassToken->IsSet ( CLASS_ABSTRACT )) && 
         (_stricmp(pThisClassToken->GetTagValue(CLASS_NAME), "CElement") != 0))
        return;

    pDerivedClass = pThisClassToken;

GetInterf:
    szInterf = pDerivedClass->GetTagValue(CLASS_INTERFACE);
    // If no interface then use the super to find an interface.
    if (!szInterf.Length())
    {
        CString     szClass;

        szClass = pDerivedClass -> GetTagValue ( CLASS_SUPER );
        pDerivedClass = FindClass(szClass);
        if (!pDerivedClass)
            ReportError ( "Unknown class\n" );

        goto GetInterf;
    }

    pInterf = FindInterface(szInterf);
    if (pInterf || strcmp((LPCSTR)szInterf, "IDispatch") == 0)
    {
#ifdef COMPLUS_SHIM

        // ***TLL*** COM+: Not spitting COM+ proxies for internal.pdl and mshtmext.pdl need to do, shouldn't special case.
        BOOL fInternalPDL = (_stricmp(_pszPDLFileName, "internal.pdl") == 0) || (_stricmp(_pszPDLFileName, "mshtmext.pdl") == 0);

        // Do we have a real coclass w/ a real GUID?
        if (pThisClassToken->IsSet(CLASS_GUID) &&
            pThisClassToken->IsSet(CLASS_INTERFACE) && !fInternalPDL)
        {
            // Then let's do some COM+ work...
            CString		inheritDecl;
            CString		szClassName;

            if (pThisClassToken->IsSet(CLASS_COCLASSNAME))
                szClassName = pThisClassToken->GetTagValue(CLASS_COCLASSNAME);
            else
                szClassName = pThisClassToken->GetTagValue(CLASS_NAME);

			// Window needs some special processing as this is how unmanaged code hooks to
			// managed code.
			if (szClassName == "HTMLWindow2")
			{
				fprintf(fpHComPlusFile, "[managed, com, uuid={FF6BF9BB-FF1B-348D-8C21-CE642A866E7F}] __interface ICOMPLUSHookWindow\n");
				fprintf(fpHComPlusFile, "{\n");
				fprintf(fpHComPlusFile, "public:\n");
	            fprintf(fpHComPlusFile, "\tvoid Init(unsigned int myThis);\n");
				fprintf(fpHComPlusFile, "};\n\n");
			}

            // COM+ managed code:
            fprintf(fpHComPlusFile, "[managed, coclass");
			if (szClassName == "HTMLWindow2")
			{
				fprintf(fpHComPlusFile, " , uuid={D66BF9BF-FF1B-348D-8C21-CE642A866E7F}");
			}
            fprintf(fpHComPlusFile, "] class %sCOMPLUS", (LPCSTR)szClassName);

            GenComPlusInheritance(pThisClassToken, inheritDecl);
            if (inheritDecl.Length())
            {
                fprintf(fpHComPlusFile, " : %s", (LPCSTR)inheritDecl);
				if (szClassName == "HTMLWindow2")
				{
					fprintf(fpHComPlusFile, ", private ICOMPLUSHookWindow");
				}

				fprintf(fpHComPlusFile, "\n{\n");
            }
            else
            {
                fprintf(fpHComPlusFile, "\n{\n");
            }			

            fprintf(fpHComPlusFile, "private:\n");
            fprintf(fpHComPlusFile, "\tunsigned int\t_myThis;\n\n");

            fprintf(fpHComPlusFile, "public:\n");
            fprintf(fpHComPlusFile, "\t%sCOMPLUS (unsigned int myThis)\n\t\t{ _myThis = myThis; }\n\n", (LPCSTR)szClassName);
            fprintf(fpHComPlusFile, "\tunsigned int getCOMCookie()\n\t\t{ return _myThis; }\n\n");

			if (szClassName == "HTMLWindow2")
			{
				fprintf(fpHComPlusFile, "\tHTMLWindow2COMPLUS ()\n");
				fprintf(fpHComPlusFile, "\t\t{ _myThis = 0; }\n\n");
				fprintf(fpHComPlusFile, "\tvoid Init(unsigned int myThis)\n\t\t{ _myThis = myThis; }\n\n");
			}
		}

#endif   // COMPLUS_SHIM
        CVTableHash VTableHash; // Special hashtable that aids in spitting out the hash table

        // Add the parser properties to the PropdescInfo array
        if(!GeneratePropdescReference(pThisClassToken, TRUE, rgPI, &nPI, bHookToCElement, &nSharedEntries ))
            ReportError("Error Storing PropDescs in PROPDESC array in HashTable");

        // Add the OM properties and methods to the PropdescInfo array
        if (pInterf)
        {
            ComputeVTable( pThisClassToken, 
                           pInterf, 
                           FALSE, 
                           rgPI, 
                           &nPI, 
                           &uVTblIndex,
                           &VTableHash,
                           bHookToCElement);

        }


#ifdef COMPLUS_SHIM
        if (pThisClassToken->IsSet(CLASS_GUID) &&
            pThisClassToken->IsSet(CLASS_INTERFACE) && !fInternalPDL)
        {
            fprintf(fpHComPlusFile, "};\n\n\n");
        }
#endif   // COMPLUS_SHIM
            
        // Number of entries in vtable array.
        *pbHashTableExists = bHookToCElement || (nPI > 0);

        // Write out the "style" mini-propdesc array if we are dealing with
        // the element class.  The reason we do this is because a parser and OM
        // propdesc (both of which are different) resolve to the same entry in 
        // the hash table.  Hence, we have to make a hack and have the name resolve 
        // to an array of propdescs.
        if(strcmp(pThisClassToken->GetTagValue(CLASS_NAME), "CElement") == 0)
        {
            fprintf(fpHDLFile, "static const PROPERTYDESC *s_propdescCElementStyleArray [ ] = \n"
                              "{\n"
                              "    (PROPERTYDESC *)&s_propdescCElementstyle,\n"
                              "    (PROPERTYDESC *)&s_propdescCElementstyle_Str\n"
                              "};\n");
        } 
        else if(strcmp(pThisClassToken->GetTagValue(CLASS_NAME), "CInput") == 0)
        {
            fprintf(fpHDLFile, "static const PROPERTYDESC *s_propdescCInputCheckedArray [ ] = \n"
                              "{\n"
                              "    (PROPERTYDESC *)&s_propdescCInputchecked,\n"
                              "    (PROPERTYDESC *)&s_propdescCInputdefaultChecked\n"
                              "};\n");
        }

        // Write out the hash table
        // Convert the class to a Unicode string so that it works correctly
        // with the hash table, which is Unicode.
        WCHAR strUnicode[256];
        int retVal = 
            MultiByteToWideChar(CP_ACP, 0, pThisClassToken->GetTagValue(CLASS_NAME),
                                256,
                                strUnicode, 256);
        if(retVal == 0)
        {
            ReportError("Error: Unable to convert classname to a Unicode string");
            return;
        }

        if(VTableHash.GetHashTableLength() > 1024)
        {
            ReportError("Error: Hash table size has grown beyond 10K. Find more bits!");
            return;
        }
        if(VTableHash.ToFile(fpHDLFile, 
                             strUnicode,
                             nSharedEntries) != S_OK)
        {
            ReportError("Error: Unable to write out hashtable");
            return;
        }

        // Write out the Hash Table Aggregate
        fprintf(fpHDLFile, 
                "const CPtrBagVTableAggregate %s::s_StringTableAggregate = {\n"
                "    {\n", pThisClassToken->GetTagValue(CLASS_NAME));
        if(bHookToCElement)
            fprintf(fpHDLFile, "        (CPtrBagVTable *)&CElement::s_StringTable,\n");

        // Every class aggregates to itself.
        fprintf(fpHDLFile, 
                "        (CPtrBagVTable *)&%s::s_StringTable,\n"
                "        NULL\n"
                "    }\n"
                "};\n", pThisClassToken->GetTagValue(CLASS_NAME));

        // Store away a special cache for the document
        if(_stricmp(pThisClassToken->GetTagValue(CLASS_NAME), "COmWindowProxy") == 0)
        {
            DWORD index;

            if(!VTableHash.GetIndex(_T("document"), &index))
            {
                ReportError("The document must exist in the COmWindowProxy");
                return;
            }

            fprintf(fpHDLFile, "const VTABLEDESC * const COmWindowProxy::s_COmWindowProxyDocument = &s_AssocVTableCOmWindowProxy%d._VTableDesc;\n", index);
        }
    }
    else
    {
        char szErrorText [ MAX_LINE_LEN+1 ];

        sprintf( szErrorText, "Unknown interface %s\n", (LPCSTR) szInterf );
        ReportError ( szErrorText );
    }
}


void
CPDLParser::SortPropDescInfo (PropdescInfo *pPI, int cPDI)
{
    int             x, y, cc;        
    PropdescInfo    pd;

    //sort em
    for (x = 0; x < cPDI - 1; ++x)
    {
        for (y = x; y < cPDI; ++y)
        {
            cc = _stricmp( pPI[x]._szSortKey, pPI[y]._szSortKey );  // API caveat
            if (cc > 0)
            {
                memcpy(&pd, pPI + x, sizeof(pd));
                memcpy(pPI + x, pPI + y, sizeof(pd));
                memcpy(pPI + y, &pd, sizeof(pd));
            }
        }
    }
}
BOOL
CPDLParser::ComputeVTable ( Token *pClass, 
                            Token *pInterface, 
                            BOOL fDerived, 
                            PropdescInfo *pPI, 
                            int *piPI, 
                            UINT *pUVTblIdx, 
                            CVTableHash *pVTableHash,
                            BOOL &bHookToCElement,
                            BOOL fNonPrimaryTearoff/*= FALSE*/ )
{
    CString         szSuperInterf;
    Token          *pChildToken;
    int             cFuncs = 0;
    BOOL            fProperty = FALSE;
    int             idxIIDPrimaryTearoff = -1;
    int				idxIID;
    CString			szInterface;
    // Compute if this interface on the class is a primary interface tearoff.
    if (!fNonPrimaryTearoff)
    {
        Token      *pTearoff;

        pTearoff = FindTearoff(pClass->GetTagValue(CLASS_NAME), pInterface->GetTagValue(INTERFACE_NAME));

        if (pTearoff)
        {
            CString     szInterface;
            Token      *pInterfaceToken;

            szInterface = pTearoff->GetTagValue(TEAROFF_INTERFACE);
            pInterfaceToken = FindInterface(szInterface);

            // If primary interface is not derived from IDispatch then this
            // interface and all derived interfaces (vtable layout) are separated
            // not concatenated.
            LPSTR szSuperPrimaryInterf = pInterfaceToken->GetTagValue(INTERFACE_SUPER);

            if (szSuperPrimaryInterf && *szSuperPrimaryInterf)
                fNonPrimaryTearoff = ((_stricmp(szSuperPrimaryInterf, "IDispatch") ||
                                      (_stricmp(pClass->GetTagValue(CLASS_NAME), "CElement") == 0)));
            else
            {
                fNonPrimaryTearoff = FALSE;
            }
        }
    }

    szInterface = pInterface->GetTagValue(INTERFACE_NAME);
    // We want classes which have their primary interface IHTMLElement
    // and are derived from CElement to hook to CElement
    if((szInterface == "IHTMLElement") &&
       (_stricmp(pClass->GetTagValue(CLASS_NAME), "CElement") != 0))
    {
        bHookToCElement = TRUE;
    }
    else
    {
        idxIID = FindAndAddIIDs(szInterface);
        if (idxIID == -1)
        {
            ReportError("Problem with IID adding.\n");
            return FALSE;
        }

        if (fNonPrimaryTearoff)
            idxIIDPrimaryTearoff = idxIID;

        szSuperInterf = pInterface->GetTagValue(INTERFACE_SUPER);
        if (szSuperInterf && *szSuperInterf && szSuperInterf != "IDispatch")
        {
            Token  *pSuperInterf;

            pSuperInterf = FindInterface(szSuperInterf);
            if (!pSuperInterf)
                return FALSE;

            if (!ComputeVTable(pClass, 
                               pSuperInterf, 
                               TRUE, 
                               pPI, 
                               piPI, 
                               pUVTblIdx, 
                               pVTableHash,
                               bHookToCElement,
                               fNonPrimaryTearoff))
                return FALSE;
        }

        CTokenListWalker ChildList ( pInterface );
        while ( pChildToken = ChildList.GetNext() )
        {
            UINT    uIIDnVTbl;

            cFuncs = 0;

            if ( pChildToken -> GetType() == TYPE_PROPERTY )
            {
                fProperty = TRUE;
                cFuncs = pChildToken -> IsSet ( PROPERTY_GET ) ? 1 : 0;
                cFuncs += (pChildToken -> IsSet ( PROPERTY_SET ) ? 1 : 0);
        
                if (pChildToken->IsSet(PROPERTY_NOPROPDESC))
                    goto AddInVTable;
            }
            else if ( pChildToken -> GetType() == TYPE_METHOD )
            {
                fProperty = FALSE;
                cFuncs = 1;

                if (pChildToken->IsSet(METHOD_NOPROPDESC))
                    goto AddInVTable;
            }
            else
            {
                ReportError ( "Unknown token type in ComputeVTable.\n" );
                return FALSE;
            }

            // Compute vtable offset.  If primary interface is a tearoff then set
            // the offset and the idx into the IID table.  Note, all indexes start
            // at 1 (zero is reserved to imply classdesc primary interface).
            uIIDnVTbl = fNonPrimaryTearoff ? (((idxIIDPrimaryTearoff + 1) << 8) | *pUVTblIdx) : *pUVTblIdx;

            pPI[*piPI].SetVTable(pChildToken -> GetTagValue ( fProperty ? (int)PROPERTY_REFDTOCLASS : (int)METHOD_REFDTOCLASS ),
                   pChildToken -> GetTagValue ( fProperty ? (int)PROPERTY_NAME : (int)METHOD_NAME ),
                   FALSE,			// Unused.
                   pChildToken -> GetTagValue ( PROPERTY_SZATTRIBUTE ),
                   uIIDnVTbl | PDLPARSE_BELONGSTOOM,		// Computed IID/VTable where iidIdx might be zero for the primary interface.
                   fProperty,
                   idxIID,			// Index of interface
                   pChildToken);

            (*piPI)++;

    AddInVTable:
            (*pUVTblIdx) += cFuncs;
        }
    }

    // Each derived interface of the primary tearoff is separated not a straight
    // derivation.
    if (fNonPrimaryTearoff && _stricmp(szInterface, "IHTMLDocument"))
        *pUVTblIdx = 0;

    // Top most interface?
    if ( !fDerived )
    {
        // Now check for any other interfaces mentioned in the as implements in
        // the class it is exposed in the coclass, that interface is a
        // separately supported interface.

        CTokenListWalker    ChildWalker(pClass);
        Token              *pChildToken;
        CString             szInterface;
        Token              *pInterfToken;

        while (pChildToken = ChildWalker.GetNext())
        {
            if (pChildToken->GetType() == TYPE_IMPLEMENTS)
            {
                *pUVTblIdx = 0;         // implements always starts at 0 vtable offset.

                szInterface = pChildToken->GetTagValue(IMPLEMENTS_NAME);
                if(_stricmp(pInterface->GetTagValue(INTERFACE_NAME), szInterface) == 0)
                    continue;
                // TODO: TerryLu - Need to add code here to recongize and handle
                // shares.  Currently, we hardcode the following interfaces
                // as once which are shared and implemented by CElement directly
        
                if (szInterface == "IHTMLElement6")
                {
                    ReportError ( "Need to Add IHTMLElement6 in parser.cxx(ComputeVTable())" );
                    return FALSE;
                }

                if  ( ((szInterface == "IHTMLElement") ||
                       (szInterface == "IHTMLElement2") ||
                       (szInterface == "IHTMLElement3") ||
                       (szInterface == "IHTMLElement4") ||
                       (szInterface == "IHTMLElement5") ) && 
                    ((_stricmp(pClass->GetTagValue(CLASS_NAME), "CElement") != 0)) )
                {
                    bHookToCElement = TRUE;
                    continue;
                }

                pInterfToken = FindInterface(szInterface);
                if (pInterfToken)
                {
                    if (!ComputeVTable(pClass, 
                                       pInterfToken, 
                                       TRUE, 
                                       pPI, 
                                       piPI, 
                                       pUVTblIdx, 
                                       pVTableHash,
                                       bHookToCElement,
                                       TRUE))
                        return FALSE;
                }
            }
        }

        // Output the vtable interface sorted by name.
        for (int iVTbl = 0; iVTbl < *piPI; iVTbl++)
        {
            PropdescInfo *pPrevPropdescInfo;
            // Convert the sort key to unicode since the HashTable is in Unicode
            WCHAR strUnicode[256];
            int retVal = 
                MultiByteToWideChar(CP_ACP, 0, pPI[iVTbl]._szSortKey,
                                    256,
                                    strUnicode, 256);
            if(retVal == 0)
            {
                ReportError("Unable to convert class name to Unicode");
                return FALSE;
            }

            // Change the style property to point to a special array
            // of PropertyDescs if we are dealing with the CElement class
            if((_stricmp(pPI[iVTbl]._szSortKey, "style") == 0) &&
               (_stricmp(pClass->GetTagValue(CLASS_NAME), "CElement") == 0))
            {
                pPI[iVTbl]._szPropName = "StyleArray";
                pPI[iVTbl]._uVTblIndex |= PDLPARSE_PROPDESCARRAY;
                pPI[iVTbl]._uVTblIndex |= PDLPARSE_BELONGSTOBOTH;
            } 
            else if((_stricmp(pPI[iVTbl]._szSortKey, "checked") == 0) &&
                    (_stricmp(pClass->GetTagValue(CLASS_NAME), "CInput") == 0))
            // Change the checked property to point to a special array
            // of PropertyDescs if we are dealing with the CInput class
            {
                pPI[iVTbl]._szPropName = "CheckedArray";
                pPI[iVTbl]._uVTblIndex |= PDLPARSE_PROPDESCARRAY;
                pPI[iVTbl]._uVTblIndex |= PDLPARSE_BELONGSTOBOTH;
            }

            // If the hash table entry was already set by the parser,
            // make it a shared entry by the parser and OM.
            pPrevPropdescInfo = (PropdescInfo *)pVTableHash->GetCi(strUnicode);
            if(pPrevPropdescInfo)
            {
                // We cannot have two different properties map to the same name
                // unless they are ones we already know about
                if((_stricmp(pPrevPropdescInfo->_szPropName, pPI[iVTbl]._szPropName) != 0) &&
                   (_stricmp(pPI[iVTbl]._szSortKey, "checked") != 0) &&
                   (_stricmp(pPI[iVTbl]._szSortKey, "style") != 0))
                {
                    ReportError("We cannot have two different properties map to the same name");
                    return FALSE;
                }
                pPI[iVTbl]._uVTblIndex |= PDLPARSE_BELONGSTOBOTH;
            }

            // Set the entry in the hash table
            if(pVTableHash->SetCi(strUnicode, 
                                  &pPI[iVTbl]) != S_OK)
            {
                ReportError("Error: Unable to add Hash entry to table");
                return FALSE;
            }

#ifdef COMPLUS_SHIM

            //  ***TLL*** COM+: Not spitting COM+ proxies for internal.pdl and mshtmext.pdl need to do, shouldn't special case.
            BOOL fInternalPDL = (_stricmp(_pszPDLFileName, "internal.pdl") == 0) || (_stricmp(_pszPDLFileName, "mshtmext.pdl") == 0);

            // Output COM+ code, only real classes are exposed.
            if (pClass->IsSet(CLASS_GUID) && pClass->IsSet(CLASS_INTERFACE) && !fInternalPDL)
            {
                GenComPlusDeclarations(pClass, pPI + iVTbl);
            }

#endif    // COMPLUS_SHIM
        }
    }

    return TRUE;
}


#ifdef COMPLUS_SHIM

void
CPDLParser::GenComPlusMethodsInInterfaces(Token *pInterfaceToken, Token *pClass /* =NULL */)
{
    Token *pChildToken;
    CString szMethodName;
    CString szPropertyName;
    CString argCStr;
    CString resultCStr;

    CTokenListWalker ChildWalker(pInterfaceToken);

    while (pChildToken = ChildWalker.GetNext())
    {
        if (pChildToken->GetType() == TYPE_METHOD)
        {
// ***TLL*** Need to handle vararg arguments. [METHOD_VARARG]

            if (pChildToken->IsSet(METHOD_NOPROPDESC) &&
                pChildToken->IsSet(METHOD_SZINTERFACEEXPOSE))
            {
                szMethodName = pChildToken->GetTagValue(METHOD_SZINTERFACEEXPOSE);
            }
            else
            {
                szMethodName = pChildToken->GetTagValue(METHOD_NAME);
            }

            if (GenComPlusArgumentSignature(pChildToken, resultCStr, argCStr))
            {
                fprintf(fpHComPlusFile, "\t%s %s %s;\n",
                        (LPCSTR)resultCStr,
                        (LPCSTR)szMethodName,
                        (LPCSTR)argCStr);
            }
        }
        else // Property
        {
            if (pChildToken->IsSet(PROPERTY_NOPROPDESC) &&
                pChildToken->IsSet(PROPERTY_SZINTERFACEEXPOSE))
            {
                szPropertyName = pChildToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE);
            }
            else
            {
                szPropertyName = pChildToken->GetTagValue(PROPERTY_NAME);
            }

            if (pChildToken->IsSet(PROPERTY_SET))
            {
// ***TLL*** COM+: What happens to displaybind, bindable, hidden, restricted, nonbrowsable, source.

                if (GenComPlusArgumentSignature(pChildToken, resultCStr, argCStr, SetProperty))
                {
                    fprintf(fpHComPlusFile, "\t%s %s %s;\n",
                            (LPCSTR)resultCStr,
                            (LPCSTR)szPropertyName,
                            (LPCSTR)argCStr);
                }
            }

            if (pChildToken->IsSet(PROPERTY_GET))
            {
// ***TLL*** COM+: What happens to displaybind, bindable, hidden, restricted, nonbrowsable, source.

                if (GenComPlusArgumentSignature(pChildToken, resultCStr, argCStr, GetProperty))
                {
                    fprintf(fpHComPlusFile, "\t%s %s %s;\n",
                            (LPCSTR)resultCStr,
                            (LPCSTR)szPropertyName,
                            (LPCSTR)argCStr);
                }
            }
        }
    }
}

void
CPDLParser::GenComPlusInterfaces(Token *pInterfaceToken, char* pszSuper)
{
    CString		szInterf;
    Token		*pSuperInterf;

#if 0
if (_stricmp("IHTMLStyle", pInterfaceToken->GetTagValue(NAME_TAG)) == 0)
__asm { int 3 };
#endif

    if (!PrimaryTearoff(pInterfaceToken) && (!pszSuper || !*pszSuper))
        ReportError("COM+: Interfaces w/o tearoff need super:IDispatch\n");

    // ***TLL*** COM+: For now don't expose any IUnknown derived classes.
    if (_stricmp(pszSuper, "IUnknown") == 0)
        return;

    // Is the super derived from IUnknown?

    szInterf = pszSuper;
    pSuperInterf = FindInterface(szInterf);
    if (pSuperInterf)
    {
        if (_stricmp(pSuperInterf->GetTagValue(INTERFACE_SUPER), "IUnknown") == 0)
            return;
    }
    // ***TLL*** End of comment section

    if (pInterfaceToken->IsSet(INTERFACE_CUSTOM) && pszSuper && *pszSuper)
    {
        fprintf(fpHComPlusFile, "[managed, com] interface %sCOMPLUS : public ICOMCookie, public %sCOMPLUS\n{\npublic:\n",
                pInterfaceToken->GetTagValue(NAME_TAG),
                pszSuper);
    }
    else
    {
        if (PrimaryTearoff(pInterfaceToken))
        {
            fprintf(fpHComPlusFile, "[managed, com] interface %sCOMPLUS : public ICOMCookie \n{\npublic:\n",
                    pInterfaceToken->GetTagValue(NAME_TAG));
        }
        else
        {
            if (strcmp("IDispatch", pszSuper) == 0)
            {
                fprintf(fpHComPlusFile, "[managed, com] interface %sCOMPLUS : public ICOMCookie \n{\npublic:\n",
                        pInterfaceToken->GetTagValue(NAME_TAG));
            }
            else
            {
                fprintf(fpHComPlusFile, "[managed, com] interface %sCOMPLUS : public ICOMCookie, public %sCOMPLUS \n{\npublic:\n",
                        pInterfaceToken->GetTagValue(NAME_TAG), pszSuper);
            }
        }
    }

    // Fill in methods of interface:
    GenComPlusMethodsInInterfaces(pInterfaceToken);

    fprintf(fpHComPlusFile, "};\n\n");
}


void
CPDLParser::GenComPlusESI()
{
    CTokenListWalker ThisFileList(pRuntimeList, _pszPDLFileName);
    Token * pInterfaceToken;
    Token * pEnumToken;
    Token * pStructToken;

    //
    // Generate all the event interfaces
    //
    ThisFileList.Reset();
    while (pInterfaceToken = ThisFileList.GetNext(TYPE_EVENT))
    {
        if (!pInterfaceToken->IsSet(EVENT_ABSTRACT) &&
            pInterfaceToken->IsSet(EVENT_GUID))
        {
// TODO: ***TLL*** Need to spit out event interfaces.
        }
    }

    //
    // Generate all the enumerators.
    //
    ThisFileList.Reset();
    while (pEnumToken = ThisFileList.GetNext(TYPE_ENUM))
    {
// TODO: ***TLL*** Need to spit out enums.
    }
    
    //
    // Generate all the structs
    //
    ThisFileList.Reset();
    while (pStructToken = ThisFileList.GetNext(TYPE_STRUCT))
    {
// TODO: ***TLL*** Need to spit out structs.
    }
    
    //
    // Generate all the non-abstract interfaces.
    //
    ThisFileList.Reset();
    while ( pInterfaceToken = ThisFileList.GetNext(TYPE_INTERFACE))
    {
        if (!pInterfaceToken->IsSet(INTERFACE_ABSTRACT) &&
            pInterfaceToken->IsSet(INTERFACE_GUID))
        {
            GenComPlusInterfaces(pInterfaceToken, pInterfaceToken->GetTagValue(INTERFACE_SUPER));
        }
        else if (!pInterfaceToken->IsSet(INTERFACE_ABSTRACT) &&
                 !pInterfaceToken->IsSet(INTERFACE_GUID))
        {
            // Generate a forward declare
            CString szInterfaceName;
            
            szInterfaceName = pInterfaceToken->GetTagValue(INTERFACE_NAME);
            if (szInterfaceName != "IDispatch" && szInterfaceName != "IUnknown")
            {
                fprintf(fpHComPlusFile, "interface %sCOMPLUS;\n", pInterfaceToken->GetTagValue(NAME_TAG));
            }
        }
    }
}


BOOL
CPDLParser::GenComPlusArgumentSignature(Token *pMethod, CString & resultCStr, CString & argCStr, PropertyType propType /* = NotProperty */)
{
    BOOL    fNameOnly;
    LPCSTR	pSimpleType;
    char	pComPlusType[128];
    BOOL	fRet = FALSE;			// Assume don't want to expose method/property

    resultCStr = "";
    argCStr = "";

    fNameOnly = _stricmp(pMethod->GetTagValue(METHOD_NOPROPDESC), "nameonly") == 0;

    if (pMethod->GetType() == TYPE_METHOD && !fNameOnly)
    {
        CTokenListWalker	ArgListWalker(pMethod);
        BOOL				fResultFound = FALSE;
        CString				szAutomationType;
        Token				*pArgToken;
        int					cAType;

        while (pArgToken = ArgListWalker.GetNext())
        {
            if (pArgToken->IsSet(METHODARG_RETURNVALUE))
            {
                szAutomationType = pArgToken->IsSet(METHODARG_ATYPE) ?
                                        pArgToken->GetTagValue(METHODARG_ATYPE) :
                                        pArgToken->GetTagValue(METHODARG_TYPE);

                cAType = szAutomationType.Length();
                if (cAType && szAutomationType[cAType - 2] == '*')
                {
                    szAutomationType.PutChar(cAType - 2, '\0');
                }
                else if (cAType && szAutomationType[cAType - 1] == '*')
                {
                    szAutomationType.PutChar(cAType - 1, '\0');
                }

#if 0
if (szAutomationType == "IHTMLControlElement")
__asm {int 3};
#endif

                pSimpleType = ConvertType(szAutomationType, TRUE, &pComPlusType[0]);

                resultCStr = pSimpleType ? pSimpleType : pComPlusType;

                fResultFound = TRUE;
            }
        }

        if (!fResultFound)
        {
            resultCStr = "void";
        }

        BOOL				fFirst = TRUE;
        int					idx = 1;
        char				buffer[40];

        argCStr = "(";
        ArgListWalker.Reset();

        while (pArgToken = ArgListWalker.GetNext())
        {
            if (!pArgToken->IsSet(METHODARG_RETURNVALUE))
            {
                if (!fFirst)
                {
                    argCStr += ", ";
                }

                szAutomationType = pArgToken->GetTagValue(METHODARG_TYPE);

                cAType = szAutomationType.Length();
                if (cAType && szAutomationType[cAType - 1] == '*')
                {
                    szAutomationType.PutChar(cAType - 1, '\0');
                }

                pSimpleType = ConvertType(szAutomationType, TRUE, &pComPlusType[0]);
                argCStr += pSimpleType ? pSimpleType : pComPlusType;
                argCStr += " param";
                _itoa(idx++, buffer, 10);
                argCStr += buffer;
            }

            fFirst = FALSE;
        }

        argCStr += ")";

        fRet = TRUE;
    }
    else
    {
        // Property
        CString		szAutomationType;
        int			cAType;

        fNameOnly = _stricmp(pMethod->GetTagValue(PROPERTY_NOPROPDESC), "nameonly") == 0;

        szAutomationType = pMethod->GetTagValue(PROPERTY_ATYPE);

        cAType = szAutomationType.Length();
        if (szAutomationType[cAType - 1] == '*')
        {
            szAutomationType.PutChar(cAType - 1, '\0');
        }

        pSimpleType = ConvertType(szAutomationType, TRUE, &pComPlusType[0]);

        if (propType == SetProperty && !fNameOnly )
        {
            resultCStr = "void";
            argCStr = "(";
            argCStr += pSimpleType ? pSimpleType : pComPlusType;
            argCStr += " param1)";

            fRet = TRUE;
        }

        if (propType == GetProperty && !fNameOnly)
        {
            resultCStr = pSimpleType ? pSimpleType : pComPlusType;
            argCStr = "()";

            fRet = TRUE;
        }
    }

    return fRet;
}


void
CPDLParser::GenComPlusDeclarations(Token *pClass, PropdescInfo *pPI)
{
    BOOL    fNameOnly;
    LPCSTR	pSimpleType;
    char	pComPlusType[128];
    int		uIIDIdx;
    int		uVTblIdx;
    CString	szClassName;

    szClassName = pClass->IsSet(CLASS_COCLASSNAME) ? pClass->GetTagValue(CLASS_COCLASSNAME) : pClass->GetTagValue(CLASS_NAME);

#if 0
//if (pPI->_pToken->GetType() == TYPE_METHOD && _stricmp("fireEvent", (LPSTR)pPI->_pToken->GetTagValue(METHOD_NAME)) == 0)
if (pPI->_pToken->GetType() == TYPE_PROPERTY && _stricmp("bookmarks", (LPSTR)pPI->_pToken->GetTagValue(PROPERTY_NAME)) == 0)
__asm {int 3};
#endif

    uIIDIdx = pPI->_uIIDIndex + 1;	// zero is reserved for error.
    uVTblIdx = (((pPI->_uVTblIndex & 0x00ff) + 7) * 4);

    fNameOnly = _stricmp(pPI->_pToken->GetTagValue(METHOD_NOPROPDESC), "nameonly") == 0;

    if (pPI->_pToken->GetType() == TYPE_METHOD && !fNameOnly)
    {
        CTokenListWalker	ArgListWalker(pPI->_pToken);
        BOOL				fResultFound = FALSE;
        CString				szAutomationType;
        Token				*pArgToken;
        int					cAType;
        CString             szTypesSig;
        CString             szArgsType;
        int                 cArgs = 0;
        int                 cRequiredArgs = 0;
        char               *pDefaultParams[MAX_ARGS]    = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
        char               *pDefaultStrParams[MAX_ARGS] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
        BOOL                fBSTRArg;
        BOOL                fVARIANTArg;
        BOOL				fObjectReturn = FALSE;
        ParamType			objectParam[MAX_ARGS] = { CPDLParser::None, CPDLParser::None, CPDLParser::None, CPDLParser::None, CPDLParser::None, CPDLParser::None, CPDLParser::None, CPDLParser::None };

        while (pArgToken = ArgListWalker.GetNext())
        {
            if (pArgToken->IsSet(METHODARG_RETURNVALUE))
            {
                szAutomationType = pArgToken->IsSet(METHODARG_ATYPE) ?
                                        pArgToken->GetTagValue(METHODARG_ATYPE) :
                                        pArgToken->GetTagValue(METHODARG_TYPE);

                cAType = szAutomationType.Length();
                if (cAType && szAutomationType[cAType - 2] == '*')
                {
                    szAutomationType.PutChar(cAType - 2, '\0');
                    fObjectReturn = szAutomationType != "Variant";
                }
                else if (cAType && szAutomationType[cAType - 1] == '*')
                {
                    szAutomationType.PutChar(cAType - 1, '\0');
                    fObjectReturn = szAutomationType != "Variant";
                }

                pSimpleType = ConvertType(szAutomationType, TRUE, &pComPlusType[0]);
                if (pSimpleType)
                {
                    // IUknown or IDispatch return value is an unsigned int from CPThunks
                    if (_stricmp(pSimpleType, "Object") != 0)
                    {
                        // VARIANT_BOOL, int's, etc. returned are not objects.
                        fObjectReturn = FALSE;
                    }
                }

                fprintf(fpCComPlusFile, "%s\n", pSimpleType ? pSimpleType : pComPlusType);
                if (!pSimpleType)
                {
                    if (_stricmp(pComPlusType, "Object") == 0)
                    {
                        strcpy(pComPlusType, "unsigned int");
                    }
                }
                fprintf(fpHComPlusFile, "\t%s ", pSimpleType ? pSimpleType : pComPlusType);

                fResultFound = TRUE;
            }
        }

        if (!fResultFound)
        {
            fprintf(fpHComPlusFile, "\tvoid ");
            fprintf(fpCComPlusFile, "void\n");
        }

        fprintf(fpCComPlusFile, "%sCOMPLUS::", (LPCSTR)szClassName);

        // Method
        fprintf(fpHComPlusFile, "\t%s (", pPI->_pToken->IsSet(METHOD_SZINTERFACEEXPOSE) ?
                                            (LPSTR)pPI->_pToken->GetTagValue(METHOD_SZINTERFACEEXPOSE) :
                                            (LPSTR)pPI->_pToken->GetTagValue(METHOD_NAME));
        fprintf(fpCComPlusFile, "%s (", pPI->_pToken->IsSet(METHOD_SZINTERFACEEXPOSE) ?
                                            (LPSTR)pPI->_pToken->GetTagValue(METHOD_SZINTERFACEEXPOSE) :
                                            (LPSTR)pPI->_pToken->GetTagValue(METHOD_NAME));

        BOOL				fFirst = TRUE;
        int					idx = 1;
        BOOL				fAnyDynamicCasts = FALSE;

        ArgListWalker.Reset();
        while (pArgToken = ArgListWalker.GetNext())
        {
            if (!pArgToken->IsSet(METHODARG_RETURNVALUE))
            {
                if (!fFirst)
                {
                    fprintf(fpHComPlusFile, ", ");
                    fprintf(fpCComPlusFile, ", ");
                }

                szAutomationType = pArgToken->GetTagValue(METHODARG_TYPE);

                cAType = szAutomationType.Length();
                if (cAType && szAutomationType[cAType - 1] == '*')
                {
                    szAutomationType.PutChar(cAType - 1, '\0');
                    if (szAutomationType == "IUnknown" || szAutomationType == "IDispatch")
                    {
                        objectParam[idx - 1] = CPDLParser::AnyObject;
                    }
                    else if (szAutomationType != "Variant")
                    {
                        objectParam[idx - 1] = CPDLParser::Object;
                    }
                }

                pSimpleType = ConvertType(szAutomationType, TRUE, &pComPlusType[0]);
                if (pSimpleType)
                {
                    // IUknown or IDispatch return value is an unsigned int from CPThunks
                    if (_stricmp(pSimpleType, "Object") != 0)
                    {
                        // VARIANT_BOOL, int's, etc. returned are not objects.
                        objectParam[idx - 1] = CPDLParser::None;
                    }
                }

                fprintf(fpHComPlusFile, "%s param%i", pSimpleType ? pSimpleType : pComPlusType, idx);
                fprintf(fpCComPlusFile, "%s param%i", pSimpleType ? pSimpleType : pComPlusType, idx++);
            }

            fFirst = FALSE;
        }

        fprintf(fpHComPlusFile, ");\n");
        fprintf(fpCComPlusFile, ")\n");
        fprintf(fpCComPlusFile, "{\n");

        if (BuildMethodSignature(pPI->_pToken,
                                 szTypesSig,
                                 szArgsType,
                                 fBSTRArg,
                                 fVARIANTArg,
                                 cArgs,
                                 cRequiredArgs,
                                 pDefaultParams,
                                 pDefaultStrParams))
        {
            CString		szFullSignature;
            BOOL		fAtLeastOne = FALSE;
            int			i;

            if (fObjectReturn)
            {
                fprintf(fpCComPlusFile, "\tunsigned int	myPDispatch;\n\n");
            }

            for (i = 0; i < cArgs; i++)
            {
                if (objectParam[i] & CPDLParser::GenericObject)
                {
                    fprintf(fpCComPlusFile, "\tICOMCookie	tempParam%i = dynamic_cast<ICOMCookie>(param%i);\n", i + 1, i + 1);
                    fAtLeastOne = TRUE;
                }
            }
            if (fAtLeastOne)
            {
                fprintf(fpCComPlusFile, "\n");
            }

            // If no return value then set the retVal to void.
            if (!szTypesSig[0])
            {
                szTypesSig = "void";
            }

            // If no arguments then set the argList to void.
            if (!szArgsType[0])
            {
                szArgsType = "_void";
            }

            szTypesSig += szArgsType;

            MakeSignature("Method", szTypesSig, szFullSignature);

            if (fResultFound)
            {
                fprintf(fpCComPlusFile, "\t%s", fObjectReturn ? "myPDispatch = " : "return ");
            }
            else
            {
                fprintf(fpCComPlusFile, "\t");
            }

            fprintf(fpCComPlusFile, "CPThunks::COMPLUS_%s(_myThis, %i, %i", (LPCSTR)szFullSignature, uIIDIdx, uVTblIdx);

            for (i = 0; i < cArgs; i++)
            {
                if (objectParam[i] & CPDLParser::GenericObject)
                {
                    fprintf(fpCComPlusFile, ", tempParam%i.getCOMCookie()", i + 1);
                }
                else if (objectParam[i] & CPDLParser::Object)
                {
                    fprintf(fpCComPlusFile, ", param%i.getCOMCookie()", i + 1);
                }
                else
                {
                    fprintf(fpCComPlusFile, ", param%i", i + 1);
                }
            }

            fprintf(fpCComPlusFile, ");\n");
        }

        if (fObjectReturn)
        {
//  ***TLL*** COM+: Need to create class for return value.  For now just return 0.
//  Should be something like "return new HTMLDOMNodeCOMPLUS(myPDispatch)" where HTMLDOMNodeCOMPLUS
//  is a COM+ class.
            if (fObjectReturn)
            {
                fprintf(fpCComPlusFile, "\n");
            }

			fprintf(fpCComPlusFile, "\treturn 0;\n");
        }

        fprintf(fpCComPlusFile, "}\n\n");
    }
    else
    {
        // Property
        CString		szAutomationType;
        int			cAType;
        ParamType	propertyParam = CPDLParser::None;
        BOOL		fInterfaceFound;

        fNameOnly = _stricmp(pPI->_pToken->GetTagValue(PROPERTY_NOPROPDESC), "nameonly") == 0;

        szAutomationType = pPI->_pToken->GetTagValue(PROPERTY_ATYPE);

        cAType = szAutomationType.Length();
        if (szAutomationType[cAType - 1] == '*')
        {
            szAutomationType.PutChar(cAType - 1, '\0');
        }

        if (cAType && szAutomationType[cAType - 1] == '*')
        {
            szAutomationType.PutChar(cAType - 1, '\0');
            if (szAutomationType == "IUnknown" || szAutomationType == "IDispatch")
            {
                propertyParam = CPDLParser::AnyObject;
            }
            else if (szAutomationType != "Variant")
            {
                propertyParam = CPDLParser::Object;
            }
        }

        pSimpleType = ConvertType(szAutomationType, TRUE, &pComPlusType[0], &fInterfaceFound);
        if (pSimpleType)
        {
            // IUknown or IDispatch return value is an unsigned int from CPThunks
            if (_stricmp(pSimpleType, "Object") != 0)
            {
                // VARIANT_BOOL, int's, etc. returned are not objects.
                propertyParam = CPDLParser::None;
            }
        }

        if (pPI->_pToken->IsSet(PROPERTY_SET) && !fNameOnly )
        {
            fprintf(fpHComPlusFile, "\tvoid\t%s (%s param1);\n",
                    pPI->_pToken->IsSet(PROPERTY_SZINTERFACEEXPOSE) ?
                                        (LPSTR)pPI->_pToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE) :
                                        (LPSTR)pPI->_pToken->GetTagValue(PROPERTY_NAME),
                    pSimpleType ? pSimpleType : pComPlusType);
            fprintf(fpCComPlusFile, "void\n%sCOMPLUS::%s (%s param1)\n",
                    (LPCSTR)szClassName,
                    pPI->_pToken->IsSet(PROPERTY_SZINTERFACEEXPOSE) ?
                                        (LPSTR)pPI->_pToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE) :
                                        (LPSTR)pPI->_pToken->GetTagValue(PROPERTY_NAME),
                    pSimpleType ? pSimpleType : pComPlusType);
            fprintf(fpCComPlusFile, "{\n");

            if (pSimpleType)
            {
                if (_stricmp(pSimpleType, "String") == 0)
                {
                    fprintf(fpCComPlusFile, "\tCPThunks::COMPLUS_S_String(_myThis, %i, %i, param1);\n", uIIDIdx, uVTblIdx); 
                }
                else if (_stricmp(pSimpleType, "Object") == 0 )
                {
                    fprintf(fpCComPlusFile, "\tunsigned int tempParam1 = dynamic_cast<ICOMCookie>(param1).getCOMCookie();\n");
                    fprintf(fpCComPlusFile, "\tCPThunks::COMPLUS_S_IDispatchp(_myThis, %i, %i, tempParam1);\n", pSimpleType, uIIDIdx, uVTblIdx);
                }
                else
                {
                    fprintf(fpCComPlusFile, "\tCPThunks::COMPLUS_S_%s(_myThis, %i, %i, param1);\n", pSimpleType, uIIDIdx, uVTblIdx);
                }
            }
            else if (fInterfaceFound)
            {
                fprintf(fpCComPlusFile, "\tCPThunks::COMPLUS_S_IDispatchp(_myThis, %i, %i, param1.getCOMCookie());\n", uIIDIdx, uVTblIdx);
            }
            else
            {
                fprintf(fpCComPlusFile, "\tCPThunks::COMPLUS_S_%s(_myThis, %i, %i, param1);\n", pComPlusType, uIIDIdx, uVTblIdx);
            }

            fprintf(fpCComPlusFile, "}\n\n");
        }
        if (pPI->_pToken->IsSet(PROPERTY_GET) && !fNameOnly)
        {
            fprintf(fpHComPlusFile, "\t%s\t%s ();\n",
                pSimpleType ? pSimpleType : pComPlusType,
                pPI->_pToken->IsSet(PROPERTY_SZINTERFACEEXPOSE) ?
                                    (LPSTR)pPI->_pToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE) :
                                    (LPSTR)pPI->_pToken->GetTagValue(PROPERTY_NAME));
            fprintf(fpCComPlusFile, "%s\n%sCOMPLUS::%s ()\n",
                pSimpleType ? pSimpleType : pComPlusType,
                (LPCSTR)szClassName,
                pPI->_pToken->IsSet(PROPERTY_SZINTERFACEEXPOSE) ?
                                    (LPSTR)pPI->_pToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE) :
                                    (LPSTR)pPI->_pToken->GetTagValue(PROPERTY_NAME));
            fprintf(fpCComPlusFile, "{\n");
            if (pSimpleType)
            {
                if (_stricmp(pSimpleType, "String") == 0)
                {
                    fprintf(fpCComPlusFile, "\treturn CPThunks::COMPLUS_G_String(_myThis, %i, %i);\n", uIIDIdx, uVTblIdx + 1); 
                }
                else if (_stricmp(pSimpleType, "Object") == 0)
                {
                    // return IUnknown or IDispatch (not a qualified interface like IHTMLnnnnn).
                    fprintf(fpCComPlusFile, "\tunsigned int\tmyPDispatch;\n\n");
                    fprintf(fpCComPlusFile, "\tmyPDispatch = CPThunks::COMPLUS_G_%s(_myThis, %i, %i);\n", pSimpleType, uIIDIdx, uVTblIdx + 1);

//TODO: ***TLL*** COM+: Hook up document property of Window.  Need generic mechanism here.
					if (_stricmp((LPCSTR)szClassName, "HTMLWindow2") == 0)
					{
						if (_stricmp(pPI->_pToken->IsSet(PROPERTY_SZINTERFACEEXPOSE) ?
										(LPSTR)pPI->_pToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE) :
										(LPSTR)pPI->_pToken->GetTagValue(PROPERTY_NAME),
									 "document") == 0)
						{
							fprintf(fpCComPlusFile, "return new HTMLDocumentCOMPLUS(myPDispatch);\n");
							fprintf(fpCComPlusFile, "//");		// comment the next return spit out
						}
					}

// TODO:	***TLL*** COM+: Need to return (coclass) object stuffed myPDispatch.  Remove return 0; and used below commented out line.
                    fprintf(fpCComPlusFile, "\treturn 0;\n");
//					fprintf(fpCComPlusFile, "\treturn new %s(myPDispatch);\n", pComPlusType);
                }
                else
                {
                    fprintf(fpCComPlusFile, "\treturn CPThunks::COMPLUS_G_%s(_myThis, %i, %i);\n", pSimpleType, uIIDIdx, uVTblIdx + 1);
                }
            }
            else if (_stricmp(pComPlusType, "Variant") == 0)
            {
                fprintf(fpCComPlusFile, "\tunsigned int\tmyPVariant;\n\n");
                fprintf(fpCComPlusFile, "\tmyPVariant = CPThunks::COMPLUS_G_%s(_myThis, %i, %i);\n\n", "VARIANT", uIIDIdx, uVTblIdx + 1);
                fprintf(fpCComPlusFile, "\treturn new Variant(myPVariant);\n");
            }
            else
            {
                fprintf(fpCComPlusFile, "\tunsigned int\tmyPDispatch;\n\n");
                fprintf(fpCComPlusFile, "\tmyPDispatch = CPThunks::COMPLUS_G_%s(_myThis, %i, %i);\n\n", "Object", uIIDIdx, uVTblIdx + 1);

//TODO: ***TLL*** COM+: Hook up document property of Window.  Need generic mechanism here.
				if (_stricmp((LPCSTR)szClassName, "HTMLWindow2") == 0)
				{
					if (_stricmp(pPI->_pToken->IsSet(PROPERTY_SZINTERFACEEXPOSE) ?
									(LPSTR)pPI->_pToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE) :
									(LPSTR)pPI->_pToken->GetTagValue(PROPERTY_NAME),
								 "document") == 0)
					{
						fprintf(fpCComPlusFile, "return new HTMLDocumentCOMPLUS(myPDispatch);\n");
						fprintf(fpCComPlusFile, "//");		// comment the next return spit out
					}
				}

// ***TLL*** COM+: Need to return (coclass) object stuffed myPDispatch.  Remove return 0; and used below commented out line.
                fprintf(fpCComPlusFile, "\treturn 0;\n");
//				fprintf(fpCComPlusFile, "\treturn new %s(myPDispatch);\n", pComPlusType);
            }

            fprintf(fpCComPlusFile, "}\n\n");
        }
    }
}

#endif   // COMPLUS_SHIM


BOOL
CPDLParser::ComputePROPDESC_STRUCT ( FILE *fp, Token *pClassToken, Token *pChild, CString & szHandler, CString & szFnPrefix )
{
    char szErrorText [ MAX_LINE_LEN+1 ];

    fprintf ( fp, "EXTERN_C const " );

    if ( !pChild->IsSet ( PROPERTY_ABSTRACT ) && szHandler == "Num" || szHandler == "Enum"  || szHandler == "UnitValue" )
    {
        // Numeric Handlers
        if ( pChild->IsSet ( PROPERTY_GETSETMETHODS ) )
        {
             fprintf ( fp, "PROPERTYDESC_NUMPROP_GETSET" );
        }
        else if ( pChild->IsSet ( PROPERTY_ABSTRACT ) )
        {
            fprintf ( fp, "PROPERTYDESC_NUMPROP_ABSTRACT" );
        }
        else if ( pChild->IsSet ( PROPERTY_ENUMREF ) )
        {
            fprintf ( fp, "PROPERTYDESC_NUMPROP_ENUMREF" );
        }
        else
        {
            fprintf ( fp, "PROPERTYDESC_NUMPROP" );
        }
    }
    else
    {
        // BASIC PROP PARAM Structure
        if ( pChild->IsSet ( PROPERTY_GETSETMETHODS ) )
        {
            if ( szFnPrefix == "" )
            {
                sprintf ( szErrorText, "Invalid Type:%s in Class:%s Property:%s\n",
                    (LPCSTR)pChild->GetTagValue ( PROPERTY_TYPE ),
                    (LPCSTR)pClassToken->GetTagValue(CLASS_NAME),
                    (LPCSTR)pChild->GetTagValue ( PROPERTY_NAME ) );
                ReportError ( szErrorText );
                return FALSE;
            }
            fprintf ( fp, "PROPERTYDESC_%s_GETSET", (LPCSTR)szFnPrefix );
        }
        else if ( pChild->IsSet ( PROPERTY_ABSTRACT ) )
        {
            fprintf ( fp, "PROPERTYDESC_BASIC_ABSTRACT" );
        }
        else
        {
            fprintf ( fp, "PROPERTYDESC_BASIC" );
        }
    }

    return TRUE;
}


Token * CPDLParser::FindEnum ( Token *pChild )
{
    // Get the enum mask from the enum named by  PROPERTY_TYPE
    CTokenListWalker WholeList ( pRuntimeList );

    return WholeList.GetNext ( TYPE_ENUM, pChild->GetTagValue ( PROPERTY_TYPE ) );
}


char * CPDLParser::MapTypeToIDispatch ( CString & szType )
{
    CString szHandler;
    CString szFnPrefix;
    char    szStrType[255];

    strcpy(szStrType, (LPCSTR)szType);
    if (GetTypeDetails (szStrType, szHandler, szFnPrefix, NULL) && (szHandler == "object"))
    {
        int cSz = szType.Length();

        if (szType[cSz - 1] == '*' && szType[cSz - 2] == '*')
        {
            // is it an IUnknown or an IDispatch?
            if (_strnicmp(szType, "IUnknown", cSz-2)==0)
                return "IUnknownpp";
            else
                return "IDispatchpp";
        }
        else if (szType[cSz - 1] == '*')
        {
            // is it an IUnknown or an IDispatch?
            if (_strnicmp(szType, "IUnknown",cSz-1)==0)
                return "IUnknownp";
            else
                return "IDispatchp";
        }
    }

    return NULL;
}

Token * CPDLParser::FindEventMethod(Token *pClassToken, LPCSTR szEvent)
{
    Token *pChildToken;
    CTokenListWalker WholeList(pRuntimeList);

    WholeList.Reset();
    Token *pEventToken = WholeList.GetNext(TYPE_EVENT, pClassToken->GetTagValue(CLASS_EVENTS));
    if (pEventToken)
    {
        CTokenListWalker ChildList(pEventToken);

        while (pChildToken = ChildList.GetNext())
        {
            if (_stricmp(pChildToken->GetTagValue(METHOD_NAME), szEvent) == 0)
                return pChildToken;
        }
    }

    WholeList.Reset();
    pEventToken = WholeList.GetNext(TYPE_EVENT, pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS1));
    if (!pEventToken)
        return NULL;

    {
        CTokenListWalker ChildList(pEventToken);

        while (pChildToken = ChildList.GetNext())
        {
            if (_stricmp(pChildToken->GetTagValue(METHOD_NAME), szEvent) == 0)
                return pChildToken;
        }
    }

    WholeList.Reset();
    pEventToken = WholeList.GetNext(TYPE_EVENT, pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS2));
    if (!pEventToken)
        return NULL;

    {
        CTokenListWalker ChildList(pEventToken);

        while (pChildToken = ChildList.GetNext())
        {
            if (_stricmp(pChildToken->GetTagValue(METHOD_NAME), szEvent) == 0)
                return pChildToken;
        }
    }
    
    WholeList.Reset();
    pEventToken = WholeList.GetNext(TYPE_EVENT, pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS3));
    if (!pEventToken)
        return NULL;

    {
        CTokenListWalker ChildList(pEventToken);

        while (pChildToken = ChildList.GetNext())
        {
            if (_stricmp(pChildToken->GetTagValue(METHOD_NAME), szEvent) == 0)
                return pChildToken;
        }
    }

    WholeList.Reset();
    pEventToken = WholeList.GetNext(TYPE_EVENT, pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS4));
    if (!pEventToken)
        return NULL;

    {
        CTokenListWalker ChildList(pEventToken);

        while (pChildToken = ChildList.GetNext())
        {
            if (_stricmp(pChildToken->GetTagValue(METHOD_NAME), szEvent) == 0)
                return pChildToken;
        }
    }
    
    return NULL;
}

Token * CPDLParser::FindEventProp(Token *pClassToken, LPCSTR szEvent)
{
    Token *pChild;
    CTokenListWalker ChildList ( pClassToken );

    while ( pChild = ChildList.GetNext() )
    {
        if ( pChild->nType == TYPE_PROPERTY &&
             pChild->IsSet(PROPERTY_SCRIPTLET) &&
             _stricmp(pChild->GetTagValue(PROPERTY_NAME), szEvent) == 0 )
            return pChild;
    }

    return NULL;
}

BOOL CPDLParser::ComputeProperty ( Token *pClassToken, Token *pChild )
{
    CString                     szClass;
    CString                     szHandler;
    CString                     szFnPrefix;
    CString                     szHTMLName;
    char                        szExposedName [ MAX_LINE_LEN+1 ];
    CString                     szdwFlags;
    CString                     szNotPresentDefault;
    CString                     szNotAssignedDefault;
    CString                     szUpperName;
    CString                     szDispid;
    char                        szErrorText [ MAX_LINE_LEN+1 ];
    StorageType                 stHowStored;
    const CCachedAttrArrayInfo *pCAAI = NULL;
    BOOL                        fNumericHandler;
    CString                     szVTDef;
    CString                     szPropSignature;
    CString                     szPropVT;
    Token                      *pEnumType;
    Token                      *pEventChild = NULL;
    char                        chCustomInvokeIdx[128];
    char                       *pDispatchType;
    CString szPreText,szPostText;
    CString szMemberDesc;
    
    szPreText = "_T(";
    szPostText = ")";

    pEnumType = FindEnum ( pChild );
    if ( pEnumType )
    {
        // Generic enumerator property handler, the propDesc has the enumerator
        // type.
        szPropVT = "PropEnum";
    }
    else
    {
        char *pWS;

        szPropVT = pChild->GetTagValue ( PROPERTY_ATYPE );

        // Remove any underscores in the type name.
        while ((pWS = szPropVT.FindChar('_')))
        {
            while (*pWS = *(pWS + 1))
                pWS++;
            *pWS = '\0';
        }
    }

    // Should this type be mapped to IDispatch?
    pDispatchType = MapTypeToIDispatch ( szPropVT );
    if (pDispatchType)
    {
        szPropVT = pDispatchType;
    }

    szClass = pClassToken->GetTagValue ( CLASS_NAME );

    szUpperName = pChild->GetTagValue ( PROPERTY_NAME );
    szUpperName.ToUpper();

    szHandler = "";
    szFnPrefix = "";
    // Check for missing handler later
    GetTypeDetails ( pChild->GetTagValue ( PROPERTY_TYPE ),
        szHandler, szFnPrefix, &stHowStored );

    CString szPropParamDesc;

    szdwFlags = pChild->GetTagValue ( PROPERTY_DWFLAGS );

    if ( pChild->IsSet ( PROPERTY_GETSETMETHODS ) )
    {
        szPropParamDesc = "PROPPARAM_GETMFHandler | PROPPARAM_SETMFHandler";
        szPropSignature = "GS";
    }
    else if ( pChild->IsSet ( PROPERTY_MEMBER ) )
    {
        szPropParamDesc = "PROPPARAM_MEMBER";
    }
    else
    {
        szPropParamDesc = "";
    }

    if ( pChild->IsSet ( PROPERTY_GET ) )
    {
        szPropSignature = "G";
        if ( szPropParamDesc [ 0 ] )
            szPropParamDesc += " | ";
        szPropParamDesc += "PROPPARAM_INVOKEGet";
    }
    if ( pChild->IsSet ( PROPERTY_SET ) )
    {
        szPropSignature += "S";
        if ( szPropParamDesc [ 0 ] )
            szPropParamDesc += " | ";
        szPropParamDesc += "PROPPARAM_INVOKESet";
    }

    if (!szPropSignature[0])
    {
        szPropSignature = "GS";
        if ( szPropParamDesc [ 0 ] )
            szPropParamDesc += " | ";
        szPropParamDesc += "PROPPARAM_INVOKEGet | PROPPARAM_INVOKESet";
    }

    // Write out the function signature for this property.
    if ( !FindAndAddSignature ( szPropSignature, szPropVT, &chCustomInvokeIdx[0] ) )
        return FALSE;

    if ( pChild->IsSet ( PROPERTY_PPFLAGS ))
    {
        szPropParamDesc += " | ";
        szPropParamDesc += pChild->GetTagValue ( PROPERTY_PPFLAGS );
    }
    if ( pChild->IsSet ( PROPERTY_NOPERSIST ) )
    {
        szPropParamDesc += " | PROPPARAM_NOPERSIST";
    }
    if ( pChild->IsSet ( PROPERTY_INVALIDASNOASSIGN ) )
    {
        szPropParamDesc += " | PROPPARAM_INVALIDASNOASSIGN";
    }
    if ( pChild->IsSet ( PROPERTY_CUSTOMENUM ) )
    {
        szPropParamDesc += " | PROPPARAM_CUSTOMENUM ";
    }    
    if ( pChild->IsSet ( PROPERTY_NOTPRESENTASDEFAULT ) )
    {
        szPropParamDesc += " | PROPPARAM_NOTPRESENTASDEFAULT";
    }
    if ( pChild->IsSet ( PROPERTY_HIDDEN ) )
    {
        szPropParamDesc += " | PROPPARAM_HIDDEN";
    }
    if ( pChild->IsSet ( PROPERTY_RESTRICTED ) )
    {
        szPropParamDesc += " | PROPPARAM_RESTRICTED";
    }
    if ( pChild->IsSet ( PROPERTY_CAA ) )
    {
        szDispid = pChild->GetTagValue( PROPERTY_DISPID );
        pCAAI = GetCachedAttrArrayInfo(szDispid);

        szPropParamDesc += " | PROPPARAM_ATTRARRAY ";
#if 0
        if (pCAAI->szPPFlags)
        {
            szPropParamDesc += " | ";
            szPropParamDesc += pCAAI->szPPFlags;
        }
        if (pCAAI->szLMinBitMask)
        {
            pChild->AddTag( PROPERTY_MIN , pCAAI->szLMinBitMask );
        }
#endif
    }

    if ( pChild->IsSet ( PROPERTY_MINOUT ) )
    {
        szPropParamDesc += " | PROPPARAM_MINOUT";
    }

    if ( pChild->IsSet ( PROPERTY_SETDESIGNMODE ) )
    {
        szPropParamDesc += " | PROPPARAM_READONLYATRUNTIME";
    }

    // If we're processing a property that applies to a CF/PF/SF/FF, mark it here
    // this helps us optimize the apply process. Only properties with a DISPID that
    // matches our apply table, can be applied
    if ( pCAAI && pCAAI->szDispId != NULL )
    {
        szPropParamDesc += " | PROPPARAM_STYLISTIC_PROPERTY";
    }

    if ( pChild -> IsSet ( PROPERTY_SCRIPTLET ) )
    {
        szPropParamDesc += " | PROPPARAM_SCRIPTLET";

        pEventChild = FindEventMethod(pClassToken, pChild->GetTagValue(PROPERTY_NAME));

        if (pEventChild)
        {
            if (pEventChild->IsSet(METHOD_CANCELABLE))
            {
                szPropParamDesc += " | PROPPARAM_CANCELABLE";
            }
            if (pEventChild->IsSet(METHOD_BUBBLING))
            {
                szPropParamDesc += " | PROPPARAM_BUBBLING";
            }
        }
        else if (!pChild->IsSet(PROPERTY_NOPROPDESC) && !pChild->IsSet(PROPERTY_BASEIMPLEMENTATION))
        {
            sprintf ( szErrorText, "Unexpected Error:Event prop:%s in Class:%s not found in any Events interface defn.\n",
                (LPCSTR)pChild->GetTagValue ( PROPERTY_NAME ),
                (LPCSTR)pClassToken->GetTagValue(CLASS_NAME) );
            ReportError ( szErrorText );
            return FALSE;
        }
    }

    szMemberDesc = "";

    if ( pChild->IsSet ( PROPERTY_CAA ) )
    {
        if ( pCAAI->dwFlags & CCSSF_CLEARCACHES )
        {
            // Always add dwFlags:ELEMCHNG_CLEARCACHES for these properties
            if ( szdwFlags [0] )
            {
                szdwFlags += "|";
            }
            else
            {
                szdwFlags = "";
            }
            szdwFlags+="ELEMCHNG_CLEARCACHES";
        }

        if ( pCAAI->dwFlags & CCSSF_CLEARFF )
        {
            // Always add dwFlags:ELEMCHNG_CLEARFF for these properties
            if ( szdwFlags [0] )
            {
                szdwFlags += "|";
            }
            else
            {
                szdwFlags = "";
            }
            szdwFlags+="ELEMCHNG_CLEARFF";
        }
        
        if ( pCAAI->dwFlags & CCSSF_REMEASURECONTENTS )
        {
            // Always add dwFlags:ELEMCHNG_REMEASURECONTENTS for these properties
            if ( szdwFlags [0] )
            {
                szdwFlags += "|";
            }
            else
            {
                szdwFlags = "";
            }
            szdwFlags+="ELEMCHNG_REMEASURECONTENTS";
        }

        if ( pCAAI->dwFlags & CCSSF_REMEASUREALLCONTENTS )
        {
            // Always add dwFlags:ELEMCHNG_REMEASURECONTENTS for these properties
            if ( szdwFlags [0] )
            {
                szdwFlags += "|";
            }
            else
            {
                szdwFlags = "";
            }
            szdwFlags+="ELEMCHNG_REMEASUREALLCONTENTS";
        }

        if ( pCAAI->dwFlags & CCSSF_REMEASUREINPARENT )
        {
            // Always add dwFlags:ELEMCHNG_REMEASUREINPARENT for these properties
            if ( szdwFlags [0] )
            {
                szdwFlags += "|";
            }
            else
            {
                szdwFlags = "";
            }
            szdwFlags+="ELEMCHNG_REMEASUREINPARENT";
        }

        if ( pCAAI->dwFlags & CCSSF_SIZECHANGED )
        {
            // Always add dwFlags:ELEMCHNG_SIZECHANGED for these properties
            if ( szdwFlags [0] )
            {
                szdwFlags += "|";
            }
            else
            {
                szdwFlags = "";
            }
            szdwFlags+="ELEMCHNG_SIZECHANGED";
        }

    }
    else if ( pChild->IsSet ( PROPERTY_MEMBER ) )
    {
        // On the object
        szMemberDesc = szClass;
        szMemberDesc += ", ";
        szMemberDesc += pChild->GetTagValue ( PROPERTY_MEMBER );
    }
    
    if ( pChild -> IsSet ( PROPERTY_ACCESSIBILITYSTATE) )
    {
        // we should only allow this on properties that can be set,
        if ( ! ( pChild->IsSet ( PROPERTY_SET ) ) )
        {
            ReportError ( "Accessibility State can only be applied to r/w properties\n" );
            return FALSE;
        }
        
        if ( szdwFlags [ 0 ] )
        {
            szdwFlags += "|";
        }
        szdwFlags += "ELEMCHNG_ACCESSIBILITY";
    }

    if ( pChild -> IsSet ( PROPERTY_UPDATECOLLECTION ) )
    {
        if ( szdwFlags [ 0 ] )
        {
            szdwFlags += "|";
        }
        szdwFlags += "ELEMCHNG_UPDATECOLLECTION";
    }
    if ( pChild -> IsSet ( PROPERTY_CLEARCACHES ) )
    {
        if ( szdwFlags [ 0 ] )
        {
            szdwFlags += "|";
        }
        szdwFlags += "ELEMCHNG_CLEARCACHES";
    }
    if ( pChild -> IsSet ( PROPERTY_STYLEPROP ) )
    {
        if ( szPropParamDesc [ 0 ] )
            szPropParamDesc += " | ";
        szPropParamDesc += "PROPPARAM_STYLESHEET_PROPERTY";
    }
    if ( pChild -> IsSet ( PROPERTY_DONTUSENOTASSIGN ) )
    {
        if ( szPropParamDesc [ 0 ] )
            szPropParamDesc += " | ";
        szPropParamDesc += "PROPPARAM_DONTUSENOTASSIGNED";
    }
    if ( pChild -> IsSet ( PROPERTY_RESIZE ) )
    {
        if ( szdwFlags [ 0 ] )
        {
            szdwFlags += "|";
        }
        szdwFlags += "ELEMCHNG_SIZECHANGED";
    }
    if ( pChild -> IsSet ( PROPERTY_REMEASURE ) )
    {
        if ( szdwFlags [ 0 ] )
        {
            szdwFlags += "|";
        }
        szdwFlags += "ELEMCHNG_REMEASURECONTENTS";
    }
    if ( pChild -> IsSet ( PROPERTY_REMEASUREALL ) )
    {
        if ( szdwFlags [ 0 ] )
        {
            szdwFlags += "|";
        }
        szdwFlags += "ELEMCHNG_REMEASUREALLCONTENTS";
    }
    if ( pChild -> IsSet ( PROPERTY_SITEREDRAW ) )
    {
        if ( szdwFlags [ 0 ] )
        {
            szdwFlags += "|";
        }
        szdwFlags += "ELEMCHNG_SITEREDRAW";
    }

    char szPropertyDesc [ MAX_LINE_LEN+1 ] ;

    pChild -> GetTagValueOrDefault ( szNotPresentDefault, PROPERTY_NOTPRESENTDEFAULT, "0" );
    if ( pChild->IsSet( PROPERTY_NOTPRESENTDEFAULT ) && szHandler == "String")
    {
        szNotPresentDefault = szPreText + szNotPresentDefault;
        szNotPresentDefault += szPostText;
    }
    else if ( szHandler == "Color" &&  szNotPresentDefault == "0" )
    {
        // This is a nasty little hack to make for colors
        szNotPresentDefault = "-1";
    }
    // If there's a not assigned default, use it, else use the not present default
    pChild -> GetTagValueOrDefault ( szNotAssignedDefault, PROPERTY_NOTSETDEFAULT,
        (LPCSTR)szNotPresentDefault );
    if ( pChild->IsSet( PROPERTY_NOTSETDEFAULT ) && szHandler == "String")
    {
        szNotAssignedDefault = szPreText + szNotAssignedDefault;
        szNotAssignedDefault += szPostText;
    }
    else if ( szHandler == "Color" &&  szNotAssignedDefault == "0" )
    {
        szNotAssignedDefault = "-1";
    }

    // szAttribute spevcifies the html name of the property, if not specified the
    // property name itself is used.
    if ( pChild -> IsSet ( PROPERTY_SZATTRIBUTE ) )
    {
        szHTMLName = pChild -> GetTagValue ( PROPERTY_SZATTRIBUTE );
        sprintf ( (LPSTR) szExposedName,
                  "_T(\"%s\")", 
                  pChild->GetTagValue ( PROPERTY_NAME ) );
    }
    else
    {
        szHTMLName = pChild -> GetTagValue ( PROPERTY_NAME );
        strcpy(szExposedName, "NULL");
    }

    // If the propdesc has a member specified generate a full propdesc
    // By setting abstract: AND member: the propdesc can be used for validation
    // ( e.g. UnitMeasurement sub-object )
    if ( pChild->IsSet ( PROPERTY_ABSTRACT ) && !pChild->IsSet ( PROPERTY_MEMBER )  )
    {
        // Generate a minimal propdesc, this is how IDispatchEx traverses
        // attributes and properties.
        sprintf ( (LPSTR) szPropertyDesc,
            " s_propdesc%s%s = \n{\n    NULL, _T(\"%s\"), %s, (ULONG_PTR)%s, (ULONG_PTR)%s,\n    {",
            (LPCSTR)szClass,
            (LPCSTR)pChild->GetTagValue ( PROPERTY_NAME ),
            (LPCSTR)szHTMLName,
            (LPCSTR)szExposedName,
            (LPCSTR)szNotPresentDefault,
            (LPCSTR)szNotAssignedDefault);
    }
    else
    {
        // If you're gonna set up a handler, better be a valid one
        if ( szHandler == "" )
        {
            sprintf ( szErrorText, "Invalid Type:%s in Class:%s Property:%s\n",
                (LPCSTR)pChild->GetTagValue ( PROPERTY_TYPE ),
                (LPCSTR)pClassToken->GetTagValue(CLASS_NAME),
                (LPCSTR)pChild->GetTagValue ( PROPERTY_NAME ) );
            ReportError ( szErrorText );
            return FALSE;
        }
        char szTempBuf[MAX_LINE_LEN+1];
        sprintf ( (LPSTR) szTempBuf, " s_propdesc%s%s =\n{\n#ifdef WIN16\n    (PFN_HANDLEPROPERTY)&PROPERTYDESC::handle%sproperty, _T(\"%s\"), %s, (ULONG_PTR)%s, (ULONG_PTR)%s,\n#else\n",
            (LPCSTR)szClass,
            (LPCSTR)pChild->GetTagValue ( PROPERTY_NAME ),
            (LPCSTR)szHandler,
            (LPCSTR)szHTMLName,
            (LPCSTR)szExposedName,
            (LPCSTR)szNotPresentDefault,
            (LPCSTR)szNotAssignedDefault);
        sprintf ( (LPSTR) szPropertyDesc, "%s    PROPERTYDESC::Handle%sProperty, _T(\"%s\"), %s, (ULONG_PTR)%s,(ULONG_PTR)%s,\n#endif\n    {", szTempBuf,
            (LPCSTR)szHandler,
            (LPCSTR)szHTMLName,
            (LPCSTR)szExposedName,
            (LPCSTR)szNotPresentDefault,
            (LPCSTR)szNotAssignedDefault);
    }

    if ( !ComputePROPDESC_STRUCT ( fpHDLFile, pClassToken, pChild, szHandler, szFnPrefix) )
        return FALSE;       // Bad error reported...leave

    if ( !szdwFlags [ 0 ] )
        szdwFlags = "0";

    fNumericHandler = FALSE;
    if ( !pChild->IsSet ( PROPERTY_ABSTRACT ) && szHandler == "Num" || szHandler == "Enum"  || szHandler == "UnitValue" )
    {
        // Numeric Handlers
        fNumericHandler = TRUE;

        fprintf ( fpHDLFile, "%s\n        {", szPropertyDesc );

        if ( szHandler == "Enum" )
        {
            szPropParamDesc += " | PROPPARAM_ENUM";
        }
        else if ( pChild -> IsSet ( PROPERTY_ENUMREF ) )
        {
            // A number with one or more enums
            szPropParamDesc += " | PROPPARAM_ENUM | PROPPARAM_ANUMBER";
        }

        pChild -> GetTagValueOrDefault ( szDispid, PROPERTY_DISPID, "0" );

        if ((strcmp(pChild->GetTagValue(PROPERTY_ATYPE), "BSTR") == 0 || strcmp(pChild->GetTagValue(PROPERTY_ATYPE), "VARIANT") == 0) && 
            ((pChild->IsSet(PROPERTY_CAA) || pChild->IsSet(PROPERTY_SET)) && !pChild->IsSet(PROPERTY_INTERNAL)) ||
            (!pChild->IsSet(PROPERTY_CAA) && !pChild->IsSet(PROPERTY_SET) && !pChild->IsSet(PROPERTY_GET)))
        {
            if (!pChild->IsSet(PROPERTY_MAXSTRLEN))
            {
                char szErrorText [ MAX_LINE_LEN+1 ];

                // Dispid not specified this is an error all methods should be accessible
                // from automation.
                sprintf ( szErrorText, "maxstrlen required for property: %s::%s in %s.\n",
                          (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                          (LPCSTR)pChild->GetTagValue ( PROPERTY_NAME ),
                          _pszPDLFileName  );
                ReportError ( szErrorText );
                return FALSE;
            }
        }
        else if (pChild->IsSet(PROPERTY_MAXSTRLEN))
        {
            char szErrorText [ MAX_LINE_LEN+1 ];

            // Dispid not specified this is an error all methods should be accessible
            // from automation.
            sprintf ( szErrorText, "maxstrlen NOT required for property: %s::%s in %s.\n",
                      (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                      (LPCSTR)pChild->GetTagValue ( PROPERTY_NAME ),
                      _pszPDLFileName  );
            ReportError ( szErrorText );
            return FALSE;
        }

        fprintf ( fpHDLFile, "\n            %s, %s, %s, %s, %s \n        },",
            (LPCSTR)szPropParamDesc,
            (LPCSTR)szDispid,
            (LPCSTR)szdwFlags,
            (LPCSTR)&chCustomInvokeIdx[0],
            pChild->IsSet(PROPERTY_MAXSTRLEN) ? (LPCSTR)pChild->GetTagValue(PROPERTY_MAXSTRLEN) : "0");

        if (fpMaxLenFile && pChild->IsSet(PROPERTY_MAXSTRLEN))
        {
            fprintf ( fpMaxLenFile, "%s::%s    %s\n",
                      (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                      (LPCSTR)pChild->GetTagValue ( PROPERTY_NAME ),
                      (LPCSTR)pChild->GetTagValue(PROPERTY_MAXSTRLEN) );
        }

        if ( pChild->IsSet ( PROPERTY_ABSTRACT ) )
        {
            fprintf ( fpHDLFile, "\n        0, 0" );
        }
        else
        {
            if ( !pChild->IsSet ( PROPERTY_VT ) )
            {
                CString szAType;
                szAType = pChild->GetTagValue ( PROPERTY_ATYPE );
                if ( szAType == "short" || szAType == "VARIANT_BOOL" )
                    szVTDef = "VT_I2";
                else
                    szVTDef = "VT_I4";
            }
            else
            {
                szVTDef = pChild->GetTagValue ( PROPERTY_VT );
            }

            if ( pChild -> IsSet ( PROPERTY_GETSETMETHODS ) )
            {
                fprintf ( fpHDLFile, "\n        %s, 0",
                    (LPCSTR)szVTDef );
            }
            else if ( pChild -> IsSet ( PROPERTY_CAA ) )
            {
                fprintf ( fpHDLFile, "\n        %s, sizeof(DWORD)",
                    (LPCSTR)szVTDef );
            }
            else
            {
                fprintf ( fpHDLFile, "\n        %s, SIZE_OF(%s)",
                    (LPCSTR)szVTDef, (LPCSTR)szMemberDesc );
            }
        }

        // Fill in the min/max values
        // If it's an enum, the min value is a ptr to the enum desc structure
        if ( szHandler == "Enum" )
        {
            if ( pChild->IsSet ( PROPERTY_ABSTRACT ) )
            {
                fprintf ( fpHDLFile, ", 0, 0,\n" );
            }
            else
            {
                // Get the enum mask from the enum named by  PROPERTY_TYPE
                CTokenListWalker WholeList ( pRuntimeList );
                Token *pEnumToken = WholeList.GetNext ( TYPE_ENUM, pChild->GetTagValue ( PROPERTY_TYPE ) );
                CString szMin;
                pChild->GetTagValueOrDefault ( szMin, PROPERTY_MIN, "0" );

                if ( pEnumToken == NULL )
                {
                    sprintf ( szErrorText,
                        "unknown enum type %s\n",pChild->GetTagValue ( PROPERTY_TYPE ) );
                    ReportError ( szErrorText );
                    return FALSE;
                }
                fprintf ( fpHDLFile, ", %s, (LONG_PTR)&s_enumdesc%s,\n",
                    (LPCSTR)szMin, pChild->GetTagValue ( PROPERTY_TYPE ) );
            }
        }
        else
        {
            CString szMax;
            CString szMin;
            pChild->GetTagValueOrDefault ( szMin, PROPERTY_MIN, "LONG_MIN" );
            pChild->GetTagValueOrDefault ( szMax, PROPERTY_MAX, "LONG_MAX" );
            fprintf ( fpHDLFile, ", %s, %s,\n", (LPCSTR)szMin, (LPCSTR)szMax );
        }
    }
    else
    {
        fprintf ( fpHDLFile, "%s\n    ", szPropertyDesc );
        pChild -> GetTagValueOrDefault ( szDispid, PROPERTY_DISPID, "0" );

        if ((strcmp(pChild->GetTagValue(PROPERTY_ATYPE), "BSTR") == 0 || strcmp(pChild->GetTagValue(PROPERTY_ATYPE), "VARIANT") == 0) && 
            ((pChild->IsSet(PROPERTY_CAA) || pChild->IsSet(PROPERTY_SET)) && !pChild->IsSet(PROPERTY_INTERNAL)) ||
            (!pChild->IsSet(PROPERTY_CAA) && !pChild->IsSet(PROPERTY_SET) && !pChild->IsSet(PROPERTY_GET)))
        {
            if (!pChild->IsSet(PROPERTY_MAXSTRLEN))
            {
                char szErrorText [ MAX_LINE_LEN+1 ];

                // Dispid not specified this is an error all methods should be accessible
                // from automation.
                sprintf ( szErrorText, "maxstrlen required for property: %s::%s in %s.\n",
                          (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                          (LPCSTR)pChild->GetTagValue ( PROPERTY_NAME ),
                          _pszPDLFileName  );
                ReportError ( szErrorText );
                return FALSE;
            }
        }
        else if (pChild->IsSet(PROPERTY_MAXSTRLEN))
        {
            char szErrorText [ MAX_LINE_LEN+1 ];

            // Dispid not specified this is an error all methods should be accessible
            // from automation.
            sprintf ( szErrorText, "maxstrlen NOT required for property: %s::%s in %s.\n",
                      (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                      (LPCSTR)pChild->GetTagValue ( PROPERTY_NAME ),
                      _pszPDLFileName  );
            ReportError ( szErrorText );
            return FALSE;
        }

        fprintf ( fpHDLFile, "    %s, %s, %s, %s, %s \n",
            (LPCSTR)szPropParamDesc,
            (LPCSTR)szDispid,
            (LPCSTR)szdwFlags,
            (LPCSTR)&chCustomInvokeIdx[0],
            pChild->IsSet(PROPERTY_MAXSTRLEN) ? (LPCSTR)pChild->GetTagValue(PROPERTY_MAXSTRLEN) : "0");

        if (fpMaxLenFile && pChild->IsSet(PROPERTY_MAXSTRLEN))
        {
            fprintf ( fpMaxLenFile, "%s::%s    %s\n",
                      (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                      (LPCSTR)pChild->GetTagValue ( PROPERTY_NAME ),
                      (LPCSTR)pChild->GetTagValue(PROPERTY_MAXSTRLEN) );
        }

    }
    fprintf ( fpHDLFile, "    }," );
    if (pEventChild && pChild->IsSet(PROPERTY_SCRIPTLET))
    {
        fprintf(fpHDLFile, "\n    (DWORD_PTR)%s", pEventChild->GetTagValue(METHOD_DISPID));
    }
    else if ( pChild->IsSet ( PROPERTY_GETSETMETHODS ) )
    {
        fprintf ( fpHDLFile,  "\n    PROPERTY_METHOD(%s, GET, %s, Get%s, GET%s)," ,
            (LPCSTR)szFnPrefix, 
            (LPCSTR)szClass, (LPCSTR)pChild->GetTagValue ( PROPERTY_GETSETMETHODS ),
            (LPCSTR)pChild->GetTagValue ( PROPERTY_GETSETMETHODS ));
        fprintf ( fpHDLFile,  "\n    PROPERTY_METHOD(%s, SET, %s, Set%s, SET%s)" ,
            (LPCSTR)szFnPrefix, 
            (LPCSTR)szClass, (LPCSTR)pChild->GetTagValue ( PROPERTY_GETSETMETHODS ),
            (LPCSTR)pChild->GetTagValue ( PROPERTY_GETSETMETHODS ));
    }
    else if ( pChild->IsSet ( PROPERTY_ABSTRACT ) )
    {
    }
    else if ( szMemberDesc [ 0 ] )
    {
        fprintf ( fpHDLFile, "\n    offsetof(%s)",
            (LPCSTR)szMemberDesc );
    }

    if ( fNumericHandler && pChild->IsSet ( PROPERTY_ENUMREF ) &&
        !pChild->IsSet ( PROPERTY_ABSTRACT ) )
    {
        CTokenListWalker WholeList ( pRuntimeList );
        Token *pEnumToken = WholeList.GetNext ( TYPE_ENUM,
            pChild->GetTagValue ( PROPERTY_ENUMREF ) );
        if ( pEnumToken == NULL )
        {
            sprintf ( szErrorText,
                "unknown enum type %s\n",pChild->GetTagValue ( PROPERTY_ENUMREF ) );
            ReportError ( szErrorText );
            return FALSE;
        }
        if ( !szMemberDesc [ 0 ] )
        {
            fprintf ( fpHDLFile, "\n    0, &s_enumdesc%s",
                pChild->GetTagValue ( PROPERTY_ENUMREF ) );
        }
        else
        {
            fprintf ( fpHDLFile, "\n    &s_enumdesc%s",
                pChild->GetTagValue ( PROPERTY_ENUMREF ) );
        }
    }

    fprintf ( fpHDLFile, "\n};\n\n" );

    return TRUE;
}


BOOL CPDLParser::BuildMethodSignature(Token *pChild,
                                      CString &szTypesSig,
                                      CString &szArgsType,
                                      BOOL &fBSTRArg,
                                      BOOL &fVARIANTArg,
                                      int  &cArgs,
                                      int  &cRequiredArgs,
                                      char *pDefaultParams[MAX_ARGS],
                                      char *pDefaultStrParams[MAX_ARGS])
{
    Token              *pArgToken;
    CTokenListWalker    ArgListWalker(pChild);
    char               *pDispatchType;
    char                szErrorText [ MAX_LINE_LEN+1 ];

    cArgs = 0;
    cRequiredArgs = 0;
    fBSTRArg = FALSE;
    fVARIANTArg = FALSE;

    // Loop thru all arguments.
    while ( (pArgToken = ArgListWalker.GetNext()) != NULL &&
            pArgToken -> GetType () == TYPE_METHOD_ARG )
    {
        fBSTRArg |= (strcmp(pArgToken->GetTagValue(METHODARG_TYPE), "BSTR") == 0);
        fVARIANTArg |= (!pArgToken->IsSet(METHODARG_OUT) && (strcmp(pArgToken->GetTagValue(METHODARG_TYPE), "VARIANT") == 0 || strcmp(pArgToken->GetTagValue(METHODARG_TYPE), "VARIANT*") == 0));

        // Looking for a return value.
        if ( pArgToken -> IsSet ( METHODARG_RETURNVALUE ) )
        {
            char   *pWS;

            szTypesSig = pArgToken -> GetTagValue ( METHODARG_TYPE );

            // Remove any underscores in the type name.
            while ((pWS = szTypesSig.FindChar('_')))
            {
                while (*pWS = *(pWS + 1))
                    pWS++;
                *pWS = '\0';
            }

            // Should this type be mapped to IDispatch?
            pDispatchType = MapTypeToIDispatch ( szTypesSig );
            if (pDispatchType)
            {
                szTypesSig = pDispatchType;
            }
        }
        else
        {
            CString     szArg;
            char        *pWS;

            if ( pArgToken->IsSet ( METHODARG_OPTIONAL ) )
            {
                // little o + zero + little o, prepended to the type signals
                // the type is optional.
                szArg = "o0o";
            }

            if ( pArgToken -> IsSet ( METHODARG_DEFAULTVALUE ) )
            {
                // Signal default.
                szArg = "oDo";

                if (cArgs >= MAX_ARGS)
                {
                    sprintf ( szErrorText, "PDL parser can only handle upto 8 parameters (increase MAX_ARGS) %s in file %s.\n",
                                (LPCSTR)pChild->GetTagValue ( METHOD_NAME ),
                                _pszPDLFileName  );
                    ReportError ( szErrorText );
                    return FALSE;
                }

                // Currently I only handle 2 types of default values numbers and
                // strings.  If any other appear then I'll need to add those as
                // well.
                if ( strcmp (pArgToken -> GetTagValue ( METHODARG_TYPE ), "BSTR") == 0)
                {
                    if (pDefaultStrParams)
                        pDefaultStrParams[cArgs] = pArgToken -> GetTagValue ( METHODARG_DEFAULTVALUE );
                }
                else if (pDefaultParams)
                {
                    pDefaultParams[cArgs] = pArgToken -> GetTagValue ( METHODARG_DEFAULTVALUE );
                }
            }
            else
            {
                // If not optional and not defaultValue then the argument is
                // required and no defaults could have appeared in between.
                if ( !pArgToken->IsSet ( METHODARG_OPTIONAL ) )
                {
                    // Insure that once a default argument is hit all arguments from
                    // that point to the last argument im the function are either
                    // defaultValue or optional.
                    if (cRequiredArgs != cArgs)
                    {
                        sprintf ( szErrorText, "Default arguments must be contiguous to last argument %s in file %s.\n",
                                    (LPCSTR)pChild->GetTagValue ( METHOD_NAME ),
                                    _pszPDLFileName  );
                        ReportError ( szErrorText );
                        return FALSE;
                    }

                    // Arguments without a defaultValue/optional are required args.

                    // Unless the argument is a safe array than any number of
                    // arguments can be specified 0 to n arguments
                    if (strcmp((LPCSTR)(pArgToken -> GetTagValue(METHODARG_TYPE)), "SAFEARRAY(VARIANT)") != 0)
                        // Not a safearray so it's a required argument.
                        cRequiredArgs++;
                }
            }

            szArg += pArgToken -> GetTagValue ( METHODARG_TYPE );
            if (szArg == "oDoVARIANT")
            {
                sprintf ( szErrorText, "Default arguments cannot be VARIANT %s in file %s.\n",
                          (LPCSTR)pChild->GetTagValue ( METHOD_NAME ),
                          _pszPDLFileName  );
                ReportError ( szErrorText );
                return FALSE;
            }

            if ( pArgToken->IsSet ( METHODARG_OPTIONAL ) &&
                 !(szArg == "o0oVARIANT" || szArg == "o0oVARIANT*") )
            {
                sprintf ( szErrorText, "Optional arguments can ONLY be VARIANT or VARIANT* %s in file %s.\n",
                          (LPCSTR)pChild->GetTagValue ( METHOD_NAME ),
                          _pszPDLFileName  );
                ReportError ( szErrorText );
                return FALSE;
            }

            // Should this type be mapped to IDispatch?
            pDispatchType = MapTypeToIDispatch ( szArg );
            if (pDispatchType)
            {
                // Remap to IDispatch* or IDispatch**
                szArg = pDispatchType;
            }

            cArgs++;

            // Remove any underscores in the type name.
            while ((pWS = szArg.FindChar('_')))
            {
                while (*pWS = *(pWS + 1))
                    pWS++;
                *pWS = '\0';
            }

            szArgsType += "_";
            szArgsType += (LPCSTR)szArg;
        }
    }

    return TRUE;
}




BOOL CPDLParser::ComputeMethod ( Token *pClassToken, Token *pChild )
{
    CString             szTypesSig;
    CString             szArgsType;
    CString             szDispid;
    CTokenListWalker    ArgListWalker ( pChild );
    char                chCustomInvokeIdx[128];
    int                 cArgs = 0;
    int                 cRequiredArgs = 0;
    char                szErrorText [ MAX_LINE_LEN+1 ];
    char               *pDefaultParams[MAX_ARGS]    = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
    char               *pDefaultStrParams[MAX_ARGS] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
    BOOL                fBSTRArg;
    BOOL                fVARIANTArg;

    if (!BuildMethodSignature(pChild,
                              szTypesSig,
                              szArgsType,
                              fBSTRArg,
                              fVARIANTArg,
                              cArgs,
                              cRequiredArgs,
                              pDefaultParams,
                              pDefaultStrParams))
        return FALSE;

    // Any default values?
    if (cArgs != cRequiredArgs)
    {
        int     i;

        // Spit out any default string constants.
        for ( i = cRequiredArgs; i < cArgs; i++)
        {
            if ( pDefaultStrParams[i] )
            {
                fprintf ( fpHDLFile, "const TCHAR s_strDef%s%s%i[] = _T(%s);\n",
                          (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                          (LPCSTR)pChild->GetTagValue ( METHOD_NAME ),
                          i - cRequiredArgs,
                          pDefaultStrParams[i] );
                             
            }
        }

        fprintf ( fpHDLFile, "const DEFAULTARGDESC s_defArg%s%s =\n{\n",
                  (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                  (LPCSTR)pChild->GetTagValue ( METHOD_NAME ) );

        // Spit out the all of all default constants
        for ( i = cRequiredArgs; i < cArgs; i++)
        {
            if ( pDefaultStrParams[i] )
            {
                fprintf ( fpHDLFile, "    (DWORD_PTR)s_strDef%s%s%i,\n",
                          (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                          (LPCSTR)pChild->GetTagValue ( METHOD_NAME ),
                          i - cRequiredArgs );
            }
            else
            {
                fprintf ( fpHDLFile, "    (DWORD_PTR)%s,\n", pDefaultParams[i] ? pDefaultParams[i] : "\"\""  );
            }
        }

        fprintf ( fpHDLFile, "};\n" );
    }

    // If no return value then set the retVal to void.
    if (!szTypesSig[0])
    {
        szTypesSig = "void";
    }

    // If no arguments then set the argList to void.
    if (!szArgsType[0])
    {
        szArgsType = "_void";
    }

    szTypesSig += szArgsType;

    szDispid = pChild->GetTagValue(METHOD_DISPID);
    if (szDispid[0])
    {
        // Write out the function signature for this method
        // only do this if a dispid exists.  Methods without dispid
        // are not accessible through automation.
        if ( !FindAndAddSignature ( "Method", szTypesSig, &chCustomInvokeIdx[0] ) )
            return FALSE;
    }
    
    fprintf ( fpHDLFile, "EXTERN_C const PROPERTYDESC_METHOD s_methdesc%s%s = \n{\n",
              (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
              (LPCSTR)pChild->GetTagValue ( METHOD_NAME ));

    fprintf ( fpHDLFile, "    NULL, NULL, _T(\"%s\"), (ULONG)0, (ULONG)0,\n    {\n",
              (LPCSTR)pChild->GetTagValue ( METHOD_NAME ));

    if (!szDispid[0])
    {
        // Dispid not specified this is an error all methods should be accessible
        // from automation.
        sprintf ( szErrorText, "DISPID required for method: %s::%s in %s.\n",
                  (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                  (LPCSTR)pChild->GetTagValue ( METHOD_NAME ),
                  _pszPDLFileName  );
        ReportError ( szErrorText );
        return FALSE;
    }

    if (fBSTRArg || fVARIANTArg)
    {
        if (!pChild->IsSet(METHOD_MAXSTRLEN))
        {
            // Dispid not specified this is an error all methods should be accessible
            // from automation.
            sprintf ( szErrorText, "maxstrlen required for method: %s::%s in %s.\n",
                      (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                      (LPCSTR)pChild->GetTagValue ( METHOD_NAME ),
                      _pszPDLFileName  );
            ReportError ( szErrorText );
            return FALSE;
        }
    }
    else if (pChild->IsSet(METHOD_MAXSTRLEN))
    {
        // Dispid not specified this is an error all methods should be accessible
        // from automation.
        sprintf ( szErrorText, "maxstrlen NOT required for method: %s::%s in %s.\n",
                  (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                  (LPCSTR)pChild->GetTagValue ( METHOD_NAME ),
                  _pszPDLFileName  );
        ReportError ( szErrorText );
        return FALSE;
    }

    fprintf ( fpHDLFile, "        %s, %s, 0, %s, %s\n    },\n    ",
              pChild->IsSet(METHOD_RESTRICTED) ? "PROPPARAM_RESTRICTED" : "0",
              (LPCSTR)szDispid,
              (LPCSTR)&chCustomInvokeIdx[0],
              pChild->IsSet(METHOD_MAXSTRLEN) ? (LPCSTR)pChild->GetTagValue(METHOD_MAXSTRLEN) : "0");
    
    if (fpMaxLenFile && pChild->IsSet(METHOD_MAXSTRLEN))
    {
        fprintf ( fpMaxLenFile, "%s::%s    %s\n",
                  (LPCSTR)pClassToken->GetTagValue(CLASS_NAME),
                  (LPCSTR)pChild->GetTagValue(METHOD_NAME),
                  (LPCSTR)pChild->GetTagValue(METHOD_MAXSTRLEN) );
    }

    if ( cArgs != cRequiredArgs )
    {
        fprintf ( fpHDLFile, "&s_defArg%s%s, ", 
                  (LPCSTR)pClassToken->GetTagValue ( CLASS_NAME ),
                  (LPCSTR)pChild->GetTagValue ( METHOD_NAME ) );
    }
    else
    {
        fprintf ( fpHDLFile, "NULL, " );
    }
    
    fprintf ( fpHDLFile, "%i, %i\n};\n\n",
              cArgs,
              cRequiredArgs );

    return TRUE;
}


BOOL CPDLParser::GeneratePROPDESCs ( void )
{
    Token *pClassToken;
    Token *pChild;

    // Only generate def's for this file
    CTokenListWalker TokenList ( pRuntimeList, _pszPDLFileName );

    // Generate propdescs for every property token in every class ( in this file )
    while ( pClassToken = TokenList.GetNext( TYPE_CLASS ) )
    {
        fprintf ( fpHDLFile, "\n" );
        CTokenListWalker ChildList ( pClassToken );

//        if ( pClassToken -> IsSet ( CLASS_ABSTRACT ) )
//        {
//            fprintf ( fpHDLFile, "\n#ifndef _PROPDESCS_EXTERNAL\n" );
//        }

        fprintf ( fpHDLFile, "\n#define _%s_PROPDESCS_\n", pClassToken -> GetTagValue ( CLASS_NAME ) );

        // Walk the super class propdescs looking for properties
        while ( pChild = ChildList.GetNext() )
        {
            if ( pChild->nType == TYPE_PROPERTY &&
                 _stricmp(pChild->GetTagValue(PROPERTY_NOPROPDESC), "nameonly") != 0 )
            {
                if ( !ComputeProperty ( pClassToken, pChild ) )
                    return FALSE;
            }
            else if ( pChild->nType == TYPE_METHOD && !pChild->IsSet(METHOD_NOPROPDESC))
            {
                if (!ComputeMethod(pClassToken, pChild) )
                    return FALSE;
            }
            else
            {
                continue;
            }
        }

        if (fpMaxLenFile)
            fprintf(fpMaxLenFile, "\n");
    }
    return TRUE;
}

void CPDLParser::GenerateThunkContext ( Token *pClassToken )
{
    CTokenListWalker ChildList (pClassToken);

    Token *pChildToken;

    while (pChildToken = ChildList.GetNext())
    {
        if( (pChildToken->GetType() == TYPE_METHOD && pChildToken->IsSet(METHOD_THUNKCONTEXT)) || 
            (pChildToken->GetType() == TYPE_PROPERTY && pChildToken->IsSet(PROPERTY_THUNKCONTEXT)) )
        {
            GenerateSingleThunkContextPrototype(pClassToken, pChildToken, FALSE);
        }
        if( (pChildToken->GetType() == TYPE_METHOD && pChildToken->IsSet(METHOD_THUNKNODECONTEXT)) || 
            (pChildToken->GetType() == TYPE_PROPERTY && pChildToken->IsSet(PROPERTY_THUNKNODECONTEXT)) )
        {
            GenerateSingleThunkContextPrototype(pClassToken, pChildToken, TRUE);
        }
    }

}

void CPDLParser::GenerateSingleThunkContextPrototype ( Token *pClassToken, Token * pChildToken, BOOL fNodeContext )
{
    CString szProp;
    Token *pArgToken;

    if (pChildToken->GetType() == TYPE_METHOD)
    {
        CTokenListWalker ArgListWalker(pChildToken);
        BOOL fFirst = TRUE;

        fprintf(fpHDLFile, "    STDMETHODIMP %s(", (LPCSTR)pChildToken->GetTagValue(METHOD_NAME));
        while (pArgToken = ArgListWalker.GetNext())
        {
            if (!fFirst)
                fprintf(fpHDLFile, ",");
            fprintf(fpHDLFile, "%s %s",
                ConvertType((LPCSTR)pArgToken->GetTagValue ( METHODARG_TYPE )),
                (LPCSTR)pArgToken -> GetTagValue ( METHODARG_ARGNAME ) );
            fFirst = FALSE;
        }

        if(fNodeContext)
        {
            fprintf(fpHDLFile, "%sCTreeNode *pNode);\n", fFirst?"":",");
        }
        else
        {
            fprintf(fpHDLFile, "%sTEAROFF_THUNK*ptt);\n", fFirst?"":",");
        }
    }
    else
    {
        if (pChildToken->IsSet(PROPERTY_SET))
        {
            fprintf(fpHDLFile, "    STDMETHODIMP set_%s(%s v, %s);\n",
                    (LPCSTR)pChildToken->GetTagValue(PROPERTY_NAME),
                    (LPCSTR)pChildToken -> GetTagValue(PROPERTY_ATYPE),
                    fNodeContext?"CTreeNode *pNode":"TEAROFF_THUNK *ptt");
        }
        if (pChildToken->IsSet(PROPERTY_GET))
        {
            fprintf(fpHDLFile, "    STDMETHODIMP get_%s(%s *p, %s);\n",
                    (LPCSTR)pChildToken->GetTagValue(PROPERTY_NAME),
                    (LPCSTR)pChildToken -> GetTagValue(PROPERTY_ATYPE),
                    fNodeContext?"CTreeNode *pNode":"TEAROFF_THUNK *ptt");
        }
    }
}

void CPDLParser::GenerateThunkContextImplemenation ( Token *pClassToken )
{
    CTokenListWalker ChildList (pClassToken);

    Token *pChildToken;

    while (pChildToken = ChildList.GetNext())
    {
        if( (pChildToken->GetType() == TYPE_METHOD && pChildToken->IsSet(METHOD_THUNKCONTEXT)) || 
            (pChildToken->GetType() == TYPE_PROPERTY && pChildToken->IsSet(PROPERTY_THUNKCONTEXT)) )
        {
            GenerateSingleThunkContextImplementation(pClassToken, pChildToken, FALSE);
        }
        if( (pChildToken->GetType() == TYPE_METHOD && pChildToken->IsSet(METHOD_THUNKNODECONTEXT)) || 
            (pChildToken->GetType() == TYPE_PROPERTY && pChildToken->IsSet(PROPERTY_THUNKNODECONTEXT)) )
        {
            GenerateSingleThunkContextImplementation(pClassToken, pChildToken, TRUE);
        }
    }
}

void CPDLParser::GenerateSingleThunkContextImplementation ( Token *pClassToken, Token * pChildToken, BOOL fNodeContext )
{
    CString szProp;
    Token *pArgToken;

    fprintf(fpHDLFile, "#ifdef USE_STACK_SPEW\n#pragma check_stack(off)\n#endif\n");

    if (pChildToken->GetType() == TYPE_METHOD)
    {
        CTokenListWalker ArgListWalker(pChildToken);
        BOOL fFirst = TRUE;

        fprintf(fpHDLFile, "STDMETHODIMP %s::ContextThunk_%s(", 
                (LPCSTR)pClassToken->GetTagValue(CLASS_NAME),
                (LPCSTR)pChildToken->GetTagValue(METHOD_NAME));

        while (pArgToken = ArgListWalker.GetNext())
        {
            if (!fFirst)
                fprintf(fpHDLFile, ",");
            fprintf(fpHDLFile, "%s %s",
                ConvertType((LPCSTR)pArgToken->GetTagValue ( METHODARG_TYPE )),
                (LPCSTR)pArgToken -> GetTagValue ( METHODARG_ARGNAME ) );
            fFirst = FALSE;
        }

        if(fNodeContext)
        {
            fprintf(fpHDLFile, ")\n"
                               "{\n"
                               "    CTreeNode* pNode;\n"
                               "    CONTEXTTHUNK_SETTREENODE\n"
                               "    return %s(", (LPCSTR)pChildToken->GetTagValue(METHOD_NAME));
        }
        else
        {
            fprintf(fpHDLFile, ")\n"
                               "{\n"
                               "    TEAROFF_THUNK* ptt;\n"
                               "    CONTEXTTHUNK_SETTEAROFFTHUNK\n"
                               "    return %s(", (LPCSTR)pChildToken->GetTagValue(METHOD_NAME));
        }

        fFirst = TRUE;
        ArgListWalker.Reset();
        while (pArgToken = ArgListWalker.GetNext())
        {
            if (!fFirst)
                fprintf(fpHDLFile, ",");
            fprintf(fpHDLFile, "%s",
                (LPCSTR)pArgToken -> GetTagValue(METHODARG_ARGNAME));
            fFirst = FALSE;
        }
        fprintf(fpHDLFile, "%s%s);\n}\n", fFirst?"":",", fNodeContext?"pNode":"ptt");
    }
    else
    {
        if (pChildToken->IsSet(PROPERTY_SET))
        {
            fprintf(fpHDLFile, 
                    "STDMETHODIMP %s::ContextThunk_set_%s(%s v)\n"
                    "{\n%s    return set_%s(v,%s);\n}\n",
                    (LPCSTR)pClassToken->GetTagValue(CLASS_NAME),
                    (LPCSTR)pChildToken->GetTagValue(PROPERTY_NAME),
                    (LPCSTR)pChildToken->GetTagValue(PROPERTY_ATYPE),
                    fNodeContext 
                      ? "    CTreeNode* pNode;\n"
                        "    CONTEXTTHUNK_SETTREENODE\n"
                      : "    TEAROFF_THUNK* ptt;\n"
                        "    CONTEXTTHUNK_SETCONTEXTTHUNK\n",
                    (LPCSTR)pChildToken->GetTagValue(PROPERTY_NAME),
                    fNodeContext ? "pNode" : "ptt");
        }
        if (pChildToken->IsSet(PROPERTY_GET))
        {
            fprintf(fpHDLFile, 
                    "STDMETHODIMP %s::ContextThunk_get_%s(%s *p)\n"
                    "{\n%s    return get_%s(p,%s);\n}\n",
                    (LPCSTR)pClassToken->GetTagValue(CLASS_NAME),
                    (LPCSTR)pChildToken->GetTagValue(PROPERTY_NAME),
                    (LPCSTR)pChildToken->GetTagValue(PROPERTY_ATYPE),
                    fNodeContext 
                      ? "    CTreeNode* pNode;\n"
                        "    CONTEXTTHUNK_SETTREENODE\n"
                      : "    TEAROFF_THUNK* ptt;\n"
                        "    CONTEXTTHUNK_SETCONTEXTTHUNK\n",
                    (LPCSTR)pChildToken->GetTagValue(PROPERTY_NAME),
                    fNodeContext ? "pNode" : "ptt");
        }
    }
    fprintf(fpHDLFile, "#ifdef USE_STACK_SPEW\n#pragma check_stack(on)\n#endif\n");
}


BOOL CPDLParser::GenerateHDLFile ( void )
{
    Token  *pClassToken;
    BOOL    bHashTableExists;
    int     numVTblPropDescs;

    CTokenListWalker ThisFilesList ( pRuntimeList, _pszPDLFileName );

    fprintf ( fpHDLFile, "\n" );
    fprintf ( fpHDLFile, "// %s.hdl\n",  _pszOutputFileRoot );
    fprintf ( fpHDLFile, "\n" );
    fprintf ( fpHDLFile, "#ifdef _hxx_\n" );
    fprintf ( fpHDLFile, "\n" );
    fprintf ( fpHDLFile, "#include \"%s.h\"\n",  _pszOutputFileRoot );
    fprintf ( fpHDLFile, "\n" );

    // Generate the DISPID's, one for each member of each class

    fprintf ( fpLOGFile, "Generating DISPID's...\n" );
    GenerateClassDISPIDs();
    GenerateInterfaceDISPIDs();
    GenerateEventDISPIDs( fpHDLFile, TRUE );

    fprintf ( fpHDLFile, "\n" );
    fprintf ( fpHDLFile, "#endif _hxx_\n" );
    fprintf ( fpHDLFile, "\n" );
    fprintf ( fpHDLFile, "#undef _hxx_\n" );
    fprintf ( fpHDLFile, "\n" );

    fprintf ( fpHDLFile, "#ifdef _cxx_\n" );
    fprintf ( fpHDLFile, "\n" );

    // Generate the enum definitions
    fprintf ( fpLOGFile, "Generating CPP Enum Defs...\n" );
    GenerateCPPEnumDefs();

    // Generate the property descriptors
    fprintf ( fpLOGFile, "Generating PROPDESC's...\n" );
    if ( !GeneratePROPDESCs() )
        goto Error;

#ifdef COMPLUS_SHIM

    // ***TLL*** COM+: Not spitting COM+ proxies for internal.pdl and mshtmext.pdl need to do, shouldn't special case.
    if ((_stricmp(_pszPDLFileName, "internal.pdl") != 0) && (_stricmp(_pszPDLFileName, "mshtmext.pdl") != 0))
    {
        GenComPlusESI();		// Output any local interfaces for COM+
    }

#endif    // COMPLUS_SHIM

    // For each TYPE_CLASS in this file generate a propdesc array and vtable
    // array for the class.
    while ( pClassToken = ThisFilesList.GetNext( TYPE_CLASS ) )
    {
        // Generate propdescs for every property token in every class ( in this file )
        fprintf ( fpLOGFile, "Generating PROPDESC Arrays...\n" );

        if ( !GenerateCPC( pClassToken ) )
            goto Error;

        // Generate the vtable array for classes in this file
        fprintf ( fpLOGFile, "Generating VTable Arrays...\n" );

        GenerateVTableArray(pClassToken, &bHashTableExists);

        // Generate the propdesc array in vtable order for classes in this file
        fprintf ( fpLOGFile, "Generating propdesc Arrays in vtbl order...\n" );

        GeneratePropDescsInVtblOrder(pClassToken, &numVTblPropDescs);

        // Abstract classes don't have propdesc arrays or vtable arrays.
        if ( !pClassToken -> IsSet ( CLASS_ABSTRACT ) )
        {
            fprintf ( fpHDLFile, "\nconst HDLDESC %s::s_apHdlDescs = { ",
                      pClassToken -> GetTagValue ( CLASS_NAME ) );

            // Store the Mondo DISPID int he HDLDesc so we can find it for GetTypeInfo
            if ( HasMondoDispInterface ( pClassToken ) )
            {
                CString szDispName;

                // Map to mondo dispinterface as default dispatch interface.
                szDispName = (pClassToken->IsSet(CLASS_COCLASSNAME)) ?
                                pClassToken->GetTagValue (CLASS_COCLASSNAME) :
                                pClassToken->GetTagValue(CLASS_NAME);
                fprintf ( fpHDLFile, " &DIID_Disp%s,", (LPCSTR)szDispName );
            }
            else
            {
                fprintf ( fpHDLFile, " NULL," );
            }

            if ( bHashTableExists )
            {
                fprintf ( fpHDLFile, "&%s::s_StringTableAggregate, ",
                          pClassToken -> GetTagValue ( CLASS_NAME ) );
            }
            else
            {
                fprintf ( fpHDLFile, "NULL, ");
            }

            if ( numVTblPropDescs )
            {
                fprintf ( fpHDLFile, "%s::s_ppropdescsInVtblOrder%s};\n",
                          pClassToken->GetTagValue(CLASS_NAME), pClassToken->GetTagValue(CLASS_INTERFACE) );
            }
            else
            {
                fprintf ( fpHDLFile, "NULL};\n" );
            }
        }
    }

    fprintf ( fpLOGFile, "Generating Property Methods...\n" );
    if ( !GeneratePropMethodImplementation() )
        goto Error;

    fprintf ( fpLOGFile, "Generating Cascaded Property Method Implementations...\n" );

    fprintf ( fpHDLFile, "//    Cascaded Property get method implementations\n\n" );

    ThisFilesList.Reset();
    while ( pClassToken = ThisFilesList.GetNext( TYPE_CLASS ) )
    {
        GenerateGetAAXImplementations(pClassToken);
        GenerateThunkContextImplemenation(pClassToken);
    }

    fprintf ( fpHDLFile, "\n" );
    fprintf ( fpHDLFile, "#endif _cxx_\n" );
    fprintf ( fpHDLFile, "\n" );
    fprintf ( fpHDLFile, "#undef _cxx_\n" );
    fprintf ( fpHDLFile, "\n" );

    fprintf ( fpLOGFile, "Generating Class Includes...\n" );

    if ( !GenerateClassIncludes() )
        goto Error;

    return TRUE;

Error:
    return FALSE;
}

FILE *OpenMaxlengthFile(LPCSTR pszPDLFileName, LPCSTR pszOutputPath)
{
    char  chMaxLenFileName[255];
    FILE *fpMaxLenFile = NULL;
    BOOL  fOpenNew = TRUE;

    strcpy(chMaxLenFileName, pszOutputPath);
    strcat(chMaxLenFileName, FILENAME_SEPARATOR_STR "maxlen.txt");

    fpMaxLenFile = fopen(chMaxLenFileName, "r");
    if (fpMaxLenFile)
    {
        char chMarker[6];
        if (fread(chMarker, sizeof(char), 5, fpMaxLenFile))
        {
            if (!_stricmp(chMarker, "XXXXX"))
            {
                fOpenNew = FALSE;
            }
        }

        fclose(fpMaxLenFile);
    }

    if (fOpenNew)
    {
        fpMaxLenFile = fopen(chMaxLenFileName, "w");
        if (fpMaxLenFile)
        {
            fprintf(fpMaxLenFile, "XXXXX Key Value Glossary:\n");
            fprintf(fpMaxLenFile, "-------------------------------\n");
            fprintf(fpMaxLenFile, "pdlUrlLen = 4096         // url strings\n");
            fprintf(fpMaxLenFile, "pdlToken = 128           // strings that really are some form of a token\n"); 
            fprintf(fpMaxLenFile, "pdlLength = 128          // strings that really are numeric lengths\n");
            fprintf(fpMaxLenFile, "pdlColor = 128           // strings that really are color values\n");
            fprintf(fpMaxLenFile, "pdlNoLimit = 0xFFFF      // strings that have no limit on their max lengths\n");
            fprintf(fpMaxLenFile, "pdlEvent = pdlNoLimit    // strings that could be assigned to onfoo event properties\n\n");
            fprintf(fpMaxLenFile, "MAX LENGTH CONSTANTS FOR OM PROPERTIES AND METHODS\n");
            fprintf(fpMaxLenFile, "-----------------------------------------------------------------------------------\n\n");
        }
    }
    else
    {
        fpMaxLenFile = fopen(chMaxLenFileName, "a");
    }

    return fpMaxLenFile;
}

int
CPDLParser::Parse ( char *szInputFile,
    char *szOutputFileRoot,
    char *szPDLFileName,
    char *szOutputPath,
    BOOL fDebugging )
{
#if 0
if (strcmp(szPDLFileName, "iframe.pdl") == 0)
    __asm {int 3};
#endif

    int		nReturnCode = 0;
    char	szFileName [ MAX_PATH+1 ];
    char	szErrorText [ MAX_LINE_LEN+1 ];
#ifdef COMPLUS_SHIM
    BOOL	fWriteHeader = FALSE;
#endif

    _pszPDLFileName = szPDLFileName;
    _pszOutputFileRoot = szOutputFileRoot;
    _pszInputFile = szInputFile;
    _pszOutputPath = szOutputPath;

    fpMaxLenFile = OpenMaxlengthFile(szPDLFileName, szOutputPath);

    // Read the input file a line at a time, for each line tokenise and
    // parse
    strcpy ( szFileName, szOutputPath );
    strcat ( szFileName, "LOG" );

    fpLOGFile = fopen ( szFileName, "w" );
    if ( !fpLOGFile )
    {
        printf ( szErrorText, "Can't open log file %s\n", szFileName );
        ReportError ( szErrorText );

        goto error;
    }

    fprintf ( fpLOGFile, "InputBuffer = %s\n", szInputFile );
    fprintf ( fpLOGFile, "OuputFileRoot = %s\n", szOutputFileRoot );
    fprintf ( fpLOGFile, "PDLFileName = %s\n", szPDLFileName );
    fprintf ( fpLOGFile, "LogFileName =% s\n", szFileName );

    // All files open and raring to go....
    if ( !ParseInputFile ( fDebugging ) )
    {
        goto error;
    }

    // Create the HDL File
    strcpy ( szFileName, szOutputFileRoot );
    strcat ( szFileName, ".hdl" );

    fpHDLFile = fopen ( szFileName, "w" );
    if ( !fpHDLFile )
    {
        printf ( szErrorText, "Can't open HDL output file %s\n", szFileName );
        ReportError ( szErrorText );

        goto error;
    }

#ifdef COMPLUS_SHIM

    // Create the COM+ header file
    strcpy ( szFileName, _pszOutputPath );
    strcat ( szFileName, "\\" );
    strcat ( szFileName, "MSProxy.h" );

    fpHComPlusFile = fopen ( szFileName, "r" );
    if (!fpHComPlusFile)
    {
        fWriteHeader = TRUE;
    }
    else
    {
        fclose(fpHComPlusFile);
    }

    fpHComPlusFile = fopen ( szFileName, "a" );
    if ( !fpHComPlusFile )
    {
        printf ( szErrorText, "Can't open COM+ output file %s\n", szFileName );
        ReportError ( szErrorText );

        goto error;
    }

    // Only write the header first time through not when each PDL is parsed.
    if (fWriteHeader)
    {
        fprintf(fpHComPlusFile, "[managed, com] __interface ICOMCookie\n");
        fprintf(fpHComPlusFile, "{\n");
        fprintf(fpHComPlusFile, "public:\n");
        fprintf(fpHComPlusFile, "\tunsigned int getCOMCookie();\n");
        fprintf(fpHComPlusFile, "};\n\n");
    }

    // Create the COM+ source file
    strcpy ( szFileName, _pszOutputPath );
    strcat ( szFileName, "\\" );
    strcat ( szFileName, "MSProxy.cpp" );

    fpCComPlusFile = fopen ( szFileName, "r" );
    if (!fpCComPlusFile)
    {
        fWriteHeader = TRUE;
    }
    else
    {
        fclose(fpCComPlusFile);
    }

    fpCComPlusFile = fopen ( szFileName, "a" );
    if ( !fpCComPlusFile )
    {
        printf ( szErrorText, "Can't open COM+ output file %s\n", szFileName );
        ReportError ( szErrorText );

        goto error;
    }

    // Only write the header first time through not when each PDL is parsed.
    if (fWriteHeader)
    {
        fprintf(fpCComPlusFile, "#import <MSCorLib.dll>\n\n");
        fprintf(fpCComPlusFile, "// Some types COM+ doesn't know remapped.\n");
        fprintf(fpCComPlusFile, "#define LONG	long\n\n");
        fprintf(fpCComPlusFile, "#include \"MSProxy.h\"\n");
        fprintf(fpCComPlusFile, "#include \"TComPlus.hxx\"\n\n\n");
    }

#endif    // COMPLUS_SHIM

    // Create the IDL File
    strcpy ( szFileName, szOutputFileRoot );
    strcat ( szFileName, ".idl" );

    fpIDLFile = fopen ( szFileName, "w" );
    if ( !fpIDLFile )
    {
        printf ( szErrorText, "Can't open IDL output file %s\n", szFileName );
        ReportError ( szErrorText );
        goto error;
    }

    // Create the external Header file for the SDK users
    // Create the HDL File
    strcpy ( szFileName, szOutputFileRoot );
    strcat ( szFileName, ".h" );    // For now

    fpHeaderFile = fopen ( szFileName, "w" );
    if ( !fpHeaderFile )
    {
        printf ( szErrorText, "Can't open Header output file %s\n", szFileName );
        ReportError ( szErrorText );
        goto error;
    }

    // Create the external DISPIDs file for the SDK users
    strcpy ( szFileName, szOutputFileRoot );
    strcat ( szFileName, ".dsp" );    // For now

    fpDISPIDFile = fopen ( szFileName, "w" );
    if ( !fpDISPIDFile )
    {
        printf ( szErrorText, "Can't open DISPID output file %s\n", szFileName );
        ReportError ( szErrorText );
        goto error;
    }

    // Create function signatures required for the custom OLEAutomation invoke.
    if ( !LoadSignatures (szOutputPath) )
    {
        ReportError ( "Signature file missing" );
        goto error;
    }

#if COLLECT_STATISTICS==1
    LoadStatistics (szOutputPath);
#endif

    // Parsed Successfully - generate HDL file
    if ( !GenerateHDLFile () )
    {
        printf ( szErrorText, "Can't create HDL output file %s%s.hdl\n",
                 szOutputFileRoot, szFileName );
        ReportError ( szErrorText );

        goto error;
    }

    strcpy ( szFileName, szOutputFileRoot );
    strcat ( szFileName, ".idl" ); // For now hxx
    if ( !GenerateIDLFile( szFileName ) )
    {
        printf ( szErrorText, "Can't create IDL file %s\n", szFileName );
        ReportError ( szErrorText );

        goto error;
    }

    // Generate the .H file with just enums & interface decls in
    GenerateHeaderFile();

    // Generate the external DISPID's file
    GenerateExternalInterfaceDISPIDs();
    GenerateEventDISPIDs ( fpDISPIDFile, FALSE );

    // Create/Open the HTML index file
    strcpy ( szFileName, szOutputPath );
    strcat ( szFileName, FILENAME_SEPARATOR_STR "AllIndex.htm" );
    fpHTMIndexFile = fopen ( szFileName, "a+" );

/* rgardner - commented out for now - not very up-to-date or useful any more
    // Create the HTM File
    strcpy ( szFileName, szOutputFileRoot );
    strcat ( szFileName, ".htm" );

    fpHTMFile = fopen ( szFileName, "w" );

    if ( !GenerateHTMFile( ) )
    {
        printf ( szErrorText, "Can't create HTM file %s\n", szFileName );
        ReportError ( szErrorText );

        goto error;
    }
*/

    // Update the signature file is any changes.
    if (!SaveSignatures( szOutputPath ))
    {
        ReportError ( "Signature file save problem." );
        goto error;
    }

#if COLLECT_STATISTICS==1
    SaveStatistics (szOutputPath);
#endif

    goto cleanup;

error:
    if ( nReturnCode == 0 )
        nReturnCode = 1;

cleanup:
    return nReturnCode;

}


#if COLLECT_STATISTICS==1

void CPDLParser::LoadStatistics ( char *pszOutputPath )
{
    BOOL        bRetVal;
    char       *buffer = NULL;
    CString     szFileName;
    FILE       *fpStatFile = NULL;

    szFileName = pszOutputPath;
    szFileName += FILENAME_SEPARATOR_STR "stats.dat";

    fpStatFile = fopen ( szFileName, "r" );
    if ( !fpStatFile )
    {
        char    chInitFuncSig[2] = { '\0', '\0' };

        fpStatFile = fopen ( szFileName, "w+");
        if ( !fpStatFile )
        {
            ReportError ( "Can't create statistics file" );
            goto error;
        }

        fwrite ( chInitFuncSig, 1, sizeof(chInitFuncSig), fpStatFile );
    }

    if ( fseek( fpStatFile, 0, SEEK_END ) == 0 )
    {
        fpos_t  pos;

        if ( fgetpos( fpStatFile, &pos ) == 0 )
        {
            int     i = 0;
            int     cLines;
            
            buffer = new char[pos];
            if (buffer == NULL)
                goto error;

            fseek( fpStatFile, 0, SEEK_SET );

            if ( fread ( buffer, 1, pos, fpStatFile ) != pos )
                goto error;

            // Intialize to 0.
            for (i = 0; i < MAX_STATS; i++)
                rgcStats[i] = 0;

            // Populate the statics array.
            i = 0;
            cLines = 0;
            while ( buffer[i] || buffer[i + 1] )
            {
                int     cStr = strlen(buffer + i);

                rgcStats[cLines] = atol(buffer + i);

                cLines ++;

                i += cStr + 1;
            }
        }
    }

    bRetVal = TRUE;

cleanup:
    delete buffer;

    fclose ( fpStatFile );

    return;

error:
    bRetVal = FALSE;
    goto cleanup;
}


void CPDLParser::SaveStatistics ( char *pszOutputPath )
{
//DebugBreak();
    BOOL        bRetVal = TRUE;
    if (rgcStats)
    {
        int         i;
        CString     szFileName;
        FILE       *fpStatFile = NULL;
        char        buffer[32];

        szFileName = pszOutputPath;
        szFileName += FILENAME_SEPARATOR_STR "stats.dat";

        fpStatFile = fopen ( szFileName, "w" );

        // Write array to file.
        if ( fseek( fpStatFile, 0, SEEK_SET ) != 0 )
            return;

        i = 0;
        while (i < MAX_STATS)
        {
            sprintf( buffer, "%i", rgcStats[i] );
            fwrite ( buffer, 1, strlen(buffer) + 1, fpStatFile );

            i++;
        }

        // Double NULL at the end.
        buffer[0] = '\0'; 
        buffer[1] = '\0'; 
        fwrite ( &buffer, 1, 2, fpStatFile );

        fclose(fpStatFile);
    }

    return;
}

#endif


void CPDLParser::RemoveSignatures()
{
    if (rgszSignatures)
    {
        int     i = cSignatures;

        while (i--)
            delete [] rgszSignatures[i];

        delete [] rgszSignatures;

        rgszSignatures = NULL;
    }

    if (rgszIIDs)
    {
        int     i = cIIDs;

        while (i--)
            delete [] rgszIIDs[i];

        delete [] rgszIIDs;

        rgszIIDs = NULL;
    }
}


BOOL CPDLParser::LoadSignatures ( char *pszOutputPath )
{
    BOOL        bRetVal;
    char       *buffer = NULL;
    CString     szFileName;
    FILE       *fpSigFile = NULL;

    rgszSignatures = NULL;
    cOnFileSignatures = 0;
    cOnFileIIDs = 0;
    cSignatures = 0;
    cIIDs = 0;

    szFileName = pszOutputPath;
    szFileName += FILENAME_SEPARATOR_STR "funcsig.dat";

/*
if (strcmp(_pszPDLFileName, "select.pdl") == 0 || strcmp(_pszPDLFileName, "header.pdl") == 0)
    __asm { int 3 };
*/

    fpSigFile = fopen ( szFileName, "rb" );
    if ( !fpSigFile )
    {
        char    chInitFuncSig[6] = { '\0', '\0', '\0', '\0', '\0', '\0' };

        fpSigFile = fopen ( szFileName, "w+");
        if ( !fpSigFile )
        {
            ReportError ( "Can't create function signature file" );
            goto error;
        }

        fwrite ( chInitFuncSig, 1, sizeof(chInitFuncSig), fpSigFile );
    }

    if ( fseek( fpSigFile, 0, SEEK_END ) == 0 )
    {
        fpos_t  pos;

        if ( fgetpos( fpSigFile, &pos ) == 0 )
        {
            int     i = 0;
            int     cLines;
            
            buffer = new char[pos];
            if (buffer == NULL)
                goto error;

            fseek( fpSigFile, 0, SEEK_SET );

            fread ( buffer, 1, pos, fpSigFile );

            // Number of entries for each signatures and IIDs
            cOnFileSignatures = buffer[0] & 0x000000ff;      // First byte is # signature
            cOnFileIIDs = buffer[1] & 0x000000ff;            // 2nd byte is # IIDs

            // Pre-allocate the signature array.
            rgszSignatures = new char *[cOnFileSignatures + 1];
            if ( !rgszSignatures )
                goto error;

            // Pre-allocate the IIDs array.
            rgszIIDs = new char *[cOnFileIIDs + 1];
            if ( !rgszIIDs )
                goto error;

            // Intialize to NULL for error handling.
            for (i = 0; i <= cOnFileSignatures; i++)
                rgszSignatures[i] = NULL;

            cSignatures = cOnFileSignatures;

            for (i = 0; i <= cOnFileIIDs; i++)
                rgszIIDs[i] = NULL;

            cIIDs = cOnFileIIDs;

            // Populate the signature array.
            i = 4;
            cLines = 0;
            while ( cLines != cSignatures )
            {
                int     cStr = strlen(buffer + i);

                rgszSignatures[cLines] = new char[cStr + 1];
                if (!rgszSignatures[cLines])
                    goto error;

                strcpy(rgszSignatures[cLines], buffer + i);

                cLines ++;

                i += cStr + 1;
            }

            // Populate the IIDs array.
            cLines = 0;
            while ( cLines != cIIDs )
            {
                int     cStr = strlen(buffer + i);

                rgszIIDs[cLines] = new char[cStr + 1];
                if (!rgszIIDs[cLines])
                    goto error;

                strcpy(rgszIIDs[cLines], buffer + i);

                cLines ++;

                i += cStr + 1;
            }
        }
    }

    bRetVal = TRUE;

cleanup:
    fclose ( fpSigFile );

    return bRetVal;

error:
    delete [] buffer;

    RemoveSignatures();

    bRetVal = FALSE;
    goto cleanup;
}


BOOL CPDLParser::SaveSignatures ( char *pszOutputPath )
{
    if (rgszSignatures || rgszIIDs)
    {
        if (cOnFileSignatures != cSignatures || cOnFileIIDs != cIIDs)
        {
            int         i;
            CString     szFileName;
            FILE       *fpSigFile = NULL;
            char        cHeaderFuncSig[4] = { '\0', '\0', '\0', '\0' };

            szFileName = pszOutputPath;
            szFileName += FILENAME_SEPARATOR_STR "funcsig.dat";

            fpSigFile = fopen ( szFileName, "wb" );

            // Write array to file.
            if ( fseek( fpSigFile, 0, SEEK_SET ) != 0 )
                return FALSE;

            // Write out the header on count of each type.
            cHeaderFuncSig[0] = (char)cSignatures;
            cHeaderFuncSig[1] = (char)cIIDs;
            fwrite ( cHeaderFuncSig, 1, sizeof(cHeaderFuncSig), fpSigFile );

            i = 0;
            while (i < cSignatures)
            {
                if ( rgszSignatures[i] )
                {
                    fwrite ( rgszSignatures[i], 1, strlen(rgszSignatures[i]) + 1, fpSigFile );
                }

                i++;
            }

            i = 0;
            while (i < cIIDs)
            {
                if ( rgszIIDs[i] )
                {
                    fwrite ( rgszIIDs[i], 1, strlen(rgszIIDs[i]) + 1, fpSigFile );
                }

                i++;
            }

            // Write out extra zero to mark end of file.
            cHeaderFuncSig[0] = '\0';
            fwrite ( cHeaderFuncSig, 1, 1, fpSigFile );

            fclose(fpSigFile);
        }

        // Dispose of signature array (IIDs is disposed of too).
        RemoveSignatures();
    }

    return TRUE;
}


void
CPDLParser::MakeSignature (LPCSTR szType, LPCSTR szSignature, CString & szLookup)
{
    char    *szWork;

    // Any empty string for type or signature is an error.
    if (!szType[0] || !szSignature[0])
    {
        return;
    }

    // Replace all * with p (e.g., BSTR * is BSTRP and long * is longP).
    while ((szWork = strchr(szSignature, '*')) != NULL)
        *szWork = 'p';        

    // Replace all ( with P.
    while ((szWork = strchr(szSignature, '(')) != NULL)
        *szWork = 'P';        

    // Replace all ) with P.
    while ((szWork = strchr(szSignature, ')')) != NULL)
        *szWork = 'P';        

    szLookup = szType;
    szLookup += "_";
    szLookup += szSignature;
}


BOOL CPDLParser::FindAndAddSignature ( LPCSTR szType, LPCSTR szSignature, LPSTR pszInvokeMethod )
{
    BOOL        bRetVal = NULL;
    CString     szLookup;
    char      **rgNewArray = NULL;

    if (pszInvokeMethod && rgszSignatures)
    {
        strcpy( pszInvokeMethod,  "ERROR in PDLParse: No custom invoke method");

        MakeSignature(szType, szSignature, szLookup);

        // Look for the signature
        for (int i = 0; i < cSignatures; i++)
        {
            if ( strcmp ( rgszSignatures[i], szLookup ) == 0 )
            {
                goto success;
            }
        }

        // If not found then add this signature.
        cSignatures++;

        rgNewArray = new char *[cSignatures + 1];   // Take into account the NULL at end.
        if (!rgNewArray)
            goto cleanup;

        memcpy(rgNewArray, rgszSignatures, sizeof(char *) * cSignatures);

        rgNewArray[cSignatures - 1] = new char[szLookup.Length() + 1];

        strcpy(rgNewArray[cSignatures - 1], szLookup);

        rgNewArray[cSignatures] = NULL;

        delete rgszSignatures;

        rgszSignatures = rgNewArray;

success:
        strcpy(pszInvokeMethod, "IDX_");
        strcat(pszInvokeMethod, (LPCSTR)szLookup);
        bRetVal = TRUE;
    }

cleanup:
    return bRetVal;
}


int CPDLParser::FindAndAddIIDs ( CString szInterface )
{
    char      **rgNewArray = NULL;

    // Any empty string interface name is an error.
    if (szInterface.Length() == 0)
        return -1;          // Error.

    // Look for the signature
    for (int i = 0; i < cIIDs; i++)
    {
        if ( strcmp ( rgszIIDs[i], (LPCSTR)szInterface ) == 0 )
        {
            goto success;
        }
    }

    // If not found then add this IID.
    cIIDs++;

    rgNewArray = new char *[cIIDs + 1];   // Take into account the NULL at end.
    if (!rgNewArray)
        return -1;

    memcpy(rgNewArray, rgszIIDs, sizeof(char *) * cIIDs);

    rgNewArray[cIIDs - 1] = new char[szInterface.Length() + 1];

    strcpy(rgNewArray[cIIDs - 1], (LPCSTR)szInterface);

    rgNewArray[cIIDs] = NULL;

    delete rgszIIDs;

    rgszIIDs = rgNewArray;

success:
    return i;
}


BOOL CPDLParser::GenerateIDLFile ( char *szFileName )
{
    CTokenListWalker ThisFileList ( pRuntimeList, _pszPDLFileName );
    Token * pInterfaceToken;
    Token * pClassToken;
    Token * pEnumToken;
    Token * pStructToken;
    
    ThisFileList.Reset();
    while ( pInterfaceToken = ThisFileList.GetNext ( TYPE_EVENT ) )
    {
        if ( !pInterfaceToken -> IsSet ( EVENT_ABSTRACT ) &&
            pInterfaceToken -> IsSet ( EVENT_GUID ) )
        {
            GenerateIDLInterfaceDecl ( pInterfaceToken,
                pInterfaceToken -> GetTagValue ( EVENT_GUID ),
                pInterfaceToken -> GetTagValue ( EVENT_SUPER ) );
        }
    }

    ThisFileList.Reset();
    while (pEnumToken = ThisFileList.GetNext(TYPE_ENUM))
    {
        GenerateIncludeEnum(pEnumToken, FALSE, fpIDLFile);
    }
    
    //
    // Generate all the structs
    //

    ThisFileList.Reset();
    while (pStructToken = ThisFileList.GetNext(TYPE_STRUCT))
    {
        GenerateStruct(pStructToken, fpIDLFile);
    }
    
    ThisFileList.Reset();
    while ( pInterfaceToken = ThisFileList.GetNext ( TYPE_INTERFACE ) )
    {
        if ( !pInterfaceToken -> IsSet ( INTERFACE_ABSTRACT ) &&
            pInterfaceToken -> IsSet ( INTERFACE_GUID ) )
        {
            GenerateIDLInterfaceDecl ( pInterfaceToken,
                pInterfaceToken -> GetTagValue ( INTERFACE_GUID ),
                pInterfaceToken -> GetTagValue ( INTERFACE_SUPER ) );
        }
        else  if ( !pInterfaceToken -> IsSet ( INTERFACE_ABSTRACT ) &&
            !pInterfaceToken -> IsSet ( INTERFACE_GUID ) )
        {
            // Generate a forward declare
            CString szInterfaceName;
            
            szInterfaceName = pInterfaceToken -> GetTagValue ( INTERFACE_NAME );
            if ( szInterfaceName != "IDispatch" &&
                szInterfaceName != "IUnknown" )
            {
                fprintf ( fpIDLFile, "interface %s;\n",
                    pInterfaceToken -> GetTagValue ( NAME_TAG ) );
            }
        }
    }

    ThisFileList.Reset();
    while (pClassToken = ThisFileList.GetNext(TYPE_CLASS))
    {
        CTokenListWalker    ChildWalker(pClassToken);
        Token              *pChildToken;
        int                 cImplements = 0;

        // Find out how many implements are in the class.
        while (pChildToken = ChildWalker.GetNext())
        {
            if (pChildToken->GetType() == TYPE_IMPLEMENTS)
            {
                cImplements++;
            }
        }

        // Any class with more than one implements needs a mondodispid to be specified.
        if (pClassToken->IsSet(CLASS_GUID) && cImplements && !pClassToken->IsSet(CLASS_MONDOGUID))
        {
            char szErrorText [ MAX_LINE_LEN+1 ];

            sprintf(szErrorText,
                    "class: %s needs a mondoguid when implements are specified for a coclass.\n",
                    pClassToken->GetTagValue(CLASS_NAME));
            ReportError(szErrorText);
            return FALSE;
        }

        // Generate non-dual dispinterface?  This is determined by the mondoguid
        // keyword being used int the class.  If this guid is specified then
        // we'll generate the mondodisp interface is use it as the default
        // dispatch interface for the coclass.
        if (pClassToken->IsSet(CLASS_MONDOGUID))
        {
            LPSTR   pMondoGUID;
            CString szInterface;

            szInterface = pClassToken->GetTagValue(CLASS_INTERFACE);
            pInterfaceToken = FindInterface(szInterface);
            pMondoGUID = pClassToken->GetTagValue(CLASS_MONDOGUID);

            // If we have a GUID then the dispinterface GUID must be in the
            // range 0x3050f500 to 0x3050f5a0
            if (pMondoGUID[0] != '3' ||
                pMondoGUID[1] != '0' ||
                pMondoGUID[2] != '5' ||
                pMondoGUID[3] != '0' ||
                pMondoGUID[4] != 'f' ||
                pMondoGUID[5] != '5' ||
                !((pMondoGUID[6] >= '0' &&
                   pMondoGUID[6] <= '9') ||
                   pMondoGUID[6] == 'a') ||
                !((pMondoGUID[7] >= '0' &&
                   pMondoGUID[7] <= '9') ||
                   (pMondoGUID[7] >= 'a' &&
                    pMondoGUID[7] <= 'f')))
            {
                char szErrorText [ MAX_LINE_LEN+1 ];

                sprintf(szErrorText,
                        "The mondoguid must be in the range 0x3050f500 to 0x3050f5a0 for class: %s\n",
                        pClassToken->GetTagValue(CLASS_NAME));
                ReportError(szErrorText);
                return FALSE;
            }

            // Generate the default dispinterface
            GenerateIDLInterfaceDecl(pInterfaceToken,
                                     pMondoGUID,
                                     pInterfaceToken->GetTagValue(INTERFACE_SUPER),
                                     TRUE,
                                     pClassToken);
        }

        if ( pClassToken-> IsSet(CLASS_GUID) &&
            pClassToken->IsSet(CLASS_INTERFACE))
        {
            GenerateCoClassDecl(pClassToken);
        }

    }

    return TRUE;
}


void CPDLParser::GenerateIDLInterfaceDecl (Token   *pInterfaceToken,
                                           char    *pszGUID,
                                           char    *pszSuper,
                                           BOOL     fDispInterface/*= FALSE*/,
                                           Token   *pClassToken/*= NULL*/)
{
    BOOL fImplements = FALSE;

    if ( pInterfaceToken -> GetType() == TYPE_EVENT )
    {
        fprintf ( fpIDLFile, "[\n    hidden,\n" );
        fprintf ( fpIDLFile, "    uuid(%s)\n]\ndispinterface %s\n{",
            pszGUID, pInterfaceToken -> GetTagValue ( NAME_TAG ) );
        fprintf ( fpIDLFile, "\nproperties:\nmethods:\n" );
    }
    else
    {
        if (fDispInterface)
        {
            fprintf ( fpIDLFile, "[\n    hidden,\n" );
            fprintf ( fpIDLFile, "    uuid(%s)\n]\ndispinterface Disp%s\n{\nproperties:\nmethods:\n",
                pszGUID,
                pClassToken->IsSet(CLASS_COCLASSNAME) ?
                        pClassToken->GetTagValue(CLASS_COCLASSNAME) :
                        pClassToken->GetTagValue(CLASS_NAME));
        }
        else
        {
            if (!PrimaryTearoff(pInterfaceToken) && (!pszSuper || !*pszSuper))
                ReportError ( "Interfaces w/o tearoff need super:IDispatch\n" );

            if (pInterfaceToken->IsSet(INTERFACE_CUSTOM) && 
                pszSuper && 
                *pszSuper)
            {
                fprintf(fpIDLFile, "[\n    object,\n    pointer_default(unique),\n" );
                fprintf ( fpIDLFile, "    uuid(%s)\n]\ninterface %s : %s\n{\n",
                    pszGUID,
                    pInterfaceToken -> GetTagValue ( NAME_TAG ),
                    pszSuper);
            }
            else
            {
                fprintf ( fpIDLFile, "[\n    odl,\n    oleautomation,\n    dual,\n" );
                fprintf ( fpIDLFile, "    uuid(%s)\n]\ninterface %s : %s\n{\n",
                    pszGUID,
                    pInterfaceToken -> GetTagValue ( NAME_TAG ),
                    (PrimaryTearoff(pInterfaceToken) && _stricmp(pszSuper, "IHTMLDocument")) ? "IDispatch" : pszSuper);
            }
        }
    }

    // Any implements in the class if so then we want the order of the mongo dispinterface to be decided
    // by the order of the implements and not the super chain.
    if (fDispInterface)
    {
        CTokenListWalker    ChildWalker(pClassToken);
        Token              *pChildToken;

        while (pChildToken = ChildWalker.GetNext())
        {
            fImplements = pChildToken->GetType() == TYPE_IMPLEMENTS;
            if (fImplements)
                break;
        }
    }

    // Use the super chain for mongo dispinterface?
    if (!fImplements)
        // Yes.
        GenerateMkTypelibDecl(pInterfaceToken, fDispInterface, pClassToken);

    // Any other interfaces exposed in the coclass which are not part of the
    // primary interface chain?  Look for implements keyword.
    if (fDispInterface)
    {
        CTokenListWalker    ChildWalker(pClassToken);
        Token              *pChildToken;
        CString             szInterface;
        Token              *pInterfToken;

        while (pChildToken = ChildWalker.GetNext())
        {
            if (pChildToken->GetType() == TYPE_IMPLEMENTS)
            {
                szInterface = pChildToken->GetTagValue(IMPLEMENTS_NAME);
                pInterfToken = FindInterface(szInterface);
                if (pInterfToken)
                {
                    GenerateMkTypelibDecl(pInterfToken, fDispInterface, pClassToken);
                }
            }
        }
    }

    fprintf(fpIDLFile, "};\n");
}


void CPDLParser::ComputePropType ( Token *pPropertyToken,
                                   CString &szProp, BOOL fComment )
{
    char szText [ MAX_LINE_LEN+1 ];

    szProp = "";

    // Through the index/indextype & index1/indextype1 pdl tags
    // you can provide up to two additional args for the property definition
    sprintf ( szText, fComment ? "/* [in] */ %s %s" : "[in] %s %s",
        pPropertyToken -> GetTagValue ( PROPERTY_INDEXTYPE ),
        pPropertyToken -> GetTagValue ( PROPERTY_INDEX ) );
    pPropertyToken -> AddParam ( szProp, PROPERTY_INDEX, szText );

    sprintf ( szText, fComment ? "/* [in] */ %s %s" : "[in] %s %s",
        pPropertyToken -> GetTagValue ( PROPERTY_INDEXTYPE1 ),
        pPropertyToken -> GetTagValue ( PROPERTY_INDEX1 ));
    pPropertyToken -> AddParam ( szProp, PROPERTY_INDEX1, szText );

    if ( szProp [ 0 ] != '\0' )
        szProp += ",";
}


void CPDLParser::GenerateMkTypelibDecl ( Token *pInterfaceToken, BOOL fDispInterface/* = FALSE*/, Token *pClass /* =NULL */)
{
    Token *pChildToken;
    Token *pArgToken;
    CString szArg;
    CString szProp;
    CString szAutomationType;
    BOOL fFirst;
    CString szInterfaceName,szMethodName,szPropertyName;

    CTokenListWalker ChildWalker ( pInterfaceToken );

    if ( pInterfaceToken -> GetType() == TYPE_EVENT &&
        pInterfaceToken -> IsSet ( EVENT_SUPER ) )
    {
        CTokenListWalker WholeList(pRuntimeList);

        Token *pSuperEvent = WholeList.GetNext ( TYPE_EVENT,
            pInterfaceToken -> GetTagValue ( EVENT_SUPER ) );
        if ( pSuperEvent )
            GenerateMkTypelibDecl ( pSuperEvent );
    }

    // Special non-dual dispinterface for the default when the primary interface
    // is a tearoff.
    if (fDispInterface)
    {
        Token  *pSuperIntf;
        CString szInterface;

        szInterface = pInterfaceToken->GetTagValue(INTERFACE_SUPER);
        pSuperIntf = FindInterface(szInterface);
        if (pSuperIntf)
            GenerateMkTypelibDecl(pSuperIntf, fDispInterface, pClass);
    }

    szInterfaceName = pInterfaceToken->GetTagValue ( INTERFACE_NAME );
    szInterfaceName.ToUpper();


    while ( pChildToken = ChildWalker.GetNext() )
    {
        if ( pChildToken -> GetType() == TYPE_METHOD )
        {
            // if nopropdesc is set, then this method doesn't
            // participate in the typelib/mondo interface. this happens
            // when the method exists in a base class/interface as well.
            if ( pChildToken->IsSet(METHOD_NOPROPDESC) && fDispInterface)
                continue;

            // Does the property name exist in another interface then the primary
            // interface had better have the override.  Otherwise, it's an error
            // MIDL will not allow overloading names.
            if (fDispInterface && pClass)
            {
                CString szPrimaryInterface;
                Token   *pPriInterf;
                Token   *pExclusiveMember;

                szPrimaryInterface = pClass->GetTagValue(CLASS_INTERFACE);
                pPriInterf = FindInterface(szPrimaryInterface);

                // If working on non-primary interface make sure the method isn't overloaded on
                // the primary, if so it better be marked exclusive.
                if (_strcmpi(szInterfaceName, szPrimaryInterface))
                {
                    pExclusiveMember = FindMethodInInterfaceWOPropDesc(pPriInterf, pChildToken, TRUE);
                    if (pExclusiveMember)
                    {
                        char szErrorText [ MAX_LINE_LEN+1 ];

                        if (pExclusiveMember->IsSet(METHOD_EXCLUSIVETOSCRIPT))
                            continue;

                        // Overloaded method -- illegal.
                        sprintf(szErrorText, "method %s:%s is overloaded - illegal.\n",
                                (LPCSTR)pClass->GetTagValue(CLASS_NAME),
                                (LPCSTR)pExclusiveMember->GetTagValue(METHOD_NAME));
                        ReportError(szErrorText);
                        return;
                    }
                }
            }

            if ( pChildToken -> IsSet ( METHOD_VARARG) )
            {
                fprintf ( fpIDLFile, "    [vararg");
            }
            else
            {
                fprintf ( fpIDLFile, "    [");
            }

            szMethodName = pChildToken -> GetTagValue ( METHOD_NAME );
            if (pChildToken->IsSet(METHOD_NOPROPDESC))
            {
                if (pChildToken->IsSet(METHOD_SZINTERFACEEXPOSE))
                    szMethodName = pChildToken->GetTagValue(METHOD_SZINTERFACEEXPOSE);
            }
            szMethodName.ToUpper();

            if ( pChildToken -> IsSet ( METHOD_DISPID ) )
            {
                fprintf ( fpIDLFile, "%sid(DISPID_%s_%s)",
                    pChildToken -> IsSet ( METHOD_VARARG ) ? "," : "",
                    (LPCSTR)szInterfaceName, (LPCSTR)szMethodName );
            }

            CTokenListWalker ArgListWalker ( pChildToken );

            if (pChildToken->IsSet(METHOD_NOPROPDESC) &&
                pChildToken->IsSet(METHOD_SZINTERFACEEXPOSE))
            {
                szMethodName = pChildToken->GetTagValue(METHOD_SZINTERFACEEXPOSE);
            }
            else
            {
                szMethodName = pChildToken->GetTagValue(METHOD_NAME);
            }

            if (fDispInterface)
            {
                szAutomationType = "void";
                while ( pArgToken = ArgListWalker.GetNext() )
                {
                    if (pArgToken->IsSet(METHODARG_RETURNVALUE))
                    {
                        szAutomationType = pArgToken->IsSet(METHODARG_ATYPE ) ?
                            pArgToken->GetTagValue(METHODARG_ATYPE) :
                            pArgToken->GetTagValue(METHODARG_TYPE);
                    }

                    // If the last character is a pointer then the pointer
                    // should be removed because that is for dual C++ style
                    // interface.  DispInterface doesn't need the retval
                    // specified as a parameter hence the need for
                    // HRESULT funcName(BOOL*) instead of BOOL funcName ().
                    int iSzLength = szAutomationType.Length();
                    if (iSzLength && szAutomationType[iSzLength - 1] == '*')
                    {
                        char    szTypeNoPtr[MAX_LINE_LEN+1];

                        strncpy(szTypeNoPtr, szAutomationType, iSzLength - 1);
                        szTypeNoPtr[iSzLength - 1] = '\0';
                        szAutomationType = szTypeNoPtr;
                    }
                }

                fprintf ( fpIDLFile, "] %s %s(",
                    (LPCSTR)szAutomationType,
                    (LPCSTR)szMethodName );

                ArgListWalker.Reset();
            }
            else
            {
                fprintf ( fpIDLFile, "] %s %s(",
                    pChildToken -> GetTagValue ( METHOD_RETURNTYPE ),
                    (LPCSTR)szMethodName );
            }

            fFirst = TRUE;
            while ( pArgToken = ArgListWalker.GetNext() )
            {
                if (!(fDispInterface && pArgToken->IsSet(METHODARG_RETURNVALUE)))
                {
                    szArg = "";
                    if ( !fFirst )
                        fprintf ( fpIDLFile, "," );

#ifndef WIN16_PARSER
                    pArgToken -> AddParamStr ( szArg, METHODARG_DEFAULTVALUE, "defaultvalue(%s)" );
#endif              
                    pArgToken -> AddParam ( szArg, METHODARG_OPTIONAL, "optional" );
                    pArgToken -> AddParam ( szArg, METHODARG_RETURNVALUE, "retval" );
                    pArgToken -> AddParam ( szArg, METHODARG_IN, "in" );
                    pArgToken -> AddParam ( szArg, METHODARG_OUT, "out" );
                    fprintf ( fpIDLFile, "[%s] %s %s",
                        (LPCSTR)szArg,
                        // Fixing a bug in the old code
                        // Should really get the atype - allow the type if atype not set
                        pArgToken -> IsSet ( METHODARG_ATYPE ) ?
                            pArgToken -> GetTagValue ( METHODARG_ATYPE ) :
                            pArgToken -> GetTagValue ( METHODARG_TYPE ),
                        pArgToken -> GetTagValue ( METHODARG_ARGNAME ) );
                    fFirst = FALSE;
                }
            }
            fprintf ( fpIDLFile, ");\n" );
        }
        else // Property
        {
            ComputePropType ( pChildToken, szProp, FALSE );
            szAutomationType = pChildToken -> GetTagValue ( PROPERTY_ATYPE );

            // if nopropdesc is set, then this property doesn't
            // participate in the typelib/mondo interface. this happens
            // when the property exists in a base class/interface as well.
            if (pChildToken->IsSet(PROPERTY_NOPROPDESC) && fDispInterface)
                continue;

            // Does the property name exist in another interface then the primary
            // interface had better have the override.  Otherwise, it's an error
            // MIDL will not allow overloading names.
            if (fDispInterface && pClass)
            {
                CString szPrimaryInterface;
                Token   *pPriInterf;
                Token   *pExclusiveMember;

                szPrimaryInterface = pClass->GetTagValue(CLASS_INTERFACE);
                pPriInterf = FindInterface(szPrimaryInterface);

                // If working on non-primary interface make sure the property isn't overloaded on
                // the primary, if so it better be marked exclusive.
                if (_strcmpi(szInterfaceName, szPrimaryInterface))
                {
                    pExclusiveMember = FindMethodInInterfaceWOPropDesc(pPriInterf, pChildToken, TRUE);
                    if (pExclusiveMember)
                    {
                        char szErrorText [ MAX_LINE_LEN+1 ];

                        if (pExclusiveMember->IsSet(PROPERTY_EXCLUSIVETOSCRIPT))
                            continue;

                        // Overloaded method -- illegal.
                        sprintf(szErrorText, "property %s:%s is overloaded - illegal.\n",
                                (LPCSTR)pClass->GetTagValue(CLASS_NAME),
                                (LPCSTR)pExclusiveMember->GetTagValue(PROPERTY_NAME));
                        ReportError(szErrorText);
                        return;
                    }
                }
            }

            if ( pChildToken -> IsSet ( PROPERTY_SET ) )
            {
#if COLLECT_STATISTICS==1
    // Collect statistics on total number of property sets.
    CollectStatistic(NUM_SETPROPERTY, GetStatistic(NUM_SETPROPERTY) + 1);
    if (FindEnum ( pChildToken ))
        CollectStatistic(NUM_SETENUMS, GetStatistic(NUM_SETENUMS) + 1);
#endif
                // If it's an object valued property, generate a propputref,
                // otherwise generate a propput
                //
                if ( pChildToken -> IsSet ( PROPERTY_OBJECT ) )
                {
                    szArg = "    [propputref";
                }
                else
                {
                    szArg = "    [propput";
                }
                if ( pChildToken -> IsSet ( PROPERTY_DISPID ) )
                {
                    szArg += ", id(DISPID_";

                    szPropertyName = pChildToken->GetTagValue(PROPERTY_NAME);
                    if (pChildToken->IsSet(PROPERTY_NOPROPDESC))
                    {
                        if (pChildToken->IsSet(PROPERTY_SZINTERFACEEXPOSE))
                            szPropertyName = pChildToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE);
                    }
                    szPropertyName.ToUpper();

                    szArg += (LPCSTR)szInterfaceName;
                    szArg += "_";
                    szArg += (LPCSTR)szPropertyName;
                    szArg += ")";
                }

                pChildToken -> AddParam ( szArg, PROPERTY_DISPLAYBIND, "displaybind" );
                pChildToken -> AddParam ( szArg, PROPERTY_BINDABLE, "bindable" );
                pChildToken -> AddParam ( szArg, PROPERTY_HIDDEN, "hidden" );
                pChildToken -> AddParam ( szArg, PROPERTY_RESTRICTED, "restricted" );
#ifndef WIN16_PARSER
                pChildToken -> AddParam ( szArg, PROPERTY_NONBROWSABLE, "nonbrowsable" );
#endif                
                pChildToken -> AddParam ( szArg, PROPERTY_SOURCE, "source" );

                if (pChildToken->IsSet(PROPERTY_NOPROPDESC) &&
                    pChildToken->IsSet(PROPERTY_SZINTERFACEEXPOSE))
                {
                    szPropertyName = pChildToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE);
                }
                else
                {
                    szPropertyName = pChildToken->GetTagValue(PROPERTY_NAME);
                }

                if (fDispInterface)
                {
                    fprintf ( fpIDLFile, "%s] void %s(%s%s v);\n",
                        (LPCSTR)szArg, (LPCSTR)szPropertyName,
                        (LPCSTR)szProp, (LPCSTR)szAutomationType );
                }
                else
                {
                    fprintf ( fpIDLFile, "%s] HRESULT %s(%s[in] %s v);\n",
                        (LPCSTR)szArg, (LPCSTR)szPropertyName,
                        (LPCSTR)szProp, (LPCSTR)szAutomationType );
                }
            }

            if ( pChildToken -> IsSet ( PROPERTY_GET ) )
            {
#if COLLECT_STATISTICS==1
    // Collect statistics on total number of property sets.
    CollectStatistic(NUM_GETPROPERTY, GetStatistic(NUM_GETPROPERTY) + 1);
    if (FindEnum ( pChildToken ))
        CollectStatistic(NUM_GETENUMS, GetStatistic(NUM_GETENUMS) + 1);
#endif
                szArg = "    [propget";
                    szArg += ", id(DISPID_";

                    szPropertyName = pChildToken->GetTagValue(PROPERTY_NAME);
                    if (pChildToken->IsSet(PROPERTY_NOPROPDESC))
                    {
                        if (pChildToken->IsSet(PROPERTY_SZINTERFACEEXPOSE))
                            szPropertyName = pChildToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE);
                    }
                    szPropertyName.ToUpper();

                    szArg += (LPCSTR)szInterfaceName;
                    szArg += "_";
                    szArg += (LPCSTR)szPropertyName;
                    szArg += ")";
                pChildToken -> AddParam ( szArg, PROPERTY_DISPLAYBIND, "displaybind" );
                pChildToken -> AddParam ( szArg, PROPERTY_BINDABLE, "bindable" );
                pChildToken -> AddParam ( szArg, PROPERTY_HIDDEN, "hidden" );
                pChildToken -> AddParam ( szArg, PROPERTY_RESTRICTED, "restricted" );
#ifndef WIN16_PARSER
                pChildToken -> AddParam ( szArg, PROPERTY_NONBROWSABLE, "nonbrowsable" );
#endif                
                pChildToken -> AddParam ( szArg, PROPERTY_SOURCE, "source" );

                if (pChildToken->IsSet(PROPERTY_NOPROPDESC) &&
                    pChildToken->IsSet(PROPERTY_SZINTERFACEEXPOSE))
                {
                    szPropertyName = pChildToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE);
                }
                else
                {
                    szPropertyName = pChildToken->GetTagValue(PROPERTY_NAME);
                }

                if (fDispInterface)
                {
                    fprintf ( fpIDLFile, "%s] %s %s();\n",
                        (LPCSTR)szArg,
                        (LPCSTR)szAutomationType,
                        (LPCSTR)szPropertyName);
                }
                else
                {
                    fprintf ( fpIDLFile, "%s] HRESULT %s(%s[retval, out] %s * p);\n",
                        (LPCSTR)szArg, (LPCSTR)szPropertyName,
                        (LPCSTR)szProp, (LPCSTR)szAutomationType );
                }
            }

        }
    }
}


void CPDLParser::GenerateMidlInterfaceDecl ( Token *pInterfaceToken, char *pszGUID,
    char *pszSuper )
{
    Token *pChildToken;
    Token *pArgToken;
    CString szArg;
    CString szProp;
    BOOL fFirst;

    if ( pInterfaceToken -> GetType() == TYPE_EVENT )
        return;

    fprintf ( fpIDLFile,  "[\n    local,\n    object,\n    pointer_default(unique),\n"  );
    fprintf ( fpIDLFile,  "    uuid(%s)\n]\ninterface %s : %s\n{\n",
        pInterfaceToken -> GetTagValue ( INTERFACE_GUID ),
        pInterfaceToken -> GetTagValue ( INTERFACE_NAME ),
        pInterfaceToken -> GetTagValue ( INTERFACE_SUPER ) );

    CTokenListWalker ChildWalker ( pInterfaceToken );

    while ( pChildToken = ChildWalker.GetNext() )
    {
        if ( pChildToken -> GetType() == TYPE_METHOD )
        {
            fprintf ( fpIDLFile, "    %s %s(",
                pChildToken -> GetTagValue ( METHOD_RETURNTYPE ),
                pChildToken -> GetTagValue ( METHOD_NAME ) );

            fFirst = TRUE;

            CTokenListWalker ArgListWalker ( pChildToken );
            while ( pArgToken = ArgListWalker.GetNext() )
            {
                szArg = "";
                if ( !fFirst )
                    fprintf ( fpIDLFile, "," );
                pArgToken -> AddParam ( szArg, METHODARG_IN, "in" );
                pArgToken -> AddParam ( szArg, METHODARG_OUT, "out" );
                fprintf ( fpIDLFile, "[%s] %s %s", (LPCSTR)szArg,
                    // Fixing a bug in the old code
                    // Should realy get the atype - allow the type if atype not set
                    pArgToken -> IsSet ( METHODARG_ATYPE ) ?
                        pArgToken -> GetTagValue ( METHODARG_ATYPE ) :
                        pArgToken -> GetTagValue ( METHODARG_TYPE ),
                    pArgToken -> GetTagValue ( METHODARG_ARGNAME ) );
                fFirst = FALSE;
            }
            fprintf ( fpIDLFile, ");\n" );
        }
        else
        {
            // Property
            ComputePropType ( pChildToken, szProp, FALSE );

            if ( pChildToken -> IsSet ( PROPERTY_SET ))
            {
                fprintf ( fpIDLFile, "    HRESULT put_%s(%s [in] %s v);\n",
                    (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_NAME ),
                    (LPCSTR)szProp,
                    pChildToken -> GetTagValue ( PROPERTY_ATYPE) );
            }

            if ( pChildToken -> IsSet ( PROPERTY_GET ))
            {
                fprintf ( fpIDLFile,
                    "    HRESULT get_%s(%s[out] %s * p);\n",
                        pChildToken -> GetTagValue ( PROPERTY_NAME ),
                        (LPCSTR)szProp,
                        pChildToken -> GetTagValue ( PROPERTY_ATYPE));
            }
        }
    }
    fprintf ( fpIDLFile, "}\n" );
}

BOOL CPDLParser::HasMondoDispInterface ( Token *pClassToken )
{
    CTokenListWalker    ChildWalker(pClassToken);
    Token              *pChildToken;
    int                 cImplements = 0;

    // Find out how many implements are in the class.
    while (pChildToken = ChildWalker.GetNext())
    {
        if (pChildToken->GetType() == TYPE_IMPLEMENTS)
        {
            cImplements++;
        }
    }

    // Any class with more than one implements a guid and a mondoguid will have
    // a mondo dispinterface.
    return (pClassToken->IsSet(CLASS_GUID) && cImplements && pClassToken->IsSet(CLASS_MONDOGUID));
}


void CPDLParser::GenerateCoClassDecl ( Token *pClassToken )
{
    CString     szName;
    CString     szDispName;
    CString     szInterfSuper;
    BOOL        fHasMondoDispInterface;
    BOOL        fElement = FALSE;

    if (pClassToken->IsSet(CLASS_COCLASSNAME))
        szName = pClassToken->GetTagValue(CLASS_COCLASSNAME);
    else
        szName = pClassToken->GetTagValue(CLASS_NAME);

    fprintf(fpIDLFile, "[\n    %suuid(%s)\n]\n",
            pClassToken->IsSet(CLASS_CONTROL) ? "control,\n    " : "",
            pClassToken->GetTagValue(CLASS_GUID));
    fprintf(fpIDLFile, "coclass %s\n{\n", (LPCSTR)szName );

    fHasMondoDispInterface = HasMondoDispInterface(pClassToken);

    if (fHasMondoDispInterface)
    {
        // Map to mondo dispinterface as default dispatch interface.
        szDispName = (pClassToken->IsSet(CLASS_COCLASSNAME)) ?
                        pClassToken->GetTagValue (CLASS_COCLASSNAME) :
                        pClassToken->GetTagValue(CLASS_NAME);
    }
    else
    {
        // Map to the primary interface as default dispatch interface.
        szDispName = pClassToken->GetTagValue(CLASS_INTERFACE);
    }

    fprintf(fpIDLFile, "    [default]           %sinterface %s%s;\n",
            fHasMondoDispInterface ? "disp" : "",
            fHasMondoDispInterface ? "Disp" : "",
            (LPCSTR)szDispName);

    if (pClassToken->IsSet(CLASS_EVENTS))
    {
        fprintf(fpIDLFile, "    [source, default]   dispinterface %s;\n",
                pClassToken->GetTagValue(CLASS_EVENTS));
    }

    if (pClassToken->IsSet(CLASS_NONPRIMARYEVENTS1))
    {
        fprintf(fpIDLFile, "    [source]            dispinterface %s;\n",
                pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS1));
    }
    if (pClassToken->IsSet(CLASS_NONPRIMARYEVENTS2))
    {
        fprintf(fpIDLFile, "    [source]            dispinterface %s;\n",
                pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS2));
    }
    if (pClassToken->IsSet(CLASS_NONPRIMARYEVENTS3))
    {
        fprintf(fpIDLFile, "    [source]            dispinterface %s;\n",
                pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS3));
    }
    if (pClassToken->IsSet(CLASS_NONPRIMARYEVENTS4))
    {
        fprintf(fpIDLFile, "    [source]            dispinterface %s;\n",
                pClassToken->GetTagValue(CLASS_NONPRIMARYEVENTS4));
    }

    // Any other interface to expose in the coclass which is part of the primary
    // interface?
    CTokenListWalker    ChildWalker(pClassToken);
    Token              *pChildToken;

    while (pChildToken = ChildWalker.GetNext())
    {
        if (pChildToken->GetType() == TYPE_IMPLEMENTS)
        {
            Token      *pInterf;
            CString     szInterface;

            if (!fElement)
                fElement = !_stricmp((LPSTR)pChildToken->GetTagValue(IMPLEMENTS_NAME), "IHTMLElement");

            szInterface = pChildToken->GetTagValue(IMPLEMENTS_NAME);
            pInterf = FindInterface(szInterface);
            if (pInterf)
            {
                // Is the interface a local one if not then don't check, we
                // only need to check where interfaces are actually used.
                if (FindInterfaceLocally(szInterface))
                {
                    // If the super isn't specified and it's not a primary interface
                    // then error the super is required for non-primary interfaces.
                    if (_stricmp((LPSTR)pClassToken->GetTagValue(CLASS_INTERFACE),
                                 (LPSTR)pInterf->GetTagValue(INTERFACE_NAME)) &&
                        !pInterf->IsSet(INTERFACE_SUPER) &&
                        !IsPrimaryInterface(szInterface))
                    {
                        char szErrorText [ MAX_LINE_LEN+1 ];

                        sprintf(szErrorText, "Interface %s missing super key.\n",
                                (LPSTR)pInterf->GetTagValue(INTERFACE_NAME));
                        ReportError(szErrorText);

                        return;
                    }
                }

                fprintf(fpIDLFile, "                        interface %s;\n",
                        (LPCSTR)pInterf->GetTagValue(INTERFACE_NAME));
            }
        }
    }

    fprintf(fpIDLFile, "};\n");

    fprintf(fpIDLFile, "cpp_quote(\"EXTERN_C const GUID CLSID_%s;\")\n",
            pClassToken->GetTagValue(CLASS_NAME));

    if (!pClassToken->IsSet(CLASS_EVENTS) && fElement)
    {
        char szErrorText [ MAX_LINE_LEN+1 ];
        sprintf(szErrorText, "Class %s missing events key.\n", pClassToken->GetTagValue(CLASS_NAME));
        ReportError(szErrorText);
        return;
    }
}



void CPDLParser::GenerateEnumDescIDL ( Token *pEnumToken )
{
    Token *pEvalToken;
    CString szName;

    fprintf ( fpIDLFile, "\ntypedef [uuid(%s)] enum _%s {\n" ,
        pEnumToken -> GetTagValue ( ENUM_GUID ),
        pEnumToken -> GetTagValue ( ENUM_NAME ) );

    CTokenListWalker EvalChildList ( pEnumToken );

    while ( pEvalToken = EvalChildList.GetNext() )
    {
        if ( pEvalToken -> IsSet ( EVAL_ODLNAME ) )
        {
            szName = pEvalToken -> GetTagValue ( EVAL_ODLNAME );
        }
        else
        {
            szName = pEnumToken -> GetTagValue ( ENUM_NAME );
            szName += pEvalToken -> GetTagValue ( EVAL_NAME );
        }
        fprintf ( fpIDLFile, "    [helpstring(\"%s\")] %s = %s,\n",
            pEvalToken -> IsSet ( EVAL_STRING ) ?
                pEvalToken -> GetTagValue ( EVAL_STRING ) :
                pEvalToken -> GetTagValue ( EVAL_NAME ),
            (LPCSTR)szName,
            pEvalToken -> GetTagValue ( EVAL_VALUE ) );
    }
    fprintf ( fpIDLFile, "}%s;\n",
        pEnumToken -> GetTagValue ( ENUM_NAME ) );

}


void CPDLParser::ReportError ( LPCSTR szErrorString )
{
    printf ( "%s(0) : error PDL0000: %s", _pszPDLFileName, szErrorString);
    fprintf ( fpLOGFile, "%s(0) : error PDL0000: %s", _pszPDLFileName, szErrorString );
}

void CPDLParser::GenerateHeaderFile ( void )
{
    CTokenListWalker ThisFileList ( pRuntimeList, _pszPDLFileName );
    Token *pImportToken;
    Token *pInterfaceToken;
    Token *pClassToken;
    Token *pEnumToken;
    Token *pStructToken;
    char *pStr;
    CString szCoClassName;
    char szName [ MAX_LINE_LEN+1 ];
    CString szInterfaceName;

    strcpy ( szName, _pszPDLFileName );
    pStr = strstr ( szName, "." );
    if ( pStr )
        *pStr = '\0';
    _strlwr ( szName );


    fprintf ( fpHeaderFile, "#ifndef __%s_h__\n", szName );
    fprintf ( fpHeaderFile, "#define __%s_h__\n\n", szName );

    fprintf ( fpHeaderFile, "/* Forward Declarations */\n" );

    fprintf ( fpHeaderFile, "\nstruct ENUMDESC;\n" );
    // For each import, generate a .h include
    while ( pImportToken = ThisFileList.GetNext ( TYPE_IMPORT ) )
    {
        fprintf ( fpHeaderFile, "\n/* header files for imported files */\n" );
        GenerateIncludeStatement ( pImportToken );
    }

    ThisFileList.Reset();

    // Forward define all the interfaces so we can have defined them in any order
    while ( pInterfaceToken = ThisFileList.GetNext ( TYPE_INTERFACE ) )
    {
        szInterfaceName = pInterfaceToken -> GetTagValue ( INTERFACE_NAME );
        if ( szInterfaceName != "IDispatch" &&
            szInterfaceName != "IUnknown" )
        {
            fprintf ( fpHeaderFile, "\n#ifndef __%s_FWD_DEFINED__\n",
                pInterfaceToken -> GetTagValue ( INTERFACE_NAME ) );
            fprintf ( fpHeaderFile, "#define __%s_FWD_DEFINED__\n",
                pInterfaceToken -> GetTagValue ( INTERFACE_NAME ) );
            fprintf ( fpHeaderFile, "typedef interface %s %s;\n",
                pInterfaceToken -> GetTagValue ( INTERFACE_NAME ),
                pInterfaceToken -> GetTagValue ( INTERFACE_NAME ) ) ;
            fprintf ( fpHeaderFile, "#endif     /* __%s_FWD_DEFINED__ */\n",
                pInterfaceToken -> GetTagValue ( INTERFACE_NAME ) );
        }
    }   

    //
    // Generate all the enums
    //
    
    ThisFileList.Reset();
    while ( pEnumToken = ThisFileList.GetNext ( TYPE_ENUM ) )
    {
        GenerateIncludeEnum(pEnumToken, TRUE);
    }

    //
    // Generate all the structs
    //

    ThisFileList.Reset();
    while (pStructToken = ThisFileList.GetNext(TYPE_STRUCT))
    {
        GenerateStruct(pStructToken, fpHeaderFile);
    }


    ThisFileList.Reset();

    // For each interface generate an extern for the GUID &
    // an interface decl
    while ( pInterfaceToken = ThisFileList.GetNext ( TYPE_INTERFACE ) )
    {
        szInterfaceName = pInterfaceToken -> GetTagValue ( INTERFACE_NAME );
        if ( szInterfaceName != "IDispatch" &&
            szInterfaceName != "IUnknown" &&
            !pInterfaceToken -> IsSet ( INTERFACE_ABSTRACT ) && 
            pInterfaceToken -> IsSet ( INTERFACE_GUID ) )
        {
            GenerateIncludeInterface ( pInterfaceToken );
        }
    }

    ThisFileList.Reset();

    // For each class with a GUID, generate a GUID ref
    while ( pClassToken = ThisFileList.GetNext ( TYPE_CLASS ) )
    {
        if ( pClassToken -> IsSet ( CLASS_GUID ) &&
            !pClassToken -> IsSet ( CLASS_ABSTRACT ) )
        {
            pClassToken -> GetTagValueOrDefault ( szCoClassName,
                CLASS_COCLASSNAME, pClassToken -> GetTagValue ( CLASS_NAME ) );
            fprintf ( fpHeaderFile, "\n\nEXTERN_C const GUID GUID_%s;\n\n",
                pClassToken -> GetTagValue ( CLASS_COCLASSNAME ) );

            if ( HasMondoDispInterface ( pClassToken ) )
            {
                CString szDispName;

                // Map to mondo dispinterface as default dispatch interface.
                szDispName = (pClassToken->IsSet(CLASS_COCLASSNAME)) ?
                                pClassToken->GetTagValue (CLASS_COCLASSNAME) :
                                pClassToken->GetTagValue(CLASS_NAME);
                fprintf(fpHeaderFile, "\n\nEXTERN_C const GUID DIID_Disp%s;\n\n",
                        (LPCSTR)szDispName);
            }
        }
        // Also generate extern definitions for all propdescs in this file
        GeneratePropdescExtern ( pClassToken, FALSE /* Don't recurse */ );

    }



    fprintf ( fpHeaderFile, "\n\n#endif /*__%s_h__*/\n\n", szName );

}

void  CPDLParser::GenerateIncludeStatement ( Token *pImportToken )
{
    char szText [ MAX_LINE_LEN+1 ];
    char *pStr;

    strcpy ( szText, pImportToken -> GetTagValue ( IMPORT_NAME ) );

    if ( pStr = strstr ( szText, "." ) )
    {
        strcpy ( pStr, ".h" );
    }
    else
    {
        strcat ( szText, ".h" );
    }
    fprintf ( fpHeaderFile, "#include \"%s\"\n", szText );
}

void  CPDLParser::GenerateIncludeInterface ( Token *pInterfaceToken )
{
    // Only generate the C++ Form
    Token *pChildToken;
    Token *pArgToken;
    CString szArg;
    CString szProp;
    BOOL fFirst;
    CString szSuper;
    
    if ( pInterfaceToken -> GetType() == TYPE_EVENT )
        return;


    fprintf ( fpHeaderFile, "\n#ifndef __%s_INTERFACE_DEFINED__\n",
        pInterfaceToken -> GetTagValue ( INTERFACE_NAME ) );
    fprintf ( fpHeaderFile, "\n#define __%s_INTERFACE_DEFINED__\n",
        pInterfaceToken -> GetTagValue ( INTERFACE_NAME ) );


    fprintf ( fpHeaderFile,  "\nEXTERN_C const IID IID_%s;\n\n",
        pInterfaceToken -> GetTagValue ( INTERFACE_NAME ) );

    if (pInterfaceToken->IsSet(INTERFACE_CUSTOM) ||
        !PrimaryTearoff(pInterfaceToken) ||
        !_stricmp((LPCSTR)pInterfaceToken->GetTagValue(INTERFACE_NAME), "IHTMLDocument2"))
    {
        szSuper = pInterfaceToken->GetTagValue(INTERFACE_SUPER);
    }
    
    fprintf(fpHeaderFile, "\nMIDL_INTERFACE(\"%s\")\n%s : public %s\n{\npublic:\n",
        pInterfaceToken->GetTagValue(INTERFACE_GUID),
        pInterfaceToken->GetTagValue(INTERFACE_NAME),
        ((LPCSTR)szSuper && *(LPCSTR)szSuper) ? (LPCSTR)szSuper : "IDispatch");

    CTokenListWalker ChildWalker ( pInterfaceToken );

    while ( pChildToken = ChildWalker.GetNext() )
    {
        if ( pChildToken -> GetType() == TYPE_METHOD )
        {
            fprintf ( fpHeaderFile, "    virtual %s STDMETHODCALLTYPE %s(\n            ",
                pChildToken -> GetTagValue ( METHOD_RETURNTYPE ),
                   pChildToken->IsSet(METHOD_SZINTERFACEEXPOSE) ?
                    pChildToken->GetTagValue(METHOD_SZINTERFACEEXPOSE) :
                    pChildToken->GetTagValue(METHOD_NAME));

            fFirst = TRUE;

            CTokenListWalker ArgListWalker ( pChildToken );
            while ( pArgToken = ArgListWalker.GetNext() )
            {
                if ( !fFirst )
                    fprintf ( fpHeaderFile, "," );
                szArg = "";
                pArgToken -> AddParam ( szArg, METHODARG_IN, "in" );
                pArgToken -> AddParam ( szArg, METHODARG_OUT, "out" );

                fprintf ( fpHeaderFile, "/* [%s] */ %s %s", (LPCSTR)szArg,
                    // Fixing a bug in the old code
                    // Should realy get the atype - allow the type if atype not set
                    ConvertType(pArgToken -> IsSet ( METHODARG_ATYPE ) ?
                        pArgToken -> GetTagValue ( METHODARG_ATYPE ) :
                        pArgToken -> GetTagValue ( METHODARG_TYPE )),
                    pArgToken -> GetTagValue ( METHODARG_ARGNAME ) );
                fFirst = FALSE;
            }
            fprintf ( fpHeaderFile, ") = 0;\n\n" );
        }
        else
        {
            // Property
            ComputePropType(pChildToken, szProp, TRUE);

            if ( pChildToken -> IsSet ( PROPERTY_SET ))
            {
                fprintf ( fpHeaderFile, "    virtual HRESULT STDMETHODCALLTYPE put_%s(\n        %s /* [in] */ %s v) = 0;\n\n",
                   	pChildToken->IsSet(PROPERTY_SZINTERFACEEXPOSE) ?
                            (LPSTR)pChildToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE) :
                            (LPSTR)pChildToken->GetTagValue(PROPERTY_NAME),
                    (LPCSTR)szProp,
                    pChildToken -> GetTagValue ( PROPERTY_ATYPE));

            }

            if ( pChildToken -> IsSet ( PROPERTY_GET ))
            {
                fprintf ( fpHeaderFile,
                    "    virtual HRESULT STDMETHODCALLTYPE get_%s(\n        %s /* [out] */ %s * p) = 0;\n\n",
                           pChildToken->IsSet(PROPERTY_SZINTERFACEEXPOSE) ?
                            (LPSTR)pChildToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE) :
                            (LPSTR)pChildToken->GetTagValue(PROPERTY_NAME),
                        (LPCSTR)szProp,
                        pChildToken -> GetTagValue ( PROPERTY_ATYPE) );
            }
        }
    }
    fprintf ( fpHeaderFile, "};\n\n" );
    fprintf ( fpHeaderFile, "#endif     /* __%s_INTERFACE_DEFINED__ */\n\n",
        pInterfaceToken -> GetTagValue ( INTERFACE_NAME ) );
}

void CPDLParser::GenerateIncludeEnum(
    Token *pEnumToken, BOOL fSpitExtern, FILE *pFile)
{
    Token *pEvalToken;

    if (!pFile)
    {
        pFile = fpHeaderFile;
    }
    
    fprintf(pFile, "typedef enum _%s\n{\n" ,
        pEnumToken -> GetTagValue ( ENUM_NAME ) );

    CTokenListWalker EvalChildList ( pEnumToken );

    while ( pEvalToken = EvalChildList.GetNext() )
    {
        fprintf(pFile, "    %s%s = %s,\n",
            pEnumToken -> GetTagValue(ENUM_PREFIX),
            pEvalToken -> GetTagValue(EVAL_NAME),
            pEvalToken -> GetTagValue(EVAL_VALUE));
    }
    //  Add an _Max for the MAC build - apparently the mac needs
    // this to indicate that it's an integer
    fprintf(pFile, "    %s_Max = 2147483647L\n",
        pEnumToken -> GetTagValue ( ENUM_NAME ) );
    fprintf(pFile, "} %s;\n\n",
        pEnumToken -> GetTagValue ( ENUM_NAME ) );

    if (fSpitExtern)
    {
        // Generate an EXTERN from the enum descriptor so other hdls only have to include
        // the .h file.
        fprintf(pFile, "\nEXTERN_C const ENUMDESC s_enumdesc%s;\n\n",
            pEnumToken->GetTagValue ( ENUM_NAME ) );
    }
}


void 
CPDLParser::GenerateStruct(Token *pStructToken, FILE *pFile)
{
    Token *pMemberToken;

    fprintf(pFile, "typedef struct _%s\n{\n" ,
        pStructToken->GetTagValue(STRUCT_NAME));

    CTokenListWalker ChildList(pStructToken);

    while (pMemberToken = ChildList.GetNext())
    {
        fprintf(pFile, "    %s %s;\n",
            pMemberToken->GetTagValue(STRUCTMEMBER_TYPE),
            pMemberToken->GetTagValue(STRUCTMEMBER_NAME));
    }
    fprintf(pFile, "} %s;\n\n",
        pStructToken->GetTagValue(STRUCT_NAME));
}


BOOL CPDLParser::AddType ( LPCSTR szTypeName, LPCSTR szHandler )
{
    Token *pTypeToken = pDynamicTypeList->AddNewToken ( (DESCRIPTOR_TYPE)TYPE_DATATYPE );
    if ( pTypeToken == NULL )
        return FALSE;
    if ( !pTypeToken->AddTag ( DATATYPE_NAME, szTypeName ) )
        return FALSE;
    return pTypeToken->AddTag ( DATATYPE_HANDLER, szHandler );
}

BOOL CPDLParser::AddEventType ( LPCSTR szTypeName, LPCSTR szVTSType )
{
    Token *pTypeToken = pDynamicEventTypeList->AddNewToken ( (DESCRIPTOR_TYPE)TYPE_DATATYPE );
    if ( pTypeToken == NULL )
        return FALSE;
    if ( !pTypeToken->AddTag ( DATATYPE_NAME, szTypeName ) )
        return FALSE;
    return pTypeToken->AddTag ( DATATYPE_HANDLER, szVTSType );
}


BOOL CPDLParser::LookupType ( LPCSTR szTypeName, CString &szIntoString,
    CString &szFnPrefix, StorageType *pStorageType /* = NULL */ )
{
    Token *pTypeToken;
    UINT uIndex;
    // Look in the static array first
    if ( ( uIndex = szIntoString.Lookup ( DataTypes, szTypeName ) ) != (UINT)-1 )
    {
        if ( pStorageType )
        {
            *pStorageType = DataTypes [ uIndex ].stStorageType;
            szFnPrefix = DataTypes [ uIndex ].szMethodFnPrefix;
        }
        return TRUE;
    }

    // Look finaly in the dynamic array
    CTokenListWalker TypeList ( pDynamicTypeList );
    if ( pTypeToken = TypeList.GetNext ( (DESCRIPTOR_TYPE)TYPE_DATATYPE, szTypeName ) )
    {
        szIntoString = pTypeToken->GetTagValue ( DATATYPE_HANDLER );
        if ( pStorageType )
        {
            // In the dynamic array are either enums iface ptrs or class ptrs
            // All can be stored in a DWORD, so ...
            *pStorageType = STORAGETYPE_NUMBER;
        }
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL CPDLParser::LookupEventType ( CString &szIntoString, LPCSTR szTypeName )
{
    Token *pTypeToken;
    // Look in the static array first
    if ( szIntoString.Lookup ( vt, szTypeName ) != (UINT)-1 )
    {
        return TRUE;
    }
    // Look finaly in the dynamic array
    CTokenListWalker TypeList ( pDynamicEventTypeList );
    if ( pTypeToken = TypeList.GetNext ( (DESCRIPTOR_TYPE)TYPE_DATATYPE, szTypeName ) )
    {
        szIntoString = pTypeToken->GetTagValue ( DATATYPE_HANDLER );
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

UINT uProps [] =
{
    PROPERTY_MEMBER,
    PROPERTY_ABSTRACT,
    PROPERTY_GETSETMETHODS,
    PROPERTY_CAA,
    PROPERTY_SUBOBJECT
};

// Legal combinations of properties
static struct
{
    UINT uID1;
    UINT uID2;
    UINT uID3;
    UINT uMask;
} PropertyCheck [] =
{
    { PROPERTY_MEMBER, (UINT)-1,(UINT)-1 },
    { PROPERTY_SUBOBJECT, (UINT)-1 ,(UINT)-1 },
    { PROPERTY_SUBOBJECT, PROPERTY_MEMBER,(UINT)-1 },
    { PROPERTY_GETSETMETHODS, (UINT)-1,(UINT)-1 },
    { PROPERTY_ABSTRACT,  (UINT)-1,(UINT)-1},
    { PROPERTY_CAA, (UINT)-1,(UINT)-1 },
    { PROPERTY_SUBOBJECT, PROPERTY_CAA,(UINT)-1 },
};


void CPDLParser::Init ( void )
{
    UINT i,j;
    for ( i = 0 ; i < ARRAY_SIZE ( PropertyCheck ) ; i++ )
    {
        PropertyCheck [ i ].uMask = 0;
        for ( j = 0 ; j < ARRAY_SIZE ( uProps ) ; j++ )
        {
            if ( PropertyCheck [ i ].uID1 == uProps [ j ] )
            {
                PropertyCheck [ i ].uMask |= 1<<j;
            }
            else if ( PropertyCheck [ i ].uID2 == uProps [ j ] )
            {
                PropertyCheck [ i ].uMask |= 1<<j;
            }
            else if ( PropertyCheck [ i ].uID3 == uProps [ j ] )
            {
                PropertyCheck [ i ].uMask |= 1<<j;
            }
        }
    }
}

BOOL CPDLParser::PatchPropertyTypes ( void )
{
    // For each property declaration, set the object flag if the
    // Handler for the type is object
    CTokenListWalker WholeList ( pRuntimeList );
    Token *pToken;
    Token *pChildToken;
    CString szHandler;
    CString szFnPrefix;
    CString szAType;
    CString szName;
    BOOL fMatched;
    char szErrorText [ MAX_LINE_LEN+1 ];
    UINT i;
    UINT uMask;

    while ( pToken = WholeList.GetNext() )
    {
        if ( pToken -> GetType() == TYPE_EVENT ||
            pToken -> GetType() == TYPE_CLASS ||
            pToken -> GetType() == TYPE_INTERFACE )
        {
            if ( pToken -> GetType() == TYPE_CLASS )
            {
                // Has it got a super, if so is it referenced
                if ( pToken -> IsSet ( CLASS_SUPER ) )
                {
                    CTokenListWalker AllList ( pRuntimeList );
                    if ( !AllList.GetNext ( TYPE_CLASS, pToken -> GetTagValue ( CLASS_SUPER ) ) )
                    {
                        sprintf ( szErrorText, "Class %s References unknown super:%s\n",
                            (LPCSTR)pToken->GetTagValue ( CLASS_NAME ),
                            (LPCSTR)pToken->GetTagValue ( CLASS_SUPER ) );
                        ReportError ( szErrorText );
                        return FALSE;
                    }
                }
                if ( pToken -> IsSet ( CLASS_INTERFACE ) )
                {
                    CTokenListWalker AllList ( pRuntimeList );
                    if ( !AllList.GetNext ( TYPE_INTERFACE, pToken -> GetTagValue ( CLASS_INTERFACE ) ) )
                    {
                        sprintf ( szErrorText, "Class %s References unknown interface:%s\n",
                            (LPCSTR)pToken->GetTagValue ( CLASS_NAME ),
                            (LPCSTR)pToken->GetTagValue ( CLASS_INTERFACE ) );
                        ReportError ( szErrorText );
                        return FALSE;
                    }
                }
                if ( pToken -> IsSet ( CLASS_EVENTS ) )
                {
                    CTokenListWalker AllList ( pRuntimeList );
                    if ( !AllList.GetNext ( TYPE_EVENT, pToken -> GetTagValue ( CLASS_EVENTS ) ) )
                    {
                        sprintf ( szErrorText, "Class %s References unknown events:%s\n",
                            (LPCSTR)pToken->GetTagValue ( CLASS_NAME ),
                            (LPCSTR)pToken->GetTagValue ( CLASS_EVENTS ) );
                        ReportError ( szErrorText );
                        return FALSE;
                    }
                }
                // If you have an event set , you must have a coclass
                if ( pToken -> IsSet ( CLASS_EVENTS ) && !pToken -> IsSet ( CLASS_ABSTRACT ) &&
                    !pToken -> IsSet ( CLASS_GUID ) )
                {
                    sprintf ( szErrorText, "Non abstract class %s has an event set but no GUID\n",
                        (LPCSTR)pToken->GetTagValue ( CLASS_NAME ) );
                    ReportError ( szErrorText );
                    return FALSE;
                }
            }
            else if ( pToken -> GetType() == TYPE_INTERFACE )
            {
                if ( pToken -> IsSet ( INTERFACE_SUPER ) )
                {
                    CTokenListWalker AllList ( pRuntimeList );
                    if ( !AllList.GetNext ( TYPE_INTERFACE, pToken -> GetTagValue ( INTERFACE_SUPER ) ) )
                    {
                        sprintf ( szErrorText, "Interface %s References unknown super:%s\n",
                            (LPCSTR)pToken->GetTagValue ( INTERFACE_NAME ),
                            (LPCSTR)pToken->GetTagValue ( INTERFACE_SUPER ) );
                        ReportError ( szErrorText );
                        return FALSE;
                    }
                }
            }
            else if ( pToken -> GetType() == TYPE_EVENT )
            {
                if ( pToken -> IsSet ( EVENT_SUPER ) )
                {
                    CTokenListWalker AllList ( pRuntimeList );
                    if ( !AllList.GetNext ( TYPE_EVENT, pToken -> GetTagValue ( EVENT_SUPER ) ) )
                    {
                        sprintf ( szErrorText, "Events %s References unknown super:%s\n",
                            (LPCSTR)pToken->GetTagValue ( EVENT_NAME ),
                            (LPCSTR)pToken->GetTagValue ( EVENT_SUPER ) );
                        ReportError ( szErrorText );
                        return FALSE;
                    }
                }
            }
            CTokenListWalker ChildList ( pToken );
            while ( pChildToken = ChildList.GetNext() )
            {
                if ( pChildToken -> GetType() == TYPE_PROPERTY )
                {
                    // If the Type field is not set, which it won't be for many
                    // abstract properties, set it to the ATYPE. We still
                    // need the type to determine if the property is an object value
                    // property
                    if ( !pChildToken -> IsSet ( PROPERTY_TYPE ) )
                    {
                        pChildToken -> AddTag ( PROPERTY_TYPE,
                            pChildToken -> GetTagValue ( PROPERTY_ATYPE ) );
                    }
                    if ( !LookupType ( pChildToken -> GetTagValue ( PROPERTY_TYPE ),
                        szHandler, szFnPrefix ) )
                    {
                        // Seeing as we don't use the handler for abstract types, we
                        // allow the lookup to fail
                        if ( !pChildToken -> IsSet ( PROPERTY_ABSTRACT ) )
                        {
                            sprintf ( szErrorText, "Invalid Type:%s in %s Property:%s\n",
                                (LPCSTR)pChildToken->GetTagValue ( PROPERTY_TYPE ),
                                (LPCSTR)pToken->GetTagValue ( NAME_TAG ),
                                (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ) );
                            ReportError ( szErrorText );
                            return FALSE;
                        }
                    }

                    // Currently we insist that you automate enums as BSTR's
                    szAType = pChildToken->GetTagValue ( PROPERTY_ATYPE );

                    if ( szHandler == "Enum" && szAType != "BSTR" )
                    {
                        sprintf ( szErrorText, "You must set atype:BSTR for an enum property %s : Property:%s\n",
                            (LPCSTR)pToken->GetTagValue ( NAME_TAG ),
                            (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ) );
                        ReportError ( szErrorText );
                        return FALSE;
                    }

                    if ( szHandler == "Color" && szAType != "VARIANT" )
                    {
                        sprintf ( szErrorText, "You must set atype:VARIANT for an type:CColorValue property %s : Property:%s\n",
                            (LPCSTR)pToken->GetTagValue ( NAME_TAG ),
                            (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ) );
                        ReportError ( szErrorText );
                        return FALSE;
                    }

                    if ( szHandler == "object" &&
                        !pChildToken -> IsSet ( PROPERTY_OBJECT ) )
                    {
                        pChildToken -> Set ( PROPERTY_OBJECT );
                    }
                    // Object valued properties must always be abstract because we don't have
                    // the notion of an "ObjectHandler"
                    if ( pChildToken -> IsSet ( PROPERTY_OBJECT ) &&
                        !pChildToken -> IsSet ( PROPERTY_ABSTRACT ) )
                    {
                        sprintf ( szErrorText, "Object Type Property %s:%s MUST be abstract\n",
                            (LPCSTR)pToken->GetTagValue ( NAME_TAG ),
                            (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ) );
                        ReportError ( szErrorText );
                        return FALSE;
                    }

                    for ( i = 0, uMask = 0 ; i < ARRAY_SIZE ( uProps ) ; i++ )
                    {
                        if ( pChildToken -> IsSet ( uProps [ i ] ) )
                        {
                            uMask |= 1<<i;
                        }
                    }

                    for ( i = 0, fMatched = FALSE;
                        i < ARRAY_SIZE ( PropertyCheck ); i++ )
                    {
                        if ( PropertyCheck [ i ].uMask == uMask )
                        {
                            fMatched = TRUE;
                        }
                    }

                    if ( !fMatched )
                    {
                        sprintf ( szErrorText, "Invalid combination of member/method/abstract/caa on %s:%s\n",
                            (LPCSTR)pToken->GetTagValue ( NAME_TAG ),
                            (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ) );
                        ReportError ( szErrorText );
                        return FALSE;
                    }
                    // Subobject MUST have a GET and MUST NOT have a SET
                    if ( pChildToken -> IsSet ( PROPERTY_SUBOBJECT ) &&
                        ( !pChildToken -> IsSet ( PROPERTY_GET ) || pChildToken -> IsSet ( PROPERTY_SET ) ) )
                    {
                        sprintf ( szErrorText, "Invalid combination of subobject/get/set on %s:%s\n",
                            (LPCSTR)pToken->GetTagValue ( NAME_TAG ),
                            (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ) );
                        ReportError ( szErrorText );
                        return FALSE;
                    }

                    // DISPLAYBIND Always implies BINDABLE - so always set it
                    if ( pChildToken -> IsSet ( PROPERTY_DISPLAYBIND ) &&
                        !pChildToken -> IsSet ( PROPERTY_BINDABLE ) )
                    {
                        pChildToken -> Set ( PROPERTY_BINDABLE );
                    }

                    // For now we limit the enum: type to atypre:VARIANT,
                    if ( pChildToken -> IsSet ( PROPERTY_ENUMREF ) )
                    {
                        if ( szAType != "VARIANT" )
                        {
                            sprintf ( szErrorText, "Invalid combination of atype/enum on %s:%s\n",
                                (LPCSTR)pToken->GetTagValue ( NAME_TAG ),
                                (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ) );
                            ReportError ( szErrorText );
                            return FALSE;
                        }
                    }
                    // Set an internal flag if the property cascades - saves looking this up later
                    if ( pChildToken -> IsSet ( PROPERTY_CAA ) )
                    {
                        const CCachedAttrArrayInfo *pCCAAI = GetCachedAttrArrayInfo( (LPCSTR)pChildToken -> GetTagValue ( PROPERTY_DISPID ) );
                        if ( pCCAAI->szDispId != NULL )
                        {
                            pChildToken -> Set ( PROPERTY_CASCADED );
                        }
                    }
                    if ( !pChildToken -> IsSet ( PROPERTY_DISPID ) )
                    {
                        sprintf ( szErrorText, "Missing compulsory attribute 'dispid' on %s:%s\n",
                            (LPCSTR)pToken->GetTagValue ( NAME_TAG ),
                            (LPCSTR)pChildToken->GetTagValue ( PROPERTY_NAME ) );
                        ReportError ( szErrorText );
                    }
                    // SETATDESIGNTIME augments regular set
                    if ( pChildToken -> IsSet ( PROPERTY_SETDESIGNMODE ) )
                    {
                        pChildToken -> Set ( PROPERTY_SET );
                    }

                }
                else if ( pChildToken -> GetType() == TYPE_METHOD )
                {
                    Token *pArgToken;
                    // For each method arg check
                    // that type is VARIANT if a optional tag is specified
                    CTokenListWalker ArgListWalker ( pChildToken );
                    while ( pArgToken = ArgListWalker.GetNext() )
                    {
                        szAType = pArgToken->GetTagValue ( METHODARG_TYPE );
                        if ( pArgToken->IsSet ( METHODARG_OPTIONAL ) &&
                            !(szAType == "VARIANT" || szAType == "VARIANT*") )
                        {
                            // MIDL will let this through but you'd never be able to
                            // set the default
                            sprintf ( szErrorText, "Method arg type must be VARIANT with optional: tag on %s:%s\n",
                                (LPCSTR)pToken->GetTagValue ( NAME_TAG ),
                                (LPCSTR)pChildToken->GetTagValue ( METHOD_NAME ) );
                            ReportError ( szErrorText );
                            return FALSE;
                        }
                        if ( LookupType ( pArgToken -> GetTagValue ( METHODARG_TYPE ),
                            szHandler, szFnPrefix ) )
                        {
                            if (szHandler == "Enum" && 
                                !(pToken->GetType() == TYPE_INTERFACE && 
                                    pToken->IsSet(INTERFACE_CUSTOM)))
                            {
                                sprintf ( szErrorText, "You must set type:BSTR for an enum %s Method:%s arg:%s\n",
                                    (LPCSTR)pToken->GetTagValue ( NAME_TAG ),
                                    (LPCSTR)pChildToken->GetTagValue ( METHOD_NAME ),
                                    (LPCSTR)pArgToken->GetTagValue ( METHODARG_ARGNAME ) );
                                ReportError ( szErrorText );
                                return FALSE;
                            }
                        }
                    }
                }
            }
        }
    }
    return TRUE;
}


//
// Patch up all interfaces which are not a primary default interfaces tearoff
// and mark as such (NOPRIMARY).  Classes marked as NOPRIMARY will be derived
// from the inheritance chain instead of being derived from IDispatch.
//
BOOL
CPDLParser::PatchInterfaces ()
{
    CTokenListWalker    ThisFilesList(pRuntimeList, _pszPDLFileName);
    Token              *pClassToken;
    Token              *pInterf;

    while (pClassToken = ThisFilesList.GetNext(TYPE_CLASS))
    {
        CString     szInterface;

        szInterface = pClassToken->GetTagValue(CLASS_INTERFACE);

        if (!FindTearoff(pClassToken->GetTagValue(CLASS_NAME),
                         (LPCSTR)szInterface))
        {
            CString szInterfSuper;

            pInterf = FindInterface(szInterface);
            while (pInterf)
            {
                pInterf->Set(INTERFACE_NOPRIMARYTEAROFF);

                szInterfSuper = pInterf->GetTagValue(INTERFACE_SUPER);
                pInterf = FindInterface(szInterfSuper);
            }
        }
    }

    return TRUE;
}


const CCachedAttrArrayInfo*
CPDLParser::GetCachedAttrArrayInfo( LPCSTR szDispId )
{
    CCachedAttrArrayInfo *pCCAAI = rgCachedAttrArrayInfo;

    while (pCCAAI->szDispId)
    {
        if (0==strcmp(szDispId, pCCAAI->szDispId))
            return pCCAAI;
        ++pCCAAI;
    }
    //This is means it is not applied to a XF structure
    return pCCAAI;
}


BOOL CPDLParser::GenerateHTMFile ()
{
    Token *pToken;
    CTokenListWalker WholeList ( pRuntimeList );
    CTokenListWalker ThisFilesList ( pRuntimeList, _pszPDLFileName );

    fprintf ( fpHTMFile, "<HTML>\n" );
    fprintf ( fpHTMFile, "<HEAD>\n" );
    fprintf ( fpHTMFile, "<TITLE>Interface Documentation from %s</TITLE>\n", _pszPDLFileName );
    fprintf ( fpHTMFile, "</HEAD>\n" );
    fprintf ( fpHTMFile, "<BODY>\n" );
    fprintf ( fpHTMFile, "<P>\n" );

    while ( pToken = ThisFilesList.GetNext ( TYPE_ENUM ) )
    {
        if ( !pToken -> IsSet ( ENUM_HIDDEN ))
        {
            fprintf ( fpHTMFile, "<B><U>Enumerations:</U></B> %s\n",
                      pToken->GetTagValue ( ENUM_NAME ) );
            fprintf ( fpHTMFile, "<P>\n" );

            fprintf ( fpHTMFile, "<TABLE WIDTH=70%%>\n" );
            fprintf ( fpHTMFile, "<TR>\n" );
            fprintf ( fpHTMFile, "<TH WIDTH=50%% ALIGN=\"Left\">Name</TH>\n" );
            fprintf ( fpHTMFile, "<TH WIDTH=25%% ALIGN=\"Center\">String</TH>\n" );
            fprintf ( fpHTMFile, "</TR>\n" );

            GenerateEnumHTM ( pToken,
                              pToken -> IsSet ( ENUM_PREFIX ) ?
                                        pToken->GetTagValue ( ENUM_PREFIX ) :
                                        pToken->GetTagValue ( ENUM_NAME ) );  // sort enums

            fprintf ( fpHTMFile, "</TABLE>\n" );
            fprintf ( fpHTMFile, "<P>\n" );
        }
    }

    // Output interface documentation

    ThisFilesList.Reset();
    while ( (pToken = ThisFilesList.GetNext ( TYPE_INTERFACE )) )
    {
        if (_stricmp("IUnknown", pToken->GetTagValue ( INTERFACE_NAME )) &&
            _stricmp("IDispatch", pToken->GetTagValue ( INTERFACE_NAME )) )
        {
            char achFilePrefix[100];
          
            strcpy (achFilePrefix, _pszPDLFileName);
            char *pDot = strchr(achFilePrefix, '.');
            if (pDot) {
                *pDot = '\0';
            }
            else {
                strcpy(achFilePrefix, "badpdl");
            }

            fprintf ( fpHTMIndexFile, "<A NAME=\"Index_Interface_%s\">Interface: <A HREF=\"%s.htm#Interface_%s\">%s</A><BR>\n",
                        pToken->GetTagValue ( INTERFACE_NAME ),
                        achFilePrefix, pToken->GetTagValue ( INTERFACE_NAME ),
                        pToken->GetTagValue ( INTERFACE_NAME ));
      
            fprintf ( fpHTMFile, "<P>\n" );
            fprintf ( fpHTMFile, "<A NAME=\"Interface_%s\">\n", pToken->GetTagValue ( INTERFACE_NAME ) );
            fprintf ( fpHTMFile, "<TABLE>\n" );
            fprintf ( fpHTMFile, "<TR><TD><H1>Interface</H1></TD>"
                                 "<TR><TD><B>%s</B></TD><TD> GUID: </TD><TD>%s</TD></TR>"
                                 "<TR><TD>inherits from interface</TD></TR>"
                                 "<TR><TD><B><A HREF=\"AllIndex.htm#Index_Interface_%s\">%s</A></B></TD></TR>\n"
                                 "</TABLE>\n",
                                  pToken->GetTagValue ( INTERFACE_NAME ),
                                  pToken->GetTagValue ( INTERFACE_GUID ),
                                  pToken->GetTagValue ( INTERFACE_SUPER ),
                                  pToken->GetTagValue ( INTERFACE_SUPER ) );
            fprintf ( fpHTMFile, "<P>\n" );

            fprintf ( fpHTMFile, "<HR>\n" );

            fprintf ( fpHTMFile, "<H2>Properties</H2>\n" );
            fprintf ( fpHTMFile, "<TABLE>\n" );
            fprintf ( fpHTMFile, "<TR>" );
            fprintf ( fpHTMFile, "<TH>Name</TH>" );
            fprintf ( fpHTMFile, "<TH>AType</TH>" );
            fprintf ( fpHTMFile, "<TH>DISPID</TH>" );
            fprintf ( fpHTMFile, "<TH>G</TH>" );
            fprintf ( fpHTMFile, "<TH>S</TH>" );
            fprintf ( fpHTMFile, "<TH>DT</TH>" );
            fprintf ( fpHTMFile, "<TH>Default</TH>" );
            fprintf ( fpHTMFile, "<TH>Min</TH>" );
            fprintf ( fpHTMFile, "<TH>Max</TH>" );
            fprintf ( fpHTMFile, "</TR>\n" );
            GenerateInterfacePropertiesHTM ( pToken );     // sort attributes
            fprintf ( fpHTMFile, "</TABLE>" );

            fprintf ( fpHTMFile, "<H2>Methods</H2>\n" );
            fprintf ( fpHTMFile, "<TABLE BORDER=1>\n" );
            fprintf ( fpHTMFile, "<TR>" );
            fprintf ( fpHTMFile, "<TH>Ret. Name</TH>" );
            fprintf ( fpHTMFile, "<TH>Name</TH>" );
            fprintf ( fpHTMFile, "<TH>Param Dir</TH>" );
            fprintf ( fpHTMFile, "<TH>Param Type</TH>" );
            fprintf ( fpHTMFile, "<TH>Param Name</TH>" );
            fprintf ( fpHTMFile, "<TH>Default Value</TH>" );
            fprintf ( fpHTMFile, "<TH>Optional</TH>" );
            fprintf ( fpHTMFile, "<TH>Ret. Type</TH>" );
            fprintf ( fpHTMFile, "</TR>\n" );
            GenerateInterfaceMethodHTM ( pToken );     // sort attributes
            fprintf ( fpHTMFile, "</TABLE>" );
        }
    }

    // Output eventset documentation
    ThisFilesList.Reset();
    while ( (pToken = ThisFilesList.GetNext ( TYPE_EVENT )) )
    {
        if (_stricmp("IDispatch", pToken->GetTagValue ( INTERFACE_NAME )) )
        {
            char achFilePrefix[100];
          
            strcpy (achFilePrefix, _pszPDLFileName);
            char *pDot = strchr(achFilePrefix, '.');
            if (pDot) {
                *pDot = '\0';
            }
            else {
                strcpy(achFilePrefix, "badpdl");
            }

            fprintf ( fpHTMIndexFile, "<A NAME=\"Index_Eventset_%s\">Eventset: <A HREF=\"%s.htm#Eventset_%s\">%s</A><BR>\n",
                        pToken->GetTagValue ( EVENT_NAME ),
                        achFilePrefix, pToken->GetTagValue ( EVENT_NAME ),
                        pToken->GetTagValue ( EVENT_NAME ));
      
            fprintf ( fpHTMFile, "<BR><BR>\n" );
            fprintf ( fpHTMFile, "<A NAME=\"Eventset_%s\">\n", pToken->GetTagValue ( EVENT_NAME ) );
            fprintf ( fpHTMFile, "<TABLE>\n" );
            fprintf ( fpHTMFile, "<TR><TD><H1>Event Set</H1></TD>"
                                 "<TR><TD><B>%s</B></TD><TD> GUID: </TD><TD>%s</TD></TR>"
                                 "<TR><TD>inherits from event set</TD></TR>"
                                 "<TR><TD><B><A HREF=\"AllIndex.htm#Index_Eventset_%s\">%s</A></B></TD></TR>\n"
                                 "</TABLE>\n",
                                  pToken->GetTagValue ( EVENT_NAME ),
                                  pToken->GetTagValue ( EVENT_GUID ),
                                  pToken->GetTagValue ( EVENT_SUPER ),
                                  pToken->GetTagValue ( EVENT_SUPER ) );
            fprintf ( fpHTMFile, "<HR>\n" );
            fprintf ( fpHTMFile, "<H2>Methods</H2>\n" );
            fprintf ( fpHTMFile, "<TABLE BORDER=1>\n" );
            fprintf ( fpHTMFile, "<TR>" );
            fprintf ( fpHTMFile, "<TH>Ret. Name</TH>" );
            fprintf ( fpHTMFile, "<TH>Name</TH>" );
            fprintf ( fpHTMFile, "<TH>DISPID</TH>" );
            fprintf ( fpHTMFile, "<TH>Cancelable</TH>" );
            fprintf ( fpHTMFile, "<TH>Bubbling</TH>" );
            fprintf ( fpHTMFile, "<TH>Param Dir</TH>" );
            fprintf ( fpHTMFile, "<TH>Param Type</TH>" );
            fprintf ( fpHTMFile, "<TH>Param Name</TH>" );
            fprintf ( fpHTMFile, "<TH>Default Value</TH>" );
            fprintf ( fpHTMFile, "<TH>Optional</TH>" );
            fprintf ( fpHTMFile, "<TH>Ret. Type</TH>" );
            fprintf ( fpHTMFile, "</TR>\n" );
            GenerateEventMethodHTM ( pToken );     // sort attributes
            fprintf ( fpHTMFile, "</TABLE>" );
        }
    }

    fprintf ( fpHTMFile, "</BODY>\n");
    fprintf ( fpHTMFile, "</HTML>\n");

    return TRUE;
}


void CPDLParser::GenerateArg ( Token *pArgToken )
{
    if ( ! pArgToken -> IsSet ( METHODARG_RETURNVALUE ) )
    {
        fprintf ( fpHTMFile, "&nbsp[%s] %s %s",
                  pArgToken -> IsSet ( METHODARG_OUT ) ? "out" : "in",
                  pArgToken -> GetTagValue ( METHODARG_TYPE ),
                  pArgToken -> GetTagValue ( METHODARG_ARGNAME ) );

        if ( pArgToken -> IsSet ( METHODARG_DEFAULTVALUE ) )
        {
            fprintf ( fpHTMFile, "=%s",
                      pArgToken -> GetTagValue ( METHODARG_DEFAULTVALUE ) );
        }

        if ( pArgToken -> IsSet ( METHODARG_OPTIONAL ) )
        {
            fprintf ( fpHTMFile, " [optional]" );
        }
    }
}

void CPDLParser::GenerateInterfaceArg ( Token *pArgToken )
{
    if ( ! pArgToken -> IsSet ( METHODARG_RETURNVALUE ) )
    {
        fprintf ( fpHTMFile, "<TD>%s</TD><TD>%s</TD><TD>%s</TD>",
                  pArgToken -> IsSet ( METHODARG_OUT ) ? "out" : "in",
                  pArgToken -> GetTagValue ( METHODARG_TYPE ),
                  pArgToken -> GetTagValue ( METHODARG_ARGNAME ) );

        fprintf ( fpHTMFile, "<TD>%s</TD><TD>%s</TD>",
                  pArgToken -> IsSet ( METHODARG_DEFAULTVALUE ) ?
                    (pArgToken -> GetTagValue ( METHODARG_DEFAULTVALUE )) : "",
                  pArgToken -> IsSet ( METHODARG_OPTIONAL) ?
                    "Y" : "N" );
    
    }
}

void CPDLParser::GenerateMethodHTM ( Token *pIntfToken )
{
    CTokenListWalker   *pChildList;
    Token              *pChildToken;
    Token              *pArgToken;
    int                 cArgs;
    CString             szSuper;
    CTokenListWalker   *ptlw = NULL;

    pChildList = new CTokenListWalker ( pIntfToken );

    szSuper = pIntfToken->GetTagValue ( INTERFACE_SUPER );

    do
    {
        while ( pChildToken = pChildList -> GetNext() )
        {
            CString             szRetValArg;
            CString             szRetValType;
            CTokenListWalker    ArgListWalker ( pChildToken );

            cArgs = 0;

            // Loop thru all arguments.
            while ( (pArgToken = ArgListWalker.GetNext()) != NULL &&
                    pArgToken -> GetType () == TYPE_METHOD_ARG )
            {
                // Looking for a return value.
                if ( pArgToken -> IsSet ( METHODARG_RETURNVALUE ) )
                {
                    // If a return value exist then get the argument name.
                    szRetValArg = pArgToken -> GetTagValue (
                        pArgToken -> IsSet ( METHODARG_ARGNAME ) ?
                            METHODARG_ARGNAME : METHODARG_RETURNVALUE );

                    szRetValType = pArgToken -> GetTagValue ( METHODARG_TYPE );
                }
                else
                {
                    cArgs++;
                }
            }

            if ( strlen ( szRetValArg ) )
            {
                fprintf ( fpHTMFile, "<TR><TD>%s = <I>object.</I><B>%s</B>",
                          (LPCSTR)szRetValArg,
                          pChildToken -> GetTagValue ( METHOD_NAME ) );
            }
            else
            {
                fprintf ( fpHTMFile, "<TR><TD><I>object.</I><B>%s</B>",
                          pChildToken -> GetTagValue ( METHOD_NAME ) );
            }

            int cArgIndex = 0;
            ArgListWalker.Reset ( );
            while ( ( pArgToken = ArgListWalker.GetNext ( ) ) != NULL &&
                      pArgToken -> GetType () == TYPE_METHOD_ARG )
            {
                if ( ! pArgToken -> IsSet ( METHODARG_RETURNVALUE ) )
                {
                    if (cArgIndex == 0)
                    {
                        switch (cArgs)
                        {
                        case 0:
                            fprintf ( fpHTMFile, "<TD>( )</TD>\n" );
                            fprintf ( fpHTMFile, "<TD ALIGN=\"Center\">%s</TD>\n",
                                      (LPCSTR)szRetValType );
                            fprintf ( fpHTMFile, "</TR>\n" );
                           break;
                        case 1:
                            fprintf ( fpHTMFile, "<TD>(" );

                            GenerateArg( pArgToken );

                            fprintf ( fpHTMFile, "&nbsp)</TD>\n" );
                            fprintf ( fpHTMFile, "<TD ALIGN=\"Center\">%s</TD>\n",
                                      (LPCSTR)szRetValType );
                            fprintf ( fpHTMFile, "</TR>\n" );
                            break;
                        default:
                            fprintf ( fpHTMFile, "<TD>(" );

                            GenerateArg( pArgToken );

                            fprintf ( fpHTMFile, ",</TD>\n" );
                            fprintf ( fpHTMFile, "<TD ALIGN=\"Center\">%s</TD>\n",
                                      (LPCSTR)szRetValType );
                            fprintf ( fpHTMFile, "</TR>\n" );
                            break;
                        }
                    }
                    else
                    {
                        if (cArgIndex > 1)
                        {
                            fprintf ( fpHTMFile, ",</TD></TR>\n" );
                        }
                        fprintf ( fpHTMFile, "<TR><TD></TD><TD>&nbsp" );
                        GenerateArg( pArgToken );
                    }

                    cArgIndex++;
                }
            }

            if ( cArgIndex == 0 )
            {
                fprintf ( fpHTMFile, "<TD>( )</TD>\n" );
                fprintf ( fpHTMFile, "<TD ALIGN=\"Center\">%s</TD>\n",
                          (LPCSTR)szRetValType );
                fprintf ( fpHTMFile, "</TR>\n" );
            }
            else if ( cArgIndex > 1 )
            {
                fprintf ( fpHTMFile, ")</TD></TR>\n" );
            }

            fprintf ( fpHTMFile, "<TR>&nbsp</TR>" );
        }

        // Get inherited interface.
        if ( strlen ( szSuper ) )
        {
            if (ptlw == NULL)
            {
                ptlw = new CTokenListWalker ( pRuntimeList, _pszPDLFileName );
            }
            else
            {
                ptlw->Reset();
            }

TryAgain:
            pIntfToken = ptlw->GetNext ( TYPE_INTERFACE, szSuper );

            if (pIntfToken)
            {
                szSuper = pIntfToken->GetTagValue ( INTERFACE_SUPER );

                delete pChildList;
                pChildList = new CTokenListWalker ( pIntfToken );
            }
            else
            {
                if ( !ptlw->IsGenericWalker ( ) )
                {
                    delete ptlw;
                    ptlw = new CTokenListWalker ( pRuntimeList );
                    goto TryAgain;
                }
            }
        }
        else
        {
            break;
        }
    } while (pIntfToken);

    delete pChildList;
    delete ptlw;
}

void CPDLParser::GenerateInterfaceMethodHTM ( Token *pIntfToken )
{
    CTokenListWalker   *pChildList;
    Token              *pChildToken;
    Token              *pArgToken;
    int                 cArgs;
    CString             szSuper;

    pChildList = new CTokenListWalker ( pIntfToken );

    szSuper = pIntfToken->GetTagValue ( INTERFACE_SUPER );

    while ( pChildToken = pChildList -> GetNext() )
    {
        CString             szRetValArg;
        CString             szRetValType;
        CTokenListWalker    ArgListWalker ( pChildToken );

        cArgs = 0;

        // Loop thru all arguments.
        while ( (pArgToken = ArgListWalker.GetNext()) != NULL &&
                pArgToken -> GetType () == TYPE_METHOD_ARG )
        {
            // Looking for a return value.
            if ( pArgToken -> IsSet ( METHODARG_RETURNVALUE ) )
            {
                // If a return value exist then get the argument name.
                szRetValArg = pArgToken -> GetTagValue (
                    pArgToken -> IsSet ( METHODARG_ARGNAME ) ?
                        METHODARG_ARGNAME : METHODARG_RETURNVALUE );

                szRetValType = pArgToken -> GetTagValue ( METHODARG_TYPE );
            }
            else
            {
                cArgs++;
            }
        }

        if ( strlen ( szRetValArg ) )
        {
            fprintf ( fpHTMFile, "<TR><TD>%s</TD><TD><I>object.</I><B>%s</B></TD>",
                      (LPCSTR)szRetValArg,
                      pChildToken -> GetTagValue ( METHOD_NAME ) );
        }
        else
        {
            fprintf ( fpHTMFile, "<TR><TD></TD><TD><I>object.</I><B>%s</B></TD>",
                      pChildToken -> GetTagValue ( METHOD_NAME ) );
        }

        int cArgIndex = 0;
        ArgListWalker.Reset ( );
        while ( ( pArgToken = ArgListWalker.GetNext ( ) ) != NULL &&
                  pArgToken -> GetType () == TYPE_METHOD_ARG )
        {
            if ( ! pArgToken -> IsSet ( METHODARG_RETURNVALUE ) )
            {
                if (cArgIndex == 0)
                {
                    switch (cArgs)
                    {
                    case 0:
                        fprintf ( fpHTMFile, "<TD></TD><TD></TD><TD></TD><TD></TD><TD></TD> <!-- 1 -->" ); 
                        fprintf ( fpHTMFile, "<TD ALIGN=\"Center\">%s</TD>\n",
                                  (LPCSTR)szRetValType );
                        fprintf ( fpHTMFile, "</TR>\n" );
                       break;
                    default:
                        GenerateInterfaceArg( pArgToken );
                        fprintf ( fpHTMFile, "<TD ALIGN=\"Center\">%s</TD>\n",
                                  (LPCSTR)szRetValType );
                        fprintf ( fpHTMFile, "</TR>\n" );
                        break;
                    }
                }
                else
                {
                    if (cArgIndex > 1)
                    {
                        fprintf ( fpHTMFile, "</TR> <!-- Hello -->\n" );
                    }
                    fprintf ( fpHTMFile, "<TR><TD></TD><TD></TD>" );
                    GenerateInterfaceArg( pArgToken );
                }

                cArgIndex++;
            }
        }

        if ( cArgIndex == 0 )
        {
            fprintf ( fpHTMFile, "<TD></TD><TD></TD><TD></TD><TD></TD><TD></TD> <!-- 2 -->" );
            fprintf ( fpHTMFile, "<TD ALIGN=\"Center\">%s</TD>\n",
                      (LPCSTR)szRetValType );
            fprintf ( fpHTMFile, "</TR>\n" );
        }
        else if ( cArgIndex > 1 )
        {
            fprintf ( fpHTMFile, "</TR> <!-- 3 -->\n" );
        }

        fprintf ( fpHTMFile, "<TR></TR>" );
    }

    delete pChildList;
}

void CPDLParser::GenerateEventMethodHTM ( Token *pIntfToken )
{
    CTokenListWalker   *pChildList;
    Token              *pChildToken;
    Token              *pArgToken;
    int                 cArgs;
    CString             szSuper;

    pChildList = new CTokenListWalker ( pIntfToken );

    szSuper = pIntfToken->GetTagValue ( INTERFACE_SUPER );

    while ( pChildToken = pChildList -> GetNext() )
    {
        CString             szRetValArg;
        CString             szRetValType;
        CTokenListWalker    ArgListWalker ( pChildToken );

        cArgs = 0;

        // Loop thru all arguments.
        while ( (pArgToken = ArgListWalker.GetNext()) != NULL &&
                pArgToken -> GetType () == TYPE_METHOD_ARG )
        {
            // Looking for a return value.
            if ( pArgToken -> IsSet ( METHODARG_RETURNVALUE ) )
            {
                // If a return value exist then get the argument name.
                szRetValArg = pArgToken -> GetTagValue (
                    pArgToken -> IsSet ( METHODARG_ARGNAME ) ?
                        METHODARG_ARGNAME : METHODARG_RETURNVALUE );

                szRetValType = pArgToken -> GetTagValue ( METHODARG_TYPE );
            }
            else
            {
                cArgs++;
            }
        }

        if ( strlen ( szRetValArg ) )
        {
            fprintf ( fpHTMFile, "<TR><TD>%s</TD><TD><I>object.</I><B>%s</B></TD>",
                      (LPCSTR)szRetValArg,
                      pChildToken -> GetTagValue ( METHOD_NAME ) );
        }
        else
        {
            fprintf ( fpHTMFile, "<TR><TD></TD><TD><I>object.</I><B>%s</B></TD>",
                      pChildToken -> GetTagValue ( METHOD_NAME ) );
        }
        
        fprintf ( fpHTMFile, "<TD>%s</TD><TD>%s</TD><TD>%s</TD>",
                  pChildToken->IsSet(METHOD_DISPID) ? pChildToken->GetTagValue ( METHOD_DISPID ) : "",
                  pChildToken->IsSet(METHOD_CANCELABLE) ? "Y" : "N",
                  pChildToken->IsSet(METHOD_BUBBLING) ? "Y" : "N" );

        int cArgIndex = 0;
        ArgListWalker.Reset ( );
        while ( ( pArgToken = ArgListWalker.GetNext ( ) ) != NULL &&
                  pArgToken -> GetType () == TYPE_METHOD_ARG )
        {
            if ( ! pArgToken -> IsSet ( METHODARG_RETURNVALUE ) )
            {
                if (cArgIndex == 0)
                {
                    switch (cArgs)
                    {
                    case 0:
                        fprintf ( fpHTMFile, "<TD></TD><TD></TD><TD></TD><TD></TD><TD></TD> <!-- 1 -->" ); 
                        fprintf ( fpHTMFile, "<TD ALIGN=\"Center\">%s</TD>\n",
                                  (LPCSTR)szRetValType );
                        fprintf ( fpHTMFile, "</TR>\n" );
                       break;
                    default:
                        GenerateInterfaceArg( pArgToken );
                        fprintf ( fpHTMFile, "<TD ALIGN=\"Center\">%s</TD>\n",
                                  (LPCSTR)szRetValType );
                        fprintf ( fpHTMFile, "</TR>\n" );
                        break;
                    }
                }
                else
                {
                    if (cArgIndex > 1)
                    {
                        fprintf ( fpHTMFile, "</TR> <!-- Hello -->\n" );
                    }
                    fprintf ( fpHTMFile, "<TR><TD></TD><TD></TD><TD></TD><TD></TD><TD></TD>" );
                    GenerateInterfaceArg( pArgToken );
                }

                cArgIndex++;
            }
        }

        if ( cArgIndex == 0 )
        {
            fprintf ( fpHTMFile, "<TD></TD><TD></TD><TD></TD><TD></TD><TD></TD> <!-- 2 -->" );
            fprintf ( fpHTMFile, "<TD ALIGN=\"Center\">%s</TD>\n",
                      (LPCSTR)szRetValType );
            fprintf ( fpHTMFile, "</TR>\n" );
        }
        else if ( cArgIndex > 1 )
        {
            fprintf ( fpHTMFile, "</TR> <!-- 3 -->\n" );
        }

        fprintf ( fpHTMFile, "<TR></TR>" );
    }

    delete pChildList;
}


void CPDLParser::GenerateEnumHTM ( Token *pClassToken, char *pEnumPrefix )
{
    CTokenListWalker    ChildList ( pClassToken );
    Token              *pChildToken;
    CString             szStringValue;

    while ( pChildToken = ChildList.GetNext() )
    {
        if ( pChildToken -> GetType() == TYPE_EVAL )
        {

            fprintf ( fpHTMFile, "<TR>\n<TD>%s%s</TD><TD ALIGN=\"Center\">\"%s\"</TD>",
                      pEnumPrefix,
                      pChildToken -> GetTagValue ( EVAL_NAME ),
                      pChildToken ->  IsSet ( EVAL_STRING ) ?
                        pChildToken -> GetTagValue ( EVAL_STRING ) :
                        pChildToken -> GetTagValue ( EVAL_NAME ) );

            fprintf ( fpHTMFile, "</TR>\n");
        }
    }
}


void CPDLParser::GeneratePropertiesHTM ( Token *pIntfToken, BOOL fAttributes )
{
    CTokenListWalker   *pChildList;
    Token              *pChildToken;
    CString             szSuper;
    CTokenListWalker   *ptlw = NULL;

    pChildList = new CTokenListWalker ( pIntfToken );

    szSuper = pIntfToken->GetTagValue ( INTERFACE_SUPER );

    do
    {
        while ( pChildToken = pChildList->GetNext() )
        {
            // Attributes are only properties which are not abstract and the
            // ppflags is not PROPPARAM_NOTHTML.
            if ( pChildToken -> GetType () == TYPE_PROPERTY     &&
                 fAttributes == (
                      !pChildToken -> IsSet ( PROPERTY_ABSTRACT )             &&
                      pChildToken -> IsSet ( PROPERTY_NOPERSIST ) ) )
            {

                if (fAttributes)
                {
                    fprintf ( fpHTMFile, "<TR><TD>%s</TD><TD>%s</TD><TD>%s</TD>",
                              pChildToken -> GetTagValue (
                                    pChildToken -> IsSet ( PROPERTY_SZATTRIBUTE ) ?
                                        PROPERTY_SZATTRIBUTE : PROPERTY_NAME ),
                              pChildToken -> GetTagValue ( PROPERTY_NAME ),
                              pChildToken -> GetTagValue ( PROPERTY_ATYPE ) );
                }
                else
                {
                    fprintf ( fpHTMFile, "<TR><TD>%s</TD><TD>%s</TD>",
                              pChildToken -> GetTagValue ( PROPERTY_NAME ),
                              pChildToken -> GetTagValue ( PROPERTY_ATYPE ) );
                }

                fprintf ( fpHTMFile, "<TD>%s</TD>",
                          pChildToken -> IsSet ( PROPERTY_NOTPRESENTDEFAULT ) ?
                            pChildToken -> GetTagValue ( PROPERTY_NOTPRESENTDEFAULT ) :
                            "" );

                fprintf ( fpHTMFile, "<TD>%s</TD>",
                          pChildToken -> IsSet ( PROPERTY_MIN ) ?
                            pChildToken -> GetTagValue ( PROPERTY_MIN ) :
                            "" );

                fprintf ( fpHTMFile, "<TD>%s</TD>",
                          pChildToken -> IsSet ( PROPERTY_MAX ) ?
                            pChildToken -> GetTagValue ( PROPERTY_MAX ) :
                            "" );

                if ( pChildToken -> IsSet ( PROPERTY_SET )  &&
                     pChildToken -> IsSet ( PROPERTY_GET ) )
                {
                    fprintf ( fpHTMFile, "<TD>R/W</TD>" );
                }
                else if ( pChildToken -> IsSet ( PROPERTY_GET ) )
                {
                    fprintf ( fpHTMFile, "<TD>R/O</TD>" );
                }
                else
                {
                    fprintf ( fpHTMFile, "<TD>W/O</TD>" );
                }

                fprintf ( fpHTMFile,
                          pChildToken -> IsSet ( PROPERTY_SETDESIGNMODE ) ?
                            "<TD>R/W</TD>" : "<TD>R/O</TD>" );

                fprintf ( fpHTMFile, "</TR>\n" );
            }
        }

        // Get inherited interface.
        if ( strlen ( szSuper ) )
        {
            if (ptlw == NULL)
            {
                ptlw = new CTokenListWalker ( pRuntimeList, _pszPDLFileName );
            }
            else
            {
                ptlw->Reset();
            }

TryAgain:
            pIntfToken = ptlw->GetNext ( TYPE_INTERFACE, szSuper );

            if (pIntfToken)
            {
                szSuper = pIntfToken->GetTagValue ( INTERFACE_SUPER );

                delete pChildList;
                pChildList = new CTokenListWalker ( pIntfToken );
            }
            else
            {
                if ( !ptlw->IsGenericWalker ( ) )
                {
                    delete ptlw;
                    ptlw = new CTokenListWalker ( pRuntimeList );
                    goto TryAgain;
                }
            }
        }
        else
        {
            break;
        }
    } while (pIntfToken);

    delete pChildList;
    delete ptlw;
}

#define GET_TAG_VALUE(pToken, value) (pToken->IsSet(value) ? pToken->GetTagValue(value) : "")

void CPDLParser::GenerateInterfacePropertiesHTM ( Token *pIntfToken )
{
    CTokenListWalker   *pChildList;
    Token              *pChildToken;
    CString             szSuper;

    pChildList = new CTokenListWalker ( pIntfToken );

    szSuper = pIntfToken->GetTagValue ( INTERFACE_SUPER );

    while ( pChildToken = pChildList->GetNext() )
    {
        if ( pChildToken -> GetType () == TYPE_PROPERTY )
        {
            fprintf ( fpHTMFile, "<TR>" );
            fprintf ( fpHTMFile, "<TD>%s</TD>", GET_TAG_VALUE(pChildToken, PROPERTY_NAME) );
            fprintf ( fpHTMFile, "<TD>%s</TD>", GET_TAG_VALUE(pChildToken, PROPERTY_ATYPE) );
            fprintf ( fpHTMFile, "<TD>%s</TD>", GET_TAG_VALUE(pChildToken, PROPERTY_DISPID) );
            fprintf ( fpHTMFile, "<TD>%s</TD>", pChildToken->IsSet(PROPERTY_GET) ? "Y" : "N" );
            fprintf ( fpHTMFile, "<TD>%s</TD>", pChildToken->IsSet(PROPERTY_SET) ? "Y" : "N" );
            fprintf ( fpHTMFile, "<TD>%s</TD>", pChildToken->IsSet(PROPERTY_SETDESIGNMODE) ? "Y" : "N" );
            fprintf ( fpHTMFile, "<TD>%s</TD>", pChildToken->IsSet(PROPERTY_NOTPRESENTDEFAULT) ? pChildToken->GetTagValue(PROPERTY_NOTPRESENTDEFAULT) : "" );
            fprintf ( fpHTMFile, "<TD>%s</TD>", pChildToken->IsSet(PROPERTY_MIN) ? pChildToken->GetTagValue(PROPERTY_MIN) : "" );
            fprintf ( fpHTMFile, "<TD>%s</TD>", pChildToken->IsSet(PROPERTY_MAX) ? pChildToken->GetTagValue(PROPERTY_MAX) : "" );
            fprintf ( fpHTMFile, "</TR>\n" );
        }
    }
    delete pChildList;
}

#undef GET_TAG_VALUE

Token* CPDLParser::FindInterface (CString szInterfaceMatch)
{
    CTokenListWalker    WholeTree ( pRuntimeList );
    Token              *pInterfaceToken;

    WholeTree.Reset();
    while ( pInterfaceToken = WholeTree.GetNext ( TYPE_INTERFACE ) )
    {
        CString     szInterface;

        if ( !pInterfaceToken -> IsSet ( INTERFACE_ABSTRACT ) &&
            pInterfaceToken -> IsSet ( INTERFACE_GUID ) )
        {
            szInterface = pInterfaceToken -> GetTagValue ( INTERFACE_NAME );
            if (szInterface == szInterfaceMatch)
            {
                return pInterfaceToken;
            }
        }
    }

    return NULL;
}


// Only interfaces defined in this file.
Token* CPDLParser::FindInterfaceLocally (CString szInterfaceMatch)
{
    CTokenListWalker    TokenList ( pRuntimeList, _pszPDLFileName );
    Token              *pInterfaceToken;

    TokenList.Reset();
    while ( pInterfaceToken = TokenList.GetNext ( TYPE_INTERFACE ) )
    {
        CString     szInterface;

        if ( !pInterfaceToken -> IsSet ( INTERFACE_ABSTRACT ) &&
            pInterfaceToken -> IsSet ( INTERFACE_GUID ) )
        {
            szInterface = pInterfaceToken -> GetTagValue ( INTERFACE_NAME );
            if (szInterface == szInterfaceMatch)
            {
                return pInterfaceToken;
            }
        }
    }

    return NULL;
}


BOOL CPDLParser::IsPrimaryInterface(CString szInterface)
{
    CTokenListWalker    TokenList ( pRuntimeList, _pszPDLFileName );
    Token              *pClassToken;

    TokenList.Reset();
    while ( pClassToken = TokenList.GetNext ( TYPE_CLASS ) )
    {
        if (!_stricmp((LPSTR)pClassToken->GetTagValue(CLASS_INTERFACE),
                      szInterface))
            return TRUE;
    }

    return FALSE;
}


Token* CPDLParser::FindClass (CString szClassMatch)
{
    CTokenListWalker    WholeTree ( pRuntimeList );
    Token              *pClassToken;

    WholeTree.Reset();
    while ( pClassToken = WholeTree.GetNext ( TYPE_CLASS ) )
    {
        CString     szClass;

        szClass = pClassToken -> GetTagValue ( CLASS_NAME );
        if (szClass == szClassMatch)
        {
            return pClassToken;
        }
    }

    return NULL;
}

Token * CPDLParser::IsSuperInterface( CString szSuper, Token * pInterface )
{
    Token              *pInterfaceToken;
    CString             szInterface;

    if(!pInterface)
        return NULL;

    szInterface = pInterface->GetTagValue(INTERFACE_NAME);
    
    pInterfaceToken = pInterface;

    while ( pInterfaceToken )
    {
        if (szSuper == szInterface)
          return pInterfaceToken;

        szInterface = pInterfaceToken->GetTagValue(INTERFACE_SUPER);
        pInterfaceToken = FindInterface(szInterface);
    }

    return NULL;

}


Token *
CPDLParser::FindMatchingEntryWOPropDesc(Token *pClass, Token *pToFindToken, BOOL fNameMatchOnly)
{
    CTokenListWalker    ChildWalker(pClass);
    Token              *pChildToken;
    CString             szInterface;
    Token              *pInterfToken;
    Token              *pFuncToken = NULL;

    while (pChildToken = ChildWalker.GetNext())
    {
        if (pChildToken->GetType() == TYPE_IMPLEMENTS)
        {
            szInterface = pChildToken->GetTagValue(IMPLEMENTS_NAME);
            pInterfToken = FindInterface(szInterface);
            if (pInterfToken)
            {
                pFuncToken = FindMethodInInterfaceWOPropDesc(pInterfToken, pToFindToken, fNameMatchOnly);
                if (pFuncToken)
                    break;      // Found a match...
            }
        }
    }

    return pFuncToken;
}


Token*
CPDLParser::FindMethodInInterfaceWOPropDesc(Token *pInterface, Token *pToFindToken, BOOL fNameMatchOnly)
{
    CTokenListWalker    ChildList(pInterface);
    Token              *pChildToken = NULL;

    while (pChildToken = ChildList.GetNext())
    {
        if (pChildToken->GetType() == pToFindToken->GetType())
        {
            if (pChildToken->GetType() == TYPE_METHOD && !pChildToken->IsSet(METHOD_NOPROPDESC))
            {
                CString szMethodName;

                if (pToFindToken->IsSet(METHOD_NOPROPDESC) &&
                    pToFindToken->IsSet(METHOD_SZINTERFACEEXPOSE))
                {
                    szMethodName = pToFindToken->GetTagValue(METHOD_SZINTERFACEEXPOSE);
                }
                else
                {
                    szMethodName = pToFindToken->GetTagValue(METHOD_NAME);
                }

                if (!strcmp((LPCSTR)szMethodName,
                            (LPCSTR)pChildToken->GetTagValue(METHOD_NAME)))
                {
                   
                    CString     szTypesSig;
                    CString     szArgsType;
                    CString     szFindTypesSig;
                    CString     szFindArgsType;
                    BOOL        fIgnore;
                    int         cIgnore;


                    // If we only need a name match then we're done.
                    if (fNameMatchOnly)
                        break;

                    if (!BuildMethodSignature(pChildToken,
                                              szTypesSig,
                                              szArgsType,
                                              fIgnore,
                                              fIgnore,
                                              cIgnore,
                                              cIgnore))
                        return NULL;

                    if (!BuildMethodSignature(pToFindToken,
                                              szFindTypesSig,
                                              szFindArgsType,
                                              fIgnore,
                                              fIgnore,
                                              cIgnore,
                                              cIgnore))
                        return NULL;

                    // Exact signature match then use it.
                    if (!strcmp(szTypesSig, szFindTypesSig) &&
                        !strcmp(szArgsType, szFindArgsType))
                        break;
                }
            }
            else if (pChildToken->GetType() == TYPE_PROPERTY && !pChildToken->IsSet(PROPERTY_NOPROPDESC))
            {
                CString szPropertyName;

                if (pToFindToken->IsSet(PROPERTY_NOPROPDESC) &&
                    pToFindToken->IsSet(PROPERTY_SZINTERFACEEXPOSE))
                {
                    szPropertyName = pToFindToken->GetTagValue(PROPERTY_SZINTERFACEEXPOSE);
                }
                else
                {
                    szPropertyName = pToFindToken->GetTagValue(PROPERTY_NAME);
                }

                if (!strcmp((LPCSTR)szPropertyName,
                            (LPCSTR)pChildToken->GetTagValue(PROPERTY_NAME)))
                {
                    // If we only need a name match then we're done.
                    if (fNameMatchOnly)
                        break;

                    // If both are properties and the types are similar or an
                    // enum then the signature is the same we found a match.
                    if ((pChildToken->IsSet(PROPERTY_GETSETMETHODS) == pToFindToken->IsSet(PROPERTY_GETSETMETHODS)) &&
                        (pChildToken->IsSet(PROPERTY_MEMBER) == pToFindToken->IsSet(PROPERTY_MEMBER)) &&
                        (pChildToken->IsSet(PROPERTY_GET) == pToFindToken->IsSet(PROPERTY_GET)) &&
                        (pChildToken->IsSet(PROPERTY_SET) == pToFindToken->IsSet(PROPERTY_SET)))
                    {
                        if (!strcmp((LPCSTR)pChildToken->GetTagValue(PROPERTY_ATYPE),
                                    (LPCSTR)pToFindToken->GetTagValue(PROPERTY_ATYPE)))
                            break;

                        if (FindEnum(pChildToken) && FindEnum(pToFindToken))
                            break;
                    }
                }
            }
        }
    }

    return pChildToken;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\btools\tldiff\cocomp.cxx ===
#include <assert.h>
#include <iostream.h>
#include "CoComp.Hxx"

bool CompareBuffer( char* pBuff1, char* pBuff2, unsigned long nLen);
void WriteLine(HANDLE file, char* pBuff, int nLen);
extern unsigned long g_ulAppRetVal;

CCompareCoClass::CCompareCoClass(char* pCurBuf, char* pRefBuf, HANDLE fileDiff, char* pszClassName )
{
	_pCurBuf = pCurBuf;
	_pRefBuf = pRefBuf;
	_fileDiff = fileDiff;
	_pszClassName = pszClassName;

	_pCurList = new CAutoArray<LINEINFO>;
	_pRefList = new CAutoArray<LINEINFO>;

	CreateLineIndex(_pCurList, _pCurBuf);
	CreateLineIndex(_pRefList, _pRefBuf);

	_bFirstTime = true;
}

CCompareCoClass::~CCompareCoClass()
{
	delete _pCurList;
	delete _pRefList;
}

void CCompareCoClass::FindAdditionsAndChanges()
{
	long lIdx;
	long lTmp;
	LINEINFO lineCur;
	LINEINFO lineRef;

	char* szBuff = new char[128];
	
	//check for additions and alterations
	for ( lIdx = 0; lIdx< (int)_pCurList->Size(); lIdx++ )
	{
		_pCurList->GetAt( lIdx, &lineCur );

		for ( lTmp=0; lTmp<_pRefList->Size(); lTmp++ )
		{
			_pRefList->GetAt( lTmp, &lineRef );
			
			//compare the names of two methods to find if they are comparable
			//in respect to other aspects of their declarations.
			if (( !lineRef.fUsed ) && 
				( CompareBuffer(&_pCurBuf[lineCur.ulNameStart], 
								&_pRefBuf[lineRef.ulNameStart], 
								max(lineCur.ulNameEnd-lineCur.ulNameStart, 
								lineRef.ulNameEnd-lineRef.ulNameStart)+ 1)))
			{
				//we have found a match. Mark it so that we don't compare anymore
				lineRef.fUsed = true;
				_pRefList->Set( lTmp, lineRef );
				break;
			}

			lineRef.fUsed = false;
		}

		//did we find a match.
		if ( lTmp == _pRefList->Size() )
		{
			char* pszName = new char[lineCur.ulNameEnd-lineCur.ulNameStart+1];
			for (lTmp=lineCur.ulNameStart; lTmp<(long)lineCur.ulNameEnd; lTmp++)
			{
				pszName[lTmp-lineCur.ulNameStart] = _pCurBuf[lTmp];
			}
			pszName[lTmp-lineCur.ulNameStart] = 0;

			//if it is the first time, put the banner in.
			if ( _bFirstTime )
			{
				lstrcpy( szBuff, "\ncoclass ");
				lstrcat( szBuff, _pszClassName);
				lstrcat( szBuff, "\n-----------------------------\n" );
				lstrcat( szBuff, "Additions and changes:" );
				WriteLine( _fileDiff, szBuff, -1 );
				_bFirstTime = false;
			}

			//this either has changed, or it's a new line.
			lstrcpy( szBuff, _pszClassName);
			lstrcat( szBuff, " : " );
			lstrcat( szBuff, pszName );
			lstrcat( szBuff, " added");

			WriteLine( _fileDiff, szBuff, -1);

// ferhane: Although this is a change, it does not break COM rules.
//          We need to return a success code but report anyway.            
//			g_ulAppRetVal |= CHANGE_ADDTOCOCLASS;

			delete pszName;
		}
	}

	delete [] szBuff;
}

void CCompareCoClass::FindRemovals()
{
	long lIdx;
	long lTmp;
	LINEINFO	lineRef;
	char* szBuff = new char[128];
	bool bFirstRemoval= true;

	for ( lIdx=0; lIdx< (int)_pRefList->Size(); lIdx++ )
	{
		//get the record
		_pRefList->GetAt( lIdx, &lineRef);

		//is the record marked ?
		if (!lineRef.fUsed)
		{
			//get the real name of the interface
			char* pszName = new char[lineRef.ulNameEnd-lineRef.ulNameStart+1];
			
			for (lTmp=lineRef.ulNameStart; lTmp<(long)lineRef.ulNameEnd; lTmp++)
			{
				pszName[lTmp-lineRef.ulNameStart] = _pRefBuf[lTmp];
			}
			pszName[lTmp-lineRef.ulNameStart] = 0;		//terminate the string

			//if it is the first time, put the banner in.
			if ( _bFirstTime )
			{
				lstrcpy( szBuff, "coclass ");
				lstrcat( szBuff, _pszClassName);
				lstrcat( szBuff, "\n-----------------------------" );
				WriteLine( _fileDiff, szBuff, -1 );
				_bFirstTime = false;
			}

			if ( bFirstRemoval )
			{
				WriteLine( _fileDiff, "Removals:", -1);
				bFirstRemoval = false;
			}

			lstrcpy( szBuff, _pszClassName );
			lstrcat( szBuff, " : ");
			lstrcat( szBuff, pszName );
			lstrcat( szBuff, " has been removed." );
			WriteLine( _fileDiff, szBuff, -1);

			g_ulAppRetVal |= CHANGE_REMOVEFROMCOCLASS;

			delete [] pszName;

			WriteLine( _fileDiff, " ", -1 );
		}
	}

	delete [] szBuff;
}

//
//
//
void CCompareCoClass::CreateLineIndex( CAutoArray<LINEINFO>* pList, char* pBuf)
{
	LINEINFO lineinfo = {0};

	unsigned long ulIdx = 0;
	unsigned long ulLastSpace = 0;	
	char chSearch = '{';			//look for the start of the declaration
	
	while ( pBuf[ulIdx] != 0 )
	{
		if ( pBuf[ulIdx] == chSearch )
		{
			switch (chSearch)
			{
				case '{':
					ulIdx+=2;		//skip over the CR/LF

					//these values are not used and there is no need to use 
					//CPU time to set them.
					//					lineinfo.ulAttrStart = 0;
					//					lineinfo.ulAttrEnd = 0;
					//					lineinfo.ulParamStart=0;
					//					lineinfo.ulParamEnd=0;

					lineinfo.ulNameStart = ulIdx+1;
					chSearch = ';';
					break;

				case ';':
					//finish logging this line
					lineinfo.ulNameEnd = ulIdx;
					pList->Append(lineinfo);

					//prepare for the next line
					ulIdx+=2;
					lineinfo.ulNameStart = ulIdx+1;
					break;
			}
		}
		ulIdx++;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\btools\pdlparse\data.cxx ===
// The names of these strings must correspond to the
// enum CACHED_CAA_STORAGE_STRUCT that is defined in cfpf.hxx
const char *rgszCcssString[]=
{
    "CCSS_EXPAND",
    "CCSS_CUSTOMAPPLY",
    "CCSS_NONE",
    "CCSS_CCHARFORMAT",
    "CCSS_CPARAFORMAT",
    "CCSS_CFANCYFORMAT"
};



// This needs to be ordered by DISPID
CCachedAttrArrayInfo rgCachedAttrArrayInfo[] =
{
    {"STDPROPID_XOBJ_LEFT",                 CCSSF_CLEARFF },
    {"STDPROPID_XOBJ_TOP",                  CCSSF_CLEARFF },
    {"STDPROPID_XOBJ_WIDTH",                CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"STDPROPID_XOBJ_HEIGHT",               CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"STDPROPID_XOBJ_BLOCKALIGN",           CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS },
    {"STDPROPID_XOBJ_CONTROLALIGN",         CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS },
    {"STDPROPID_XOBJ_DISABLED",             CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS },
    {"STDPROPID_XOBJ_RIGHT",                CCSSF_CLEARFF },
    {"STDPROPID_XOBJ_BOTTOM",               CCSSF_CLEARFF },
    {"DISPID_A_WORDSPACING",                CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_VERTICALALIGN",              CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_COLOR",                      CCSSF_CLEARCACHES },
    {"DISPID_A_TEXTTRANSFORM",              CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_NOWRAP",                     CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_LINEHEIGHT",                 CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_TEXTINDENT",                 CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_LETTERSPACING",              CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_OVERFLOW",                   CCSSF_CLEARFF     | CCSSF_SIZECHANGED },
    {"DISPID_A_PADDINGTOP",                 CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS },
    {"DISPID_A_PADDINGRIGHT",               CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS },
    {"DISPID_A_PADDINGBOTTOM",              CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS },
    {"DISPID_A_PADDINGLEFT",                CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS },
    {"DISPID_A_CLEAR",                      CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_FONTFACE",                   CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_TEXTDECORATION",             CCSSF_CLEARCACHES },
    {"DISPID_A_ACCELERATOR",                CCSSF_CLEARCACHES },
    {"DISPID_A_FONTSIZE",                   CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_FONTSTYLE",                  CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_FONTVARIANT",                CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_BASEFONT",                   CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_FONTWEIGHT",                 CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },

    {"DISPID_A_TABLEBORDERCOLOR",           CCSSF_CLEARFF     },
    {"DISPID_A_TABLEBORDERCOLORLIGHT",      CCSSF_CLEARFF     },
    {"DISPID_A_TABLEBORDERCOLORDARK",       CCSSF_CLEARFF     },
    {"DISPID_A_TABLEVALIGN",                CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS },

    {"DISPID_BACKCOLOR",                    CCSSF_CLEARCACHES },
    {"DISPID_A_MARGINTOP",                  CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_MARGINRIGHT",                CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_MARGINBOTTOM",               CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_MARGINLEFT",                 CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },

    {"DISPID_A_FONT",                       CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },

    {"DISPID_A_BORDERTOPCOLOR",             CCSSF_CLEARCACHES },
    {"DISPID_A_BORDERRIGHTCOLOR",           CCSSF_CLEARCACHES },
    {"DISPID_A_BORDERBOTTOMCOLOR",          CCSSF_CLEARCACHES },
    {"DISPID_A_BORDERLEFTCOLOR",            CCSSF_CLEARCACHES },
    {"DISPID_A_BORDERTOPWIDTH",             CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_BORDERRIGHTWIDTH",           CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_BORDERBOTTOMWIDTH",          CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_BORDERLEFTWIDTH",            CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_BORDERTOPSTYLE",             CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_BORDERRIGHTSTYLE",           CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_BORDERBOTTOMSTYLE",          CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_BORDERLEFTSTYLE",            CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },

    {"DISPID_A_FLOAT",                      CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_DISPLAY",                    CCSSF_CLEARCACHES | CCSSF_REMEASUREINPARENT },
    {"DISPID_A_LISTTYPE",                   CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_LISTSTYLETYPE",              CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_LISTSTYLEPOSITION",          CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS | CCSSF_SIZECHANGED },
    {"DISPID_A_LISTSTYLEIMAGE",             CCSSF_CLEARCACHES | CCSSF_SIZECHANGED },
    {"DISPID_A_WHITESPACE",                 CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_VISIBILITY",                 CCSSF_CLEARCACHES },
    {"DISPID_A_POSITION",                   CCSSF_CLEARCACHES | CCSSF_REMEASUREINPARENT },
    {"DISPID_A_ZINDEX",                     CCSSF_CLEARFF     },
    {"DISPID_A_CLIP",                       CCSSF_CLEARFF     },
    {"DISPID_A_CLIPRECTTOP",                CCSSF_CLEARFF     },
    {"DISPID_A_CLIPRECTRIGHT",              CCSSF_CLEARFF     },
    {"DISPID_A_CLIPRECTBOTTOM",             CCSSF_CLEARFF     },
    {"DISPID_A_CLIPRECTLEFT",               CCSSF_CLEARFF     },
    {"DISPID_A_PAGEBREAKBEFORE",            CCSSF_CLEARCACHES },
    {"DISPID_A_PAGEBREAKAFTER",             CCSSF_CLEARCACHES },
    {"DISPID_A_CURSOR",                     CCSSF_CLEARCACHES },
    {"DISPID_A_FILTER",                     CCSSF_CLEARCACHES },
    {"DISPID_A_BACKGROUNDIMAGE",            CCSSF_CLEARCACHES },
    {"DISPID_A_BACKGROUNDPOSX",             CCSSF_CLEARFF     },
    {"DISPID_A_BACKGROUNDPOSY",             CCSSF_CLEARFF     },
    {"DISPID_A_BACKGROUNDREPEAT",           CCSSF_CLEARFF     },
    {"DISPID_A_BACKGROUNDATTACHMENT",       CCSSF_CLEARFF     | CCSSF_SIZECHANGED },
    {"DISPID_A_LANG",                       CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_TABLELAYOUT",                CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
    {"DISPID_A_BORDERCOLLAPSE",             CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },

    {"DISPID_A_BEHAVIOR",                   CCSSF_CLEARCACHES },
    {"DISPID_A_DIR",                        CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_UNICODEBIDI",                CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_DIRECTION",                  CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_RUBYPOSITION",               CCSSF_CLEARCACHES }, 
    {"DISPID_A_IMEMODE",                    CCSSF_NONE }, 
    {"DISPID_A_RUBYALIGN",                  CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_RUBYPOSITION",               CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_RUBYOVERHANG",               CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_LAYOUTGRIDCHAR",             CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_LAYOUTGRIDLINE",             CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_LAYOUTGRIDMODE",             CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_LAYOUTGRIDTYPE",             CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_LAYOUTGRID",                 CCSSF_CLEARCACHES | CCSSF_REMEASURECONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_TEXTAUTOSPACE",              CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_WORDBREAK",                  CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_LINEBREAK",                  CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_TEXTJUSTIFY",                CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_TEXTJUSTIFYTRIM",            CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_TEXTKASHIDA",                CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_OVERFLOWX",                  CCSSF_CLEARFF     | CCSSF_SIZECHANGED },
    {"DISPID_A_OVERFLOWY",                  CCSSF_CLEARFF     | CCSSF_SIZECHANGED },
#ifdef IE6_WYSIWYG_OM
    {"DISPID_A_ROTATE",                     CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS },
#endif
    {"DISPID_A_ZOOM",                       CCSSF_CLEARCACHES | CCSSF_CLEARFF },
    {"DISPID_A_LAYOUTFLOW",                 CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_WORDWRAP",                   CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_TEXTUNDERLINEPOSITION",      CCSSF_CLEARCACHES }, 
    {"DISPID_A_WRAP",                       CCSSF_REMEASURECONTENTS | CCSSF_REMEASUREINPARENT },
    {"DISPID_A_VIEW",                       CCSSF_CLEARCACHES | CCSSF_REMEASUREINPARENT },
    {"DISPID_A_EDITABLE",                   CCSSF_CLEARCACHES },
    {"DISPID_A_SCROLLBARBASECOLOR",         CCSSF_CLEARCACHES },
    {"DISPID_A_SCROLLBARTRACKCOLOR",        CCSSF_CLEARCACHES },
    {"DISPID_A_SCROLLBARFACECOLOR",         CCSSF_CLEARCACHES },
    {"DISPID_A_SCROLLBAR3DLIGHTCOLOR",      CCSSF_CLEARCACHES },
    {"DISPID_A_SCROLLBARSHADOWCOLOR",       CCSSF_CLEARCACHES },
    {"DISPID_A_SCROLLBARHIGHLIGHTCOLOR",    CCSSF_CLEARCACHES },
    {"DISPID_A_SCROLLBARDARKSHADOWCOLOR",   CCSSF_CLEARCACHES },
    {"DISPID_A_SCROLLBARARROWCOLOR",        CCSSF_CLEARCACHES },
    {"DISPID_A_WRITINGMODE",                CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED },
    {"DISPID_A_FROZEN",                     CCSSF_CLEARCACHES },     
    {"DISPID_A_VIEWINHERITSTYLE",           CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED},
    {"DISPID_A_TEXTALIGNLAST",              CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_TEXTKASHIDASPACE",           CCSSF_CLEARCACHES | CCSSF_REMEASUREALLCONTENTS | CCSSF_SIZECHANGED }, 
    {"DISPID_A_ALLOWTRANSPARENCY",          CCSSF_CLEARCACHES | CCSSF_SIZECHANGED | CCSSF_REMEASURECONTENTS },
    {"DISPID_A_TEXTOVERFLOW",               CCSSF_CLEARCACHES }, 
    {"DISPID_A_MINHEIGHT",                  CCSSF_CLEARCACHES | CCSSF_SIZECHANGED }, 
    {NULL,                                  CCSSF_NONE },
};

AssociateDataType DataTypes[] =
{
    { "void*",                 "Num" ,      "NUM",          STORAGETYPE_NUMBER},
    { "DWORD",                 "Num" ,      "NUM",          STORAGETYPE_NUMBER},
    { "DISPID",                "Num" ,      "NUM",          STORAGETYPE_NUMBER},
    { "SIZEL*",                "Num" ,      "NUM",          STORAGETYPE_NUMBER},
    { "CStr",                  "String" ,   "CSTR",         STORAGETYPE_STRING},
    { "BSTR",                  "String" ,   "CSTR",         STORAGETYPE_STRING},
    { "long",                  "Num" ,      "NUM",          STORAGETYPE_NUMBER},
    { "int",                   "Num" ,      "NUM",          STORAGETYPE_NUMBER},
    { "short",                 "Num" ,      "NUM",          STORAGETYPE_NUMBER},
    { "char",                  "Num" ,      "NUM",          STORAGETYPE_NUMBER},
    { "enum",                  "Enum" ,     "ENUM",         STORAGETYPE_NUMBER},
    { "ULONG",                 "Num" ,      "NUM",          STORAGETYPE_NUMBER},
    { "CStyleComponent",    "StyleComponent" , "CSTR",          STORAGETYPE_STRING},
    { "CStyle",                "Style" ,    "CSTR",         STORAGETYPE_OTHER},
    { "CColorValue",           "Color" ,    "COLOR",        STORAGETYPE_NUMBER},
    { "CUnitValue",            "UnitValue" , "UNITVALUE",   STORAGETYPE_NUMBER},
    { "VARIANT_BOOL",          "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "OLE_XPOS_PIXELS",       "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "OLE_YPOS_PIXELS",       "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "OLE_XSIZE_PIXELS",      "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "OLE_YSIZE_PIXELS",      "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "OLE_XPOS_HIMETRIC",     "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "OLE_YPOS_HIMETRIC",     "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "OLE_XSIZE_HIMETRIC",    "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "OLE_YSIZE_HIMETRIC",    "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "OLE_XPOS_CONTAINER",    "Float" ,     "FLOAT",       STORAGETYPE_NUMBER},
    { "OLE_YPOS_CONTAINER",    "Float" ,     "FLOAT",       STORAGETYPE_NUMBER},
    { "OLE_XSIZE_CONTAINER",   "Float" ,     "FLOAT",       STORAGETYPE_NUMBER},
    { "OLE_YSIZE_CONTAINER",   "Float" ,     "FLOAT",       STORAGETYPE_NUMBER},
    { "OLE_CANCELBOOL",        "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "OLE_ENABLEDEFAULTBOOL", "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "IDispatch*",            "Object" ,    "OBJECT",      STORAGETYPE_OTHER},
    { "IUnknown*",             "Object"  ,   "OBJECT",      STORAGETYPE_OTHER},
    { "VARIANT",               "Variant"   , "VARIANT",     STORAGETYPE_OTHER},
    { "BYTE",                  "Num" ,       "NUM",         STORAGETYPE_NUMBER},
    { "BOOL",                  "Boolean" ,   "BOOLEAN",     STORAGETYPE_NUMBER},
    { "float",                 "Float" ,     "FLOAT",       STORAGETYPE_NUMBER},
    { "url",                   "Url",        "CSTR",        STORAGETYPE_STRING},
    { "code",                  "Code",       "CSTR",        STORAGETYPE_STRING},
    { NULL,                    NULL ,        NULL,          STORAGETYPE_NUMBER},
};


    //# { ]
    //#   index is argument type
    //#   value is VTS type

Associate vt[] =
{
    { "void*", "VTS_PI4" },
    { "DWORD", "VTS_I4" },
    { "DISPID", "VTS_I4" },
    { "SIZEL*", "VTS_PI4" },
    { "short", "VTS_I2" },
    { "long", "VTS_I4" },
    { "ULONG", "VTS_I4" },
    { "ULONG*", "VTS_PI4" },
    { "int", "VTS_I4" },
    { "float", "VTS_R4" },
    { "double", "VTS_R8" },
    { "CY*", "VTS_CY" },
    { "DATE", "VTS_DATE" },
    { "BSTR", "VTS_BSTR" },
    { "LPCTSTR", "VTS_BSTR" },
    { "IDispatch*", "VTS_DISPATCH" },
    { "SCODE", "VTS_ERROR" },
    { "VARIANT_BOOL", "VTS_BOOL" },
    { "boolean", "VTS_BOOL" },
    { "ERROR", "VTS_ERROR" },
    { "BOOL", "VTS_BOOL" },
    { "VARIANT", "VTS_VARIANT" },
    { "IUnknown*", "VTS_UNKNOWN" },
    { "unsigned char", "VTS_UI1" },
    { "short*", "VTS_PI2" },
    { "long*", "VTS_PI4" },
    { "int*", "VTS_PI4" },
    { "float*", "VTS_PR4" },
    { "double*", "VTS_PR8" },
    { "CY*", "VTS_PCY" },
    { "DATE*", "VTS_PDATE" },
    { "BSTR*", "VTS_PBSTR" },
    { "IDispatch**", "VTS_PDISPATCH" },
    { "SCODE*", "VTS_PERROR" },
    { "VARIANT_BOOL*", "VTS_PBOOL" },
    { "boolean*", "VTS_PBOOL" },
    { "VARIANT*", "VTS_PVARIANT" },
    { "IUnknown**", "VTS_PUNKNOWN" },
    { "unsigned char *", "VTS_PUI1" },
    { "", "VTS_NONE" },
    { "OLE_COLOR", "VTS_COLOR" },
    { "OLE_XPOS_PIXELS", "VTS_XPOS_PIXELS" },
    { "OLE_YPOS_PIXELS", "VTS_YPOS_PIXELS" },
    { "OLE_XSIZE_PIXELS", "VTS_XSIZE_PIXELS" },
    { "OLE_YSIZE_PIXELS", "VTS_YSIZE_PIXELS" },
    { "OLE_XPOS_HIMETRIC", "VTS_XPOS_HIMETRIC" },
    { "OLE_YPOS_HIMETRIC", "VTS_YPOS_HIMETRIC" },
    { "OLE_XSIZE_HIMETRIC", "VTS_XSIZE_HIMETRIC" },
    { "OLE_YSIZE_HIMETRIC", "VTS_YSIZE_HIMETRIC" },
    { "OLE_XPOS_CONTAINER", "VTS_R4" },
    { "OLE_YPOS_CONTAINER", "VTS_R4" },
    { "OLE_XSIZE_CONTAINER", "VTS_R4" },
    { "OLE_YSIZE_CONTAINER", "VTS_R4" },
    { "OLE_TRISTATE", "VTS_TRISTATE" },
    { "OLE_OPTEXCLUSIVE", "VTS_OPTEXCLUSIVE" },
    { "OLE_COLOR*", "VTS_PCOLOR" },
    { "OLE_XPOS_PIXELS*", "VTS_PXPOS_PIXELS" },
    { "OLE_YPOS_PIXELS*", "VTS_PYPOS_PIXELS" },
    { "OLE_XSIZE_PIXELS*", "VTS_PXSIZE_PIXELS" },
    { "OLE_YSIZE_PIXELS*", "VTS_PYSIZE_PIXELS" },
    { "OLE_XPOS_HIMETRIC*", "VTS_PXPOS_HIMETRIC" },
    { "OLE_YPOS_HIMETRIC*", "VTS_PYPOS_HIMETRIC" },
    { "OLE_XSIZE_HIMETRIC*", "VTS_PXSIZE_HIMETRIC" },
    { "OLE_YSIZE_HIMETRIC*", "VTS_PYSIZE_HIMETRIC" },
    { "OLE_TRISTATE*", "VTS_PTRISTATE" },
    { "OLE_OPTEXCLUSIVE*", "VTS_POPTEXCLUSIVE" },
    { "IFontDispatch*", "VTS_FONT" },
    { "IPictureDispatch*", "VTS_PICTURE" },
    { "OLE_HANDLE", "VTS_HANDLE" },
    { "OLE_HANDLE*", "VTS_PHANDLE" },
    { "BYTE", "VTS_BOOL" },
    // Internal Types
    { "CStr", "VTS_BSTR" },
    { "CUnitValue", "VTS_I4" },
    { "CStyleComponent", "VTS_BSTR" },
    { "CStyle", "VTS_BSTR" },
    { "CColorValue", "VTS_BSTR" },
    { NULL, NULL },
};


TokenDescriptor FileDescriptor =
{
    "file", TRUE,
    {
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor InterfaceDescriptor =
{
    "interface", TRUE,
    {
        {
            "super", FALSE, TRUE    // Mandatory
        },
        {
            "guid", FALSE, FALSE
        },
        {
            "abstract", TRUE, FALSE
        },
        {
            "custom", TRUE, FALSE
        },
        {
            "<noprimary>", TRUE, FALSE  // Not settable from pdl, set internally.
        },
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor EvalDescriptor =
{
    "eval", FALSE,
    {
        {
            "value", FALSE, FALSE
        },
        {
            "string", FALSE, FALSE
        },
        {
            "name", FALSE, FALSE
        },
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor EnumDescriptor =
{
    "enum", TRUE,
    {
        {
            "prefix", FALSE, FALSE
        },
        {
            "guid", FALSE, FALSE
        },
        {
            "hidden", TRUE, FALSE
        },
        END_OF_ARG_ARRAY
    },
};


TokenDescriptor ClassDescriptor =
{
    "class", TRUE,
    {

        {
            "super", FALSE, FALSE
        },
        {
            "primaryinterface", FALSE, FALSE
        },
        {
            "guid", FALSE, FALSE
        },
        {
            "abstract", TRUE, FALSE
        },
        {
            "name", FALSE, FALSE
        },
        {
            "events", FALSE, FALSE
        },
        {
            "cascadedmethods", TRUE, FALSE
        },
        {
            "noaamethods", TRUE, FALSE
        },
        {
            "keepnopersist", TRUE, FALSE
        },
        {
            "noconnectionpoints", TRUE, FALSE
        },
        {
            "control", TRUE, FALSE
        },
        {
            "mondoguid", FALSE, FALSE
        },
        {
            "nonprimaryevents", FALSE, FALSE
        },
        {
            "nonprimaryevents2", FALSE, FALSE
        },
        {
            "nonprimaryevents3", FALSE, FALSE
        },
        {
            "nonprimaryevents4", FALSE, FALSE
        },
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor ImplementsDescriptor =
{
    "implements", FALSE,
    {
        {
            "guid", FALSE, FALSE
        },
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor PropertyDescriptor =
{
    "property", FALSE,
    {
        {
            "atype", FALSE, FALSE
        },
        {
            "dispid", FALSE, FALSE
        },
        {
            "type", FALSE, FALSE
        },
        {
            "member", FALSE, FALSE
        },
        {
            "get", TRUE, FALSE
        },
        {
            "set", TRUE, FALSE
        },
        {
            "bindable", TRUE, FALSE
        },
        {
            "displaybind", TRUE, FALSE
        },
        {
            "dwflags", FALSE, FALSE
        },
        {
            "abstract", TRUE, FALSE
        },
        {
            "ppflags", FALSE, FALSE
        },
        {
            "default", FALSE, FALSE
        },
        {
            "noassigndefault", FALSE, FALSE
        },
        {
            "min", FALSE, FALSE
        },
        {
            "max", FALSE, FALSE
        },
        {
            "method", TRUE, FALSE
        },
        {
            "help", FALSE, FALSE
        },
        {
            "vt", FALSE, FALSE
        },
        {
            "caa", FALSE, FALSE
        },
        {
            "object", FALSE, FALSE
        },
/*  I'm creating bizarre names these out for now because currently JScript cannot deal with
    Properties that have parameters */
        {
            "<<index>>", FALSE, FALSE
        },
        {
            "<<index1>>", FALSE, FALSE
        },
        {
            "<<indextype>>", FALSE, FALSE
        },
        {
            "<<indextype1>>", FALSE, FALSE
        },
        {
            "szattribute", FALSE, FALSE
        },
        {
            "hidden", TRUE, FALSE
        },
        {
            "nonbrowsable", TRUE, FALSE
        },
        {
            "restricted", TRUE, FALSE
        },
        {
            "subobject", FALSE, FALSE
        },
        {
            "param1", FALSE, FALSE
        },
        {
            "precallfn", FALSE, FALSE
        },
        {
            "enumref", FALSE, FALSE
        },
        {
            "virtual", TRUE, FALSE
        },
        {
            "getaa", FALSE, FALSE
        },
        {
            "setaahr", FALSE, FALSE
        },
        {
            "source", TRUE, FALSE
        },
        {
            "minout", TRUE, FALSE
        },
        {
            "<cascaded>", TRUE,FALSE
        },
        {
            "updatecollection", TRUE, FALSE
        },
        {
            "scriptlet", TRUE, FALSE
        },
        {
            "clearcaches", TRUE, FALSE
        },
        {
            "stylesheetproperty", TRUE, FALSE
        },
        {
            "noassigntypeonly", TRUE, FALSE
        },
        {
            "resize", TRUE, FALSE
        },
        {
            "remeasure", TRUE, FALSE
        },
        {
            "remeasureall", TRUE, FALSE
        },
        {
            "siteredraw", TRUE, FALSE
        },
        {
            "set_designtime", TRUE, FALSE
        },
        {
            "invalid=noassigndefault", TRUE, FALSE
        },
        {
            "notpresent=default", TRUE, FALSE
        },
        {
            "contextual", TRUE, FALSE
        },
        {
            "nodecontextual", TRUE, FALSE
        },
        {
            "baseimplementation", TRUE, FALSE
        },
        {
            "nopersist", TRUE, FALSE
        },
        {
            "internal", TRUE, FALSE
        },
        {
            "<refdclass>", TRUE, FALSE
        },
        {
            "maxstrlen", FALSE, FALSE
        },
        {
            "nopropdesc", TRUE, FALSE
        },
        {
            "exclusivetoscript", TRUE, FALSE
        },
        {
            "szInterfaceExpose", TRUE, FALSE
        },
        {
            "dataevent", TRUE, FALSE
        },
        {
            "accessibilitystate", FALSE, FALSE
        },
        {
            "customenum", TRUE, FALSE
        },
        
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor MethodArgDescriptor =
{
    "<methodarg>" /* Implied */, FALSE,
    {
        {
            "atype", FALSE, FALSE
        },
        {
            "type", FALSE, FALSE
        },
        {
            "in", TRUE, FALSE
        },
        {
            "out", TRUE, FALSE
        },
        {
            "arg", FALSE, FALSE
        },
        {
            "retval", FALSE, FALSE
        },
        {
            "defaultvalue", FALSE, FALSE
        },
        {
            "optional", TRUE, FALSE
        },
        END_OF_ARG_ARRAY
    }
};


// These are just the tokens for the method, there is a separate descriptor for a method arg
TokenDescriptor MethodDescriptor =
{
    "method", FALSE,
    {
        {
            "<ReturnType>", FALSE, FALSE // Un-Tagged
        },
        {
            "dispid", FALSE, FALSE
        },
        {
            "abstract", TRUE, FALSE
        },
        {
            "virtual", TRUE, FALSE
        },
        {
            "<RefdToClassFlag>", TRUE, FALSE
        },
        {
            "vararg", TRUE, FALSE
        },
        {
            "cancelable", TRUE, FALSE
        },
        {
            "bubbling", TRUE, FALSE
        },
        {
            "restricted", TRUE, FALSE
        },
        {   
            "contextual", TRUE, FALSE
        },
        {   
            "nodecontextual", TRUE, FALSE
        },
        {   
            "maxstrlen", FALSE, FALSE
        },
        {
            "nopropdesc", TRUE, FALSE
        },
        {
            "exclusivetoscript", TRUE, FALSE
        },
        {
            "szInterfaceExpose", TRUE, FALSE
        },
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor RefPropDescriptor =
{
    "refprop", FALSE,
    {
        {
            "<ClassName>", FALSE, FALSE // Un-Tagged
        },
        {
            "<PropertyName>", FALSE, FALSE // Untagged
        },
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor RefMethodDescriptor =
{
    "refmethod", FALSE,
    {
        {
            "<ClassName>", FALSE, FALSE // Un-Tagged
        },
        {
            "<PropertyName>", FALSE, FALSE // Untagged
        },
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor EventDescriptor =
{
    "event", TRUE,
    {
        {
            "super", FALSE, TRUE    // Mandatory
        },
        {
            "guid", FALSE, FALSE
        },
        {
            "abstract", TRUE, FALSE
        },
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor ImportDescriptor =
{
    "import", TRUE, // import just has a name
    {
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor TearoffDescriptor =
{
    "tearoff", TRUE,
    {
        {
            "interface", FALSE, FALSE
        },
        {
            "BaseImpl", FALSE, FALSE
        },
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor TearoffMethod =
{
    "tearmethod", FALSE,
    {
        {
            "mapto", FALSE, TRUE    // mandatory
        },
        END_OF_ARG_ARRAY
    }
};

TokenDescriptor StructDescriptor =
{
    "struct", TRUE,
    {
        END_OF_ARG_ARRAY
    }
};

TokenDescriptor StructMemberDescriptor =
{
    "member", FALSE,
    {
        {
            "type", FALSE, FALSE
        },
        END_OF_ARG_ARRAY
    }
};


TokenDescriptor *AllDescriptors[ NUM_DESCRIPTOR_TYPES ] =
{
    &FileDescriptor,
    &InterfaceDescriptor,
    &EvalDescriptor,
    &EnumDescriptor,
    &ClassDescriptor,
    &ImplementsDescriptor,
    &PropertyDescriptor,
    &MethodDescriptor,
    &MethodArgDescriptor,
    &RefPropDescriptor,
    &RefMethodDescriptor,
    &EventDescriptor,
    &ImportDescriptor,
    &TearoffDescriptor,
    &TearoffMethod,
    &StructDescriptor,
    &StructMemberDescriptor
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\btools\tldiff\types.h ===
#ifndef types_h
#define types_h 1

//
//  Types of description blocks that can be hit.
//
enum BLOCK_TYPE
{
        BLK_NONE,       //single line information. comments, empty lines, [...] headers
        BLK_DISPINT,    //dispatch interface description block
        BLK_INTERFACE,  //interface description block
        BLK_COCLASS,    //coclass description block
        BLK_TYPEDEF,    //typedef description block
        BLK_ATTR        //attribute block for interface, coclass or typedef
};

//
//  The structure used for block index records.
//
typedef struct {
    BLOCK_TYPE  blockType;
    unsigned long ulStartPos;
    unsigned long ulEndPos;
    unsigned long ulAttrStartPos;
    unsigned long ulAttrEndPos;
    bool          fCopied;
}INDEX;

//
// The structure used for making it faster to access and compare 
// data about the methods in an interface.
//
typedef struct {
    unsigned long ulAttrStart;
    unsigned long ulAttrEnd;
    unsigned long ulNameStart;
    unsigned long ulNameEnd;
    unsigned long ulParamStart;
    unsigned long ulParamEnd;
    unsigned long ulMethodNameStart;
    bool          fUsed;
}LINEINFO;

typedef struct {
    unsigned long   ulAttrStart;
    unsigned long   ulAttrLength;
    bool            fUsed;
}ATTRINFO;

typedef struct {
    unsigned long   ulTypeStart;
    unsigned long   ulTypeLength;
    unsigned long   ulNameStart;
    unsigned long   ulNameLength;
    unsigned long   ulParamLength;
    bool            fUsed;
}PARAMINFO;

//
//  lengths of keywords that are used, to ease maintenance
//
#define LEN_DISPINT     13  //dispinterface
#define LEN_INTERFACE   9   //interface
#define LEN_COCLASS     7   //coclass
#define LEN_TYPEDEF     7   //typedef

//
//  Granularity for memory allocation.
//
#define SZ  512


//
//  Return value flags for the application
//
#define CHANGE_ADDINTERFACE         0x00000001  //  A new interface was added 
#define CHANGE_ADDDISPINT           0x00000002  //  A new dispinterface was added
#define CHANGE_ADDCOCLASS           0x00000004  //  A new coclass was added
#define CHANGE_ADDATTRIBUTE         0x00000008  //  A new attribute was added
#define CHANGE_REMOVEFROMINT        0x00000010  //  A method/property was removed from an interface
#define CHANGE_REMOVEFROMDISPINT    0x00000020  //  A method/property was removed from a dispinterface
#define CHANGE_METHODONINT          0x00000040  //  A method/property was added to an interface
#define CHANGE_METHODONDISPINT      0x00000080  //  A method/property was added to an dispinterface
#define CHANGE_PARAMCHANGE          0x00000100  //  A method's parameters were changed.
#define CHANGE_ATTRCHANGE           0x00000200  //  A method's attributes were changed
#define CHANGE_REMOVEFROMCOCLASS    0x00000400  //  An interface was removed from a coclass
#define CHANGE_ADDTOCOCLASS         0x00000800  //  An interface was added to a coclass
#define CHANGE_RETVALCHANGE         0x00001000  //  A  method's return value has been modified
#define CHANGE_BLOCKREMOVED         0x00002000  //  A coclass was removed
#define CHANGE_DUALATTRADDED        0x00004000  //  the attribute 'dual' was added to an interface/dispinterface
#define CHANGE_DUALATTRREMOVED      0x00008000  //  the attribute 'dual' was removed from an interface/dispinterface
#define CHANGE_UUIDHASCHANGED       0x00010000  //  GUID was changed for a coclass or an interface

#endif  // def types_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\btools\pdlparse\main.cxx ===
#include "headers.hxx"

// COM+ shim.  Uncomment below line to build the COM+ shim.
//#define COMPLUS_SHIM

#ifndef X_PDLPARSE_HXX_
#define X_PDLPARSE_HXX_
#include "pdlparse.hxx"
#endif

#ifndef X_DATA_HXX_
#define X_DATA_HXX_
#include "data.hxx"
#endif

#ifndef X_VTABLE_HXX_
#define X_VTABLE_HXX_
#include <vtable.hxx>
#endif

#ifndef X_ASSERT_H_
#define X_ASSERT_H_
#include <assert.h>
#endif

// Win16 needs the old typelibs. Old Typelib can't cope
// with default parameters. So if this flag is set we
// ignore all the default parameters in the PDL files.
// This flag is set based on run-time argument "win16"
BOOL gbWin16Mode = FALSE;


//
// TO deal with the LONG_PTR problem : we need to translate it to different
// automation type for Win32 and Win64
//
BOOL gfWin64 = FALSE;

static 
BOOL
GetALine ( FILE *fp, char *szLineBuffer, int nMaxLen, int &nLenRead );


void PDLError (char *szTextError)
{
    printf ( "PDLParse (0) : error PDL0001: /G  %s", szTextError);
}


BOOL TagArray::CompareTag ( INT nIndex, char *szWith )
{
    if ( szValues [ nIndex ] == NULL )
        return FALSE;
    else
        return _stricmp ( szValues [ nIndex ], szWith ) == 0 ? TRUE : FALSE;
}

char *TagArray::GetTagValue ( INT nIndex )
{
    // If the string is null always return an empty string
    if ( szValues [ nIndex ] == NULL )
        return szEmptyString;
    else
        return szValues [ nIndex ];
}

BOOL TagArray::AddTag ( int iTag, LPCSTR szStr, int nLen )
{
    if ( szValues [ iTag ] )
        delete [] ( szValues [ iTag ] );
    if ( nLen == -1 )
        nLen = strlen ( szStr );
    if ( szStr == NULL )
    {
        szValues [ iTag ] = NULL;
        return TRUE;
    }
    szValues [ iTag ] = new char [ nLen + 1 ];
    if ( !szValues [ iTag ] )
        return FALSE;
    strncpy ( szValues [ iTag ], szStr, nLen );
    szValues [ iTag ][ nLen ] = '\0';
    return TRUE;
}


Token::~Token()
{
    if ( _pChildList )
        _pChildList -> Release();
}

void CTokenListWalker::Reset ( void )
{
    _pCurrentToken = NULL;
    if ( _pszFileName )
        _fInCurrentFile = FALSE;
    else
        _fInCurrentFile = TRUE;
    _fAtEnd = FALSE;
}


UINT CString::Lookup ( Associate *pArray, LPCSTR pStr )
{
    UINT uIndex =0;
    while ( pArray->szKey )
    {
        if ( strcmp ( pArray->szKey, pStr ) == 0 )
        {
            strcpy ( szString, pArray->szValue );
            return uIndex;
        }
        pArray++; uIndex++;
    }
    return (UINT)-1;
}

UINT CString::Lookup ( AssociateDataType *pArray, LPCSTR pStr )
{
    UINT uIndex =0;
    while ( pArray->szKey )
    {
        if ( strcmp ( pArray->szKey, pStr ) == 0 )
        {
            strcpy ( szString, pArray->szValue );
            return uIndex;
        }
        pArray++; uIndex++;
    }
    return (UINT)-1;
}


/* static */
char *TagArray::szEmptyString = "";

BOOL
GetStdInLine ( char *szLineBuffer, int nMaxLen )
{
    int nLenRead,i;
    int nTotalRead = 0;

    do
    {
        if ( !GetALine ( NULL, szLineBuffer+nTotalRead, 
            nMaxLen, nLenRead ) )
        {
            return FALSE;
        }
        nTotalRead += nLenRead;
        for ( i = nTotalRead-1 ; i >= 0 ; i-- )
        {
            if ( !isspace ( szLineBuffer [ i ] ) )
            {
                break;
            }
        }
        if ( i > 0 )
        {
            if ( szLineBuffer [ i ] == '\\' )
            {
                szLineBuffer [ i ] = ' ';
                szLineBuffer [ i+1 ] = '\0';
                // we'll go on to the next line
                nTotalRead = i+1; 
                // Don't break, so we append the next line
            }
            else
            {
                // Regular line
                szLineBuffer [ i+1 ] = '\0';
                nTotalRead = i+1;
                // Not continuing - break so we process this line
                break;
            }
        }
        else
        {
            // Completly blank line - ignore it...
            nTotalRead = 0;
        }
    } while ( nTotalRead < nMaxLen );
    return TRUE;
}

static
BOOL
GetALine (  FILE *fp,char *szLineBuffer, int nMaxLen, int &nLenRead )
{
    nLenRead = 0;
    // Keep reading in data until we blow the buffer size, or hit a real
    // EOL. If we have a trailing \ character, go on to the next line
    if ( fp )
    {
        if ( !fgets ( szLineBuffer, nMaxLen, fp )  )
        {
            return FALSE;
        }
    }
    else
    {
        if ( !gets ( szLineBuffer )  )
        {
            return FALSE;
        }
    }

    nLenRead = strlen ( szLineBuffer );
    if ( szLineBuffer [ 0 ] && szLineBuffer [ nLenRead-1 ] == '\n' )
    {
        szLineBuffer [ --nLenRead ] = '\0';
    }
    return TRUE;
}

Token *CTokenList::FindToken ( char *pTokenName, DESCRIPTOR_TYPE nType )  const
{
    Token *pToken;

    for ( pToken = _pFirstToken ;
        pToken != NULL ; pToken = pToken-> GetNextToken() )
    {
        // Token 0 is always the name
        // Case sensitive match
        if ( strcmp ( pToken->GetTagValue ( 0 ), pTokenName ) == 0 )
        {
            return pToken->GetType() ? pToken : NULL;
        }
    }
    return NULL;
}


Token *CTokenList::AddNewToken ( DESCRIPTOR_TYPE nTokenDescriptor )
{
    Token *pNewToken = new Token ( nTokenDescriptor );

    if ( !pNewToken )
        return NULL;

    if ( !_pFirstToken )
    {
        _pFirstToken = pNewToken;
    }
    else
    {
        _pLastToken->SetNextToken ( pNewToken );
    }
    _pLastToken = pNewToken;
    _uTokens++;
    return pNewToken;
}




/*
 Scan the input file and extract the 4 build arguments
    Do this to be compatible with previous version of mkprop
*/
//--------------------------------------------------
//TODO: Modify this to accept flags for ia64/i386!
//--------------------------------------------------
static
BOOL
ScanBuildFile ( char *szBuildFileName,
    char *szInputFile, 
    char *szOutputFileRoot, 
    char *szPDLFileName, 
    char *szOutputPath )
{
    FILE   *fp = NULL;
    char    szLineBuffer [ MAX_LINE_LEN+1 ]; 
    BOOL    fReturn = FALSE;
    int     nRead;

    fp = fopen ( szBuildFileName, "r" );
    if ( !fp )
    {
        printf ( "Cannot open %s\n", szBuildFileName );
        goto cleanup;
    }
    if ( !GetALine ( fp, szLineBuffer, sizeof ( szLineBuffer ), nRead ) )
    {
        printf ( "Cannot read %s\n", szBuildFileName );
        goto cleanup;
    }

    // Old input file used to support "-<flags>" - which was never used
    // so I just skip them
    if (sscanf ( szLineBuffer, "- %s %s %s",
                     (LPCSTR)szOutputFileRoot,
                     (LPCSTR)szInputFile,
                     (LPCSTR)szOutputPath ) != 3)
    {
        printf ( "Cannot read params from %s\n", szBuildFileName );
        goto cleanup;
    }

    while ( GetALine ( fp, szLineBuffer, sizeof ( szLineBuffer ), nRead ) )
        printf ( "Build file Line:%s\n",szLineBuffer ); 

    strcpy ( szPDLFileName, szInputFile );

    fReturn = TRUE;
    goto cleanup;

cleanup:
    if ( fp )
        fclose ( fp );
    return fReturn;
}

CTokenList::~CTokenList()
{
    Token *pNextToken;
    Token *pToken;
    // Tidy up the list
    for ( pToken = _pFirstToken ; pToken != NULL ; pToken = pNextToken )
    {
        pNextToken = pToken -> _pNextToken;
        delete pToken;
    }
}


Token *CTokenListWalker::GetNext ( void )
{
    Token *pToken;
    while ( pToken = GetNextToken() )
    {
        if ( _pszFileName )
        {
            if ( _pCurrentToken->nType == TYPE_FILE )
            {
                if ( _fInCurrentFile && _pszFileName )
                {
                    _fInCurrentFile = FALSE;
                }
                else
                {
                    _fInCurrentFile = pToken->CompareTag ( FILE_TAG, _pszFileName );
                }
            }
            else if ( _fInCurrentFile )
            {
                break;
            }
        }
        else
        {
            break;
        }
    }
    return pToken;
}

Token *CTokenListWalker::GetNext ( DESCRIPTOR_TYPE Type, LPCSTR pName )
{
    Token *pToken;
    while ( pToken = GetNext() )
    {
        if ( pToken -> nType == Type && 
            ( pName == NULL || _stricmp ( pName, pToken -> GetTagValue ( NAME_TAG ) ) == 0 ) ) 
        {
            return pToken;
        }
    }
    return NULL;
}



Token *Token::AddChildToken ( DESCRIPTOR_TYPE nType )
{
    Token *pNewToken;

    if ( _pChildList == NULL )
    {
        if ( ( _pChildList = new CTokenList() ) == NULL )
        {
            return NULL;
        }
    }

    // Created the new arg token
    if ( ! ( pNewToken = _pChildList->AddNewToken ( nType ) ) )
    {
        return NULL;
    }
    return pNewToken;
}

void Token::CalculateEnumMask ( Token *pParentToken )
{
    INT nValue;
    if ( IsSet ( EVAL_VALUE ) )
    {
        nValue = atoi ( GetTagValue ( EVAL_VALUE ) );
    }
    else
    {
        char szText [ MAX_LINE_LEN+1 ];
        nValue = pParentToken -> nNextEnumValue;
        // Plug the new value into the tag
        sprintf ( szText, "%d", nValue );
        AddTag ( EVAL_VALUE, szText );

    }
    if ( nValue >=0 && nValue < 32 )
    {
        pParentToken -> uEnumMask |= (1 << (UINT)nValue);
    }
    pParentToken -> nNextEnumValue = ++nValue;
}

UINT Token::GetChildTokenCount ( void )
{
    return _pChildList ? _pChildList -> GetTokenCount() : 0;
}

// Helper for building comma sperarated arg lists
// if the arg is set add the corresponding text to
// the arg string
void Token::AddParam ( CString &szArg, INT nTag, LPCSTR szText )
{
    if ( IsSet ( nTag ) )
    {
        if ( szArg [ 0 ] != '\0' )
            szArg += ", ";

        szArg += szText;
    }
}

// Helper for building comma sperarated arg lists
// if the arg is set add the corresponding text to
// the arg string. With the current arg value replacing the %s
// szArg must contain one and only one %s
void Token::AddParamStr ( CString &szArg, INT nTag, LPCSTR szText )
{
    char szTemp [ MAX_LINE_LEN+1 ];
    if ( IsSet ( nTag ) )
    {
        sprintf ( szTemp, (LPCSTR)szText, (LPCSTR)GetTagValue ( nTag ) );
        if ( szArg [ 0 ] != '\0' )
            szArg += ", ";
        szArg += szTemp;
    }
}

void Token::Clone ( Token *pFrom )
{
    UINT i;
    INT nLen;

    for ( i = 0 ; i < MAX_TAGS ; i++ )
    {
        nLen = pFrom -> TagValues.GetInternalValue ( i ) ?  strlen ( pFrom -> TagValues.GetInternalValue ( i ) ) : 0;
        TagValues.AddTag ( i, pFrom -> TagValues.GetInternalValue ( i ), nLen );
    }
    nType = pFrom -> nType;

    // Now clone the child arg list if there is one
    // Implemented an Addref/Release to simplify the process
    if ( _pChildList )
    {
        _pChildList -> Release();
        _pChildList = NULL;
    }
    if ( pFrom -> _pChildList )
    {
        // Point ourselves at the child list & AddRef it
        _pChildList = pFrom -> _pChildList;
        _pChildList -> AddRef();
    }
}


struct METH_PARAMS  {
        BOOL        fOptional;
        BOOL        fDefaultValue;
        CString     szVTParamType;
        CString     szCParamType;
        VARTYPE     vtParam;
};

#define ATYPE_Undefined         0
#define ATYPE_Method            1
#define ATYPE_GetProperty       2
#define ATYPE_SetProperty       4
#define ATYPE_ReturnValue       8
#define ATYPE_ParametersOnly   16

struct DispatchHandler {
    CString     szRawString;
    WORD        invokeType;
    CString     szDispName;
    CString     szVTResult;
    CString     szCResult;
    VARTYPE     vtResult;
    METH_PARAMS params[8];
};


#define MAX_HANDLERS    130
#define MAX_IIDS        330

int             _cHandlers;
DispatchHandler _allHandlers[MAX_HANDLERS];
int             _cIID;
LPSTR           _allIIDs[MAX_IIDS];

#ifdef COMPLUS_SHIM

//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////
//                                    Beginning of COM+ code                                //
//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////


enum CODETYPE {CT_managed, CT_unmanaged, CT_managedNDirect};

typedef void (__stdcall * NDBodyFunc)(FILE *, DispatchHandler *, CODETYPE, int);

#define PARAM_NAME_PREFIX	"param"
#define PARAM_RESULT_PREFIX	"resultParam"


// When we have a setter or getter only we look to see if there were any properties with the same type that supported 
// getting/setting if so use that entry.
BOOL AnyGSHandler(DispatchHandler & handler)
{
    if (handler.invokeType & (ATYPE_GetProperty | ATYPE_SetProperty))
    {
        for (int i = 0; i < _cHandlers; i++)
        {
            if ((_allHandlers[i].invokeType & (ATYPE_GetProperty | ATYPE_SetProperty)) == (ATYPE_GetProperty | ATYPE_SetProperty))
            {
                if (_allHandlers[i].vtResult == handler.vtResult)
                {
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}


LPCSTR ResultType(DispatchHandler *pHandler, CODETYPE codeType, BOOL *pfAllocate)
{
    BOOL	tempBool;

    if (!pfAllocate)
    {
        pfAllocate = &tempBool;
    }
    *pfAllocate = FALSE;

    VARTYPE vtResult = pHandler->vtResult & VT_TYPEMASK;

    if (codeType == CT_managedNDirect)
    {
        if (vtResult == VT_BSTR)
        {
            return "wchar_t*";
        }
        else if (vtResult == VT_DISPATCH || vtResult == VT_UNKNOWN)
        {
            return "unsigned int";
        }
        else if (vtResult == VT_VARIANT)
        {
            return "unsigned int";
        }
        else if (vtResult == VT_BOOL)
        {
            return "short";
        }
        else if (vtResult == VT_I4)
        {
            return "long";
        }
        else if (vtResult == VT_I2)
        {
            return "short";
        }
        else if (pHandler->vtResult == VT_ARRAY)
        {
            return "wchar_t*";			// ***TLL*** COM+: Need something different here for now it's a string.
        }
        else
        {
            return (LPCSTR)pHandler->szCResult;
        }
    }
    else if (codeType == CT_managed)
    {
        if (vtResult != VT_EMPTY)
        {
            if (vtResult == VT_BSTR)
            {
                return "String";
            }
            else if (vtResult == VT_DISPATCH || vtResult == VT_UNKNOWN)
            {
                return "unsigned int";
            }
            else if (vtResult == VT_VARIANT)
            {
                return "Variant";
            }
            else if (vtResult == VT_BOOL)
            {
                return "Boolean";
            }
            else if (vtResult == VT_I4)
            {
                return "long";
            }
            else if (vtResult == VT_I2)
            {
                return "short";
            }
            else if (pHandler->vtResult == VT_ARRAY)
            {
                return "String";			// ***TLL*** COM+: Need something different here for now it's a string.
            }
            else
            {
                LPCSTR pFoundSpace = strchr((LPCSTR)pHandler->szCResult, ' ');
                LPSTR pString;

                if (pFoundSpace)
                {
                    UINT	cLen = pFoundSpace - (LPCSTR)pHandler->szCResult;
                    pString = new char[cLen + 1];
                    if (pString)
                    {
                        *pfAllocate = TRUE;
                        strncpy(pString, (LPCSTR)pHandler->szCResult, cLen);
                        pString[cLen] = '\0';
                        return pString;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return (LPCSTR)pHandler->szCResult;
                }
            }
        }
        else
        {
            return "void";
        }
    }
    else
    {
        return (LPCSTR)pHandler->szCResult;
    }
}


void
OutputParameters(FILE *fpOut, DispatchHandler *pHandler, CODETYPE codeType, int invokeType)
{
    BOOL	fAllocate = FALSE;
    LPCSTR	mappedParamType = ResultType(pHandler, codeType, &fAllocate);

    if (invokeType & ATYPE_GetProperty)
    {
        if (codeType != CT_managed)
        {
            fprintf(fpOut, ", %s* " PARAM_RESULT_PREFIX ")", mappedParamType);
        }
        else
        {
            fprintf(fpOut, ")");
        }
    }
    else if (invokeType & ATYPE_SetProperty)
    {
        fprintf(fpOut, ", %s " PARAM_NAME_PREFIX "1)", mappedParamType);
    }
    else if (invokeType & ATYPE_ReturnValue)
    {
        fprintf(fpOut, "%s ", mappedParamType);
    }
    else
    {
        int j = 0;
        int cArgs = 0;

        if (fAllocate)
        {
            delete [] (LPSTR)mappedParamType;
            fAllocate = FALSE;
        }

        while (pHandler->params[j].szVTParamType.Length())
        {
            VARTYPE vtParam = pHandler->params[j].vtParam & VT_TYPEMASK;

            if (codeType == CT_managedNDirect)
            {
                if (vtParam == VT_BSTR)
                {
                    mappedParamType = "wchar_t*";
                }
                else if (vtParam == VT_DISPATCH || vtParam == VT_UNKNOWN)
                {
                    mappedParamType = "unsigned int";
                }
                else if (vtParam == VT_VARIANT)
                {
                    mappedParamType = "unsigned int";
                }
                else if (vtParam == VT_BOOL)
                {
                    mappedParamType = "short";
                }
                else if (vtParam == VT_I4)
                {
                    mappedParamType = "long";
                }
                else if (vtParam == VT_I2)
                {
                    mappedParamType = "short";
                }
                else if (pHandler->params[j].vtParam == VT_ARRAY)
                {
                    mappedParamType = "wchar_t*";			// ***TLL*** COM+: Need something different here for now it's a string.
                }
                else
                {
                    mappedParamType = (LPCSTR)pHandler->params[j].szCParamType;
                }
            }
            else if (codeType == CT_managed)
            {
                if (vtParam == VT_BSTR)
                {
                    mappedParamType = "String";
                }
                else if (vtParam == VT_DISPATCH || vtParam == VT_UNKNOWN)
                {
                    mappedParamType = "unsigned int";
                }
                else if (vtParam == VT_VARIANT)
                {
                    mappedParamType = "Variant";
                }
                else if (vtParam == VT_BOOL)
                {
                    mappedParamType = "Boolean";
                }
                else if (vtParam == VT_I4)
                {
                    mappedParamType = "long";
                }
                else if (vtParam == VT_I2)
                {
                    mappedParamType = "short";
                }
                else if (pHandler->params[j].vtParam == VT_ARRAY)
                {
                    mappedParamType = "String";			// ***TLL*** COM+: Need something different here for now it's a string.
                }
                else
                {
                    mappedParamType = (LPCSTR)pHandler->params[j].szCParamType;
                }
            }
            else
            {
                mappedParamType = (LPCSTR)pHandler->params[j].szCParamType;
            }

            fprintf (fpOut, ", %s " PARAM_NAME_PREFIX "%i", mappedParamType, j + 1);
            j++;
            cArgs++;
        }

        if (!(invokeType & ATYPE_ParametersOnly))
        {
            if (pHandler->vtResult != VT_EMPTY)
            {
                mappedParamType = ResultType(pHandler, codeType, &fAllocate);
                fprintf(fpOut, ", %s " PARAM_RESULT_PREFIX, mappedParamType);
            }
        }
        
        fprintf(fpOut, ")");
    }

    if (fAllocate)
    {
        delete [] (LPSTR)mappedParamType;
    }
}


void
OutputNDSignature(FILE *fpOut, DispatchHandler *pHandler, LPCSTR pPreHeader, CODETYPE codeType, NDBodyFunc pNDBodyFunc)
{
    BOOL	fSetDone = FALSE;
    int		invokeType = pHandler->invokeType;
    BOOL	fGetAndSet = ((invokeType & ATYPE_GetProperty) && (invokeType & ATYPE_SetProperty));		
    CString	funcName;

    if (!fGetAndSet)
    {
        if (AnyGSHandler(*pHandler))
            return;		
        
        if (codeType == CT_managedNDirect || codeType == CT_unmanaged)
        {
            fprintf(fpOut, "%s NDCP_%s (unsigned int myThis, unsigned int idxIID, unsigned int wVTblOffset", pPreHeader, (LPCSTR)(pHandler->szRawString));
        }
        else if (codeType == CT_managed)
        {
            if (!pNDBodyFunc)
                fprintf(fpOut, "\tstatic ");
            OutputParameters(fpOut, pHandler, codeType, ATYPE_ReturnValue);

            if (pNDBodyFunc)
                fprintf(fpOut, "\nCPThunks::");

            if (pHandler->szRawString[0] == 'G' || pHandler->szRawString[0] == 'S')
            {
                funcName = pHandler->szRawString[0] == 'G' ? "G_" : "S_";

                if (strcmp((LPCSTR)(pHandler->szRawString) + 2, "BSTR") == 0)
                {
                    funcName += "String";
                }
                else if (strcmp((LPCSTR)(pHandler->szRawString) + 2, "VARIANT") == 0)
                {
                    funcName += "Variant";
                }
                else if (strcmp((LPCSTR)(pHandler->szRawString) + 2, "VARIANTBOOL") == 0)
                {
                    funcName += "Boolean";
                }
                else if (strcmp((LPCSTR)(pHandler->szRawString) + 2, "IDispatchp") == 0 ||
                         strcmp((LPCSTR)(pHandler->szRawString) + 2, "IUnknownp") == 0)
                {
                    funcName += "Object";
                }
                else
                {
                    funcName = (LPCSTR)(pHandler->szRawString);
                }
            }
            else
            {
                funcName = (LPCSTR)(pHandler->szRawString);
            }

            fprintf(fpOut, "COMPLUS_%s (unsigned int myThis, unsigned int idxIID, unsigned int wVTblOffset", (LPCSTR)funcName);
            
            invokeType |= (~ATYPE_ReturnValue & ATYPE_ParametersOnly);
        }

        OutputParameters(fpOut, pHandler, codeType, invokeType);

        if (pNDBodyFunc)
        {
            fprintf(fpOut, "\n");

            (*pNDBodyFunc)(fpOut, pHandler, codeType, invokeType);

            fprintf(fpOut, "\n\n");
        }
        else
        {
            fprintf(fpOut, ";\n");
        }
    }
    else
    {
        if (codeType == CT_managed)
        {
            if (strcmp((LPCSTR)(pHandler->szRawString) + 3, "BSTR") == 0)
            {
                funcName = "_String";
            }
            else if (strcmp((LPCSTR)(pHandler->szRawString) + 3, "VARIANT") == 0)
            {
                funcName = "_Variant";
            }
            else if (strcmp((LPCSTR)(pHandler->szRawString) + 3, "VARIANTBOOL") == 0)
            {
                funcName = "_Boolean";
            }
            else
            {
                funcName = (LPCSTR)((pHandler->szRawString)) + 2;
            }
        }
        else
        {
            funcName = pHandler->szRawString;
        }
                
SpitOutAgain:
        if (!fSetDone && (pHandler->invokeType & ATYPE_GetProperty))
        {
            if (codeType == CT_managedNDirect || codeType == CT_unmanaged)
            {
                fprintf(fpOut, "%s NDCP_G%s (unsigned int myThis, unsigned int idxIID, unsigned int wVTblOffset", pPreHeader, (LPCSTR)((pHandler->szRawString)) + 2);
                OutputParameters(fpOut, pHandler, codeType, ATYPE_GetProperty);
            }
            else if (codeType == CT_managed)
            {
                if (!pNDBodyFunc)
                    fprintf(fpOut, "\tstatic ");

                OutputParameters(fpOut, pHandler, codeType, ATYPE_ReturnValue);

                if (pNDBodyFunc)
                    fprintf(fpOut, "\nCPThunks::");

                fprintf(fpOut, "COMPLUS_G%s (unsigned int myThis, unsigned int idxIID, unsigned int wVTblOffset)", (LPCSTR)funcName);
            }

            fSetDone = TRUE;

            if (pNDBodyFunc)
            {
                fprintf(fpOut, "\n");

                (*pNDBodyFunc)(fpOut, pHandler, codeType, ATYPE_GetProperty);

                fprintf(fpOut, "\n\n");
            }
            else
            {
                fprintf(fpOut, ";\n");
            }
            
            goto SpitOutAgain;
        }
        else if (pHandler->invokeType & ATYPE_SetProperty)
        {
            if (codeType == CT_managedNDirect || codeType == CT_unmanaged)
            {
                fprintf(fpOut, "%s NDCP_S%s (unsigned int myThis, unsigned int idxIID, unsigned int wVTblOffset", pPreHeader, (LPCSTR)((pHandler->szRawString)) + 2);
            }
            else if (codeType == CT_managed)
            {
                if (!pNDBodyFunc)
                {
                    fprintf(fpOut, "\tstatic void ");
                }
                else
                {
                    fprintf(fpOut, "void\nCPThunks::");
                }

                fprintf(fpOut, "COMPLUS_S%s (unsigned int myThis, unsigned int idxIID, unsigned int wVTblOffset", (LPCSTR)funcName);
            }

            OutputParameters(fpOut, pHandler, codeType, ATYPE_SetProperty);

            if (pNDBodyFunc)
            {
                fprintf(fpOut, "\n");

                (*pNDBodyFunc)(fpOut, pHandler, codeType, ATYPE_SetProperty);

                fprintf(fpOut, "\n\n");
            }
            else
            {
                fprintf(fpOut, ";\n");
            }
            
        }
    }
}


BOOL GenerateNDirectHeader (LPCSTR pszOutputPath)
{
    char    chNDDefFileName[255];
    FILE   *fpNDDefFile;

    strcpy(chNDDefFileName, pszOutputPath);
    strcat(chNDDefFileName, FILENAME_SEPARATOR_STR "ComPlsND.def");

    fpNDDefFile = fopen(chNDDefFileName, "w");
    if (!fpNDDefFile)
    {
        return FALSE;
    }

    fprintf(fpNDDefFile, "// Trident Def file NDirect functions.\n\n\n");

    // Spit out function signatures for NDirect functions.
    for (int i = 0; i < _cHandlers; i++)
    {
        BOOL	fSetDone = FALSE;
        BOOL	fGetAndSet = ((_allHandlers[i].invokeType & ATYPE_GetProperty) && (_allHandlers[i].invokeType & ATYPE_SetProperty));		

        if (!fGetAndSet)
        {
            if (!AnyGSHandler(_allHandlers[i]))
            {			
                fprintf(fpNDDefFile, "NDCP_%s\t\tPRIVATE\n", (LPCSTR)(_allHandlers[i].szRawString));
            }
        }
        else
        {
SpitOutAgain:
            if (!fSetDone && (_allHandlers[i].invokeType & ATYPE_GetProperty))
            {
                fprintf(fpNDDefFile, "NDCP_G%s\t\tPRIVATE\n", (LPCSTR)((_allHandlers[i].szRawString)) + 2);
                fSetDone = TRUE;		
                goto SpitOutAgain;
            }
            else if (_allHandlers[i].invokeType & ATYPE_SetProperty)
            {
                fprintf(fpNDDefFile, "NDCP_S%s\t\tPRIVATE\n", (LPCSTR)((_allHandlers[i].szRawString)) + 2);
            }
        }

    }

    fclose(fpNDDefFile);

    return TRUE;
}


void GenerateNDBody(FILE *fpOut, DispatchHandler *pHandler, CODETYPE codeType, int invokeType)
{
    fprintf(fpOut, "{\n");

    fprintf(fpOut, "\ttypedef HRESULT (STDMETHODCALLTYPE *OLEVTblPropFunc)(IDispatch *");
    OutputParameters(fpOut, pHandler, codeType, invokeType);
    fprintf(fpOut, ";\n\n");

    fprintf(fpOut, "\tHRESULT\t\t\thr;\n\tIUnknown\t\t*pUnknownInstance;\n\tIDispatch\t\t*pInstance = 0;\n\tVTABLE_ENTRY\t*pVTbl;\n\n");

    fprintf(fpOut, "\tAssert(myThis);\n\n");

    fprintf(fpOut, "\tpUnknownInstance = (IUnknown *)myThis;\n\n");

    fprintf(fpOut, "\tAssert(idxIID <= MAX_IIDS);\n");
    fprintf(fpOut, "\thr = pUnknownInstance->QueryInterface(*_IIDTable[idxIID], (void **)&pInstance);\n");
    fprintf(fpOut, "\tif (hr)\n");
    fprintf(fpOut, "\t\tgoto Cleanup;\n\n");
    fprintf(fpOut, "\tpVTbl = (VTABLE_ENTRY *)(((BYTE *)(*(DWORD_PTR *)pInstance)) + (wVTblOffset*sizeof(VTABLE_ENTRY)/sizeof(DWORD_PTR) + FIRST_VTABLE_OFFSET));\n");

    fprintf(fpOut, "\thr = (*(OLEVTblPropFunc)VTBL_PFN(pVTbl))((IDispatch*) VTBL_THIS(pVTbl,pInstance)");
    if (invokeType & ATYPE_GetProperty)
    {
        fprintf(fpOut, ", resultParam");
    }
    else if (invokeType & ATYPE_SetProperty)
    {
        fprintf(fpOut, ", param1");
    }
    else
    {
        int i = 0;

        while (pHandler->params[i++].szVTParamType.Length())
        {
            fprintf (fpOut, ", param%i", i);
        }

        if (pHandler->vtResult != VT_EMPTY)
        {
            fprintf(fpOut, ", resultParam");
        }
    }
    
    fprintf(fpOut, ");\n\n");

    fprintf(fpOut, "\tpInstance->Release();\n\n");

    fprintf(fpOut, "Cleanup:\n\treturn hr;\n");

    fprintf(fpOut, "}\n");
}


BOOL GenerateNDirectCXX (LPCSTR pszOutputPath)
{
    char    chNDCXXFileName[255];
    FILE   *fpNDCXXFile;

    strcpy(chNDCXXFileName, pszOutputPath);
    strcat(chNDCXXFileName, FILENAME_SEPARATOR_STR "funcND.cpp");

    fpNDCXXFile = fopen(chNDCXXFileName, "w");
    if (!fpNDCXXFile)
    {
        return FALSE;
    }

    fprintf(fpNDCXXFile, "// Trident NDirect functions source file.\n\n\n");

    // Spit out function signatures for NDirect functions.
    for (int i = 0; i < _cHandlers; i++)
    {
        OutputNDSignature(fpNDCXXFile, &(_allHandlers[i]), "STDAPI ", CT_unmanaged, GenerateNDBody);
    }

    fclose(fpNDCXXFile);

    return TRUE;
}


void GenerateManagedThunkBody(FILE *fpOut, DispatchHandler *pHandler, CODETYPE codeType, int invokeType)
{
    CString		szAfterBlock;
    CString		szResult;

    fprintf(fpOut, "{\n");

    fprintf(fpOut, "\tif (myThis)\n");
    fprintf(fpOut, "\t{\n");
    fprintf(fpOut, "\t\tHRESULT\thr;\n");

    // Spit out the getter body.
    if (invokeType & ATYPE_GetProperty)
    {
        if ((pHandler->vtResult & VT_TYPEMASK) == VT_BSTR)
        {
            fprintf(fpOut, "\t\twchar_t\t*bstrString = 0;\n\n");
            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_G_BSTR(myThis, idxIID, wVTblOffset, &bstrString);\n\n");
            fprintf(fpOut, "\t\tString pString = CustomInvoke::BSTRToString(bstrString, 1);\n\n");
            fprintf(fpOut, "\t\treturn pString;\n");

            szAfterBlock = "\treturn 0;\n";
        }
        else if ((pHandler->vtResult & VT_TYPEMASK) == VT_DISPATCH)
        {
            fprintf(fpOut, "\t\tunsigned int\tmyPDispatch = 0;\n\n");
            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_G_IDispatchp(myThis, idxIID, wVTblOffset, &myPDispatch);\n\n");
            fprintf(fpOut, "\t\treturn myPDispatch;\n");

            szAfterBlock = "\treturn 0;\n";
        }
        else if ((pHandler->vtResult & VT_TYPEMASK) == VT_UNKNOWN)
        {
            fprintf(fpOut, "\t\tunsigned int\tmyPUnknown = 0;\n\n");
            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_G_IUnknownp(myThis, idxIID, wVTblOffset, &myPUnknown);\n\n");
            fprintf(fpOut, "\t\treturn myPUnknown;\n");

            szAfterBlock = "\treturn 0;\n";
        }
        else if ((pHandler->vtResult & VT_TYPEMASK) == VT_BOOL)
        {
            fprintf(fpOut, "\t\tshort\tmyCOMBool = 0;\n");
            fprintf(fpOut, "\t\tBoolean\tmyCPBool = 0;\n\n");
            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_G_VARIANTBOOL(myThis, idxIID, wVTblOffset, &myCOMBool);\n\n");
            fprintf(fpOut, "\t\treturn myCPBool;\n");

            szAfterBlock = "\treturn 0;\n";
        }
        else if ((pHandler->vtResult & VT_TYPEMASK) == VT_VARIANT)
        {
//
// COM+ Need to fix dispatch getter to return this as unsigned int and have the actual COM+ function create the
//      COM+ Variant.
//
            fprintf(fpOut, "\t\tunsigned int myPDispatch;\n");
            fprintf(fpOut, "\t\tVariant myVariant;\n");

            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_G_VARIANT(myThis, idxIID, wVTblOffset, &myPDispatch);\n\n");
            fprintf(fpOut, "\t\treturn myVariant;\n");

            szAfterBlock = "\treturn 0;\n";
        }
        else
        {
            if (pHandler->szCResult == "LONG")
            {
                szResult = "long";
            }
            else if (pHandler->szCResult == "SHORT")
            {
                szResult = "short";
            }
            else
            {
                szResult = pHandler->szCResult;
            }

            fprintf(fpOut, "\t\t%s\treturnValue = 0;\n\n", (LPCSTR)szResult);
            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_G_%s(myThis, idxIID, wVTblOffset, &returnValue);\n\n", (LPCSTR)szResult);
            fprintf(fpOut, "\t\treturn returnValue;\n");

            szAfterBlock = "\treturn 0;\n";
        }
    }

    // Spit out the setter body.
    if (invokeType & ATYPE_SetProperty)
    {
        if ((pHandler->vtResult & VT_TYPEMASK) == VT_BSTR)
        {
            fprintf(fpOut, "\t\twchar_t\t*bstrString = 0;\n\n");
            fprintf(fpOut, "\t\tbstrString = CustomInvoke::StringToBSTR(param1);\n");
            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_S_BSTR(myThis, idxIID, wVTblOffset, bstrString);\n\n");
            fprintf(fpOut, "\t\tCustomInvoke::SysFreeString(bstrString);\n");
        }
        else if ((pHandler->vtResult & VT_TYPEMASK) == VT_DISPATCH)
        {
            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_S_IDispatchp(myThis, idxIID, wVTblOffset, param1);\n\n");
        }
        else if ((pHandler->vtResult & VT_TYPEMASK) == VT_UNKNOWN)
        {
            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_S_IUnknownpp(myThis, idxIID, wVTblOffset, param1);\n\n");
        }
        else if ((pHandler->vtResult & VT_TYPEMASK) == VT_VARIANT)
        {
            fprintf(fpOut, "\t\tunsigned myCOMVariant = 0;\n\n");
            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_S_VARIANT(myThis, idxIID, wVTblOffset, myCOMVariant);\n\n");
        }
        else if ((pHandler->vtResult & VT_TYPEMASK) == VT_BOOL)
        {
            fprintf(fpOut, "\t\tshort myCOMBool = 0;\n\n");
            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_S_VARIANTBOOL(myThis, idxIID, wVTblOffset, myCOMBool);\n\n");
        }
        else
        {
            if (pHandler->szCResult == "LONG")
            {
                szResult = "long";
            }
            else if (pHandler->szCResult == "SHORT")
            {
                szResult = "short";
            }
            else
            {
                szResult = pHandler->szCResult;
            }

            fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_S_%s(myThis, idxIID, wVTblOffset, param1);\n\n", (LPCSTR)szResult);
        }
    }

    // Spit out the method body.
    if (invokeType & ATYPE_Method)
    {
		// ***TLL*** COM+: Just look for one parameter BSTR
        if (pHandler->params[0].szVTParamType.Length() && !pHandler->params[1].szVTParamType.Length())
		{
			if (pHandler->params[0].vtParam == VT_BSTR)
			{
				fprintf(fpOut, "\t\twchar_t	*bstrString = 0;\n\n");

				fprintf(fpOut, "\t\tbstrString = CustomInvoke::StringToBSTR(param1);\n");
				fprintf(fpOut, "\t\thr = CustomInvoke::NDCP_Method_void_BSTR(myThis, idxIID, wVTblOffset, bstrString);\n\n");

				fprintf(fpOut, "\t\tCustomInvoke::SysFreeString(bstrString);\n");
			}
		}

		//  ***TLL*** COM+: Need to do.
        // If no void result then return 0 for now.
        if ((pHandler->vtResult & VT_TYPEMASK) != VT_EMPTY)
            szAfterBlock = "\treturn 0;\n";
    }	
    
    fprintf(fpOut, "\t}\n");

    fprintf(fpOut, (LPCSTR)szAfterBlock);

    fprintf(fpOut, "}\n");
}


BOOL GenerateComPlusHeader (LPCSTR pszOutputPath)
{
    char    chCPHeaderFileName[255];
    FILE   *fpCPHeaderFile;
    int     i;

    strcpy(chCPHeaderFileName, pszOutputPath);
    strcat(chCPHeaderFileName, FILENAME_SEPARATOR_STR "TComPlus.hxx");

    fpCPHeaderFile = fopen(chCPHeaderFileName, "w");
    if (!fpCPHeaderFile)
    {
        return FALSE;
    }

    fprintf(fpCPHeaderFile, "// Trident COM+ Header file.\n\n\n");

    fprintf(fpCPHeaderFile, "[managed,coclass] class CustomInvoke {\n");
    fprintf(fpCPHeaderFile, "public:\n");
    fprintf(fpCPHeaderFile, "\t// Function signatures:\n");


    // Spit out COM+ NDirect signatures
    for (i = 0; i < _cHandlers; i++)
    {
        OutputNDSignature(fpCPHeaderFile, &(_allHandlers[i]), "\t[sysimport(dll=\"mshtml.dll\")]\n\tstatic HRESULT ", CT_managedNDirect, NULL);
    }

    fprintf(fpCPHeaderFile, "\n");

    // Output misc. conversion routines:
    fprintf(fpCPHeaderFile, "\t// Conversion routines:\n");
    fprintf(fpCPHeaderFile, "\tstatic String BSTRToString(wchar_t* myBSTR, int fFreeBSTR);\n");
    fprintf(fpCPHeaderFile, "\tstatic wchar_t* StringToBSTR(String myString);\n");
    fprintf(fpCPHeaderFile, "\tstatic unsigned int VariantToVARIANT(Variant myVariant);\n");
    fprintf(fpCPHeaderFile, "\tstatic void VariantClear(unsigned int myCOMVariant);\n\n");
    fprintf(fpCPHeaderFile, "\t// Misc BSTR routines:\n");
    fprintf(fpCPHeaderFile, "\t[sysimport(dll=\"oleaut32.dll\")]\n");
    fprintf(fpCPHeaderFile, "\tstatic wchar_t* SysAllocStringLen(wchar_t *pch, unsigned int cch);\n\n");
    fprintf(fpCPHeaderFile, "\t[sysimport(dll=\"oleaut32.dll\")]\n");
    fprintf(fpCPHeaderFile, "\tstatic void SysFreeString(wchar_t *myBSTR);\n\n");
    fprintf(fpCPHeaderFile, "\t// Misc VARIANT routines:\n");
    fprintf(fpCPHeaderFile, "\t[sysimport(dll=\"oleaut32.dll\", name=\"SysAllocStringLen\")]\n");
    fprintf(fpCPHeaderFile, "\tstatic unsigned int AllocVariant(wchar_t *pch, unsigned int cch);\n\n");
    fprintf(fpCPHeaderFile, "\t[sysimport(dll=\"oleaut32.dll\")]\n");
    fprintf(fpCPHeaderFile, "\tstatic void VariantInit(unsigned int);\n\n");
    fprintf(fpCPHeaderFile, "\t[sysimport(dll=\"oleaut32.dll\", name=\"SysFreeString\")]\n");
    fprintf(fpCPHeaderFile, "\tstatic void FreeVariant(wchar_t *myBSTR);\n");

    fprintf(fpCPHeaderFile, "};\n\n");

    fprintf(fpCPHeaderFile, "[managed,coclass] class CPThunks {\n");
    fprintf(fpCPHeaderFile, "public:\n");
    fprintf(fpCPHeaderFile, "\t// Function signatures:\n");

    // Spit out COM+ thunks for each signature type
    for (i = 0; i < _cHandlers; i++)
    {
        OutputNDSignature(fpCPHeaderFile, &(_allHandlers[i]), "", CT_managed, NULL);
    }

    fprintf(fpCPHeaderFile, "};\n\n");

    fclose(fpCPHeaderFile);

    return TRUE;
}


BOOL GenerateComPlusCXX (LPCSTR pszOutputPath)
{
    char    chCPCXXFileName[255];
    FILE   *fpCPCXXFile;

    strcpy(chCPCXXFileName, pszOutputPath);
    strcat(chCPCXXFileName, FILENAME_SEPARATOR_STR "TComPlus.cpp");

    fpCPCXXFile = fopen(chCPCXXFileName, "w");
    if (!fpCPCXXFile)
    {
        return FALSE;
    }

    fprintf(fpCPCXXFile, "// Trident COM+ source file.\n\n\n");

    fprintf(fpCPCXXFile, "#import <mscorlib.dll>\n");
    fprintf(fpCPCXXFile, "#include <crt.h>\n");
    fprintf(fpCPCXXFile, "#include \"TComPlus.hxx\"\n\n\n");

    // Spit out COM+ thunks for each signature type
    for (int i = 0; i < _cHandlers; i++)
    {
        OutputNDSignature(fpCPCXXFile, &(_allHandlers[i]), "", CT_managed, GenerateManagedThunkBody);
    }

    // Output conversion routines:
    fprintf(fpCPCXXFile, "\n\n");
    fprintf(fpCPCXXFile, "//////////////////////////////////////////////////////////////////////////\n");
    fprintf(fpCPCXXFile, "//////////////////////////////////////////////////////////////////////////\n");
    fprintf(fpCPCXXFile, "//																		//\n");
    fprintf(fpCPCXXFile, "//																		//\n");
    fprintf(fpCPCXXFile, "//	Conversion routines:												//\n");
    fprintf(fpCPCXXFile, "//																		//\n");
    fprintf(fpCPCXXFile, "//																		//\n");
    fprintf(fpCPCXXFile, "//////////////////////////////////////////////////////////////////////////\n");
    fprintf(fpCPCXXFile, "//////////////////////////////////////////////////////////////////////////\n\n\n");

    fprintf(fpCPCXXFile, "String\n");
    fprintf(fpCPCXXFile, "CustomInvoke::BSTRToString(wchar_t *myBSTR, int fFreeBSTR)\n");
    fprintf(fpCPCXXFile, "{\n");
    fprintf(fpCPCXXFile, "\tString pString(\"\");\n\n");
    fprintf(fpCPCXXFile, "\tif (myBSTR)\n");
    fprintf(fpCPCXXFile, "\t{\n");
    fprintf(fpCPCXXFile, "\t\tpString = Interop.PInvoke.PtrToStringAuto((int)myBSTR);\n");
    fprintf(fpCPCXXFile, "\t\tif (fFreeBSTR)\n");
    fprintf(fpCPCXXFile, "\t\t{\n");
    fprintf(fpCPCXXFile, "\t\t\tSysFreeString(myBSTR);\n");
    fprintf(fpCPCXXFile, "\t\t}\n");
    fprintf(fpCPCXXFile, "\t}\n\n");
    fprintf(fpCPCXXFile, "\treturn pString;\n");
    fprintf(fpCPCXXFile, "}\n\n\n");


    fprintf(fpCPCXXFile, "wchar_t*\n");
    fprintf(fpCPCXXFile, "CustomInvoke::StringToBSTR(String myString)\n");
    fprintf(fpCPCXXFile, "{\n");
    fprintf(fpCPCXXFile, "\twchar_t *myBSTR = 0;\n");
    fprintf(fpCPCXXFile, "\tint	cch;\n\n");

    fprintf(fpCPCXXFile, "\tcch = myString.GetLength();\n");
    
    fprintf(fpCPCXXFile, "\tmyBSTR = CustomInvoke::SysAllocStringLen(0, cch);\n");
    fprintf(fpCPCXXFile, "\tif (myBSTR)\n");
    fprintf(fpCPCXXFile, "\t{\n");
    fprintf(fpCPCXXFile, "\t\tunsigned int	i = 0;\n\n");

    fprintf(fpCPCXXFile, "\t\twhile (cch-- > 0)\n");
    fprintf(fpCPCXXFile, "\t\t{\n");
    fprintf(fpCPCXXFile, "\t\t\t*(myBSTR + i) = myString.GetChar(i);\n");
    fprintf(fpCPCXXFile, "\t\t\ti++;\n");
    fprintf(fpCPCXXFile, "\t\t};\n");
    fprintf(fpCPCXXFile, "\t}\n\n");

    fprintf(fpCPCXXFile, "\treturn myBSTR;\n");
    fprintf(fpCPCXXFile, "}\n\n");

    fprintf(fpCPCXXFile, "unsigned int\n");
    fprintf(fpCPCXXFile, "CustomInvoke::VariantToVARIANT(Variant myVariant)\n");
    fprintf(fpCPCXXFile, "{\n");
    fprintf(fpCPCXXFile, "\treturn 0;\n");
    fprintf(fpCPCXXFile, "}\n\n");

    fprintf(fpCPCXXFile, "void\n");
    fprintf(fpCPCXXFile, "CustomInvoke::VariantClear(unsigned int myCOMVariant)\n");
    fprintf(fpCPCXXFile, "{\n");
    fprintf(fpCPCXXFile, "\n\n");
    fprintf(fpCPCXXFile, "}\n\n");

    // Close file.
    fclose(fpCPCXXFile);

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////
//                                     End of COM+ code                                     //
//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////


#endif // COMPLUS_SHIM


BOOL GenerateVTableHeader  ( LPCSTR pszOutputPath )
{
    char    chHeaderFileName[255];
    FILE   *fpHeaderFile;
    int     i;

    strcpy(chHeaderFileName, pszOutputPath);
    strcat(chHeaderFileName, FILENAME_SEPARATOR_STR "funcsig.hxx");

    fpHeaderFile = fopen ( chHeaderFileName, "w" );
    if ( !fpHeaderFile )
    {
        return FALSE;
    }

    fprintf ( fpHeaderFile, "BOOL DispNonDualDIID(IID iid);\n" );

    fprintf ( fpHeaderFile, "typedef HRESULT (*CustomHandler)(CBase *pBase,\n" );
    fprintf ( fpHeaderFile, "                                 IServiceProvider *pSrvProvider,\n" );
    fprintf ( fpHeaderFile, "                                 IDispatch *pInstance,\n" );
    fprintf ( fpHeaderFile, "                                 WORD wVTblOffset,\n" );
    fprintf ( fpHeaderFile, "                                 PROPERTYDESC_BASIC_ABSTRACT *pDesc,\n" );
    fprintf ( fpHeaderFile, "                                 WORD wFlags,\n" );
    fprintf ( fpHeaderFile, "                                 DISPPARAMS *pdispparams,\n" );
    fprintf ( fpHeaderFile, "                                 VARIANT *pvarResult);\n\n\n" );

    // Spit out function signatures for handlers.
    for (i = 0; i < _cHandlers; i++)
    {
        fprintf ( fpHeaderFile, "HRESULT %s (CBase *pBase,\n", (LPCSTR)(_allHandlers[i].szRawString) );
        fprintf ( fpHeaderFile, "            IServiceProvider *pSrvProvider,\n" );
        fprintf ( fpHeaderFile, "            IDispatch *pInstance,\n" );
        fprintf ( fpHeaderFile, "            WORD wVTblOffset,\n" );
        fprintf ( fpHeaderFile, "            PROPERTYDESC_BASIC_ABSTRACT *pDesc,\n" );
        fprintf ( fpHeaderFile, "            WORD wFlags,\n" );
        fprintf ( fpHeaderFile, "            DISPPARAMS *pdispparams,\n" );
        fprintf ( fpHeaderFile, "            VARIANT *pvarResult);\n\n" );
    }

    fprintf ( fpHeaderFile, "\n" );

    // Spit out indexes into handler table.
    for (i = 0; i < _cHandlers; i++)
    {
        fprintf ( fpHeaderFile, "#define \tIDX_%s \t%i\n", (LPCSTR)(_allHandlers[i].szRawString), i );
    }

    fclose ( fpHeaderFile );

    return TRUE;
}


void GenerateFunctionBody ( FILE * fpCXXFile, DispatchHandler *pHandler)
{
    if ((pHandler->invokeType & ATYPE_GetProperty) || (pHandler->invokeType & ATYPE_SetProperty))
    {
        BOOL    fObjectRet = FALSE;
        BOOL    fBSTRParam = FALSE;
        BOOL    fGetAndSet = (pHandler->invokeType & ATYPE_GetProperty) &&
                             (pHandler->invokeType & ATYPE_SetProperty);
        BOOL    fGS_BSTR    = pHandler->szRawString == "GS_BSTR";
        BOOL    fGS_VARIANT = pHandler->szRawString == "GS_VARIANT";
        BOOL    fGS_PropEnum = pHandler->szRawString == "GS_PropEnum";
        char    chIdent[16];

        chIdent[0] = '\0';

        // Does the property muck with an object?
        fObjectRet = ((pHandler->vtResult & VT_TYPEMASK) == VT_UNKNOWN) ||
                      ((pHandler->vtResult & VT_TYPEMASK) == VT_DISPATCH);
        fBSTRParam = ((pHandler->vtResult & VT_TYPEMASK) == VT_BSTR);

        if (pHandler->invokeType & ATYPE_GetProperty)
        {
            fprintf ( fpCXXFile, "    typedef HRESULT (STDMETHODCALLTYPE *OLEVTbl%sPropFunc)(IDispatch *, %s *);\n", fGetAndSet ? "Get" : "", (LPCSTR)pHandler->szCResult );
        }
        if (pHandler->invokeType & ATYPE_SetProperty)
        {
            fprintf ( fpCXXFile, "    typedef HRESULT (STDMETHODCALLTYPE *OLEVTbl%sPropFunc)(IDispatch *, %s);\n", fGetAndSet ? "Set" : "", (LPCSTR)pHandler->szCResult );
        }
        fprintf ( fpCXXFile, "\n" );

        fprintf ( fpCXXFile, "    HRESULT         hr;\n" );

        // Any IDispatch* or IUnknown* arguments?  If so then possible
        // creation of BSTR/object needs to be handled.
        if ((pHandler->invokeType & ATYPE_SetProperty) && (fObjectRet || fBSTRParam || fGS_VARIANT))
        {
            fprintf ( fpCXXFile, "    ULONG   ulAlloc = 0;\n" );
        }

        if (pHandler->invokeType & ATYPE_GetProperty)
        {
            fprintf ( fpCXXFile, "    VTABLE_ENTRY *pVTbl;\n");
        }
        else if (pHandler->invokeType & ATYPE_SetProperty)
        {
            fprintf ( fpCXXFile, "    VTABLE_ENTRY *pVTbl;\n");
        }
        fprintf ( fpCXXFile, "    VARTYPE         argTypes[] = { %s };\n", (LPCSTR)pHandler->szVTResult );

        if (pHandler->invokeType & ATYPE_SetProperty && pHandler->szCResult.Length() > 0)
        {
            fprintf ( fpCXXFile, "    %s    param1;\n", (LPCSTR)pHandler->szCResult );
        }

        fprintf ( fpCXXFile, "\n    Assert(pInstance || pDesc || pdispparams);\n\n" );

        if (pHandler->invokeType & ATYPE_GetProperty)
        {
            fprintf ( fpCXXFile, "    pVTbl = (VTABLE_ENTRY *)(((BYTE *)(*(DWORD_PTR *)pInstance)) + (wVTblOffset*sizeof(VTABLE_ENTRY)/sizeof(DWORD_PTR) + FIRST_VTABLE_OFFSET));\n\n");
        }
        else if (pHandler->invokeType & ATYPE_SetProperty)
        {
            fprintf ( fpCXXFile, "    pVTbl = (VTABLE_ENTRY *)(((BYTE *)(*(DWORD_PTR *)pInstance)) + (wVTblOffset*sizeof(VTABLE_ENTRY)/sizeof(DWORD_PTR) + FIRST_VTABLE_OFFSET));\n\n");
        }

        if ((pHandler->invokeType & ATYPE_GetProperty) && (pHandler->invokeType & ATYPE_SetProperty))
        {
            fprintf ( fpCXXFile, "    if (wFlags & INVOKE_PROPERTYGET)\n" );
            fprintf ( fpCXXFile, "    {\n" );
            strcpy( chIdent, "    " );
        }

        if (pHandler->invokeType & ATYPE_GetProperty)
        {
            if ((pHandler->szCResult.Length() > 0) && (pHandler->vtResult != VT_VARIANT))
            {
                fprintf ( fpCXXFile, "%s    hr = (*(OLEVTbl%sPropFunc)VTBL_PFN(pVTbl))((IDispatch*) VTBL_THIS(pVTbl,pInstance), (%s *)&pvarResult->iVal);\n", chIdent, fGetAndSet ? "Get" : "", (LPCSTR)pHandler->szCResult);
                fprintf ( fpCXXFile, "%s    if (!hr)\n", chIdent );
                fprintf ( fpCXXFile, "%s        V_VT(pvarResult) = argTypes[0];\n", chIdent );
            }
            else
            {
                fprintf ( fpCXXFile, "%s    hr = (*(OLEVTbl%sPropFunc)VTBL_PFN(pVTbl))((IDispatch*)VTBL_THIS(pVTbl, pInstance), pvarResult);\n", chIdent, fGetAndSet ? "Get" : "");
            }
        }

        if ((pHandler->invokeType & ATYPE_GetProperty) && (pHandler->invokeType & ATYPE_SetProperty))
        {
            fprintf ( fpCXXFile, "    }\n" );
            fprintf ( fpCXXFile, "    else\n" );
            fprintf ( fpCXXFile, "    {\n" );
        }

        if (pHandler->invokeType & ATYPE_SetProperty)
        {
            if (pHandler->szCResult.Length() > 0)
            {
                fprintf ( fpCXXFile, "%s     // Convert dispatch params to C params.\n", chIdent );
                fprintf ( fpCXXFile, "%s     hr = DispParamsToCParams(pSrvProvider, pdispparams, ", chIdent);
                if (fObjectRet || fBSTRParam || fGS_VARIANT)
                    fprintf ( fpCXXFile, "&ulAlloc, " );    // Keep track of all allocation.
                else
                    fprintf ( fpCXXFile, "0L, " );

                if (fGS_BSTR || fGS_VARIANT || fGS_PropEnum)
                    fprintf ( fpCXXFile, "((PROPERTYDESC_BASIC_ABSTRACT *)pDesc)->b.wMaxstrlen, " );
                else
                    fprintf ( fpCXXFile, "0, " );
                
                fprintf ( fpCXXFile, "argTypes, &param1, -1);\n" );

                fprintf ( fpCXXFile, "%s     if (hr)\n", chIdent );
                fprintf ( fpCXXFile, "%s         pBase->SetErrorInfo(hr);\n", chIdent );
                fprintf ( fpCXXFile, "%s     else\n", chIdent );
                if (fGetAndSet)
                {
                    fprintf ( fpCXXFile, "%s         hr = (*(OLEVTblSetPropFunc)VTBL_PFN(pVTbl))((IDispatch*)VTBL_THIS(pVTbl,pInstance), (%s)param1);\n", chIdent, (LPCSTR)pHandler->szCResult);
                }
                else
                {
                    fprintf ( fpCXXFile, "%s         hr = (*(OLEVTblPropFunc)VTBL_PFN(pVTbl))((IDispatch*)VTBL_THIS(pVTbl,pInstance), (%s)param1);\n", chIdent, (LPCSTR)pHandler->szCResult);
                }
            }
            else
            {
                fprintf ( fpCXXFile, "%s     hr = (*(OLEVTblPropFunc)VTBL_PFN(pVTbl))((IDispatch*)VTBL_THIS(pVTbl,pInstance), pdispparams[0]);\n", chIdent );
            }
        }

        if ((pHandler->invokeType & ATYPE_GetProperty) && (pHandler->invokeType & ATYPE_SetProperty))
        {
            fprintf ( fpCXXFile, "    }\n" );
        }

        if ((pHandler->invokeType & ATYPE_SetProperty) && (fObjectRet || fBSTRParam || fGS_VARIANT))
        {
            if (fGS_VARIANT)
                fprintf ( fpCXXFile, "    if (ulAlloc)\n" );
            else 
                fprintf ( fpCXXFile, "    if (ulAlloc && param1)\n" );

            if (fObjectRet)
            {
                fprintf ( fpCXXFile, "        param1->Release();\n");
            }
            else if (fBSTRParam)
            {
                fprintf ( fpCXXFile, "        SysFreeString(param1);\n");
            }
            else if (fGS_VARIANT)
            {
                fprintf ( fpCXXFile, "    {\n" );
                fprintf ( fpCXXFile, "        Assert(V_VT(&param1) == VT_BSTR);\n" );
                fprintf ( fpCXXFile, "        SysFreeString(V_BSTR(&param1));\n" );
                fprintf ( fpCXXFile, "    }\n" );
            }
        }

        fprintf ( fpCXXFile, "\n    return hr;\n" );
    }
    else if ( pHandler->invokeType & ATYPE_Method )
    {
        // We've got a method to spit out.
        char    chVARMacro[16];
        int     i;
        BOOL    fParamConvert;
        BOOL    fBSTRParam = FALSE;
        BOOL    fObjectParam = FALSE;
        BOOL    fVariantParam = FALSE;
        int     cArgs;

        if (pHandler->vtResult & VT_BYREF)
        {
            strcpy(chVARMacro, "V_BYREF");
        }
        else
        {
            switch (pHandler->vtResult & VT_TYPEMASK) {
            case VT_EMPTY:
                strcpy(chVARMacro, "");
                break;
            case VT_I2:
                strcpy(chVARMacro, "V_I2");
                break;
            case VT_I4:
                strcpy(chVARMacro, "V_I4");
                break;
            case VT_R4:
                strcpy(chVARMacro, "V_R4");
                break;
            case VT_R8:
                strcpy(chVARMacro, "V_R8");
                break;
            case VT_CY:
                strcpy(chVARMacro, "V_CY");
                break;
            case VT_BSTR:
                strcpy(chVARMacro, "V_BSTR");
                break;
            case VT_DISPATCH:
            case VT_VARIANT:
            case VT_UNKNOWN:
                strcpy(chVARMacro, "V_BYREF");
                break;
            case VT_BOOL:
                strcpy(chVARMacro, "V_BOOL");
                break;
            default:
                strcpy(chVARMacro, "Unsupported");
            }
        }

        fprintf ( fpCXXFile, "    typedef HRESULT (STDMETHODCALLTYPE *MethodOLEVTblFunc)(IDispatch *" );

        i = 0;
        cArgs = 0;
        while ( pHandler->params[i].szVTParamType.Length() )
        {
            fprintf ( fpCXXFile, ", %s", (LPCSTR)pHandler->params[i].szCParamType );
            i++;
            cArgs++;
        }

        if ( pHandler->vtResult != VT_EMPTY )
        {
            fprintf ( fpCXXFile, ", %s", (LPCSTR)pHandler->szCResult );
        }

        fprintf ( fpCXXFile, ");\n\n" );

        fprintf ( fpCXXFile, "    HRESULT               hr;\n" );
        fprintf ( fpCXXFile, "    VTABLE_ENTRY     *pVTbl;\n" );

        fParamConvert = cArgs;

        // Any paramters?
        if (fParamConvert)
        {
            int     iDefIndex;

            fprintf ( fpCXXFile, "    VARTYPE               argTypes[] = {\n" );

            i = 0;
            while ( pHandler->params[i].szVTParamType.Length() )
            {
                fprintf ( fpCXXFile, "                                %s,\n",
                          (LPCSTR)pHandler->params[i].szVTParamType );
                i++;
            }

            fprintf ( fpCXXFile, "                          };\n" );

            i = 0;
            iDefIndex = 0;
            while ( pHandler->params[i].szVTParamType.Length() )
            {
                fBSTRParam |= ((pHandler->params[i].vtParam & VT_TYPEMASK) == VT_BSTR);
                fVariantParam |= ((pHandler->params[i].vtParam & VT_TYPEMASK) == VT_VARIANT);
                fObjectParam |= ((pHandler->params[i].vtParam & VT_TYPEMASK) == VT_UNKNOWN) ||
                                ((pHandler->params[i].vtParam & VT_TYPEMASK) == VT_DISPATCH);

                if (pHandler->params[i].fOptional)
                {
                    if (pHandler->params[i].vtParam == (VT_VARIANT | VT_BYREF))
                    {
                        fprintf ( fpCXXFile, "    CVariant   param%iopt(VT_ERROR);      // optional variant\n", i + 1 );
                        fprintf ( fpCXXFile, "    VARIANT   *param%i = &param%iopt;      // optional arg.\n", i + 1, i + 1 );
                    }
                    else if (pHandler->params[i].vtParam == VT_VARIANT)
                    {
                        fprintf ( fpCXXFile, "    VARIANT    param%i;    // optional arg.\n", i + 1 );
                    }
                    else
                    {
                        // error, only VARIANT and VARIANT * can be optional.
                        PDLError("optional only allowed for VARIANT and VARIANT *");
                        return;
                    }
                }
                else if (pHandler->params[i].fDefaultValue)
                {
                    if (pHandler->params[i].vtParam == VT_BSTR)
                    {
                        fprintf ( fpCXXFile, "    %s    paramDef%i = SysAllocString((TCHAR *)(((PROPERTYDESC_METHOD *)pDesc)->c->defargs[%i]));\n",
                                  (LPCSTR)pHandler->params[i].szCParamType,
                                  i + 1,
                                  iDefIndex );
                        fprintf ( fpCXXFile, "    %s    param%i = paramDef%i;\n",
                                  (LPCSTR)pHandler->params[i].szCParamType,
                                  i + 1,
                                  i + 1);
                    }
                    else
                    {
                        fprintf ( fpCXXFile, "    %s    param%i = (%s)(((PROPERTYDESC_METHOD *)pDesc)->c->defargs[%i]);\n",
                                  (LPCSTR)pHandler->params[i].szCParamType,
                                  i + 1,
                                  (LPCSTR)pHandler->params[i].szCParamType,
                                  iDefIndex );
                    }

                    iDefIndex++;
                }
                else
                {
                    // Non optional variants need conversion if they contain a string that it longer than maxlen
                    fprintf ( fpCXXFile, "    %s    param%i;\n", (LPCSTR)pHandler->params[i].szCParamType, i + 1 );
                }
                i++;
            }

            // Any BSTR or IDispatch* or IUnknown* arguments?  If so then possible
            // creation of BSTR/object needs to be handled.
            if (fBSTRParam || fObjectParam || fVariantParam)
            {
                fprintf ( fpCXXFile, "    ULONG   ulAlloc = 0;\n" );
            }

            fprintf ( fpCXXFile, "\n" );
        }

        i = 0;
        while ( pHandler->params[i].szVTParamType.Length() )
        {
            if ( pHandler->params[i].fOptional &&
                 pHandler->params[i].vtParam == VT_VARIANT )
            {
                fprintf ( fpCXXFile, "    V_VT(&param%i) = VT_ERROR;\n", i + 1 );
            }

            i++;
        };
        fprintf ( fpCXXFile, "\n" );

        fprintf ( fpCXXFile, "    Assert(pInstance || pDesc || pdispparams);\n\n" );
        fprintf ( fpCXXFile, "    pVTbl = (VTABLE_ENTRY*)(((BYTE *)(*(DWORD_PTR *)pInstance)) + wVTblOffset * sizeof(VTABLE_ENTRY)/sizeof(DWORD_PTR) + FIRST_VTABLE_OFFSET);\n\n" );

        if ( pHandler->params[0].vtParam == VT_ARRAY )
        {
            fprintf ( fpCXXFile, "    // Convert dispatch params to safearray.\n" );
            fprintf ( fpCXXFile, "    param1 = DispParamsToSAFEARRAY(pdispparams);\n" );
        }
        else if ( fParamConvert )
        {
            // Any parameters?
            fprintf ( fpCXXFile, "    // Convert dispatch params to C params.\n" );
            fprintf ( fpCXXFile, "    hr = DispParamsToCParams(pSrvProvider, pdispparams, " );
            if (fBSTRParam || fObjectParam || fVariantParam)
                fprintf ( fpCXXFile, "&ulAlloc, " );
            else
                fprintf ( fpCXXFile, "NULL, " );
            
            if (fBSTRParam || fVariantParam)
                fprintf ( fpCXXFile, "((PROPERTYDESC_BASIC_ABSTRACT *)pDesc)->b.wMaxstrlen" );
            else
                fprintf ( fpCXXFile, "0" );

            fprintf ( fpCXXFile, ", argTypes" );
          
            i = 0;
            while ( pHandler->params[i].szVTParamType.Length() )
            {
                fprintf ( fpCXXFile, ", &param%i", i + 1 );
                i++;
            }

            fprintf ( fpCXXFile, ", -1L);\n" );

            fprintf ( fpCXXFile, "    if (hr)\n" );
            fprintf ( fpCXXFile, "    {\n" );
            fprintf ( fpCXXFile, "        pBase->SetErrorInfo(hr);\n" );
            fprintf ( fpCXXFile, "        goto Cleanup;\n" );
            fprintf ( fpCXXFile, "    }\n\n" );
        }

        fprintf ( fpCXXFile, "    hr = (*(MethodOLEVTblFunc)VTBL_PFN(pVTbl))((IDispatch*)VTBL_THIS(pVTbl,pInstance)", chVARMacro );

        i = 0;
        while ( pHandler->params[i].szVTParamType.Length() )
        {
            fprintf ( fpCXXFile, ", param%i", i + 1 );
            i++;
        }

        // Do we have a result type?
        if ( pHandler->vtResult != VT_EMPTY )
        {
            if (((pHandler->vtResult & VT_BYREF) == VT_BYREF) && ((pHandler->vtResult & VT_TYPEMASK) != VT_VARIANT))
            {
                fprintf ( fpCXXFile, ", (%s)(&(pvarResult->pdispVal))", (LPCSTR)pHandler->szCResult );
            }
            else
            {
                fprintf ( fpCXXFile, ", pvarResult" );
            }
        }

        fprintf ( fpCXXFile, ");\n" );

        if (((pHandler->vtResult & VT_BYREF) == VT_BYREF) && ((pHandler->vtResult & VT_TYPEMASK) != VT_VARIANT))
        {
            fprintf ( fpCXXFile, "    if (!hr)\n");
            fprintf ( fpCXXFile, "        V_VT(pvarResult) = (%s) & ~VT_BYREF;\n", (LPCSTR)pHandler->szVTResult );
        }

        if ( pHandler->params[0].vtParam == VT_ARRAY )
        {
            fprintf ( fpCXXFile, "    if (param1)\n" );
            fprintf ( fpCXXFile, "    {\n" );
            fprintf ( fpCXXFile, "        HRESULT hr1 = SafeArrayDestroy(param1);\n" );
            fprintf ( fpCXXFile, "        if (hr1)\n");
            fprintf ( fpCXXFile, "            hr = hr1;\n");
            fprintf ( fpCXXFile, "    }\n" );
        }
        else if ( fParamConvert )
        {
            // Any parameters then we'll need a cleanup routine.
            fprintf ( fpCXXFile, "\nCleanup:\n" );
        }


        // Deallocate any default BSTR parameters.
        i = 0;
        while ( pHandler->params[i].szVTParamType.Length() )
        {
            if (pHandler->params[i].fDefaultValue && pHandler->params[i].vtParam == VT_BSTR)
            {
                fprintf ( fpCXXFile, "    SysFreeString(paramDef%i);\n", i + 1);
            }
            i++;
        }

        if (fBSTRParam || fObjectParam || fVariantParam)
        {
            i = 0;
            while ( pHandler->params[i].szVTParamType.Length() )
            {
                // Variants don't need conversion.
                if ((pHandler->params[i].vtParam & VT_TYPEMASK) == VT_BSTR)
                {
                    fprintf ( fpCXXFile, "    if (ulAlloc & %i)\n",  (1 << i) );
                    fprintf ( fpCXXFile, "        SysFreeString(param%i);\n", i + 1);
                }
                if ((pHandler->params[i].vtParam & VT_TYPEMASK) == VT_UNKNOWN ||
                    (pHandler->params[i].vtParam & VT_TYPEMASK) == VT_DISPATCH)
                {
                    if (!(pHandler->params[i].vtParam & VT_BYREF))
                    {
                        fprintf ( fpCXXFile, "    if ((ulAlloc & %i) && param%i)\n",  (1 << i), i + 1 );
                        fprintf ( fpCXXFile, "        param%i->Release();\n", i + 1);
                    }
                    else
                    {
                        fprintf ( fpCXXFile, "    if ((ulAlloc & %i) && *param%i)\n",  (1 << i), i + 1 );
                        fprintf ( fpCXXFile, "        (*param%i)->Release();\n", i + 1);
                    }
                }
                if ((pHandler->params[i].vtParam & VT_TYPEMASK) == VT_VARIANT)
                {
                    fprintf ( fpCXXFile, "    if (ulAlloc & %i)\n",  (1 << i) );
                    fprintf ( fpCXXFile, "    {\n" );
                    fprintf ( fpCXXFile, "        Assert(V_VT(%sparam%i) == VT_BSTR);\n",
                                        pHandler->params[i].vtParam & VT_BYREF ? "" : "&", i + 1);
                    fprintf ( fpCXXFile, "        SysFreeString(V_BSTR(%sparam%i));\n", 
                                        pHandler->params[i].vtParam & VT_BYREF ? "" : "&", i + 1);
                    fprintf ( fpCXXFile, "    }\n" );
                }
                i++;
            }
        }

        fprintf ( fpCXXFile, "    return hr;\n" );
    }
}


BOOL GenerateVTableCXX  ( LPCSTR pszOutputPath )
{
    char    chCXXFileName[255];
    FILE   *fpCXXFile;
    int     i;

    strcpy(chCXXFileName, pszOutputPath);
    strcat(chCXXFileName, FILENAME_SEPARATOR_STR "funcsig.cxx");

    fpCXXFile = fopen ( chCXXFileName, "w" );
    if ( !fpCXXFile )
    {
        return FALSE;
    }

    //
    // Generate CXX file.
    //

    // Spit out handler table.
    fprintf ( fpCXXFile, "\n\nstatic const CustomHandler  _HandlerTable[] = {\n" );

    for (i = 0; i < _cHandlers; i++)
    {
        fprintf ( fpCXXFile, "   %s,\n", (LPCSTR)(_allHandlers[i].szRawString));
    }

    fprintf ( fpCXXFile, "   NULL\n" );
    fprintf ( fpCXXFile, "};\n\n" );

    // Spit out function signatures for handlers.
    for (i = 0; i < _cHandlers; i++)
    {
        fprintf ( fpCXXFile, "HRESULT %s (CBase *pBase,\n", (LPCSTR)(_allHandlers[i].szRawString) );
        fprintf ( fpCXXFile, "            IServiceProvider *pSrvProvider,\n" );
        fprintf ( fpCXXFile, "            IDispatch *pInstance,\n" );
        fprintf ( fpCXXFile, "            WORD wVTblOffset,\n" );
        fprintf ( fpCXXFile, "            PROPERTYDESC_BASIC_ABSTRACT *pDesc,\n" );
        fprintf ( fpCXXFile, "            WORD wFlags,\n" );
        fprintf ( fpCXXFile, "            DISPPARAMS *pdispparams,\n" );
        fprintf ( fpCXXFile, "            VARIANT *pvarResult)\n" );
        fprintf ( fpCXXFile, "{\n" );

        GenerateFunctionBody ( fpCXXFile, &(_allHandlers[i]) );

        fprintf ( fpCXXFile, "}\n" );
    }

    fprintf ( fpCXXFile, "\n" );

    for (i = 0; i < _cIID; i++)
    {
        fprintf ( fpCXXFile, "EXTERN_C const IID IID_%s;\n", _allIIDs[i] );
    }

    fprintf ( fpCXXFile, "\n\n" );

    fprintf ( fpCXXFile, "#define MAX_IIDS %i\n", _cIID + 1);   // The null entry at index 0.

    fprintf ( fpCXXFile, "static const IID * _IIDTable[MAX_IIDS] = {\n" );
    fprintf ( fpCXXFile, "\tNULL,\n" );     // Index 0 is reserved for primary dispatch interface.
    // Spit out indexes into IID table.
    for (i = 0; i < _cIID; i++)
    {
        fprintf ( fpCXXFile, "\t&IID_%s,\n", _allIIDs[i] );
    }
    fprintf ( fpCXXFile, "};\n");

    fprintf ( fpCXXFile, "\n" );

    // Helper function for mapping DISP_IHTMLxxxxx
    fprintf ( fpCXXFile, "#define DIID_DispBase   0x3050f500\n" );
    fprintf ( fpCXXFile, "#define DIID_DispMax    0x3050f5a0\n" );
    fprintf ( fpCXXFile, "\n" );
    fprintf ( fpCXXFile, "const GUID DIID_Low12Bytes = { 0x00000000, 0x98b5, 0x11cf, { 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b } };\n" );
    fprintf ( fpCXXFile, "\n\n" );
    fprintf ( fpCXXFile, "BOOL DispNonDualDIID(IID iid)\n" );
    fprintf ( fpCXXFile, "{\n" );
    fprintf ( fpCXXFile, "\tBOOL    fRetVal = FALSE;\n" );
    fprintf ( fpCXXFile, "\n" );
    fprintf ( fpCXXFile, "\tif (iid.Data1 >= DIID_DispBase && iid.Data1 <= DIID_DispMax)\n" );
    fprintf ( fpCXXFile, "\t{\n" );
    fprintf ( fpCXXFile, "\t\tfRetVal = memcmp(&iid.Data2,\n" );
    fprintf ( fpCXXFile, "\t\t\t\t&DIID_Low12Bytes.Data2,\n" );
    fprintf ( fpCXXFile, "\t\t\t\tsizeof(IID) - sizeof(DWORD)) == 0;\n" );
    fprintf ( fpCXXFile, "\t}\n" );
    fprintf ( fpCXXFile, "\n" );
    fprintf ( fpCXXFile, "\treturn fRetVal;\n" );
    fprintf ( fpCXXFile, "}\n\n" );

    fclose ( fpCXXFile );

    return TRUE;
}


struct TypeMap {
    char    chType[32];
    char    chAutomationType[32];
    char    chCType[32];
    VARTYPE vtResult;
};

static TypeMap  _mapper[] = {
    { "IDispatchp"          ,   "VT_DISPATCH"               , "IDispatch *"     ,   VT_DISPATCH             },  // Entry 0 is VT_DISPATCH
    { "IDispatchpp"         ,   "VT_DISPATCH | VT_BYREF"    , "IDispatch **"    ,   VT_DISPATCH | VT_BYREF  },  // Entry 1 is VT_DISPATCH | VT_BYREF
    { "DWORD"               ,   "VT_I4"                     , "DWORD"           ,   VT_I4                   },
    { "long"                ,   "VT_I4"                     , "LONG"            ,   VT_I4                   },
    { "LONG"                ,   "VT_I4"                     , "LONG"            ,   VT_I4                   },
    //************************************************************************************************
    // Warning Warning Warning:
    // This only works for abstract properies. To use it for non-abstract property, please modify corresponding Trident code
    //
    { "LONGPTR"             ,   "VT_I4"         , "LONG_PTR"            ,   VT_I4},
    { "LONGPTR"             ,   "VT_I8"         , "LONG_PTR"            ,   VT_I8},
     //
    //************************************************************************************************
    { "short"               ,   "VT_I2"                     , "SHORT"           ,   VT_I2                   },
    { "VARIANT"             ,   "VT_VARIANT"                , "VARIANT"         ,   VT_VARIANT              },
    { "BSTR"                ,   "VT_BSTR"                   , "BSTR"            ,   VT_BSTR                 },
    { "BOOL"                ,   "VT_BOOL"                   , "VARIANT_BOOL"    ,   VT_BOOL                 },
    { "BOOLp"               ,   "VT_BOOL | VT_BYREF"        , "VARIANT_BOOL *"  ,   VT_BOOL | VT_BYREF      },
    { "VARIANTp"            ,   "VT_VARIANT | VT_BYREF"     , "VARIANT *"       ,   VT_VARIANT | VT_BYREF   },
    { "IUnknownp"           ,   "VT_UNKNOWN"                , "IUnknown *"      ,   VT_UNKNOWN              },
    { "IUnknownpp"          ,   "VT_UNKNOWN | VT_BYREF"     , "IUnknown **"     ,   VT_UNKNOWN | VT_BYREF   },
    { "float"               ,   "VT_R4"                     , "float"           ,   VT_R4                   },
    { "longp"               ,   "VT_I4 | VT_BYREF"          , "LONG *"          ,   VT_I4 | VT_BYREF        },
    { "BSTRp"               ,   "VT_BSTR | VT_BYREF"        , "BSTR *"          ,   VT_BSTR | VT_BYREF      },
    { "int"                 ,   "VT_I4"                     , "LONG"            ,   VT_I4                   },
    { "VARIANTBOOL"         ,   "VT_BOOL"                   , "VARIANT_BOOL"    ,   VT_BOOL                 },
    { "VARIANTBOOLp"        ,   "VT_BOOL | VT_BYREF"        , "VARIANT_BOOL *"  ,   VT_BOOL | VT_BYREF      },
    { "SAFEARRAYPVARIANTP"  ,   "VT_ARRAY"                  , "SAFEARRAY *"     ,   VT_ARRAY                },
    { "void"                ,   ""                          , ""                ,   VT_EMPTY                },
    { "PropEnum"            ,   "VT_BSTR"                   , "BSTR"            ,   VT_BSTR                 },  // TODO: Remove and fix.
    { "IHTMLControlElementp",   "VT_DISPATCH"               , "IDispatch *"     ,   VT_DISPATCH             },  // TODO: Not converted to IDispatch
    { "IHTMLElementpp"      ,   "VT_DISPATCH | VT_BYREF"    , "IDispatch **"    ,   VT_DISPATCH | VT_BYREF  },  // TODO: Not converted to IDispatch
    { "IHTMLElementCollectionpp"      ,   "VT_DISPATCH | VT_BYREF"    , "IDispatch **"    ,   VT_DISPATCH | VT_BYREF  },  // TODO: Not converted to IDispatch
    { ""                    ,   ""                          , ""                ,   VT_EMPTY                }
};

BOOL MapTypeToAutomationType (char *pTypeStr, char **ppAutomationType, char **ppCType, VARTYPE *pVTType)
{
    int     i = 0;
    int     win64offset = 0;
    VARTYPE vtTemp;

    if (!pVTType)
        pVTType = &vtTemp;

    if (gfWin64)
        win64offset = 1;
    
    while (_mapper[i].chType[0])
    {
        if (strcmp(_mapper[i].chType, pTypeStr) == 0)
        {
            //
            // special handling for LONGPTR is required since it will be 
            // resolved to two diffferent types depending on arch!
            //
            if (strcmp(_mapper[i].chType, "LONGPTR") == 0)
            {
                i += win64offset;
            }
            
            *ppAutomationType = _mapper[i].chAutomationType;
            *ppCType = _mapper[i].chCType;
            *pVTType = _mapper[i].vtResult;
             return TRUE;
        }

        i++;
    }
    return FALSE;
}


BOOL ProcessDatFile ( LPCSTR pszOutputPath )
{
    char   *buffer;
    FILE   *fpDatFile;
    char    chDatFileName[255];
    char    szTextError[MAX_LINE_LEN+1];
    char   *pATypeStr;
    char   *pCTypeStr;
    int     cLines;

    if ( !pszOutputPath )
        return FALSE;

    strcpy(chDatFileName, pszOutputPath);
    strcat(chDatFileName, FILENAME_SEPARATOR_STR "funcsig.dat");

    fpDatFile = fopen ( chDatFileName, "rb");

    if ( !fpDatFile )
    {
        return FALSE;
    }

    if ( fseek( fpDatFile, 0, SEEK_END ) == 0 )
    {
        fpos_t  pos;

        if ( fgetpos( fpDatFile, &pos ) == 0 )
        {
            int     i = 0;

            buffer = new char[pos];
            if (buffer == NULL)
                return FALSE;

            fseek( fpDatFile, 0, SEEK_SET );

            if ( (unsigned) fread ( buffer, 1, pos, fpDatFile ) != pos )
                return FALSE;

            // Create the header file from the .dat file.
            _cHandlers = buffer[0];     // Number of signatures
            _cHandlers &= 0x000000ff;
            _cIID = buffer[1];          // Number of IIDs
            _cIID &= 0x000000ff;

            if (_cHandlers >= MAX_HANDLERS)
            {
                PDLError("To many handlers increase MAX_HANDLERS\n");
                goto Error;
            }

            if (_cIID >= MAX_IIDS)
            {
                PDLError("To many handlers increase MAX_IIDS\n");
                goto Error;
            }

            i = 4;                      // Skip 4 byte header.
            cLines = 0;
            while ( cLines < _cHandlers )
            {
                char   *pStrWork;
                char   *pStrWork2;
                int     cStr = strlen ( buffer + i );

                // Copy raw function signature.
                _allHandlers[cLines].szRawString = (buffer + i);

                pStrWork = buffer + i;

                // Get type
                pStrWork2 = strchr(pStrWork, '_');
                if (!pStrWork2)
                    goto Error;
                *pStrWork2 = '\0';

                _allHandlers[cLines].invokeType = ATYPE_Undefined;
                if (strchr(pStrWork, 'G'))
                    _allHandlers[cLines].invokeType |= ATYPE_GetProperty;
                if (strchr(pStrWork, 'S'))
                    _allHandlers[cLines].invokeType |= ATYPE_SetProperty;
                if (strchr(pStrWork, 'M'))
                    _allHandlers[cLines].invokeType = ATYPE_Method;

                // Point pass the G, S, GS or Method
                pStrWork = pStrWork2 + 1;

                if (_allHandlers[cLines].invokeType == ATYPE_Method)
                {
                    // Do method parsing:
                    int     iArg;

                    pStrWork2 = strchr(pStrWork, '_');
                    if (!pStrWork2)
                    {
                        PDLError("bad method result");
                        return FALSE;
                    }

                    *pStrWork2 = '\0';

                    // Get result type
                    if (MapTypeToAutomationType(pStrWork, &pATypeStr, &pCTypeStr, &(_allHandlers[cLines].vtResult)))
                    {
                        _allHandlers[cLines].szVTResult = pATypeStr;
                        _allHandlers[cLines].szCResult = pCTypeStr;
                    }
                    else
                    {
                        sprintf(szTextError, "result type '%s' not found.", pStrWork);
                        PDLError(szTextError);
                        return FALSE;
                    }

                    pStrWork = pStrWork2 + 1;

                    // arg parsing:
                    iArg = 0;
                    while (*pStrWork)
                    {
                        pStrWork2 = strchr(pStrWork, '_');
                        if (pStrWork2)
                        {
                            *pStrWork2 = '\0';
                        }

                        // optional argument?
                        _allHandlers[cLines].params[iArg].fOptional = 
                                            (pStrWork[0] == 'o' &&
                                             pStrWork[1] == '0' &&
                                             pStrWork[2] == 'o');
                        _allHandlers[cLines].params[iArg].fDefaultValue = 
                                            (pStrWork[0] == 'o' &&
                                             pStrWork[1] == 'D' &&
                                             pStrWork[2] == 'o');

                        if (_allHandlers[cLines].params[iArg].fOptional ||
                            _allHandlers[cLines].params[iArg].fDefaultValue)
                        {
                            pStrWork += 3;  // Skip o0o or oDo which signals optional (litle o zero little o) or defaultValue.
                        }

                        if (MapTypeToAutomationType(pStrWork, &pATypeStr, &pCTypeStr, &(_allHandlers[cLines].params[iArg].vtParam)))
                        {
                            _allHandlers[cLines].params[iArg].szVTParamType = pATypeStr;
                            _allHandlers[cLines].params[iArg].szCParamType = pCTypeStr;
                        }
                        else
                        {
                            sprintf(szTextError, "argument type '%s' not found.", pStrWork);
                            PDLError(szTextError);
                            return FALSE;
                        }

                        pStrWork += strlen(pStrWork);
                        // More args to parse?
                        if (pStrWork2)
                            pStrWork++;         // Point at next arg.

                        iArg++;
                    }
                }
                else
                {
                    // Do property parsing
                    if (MapTypeToAutomationType(pStrWork, &pATypeStr, &pCTypeStr, &(_allHandlers[cLines].vtResult)))
                    {
                        _allHandlers[cLines].szVTResult = pATypeStr;
                        _allHandlers[cLines].szCResult = pCTypeStr;
                    }
                    else
                    {
                        sprintf(szTextError, "type '%s' not found.", pStrWork);
                        PDLError(szTextError);
                        return FALSE;
                    }
                }

                cLines++;
                i += cStr + 1;
            }

            // Load up the IIDs.
            cLines = 0;
            while ( cLines < _cIID )
            {
                int     cStr = strlen ( buffer + i );

                _allIIDs[cLines] = buffer + i;

                cLines++;
                i += cStr + 1;
            }

            fclose ( fpDatFile );

            return TRUE;
        }
    }

Error:
    return FALSE;
}


int __cdecl
main  ( int argc, char *argv[] )
{
    int nReturnCode;
    char szInputFile [ MAX_PATH+1 ];
    char szOutputFileRoot [ MAX_PATH+1 ];
    char szPDLFileName [ MAX_PATH+1 ];
    char szOutputPath [ MAX_PATH+1 ];
    BOOL fDebugging = FALSE;

    {
    CPDLParser Parser;

    
    // argv[1] is the name of a file containing build args
    // arg1 of this file is the full path/filename of the input file
    // arg2 is the full name of the output file, minus the file extension
    // arg3 is the 8.3 pdl file name
    // arg4 is a log file name
    if ( argc == 5 )
    {
        strcpy ( szInputFile, argv [ 1] );
        strcpy ( szOutputFileRoot, argv [ 2 ] );
        strcpy ( szPDLFileName, argv [ 3 ] );
        strcpy ( szOutputPath, argv [ 4 ] );
        fDebugging = TRUE;
    }
    else if ( argc == 4 && _stricmp( argv[1], "/g") == 0 ||
                           _stricmp( argv[1], "-g") == 0 )
    {
        if (_stricmp(argv[2], "win64") == 0)
        {
            gfWin64 = TRUE;
        }
        else if (_stricmp(argv[2], "i386") ==0)
        {
            gfWin64 = FALSE;
        }
        else
        {
            printf ( "Invalid command line params\n" );
            nReturnCode = 3;
            goto Cleanup;
        }
    
        // Process the funcsig.dat file and produce custsig.hxx file:
        if (!ProcessDatFile ( argv [ 3 ] ))
        {
            nReturnCode = 4;
            goto Cleanup;
        }

        if (!GenerateVTableHeader ( argv [ 3 ] ))
        {
            nReturnCode = 4;
            goto Cleanup;
        }

        if (!GenerateVTableCXX ( argv [ 3 ] ))
        {
            nReturnCode = 4;
            goto Cleanup;
        }

        FILE *fpMaxLenFile = NULL;

        strcpy(szOutputPath, argv [ 3 ]);
        strcat(szOutputPath, FILENAME_SEPARATOR_STR "maxlen.txt");

        fpMaxLenFile = fopen(szOutputPath, "r+");
        if (fpMaxLenFile)
        {
            char chMarker[6];
            strcpy(chMarker, "Const");
            fwrite(chMarker, sizeof(char), 5, fpMaxLenFile);
            fclose(fpMaxLenFile);
        }

#ifdef COMPLUS_SHIM

        if (!GenerateNDirectHeader ( argv [ 3 ] ))
        {
            nReturnCode = 4;
            goto Cleanup;
        }

        if (!GenerateNDirectCXX ( argv [ 3 ] ))
        {
            nReturnCode = 4;
            goto Cleanup;
        }

        if (!GenerateComPlusHeader ( argv [ 3] ))
        {
            nReturnCode = 4;
            goto Cleanup;
        }

        if (!GenerateComPlusCXX ( argv [ 3 ] ))
        {
            nReturnCode = 4;
            goto Cleanup;
        }

#endif    // COMPLUS_SHIM

        nReturnCode = 0;
        goto Cleanup;
    }
    else if ( argc > 1 )
    {
        if ( !ScanBuildFile ( argv[ 1 ],
                              szInputFile,
                              szOutputFileRoot,
                              szPDLFileName,
                              szOutputPath ) )
        {
            printf ( "Cant scan build file\n" );
            nReturnCode = 2;
            goto Cleanup;
        }
    }
    else
    {
        printf ( "Invalid command line params\n" );
        nReturnCode = 3;
        goto Cleanup;
    }

    nReturnCode = Parser.Parse ( szInputFile, szOutputFileRoot, 
        szPDLFileName, szOutputPath, fDebugging  );

    }

Cleanup:
    if ( nReturnCode != 0 )
        printf ( "Error %d building PDL file\n", nReturnCode );
    exit ( nReturnCode );
}

#ifndef X_DATA_CXX_
#define X_DATA_CXX_
#include "data.cxx"
#endif

#ifndef X_ASSOC_CXX_
#define X_ASSOC_CXX_
#include "assoc.cxx"
#endif

#ifndef X_PARSER_CXX_
#define X_PARSER_CXX_
#include "parser.cxx"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\btools\tldiff\tldiff.cxx ===
#include <windows.h>
#include <iostream.h>
#include <iomanip.h>
#include <assert.h>
#include <stdio.h>
#include "array.hxx"
#include "types.h"
#include "icomp.hxx"
#include "CoComp.hxx"
#include "errors.hxx"


//
// PROTOTYPES
//
void WriteLine(HANDLE file, char* pBuff, int nLen);
unsigned long FindEndOfLine(char* pBuff );
BLOCK_TYPE GetBlockType(char* pchData, char* pchTerm );
bool GetBlock(HANDLE file, INDEX* pIdx, char** ppTarget = NULL, unsigned long* pulBlockBase=NULL );
void DisplayError(UINT uError, UINT uLineNum, ostream& out = cerr);
extern void TokenizeAttributes( char* pBuf, unsigned long nCnt, CAutoArray<ATTRINFO>* pList );
extern long CompareAttributeBlock(  char * pRefBuf, CAutoArray<ATTRINFO>* pRefList, char * pCurBuf, 
                                                    CAutoArray<ATTRINFO>* pCurList);
//
// GLOBALS
//
bool fgCoClass;
bool fgInterface;
bool fgDispInterface;
bool fgMethodAttribute;
bool fgMethodParameter;
bool fgInterfaceAttr;
bool fgFlush;

bool fgParamNames;
bool fgParamTypes;
bool fgParamNameCase;
bool fgParamTypeCase;

unsigned long g_ulAppRetVal;
bool g_fWriteToStdOut = false;

char g_szDiffFileName[14] = {0};   // Will contain differences 
char g_szNewFileName[14]  = {0};   // Will contain added interfaces, etc.
char g_szCurFileName[256] = {0};   // Contains tlviewer output for current tlb
char g_szRefFileName[256] = {0};   // Contains tlviewer output for new tlb

char* g_pszMethodAttr = NULL;

#define BUFFER_SIZE(buf) (sizeof(buf)/sizeof(buf[0]))


//
// Test function to test the index structure on the original MSHTML.OUT
// without debugging the system. The mirror file and the original fileCur
// should only be different with their blanks.
//
void CreateTestMirror(HANDLE fileCur, CAutoArray<INDEX>* rgFileIdx)
{
    INDEX    idxTmp;
    char*    pTmp;
    DWORD    dwRead;
    
    HANDLE  fileData = CreateFile("mirror", GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL, NULL);
    
    if (INVALID_HANDLE_VALUE == fileData)
    {
        DisplayError(ERR_OPENINGMIRROR, __LINE__);
        return;
    }
    
    // Write this stuff to a file.
    for (int i = 0; i < rgFileIdx->Size(); i++)
    {
        long nLen;
        
        //get records
        rgFileIdx->GetAt(i, &idxTmp);
        
        nLen = idxTmp.ulEndPos - idxTmp.ulAttrStartPos;

        //allocate memory to read
        pTmp = new char[nLen+1];
        
        if (!pTmp)  // Hopefully will never happen but just in case.
        {
            DisplayError(ERR_OUTOFMEMORY, __LINE__);
            return;
        }
        
        // Read data
        SetFilePointer( (HANDLE)fileCur, idxTmp.ulAttrStartPos, NULL, FILE_BEGIN);
        ReadFile( (HANDLE)fileCur, pTmp, nLen, &dwRead, NULL);
        
        // Terminate string
        pTmp[ nLen ]=0;
        
        // Write to file
        WriteLine(fileData, pTmp, nLen);
        
        // Release mem.
        delete [] pTmp;
    }
    
    CloseHandle(fileData);
}

//
//
//
void MarkAttrChanges(HANDLE fileCur, CAutoArray<INDEX>* rgFileIdx, char* pszDiffFileName)
{
   INDEX   idxTmp1, idxTmp2;
   DWORD   dwRead;
   HANDLE  fileLocal = INVALID_HANDLE_VALUE;
   char   szEntry[160];
   char   szTmp[80];

   // First, add the modified ATTR tags to the difference file.
   if (g_fWriteToStdOut)
   {
       fileLocal = GetStdHandle(STD_OUTPUT_HANDLE);
   }
   else
   {
      fileLocal = CreateFile(pszDiffFileName, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL, NULL);
   }

   if (INVALID_HANDLE_VALUE == fileLocal)
   {
       DisplayError(ERR_OPENINGDIFF, __LINE__);
       return;
   }

   SetFilePointer(fileLocal, 0, NULL, FILE_END);

   // An attribute cannot be the last block in a file, so we
   // can go until size - 1
   for ( int i = 0; i < rgFileIdx->Size() - 1; i++)
   {
      // Get record 
      rgFileIdx->GetAt(i, &idxTmp1);

      // If it is an unmatched attribute, analyze
      if ((!idxTmp1.fCopied) && (idxTmp1.blockType == BLK_ATTR))
      {
         // Get the next block
         rgFileIdx->GetAt(i + 1, &idxTmp2);

         // If the next block is valid and it is matched, then the attributes
         // for it must have changed.
            //
         if ((idxTmp2.blockType != BLK_NONE) && 
            (idxTmp2.fCopied))
         {
            // Take a note of this in the differences file
            lstrcpy(szEntry, "Attributes for ");

            // Read the data
            SetFilePointer((HANDLE)fileCur, idxTmp2.ulStartPos, NULL, FILE_BEGIN);
            ReadFile((HANDLE)fileCur, szTmp, 79, &dwRead, NULL);

            // Add the type and the name of the block here.
            unsigned int j = 0;
            int nSpaceCnt = 0;

            while (j < min(79, dwRead))
            {
               if (szTmp[j] == ' ') 
                  nSpaceCnt++;

               if (nSpaceCnt == 2)
                  break;

               j++;
            }

            if (nSpaceCnt!=2)
               break;

            szTmp[j] = 0;

            lstrcat(szEntry, szTmp);
            lstrcat(szEntry, " changed ");

            WriteLine(fileLocal, szEntry, -1);

            idxTmp1.fCopied = true;
            rgFileIdx->Set(i, idxTmp1);
         }
      }
   }

    // Don't want to close the stdout. Otherwise, write
    // operations go nowhere. We will close stdout
    // at the end of this program.
    //
    if (!g_fWriteToStdOut)
        CloseHandle(fileLocal);
}

//
//
//
void FlushDifferences(HANDLE fileCur, CAutoArray<INDEX>* rgFileIdx)
{
    INDEX   idxTmp;
    DWORD   dwRead;
    char*   pTmp;
    bool    fCheck;
    HANDLE  fileDiff = INVALID_HANDLE_VALUE;

    if (g_fWriteToStdOut)
    {
        fileDiff = GetStdHandle(STD_OUTPUT_HANDLE);
    }
    else
    {
       fileDiff = CreateFile(g_szNewFileName, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL, NULL);
    }

    if (INVALID_HANDLE_VALUE == fileDiff)
    {
        DisplayError(ERR_OPENINGNEW, __LINE__);
        return;
    }
    
    // Write this stuff to a file.
    bool fFirst = true;

    for (int i = 0; i < rgFileIdx->Size(); i++)
    {
        // Get records
        rgFileIdx->GetAt(i, &idxTmp);

        switch ( idxTmp.blockType )
        {
             case BLK_INTERFACE:
                if (!fgInterface)
                   fCheck = false;
                break;

             case BLK_DISPINT:
                if (!fgDispInterface)
                   fCheck = false;
                break;

             case BLK_COCLASS:
                if (!fgCoClass)
                   fCheck = false;

             default:
                fCheck = true;
        }

        if ((!idxTmp.fCopied) && (fCheck))
        {
            // Allocate memory to read
            pTmp = new char[idxTmp.ulEndPos - idxTmp.ulStartPos+1];
         
            // Read data
            SetFilePointer((HANDLE)fileCur, idxTmp.ulStartPos, NULL, FILE_BEGIN);
            ReadFile((HANDLE)fileCur, pTmp, idxTmp.ulEndPos - idxTmp.ulStartPos, &dwRead, NULL);
         
            // Terminate string
            pTmp[idxTmp.ulEndPos - idxTmp.ulStartPos ]=0;
         
            if (fFirst)
            {
                fFirst = false;
            
                // Write out a blank line if writing to stdout
                //
                if (g_fWriteToStdOut)
                    WriteLine(fileDiff, "", -1);
            
                WriteLine(fileDiff, "------------------------------------------", -1);
                WriteLine(fileDiff, "NEW BLOCKS", -1);
                WriteLine(fileDiff, "------------------------------------------", -1);
                WriteLine(fileDiff, "", -1);
            }

            // Write the block
            WriteLine(fileDiff, pTmp, idxTmp.ulEndPos - idxTmp.ulStartPos);
         
            // Put some empty lines after the block to make it easier to read
            WriteLine(fileDiff, "", -1);
         
         // ScotRobe: only want to set g_ulAppRetVal to an error 
         // code if something was changed. We don't want to stop the
         // build process if something was added. Adding is okay,
         // change is bad.
         //
/*       switch (idxTmp.blockType)
         {
            case BLK_INTERFACE:
               ulTmp |= CHANGE_ADDINTERFACE;
               break;

            case BLK_DISPINT:
               ulTmp |= CHANGE_ADDDISPINT;
               break;

            case BLK_COCLASS:
               ulTmp |= CHANGE_ADDCOCLASS;
               break;

            case BLK_ATTR:
               ulTmp |= CHANGE_ADDATTRIBUTE;
               break;

            default:
               break;
         }
*/

            // Release memory.
            delete [] pTmp;
        }
    }

    // Don't want to close the stdout if we are writing to it.
    // Otherwise, write operations go nowhere. We will close
    // stdout at the end of main.
    //
    if (!g_fWriteToStdOut)
        CloseHandle(fileDiff);

    // Uncomment this line if you uncomment the above switch statement.
    //
    //g_ulAppRetVal |= ulTmp;  
}

//----------------------------------------------------------------------------
// Function :  PrepareIndex
// Description :  Prepare the index for a given file by creating an array of
//             INDEX structures.
// Parameters  :  
//       fileCur              : handle of current file
//       CAutoArray<INDEX>*   : pointer to the index array
// 
// Returns     :  void
//----------------------------------------------------------------------------
void PrepareIndex (HANDLE fileCur, CAutoArray<INDEX>* rgFileIdx)
{
    INDEX    idxCurr = {BLK_NONE, 0};
    INDEX    idxAttr;
    
    bool    fContinue = true;
    
    // Create an index for the file that is to be analyzed.
    while (fContinue)
    {
        fContinue = GetBlock(fileCur, &idxCurr);
        
        if (fContinue)
        {
            switch (idxCurr.blockType)
            {
            case BLK_ATTR:
                idxAttr = idxCurr;
                break;
                
            case BLK_DISPINT:
            case BLK_INTERFACE:
            case BLK_COCLASS:
                assert(idxAttr.blockType == BLK_ATTR);
                
                // copy the attribute start and end positions to the current block's
                // index structure.
                idxCurr.ulAttrStartPos = idxAttr.ulStartPos;
                idxCurr.ulAttrEndPos = idxAttr.ulEndPos;
                
                //add the data to the index 
                rgFileIdx->Append(idxCurr);

                // reset
                idxAttr.blockType = BLK_NONE;
                idxAttr.ulStartPos = idxAttr.ulEndPos = 0;
                
                break;

/* LEAVE TYPEDEFs out of this for now, since there are problems with them.
                The end of the typedef block is coded as it should be a semicolon. However, the semicolon could be
                used for anything inside the typedef when the typedef is a structure. This causes a false termination
                of the typedef.
    Solution:
                Find the '}', however, end the block at the end of the line that contains the '}'

            case BLK_TYPEDEF:
                // copy the block as it is. However, for the mirror file use, make sure the
                // attribute information starts and ends with the actual buffer.
                idxCurr.ulAttrStartPos = idxCurr.ulStartPos;
                
                //add the data to the index 
                rgFileIdx->Append(idxCurr);

                // reset
                idxAttr.blockType = BLK_NONE;
                idxAttr.ulStartPos = idxAttr.ulEndPos = 0;
                break;
*/

            }
        }
    }
}

//
//
//
bool 
CompareCoClass( char* pCurBuf, char* pRefBuf, 
               char * pAttrCur, char * pAttrRef, HANDLE fileDiff)
{
    bool                    bRes = true;
    char                    szClassName[64] = {0};
    CCompareCoClass *       pCompareCoClass = NULL;
    CAutoArray<ATTRINFO>*   pCurList = new CAutoArray<ATTRINFO>;
    CAutoArray<ATTRINFO>*   pRefList = new CAutoArray<ATTRINFO>;
    long                    lRes;
    
    // compare the names of the coclasses. The comparison is done until we reach the 
    // end of the longer name
    for ( unsigned long ulIdx = LEN_COCLASS+1; 
    (pCurBuf[ulIdx] != 0x20) || (pRefBuf[ulIdx] != 0x20); 
    ulIdx++ )
    {
        if ( pCurBuf[ulIdx] != pRefBuf[ulIdx] )
            goto Fail;        //if the names don't match, these are not the coclasses that we
        //want to compare.
        
        szClassName[ulIdx-LEN_COCLASS-1] = pCurBuf[ulIdx]; //get the coclass name 
        
        //OVERFLOW check
        assert( ulIdx<64 );              //sanity check to stop a corrupt file from killing us.
        if ( ulIdx==64 )
            goto Fail;
    }
    
    TokenizeAttributes( pAttrRef+1, lstrlen(pAttrRef) - 2, pRefList );
    TokenizeAttributes( pAttrCur+1, lstrlen(pAttrCur) - 2, pCurList );

    lRes = CompareAttributeBlock( pAttrRef+1, pRefList, pAttrCur+1, pCurList);

    if (lRes != 0)
    {
        char    szBuf[MAX_PATH];

        if (lRes == CHANGE_UUIDHASCHANGED)
        {
            sprintf(szBuf, "\nGUID was modified for the coclass %s", szClassName);
        }
        else
        {
            sprintf(szBuf, "\nUnexpected error when comparing attributes for coclass %s", szClassName);
        }

        WriteLine(fileDiff, szBuf, -1);

        g_ulAppRetVal |= CHANGE_BLOCKREMOVED;

        goto Fail;
    }

    pCompareCoClass = new CCompareCoClass( pCurBuf, pRefBuf, fileDiff, szClassName );
    
    pCompareCoClass->FindAdditionsAndChanges();
    pCompareCoClass->FindRemovals();
    
Cleanup:
    if (pCompareCoClass)
        delete pCompareCoClass;
    return bRes;
    
Fail:
    bRes= false;
    goto Cleanup;
}

//
//
//
bool 
CompareInterface( BLOCK_TYPE blockType, char* pCurBuf, char* pRefBuf, 
                      char * pAttrCur, char * pAttrRef, HANDLE fileDiff)
{
    bool                    bRes = true;
    unsigned long           ulNameOffset=0; //offset to start reading for the name of the interface on both blocks.
    char                    szIntName[64] = {0};    //initialize to zero so we don't deal with termination later.
    CCompareInterface *     pCompareInterface = NULL;
    CAutoArray<ATTRINFO>*   pCurList = new CAutoArray<ATTRINFO>;
    CAutoArray<ATTRINFO>*   pRefList = new CAutoArray<ATTRINFO>;
    long                    lRes;

    //assign the offset for the first space
    ulNameOffset = ( blockType==BLK_DISPINT ) ? LEN_DISPINT+1 : LEN_INTERFACE+1;
 
    // The format of the name is: interface/dispinterface_name_{
    // Compare until the space character is reached for either of the names. 
    for (unsigned long ulIdx = ulNameOffset; 
    (pCurBuf[ulIdx] != 0x20) || (pRefBuf[ulIdx] != 0x20); 
    ulIdx++ )
    {
        if ( pCurBuf[ulIdx] != pRefBuf[ulIdx] )
            goto Fail;                     //if the name does not match, this is not 
        //the interface we are looking to compare with
        
        szIntName[ulIdx-ulNameOffset] = pCurBuf[ulIdx]; //get the interface name simultaneously
        
        //OVERFLOW CHECK
        assert( ulIdx<64 );              //sanity check to stop a corrupt file from killing us.
        if ( ulIdx==64 )
            goto Fail;
    }
    
    TokenizeAttributes( pAttrRef+1, lstrlen(pAttrRef) - 2, pRefList );
    TokenizeAttributes( pAttrCur+1, lstrlen(pAttrCur) - 2, pCurList );

    lRes = CompareAttributeBlock( pAttrRef+1, pRefList, pAttrCur+1, pCurList);

    if (lRes != 0)
    {
        char    szBuf[MAX_PATH];

        switch(lRes)
        {
        case CHANGE_DUALATTRADDED:
            sprintf(szBuf, "\nDual attribute was added to the interface %s", szIntName);
            break;

        case CHANGE_DUALATTRREMOVED:
            sprintf(szBuf, "\nDual attribute was removed from the interface %s", szIntName);
            break;

        case CHANGE_UUIDHASCHANGED:
            sprintf(szBuf, "\nIID was changed for the interface %s", szIntName);
            break;

        default:
            break;
        }

        WriteLine(fileDiff, szBuf, -1);

        g_ulAppRetVal |= CHANGE_BLOCKREMOVED;

        goto Fail;
    }

    pCompareInterface = new CCompareInterface(pCurBuf, pRefBuf, fileDiff, szIntName, blockType, g_pszMethodAttr);

    pCompareInterface->FindAdditionsAndChanges();
    pCompareInterface->FindRemovals();
    
Cleanup:
    if ( pCompareInterface )
        delete pCompareInterface;
    return bRes;
    
Fail:
    bRes= false;
    goto Cleanup;
}

//
//
//
bool CompareBlocks(HANDLE fileCur, CAutoArray<INDEX>* rgFileIdx, INDEX* pIdxRef, 
                   char* pRefBuf, char * pAttrRef, HANDLE fileDiff)
{
    INDEX   idxCur  = {BLK_NONE, 0}; // Index record for the current file's block
    char *  pCurBuf = NULL;
    char *  pAttrCur = NULL;
    DWORD   dwRead;
    BOOL    bRes = FALSE;
    int     nRes = 1;
    
    //we have index information about the reference file block
    //use it to narrow down the possibilities
    //
    //walk through the index and find the matching block types
    //with matching lengths.
    for (int i = 0; i < rgFileIdx->Size(); i++)
    {
        rgFileIdx->GetAt(i, &idxCur);
        
        //if the block we read from the reference file matches this
        //block's type 
        if ((idxCur.blockType == pIdxRef->blockType) &&
            (!idxCur.fCopied))
        {
            //read the block from the current file, using the
            //index record
            int nLen = idxCur.ulEndPos - idxCur.ulStartPos;
            pCurBuf = new char[nLen+1];
            
            int nAttrLen = idxCur.ulAttrEndPos - idxCur.ulAttrStartPos;
            pAttrCur = new char[nAttrLen+1];
            
            SetFilePointer((HANDLE)fileCur, idxCur.ulStartPos, NULL, FILE_BEGIN);
            bRes = ReadFile((HANDLE)fileCur, pCurBuf, nLen, &dwRead, NULL);
            
            SetFilePointer((HANDLE)fileCur, idxCur.ulAttrStartPos, NULL, FILE_BEGIN);
            bRes = ReadFile((HANDLE)fileCur, pAttrCur, nAttrLen, &dwRead, NULL);
            
            // Terminate the string that was just read from the current file.
            pCurBuf[nLen] = 0;
            pAttrCur[nAttrLen] = 0;
            
            //comparison behavior may change by the type of the block to be
            //compared
            switch ( pIdxRef->blockType )
            {
            case BLK_COCLASS:
                if (fgCoClass)
                    nRes = !CompareCoClass(pCurBuf, pRefBuf, pAttrCur, pAttrRef, fileDiff);
                else
                    nRes = 0;
                break;
                
            case BLK_DISPINT:
                if (fgDispInterface)
                {
                    //if the length of two blocks is the same, there is a chance that 
                    //they are the same block. So, compare the memory before going into
                    //a long and detailed analysis
                    nRes = 1;
                    if (( pIdxRef->ulEndPos - pIdxRef->ulStartPos) == (unsigned long)nLen )
                    {
                        nRes = memcmp(pCurBuf, pRefBuf, nLen);
                    }

                    if (!nRes)
                        nRes = memcmp( pAttrCur, pAttrRef, max(lstrlen(pAttrCur), lstrlen(pAttrRef)));
                    
                    // The memory comparison failed. Go into details.
                    if ( nRes )
                        nRes = !CompareInterface(pIdxRef->blockType, pCurBuf, pRefBuf, pAttrCur, pAttrRef, fileDiff);
                }
                else
                {
                    // although we did not compare, set the flag so that 
                    // we mark the index as if we did compare to avoid false errors.
                    nRes = 0;
                }
                break;
                
            case BLK_INTERFACE:
                if (fgInterface)
                {
                    //if the length of two blocks is the same, there is a chance that 
                    //they are the same block. So, compare the memory before going into
                    //a long and detailed analysis
                    nRes = 1;
                    if ((pIdxRef->ulEndPos - pIdxRef->ulStartPos) == (unsigned long)nLen)
                    {
                        nRes = memcmp(pCurBuf, pRefBuf, nLen);
                    }
                    
                    if (!nRes)
                        nRes = memcmp( pAttrCur, pAttrRef, max(lstrlen(pAttrCur), lstrlen(pAttrRef)));

                    //the memory comparison failed. Go into details.
                    if ( nRes )
                        nRes = !CompareInterface(pIdxRef->blockType, pCurBuf, pRefBuf, pAttrCur, pAttrRef, fileDiff);
                }
                else
                {
                    // although we did not compare, set the flag so that 
                    // we mark the index as if we did compare to avoid false errors.
                    nRes = 0;
                }
                break;
                
            default:
                nRes = memcmp(pCurBuf, pRefBuf, nLen);
                break;
            }
            
            if (nRes == 0)
            {
                // Mark the current index record, so it's not used anymore.
                // This is true if the block name is found, regardless of the content 
                // comparison results.
                idxCur.fCopied = true;
                rgFileIdx->Set(i, idxCur);
                break;
            }
            
            
            delete [] pCurBuf;
            pCurBuf = NULL;
        }
    }
    
    if (pCurBuf)
    {
        delete [] pCurBuf;
        pCurBuf = NULL;
    }
    
    return (nRes ? false : true);
}

//
// Compare two files, by walking through the reference file and using the index
// to read the current file.
//
void CompareFiles(HANDLE fileCur, HANDLE fileRef, 
                  CAutoArray<INDEX>* rgFileIdx, HANDLE fileDiff)
{
    INDEX           idxRef = {BLK_NONE, 0};        // index record for the reference file block
    INDEX           idxAttr = {BLK_NONE, 0};
    
    bool            fContinue = true;
    unsigned long   ulOffset;
    char *          pRefBuf = NULL;
    char *          pAttrBuf = NULL;
    bool            fFound = false;
    
    
    //create an index for the file that is to be analyzed.
    while ( fContinue )
    {
        ulOffset = 0;
        fContinue = GetBlock(fileRef, &idxRef, &pRefBuf, &ulOffset);
        
        if (fContinue)
        {
            switch (idxRef.blockType)
            {
            case BLK_ATTR:
                int nLen;

                idxAttr = idxRef;   // the last attribute block is remembered, to be used with the 
                                    // interface, dispinteface and coclass comparison.
                // if we currently have a block, release it
                if (pAttrBuf)
                {
                    delete [] pAttrBuf;
                    pAttrBuf = NULL;
                }

                nLen = idxAttr.ulEndPos - idxAttr.ulStartPos;
                
                pAttrBuf = new char[nLen+1];

                memcpy( pAttrBuf, pRefBuf+ulOffset, nLen);

                pAttrBuf[nLen] = 0;

                break;
                
            case BLK_DISPINT:
            case BLK_INTERFACE:
            case BLK_COCLASS:
                
                assert(idxAttr.blockType == BLK_ATTR);

                idxRef.ulAttrStartPos = idxAttr.ulStartPos;
                idxRef.ulAttrEndPos = idxAttr.ulEndPos;

                fFound = CompareBlocks( fileCur, rgFileIdx, &idxRef, &pRefBuf[ulOffset], pAttrBuf, fileDiff);
                
                if (!fFound)
                {
                    char szBuf[MAX_PATH];
                    
                    sprintf(szBuf, "\n%s- Removed", strtok(&pRefBuf[ulOffset], "{"));
                    WriteLine(fileDiff, szBuf, -1);
                    g_ulAppRetVal |= CHANGE_BLOCKREMOVED;
                }
                
                //release the memory allocated by the GetBlock function
                delete [] pRefBuf;
                pRefBuf = NULL;

                delete [] pAttrBuf;
                pAttrBuf = NULL;

                idxAttr.blockType = BLK_NONE;
                break;
                
/* ferhane: see comments in PrepareIndex
                case BLK_TYPEDEF:
                break;
*/ 
            }
        }
    }
}

void DisplayError(UINT uError, UINT uLineNum /* = __LINE__ */, ostream& out /* = cerr*/)
{
    assert(uError < BUFFER_SIZE(pszErrors));

    out.fill('0');
    out << "TlDiff.exe(" << uLineNum << ") : error E9"
        << setw(3) << uError << ": " << pszErrors[uError] << endl;
}

/*----------------------------------------------------------------------------
 -----------------------------------------------------------------------------*/
bool ProcessINIFile(char* lpszIniFile)
{
    bool    fRet = true;
    char    szFileNames[] = {"FileNames"};
    char    szCheckRules[] = {"CheckRules"};
    char    szMethodAttr[] = {"BreakingMethodAttributes"};
    DWORD   dwBuffSize = 256;
    DWORD   dwBuffSizeOld;

    char*  pszDirectory = new char[dwBuffSize + 13];

    dwBuffSize = GetCurrentDirectory(dwBuffSize, pszDirectory);
    if (dwBuffSize > 256)
    {
        // we need a larger buffer for path.
        delete pszDirectory;
        pszDirectory = NULL;

        pszDirectory = new char[dwBuffSize+13];
        if (!pszDirectory)
        {
            DisplayError(ERR_OUTOFMEMORY, __LINE__);
            fRet = false;
            goto Error;
        }

        GetCurrentDirectory( dwBuffSize, pszDirectory );
    }

    lstrcat(pszDirectory, "\\");
    lstrcat(pszDirectory, lpszIniFile);

    // Make sure the INI file exists
    // GetFileAttributes returns 0xFFFFFFFF if the 
    // file doesn't exist.
    //
    if (0xFFFFFFFF == GetFileAttributes(pszDirectory))
    {
        DisplayError(ERR_INIFILENOTFOUND, __LINE__);
        fRet = false;
        goto Error;
    }

/*
    if (!GetPrivateProfileString(szFileNames, "CurrentFile", "cur.out", g_szCurFileName, 255, pszDirectory))
    {
        DisplayError( ERR_CURRFILENAME );
        bRet = FALSE;
        goto Error;
    }

    if (!GetPrivateProfileString(szFileNames, "ReferenceFile", "ref.out", g_szRefFileName, 255, pszDirectory))
    {
        DisplayError( ERR_REFFILENAME );
        bRet = FALSE;
        goto Error;
    }
*/

    if (!g_fWriteToStdOut)
    {
        // Specify a NULL default name so that we can check to see
        // if the file name wasn't specified in the INI file.
        //
        // If either the difference file or new file name is missing
        // from the INI, we write to stdout.
        //
        GetPrivateProfileString(szFileNames, "DifferenceFile", NULL, g_szDiffFileName,
                                BUFFER_SIZE(g_szDiffFileName) - 1, pszDirectory);

        if (NULL == g_szDiffFileName[0])
        {
            g_fWriteToStdOut = true;
        }
        else  
        {
            GetPrivateProfileString(szFileNames, "AdditionsFile", NULL, g_szNewFileName, 
                                    BUFFER_SIZE(g_szNewFileName) - 1, pszDirectory);

            if (NULL == g_szNewFileName[0])
            {
                g_fWriteToStdOut = true;
            }
        }
    }

    fgCoClass = !!(GetPrivateProfileInt(szCheckRules, "Coclass", 1, pszDirectory));

    fgInterface = !!(GetPrivateProfileInt(szCheckRules, "Interface", 1, pszDirectory));

    fgDispInterface = !!(GetPrivateProfileInt(szCheckRules, "Dispinterface", 1, pszDirectory));

    fgMethodParameter = !!(GetPrivateProfileInt(szCheckRules, "MethodParameter", 1, pszDirectory));

    fgMethodAttribute = !!(GetPrivateProfileInt(szCheckRules, "MethodAttribute", 1, pszDirectory));

    fgInterfaceAttr = !!(GetPrivateProfileInt(szCheckRules, "InterfaceAttribute", 1, pszDirectory));

    fgFlush = !!(GetPrivateProfileInt(szCheckRules, "GenerateAdditionsFile", 1, pszDirectory));

    fgParamNames = !!(GetPrivateProfileInt(szCheckRules, "ParameterName", 1, pszDirectory));
    fgParamTypes = !!(GetPrivateProfileInt(szCheckRules, "ParameterType", 1, pszDirectory));
    fgParamNameCase= !!(GetPrivateProfileInt(szCheckRules, "ParameterNameCase", 1, pszDirectory));
    fgParamTypeCase= !!(GetPrivateProfileInt(szCheckRules, "ParameterTypeCase", 1, pszDirectory));

    // get breaking method attributes.
    g_pszMethodAttr = new char[dwBuffSize];
    dwBuffSizeOld = 0;

    // down side of the APIs... It won't tell it needs more, it returns size - 1 or
    // size - 2 to indicate that it does not have enough buffer.
    //
    while (dwBuffSize < dwBuffSizeOld - 2)
    {
        dwBuffSizeOld = dwBuffSize;     // reset the condition.

        // Read into the buffer.
        dwBuffSize = GetPrivateProfileString(szMethodAttr, NULL, "none", g_pszMethodAttr,
                                             dwBuffSize, pszDirectory);

        // Did we have enough buffer size? 
        //
        if  (dwBuffSize < dwBuffSizeOld - 2)
        {
            break;
        }

        // Reallocate and try again.
        //
        delete g_pszMethodAttr;
        dwBuffSize = dwBuffSize * 2;
        g_pszMethodAttr = new char[dwBuffSize];
    }

Error:
    if (pszDirectory)
        delete pszDirectory;

    return fRet;
}

void ShowUsage()
{
    cout << endl 
         << "Usage: tldiff [-?|h] [-s] -f SettingsFile CurFile.out RefFile.out" << endl << endl
         << "Where: -?|h = Show usage. (These arguments are exclusive from the rest)" << endl
         << "       -s = write output to stdout." << endl
         << "       -f = use SettingsFile for initialization data." << endl
         << "       CurFile.out = Tlviewer file containing data for current tlb" << endl
         << "       RefFile.out = Tlviewer file containing data for new tlb"     << endl
         << endl;
}

bool ProcessArgs(int argc, char* argv[])
{
    char*  pszIniFile = NULL;
    bool    fSuccess   = true;
    int     i;

    // Check for "Show usage" request.
    //
    if ((argc >= 2) && ('-' == argv[1][0]) && ('?' == argv[1][1] || 'h' == argv[1][1]))
    {
        ShowUsage();
        return false;
    }

    if (argc < 5)
    {
        DisplayError(ERR_MISSINGARGS, __LINE__);
        goto Error;
    }

    // Note: i is initialized up top.
    //
    for (i=1; i < argc; i++)
    {
        if ('-' == argv[i][0])
        {
            switch(argv[i][1])
            {
            case 'f': 
                {
                    // The file is the next argument
                    i++;
                    if (i >= argc)
                    {
                        DisplayError(ERR_INIFILENAME, __LINE__);
                        goto Error;
                    }

                    int nBufSize = lstrlen(argv[i]) + 1;
                    pszIniFile = new char[nBufSize];

                    if (!pszIniFile)
                    {
                        DisplayError(ERR_OUTOFMEMORY, __LINE__);
                        goto Error;
                    }

                    lstrcpyn(pszIniFile, argv[i], nBufSize);

                    break;
                }

            case 's':
                g_fWriteToStdOut = true;
                break;

            // Stop the build process for invalid arguments.
            // This ensures that somebody didn't make a typo.
            // 
            default:
                DisplayError(ERR_INVALIDARG, __LINE__);
                goto Error;
            }
        }
        else
        {
            // Retrieve the current and new tlviewer output files.
            // These files must be in order. Therefore, I assume that
            // if the current file name variable is not set, then it's time
            // to set the current file name variable. If it is set, it's time
            // to set the new file name variable.
            //
            if (NULL == g_szCurFileName[0])
            {
                lstrcpyn(g_szCurFileName, argv[i], BUFFER_SIZE(g_szCurFileName));
            }
            else
            {
                lstrcpyn(g_szRefFileName, argv[i], BUFFER_SIZE(g_szRefFileName));
            }
        }
    }

    // This should never happen because the current file name
    // is the first file name in the arg list. I check anyway just
    // in case. If this every happens, that means there's a 
    // nasty bug somewhere in the code.
    //
    if (NULL == g_szCurFileName[0])
    {
        DisplayError(ERR_CURFILENAME, __LINE__);
        goto Error;
    }

    if (NULL == g_szRefFileName[0]) 
    {
        DisplayError(ERR_REFFILENAME, __LINE__);
        goto Error;
    }

    if (pszIniFile)
    {
        fSuccess = ProcessINIFile(pszIniFile);
    }
    else
    {
        DisplayError(ERR_INIFILENAME, __LINE__);
        goto Error;
    }

Cleanup:
    if (pszIniFile)
        delete pszIniFile;

    return fSuccess;

Error:
    ShowUsage();
    fSuccess = false;
    goto Cleanup;
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
int __cdecl main(int argc, char* argv[])
{
    
    HANDLE fileRef  = INVALID_HANDLE_VALUE;
    HANDLE fileCur  = INVALID_HANDLE_VALUE;
    HANDLE fileDiff = INVALID_HANDLE_VALUE;
    
    CAutoArray<INDEX>* rgFileIdx = NULL;
    
    //initialize global variables
    fgCoClass = fgInterface = fgDispInterface = fgMethodAttribute = fgMethodParameter
              = fgFlush = fgInterfaceAttr = true;
    
    g_ulAppRetVal = 0;
    
    //
    // Get and process the input arguments
    //
    if (!ProcessArgs(argc, argv))
    {
        goto Cleanup;
    }
    
    rgFileIdx = new CAutoArray<INDEX>;
    
    // Open the reference file and the current file
    //
    fileCur = CreateFile(g_szCurFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL, NULL);
    
    if (INVALID_HANDLE_VALUE == fileCur)
    {
        DisplayError(ERR_OPENINGCUR, __LINE__);
        goto Cleanup;
    }
    
    fileRef = CreateFile(g_szRefFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL, NULL);
    
    if (INVALID_HANDLE_VALUE == fileRef)
    {
        DisplayError(ERR_OPENINGREF, __LINE__);
        goto Cleanup;
    }
    
    // Prepare the index for the current file.
    cout << "Preparing index" << endl;
    PrepareIndex(fileCur, rgFileIdx);
    
    /* This was to test if the index algorithm would work on different files. 
    The mirror file should only be different from the file passed in as the
    current file, by its blanks and new lines.
    */

    //create a test mirror file using the index information we have.
    /*cout << "Creating test mirror file" << endl;
    CreateTestMirror( fileCur, rgFileIdx );
    */
    
    // Compare files.
    //
    if (g_fWriteToStdOut)
    {
        fileDiff = GetStdHandle(STD_OUTPUT_HANDLE);
    }
    else
    {
        fileDiff = CreateFile(g_szDiffFileName, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL, NULL);
    }
    
    if (INVALID_HANDLE_VALUE == fileDiff)
    {
        DisplayError(ERR_OPENINGDIFF, __LINE__);
        goto Cleanup;
    }
    
    cout << "Comparing Files" << endl;
    
    CompareFiles(fileCur, fileRef, rgFileIdx, fileDiff);
    
    // Only close here if we aren't writing to stdout.
    // Otherwise, we won't be able to write to stdout anymore.
    //
    if ((!g_fWriteToStdOut) && (INVALID_HANDLE_VALUE != fileDiff))
    {
        CloseHandle(fileDiff);
        fileDiff = INVALID_HANDLE_VALUE;
    }
    
    // Compare the attributes of interfaces. 
    // These contain the GUIDs of interfaces too.
    //
    if (fgInterfaceAttr)
        MarkAttrChanges(fileCur, rgFileIdx, g_szDiffFileName);
    
    // Flush out the blocks that are completely new for the current file 
    // and do not exist on the reference file.
    if (fgFlush)
        FlushDifferences(fileCur, rgFileIdx);
    
    if (g_ulAppRetVal)
    {
        DisplayError(ERR_DIFFERENCES, __LINE__);
    }
    else
    {
        cout << "Comparison Complete: No Errors" << endl;
    }
    
Cleanup:
    
    if (INVALID_HANDLE_VALUE != fileCur)
        CloseHandle(fileCur);
    
    if (INVALID_HANDLE_VALUE != fileRef)
        CloseHandle(fileRef);
    
    // Due to the fact that we may be writing to 
    // stdout, we should only close it once at the
    // very end of this program. It is not specified
    // if closing the console is actually necessary.
    //
    if (INVALID_HANDLE_VALUE != fileDiff)
        CloseHandle(fileDiff);
    
    // Release the memory allocated for the index array
    if (rgFileIdx)
        delete [] rgFileIdx;
    
    if (g_pszMethodAttr)
        delete g_pszMethodAttr;
    
    return g_ulAppRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\btools\tldiff\utils.cxx ===
#include <iostream.h>
#include <assert.h>
#include <windows.h>
#include "types.h"
#include "array.hxx"

extern bool g_fWriteToStdOut;

//
//
//
bool 
CompareBuffer(char* pBuff1, char* pBuff2, unsigned long nLen)
{
    for ( unsigned long i=0; i<nLen; i++ )
        if (pBuff1[i] != pBuff2[i])
            return false;
    return true;
}

bool 
CompareBufferNoCase( char* pBuff1, char* pBuff2, unsigned long nLen)
{
    // or ing with 0x20 always gives the lower case for ASCII characters.
    // this way we can compare case insensitive.
    for ( unsigned long i=0; i<nLen; i++ )
        if ( (pBuff1[i]|0x20) != (pBuff2[i]|0x20)  )
            return false;
    return true;
}


//
//
//
void 
WriteLine(HANDLE file, char* pBuff, int nLen)
{
    DWORD   dwSize;
    char    szBuff[2] = {0x0d, 0x0a};
    
    if (-1 == nLen)
    {
        nLen = lstrlen( pBuff );
    }
    
    WriteFile(file, pBuff, nLen, &dwSize, NULL);
    WriteFile(file, &szBuff, 2, &dwSize, NULL);
}


//
//
//
unsigned long 
FindEndOfLine( char* pBuff )
{
    char* pWalk = pBuff;
    
    while ( *pWalk != 0x0d )
        pWalk++;
    
    return ((unsigned long)(pWalk-pBuff));
}

//
//
//
bool 
GetLine(HANDLE file, char** ppTarget)
{
    //buffer
    char* pchBuff;
    unsigned long ulBuffIdx;
    unsigned long ulBuffSize = SZ;
    
    // Read variables
    DWORD   dwRead=0;
    BOOL    bRes;
    
    //allocate the initial buffer
    pchBuff = new char[ulBuffSize];
    
    //if we are currently positioned at wherever the previous 
    //operation left us, skip the carriage returns and 
    //get to the real data.
    pchBuff[0] = 0x0d;
    while (( pchBuff[0] == 0x0d ) || ( pchBuff[0] == 0x0a ))
    {
        bRes = ReadFile( (HANDLE)file, pchBuff, 1, &dwRead, NULL);
        if ( !bRes || !dwRead )
            return false;
    }
    
    
    //get the buffer until you reach the terminating character.
    //the first character of the buffer is filled. ulBuffIdx always points
    //to the char. to be read.
    ulBuffIdx = 1;
    
    BOOL fContinue = true;
    
    while( fContinue )
    {
        bRes = ReadFile( (HANDLE)file, &pchBuff[ulBuffIdx], 1, &dwRead, NULL);
        
        if ( !bRes || !dwRead )
            return false;
        
        //was this the terminating character?
        if ( pchBuff[ulBuffIdx] == 0x0A )
        {
            fContinue = false;
        }
        
        ulBuffIdx++;    //always point to the character to be read.
        
        //did we reach the end of the buffer? If so, enlarge buffer
        if ( 0 == (ulBuffIdx % SZ) )
        {
            //allocate new memory chunk
            char* pTmp = new char[ulBuffSize+SZ];
            
            //copy data
            memcpy( pTmp, pchBuff, ulBuffSize);
            
            //release old memory
            delete [] pchBuff;
            
            //make the new chunk the current one
            pchBuff = pTmp;
            ulBuffSize += SZ;
        }
    }
    
    pchBuff[ulBuffIdx-2] = 0;
    
    //if there is a receiving pointer and it is 
    //initialized to NULL properly
    if ((ppTarget) && (*ppTarget==NULL))
    {
        *ppTarget = pchBuff;
    }
    else
    {
        //since there are no valid receivers of the buffer,
        //we can delete it.
        delete [] pchBuff;
    }
    
    return true;
}

//----------------------------------------------------------------------------
//  Function    :   GetBlockType
//  Description :   Get a block of memory that is the first line 
//                  of a block, and determine the block type, by 
//                  checking the first characters on the line
//  Parameters  :
//          char*   :   pointer to the buf. that contains the line
//
//  Returns     :   Returns the type of the block ( enumeration BLOCK_TYPE)
//----------------------------------------------------------------------------
BLOCK_TYPE 
GetBlockType( char* pchData, char* pchTerm )
{
    assert( pchData );
    assert( pchTerm );
    
    switch (*pchData)
    {
    case 'd':
        *pchTerm = '}';         //end of block
        return BLK_DISPINT;
        break;
        
    case 'i':
        *pchTerm = '}';         //end of block
        return BLK_INTERFACE;
        break;
        
    case 'c':
        *pchTerm = '}';         //end of block
        return BLK_COCLASS;
        break;
        
    case 't':
        *pchTerm = ';';         //end of type definition
        return BLK_TYPEDEF;
        break;
        
    case '[':
        *pchTerm = ']';         //end of attribute
        return BLK_ATTR;
        break;
        
    default:
        *pchTerm = 0x0a;        //end of line
        return BLK_NONE;
        break;
    }
}

//
//
//
bool 
GetBlock(HANDLE file, INDEX* pIdx, char** ppTarget = NULL, unsigned long* pulBlockBase = NULL )
{
    char *          pchBuff;          //buffer
    unsigned long   ulBuffIdx;        //walking pointer
    unsigned long   ulBuffBase;       //end of the last memory chunk.
    unsigned long   ulBlockBase;      //beginning of the actual block, 

    //after the funny characters are skipped
    unsigned long   ulBuffSize = SZ+1; // the extra character is for the NULL termination.
    unsigned long   ulLines = 0;
    BOOL            fContinue = TRUE;
    
    //read variables
    DWORD           dwRead=0;
    BOOL            bRes;
    char            chTerm;
    
    assert(pIdx);
    
    if ( ppTarget )
        *ppTarget = NULL;       //reset the pointer to be returned.
    
    //allocate the initial buffer
    pchBuff = new char[ulBuffSize];
    ulBuffBase = ulBuffIdx = ulBlockBase = 0;
    
    //we are currently positioned at wherever the previous 
    //operation left us. learn where we are and start to read.
    pIdx->ulStartPos = SetFilePointer( (HANDLE)file, 0, NULL, FILE_CURRENT);
    
    while( fContinue ) 
    {
        //read a block from the file.
        bRes = ReadFile( (HANDLE)file, &pchBuff[ulBuffIdx], SZ, &dwRead, NULL);
        
        //if there was a failure or we had reached the end of the file.
        if ( !bRes || !dwRead )
            return false;
        
        //skip the possible 0d 0a sequences at the beginning and process the rest of 
        //the message.
        if ( ulBuffIdx== 0 )
        {
            while((pchBuff[ulBuffIdx] == 0x0D ) || 
                ( pchBuff[ulBuffIdx] == 0x0A ) ||
                ( pchBuff[ulBuffIdx] == 0x20 ))
            {
                ulBuffIdx++;                    //read position in the buffer
                ulBlockBase++;                  //increment the buffer base position.
                pIdx->ulStartPos++;             //start position in the file.
            }
            
            //if we reached the end of file by doing this, return. There is nothing left.
            if (dwRead==ulBuffIdx)
                return false;
            
            //now we are pointing to the actual data, learn the terminating
            //character and terminate this loop.
            pIdx->blockType = GetBlockType(&pchBuff[ulBuffIdx], &chTerm);
        }
        
        //walk until you reach the terminating character or the end of the read buffer
        while ((ulBuffIdx<(ulBuffBase+dwRead)) && (pchBuff[ulBuffIdx] != chTerm))
        {
            //check for the 0x0A to determine the number of lines
            //the linefeed after the chTerm is found is taken care of
            //in the spin routine for the empty lines.
            if (pchBuff[ulBuffIdx] == 0x0A )
                ulLines++;
            
            ulBuffIdx++;
        }
        
        //did we reach the end of the buffer or found the chTerm character
        if (ulBuffIdx == ulBuffSize - 1)
        {
            char* pTmp = new char[ulBuffSize+SZ];   //allocate new memory chunk
            memcpy( pTmp, pchBuff, ulBuffSize);     //copy data
            delete [] pchBuff;                      //release old memory
            pchBuff = pTmp;                         //make the new chunk the current one
            ulBuffSize += SZ;                       //adjust the buffer size
            ulBuffBase = ulBuffIdx;                 //reset the base to the current limit
        }
        else
        {
            //we found the terminating character.
            ulBuffIdx++;        //always point to the character to be read next.
            break;
        }
    }
    
    // Subtract the block base, If there were 0d0a pairs, we incremented both
    // ulStartPos and ulBuffIdx, and doubled the effect of the skipping these
    // characters. Compensation is provided by -ulBlockBase ...
    pIdx->ulEndPos = pIdx->ulStartPos + ulBuffIdx - ulBlockBase;
    
    // If the terminating character was a line break, we don't want it to go 
    // into the record as a part of this line
    if ( chTerm == 0x0a )
    {
        pIdx->ulEndPos -= 2;
        ulBuffIdx -= 2;
    }
    
    // Reset the pointer to the end of this block.  
    SetFilePointer( (HANDLE)file, pIdx->ulEndPos, NULL, FILE_BEGIN);
    
    // Terminate the buffer, since the index always shows the next 
    // position available, subtract 1 from the index.
    pchBuff[ulBuffIdx] = 0;
    
    // If there is a receiving pointer and it is 
    // initialized to NULL properly
    if ((ppTarget) && (*ppTarget==NULL) && (pulBlockBase))
    {
        *ppTarget = pchBuff;
        *pulBlockBase = ulBlockBase;
    }
    else
    {
        // Since there are no valid receivers of the buffer,
        // we can delete it.
        delete [] pchBuff;
    }
    
    return true;
}

//
//  Compare two attribute blocks. Attribute blocks are placed before interface descriptions 
//  and coclass descriptions.
//  dual --> breaker for both coclass and interface if added/removed
//  uuid(...) --> breaker for interfaces of all kinds if the contents of the uuid is changed
//
//  Return Value:
//  The return value from this function 0 if there are no differences between these two blocks
//  otherwise an error code is returned.

long
CompareAttributeBlock(  char * pRefBuf, 
                        CAutoArray<ATTRINFO>*   pRefList, 
                        char * pCurBuf,
                        CAutoArray<ATTRINFO>*   pCurList)
{
    char        szDual[] = {"dual"};
    char        szUuid[] = {"uuid"};
    char *      pszAttr;
    ATTRINFO    attrCur, attrRef;
    int         i, j, k;
    long        lErr;


    // For all of the attributes that are in the reference list, if the attribute is one of 
    // the attributes that we care about, we will make sure that the current list contains 
    // the same attribute.
    for ( i=0; i < pRefList->Size(); i++ )
    {
        pRefList->GetAt(i, &attrRef);

        if (attrRef.ulAttrLength == 4)
        {
            pszAttr = szDual;
            lErr    = CHANGE_DUALATTRREMOVED;
        }
        else if (attrRef.ulAttrLength == 42)
        {
            pszAttr = szUuid;
            lErr    = CHANGE_UUIDHASCHANGED;
        }
        else
            continue;

        assert(pszAttr);

        // is this attribute one of those that we want to check for?
        for (j=0; j<4; j++)
            if( pszAttr[j] != pRefBuf[attrRef.ulAttrStart+j])
                break;

        // We don't want to compare this attribute.
        if (j != 4)
            continue;

        // we care about this attribute. It MUST be in the current attribute block 
        for (k=0; k < pCurList->Size(); k++)
        {
            pCurList->GetAt(k, &attrCur);

            if ((!attrCur.fUsed) && 
                (0 == memcmp( pRefBuf+attrRef.ulAttrStart, 
                                pCurBuf+attrCur.ulAttrStart, 
                                attrRef.ulAttrLength)))
            {
                // if the attribute is found, then mark the current list so we skip
                // over this one next time.
                attrCur.fUsed = true;
                pCurList->Set(k, attrCur);

                // shortcut...
                break;
            }
        }
        
        // if we did not find the same attribute, return the error code that is in lErr
        if (k == pCurList->Size())
            return lErr;
    }

    // check for things that are added to the current list, 
    // but don't exist in the reference list. If something we check for is added, this is a breaker.
    for ( i=0; i < pCurList->Size(); i++)
    {
        pCurList->GetAt(i, &attrCur);

        if (!attrCur.fUsed)
        {
            // only check for "dual" here.
            pszAttr = szDual;

            for (j=0; j<4; j++)
                if( pszAttr[j] != pCurBuf[attrCur.ulAttrStart+j])
                    break;

            if (j==4)
                return CHANGE_DUALATTRADDED;
        }
    }

    return 0;
}

void 
TokenizeAttributes( char* pBuf, unsigned long nCnt, CAutoArray<ATTRINFO>* pList )
{
    unsigned long i,j;
    ATTRINFO    attrInfo;

    attrInfo.ulAttrStart = 0;

    // the first attribute is always at 0
    for ( i=0, j=0; i<= nCnt; i++, j++ )
    {
        if ( ( pBuf[i] == ',' ) || (i==nCnt) )
        {
            attrInfo.ulAttrLength = i- attrInfo.ulAttrStart;
            attrInfo.fUsed = false;

            pList->Append( attrInfo );

            i += 2;

            attrInfo.ulAttrStart = i;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\btools\tlviewer\apglobal.h ===
/*** 
*apglobal.h - Header file for the C/C++ version of the apglobal functions 
*
*  Copyright (C) 1992, Microsoft Corporation.  All Rights Reserved.
*  Information Contained Herein Is Proprietary and Confidential.
*
*Purpose: Defines the apglobal functions 
*
*Revision History:
*
* [00]	25-Nov-92      ChrisKau : created
* [01]	13-Dec-92      Brandonb : changed to DLL, added apLogExtra
* [02]  04-Jan-93      ChrisKau : added apSPrintf
* [03]  19-Jan-94	   MesfinK  : added WriteDebugStr lWriteAnsi
*	
*Implementation Notes:
*
*****************************************************************************/

#define E_TEST_FAILED 	MAKE_SCODE(SEVERITY_ERROR, FACILITY_DISPATCH, 1024)
#define E_BAD_TEST 		MAKE_SCODE(SEVERITY_ERROR, FACILITY_DISPATCH, 1025)


#ifdef _MAC
//  ************************* MAC MAC MAC **************************
#ifdef __cplusplus
extern "C" {
#endif


#define XCHAR		char
#define LPXSTR 		char *
#define XSTR(x)		x
#define SYSCHAR		char
#define LPSYSSTR 	char *
#define SYSSTR(x)	x

int apLogFailInfo(char FAR *szDescription, char FAR *szExpected, char FAR *szActual, char FAR *szBugNum);
int apInitTest(char FAR *szTestName);
int apInitScenario(char FAR *szScenario);
void apEndTest();
int apWriteDebug(char FAR *szFormat, ...);

#define osStrCpy  strcpy
#define osStrCmp  strcmp
#define osStrCmpi strcmpi
#define osStrCat  strcat
#define osStrLen  strlen
#define apSPrintf sprintf

short FSpFileExists(FSSpec *f);
short FSpOpenForAppend(FSSpec *fs);
short FSpOpenForOutput( FSSpec *fs );
OSErr FSpAppend(FSSpec *fileA, FSSpec *fileB);
OSErr WriteLn(short fRefNum, StringPtr s);
void Yield();	

#ifdef __cplusplus
}
#endif

#else  // ******************* NOT MAC ******************************

#ifdef OAU
#define XCHAR   WCHAR
#define LPXSTR  LPWSTR
#define XSTR(x) L##x
#else	
#define XCHAR   char
#define LPXSTR  LPSTR
#define XSTR(x) x
#endif	


#ifdef UNICODE
#define SYSCHAR     WCHAR
#define LPSYSSTR    LPWSTR
#define SYSSTR(x)   L##x
#else	
#define SYSCHAR     char
#define LPSYSSTR    LPSTR
#define SYSSTR(x)   x
#endif	

#if defined(WIN16)
#define lstrcpyA lstrcpy
#define lstrcatA lstrcat
#define FILETHING HFILE
#else
#define FILETHING FILE *
#endif


#ifdef __cplusplus
extern "C" {
#endif

void    FAR PASCAL  apEndTest           ();
int     FAR PASCAL  apInitTestCore      (SYSCHAR FAR * szTestName);
int     FAR PASCAL  apLogFailInfoCore   (LPSYSSTR szDescription, LPSYSSTR szExpected, LPSYSSTR szActual, LPSYSSTR szBugNum);
int     FAR PASCAL  apInitScenarioCore  (SYSCHAR FAR * szScenarioName);
int     FAR __cdecl apWriteDebugCore    (SYSCHAR FAR *szFormat, ...);
int     FAR PASCAL  apInitPerfCore      (SYSCHAR FAR * szServerType, SYSCHAR FAR * szProcType, int bitness, int server_bitness);
int     FAR PASCAL  apLogPerfCore       (SYSCHAR FAR * szTestType, DWORD microsecs, float std_deviation);


// wrap function with pascal calling convention so you can call from vb3
#if defined(WIN16)
DATE FAR PASCAL apDateFromStr(char FAR *str, LCID lcid);
#endif

#if defined(_NTWIN)

int     FAR PASCAL  apInitTestA     (LPSTR szTestName);
int     FAR PASCAL  apLogFailInfoA  (LPSTR szDescription, LPSTR szExpected, LPSTR szActual, LPSTR szBugNum);
int     FAR PASCAL  apInitScenarioA (LPSTR szScenarioName);
int     FAR __cdecl apWriteDebugA   (char FAR *szFormat, ...);
int     FAR PASCAL  apInitPerfA     (char FAR * szServerType, char FAR * szProcType, int bitness, int server_bitness);
int     FAR PASCAL  apLogPerfA      (char FAR * szTestType, DWORD microsecs, float std_deviation);

#else // win16 || chicago || win32s

#if defined(WIN32)

int     FAR PASCAL  apInitTestW     (LPWSTR szTestName);
int     FAR PASCAL  apLogFailInfoW  (LPWSTR szDescription, LPWSTR szExpected, LPWSTR szActual, LPWSTR szBugNum);
int     FAR PASCAL  apInitScenarioW (LPWSTR szScenarioName);
int     FAR __cdecl apWriteDebugW   (LPWSTR szFormat, ...);
int     FAR PASCAL  apInitPerfW     (LPWSTR szServerType, LPWSTR szProcType, int bitness, int server_bitness);
int     FAR PASCAL  apLogPerfW      (LPWSTR szTestType, DWORD microsecs, float std_deviation);
LPWSTR  FAR PASCAL  lstrcatWrap     (LPWSTR sz1, LPWSTR sz2);
LPWSTR  FAR PASCAL  lstrcpyWrap     (LPWSTR sz1, LPWSTR sz2);
int     FAR PASCAL  lstrcmpWrap     (LPWSTR sz1, LPWSTR sz2);
int     FAR PASCAL  lstrcmpiWrap    (LPWSTR sz1, LPWSTR sz2);
SIZE_T     FAR PASCAL  lstrlenWrap     (LPWSTR sz1);
int     FAR __cdecl wsprintfWrap    (LPWSTR szDest, WCHAR FAR *szFormat, ...);
#endif //win32
#endif //_ntwin


#if !defined(_APGLOBAL_)
#if defined(_NTWIN)
#if defined (OAU)
#define     apInitTest      apInitTestCore
#define     apLogFailInfo   apLogFailInfoCore
#define     apInitScenario  apInitScenarioCore
#define     apWriteDebug    apWriteDebugCore
#define     apInitPerf		apInitPerfCore
#define		apLogPerf		apLogPerfCore
#define     osStrCmp        lstrcmp
#define     osStrCmpi       lstrcmpi
#define     osStrCpy        lstrcpy
#define     osStrCat        lstrcat
#define     osStrLen        lstrlen
#define     apSPrintf       wsprintf
#define     apSPrintfA      wsprintfA
#else
#define     osStrCmp        lstrcmpA
#define     osStrCmpi       lstrcmpiA
#define     osStrCpy        lstrcpyA
#define     osStrCat        lstrcatA
#define     osStrLen        lstrlenA
#define     apSPrintf       wsprintfA
#define     apSPrintfW      wsprintf
#define     apInitTest      apInitTestA
#define     apLogFailInfo   apLogFailInfoA
#define     apInitScenario  apInitScenarioA
#define     apWriteDebug    apWriteDebugA
#define     apInitPerf		apInitPerfA
#define		apLogPerf		apLogPerfA
#endif // OAU
#else // win16 || chicago || win32s
#if defined (OAU)
#define     osStrCmp        lstrcmpWrap
#define     osStrCmpi       lstrcmpiWrap
#define     osStrCpy        lstrcpyWrap
#define     osStrCat        lstrcatWrap
#define     osStrLen        lstrlenWrap
#define     apInitTestA     apInitTestCore
#define     apLogFailInfoA  apLogFailInfoCore
#define     apInitScenarioA apInitScenarioCore
#define     apWriteDebugA   apWriteDebugCore
#define     apInitTest      apInitTestW
#define     apLogFailInfo   apLogFailInfoW
#define     apInitScenario  apInitScenarioW
#define     apWriteDebug    apWriteDebugW
#define     apInitPerf		apInitPerfW
#define		apLogPerf		apLogPerfW
#define     apSPrintf       wsprintfWrap
#define     apSPrintfA      wsprintf
#else
#define     apInitTest      apInitTestCore
#define     apLogFailInfo   apLogFailInfoCore
#define     apInitScenario  apInitScenarioCore
#define     apWriteDebug    apWriteDebugCore
#define     apInitPerf		apInitPerfCore
#define		apLogPerf		apLogPerfCore
#define     osStrCmp        lstrcmp
#define     osStrCmpi       lstrcmpi
#define     osStrCpy        lstrcpy
#define     osStrCat        lstrcat
#define     osStrLen        lstrlen
#define     apSPrintf       wsprintf
#define     apSPrintfW      wsprintfWrap
#endif // OAU
#endif
#endif // !_APGLOBAL_

// functions internal to apglobal
#if defined(_APGLOBAL_)
#if defined(WIN32)
extern "C"
BOOL WINAPI _CRT_INIT(HINSTANCE, DWORD, LPVOID);
#endif

LPSTR       Unicode2Ansi    (SYSCHAR FAR *);
SIZE_T         lWriteAnsi      (FILETHING , SYSCHAR FAR *, int);
FILETHING   lOpenAnsi       (char FAR *);
int _cdecl  FilePrintf      (FILETHING, SYSCHAR FAR *, ...);
int         lCloseAnsi      (FILETHING f);

#endif // _APGLOBAL_

#ifdef __cplusplus
}
#endif

#endif // !_MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\btools\tlviewer\apglobal.cpp ===
/*** 
*apglobal.cpp - Ffile for the C/C++ version of the apglobal functions 
*
*  Copyright (C) 1992, Microsoft Corporation.  All Rights Reserved.
*  Information Contained Herein Is Proprietary and Confidential.
*
*Purpose: This allows tests written in C to write debug info in the same manner 
*           as our Basic tests. 
*
*Revision History:
*
* [00]  25-Nov-92      chriskau : created
* [01]  13-Dec-92      Brandonb : changed to DLL, added apLogExtra
* [02]  26-Jan-93      ChrisK   : added exe.don support to apEndTest
* [03]  23-Feb-93      ChrisK   : reset iFailFlag and icErrorCount on apInitTest
* [04]  14-Jan-94      Mesfink  : Modified to enable 32bit compilation & unicode
*Implementation Notes:  
*
*****************************************************************************/
#include "hostenv.h"
#define _APGLOBAL_
#include "apglobal.h"
#define     wcsicmp     _wcsicmp


#define APLOGFAIL_MAX   254
#define AMAX            255

#define RESULTS_TXT     "results.txt" 
#define RESULTS_LOG     "results.log" 
#define OLEAUTO_PRF     "oleauto.prf" 
#define RESULTS_TXTX    SYSSTR("results.txt") 
#define RESULTS_LOGX    SYSSTR("results.log") 
#define OLEAUTO_PRFX    SYSSTR("oleauto.prf") 

#define RESULTS_DEB     "results.deb"       
#define RESULTS_DON     "exe.don"           
#define RES_PATH        "c:\\school\\"
#define PASS_STR        SYSSTR("PASSED       ")
#define FAIL_STR        SYSSTR("FAILED ***** ")
#define RUN_STR         SYSSTR("RUNNING **** ")



// vars for output of testing/failure info
SYSCHAR     szTest[255];
SYSCHAR     szScenario[255];
SYSCHAR     szLastTest[255]     = SYSSTR("");
SYSCHAR     szLastScen[255]     = SYSSTR("");
SYSCHAR     szBugNumber[255];
int         iFailFlag;

// vars for bookkeeping
int         icErrorCount;
long        icLogFileLocation;
long        icPrfFileLocation;
int         fInTest;


// vars for thread and process syncronization on win95/NT
#if defined(_MT)
HANDLE              hmutexTxt;
HANDLE              hmutexLog;
HANDLE              hmutexPrf;
#endif


/* -------------------------------------------------------------------------
   NAME: Unicode2Ansi lWriteAnsi lOpenAnsi lCreatAnsi

   Revision:

      [0]   19-01-94    MesfinK:     Created
   -------------------------------------------------------------------------*/

/*LPSTR Unicode2Ansi(SYSCHAR FAR * szString)
{
#if defined(UNICODE)
	char AnsiBuffer[AMAX];
	int iCount;

	iCount=lstrlen(szString);
	if(WideCharToMultiByte(CP_ACP,WC_COMPOSITECHECK, szString,iCount+1,(LPSTR)
		AnsiBuffer,AMAX,NULL,NULL))
		return (LPSTR)AnsiBuffer;
	else
		return NULL;
#else
	return (LPSTR)szString;
#endif
}*/

SIZE_T lWriteAnsi(FILETHING hfile, SYSCHAR FAR *szString, int iCount)
{
#if defined(UNICODE)
	char AnsiBuffer[AMAX];
	if(!WideCharToMultiByte(CP_ACP,WC_COMPOSITECHECK, szString, iCount+1, (LPSTR)
		AnsiBuffer, AMAX, NULL, NULL))
		return (SIZE_T)HFILE_ERROR;
	else
	    return fwrite(AnsiBuffer, 1, (short)iCount, hfile);
#elif defined(WIN16)
	return _lwrite(hfile,(LPSTR)szString,(short)iCount);
#else
	return fwrite(szString, 1, (short)iCount, hfile);
#endif
}

FILETHING lOpenAnsi(char FAR *szFileName)
{
    FILETHING hfTemp;
#if defined(WIN16)
    
    hfTemp = _lopen(szFileName, WRITE);

    if (hfTemp == HFILE_ERROR)
	    hfTemp = _lcreat(szFileName, 0);
    else
	_llseek(hfTemp, 0, 2);

    return hfTemp;
#else
    hfTemp = fopen(szFileName, "r+b");
    if (hfTemp == NULL)
        hfTemp = fopen(szFileName, "wb");
    else
        fseek(hfTemp, 0, SEEK_END); 
    return hfTemp;
#endif
}



int lCloseAnsi(FILETHING f)
{
#if defined(WIN16)
   return _lclose(f);
#else
    return fclose(f);
#endif
}

/* -------------------------------------------------------------------------
   NAME: FilePrintf

   Revision:

      [0]   12-07-92    BrandonB     Created
   -------------------------------------------------------------------------*/
int _cdecl 
FilePrintf(FILETHING hfile, SYSCHAR FAR * szFormat, ...)
{
    int x;
    SYSCHAR szBuf[1024];
#if defined(WIN16)
    char szLocal[256];
#endif

    
#if defined(_ALPHA_)
    va_list args;
    args.offset=4;
#else
    char FAR *args;
#endif    

    if (szFormat != NULL)
    {
#if defined(_ALPHA_)
	args.a0 = ((char FAR *)(&szFormat))+4;
#else
	args =((char FAR *)(&szFormat))+4;
#endif
#if defined(_NTWIN)
	x = vswprintf(szBuf, szFormat, args);
#else
#if defined(WIN16)
    x = wvsprintf(szBuf, szFormat, args);
#else    
	x = vsprintf(szBuf, szFormat, args);
#endif
#endif       
	if (lWriteAnsi(hfile, szBuf, lstrlen(szBuf)) == NULL)
	    return(-1);                                     
    }
    return (0);
}


#if 0

/* -------------------------------------------------------------------------
   NAME: apInitTest

   Description: This function initializes a testcase.  The name of the
		testcase is written to results.txt and a global variable
		is set to the same value.

   Input: szTestName - char * pointing to the name of the testcase

   Output: (return) - 0 if no error, -1 if there was an error

   Revision:

      [0]   11-24-92    ChrisKau     Created
      [1]   12-04-92    BrandonB     changed to use only windows call

   -------------------------------------------------------------------------*/
extern "C" int FAR  PASCAL
apInitTestCore (SYSCHAR FAR * szTestName)
{   
    FILETHING hfResultsTxt;
    char      szFullFileName[255];
    

    if (fInTest == TRUE)
    {
        // log error information
        FILETHING hfResultsLog;
        
        lstrcpyA(szFullFileName, RES_PATH);                      
        lstrcatA(szFullFileName, RESULTS_LOG);

#if defined(_MT)
        WaitForSingleObject(hmutexLog, INFINITE);
#endif                
        hfResultsLog = lOpenAnsi(szFullFileName);

        if (hfResultsLog == NULL)
    	    goto Done;

	    FilePrintf(hfResultsLog, SYSSTR("\r\n========================================\r\n") );
	    FilePrintf(hfResultsLog, SYSSTR(" Begin: %s\r\n\r\n"), (LPSYSSTR )szTest);							    
        FilePrintf(hfResultsLog, SYSSTR("\r\n ________________\r\n %s\r\n"), (LPSYSSTR )szScenario);
        FilePrintf (hfResultsLog, SYSSTR(" !!! apInitTest called before previous test ended!\r\n")); 
        iFailFlag++;                                             
        FilePrintf (hfResultsLog, SYSSTR(" ________________\r\n"));
        lCloseAnsi(hfResultsLog);
Done:;
#if defined(_MT)
        ReleaseMutex(hmutexLog);
#endif                
        apEndTest();
        return(-1);
    }
    else fInTest = TRUE;

    iFailFlag = 0;                                           
    icErrorCount = 0;                                        
    szBugNumber[0] = 0;
    
    wsprintf( szTest, SYSSTR("%-20s") , szTestName);
    if (!(szTestName))
        return(-1);                                           

    lstrcpyA(szFullFileName, RES_PATH);        
    lstrcatA(szFullFileName, RESULTS_TXT);

#if defined(_MT)
    WaitForSingleObject(hmutexTxt, INFINITE);
#endif                
    hfResultsTxt = lOpenAnsi(szFullFileName);

    if (hfResultsTxt == NULL)
    {
#if defined(_MT)
        ReleaseMutex(hmutexTxt);
#endif                
	    return(-1);
	}    
								   
    if (lWriteAnsi(hfResultsTxt, (SYSCHAR FAR * )szTest, lstrlen(szTest)) == NULL)
    {
#if defined(_MT)
        ReleaseMutex(hmutexTxt);
#endif                
	    return(-1);
	}    

#if defined(WIN32)
    if ((icLogFileLocation = ftell(hfResultsTxt)) == -1)
    {
#if defined(_MT)    
        ReleaseMutex(hmutexTxt);
#endif        
        lCloseAnsi(hfResultsTxt);                                   
	    return(-1);
    }
#else // win16
    if ((icLogFileLocation = _llseek(hfResultsTxt, 0, 1)) == HFILE_ERROR)
    {
        lCloseAnsi(hfResultsTxt);                                   
	    return(-1);
    }
#endif     
    else FilePrintf(hfResultsTxt,SYSSTR("%-70s\r\n") , RUN_STR);


    lCloseAnsi(hfResultsTxt);                                   
#if defined(_MT)
    ReleaseMutex(hmutexTxt);
#endif                

    apWriteDebugCore(SYSSTR("%s\n") , (SYSCHAR FAR * )szTest);                
 
    return(0);
}

/* -------------------------------------------------------------------------
   NAME: apInitScenario

   Description: This function initializes a scenario.  The name of the
		scenario is written to the debug window and a global
		variable is set to the same value.

   Input: szScenarioName - SYSCHAR  * pointing to the name of the scenario

   Output: (return) - 0 if no error, -1 if there was an error

   Revision:

      [0]   11-24-92    ChrisKau     Created
      [1]   12-04-92    BrandonB     changed to use only windows calls etc.
	  [2]   01-28-94        MesfinK          added API & NLS information.
   -------------------------------------------------------------------------*/
extern "C" int FAR  PASCAL 
apInitScenarioCore (SYSCHAR FAR * szScenarioName)
{
   
   lstrcpy((SYSCHAR FAR * )szScenario, (SYSCHAR FAR * )szScenarioName);       
   szLastScen[0] = 0;                                               

   apWriteDebugCore(SYSSTR("%s\n") , (SYSCHAR FAR * )szScenarioName);       
   return(0);
}


#endif //0
   
    
/* -------------------------------------------------------------------------
   NAME: apLogFailInfo

   Description: This call takes four strings, and writes out the error
		information to results.txt and results.log files.

   Input: szDescription - SYSCHAR  * describing what went wrong
	  szExpected - SYSCHAR  * expected value of testcase
	  szActual - SYSCHAR  * actual value of testcase
	  szBugNum - SYSCHAR  * bug number in RAID data base

   Output: (return) - 0 if no error, -1 if there was an error

   Revision:

      [0]   11-24-92    ChrisKau     Created
      [1]   12-04-92    BrandonB     changed to use only windows call
      [2]   02-03-94    ChrisK       Change to handle WIN16/WIN32/UNICODE
   -------------------------------------------------------------------------*/
extern "C" int FAR  PASCAL
apLogFailInfoCore (LPSYSSTR szDescription, LPSYSSTR szExpected, LPSYSSTR szActual, LPSYSSTR szBugNum)
{
    FILETHING hfResultsLog;
    char      szFullFileName[255];
    
    lstrcpyA(szFullFileName, RES_PATH);                      
    lstrcatA(szFullFileName, RESULTS_LOG);

#if defined(_MT)
    WaitForSingleObject(hmutexLog, INFINITE);
#endif                
    hfResultsLog = lOpenAnsi((char FAR *)szFullFileName);

    if (hfResultsLog == NULL)
    {
#if defined(_MT)
        ReleaseMutex(hmutexLog);
#endif // _MT               
	    return(-1);
	}    

	if (fInTest != TRUE)
	{
	    // log failure info or warn of mem leak
	}

    if (lstrcmp(szTest, szLastTest))                                                                                     
	{                                                       							    
	    FilePrintf(hfResultsLog, SYSSTR("\r\n========================================\r\n") );
	    FilePrintf(hfResultsLog, SYSSTR(" Begin: %s\r\n\r\n"), (LPSYSSTR)szTest);							    
	    apWriteDebugCore(SYSSTR("\n========================================\n\n"));
	    apWriteDebugCore(SYSSTR(" Begin: %s\n\n"), (LPSYSSTR)szTest);      
	    lstrcpy(szLastTest, szTest);                          
    }

    if (lstrcmp(szScenario, szLastScen))                                                                                  
    {                                                                                                                    
        FilePrintf(hfResultsLog, SYSSTR("\r\n ________________\r\n %s\r\n"), (LPSYSSTR)szScenario);
        apWriteDebugCore(SYSSTR("\n ________________\n %s\n"), (LPSYSSTR)szScenario);
        lstrcpy(szLastScen, szScenario);                      
    }

    iFailFlag++;                                             

    if (lstrlen(szDescription))                              
    {                                                        
        FilePrintf (hfResultsLog, SYSSTR(" !!! %s\r\n"), (LPSYSSTR)szDescription); 
        apWriteDebugCore (SYSSTR(" !!! %s\n"), (LPSYSSTR)szDescription);
    }

    if (lstrlen(szExpected)+lstrlen(szActual))               
    {
        FilePrintf(hfResultsLog, SYSSTR(" Expected: %s\r\n"), (LPSYSSTR)szExpected);
        FilePrintf(hfResultsLog, SYSSTR(" Actuals : %s\r\n"), (LPSYSSTR)szActual);
        apWriteDebugCore(SYSSTR(" Expected: %s\n"), (LPSYSSTR)szExpected);
        apWriteDebugCore(SYSSTR(" Actuals : %s\n"), (LPSYSSTR)szActual);
    }

    if (lstrlen(szBugNum))                                   
    {                                                                                                                    
        FilePrintf(hfResultsLog, SYSSTR(" BugNum  : %s\r\n"), (LPSYSSTR)szBugNum);
        apWriteDebugCore(SYSSTR(" BugNum  : %s\n"), (LPSYSSTR)szBugNum);
        lstrcpy(szBugNumber, szBugNum);
    }

    FilePrintf (hfResultsLog, SYSSTR(" ________________\r\n"));
    apWriteDebugCore( SYSSTR(" ________________\n"));

    lCloseAnsi(hfResultsLog);
#if defined(_MT)
    ReleaseMutex(hmutexLog);
#endif                

    return(0);
}


/* -------------------------------------------------------------------------
   NAME: apEndTest

   Description: This function writes out the final passed or failed for
		a particular testcase.

   Input: (none)

   Output: (none) - if there is an error we are already quitting

   Revision

      [0]   11-24-92    ChrisKau     Created
      [1]   12-04-92    BrandonB     changed to use only windows call
   -------------------------------------------------------------------------*/
extern "C" void FAR  PASCAL 
apEndTest()
{
    SYSCHAR     szMessage[25];
    SYSCHAR     szMTOut[255];
    FILETHING   hfResultsTxt;
    char        szFullFileName[255];
        
    if (iFailFlag)                                           
    {
        lstrcpy(szMessage, FAIL_STR);
    }
    else
    {
        lstrcpy(szMessage, PASS_STR);
    }
   
    fInTest = FALSE;
    lstrcpyA(szFullFileName, RES_PATH);
    lstrcatA(szFullFileName, RESULTS_TXT);                            

#if defined(_MT)
    WaitForSingleObject(hmutexTxt, INFINITE);
#endif                
    hfResultsTxt = lOpenAnsi(szFullFileName);

    if (hfResultsTxt == NULL)
    {
#if defined(_MT)
        ReleaseMutex(hmutexTxt);
#endif                
	    return;
	}    

// #if defined(_MT)
    if (!lstrlen(szBugNumber))
        wsprintf(szMTOut, SYSSTR("%s\t%d"), (SYSCHAR FAR * )szMessage, iFailFlag);
    else
        wsprintf(szMTOut, SYSSTR("%s\t%d Bug(s): %s"), (SYSCHAR FAR * )szMessage, iFailFlag, (SYSCHAR FAR * )szBugNumber);

#if defined(WIN32)                
    fseek(hfResultsTxt, icLogFileLocation, SEEK_SET); 
#else // win16
    _llseek(hfResultsTxt, icLogFileLocation, 0); 
#endif       
    FilePrintf(hfResultsTxt,SYSSTR("%-70s\r\n") , (SYSCHAR FAR * )szMTOut);
    apWriteDebugCore(SYSSTR("%-70s\r\n") , (SYSCHAR FAR * )szMTOut);
    lCloseAnsi(hfResultsTxt);
#if defined(_MT)
    ReleaseMutex(hmutexTxt);
#endif
                
    lstrcpyA(szFullFileName, RES_PATH);                
    lstrcatA(szFullFileName, RESULTS_DON);

    hfResultsTxt = lOpenAnsi(szFullFileName);                       
    lCloseAnsi(hfResultsTxt);

    return;
}




#if 0

extern "C" int FAR PASCAL  
apInitPerfCore(SYSCHAR FAR * szServerType, SYSCHAR FAR * szProcType, int bitness, int server_bitness)
{   
    FILETHING hfResultsPrf;
    char      szFullFileName[255];
    SYSCHAR   szMTOut[255];

    
    wsprintf(szMTOut, SYSSTR("*%-30s, %-8s, %d, %d\r\n"), szServerType, szProcType, bitness, server_bitness);

    lstrcpyA(szFullFileName, RES_PATH);        
    lstrcatA(szFullFileName, OLEAUTO_PRF);

#if defined(_MT)
    WaitForSingleObject(hmutexPrf, INFINITE);
#endif                
    hfResultsPrf = lOpenAnsi(szFullFileName);

    if (hfResultsPrf == NULL)
    {
#if defined(_MT)
        ReleaseMutex(hmutexPrf);
#endif                
	    return(-1);
	}    
								   
    if (lWriteAnsi(hfResultsPrf, szMTOut, lstrlen(szMTOut)) == NULL)
    {
#if defined(_MT)
        ReleaseMutex(hmutexPrf);
#endif                
	    return(-1);
	}    

#if defined(WIN32)
    if ((icPrfFileLocation = ftell(hfResultsPrf)) == -1)
    {
#if defined(_MT)    
        ReleaseMutex(hmutexPrf);
#endif        
        lCloseAnsi(hfResultsPrf);                                   
	    return(-1);
    }
#else // win16
    if ((icPrfFileLocation = _llseek(hfResultsPrf, 0, 1)) == HFILE_ERROR)
    {
        lCloseAnsi(hfResultsPrf);                                   
	    return(-1);
    }
#endif     
    else FilePrintf(hfResultsPrf, SYSSTR("%-31s, %8ld, %6.2f\r\n"), SYSSTR("UNKNOWN"), 0, 0.00);


    lCloseAnsi(hfResultsPrf);                                   
#if defined(_MT)
    ReleaseMutex(hmutexPrf);
#endif                

 
    return(0);
}




extern "C" int FAR PASCAL 
apLogPerfCore(SYSCHAR FAR *szTestType, DWORD microsecs, float std_deviation)
{
    FILETHING   hfResultsPrf;
    char        szFullFileName[255];
        
   
    lstrcpyA(szFullFileName, RES_PATH);
    lstrcatA(szFullFileName, OLEAUTO_PRF);                            

#if defined(_MT)
    WaitForSingleObject(hmutexPrf, INFINITE);
#endif                
    hfResultsPrf = lOpenAnsi(szFullFileName);

    if (hfResultsPrf == NULL)
    {
#if defined(_MT)
        ReleaseMutex(hmutexPrf);
#endif                
	    return(-1);
	}    


#if defined(WIN32)                
    fseek(hfResultsPrf, icPrfFileLocation, SEEK_SET); 
#else // win16
    _llseek(hfResultsPrf, icPrfFileLocation, 0); 
#endif       
    FilePrintf(hfResultsPrf, SYSSTR("%-31s, %8ld, %6.2f\r\n"), szTestType, microsecs, std_deviation);
#if defined(WIN32)
    if ((icPrfFileLocation = ftell(hfResultsPrf)) == -1)
    {
#if defined(_MT)    
        ReleaseMutex(hmutexPrf);
#endif        
        lCloseAnsi(hfResultsPrf);                                   
	    return(-1);
    }
#else // win16
    if ((icPrfFileLocation = _llseek(hfResultsPrf, 0, 1)) == HFILE_ERROR)
    {
        lCloseAnsi(hfResultsPrf);                                   
	    return(-1);
    }
#endif     
                
    lCloseAnsi(hfResultsPrf);                                   
#if defined(_MT)
    ReleaseMutex(hmutexPrf);
#endif                
    return(0);
}


#endif //0

/* -------------------------------------------------------------------------
   NAME: apWriteDebugCore

   Description: This function writes a string to the debug window or 
		monochrome monitor or to the results.deb file or to both

   Input: a format sting and a variable number of arguments

   Output: 0 if sucessful, -1 if not

   Revision:

      [0]   12-07-92    BrandonB     Created
   -------------------------------------------------------------------------*/
int FAR _cdecl 
apWriteDebugCore(SYSCHAR FAR * szFormat, ...)
{
    int     x;
    SYSCHAR szBuf[1024];    
//    char    szFullFileName[255];
//    FILETHING hfResultsExtra;
    
#if defined(_ALPHA_)
    va_list args;
    args.offset=4;
#else
    char FAR *args;
#endif    

    if (szFormat != NULL)
    {
#if defined(_ALPHA_)
	args.a0 = ((char FAR *)(&szFormat))+4;
#else
	args =((char FAR *)(&szFormat))+4;
#endif
	x = wvsprintf(szBuf, szFormat, args);
    }
    else return (-1);


    // if (fDebTrace == TRUE) 
        OutputDebugString(szBuf);
			    
/*
    if (fFileTrace == TRUE)
    {
	lstrcpyA(szFullFileName, RES_PATH);        // create full path name
	lstrcatA(szFullFileName, RESULTS_DEB);

	hfResultsExtra = lOpenAnsi(szFullFileName);

	if (hfResultsExtra == NULL)
	    return(-1);       
       
	if (lWriteAnsi(hfResultsExtra, szBuf, lstrlen(szBuf)) == NULL)
	    return(-1);                                     

	lCloseAnsi(hfResultsExtra);                                 // close results file
    }
*/    
    Yield();
    return(0);
}


#if 0


#if defined(UNICODE)
extern "C" int FAR PASCAL
apInitTestA (LPSTR szTestName)
{
	SYSCHAR szTestNameW[255];

	if (lstrlenA(szTestName) <= 126)
	{
		MultiByteToWideChar(CP_ACP,
				    MB_PRECOMPOSED,
				    szTestName,
				    -1,
				    szTestNameW,
				    255);

		return apInitTestCore (szTestNameW);
	}
	else
	{
		return -1;
	}
}


extern "C" int FAR  PASCAL
apInitScenarioA (LPSTR szScenarioName)
{
	SYSCHAR szScenarioNameW[255];

	if (lstrlenA(szScenarioName) <= 126)
	{
		MultiByteToWideChar(CP_ACP,
				    MB_PRECOMPOSED,
				    szScenarioName,
				    -1,
				    szScenarioNameW,
				    255);

		return apInitScenarioCore(szScenarioNameW);
	}
	else
	{
		return -1;
	}
}


// ANSI version that is exposed when the system is unicode version
/* -------------------------------------------------------------------------
   NAME: apLogFailInfoA

   Description: This call takes four ansi strings, converts them to
		unicode and calls the wide version of apLogFailInfo.

   Input: szDescription - LPSTR describing what went wrong
	  szExpected - LPSTR expected value of testcase
	  szActual - LPSTR actual value of testcase
	  szBugNum - LPSTR bug number in RAID data base

   Output: (return) - 0 if no error, -1 if there was an error

   Revision:

      [0]   11-24-92    ChrisKau     Created
      [1]   12-04-92    BrandonB     changed to use only windows call
	  [2]   01-18-94        Mesfink          modified to enable UNICODE.            
      [3]   02-03-94    ChrisK       Made apLogFailInfoA out of everything else
   -------------------------------------------------------------------------*/
// this should be an even number for 'nice' reasons

extern "C" int FAR PASCAL
apLogFailInfoA (LPSTR szDescription, LPSTR szExpected,
		LPSTR szActual, LPSTR szBugNum)
{
	SYSCHAR szDescriptionW[APLOGFAIL_MAX];
	SYSCHAR szExpectedW[APLOGFAIL_MAX];
	SYSCHAR szActualW[APLOGFAIL_MAX];
	SYSCHAR szBugNumW[APLOGFAIL_MAX];

	if (lstrlenA(szDescription) <= (APLOGFAIL_MAX))
	if (lstrlenA(szExpected) <= (APLOGFAIL_MAX))
	if (lstrlenA(szActual) <= (APLOGFAIL_MAX))
	if (lstrlenA(szBugNum) <= (APLOGFAIL_MAX)) {

		MultiByteToWideChar(CP_ACP,
				    MB_PRECOMPOSED,
				    szDescription,
				    -1,
				    szDescriptionW,
				    APLOGFAIL_MAX);

		MultiByteToWideChar(CP_ACP,
				    MB_PRECOMPOSED,
				    szExpected,
				    -1,
				    szExpectedW,
				    APLOGFAIL_MAX);

		MultiByteToWideChar(CP_ACP,
				    MB_PRECOMPOSED,
				    szActual,
				    -1,
				    szActualW,
				    APLOGFAIL_MAX);

		MultiByteToWideChar(CP_ACP,
				    MB_PRECOMPOSED,
				    szBugNum,
				    -1,
				    szBugNumW,
				    APLOGFAIL_MAX);

		return (apLogFailInfoCore(szDescriptionW, szExpectedW, szActualW, szBugNumW));
	}
	else
	{
		return (-1);
	}
	else
	{
		return (-1);
	}
	else
	{
		return (-1);
	}
	else
	{
		return (-1);
	}

}



/* -------------------------------------------------------------------------
   NAME: apWriteDebugA

   Description: This function writes a string to the debug window or 
		monochrome monitor or to the results.deb file or to both

   Input: a format sting and a variable number of arguments

   Output: 0 if sucessful, -1 if not

   Revision:

      [0]   02-04-94    BrandonB     Created
   -------------------------------------------------------------------------*/
extern "C" int FAR _cdecl 
apWriteDebugA(char FAR * szFormat, ...)
{
    int     x;
    char    szANSIBuf[1024];    
//    FILETHING hfResultsExtra;
//    char    szFullFileName[255];
        
#if defined(_ALPHA_)
    va_list args;
    args.offset=4;
#else
    char FAR *args;
#endif    

    if (szFormat != NULL)
    {
#if defined(_ALPHA_)
	args.a0 = ((char FAR *)(&szFormat))+4;
#else
	args =((char FAR *)(&szFormat))+4;
#endif
	x = wvsprintfA(szANSIBuf, szFormat, args);
    }
    else return (-1);


    // if (fDebTrace == TRUE) 
        OutputDebugStringA(szANSIBuf);
			    
/*
    if (fFileTrace == TRUE)
    {
	lstrcpyA((char FAR * )szFullFileName, (char FAR * )RES_PATH);        
	lstrcatA((char FAR * )szFullFileName, (char FAR * )RESULTS_DEB);

	hfResultsExtra = lOpenAnsi(szFullFileName);

       
	if (hfResultsExtra == NULL)
	    return(-1);                                          
       
	fwrite( (LPSTR)szANSIBuf, 1, lstrlenA(szANSIBuf), hfResultsExtra);

	lCloseAnsi(hfResultsExtra);                                 
    }
*/
    Yield();
    return(0);
}





extern "C" int FAR PASCAL  
apInitPerfA(char * szServerType, char * szProcType, int bitness, int server_bitness)
{
	SYSCHAR szServerTypeW[255];
	SYSCHAR szProcTypeW[255];

	if ((lstrlenA(szServerType) <= 254) && (lstrlenA(szProcType) <= 254))
	{
		MultiByteToWideChar(CP_ACP,
				    MB_PRECOMPOSED,
				    szServerType,
				    -1,
				    szServerTypeW,
				    255);
				    
		MultiByteToWideChar(CP_ACP,
				    MB_PRECOMPOSED,
				    szProcType,
				    -1,
				    szProcTypeW,
				    255);

		return apInitPerfCore(szServerTypeW, szProcTypeW, bitness, server_bitness);
	}
	else
	{
		return(-1);
	}
}




extern "C" int FAR PASCAL 
apLogPerfA(char *szTestType, DWORD microsecs, float std_deviation)
{
	SYSCHAR szTestTypeW[255];

	if (lstrlenA(szTestType) <= 254)
	{
		MultiByteToWideChar(CP_ACP,
				    MB_PRECOMPOSED,
				    szTestType,
				    -1,
				    szTestTypeW,
				    255);

		return apLogPerfCore(szTestTypeW, microsecs, std_deviation);
	}
	else
	{
		return(-1);
	}
}










#endif // UNICODE

#endif //0


#if defined(WIN32) && !defined(UNICODE)  // chicago and win32s
#include <wchar.h>

LPWSTR  FAR PASCAL  lstrcatWrap(LPWSTR sz1, LPWSTR sz2)
{
    return wcscat(sz1, sz2);
}


LPWSTR  FAR PASCAL  lstrcpyWrap(LPWSTR sz1, LPWSTR sz2)
{
    return wcscpy(sz1, sz2);
}


int     FAR PASCAL  lstrcmpWrap(LPWSTR sz1, LPWSTR sz2)
{
    return wcscmp(sz1, sz2);
}


int     FAR PASCAL  lstrcmpiWrap(LPWSTR sz1, LPWSTR sz2)
{
    return wcsicmp(sz1, sz2);
}


//int     FAR __cdecl wsprintfWrap(LPWSTR szDest, WCHAR FAR *szFormat, ...)
//{
//    return vswprintf(szDest, szFormat, ((char far *)(&szFormat))+4);
//}

SIZE_T     FAR PASCAL  lstrlenWrap(LPWSTR sz1)
{
    return wcslen(sz1);
}




#if 0

extern "C" int FAR PASCAL
apInitTestW (LPWSTR szTestName)
{
	SYSCHAR szTestNameA[255];

	if (lstrlenWrap(szTestName) <= 126)
	{
		WideCharToMultiByte(CP_ACP,
				    NULL,
				    szTestName,
				    -1,
				    szTestNameA,
				    255, NULL, NULL);

		return apInitTestCore(szTestNameA);
	}
	else
	{
		return -1;
	}
}


int     FAR PASCAL  apLogFailInfoW (LPWSTR szDescription, LPWSTR szExpected, LPWSTR szActual, LPWSTR szBugNum);
extern "C" int FAR PASCAL
apLogFailInfoW (LPWSTR szDescription, LPWSTR szExpected,
		LPWSTR szActual, LPWSTR szBugNum)
{
	SYSCHAR szDescriptionA[APLOGFAIL_MAX];
	SYSCHAR szExpectedA[APLOGFAIL_MAX];
	SYSCHAR szActualA[APLOGFAIL_MAX];
	SYSCHAR szBugNumA[APLOGFAIL_MAX];

	if (lstrlenWrap(szDescription) <= (APLOGFAIL_MAX))
	if (lstrlenWrap(szExpected) <= (APLOGFAIL_MAX))
	if (lstrlenWrap(szActual) <= (APLOGFAIL_MAX))
	if (lstrlenWrap(szBugNum) <= (APLOGFAIL_MAX)) 
	{

		WideCharToMultiByte(CP_ACP,
				    NULL,
				    szDescription,
				    -1,
				    szDescriptionA,
				    APLOGFAIL_MAX, NULL, NULL);

		WideCharToMultiByte(CP_ACP,
				    NULL,
				    szExpected,
				    -1,
				    szExpectedA,
				    APLOGFAIL_MAX, NULL, NULL);

		WideCharToMultiByte(CP_ACP,
				    NULL,
				    szActual,
				    -1,
				    szActualA,
				    APLOGFAIL_MAX, NULL, NULL);

		WideCharToMultiByte(CP_ACP,
				    NULL,
				    szBugNum,
				    -1,
				    szBugNumA,
				    APLOGFAIL_MAX, NULL, NULL);

		return (apLogFailInfoCore(szDescriptionA, szExpectedA, szActualA, szBugNumA));
	}
	else
	{
		return (-1);
	}
	else
	{
		return (-1);
	}
	else
	{
		return (-1);
	}
	else
	{
		return (-1);
	}

}




extern "C" int FAR  PASCAL
apInitScenarioW (LPWSTR szScenarioName)
{
	SYSCHAR szScenarioNameA[255];

	if (lstrlenWrap(szScenarioName) <= 126)
	{
		WideCharToMultiByte(CP_ACP,
				    NULL,
				    szScenarioName,
				    -1,
				    szScenarioNameA,
				    255, NULL, NULL);

		return apInitScenarioCore(szScenarioNameA);
	}
	else
	{
		return -1;
	}
}



extern "C" int FAR _cdecl 
apWriteDebugW(WCHAR FAR * szFormat, ...)
{
    int         x;
    SYSCHAR     szBuf[1024];    
    char        szANSIBuf[1024];    
    char FAR   *args;
//    FILETHING   hfResultsExtra;
//    char        szFullFileName[255];
    
    if (szFormat != NULL)
    {
	args =((char FAR *)(&szFormat))+4;
	x = vswprintf((unsigned short *)szBuf, szFormat, args);
    }
    else return (-1);

	WideCharToMultiByte(CP_ACP,
				NULL,
				(unsigned short *)szBuf,
				-1,
				szANSIBuf,
				1024, NULL, NULL);


    // if (fDebTrace == TRUE) 
        OutputDebugString(szANSIBuf);
			    
/*
    if (fFileTrace == TRUE)
    {
	lstrcpyA(szFullFileName, RES_PATH);        
	lstrcatA(szFullFileName, RESULTS_DEB);

	hfResultsExtra = lOpenAnsi(szFullFileName);
	    return(-1);
	     
	if (lWriteAnsi(hfResultsExtra, szANSIBuf, lstrlen(szANSIBuf)) == NULL)
	    return(-1);                                     

	lCloseAnsi(hfResultsExtra);                                 
    }
*/
    Yield();
    return(0);
}




extern "C" int FAR PASCAL
apInitPerfW (LPWSTR szServerType, LPWSTR szProcType, int bitness, int server_bitness)
{
	SYSCHAR szProcTypeA[255];
	SYSCHAR szServerTypeA[255];

		WideCharToMultiByte(CP_ACP,
				    NULL,
				    szServerType,
				    -1,
				    szServerTypeA,
				    255, NULL, NULL);

		WideCharToMultiByte(CP_ACP,
				    NULL,
				    szProcType,
				    -1,
				    szProcTypeA,
				    255, NULL, NULL);

		return apInitPerfCore(szServerTypeA, szProcTypeA, bitness, server_bitness);
}



extern "C" int FAR PASCAL
apLogPerfW (LPWSTR szTestType, DWORD microsecs, float std_deviation)
{
	SYSCHAR szTestTypeA[255];

		WideCharToMultiByte(CP_ACP,
				    NULL,
				    szTestType,
				    -1,
				    szTestTypeA,
				    255, NULL, NULL);

		return apLogPerfCore(szTestTypeA, microsecs, std_deviation);
}






#endif //chicago or win32s


#if defined(WIN16)
extern "C" DATE FAR PASCAL
apDateFromStr(char FAR *str, LCID lcid)
{
    DATE date;
    HRESULT hr;
    
    hr = VarDateFromStr(str, lcid, 0, &date);
    if (hr != NOERROR) return -1;
    else return date;   
}
#endif                   

#endif //0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\btools\tlviewer\cmallspy.cpp ===
#include "hostenv.h"
#include "cmallspy.h"
#include "apglobal.h"

#define cbAlign 32

#define HEADERSIZE cbAlign		// # of bytes of block header					
#define TRAILERSIZE cbAlign		// # of bytes of block trailer
					

static XCHAR g_rgchHead[] = XSTR("OLEAuto Mem Head");	// beginning of block signature
static XCHAR g_rgchTail[] = XSTR("OLEAuto Mem Tail");	// end of block signature

#define MEMCMP(PV1, PV2, CB)	memcmp((PV1), (PV2), (CB))
#define MEMCPY(PV1, PV2, CB)	memcpy((PV1), (PV2), (CB))
#define MEMSET(PV,  VAL, CB)	memset((PV),  (VAL), (CB))

#define MALLOC(CB)		GlobalLock(GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, CB))


CMallocSpy myMallocSpy;		

UINT g_cHeapCheckInterval = 10; // only check full heap every 100 times.



//---------------------------------------------------------------------
//              implementation of the debug allocator
//---------------------------------------------------------------------

CAddrNode32 FAR* CAddrNode32::m_pnFreeList = NULL;

// AddrNodes are allocated in blocks to reduce the number of allocations
// we do for these. Note, we get away with this because the addr nodes
// are never freed, so we can just allocate a block, and thread them
// onto the freelist.
//
#define MEM_cAddrNodes 128
void FAR* CAddrNode32::operator new(size_t /*cb*/)
{
    CAddrNode32 FAR* pn;

    if(m_pnFreeList == NULL)
    {
        pn = (CAddrNode32 FAR*)MALLOC(sizeof(CAddrNode32) * MEM_cAddrNodes);

        for(int i = 1; i < MEM_cAddrNodes-1; ++i)
	        pn[i].m_pnNext = &pn[i+1];
        pn[MEM_cAddrNodes-1].m_pnNext = m_pnFreeList;
        m_pnFreeList = &pn[1];
    }
    else
    {
        pn = m_pnFreeList;
        m_pnFreeList = pn->m_pnNext;
    }
    return pn;
}

void CAddrNode32::operator delete(void FAR* pv)
{
    CAddrNode32 FAR *pn;

    pn = (CAddrNode32 FAR*)pv;
    pn->m_pnNext = m_pnFreeList;
    m_pnFreeList = pn;
}




//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::CMallocSpy
//
//  Synopsis:   Constructor
//
//  Returns:
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
CMallocSpy::CMallocSpy(void)
{
    m_cRef = 0;
    m_fWantTrueSize = FALSE;
    m_cAllocCalls = 0;
    m_cHeapChecks = 0;

    MEMSET(m_rganode, 0, sizeof(m_rganode));
}




//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::~CMallocSpy
//
//  Synopsis:   Destructor
//
//  Returns:
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
CMallocSpy::~CMallocSpy(void)
{
    CheckForLeaks();
}




//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::QueryInterface
//
//  Synopsis:   Only IUnknown and IMallocSpy are meaningful
//
//  Arguments:  [riid] --
//              [ppUnk] --
//
//  Returns:    S_OK or E_NOINTERFACE
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
HRESULT CMallocSpy::QueryInterface(REFIID riid, LPVOID *ppUnk)
{
    HRESULT hr = S_OK;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppUnk = (IUnknown *) this;
    }
    else if (IsEqualIID(riid, IID_IMallocSpy))
    {
        *ppUnk =  (IMalloc *) this;
    }
    else
    {
        *ppUnk = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return hr;
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::AddRef
//
//  Synopsis:   Add a reference
//
//  Returns:    New reference count
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
ULONG CMallocSpy::AddRef(void)
{
    return ++m_cRef;
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::Release
//
//  Synopsis:   Remove a reference
//
//  Returns:    The new reference count
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
ULONG CMallocSpy::Release(void)
{
    ULONG cRef;

    cRef = --m_cRef;

    if (cRef == 0) 
    {
#if 0	// don't delete -- we're statically allocated
        delete this;
#endif 
    }
    return cRef;
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::PreAlloc
//
//  Synopsis:   Called prior to OLE calling IMalloc::Alloc
//
//  Arguments:  [cbRequest] -- The number of bytes the caller of
//                             is requesting IMalloc::Alloc
//
//  Returns:    The count of bytes to actually allocate
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
SIZE_T CMallocSpy::PreAlloc(SIZE_T cbRequest)
{
    HeapCheck();

    return cbRequest + HEADERSIZE + TRAILERSIZE;
}




//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::PostAlloc
//
//  Synopsis:   Called after OLE calls IMalloc::Alloc
//
//  Arguments:  [pActual] -- The allocation returned by IMalloc::Alloc
//
//  Returns:    The allocation pointer to return to the caller of
//              IMalloc::Alloc
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
void *CMallocSpy::PostAlloc(void *pActual)
{
    IMalloc *pmalloc;
    SIZE_T cbRequest;
    HRESULT hresult;
    XCHAR sz[20];

    if (pActual == NULL)		// if real alloc failed, then
	    return NULL;			// propogate failure

    if (FAILED(hresult = CoGetMalloc(MEMCTX_TASK, &pmalloc))) 
    {
        apSPrintf(sz, XSTR("%lX"), hresult);
        apLogFailInfo(XSTR("ERROR:CoGetMalloc failed!!!"), XSTR("NOEEROR"), sz, XSTR(""));
        return(NULL);
    }

    m_fWantTrueSize = TRUE;
    cbRequest = pmalloc->GetSize(pActual) - HEADERSIZE - TRAILERSIZE;
    m_fWantTrueSize = FALSE;

    pmalloc->Release();

    // set header signature
    MEMCPY(pActual, g_rgchHead, HEADERSIZE);

    // set trailer signature
    MEMCPY((BYTE *)pActual+HEADERSIZE+cbRequest, g_rgchTail, TRAILERSIZE);

    // save info for leak detection
    AddInst((BYTE *)pActual+HEADERSIZE, cbRequest);

    // Return the allocation plus offset
    return (void *) (((BYTE *) pActual) + HEADERSIZE);
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::PreFree
//
//  Synopsis:   Called prior to OLE calling IMalloc::Free
//
//  Arguments:  [pRequest] -- The allocation to be freed
//              [fSpyed]   -- Whether it was allocated with a spy active
//
//  Returns:
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
void *CMallocSpy::PreFree(void *pRequest, BOOL fSpyed)
{
    HeapCheck();

    if (pRequest == NULL)
    {
        return NULL;
    }

    // Undo the offset
    if (fSpyed)
    {
        CAddrNode32 FAR* pn;
        SIZE_T sizeToFree;

    	pn = FindInst(pRequest);

    	// check for attempt to operate on a pointer we didn't allocate
    	if(pn == NULL)
    	{
            apLogFailInfo(XSTR("Attempt to free memory not allocated by this 32-bit test!"), XSTR(""), XSTR(""), XSTR(""));
    	}

    	// check the block we're freeing
    	VerifyHeaderTrailer(pn);

        sizeToFree = pn->m_cb + HEADERSIZE + TRAILERSIZE;

        DelInst(pRequest);

    	// mark entire block as invalid
    	MEMSET((BYTE *) pRequest - HEADERSIZE, '~', sizeToFree);

        return (void *) (((BYTE *) pRequest) - HEADERSIZE);
    }
    else
    {
        return pRequest;
    }
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::PostFree
//
//  Synopsis:   Called after OLE calls IMalloc::Free
//
//  Arguments:  [fSpyed]   -- Whether it was allocated with a spy active
//
//  Returns:
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
void CMallocSpy::PostFree(BOOL /*fSpyed*/)
{
    return;
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::PreRealloc
//
//  Synopsis:   Called prior to OLE calling IMalloc::Realloc
//
//  Arguments:  [pRequest]     -- The buffer to be reallocated
//              [cbRequest]    -- The requested new size of the buffer
//              [ppNewRequest] -- Where to store the new buffer pointer
//                                to be reallocated
//              [fSpyed]       -- Whether it was allocated with a spy active
//
//  Returns:    The new size to actually be allocated
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
SIZE_T CMallocSpy::PreRealloc(void *pRequest, SIZE_T cbRequest, void **ppNewRequest, BOOL fSpyed)
{
    HeapCheck();

    if (fSpyed)
    {
        CAddrNode32 FAR* pn;
        SIZE_T sizeToFree;

	    pn = FindInst(pRequest);

	    // check for attempt to operate on a pointer we didn't allocate
	    if(pn == NULL)
	    {
            apLogFailInfo(XSTR("Attempt to reallocate memory not allocated by this 32-bit test!"), XSTR(""), XSTR(""), XSTR(""));
	    }

        sizeToFree = pn->m_cb;


        *ppNewRequest = (void *) (((BYTE *) pRequest) - HEADERSIZE);

        m_pvRealloc = pRequest;

        return cbRequest + HEADERSIZE + TRAILERSIZE;
    }
    else
    {
        *ppNewRequest = pRequest;
        return cbRequest;
    }
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::PostRealloc
//
//  Synopsis:   Called after OLE calls IMalloc::Realloc
//
//  Arguments:  [pActual] -- Pointer to the reallocated buffer
//              [fSpyed]  -- Whether it was allocated with a spy active
//
//  Returns:    The buffer pointer to return
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
void *CMallocSpy::PostRealloc(void *pActual, BOOL fSpyed)
{
    IMalloc *pmalloc;
    SIZE_T cbRequest;
    HRESULT hresult;
    XCHAR sz[50];

    if (pActual == NULL) 
    {		
	    apLogFailInfo(XSTR("CMallocSpy::PostRealloc - Realloc of a block failed."), XSTR(""), XSTR(""), XSTR(""));
	    return NULL;			
    }

    // Return the buffer with the header offset
    if (fSpyed)
    {
	    DelInst(m_pvRealloc);

        if (FAILED(hresult = CoGetMalloc(MEMCTX_TASK, &pmalloc))) 
        {
        apSPrintf(sz, XSTR("%lX"), hresult);
        apLogFailInfo(XSTR("ERROR:CoGetMalloc failed!!!"), XSTR("NOEEROR"), sz, XSTR(""));
        }

        m_fWantTrueSize = TRUE;
        cbRequest = pmalloc->GetSize(pActual) - HEADERSIZE - TRAILERSIZE;
        m_fWantTrueSize = FALSE;

        pmalloc->Release();

	    if (MEMCMP(pActual, g_rgchHead, HEADERSIZE) != 0)
	    {
            MEMCPY(sz, pActual, HEADERSIZE);
            sz[HEADERSIZE] = 0;
            apLogFailInfo(XSTR("32-bit Memory header not intact!"), g_rgchHead, sz, XSTR(""));
	    }

        // set new trailer signature
        MEMCPY((BYTE *)pActual+HEADERSIZE+cbRequest, g_rgchTail, TRAILERSIZE);

        // save info for leak detection
        AddInst((BYTE *)pActual+HEADERSIZE, cbRequest);

        return (void *) (((BYTE *) pActual) + HEADERSIZE);
    }
    else
    {
        return pActual;
    }
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::PreGetSize
//
//  Synopsis:   Called prior to OLE calling IMalloc::GetSize
//
//  Arguments:  [pRequest] -- The buffer whose size is to be returned
//              [fSpyed]   -- Whether it was allocated with a spy active
//
//  Returns:    The actual buffer with which to call IMalloc::GetSize
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
void *CMallocSpy::PreGetSize(void *pRequest, BOOL fSpyed)
{
    HeapCheck();

    if (fSpyed && !m_fWantTrueSize)
    {
        return (void *) (((BYTE *) pRequest) - HEADERSIZE);
    }
    else
    {
        return pRequest;
    }
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::PostGetSize
//
//  Synopsis:   Called after OLE calls IMalloc::GetSize
//
//  Arguments:  [cbActual] -- The result of IMalloc::GetSize
//              [fSpyed]   -- Whether it was allocated with a spy active
//
//  Returns:    The size to return to the IMalloc::GetSize caller
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
SIZE_T CMallocSpy::PostGetSize(SIZE_T cbActual, BOOL fSpyed)
{
    if (fSpyed && !m_fWantTrueSize)
    {
        return cbActual - HEADERSIZE - TRAILERSIZE;
    }
    else
    {
        return cbActual;
    }
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::PreDidAlloc
//
//  Synopsis:   Called prior to OLE calling IMalloc::DidAlloc
//
//  Arguments:  [pRequest] -- The buffer whose allocation is being tested
//              [fSpyed]   -- Whether it was allocated with a spy active
//
//  Returns:    The buffer whose allocation is actually to be tested
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
void *CMallocSpy::PreDidAlloc(void *pRequest, BOOL fSpyed)
{
    HeapCheck();

    if (fSpyed)
    {
        return (void *) (((BYTE *) pRequest) - HEADERSIZE);
    }
    else
    {
        return pRequest;
    }
}





//+---------------------------------------------------------------------
//
//  Function:   PostDidAlloc
//
//  Synopsis:   Called after OLE calls the IMalloc::DidAlloc
//
//  Arguments:  [pRequest] -- The passed allocation
//              [fSpyed]   -- Whether it was allocated with a spy active
//              [fActual]  -- The result of IMalloc::DidAlloc
//
//  Returns:    The result of IMalloc::DidAlloc
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
BOOL CMallocSpy::PostDidAlloc(void * /*pRequest*/, BOOL /*fSpyed*/, BOOL fActual)
{
    return fActual;
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::PreHeapMinimize
//
//  Synopsis:   Called prior to OLE calling the IMalloc::HeapMinimize
//
//  Returns:
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
void CMallocSpy::PreHeapMinimize(void)
{
    HeapCheck();
    return;
}





//+---------------------------------------------------------------------
//
//  Member:     CMallocSpy::PostHeapMinimize
//
//  Synopsis:   Called after OLE calls the IMalloc::HeapMinimize
//
//  Returns:
//
//  History:    24-Oct-94   Created.
//
//  Notes:
//
//----------------------------------------------------------------------
void CMallocSpy::PostHeapMinimize(void)
{
    return;
}

//---------------------------------------------------------------------
//                     Instance table methods
//---------------------------------------------------------------------
VOID CMallocSpy::MemInstance()
{
    ++m_cAllocCalls;
}


/***
*PRIVATE CMallocSpy::AddInst
*Purpose:
*  Add the given instance to the address instance table.
*
*Entry:
*  pv = the instance to add
*  nAlloc = the allocation passcount of this instance
*
*Exit:
*  None
*
***********************************************************************/
void
CMallocSpy::AddInst(void FAR* pv, SIZE_T cb)
{
    ULONG nAlloc;
    UINT hash;
    CAddrNode32 FAR* pn;

    MemInstance();
    nAlloc = m_cAllocCalls;

    // DebAssert(pv != NULL, "");

    pn = (CAddrNode32 FAR*)new FAR CAddrNode32();

    // DebAssert(pn != NULL, "");

    pn->m_pv = pv;
    pn->m_cb = cb;
    pn->m_nAlloc = nAlloc;

    hash = HashInst(pv);
    pn->m_pnNext = m_rganode[hash];
    m_rganode[hash] = pn;
}


/***
*PRIVATE CMallocSpy::DelInst(void*)
*Purpose:
*  Remove the given instance from the address instance table.
*
*Entry:
*  pv = the instance to remove
*
*Exit:
*  None
*
***********************************************************************/
void
CMallocSpy::DelInst(void FAR* pv)
{
    CAddrNode32 FAR* FAR* ppn, FAR* pnDead;

    for(ppn = &m_rganode[HashInst(pv)]; *ppn != NULL; ppn = &(*ppn)->m_pnNext)
    {
        if((*ppn)->m_pv == pv)
        {
	        pnDead = *ppn;
	        *ppn = (*ppn)->m_pnNext;
	        delete pnDead;
	        return;
        }
    }
    // didnt find the instance
    // DebAssert(FALSE, "memory instance not found");
}


CAddrNode32 FAR*
CMallocSpy::FindInst(void FAR* pv)
{
    CAddrNode32 FAR* pn;

    for(pn = m_rganode[HashInst(pv)]; pn != NULL; pn = pn->m_pnNext)
    {
        if(pn->m_pv == pv)
            return pn;
    }
    return NULL;
}


void
CMallocSpy::DumpInst(CAddrNode32 FAR* pn)
{
    XCHAR     szActual[128];
    
    apSPrintf(szActual, XSTR("Block of %ld bytes leaked in test"), pn->m_cb);    
    apLogFailInfo(XSTR("Memory leaked on release of 32-bit test allocator!"), XSTR("no leak"), szActual, XSTR(""));

         
    // Printf("[%lp]  nAlloc=0x%lx  size=0x%lx\n", pn->m_pv, pn->m_nAlloc, pn->m_cb);
}


/***
*PRIVATE BOOL IsEmpty
*Purpose:
*  Answer if the address instance table is empty.
*
*Entry:
*  None
*
*Exit:
*  return value = BOOL, TRUE if empty, FALSE otherwise
*
***********************************************************************/
BOOL
CMallocSpy::IsEmpty()
{
    UINT u;

    for(u = 0; u < DIM(m_rganode); ++u)
    {
        if(m_rganode[u] != NULL) return FALSE;	// something leaked
    }

    return TRUE;
}

/***
*PRIVATE CMallocSpy::DumpInstTable()
*Purpose:
*  Print the current contents of the address instance table,
*
*Entry:
*  None
*
*Exit:
*  None
*
***********************************************************************/
void
CMallocSpy::DumpInstTable()
{
    UINT u;
    CAddrNode32 FAR* pn;

    for(u = 0; u < DIM(m_rganode); ++u)
    {
        for(pn = m_rganode[u]; pn != NULL; pn = pn->m_pnNext)
        {
	        VerifyHeaderTrailer(pn);
	        DumpInst(pn);
        }
    }
}

/***
*PRIVATE void CMallocSpy::VerifyHeaderTrailer()
*Purpose:
*  Inspect allocations for signature overwrites.
*
*Entry:
*  None
*
*Exit:
*  return value = None.
*
***********************************************************************/
VOID CMallocSpy::VerifyHeaderTrailer(CAddrNode32 FAR* pn)
{
    XCHAR sz[50];
    XCHAR sz2[100];
    
    if (MEMCMP((char FAR*)pn->m_pv + pn->m_cb, g_rgchTail, TRAILERSIZE) != 0) 
    {
        // DumpInst(pn);
        MEMCPY(sz, (char FAR*)pn->m_pv + pn->m_cb, TRAILERSIZE);
        sz[TRAILERSIZE] = 0;
        apSPrintf(sz2, XSTR("32-bit memory trailer corrupt on alloc of %ld bytes"), pn->m_cb);
        apLogFailInfo(sz2, g_rgchTail, sz, XSTR(""));
        apEndTest();
    }
  
    if (MEMCMP((char FAR*)pn->m_pv - HEADERSIZE, g_rgchHead, HEADERSIZE) != 0) 
    {
        // DumpInst(pn);
        MEMCPY(sz, (char FAR*)pn->m_pv - HEADERSIZE, HEADERSIZE);
        sz[HEADERSIZE] = 0;
        apSPrintf(sz2, XSTR("32-bit memory header corrupt on alloc of %ld bytes"), pn->m_cb);
        apLogFailInfo(sz2, g_rgchHead, sz, XSTR(""));
        apEndTest();
    }
}


/***
*PRIVATE void CMallocSpy::HeapCheck()
*Purpose:
*  Inspect allocations for signature overwrites.
*
*Entry:
*  None
*
*Exit:
*  return value = None.
*
***********************************************************************/
VOID CMallocSpy::HeapCheck()
{
    UINT u;
    CAddrNode32 FAR* pn;


    if (m_cHeapChecks++ < g_cHeapCheckInterval) 
    {
	    return;
    }
    m_cHeapChecks = 0;		// reset

    for (u = 0; u < DIM(m_rganode); ++u) 
    {
        for (pn = m_rganode[u]; pn != NULL; pn = pn->m_pnNext) 
        {
	        VerifyHeaderTrailer(pn);
        }
    }
}


void
CMallocSpy::CheckForLeaks()
{
    if (!IsEmpty()) 
    {
        DumpInstTable();
        apEndTest();        // make sure a failure get recorded
    }
}





//---------------------------------------------------------------------
//                     Helper routines
//---------------------------------------------------------------------
STDAPI GetMallocSpy(IMallocSpy FAR* FAR* ppmallocSpy)
{
    *ppmallocSpy = &myMallocSpy;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\btools\tlviewer\cmallspy.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       cmallspy.hxx
//
//  Contents:   CMallocSpy definitions
//
//  Classes:    
//
//  Functions:  
//
//  History:    24-Oct-94   Created.
//
//----------------------------------------------------------------------
#ifdef __cplusplus
extern "C" {
#endif


#define DIM(X) (sizeof(X)/sizeof((X)[0]))

class FAR CAddrNode32
{
public:
    void FAR*           m_pv;	    // instance
    SIZE_T	            m_cb;	    // size of allocation in BYTES
    ULONG               m_nAlloc;	// the allocation pass count
    CAddrNode32 FAR    *m_pnNext;

    void FAR* operator new(size_t cb);
    void operator delete(void FAR* pv);

    static CAddrNode32 FAR* m_pnFreeList;
};




class CMallocSpy : public IMallocSpy
{
public:
    CMallocSpy(void);
    ~CMallocSpy(void);

    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID *ppUnk);
    STDMETHOD_(ULONG, AddRef) (void);
    STDMETHOD_(ULONG, Release) (void);

    
    // IMallocSpy methods
    STDMETHOD_(SIZE_T, PreAlloc) (SIZE_T cbRequest);
    STDMETHOD_(void *, PostAlloc) (void *pActual);

    STDMETHOD_(void *, PreFree) (void *pRequest, BOOL fSpyed);
    STDMETHOD_(void, PostFree) (BOOL fSpyed);

    STDMETHOD_(SIZE_T, PreRealloc) (void *pRequest, SIZE_T cbRequest,
                                   void **ppNewRequest, BOOL fSpyed);
    STDMETHOD_(void *, PostRealloc) (void *pActual, BOOL fSpyed);

    STDMETHOD_(void *, PreGetSize) (void *pRequest, BOOL fSpyed);
    STDMETHOD_(SIZE_T, PostGetSize) (SIZE_T cbActual, BOOL fSpyed);

    STDMETHOD_(void *, PreDidAlloc) (void *pRequest, BOOL fSpyed);
    STDMETHOD_(BOOL, PostDidAlloc) (void *pRequest, BOOL fSpyed, BOOL fActual);

    STDMETHOD_(void, PreHeapMinimize) (void);
    STDMETHOD_(void, PostHeapMinimize) (void);


private:
    ULONG m_cRef;
    BOOL m_fWantTrueSize;
    UINT m_cHeapChecks;
    VOID * m_pvRealloc;			// block we are throwing away during
					            // a realloc

    ULONG m_cAllocCalls;		        // total count of allocation calls
    CAddrNode32 FAR* m_rganode[1024];	// address instance table

    // Instance table methods

    VOID MemInstance();
    VOID HeapCheck();
    void DelInst(void FAR* pv);
    CAddrNode32 FAR* FindInst(void FAR* pv);
    void AddInst(void FAR* pv, SIZE_T cb);
    void DumpInst(CAddrNode32 FAR* pn);
    void VerifyHeaderTrailer(CAddrNode32 FAR* pn);

    inline UINT HashInst(void FAR* pv) const 
    {
      return ((UINT)((ULONG)pv >> 4)) % DIM(m_rganode);
    }

    BOOL IsEmpty(void);
    void DumpInstTable(void);
    void CheckForLeaks();

};

STDAPI GetMallocSpy(IMallocSpy FAR* FAR* ppmallocSpy);


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\btools\tlviewer\hostenv.h ===
/*** 
*hostenv.h
*
*  Copyright (C) 1992-93, Microsoft Corporation.  All Rights Reserved.
*
*Purpose:
*  Generic host specific includes.
*
*Implementation Notes:
*
*****************************************************************************/
#if defined(_MAC)

# include <values.h>
# include <types.h>
# include <strings.h>
# include <quickdraw.h>
# include <fonts.h>
# include <events.h>
# include <resources.h>
# include <windows.h>
# include <menus.h>
# include <textedit.h>
# include <dialogs.h>
# include <desk.h>
# include <toolutils.h>
# include <memory.h>
# include <files.h>
# include <osutils.h>
# include <osevents.h>
# include <diskinit.h>
# include <packages.h>
# include <traps.h>
# include <AppleEvents.h>

#include <stdio.h>

#define HINSTANCE long
#define HWND      long
#define ULONG unsigned long
#define LONG long
#define UINT unsigned int
#define NEARDATA
#define NEAR
#define EXPORT
#define FAR
#define LPVOID void FAR *
#define UNUSED(X) ((void)(void*)&(X))
#define WORD unsigned short
#define BOOL unsigned long
#define DWORD unsigned long
#define TRUE 1
#define FALSE 0
#define SHORT short

#ifndef _PPCMAC
#define PASCAL pascal
#define CDECL  
#else
#define PASCAL
#define CDECL 
#endif

#else
#include <windows.h>
#ifndef CDECL
#define CDECL _cdecl
#endif
#endif

#include <ole2.h>
#include <stdarg.h>
#include <stdio.h>
#if !defined(WIN32)
#include <olenls.h>
#include <dispatch.h>
#else
#include <oleauto.h>
#if defined(_ALPHA_)
//#include <cobjerr.h>
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\btools\tlviewer\osutil32.cpp ===
/*
  Related Files:
  [Section = Compile]
  	%OsUtilDir%:OsUtil.hxx
 [Section =End]

*/
/* -------------------------------------------------------------------------
  Project     : OB - Type Information Interface
  Platform    : Win32
  Module      : osutil.cpp

		Copyright (C) 1992-3, Microsoft Corporation
 ---------------------------------------------------------------------------
  Notes       : Library routines for programs that run under Win32
 ---------------------------------------------------------------------------
  Revision History:
 
	[ 0]	09-Mar-1993		     Angelach: Created Test
	[ 1]	10-Mar-1993		     Angelach: added support to Win32s
        [ 2]    06-Jul-1994                  Angelach: added support for remoting
                                                       typelib testing
	[ 3]	27-Oct-1994		     Angelach: added LCMapStringX
	[ 4]	06-Mar-1995		     Angelach: added osGetNetDrive
	[ 5]	07-Mar-1995		     Angelach: added Memory-leak detection
 --------------------------------------------------------------------------- */

#include "osutil32.hxx"

IMalloc FAR* ppmalloc ; 		       // need for memory allocation
IMallocSpy  FAR* g_IMallocSpy ; 	       // [7]

/*---------------------------------------------------------------------------
 NAME	    : osAllocSpaces

 PURPOSE    : obtains some spaces from the far heap

 INPUTS     : nSize - no of bytes to be allocated

 OUTPUT     : pointer to the allocated space

 NOTES	    : caller is responsible to free up the memory after used

---------------------------------------------------------------------------*/

VOID FAR * osAllocSpaces(WORD nSize)
  {
     return ( (VOID FAR *)malloc(nSize) ) ;
  }

/*---------------------------------------------------------------------------
 NAME	    : osGetRootDir

 PURPOSE    : Retrieves pathspec of the root directory

 INPUTS     : lpszRootDir - storage for the pathspec

 OUTPUT     : none


 NOTES	    :

---------------------------------------------------------------------------*/
VOID FAR osGetRootDir(LPXSTR lpszRootDir)
  {
     osStrCpy(lpszRootDir, XSTR("c:")) ;
     osStrCat(lpszRootDir, szPathSep) ;
  }

/*---------------------------------------------------------------------------
 NAME	    : osGetCurDir

 PURPOSE    : Retrieves pathspec of the current directory

 INPUTS     : lpszCurDir - storage for the pathspec

 OUTPUT     : True if information is retrieved successfully; otherwise, False
	      lpszCurDir contains the pathspec if True

 NOTES	    :

---------------------------------------------------------------------------*/

BOOL FAR osGetCurDir(LPXSTR lpszCurDir)
  {
      int  i ;
#if defined (OAU) && !defined (UNICODE)   // [1]
      char szBufferC[256];

      i = GetCurrentDirectory((DWORD)256, szBufferC) ;

      MultiByteToWideChar(CP_ACP,
			  MB_PRECOMPOSED,
                          szBufferC,
			  -1,
                          lpszCurDir,
                          256);
#else					  // if OAU && ! UNICODE
      i = GetCurrentDirectory((DWORD)256, lpszCurDir) ;
#endif					  // if OAU && ! UNICODE

      if ( i != 0 )
	return TRUE ;			  // info of the current directory
      else				  // is retrieved successfully
	return FALSE ;
  }

/*---------------------------------------------------------------------------
 NAME	    : osMkDir

 PURPOSE    : Creates a subdirectory

 INPUTS     : lpszSubDir - name of the subdirectory to be created

 OUTPUT     : True if subdirectory is created successfully; otherwise, False

 NOTES	    :

---------------------------------------------------------------------------*/

BOOL FAR osMkDir(LPXSTR lpszSubDir)
  {
     SECURITY_ATTRIBUTES sa ;
     BOOL		 rCode ;

     sa.nLength = sizeof(SECURITY_ATTRIBUTES) ;
     sa.lpSecurityDescriptor = NULL ;
     sa.bInheritHandle = FALSE ;

#if defined (OAU) && !defined (UNICODE)  // [1]
      char szBufferS[256];

      WideCharToMultiByte(CP_ACP,
			  0,
			  lpszSubDir,
			  -1,
			  szBufferS,
			  256,
			  NULL,
			  NULL);
     rCode = CreateDirectory(szBufferS, &sa) ;
#else					 // if OAU && ! UNICODE
     rCode = CreateDirectory(lpszSubDir, &sa) ;
#endif					 // if OAU && ! UNICODE

     return rCode;
  }

/*---------------------------------------------------------------------------
 NAME	    : osItoA

 PURPOSE    : Gets the string representation of an integer

 INPUTS     : inVal - the integer in concern
	      lpsz  - the string representation

 OUTPUT     : the string representation of inVal will be returned via lpsz

 NOTES	    :

---------------------------------------------------------------------------*/

VOID FAR  osItoA (int inVal, LPXSTR lpsz)
  {
     char   szlTmp[20] ;

     _itoa(inVal, szlTmp, 10) ;
#ifdef OAU
      MultiByteToWideChar(CP_ACP,
			  MB_PRECOMPOSED,
			  szlTmp,
			  -1,
			  lpsz,
			  20);
#else					 // OAU
     osStrCpy(lpsz, szlTmp) ;
#endif					 // OAU
  }

/*---------------------------------------------------------------------------
 NAME	    : osLtoA

 PURPOSE    : Gets the string representation of a long integer

 INPUTS     : inVal - the long integer in concern
	      lpsz  - the string representation

 OUTPUT     : the string representation of inVal will be returned via lpsz

 NOTES	    :

---------------------------------------------------------------------------*/

VOID FAR  osLtoA (long inVal, LPXSTR lpsz)
  {
     char szlTmp[20] ;

     _ltoa(inVal, szlTmp, 10) ;
#ifdef OAU
      MultiByteToWideChar(CP_ACP,
			  MB_PRECOMPOSED,
			  szlTmp,
			  -1,
			  lpsz,
			  20);
#else					  // OAU
     osStrCpy(lpsz, szlTmp) ;
#endif					  // OAU
  }

/*---------------------------------------------------------------------------
 NAME       : osAtoL

 PURPOSE    : Gets the long integer from a string representing that value

 INPUTS     : lpsz  - the string representation

 OUTPUT     : the long integer

 NOTES	    :

---------------------------------------------------------------------------*/

long FAR osAtoL (LPXSTR lpsz)
  {

#ifdef OAU
      char szlTmp[20];

      WideCharToMultiByte(CP_ACP,
			  0,
                          lpsz,
			  -1,
                          szlTmp,
                          20,
			  NULL,
			  NULL);

     return atol(szlTmp) ;
#else
     return atol(lpsz) ;
#endif

  }


/*---------------------------------------------------------------------------
 NAME	    : osGetNetDrive

 PURPOSE    : Establish/Break a net connection

 INPUTS     : lpszNetDir - string to receieve the network drive letter
	      bnAct - flag for establishing or breaking the net connection
		      TRUE: establish a net connection
		      FALSE: break a net connection

 OUTPUT     : True if net connect is established/broken successfully

 NOTES	    : Since Win32s has no API's that support net work action; this
	      routine does nothing for right now.  It can be modified to
	      establish/break a net connection programmatically in the future.

---------------------------------------------------------------------------*/

BOOL FAR osGetNetDrive(LPXSTR lpszNetDir, LPXSTR lpUNCDir, BOOL /*bnAct*/)	// [4]
  {
     osStrCpy(lpszNetDir, XSTR("z:\\tmp\\")) ;
     osStrCpy(lpUNCDir, XSTR("\\\\apputest\\slm\\tmp\\")) ;

     return TRUE ;
  }


/*---------------------------------------------------------------------------
 NAME	    : osCreateGuid

 PURPOSE    : Converts a GUID value from string to GUID format

 INPUTS     : lpszGuid - string contains the desired GUID value

 OUTPUT     : pointer to the GUID structure

 NOTES	    : caller is responsible to free up the memory after used

---------------------------------------------------------------------------*/

GUID FAR * osCreateGuid(LPXSTR lpszGuid)
   {

     GUID    FAR * lpGuid ;
     HRESULT hRes ;

     lpGuid = (GUID FAR *) osAllocSpaces(sizeof(GUID)*2) ;// allocate space
							  // for the Guid
     if ( lpGuid )
       {					// convert string to GUID format
	  hRes = CLSIDFromStringX(lpszGuid, (LPCLSID)lpGuid);
	  if ( LOWORD (hRes) )
	    {
	      osDeAllocSpaces ((LPXSTR)lpGuid) ; // release space before exit
	      return NULL ;
	    }
	  else
	      return lpGuid ;		  // return pointer to the
       }				  // GUID structure
     else
       return NULL ;			  // no space is allocated

   }

/*---------------------------------------------------------------------------
 NAME	    : osRetrieveGuid

 PURPOSE    : Converts a GUID structure to a readable string format

 INPUTS     : lpszGuid - string representation of the GUID will be returned
	      GUID     - the GUID structure in concern

 OUTPUT     : True if conversion is succeed

 NOTES	    :

---------------------------------------------------------------------------*/

BOOL FAR osRetrieveGuid (LPXSTR lpszGuid, GUID inGuid)
   {
     LPOLESTR   lpszTmp ;
     HRESULT hRes ;
					    // allocate memory for the string
     hRes = StringFromCLSID((REFCLSID) inGuid, &lpszTmp) ;
      if ( LOWORD (hRes) )		    // representation
	{
	   ppmalloc->Free(lpszTmp) ;
	   return FALSE ;
	}
      else
	{
#ifdef OAU
	   osStrCpy (lpszGuid, lpszTmp) ;
#else
	   WideCharToMultiByte(CP_ACP,
			       0,
			       lpszTmp,
			       -1,
			       lpszGuid,
			       40,
			       NULL,
			       NULL);
#endif
	   ppmalloc->Free(lpszTmp) ;
	   return TRUE ;
	}
   }

/*---------------------------------------------------------------------------
 NAME	    : osGetSize

 PURPOSE    : returns size of the input data

 INPUTS     : inVT - data type; WORD

 OUTPUT     : size of inVT; WORD

 NOTES	    :

---------------------------------------------------------------------------*/

WORD FAR osGetSize (WORD inVT)
   {
      WORD tSize ;

      switch ( inVT )
       {
	 case VT_I2:
	   tSize = sizeof(short) ;
	   break ;
	 case VT_I4:
	   tSize = sizeof(long) ;
	   break ;
	 case VT_R4:
	   tSize = sizeof(float) ;
	   break ;
	 case VT_R8:
	   tSize = sizeof(double) ;
	   break ;
	 case VT_CY:
	   tSize = sizeof(CY) ;
	   break ;
	 case VT_DATE:
	   tSize = sizeof(DATE) ;
	   break ;
	 case VT_BSTR:
	   tSize = sizeof(BSTR) ;
	   break ;
	 case VT_ERROR:
	   tSize = sizeof(SCODE) ;
	   break ;
	 case VT_BOOL:
	   tSize = sizeof(VARIANT_BOOL) ;
	   break ;
	 case VT_VARIANT:
	   tSize = sizeof(VARIANT) ;
	   break ;
	 case VT_I1:
	   tSize = sizeof(char) ;
	   break ;
	 case VT_UI1:
	   tSize = sizeof(char) ;
	   break ;
	 case VT_UI2:
	   tSize = sizeof(short) ;
	   break ;
	 case VT_UI4:
	   tSize = sizeof(long) ;
	   break ;
	 case VT_I8:
	   tSize = sizeof(long)*2 ;
	   break ;
	 case VT_UI8:
	   tSize = sizeof(long)*2 ;
	   break ;
	 case VT_INT:
	   tSize = sizeof(int) ;
	   break ;
	 case VT_UINT:
	   tSize = sizeof(int) ;
	   break ;
	 case VT_VOID:
	   tSize = 0 ;
	   break ;
	 case VT_HRESULT:
	   tSize = sizeof(HRESULT) ;
	   break ;
	 case VT_LPSTR:
	   tSize = sizeof(LPSTR) ;
	   break ;
	 case VT_PTR:
	   tSize = 4 ;
	   break ;
	 case VT_SAFEARRAY:
	   tSize = sizeof(ARRAYDESC FAR *) ;
           break ;
         case VT_DISPATCH:
           tSize = 4 ;
           break ;
         case VT_UNKNOWN:
           tSize = 4 ;
	   break ;
	 default:
	   tSize = 1 ;
	   break ;
       }

      return tSize ;
}

/*---------------------------------------------------------------------------
 NAME	    : osGetAlignment

 PURPOSE    : returns value of the alignment

 INPUTS     : inVT - data type; WORD
              mAlign - max possible alignment; WORD

 OUTPUT     : value of the aliangment; WORD

 NOTES	    : value is machine dependent:
		 Win16 = 1 (everything is packed -> always = 1)
                 Win32 = natural alignment; max is 4-byte align
		 mac   = everything is on the even-byte boundary
	      see silver\cl\clutil.cxx for a table of the alignement information
---------------------------------------------------------------------------*/

WORD FAR osGetAlignment (WORD inVT, WORD mAlign)
  {
     WORD expAlign ;

     expAlign = osGetSize(inVT) ;         // check size of the data

     return ( expAlign <= mAlign ? expAlign : mAlign ) ;
  }

/*---------------------------------------------------------------------------
 NAME	    : osGetEnumType

 PURPOSE    : return the type of an enum member

 INPUTS     : none

 OUTPUT     : VT_I2 for Win16; VARTYPE

 NOTES	    :

---------------------------------------------------------------------------*/

VARTYPE FAR osGetEnumType ()
  {
     return VT_I4 ;
  }

/*---------------------------------------------------------------------------
 NAME	    : osOleInit

 PURPOSE    : Calls OleInitialize and returns its return code

 INPUTS     : none

 OUTPUT     : return code from calling OleInitialize; HRESULT

 NOTES	    :

---------------------------------------------------------------------------*/

HRESULT FAR osOleInit ()
  {
     HRESULT hRes ;

     hRes = OleInitialize(NULL) ;      // Ole initialization

#ifdef DEBUG
     if ( hRes != NOERROR )
       return hRes ;

     hRes = GetMallocSpy(&g_IMallocSpy) ;   // [5]
     hRes = CoRegisterMallocSpy(g_IMallocSpy) ;

     if ( hRes != NOERROR )
       OleUninitialize ;
     else
       hRes = CoGetMalloc(MEMCTX_TASK, &ppmalloc) ;
#else
     if ( !LOWORD(hRes) )	       // allocate memory for use in the
       hRes = CoGetMalloc(MEMCTX_TASK, &ppmalloc) ;  // the program
#endif

     return hRes ;

  }

/*---------------------------------------------------------------------------
 NAME	    : osOleUninit

 PURPOSE    : Calls OleUnInitialize

 INPUTS     : none

 OUTPUT     : none

 NOTES	    :

---------------------------------------------------------------------------*/

VOID FAR osOleUninit ()
  {

     ppmalloc->Release () ;	       // release memory that was been
     OleUninitialize ();	       // allocated at OleInitialize
#ifdef DEBUG
     CoRevokeMallocSpy () ;	       // [5]
#endif
  }

/*---------------------------------------------------------------------------
 NAME	    : osMessage

 PURPOSE    : Displays a MessageBox

 INPUTS     : Message to be displayed; a string of characters

 OUTPUT     : none

 NOTES	    :

---------------------------------------------------------------------------*/

VOID FAR osMessage (LPXSTR lpszMsg, LPXSTR lpszTitle)
  {
#if defined (OAU) && !defined (UNICODE)// [1]
      char szBufferM[256];
      char szBufferT[256];

      WideCharToMultiByte(CP_ACP,
			  0,
			  lpszMsg,
			  -1,
			  szBufferM,
			  256,
			  NULL,
			  NULL);

      WideCharToMultiByte(CP_ACP,
			  0,
			  lpszTitle,
			  -1,
			  szBufferT,
			  256,
			  NULL,
			  NULL);
    MessageBox (NULL, szBufferM, szBufferT, MB_OK) ;
#else				       // if OAU && ! UNICODE
    MessageBox (NULL, lpszMsg, lpszTitle, MB_OK) ;
#endif				       // if OAU && ! UNICODE
  }

/*---------------------------------------------------------------------------
 NAME       : osSetErrorMode

 PURPOSE    : For Win16 compatibility

 INPUTS     : eFlag - UINT

 OUTPUT     : UINT

 NOTES      : This routine is for Win16 compatibility purposes

---------------------------------------------------------------------------*/

UINT FAR osSetErrorMode (UINT eFlag)
  {
    return eFlag ;
  }

/*---------------------------------------------------------------------------
 NAME	    : WinMain

 PURPOSE    : Entry point of the test

 INPUTS     : standard inputs

 OUTPUT     : None

 NOTES	    :
---------------------------------------------------------------------------*/
int FAR pascal WinMain(HINSTANCE /*hInstanceCur*/, HINSTANCE /*hInstancePrev*/, LPSTR lpCmdLineA, int /*nCmdShow*/)
   {
#ifdef OAU
	XCHAR lpCmdLine[128];

        MultiByteToWideChar(CP_ACP,
			  MB_PRECOMPOSED,
			  lpCmdLineA,
			  -1,
			  lpCmdLine,
			  128);
#else				      //OAU
#define lpCmdLine	lpCmdLineA
#endif				      //OAU
      mainEntry (lpCmdLine) ;	      // entry point for all programs

      return 1 ;
   }


//======================= Wrapper functions ==================================

#if !defined(OAU)
/*---------------------------------------------------------------------------
 NAME	    : CreateTypeLibA

 PURPOSE    : Creates a typelib name of which is an ANSI string

 INPUTS     : syskind - os that the type library is created on; SYSKIND
	      szFile - name of type library; ANSI string
	      ppctlib - pointer to the created library

 OUTPUT     : None

 NOTES	    :
---------------------------------------------------------------------------*/
STDAPI
CreateTypeLibA(SYSKIND syskind, char * szFile, ICreateTypeLibA * * ppctlib)
  {				      // [1]
    OLECHAR	   szFileW[_MAX_PATH] ;
    ICreateTypeLib * ptlibW ;
    HRESULT	   hresult ;

    MultiByteToWideChar(CP_ACP,
			MB_PRECOMPOSED,
			szFile,
			-1,
			szFileW,
			_MAX_PATH);

    hresult = CreateTypeLib(syskind, szFileW, &ptlibW);

    if (hresult == NOERROR)
      {
	hresult = ptlibW->QueryInterface(IID_ICreateTypeLibA, (VOID **)ppctlib);
        ptlibW->Release();
      }
    return hresult;
  }

/*---------------------------------------------------------------------------
 NAME       : LHashValOfNameSysA

 PURPOSE    : Finds the hash value for a given string

 INPUTS     : syskind - current operating system
              lcid - lcid of the currenet system
              szName - string in concern; ANSI string

 OUTPUT     : Return LHashValOfNameSys

 NOTES	    :
---------------------------------------------------------------------------*/
STDAPI_(unsigned long)
LHashValOfNameSysA(SYSKIND syskind, LCID lcid, char * szName)
  {
    OLECHAR szNameW[_MAX_PATH];

    if ( szName )
      {
         MultiByteToWideChar(CP_ACP,
			MB_PRECOMPOSED,
			szName,
			-1,
			szNameW,
			_MAX_PATH);

         return LHashValOfNameSys(syskind, lcid, szNameW) ;
      }
    else
         return LHashValOfNameSys(syskind, lcid, NULL) ;

  }

/*---------------------------------------------------------------------------
 NAME	    : LoadTypeLibA

 PURPOSE    : Loads a typelib name of which is an ANSI string

 INPUTS     : szFile - name of type library; ANSI string
	      pptlib - pointer to the loaded library

 OUTPUT     : None

 NOTES	    :
---------------------------------------------------------------------------*/
STDAPI
LoadTypeLibA(char * szFile, ITypeLibA * * pptlib)
  {
    OLECHAR szFileW[_MAX_PATH];
    ITypeLib * ptlibW;
    HRESULT hresult = (HRESULT) E_INVALIDARG ;

    if ( szFile && pptlib )
      {
         MultiByteToWideChar(CP_ACP,
			MB_PRECOMPOSED,
			szFile,
			-1,
			szFileW,
			_MAX_PATH);

         hresult = LoadTypeLibEx(szFileW, REGKIND_NONE, &ptlibW);

         if (hresult == NOERROR)       // convert the wide pointer to a narrow
           {                           // one
              hresult = ptlibW->QueryInterface(IID_ITypeLibA, (VOID **)pptlib);
              ptlibW->Release();
           }
       }

    return hresult;
  }


/*---------------------------------------------------------------------------
 NAME       : LoadRegTypeLibA

 PURPOSE    : Loads a typelib according to the info from the registry

 INPUTS     : rguid - GUID of the library
              wVerMajor - Major version number of the library
              wVerMinor - Minor version number of the library
              pptlib - pointer to receive the library; an ANSI pointer

 OUTPUT     : result from LoadRegTypeLib

 NOTES	    :
---------------------------------------------------------------------------*/
STDAPI
LoadRegTypeLibA(REFGUID rguid, unsigned short wVerMajor, unsigned short wVerMinor, LCID lcid, ITypeLibA * * pptlib)
  {
    ITypeLib * ptlibW;
    HRESULT hresult;

    hresult = LoadRegTypeLib(rguid, wVerMajor, wVerMinor, lcid, &ptlibW);

    if (hresult == NOERROR) {         // convert the wide pointer to a narrow
	hresult = ptlibW->QueryInterface(IID_ITypeLibA, (VOID **)pptlib);
        ptlibW->Release();            // one
    }
    return hresult;
  }


/*---------------------------------------------------------------------------
 NAME       : RegisterTypeLibA

 PURPOSE    : Adds information of a library to the system registry

 INPUTS     : ptlib - pointer to the library; an ANSI pointer
              szFullPath - pathspec of the library; ANSI string
              szHelpDir - pathspec of the help file; ANSI string

 OUTPUT     : result from RegisterTypeLib

 NOTES	    :
---------------------------------------------------------------------------*/
STDAPI
RegisterTypeLibA(ITypeLibA FAR * ptlib, char * szFullPath,  char * szHelpDir)
  {
    OLECHAR  szPathW[_MAX_PATH];
    OLECHAR  szHelpW[_MAX_PATH];
    ITypeLib FAR * ptlibW = NULL ;
    BOOL     PathOk = FALSE , HelpOk = FALSE ;
    HRESULT  hresult = (HRESULT) TYPE_E_LIBNOTREGISTERED ;

    if ( !ptlib )                     // ptlib == NULL
      return (HRESULT) E_INVALIDARG ;

    ptlibW = ITypeLibWFromA(ptlib) ;  // convert the narrow pointer to a wide
                                      // one
    if ( ptlibW )                     // check if the pathspec is NULL or not
      {                               // if it is not, convert the ANSI path
        if ( szFullPath )             // to an UNICODE path
            {
               MultiByteToWideChar(CP_ACP,
			MB_PRECOMPOSED,
			szFullPath,
			-1,
			szPathW,
                        _MAX_PATH);
               PathOk = TRUE ;
            }

        if ( szHelpDir )
            {
               MultiByteToWideChar(CP_ACP,
			MB_PRECOMPOSED,
			szHelpDir,
			-1,
			szHelpW,
                        _MAX_PATH);
               HelpOk = TRUE ;
            }

        if ( PathOk && HelpOk )       // if both pathspec's are not NULL
           hresult = RegisterTypeLib(ptlibW, szPathW, szHelpW);
        else
          {
             if ( PathOk )            // here if helpdir is NULL
                hresult = RegisterTypeLib(ptlibW, szPathW, NULL);
             else                     // here if pathspec of library is NULL
                hresult = RegisterTypeLib(ptlibW, NULL, szHelpW);
          }

        ptlibW->Release();
     }

    return hresult;
  }

/*---------------------------------------------------------------------------
 NAME	    : CLSIDFromStringA

 PURPOSE    : Converts an ANSI string to a UUID

 INPUTS     : szG - string that represents a UUID; ANSI string
	      lpG - pointer to the UUID

 OUTPUT     : return code form CLSIDFromString

 NOTES	    :
---------------------------------------------------------------------------*/
STDAPI
CLSIDFromStringA(char * szG, LPCLSID lpG)
  {
    OLECHAR szGW[100];

    MultiByteToWideChar(CP_ACP,
			MB_PRECOMPOSED,
			szG,
			-1,
			szGW,
			100);

    return CLSIDFromString(szGW, (LPCLSID)lpG) ;
  }


/*---------------------------------------------------------------------------
 NAME	    : IIDFromStringA

 PURPOSE    : Converts an ANSI string to an IID

 INPUTS     : szA   - string that represents a IID; ANSI string
	      lpiid - pointer to the iid

 OUTPUT     : Return code form IIDFromString

 NOTES	    :
---------------------------------------------------------------------------*/
STDAPI
IIDFromStringA(LPSTR lpszA, LPIID lpiid)
  {
    OLECHAR szAW[100];

    MultiByteToWideChar(CP_ACP,
			MB_PRECOMPOSED,
			lpszA,
			-1,
			szAW,
			100);

    return IIDFromString(szAW, (LPIID)lpiid) ;
  }


/*---------------------------------------------------------------------------
 NAME       : StgCreateDocfileA

 PURPOSE    : Creates a doc file

 INPUTS     : pwcsName - name of the doc file; ANSI string
              grfMode - creation mode
              ppstgOpenA - pointer the storage

 OUTPUT     : Return code from StgCreateDocfile

 NOTES	    :
---------------------------------------------------------------------------*/
STDAPI StgCreateDocfileA(LPCSTR pwcsName, DWORD grfMode, DWORD reserved, IStorage * *ppstgOpenA)
  {
    OLECHAR szNameW[100];

    MultiByteToWideChar(CP_ACP,
			MB_PRECOMPOSED,
			pwcsName,
			-1,
			szNameW,
			100);

    return StgCreateDocfile(szNameW, grfMode, reserved, ppstgOpenA) ;
  }


/*---------------------------------------------------------------------------
 NAME       : CreateFileMonikerA

 PURPOSE    : Creates a doc file

 INPUTS     : szfName - name of the file spec; ANSI string
              pmk - pointer the moniker

 OUTPUT     : Return code from CreateFileMoniker

 NOTES	    :
---------------------------------------------------------------------------*/
STDAPI CreateFileMonikerA (char * szfName, LPMONIKER FAR * pmk)  // [2]
 {
    OLECHAR szNameW[128];

    MultiByteToWideChar(CP_ACP,
			MB_PRECOMPOSED,
                        szfName,
			-1,
			szNameW,
                        128);

    return CreateFileMoniker(szNameW, pmk) ;
  }

#endif				      // if !OAU


#if defined(OAU) && !defined(UNICODE) // [1]
/*---------------------------------------------------------------------------
 NAME	    : osKillFile

 PURPOSE    : Removes a specific file from the disk

 INPUTS     : szFile - name of file to be removed; UNICODE string

 OUTPUT     : Output from DeleteFile

 NOTES	    :
---------------------------------------------------------------------------*/
int osKillFile (XCHAR * szFile)
  {
      char szBuffer[256];

      WideCharToMultiByte(CP_ACP,
			  0,
			  szFile,
			  -1,
			  szBuffer,
			  256,
			  NULL,
			  NULL);

      return DeleteFile (szBuffer) ;
  }

/*---------------------------------------------------------------------------
 NAME	    : osRmDir

 PURPOSE    : Removes a specific directory from the disk

 INPUTS     : szDir - name of directory to be removed; UNICODE string

 OUTPUT     : Output from RemoveDirectory

 NOTES	    :
---------------------------------------------------------------------------*/
int osRmDir    (XCHAR * szDir)
  {
      char szBuffer[256];

      WideCharToMultiByte(CP_ACP,
			  0,
			  szDir,
			  -1,
			  szBuffer,
			  256,
			  NULL,
			  NULL);

      return RemoveDirectory(szBuffer) ;
  }

/*---------------------------------------------------------------------------
 NAME	    : LCMapStringX

 PURPOSE    : Converts one string of characters to another

 INPUTS     : lcid - Locale context fo the mapping; LCID
	      dw1  - type of mapping; unsigned long
	      sz1  - string for conversion; UNICODE string
	      i1   - number of characters in sz1; int
	      sz2  - buffer to store the resulting string; UNICODE string
	      i2   - number of characters converted

 OUTPUT     : Output from LCMapStringA

 NOTES	    :
---------------------------------------------------------------------------*/
int LCMapStringX  (LCID lcid, DWORD dw1, LPXSTR sz1, int i1, LPXSTR sz2, int i2) // [3]
  {
      char szBuf1[300];
      char szBuf2[300];
      int  retval ;

      WideCharToMultiByte(CP_ACP,
			  0,
			  sz1,
			  -1,
			  szBuf1,
			  300,
			  NULL,
			  NULL);

      retval = LCMapStringA(lcid, dw1, szBuf1, i1, szBuf2, i2) ;

      MultiByteToWideChar(CP_ACP,
			  MB_PRECOMPOSED,
			  szBuf2,
			  -1,
			  sz2,
			  300);

      return retval ;
  }

#endif				      // if OAU && !UNICODE

#ifdef OAU


/*---------------------------------------------------------------------------
 NAME       : fopenX

 PURPOSE    : Opens a file for read/write

 INPUTS     : szFilName - name of file to be open; UNICODE string
              szMode - purpose for the file; UNICODE string

 OUTPUT     : Return code from fopen

 NOTES	    :
---------------------------------------------------------------------------*/
FILE * fopenX(XCHAR * szFilName, XCHAR * szMode)
  {
      char  szANSITmp1[256];
      char  szANSITmp2[256];

      WideCharToMultiByte(CP_ACP,
			  0,
			  szFilName,
			  -1,
			  szANSITmp1,
			  256,
			  NULL,
			  NULL);

      WideCharToMultiByte(CP_ACP,
			  0,
			  szMode,
			  -1,
			  szANSITmp2,
			  256,
			  NULL,
			  NULL);

      return fopen(szANSITmp1, szANSITmp2) ;  // open output as an ANSI file
  }


/*---------------------------------------------------------------------------
 NAME       : fputsX

 PURPOSE    : Writes to a file for read/write

 INPUTS     : szBuf - data to be written; UNICODE string
              hFile - handle of the output file

 OUTPUT     : Return code from fputs

 NOTES	    :
---------------------------------------------------------------------------*/
int fputsX(XCHAR *szBuf, FILE *hFile)
   {
      char  szANSITmp[512];

      WideCharToMultiByte(CP_ACP,
			  0,
			  szBuf,
			  -1,
			  szANSITmp,
			  512,
			  NULL,
			  NULL);

     return fputs(szANSITmp, hFile)  ;
  }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\btools\tlviewer\tlviewer.cpp ===
/* 
    Related Files:
	[Section=Compile]
		%TlViewerDir%:tlviewer.hxx
	  	[Platform= 3] %ApGlobalSrcDir%:apglobal.h
		%OsUtilDir%:osutil.hxx
	[Section=Link]
		[Options=NO_COPY] tlviewer.obj
		OsUtil.obj %OsUtilDir%:OsUtil.cpp
		[Platform= 6,7,8 Options=CVTRES] _resfile.obj %TlViewerDir%:RcBuild.ins
		[Platform= 6,7,8 Options=product] ole32.lib
		[Platform= 6,7,8 Options=product] oleaut32.lib
		[Platform= 6,7,8 Options=product] uuid.lib
		[Platform= 6,7,8 Options=SYSTEM_LIB] kernel32.lib
		[Platform= 6,7,8 Options=SYSTEM_LIB] user32.lib
		[Platform= 6,7,8 Options=C_LIB] libc.lib

               [Platform= 3 Options=C_LIB] libw.lib
               [Platform= 3 Options=C_LIB] mlibcew.lib
               [Platform= 3 Options=Product] typelib.lib
               [Platform= 3 Options=Product] ole2disp.lib
               [Platform= 3 Options=Product] ole2.lib
        	[Platform= 3 Options=DEFFILE] %TlViewerDir%:%platform%:tlviewer.def

		[Platform= 1] %BuildLibs%:Ole2Auto.far.debug.o
		[Platform= 1] %BuildLibs%:Ole2Lib.far.debug.o
		[Platform= 1] %BuildLibs%:StdCLib.o
		[Platform= 1] %BuildLibs%:Stubs.o
		[Platform= 1] %BuildLibs%:Runtime.o
		[Platform= 1] %BuildLibs%:Interface.o
       [Section=end]

    [ 0]		  Created			   AngelaCh
    [ 1]		  Added additional attributes	   ChrisK
    [ 2]  17-Mar-1994	  Added support for Win32s	   AngelaCh
    [ 3]  08-Apr-1994     Added LPWSTR                     AngelaCh
    [ 4]  08-Apr-1994     Added check for Licensed attr    AngelaCh
    [ 5]  20-Apr-1994     Added check for Alignment        AngelaCh
    [ 6]  24-May-1994     Added check for Source in method AngelaCh
    [ 7]  25-May-1994     Added checks for diff attributes AngelaCh
    [ 8]  19-Dec-1994	  Fixed problem in tOutDaul	   AngelaCh
    [ 9]  08-Feb-1995	  Added support for Null str const AngelaCh
    [10]  08-Feb-1995	  Added support for typeinfo level AngelaCh
			  Restricted attribute
    [11]  08-Feb-1995	  Added support for GetLastError   Angelach
    [12]  18-Apr-1995	  Added support for float's        Angelach
============================================================================== */

#include	"tlviewer.hxx"

const IID IID_ITypeLib2 = {0x00020411,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
const IID IID_ITypeInfo2 = {0x00020412,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

ITypeInfo2 * ptinfo2 = NULL;
ITypeLib2 * ptlib2 = NULL;
BSTRX    g_bstrHelpDll = NULL;		    // name of help DLL

VOID FAR mainEntry (LPXSTR lpCmd)
{
    if ( *lpCmd )
       {
	 ParseCmdLine (lpCmd) ;		     // get name of in/output files
	 ProcessInput () ;		     // read input file
       }
    else
       osMessage(XSTR("Usage: tlviewer <tlbfile> [<outputfile> [Alignment] [</o]]"), XSTR("Tlviewer")) ; // [5]

}

VOID NEAR ParseCmdLine (LPXSTR lpsz)
  {
      XCHAR  szlTmp[fMaxBuffer] ;
      LPXSTR lpszTmp ;			     // name of input type library
					     // is expected to be in the
      lpszTmp = lpsz ;			     // first substring; name of
      lpszTmp = fGetFileName (lpszTmp,  szInputFile) ;
      lpszTmp = fGetFileName (lpszTmp,  szOutputFile) ;
					     // output is in the second
					     // substring if specified
      if ( !*szOutputFile )		     // if no ouput file is
	 osStrCpy ( szOutputFile, defaultOutput ) ;
					     // specified; use default
      lpszTmp = fGetFileName (lpszTmp,  szlTmp) ;  // see if /o
					     // option is given

      isOut = TRUE;		// always as if /o was specified

      if ( osStrCmp(szlTmp, outOpt) == 0 )
         isOut = TRUE ;
      else                                   // if may be specifying an [5]
        if ( *szlTmp )                       // alignment value
          {
             inAlign = (unsigned short) osAtoL(szlTmp); // get alignment value
             lpszTmp = fGetFileName (lpszTmp, szlTmp) ; // see if /o
             if ( osStrCmp(szlTmp, outOpt) == 0 )       // option is given
               isOut = TRUE ;
          }
  }


LPXSTR NEAR fGetFileName (LPXSTR lpszIn, LPXSTR lpszOut)
  {
      int    i = 0 ;
      LPXSTR lpszTmp ;

      lpszTmp = lpszIn ;

      while ( *lpszTmp == ' ' )		     // remove leading spaces
	   lpszTmp++ ;

      while ( *lpszTmp != '\0' && *lpszTmp != ' ') // copy the substring (up
	{					   // to the first space) or
	   lpszOut[i] = *lpszTmp ;		   // the entire string of
	   lpszTmp++ ;				   // lpszIn to lpszOut
	   i++ ;
	}
      lpszOut[i] = '\0' ;

      return lpszTmp ;			     // return the remaining string
  }

VOID NEAR ProcessInput()
  {
      HRESULT	   hRes ;		     // return code
      XCHAR	   szTmp[fMaxBuffer] ;

      hRes = osOleInit () ;		     // ole initialization
      if ( !hRes )
	{				     // load the file
	   hRes = LoadTypeLibX( szInputFile, &ptLib) ; // [2]
	   OutToFile (hRes) ;		     // print result to the
					     // output file
	   osStrCpy(szTmp, szOutputFile) ;
	   osStrCat(szTmp, szOutSuccess) ;

	   if ( isOut )
             {
                 mFile = fopenX(szOutMsgFile, fnWrite);// open message file [2]
                 if (mFile == NULL)
                    {
                       osMessage (XSTR("Fail to open the message file"), XSTR("Tlviewer")) ;
                       osMessage (szTmp, XSTR("Tlviewer")) ;
                    }
                 else
                    {
                       WriteOut(mFile, szTmp) ;
                       fclose(mFile) ;       // finish writing to message file
                       mFile = NULL ;        // close done
                    }
	     }
	   else
	     osMessage (szTmp, XSTR("Tlviewer")) ;

	   osOleUninit () ;
	}
      else
	{
          if ( isOut )
             {
                mFile = fopenX(szOutMsgFile, fnWrite);// open message file [2]
                if (mFile == NULL)
                   {
                      osMessage (XSTR("Fail to open the message file"), XSTR("Tlviewer")) ;
                      osMessage (XSTR("OleInitialize fails"), XSTR("Tlviewer")) ;
                   }
                 else
                   {
                      WriteOut(mFile, XSTR("OleInitialize fails")) ;
                      fclose(mFile) ;
                      mFile = NULL ;
                    }
             }
	  else
	    osMessage (XSTR("OleInitialize fails"), XSTR("Tlviewer")) ;
	}
   }


VOID NEAR OutToFile(HRESULT hRes)
   {
      FILE  *hFile ;			     // file handle
      UINT  tInfoCount ;		     // total number of type info
      int   i ; 			     // note: szTmp is either UNICODE
      XCHAR  szTmp[fMaxBuffer] ;	     //       or ANSI

      hFile = fopenX(szOutputFile, fnWrite); // but we want to open output file [2]
      if (hFile == NULL)                     // as an ANSI file regardless
	{
	   osStrCpy(szTmp, XSTR("Fail to open the output file")) ;
	   osStrCat(szTmp, szOutputFile) ;
           if ( isOut )
             {
                mFile = fopenX(szOutMsgFile, fnWrite);// open message file [2]
                if (mFile == NULL)
                   {
                      osMessage (XSTR("Fail to open the message file"), XSTR("Tlviewer")) ;
                      osMessage (szTmp, XSTR("Tlviewer")) ;
                   }
                 else
                   {
                      WriteOut(mFile, szTmp) ;
                      fclose(mFile) ;
                      mFile = NULL ;
                    }
             }
	   else
	     osMessage (szTmp, XSTR("Tlviewer")) ;
	}
      else
	{
	 WriteOut(hFile, szFileHeader) ;     // output file header

         OLECHAR FAR* pchDir;

         // remove the path.
#if WIN32
         wcscpy(szTmp, szInputFile);
         pchDir = wcsrchr(szTmp, '\\');

         if (pchDir) {
           wcscpy(szTmp, pchDir + 1);
         }
#else // !WIN32
         _fstrcpy(szTmp, szInputFile);

         pchDir = _fstrrchr(szTmp, '\\');

         if (pchDir) {
           _fstrcpy(szTmp, pchDir + 1);
         }
#endif // !WIN32

	 // force path to lower case
#if WIN16
	 AnsiLower(szTmp);
#else //WIN16
	 WCHAR * pch;
	 for (pch = szTmp; *pch != 0; pch++) {
	   if (*pch >= OLECHAR('A') && *pch <= OLECHAR('Z'))
	     *pch = *pch + 'a' - 'A';
	 }
#endif //WIN16

	 WriteOut(hFile, szTmp) ;
	 WriteOut(hFile, szEndStr) ;

	 if ( FAILED(hRes) )		     // if it is not a valid type ****
	    WriteOut(hFile, szInputInvalid) ;// library
	 else
	   {
             // try to QI the typelib for ITypeLib2
             ptLib->QueryInterface(IID_ITypeLib2, (void **)&ptlib2);

      	     if ( fOutLibrary(hFile) )
	       {
		 tInfoCount = ptLib->GetTypeInfoCount() ;
		 for (i = 0 ; i < (int) tInfoCount ; i++)
		   {
		      if ( FAILED(ptLib->GetTypeInfo(i, &ptInfo)) )
			{
			   WriteOut(hFile, szReadFail) ;
			   WriteOut(hFile, XSTR("type info\n\n")) ;
			}
		      else
			{
			  // try to QI it for ITypeInfo2
	   		  ptInfo->QueryInterface(IID_ITypeInfo2, (void **)&ptinfo2);
			  if ( FAILED(ptInfo->GetTypeAttr(&lpTypeAttr)) )
			    {
			      WriteOut(hFile, szReadFail) ;
			      WriteOut(hFile, XSTR("attributes of type info\n\n")) ;
			    }
			  else
                            {
                              expAlign = 0 ;
                              alignFound = FALSE ;
			      switch (lpTypeAttr->typekind)
				{
				  case TKIND_ENUM:
				    tOutEnum(hFile, i) ;
				    break ;

				  case TKIND_RECORD:
				    tOutRecord(hFile, i) ;
				    break ;

				  case TKIND_MODULE:
				    tOutModule(hFile, i) ;
				    break ;

				  case TKIND_INTERFACE:
				    tOutInterface(hFile, i) ;
				    break ;

				  case TKIND_DISPATCH:
				    tOutDispatch(hFile, i) ;
				    break ;

				  case TKIND_COCLASS:
				    tOutCoclass(hFile, i) ;
				    break ;

				  case TKIND_ALIAS:
				    tOutAlias(hFile, i) ;
				    break ;

				  case TKIND_UNION:
				    tOutUnion(hFile, i) ;
				    break ;

			     /*	  case TKIND_ENCUNION:
				    tOutEncunion(hFile, i) ;
				    break ; */

				  default:
				    WriteOut(hFile,  XSTR("Type of definition is unknown\n\n")) ;
				}	     // switch
                               ptInfo->ReleaseTypeAttr (lpTypeAttr) ;
			    }		     // if gettypeattr
			  ptInfo->Release() ;// release the current TypeInfo
	 		  if (ptinfo2) {
			    ptinfo2->Release();
			  }
			}		     // if gettypeinfo
		   }			     // for i
		 WriteOut(hFile, XSTR("}\n")) ; // output the closing }
					     // if fOutLibrary
		 ptLib->Release();	     // clean up before exit
	       }
	    }

	 fclose(hFile);			     // finish writing to the output
	 hFile = NULL;			     // close done

	}
	if (ptlib2) {
	  ptlib2->Release();
	}
	SysFreeString((BSTR)g_bstrHelpDll) ;
  }


VOID  NEAR tOutCustData (FILE *hFile, LPCUSTDATA pCustData)
   {
      XCHAR  szTmp[50] ;
      UINT i;

      for (i = 0; i < pCustData->cCustData; i++) {
					    // get a string representation
					    // for the incoming Guid value
        if ( !(osRetrieveGuid (szTmp, pCustData->prgCustData[i].guid)) )
	   { WriteOut(hFile, szReadFail) ;
	   WriteOut(hFile, XSTR("insufficient memory")) ;
	   }
        else
	 {	    // string is in {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
	   szTmp[37] = '\0' ;	    // format, need to remove the {}
	   WriteAttr(hFile, XSTR("CustomGuid"), &szTmp[1], numValue) ;
	   
           VARIANT * pvar;
	   pvar = &pCustData->prgCustData[i].varValue;
           if ( FAILED(VariantChangeType(pvar, pvar, VARIANT_NOVALUEPROP,  VT_BSTR)) )
	     WriteOut(hFile, XSTR("VariantChangeType fails\n")) ;
	   else {
               WriteAttr(hFile, XSTR("CustomValue"), (BSTRX)pvar->bstrVal, strValue) ;
	   }

	 }
      }
      // done with it -- release all the memory
      ClearCustData(pCustData);
   }

BOOL NEAR fOutLibrary(FILE *hFile)
  {
      TLIBATTR FAR *lpLibAttr ;		     // attributes of the library
      XCHAR    szTmp[16] ;
      BOOL     retval = FALSE ;

      if ( FAILED( ptLib->GetLibAttr(&lpLibAttr) ) )

	{
	   WriteOut(hFile, szReadFail) ;
	   WriteOut(hFile, XSTR("attributes of library\n\n")) ;
	}
      else
	{				     // output documentational
	   tOutAttr(hFile, -1) ;	     // attributes first
					     // output id-related attributes
	   osLtoA((long)lpLibAttr->lcid, szTmp) ; // output lcid;
	   WriteAttr(hFile, attrLcid, szTmp, numValue) ; // default is 0
	   GetVerNumber (lpLibAttr->wMajorVerNum, lpLibAttr->wMinorVerNum, szTmp) ;
	   WriteAttr(hFile, attrVer, szTmp, numValue) ; // output version
	   tOutUUID(hFile, lpLibAttr->guid) ;
					     // output restricted attribute
           if ( (lpLibAttr->wLibFlags & LIBFLAG_FRESTRICTED) == LIBFLAG_FRESTRICTED )
	     WriteAttr(hFile, attrRestrict, NULL, noValue) ;
           if ( (lpLibAttr->wLibFlags & LIBFLAG_FCONTROL) == LIBFLAG_FCONTROL )  // [7]
             WriteAttr(hFile, attrControl, NULL, noValue) ;
           if ( (lpLibAttr->wLibFlags & LIBFLAG_FHIDDEN) == LIBFLAG_FHIDDEN )    // [7]
             WriteAttr(hFile, attrHidden, NULL, noValue) ;

	   if (ptlib2) {
	     // new-format typelib
             XCHAR szTmp[16] ;
	     DWORD cUniqueNames;
	     DWORD cchUniqueNames;
             HRESULT hresult;
	     hresult = ptlib2->GetLibStatistics(&cUniqueNames, &cchUniqueNames);

             osLtoA(cUniqueNames, szTmp);
	     WriteAttr(hFile, XSTR("cUniqueNames"), szTmp, numValue) ;
             osLtoA(cchUniqueNames, szTmp);
	     WriteAttr(hFile, XSTR("cchUniqueNames"), szTmp, numValue) ;

	     CUSTDATA custdata;
	     ptlib2->GetAllCustData(&custdata);
	     tOutCustData(hFile, &custdata);
	   }
	   if ( endAttrFlag )
	     {
	       WriteOut(hFile, szEndAttr) ;
	       endAttrFlag = FALSE ;
	     }
	   ptLib->ReleaseTLibAttr(lpLibAttr) ;	// de-allocate attribute

	   WriteOut(hFile, XSTR("\nlibrary ")) ;
	   tOutName(hFile, MEMBERID_NIL) ;	// output name of library
	   WriteOut(hFile, XSTR("{\n\n")) ;
	   retval = TRUE ;
	}					// if GetLibAttributes
      return (retval) ; 			// before exit
  }

VOID NEAR tOutEnum (FILE *hFile, int iTypeId)
   {
      WriteOut(hFile,  XSTR("\ntypedef\n")); // output typedef first
      tOutAttr(hFile, (int)iTypeId) ;	     // output attribute
      tOutMoreAttr(hFile) ;
      WriteOut(hFile,  XSTR("\nenum {\n")) ;
      tOutVar(hFile) ;                       // output enum members

      WriteOut(hFile,  XSTR("} ")) ;         // close the definition and
      tOutName(hFile, iTypeId) ;             // output name of the enum type
      WriteOut(hFile,  XSTR(" ;")) ;
      if ( inAlign )                         // [5]
        if ( lpTypeAttr->cbAlignment != osGetAlignment(VT_INT, inAlign) )
          tOutAlignError (hFile) ;

      WriteOut(hFile,  XSTR("\n\n")) ;
    }

VOID NEAR tOutRecord (FILE *hFile, int iTypeId)
   {
      WriteOut(hFile,  XSTR("\ntypedef\n")); // output typedef first
      tOutAttr(hFile, (int)iTypeId) ;        // output attribute
      tOutMoreAttr(hFile) ;
      WriteOut(hFile,  XSTR("\nstruct {\n")) ;
      tOutVar (hFile) ;                      // output members

      WriteOut(hFile,  XSTR("} ")) ;
      tOutName(hFile, iTypeId) ;
      WriteOut(hFile,  XSTR(" ;")) ;
      if ( inAlign )                         // [5]
        if ( lpTypeAttr->cbAlignment != expAlign )
           tOutAlignError (hFile) ;
      WriteOut(hFile,  XSTR("\n\n")) ;
   }

VOID  NEAR tOutModule	(FILE *hFile, int iTypeId)
   {
      tOutAttr(hFile, (int)iTypeId) ;	     // output attribute first
      tOutMoreAttr(hFile) ;
      WriteOut(hFile,  XSTR("\nmodule ")) ;
      tOutName(hFile, iTypeId) ;
      WriteOut(hFile, XSTR(" {\n")) ;

      tOutVar (hFile) ; 		     // output each const

      tOutFunc (hFile) ;		     // output each member function
      WriteOut(hFile,  XSTR("}\n\n")) ;
    }

VOID  NEAR tOutInterface(FILE *hFile, int iTypeId)
   {
      HREFTYPE	phRefType ;

      tOutAttr(hFile, (int)iTypeId) ;	     // output attribute first

      tOutMoreAttr(hFile) ;

      WriteOut(hFile,  XSTR("\ninterface ")) ;
      tOutName(hFile, iTypeId) ;
                                             // find out if the interface
      if ( !FAILED(ptInfo->GetRefTypeOfImplType(0, &phRefType)) )
	 {
	   isInherit = TRUE ;
           tOutAliasName(hFile, phRefType) ; // is inherited from some other
           isInherit = FALSE ;               // interface
	 }
      WriteOut(hFile, XSTR(" {\n")) ;

      tOutFunc (hFile) ;                     // output each member function
      if ( inAlign )                         // [5]
         {
           if ( expAlign )                   // is base-interface exists
             {                               // alignment depends on the base-
               if ( lpTypeAttr->cbAlignment != expAlign ) // interface
                 tOutAlignError (hFile) ;
             }
           else                              // otherwise, it depends on
             if ( lpTypeAttr->cbAlignment != osGetAlignment(VT_PTR, inAlign) )
                tOutAlignError (hFile) ;     // size of a pointer
         }
      WriteOut(hFile,  XSTR("}\n\n")) ;
    }

VOID  NEAR tOutDual (FILE *hFile, int iTypeId)  // [7]
   {
      ITypeInfoX FAR *lptInfo ;
      TYPEATTR   FAR *lpAttr ;
      HREFTYPE   phRefType ;

                                             // obtain reference to the
       if ( FAILED(ptInfo->GetRefTypeOfImplType((UINT)MEMBERID_NIL, &phRefType)) )
          {                                  // dual interface
             WriteOut(hFile, szReadFail) ;
             WriteOut(hFile, XSTR("tOutDispach: GetRefTypeOfImpType\n")) ;
          }
       else
          {                                  // get a pointer to the dual
             if ( FAILED(ptInfo->GetRefTypeInfo(phRefType, &lptInfo)) )
               {                             // interface
                 WriteOut(hFile, szReadFail) ;
                 WriteOut(hFile, XSTR("tOutDispatch: GetRefTypeInfo\n")) ;
               }
             else
               {
                 if ( FAILED(lptInfo->GetTypeAttr(&lpAttr)) )
                   {
                     WriteOut(hFile, szReadFail) ;
                     WriteOut(hFile, XSTR("attribute of reftype in tOutDual\n\n")) ;
		     lptInfo->Release () ;   // [8]
                   }
                 else
                   {
                     if ( lpAttr->typekind != TKIND_INTERFACE )
                       {
                         WriteOut(hFile, szReadFail) ;
                         WriteOut(hFile, XSTR("attribute of reftype in tOutDual\n\n")) ;
                         lptInfo->ReleaseTypeAttr (lpAttr) ;
			 lptInfo->Release () ; // [8]
                       }
                     else
		       {
			 ptInfo->ReleaseTypeAttr (lpTypeAttr) ;
			 ptInfo->Release () ;  // release the Dispinterface [8]
			 lpTypeAttr = lpAttr ;
			 ptInfo = lptInfo ;  // now points to the interface
			 tOutInterface(hFile, iTypeId) ; // output the dual interface
                       }
                   }                         // if typekind

               }                             // if GetRefTypeInfo
         }                                   // if GetRefTypeOfImplType
   }

VOID  NEAR tOutDispatch	(FILE *hFile, int iTypeId)
   {
      // dump the dispinterface, and dispinterface versions of dual interfaces
      tOutAttr(hFile, (int)iTypeId) ;   // output attribute first
      tOutMoreAttr(hFile) ;

      WriteOut(hFile,  XSTR("\ndispinterface ")) ;
      tOutName(hFile, iTypeId) ;
      WriteOut(hFile,  XSTR(" {\n")) ;
                                             // if there is no data nor function
      WriteOut(hFile,  XSTR("\nproperties:\n")) ;
      tOutVar (hFile) ;                 // output each date member

      WriteOut(hFile,  XSTR("\nmethods:\n")) ;
      tOutFunc (hFile) ;                // output each member function

                                             // alignment depends on the base-
      if ( inAlign )                    // interface which is stdole.tlb
         if ( lpTypeAttr->cbAlignment != osGetAlignment(VT_PTR, MaxAlignment) )
             tOutAlignError (hFile)  ;  // on that particular system [5]

      WriteOut(hFile,  XSTR("}\n\n")) ;

      // also dump the interface version of dual interfaces
      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FDUAL ) == TYPEFLAG_FDUAL ) // [7]
	{
	  // if dual, also dump the interface portion
	  tOutDual (hFile, iTypeId) ;
	}
    }

VOID  NEAR tOutCoclass	(FILE *hFile, int iTypeId)
   {

      HREFTYPE	phRefType ;
      WORD	i ;
      int	iFlags ;

      tOutAttr(hFile, (int)iTypeId) ;	    // output attribute first
					    // output appobject attribute if
      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FCANCREATE ) == 0 )
           WriteAttr(hFile, XSTR("noncreatable"), NULL, noValue) ;
      tOutMoreAttr(hFile) ;

      WriteOut(hFile,  XSTR("\ncoclass ")) ;// well
      tOutName(hFile, iTypeId) ;
      WriteOut(hFile,  XSTR(" {\n")) ;

      for ( i = 0 ; i < lpTypeAttr->cImplTypes; i++ )
	{
	  if ( FAILED(ptInfo->GetRefTypeOfImplType(i, &phRefType)) )
	    {
	       WriteOut(hFile, szReadFail) ;
	       WriteOut(hFile, XSTR("GetRefTypeOfImpType\n")) ;
	     }
	  else
	    {
	      if ( FAILED(ptInfo->GetImplTypeFlags(i, &iFlags)) )
		{
		  WriteOut(hFile, szReadFail) ;
		  WriteOut(hFile, XSTR("GetImplTypeFlags\n")) ;
		}
	      else
		{			     // output attribute(s)
		   if ( (iFlags & IMPLTYPEFLAG_FDEFAULT) == IMPLTYPEFLAG_FDEFAULT )
		     WriteAttr(hFile, attrDefault, NULL, noValue) ;

		   if ( (iFlags & IMPLTYPEFLAG_FRESTRICTED) == IMPLTYPEFLAG_FRESTRICTED )
		     WriteAttr(hFile, attrRestrict, NULL, noValue) ;

		   if ( (iFlags & IMPLTYPEFLAG_FSOURCE) == IMPLTYPEFLAG_FSOURCE )
		     WriteAttr(hFile, attrSource, NULL, noValue) ;
		   if ( (iFlags & IMPLTYPEFLAG_FDEFAULTVTABLE) == IMPLTYPEFLAG_FDEFAULTVTABLE)
		     WriteAttr(hFile, XSTR("defaultvtable"), NULL, noValue) ;


      		   if (ptinfo2) {
	 	     // new-format typelib -- output more stuff
	 	     CUSTDATA custdata;
	 	     ptinfo2->GetAllImplTypeCustData(i, &custdata);
	 	     tOutCustData(hFile, &custdata);
      		   }

		   if ( endAttrFlag )
		     {
			WriteOut(hFile, szEndAttr) ;
			endAttrFlag = FALSE ;
		     }
		}

	      tOutAliasName(hFile, phRefType) ;
	   }
	}

      if ( inAlign )                        // alignment depends on the base-
        if ( lpTypeAttr->cbAlignment != expAlign ) // interface [5]
           tOutAlignError (hFile) ;
      WriteOut(hFile,  XSTR("}\n\n")) ;
    }

VOID  NEAR tOutAlias	(FILE *hFile, int iTypeId)
   {
      XCHAR szTmp[16] ;

      WriteOut(hFile,  XSTR("\ntypedef ")) ;
      tOutAttr(hFile, (int)iTypeId) ;	    // output attribute first
      WriteAttr(hFile, attrPublic, szTmp, noValue) ; // public attr
      tOutMoreAttr(hFile) ;

      tOutType(hFile, lpTypeAttr->tdescAlias) ;  // output name of base-type

      tOutName(hFile, iTypeId) ;		 // output name of new type
      WriteOut(hFile,  XSTR(";")) ;
      if ( inAlign )                        // alignment of the alias with
        if ( lpTypeAttr->cbAlignment != expAlign )
            tOutAlignError (hFile) ;        // that of the basetype [5]

      WriteOut(hFile,  XSTR("\n\n")) ;
    }

VOID NEAR tOutUnion (FILE *hFile, int iTypeId)
   {
      WriteOut(hFile,  XSTR("\ntypedef\n")); // output typedef first
      tOutAttr(hFile, (int)iTypeId) ;	    // output attribute
      tOutMoreAttr(hFile) ;
      WriteOut(hFile,  XSTR("\nunion {\n")) ;
      tOutVar (hFile) ; 		    // output members

      WriteOut(hFile,  XSTR("} ")) ;
      tOutName(hFile, iTypeId) ;
      WriteOut(hFile,  XSTR(" ;")) ;
      if ( inAlign )                        // [5]
         if ( lpTypeAttr->cbAlignment != expAlign )
            tOutAlignError (hFile) ;

      WriteOut(hFile,  XSTR("\n\n")) ;
   }


VOID NEAR tOutEncunion (FILE *hFile, int iTypeId)
   {
      WriteOut(hFile,  XSTR("\ntypedef\n")); // output typedef first
      tOutAttr(hFile, (int)iTypeId) ;	    // output attribute
      tOutMoreAttr(hFile) ;
      WriteOut(hFile,  XSTR("\nencunion {\n")) ;
      tOutVar (hFile) ; 		    // output members

      WriteOut(hFile,  XSTR("} ")) ;
      tOutName(hFile, iTypeId) ;
      WriteOut(hFile,  XSTR(" ;\n\n")) ;
   }


VOID NEAR tOutName (FILE *hFile, int iTypeId)
   {
      BSTRX bstrName ;

      if ( FAILED(ptLib->GetDocumentation(iTypeId, &bstrName, NULL, NULL, NULL)) )
	{
	   WriteOut(hFile, szReadFail) ;
	   WriteOut(hFile, XSTR("name of type definition")) ;
	}
      else
	{
	   WriteOut(hFile,  bstrName) ;
	   WriteOut(hFile,  XSTR(" ")) ;

	   if ( iTypeId == -1 ) 	    // record name of the library
	     osStrCpy(szLibName, bstrName) ;

	   SysFreeString((BSTR)bstrName) ;
	}
   }

VOID NEAR tOutType (FILE *hFile, TYPEDESC tdesc)
   {
      XCHAR szTmp[20] ;

      if ( inAlign && tdesc.vt != VT_USERDEFINED && tdesc.vt != VT_CARRAY && !alignFound )  // [5]
         {
            if ( expAlign < osGetAlignment(tdesc.vt, inAlign) )
               expAlign = osGetAlignment(tdesc.vt, inAlign) ;
            alignFound = TRUE ;
         }

      switch (tdesc.vt)
	{
	  case VT_EMPTY:
	    osStrCpy ( szTmp,  XSTR("notSpec ") ) ;
	    break ;
	  case VT_NULL:
	    osStrCpy ( szTmp,  XSTR("NULL ") ) ;
	    break ;
	  case VT_I2:
	    osStrCpy ( szTmp,  XSTR("short ") ) ;
	    break ;
	  case VT_I4:
	    osStrCpy ( szTmp,  XSTR("long ") ) ;
	    break ;
	  case VT_R4:
	    osStrCpy ( szTmp,  XSTR("float ") ) ;
	    break ;
	  case VT_R8:
	    osStrCpy ( szTmp,  XSTR("double ") ) ;
	    break ;
	  case VT_CY:
	    osStrCpy ( szTmp,  XSTR("CURRENCY ") ) ;
	    break ;
	  case VT_DATE:
	    osStrCpy ( szTmp,  XSTR("DATE ") ) ;
	    break ;
	  case VT_BSTR:
	    osStrCpy ( szTmp,  XSTR("BSTR ") ) ;
	    break ;
	  case VT_DISPATCH:
	    osStrCpy ( szTmp,  XSTR("IDispatch * ") ) ;
	    break ;
	  case VT_ERROR:
	    osStrCpy ( szTmp,  XSTR("scode ") ) ;
	    break ;
	  case VT_BOOL:
	    osStrCpy ( szTmp,  XSTR("boolean ") ) ;
	    break ;
	  case VT_VARIANT:
	    osStrCpy ( szTmp,  XSTR("VARIANT ") ) ;
	    break ;
	  case VT_UNKNOWN:
	    osStrCpy ( szTmp,  XSTR("IUnknown * ") ) ;
	    break ;
	  case VT_DECIMAL:
	    osStrCpy ( szTmp,  XSTR("DECIMAL ") ) ;
	    break ;
	  case VT_I1:
	    osStrCpy ( szTmp,  XSTR("char ") ) ;
	    break ;
	  case VT_UI1:
	    osStrCpy ( szTmp,  XSTR("unsigned char ") ) ;
	    break ;
	  case VT_UI2:
	    osStrCpy ( szTmp,  XSTR("unsigned short ") ) ;
	    break ;
	  case VT_UI4:
	    osStrCpy ( szTmp,  XSTR("unsigned long ") ) ;
	    break ;
	  case VT_I8:
	    osStrCpy ( szTmp,  XSTR("long long ") ) ;
	    break ;
	  case VT_UI8:
	    osStrCpy ( szTmp,  XSTR("unsigned long long ") ) ;
	    break ;
	  case VT_INT:
	    osStrCpy ( szTmp,  XSTR("int ") ) ;
	    break ;
	  case VT_UINT:
	    osStrCpy ( szTmp,  XSTR("unsigned int ") ) ;
	    break ;
	  case VT_VOID:
	    osStrCpy ( szTmp,  XSTR("void ") ) ;
	    break ;
	  case VT_HRESULT:
	    osStrCpy ( szTmp,  XSTR("HRESULT ") ) ;
	    break ;
	  case VT_PTR:
	    tOutType (hFile, *(tdesc.lptdesc)) ;
	    osStrCpy ( szTmp,  XSTR("* ") ) ;
	    break ;
	  case VT_SAFEARRAY:
	    if ( endAttrFlag )
	      {
		WriteOut(hFile, szEndAttr) ;
		endAttrFlag = FALSE ;
	      }
	    WriteOut(hFile, XSTR("SAFEARRAY ( ")) ;
	    tOutType (hFile, *(tdesc.lptdesc)) ;
	    break ;
	  case VT_CARRAY:
	    cArrFlag = tdesc.lpadesc->cDims ;  // get dimemsion of array
	    tOutType (hFile, tdesc.lpadesc->tdescElem) ;
	    break ;
	  case VT_USERDEFINED:
	    if ( endAttrFlag )
	      {
		WriteOut(hFile, szEndAttr) ;
		endAttrFlag = FALSE ;
	      }
	    tOutAliasName (hFile, tdesc.hreftype) ;
	    break ;			    // output name of the user-defined type
	  case VT_LPSTR:
	    osStrCpy ( szTmp,  XSTR("LPSTR ") ) ;
	    break ;
          case VT_LPWSTR:                   // [3]
            osStrCpy ( szTmp,  XSTR("LPWSTR ") ) ;
	    break ;
	  default:
	    osStrCpy ( szTmp,  XSTR("unknown type ") ) ;
	}

      if ( endAttrFlag )
	{
	  WriteOut(hFile, szEndAttr) ;
	  endAttrFlag = FALSE ;
	}

      if ( tdesc.vt != VT_CARRAY && tdesc.vt != VT_USERDEFINED && tdesc.vt != VT_SAFEARRAY )
	WriteOut(hFile, szTmp) ;

      if ( tdesc.vt == VT_SAFEARRAY )
	WriteOut(hFile, XSTR(") ")) ;

   }

VOID  NEAR tOutCDim (FILE *hFile, TYPEDESC tdesc)
   {
      USHORT i ;
      ULONG  l ;
      XCHAR  szTmp[16] ;

      for ( i = 0 ; i < cArrFlag ; i++ )
	 {
	   l = tdesc.lpadesc->rgbounds[i].cElements ;
	   osLtoA(l, szTmp) ;
	   WriteOut(hFile, XSTR("[")) ;
	   WriteOut(hFile, szTmp) ;
	   WriteOut(hFile, XSTR("]")) ;
	 }

      cArrFlag = 0 ;
   }

VOID NEAR tOutAliasName (FILE *hFile, HREFTYPE phRefType)
   {
      ITypeInfoX FAR *lpInfo ;		    // pointer to the type definition
      ITypeLibX  FAR *lpLib ;		    // pointer to a type library
      TYPEATTR	 FAR *lptAttr ;
      BSTRX	 bstrName ;
      UINT	 iTypeId ;
      HRESULT	 hRes;

     hRes = ptInfo->GetRefTypeInfo(phRefType, &lpInfo);
      if ( FAILED(hRes) )
	{				    // get TypeInfo of the alias
	  WriteOut(hFile, szReadFail) ;
	  WriteOut(hFile, XSTR("GetRefTypeInfo\n")) ;
	}
      else
	{
          if ( FAILED(lpInfo->GetTypeAttr(&lptAttr)) )
            {
              WriteOut(hFile, szReadFail) ;
              WriteOut(hFile, XSTR("attribute of reftype\n\n")) ;
            }
          else
            {
              if ( inAlign && !alignFound && (lpTypeAttr->typekind != TKIND_DISPATCH) )
                 {                          // [5]
                   if ( expAlign < lptAttr->cbAlignment )
                      expAlign = lptAttr->cbAlignment ;
                   alignFound = TRUE ;
                 }

               switch ( lpTypeAttr->typekind )
                  {
                      case TKIND_INTERFACE:
                        if ( isInherit )    // output name of base-interface
                           WriteOut(hFile, XSTR(" : ")) ;
                        break ;
		      default:
			if (lpTypeAttr->typekind == TKIND_COCLASS ||
			    lptAttr->wTypeFlags & TYPEFLAG_FDUAL) {
                          // output type of the referenced interface if we
			  // are a coclass or if we are referencing a dual
			  // interface.
                          if ( lptAttr->typekind == TKIND_INTERFACE )
                            WriteOut(hFile, XSTR("interface ")) ;
                          else if ( lptAttr->typekind == TKIND_DISPATCH )
                             WriteOut(hFile, XSTR("dispinterface ")) ;
			}

                  }

               lpInfo->ReleaseTypeAttr(lptAttr) ;
            }

	  if ( FAILED(lpInfo->GetContainingTypeLib(&lpLib, &iTypeId)) )
	    {				    // get id of the alias
	      WriteOut(hFile, szReadFail) ;
	      WriteOut(hFile, XSTR("GetAlias: containing typelib\n\n")) ;
	    }
	  else
	    {				    // check origin of the alias
	      if ( FAILED(lpLib->GetDocumentation(MEMBERID_NIL, &bstrName, NULL, NULL, NULL)) )
		{
		  WriteOut(hFile, szReadFail) ;
		  WriteOut(hFile, XSTR("name of import library")) ;
		}
	      else
		{			    // if it is not defined locally
		  if ( osStrCmp(szLibName, bstrName) != 0 )
		    {			    // i.e. name of origin is diff
		       WriteOut(hFile,  bstrName) ;
		       WriteOut(hFile, XSTR(".")) ;
		    }			    // from the name of library;
					    // output its origin
		  SysFreeString((BSTR)bstrName) ;
		}

	      if ( FAILED(lpLib->GetDocumentation((int)iTypeId, &bstrName, NULL, NULL, NULL)) )
		{			    // retrieve name of the alias
		  WriteOut(hFile, szReadFail) ;
		  WriteOut(hFile, XSTR("name of alias")) ;
		}
	      else
		{
		  WriteOut(hFile, bstrName) ;

		  if ( lpTypeAttr->typekind == TKIND_COCLASS ||
		       (lpTypeAttr->typekind == TKIND_DISPATCH && isInherit) )
		     WriteOut(hFile, XSTR(" ;\n")) ;
		  else
		     WriteOut(hFile, XSTR(" ")) ;

		  SysFreeString((BSTR)bstrName) ;
		}

	      lpLib->Release () ;
	    }

	  lpInfo->Release () ;
	}
   }

VOID  NEAR tOutValue(FILE *hFile, BSTRX bstrName, VARDESCX FAR *lpVarDesc)
  {
       VARTYPE	vvt ;
       VARIANTX varTmp ;		    // [12]
       XCHAR	szTmp[25] ;

       if ( endAttrFlag )
	 {
	    WriteOut(hFile, szEndAttr) ;
	    endAttrFlag = FALSE ;
	 }

       if ( lpTypeAttr->typekind == TKIND_MODULE )
	{
	  WriteOut(hFile, XSTR("const ")) ; // output the const keyword
	  tOutType(hFile, lpVarDesc->elemdescVar.tdesc) ; // output its type
	}

       WriteOut(hFile, bstrName) ;	    // output name of member
       WriteOut(hFile, XSTR(" = ")) ;

       vvt = lpVarDesc->lpvarValue->vt ;

       if ( vvt == VT_VARIANT )
	 {
	   vvt = lpVarDesc->lpvarValue->pvarVal->vt ;
	   switch ( vvt )
	     {
	       case VT_I1:
		 osItoA((int)lpVarDesc->lpvarValue->pvarVal->cVal, szTmp) ;
		 break ;
	       case VT_UI1:
		 osItoA((int)lpVarDesc->lpvarValue->pvarVal->bVal, szTmp) ;
		 break ;
	       case VT_UI2:
		 osItoA((int)lpVarDesc->lpvarValue->pvarVal->uiVal, szTmp) ;
		 break ;
	       case VT_BOOL:
		 osItoA((int)lpVarDesc->lpvarValue->pvarVal->boolVal, szTmp) ;
		 break ;
	       case VT_I2:
		 if ( ( lpVarDesc->elemdescVar.tdesc.vt == VT_UI2 || lpVarDesc->elemdescVar.tdesc.vt == VT_UINT ) && lpVarDesc->lpvarValue->iVal < 0 )
		   osLtoA((long)65536+(lpVarDesc->lpvarValue->pvarVal->iVal), szTmp) ;
		 else
		   osItoA((int)lpVarDesc->lpvarValue->pvarVal->iVal, szTmp) ;
		 break ;
	       case VT_R4:		    // [12]
	       case VT_R8:
	       case VT_CY:
               case VT_UI4:
               case VT_UINT:
               case VT_DECIMAL:
		 varTmp.vt = VT_EMPTY ;
		 if ( FAILED(VariantChangeType(&varTmp, lpVarDesc->lpvarValue->pvarVal, VARIANT_NOVALUEPROP,  VT_BSTR)) )
		    WriteOut(hFile, XSTR("VariantChangeType fails\n")) ;
		 else
		    {
		      osStrCpy(szTmp, varTmp.bstrVal) ;
		      SysFreeStringX(varTmp.bstrVal) ;
		    }
		 break ;
	       case VT_DATE:		    // [12]
		 varTmp.vt = VT_EMPTY ;
		 if ( FAILED(VariantChangeType(&varTmp, lpVarDesc->lpvarValue, VARIANT_NOVALUEPROP,  VT_BSTR)) )
		    WriteOut(hFile, XSTR("VariantChangeType fails\n")) ;
		 else
		    {
		      WriteOut(hFile, XSTR("\"")) ;
		      WriteOut(hFile, (LPXSTR)varTmp.bstrVal) ;
		      WriteOut(hFile, XSTR("\"")) ;
		      SysFreeStringX(varTmp.bstrVal) ;
		    }
		 break ;
	       case VT_BSTR:
		 if ( lpVarDesc->lpvarValue->pvarVal->bstrVal != NULL )  // [9]
		   {
		     WriteOut(hFile, XSTR("\"")) ;
		     WriteOut(hFile, (LPXSTR)lpVarDesc->lpvarValue->pvarVal->bstrVal) ;
		     WriteOut(hFile, XSTR("\"")) ;
		   }
		 else							 // [9]
		     WriteOut(hFile, XSTR("0")) ;
		 break ;
	       default:
		 osLtoA((long)lpVarDesc->lpvarValue->pvarVal->lVal, szTmp) ;
		 break ;
	      }
	}
      else
	{
	   switch ( vvt )
	     {
               case VT_I1:
		 osItoA((int)lpVarDesc->lpvarValue->cVal, szTmp) ;
		 break ;
               case VT_UI1:
		 osItoA((int)lpVarDesc->lpvarValue->bVal, szTmp) ;
		 break ;
               case VT_BOOL:
		 osItoA((int)lpVarDesc->lpvarValue->boolVal, szTmp) ;
		 break ;
               case VT_UI2:
		 osItoA((int)lpVarDesc->lpvarValue->uiVal, szTmp) ;
		 break ;
	       case VT_I2:
		 if ( ( lpVarDesc->elemdescVar.tdesc.vt == VT_UI2 || lpVarDesc->elemdescVar.tdesc.vt == VT_UINT ) && lpVarDesc->lpvarValue->iVal < 0 )
		   osLtoA((long)65536+(lpVarDesc->lpvarValue->iVal), szTmp) ;
		 else
		   osItoA((int)lpVarDesc->lpvarValue->iVal, szTmp) ;
		 break ;
	       case VT_R4:		    // [12]
	       case VT_R8:
	       case VT_CY:
               case VT_UI4:
               case VT_UINT:
               case VT_DECIMAL:
		 varTmp.vt = VT_EMPTY ;
		 if ( FAILED(VariantChangeType(&varTmp, lpVarDesc->lpvarValue, VARIANT_NOVALUEPROP,  VT_BSTR)) )
		    WriteOut(hFile, XSTR("VariantChangeType fails\n")) ;
		 else
		    {
		      osStrCpy(szTmp, varTmp.bstrVal) ;
		      SysFreeStringX(varTmp.bstrVal) ;
		    }
		 break ;
	       case VT_DATE:		    // [12]
		 varTmp.vt = VT_EMPTY ;
		 if ( FAILED(VariantChangeType(&varTmp, lpVarDesc->lpvarValue, VARIANT_NOVALUEPROP,  VT_BSTR)) )
		    WriteOut(hFile, XSTR("VariantChangeType fails\n")) ;
		 else
		    {
		      WriteOut(hFile, XSTR("\"")) ;
		      WriteOut(hFile, (LPXSTR)varTmp.bstrVal) ;
		      WriteOut(hFile, XSTR("\"")) ;
		      SysFreeStringX(varTmp.bstrVal) ;
		    }
		 break ;
	       case VT_BSTR:
		 if ( lpVarDesc->lpvarValue->bstrVal != NULL )	// [9]
		   {
		     WriteOut(hFile, XSTR("\"")) ;
		     WriteOut(hFile, (LPXSTR)lpVarDesc->lpvarValue->bstrVal) ;
		     WriteOut(hFile, XSTR("\"")) ;
		   }
		 else						// [9]
		     WriteOut(hFile, XSTR("0")) ;
		 break ;
	       default:
		 osLtoA((long)lpVarDesc->lpvarValue->lVal, szTmp) ;
		 break ;
	      }
	}

	 if ( vvt != VT_BSTR && vvt != VT_DATE )
	   WriteOut(hFile, szTmp) ; // output value of member

       if ( lpTypeAttr->typekind == TKIND_MODULE )
	 WriteOut(hFile, XSTR(" ;\n")) ;
       else
	 WriteOut(hFile, XSTR(" ,\n")) ;
}


VOID  NEAR tOutMember(FILE *hFile, LONG idMember, BSTRX bstrName, TYPEDESC tdesc)
  {
       XCHAR szTmp[16] ;

       if ( lpTypeAttr->typekind == TKIND_DISPATCH )
	 {
           osLtoA(idMember, szTmp) ;        // output id
	   WriteAttr(hFile, attrId, szTmp, numValue) ;
         }
       else				    // [5]
         if ( inAlign )
            alignFound = FALSE ;
					   // output name of base-type
       tOutType(hFile, tdesc) ;
       WriteOut(hFile, bstrName) ;         // output name of member
       if ( cArrFlag != 0 )		   // it is a c-array; output
	 tOutCDim (hFile, tdesc) ;
					   // dimensions of the array
       WriteOut(hFile, XSTR(" ;\n")) ;
  }

VOID  NEAR tOutVar(FILE *hFile)
   {
      VARDESCX FAR *ptVarDesc ; 	    // [2]
      BSTRX    bstrName ;		    // name of member
      BSTRX    bstrDoc ;		    // file string
      DWORD    hContext ;		    // help context
      XCHAR    szTmp[16] ;
      WORD     i ;
      LONG     idMember ;
      BSTRX    rgNames[MAX_NAMES];
      UINT     cNames, j ;

	for (i = 0 ; i < lpTypeAttr->cVars; i++) // for every member
	{
	   if ( FAILED(ptInfo->GetVarDesc(i, &ptVarDesc)) )
	     {
		WriteOut(hFile, szReadFail) ;
		WriteOut(hFile, XSTR("variables\n")) ;
	     }
	   else
	     {
		idMember = ptVarDesc->memid ;
					    // this is readonly var
		if ( (ptVarDesc->wVarFlags & VARFLAG_FREADONLY) == VARFLAG_FREADONLY )	   // CK [ 1]
		   WriteAttr(hFile, attrReadonly, NULL, noValue) ;

					    // output source attribute									 // CK [ 2]
		if (( ptVarDesc->wVarFlags & VARFLAG_FSOURCE ) == VARFLAG_FSOURCE)	   // CK [ 1]
		   WriteAttr(hFile, attrSource, NULL, noValue) ;			   // CK [ 1]

					    // output bindable attribute								 // CK [ 2]
		if (( ptVarDesc->wVarFlags & VARFLAG_FBINDABLE)== VARFLAG_FBINDABLE )	   // CK [ 1]
		   WriteAttr(hFile, attrBindable, NULL, noValue) ;			   // CK [ 1]

					    // output requestedit attribute								 // CK [ 2]
		if (( ptVarDesc->wVarFlags & VARFLAG_FREQUESTEDIT)== VARFLAG_FREQUESTEDIT )// CK [ 1]
		   WriteAttr(hFile, attrRequestedit, NULL, noValue) ;			   // CK [ 1]

					    // output displaybind attribute								 // CK [ 2]
		if (( ptVarDesc->wVarFlags & VARFLAG_FDISPLAYBIND)== VARFLAG_FDISPLAYBIND )// CK [ 1]
		   WriteAttr(hFile, attrDisplaybind, NULL, noValue) ;			   // CK [ 1]

					    // output defaultbind attribute								 // CK [ 2]
		if (( ptVarDesc->wVarFlags & VARFLAG_FDEFAULTBIND)== VARFLAG_FDEFAULTBIND )// CK [ 1]
		   WriteAttr(hFile, attrDefaultbind, NULL, noValue) ;			   // CK [ 1]
		if (( ptVarDesc->wVarFlags & VARFLAG_FIMMEDIATEBIND)== VARFLAG_FIMMEDIATEBIND )// CK [ 1]
		   WriteAttr(hFile, XSTR("immediatebind"), NULL, noValue) ;			   // CK [ 1]
					    // output hidden attribute
                if (( ptVarDesc->wVarFlags & VARFLAG_FHIDDEN)== VARFLAG_FHIDDEN )          // [7]
                   WriteAttr(hFile, attrHidden, NULL, noValue) ;                      // CK [ 1]
                if (( ptVarDesc->wVarFlags & VARFLAG_FDEFAULTCOLLELEM)== VARFLAG_FDEFAULTCOLLELEM)
                   WriteAttr(hFile, XSTR("defaultcollelem"), NULL, noValue) ;
                if (( ptVarDesc->wVarFlags & VARFLAG_FUIDEFAULT)== VARFLAG_FUIDEFAULT)
                   WriteAttr(hFile, XSTR("uidefault"), NULL, noValue) ;
                if (( ptVarDesc->wVarFlags & VARFLAG_FNONBROWSABLE)== VARFLAG_FNONBROWSABLE)
                   WriteAttr(hFile, XSTR("nonbrowsable"), NULL, noValue) ;
                if (( ptVarDesc->wVarFlags & VARFLAG_FREPLACEABLE)== VARFLAG_FREPLACEABLE)
                   WriteAttr(hFile, XSTR("replaceable"), NULL, noValue) ;

      		// also dump out the varkind
      		osItoA(ptVarDesc->varkind, szTmp) ;
      		WriteAttr(hFile, XSTR("varkind"), szTmp, numValue) ;

      		// also dump out the oInst
		if (ptVarDesc->varkind != VAR_CONST) {
      		  osItoA(ptVarDesc->oInst, szTmp) ;
      		  WriteAttr(hFile, XSTR("oInst"), szTmp, numValue) ;
		}


      		if (ptinfo2) {
	 	  // new-format typelib -- output more stuff
	 	  CUSTDATA custdata;
	 	  ptinfo2->GetAllVarCustData(i, &custdata);
	 	  tOutCustData(hFile, &custdata);


      		  BSTRX    bstrHelpDll;
		    if ( FAILED(ptinfo2->GetDocumentation2(idMember, 0x409, &bstrDoc, &hContext, &bstrHelpDll)) )
		    {
	    	      WriteOut(hFile, szReadFail);
	    	      WriteOut(hFile, XSTR("GetDocumentation2 failed\n\n")) ;
	  	    } else {
		      if (hContext != 0) {
	    	        osLtoA((long)hContext, szTmp) ;
	    	        WriteAttr(hFile, XSTR("helpstringcontext"), szTmp, numValue) ;
		      }

	    	      if ( bstrDoc != NULL )	    // output helpstring if exists
	      	        WriteAttr(hFile, XSTR("localizedhelpstring"), bstrDoc, strValue) ;

		      // output help dll name if exists && different from main
	    	      if (bstrHelpDll && (g_bstrHelpDll == NULL || osStrCmp(bstrHelpDll, g_bstrHelpDll)))
	      	        WriteAttr(hFile, XSTR("helpstringdll"), bstrHelpDll, strValue) ;
	    	      SysFreeString((BSTR)bstrDoc) ;    // release local bstr's
	    	      SysFreeString((BSTR)bstrHelpDll) ;
	  	    }
      		}

		if ( FAILED(ptInfo->GetDocumentation(idMember, &bstrName, &bstrDoc, &hContext, NULL)) )
		  {
		     WriteOut(hFile, szReadFail) ;
		     WriteOut(hFile, XSTR("attributes of variable\n")) ;
		  }
		else
		  {				  // output helpcontext; default is 0
		     osLtoA((long)hContext, szTmp) ;
		     WriteAttr(hFile, attrHelpCont, szTmp, numValue) ;

		     if ( bstrDoc != NULL )	  // output helpstring if exists
		       WriteAttr(hFile, attrHelpStr, bstrDoc, strValue) ;

		     // typedef enum or const in module
		     if ( lpTypeAttr->typekind == TKIND_ENUM || lpTypeAttr->typekind == TKIND_MODULE )
		       tOutValue (hFile, bstrName, ptVarDesc) ;
		     else			  // typedef struct or dispinterface
		       tOutMember (hFile, idMember, bstrName, ptVarDesc->elemdescVar.tdesc) ;

		     SysFreeString((BSTR)bstrDoc) ;	   // release local bstr
						   // also checking the name
		     if ( FAILED(ptInfo->GetNames(idMember, rgNames, MAX_NAMES, &cNames)) )
		       {			   // with GetNames
			 WriteOut(hFile, szReadFail) ;
			 WriteOut(hFile, XSTR("name of variable\n")) ;
		       }
		     else
		       {
			 if ( cNames != 1 )
			   {
			     WriteOut(hFile, szReadFail) ;
			     WriteOut(hFile, XSTR("GetNames return more than one name\n")) ;
			   }
			 else
			   {
			     if ( osStrCmp(rgNames[0], bstrName) != 0 )
			       {
				 WriteOut(hFile, szReadFail) ;
				 WriteOut(hFile, XSTR("name of variable inconsistent\n")) ;
			       }
			   }

			 for ( j = 0 ; j < cNames ; j++ )
			   SysFreeString((BSTR)rgNames[j]) ;
		       }

		     SysFreeString((BSTR)bstrName) ;
		  }

	     }
	   ptInfo->ReleaseVarDesc(ptVarDesc) ;
	   ptVarDesc = NULL ;
	}				   // for i
   }


VOID  NEAR tOutFuncAttr(FILE *hFile, FUNCDESC FAR *lpFuncDesc, DWORD hContext, BSTRX bstrDoc)
  {
      XCHAR szTmp[16] ;

      osLtoA((long)hContext, szTmp) ;// output helpcontext; default is 0
      WriteAttr(hFile, attrHelpCont, szTmp, numValue) ;

      if ( bstrDoc != NULL )		   // output helpstring if exists
	WriteAttr(hFile, attrHelpStr, bstrDoc, strValue) ;
					   // output restricted attribute
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FRESTRICTED)== FUNCFLAG_FRESTRICTED )
	WriteAttr(hFile, attrRestrict, NULL, noValue) ;
					   // output usesgetlasterror attribute [11]
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FUSESGETLASTERROR)== FUNCFLAG_FUSESGETLASTERROR )
	WriteAttr(hFile, attrGetLastErr, NULL, noValue) ;
                                           // output soruce attribute
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FSOURCE ) == FUNCFLAG_FSOURCE ) // [6]
         WriteAttr(hFile, attrSource, NULL, noValue) ;
					   // output bindable attribute
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FBINDABLE)== FUNCFLAG_FBINDABLE )
	WriteAttr(hFile, attrBindable, NULL, noValue) ;
					   // output requestedit attribute
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FREQUESTEDIT)== FUNCFLAG_FREQUESTEDIT )
	WriteAttr(hFile, attrRequestedit, NULL, noValue) ;
					   // output displaybind attribute
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FDISPLAYBIND)== FUNCFLAG_FDISPLAYBIND )
	WriteAttr(hFile, attrDisplaybind, NULL, noValue) ;
					   // output defaultbind attribute
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FDEFAULTBIND)== FUNCFLAG_FDEFAULTBIND )
	WriteAttr(hFile, attrDefaultbind, NULL, noValue) ;
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FIMMEDIATEBIND)== FUNCFLAG_FIMMEDIATEBIND )
	WriteAttr(hFile, XSTR("immediatebind"), NULL, noValue) ;
                                           // output hidden attribute
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FHIDDEN)== FUNCFLAG_FHIDDEN ) // [7]
        WriteAttr(hFile, attrHidden, NULL, noValue) ;

      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FDEFAULTCOLLELEM)== FUNCFLAG_FDEFAULTCOLLELEM )
        WriteAttr(hFile, XSTR("defaultcollelem"), NULL, noValue) ;
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FUIDEFAULT)== FUNCFLAG_FUIDEFAULT )
        WriteAttr(hFile, XSTR("uidefault"), NULL, noValue) ;
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FNONBROWSABLE)== FUNCFLAG_FNONBROWSABLE )
        WriteAttr(hFile, XSTR("nonbrowsable"), NULL, noValue) ;
      if (( lpFuncDesc->wFuncFlags & FUNCFLAG_FREPLACEABLE)== FUNCFLAG_FREPLACEABLE )
        WriteAttr(hFile, XSTR("replaceable"), NULL, noValue) ;
      
      // also dump the funckind
      osItoA(lpFuncDesc->funckind, szTmp) ;
      WriteAttr(hFile, XSTR("funckind"), szTmp, numValue) ;

      // also dump out the oVft.  Only do this if not FUNC_DISPATCH
      // if (lpFuncDesc->funckind != FUNC_DISPATCH)
      {
        osItoA((int)lpFuncDesc->oVft, szTmp) ;
        WriteAttr(hFile, XSTR("oVft"), szTmp, numValue) ;
      }

					   // last parm is optional array
      if ( lpFuncDesc->cParamsOpt == -1 )  // of Variants
	WriteAttr(hFile, attrVar, NULL, noValue) ;

      if ( lpFuncDesc->memid == DISPID_VALUE ) // DISPID designates the
	 {				       // default function
	    osLtoA((long)DISPID_VALUE, szTmp) ;
	    WriteAttr(hFile, attrId, szTmp, numValue) ;
	 }
      else
	if ( lpTypeAttr->typekind == TKIND_DISPATCH )
	 {
	    osLtoA(lpFuncDesc->memid, szTmp) ;	 // output id
	    WriteAttr(hFile, attrId, szTmp, numValue) ;
	 }

      switch ( lpFuncDesc->invkind )	   // Note: if one of these
	{				   // flag is set, name of
	  case INVOKE_FUNC:		   // parm can't be set: i.e.
//	     WriteAttr(hFile, XSTR("invoke_func", NULL, noValue)) ;
	     break ;			   // GetNames only returns name
	  case INVOKE_PROPERTYGET:	   // of the function
	     WriteAttr(hFile, attrPropget, NULL, noValue) ;
	     break ;
	  case INVOKE_PROPERTYPUT:
	     WriteAttr(hFile, attrPropput, NULL, noValue) ;
	     break ;
	  case INVOKE_PROPERTYPUTREF:
	     WriteAttr(hFile, attrProppr, NULL, noValue) ;
	     break ;
	  default:
	     WriteAttr(hFile, XSTR("unknown invkind"), NULL, noValue) ;
	}
   }

VOID  NEAR tOutCallConv(FILE *hFile, FUNCDESC FAR *lpFuncDesc, TYPEKIND tkind)
   {
      switch ( lpFuncDesc->callconv )
	{
	  case CC_MSCPASCAL:
#if WIN16
	     if (tkind == TKIND_MODULE)
	       WriteOut(hFile, XSTR("STDAPICALLTYPE ")) ;
	     else
#endif //WIN16
	       WriteOut(hFile, XSTR("__pascal ")) ;
	     break ;
	  case CC_MACPASCAL:
	     WriteOut(hFile, XSTR("__pascal ")) ;
	     break ;
	  case CC_STDCALL:
#if WIN32
	     if (tkind == TKIND_MODULE)
	       WriteOut(hFile, XSTR("STDAPICALLTYPE ")) ;
	     else
	       WriteOut(hFile, XSTR("STDMETHODCALLTYPE ")) ;
#else //WIN32
	     WriteOut(hFile, XSTR("__stdcall ")) ;
#endif //WIN32
	     break ;
	  case CC_SYSCALL:
	     WriteOut(hFile, XSTR("__syscall ")) ;
	     break ;
	  case CC_CDECL:
#if WIN16
	     if (tkind != TKIND_MODULE)
	       WriteOut(hFile, XSTR("STDMETHODCALLTYPE ")) ;
	     else
#endif //WIN16
	     WriteOut(hFile, XSTR("__cdecl ")) ;
	     break ;

	  case CC_FASTCALL:
	     WriteOut(hFile, XSTR("__fastcall ")) ;
	     break ;
	  case CC_FPFASTCALL:
	     WriteOut(hFile, XSTR("__fpfastcall ")) ;
	     break ;

	  default:
	     WriteOut(hFile, XSTR("unknown calling convention ")) ;
	     break ;
	}
    }

VOID  NEAR tOutParams(FILE *hFile, FUNCDESC FAR *lpFuncDesc, UINT iFunc, BSTRX bstrName)
   {
      BSTRX    rgNames[MAX_NAMES];
      UINT     cNames ;
      SHORT    i ;
      SHORT    iArgOptLast;

      WriteOut(hFile, XSTR("(")) ;

      if ( lpFuncDesc->cParams == 0 )
	WriteOut(hFile, XSTR("void")) ;
      else
	{
	  if ( FAILED(ptInfo->GetNames(lpFuncDesc->memid, rgNames, MAX_NAMES, &cNames)) )
	    {
	      WriteOut(hFile, szReadFail) ;
	      WriteOut(hFile, XSTR("parm of func in definition\n")) ;
	    }
	  else
	    {
	      if (bstrName && osStrCmp(rgNames[0], bstrName) != 0 )
		{
		  WriteOut(hFile, szReadFail) ;
		  WriteOut(hFile, XSTR("name of function inconsistent\n")) ;
		}
	      SysFreeString((BSTR)rgNames[0]) ;  // release name of function

	      // figure out the last parameter to be given the [optional]
	      // attribute
	      iArgOptLast = lpFuncDesc->cParams;
	      if ( ( lpFuncDesc->invkind == INVOKE_PROPERTYPUT
		   || lpFuncDesc->invkind == INVOKE_PROPERTYPUTREF)) {
		iArgOptLast--;
	      }
	      for (i = 1; i <= lpFuncDesc->cParams; i++)
		{
                   if ( ( lpFuncDesc->lprgelemdescParam[i-1].idldesc.wIDLFlags & IDLFLAG_FRETVAL ) == IDLFLAG_FRETVAL ) // [7]
		       iArgOptLast--;
                   if ( ( lpFuncDesc->lprgelemdescParam[i-1].idldesc.wIDLFlags & IDLFLAG_FLCID ) == IDLFLAG_FLCID ) // [7]
		       iArgOptLast--;
		}

	      for (i = 1; i <= lpFuncDesc->cParams; i++)
		{
		  if ( i != 1 )
		    WriteOut(hFile, XSTR(", ")) ;
					   // output in/out attribute
		  if ( lpFuncDesc->lprgelemdescParam[i-1].idldesc.wIDLFlags != 0 )
		    {
		      if ( ( lpFuncDesc->lprgelemdescParam[i-1].idldesc.wIDLFlags & IDLFLAG_FIN ) == IDLFLAG_FIN )
			WriteAttr(hFile, attrIn, NULL, noValue) ;

		      if ( ( lpFuncDesc->lprgelemdescParam[i-1].idldesc.wIDLFlags & IDLFLAG_FOUT ) == IDLFLAG_FOUT )
                        WriteAttr(hFile, attrOut, NULL, noValue) ;

                      if ( ( lpFuncDesc->lprgelemdescParam[i-1].idldesc.wIDLFlags & IDLFLAG_FRETVAL ) == IDLFLAG_FRETVAL ) // [7]
                        WriteAttr(hFile, attrRetval, NULL, noValue) ;

                      if ( ( lpFuncDesc->lprgelemdescParam[i-1].idldesc.wIDLFlags & IDLFLAG_FLCID ) == IDLFLAG_FLCID ) // [7]
                        WriteAttr(hFile, attrLcid, NULL, noValue) ;

                      if ( ( lpFuncDesc->lprgelemdescParam[i-1].idldesc.wIDLFlags & PARAMFLAG_FHASDEFAULT ) == PARAMFLAG_FHASDEFAULT ) {
			VARIANT varTmp;
			VARIANT *pVarDefault;
			pVarDefault = &(lpFuncDesc->lprgelemdescParam[i-1].paramdesc.pparamdescex->varDefaultValue);
		 	varTmp.vt = VT_EMPTY ;
			
		        if ( FAILED(VariantChangeType(&varTmp, pVarDefault, VARIANT_NOVALUEPROP,  VT_BSTR)) )
		    	   WriteOut(hFile, XSTR("VariantChangeType fails\n")) ;
		        else {
                           WriteAttr(hFile, XSTR("defaultvalue"), (BSTRX)varTmp.bstrVal, strValue) ;
		           SysFreeStringX(varTmp.bstrVal) ;
		        }
		      }
                      if ( ( lpFuncDesc->lprgelemdescParam[i-1].idldesc.wIDLFlags & PARAMFLAG_FOPT ) == PARAMFLAG_FOPT ) // [7]
                        WriteAttr(hFile, XSTR("PARAMFLAG_FOPT"), NULL, noValue) ;
                      if ( ( lpFuncDesc->lprgelemdescParam[i-1].idldesc.wIDLFlags & PARAMFLAG_FHASCUSTDATA ) == PARAMFLAG_FHASCUSTDATA ) // [7]
                        WriteAttr(hFile, XSTR("PARAMFLAG_FHASCUSTDATA"), NULL, noValue) ;

      		      if (ptinfo2) {
	 		  // new-format typelib -- output more stuff
	 		  CUSTDATA custdata;
	 		  ptinfo2->GetAllParamCustData(iFunc, i-1, &custdata);
	 		  tOutCustData(hFile, &custdata);
      		      }
		    }
					   // check for optional parm
		  if ( lpFuncDesc->cParamsOpt > 0) {
		    if ( ( lpFuncDesc->cParamsOpt + i ) > iArgOptLast
			   && i <= iArgOptLast )
		      WriteAttr(hFile, attrOption, NULL, noValue) ;
					   // and output optional attr
		  }
					   // output name of base-type
		  tOutType(hFile, lpFuncDesc->lprgelemdescParam[i-1].tdesc) ;
		  if ( i < (SHORT) cNames )// output name of parm if its is
		    {			   // not property-accessor function
		      if (rgNames[i] == NULL)
		        WriteOut(hFile, XSTR("_NONAME_")) ;
		      else
		        WriteOut(hFile, rgNames[i]) ;
		      SysFreeString((BSTR)rgNames[i]) ;  // release name of parm's
		    }
		  else
		    WriteOut(hFile, XSTR("PseudoName")) ;

		  if ( cArrFlag != 0 )	   // it is a c-array; output
		    tOutCDim (hFile, lpFuncDesc->lprgelemdescParam[i-1].tdesc) ;
					   // dimension of the array
		}			   // for i = 1
	    }				   // GetNames

	}				   // if (ptFunDesc->cParams)

      WriteOut(hFile, XSTR(") ;\n")) ;
   }


VOID  NEAR tOutFunc(FILE *hFile)
   {
      FUNCDESC FAR *ptFuncDesc ;
      BSTRX    bstrName ;		    // name of member
      BSTRX    bstrDoc ;		    // file string
      DWORD    hContext ;		    // help context
      BSTRX    bstrDllName;
      BSTRX    bstrEntryName;
      WORD     wOrdinal;
      XCHAR    szTmp[16] ;
      WORD     i ;
      LONG     idMember ;

      alignFound = TRUE ;                   // turn off align checking [5]

      for (i = 0 ; i < lpTypeAttr->cFuncs; i++) // for every member function
	{
	   if ( FAILED(ptInfo->GetFuncDesc(i, &ptFuncDesc)) )
	     {
		WriteOut(hFile, szReadFail) ;
		WriteOut(hFile, XSTR("function of definition\n")) ;
	     }
	   else
	     {
		idMember = ptFuncDesc->memid ;
		if ( FAILED(ptInfo->GetDocumentation(ptFuncDesc->memid, &bstrName, &bstrDoc, &hContext, NULL)) )
		  {
		     WriteOut(hFile, szReadFail) ;
		     WriteOut(hFile, XSTR("attributes of function\n")) ;
		  }
		else
		  {
		     if ( lpTypeAttr->typekind == TKIND_MODULE )
			if( !FAILED(ptInfo->GetDllEntry(ptFuncDesc->memid, ptFuncDesc->invkind, &bstrDllName, &bstrEntryName, &wOrdinal)) )
			 {		   // check for Dll entry
			    WriteAttr(hFile, attrDllName, bstrDllName, strValue) ;
			    SysFreeString((BSTR)bstrDllName) ;

			    if ( bstrEntryName != NULL )
			      {
				WriteAttr(hFile, attrEntry, bstrEntryName, strValue) ;
				SysFreeString((BSTR)bstrEntryName) ;
			      }
			    else
			      {
				osItoA((int)wOrdinal, szTmp) ;
				WriteAttr(hFile, attrEntry, szTmp, numValue) ;
			      }
			  }

      		      if (ptinfo2) {
	 		  // new-format typelib -- output more stuff
	 		  CUSTDATA custdata;
	 		  ptinfo2->GetAllFuncCustData(i, &custdata);
	 		  tOutCustData(hFile, &custdata);

	 	     // new-format typelib -- output more stuff
      		    BSTRX    bstrHelpDll;
		    BSTRX    bstrLocalDoc;
		    DWORD    hStringContext;
		    if ( FAILED(ptinfo2->GetDocumentation2(idMember, 0x409, &bstrLocalDoc, &hStringContext, &bstrHelpDll)) )
		    {
	    	      WriteOut(hFile, szReadFail);
	    	      WriteOut(hFile, XSTR("GetDocumentation2 failed\n\n")) ;
	  	    } else {
		      if (hStringContext != 0) {
	    	        osLtoA((long)hStringContext, szTmp) ;
	    	        WriteAttr(hFile, XSTR("helpstringcontext"), szTmp, numValue) ;
		      }

	    	      if ( bstrLocalDoc != NULL )	    // output helpstring if exists
	      	        WriteAttr(hFile, XSTR("localizedhelpstring"), bstrLocalDoc, strValue) ;

		      // output help dll name if exists && different from main
	    	      if (bstrHelpDll && (g_bstrHelpDll == NULL || osStrCmp(bstrHelpDll, g_bstrHelpDll)))
	      	        WriteAttr(hFile, XSTR("helpstringdll"), bstrHelpDll, strValue) ;

	    	      SysFreeString((BSTR)bstrLocalDoc);
	    	      SysFreeString((BSTR)bstrHelpDll) ;
	  	    }

      		      }

						   // output attr for function
		     tOutFuncAttr(hFile, ptFuncDesc, hContext, bstrDoc) ;
						  // output return type
		     tOutType(hFile, ptFuncDesc->elemdescFunc.tdesc) ;
						  // output calling convention
		     tOutCallConv(hFile, ptFuncDesc, lpTypeAttr->typekind) ;
	      	     if (bstrName == NULL)
		         WriteOut(hFile, XSTR("_NONAME_")) ;
	      	     else
		         WriteOut(hFile, bstrName) ; // output name of member function
		     tOutParams(hFile, ptFuncDesc, i, bstrName) ;
							// output parameters
		     SysFreeString((BSTR)bstrDoc) ;	// release local bstr's
		     SysFreeString((BSTR)bstrName) ;
		  }
	        ptInfo->ReleaseFuncDesc(ptFuncDesc) ;

	     }
	   ptFuncDesc = NULL ;
        }                                   // for i

      alignFound = FALSE ;                  // turn align checking back on [5]
    }

VOID  NEAR tOutUUID (FILE *hFile, GUID inGuid)
   {
      XCHAR  szTmp[50] ;
					    // get a string representation
					    // for the incoming Guid value
      if ( !(osRetrieveGuid (szTmp, inGuid)) )
	 { WriteOut(hFile, szReadFail) ;
	   WriteOut(hFile, XSTR("insufficient memory")) ;
	 }
      else
	 {	    // string is in {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
	   szTmp[37] = '\0' ;	    // format, need to remove the {}
	   WriteAttr(hFile, attrUuid, &szTmp[1], numValue) ;
	 }
   }

VOID NEAR tOutAttr (FILE *hFile, int iTypeId)
   {
      BSTRX    bstrDoc ;		    // file string
      BSTRX    bstrHelp ;		    // name of help file
      DWORD    hContext ;		    // help context
      XCHAR    szTmp[16] ;

      if ( FAILED(ptLib->GetDocumentation(iTypeId, NULL, &bstrDoc, &hContext, &bstrHelp)) )
	{
	  WriteOut(hFile, szReadFail) ;
	  WriteOut(hFile, XSTR("documentational attribute\n\n")) ;
	}
      else
	{				    // output helpcontext; default is 0
	  osLtoA((long)hContext, szTmp) ;
	  WriteAttr(hFile, attrHelpCont, szTmp, numValue) ;

	  if ( bstrDoc != NULL )	    // output helpstring if exists
	    WriteAttr(hFile, attrHelpStr, bstrDoc, strValue) ;

	  if ( bstrHelp != NULL ) {	    // output helpfile if exists
            OLECHAR FAR* pchDir;

            // remove the path.
#if WIN32
            pchDir = wcsrchr(bstrHelp, '\\');

            if (pchDir) {
              wcscpy(bstrHelp, pchDir);
            }
#else // !WIN32
            pchDir = _fstrrchr(bstrHelp, '\\');

            if (pchDir) {
              _fstrcpy(bstrHelp, pchDir);
            }
#endif // !WIN32

	    // force path to lower case
#if WIN16
	    AnsiLower(bstrHelp);
#else //WIN16
	    WCHAR * pch;
	    for (pch = bstrHelp; *pch != 0; pch++) {
	      if (*pch >= OLECHAR('A') && *pch <= OLECHAR('Z'))
		*pch = *pch + 'a' - 'A';
	    }
#endif //WIN16
	    WriteAttr(hFile, attrHelpFile, bstrHelp, strValue) ;
	  }

	  SysFreeString((BSTR)bstrDoc) ;    // release local bstr's
	  SysFreeString((BSTR)bstrHelp) ;
	}  

        if (ptlib2) {
	  // new-format typelib -- output more stuff
          if ( FAILED(ptlib2->GetDocumentation2(iTypeId, 0x409, &bstrDoc, &hContext, &bstrHelp)) )
	{
	    WriteOut(hFile, szReadFail);
	    WriteOut(hFile, XSTR("GetDocumentation2 failed\n\n")) ;
	  } else {
	    if (hContext != 0) {
	      osLtoA((long)hContext, szTmp) ;
	      WriteAttr(hFile, XSTR("helpstringcontext"), szTmp, numValue) ;
	    }

	    if ( bstrDoc != NULL )	    // output helpstring if exists
	      WriteAttr(hFile, XSTR("localizedhelpstring"), bstrDoc, strValue) ;

	    // output help dll name if exists && different from main one
	    if (bstrHelp && (!g_bstrHelpDll || osStrCmp(bstrHelp, g_bstrHelpDll)))
	      WriteAttr(hFile, XSTR("helpstringdll"), bstrHelp, strValue) ;

	    SysFreeString((BSTR)bstrDoc) ;    // release local bstr's
	    if (iTypeId == -1) {
	      g_bstrHelpDll = bstrHelp;
	    } else {
	      SysFreeString((BSTR)bstrHelp) ;
	    }
	  }
	}
   }

VOID NEAR tOutMoreAttr (FILE *hFile)
   {
      XCHAR szTmp[16] ;

      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FDUAL ) == TYPEFLAG_FDUAL ) {
         WriteAttr(hFile, attrDual, NULL, noValue) ;
      }
      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FOLEAUTOMATION ) == TYPEFLAG_FOLEAUTOMATION ) // [7]
           WriteAttr(hFile, attrOleAuto, NULL, noValue) ; // check for oleautomation attr

      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FNONEXTENSIBLE ) == TYPEFLAG_FNONEXTENSIBLE ) // [7]
           WriteAttr(hFile, attrNonExt, NULL, noValue) ;  // check for nonextensible attr
#if 0	// messes up old vs new typelib diffs
      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FDISPATCHABLE ) == TYPEFLAG_FDISPATCHABLE )
           WriteAttr(hFile, XSTR("dispatchable"), NULL, noValue) ;
#endif //0
      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FREPLACEABLE ) == TYPEFLAG_FREPLACEABLE )
           WriteAttr(hFile, XSTR("replaceable"), NULL, noValue) ;
      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FAPPOBJECT ) == TYPEFLAG_FAPPOBJECT )
           WriteAttr(hFile, attrAppObj, NULL, noValue) ;
      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FLICENSED ) == TYPEFLAG_FLICENSED ) // [4]
           WriteAttr(hFile, attrLic, NULL, noValue) ;  // check for license
      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FCONTROL ) == TYPEFLAG_FCONTROL ) // [7]
           WriteAttr(hFile, attrControl, NULL, noValue) ;  // check for control attr
      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FAGGREGATABLE ) == TYPEFLAG_FAGGREGATABLE )
           WriteAttr(hFile, XSTR("aggregatable"), NULL, noValue) ;
      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FPROXY ) == TYPEFLAG_FPROXY )
           WriteAttr(hFile, XSTR("proxy"), NULL, noValue) ;

      GetVerNumber (lpTypeAttr->wMajorVerNum, lpTypeAttr->wMinorVerNum, szTmp) ;
      WriteAttr(hFile, attrVer, szTmp, numValue) ; // output version
      tOutUUID(hFile, lpTypeAttr->guid) ;

      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FHIDDEN ) == TYPEFLAG_FHIDDEN ) // [7]
           WriteAttr(hFile, attrHidden, NULL, noValue) ;  // check for hidden attr

      if ( ( lpTypeAttr->wTypeFlags & TYPEFLAG_FRESTRICTED ) == TYPEFLAG_FRESTRICTED ) // [10]
	   WriteAttr(hFile, attrRestrict, NULL, noValue) ;  // check for restricted attr
      osItoA((int)lpTypeAttr->cbSizeVft, szTmp) ;
      WriteAttr(hFile, XSTR("cbSizeVft"), szTmp, numValue) ;
      osItoA(lpTypeAttr->cbSizeInstance, szTmp) ;
      WriteAttr(hFile, XSTR("cbSizeInstance"), szTmp, numValue) ;
      osItoA((int)lpTypeAttr->cbAlignment, szTmp) ;
      WriteAttr(hFile, XSTR("cbAlignment"), szTmp, numValue) ;

      if (ptinfo2) {
	 // new-format typelib -- output more stuff
	 CUSTDATA custdata;
	 ptinfo2->GetAllCustData(&custdata);
	 tOutCustData(hFile, &custdata);
      }

      if ( endAttrFlag )
	 {
	   WriteOut(hFile, szEndAttr) ;
	   endAttrFlag = FALSE ;
	 }
   }


VOID NEAR WriteAttr(FILE *hFile, LPXSTR lpszAttr, LPXSTR lpszStr, int ivalType)
   {
       BOOL firstAttr = FALSE ;

       if ( !endAttrFlag )
	  {
	    WriteOut(hFile, szBeginAttr) ;	// output "[" first
	    endAttrFlag = TRUE ;
	    firstAttr = TRUE ;
	  }
						// this is not the first
       if ( !firstAttr )			// attribute to be written;
	  WriteOut(hFile, XSTR(", ")) ; 	// need to put a , before
						// output name of attribute
       WriteOut(hFile, lpszAttr) ;
       if ( ivalType != noValue )		// attribute has a value
	 {
	    WriteOut(hFile, XSTR("(")) ;
	    if ( ivalType != numValue )		// value is a string
	       WriteOut(hFile, XSTR("\"")) ;

	    WriteOut(hFile, lpszStr) ;		// output value of attribute
	    if ( ivalType != numValue )		// close the string value
	       WriteOut(hFile, XSTR("\"")) ;
	    WriteOut(hFile, XSTR(")")) ;
	 }
   }


VOID NEAR GetVerNumber (WORD wMajorNum, WORD wMinorNum, LPXSTR szVersion)
  {
      XCHAR szTmp[6] ;

      osLtoA((long)wMajorNum, szVersion) ;
      osLtoA((long)wMinorNum, szTmp) ;

      osStrCat(szVersion, XSTR(".")) ;	    // major.
      osStrCat(szVersion, szTmp) ;	    // major.minor
   }

VOID NEAR tOutAlignError (FILE * hFile)     // [5]
   {
      XCHAR szTmp1[30] ;
      XCHAR szTmp2[15] ;

      WriteOut(hFile, szAlignErr) ;
      osLtoA((long)inAlign, szTmp2) ;
      osStrCpy(szTmp1, XSTR("inAlign = ")) ;
      osStrCat(szTmp1, szTmp2) ;
      WriteOut(hFile, szTmp1) ;
   }

VOID NEAR WriteOut(FILE *hFile, LPXSTR lpszData)
  {					    // Note: szBuffer is either UNICODE
					    // or ANSI depending of the UNICODE
      XCHAR szBuffer[fMaxBuffer];	    // compiler switch

      if ( fputsX(lpszData, hFile) < 0 )    // [2]
	 {				    // regardless the OS enviornment
	   osStrCpy(szBuffer, XSTR("Fail to write to file ")) ;
	   osStrCat(szBuffer, lpszData) ;
           if ( isOut )
             {
                mFile = fopenX(szOutMsgFile, fnWrite);// open message file [2]
                if (mFile == NULL)
                   {
                      osMessage (XSTR("Fail to open the message file"), XSTR("Tlviewer")) ;
                      osMessage (szBuffer, XSTR("Tlviewer")) ;
                   }
                 else
                   {
                      WriteOut(mFile, szBuffer) ;
                      fclose(mFile) ;
                      mFile = NULL ;
                    }
             }
	   else
	     osMessage (szBuffer, XSTR("Tlviewer")) ;
	 }
  }


// test routine for use in the typelib dumping routines.  Supposed to
// return a help string from a resource.   (Called as a result of doing
// a GetDocumentation2).  We just fake something out here.
extern "C" HRESULT __declspec(dllexport) DLLGetDocumentation
(
    ITypeLib * /*ptlib*/,
    ITypeInfo * /*ptinfo*/,
    LCID lcid,
    DWORD dwHelpStringContext,
    BSTR * pbstrHelpString
)
{
    switch (dwHelpStringContext) {
      case 99:
	if (lcid == 0x409) {
          *pbstrHelpString = SysAllocString(OLESTR("English help for context 99"));
	} else
	if (lcid == 0) {
          *pbstrHelpString = SysAllocString(OLESTR("Default help for context 99"));
	} else {
          *pbstrHelpString = SysAllocString(OLESTR("Foreign help for context 99"));
	}
	break;
      default:
	*pbstrHelpString = NULL;	// no help for this item
    }
   return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\jgdw.h ===
/*----------------------------------------------------------------------------
;
; jgdw.h -- JGDW decoder API
;
; Copyright (c) 1994-1996 Johnson-Grace Company, all rights reserved
;
; This file contains all the defines necessary to interface the
; Johnson-Grace decompressor.
;
;---------------------------------------------------------------------------*/

#ifndef JGDW_H
#define JGDW_H 1

#ifdef _MAC
#include <Types.h>
#include <Palettes.h>
#include <QuickDraw.h>
#include <QDOffscreen.h>
#else
#pragma warning(disable:4201)
#include <windows.h>
#pragma warning(default:4201)
#endif

#include "jgtypes.h"

#ifdef __cplusplus
extern "C" {         /* Indicate C declarations for C++ */
#endif


#define JG_ARTIMAGE_INFO		JG_RAWIMAGE_INFO
#define JgGetImageHandleDIB		JgGetImage
#define JgGetMaskDIB			JgGetMask
#define NormalUpdateRect		OldRect

#ifdef _MAC

#define JGDW_CALL

typedef struct JGDW_RECORD_TAG JGDW_RECORD;
typedef JGDW_RECORD JGPTR	JGDW_HDEC;

typedef GWorldPtr			JGDW_HBITMAP;
typedef Rect				JGDW_RECT;
typedef RGBColor			JGDW_COLOR;
typedef ColorInfo			JGDW_PALETTEENTRY;

#else

#if defined(_WIN32) || defined(__FLAT__) /* 16/32 bit compatibility */
  #ifndef JGDW_DECLSPEC
    #define JGDW_DECLSPEC __declspec(dllimport)
  #endif
  #define JGDW_CALL JGDW_DECLSPEC WINAPI
#else
  #ifndef JGDW_DECLSPEC
    #define JGDW_DECLSPEC _export
  #endif
  #define JGDW_CALL JGDW_DECLSPEC WINAPI
#endif

typedef HGLOBAL				JGDW_HDEC;
typedef HGLOBAL				JGDW_HBITMAP;
typedef RECT				JGDW_RECT;
typedef PALETTEENTRY		JGDW_COLOR;
typedef PALETTEENTRY		JGDW_PALETTEENTRY;

#endif

typedef struct JGDW_CONTEXT JGDW_CONTEXT;
typedef JGDW_CONTEXT JGPTR JGDW_HCONTEXT;


#define JG_HEADER_SIZE      40  /* Min # of bytes for JgQueryArtImage() */

/*
** Note: the Decode library returns status codes as integers.
** Zero is returned for success.  A non-zero return means that some
** exception occurred.  Non-documented exceptions should be treated as
** non-recoverable errors.  In this case the application should print the
** full integer value to aid support after the product is in the field.
**
** The application can determine the class of the exception by masking
** off the high order bits of the word. See JgTypes.h for JG_ERR_xxx
** defines.
**
** Final Note: Currently all nonzero returns should be treated as
** non-recoverable errors.
*/

#define JGD_STATUS_SUCCESS      0
#define JGD_STATUS_MEMERR       (300 | JG_ERR_MEMORY)
#define JGD_STATUS_BADARG       (301 | JG_ERR_ARG)
#define JGD_STATUS_ERROR        (302 | JG_ERR_STATUS)
#define JGD_STATUS_NOPALETTE    (303 | JG_ERR_STATUS)
#define JGD_STATUS_BADDATA      (304 | JG_ERR_DATA)
#define JGD_STATUS_IERROR       (305 | JG_ERR_CHECK)
#define JGD_STATUS_TOOWIDE      (306 | JG_ERR_ARG)

                                /* Not Valid because not enough data */
#define JGD_STATUS_INVALID      (307 | JG_ERR_ARG)      

                                /* Unsupported version of compression */
#define JGD_STATUS_BADVERSION   (308 | JG_ERR_VERSION)   
                                /* Unsupported Sub Version of file */
#define JGD_STATUS_BADSUBVER    (309 | JG_ERR_VERSION)  
                                /* File segments in wrong order */
#define JGD_STATUS_BADORDER     (310 | JG_ERR_DATA)     
                                /* Segment is shorter than expected */
#define JGD_STATUS_SHORTSEG     (311 | JG_ERR_DATA)     
                                /* Input Buffer is shorter than necessary */
#define JGD_STATUS_SHORTBUF     (312 | JG_ERR_DATA)     
                                /* Decodeable with some degradation */ 
#define JGD_STATUS_OLDRESOURCE  (313 | JG_ERR_STATUS)   
                                /* Decodeable with extreme degradation */
#define JGD_STATUS_NORESOURCE   (314 | JG_ERR_STATUS)   
                                /* Not decodeable because missing resource */
#define JGD_STATUS_BADRESOURCE  (315 | JG_ERR_STATUS)   
                                /* Resource not found */
#define JGD_STATUS_NOTFOUND     (316 | JG_ERR_STATUS)   
                                /* The Resource data is corrupted */
#define JGD_STATUS_BADRCDATA    (317 | JG_ERR_DATA)     

#define JGD_STATUS_READY        (318 | JG_ERR_STATUS)
#define JGD_STATUS_WAITING      (319 | JG_ERR_STATUS)
#define JGD_STATUS_DONE         (320 | JG_ERR_STATUS)

                                /* CB Patterns Missing */
#define JGD_STATUS_NOPATTERNS   (321 | JG_ERR_STATUS)
                                /* Data is not in ART format */
#define JGD_STATUS_NOTART       (322 | JG_ERR_STATUS)
                                /* End of file found */
#define JGD_STATUS_EOF          (323 | JG_ERR_STATUS)
                                /* Result is too big */
#define JGD_STATUS_TOOBIG       (324 | JG_ERR_STATUS) 
				/* Invalid state for requested operation */
#define JGD_STATUS_BADSTATE     (325 | JG_ERR_STATE)
				/* Invalid or corrupted handle */
#define JGD_STATUS_BADHANDLE	(326 | JGD_STATUS_BADARG)
#define JGD_STATUS_LIB_NOT_FOUND (327 | JG_ERR_STATUS)
#define JGD_STATUS_UNSUPPORTED	(328 | JG_ERR_DATA)
#define JGD_STATUS_UNKNOWN		(329 | JG_ERR_DATA)
#define JGD_STATUS_OBSOLETE	(330 | JG_ERR_VERSION)
#define JGD_STATUS_BADGAMMA	(331 | JG_ERR_ARG) /* Bad gamma argument(s) */

/*
** These defines are used to select the various image decoding options.
*/

#define JG_OPTION_DITHER        0x0001  /* To Request dithering */
#define JG_OPTION_USEDEFAULT_PALETTE 0x0002  /* To force Default Palette */
#define JG_OPTION_FULLIMAGE     0x0008  /* To request full image */
#define JG_OPTION_BACKGROUNDCOLOR 0x10  /* To enable Background color */
#define JG_OPTION_INHIBIT_AUDIO   0x20  /* To disable audio, if any */
#define JG_OPTION_ONEPASS       0x0080  /* To request one pass decoding. */
#define JG_OPTION_MASK_BITMAP   0x0100  /* Create transparency mask 1=opaque */
#define JG_OPTION_IMAGEFORMAT	0x0200  /* Decode specific image format */
#define JG_OPTION_GAMMACORRECT	0x0400  /* Perform gamma correction */
#define JG_OPTION_COMMONDEVICE	0x0800  /* Mac only: use common GDevice */
#define JG_OPTION_TRANSINDEX	0x1000  /* Enables TransIndex field */


/*
** These defines indicate the type of palettizing actually done by
** the decoder.  They are returned in JgGetImageInfo().
*/

#define JG_PALETTE_MODE_OFF     0  /* No Palette, 24-bit */
#define JG_PALETTE_MODE_OPT     1  /* Use Optimal Palette, if Possible */
#define JG_PALETTE_MODE_DEFAULT 2  /* Use the input default palette */
#define JG_PALETTE_MODE_332     3  /* Use the standard 332 palette */

#define JG_POSTSCALE_LONGSIDE   0x0001  /* Do Post Scaling by long side */
#define JG_POSTSCALE_X          0x0002  /* Do Post Scaling in X */
#define JG_POSTSCALE_Y          0x0004  /* Do Post Scaling in Y */
#define JG_POSTSCALE_BESTFIT    0x0008  /* Do Post Scale with BestFit method */

// Use these defines for both GammaIn and GammaOut
#define JG_GAMMA_NONE			100  /* No gamma correction */
#define JG_GAMMA_MAC			180  /* Correction required for Mac = 1.8 */
#define JG_GAMMA_PC				250  /* Correction required for PC = 2.5 */

typedef struct {
    UINTW nSize;            /* Size of this structure, set be caller */
    UINTW ColorDepth;       /* Color depth to use (4, 8, or 24) */
    UINTW DecodeOptions;    /* Decoding Options */
    JGDW_PALETTEENTRY JGPTR DefaultPalette; /* Default Palette, or NULL if none */
    UINTW PaletteSize;      /* Size of Default Palette, if any */
    UINTW SplashDupFactor;  /* Replication Factor of Miniature in Full */
                           /*    image; 0=Off, >100=Full Size */
    JGBOOL bTrueSplash;      /* Save splash image until completely rdy */
    UINTW PostScaleFlags;   /* Defines Post Scale.  Or of JG_POSTSCALE_xxx */ 
    UINTW ScaledLongSide;   /* Used for Post scale, for JG_POSTSCALE_LONGSIDE */
    UINTW ScaledX;          /* Used for Post scale, for JG_POSTSCALE_X */
    UINTW ScaledY;          /* Used for Post scale, for JG_POSTSCALE_Y */
    JGDW_COLOR BackgroundColor; /* Used to specify background color */
    UINTW AudioOptions;     /* Defined elsewhere (in JGAW.H) */
	JGFOURCHAR ImageFormat;/* Specify image format or 'auto' for autodetect */
	UINTW GammaIn;          /* Default input gamma correction */
	UINTW GammaOut;         /* Desired output gamma correction */
    UINTW TransIndex;       /* Make this color transparent */
} JG_DECOMPRESS_INIT;

typedef struct {
    UINTW  nSize;                /* Size of this structure, set by caller */
    JGBOOL  bError;              /* Out: True if error detected which
                                    prevents further decoding */
    JGBOOL  bImageDone;          /* True if no further input required */
    JGBOOL  bNewNormalPixels;    /* True if Pixels ready in normal image */
    JGBOOL  Reserved1;
    JGDW_RECT  OldRect;          /* For compatibility */
    JGDW_RECT  UpdateRect;       /* Update region of image */
    UINTW  PaletteMode;          /* Type of palettizing being done */
    JGERR  iErrorReason;         /* Status code for error, if any */
    JGFOURCHAR ImageFormat;      /* Format of compressed image */
    UINTW	PaletteColors;	     /* Number of colors in palette */
    UINTW TransIndex;		     /* Index of transparent color (0xffff=none) */
} JG_DECOMPRESS_INFO;

typedef struct {
    UINTW  nSize;                /* Size of this structure, set by caller */
    UINTW  Version;              /* File's Version */
    UINTW  SubVersion;           /* File's SubVersion */
    JGBOOL  Decodeable;          /* Nonzero if file can be decoded */
                                 /* The following elements are only */
                                 /* Valid if the image is decodeable */
    UINTW  Rows;                 /* Actual Rows at compress time */
    UINTW  Cols;                 /* Actual Cols at compress time */
    JGBOOL  HasPalette;          /* If Nonzero, image contains a palette */
    JGBOOL  HasOverlays;         /* If Nonzero, image has enhancements */
    JGFOURCHAR ImageFormat;      /* Four-character image type code */
    UINTW  ColorDepth;           /* Native color depth of image */
} JG_RAWIMAGE_INFO;

/*
** The following are prototypes to Decoder functions.
*/

#ifdef __CFM68K__
 #pragma import on
#endif

//JGERR JGDW_CALL JgSetMemCallbacks(
//	void * (* JGFUNC memAlloc)(UINT32 size),	/* malloc */
//	void (* JGFUNC memFree)(void *ptr)			/* free */
//);

JGERR JGDW_CALL JgSetDecompressResourceBuffer(
    UINT8 JGPTR pBuffer,               /* The pointer to the resource buffer */
    UINT32 BufSize                 /* The size of the buffer */
);


/* The pointer returned by JgGetDecompressCaps points to an array of */
/* JG_READER_DESC structures.  A last dummy element exists with .nSize == 0 */
JGERR JGDW_CALL JgGetDecompressCaps(
	JG_READER_DESC JGPTR JGPTR FormatList /* Pointer to reader list. */
);


JGERR JGDW_CALL JgCreateDecompressContext(
    JGDW_HCONTEXT JGPTR hContext,        // OUT: context handle
    JG_DECOMPRESS_INIT JGPTR InitStruct  // IN: filled init structure
);

JGERR JGDW_CALL JgCreateDecompressor(
    JGDW_HDEC JGPTR hDec,                // OUT: decompression handle
    JGDW_HCONTEXT hContext,              // IN: context handle
    JG_DECOMPRESS_INIT JGPTR Init        // IN: null, or override of context
);

JGERR JGDW_CALL JgDestroyDecompressor(
    JGDW_HDEC hDec                       // IN: decompression handle
);

JGERR JGDW_CALL JgDestroyDecompressContext(
    JGDW_HCONTEXT hContext               // IN: context handle
);

JGERR JGDW_CALL JgInitDecompress(
    JGDW_HDEC JGPTR hJgImageOutput,        /* A pntr to recve the Img handle. */
    JG_DECOMPRESS_INIT JGPTR InitStruct  /* A filled init structure */
);

JGERR JGDW_CALL JgQueryArtImage(
    UINT8 JGHPTR pBuf,      /* First bytes of the compressed image */
    UINT32 nBufSize              /* Size of Buffer */
);

JGERR JGDW_CALL JgGetImageInfo(
    UINT8 JGHPTR pBuf,      /* First bytes of the compressed image */
    UINT32 nBufSize,             /* Number of bytes in buffer */
    JG_RAWIMAGE_INFO JGPTR Info
);

JGERR JGDW_CALL JgDecompressDone(
    JGDW_HDEC hJgImage              /* Handle to Decompress Struct */
);

JGERR JGDW_CALL JgGetImage(
    JGDW_HDEC hJgImage,             /* Handle to Decompression Structure */
    JGDW_HBITMAP JGPTR hBitmap      /* Output Handle to bitmap, if it exists */
);

JGERR JGDW_CALL JgDecompressImageBlock(
    JGDW_HDEC hJgImage,           /* Handle to Decompress Struct */
    UINT8 JGHPTR pImageBuf, /* Input buffer of compressed image data */
    UINT32 nBufSize,             /* Number of bytes of data in buffer */
    JGBOOL JGPTR bNewData          /* True if new data are available */
);

JGERR JGDW_CALL JgGetDecompressInfo(
    JGDW_HDEC hJgImage,             /* Handle to Decompress Struct */
    JG_DECOMPRESS_INFO JGPTR Info  /* Out: Filled Info struct */
);

JGERR JGDW_CALL JgGetDecoderVersion(
    char JGPTR Version
);

JGERR JGDW_CALL JgGetMiniatureOffset(
    UINT8 JGHPTR pBuf,      /* Entire compressed image */
    UINT32 nBufSize,             /* Size of compressed image */
    UINT32 JGPTR Offset              /* Output Offset to End of Miniature */
);

JGERR JGDW_CALL JgGetMask(
	JGDW_HDEC hJgImage,           /* Handle to Decompression Structure */
    JGDW_HBITMAP JGPTR hMask      /* Output Handle to Mask, if it exists */
);


JGERR JGDW_CALL JgSetDebug(JGDW_HDEC hJgVars,
                        UINTW DebugOptions);

/*
** New (8/95) Lossless decompression definitions.
*/

#ifndef JG_LOSSLESS_INFO_DEFINED // (also defined in jgew.h)
#define JG_LOSSLESS_INFO_DEFINED 1
typedef struct {
	UINT16 nSize;                /* Size of structure in bytes */
	INT16  SearchSize;           /* (Compression control) */
	UINT32 CompressedSize;       /* Total compressed block bytes */
	UINT32 CompressedSoFar;      /* Compressed processed so far */
	UINT32 CompressedLastCall;   /* Compressed processed last call */
	UINT32 DecompressedSize;     /* Total decompressed block bytes */
	UINT32 DecompressedSoFar;    /* Decompressed processed so far */
	UINT32 DecompressedLastCall; /* Decompressed processed last call */
} JG_LOSSLESS_INFO;
#endif

typedef void JGPTR JG_LOSSLESS_HDEC; /* lossless decompression handle type */

JGERR JGDW_CALL JgLosslessDecompressQuery(  /* Interrogate lossless stream */
    UINT8 JGHPTR InBuffer,   /* IN: Beginning of compressed stream */
    UINT32 InBufferSize,         /* IN: Bytes in InBuffer (0-n) */
    JG_LOSSLESS_INFO JGPTR LosslessInfo); /* OUT: Stream info returned here */

JGERR JGDW_CALL JgLosslessDecompressCreate( /* Create decompression handle */
    JG_LOSSLESS_HDEC JGPTR DecHandle);    /* IN: Pointer to new handle */

void JGDW_CALL JgLosslessDecompressDestroy( /* Destroy decompression handle */
    JG_LOSSLESS_HDEC DecHandle); /* IN: Handle from decompress create */

JGERR JGDW_CALL JgLosslessDecompressReset( /* Reset existing handle */
    JG_LOSSLESS_HDEC DecHandle); /* IN: Handle from decompress create */

JGERR JGDW_CALL JgLosslessDecompressBlock( /* decompress block of data */
    JG_LOSSLESS_HDEC DecHandle,  /* IN: Handle from decompress create */
    UINT8 JGHPTR InBuffer,    /* IN: Input (compressed) data */
    UINT32 InBufferSize,          /* IN: Bytes at *InBuffer (0-n) */
    UINT8 JGHPTR OutBuffer,   /* OUT: Output (decompressed result) buff */
    UINT32 OutBufferSize,         /* IN: Free bytes at *OutBuffer */
    JG_LOSSLESS_INFO JGPTR LosslessInfo); /* OUT: Updated info returned here */

JGERR JGDW_CALL JgLosslessDecompressPartitionReset( /* new partition reset */
    JG_LOSSLESS_HDEC DecHandle);  /* IN: Handle from decompress create */

#ifdef __CFM68K__
 #pragma import off
#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\f3ctx.h ===
#define f3evtAddControl 2000010
#define f3evtAfterUpdate 2000020
#define f3evtBeforeDragOver 2000030
#define f3evtBeforeDropOrPaste 2000040
#define f3evtBeforeUpdate 2000050
#define f3evtChange 2000060
#define f3evtClick 2000070
#define f3evtDblClick 2000080
#define f3evtDropButtonClick 2000090
#define f3evtError 2000100
#define f3evtGotFocus 2000110
#define f3evtKeyDown 2000120
#define f3evtKeyPress 2000130
#define f3evtKeyUp 2000140
#define f3evtLayout 2000150
#define f3evtLostFocus 2000160
#define f3evtMouseDown 2000170
#define f3evtMouseMove 2000180
#define f3evtMouseUp 2000190
#define f3evtRemoveControl 2000200
#define f3evtScroll 2000210
#define f3evtSpinDown 2000220
#define f3evtSpinUp 2000230
#define f3evtZoom 2000240
#define f3mthAdd 2000250
#define f3mthAddItem 2000260
#define f3mthClear 2000270
#define f3mthCopy 2000280
#define f3mthCut 2000290
#define f3mthDropDown 2000300
#define f3mthItem 2000310
#define f3mthMove 2000320
#define f3mthPaste 2000330
#define f3mthRedoAction 2000340
#define f3mthRefresh 2000350
#define f3mthRemove 2000360
#define f3mthRemoveItem 2000370
#define f3mthRepaint 2000380
#define f3mthScroll 2000390
#define f3mthSelect 2000400
#define f3mthSelectAll 2000410
#define f3mthSetDefaultTabOrder 2000420
#define f3mthSetFocus 2000430
#define f3mthStartDrag 2000440
#define f3mthUndoAction 2000450
#define f3mthZOrder 2000460
#define f3objCheckBox 2000470
#define f3objComboBox 2000480
#define f3objCommandButton 2000490
#define f3objControls 2000500
#define f3objDataObject 2000510
#define f3objFont 2000520
#define f3objForm 2000530
#define f3objFrame 2000535                     // Manually added
#define f3objImage 2000540
#define f3objLabel 2000550
#define f3objListBox 2000560
#define f3objMultiPage 2000570
#define f3objOptionButton 2000580
#define f3objPage 2000590
#define f3objPages 2000600
#define f3objScrollBar 2000610
#define f3objSelected 2000620
#define f3objSpinButton 2000630
#define f3objTab 2000640
#define f3objTabs 2000650
#define f3objTabStrip 2000660
#define f3objTextBox 2000670
#define f3objToggleButton 2000680
#define f3proAccelerator 2000690
#define f3proActiveControl 2000700
#define f3proAlignment 2000710
#define f3proApplication 2000720
#define f3proAutoSelectChild 2000730
#define f3proAutoSize 2000740
#define f3proAutoTab 2000750
#define f3proAutoWordSelect 2000760
#define f3proBackColor 2000770
#define f3proBackStyle 2000780
#define f3proBold 2000790
#define f3proBorderColor 2000800
#define f3proBordersSuppress 2000810
#define f3proBorderStyle 2000820
#define f3proBoundColumn 2000830
#define f3proCancel 2000840
#define f3proCanPaste 2000850
#define f3proCanRedo 2000860
#define f3proCanUndo 2000870
#define f3proCaption 2000880
#define f3proClientHeight 2000890
#define f3proClientLeft 2000900
#define f3proClientTop 2000910
#define f3proClientWidth 2000920
#define f3proColumn 2000930
#define f3proColumnCount 2000940
#define f3proColumnHeads 2000950
#define f3proColumnWidths 2000960
#define f3proControls 2000970
#define f3proControlSource 2000980
#define f3proControlTipText 2000990
#define f3proCount 2001000
#define f3proCurLine 2001010
#define f3proCurTargetX 2001020
#define f3proCurTargetY 2001030
#define f3proCurX 2001040
#define f3proCurY 2001050
#define f3proCycle 2001060
#define f3proDefault 2001070
#define f3proDelay 2001080
#define f3proDragBehavior 2001085               // Added manually
#define f3proDrawBuffer 2001087                  // Added manually
#define f3proDesignMode 2001090
#define f3proDirty 2001100
#define f3proDropButtonStyle 2001110
#define f3proEnabled 2001120
#define f3proEnterFieldBehavior 2001125 // Added manually
#define f3proEnterKeyBehavior 2001130
#define f3proFont 2001140
#define f3proFontBold 2001150
#define f3proFontItalic 2001160
#define f3proFontName 2001170
#define f3proFontSize 2001180
#define f3proFontStrikethru 2001190
#define f3proFontUnderline 2001200
#define f3proFontWeight 2001210
#define f3proForeColor 2001220
#define f3proGridX 2001230
#define f3proGridY 2001240
#define f3proGroupName 2001245          // Added manually, AndrewL, 3/31/96
#define f3proHeight 2001250
#define f3proHelpContextID 2001260
#define f3proHideSelection 2001270
#define f3proIndex 2001280
#define f3proInSelection 2001290
#define f3proInsideHeight 2001300
#define f3proInsideWidth 2001310
#define f3proIntegralHeight 2001320
#define f3proItalic 2001330
#define f3proKeepFocusOnClick 2001340
#define f3proKeepScrollbarsVisible 2001350
#define f3proLargeChange 2001360
#define f3proLayoutEffect 2001370
#define f3proLeft 2001380
#define f3proLineCount 2001390
#define f3proList 2001400
#define f3proListCount 2001410
#define f3proListCursor 2001420
#define f3proListIndex 2001430
#define f3proListRows 2001440
#define f3proListStyle 2001450
#define f3proListWidth 2001460
#define f3proLocked 2001470
#define f3proMatchEntry 2001480
#define f3proMatchFound 2001490
#define f3proMatchRequired 2001500
#define f3proMax 2001510
#define f3proMaxLength 2001520
#define f3proMin 2001530
#define f3proMouseIcon 2001540
#define f3proMousePointer 2001550
#define f3proMultiLine 2001560
#define f3proMultiRow 2001570
#define f3proMultiSelect 2001580
#define f3proName 2001590
#define f3pronewEnum 2001600
#define f3proObject 2001610
#define f3proOldHeight 2001620
#define f3proOldLeft 2001630
#define f3proOldTop 2001640
#define f3proOldWidth 2001650
#define f3proOrientation 2001660
#define f3proPages 2001670
#define f3proParent 2001680
#define f3proPasswordChar 2001690
#define f3proPictureAlignment 2001700
#define f3proPictureData 2001710
#define f3proPicturePosition 2001720
#define f3proPictureSizeMode 2001730
#define f3proPictureTiling 2001740
#define f3proProportionalThumb 2001750
#define f3proRowSource 2001760
#define f3proRowSourceType 2001770
#define f3proScrollBars 2001780
#define f3proScrollHeight 2001790
#define f3proScrollLeft 2001800
#define f3proScrollTop 2001810
#define f3proScrollWidth 2001820
#define f3proSelected 2001830
#define f3proSelectedCount 2001840
#define f3proSelectedItem 2001850
#define f3proSelectionMargin 2001860
#define f3proSelLength 2001870
#define f3proSelStart 2001880
#define f3proSelText 2001890
#define f3proShowDropButtonWhen 2001900
#define f3proShowGridDots 2001910
#define f3proSize 2001920
#define f3proSizeMode 2001930
#define f3proSmallChange 2001940
#define f3proSnapToGrid 2001950
#define f3proSpecialEffect 2001960
#define f3proStrikeThrough 2001970
#define f3proStyle 2001980
#define f3proTabFixedHeight 2001990
#define f3proTabFixedWidth 2002000
#define f3proTabIndex 2002010
#define f3proTabKeyBehavior 2002020
#define f3proTabOrientation 2002030
#define f3proTabs 2002040
#define f3proTabStop 2002050
#define f3proTag 2002060
#define f3proText 2002070
#define f3proTextAlign 2002080
#define f3proTextColumn 2002090
#define f3proTextLength 2002100
#define f3proTop 2002110
#define f3proTopIndex 2002120
#define f3proTransitionEffect 2002130
#define f3proTransitionPeriod 2002140
#define f3proTripleState 2002150
#define f3proUnderline 2002160
#define f3proValid 2002170
#define f3proValue 2002180
#define f3proVerticalScrollbarSide 2002190
#define f3proVisible 2002200
#define f3proWeight 2002210
#define f3proWidth 2002220
#define f3proWordWrap 2002230
#define f3proZoom 2002240
#define IDH_f3defControl 2002250
#define IDH_f3defANSICharacterSet 2002260
#define IDH_f3defAcceleratorKey 2002270
#define IDH_f3defActive 2002280
#define IDH_f3defArgument 2002290
#define IDH_f3defArray 2002300
#define IDH_f3defBackgroundColor 2002310
#define IDH_f3defBound 2002320
#define IDH_f3defCaption 2002330
#define IDH_f3defClass 2002340
#define IDH_f3defClassIdentifier 2002350
#define IDH_f3defClear 2002360
#define IDH_f3defClientRegion 2002370
#define IDH_f3defClip 2002380
#define IDH_f3defCollection 2002390
#define IDH_f3defContainer 2002400
#define IDH_f3defContextID 2002410
#define IDH_f3defControlGroup 2002420
#define IDH_f3defCycle 2002430
#define IDH_f3defDataSource 2002440
#define IDH_f3defDefault 2002450
#define IDH_f3defDesignTime 2002460
#define IDH_f3defDisable 2002470
#define IDH_f3defDoubleclickSpeedSetting 2002480
#define IDH_f3defDraganddropOperation 2002490
#define IDH_f3defDropSource 2002500
#define IDH_f3defDropdownList 2002510
#define IDH_f3defEnable 2002520
#define IDH_f3defEvent 2002530
#define IDH_f3defEventProcedure 2002540
#define IDH_f3defFocus 2002550
#define IDH_f3defForegroundColor 2002560
#define IDH_f3defForm 2002570
#define IDH_f3defFormat 2002580
#define IDH_f3defIME 2002590
#define IDH_f3defInheritedProperty 2002600
#define IDH_f3defInputArea 2002610
#define IDH_f3defInsertionPoint 2002620
#define IDH_f3defKeyboardState 2002630
#define IDH_f3defLabel 2002640
#define IDH_f3defMember 2002650
#define IDH_f3defMemberName 2002660
#define IDH_f3defMethod 2002670
#define IDH_f3defModule 2002680
#define IDH_f3defNamedArgument 2002690
#define IDH_f3defNull 2002700
#define IDH_f3defOLEContainerControls 2002710
#define IDH_f3defOLEObject 2002720
#define IDH_f3defOLEStatusCode 2002730
#define IDH_f3defObject 2002740
#define IDH_f3defObjectBrowser 2002750
#define IDH_f3defPage 2002760
#define IDH_f3defPlaceholder 2002770
#define IDH_f3defPoint 2002780
#define IDH_f3defProcedure 2002790
#define IDH_f3defProject 2002800
#define IDH_f3defProperty 2002810
#define IDH_f3defPropertyPage 2002820
#define IDH_f3defRGB 2002830
#define IDH_f3defRunTime 2002840
#define IDH_f3defSelection 2002850
#define IDH_f3defSendKeysStatement 2002860
#define IDH_f3defSeparator 2002870
#define IDH_f3defSingleprecisionValue 2002880
#define IDH_f3defSizingHandles 2002890
#define IDH_f3defStatement 2002900
#define IDH_f3defSystemColors 2002910
#define IDH_f3defTabOrder 2002920
#define IDH_f3defTarget 2002930
#define IDH_f3defToolbar 2002940
#define IDH_f3defTransparent 2002950
#define IDH_f3defUnbound 2002960
#define IDH_f3defUserInterface 2002970
#define IDH_f3defValue 2002980
#define IDH_f3defVisualBasicForApplications 2002990
#define IDH_f3defVisualGroup 20023000
#define IDH_f3defZorder 20023010
#define f3defDataFormat 20023020        //Added manually 5/17/96
#define f3defDominantControl  20023030  //Added manually 5/17/96
#define f3defGridBlock  20023040        //Added manually 5/17/96
// ***** Begin Dialog Box context IDs
#define f3dlgRename 2010010
#define f3dlgPageOrder 2010020
#define f3dlgCustomControls 2010030
#define f3dlgCustomizeControl 2010040
#define IDH_f3defDataFormat 2010050
#define IDH_f3defDominantControl 2010060
#define IDH_f3defGridBlock 2010070
#define IDH_f3defControlTip 2010080
#define IDH_f3defCursor 2010090
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\jgplay.h ===
// jgplay.h -- Public Header for ART 3.5 Player
// --------------------------------------------------------------------
// Copyright (c) 1995 Johnson-Grace Company, all rights reserved
//
// Change History
// --------------
// 950820 DLB Original File
// 960426 Eric Rodriguez-Diaz
//		- For Mac only, added import pragmas.
// 960429 Eric Rodriguez-Diaz
//		- Improved import pragmas for Mac.
// 960605 Eric Rodriguez-Diaz
//		- Now taking into account the fact that for the Mac symbol
//		  GENERATINGCFM is always defined in the universal headers.
// 960606 SED Added UI hook functions.
// 960613 SED Added Art file attributes; removed HasAudio, HasImage,
//			  HasMIDI. Added memory calls for UI DLL.  Added Lossless
//			  Decompression calls for ARTDoc. Added memory hooks for
//			  MAC.  Also added memory function struct arg to
//			  JgPlayStartUp for MAC.  Added ShowIsOver, TitleReady,
//			  JGPLAY_ERR_FULL and JGPLAY_MAX_INPUT for Slide Shows.
//			  Added JgPlayFreeImage.
// 960617 SED Added JGPLAY_PALETTE and modifed JgPlayGetPalette to
//			  use it.
// 960618 SED Added the UI Report hook and modified the UI Input hook.
// 960619 SED Removed JgPlayFreeImage.  Modified JgPlayGetImage to
//			  use JGPLAY_IMAGE_REF and JgPlayGetPalette to use
//			  JGPLAY_PALETTE_REF.  Added the JgPlayStopPlay element
//			  argument and the element constants.  Added a Size member
//			  to the JGPLAY_MEMORY structure.  Changed the JGPLAY_SETUP
//			  DefaultPalette member to a JGPLAY_PALETTE_REF.
// 960621 SED Added Number of colors parameter to JgPlayGetPalette.
// 960621 SED Changed JGPLAY_ERR_OLDERROR to JGPLAY_ERR_PREVIOUS.
//			  Removed JGPLAY_ERR_IMGDECODER.
// 960625 SED Added JgPlayPausePlay, JgPlayResumePlay, JgPlaySetPosition
//			  and JgPlayGetPosition.  Removed element-to-stop arg from
//			  JgPlayStopPlay.  Removed StopTime from JgPlayStartPlay and
//			  StopTime from JgPlayStopPlay. Added UI hooks defines for
//			  JgPlayPausePlay and JgPlayResumePlay.
// 960626 SED Added JGHandle to JGPLAY_SETUP structure to support reuse
// 			  of the JGDW context.
// 960628 SED Added PaletteMode and IndexOverride and associated constants
//			  to JGPLAY_SETUP structure.  
// 960708 SED Changed JGPLAY_XXX to JGP_XXX and JgPlayXXX to JgpXXXX.
// 960709 SED Changed JGPTR to JGFAR * and JGHPTR to JGHUGE *.  Changed
//			  BOOLW to UINTW and removed convenience typedefs.
// 960710 Eric Rodriguez-Diaz
//	- For the Mac, now have pragmas forcing power structure alignment.
//	  Not using native alignment because it isn't supported by
//	  the Symantec compilers. Not using mac68k alignment because 68k
//	  is a dying breed.
// 960805 SED Added Slide Show support.
// --------------------------------------------------------------------

#ifndef JGPLAY_H
	#define JGPLAY_H 1

	#ifdef _MAC
		#include <Types.h>
		#include <Palettes.h>
		#include <QuickDraw.h>
		#include <QDOffscreen.h>
	#else
		#pragma warning(disable:4201)
		#include <windows.h>
		#pragma warning(default:4201)
	#endif

	#include "jgtypes.h"	// Include this for basic JG Types
	
	#ifdef __cplusplus
		extern "C" {         	// Indicate C declarations if C++
	#endif
	
	#ifdef _MAC
		// make sure GENERATINGCFM is defined
		#include <ConditionalMacros.h>
		#if GENERATINGCFM
			#pragma import on
		#endif
		// select PowerPC structure alignment
		#pragma options align=power
	#endif
	

	// --------------------------------------------------------------------
	// Error Codes

	#define JGP_ERR_BASE    3000  // Get this from the registor. (not yet)
	#define JGP_SUCCESS     0     // Always true at JG.

	#define JGP_ERR_MEM				((JGP_ERR_BASE +  1) | JG_ERR_MEMORY)
	#define JGP_ERR_INIT			((JGP_ERR_BASE +  2) | JG_ERR_CHECK)
	#define JGP_ERR_BADDATA			((JGP_ERR_BASE +  3) | JG_ERR_DATA)
	#define JGP_ERR_BADARG			((JGP_ERR_BASE +  4) | JG_ERR_ARG)
	#define JGP_ERR_CODECHECK		((JGP_ERR_BASE +  5) | JG_ERR_CHECK)
	#define JGP_ERR_PREVIOUS		((JGP_ERR_BASE +  6) | JG_ERR_ARG)
	#define JGP_ERR_NOTREADY		((JGP_ERR_BASE +  7) | JG_ERR_CHECK)
	#define JGP_ERR_RESOURCE		((JGP_ERR_BASE +  8) | JG_ERR_CHECK)
	#define JGP_ERR_BADSTRUCTSIZE	((JGP_ERR_BASE +  9) | JG_ERR_CHECK)
	#define JGP_ERR_AUDIODECODER	((JGP_ERR_BASE + 10) | JG_ERR_CHECK)
	#define JGP_ERR_MIDIDECODER    	((JGP_ERR_BASE + 11) | JG_ERR_CHECK)
	#define JGP_ERR_VOLUME			((JGP_ERR_BASE + 12) | JG_ERR_CHECK)
	#define JGP_ERR_NONOTE			((JGP_ERR_BASE + 13) | JG_ERR_CHECK)
	#define JGP_ERR_UNSUPPORTED		((JGP_ERR_BASE + 14) | JG_ERR_DATA)
	#define JGP_ERR_NOPALETTE		((JGP_ERR_BASE + 15) | JG_ERR_CHECK)
	#define JGP_ERR_FULL			((JGP_ERR_BASE + 16) | JG_ERR_CHECK)
	#define JGP_ERR_OPENHANDLE		((JGP_ERR_BASE + 17) | JG_ERR_CHECK)
	#define JGP_ERR_NOTAVAILABLE    ((JGP_ERR_BASE + 18) | JG_ERR_ARG)
	#define JGP_ERR_BADSTATE        ((JGP_ERR_BASE + 19) | JG_ERR_ARG)
	#define JGP_ERR_UIMODULE        ((JGP_ERR_BASE + 20) | JG_ERR_UNKNOWN)

	// Error Codes dealing with Library Startup/Shutdown
	#define	JGP_ERR_IGNORED_MEMORY_HOOKS	((JGP_ERR_BASE + 21) | JG_ERR_UNKNOWN)
	#define	JGP_ERR_BAD_SHUTDOWN			((JGP_ERR_BASE + 22) | JG_ERR_UNKNOWN)

	// Max number of input bytes accepted at once by JgpInputStream,
	// one-half a mega byte.
	#define JGP_MAX_INPUT 524288

	// Max length of ART Note
	#define JGP_ARTLENGTH 200

	// --------------------------------------------------------------------
	// Options for scaling.

	#define JGP_SCALE_NONE 		  	0	// No Scaling
	#define JGP_SCALE_EXACT        	1	// Scale to ScaleWidth and ScaleHeight
	#define JGP_SCALE_BESTFIT      	2	// Maintain aspect ratio, use best fit

	// --------------------------------------------------------------------
	// Options for gamma correction.

	#define JGP_GAMMA_NONE		0
	#define JGP_GAMMA_UP		1  	
	#define JGP_GAMMA_DOWN 		2

	// --------------------------------------------------------------------
	// File Types

	#define JGP_UNSUPPORTED 0
	#define JGP_ART	JG4C_ART
	#define JGP_BMP	JG4C_BMP
	#define JGP_GIF	JG4C_GIF
	#define JGP_JPG	JG4C_JPEG

	// --------------------------------------------------------------------
	// File Attributes

	#define JGP_HASIMAGE 			1
	#define JGP_HASAUDIO 		    2
	#define JGP_HASMIDI				4
	#define JGP_HASARTNOTE			8
	#define JGP_HASDYNAMICIMAGES	16
	#define JGP_ISTEMPORAL			32
	#define JGP_HASPAUSE			64
	#define JGP_HASTIMELINE			128

	// --------------------------------------------------------------------
	// Audio Modes.  Choose one of these for playback or zero to choose the
	// mode with the lowest processing cost on the CPU (usually 11K, 16bit).

	#define JGP_AUDIO_DEFAULT	0x0000
	#define JGP_AUDIO_11K_8BIT	0x0001
	#define JGP_AUDIO_11K_16BIT	0x0002
	#define JGP_AUDIO_22K_8BIT	0x0004
	#define JGP_AUDIO_22K_16BIT	0x0008

	// --------------------------------------------------------------------
	// Common UI hooks.

	#define JGP_CLOSEUIHOOK		0	// JgPClose HEAD hook
	#define JGP_STARTUIHOOK		1	// JgPStartPlay TAIL hook
	#define JGP_STOPUIHOOK		2	// JgPStopPlay TAIL hook
	#define JGP_PAUSEUIHOOK		3	// JgPPausePlay TAIL hook
	#define JGP_RESUMEUIHOOK	4	// JgPResumePlay TAIL hook
	#define JGP_MAXUIHOOKS		5	// INCREASE if more hooks are allowed


	// --------------------------------------------------------------------
	// PaletteModes.

	#define JGP_PALETTE_AUTO	0	// Use first available: file, input, 332
	#define JGP_PALETTE_INPUT	1	// Use input palette
	#define JGP_PALETTE_332		2	// Use 332

	// --------------------------------------------------------------------
	// Use this constant to turn off IndexOverride option.

	#define JGP_OVERRIDE_NONE	0xFFFF

	// --------------------------------------------------------------------
	// Typedefs for System dependent Image and Palette data types. 

	#ifndef _MAC
		typedef HGLOBAL JGP_IMAGE_REF;
		typedef HGLOBAL JGP_PALETTE_REF;
	#else
		typedef GWorldPtr JGP_IMAGE_REF;
		typedef PaletteHandle JGP_PALETTE_REF;
	#endif

	// These typedefs must match the jgdw lossless typedefs.

	typedef struct {
		UINT16 nSize;                // Size of structure in bytes
		INT16  SearchSize;           // (Compression control)
		UINT32 CompressedSize;       // Total compressed block bytes
		UINT32 CompressedSoFar;      // Compressed processed so far
		UINT32 CompressedLastCall;   // Compressed processed last call
		UINT32 DecompressedSize;     // Total decompressed block bytes
		UINT32 DecompressedSoFar;    // Decompressed processed so far
		UINT32 DecompressedLastCall; // Decompressed processed last call
	} JGP_LOSSLESS;

	// lossless decompression handle type
	typedef void JGFAR * JGP_LOSSLESS_HANDLE; 


	// --------------------------------------------------------------------
	// JGP_IMG -- Defines the exported image format for the ART file Player.
	// This format is designed to be system independent, but it can carry
	// information that is helpful in the system dependent conversion process.
	// It is also  designed to be very close to JG_IMG which is used by JGIPROC.
	// It can also hold the data in the form of a DIB for windows, or a  GWorld
	// for a MAC.

	typedef struct {
		UINTW Rows;				// Rows, in pixels
		UINTW Cols;				// Cols, in pixels
		UINTW Colordepth;		// Colordepth: 4, 8, 16 or 24
		UINT8 JGHUGE *pPixels;	// Pointer to top row of pixels in this image
		INTW  RowDisp;			// Offset between rows in this image
		UINTW nColors;			// Number of colors in the palette.
		JG_BGRX JGFAR *pPalette;// Pointer to list of colors for palette. 
		void JGFAR *pManager;	// Reserved.  (Internally maintained ptr.)
	} JGP_IMG;

	// --------------------------------------------------------------------
	// JGRECT -- A rectangle structure, defined to be equivalent to the
	// Window's RECT.  Used here to avoid machine dependance.  These rects
	// assume that screen coordinates run top (starting at zero) to bottom
	// (positive increase) and from left (starting at zero) to right 
	// (positive increase).  We also assume that the bottom-right border
	// defined by the structure is not part of the rectanglar area.

	typedef struct {
		INTW left;				// Location of left border
		INTW top;				// Location of top border
		INTW right;				// Location of right border, (plus 1)
		INTW bottom;			// Location of bottom border, (plus 1)
	} JGRECT;

	// --------------------------------------------------------------------
	// JGP_REPORT -- This structure is used to obtain information
	// about a specific show which can be idenitified by an instance handle.

	typedef struct {
		UINTW	Size;				// Size of this struct in bytes, set by caller
		UINTW   ImageValid;			// True if the image is valid.
		UINT32  CurrentTime;		// Current Time of play, in ms.
		UINT32  AvailPlayTime;		// Total Play Time in buffer from start to end.	
		UINTW   DoingAudio;			// Non-zero if audio is playing.
		UINTW   DoingMIDI;			// Non-zero if MIDI is playing.
		UINTW   ShowStalled;		// If nothing else to do, ... Waiting for input
		UINTW   GotEOF;				// If this show has received an EOF mark
		UINTW   IsDone;				// The presentation is finished.
		UINTW   UpdateImage;		// Non-zero if the image needs an update.
		UINTW   TransparentIndex;	// Index of transparent color.
		JGRECT	UpdateRect;			// Area in image that has changed.
		UINTW	ShowIsOver;			// The show is finished playing.
		UINTW	TitleReady;			// Title page is ready.
		UINTW	IsPaused;			// The show is paused.
		UINTW   IsPlaying;			// The show is playing
	} JGP_REPORT;

	// --------------------------------------------------------------------
	// JGP_SETUP -- This structure is used to communicate the input parameters
	// for the playing of a show.

	typedef struct {
		UINTW Size;				// Size of this struct in bytes, set by caller
		UINTW ColorDepth;		// Output colordepth  (Allowed: 4, 8, 16 or 24)
		UINTW InhibitImage;		// If true, no image returned.
		UINTW InhibitAudio;		// If true, no audio played.
		UINTW InhibitMIDI;		// If true, no MIDI played.
		UINTW InhibitDither;	// If true, no dithering is done
		UINTW InhibitSplash;	// If true, no splash with image	
		UINTW AudioMode;		// Desired Audio mode, or zero for default.
		UINTW CreateMask;		// If true, create mask imacdge
		UINTW ScaleImage;		// Scaling option
		UINTW ScaleWidth;		// Scaled width
		UINTW ScaleHeight;		// Scaled height
		UINTW  GammaAdjust;		// Gamma adjustment value
	    JG_RGBX BackgroundColor;// Background color under the image.
	    JGP_PALETTE_REF DefaultPalette; // Default Palette, NULL if none
		UINTW PaletteSize; 		// Number of Colors in Default Palette, or 0
		JGHANDLE OldHandle;		// Handle for image context reuse
		UINTW	PaletteMode;	// Specifies palette mode
		UINTW	IndexOverride;	// Transparent override/create index
		UINTW	TempMemory;		// TRUE to use temporary memory 
		UINT32  InputBaud;		// Input Baud if known by app. Zero otherwise.
	} JGP_SETUP;

	// --------------------------------------------------------------------
	// JGP_STREAM -- This structure is used to return information
	// about the ART Stream

	typedef struct {
		UINTW Size;				// Size of this struct in bytes, set by caller
		UINTW MajorVersion;		// Major version of the ART tstream.
		UINTW MinorVersion;		// Subversion of the ART stream.
		UINTW CanDecode;		// TRUE if this module can decode the stream.
		UINT32 Filetype;		// JGPL_xxx returned constant
		UINT32 Attributes;		// File attributes	
		UINT32 PlayTime;		// Playtime if temporal, non-realtime stream.
		JGRECT Dimensions;		// Native dimensions of stream if has image(s).
		UINTW  ColorDepth;		// Color Depth of Stream (4,8,16,24)
		UINT32 UpdateRate;		// Minimum ms between heartbeat calls.
		UINT32 Baud;			// Minimum input baud rate.
		UINT32 BytesToTitle;	// Number of bytes needed to get title image.	
		UINTW  SubType;			// ART subtype ID
	} JGP_STREAM;

	// --------------------------------------------------------------------
	// JGP_TEST -- This structure contains the information about the
	// test to see if the CPU and other environment is up to doing the 
	// show in real-time.

	typedef struct {
		UINTW	Size;				// Size of this struct in bytes, set by caller
		UINTW   CanDoAudio;			// Non-zero if audio can be part of the show.
		UINTW   CanDoMIDI;		    // Non-zero if MIDI	 can be part of the show.
		UINTW   PrefAudioMode;		// Preferred audio mode.
	} JGP_TEST;

	// --------------------------------------------------------------------
	// JGP_NOTE -- This structure contains information about the ART note.

	typedef struct {
		UINTW Size;					// Size of this struct in bytes, set by caller
		UINTW Display;				// If true ART note should always be displayed
		UINTW Copyrighted;			// If true the note is copyrighted
	} JGP_NOTE;


	// --------------------------------------------------------------------
	// Generic palette pointer for MAC and Windows

	typedef void JGFAR * JGP_PALETTE;

	// --------------------------------------------------------------------
	// Memory function typedefs

	typedef void JGFAR * (JGFFUNC * JGMEMALLOC) (
		UINT32 RequestedSize		// In: Number of bytes to allocate
	);

	typedef void JGFAR * (JGFFUNC * JGMEMREALLOC) (
		void JGFAR *pBuffer,		// In: Allocated buffer pointer
		UINT32 RequestedSize		// In: Number of bytes to allocate
	);

	typedef void (JGFFUNC * JGMEMFREE) (
		void  JGFAR *pBuffer		// In: Allocated buffer pointer
	);

	typedef struct {
		UINTW Size;					// Size of this struct in bytes, set by caller
		JGMEMALLOC MemAlloc;		// Allocation function pointer
		JGMEMREALLOC MemReAlloc;    // Re-Allocation function pointer
		JGMEMFREE MemFree;          // Free function pointer
	} JGP_MEMORY;

	// --------------------------------------------------------------------
	// UI hooks typedef and constants.

	typedef JGERR (JGFFUNC * JGP_UIHOOK) (
		JGHANDLE Handle,		// In: Instance handle	
		JGERR	 Err			// In: Calling function status
	);

	typedef JGERR (JGFFUNC * JGP_INPUT_UIHOOK) (
		JGHANDLE Handle,		// In: Instance handle
		UINT8  JGHUGE *pARTStream,// In: Pointer to the ART Stream
		UINT32   nBytes,		// In: Number of bytes being input	
		JGERR	 iErr			// In: Calling function status
	);

	typedef JGERR (JGFFUNC * JGP_REPORT_UIHOOK) (
		JGHANDLE Handle,		// In: Instance handle	
		JGP_REPORT JGFAR *pReport,// In: Report structure
		JGERR	 Err			// In: Calling function status
	);

	// --------------------------------------------------------------------
	// JgpStartUp{} -- This function can be called when the library is
	// started.  Under Windows, the LibMain does this.

	JGERR JGFFUNC JgpStartUp(
		JGP_MEMORY JGFAR *pMemFcns);	// In: Memory function struct pointer

	// --------------------------------------------------------------------
	// JgpShutDown{} -- This function can be called to shut the player 
	// down.  Under Windows, the WEP function does this.

	JGERR JGFFUNC JgpShutDown(void);

	// --------------------------------------------------------------------
	// JgpHeartBeat{} -- This function is used to keep the Show going.
	// This function or JgpInputStream must be called every 100 ms.

	JGERR JGFFUNC JgpHeartBeat(
		JGHANDLE SHandle);		// In: Show handle

	// --------------------------------------------------------------------
	// JgpQueryStream{} -- This is a utility function, which if given the
	// first part of an ART Stream will return useful info about it.  Usually,
	// the data to fill the info structure can be found in the first
	// 100 bytes of a Stream, but not necessarily.

	JGERR JGFFUNC JgpQueryStream(
		UINT8 JGHUGE *pARTStream,		// In: ART Stream
		UINT32 nARTStreamBytes,			// In: Size of ARTStream in Bytes
		JGP_STREAM JGFAR *pInfo); 		// Out: Info structure

	// --------------------------------------------------------------------
	// JgpDoTest{} -- Perform a test to determine ability of CPU to do
	// the show in real-time.

	JGERR JGFFUNC JgpDoTest(
		JGP_TEST JGFAR *pInfo);			// In: Info struct to be filled

	// --------------------------------------------------------------------
	// JgpOpen{} -- This function is used to obtain a handle for a
	// show.

	JGERR JGFFUNC JgpOpen(
		JGHANDLE JGFAR *pSHandle,	// Out: Place to receive handle   
		JGP_SETUP JGFAR *pSetup);	// In: The setup structure

	// --------------------------------------------------------------------
	// JgpClose{} -- This function frees all the resources associated
	// with a show.  If the show (and sound) is playing, it is immediately
	// stopped.

	JGERR JGFFUNC JgpClose(
		JGHANDLE SHandle);			// In: Show handle

	// --------------------------------------------------------------------
	// JgpSetEOFMark{} -- Sets and EOF mark for the ART stream.
	// This tells the player that no more data is expected for this stream,
	// and if, during play, the EOF mark is reached, to shut down play.
	// Otherwise, if an out-of-data condition occures, play goes into a
	// suppended state which continues to hold onto output resources of the
	// computer.

	JGERR JGFFUNC JgpSetEOFMark(
		JGHANDLE SHandle);			// In: Show handle

	// --------------------------------------------------------------------
	// JgpInputStream{} -- Accepts the Show stream. Call in a loop!
	// Must be called every XX ms even if there is no new data.
	//
	// Note, by calling this routine, the show does not automatically
	// start.  Call JgpStartShow to do this.

	JGERR JGFFUNC JgpInputStream(
		JGHANDLE SHandle,			// In: Show Handle
		UINT8  JGHUGE *pARTStream,	// In: Pointer to the ART Stream
		UINT32 nBytes);				// In: Number of bytes being input

	// --------------------------------------------------------------------
	// JgpStartPlay{} -- Starts play of a show at an arbitrary point
	// in the stream.  The arbitrary point in the stream can be specifed
	// using the JgpSetPostion. The call can be made anytime after the
	// stream is opened, even if there is no data.  In a download situation,
	// the show is not started until there is enough data to play at the
	// given starttime plus 5 seconds.

	JGERR JGFFUNC JgpStartPlay(
		JGHANDLE SHandle);			// In: Show Handle

	// --------------------------------------------------------------------
	// JgpResumePlay{} -- Starts play of an ART stream at the point
	// in the stream at which it was paused.

	UINTW JGFFUNC JgpResumePlay(
		JGHANDLE SHandle);			// In: Show Handle

	// --------------------------------------------------------------------
	// JgpPausePlay{} -- Causes play of an ART stream to stop.  The
	// stop time is saved for later resuming.
		
	UINTW JGFFUNC JgpPausePlay(
		JGHANDLE SHandle);			// In: Show Handle

	// --------------------------------------------------------------------
	// JgpStopPlay{} -- Stops the play of the show.   

	JGERR JGFFUNC JgpStopPlay(
		JGHANDLE SHandle);			// In: Show Handle
		
	// --------------------------------------------------------------------
	// JgpReleaseSound{} -- Disconnects the instance from the sound devices.

	JGERR JGFFUNC JgpReleaseSound(
		JGHANDLE SHandle);			// In: Show Handle	

	// --------------------------------------------------------------------
	// JgpResumeSound{} -- Reconnects the instance to the sound devices.

	JGERR JGFFUNC JgpResumeSound(
		JGHANDLE SHandle);			// In: Show Handle	
	
#ifdef _MAC
	// --------------------------------------------------------------------
	// JgpGetVolume{} -- Gets sound volume for a show instance.
	
	JGERR JGFFUNC JgpGetVolume(
		JGHANDLE SHandle,
		UINTW JGFAR *pnOutVolume
	);
	
	// --------------------------------------------------------------------
	// JgpSetVolume{} -- Sets sound volume for a show instance.
	
	JGERR JGFFUNC JgpSetVolume(
		JGHANDLE SHandle,
		UINTW nInVolume
	);
#endif

	// --------------------------------------------------------------------
	// JgpSetPosition{} -- This function sets the stop/pause position
	// time associated with the Show instance.
		
	JGERR JGFFUNC JgpSetPosition(
		JGHANDLE SHandle,				// In: Show Handle
		UINT32 nPosition);				// In: Position

	// --------------------------------------------------------------------
	// JgpGetPosition{} -- This function gets the stop/pause position
	// time associated with the Show instance.
		
	JGERR JGFFUNC JgpGetPosition(
		JGHANDLE SHandle,				// In: Show Handle
		UINT32 JGFAR *pPosition);		// Out: Position

	// --------------------------------------------------------------------
	// JgpGetImage{} -- Returns a system independent representation of
	// the image.  
	//
	// Depending on the platform phImg is either a GWorldPtr or a huge
	// pointer to a DIB.  The caller must lock the returned HGLOBAL to use
	// the DIB.

	JGERR JGFFUNC JgpGetImage(
		JGHANDLE SHandle,				// In: Show handle            
		JGP_IMAGE_REF JGFAR *phImg);	// Out: Handle to Image memory

	// --------------------------------------------------------------------
	// JgpGetMask{} -- Returns a system independent representation of
	// the mask image.  
	//
	// Depending on the platform phImg is either a BitMapPtr or a huge
	// pointer to a DIB.  The caller must lock the returned HGLOBAL to use
	// the DIB.

	JGERR JGFFUNC JgpGetMask(
		JGHANDLE SHandle,				// In: Show handle
		JGP_IMAGE_REF JGFAR *phImg);	// Out: Handle to Image memory

	// --------------------------------------------------------------------
	// JgpGetPalette{} -- Returns a system independent representation
	// of the image palette.  
	//
	// The caller is responsible for freeing the memory buffer space.
	// Depending on the platform pPal is either a pointer to a PaletteHandle
	// or a pointer to PALETTEENTRY structures.

	JGERR JGFFUNC JgpGetPalette(
		JGHANDLE SHandle,				// In: Show Handle
		JGP_PALETTE_REF JGFAR *phPal, 	// Out: Palette data	
		UINTW JGFAR	*pnColors);			// Out: Number of colors

	// --------------------------------------------------------------------
	// JgpGetARTNote{} -- Returns the ART note.

	JGERR JGFFUNC JgpGetARTNote(
		UINT8 JGHUGE *pARTStream,		// In: ART Stream
		UINT32 nARTStreamBytes,			// In: Size of ARTStream in Bytes
		JGP_NOTE JGFAR *pNote,			// Out: Info structure
		UINT8 JGFAR *pData);				// Out: Note text

	// --------------------------------------------------------------------
	// JgpGetReport{} -- Reports the activity of a show, given it's handle.
	// This is usually called after 'bImageUpdate' becomes true.

	JGERR JGFFUNC JgpGetReport(
		JGHANDLE SHandle,			// In:  Show Handle
		JGP_REPORT JGFAR *pReport);	// Out: Structure to receive the report
		
	// --------------------------------------------------------------------
	// JgpSetUiHook{} -- This function sets a UI function hook.
		
	JGERR JGFFUNC JgpSetUiHook(
		JGP_UIHOOK pHook,				// In: Ui Hook function
		UINTW UiHook);					// In: Hook tag

	// --------------------------------------------------------------------
	// JgpGetUiHook{} -- This function returns a UI function hook.

	JGERR JGFFUNC JgpGetUiHook(
		JGP_UIHOOK JGFAR *hHook,			// Out: Ui Hook function
		UINTW UiHook);					// In: Hook tag	
		
	// --------------------------------------------------------------------
	// JgpSetUiInputHook{} -- This function sets the JgpInputStream
	// UI function hook.
		
	JGERR JGFFUNC JgpSetUiInputHook(
		JGP_INPUT_UIHOOK pHook);		// In: Ui Hook function

	// --------------------------------------------------------------------
	// JgpGetUiInputHook{} -- This function returns the JgpInputStream
	// UI function hook.

	JGERR JGFFUNC JgpGetUiInputHook(
		JGP_INPUT_UIHOOK JGFAR *hHook);	// Out: Ui Hook function

	// --------------------------------------------------------------------
	// JgpSetUiReportHook{} -- This function sets the JgpGetReport
	// UI function hook.
		
	JGERR JGFFUNC JgpSetUiReportHook(
		JGP_REPORT_UIHOOK pHook);		// In: Ui Hook function

	// --------------------------------------------------------------------
	// JgpGetUiReportHook{} -- This function returns the JgpGetReport
	// UI function hook.

	JGERR JGFFUNC JgpGetUiReportHook(
		JGP_REPORT_UIHOOK JGFAR *hHook);	// Out: Ui Hook function

	// --------------------------------------------------------------------
	// JgpSetUiLong{} -- This function sets a UI long value associated
	// with the Show instance.
		
	JGERR JGFFUNC JgpSetUiLong(
		JGHANDLE SHandle,				// In: Show Handle
		UINT32 LongVal);				// In: Long value

	// --------------------------------------------------------------------
	// JgpGetUiLong{} -- This function returns the UI long value
	// associated with the Show instance.

	JGERR JGFFUNC JgpGetUiLong(
		JGHANDLE SHandle,				// In: Show Handle
		UINT32 JGFAR *pLongVal);		// Out: Long value
		
	// --------------------------------------------------------------------
	// JgpAlloc{} -- This function allocates memory.  The returned
	// JGFAR * can be cast to HUGE.

	void JGFAR * JGFFUNC JgpAlloc(
		JGHANDLE SHandle,               // In: Show Handle
		UINT32 nBytes);					// In: Bytes to allocate

	// --------------------------------------------------------------------
	// JgpReAlloc{} -- This function re-allocates memory.  The returned
	// JGFAR * can be cast to HUGE.

	void JGFAR * JGFFUNC JgpReAlloc(
		JGHANDLE SHandle,               // In: Show Handle
		void JGFAR *pMem,				// In: Old pointer
		UINT32 nBytes);					// In: Bytes to allocate

	// --------------------------------------------------------------------
	// JgpFree{} -- This function frees memory.

	void JGFFUNC JgpFree(
		JGHANDLE SHandle,               // In: Show Handle
		void JGFAR *pMem);				// In: Pointer to free

	// --------------------------------------------------------------------
	// JgpLosslessQuery{} -- This function interrogates a lossless stream.

	JGERR JGFFUNC JgpLosslessQuery(
	    UINT8 JGHUGE *pInBuffer,   		// In: Beginning of compressed stream
	    UINT32 InBufferSize,         	// In: Bytes in InBuffer (0-n)
	    JGP_LOSSLESS JGFAR *pLosslessInfo); // Out: Stream info returned here

	// --------------------------------------------------------------------
	// JgpLosslessCreate{} -- This function creates a decompression handle.

	JGERR JGFFUNC JgpLosslessCreate(
	    JGP_LOSSLESS_HANDLE JGFAR *pDecHandle); // In: Pointer to new handle

	// --------------------------------------------------------------------
	// JgpLosslessDestroy{} -- This function destroys a decompression handle.

	void JGFFUNC JgpLosslessDestroy(
	    JGP_LOSSLESS_HANDLE DecHandle); // In: Handle from decompress create

	// --------------------------------------------------------------------
	// JgpLosslessReset{} -- This function resets an existing handle.

	JGERR JGFFUNC JgpLosslessReset(
	    JGP_LOSSLESS_HANDLE DecHandle); // In: Handle from decompress create

	// --------------------------------------------------------------------
	// JgpLosslessBlock{} -- This function decompresses a block of data.

	JGERR JGFFUNC JgpLosslessBlock(
	    JGP_LOSSLESS_HANDLE DecHandle,	// In: Handle from decompress create
	    UINT8 JGHUGE *pInBuffer,    	// In: Input (compressed) data
	    UINT32 InBufferSize,          	// In: Bytes at *InBuffer (0-n)
	    UINT8 JGHUGE *pOutBuffer,   	// Out: Output (decompressed result) buff
	    UINT32 OutBufferSize,         	// In: Free bytes at *OutBuffer
	    JGP_LOSSLESS JGFAR *pLosslessInfo);// Out: Updated info returned here

	// --------------------------------------------------------------------
	// JgpLosslessPartitionReset{} -- This function does a new partition reset.

	JGERR JGFFUNC JgpLosslessPartitionReset(
	    JGP_LOSSLESS_HANDLE DecHandle);  // In: Handle from decompress create 
	    

	// ====================================================================
	// UNDOCUMENTED/UNSUPPORTED FUNCTIONS (Below) -- (Use at your own risk...)
	// ====================================================================

	// --------------------------------------------------------------------
	// JGP_PERFORMANCE -- This structure returns performance data.  It can
	// be used to map the CPU and Memory requirements for a Slideshow...

	typedef struct {  
		UINTW Size;				// Size of this structure, in bytes, set by caller
		UINTW IsSS;				// If a slideshow is being played
		UINTW IsValidInfo;		// If info in this structure contains valid info.
		UINTW Mode;				// Show Mode: 0=not Init, 1=Preload, 2=Playable
		UINT32 CPUTime;			// CPU Time (of call)
		UINT32 ShowTime;		// ShowTime for this measurement
		UINTW nAssets;			// Number of known assets.               
		UINT32 nAssetBytes;		// Allocated bytes for storing raw assets
		UINTW nVisPics;			// Number of visible pictures
		UINTW nCashedPics;		// Number of cashed pictures
		UINT32 nPixelBytes;		// Number of allocated bytes for pixels        
		UINT32 tCPUUsed;		// Total ms of CPU useage since last call...
	} JGP_PERFORMANCE;


	// --------------------------------------------------------------------
	// JgpGetPerformance{} -- Reports the performance measurement of a show.

	JGERR JGFFUNC JgpGetPerformance(
		JGHANDLE SHandle,						// In:  Show Handle
		JGP_PERFORMANCE JGFAR *pPerformance);	// Out: Structure to receive the report

	
	#ifdef _MAC
		// restore structure alignment mode
		#pragma options align=reset
		#if GENERATINGCFM
			#pragma import reset
		#endif
	#endif

	#ifdef __cplusplus
		}
	#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msdaipper.h ===
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: IPP_E_FIRST
//
// MessageText:
//
//  Internet Publishing Provider first error message
//
#define IPP_E_FIRST                      0x40048000L

//
// MessageId: IPP_E_SYNCCONFLICT
//
// MessageText:
//
//  The server resource has changed since the local copy on your computer was obtained.
//
#define IPP_E_SYNCCONFLICT               0xC0048003L

//
// MessageId: IPP_E_FILENOTDIRTY
//
// MessageText:
//
//  The copy of the resource on your computer has not been modified since it was downloaded from the server.
//
#define IPP_E_FILENOTDIRTY               0xC0048004L

//
// MessageId: IPP_E_MARKFOROFFLINE_FAILED
//
// MessageText:
//
//  The attempt to mark or unmark the resource for offline use failed.
//
#define IPP_E_MARKFOROFFLINE_FAILED      0xC0048006L

//
// MessageId: IPP_E_OFFLINE
//
// MessageText:
//
//  The requested operation could not be completed because the resource is offline.
//
#define IPP_E_OFFLINE                    0xC0048007L

//
// MessageId: IPP_E_UNSYNCHRONIZED
//
// MessageText:
//
//  The requested operation could not be completed because the resource has been modified
//  on your computer but has not been synchronized with the server.
//
#define IPP_E_UNSYNCHRONIZED             0xC0048008L

//
// MessageId: IPP_E_SERVERTYPE_NOT_SUPPORTED
//
// MessageText:
//
//  This server type is not currently supported.
//
#define IPP_E_SERVERTYPE_NOT_SUPPORTED   0xC004800AL

//
// MessageId: IPP_E_MDAC_VERSION
//
// MessageText:
//
//  The Microsoft Data Access Components (MDAC) are either not present on this computer or are an old version. (MSDAIPP 1.0 requires MDAC 2.1)
//
#define IPP_E_MDAC_VERSION               0xC004800DL

//
// MessageId: IPP_E_COLLECTIONEXISTS
//
// MessageText:
//
//  The move or copy operation failed because a collection with that name already exists.
//
#define IPP_E_COLLECTIONEXISTS           0xC004800EL

//
// MessageId: IPP_E_CANNOTCREATEOFFLINE
//
// MessageText:
//
//  The requested resource could not be created because parent cache entry does not exist.
//
#define IPP_E_CANNOTCREATEOFFLINE        0xC004800FL

//
// MessageId: IPP_E_STATUS_CANNOTCOMPLETE
//
// MessageText:
//
//  This is an internal MSDAIPP.DLL error.
//
#define IPP_E_STATUS_CANNOTCOMPLETE      0xC0048101L

//
// MessageId: IPP_E_RESELECTPROVIDER
//
// MessageText:
//
//  This is an internal MSDAIPP.DLL error.
//
#define IPP_E_RESELECTPROVIDER           0xC0048102L

//
// MessageId: IPP_E_CLIENTMUSTEMULATE
//
// MessageText:
//
//  This is an internal MSDAIPP.DLL error.
//
#define IPP_E_CLIENTMUSTEMULATE          0xC0048103L

//
// MessageId: IPP_S_WEAKRESERVE
//
// MessageText:
//
//  This is an internal MSDAIPP.DLL error.
//
#define IPP_S_WEAKRESERVE                0x00048104L

//
// MessageId: IPP_S_TRUNCATED
//
// MessageText:
//
//  This is an internal MSDAIPP.DLL error.
//
#define IPP_S_TRUNCATED                  0x00048105L

//
// MessageId: IPP_E_LAST
//
// MessageText:
//
//  Internet Publishing Provider last error message
//
#define IPP_E_LAST                       0x40048106L
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\jgtypes.h ===
/*----------------------------------------------------------------------------
;
; Start of jgtypes.h - Definitions for common types and macros
;
; Copyright (c) 1994-1996 Johnson-Grace Company, all rights reserved
;
;---------------------------------------------------------------------------*/

#ifndef JGTYPES_INCLUDED
#define JGTYPES_INCLUDED

#ifdef __cplusplus
  extern "C" {                  // indicate C declarations if C++
#endif

// Determine if 32-bit architecture (vs. 16-bit segmented).  If segmented,
// determine if using a small data model (tiny model is not supported).

#if defined(__FLAT__) || defined(_WIN32) || defined(unix) || defined(_MAC)
  #define JGMACH32
#elif defined(__SMALL__) || defined(__MEDIUM__) // Borland
  #define JGSMALLDATA
#elif defined(_M_I86SM) || defined(_M_I86MM)    // Microsoft
  #define JGSMALLDATA
#endif

#define JGCONST const
#define JGVOLATILE volatile

// These defines declare the native int.  These are the fastest ints
// available (of at least 16 bits) for a given environment.

#ifdef JGINTW32
  typedef long INTW;
  typedef unsigned long UINTW;
#else
  typedef int INTW;
  typedef unsigned int UINTW;
#endif

// These ints are for known lengths.
// Note that they work for both 16 and 32 machines...
// (at least for WATCOM, BORLAND and Microsoft compilers)

#ifndef _BASETSD_H_
typedef signed char    INT8;
typedef signed short   INT16;
typedef signed long    INT32;
typedef unsigned char  UINT8;
typedef unsigned short UINT16;
typedef unsigned long  UINT32;
#endif

// Pointers, calling conventions.

#ifdef JGSTATIC
  #define JGIMPORT
  #define JGEXPORT
#endif

#ifdef JGMACH32
  #define JGHUGE
  #define JGFAR
  #define JGNEAR
  #ifndef JGCCONV
	#if defined(unix) || defined(_MAC)
		#define JGCCONV
	#else
		#define JGCCONV __cdecl
	#endif
  #endif
  #ifndef JGEXPORT
	#if defined(unix) || defined(_MAC)
		#define JGEXPORT
	#else
		#define JGEXPORT __declspec(dllexport)
	#endif
  #endif
  #ifndef JGIMPORT
	#if defined(unix) || defined(_MAC)
		#define JGIMPORT
	#else
		#define JGIMPORT __declspec(dllimport)
		#pragma warning(disable:4273)
	#endif
  #endif
#else
  #define JGHUGE _huge
  #define JGFAR  _far
  #define JGNEAR _near
  #ifndef JGCCONV
    #define JGCCONV __pascal
  #endif
  #ifndef JGEXPORT
	#define JGEXPORT __export
  #endif
  #ifndef JGIMPORT
	#define JGIMPORT __export
  #endif
#endif

#define JGPTR JGFAR *
#define JGHPTR JGHUGE *
#ifndef JGNFUNC
  #define JGNFUNC JGNEAR JGCCONV
#endif
#ifndef JGFFUNC
  #define JGFFUNC JGFAR JGCCONV
#endif
#ifndef JGFUNC
  #define JGFUNC JGCCONV
#endif

// Other simple types.

typedef int JGBOOL;
typedef UINTW JGERR;

// Type-checked handle creation macro
#define JG_DECLARE_HANDLE(id) \
  struct id##_DUMMY { UINTW dummy[16]; }; \
  typedef const struct id##_DUMMY JGPTR id

// Generic JG handle
JG_DECLARE_HANDLE(JGHANDLE);

/******************************************
MEMORY MANIPULATION
******************************************/

typedef void (JGFUNC JGPTR JG_HMEMCPY_FN)(void JGHPTR, void JGHPTR, UINT32);

 #if defined(JGMACH32)
  #if defined(_MAC)
    #define JG_HMEMCPY(Dst, Src, n) memmove(Dst, Src, (UINTW)(n))
    #define JG_FMEMCPY(Dst, Src, n)  memmove(Dst, Src, (UINTW)(n))
    #define JG_FMEMMOVE(Dst, Src, n)  memmove(Dst, Src, (UINTW)(n))
  #else
    #define JG_HMEMCPY(Dst, Src, n) memcpy(Dst, Src, (UINTW)(n))
    #define JG_FMEMCPY memcpy
    #define JG_FMEMMOVE memmove
  #endif
  #define JG_FMEMCMP memcmp
  #define JG_FMEMSET memset
  #define JG_FSTRNCPY strncpy
  #define JG_FSTRCPY strcpy
  #define JG_FSTRCAT strcat
  #define JG_FSTRLEN strlen
  #define JG_FSTRCHR strchr
  #define JG_FSTRRCHR strrchr
#else
  #define JG_HMEMCPY Jghmemcpy		// Defined by user.
  void JGFUNC Jghmemcpy(void JGHPTR, void JGHPTR, UINT32);
  #define JG_FMEMCPY Jgfmemcpy
  void JGFUNC Jgfmemcpy(void JGPTR, void JGPTR, UINTW);
  #define JG_FMEMCMP _fmemcmp
  #define JG_FMEMMOVE _fmemmove
  #define JG_FMEMSET _fmemset
  #define JG_FSTRNCPY _fstrncpy
  #define JG_FSTRCPY _fstrcpy
  #define JG_FSTRCAT _fstrcat
  #define JG_FSTRLEN _fstrlen
  #define JG_FSTRCHR _fstrchr
  #define JG_FSTRRCHR _fstrrchr
#endif

/**************************************
* Resource Management Definitions     *
**************************************/

typedef void JGPTR (JGFFUNC *JG_FMALLOC_FN)(UINT32 n);
typedef void (JGFFUNC *JG_FFREE_FN)(void JGPTR p);

typedef void (JGFFUNC *JG_ENTERCS_FN)(void);
typedef void (JGFFUNC *JG_LEAVECS_FN)(void);

JG_DECLARE_HANDLE(JG_LIBHANDLE);
typedef JG_LIBHANDLE (JGFFUNC *JG_LOADLIB_FN)(char JGPTR LibFileName);
typedef void (JGFFUNC *JG_FREELIB_FN)(JG_LIBHANDLE LibHandle);
typedef void JGPTR (JGFFUNC *JG_GETLIBFN_FN)
	(JG_LIBHANDLE LibHandle, char JGPTR FuncName);

typedef struct {				// JG System Services override structure
	UINT32 Flags;				// override selection flags (defined below)
	JG_FMALLOC_FN	Jgfmalloc;	// mem alloc (16-bit: 0-offset, >64k allowed)
	JG_FFREE_FN		Jgffree;	// frees Jgfmalloc'd block
	JG_ENTERCS_FN	JgEnterCs;	// enter thread critical section
	JG_LEAVECS_FN	JgLeaveCs;	// leave thread critical section
	JG_LOADLIB_FN	JgLoadLib;	// explicitly load library
	JG_FREELIB_FN	JgFreeLib;	// free explicitly-loaded library
	JG_GETLIBFN_FN	JgGetLibFn;	// get explicitly-loaded library function ptr
} JG_SYS_SERVICES;

#define JG_SYSFL_ALLOC		1	// override Jgfmalloc/Jgffree
#define JG_SYSFL_CRITSEC	2	// override JgEnterCs/JgLeaveCs
#define JG_SYSFL_LOADLIB	4	// override JgLoadLib/JgFreeLib/JgGetLibFn

#ifdef	JGMACH32				// if 32-bit (true multi-tasking w/threads),
  void JGFUNC JgEnterCs(void);
  #define JG_ENTERCS JgEnterCs();
  void JGFUNC JgLeaveCs(void);
  #define JG_LEAVECS JgLeaveCs();
#else							// else 16-bit (cooperative multi-tasking),
  #define JG_ENTERCS
  #define JG_LEAVECS
#endif

#ifndef JGSTATIC
  #define JG_LOADLIB(LibFileName) JgLoadLib(LibFileName)
  JG_LIBHANDLE JGFUNC JgLoadLib(char JGPTR LibFileName);
  #define JG_FREELIB(LibHandle) JgFreeLib(LibHandle)
  void JGFUNC JgFreeLib(JG_LIBHANDLE LibHandle);
  #define JG_GETLIBFN(LibHandle, FuncName) JgGetLibFn(LibHandle, #FuncName)
  void JGPTR JGFUNC JgGetLibFn(JG_LIBHANDLE LibHandle, char JGPTR FuncName);
#else
  #define JG_LOADLIB(LibFileName) ((JG_LIBHANDLE) (UINT32) (LibFileName))
  #define JG_FREELIB(LibHandle) { LibHandle = LibHandle; }
  #define JG_GETLIBFN(LibHandle, FuncName) (LibHandle = LibHandle, FuncName)
#endif


#ifndef JGNOMEMDEF
 #ifdef JGMACH32
  #define JG_FMALLOC(n) Jgmalloc((UINTW)(n))
  #define JG_ZFMALLOC(n) Jgmalloc((UINTW)(n))
  #define JG_MALLOC     Jgmalloc
  void * JGFUNC         Jgmalloc(UINT32 n);
  #define JG_FFREE      Jgfree
  #define JG_ZFFREE     Jgfree
  #define JG_FREE       Jgfree
  void JGFUNC           Jgfree(void *p);
  #ifdef JGMEMCALL
	#define JG_MAKEEXEPTR JgMakeExePtr
	void JGPTR JGFUNC     JgMakeExePtr(void JGPTR p);
	#define JG_FREEEXEPTR JgFreeExePtr
	void JGFUNC JgFreeExePtr(void JGPTR p);
  #else
	#define JG_MAKEEXEPTR(a) (a)
	#define JG_FREEEXEPTR(a)
  #endif
 #else
  #ifndef JGMEMCALL
    #define JGMEMCALL
  #endif
    #define JG_MALLOC   Jgmalloc
    void * JGFUNC       Jgmalloc(UINT32 n);
    #define JG_FREE     Jgfree
    void JGFUNC         Jgfree(void *p);

    #define JG_FMALLOC  Jgfmalloc       // note: must return 0-offset pointers
    void JGPTR JGFUNC   Jgfmalloc(UINT32 n);
    #define JG_ZFMALLOC Jgsvfmalloc
    void JGPTR JGFUNC Jgsvfmalloc(UINT32 n);
    #define JG_FFREE    Jgffree
    void JGFUNC         Jgffree(void JGPTR p);
    #define JG_ZFFREE   Jgffree
    void JGFUNC         Jgsvffree(void JGPTR p);
	#define JG_MAKEEXEPTR JgMakeExePtr
	void JGPTR JGFUNC     JgMakeExePtr(void JGPTR p);
	#define JG_FREEEXEPTR JgFreeExePtr
	void JGFUNC JgFreeExePtr(void JGPTR p);

 #endif
#endif

/**************************************
* ERROR CLASSIFICATIONS               *
**************************************/

#define JG_ERR_SHIFT (12)
#define JG_ERR_MASK  (0x000F)

#define JG_ERR_UNKNOWN (0<<JG_ERR_SHIFT) // (Place holder, don't use this)
#define JG_ERR_STATUS  (1<<JG_ERR_SHIFT) // Exceptions that may not be errors
#define JG_ERR_MEMORY  (2<<JG_ERR_SHIFT) // Memory allocation errors
#define JG_ERR_FILEIO  (3<<JG_ERR_SHIFT) // File IO Errors
#define JG_ERR_ARG     (4<<JG_ERR_SHIFT) // Errors due to passing bad args
#define JG_ERR_VERSION (5<<JG_ERR_SHIFT) // Errors due to version mismatch
#define JG_ERR_DATA    (6<<JG_ERR_SHIFT) // Errors due to corrupted data
#define JG_ERR_CHECK   (7<<JG_ERR_SHIFT) // Internal consistency checks
#define JG_ERR_STATE   (8<<JG_ERR_SHIFT) // State invalid to perform operation

#define JGERR_BASE			0x0f00		// JGERR-type standard error code base
#define JGERR_NOMEM			/* insufficient memory */	\
							(JG_ERR_MEMORY	| JGERR_BASE | 0)
#define JGERR_BADARG		/* bad function argument */	\
							(JG_ERR_ARG		| JGERR_BASE | 4)
#define JGERR_BADHANDLE		/* invalid/corrupt handle */ \
							(JG_ERR_ARG		| JGERR_BASE | 5)
#define JGERR_BADVERSION	/* unknown/obsolete version */ \
							(JG_ERR_DATA	| JGERR_BASE | 6)
#define JGERR_BADDATA		/* data block is corrupt */ \
							(JG_ERR_DATA	| JGERR_BASE | 7)
#define JGERR_BADSTREAM		/* data stream corrupt/out-of-order */ \
							(JG_ERR_DATA	| JGERR_BASE | 8)
#define JGERR_BUFOVERFLOW	/* output buffer too small */ \
							(JG_ERR_DATA	| JGERR_BASE | 9)
#define JGERR_SHORTBUF		/* insufficient input data */ \
							(JG_ERR_DATA	| JGERR_BASE | 10)
#define JGERR_BADSTATE		/* improper state for operation */ \
							(JG_ERR_STATE	| JGERR_BASE | 13)
#define JGERR_WAITING		/* system waiting caller action */ \
							(JG_ERR_STATE	| JGERR_BASE | 14)
#define JGERR_DONE			/* cannot proceed - process complete */ \
							(JG_ERR_STATE	| JGERR_BASE | 15)
#define JGERR_INTERNAL		/* fatal internal error */ \
							(JG_ERR_CHECK	| JGERR_BASE | 16)
#define JGERR_LIBNOTFOUND	/* DLL library not found */ \
							(JG_ERR_CHECK	| JGERR_BASE | 17)

/**************************************
* COMPLEX STRUCTURES                  *
**************************************/

// More complex structures/types.

typedef UINT32 JGFOURCHAR;		// Four character code
#define JG_MAKEFOURCHAR(a,b,c,d) \
	(((UINT32)(UINT8)(a) << 24) | ((UINT32)(UINT8)(b) << 16) | \
	((UINT32)(UINT8)(c) << 8) | (UINT32)(UINT8)(d))
#define JG4C_AUTO JG_MAKEFOURCHAR('a','u','t','o')	// image formats
#define JG4C_ART  JG_MAKEFOURCHAR('A','R','T','f')
#define JG4C_GIF  JG_MAKEFOURCHAR('G','I','F','f')
#define JG4C_BMP  JG_MAKEFOURCHAR('B','M','P',' ')
#define JG4C_JPEG JG_MAKEFOURCHAR('J','P','E','G')
#define JG4C_ART_GT8	JG_MAKEFOURCHAR('G','T','8',' ') // .ART sub-formats
#define JG4C_ART_GT24	JG_MAKEFOURCHAR('G','T','2','4')
#define JG4C_ART_CT	JG_MAKEFOURCHAR('C','T',' ',' ')
#define JG4C_ART_WAVE	JG_MAKEFOURCHAR('W','A','V','E')

typedef struct {		// component decoder stream type descriptor
    UINTW nSize;		// sizeof() this structure, in bytes
    JGFOURCHAR	ImageFormat;	// main format (JPEG, GIF, etc)
    JGFOURCHAR	SubFormat;	// sub-format (e.g. ART: GT, WAVE, etc), or 0
    char JGPTR	Extension;	// common three character file extension
    char JGPTR	Description;	// short format description string
} JG_READER_DESC;

typedef struct {                // bit-stream pointer structure
    UINT8 JGPTR BitPtr;         // pointer to next byte to access
    UINTW  BitCnt;              // next *BitPtr bit, 7(hi bit) to 0(low bit)
} BIT_STREAM;

typedef struct {                // bit-stream pointer structure
    UINT8 JGPTR BitPtr;         // pointer to next byte to access
    UINTW  BitCnt;              // next *BitPtr bit, 7(hi bit) to 0(low bit)
} JG_BIT_PTR;

typedef struct {                // "new" bit-block bit-stream pointer
    UINT8 JGPTR BitPtr;         // pointer to next byte to access in bit-block
    UINTW BitCnt;               // next *BitPtr bit, 7(hi bit) to 0(low bit)
    UINTW ByteCnt;              // bytes remaining in blk (including *BitPtr)
} JG_BIT_STREAM;

typedef struct {
	UINT8 JGPTR BufPtr;			// buffer pointer
	UINTW BufLeft;				// bytes remaining (0-n) starting at BufPtr
} JG_SIZED_PTR;

typedef struct {                // Vector description structure
    INT16 JGPTR Codebook;       // 4x4 block code book table
    UINT8 JGPTR Data;           // ptr to vector of CodeBook indexes
} VQ_DATA;

typedef struct {                // edge information structure
    UINT16 FirstBlock;          // absolute 1st-panel-block index
    UINT16 BlocksPerPanel;      // blocks per panel
    UINT16 NEdges;              // ??? undocumented ???
    UINT16 BlocksPerRow;        // number of blocks per panel row
    UINT16 NextEdgeBlock;       // next edge block's absolute position
    UINT16 JGPTR Offsets;       // ptr to offsets of following blocks
} EDGE_INFO;

// Portable color representations - when viewed as 32-bit values:
//
//   JG0RGB:   [31..24] = 0, [23..16] = Red, [15..8] = Green, [7..0] = Blue.
//   JG0YUV:   [31..24] = 0, [23..16] = Y,   [15..8] = U,     [7..0] = V.
//   JG0RGB16: [15..15] = 0, [14..10] = Red, [ 9..5] = Green, [4..0] = Blue.
//   JGRGB8:   [7..5] = Red, [ 4..2] = Green, [1..0] = Blue.

#define JG0RGB_UNDEFINED 0xffffffff

typedef UINT32 JG0RGB;
typedef UINT32 JG0YUV;
typedef UINT16 JG0RGB16;
typedef UINT8  JGRGB8;

// Structures for palettes, color data, ...
// If you are going to used these in arrays, (for palettes or images),
// make sure the 3 byte structures are packed tightly.

typedef struct {        // Used to define an RGB color in 3 bytes.
    UINT8 red;
    UINT8 green;
    UINT8 blue;
} JG_RGB;

typedef struct {        // Used to define an RGB color in 4 bytes.
    UINT8 red;
    UINT8 green;
    UINT8 blue;
    UINT8 flags;        // Don't care field. Named "flags" after Windows.
} JG_RGBX;

typedef struct {        // Used to define a color in 3 bytes. (RGB backwards)
    UINT8 blue;
    UINT8 green;
    UINT8 red;
} JG_BGR;

typedef struct {        // Used to define a color in 4 bytes. (RGB backwards)
    UINT8 blue;
    UINT8 green;
    UINT8 red;
    UINT8 flags;        // Don't care field.  Named "flags" after windows.
} JG_BGRX;

typedef struct {
    UINT8 y;            // Luminance Component.
    UINT8 u;            // U. Color difference. Usually offset by +128.
    UINT8 v;            // V. Color difference. Usually offset by +128.
} JG_YUV;

// JG_CCCXPAL is used to define 4 byte palette entry where the first three
// components may be any colorspace/order and the fourth is ignored.
typedef struct {
	UINT8   c0;
	UINT8   c1;
	UINT8   c2;
	UINT8   flags;
} JG_CCCXPAL;

// JG_CCCPAL is used to define 3 byte palette entry where the components
// may be any colorspace/order.
typedef struct {
	UINT8   c0;
	UINT8   c1;
	UINT8   c2;
} JG_CCCPAL;

// Pixel Formats
#define JG_PIXEL_UNDEFINED   0 // Undefined
#define JG_PIXEL_1BIT        1 // 1-bit index into a 2 color palette
#define JG_PIXEL_4BIT        2 // 4-bit index into a 16 color palette
#define JG_PIXEL_8BIT        3  // 8-bit index into a 256 color palette
#define JG_PIXEL_555         4  // JG0RGB16
#define JG_PIXEL_BGR         5  // JG_BGR
#define JG_PIXEL_YUV         6  // JG_YUV
#define JG_PIXEL_0RGB        7  // JG0RGB
#define JG_PIXEL_SPLIT_RGB   8  // Separate 8-bit components: R, G, then B
#define JG_PIXEL_SPLIT_YUV   9  // Separate 8-bit components: Y, U, then V
#define JG_PIXEL_332         10 // JGRGB8
#define JG_PIXEL_MASK        11 // 1-bit mask (1=image)


#ifdef __cplusplus
  }
#endif

#endif

/*----------------------------------------------------------------------------
;
; End of jgtypes.h
;
;---------------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\handler.h ===
#ifndef HANDLER_H
#define HANDLER_H



interface IScriptletHandlerConstructor;
interface IScriptletHandler;

/***************************************************************************
	Scriptlet Interface Handlers
	============================
	This is a preliminary draft. Changes may need to be made based on
	review feedback, support needed for client side security, and support
	for MTS scalability.
	
	The primary responsibility of a scriptlet interface handler is to 
	aggregate a set of COM interfaces with the scriptlet base runtime
	and translate calls made on those COM interfaces into calls to the
	script name space.
	
	Interface handlers are created using a constructor object. The 
	constructor object takes on the role similar to that of class
	objects in most other languages. It is intialized with the XML
	data nested in the implements element and then can be used for:	
		1. Execution - creating handler objects for scriptlet instances
		2. Registration - performing handler specific registration for an object
		3. Type library generation - generating a typelibrary for use with MTS
***************************************************************************/
typedef WORD PK;

#define pkELEMENT	0
#define pkATTRIBUTE	1
#define pkTEXT		2
#define pkCOMMENT	3
#define pkPI		4
#define pkXMLDECL	5
#define pkVALUE		6

#define fcompileIsXML		0x0001
#define fcompileValidate	0x0002
#define fcompileAllowDebug	0x8000
	
struct PNODE
	{
	PK pk;
	ULONG line;
	ULONG column;
	ULONG cchToken;
	LPCOLESTR pstrToken;
	PNODE *pnodeNext;
	union
		{
		struct
			{
			PNODE *pnodeAttr;
			PNODE *pnodeData;
			void *pvLim; // Used to calc amount of memory to allocate
			} element;
		
		struct 
			{
			PNODE *pnodeAttr;
			void *pvLim;
			} xmldecl;
			
		struct
			{
			PNODE *pnodeValue;
			void *pvLim; // Used to calc amount of memory to allocate
			} attribute, pi;

		struct
			{
			void *pvLim; // Used to calc amount of memory to allocate
			} text, comment, value;
		
		};
	};


DEFINE_GUID(IID_IScriptletHandlerConstructor, 0xa3d52a50, 0xb7ff, 0x11d1, 0xa3, 0x5a, 0x0, 0x60, 0x8, 0xc3, 0xfb, 0xfc);
interface IScriptletHandlerConstructor : public IUnknown
	{
    STDMETHOD(Load)(WORD wFlags, PNODE *pnode) PURE;
	STDMETHOD(Create)(IUnknown *punkContext, IUnknown *punkOuter,
			IUnknown **ppunkHandler) PURE;
	STDMETHOD(Register)(LPCOLESTR pstrPath, REFCLSID rclisid, 
			LPCOLESTR pstrProgId) PURE;
	STDMETHOD(Unregister)(REFCLSID rclsid, LPCOLESTR pstrProgId) PURE;
	STDMETHOD(AddInterfaceTypeInfo)(ICreateTypeLib *ptclib, 
			ICreateTypeInfo *pctiCoclass, UINT *puiImplIndex) PURE;
	};

DEFINE_GUID(IID_IScriptletHandler, 0xa001a870, 0xa7df, 0x11d1, 0x89, 0xbe, 0x0, 0x60, 0x8, 0xc3, 0xfb, 0xfc);
interface IScriptletHandler : public IUnknown
	{
	STDMETHOD(GetNameSpaceObject)(IUnknown **ppunk) PURE;
	STDMETHOD(SetScriptNameSpace)(IUnknown *punkNameSpace) PURE;
	};


#define IScriptletHandlerConstructorNew IScriptletHandlerConstructor
#define IID_IScriptletHandlerConstructorNew IID_IScriptletHandlerConstructorNew









/***************************************************************************
	Scriptlet XML Object Model Interfaces
	
	In an ideal world, we would be using a standard IPersistXML interface
	with a standardized XML DOM to load interface handlers from the XML
	data stream. Unfortunately, these interface definitions will not be ready
	in time for our ship date. As a result, we define our own private 
	intefaces which we will use until the official stuff becomes available.
	
	These interfaces are designed to provide the minimal set of methods
	needed to implement persistence support for scriptlet interface handlers.
	Matching the proposed XML interfaces was a consideration, but not an
	overwhelming factor. The main constraint in this design is the time
	required to implement.
	
	The return values of the methods name and data depend on the node 
	type. Here's a table that describes the return values for each of the
	types. NOTHING is signalled by the method returning S_FALSE and setting
	the bstr pointer to NULL.
	
	Type		name method					data method
	====		===========					===========
	ELEMENT		Tag name					NOTHING
	ATTRIBUTE	Attribute name				NOTHING or attribute value if exists
	TEXT		NOTHING						Characters in text
	COMMENT		NOTHING						Characters in comment
	PI			Processing instruction		Data for the PI.
	XMLDECL		NOTHING						NOTHING
	
	The getFirstChild and getAttributes methods are only valid for
	nodes of type ELEMENT. The nodes returned by getFirstAttribute will
	always be of type ScriptletXML_ATTRIBUTE.
	
	The getNext method gets the next sibling. The grfxml parameter allows
	you to filter out the types of nodes you're interested in. The flag
	fxmlText will only return only those text sequences that are not
	all white space. Passing in fxmlAllText will get all text nodes.
***************************************************************************/
interface IScriptletXML;

typedef enum
	{
	ScriptletXML_ELEMENT,
	ScriptletXML_ATTRIBUTE,
	ScriptletXML_TEXT,
	ScriptletXML_COMMENT,
	ScriptletXML_PI,
	ScriptletXML_XMLDECL,
	} ScriptletXMLNodeType;	

#define fxmlElement		(1<<ScriptletXML_ELEMENT)
#define fxmlAttribute 	(1<<ScriptletXML_ATTRIBUTE)
#define fxmlText		(1<<ScriptletXML_TEXT)
#define fxmlComment		(1<<ScriptletXML_COMMENT)
#define fxmlPI			(1<<ScriptletXML_PI)
#define fxmlXMLDecl		(1<<ScriptletXML_XMLDECL)
#define fxmlHasText		0x0100

#define kgrfxmlNormal	(fxmlElement|fxmlHasText)
#define kgrfxmlAll		(fxmlElement|fxmlAttribute|fxmlText|fxmlComment| \
							fxmlPI|fxmlXMLDecl)

#define fattrFailOnUnknown	0x0001
							
							
DEFINE_GUID(IID_IScriptletXML, 0xddd30cc0, 0xa3fe, 0x11d1, 0xb3, 0x82, 0x0, 0xa0, 0xc9, 0x11, 0xe8, 0xb2);

interface IScriptletXML : public IUnknown
    {
	STDMETHOD(getNodeType)(long *ptype) PURE;
	STDMETHOD(getPosition)(ULONG *pline, ULONG *pcolumn) PURE;
	STDMETHOD(getName)(BSTR *pbstrName) PURE;
	STDMETHOD(getData)(BSTR *pbstrValue) PURE; 
	STDMETHOD(getNext)(WORD grfxmlFilter, IScriptletXML **ppxml) PURE;
	STDMETHOD(getFirstChild)(WORD grfxmlFilter, IScriptletXML **ppxml) PURE;
	STDMETHOD(getFirstAttribute)(IScriptletXML **ppxml) PURE;
	STDMETHOD(getAttributes)(WORD grfattr, long cattr, 
			LPCOLESTR *prgpstrAttributes, BSTR *prgbstrValues) PURE;
    };



DEFINE_GUID(IID_IScriptletHandlerConstructorOld, 0x67463cd0, 0xb371, 0x11d1, 0x89, 0xca, 0x0, 0x60, 0x8, 0xc3, 0xfb, 0xfc);
interface IScriptletHandlerConstructorOld : public IUnknown
	{
    STDMETHOD(Load)(WORD wFlags, IScriptletXML *pxmlElement) PURE;
	STDMETHOD(Create)(IUnknown *punkContext, IUnknown *punkOuter,
			IUnknown **ppunkHandler) PURE;
	STDMETHOD(Register)(LPCOLESTR pstrPath, REFCLSID rclisid, 
			LPCOLESTR pstrProgId) PURE;
	STDMETHOD(Unregister)(REFCLSID rclsid, LPCOLESTR pstrProgId) PURE;
	STDMETHOD(AddInterfaceTypeInfo)(ICreateTypeLib *ptclib, 
			ICreateTypeInfo *pctiCoclass, UINT *puiImplIndex) PURE;
	};



#endif // HANDLER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\multinfo.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Mar 29 16:59:57 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __multinfo_h__
#define __multinfo_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IProvideClassInfo_FWD_DEFINED__
#define __IProvideClassInfo_FWD_DEFINED__
typedef interface IProvideClassInfo IProvideClassInfo;
#endif 	/* __IProvideClassInfo_FWD_DEFINED__ */


#ifndef __IProvideClassInfo2_FWD_DEFINED__
#define __IProvideClassInfo2_FWD_DEFINED__
typedef interface IProvideClassInfo2 IProvideClassInfo2;
#endif 	/* __IProvideClassInfo2_FWD_DEFINED__ */


#ifndef __IProvideMultipleClassInfo_FWD_DEFINED__
#define __IProvideMultipleClassInfo_FWD_DEFINED__
typedef interface IProvideMultipleClassInfo IProvideMultipleClassInfo;
#endif 	/* __IProvideMultipleClassInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri Mar 29 16:59:57 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


#ifndef _OLECTL_H_
#include <olectl.h>
#endif
#if 0


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IProvideClassInfo_INTERFACE_DEFINED__
#define __IProvideClassInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideClassInfo
 * at Fri Mar 29 16:59:57 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IProvideClassInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IProvideClassInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassInfo( 
            /* [out] */ LPTYPEINFO __RPC_FAR *ppTI) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideClassInfoVtbl
    {
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IProvideClassInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IProvideClassInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IProvideClassInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassInfo )( 
            IProvideClassInfo __RPC_FAR * This,
            /* [out] */ LPTYPEINFO __RPC_FAR *ppTI);
        
    } IProvideClassInfoVtbl;

    interface IProvideClassInfo
    {
        CONST_VTBL struct IProvideClassInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideClassInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideClassInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideClassInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideClassInfo_GetClassInfo(This,ppTI)	\
    (This)->lpVtbl -> GetClassInfo(This,ppTI)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IProvideClassInfo_GetClassInfo_Proxy( 
    IProvideClassInfo __RPC_FAR * This,
    /* [out] */ LPTYPEINFO __RPC_FAR *ppTI);


void __RPC_STUB IProvideClassInfo_GetClassInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideClassInfo_INTERFACE_DEFINED__ */


#ifndef __IProvideClassInfo2_INTERFACE_DEFINED__
#define __IProvideClassInfo2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideClassInfo2
 * at Fri Mar 29 16:59:57 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IProvideClassInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IProvideClassInfo2 : public IProvideClassInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetGUID( 
            /* [in] */ DWORD dwGuidKind,
            /* [out] */ GUID __RPC_FAR *pGUID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideClassInfo2Vtbl
    {
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IProvideClassInfo2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IProvideClassInfo2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IProvideClassInfo2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassInfo )( 
            IProvideClassInfo2 __RPC_FAR * This,
            /* [out] */ LPTYPEINFO __RPC_FAR *ppTI);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGUID )( 
            IProvideClassInfo2 __RPC_FAR * This,
            /* [in] */ DWORD dwGuidKind,
            /* [out] */ GUID __RPC_FAR *pGUID);
        
    } IProvideClassInfo2Vtbl;

    interface IProvideClassInfo2
    {
        CONST_VTBL struct IProvideClassInfo2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideClassInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideClassInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideClassInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideClassInfo2_GetClassInfo(This,ppTI)	\
    (This)->lpVtbl -> GetClassInfo(This,ppTI)


#define IProvideClassInfo2_GetGUID(This,dwGuidKind,pGUID)	\
    (This)->lpVtbl -> GetGUID(This,dwGuidKind,pGUID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IProvideClassInfo2_GetGUID_Proxy( 
    IProvideClassInfo2 __RPC_FAR * This,
    /* [in] */ DWORD dwGuidKind,
    /* [out] */ GUID __RPC_FAR *pGUID);


void __RPC_STUB IProvideClassInfo2_GetGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideClassInfo2_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0053
 * at Fri Mar 29 16:59:57 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


#endif // 0
// {A7ABA9C1-8983-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IProvideMultipleClassInfo,
0xa7aba9c1, 0x8983, 0x11cf, 0x8f, 0x20, 0x0, 0x80, 0x5f, 0x2c, 0xd0, 0x64);


extern RPC_IF_HANDLE __MIDL__intf_0053_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0053_v0_0_s_ifspec;

#ifndef __IProvideMultipleClassInfo_INTERFACE_DEFINED__
#define __IProvideMultipleClassInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideMultipleClassInfo
 * at Fri Mar 29 16:59:57 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


#define MULTICLASSINFO_GETTYPEINFO           0x00000001
#define MULTICLASSINFO_GETNUMRESERVEDDISPIDS 0x00000002
#define MULTICLASSINFO_GETIIDPRIMARY         0x00000004
#define MULTICLASSINFO_GETIIDSOURCE          0x00000008
#define TIFLAGS_EXTENDDISPATCHONLY           0x00000001

EXTERN_C const IID IID_IProvideMultipleClassInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IProvideMultipleClassInfo : public IProvideClassInfo2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMultiTypeInfoCount( 
            /* [out] */ ULONG __RPC_FAR *pcti) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInfoOfIndex( 
            /* [in] */ ULONG iti,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptiCoClass,
            /* [out] */ DWORD __RPC_FAR *pdwTIFlags,
            /* [out] */ ULONG __RPC_FAR *pcdispidReserved,
            /* [out] */ IID __RPC_FAR *piidPrimary,
            /* [out] */ IID __RPC_FAR *piidSource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideMultipleClassInfoVtbl
    {
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IProvideMultipleClassInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IProvideMultipleClassInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassInfo )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [out] */ LPTYPEINFO __RPC_FAR *ppTI);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGUID )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [in] */ DWORD dwGuidKind,
            /* [out] */ GUID __RPC_FAR *pGUID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMultiTypeInfoCount )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcti);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfoOfIndex )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [in] */ ULONG iti,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptiCoClass,
            /* [out] */ DWORD __RPC_FAR *pdwTIFlags,
            /* [out] */ ULONG __RPC_FAR *pcdispidReserved,
            /* [out] */ IID __RPC_FAR *piidPrimary,
            /* [out] */ IID __RPC_FAR *piidSource);
        
    } IProvideMultipleClassInfoVtbl;

    interface IProvideMultipleClassInfo
    {
        CONST_VTBL struct IProvideMultipleClassInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideMultipleClassInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideMultipleClassInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideMultipleClassInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideMultipleClassInfo_GetClassInfo(This,ppTI)	\
    (This)->lpVtbl -> GetClassInfo(This,ppTI)


#define IProvideMultipleClassInfo_GetGUID(This,dwGuidKind,pGUID)	\
    (This)->lpVtbl -> GetGUID(This,dwGuidKind,pGUID)


#define IProvideMultipleClassInfo_GetMultiTypeInfoCount(This,pcti)	\
    (This)->lpVtbl -> GetMultiTypeInfoCount(This,pcti)

#define IProvideMultipleClassInfo_GetInfoOfIndex(This,iti,dwFlags,pptiCoClass,pdwTIFlags,pcdispidReserved,piidPrimary,piidSource)	\
    (This)->lpVtbl -> GetInfoOfIndex(This,iti,dwFlags,pptiCoClass,pdwTIFlags,pcdispidReserved,piidPrimary,piidSource)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IProvideMultipleClassInfo_GetMultiTypeInfoCount_Proxy( 
    IProvideMultipleClassInfo __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcti);


void __RPC_STUB IProvideMultipleClassInfo_GetMultiTypeInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProvideMultipleClassInfo_GetInfoOfIndex_Proxy( 
    IProvideMultipleClassInfo __RPC_FAR * This,
    /* [in] */ ULONG iti,
    /* [in] */ DWORD dwFlags,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptiCoClass,
    /* [out] */ DWORD __RPC_FAR *pdwTIFlags,
    /* [out] */ ULONG __RPC_FAR *pcdispidReserved,
    /* [out] */ IID __RPC_FAR *piidPrimary,
    /* [out] */ IID __RPC_FAR *piidSource);


void __RPC_STUB IProvideMultipleClassInfo_GetInfoOfIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideMultipleClassInfo_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\mshtmsvr.h ===
/*++

     Copyright (c) 1998 Microsoft Corporation

     Module Name:
         mshtmsvr.h

     Abstract:
         This header file declares the API for connecting IIS to MSHTML.DLL

     Authors:
         Anand Ramakrishna (anandra)
         Dmitry Robsman (dmitryr)

     Revision History:

--*/

#ifndef _MSHTMSVR_H_
#define _MSHTMSVR_H_

//
//  Callback definitions
//
//

typedef BOOL
(WINAPI *PFN_SVR_WRITER_CALLBACK)(
    VOID *pvSvrContext,             // [in] passed to GetDLText
    void *pvBuffer,                 // [in] data
    DWORD cbBuffer                  // [in] data length (bytes)
    );

typedef BOOL
(WINAPI *PFN_SVR_MAPPER_CALLBACK)(
    VOID *pvSvrContext,             // [in] passed to GetDLText
    CHAR *pchVirtualFileName,       // [in] virtual file name to map
    CHAR *pchPhysicalFilename,      // [in, out] physical file name
    DWORD cchMax                    // [in] buffer size
    );

typedef BOOL
(WINAPI *PFN_SVR_GETINFO_CALLBACK)(
    VOID *pvSvrContext,             // [in] passed to GetDLText
    DWORD dwInfo,                   // [in] One of the SVRINFO_XXXX contants
    CHAR *pchBuffer,                // [in, out] buffer
    DWORD cchMax                    // [in] buffer size
    );

//
//  Constants for GETINFO callback
//
                                        // Example          http://host/page.htm?a=v
#define SVRINFO_PROTOCOL        1       // SERVER_PROTOCOL  HTTP/1.1
#define SVRINFO_HOST            2       // SERVER_NAME      host
#define SVRINFO_PATH            3       // PATH_INFO        /page.htm
#define SVRINFO_PATH_TRANSLATED 4       // PATH_TRANSLATED  c:\wwwroot\page.htm
#define SVRINFO_QUERY_STRING    5       // QUERY_STRING     a=v
#define SVRINFO_PORT            6       // SERVER_PORT      80
#define SVRINFO_METHOD          7       // REQUEST_METHOD   GET
#define SVRINFO_USERAGENT       8       // HTTP_USER_AGENT  Mozilla/4.0 ...

//
//  Constants for Normalized User Agent
//

#define USERAGENT_RESERVED  0xffffffff
#define USERAGENT_DEFAULT   0
#define USERAGENT_IE3       1
#define USERAGENT_IE4       2
#define USERAGENT_NAV5      3
#define USERAGENT_NAV4      4
#define USERAGENT_NAV3      5
#define USERAGENT_IE5       10000

//
//  The API
//
//

#ifdef __cplusplus
extern "C" {
#endif

BOOL WINAPI 
SvrTri_NormalizeUA(
    CHAR  *pchUA,                      // [in] User agent string
    DWORD *pdwUA                       // [out] User agend id
    );

BOOL WINAPI
SvrTri_GetDLText(
    VOID *pvSrvContext,                // [in] Server Context
    DWORD dwUA,                        // [in] User Agent (Normalized)
    CHAR *pchFileName,                 // [in] Physical file name of htm file
    IDispatch *pdisp,                  // [in] OA 'Server' object for scripting
    PFN_SVR_GETINFO_CALLBACK pfnInfo,  // [in] GetInfo callback
    PFN_SVR_MAPPER_CALLBACK pfnMapper, // [in] Mapper callback
    PFN_SVR_WRITER_CALLBACK pfnWriter, // [in] Writer callback
    DWORD *rgdwUAEquiv,                // [in, out] Array of ua equivalences
    DWORD cUAEquivMax,                 // [in] Size of array of ua equiv
    DWORD *pcUAEquiv                   // [out] # of UA Equivalencies filled in
    );

#ifdef __cplusplus
};
#endif

#endif // _MSHTMSVR_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\objext.h ===
#ifndef UNIX
#pragma pack(push, 8)
#endif 
//+------------------------------------------------------------------------
//  
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//  
//  File:       objext.h
//  
//  Contents:   header file for Object Extensions interfaces
//  
//              6/24/96 (dbau) removed IServiceProvider (to servprov.h)
//-------------------------------------------------------------------------

#ifndef __OBJEXT_H
#define __OBJEXT_H

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

///////////////////////////////////////////////////////////////////////////
//
// forward declares
//
///////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
interface IFilterMembers;
#else  // __cplusplus
typedef interface IFilterMembers IFilterMembers;
#endif  // __cplusplus

///////////////////////////////////////////////////////////////////////////
//
// Object Extension Interfaces
//
///////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////
//
// Standard Services and Interfaces
//
///////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------
//  SLicensedClassManager
//    VBA provides this service to it's components and hosts to optimize
//    registry access and to insulate them from licensing concerns
//
//  interfaces implemented:
//    ILicensedClassManager
//-------------------------------------------------------------------------
// { 6d5140d0-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IRequireClasses, 0x6d5140d0, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  IRequireClasses
DECLARE_INTERFACE_(IRequireClasses, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IRequireClasses methods ***
    STDMETHOD(CountRequiredClasses)(THIS_
                    /* [out] */ ULONG * pcClasses ) PURE;
    STDMETHOD(GetRequiredClasses)(THIS_
                  /* [in]  */ ULONG index,
                  /* [out] */ CLSID * pclsid ) PURE;
};

// { 6d5140d4-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ILicensedClassManager, 0x6d5140d4, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SLicensedClassManager  IID_ILicensedClassManager

#undef  INTERFACE
#define INTERFACE  ILicensedClassManager
DECLARE_INTERFACE_(ILicensedClassManager, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ILicensedClassManager methods ***
    STDMETHOD(OnChangeInRequiredClasses)(THIS_
                     /* [in] */ IRequireClasses *pRequireClasses) PURE;
};


//-------------------------------------------------------------------------
//  SLocalRegistry Service
//    VBA provides this service to it's components and hosts to optimize
//    registry access and to insulate them from licensing concerns
//
//  interfaces implemented:
//    ILocalRegistry
//-------------------------------------------------------------------------

// { 6d5140d3-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ILocalRegistry, 0x6d5140d3, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SLocalRegistry IID_ILocalRegistry

#undef  INTERFACE
#define INTERFACE  ILocalRegistry
DECLARE_INTERFACE_(ILocalRegistry, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ILocalRegistry methods ***
    STDMETHOD(CreateInstance)(THIS_
                  /* [in]  */ CLSID      clsid,     
                  /* [in]  */ IUnknown * punkOuter,
                  /* [in]  */ REFIID     riid,
                  /* [in]  */ DWORD      dwFlags,
                  /* [out] */ void **    ppvObj ) PURE;
    STDMETHOD(GetTypeLibOfClsid)(THIS_
                 /* [in]  */ CLSID       clsid,
                 /* [out] */ ITypeLib ** ptlib ) PURE;
    STDMETHOD(GetClassObjectOfClsid)(THIS_
                     /* [in]  */ REFCLSID clsid,
                                 /* [in]  */ DWORD    dwClsCtx,
                     /* [in]  */ LPVOID   lpReserved,
                     /* [in]  */ REFIID   riid,
                     /* [out] */ void **  ppcClassObject ) PURE;
};



#endif // __OBJEXT_H

#ifndef UNIX
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\plugin_i.h ===
/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: ActiveXPlugin */

#ifndef _ActiveXPlugin_H_
#define _ActiveXPlugin_H_

DEFINE_GUID(LIBID_ActiveXPlugin,0x06DD38D0L,0xD187,0x11CF,0xA8,0x0D,0x00,0xC0,0x4F,0xD7,0x4A,0xD8);
#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

DEFINE_GUID(IID_IActiveXPlugin,0x06DD38D1L,0xD187,0x11CF,0xA8,0x0D,0x00,0xC0,0x4F,0xD7,0x4A,0xD8);

/* Definition of interface: IActiveXPlugin */
#undef INTERFACE
#define INTERFACE IActiveXPlugin

DECLARE_INTERFACE_(IActiveXPlugin, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IActiveXPlugin methods */
    STDMETHOD_(void, Load)(THIS_ BSTR bstrUrl, int bDeleteRegistry) PURE;
    STDMETHOD_(void, AddParam)(THIS_ BSTR bstrName, BSTR bstrValue) PURE;
    STDMETHOD_(void, Show)(THIS) PURE;
    STDMETHOD_(void, Hide)(THIS) PURE;
    STDMETHOD_(void, Clear)(THIS) PURE;
    STDMETHOD(get_dispatch)(THIS_ IDispatch * FAR* retval) PURE;
};

DEFINE_GUID(DIID_DActiveXPluginEvents,0x06DD38D2L,0xD187,0x11CF,0xA8,0x0D,0x00,0xC0,0x4F,0xD7,0x4A,0xD8);

/* Definition of dispatch interface: DActiveXPluginEvents */
#undef INTERFACE
#define INTERFACE DActiveXPluginEvents

DECLARE_INTERFACE_(DActiveXPluginEvents, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif
};

DEFINE_GUID(CLSID_ActiveXPlugin,0x06DD38D3L,0xD187,0x11CF,0xA8,0x0D,0x00,0xC0,0x4F,0xD7,0x4A,0xD8);

#ifdef __cplusplus
class ActiveXPlugin;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\pstat.h ===
#ifndef _PSTAT_INCLUDED_
#define _PSTAT_INCLUDED_


#define MAX_EVENTS              2
#define MAX_THUNK_COUNTERS     64
#define MAX_PROCESSORS         32


#define PSTAT_READ_STATS    CTL_CODE (FILE_DEVICE_UNKNOWN, 0, METHOD_NEITHER, FILE_ANY_ACCESS)
#define PSTAT_SET_CESR      CTL_CODE (FILE_DEVICE_UNKNOWN, 1, METHOD_NEITHER, FILE_ANY_ACCESS)
#define PSTAT_HOOK_THUNK    CTL_CODE (FILE_DEVICE_UNKNOWN, 2, METHOD_NEITHER, FILE_ANY_ACCESS)
#define PSTAT_REMOVE_HOOK   CTL_CODE (FILE_DEVICE_UNKNOWN, 3, METHOD_NEITHER, FILE_ANY_ACCESS)
#define PSTAT_QUERY_EVENTS  CTL_CODE (FILE_DEVICE_UNKNOWN, 4, METHOD_NEITHER, FILE_ANY_ACCESS)

#define OFFSET(type, field) ((LONG)(&((type *)0)->field))

//
//
//

typedef struct {
    ULONGLONG       Counters[MAX_EVENTS];
    ULONG           EventId[MAX_EVENTS];
    ULONGLONG       TSC;
    ULONG           reserved;
    ULONG           SpinLockAcquires;
    ULONG           SpinLockCollisions;
    ULONG           SpinLockSpins;
    ULONG           Irqls;
    ULONG           ThunkCounters[MAX_THUNK_COUNTERS];
} PSTATS, *pPSTATS;

typedef struct {
    ULONG           EventId;
    BOOLEAN         Active;
    BOOLEAN         UserMode;
    BOOLEAN         KernelMode;
    BOOLEAN         EdgeDetect;
    ULONG           AppReserved;
    ULONG           reserved;
} SETEVENT, *PSETEVENT;

typedef struct {
    PUCHAR          SourceModule;
    ULONG           ImageBase;
    PUCHAR          TargetModule;
    PUCHAR          Function;
    ULONG           TracerId;
} HOOKTHUNK, *PHOOKTHUNK;

typedef struct {
    ULONG           EventId;
    KPROFILE_SOURCE ProfileSource;
    ULONG           DescriptionOffset;
    ULONG           SuggestedIntervalBase;
    UCHAR           Buffer[];
} EVENTID, *PEVENTID;

#endif /* _PSTAT_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\w95fiber.h ===
//
//  W95FIBER.H
//
//  Copyright (C) Microsoft Corporation, 1996
//
//  Public definitions for the Windows 95 fiber library.
//

#ifndef _W95FIBER_
#define _W95FIBER_

#ifdef __cplusplus
extern "C" {
#endif

typedef VOID (WINAPI *PFIBER_START_ROUTINE)(
    LPVOID lpFiberParameter
    );
typedef PFIBER_START_ROUTINE LPFIBER_START_ROUTINE;

#ifdef _X86_

LPVOID
WINAPI
FbrCreateFiber(
    DWORD dwStackSize,
    LPFIBER_START_ROUTINE lpStartAddress,
    LPVOID lpParameter
    );

VOID
WINAPI
FbrDeleteFiber(
    LPVOID lpFiber
    );

LPVOID
WINAPI
FbrConvertThreadToFiber(
    LPVOID lpParameter
    );

VOID
WINAPI
FbrSwitchToFiber(
    LPVOID lpFiber
    );

LPVOID
WINAPI
FbrGetCurrentFiber(
    VOID
    );

LPVOID
WINAPI
FbrGetFiberData(
    VOID
    );

BOOL
WINAPI
FbrAttachToBase(
    VOID
    );

VOID
WINAPI
FbrDetachFromBase(
    VOID
    );

#else

#define FbrCreateFiber              CreateFiber
#define FbrDeleteFiber              DeleteFiber
#define FbrConvertThreadToFiber     ConvertThreadToFiber
#define FbrSwitchToFiber            SwitchToFiber
#define FbrGetCurrentFiber()        GetCurrentFiber()
#define FbrGetFiberData()           GetFiberData()
#define FbrAttachToBase()           (g_dwPlatformID != VER_PLATFORM_WIN32_WINDOWS)
#define FbrDetachFromBase()

#endif // _X86_

#ifdef __cplusplus
}
#endif

#endif // _W95FIBER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\oledbtri.h ===
/* This file contains a few interfaces that were once part of OLE-DB
    but that Trident still uses.  Cut-and-paste from oledb.h (version below).
*/

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu May 22 17:05:14 1997
 */
/* Compiler settings for C:\oledb\PRIVATE\OLEDB\IDL\oledb.idl:
    Oicf (OptLev=i2), W1, Zp2, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifdef WIN16
#define OLEDBVER 0x0200
#endif

#ifndef __oledbtri_h__
#define __oledbtri_h__

#ifdef __cplusplus
extern "C"{
#endif 

#ifndef __IRowsetExactScroll_FWD_DEFINED__
#define __IRowsetExactScroll_FWD_DEFINED__
typedef interface IRowsetExactScroll IRowsetExactScroll;
#endif 	/* __IRowsetExactScroll_FWD_DEFINED__ */


#ifndef __IRowsetNewRowAfter_FWD_DEFINED__
#define __IRowsetNewRowAfter_FWD_DEFINED__
typedef interface IRowsetNewRowAfter IRowsetNewRowAfter;
#endif 	/* __IRowsetNewRowAfter_FWD_DEFINED__ */


/* header files for imported files */
#ifndef WIN16
#include "wtypes.h"
#endif
#include "oaidl.h"
#include "transact.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


/****************************************
 * Generated header for interface: __MIDL_itf_oledb_0082
 * at Thu May 22 17:05:14 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


#if( OLEDBVER >= 0x0200 )


extern RPC_IF_HANDLE __MIDL_itf_oledb_0082_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oledb_0082_v0_0_s_ifspec;

#ifndef __IRowsetExactScroll_INTERFACE_DEFINED__
#define __IRowsetExactScroll_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowsetExactScroll
 * at Thu May 22 17:05:14 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IRowsetExactScroll;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a7f-2a1c-11ce-ade5-00aa0044773d")
    IRowsetExactScroll : public IRowsetScroll
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExactPosition( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBBKMARK cbBookmark,
            /* [size_is][in] */ const BYTE __RPC_FAR *pBookmark,
            /* [out] */ DBCOUNTITEM __RPC_FAR *pulPosition,
            /* [out] */ DBCOUNTITEM __RPC_FAR *pcRows) = 0;
        
    };
    
#else 	/* C style interface */

#error "C style interface not maintained"

#endif 	/* C style interface */

#endif 	/* __IRowsetExactScroll_INTERFACE_DEFINED__ */
#endif /* OLEDBVER >= 0200 */


/****************************************
 * Generated header for interface: __MIDL_itf_oledb_0087
 * at Thu May 22 17:05:14 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


//@@@+ V2.0
#if( OLEDBVER >= 0x0200 )


extern RPC_IF_HANDLE __MIDL_itf_oledb_0087_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oledb_0087_v0_0_s_ifspec;

#ifndef __IRowsetNewRowAfter_INTERFACE_DEFINED__
#define __IRowsetNewRowAfter_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRowsetNewRowAfter
 * at Thu May 22 17:05:14 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object][local] */ 



EXTERN_C const IID IID_IRowsetNewRowAfter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0c733a71-2a1c-11ce-ade5-00aa0044773d")
    IRowsetNewRowAfter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetNewDataAfter( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBBKMARK cbbmPrevious,
            /* [size_is][in] */ const BYTE __RPC_FAR *pbmPrevious,
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ BYTE __RPC_FAR *pData,
            /* [out] */ HROW __RPC_FAR *phRow) = 0;
        
    };
    
#else 	/* C style interface */

#error "C style interface not maintained"

#endif 	/* C style interface */
#endif 	/* __IRowsetNewRowAfter_INTERFACE_DEFINED__ */
#endif /* OLEDBVER >= 0200 */


#if( OLEDBVER >= 0x0200 )
// IID_IRowsetExactScroll		= {0x0c733a7f,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
// IID_IRowsetNewRowAfter		= {0x0c733a71,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}}
#endif // OLEDBVER >= 0x0200

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\oleacc.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0158 */
/* at Wed May 13 11:31:10 1998
 */
/* Compiler settings for oleacc.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef UNIX
#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#else
#define MIDL_INTERFACE(x) struct
#endif

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __oleacc_h__
#define __oleacc_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IAccessible_FWD_DEFINED__
#define __IAccessible_FWD_DEFINED__
typedef interface IAccessible IAccessible;
#endif 	/* __IAccessible_FWD_DEFINED__ */


#ifndef __IAccessibleHandler_FWD_DEFINED__
#define __IAccessibleHandler_FWD_DEFINED__
typedef interface IAccessibleHandler IAccessibleHandler;
#endif 	/* __IAccessibleHandler_FWD_DEFINED__ */


#ifndef __IAccessible_FWD_DEFINED__
#define __IAccessible_FWD_DEFINED__
typedef interface IAccessible IAccessible;
#endif 	/* __IAccessible_FWD_DEFINED__ */


#ifndef __IAccessibleHandler_FWD_DEFINED__
#define __IAccessibleHandler_FWD_DEFINED__
typedef interface IAccessibleHandler IAccessibleHandler;
#endif 	/* __IAccessibleHandler_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_oleacc_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// OLEACC.H
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// Typedefs
//=--------------------------------------------------------------------------=

typedef LRESULT (STDAPICALLTYPE *LPFNLRESULTFROMOBJECT)(REFIID riid, WPARAM wParam, LPUNKNOWN punk);
typedef HRESULT (STDAPICALLTYPE *LPFNOBJECTFROMLRESULT)(LRESULT lResult, REFIID riid, WPARAM wParam, void** ppvObject);
typedef HRESULT (STDAPICALLTYPE *LPFNACCESSIBLEOBJECTFROMWINDOW)(HWND hwnd, DWORD dwId, REFIID riid, void** ppvObject);
typedef HRESULT (STDAPICALLTYPE *LPFNACCESSIBLEOBJECTFROMPOINT)(POINT ptScreen, IAccessible** ppacc, VARIANT* pvarChild);
typedef HRESULT (STDAPICALLTYPE *LPFNCREATESTDACCESSIBLEOBJECT)(HWND hwnd, LONG idObject, REFIID riid, void** ppvObject);
typedef HRESULT (STDAPICALLTYPE *LPFNACCESSIBLECHILDREN)(IAccessible* paccContainer, LONG iChildStart,LONG cChildren,VARIANT* rgvarChildren,LONG* pcObtained);

//=--------------------------------------------------------------------------=
// GUIDs
//=--------------------------------------------------------------------------=

DEFINE_GUID(LIBID_Accessibility,	0x1ea4dbf0, 0x3c3b, 0x11cf, 0x81, 0x0c, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(IID_IAccessible,		0x618736e0, 0x3c3d, 0x11cf, 0x81, 0x0c, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
DEFINE_GUID(IID_IAccessibleHandler, 0x03022430, 0xABC4, 0x11d0, 0xBD, 0xE2, 0x00, 0xAA, 0x00, 0x1A, 0x19, 0x53);

//=--------------------------------------------------------------------------=
// MSAA API Prototypes
//=--------------------------------------------------------------------------=

STDAPI_(LRESULT) LresultFromObject(REFIID riid, WPARAM wParam, LPUNKNOWN punk);
STDAPI          ObjectFromLresult(LRESULT lResult, REFIID riid, WPARAM wParam, void** ppvObject);
STDAPI          WindowFromAccessibleObject(IAccessible*, HWND* phwnd);
STDAPI          AccessibleObjectFromWindow(HWND hwnd, DWORD dwId, REFIID riid, void **ppvObject);
STDAPI          AccessibleObjectFromEvent(HWND hwnd, DWORD dwId, DWORD dwChildId, IAccessible** ppacc, VARIANT* pvarChild);
STDAPI          AccessibleObjectFromPoint(POINT ptScreen, IAccessible ** ppacc, VARIANT* pvarChild);
STDAPI          CreateStdAccessibleObject(HWND hwnd, LONG idObject, REFIID riid, void** ppvObject);
STDAPI          AccessibleChildren (IAccessible* paccContainer, LONG iChildStart,LONG cChildren, VARIANT* rgvarChildren,LONG* pcObtained);

STDAPI_(UINT)   GetRoleTextA(DWORD lRole, LPSTR lpszRole, UINT cchRoleMax);
STDAPI_(UINT)   GetRoleTextW(DWORD lRole, LPWSTR lpszRole, UINT cchRoleMax);
#ifdef UNICODE
#define GetRoleText     GetRoleTextW
#else
#define GetRoleText     GetRoleTextA
#endif // UNICODE

STDAPI_(UINT)   GetStateTextA(DWORD lStateBit, LPSTR lpszState, UINT cchState);
STDAPI_(UINT)   GetStateTextW(DWORD lStateBit, LPWSTR lpszState, UINT cchState);
#ifdef UNICODE
#define GetStateText    GetStateTextW
#else
#define GetStateText    GetStateTextA
#endif // UNICODE

//=--------------------------------------------------------------------------=
// Interface Definitions
//=--------------------------------------------------------------------------=



extern RPC_IF_HANDLE __MIDL_itf_oleacc_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oleacc_0000_v0_0_s_ifspec;

#ifndef __IAccessible_INTERFACE_DEFINED__
#define __IAccessible_INTERFACE_DEFINED__

/* interface IAccessible */
/* [unique][dual][hidden][uuid][object] */ 

#define	DISPID_ACC_PARENT	( -5000 )

#define	DISPID_ACC_CHILDCOUNT	( -5001 )

#define	DISPID_ACC_CHILD	( -5002 )

#define	DISPID_ACC_NAME	( -5003 )

#define	DISPID_ACC_VALUE	( -5004 )

#define	DISPID_ACC_DESCRIPTION	( -5005 )

#define	DISPID_ACC_ROLE	( -5006 )

#define	DISPID_ACC_STATE	( -5007 )

#define	DISPID_ACC_HELP	( -5008 )

#define	DISPID_ACC_HELPTOPIC	( -5009 )

#define	DISPID_ACC_KEYBOARDSHORTCUT	( -5010 )

#define	DISPID_ACC_FOCUS	( -5011 )

#define	DISPID_ACC_SELECTION	( -5012 )

#define	DISPID_ACC_DEFAULTACTION	( -5013 )

#define	DISPID_ACC_SELECT	( -5014 )

#define	DISPID_ACC_LOCATION	( -5015 )

#define	DISPID_ACC_NAVIGATE	( -5016 )

#define	DISPID_ACC_HITTEST	( -5017 )

#define	DISPID_ACC_DODEFAULTACTION	( -5018 )

typedef /* [unique] */ IAccessible __RPC_FAR *LPACCESSIBLE;

#define	NAVDIR_MIN	( 0 )

#define	NAVDIR_UP	( 0x1 )

#define	NAVDIR_DOWN	( 0x2 )

#define	NAVDIR_LEFT	( 0x3 )

#define	NAVDIR_RIGHT	( 0x4 )

#define	NAVDIR_NEXT	( 0x5 )

#define	NAVDIR_PREVIOUS	( 0x6 )

#define	NAVDIR_FIRSTCHILD	( 0x7 )

#define	NAVDIR_LASTCHILD	( 0x8 )

#define	NAVDIR_MAX	( 0x9 )

#define	SELFLAG_NONE	( 0 )

#define	SELFLAG_TAKEFOCUS	( 0x1 )

#define	SELFLAG_TAKESELECTION	( 0x2 )

#define	SELFLAG_EXTENDSELECTION	( 0x4 )

#define	SELFLAG_ADDSELECTION	( 0x8 )

#define	SELFLAG_REMOVESELECTION	( 0x10 )

#define	SELFLAG_VALID	( 0x1f )

#define	STATE_SYSTEM_UNAVAILABLE	( 0x1 )

#define	STATE_SYSTEM_SELECTED	( 0x2 )

#define	STATE_SYSTEM_FOCUSED	( 0x4 )

#define	STATE_SYSTEM_PRESSED	( 0x8 )

#define	STATE_SYSTEM_CHECKED	( 0x10 )

#define	STATE_SYSTEM_MIXED	( 0x20 )

#define	STATE_SYSTEM_INDETERMINATE	( STATE_SYSTEM_MIXED )

#define	STATE_SYSTEM_READONLY	( 0x40 )

#define	STATE_SYSTEM_HOTTRACKED	( 0x80 )

#define	STATE_SYSTEM_DEFAULT	( 0x100 )

#define	STATE_SYSTEM_EXPANDED	( 0x200 )

#define	STATE_SYSTEM_COLLAPSED	( 0x400 )

#define	STATE_SYSTEM_BUSY	( 0x800 )

#define	STATE_SYSTEM_FLOATING	( 0x1000 )

#define	STATE_SYSTEM_MARQUEED	( 0x2000 )

#define	STATE_SYSTEM_ANIMATED	( 0x4000 )

#define	STATE_SYSTEM_INVISIBLE	( 0x8000 )

#define	STATE_SYSTEM_OFFSCREEN	( 0x10000 )

#define	STATE_SYSTEM_SIZEABLE	( 0x20000 )

#define	STATE_SYSTEM_MOVEABLE	( 0x40000 )

#define	STATE_SYSTEM_SELFVOICING	( 0x80000 )

#define	STATE_SYSTEM_FOCUSABLE	( 0x100000 )

#define	STATE_SYSTEM_SELECTABLE	( 0x200000 )

#define	STATE_SYSTEM_LINKED	( 0x400000 )

#define	STATE_SYSTEM_TRAVERSED	( 0x800000 )

#define	STATE_SYSTEM_MULTISELECTABLE	( 0x1000000 )

#define	STATE_SYSTEM_EXTSELECTABLE	( 0x2000000 )

#define	STATE_SYSTEM_ALERT_LOW	( 0x4000000 )

#define	STATE_SYSTEM_ALERT_MEDIUM	( 0x8000000 )

#define	STATE_SYSTEM_ALERT_HIGH	( 0x10000000 )

#define	STATE_SYSTEM_PROTECTED	( 0x20000000 )

#define	STATE_SYSTEM_ONLY_REDUNDANT	( 0x40000000 )

#define	STATE_SYSTEM_VALID	( 0x7fffffff )

#define	ROLE_SYSTEM_TITLEBAR	( 0x1 )

#define	ROLE_SYSTEM_MENUBAR	( 0x2 )

#define	ROLE_SYSTEM_SCROLLBAR	( 0x3 )

#define	ROLE_SYSTEM_GRIP	( 0x4 )

#define	ROLE_SYSTEM_SOUND	( 0x5 )

#define	ROLE_SYSTEM_CURSOR	( 0x6 )

#define	ROLE_SYSTEM_CARET	( 0x7 )

#define	ROLE_SYSTEM_ALERT	( 0x8 )

#define	ROLE_SYSTEM_WINDOW	( 0x9 )

#define	ROLE_SYSTEM_CLIENT	( 0xa )

#define	ROLE_SYSTEM_MENUPOPUP	( 0xb )

#define	ROLE_SYSTEM_MENUITEM	( 0xc )

#define	ROLE_SYSTEM_TOOLTIP	( 0xd )

#define	ROLE_SYSTEM_APPLICATION	( 0xe )

#define	ROLE_SYSTEM_DOCUMENT	( 0xf )

#define	ROLE_SYSTEM_PANE	( 0x10 )

#define	ROLE_SYSTEM_CHART	( 0x11 )

#define	ROLE_SYSTEM_DIALOG	( 0x12 )

#define	ROLE_SYSTEM_BORDER	( 0x13 )

#define	ROLE_SYSTEM_GROUPING	( 0x14 )

#define	ROLE_SYSTEM_SEPARATOR	( 0x15 )

#define	ROLE_SYSTEM_TOOLBAR	( 0x16 )

#define	ROLE_SYSTEM_STATUSBAR	( 0x17 )

#define	ROLE_SYSTEM_TABLE	( 0x18 )

#define	ROLE_SYSTEM_COLUMNHEADER	( 0x19 )

#define	ROLE_SYSTEM_ROWHEADER	( 0x1a )

#define	ROLE_SYSTEM_COLUMN	( 0x1b )

#define	ROLE_SYSTEM_ROW	( 0x1c )

#define	ROLE_SYSTEM_CELL	( 0x1d )

#define	ROLE_SYSTEM_LINK	( 0x1e )

#define	ROLE_SYSTEM_HELPBALLOON	( 0x1f )

#define	ROLE_SYSTEM_CHARACTER	( 0x20 )

#define	ROLE_SYSTEM_LIST	( 0x21 )

#define	ROLE_SYSTEM_LISTITEM	( 0x22 )

#define	ROLE_SYSTEM_OUTLINE	( 0x23 )

#define	ROLE_SYSTEM_OUTLINEITEM	( 0x24 )

#define	ROLE_SYSTEM_PAGETAB	( 0x25 )

#define	ROLE_SYSTEM_PROPERTYPAGE	( 0x26 )

#define	ROLE_SYSTEM_INDICATOR	( 0x27 )

#define	ROLE_SYSTEM_GRAPHIC	( 0x28 )

#define	ROLE_SYSTEM_STATICTEXT	( 0x29 )

#define	ROLE_SYSTEM_TEXT	( 0x2a )

#define	ROLE_SYSTEM_PUSHBUTTON	( 0x2b )

#define	ROLE_SYSTEM_CHECKBUTTON	( 0x2c )

#define	ROLE_SYSTEM_RADIOBUTTON	( 0x2d )

#define	ROLE_SYSTEM_COMBOBOX	( 0x2e )

#define	ROLE_SYSTEM_DROPLIST	( 0x2f )

#define	ROLE_SYSTEM_PROGRESSBAR	( 0x30 )

#define	ROLE_SYSTEM_DIAL	( 0x31 )

#define	ROLE_SYSTEM_HOTKEYFIELD	( 0x32 )

#define	ROLE_SYSTEM_SLIDER	( 0x33 )

#define	ROLE_SYSTEM_SPINBUTTON	( 0x34 )

#define	ROLE_SYSTEM_DIAGRAM	( 0x35 )

#define	ROLE_SYSTEM_ANIMATION	( 0x36 )

#define	ROLE_SYSTEM_EQUATION	( 0x37 )

#define	ROLE_SYSTEM_BUTTONDROPDOWN	( 0x38 )

#define	ROLE_SYSTEM_BUTTONMENU	( 0x39 )

#define	ROLE_SYSTEM_BUTTONDROPDOWNGRID	( 0x3a )

#define	ROLE_SYSTEM_WHITESPACE	( 0x3b )

#define	ROLE_SYSTEM_PAGETABLIST	( 0x3c )

#define	ROLE_SYSTEM_CLOCK	( 0x3d )


EXTERN_C const IID IID_IAccessible;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("618736e0-3c3d-11cf-810c-00aa00389b71")
    IAccessible : public IDispatch
    {
    public:
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accParent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispParent) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accChildCount( 
            /* [retval][out] */ long __RPC_FAR *pcountChildren) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accChild( 
            /* [in] */ VARIANT varChild,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispChild) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accName( 
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszName) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accValue( 
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszValue) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accDescription( 
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszDescription) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accRole( 
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarRole) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accState( 
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarState) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accHelp( 
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszHelp) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accHelpTopic( 
            /* [out] */ BSTR __RPC_FAR *pszHelpFile,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ long __RPC_FAR *pidTopic) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accKeyboardShortcut( 
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszKeyboardShortcut) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accFocus( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarChild) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accSelection( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarChildren) = 0;
        
        virtual /* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_accDefaultAction( 
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszDefaultAction) = 0;
        
        virtual /* [id][hidden] */ HRESULT STDMETHODCALLTYPE accSelect( 
            /* [in] */ long flagsSelect,
            /* [optional][in] */ VARIANT varChild) = 0;
        
        virtual /* [id][hidden] */ HRESULT STDMETHODCALLTYPE accLocation( 
            /* [out] */ long __RPC_FAR *pxLeft,
            /* [out] */ long __RPC_FAR *pyTop,
            /* [out] */ long __RPC_FAR *pcxWidth,
            /* [out] */ long __RPC_FAR *pcyHeight,
            /* [optional][in] */ VARIANT varChild) = 0;
        
        virtual /* [id][hidden] */ HRESULT STDMETHODCALLTYPE accNavigate( 
            /* [in] */ long navDir,
            /* [optional][in] */ VARIANT varStart,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarEndUpAt) = 0;
        
        virtual /* [id][hidden] */ HRESULT STDMETHODCALLTYPE accHitTest( 
            /* [in] */ long xLeft,
            /* [in] */ long yTop,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarChild) = 0;
        
        virtual /* [id][hidden] */ HRESULT STDMETHODCALLTYPE accDoDefaultAction( 
            /* [optional][in] */ VARIANT varChild) = 0;
        
        virtual /* [id][propput][hidden] */ HRESULT STDMETHODCALLTYPE put_accName( 
            /* [optional][in] */ VARIANT varChild,
            /* [in] */ BSTR szName) = 0;
        
        virtual /* [id][propput][hidden] */ HRESULT STDMETHODCALLTYPE put_accValue( 
            /* [optional][in] */ VARIANT varChild,
            /* [in] */ BSTR szValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAccessibleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAccessible __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAccessible __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAccessible __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IAccessible __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IAccessible __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IAccessible __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IAccessible __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accParent )( 
            IAccessible __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispParent);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accChildCount )( 
            IAccessible __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcountChildren);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accChild )( 
            IAccessible __RPC_FAR * This,
            /* [in] */ VARIANT varChild,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispChild);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accName )( 
            IAccessible __RPC_FAR * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszName);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accValue )( 
            IAccessible __RPC_FAR * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszValue);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accDescription )( 
            IAccessible __RPC_FAR * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszDescription);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accRole )( 
            IAccessible __RPC_FAR * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarRole);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accState )( 
            IAccessible __RPC_FAR * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarState);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accHelp )( 
            IAccessible __RPC_FAR * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszHelp);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accHelpTopic )( 
            IAccessible __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pszHelpFile,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ long __RPC_FAR *pidTopic);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accKeyboardShortcut )( 
            IAccessible __RPC_FAR * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszKeyboardShortcut);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accFocus )( 
            IAccessible __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarChild);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accSelection )( 
            IAccessible __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarChildren);
        
        /* [id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_accDefaultAction )( 
            IAccessible __RPC_FAR * This,
            /* [optional][in] */ VARIANT varChild,
            /* [retval][out] */ BSTR __RPC_FAR *pszDefaultAction);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *accSelect )( 
            IAccessible __RPC_FAR * This,
            /* [in] */ long flagsSelect,
            /* [optional][in] */ VARIANT varChild);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *accLocation )( 
            IAccessible __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *pxLeft,
            /* [out] */ long __RPC_FAR *pyTop,
            /* [out] */ long __RPC_FAR *pcxWidth,
            /* [out] */ long __RPC_FAR *pcyHeight,
            /* [optional][in] */ VARIANT varChild);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *accNavigate )( 
            IAccessible __RPC_FAR * This,
            /* [in] */ long navDir,
            /* [optional][in] */ VARIANT varStart,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarEndUpAt);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *accHitTest )( 
            IAccessible __RPC_FAR * This,
            /* [in] */ long xLeft,
            /* [in] */ long yTop,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarChild);
        
        /* [id][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *accDoDefaultAction )( 
            IAccessible __RPC_FAR * This,
            /* [optional][in] */ VARIANT varChild);
        
        /* [id][propput][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_accName )( 
            IAccessible __RPC_FAR * This,
            /* [optional][in] */ VARIANT varChild,
            /* [in] */ BSTR szName);
        
        /* [id][propput][hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_accValue )( 
            IAccessible __RPC_FAR * This,
            /* [optional][in] */ VARIANT varChild,
            /* [in] */ BSTR szValue);
        
        END_INTERFACE
    } IAccessibleVtbl;

    interface IAccessible
    {
        CONST_VTBL struct IAccessibleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAccessible_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAccessible_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAccessible_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAccessible_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAccessible_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAccessible_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAccessible_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAccessible_get_accParent(This,ppdispParent)	\
    (This)->lpVtbl -> get_accParent(This,ppdispParent)

#define IAccessible_get_accChildCount(This,pcountChildren)	\
    (This)->lpVtbl -> get_accChildCount(This,pcountChildren)

#define IAccessible_get_accChild(This,varChild,ppdispChild)	\
    (This)->lpVtbl -> get_accChild(This,varChild,ppdispChild)

#define IAccessible_get_accName(This,varChild,pszName)	\
    (This)->lpVtbl -> get_accName(This,varChild,pszName)

#define IAccessible_get_accValue(This,varChild,pszValue)	\
    (This)->lpVtbl -> get_accValue(This,varChild,pszValue)

#define IAccessible_get_accDescription(This,varChild,pszDescription)	\
    (This)->lpVtbl -> get_accDescription(This,varChild,pszDescription)

#define IAccessible_get_accRole(This,varChild,pvarRole)	\
    (This)->lpVtbl -> get_accRole(This,varChild,pvarRole)

#define IAccessible_get_accState(This,varChild,pvarState)	\
    (This)->lpVtbl -> get_accState(This,varChild,pvarState)

#define IAccessible_get_accHelp(This,varChild,pszHelp)	\
    (This)->lpVtbl -> get_accHelp(This,varChild,pszHelp)

#define IAccessible_get_accHelpTopic(This,pszHelpFile,varChild,pidTopic)	\
    (This)->lpVtbl -> get_accHelpTopic(This,pszHelpFile,varChild,pidTopic)

#define IAccessible_get_accKeyboardShortcut(This,varChild,pszKeyboardShortcut)	\
    (This)->lpVtbl -> get_accKeyboardShortcut(This,varChild,pszKeyboardShortcut)

#define IAccessible_get_accFocus(This,pvarChild)	\
    (This)->lpVtbl -> get_accFocus(This,pvarChild)

#define IAccessible_get_accSelection(This,pvarChildren)	\
    (This)->lpVtbl -> get_accSelection(This,pvarChildren)

#define IAccessible_get_accDefaultAction(This,varChild,pszDefaultAction)	\
    (This)->lpVtbl -> get_accDefaultAction(This,varChild,pszDefaultAction)

#define IAccessible_accSelect(This,flagsSelect,varChild)	\
    (This)->lpVtbl -> accSelect(This,flagsSelect,varChild)

#define IAccessible_accLocation(This,pxLeft,pyTop,pcxWidth,pcyHeight,varChild)	\
    (This)->lpVtbl -> accLocation(This,pxLeft,pyTop,pcxWidth,pcyHeight,varChild)

#define IAccessible_accNavigate(This,navDir,varStart,pvarEndUpAt)	\
    (This)->lpVtbl -> accNavigate(This,navDir,varStart,pvarEndUpAt)

#define IAccessible_accHitTest(This,xLeft,yTop,pvarChild)	\
    (This)->lpVtbl -> accHitTest(This,xLeft,yTop,pvarChild)

#define IAccessible_accDoDefaultAction(This,varChild)	\
    (This)->lpVtbl -> accDoDefaultAction(This,varChild)

#define IAccessible_put_accName(This,varChild,szName)	\
    (This)->lpVtbl -> put_accName(This,varChild,szName)

#define IAccessible_put_accValue(This,varChild,szValue)	\
    (This)->lpVtbl -> put_accValue(This,varChild,szValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accParent_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispParent);


void __RPC_STUB IAccessible_get_accParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accChildCount_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcountChildren);


void __RPC_STUB IAccessible_get_accChildCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accChild_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [in] */ VARIANT varChild,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispChild);


void __RPC_STUB IAccessible_get_accChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accName_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [optional][in] */ VARIANT varChild,
    /* [retval][out] */ BSTR __RPC_FAR *pszName);


void __RPC_STUB IAccessible_get_accName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accValue_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [optional][in] */ VARIANT varChild,
    /* [retval][out] */ BSTR __RPC_FAR *pszValue);


void __RPC_STUB IAccessible_get_accValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accDescription_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [optional][in] */ VARIANT varChild,
    /* [retval][out] */ BSTR __RPC_FAR *pszDescription);


void __RPC_STUB IAccessible_get_accDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accRole_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [optional][in] */ VARIANT varChild,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarRole);


void __RPC_STUB IAccessible_get_accRole_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accState_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [optional][in] */ VARIANT varChild,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarState);


void __RPC_STUB IAccessible_get_accState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accHelp_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [optional][in] */ VARIANT varChild,
    /* [retval][out] */ BSTR __RPC_FAR *pszHelp);


void __RPC_STUB IAccessible_get_accHelp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accHelpTopic_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pszHelpFile,
    /* [optional][in] */ VARIANT varChild,
    /* [retval][out] */ long __RPC_FAR *pidTopic);


void __RPC_STUB IAccessible_get_accHelpTopic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accKeyboardShortcut_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [optional][in] */ VARIANT varChild,
    /* [retval][out] */ BSTR __RPC_FAR *pszKeyboardShortcut);


void __RPC_STUB IAccessible_get_accKeyboardShortcut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accFocus_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarChild);


void __RPC_STUB IAccessible_get_accFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accSelection_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarChildren);


void __RPC_STUB IAccessible_get_accSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_get_accDefaultAction_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [optional][in] */ VARIANT varChild,
    /* [retval][out] */ BSTR __RPC_FAR *pszDefaultAction);


void __RPC_STUB IAccessible_get_accDefaultAction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_accSelect_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [in] */ long flagsSelect,
    /* [optional][in] */ VARIANT varChild);


void __RPC_STUB IAccessible_accSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_accLocation_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *pxLeft,
    /* [out] */ long __RPC_FAR *pyTop,
    /* [out] */ long __RPC_FAR *pcxWidth,
    /* [out] */ long __RPC_FAR *pcyHeight,
    /* [optional][in] */ VARIANT varChild);


void __RPC_STUB IAccessible_accLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_accNavigate_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [in] */ long navDir,
    /* [optional][in] */ VARIANT varStart,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarEndUpAt);


void __RPC_STUB IAccessible_accNavigate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_accHitTest_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [in] */ long xLeft,
    /* [in] */ long yTop,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarChild);


void __RPC_STUB IAccessible_accHitTest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_accDoDefaultAction_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [optional][in] */ VARIANT varChild);


void __RPC_STUB IAccessible_accDoDefaultAction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_put_accName_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [optional][in] */ VARIANT varChild,
    /* [in] */ BSTR szName);


void __RPC_STUB IAccessible_put_accName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput][hidden] */ HRESULT STDMETHODCALLTYPE IAccessible_put_accValue_Proxy( 
    IAccessible __RPC_FAR * This,
    /* [optional][in] */ VARIANT varChild,
    /* [in] */ BSTR szValue);


void __RPC_STUB IAccessible_put_accValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAccessible_INTERFACE_DEFINED__ */


#ifndef __IAccessibleHandler_INTERFACE_DEFINED__
#define __IAccessibleHandler_INTERFACE_DEFINED__

/* interface IAccessibleHandler */
/* [unique][oleautomation][hidden][uuid][object] */ 

typedef /* [unique] */ IAccessibleHandler __RPC_FAR *LPACCESSIBLEHANDLER;


EXTERN_C const IID IID_IAccessibleHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03022430-ABC4-11d0-BDE2-00AA001A1953")
    IAccessibleHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AccessibleObjectFromID( 
            /* [in] */ long hwnd,
            /* [in] */ long lObjectID,
            /* [out] */ LPACCESSIBLE __RPC_FAR *pIAccessible) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAccessibleHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAccessibleHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAccessibleHandler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAccessibleHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AccessibleObjectFromID )( 
            IAccessibleHandler __RPC_FAR * This,
            /* [in] */ long hwnd,
            /* [in] */ long lObjectID,
            /* [out] */ LPACCESSIBLE __RPC_FAR *pIAccessible);
        
        END_INTERFACE
    } IAccessibleHandlerVtbl;

    interface IAccessibleHandler
    {
        CONST_VTBL struct IAccessibleHandlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAccessibleHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAccessibleHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAccessibleHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAccessibleHandler_AccessibleObjectFromID(This,hwnd,lObjectID,pIAccessible)	\
    (This)->lpVtbl -> AccessibleObjectFromID(This,hwnd,lObjectID,pIAccessible)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAccessibleHandler_AccessibleObjectFromID_Proxy( 
    IAccessibleHandler __RPC_FAR * This,
    /* [in] */ long hwnd,
    /* [in] */ long lObjectID,
    /* [out] */ LPACCESSIBLE __RPC_FAR *pIAccessible);


void __RPC_STUB IAccessibleHandler_AccessibleObjectFromID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAccessibleHandler_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_oleacc_0105 */
/* [local] */ 


//=--------------------------------------------------------------------------=
// Type Library Definitions
//=--------------------------------------------------------------------------=



extern RPC_IF_HANDLE __MIDL_itf_oleacc_0105_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oleacc_0105_v0_0_s_ifspec;


#ifndef __Accessibility_LIBRARY_DEFINED__
#define __Accessibility_LIBRARY_DEFINED__

/* library Accessibility */
/* [hidden][version][lcid][uuid] */ 




EXTERN_C const IID LIBID_Accessibility;
#endif /* __Accessibility_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\scrptlet.h ===
#ifndef SCRPTLET_H
#define SCRPTLET_H


// If an error is reported successfully using IScriptletSite, then this
// error code is propagated up the call stack.
#define E_REPORTED	0x80004100L

DEFINE_GUID(CLSID_ScriptletConstructor, 0x21617250, 0xa071, 0x11d1, 0x89, 0xb6, 0x0, 0x60, 0x8, 0xc3, 0xfb, 0xfc);
DEFINE_GUID(SID_ScriptletSite, 0x22a98050, 0xa65d, 0x11d1, 0x89, 0xbe, 0x0, 0x60, 0x8, 0xc3, 0xfb, 0xfc);


/***************************************************************************
	IScriptletConstructor
	
	We need to move these definitions into an idl so we can generate the
	appropriate proxy/stub code.
***************************************************************************/
DEFINE_GUID(IID_IScriptletConstructor, 0xc265fb00, 0x9fa4, 0x11d1, 0x89, 0xb6, 0x0, 0x60, 0x8, 0xc3, 0xfb, 0xfc);
interface IScriptletConstructor : public IUnknown
	{
	STDMETHOD(Load)(LPCOLESTR pstrSource) PURE;
	STDMETHOD(Create)(LPCOLESTR pstrId, IUnknown *punkContext,
			IUnknown *punkOuter, REFIID riid, void **ppv) PURE;
	STDMETHOD(Register)(LPCOLESTR pstrSourceFileName) PURE;
	STDMETHOD(Unregister)(void) PURE;
	STDMETHOD(AddCoclassTypeInfo)(ICreateTypeLib *ptclib) PURE;
	STDMETHOD(IsDefined)(LPCOLESTR pstrId) PURE;
	};


/***************************************************************************
	IScriptletError
***************************************************************************/
DEFINE_GUID(IID_IScriptletError, 0xdf9f3d20, 0xa670, 0x11d1, 0x89, 0xbe, 0x0, 0x60, 0x8, 0xc3, 0xfb, 0xfc);
interface IScriptletError : public IUnknown
    {
	STDMETHOD(GetExceptionInfo)(EXCEPINFO *pexcepinfo) PURE;
	STDMETHOD(GetSourcePosition)(ULONG *pline, ULONG *pcolumn) PURE;
	STDMETHOD(GetSourceLineText)(BSTR *pbstrSourceLine) PURE;
	};


/***************************************************************************
	IScriptletSite
	
	In addition to the dispids defined below, the site may also choose to 
	handle the follwing dispids.
		DISPID_ERROREVENT
		DISPID_AMBIENT_LOCALEID
***************************************************************************/
#define DISPID_SCRIPTLET_ALLOWDEBUG		1

DEFINE_GUID(IID_IScriptletSite, 0xc5f21c30, 0xa7df, 0x11d1, 0x89, 0xbe, 0x0, 0x60, 0x8, 0xc3, 0xfb, 0xfc);
interface IScriptletSite : public IUnknown
	{
	STDMETHOD(OnEvent)(DISPID dispid, int cArg, VARIANT *prgvarArg,
			VARIANT *pvarRes) PURE;
	STDMETHOD(GetProperty)(DISPID dispid, VARIANT *pvarRes) PURE;
	};


		
#endif // SCRPTLET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\shlwrap.h ===
#ifndef I_SHLWRAP_H_
#define I_SHLWRAP_H_

#if defined(_M_IX86) && !defined(WINCE)

#define UNICODE_SHDOCVW
#define POST_IE5_BETA

#ifndef X_W95WRAPS_H_
#define X_W95WRAPS_H_
#include <w95wraps.h>
#endif

// Trident doesn't want certain system functions wrapped

#undef TextOutW
#undef ExtTextOutW

#else

// Manually enable wrapping for certain APIs

// (JBEDA, via DINARTEM)  We may want to take this ifdef out entirely so
// that we always use shlwapi on AMD64/ia64

#define ShellExecuteExW             ShellExecuteExWrapW

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\breakrec.h ===
#ifndef BREAKREC_DEFINED
#define BREAKREC_DEFINED

#include "lsdefs.h"

/* ---------------------------------------------------------------------- */

struct breakrec
{
	DWORD idobj;
	LSCP cpFirst;
};

typedef struct breakrec BREAKREC;

#endif /* !BREAKREC_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\brkcond.h ===
#ifndef BRKCOND_DEFINED
#define BRKCOND_DEFINED

#include "lsdefs.h"

typedef enum
{
	brkcondPlease,
	brkcondCan,
	brkcondNever
} BRKCOND;


#endif /* !BRKCOND_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\brko.h ===
#ifndef BRKO_DEFINED
#define BRKO_DEFINED

#include "lsdefs.h"
#include "pbrko.h"
#include "objdim.h"
#include "posichnk.h"
#include "brkcond.h"

typedef struct brkout						/* break output */ 
{
	BOOL fSuccessful;						/* break result */
	BRKCOND brkcond;						/* iff !fSuccessful, recommendation on the other side */
	POSICHNK posichnk;
	OBJDIM objdim;
} BRKOUT;


#endif /* !BRKO_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\brkcls.h ===
#ifndef BRKCLS_DEFINED
#define BRKCLS_DEFINED

#include "lsdefs.h"

typedef DWORD BRKCLS;

#endif /* !BRKCLS_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\brkpos.h ===
#ifndef BRKPOS_DEFINED
#define BRKPOS_DEFINED

#include "lsdefs.h"

typedef enum
{
	brkposBeforeFirstDnode,
	brkposInside,
	brkposAfterLastDnode

} BRKPOS;


#endif /* !BRKPOS_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\brkkind.h ===
#ifndef BRKKIND_DEFINED
#define BRKKIND_DEFINED

#include "lsdefs.h"

typedef enum
{
	brkkindImposedAfter,
	brkkindPrev,
	brkkindNext,
	brkkindForce

} BRKKIND;


#endif /* !BRKKIND_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\dispi.h ===
#ifndef DISPI_DEFINED
#define DISPI_DEFINED

#include "lsdefs.h"
#include "pdispi.h"
#include "plsrun.h"
#include "plschp.h"
#include "heights.h"
#include "lstflow.h"

typedef struct dispin
{
	POINT 	ptPen;					/* starting pen position (x,y) */
	PCLSCHP plschp;					/* CHP for this display object */
	PLSRUN 	plsrun;					/* client pointer to run */

	UINT 	kDispMode;				/* display mode, opaque, etc */
	LSTFLOW lstflow;	 			/* text direction and orientation */
	RECT* 	prcClip;				/* clip rectangle (x,y) */

	BOOL 	fDrawUnderline;			/* Draw underline while displaying */
	BOOL 	fDrawStrikethrough;		/* Draw strikethrough while Displaying */

	HEIGHTS heightsPres;
	long 	dup;
	long	dupLimUnderline;		/* less than dup if trailing spaces */
} DISPIN;	

#endif /* !DISPI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\endres.h ===
#ifndef ENDRES_DEFINED
#define ENDRES_DEFINED

enum endres
{
	endrNormal,
	endrHyphenated,
	endrEndPara,
	endrAltEndPara,
	endrSoftCR,
	endrEndColumn,
	endrEndSection,
	endrEndPage,
	endrEndParaSection,
	endrStopped
};

typedef enum endres ENDRES;

#endif /* ENDRES_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\exptype.h ===
#ifndef EXPTYPE_DEFINED
#define EXPTYPE_DEFINED

#include "lsdefs.h"

typedef BYTE EXPTYPE;

/* kinds of glyph expansion */
#define	exptNone  0
#define	exptAddWhiteSpace 1
#define	exptAddInkContinuous 2
#define	exptAddInkDiscrete 3

typedef EXPTYPE* PEXPTYPE;
typedef const EXPTYPE* PCEXPTYPE;


#endif /* !EXPTYPE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\fmti.h ===
#ifndef FMTIO_DEFINED
#define FMTIO_DEFINED

#include "lsdefs.h"
#include "pfmti.h"
#include "plsdnode.h"
#include "lsfgi.h"
#include "lsfrun.h"
#include "lstxm.h"

/* ------------------------------------------------------------------------ */

struct fmtin
{
	LSFGI lsfgi;
	LSFRUN lsfrun;
	PLSDNODE plsdnTop;
	LSTXM lstxmPres;
	LSTXM lstxmRef;
};

/* ------------------------------------------------------------------------ */


#endif /* !FMTIO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\gmap.h ===
#ifndef GMAP_DEFINED
#define GMAP_DEFINED

#include "lsdefs.h"

typedef WORD GMAP;
typedef GMAP* PGMAP;
typedef const GMAP* PCGMAP;

#endif /* !GMAP_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\heights.h ===
#ifndef HEIGHTS_DEFINED
#define HEIGHTS_DEFINED

#include "lsdefs.h"
#include "pheights.h"

#define dvHeightIgnore 0x7FFFFFFF

typedef struct heights
{
	long dvAscent;
	long dvDescent;
	long dvMultiLineHeight;
} HEIGHTS;

#endif /* !HEIGHTS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\gprop.h ===
#ifndef GPROP_DEFINED
#define GPROP_DEFINED

#include "lsdefs.h"

typedef WORD GPROP;
typedef GPROP* PGPROP;
typedef const GPROP* PCGPROP;

#endif /* !GPROPS_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\fmtres.h ===
#ifndef FMTRES_DEFINED
#define FMTRES_DEFINED

/* used in fmtio.h and lsfd.h */

enum fmtres							/* Why did the formatter return? */
{
	fmtrCompletedRun,				/* no problems */
	fmtrExceededMargin,				/* reached right margin */
	fmtrTab,						/* reached tab				  */
	fmtrStopped						
};

typedef enum fmtres FMTRES;

#endif /* !FMTRES_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\locchnk.h ===
#ifndef LOCCHNK_DEFINED
#define LOCCHNK_DEFINED

#include "lsdefs.h"
#include "lsfgi.h"
#include "lschnke.h"

typedef struct locchnk					/* located chnk					*/
{
	LSFGI lsfgi;						/* location of chunk			*/
	DWORD clschnk;						/* number of dobj's in chunk	*/
	PLSCHNK plschnk;					/* chunk 						*/
	PPOINTUV ppointUvLoc;				/* location of each chunk's node*/
} LOCCHNK;



#endif /* !LOCCHNK_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsact.h ===
#ifndef LSACT_DEFINED
#define LSACT_DEFINED

#include "lsdefs.h"
#include "kamount.h"

#define sideNone				0		/* means no action				*/
#define sideLeft				1
#define sideRight				2
#define sideLeftRight			3		/* Review(segeyge): how to distribute?*/

typedef struct lsact					/* action							*/
{
	BYTE side;							/* side of action (left/right/both)	*/
	KAMOUNT kamnt;						/* amount of action					*/
} LSACT;


#endif /* !LSACT_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\kamount.h ===
#ifndef KAMOUNT_DEFINED
#define KAMOUNT_DEFINED

#include "lsdefs.h"
/* Interpretation for kamnBy... is as follows:
	Compression			-
	Expansion			+
	PunctStartLine   	-
	ModWidthPairs		-
	ModWidthSpace		+
	ModWidthOnRun		+
*/


typedef BYTE KAMOUNT;

#define kamntNone				0
#define kamntToHalfEm			1
#define kamntToQuarterEm		2
#define kamntToThirdEm			3
#define kamntTo15Sixteenth		4
#define kamntByHalfEm			5
#define kamntByQuarterEm		6
#define kamntByEighthEm			7
#define kamntByUserDefinedExpan	8	
#define kamntByUserDefinedComp	9	
#define kamntToUserDefinedExpan	10	
#define kamntToUserDefinedComp	11	


#endif /* !KAMOUNT_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\hih.h ===
#ifndef HIH_DEFINED
#define HIH_DEFINED

#include "lsimeth.h"

/*
 *	H(orizontal)I(n)H(orizontal)
 *
 *	This object is designed to help client implementations which use 
 *	Tatenakayoko and wish to be able to convert the display from vertical
 *	to horizontal and then to display the Tatenakayoko text as horizontal.
 *	To do this the client application simply changes the object handler
 *	from the Tatenakayoko handler to this object handler and the text
 *	will be displayed horizontally.
 *	
 */

/* typedef for callback to client for enumeration */
typedef LSERR(WINAPI * PFNHIHENUM)(
	POLS pols,				/*(IN): client context */
	PLSRUN plsrun,			/*(IN): from DNODE */
	PCLSCHP plschp,			/*(IN): from DNODE */
	LSCP cp,				/*(IN): from DNODE */
	LSDCP dcp,				/*(IN): from DNODE */
	LSTFLOW lstflow,		/*(IN): text flow*/
	BOOL fReverse,			/*(IN): enumerate in reverse order */
	BOOL fGeometryNeeded,	/*(IN): */
	const POINT* pt,		/*(IN): starting position (top left), iff fGeometryNeeded */
	PCHEIGHTS pcheights,	/*(IN): from DNODE, relevant iff fGeometryNeeded */
	long dupRun,			/*(IN): from DNODE, relevant iff fGeometryNeeded*/
	PLSSUBL plssubl);		/*(IN): subline in hih object. */

/*
 *
 *	HIH object initialization data that the client application must return
 *	when the HIH object handler calls the GetObjectHandlerInfo callback.
 */

#define HIH_VERSION 0x300

typedef struct HIHINIT
{
	DWORD				dwVersion;		/* Version. Must be HIH_VERSION */
	WCHAR				wchEndHih;		/* Escape for end of HIH object */
	WCHAR				wchUnused1;
	WCHAR				wchUnused2;
	WCHAR				wchUnused3;
	PFNHIHENUM			pfnEnum;		/* Enumeration callback */
} HIHINIT, *PHIHINIT;

LSERR WINAPI LsGetHihLsimethods(
	LSIMETHODS *plsim);

/* GetHihLsimethods
 *	
 *	plsim (OUT): Hih object methods for Line Services
 *
 */

#endif /* HIH_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsbrjust.h ===
#ifndef LSBRJUST_DEFINED
#define LSBRJUST_DEFINED

enum lsbreakjust							/* kinds of breaking/justification */
{
	lsbrjBreakJustify,						/* Regular US */
	lsbrjBreakWithCompJustify,				/* FE & Newspaper */
	lsbrjBreakThenExpand,					/* Arabic			 */
	lsbrjBreakThenSqueeze					/* Word Perfect			 */
};

typedef enum lsbreakjust LSBREAKJUST;

#endif /* !LSBRJUST_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lscell.h ===
#ifndef LSCELL_DEFINED
#define LSCELL_DEFINED

#include "lsdefs.h"
#include "plscell.h"
#include "pcelldet.h"
#include "plscell.h"

struct lstextcell
{
	LSCP cpStartCell;
	LSCP cpEndCell;
 	POINTUV pointUvStartCell;		/* In coordinate system of main line/subline */
	long dupCell;					/* In direction lstflowSubline			*/

	DWORD cCharsInCell;
	DWORD cGlyphsInCell;

	PCELLDETAILS pCellDetails;

};

typedef struct lstextcell LSTEXTCELL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsbrk.h ===
#ifndef LSBRK_DEFINED
#define LSBRK_DEFINED

#include "lsdefs.h"

typedef struct lsbrk					/* breaking information unit		*/
{
	BYTE fBreak;						/* break for neibours	*/
	BYTE fBreakAcrossSpaces;			/* break across spaces	*/
} LSBRK;									


#endif /* !LSBRK_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lschnke.h ===
#ifndef LSCHNKE_DEFINED
#define LSCHNKE_DEFINED

#include "lsdefs.h"
#include "plschp.h"
#include "plsrun.h"
#include "pdobj.h"

typedef struct lschnke
{
	LSCP cpFirst;
	LSDCP dcp;
	PCLSCHP plschp;
	PLSRUN plsrun;
	PDOBJ pdobj;
} LSCHNKE;

typedef LSCHNKE* PLSCHNK;
typedef const LSCHNKE* PCLSCHNK;

#endif  /* !LSCHNKE_DEFINED   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lschp.h ===
#ifndef LSCHP_DEFINED
#define LSCHP_DEFINED

#include "lsdefs.h"
#include "plschp.h"

#define idObjTextChp	((WORD)~0)		/* idObj for FetchRun to use  */
										/*  when returning a text run */
										/*  (Internal id will differ.) */

/* LS expects that for GlyphBased runs the following flags are set to FALSE:
			fApplyKern
			fModWidthSpace
			fModWidthPairs
			fCompressTable
*/

struct lschp							/* Character properties */
{
	WORD idObj;							/* Object type */
	BYTE dcpMaxContext;

	BYTE EffectsFlags;

    /* Property flags */
	UINT fApplyKern : 1;
	UINT fModWidthOnRun:1;
	UINT fModWidthSpace:1;
	UINT fModWidthPairs:1;
	UINT fCompressOnRun:1;
	UINT fCompressSpace:1;
	UINT fCompressTable:1;
	UINT fExpandOnRun:1;
	UINT fExpandSpace:1;
	UINT fExpandTable:1;
	UINT fGlyphBased : 1;

	UINT pad1:5;

	UINT fInvisible : 1;
	UINT fUnderline : 1;				
	UINT fStrike : 1;
	UINT fShade : 1;				
	UINT fBorder : 1;				
	UINT fHyphen : 1;					/* Hyphenation opportunity (YSR info) */
	UINT fCheckForReplaceChar : 1;		/* Activate the replace char mechanizm for Yen	*/

	UINT pad2:9;
										/* for dvpPos values, */
										/*  pos => raised, neg => lowered, */
	long dvpPos;
};

typedef struct lschp LSCHP;

#endif /* !LSCHP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lscbk.h ===
#ifndef LSCBK_DEFINED
#define LSCBK_DEFINED

/* LineServices callbacks */

#include "lsdefs.h"
#include "lsdevice.h"
#include "lsksplat.h"
#include "lskjust.h"
#include "lstflow.h"
#include "endres.h"
#include "mwcls.h"
#include "lsact.h"
#include "lspract.h"
#include "brkcond.h"
#include "brkcls.h"
#include "gprop.h"
#include "gmap.h"
#include "lsexpinf.h"
#include "lskalign.h"
#include "plstabs.h"
#include "pheights.h"
#include "plsrun.h"
#include "plscbk.h"
#include "plschp.h"
#include "plspap.h"
#include "plstxm.h"
#include "plshyph.h"
#include "plsstinf.h"
#include "plsulinf.h"
#include "plsems.h"

#define cpFirstAnm (-0x7FFFFFFF)   /* Used for the fetch of the first Autonumber run */


struct lscbk	/* Interfaces to application-specific callbacks */
{
	/* Dynamic memory APIs */
	void* (WINAPI* pfnNewPtr)(POLS, DWORD);
	void  (WINAPI* pfnDisposePtr)(POLS, void*);
	void* (WINAPI* pfnReallocPtr)(POLS, void*, DWORD);


	LSERR (WINAPI* pfnFetchRun)(POLS, LSCP,
							    LPCWSTR*, DWORD*, BOOL*, PLSCHP, PLSRUN*);
	/* FetchRun:
	 *  pols (IN):
	 *  cp (IN):
	 *  &lpwchRun (OUT): run of characters.
	 *  &cchRun (OUT): number of characters in run
	 *  &fHidden (OUT) : hidden run?
	 *  &lsChp (OUT): char properties of run 
	 *  &plsrun (OUT): abstract representation of run properties
	 */

	LSERR (WINAPI* pfnGetAutoNumberInfo)(POLS, LSKALIGN*, PLSCHP, PLSRUN*, WCHAR*, PLSCHP, PLSRUN*, BOOL*, long*, long*);

	/* GetAutoNumberInfo:
	 *  pols (IN):
	 *  &lskalAnm (OUT):
	 *  &lschpAnm (OUT): lschp for Anm
	 *  &plsrunAnm (OUT): plsrun for Anm
	 *  &wchAdd (OUT): character to add (Nil is treated as none)
	 *  &lschpWch (OUT): lschp for added char
	 *  &plsrunWch (OUT): plsrun for added char
	 *  &fWord95Model(OUT):
	 *  &duaSpaceAnm(OUT):	relevant iff fWord95Model
	 *  &duaWidthAnm(OUT):	relevant iff fWord95Model
	 */

	LSERR (WINAPI* pfnGetNumericSeparators)(POLS, PLSRUN, WCHAR*,WCHAR*);
	/* GetNumericSeparators:
	 *  pols (IN):
	 *  plsrun (IN): run pointer as returned from FetchRun
	 *  &wchDecimal (OUT): decimal separator for this run.
	 *  &wchThousands (OUT): thousands separator for this run
	 */

	LSERR (WINAPI* pfnCheckForDigit)(POLS, PLSRUN, WCHAR, BOOL*);
	/* GetNumericSeparators:
	 *  pols (IN):
	 *  plsrun (IN): run pointer as returned from FetchRun
	 *  wch (IN): character to check
	 *  &fIsDigit (OUT): this character is digit
	 */

	LSERR (WINAPI* pfnFetchPap)(POLS, LSCP, PLSPAP);
	/* FetchPap:
	 *  pols (IN):
	 *  cp (IN): an arbitrary cp value inside the paragraph
	 *  &lsPap (OUT): Paragraph properties.
	 */

	LSERR (WINAPI* pfnFetchTabs)(POLS, LSCP, PLSTABS, BOOL*, long*, WCHAR*);
	/* FetchTabs:
	 *  pols (IN):
	 *  cp (IN): an arbitrary cp value inside the paragraph
	 *  &lstabs (OUT): tabs array
	 *  &fHangingTab (OUT): there is hanging tab
	 *  &duaHangingTab (OUT): dua of hanging tab
	 *  &wchHangingTabLeader (OUT): leader of hanging tab
	 */

	LSERR (WINAPI* pfnGetBreakThroughTab)(POLS, long, long, long*);
	/* GetBreakThroughTab:
	 *  pols (IN):
	 *  uaRightMargin (IN): right margin for breaking
	 *  uaTabPos (IN): breakthrough tab position
	 *  uaRightMarginNew (OUT): new right margin
	 */

	LSERR (WINAPI* pfnFGetLastLineJustification)(POLS, LSKJUST, LSKALIGN, ENDRES, BOOL*, LSKALIGN*);
	/* FGetLastLineJustification:
	 *  pols (IN):
	 *  lskj (IN): kind of justification for the paragraph
	 *  lskal (IN): kind of alignment for the paragraph
	 *  endr (IN): result of formatting
	 *  &fJustifyLastLine (OUT): should last line be fully justified
	 *  &lskalLine (OUT): kind of alignment for this line
	 */

	LSERR (WINAPI* pfnCheckParaBoundaries)(POLS, LSCP, LSCP, BOOL*);
	/* CheckParaBoundaries:
	 *  pols (IN):
	 *  cpOld (IN):
	 *  cpNew (IN):
	 *  &fChanged (OUT): "Dangerous" change between paragraph properties.
	 */

	LSERR (WINAPI* pfnGetRunCharWidths)(POLS, PLSRUN, 
									 	LSDEVICE, LPCWSTR,
										DWORD, long, LSTFLOW,
										int*,long*,long*);
	/* GetRunCharWidths:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  lsDeviceID (IN): presentation or reference
	 *  lpwchRun (IN): run of characters
	 *  cwchRun (IN): number of characters in run
	 *  du (IN): available space for characters
	 *  kTFlow (IN): text direction and orientation
	 *  rgDu (OUT): widths of characters
	 *  &duRun (OUT): sum of widths in rgDx[0] to rgDu[limDx-1]
	 *  &limDu (OUT): number of widths fetched
	 */

	LSERR (WINAPI* pfnCheckRunKernability)(POLS, PLSRUN,PLSRUN, BOOL*);
	/* CheckRunKernability:
	 *  pols (IN):
	 *  plsrunLeft (IN): 1st of pair of adjacent runs
	 *  plsrunRight (IN): 2nd of pair of adjacent runs
	 *  &fKernable (OUT) : if TRUE, Line Service may kern between these runs
	 */

	LSERR (WINAPI* pfnGetRunCharKerning)(POLS, PLSRUN,
										 LSDEVICE, LPCWSTR,
										 DWORD, LSTFLOW, int*);
	/* GetRunCharKerning:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  lsDeviceID (IN): presentation or reference
	 *  lpwchRun (IN): run of characters
	 *  cwchRun (IN): number of characters in run
	 *  kTFlow (IN): text direction and orientation
	 *  rgDu (OUT): widths of characters
	 */

	LSERR (WINAPI* pfnGetRunTextMetrics)(POLS, PLSRUN,
										 LSDEVICE, LSTFLOW, PLSTXM);
	/* GetRunTextMetrics:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  deviceID (IN):  presentation, reference, or absolute
	 *  kTFlow (IN): text direction and orientation
	 *  &lsTxMet (OUT): Text metrics
	 */

	LSERR (WINAPI* pfnGetRunUnderlineInfo)(POLS, PLSRUN, PCHEIGHTS, LSTFLOW,
										   PLSULINFO);
	/* GetRunUnderlineInfo:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  heightsPres (IN):
	 *  kTFlow (IN): text direction and orientation
	 *  &lsUlInfo (OUT): Underline information
	 */

	LSERR (WINAPI* pfnGetRunStrikethroughInfo)(POLS, PLSRUN, PCHEIGHTS, LSTFLOW,
											  PLSSTINFO);
	/* GetRunStrikethroughInfo:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  heightsPres (IN):
	 *  kTFlow (IN): text direction and orientation
	 *  &lsStInfo (OUT): Strikethrough information
	 */

	LSERR (WINAPI* pfnGetBorderInfo)(POLS, PLSRUN, LSTFLOW, long*, long*);
	/* GetBorderInfo:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  kTFlow (IN): text direction and orientation
	 *  &durBorder (OUT): Width of the border on the reference device
	 *  &dupBorder (OUT): Width of the border on the presentation device
	 */


	LSERR (WINAPI* pfnReleaseRun)(POLS, PLSRUN);
	/* ReleaseRun:
	 *  pols (IN):
	 *  plsrun (IN): run to be released, from GetRun() or FetchRun()
	 */

	LSERR (WINAPI* pfnHyphenate)(POLS, PCLSHYPH, LSCP, LSCP, PLSHYPH);
	/* Hyphenate:
	 *  pols (IN):
	 *  &lsHyphLast (IN): last hyphenation found. kysr==kysrNil means "none"
	 *  cpBeginWord (IN): 1st cp in word which exceeds column
	 *  cpExceed (IN): 1st which exceeds column, in this word
	 *  &lsHyph (OUT): hyphenation results. kysr==kysrNil means "none"
	 */

	LSERR (WINAPI* pfnGetHyphenInfo)(POLS, PLSRUN, DWORD*, WCHAR*);
	/* GetHyphenInfo:
	 *  pols (IN):
	 *  plsrun (IN):
     *  kysr (OUT)	  Ysr type - see "lskysr.h"
     *  wchYsr (OUT)  Character code of YSR
	*/

	LSERR (WINAPI* pfnDrawUnderline)(POLS, PLSRUN, UINT,
								const POINT*, DWORD, DWORD, LSTFLOW,
								UINT, const RECT*);
	/* DrawUnderline:
	 *  pols (IN):
	 *  plsrun (IN): run to use for the underlining
	 *  kUlbase (IN): underline kind 
	 *  pptStart (IN): starting position (top left)
	 *  dupUL (IN): underline width
	 *  dvpUL (IN) : underline thickness
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN) : display mode - opaque, transparent
	 *  prcClip (IN) : clipping rectangle
	 */

	LSERR (WINAPI* pfnDrawStrikethrough)(POLS, PLSRUN, UINT,
								const POINT*, DWORD, DWORD, LSTFLOW,
								UINT, const RECT*);
	/* DrawStrikethrough:
	 *  pols (IN):
	 *  plsrun (IN): the run for the strikethrough
	 *  kStbase (IN): strikethrough kind 
	 *  pptStart (IN): starting position (top left)
	 *  dupSt (IN): strikethrough width
	 *  dvpSt (IN) : strikethrough thickness
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN) : display mode - opaque, transparent
	 *  prcClip (IN) : clipping rectangle
	 */

	LSERR (WINAPI* pfnDrawBorder)(POLS, PLSRUN, const POINT*, PCHEIGHTS, PCHEIGHTS,
								  PCHEIGHTS, PCHEIGHTS, long, long, LSTFLOW, UINT, const RECT*);

	/* DrawBorder:
	 *  pols (IN):
	 *  plsrun (IN): plsrun of the first bordered run
	 *  pptStart (IN): starting point for the border
	 *  pheightsLineFull (IN): height of the line including SpaceBefore & SpaceAfter
	 *  pheightsLineWithoutAddedSpace (IN): height of the line without SpaceBefore & SpaceAfter
	 *  pheightsSubline (IN): height of subline
	 *  pheightsRuns (IN): height of collected runs to be bordered
	 *  dupBorder (IN): width of one border
	 *  dupRunsInclBorders (IN): width of collected runs
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN) : display mode - opaque, transparent
	 *  prcClip (IN) : clipping rectangle
	 */

	LSERR (WINAPI* pfnDrawUnderlineAsText)(POLS, PLSRUN, const POINT*,
										   long, LSTFLOW, UINT, const RECT*);
	/* DrawUnderlineAsText:
	 *  pols (IN):
	 *  plsrun (IN): run to use for the underlining
	 *  pptStart (IN): starting pen position
	 *  dupLine (IN): length of UL
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN) : display mode - opaque, transparent
	 *  prcClip (IN) : clipping rectangle
	 */

	LSERR (WINAPI* pfnFInterruptUnderline)(POLS, PLSRUN, LSCP, PLSRUN, LSCP,BOOL*);
	/* FInterruptUnderline:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the previous run
	 *  cpLastFirst (IN): cp of the last character of the previous run
	 *  plsrunSecond (IN): run pointer for the current run
	 *  cpStartSecond (IN): cp of the first character of the current run
	 *  &fInterruptUnderline (OUT): do you want to interrupt drawing of the underline between these runs
	 */

	LSERR (WINAPI* pfnFInterruptShade)(POLS, PLSRUN, PLSRUN, BOOL*);
	/* FInterruptShade:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the previous run
	 *  plsrunSecond (IN): run pointer for the current run
	 *  &fInterruptShade (OUT): do you want to interrupt shading between these runs
	 */

	LSERR (WINAPI* pfnFInterruptBorder)(POLS, PLSRUN, PLSRUN, BOOL*);
	/* FInterruptBorder:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the previous run
	 *  plsrunSecond (IN): run pointer for the current run
	 *  &fInterruptBorder (OUT): do you want to interrupt border between these runs
	 */


	LSERR (WINAPI* pfnShadeRectangle)(POLS, PLSRUN, const POINT*, PCHEIGHTS, PCHEIGHTS,
								  PCHEIGHTS, PCHEIGHTS, PCHEIGHTS, long, long, LSTFLOW, UINT, const RECT*);

	/* ShadeRectangle:
	 *  pols (IN):
	 *  plsrun (IN): plsrun of the first shaded run
	 *  pptStart (IN): starting point for the shading rectangle
	 *  pheightsLineWithAddSpace(IN): height of the line including SpaceBefore & SpaceAfter (main baseline, 
	 *						lstflow of main line)
	 *  pheightsLineWithoutAddedSpace (IN): height of the line without SpaceBefore & SpaceAfter
	 *  pheightsSubline (IN): height of subline (local baseline, lstflow of subline)
	 *  pheightsRunsExclTrail (IN): height of collected runs to be shaded excluding 
	 *									trailing spaces area (local baseline, lstflow of subline)
	 *  pheightsRunsInclTrail (IN): height of collected runs to be shaded including
	 *									trailing spaces area (local baseline, lstflow of subline)
	 *  dupRunsExclTrail (IN): width of collected runs excluding trailing spaces area
	 *  dupRunsInclTrail (IN): width of collected runs including trailing spaces area
	 *  kTFlow (IN): text direction and orientation of subline
	 *  kDisp (IN) : display mode - opaque, transparent
	 *  prcClip (IN) : clipping rectangle
	 */

	LSERR (WINAPI* pfnDrawTextRun)(POLS, PLSRUN, BOOL, BOOL, 
								   const POINT*, LPCWSTR, const int*, DWORD, 
								   LSTFLOW, UINT, const POINT*, PCHEIGHTS, long, long, const RECT*);
	/* DrawTextRun:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  fStrikeout (IN) :
	 *  fUnderline (IN) :
	 *  pptText (IN): starting point for the text output
	 *  lpwchRun (IN): run of characters
	 *  rgDupRun (IN): widths of characters
	 *  cwchRun (IN): number of characters in run
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN): display mode - opaque, transparent
	 *  pptRun (IN): starting point of the run
	 *  heightsPres (IN): presentation heights for this run
	 *  dupRun (IN): presentation width for this run
	 *  dupLimUnderline (IN): underlining limit
	 *  pRectClip (IN): clipping rectangle
	 */

    LSERR (WINAPI* pfnDrawSplatLine)(POLS, enum lsksplat, LSCP, const POINT*,
									 PCHEIGHTS, PCHEIGHTS, PCHEIGHTS, long, LSTFLOW,
									 UINT, const RECT*);
	/* DrawSplatLine:
	 *  pols (IN):
	 *  ksplat (IN): See definitions in lsksplat.h
	 *  cpSplat (IN): location of the break character which caused the splat.
	 *  pptSplatLine (IN) : starting position of the splat line
	 *  pheightsLineFull (IN): height of the line including SpaceBefore & SpaceAfter
	 *  pheightsLineWithoutAddedSpace (IN): height of the line without SpaceBefore & SpaceAfter
	 *  pheightsSubline (IN): height of subline
	 *  dup (IN): distance to right margin
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN): display mode - opaque, transparent
	 *  &rcClip (IN) : clipping rectangle
	 */


/* Advanced typography enabling API's */

	/* Glyph enabling */

	LSERR (WINAPI* pfnFInterruptShaping)(POLS, LSTFLOW, PLSRUN, PLSRUN, BOOL*);
	/* FInterruptShaping:
	 *  pols (IN):
	 *  kTFlow (IN): text direction and orientation
	 *  plsrunFirst (IN): run pointer for the previous run
	 *  plsrunSecond (IN): run pointer for the current run
	 *  &fInterruptShaping (OUT): do you want to interrupt character shaping between these runs
	*/

	LSERR (WINAPI* pfnGetGlyphs)(POLS, PLSRUN, LPCWSTR, DWORD, LSTFLOW, PGMAP, PGINDEX*, PGPROP*, DWORD*);
	/* GetGlyphs:
	 *  pols (IN):
	 *  plsrun (IN): run pointer of the first run
	 *  pwch (IN): pointer to the string of character codes
	 *  cwch (IN): number of characters to be shaped
	 *  kTFlow (IN): text direction and orientation
	 *  rgGmap (OUT): parallel to the char codes mapping wch->glyph info
	 *  &rgGindex (OUT): array of output glyph indices
	 *  &rgGprop (OUT): array of output glyph properties
	 *  &cgindex (OUT): number of output glyph indices
	 */

	LSERR (WINAPI* pfnGetGlyphPositions)(POLS, PLSRUN, LSDEVICE, LPWSTR, PCGMAP, DWORD,
											PCGINDEX, PCGPROP, DWORD, LSTFLOW, int*, PGOFFSET);
	/* GetGlyphPositions:
	 *  pols (IN):
	 *  plsrun (IN): run pointer of the first run
	 *  lsDeviceID (IN): presentation or reference
	 *  pwch (IN): pointer to the string of character codes
	 *  pgmap (IN): array of wch->glyph mapping
	 *  cwch (IN): number of characters to be shaped
	 *  rgGindex (IN): array of glyph indices
	 *  rgGprop (IN): array of glyph properties
	 *  cgindex (IN): number glyph indices
	 *  kTFlow (IN): text direction and orientation
	 *  rgDu (OUT): array of widths of glyphs
	 *  rgGoffset (OUT): array of offsets of glyphs
	 */

	LSERR (WINAPI* pfnResetRunContents)(POLS, PLSRUN, LSCP, LSDCP, LSCP, LSDCP);
	/* ResetRunContents:
	 *  pols (IN):
	 *  plsrun (IN): run pointer as returned from FetchRun
	 *  cpFirstOld (IN): cpFirst before shaping
	 *  dcpOld (IN): dcp before shaping
	 *  cpFirstNew (IN): cpFirst after shaping
	 *  dcpNew (IN): dcp after shaping
	 */

	LSERR (WINAPI* pfnDrawGlyphs)(POLS, PLSRUN, BOOL, BOOL, PCGINDEX, const int*, const int*,
						PGOFFSET, PGPROP, PCEXPTYPE, DWORD,
						LSTFLOW, UINT, const POINT*, PCHEIGHTS, long, long, const RECT*);
	/* DrawGlyphs:
	 *  pols (IN):
	 *  plsrun (IN): run pointer of the first run
	 *  fStrikeout (IN) :
	 *  fUnderline (IN) :
	 *  pglyph (IN): array of glyph indices
	 *  rgDu (IN): array of widths of glyphs
	 *  rgDuBeforeJust (IN): array of widths of glyphs before justification
	 *  rgGoffset (IN): array of offsets of glyphs
	 *  rgGprop (IN): array of glyph properties
	 *  rgExpType (IN): array of glyph expansion types
	 *  cglyph (IN): number glyph indices
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN): display mode - opaque, transparent
	 *  pptRun (IN): starting point of the run
	 *  heightsPres (IN): presentation heights for this run
	 *  dupRun (IN): presentation width for this run
	 *  dupLimUnderline (IN): underlining limit
	 *  pRectClip (IN): clipping rectangle
	 */

	/* Glyph justification */

	LSERR (WINAPI* pfnGetGlyphExpansionInfo)(POLS, PLSRUN, LSDEVICE, LPCWSTR, PCGMAP, DWORD, 
							PCGINDEX, PCGPROP, DWORD, LSTFLOW, BOOL, PEXPTYPE, LSEXPINFO*);
	/* GetGlyphExpansionInfo:
	 *  pols (IN):
	 *  plsrun (IN): run pointer of the first run
	 *  lsDeviceID (IN): presentation or reference
	 *  pwch (IN): pointer to the string of character codes
	 *  rggmap (IN): array of wchar->glyph mapping
	 *  cwch (IN): number of characters to be shaped
	 *  rgglyph (IN): array of glyph indices
	 *  rgProp (IN): array of glyph properties
	 *  cglyph (IN): number glyph indices
	 *  kTFlow (IN): text direction and orientation
	 *  fLastTextChunkOnLine (IN): Last text chunk on line?
	 *  rgExpType (OUT): array of glyph expansion types
	 *  rgexpinfo (OUT): array of glyph expansion info
	 */

	LSERR (WINAPI* pfnGetGlyphExpansionInkInfo)(POLS, PLSRUN, LSDEVICE, GINDEX, GPROP, LSTFLOW, DWORD, long*);
	/* GetGlyphExpansionInkInfo:
	 *  pols (IN):
	 *  plsrun (IN): run pointer of the first run
	 *  lsDeviceID (IN): presentation or reference
	 *  gindex (IN): glyph index
	 *  gprop (IN): glyph properties
	 *  kTFlow (IN): text direction and orientation
	 *  cAddInkDiscrete (IN): number of discrete values (minus 1, because maximum is already known)
	 *  rgDu (OUT): array of discrete values
	 */

	/* FarEast realted typograpy issues */

	LSERR (WINAPI* pfnGetEms)(POLS, PLSRUN, LSTFLOW, PLSEMS);
	/* GetEms:
	 *  pols (IN):
	 *  plsrun (IN): run pointer as returned from FetchRun
	 *  kTFlow (IN): text direction and orientation
	 *  &lsems (OUT): different fractions of EM in appropriate pixels
	 */

	LSERR (WINAPI* pfnPunctStartLine)(POLS, PLSRUN, MWCLS, WCHAR, LSACT*);
	/* PunctStartLine:
	 *  pols (IN):
	 *  plsrun (IN): run pointer for the char
	 *  mwcls (IN): mod width class for the char
	 *  wch (IN): char
	 *  &lsact (OUT): action on the first char on the line
	 */

	LSERR (WINAPI* pfnModWidthOnRun)(POLS, PLSRUN, WCHAR, PLSRUN, WCHAR,
									   LSACT*);
	/* ModWidthOnRun:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the first char
	 *  wchFirst (IN): first char
	 *  plsrunSecond (IN): run pointer for the second char
	 *  wchSecond (IN): second char
	 *  &lsact (OUT): action on the last char in 1st run
	 */

	LSERR (WINAPI* pfnModWidthSpace)(POLS, PLSRUN, PLSRUN, WCHAR, PLSRUN, WCHAR,
									 LSACT*);
	/* ModWidthSpace:
	 *  pols (IN):
	 *  plsrunCur (IN): run pointer for the current run
	 *  plsrunPrev (IN): run pointer for the previous char
	 *  wchPrev (IN): previous char
	 *  plsrunNext (IN): run pointer for the next char
	 *  wchNext (IN): next char
	 *  &lsact (OUT): action on space's width
	 */

	LSERR (WINAPI* pfnCompOnRun)(POLS, PLSRUN, WCHAR, PLSRUN, WCHAR,
								   LSPRACT*);
	/* CompOnRun:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the first char
	 *  wchFirst (IN): first char
	 *  plsrunSecond (IN): run pointer for the second char
	 *  wchSecond (IN): second char
	 *  &lspract (OUT): prioritized action on the last char in 1st run
	 */

	LSERR (WINAPI* pfnCompWidthSpace)(POLS, PLSRUN, PLSRUN, WCHAR, PLSRUN, WCHAR,
									  LSPRACT*);
	/* CompWidthSpace:
	 *  pols (IN):
	 *  plsrunCur (IN): run pointer for the current run
	 *  plsrunPrev (IN): run pointer for the previous char
	 *  wchPrev (IN): previous char
	 *  plsrunNext (IN): run pointer for the next char
	 *  wchNext (IN): next char
	 *  &lspract (OUT): prioritized action on space's width
	 */


	LSERR (WINAPI* pfnExpOnRun)(POLS, PLSRUN, WCHAR, PLSRUN, WCHAR,
								  LSACT*);
	/* ExpOnRun:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the first char
	 *  wchFirst (IN): first char
	 *  plsrunSecond (IN): run pointer for the second char
	 *  wchSecond (IN): second char
	 *  &lsact (OUT): action on the last run char from 1st run
	 */

	LSERR (WINAPI* pfnExpWidthSpace)(POLS, PLSRUN, PLSRUN, WCHAR, PLSRUN,
									   WCHAR, LSACT*);
	/* ExpWidthSpace:
	 *  pols (IN):
	 *  plsrunCur (IN): run pointer for the current run
	 *  plsrunPrev (IN): run pointer for the previous char
	 *  wchPrev (IN): previous char
	 *  plsrunNext (IN): run pointer for the next char
	 *  wchNext (IN): next char
	 *  &lsact (OUT): action on space's width
	 */

	LSERR (WINAPI* pfnGetModWidthClasses)(POLS, PLSRUN, const WCHAR*, DWORD, MWCLS*);
	/* GetModWidthClasses:
	 *  pols (IN):
	 *  plsrun (IN): run pointer for the characters
	 *  rgwch (IN): array of characters
	 *  cwch (IN): number of characters in the rgwch array
	 *  rgmwcls(OUT): array of ModWidthClass's for chars from the rgwch array
	 */

	LSERR (WINAPI* pfnGetBreakingClasses)(POLS, PLSRUN, LSCP, WCHAR, BRKCLS*, BRKCLS*);
	/* GetBreakingClasses:
	 *  pols (IN):
	 *  plsrun (IN): run pointer for the char
	 *  cp (IN): cp of the character
	 *  wch (IN): character
	 *  &brkclsFirst (OUT): breaking class for this char as the leading one in a pair
	 *  &brkclsSecond (OUT): breaking class for this char as the following one in a pair
	 */

	LSERR (WINAPI* pfnFTruncateBefore)(POLS, PLSRUN, LSCP, WCHAR, long, PLSRUN, LSCP, WCHAR, long, long, BOOL*);
	/* FTruncateBefore:
	 *  pols (IN):
	 *	plsrunCur (IN): plsrun of the current character 
	 *  cpCur (IN): cp of truncation char
	 *  wchCur (IN): truncation character 
	 *  durCur (IN): width of truncation character
	 *	plsrunPrev (IN): plsrun of the previous character 
	 *  cpPrev (IN): cp of the previous character
	 *  wchPrev (IN): previous character 
	 *  durPrev (IN): width of truncation character
	 *  durCut (IN): width from the RM until the end of the current character
	 *  &fTruncateBefore (OUT): truncation point is before this character
	 * 			(if it exceeds RM)
	 */
	
	LSERR (WINAPI* pfnCanBreakBeforeChar)(POLS, BRKCLS, BRKCOND*);
	/* CanBreakBeforeChar:
	 *  pols (IN):
	 *	brkcls (IN): breaking class for the char as the following one in a pair
	 *  &brktxtBefore (OUT): break condition before the character
	 */

	LSERR (WINAPI* pfnCanBreakAfterChar)(POLS, BRKCLS, BRKCOND*);
	/* CanBreakAfterChar:
	 *  pols (IN):
	 *  brkcls (IN): breaking class for the char as the leading one in a pair
	 *  &brktxtAfter (OUT): break text condition after the character
	 */


	LSERR (WINAPI* pfnFHangingPunct)(POLS, PLSRUN, MWCLS, WCHAR, BOOL*);
	/* FHangingPunct:
	 *  pols (IN):
	 *  plsrun (IN): run pointer for the char
	 *  mwcls (IN): mod width class of this char
	 *  wch (IN): character
	 *  &fHangingPunct (OUT): can be pushed to the right margin?
	 */

	LSERR (WINAPI* pfnGetSnapGrid)(POLS, WCHAR*, PLSRUN*, LSCP*, DWORD, BOOL*, DWORD*);
	/* GetGridInfo:
	 *  pols (IN):
	 *  rgwch (IN): array of characters
	 *  rgplsrun (IN): array of corresponding plsrun's
	 *  rgcp (IN): array of corresponding cp's
	 *  iwch (IN): number of characters
	 *	rgfSnap (OUT): array of fSnap flags for all characters
	 *	pwGridNumber (OUT): number of grid points on the line
	 */

	LSERR (WINAPI* pfnDrawEffects)(POLS, PLSRUN, UINT,
								   const POINT*, LPCWSTR, const int*, const int*, DWORD, 
								   LSTFLOW, UINT, PCHEIGHTS, long, long, const RECT*);
	/* DrawTextRun:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  EffectsFlags (IN): set of client defined special effects bits
	 *  ppt (IN): output location
	 *  lpwchRun (IN): run of characters
	 *  rgDupRun (IN): widths of characters
	 *  rgDupLeftCut (IN): dup cut from the left side of the char
	 *  cwchRun (IN): number of characters in run
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN): display mode - opaque, transparent
	 *  heightsPres (IN): presentation heights for this run
	 *  dupRun (IN): presentation width for this run
	 *  dupLimUnderline (IN): underlining limit
	 *  pRectClip (IN): clipping rectangle
	 */

	LSERR (WINAPI* pfnFCancelHangingPunct)(POLS, LSCP, LSCP, WCHAR, MWCLS, BOOL*);

	/* FCancelHangingPunct:
	 *  pols (IN):
	 *  cpLim (IN): cpLim of the line
	 *  cpLastAdjustable (IN): cp of the last adjustable character on the line
	 *  wch (IN): last character
	 *  mwcls (IN): mod width class of this char
	 *  pfCancelHangingPunct (OUT): cancel hanging punctuation?
	*/

	LSERR (WINAPI* pfnModifyCompAtLastChar)(POLS, LSCP, LSCP, WCHAR, MWCLS, long, long, long*);

	/* ModifyCompAtLastChar:
	 *  pols (IN):
	 *  cpLim (IN): cpLim of the line
	 *  cpLastAdjustable (IN): cp of the last adjustable character on the line
	 *  wch (IN): last character
	 *  mwcls (IN): mod width class of this char
	 *  durCompLastRight (IN): suggested compression on the right side
	 *  durCompLastLeft (IN): suggested compression on the left side
	 *  pdurCahngeComp (OUT): change compression amount on the last char
	*/

	/* Enumeration callbacks */

	LSERR (WINAPI* pfnEnumText)(POLS, PLSRUN, LSCP, LSDCP, LPCWSTR, DWORD, LSTFLOW, BOOL,
											BOOL, const POINT*, PCHEIGHTS, long, BOOL, long*);
	/* EnumText:
	 *  pols (IN):
	 *  plsrun (IN): from DNODE
	 *  cpFirst (IN): from DNODE
	 *  dcp (IN): from DNODE
	 *  rgwch(IN): array of characters
	 *  cwch(IN): number of characters
	 *  lstflow (IN): text flow
	 *  fReverseOrder (IN): enumerate in reverse order
	 *  fGeometryProvided (IN):
	 *  pptStart (IN): starting position, iff fGeometryProvided
	 *  pheightsPres(IN): from DNODE, relevant iff fGeometryProvided
	 *  dupRun(IN): from DNODE, relevant iff fGeometryProvided
	 *  fCharWidthProvided (IN):
	 *  rgdup(IN): array of character widths, iff fCharWidthProvided
	*/

	LSERR (WINAPI* pfnEnumTab)(POLS, PLSRUN, LSCP, LPCWSTR, WCHAR, LSTFLOW, BOOL,
													BOOL, const POINT*, PCHEIGHTS, long);
	/* EnumTab:
	 *  pols (IN):
	 *  plsrun (IN): from DNODE
	 *  cpFirst (IN): from DNODE
	 *  rgwch(IN): Pointer to one Tab character
	 *  wchTabLeader (IN): tab leader
	 *  lstflow (IN): text flow
	 *  fReverseOrder (IN): enumerate in reverse order
	 *  fGeometryProvided (IN):
	 *  pptStart (IN): starting position, iff fGeometryProvided
	 *  pheightsPres(IN): from DNODE, relevant iff fGeometryProvided
	 *  dupRun(IN): from DNODE, relevant iff fGeometryProvided
	*/

	LSERR (WINAPI* pfnEnumPen)(POLS, BOOL, LSTFLOW, BOOL, BOOL, const POINT*, long, long);
	/* EnumPen:
	 *  pols (IN):
	 *  fBorder (IN):
	 *  lstflow (IN): text flow
	 *  fReverseOrder (IN): enumerate in reverse order
	 *  fGeometryProvided (IN):
	 *  pptStart (IN): starting position, iff fGeometryProvided
	 *  dup(IN): from DNODE iff fGeometryProvided
	 *  dvp(IN): from DNODE iff fGeometryProvided
	*/

	/* Objects bundling */

	LSERR (WINAPI* pfnGetObjectHandlerInfo)(POLS, DWORD, void*);
	/* GetObjectHandlerInfo:
	 *  pols (IN):
	 *  idObj (IN): id of the object handler
	 *  pObjectInfo (OUT): initialization information of the specified object
	*/


	/* Debugging APIs */
	void (WINAPI *pfnAssertFailed)(char*, char*, int);

};
typedef struct lscbk LSCBK;

#endif /* !LSCBK_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lscontxt.h ===
#ifndef LSCONTXT_DEFINED
#define LSCONTXT_DEFINED

#include "lsdefs.h"
#include "lscbk.h"
#include "lstxtcfg.h"
#include "lsimeth.h"


typedef struct 
{
	DWORD version;						/* version number	*/
	DWORD cInstalledHandlers;
	const LSIMETHODS* pInstalledHandlers; /* Installed handlers */
	LSTXTCFG lstxtcfg;					/* Straight-text configuration data */
	POLS pols;							/* Client data for this context */
	LSCBK lscbk;						/* LineServices client callbacks */
	BOOL fDontReleaseRuns;				/* Optimization---don't call pfnReleaseRun */
} LSCONTEXTINFO;


LSERR WINAPI LsCreateContext(const LSCONTEXTINFO*, PLSC*);
LSERR WINAPI LsDestroyContext(PLSC);

#endif /* LSCONTXT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lscrline.h ===
#ifndef LSCRLINE_DEFINED
#define LSCRLINE_DEFINED

#include "lsdefs.h"
#include "plsline.h"
#include "breakrec.h"
#include "lslinfo.h"

LSERR WINAPI LsCreateLine(PLSC,				/* IN: ptr to line services context		*/
						  LSCP,				/* IN: cpFirst							*/
						  long,				/* IN: duaColumn						*/
						  const BREAKREC*,	/* IN: input array of break records		*/
						  DWORD,			/* IN: number of records in input array	*/
						  DWORD,			/* IN: size of the output array			*/
						  BREAKREC*,		/* OUT: output array of break records	*/
						  DWORD*,			/* OUT:actual number of records in array*/
						  LSLINFO*,			/* OUT: visible line info				*/
						  PLSLINE*);		/* OUT: ptr to line opaque to client	*/

LSERR WINAPI LsModifyLineHeight(PLSC,		/* IN: ptr to line services context 	*/
								PLSLINE,	/* IN: ptr to line -- opaque to client	*/
								long,		/* IN: dvpAbove							*/
								long,		/* IN: dvpAscent						*/
								long,		/* IN: dvpDescent						*/	
								long);		/* IN: dvpBelow							*/	

LSERR WINAPI LsDestroyLine(PLSC,			/* IN: ptr to line services context		*/
						   PLSLINE);		/* IN: ptr to line -- opaque to client	*/

LSERR WINAPI LsGetLineDur(PLSC,				/* IN: ptr to line services context 	*/
						  PLSLINE,			/* IN: ptr to line -- opaque to client	*/
						  long*,			/* OUT: dur of line incl. trailing area	*/
						  long*);			/* OUT: dur of line excl. trailing area	*/

LSERR WINAPI LsGetMinDurBreaks(PLSC,		/* IN: ptr to line services context 	*/
						  	   PLSLINE,		/* IN: ptr to line -- opaque to client	*/
						  	   long*,		/* OUT: min dur between breaks including 
																	trailing area	*/
						  	   long*);		/* OUT: min dur between breaks excluding 
																	trailing area	*/

#endif /* !LSCRLINE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lscrsubl.h ===
#ifndef LSCRSUBL_DEFINED
#define LSCRSUBL_DEFINED

/* Line services formatter fetch/dispatcher interface (to LsCreateLine())
 */

#include "lsdefs.h"
#include "lsfrun.h"
#include "lsesc.h"
#include "plssubl.h"
#include "plsdnode.h"
#include "fmtres.h"
#include "objdim.h"
#include "lstflow.h"
#include "lskjust.h"
#include "breakrec.h"
#include "brkkind.h"
#include "brkpos.h"

LSERR WINAPI LsCreateSubline(
							PLSC,			/* IN: LS context						*/
							LSCP,			/* IN: cpFirst							*/
						    long,			/* IN: urColumnMax						*/
							LSTFLOW,		/* IN: text flow						*/
							BOOL);			/* IN: fContiguous						*/

LSERR WINAPI LsFetchAppendToCurrentSubline(
							PLSC,			/* IN: LS context						*/
							LSDCP,			/* IN:Increase cp before fetching		*/
						    const LSESC*,	/* IN: escape characters				*/
						    DWORD,			/* IN: # of escape characters			*/
							BOOL*,			/* OUT: Successful?---if not, finish 
												subline, destroy it and start anew	*/
						    FMTRES*,		/* OUT: result of last formatter		*/
						    LSCP*,			/* OUT: cpLim							*/
						    PLSDNODE*,		/* OUT: First DNODE created				*/
						 	PLSDNODE*);		/* OUT: Last DNODE created				*/

LSERR WINAPI LsFetchAppendToCurrentSublineResume(
							PLSC,			/* IN: LS context						*/
							const BREAKREC*,/* IN: array of break records			*/
							DWORD,			/* IN: number of records in array		*/
							LSDCP,			/* IN:Increase cp before fetching		*/
						    const LSESC*,	/* IN: escape characters				*/
						    DWORD,			/* IN: # of escape characters			*/
							BOOL*,			/* OUT: Successful?---if not, finish 
												subline, destroy it and start anew	*/
						    FMTRES*,		/* OUT: result of last formatter		*/
						    LSCP*,			/* OUT: cpLim							*/
						    PLSDNODE*,		/* OUT: First DNODE created				*/
						 	PLSDNODE*);		/* OUT: Last DNODE created				*/

LSERR WINAPI LsAppendRunToCurrentSubline(		/* Simple runs only	*/
							PLSC,			/* IN: LS context						*/
						    const LSFRUN*,	/* IN: given run						*/
							BOOL*,			/* OUT: Successful?---if not, finish 
												subline, destroy it and start anew	*/
						    FMTRES*,		/* OUT: result of last formatter		*/
						    LSCP*,			/* OUT: cpLim							*/
						    PLSDNODE*);		/* OUT: DNODE created					*/

LSERR WINAPI LsResetRMInCurrentSubline(
							PLSC,			/* IN: LS context						*/
						    long);			/* IN: urColumnMax						*/

LSERR WINAPI LsFinishCurrentSubline(
							PLSC,			/* IN: LS context						*/
							PLSSUBL*);		/* OUT: subline context					*/


LSERR WINAPI LsTruncateSubline(
							PLSSUBL,		/* IN: subline context					*/
							long,			/* IN: urColumnMax						*/
							LSCP*);			/* OUT: cpTruncate 						*/

LSERR WINAPI LsFindPrevBreakSubline(
							PLSSUBL,		/* IN: subline context					*/
							BOOL,			/* IN: fFirstSubline					*/
							LSCP,			/* IN: truncation cp					*/
						    long,			/* IN: urColumnMax						*/
							BOOL*,			/* OUT: fSuccessful?					*/
							LSCP*,			/* OUT: cpBreak							*/
							POBJDIM,		/* OUT: objdimSub up to break			*/
							BRKPOS*);		/* OUT: Before/Inside/After				*/

LSERR WINAPI LsFindNextBreakSubline(
							PLSSUBL,		/* IN: subline context					*/
							BOOL,			/* IN: fFirstSubline					*/
							LSCP,			/* IN: truncation cp					*/
						    long,			/* IN: urColumnMax						*/
							BOOL*,			/* OUT: fSuccessful?					*/
							LSCP*,			/* OUT: cpBreak							*/
							POBJDIM,		/* OUT: objdimSub up to break			*/			
							BRKPOS*);		/* OUT: Before/Inside/After				*/

LSERR WINAPI LsForceBreakSubline(
							PLSSUBL,		/* IN: subline context					*/
							BOOL,			/* IN: fFirstSubline					*/
							LSCP,			/* IN: truncation cp					*/
						    long,			/* IN: urColumnMax						*/
							LSCP*,			/* OUT: cpBreak							*/
							POBJDIM,		/* OUT: objdimSub up to break			*/			
							BRKPOS*);		/* OUT: Before/Inside/After				*/

LSERR WINAPI LsSetBreakSubline(
							PLSSUBL,		/* IN: subline context					*/
							BRKKIND,		/* IN: Prev/Next/Force/Imposed			*/			
							DWORD,			/* IN: size of array					*/
							BREAKREC*, 		/* OUT: array of break records			*/
							DWORD*);		/* OUT: number of used elements of the array*/

LSERR WINAPI LsDestroySubline(PLSSUBL);

LSERR WINAPI LsMatchPresSubline(
							  PLSSUBL);		/* IN: subline context		*/

LSERR WINAPI LsExpandSubline(
							  PLSSUBL,		/* IN: subline context		*/
							  LSKJUST,		/* IN: justification type	*/
							  long);		/* IN: dup					*/

LSERR WINAPI LsCompressSubline(
							  PLSSUBL,		/* IN: subline context		*/
							  LSKJUST,		/* IN: justification type	*/
							  long);		/* IN: dup					*/

LSERR WINAPI LsSqueezeSubline(
							  PLSSUBL,		/* IN: subline context		*/
							  long,			/* IN: durTarget			*/
							  BOOL*,		/* OUT: fSuccessful?		*/
							  long*);		/* OUT: if nof successful, 
													extra dur 			*/

LSERR WINAPI LsGetSpecialEffectsSubline(
							  PLSSUBL,		/* IN: subline context		*/
							  UINT*);		/* OUT: special effects		*/

#endif /* !LSCRSUBL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsdevice.h ===
#ifndef LSDEVICE_DEFINED
#define LSDEVICE_DEFINED

enum lsdevice				/* Parameter for pfnGetRunTextMetrics callback */
{
	lsdevPres,
	lsdevReference
};

typedef enum lsdevice LSDEVICE;

#endif /* !LSDEVICE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsdevres.h ===
#ifndef LSDEVRES_DEFINED
#define LSDEVRES_DEFINED

typedef struct
{
	long dxpInch, dypInch;				/* resolution of preview device */
	long dxrInch, dyrInch;				/* resolution of reference device */
} LSDEVRES;

#endif /* !LSDEVRES_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsdefs.h ===
/* Common definitions for line services
 */

#ifndef LSDEFS_DEFINED
#define LSDEFS_DEFINED

#ifdef UNIX
#include <wchar.h>
#endif

#ifndef WINVER	/* defined in <windows.h> */

/* <windows.h> must be included FIRST, if at all. */
/* We define basic types if <windows.h> is not included. */

#ifndef NULL
#define NULL    ((void *)0)
#endif /* NULL */

#ifdef UNDER_CE
#define WINAPI __cdecl	/* CE converts all stdcall's to cdecl's */
#else
#define WINAPI __stdcall
#endif

#define FALSE	0
#define TRUE	1

typedef int BOOL;
typedef long LONG;
typedef unsigned long DWORD;
typedef unsigned short WORD;
typedef unsigned int UINT;
typedef unsigned char BYTE;
typedef int INT;
#ifdef UNIX
typedef wchar_t WCHAR;
#else
typedef WORD WCHAR;
#endif
typedef const WCHAR* LPCWSTR;
typedef WCHAR* LPWSTR;

typedef struct tagRECT
{
    LONG    left;
    LONG    top;
    LONG    right;
    LONG    bottom;
} RECT;

typedef struct tagPOINT
{
    LONG  x;
    LONG  y;
} POINT;

#endif /* WINVER */


/* Line services definitions */
struct lscontext;					/* Opaque to clients */
typedef struct lscontext* PLSC;
typedef const struct lscontext* PCLSC;

struct ols;								/* Owner of LineServices */
typedef struct ols* POLS;				/*  (Opaque to LineService) */

typedef long LSCP;
typedef DWORD LSDCP;

typedef WORD GINDEX;
typedef GINDEX* PGINDEX;
typedef const GINDEX* PCGINDEX;

typedef struct tagPOINTUV
{
    LONG  u;
    LONG  v;
} POINTUV;

typedef POINTUV* PPOINTUV;
typedef const POINTUV* PCPOINTUV;

#ifndef __usp10__   // defined in usp10.h
typedef struct tagGOFFSET
{
    LONG  du;
    LONG  dv;
} GOFFSET;
#endif

typedef GOFFSET* PGOFFSET;
typedef const GOFFSET* PCGOFFSET;

/* Line services error codes */
typedef long LSERR;
#define lserrNone						( 0L)
#ifdef LSERRSTOP				/* stop immediately, don't return error */
#define lserrInvalidParameter   		AssertErr("lserrInvalidParameter")  	
#define lserrOutOfMemory    			AssertErr("lserrOutOfMemory")
#define lserrNullOutputParameter  		AssertErr("lserrNullOutputParameter") 
#define lserrInvalidContext    			AssertErr("lserrInvalidContext") 
#define lserrInvalidLine    			AssertErr("lserrInvalidLine")
#define lserrInvalidDnode    			AssertErr("lserrInvalidDnode")    
#define lserrInvalidDeviceResolution 	AssertErr("lserrInvalidDeviceResolution")
#define lserrInvalidRun  			   	AssertErr("lserrInvalidRun")
#define lserrMismatchLineContext  		AssertErr("lserrMismatchLineContext")
#define lserrContextInUse    			AssertErr("lserrContextInUse")
#define lserrDuplicateSpecialCharacter 	AssertErr("lserrDuplicateSpecialCharacter")
#define lserrInvalidAutonumRun  		AssertErr("lserrInvalidAutonumRun")
#define lserrFormattingFunctionDisabled AssertErr("lserrFormattingFunctionDisabled")
#define lserrUnfinishedDnode   			AssertErr("lserrUnfinishedDnode")
#define lserrInvalidDnodeType   		AssertErr("lserrInvalidDnodeType")
#define lserrInvalidPenDnode   			AssertErr("lserrInvalidPenDnode")   
#define lserrInvalidNonPenDnode   		AssertErr("lserrInvalidNonPenDnode")
#define lserrInvalidBaselinePenDnode 	AssertErr("lserrInvalidBaselinePenDnode")
#define lserrInvalidFormatterResult  	AssertErr("lserrInvalidFormatterResult")
#define lserrInvalidObjectIdFetched  	AssertErr("lserrInvalidObjectIdFetched")
#define lserrInvalidDcpFetched   		AssertErr("lserrInvalidDcpFetched")
#define lserrInvalidCpContentFetched 	AssertErr("lserrInvalidCpContentFetched")
#define lserrInvalidBookmarkType  		AssertErr("lserrInvalidBookmarkType")
#define lserrSetDocDisabled    			AssertErr("lserrSetDocDisabled")
#define lserrFiniFunctionDisabled  		AssertErr("lserrFiniFunctionDisabled")
#define lserrCurrentDnodeIsNotTab  		AssertErr("lserrCurrentDnodeIsNotTab")
#define lserrPendingTabIsNotResolved	AssertErr("lserrPendingTabIsNotResolved")
#define lserrWrongFiniFunction 			AssertErr("lserrWrongFiniFunction")
#define lserrInvalidBreakingClass		AssertErr("lserrInvalidBreakingClass")
#define lserrBreakingTableNotSet		AssertErr("lserrBreakingTableNotSet")
#define lserrInvalidModWidthClass		AssertErr("lserrInvalidModWidthClass")
#define lserrModWidthPairsNotSet		AssertErr("lserrModWidthPairsNotSet")
#define lserrWrongTruncationPoint 		AssertErr("lserrWrongTruncationPoint")
#define lserrWrongBreak 				AssertErr("lserrWrongBreak")
#define lserrDupInvalid 				AssertErr("lserrDupInvalid")
#define lserrRubyInvalidVersion			AssertErr("lserrRubyVersionInvalid")
#define lserrTatenakayokoInvalidVersion	AssertErr("lserrTatenakayokoInvalidVersion")
#define lserrWarichuInvalidVersion		AssertErr("lserrWarichuInvalidVersion")
#define lserrWarichuInvalidData			AssertErr("lserrWarichuInvalidData")
#define lserrCreateSublineDisabled		AssertErr("lserrCreateSublineDisabled")
#define lserrCurrentSublineDoesNotExist	AssertErr("lserrCurrentSublineDoesNotExist")
#define lserrCpOutsideSubline			AssertErr("lserrCpOutsideSubline")
#define lserrHihInvalidVersion			AssertErr("lserrHihInvalidVersion")
#define lserrInsufficientQueryDepth		AssertErr("lserrInsufficientQueryDepth")
#define lserrInsufficientBreakRecBuffer	AssertErr("lserrInsufficientBreakRecBuffer")
#define lserrInvalidBreakRecord			AssertErr("lserrInvalidBreakRecord")
#define lserrInvalidPap					AssertErr("lserrInvalidPap")
#define lserrContradictoryQueryInput	AssertErr("lserrContradictoryQueryInput")
#define lserrLineIsNotActive			AssertErr("lserrLineIsNotActive")
#define lserrTooLongParagraph			AssertErr("lserrTooLongParagraph")
#else
#define lserrInvalidParameter			(-1L)
#define lserrOutOfMemory				(-2L)
#define lserrNullOutputParameter		(-3L)
#define lserrInvalidContext				(-4L)
#define lserrInvalidLine				(-5L)
#define lserrInvalidDnode				(-6L)
#define lserrInvalidDeviceResolution	(-7L)
#define lserrInvalidRun					(-8L)
#define lserrMismatchLineContext		(-9L)
#define lserrContextInUse				(-10L)
#define lserrDuplicateSpecialCharacter	(-11L)
#define lserrInvalidAutonumRun			(-12L)
#define lserrFormattingFunctionDisabled	(-13L)
#define lserrUnfinishedDnode			(-14L)
#define lserrInvalidDnodeType			(-15L)
#define lserrInvalidPenDnode			(-16L)
#define lserrInvalidNonPenDnode			(-17L)
#define lserrInvalidBaselinePenDnode	(-18L)
#define lserrInvalidFormatterResult		(-19L)
#define lserrInvalidObjectIdFetched		(-20L)
#define lserrInvalidDcpFetched			(-21L)
#define lserrInvalidCpContentFetched	(-22L)
#define lserrInvalidBookmarkType		(-23L)
#define lserrSetDocDisabled				(-24L)
#define lserrFiniFunctionDisabled		(-25L)
#define lserrCurrentDnodeIsNotTab		(-26L)
#define lserrPendingTabIsNotResolved    (-27L)
#define lserrWrongFiniFunction 			(-28L)
#define lserrInvalidBreakingClass		(-29L)
#define lserrBreakingTableNotSet		(-30L)
#define lserrInvalidModWidthClass		(-31L)
#define lserrModWidthPairsNotSet		(-32L)
#define lserrWrongTruncationPoint 		(-33L)
#define lserrWrongBreak 				(-34L)
#define	lserrDupInvalid					(-35L)
#define lserrRubyInvalidVersion			(-36L)
#define lserrTatenakayokoInvalidVersion	(-37L)
#define lserrWarichuInvalidVersion		(-38L)
#define lserrWarichuInvalidData			(-39L)
#define lserrCreateSublineDisabled		(-40L)
#define lserrCurrentSublineDoesNotExist	(-41L)
#define lserrCpOutsideSubline			(-42L)
#define lserrHihInvalidVersion			(-43L)
#define lserrInsufficientQueryDepth		(-44L)
#define lserrInsufficientBreakRecBuffer	(-45L)
#define lserrInvalidBreakRecord			(-46L)
#define lserrInvalidPap					(-47L)
#define lserrContradictoryQueryInput	(-48L)
#define lserrLineIsNotActive			(-49L)
#define lserrTooLongParagraph			(-50L)
#endif	/* LSERRORSTOP */


#ifndef fTrue
#define fTrue	1
#define fFalse	0
#endif

#define uLsInfiniteRM	0x3FFFFFFF

#define czaUnitInch					(1440L) /* 1440 absolute units per inch */

#endif /* LSDEFS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsdnfin.h ===
#ifndef LSDNFIN_DEFINED
#define LSDNFIN_DEFINED

/* Access routines for contents of DNODES */

#include "lsdefs.h"
#include "plsrun.h"
#include "plsfrun.h"
#include "plschp.h"
#include "pobjdim.h"
#include "pdobj.h"


LSERR WINAPI LsdnFinishRegular(
							  PLSC,				/* IN: Pointer to LS Context */
							  LSDCP,     		/* IN: dcp adopted           */
							  PLSRUN,   		/* IN: PLSRUN  		         */
							  PCLSCHP,  		/* IN: CHP          	     */
							  PDOBJ,    		/* IN: PDOBJ             	 */ 
							  PCOBJDIM);		/* IN: OBJDIM      		     */

LSERR WINAPI LsdnFinishRegularAddAdvancePen(
							  PLSC,				/* IN: Pointer to LS Context */
							  LSDCP,     		/* IN: dcp adopted           */
							  PLSRUN,   		/* IN: PLSRUN  		         */
							  PCLSCHP,  		/* IN: CHP          	     */
							  PDOBJ,    		/* IN: PDOBJ             	 */ 
							  PCOBJDIM,			/* IN: OBJDIM      		     */
							  long,				/* IN: durPen				 */
							  long,				/* IN: dvrPen				 */
							  long);			/* IN: dvpPen 				 */

LSERR WINAPI LsdnFinishByPen(PLSC,				/* IN: Pointer to LS Context */
						   LSDCP, 	    		/* IN: dcp	adopted          */
						   PLSRUN,		   		/* IN: PLSRUN  		         */
						   PDOBJ,	    		/* IN: PDOBJ             	 */ 
						   long,    	 		/* IN: dur         		     */
						   long,     			/* IN: dvr             		 */
						   long);   			/* IN: dvp          	     */

LSERR WINAPI LsdnFinishDeleteAll(PLSC,			/* IN: Pointer to LS Context */
					  			LSDCP);			/* IN: dcp adopted			 */

#endif /* !LSDNFIN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsdocinf.h ===
#ifndef LSDOCINF_DEFINED
#define LSDOCINF_DEFINED

#include "lsdefs.h"
#include "plsdocin.h"
#include "lsdevres.h"

typedef struct lsdocinf
{
	BOOL fDisplay;
	BOOL fPresEqualRef;
	LSDEVRES lsdevres;
} LSDOCINF;

#endif /* !LSDOCINF_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsdsply.h ===
#ifndef LSDSPLY_DEFINED
#define LSDSPLY_DEFINED

#include "lsdefs.h"
#include "plsline.h"

LSERR WINAPI LsDisplayLine(PLSLINE, const POINT*, UINT, const RECT*);
/* LsDisplayLine
 *  pline (IN)
 *  ppt (IN)
 *  kDisp (IN): transparent or opaque
 *  &rcClip (IN): clipping rect
 */

#endif /* !LSDSPLY_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsdnset.h ===
#ifndef LSDNSET_DEFINED
#define LSDNSET_DEFINED

/* Access routines for contents of DNODES */

#include "lsdefs.h"
#include "plssubl.h"
#include "plsdnode.h"
#include "pobjdim.h"
#include "lsktab.h"
#include "lskeop.h"

LSERR WINAPI LsdnQueryObjDimRange(
								  PLSC,			/* IN: Pointer to LS Context */
							 	  PLSDNODE,		/* IN: plsdnFirst -- First DNODE in range */
								  PLSDNODE,		/* IN: plsdnLast -- Last DNODE in range */
							 	  POBJDIM);		/* OUT: dimensions of range */


LSERR WINAPI LsdnResetObjDim(
								 PLSC,			/* IN: Pointer to LS Context	*/
								 PLSDNODE,		/* IN: plsdnFirst 				*/
								 PCOBJDIM);		/* IN: dimensions of dnode 		*/


LSERR WINAPI LsdnQueryPenNode(
							  PLSC,				/* IN: Pointer to LS Context*/
						  	  PLSDNODE,			/* IN: DNODE queried		*/
						  	  long*,			/* OUT: &dvpPen				*/
						  	  long*,			/* OUT: &durPen				*/
						  	  long*);			/* OUT: &dvrPen				*/


LSERR WINAPI LsdnResetPenNode(
							  PLSC,				/* IN: Pointer to LS Context */
						  	  PLSDNODE,			/* IN: DNODE to be modified */
						  	  long,				/* IN: dvpPen */
						  	  long,				/* IN: durPen */
						  	  long);			/* IN: dvrPen */

LSERR WINAPI LsdnSetRigidDup(
							 PLSC,				/* IN: Pointer to LS Context */
							 PLSDNODE,			/* IN: DNODE to be modified	 */
							 long);				/* IN: dup					 */

LSERR WINAPI LsdnGetDup(
							 PLSC,				/* IN: Pointer to LS Context */
							 PLSDNODE,			/* IN: DNODE queried		 */
							 long*);			/* OUT: dup					 */

LSERR WINAPI LsdnSetAbsBaseLine(
								PLSC,			/* IN: Pointer to LS Context */
							  	long);    		/* IN: new vaBase            */

LSERR WINAPI LsdnModifyParaEnding(
								PLSC,			/* IN: Pointer to LS Context */
								LSKEOP);		/* IN: Kind of line ending			*/

LSERR WINAPI LsdnResolvePrevTab(PLSC);			/* IN: Pointer to LS Context */

LSERR WINAPI LsdnGetCurTabInfo(
							PLSC,				/* IN: Pointer to LS Context */
							LSKTAB*);			/* OUT: Type of current tab  */

LSERR WINAPI LsdnSkipCurTab(PLSC);					/* IN: Pointer to LS Context */

LSERR WINAPI LsdnDistribute(
							PLSC,				/* IN: Pointer to LS Context	*/
							PLSDNODE,			/* IN: First DNODE				*/
							PLSDNODE,			/* IN: Last DNODE				*/
							long);				/* IN: durToDistribute			*/

LSERR WINAPI LsdnSubmitSublines(
							PLSC,				/* IN: Pointer to LS Context	*/
							PLSDNODE,			/* IN: DNODE					*/
							DWORD,				/* IN: cSublinesSubmitted		*/
							PLSSUBL*,			/* IN: rgpsublSubmitted			*/
							BOOL,				/* IN: fUseForJustification		*/
							BOOL,				/* IN: fUseForCompression		*/
							BOOL,				/* IN: fUseForDisplay			*/
							BOOL,				/* IN: fUseForDecimalTab		*/
							BOOL				/* IN: fUseForTrailingArea		*/
							);											
LSERR WINAPI LsdnGetFormatDepth(
							PLSC,				/* IN: Pointer to LS Context	*/
							DWORD*);			/* OUT: nDepthFormatLineMax		*/

#endif /* !LSDNSET_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsensubl.h ===
#ifndef LSENSUBL_DEFINED
#define LSENSUBL_DEFINED

/* Line services formatter fetch/dispatcher interface (to LsCreateLine())
 */

#include "lsdefs.h"
#include "plssubl.h"


LSERR WINAPI LsEnumSubline(PLSSUBL,
						   BOOL,			/* IN: enumerate in reverse order?					*/
						   BOOL,			/* IN: geometry needed?								*/
						   const POINT*);	/* IN: starting position(xp, yp) iff fGeometryNeeded*/
#endif /* !LSENSUBL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsesc.h ===
#ifndef LSESC_DEFINED
#define LSESC_DEFINED

/* Definition of Line Services escape characters.
 * Used for LsFetchDispatchEsc().
 */

#include "lsdefs.h"

typedef struct
{
	WCHAR wchFirst, wchLast;			/* Range of chars codes */
} LSESC;


#endif /* !LSESC_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsems.h ===
#ifndef LSEMS_DEFINED
#define LSEMS_DEFINED

#include "lsdefs.h"

typedef struct lsems
{
	long em;		/* one em			*/
	long em2;		/* half em			*/
	long em3;		/* third em			*/
	long em4;		/* quater em		*/
	long em8;		/* eighth em		*/
	long em16;		/* 15/16 of em		*/
	long udExp;		/* user defined expansion	*/
	long udComp;	/* user defined compression*/
} LSEMS;



#endif /* !LSEMS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsexpan.h ===
#ifndef LSEXPAN_DEFINED
#define LSEXPAN_DEFINED

#include "lsdefs.h"
#include "lsact.h"

typedef struct lsexpan					/* expansion information unit		*/
{
	BYTE fFullScaled;					/* expand for full justification	*/
	BYTE fFullInterletter;				/* expand for distributed justification	*/
} LSEXPAN;									


#endif /* !LSEXPAN_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsenum.h ===
#ifndef LSENUM_DEFINED
#define LSENUM_DEFINED

#include "lsdefs.h"
#include "plsline.h"

LSERR WINAPI LsEnumLine(PLSLINE,
					   	BOOL,			/* IN: enumerate in reverse order?					*/
						BOOL,			/* IN: geometry needed?								*/
						const POINT*);	/* IN: starting position(xp, yp) iff fGeometryNeeded*/

#endif /* LSENUM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsdssubl.h ===
#ifndef LSDSSUBL_DEFINED
#define LSDSSUBL_DEFINED

/* Line services formatter fetch/dispatcher interface (to LsCreateLine())
 */

#include "lsdefs.h"
#include "plssubl.h"


LSERR WINAPI LsDisplaySubline(
							PLSSUBL,			/* IN: subline context			*/
							const POINT*,		/* IN: starting position(xp, yp)*/
							UINT,				/* IN: display mode, opaque, etc */
							const RECT*);		/* IN: clip rectangle (xp, yp,...) */

#endif /* !LSDSSUBL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsexpinf.h ===
#ifndef LSEXPINF_DEFINED
#define LSEXPINF_DEFINED

#include "lsdefs.h"
#include "exptype.h"

#define lsexpinfInfinity	0x1FFFFF

/* ------------------------------------------------------------------------ */

struct lsexpinfo							/* Expansion info */
{
	long duMax;
	union
	{
		struct
		{
			long duMin;
		} AddInkContinuous;
	
		struct
		{
			DWORD cwidths;
		} AddInkDiscrete;

	} u;

	BYTE prior;
	BYTE fCanBeUsedForResidual;
	WORD pad;
};

typedef struct lsexpinfo LSEXPINFO;

#endif /* !LSEXPINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsfrun.h ===
#ifndef LSFRUN_DEFINED
#define LSFRUN_DEFINED

#include "lsdefs.h"
#include "plschp.h"
#include "plsrun.h"
#include "plsfrun.h"

struct lsfrun							/* Formatter run */
{
	PCLSCHP plschp;
	PLSRUN plsrun;
	LPCWSTR lpwchRun;
	DWORD cwchRun;
};
typedef struct lsfrun LSFRUN;

#endif /* !LSFRUN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lshyph.h ===
#ifndef LSHYPH_DEFINED
#define LSHYPH_DEFINED

#include "lsdefs.h"
#include "plshyph.h"

struct lshyph							/* Output of pfnHyphenate callback */
{
	UINT kysr;							/* Kind of Ysr - see "lskysr.h" */
	LSCP cpYsr;							/* cp value of YSR */
	WCHAR wchYsr;						/* YSR char code  */
};

#endif /* !LSHYPH_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsffi.h ===
#ifndef LSFFI_DEFINED
#define LSFFI_DEFINED


/* Line Services "format flags" (from LSPAP ) */

/* Visi flags	*/
#define fFmiVisiCondHyphens			0x00000001L
#define fFmiVisiParaMarks			0x00000002L
#define fFmiVisiSpaces				0x00000004L
#define fFmiVisiTabs				0x00000008L
#define fFmiVisiSplats				0x00000010L
#define fFmiVisiBreaks				0x00000020L


/* Advanced typography enabling    */
#define fFmiPunctStartLine			0x00000040L
#define fFmiHangingPunct			0x00000080L
#define fFmiApplyBreakingRules		0x00000100L

/* WYSIWYG flags */
#define fFmiPresSuppressWiggle		0x00000200L
#define fFmiPresExactSync			0x00000400L

/* Autonumbering flags */
#define fFmiAnm						0x00000800L

/* Miscellaneous flags */
#define fFmiAutoDecimalTab			0x00001000L
#define fFmiUnderlineTrailSpacesRM	0x00002000L

#define fFmiSpacesInfluenceHeight	0x00004000L

#define fFmiIgnoreSplatBreak		0x00010000L
#define fFmiLimSplat				0x00020000L
#define fFmiAllowSplatLine			0x00040000L

#define	fFmiForceBreakAsNext		0x00080000L
#define fFmiFCheckTruncateBefore	0x00100000L

#define fFmiDoHyphenation			0x00200000L

#define fFmiDrawInCharCodes			0x00400000L

#define	fFmiTreatHyphenAsRegular	0x00800000L
#define fFmiWrapTrailingSpaces		0x01000000L
#define fFmiWrapAllSpaces			0x02000000L

/* Compatibility flags for bugs in older versions of WORD */
#define fFmiForgetLastTabAlignment	0x10000000L
#define fFmiIndentChangesHyphenZone	0x20000000L
#define fFmiNoPunctAfterAutoNumber	0x40000000L
#define fFmiResolveTabsAsWord97		0x80000000L

#endif /* !LSFFI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lskeop.h ===
#ifndef LSKEOP_DEFINED
#define LSKEOP_DEFINED

enum lskeop							/* kinds of para ending */
{
	lskeopEndPara1,
	lskeopEndPara2,
	lskeopEndPara12,
	lskeopEndParaAlt
};

typedef enum lskeop LSKEOP;

#endif /* !LSKEOP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lskalign.h ===
#ifndef LSKALIGN_DEFINED
#define LSKALIGN_DEFINED

enum lskalign							/* kinds of para alignment */
{
	lskalLeft,
	lskalCentered,
	lskalRight,
};

typedef enum lskalign LSKALIGN;

#endif /* !LSKALIGN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsimeth.h ===
#ifndef LSIMETH_DEFINED
#define LSIMETH_DEFINED

#include "lsdefs.h"

#include "plscbk.h"
#include "plsrun.h"
#include "pilsobj.h"
#include "plnobj.h"
#include "pdobj.h"
#include "pfmti.h"
#include "pbrko.h"
#include "pobjdim.h"
#include "pdispi.h"
#include "plsdocin.h"
#include "pposichn.h"
#include "plocchnk.h"
#include "plsfgi.h"
#include "pheights.h"
#include "plsqin.h"
#include "plsqout.h"
#include "plssubl.h"
#include "plschp.h"
#include "lstflow.h"
#include "lskjust.h"
#include "breakrec.h"
#include "brkcond.h"
#include "brkkind.h"
#include "fmtres.h"
#include "mwcls.h"

typedef struct
{
	LSERR (WINAPI* pfnCreateILSObj)(POLS, PLSC,  PCLSCBK, DWORD, PILSOBJ*);
	/* CreateILSObj
	 *  pols (IN):
	 *  plsc (IN): LS context
	 *  plscbk (IN): callbacks
	 *  idObj (IN): id of the object
	 *  &pilsobj (OUT): object ilsobj
	*/

	LSERR (WINAPI* pfnDestroyILSObj)(PILSOBJ);
	/* DestroyILSObj
	 *  pilsobj (IN): object ilsobj
	*/

	LSERR (WINAPI* pfnSetDoc)(PILSOBJ, PCLSDOCINF);
	/* SetDoc
	 *  pilsobj (IN): object ilsobj
	 *  lsdocinf (IN): initialization data at document level
	*/

	LSERR (WINAPI* pfnCreateLNObj)(PCILSOBJ, PLNOBJ*);
	/* CreateLNObj
	 *  pilsobj (IN): object ilsobj
	 *  &plnobj (OUT): object lnobj
	*/

	LSERR (WINAPI* pfnDestroyLNObj)(PLNOBJ);
	/* DestroyLNObj
	 *  plnobj (OUT): object lnobj
	*/

	LSERR (WINAPI* pfnFmt)(PLNOBJ, PCFMTIN, FMTRES*);
	/* Fmt
	 *  plnobj (IN): object lnobj
	 *  pfmtin (IN): formatting input
	 *  &fmtres (OUT): formatting result
	*/

	LSERR (WINAPI* pfnFmtResume)(PLNOBJ, const BREAKREC*, DWORD, PCFMTIN, FMTRES*);
	/* FmtResume
	 *  plnobj (IN): object lnobj
	 *  rgBreakRecord (IN): array of break records
	 *	nBreakRecord (IN): size of the break records array
	 *  pfmtin (IN): formatting input
	 *  &fmtres (OUT): formatting result
	*/

	LSERR (WINAPI* pfnGetModWidthPrecedingChar)(PDOBJ, PLSRUN, PLSRUN, PCHEIGHTS, WCHAR, MWCLS, long*);
	/* GetModWidthPrecedingChar
	 *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the preceding char
     *  heightsRef (IN): height info about character
	 *  wchar (IN): preceding character
	 *  mwcls (IN): ModWidth class of preceding character
	 *  &durChange (OUT): amount by which width of the preceding char is to be changed
	*/

	LSERR (WINAPI* pfnGetModWidthFollowingChar)(PDOBJ, PLSRUN, PLSRUN, PCHEIGHTS, WCHAR, MWCLS, long*);
	/* GetModWidthPrecedingChar
	 *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the following char
     *  heightsRef (IN): height info about character
	 *  wchar (IN): following character
	 *  mwcls (IN): ModWidth class of the following character
	 *  &durChange (OUT): amount by which width of the following char is to be changed
	*/

	LSERR (WINAPI* pfnTruncateChunk)(PCLOCCHNK, PPOSICHNK);
	/* Truncate
	 *  plocchnk (IN): locchnk to truncate
	 *  posichnk (OUT): truncation point
	*/

	LSERR (WINAPI* pfnFindPrevBreakChunk)(PCLOCCHNK, PCPOSICHNK, BRKCOND, PBRKOUT);
	/* FindPrevBreakChunk
	 *  plocchnk (IN): locchnk to break
	 *  pposichnk (IN): place to start looking for break
	 *  brkcond (IN): recommmendation about the break after chunk
	 *  &brkout (OUT): results of breaking
	*/

	LSERR (WINAPI* pfnFindNextBreakChunk)(PCLOCCHNK, PCPOSICHNK, BRKCOND, PBRKOUT);
	/* FindNextBreakChunk
	 *  plocchnk (IN): locchnk to break
	 *  pposichnk (IN): place to start looking for break
	 *  brkcond (IN): recommmendation about the break before chunk
	 *  &brkout (OUT): results of breaking
	*/

	LSERR (WINAPI* pfnForceBreakChunk)(PCLOCCHNK, PCPOSICHNK, PBRKOUT);
	/* ForceBreakChunk
	 *  plocchnk (IN): locchnk to break
	 *  pposichnk (IN): place to start looking for break
	 *  &brkout (OUT): results of breaking
	*/

	LSERR (WINAPI* pfnSetBreak)(PDOBJ, BRKKIND, DWORD, BREAKREC*, DWORD*);
	/* SetBreak
	 *  pdobj (IN): dobj which is broken
	 *  brkkind (IN): Previous/Next/Force/Imposed was chosen
	 *	nBreakRecord (IN): size of array
	 *  rgBreakRecord (OUT): array of break records
	 *	nActualBreakRecord (OUT): actual number of used elements in array
	*/

	LSERR (WINAPI* pfnGetSpecialEffectsInside)(PDOBJ, UINT*);
	/* GetSpecialEffects
	 *  pdobj (IN): dobj
	 *  &EffectsFlags (OUT): Special effects inside of this object
	*/

	LSERR (WINAPI* pfnFExpandWithPrecedingChar)(PDOBJ, PLSRUN, PLSRUN, WCHAR, MWCLS, BOOL*);
	/* FExpandWithPrecedingChar
	 *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the preceding char
	 *  wchar (IN): preceding character
	 *  mwcls (IN): ModWidth class of preceding character
	 *  &fExpand (OUT): expand preceding character?
	*/

	LSERR (WINAPI* pfnFExpandWithFollowingChar)(PDOBJ, PLSRUN, PLSRUN, WCHAR, MWCLS, BOOL*);
	/* FExpandWithFollowingChar
	 *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the following char
	 *  wchar (IN): following character
	 *  mwcls (IN): ModWidth class of the following character
	 *  &fExpand (OUT): expand object?
	*/
	LSERR (WINAPI* pfnCalcPresentation)(PDOBJ, long, LSKJUST, BOOL);
	/* CalcPresentation
	 *  pdobj (IN): dobj
	 *  dup (IN): dup of dobj
	 *  lskj (IN): current justification mode
	 *  fLastVisibleOnLine (IN): this object is last visible object on line
	*/

	LSERR (WINAPI* pfnQueryPointPcp)(PDOBJ, PCPOINTUV, PCLSQIN, PLSQOUT);
	/* QueryPointPcp
	 *  pdobj (IN): dobj to query
	 * 	ppointuvQuery (IN): query point (uQuery,vQuery)
     *	plsqin (IN): query input
     *	plsqout (OUT): query output
	*/
	
	LSERR (WINAPI* pfnQueryCpPpoint)(PDOBJ, LSDCP, PCLSQIN, PLSQOUT);
	/* QueryCpPpoint
	 *  pdobj (IN): dobj to query
	 *  dcp (IN):  dcp for the query
     *	plsqin (IN): query input
     *	plsqout (OUT): query output
	*/

	LSERR (WINAPI* pfnEnum)(PDOBJ, PLSRUN, PCLSCHP, LSCP, LSDCP, LSTFLOW, BOOL,
												BOOL, const POINT*, PCHEIGHTS, long);
	/* Enum object
	 *  pdobj (IN): dobj to enumerate
	 *  plsrun (IN): from DNODE
	 *  plschp (IN): from DNODE
	 *  cpFirst (IN): from DNODE
	 *  dcp (IN): from DNODE
	 *  lstflow (IN): text flow
	 *  fReverseOrder (IN): enumerate in reverse order
	 *  fGeometryNeeded (IN):
	 *  pptStart (IN): starting position, iff fGeometryNeeded
	 *  pheightsPres(IN): from DNODE, relevant iff fGeometryNeeded
	 *  dupRun(IN): from DNODE, relevant iff fGeometryNeeded
	*/

	LSERR (WINAPI* pfnDisplay)(PDOBJ, PCDISPIN);
	/* Display
	 *  pdobj (IN): dobj to display
	 *  pdispin (IN): input display info
	*/

	LSERR (WINAPI* pfnDestroyDObj)(PDOBJ);
	/* DestroyDObj
	 *  pdobj (IN): dobj to destroy
	*/

} LSIMETHODS;

#endif /* LSIMETH_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lskjust.h ===
#ifndef LSKJUST_DEFINED
#define LSKJUST_DEFINED

enum lskjust							/* kinds of para justification */
{
	lskjNone,
	lskjFullInterWord,
	lskjFullInterLetterAligned,
	lskjFullScaled,
	lskjFullGlyphs,
	lskjSnapGrid
};

typedef enum lskjust LSKJUST;

#endif /* !LSKJUST_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsfgi.h ===
#ifndef LSFGI_DEFINED
#define LSFGI_DEFINED

#include "lsdefs.h"
#include "lstflow.h"
#include "plsfgi.h"

/* ------------------------------------------------------------------------ */

struct lsfgi							/* Formatter geometry input */
{
	BOOL fFirstOnLine;	/* REVIEW sergeyge(elik): Query instead of this member? */
	LSCP cpFirst;
	long urPen,vrPen;
	long urColumnMax;
	LSTFLOW lstflow;
};
typedef struct lsfgi LSFGI;

#endif /* !LSFGI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsktab.h ===
#ifndef LSKTAB_DEFINED
#define LSKTAB_DEFINED

#include "lsdefs.h"


enum lsktab								/* Kinds of tabs */
{
	lsktLeft,
	lsktCenter,
	lsktRight,
	lsktDecimal,
	lsktChar
};

typedef enum lsktab LSKTAB;


#endif  /* !LSKTAB_DEFINED     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lspairac.h ===
#ifndef LSPAIRAC_DEFINED
#define LSPAIRAC_DEFINED

#include "lsdefs.h"
#include "lsact.h"


typedef struct lspairact				/* Mod width pair unit				*/
{
	LSACT lsactFirst;					/* Action on first char				*/
	LSACT lsactSecond;					/* Action on second char			*/
} LSPAIRACT;									


#endif /* !LSPAIRAC_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsksplat.h ===
#ifndef LSKSPLAT_DEFINED
#define LSKSPLAT_DEFINED

enum lsksplat							/* Kind of splat */
{
	lsksplPageBreak,
	lsksplColumnBreak,
	lsksplSectionBreak
};

#endif /* !LSKSPLAT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsqin.h ===
#ifndef LSQIN_DEFINED
#define LSQIN_DEFINED

#include "lsdefs.h"
#include "heights.h"
#include "lstflow.h"
#include "plsrun.h"
#include "plsqin.h"

typedef struct lsqin			
{
	LSTFLOW	lstflowSubline;
	PLSRUN plsrun;					/* PLSRUN this cp belongs to */
	LSCP cpFirstRun;
	LSDCP dcpRun;
	HEIGHTS	heightsPresRun;			/* In direction lstflowSubline */
	long dupRun;					/* In direction lstflowSubline			*/
	long dvpPosRun;					/* in direction of lstflowSubline	*/

} LSQIN;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lspract.h ===
#ifndef LSPRACT_DEFINED
#define LSPRACT_DEFINED

#include "lsdefs.h"
#include "lsact.h"

#define prior0					0		/* means priority is not defined	*/
#define prior1					1
#define prior2					2
#define prior3					3
#define prior4					4
#define prior5					5

typedef struct lspract					/* prioritized action 				*/
{
	BYTE prior;							/* priority							*/
	LSACT lsact;						/* action							*/
} LSPRACT;									


#endif /* !LSPRACTION_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lskysr.h ===
#ifndef LSKYSR_DEFINED
#define LSKYSR_DEFINED

/* kysr codes: for LSCHP.kysr - Kind of YSR */
#define	kysrNil				0		/* No Hyphenation				*/
#define kysrNormal			1		/* Normal Hyphenation			*/
#define kysrAddBefore		2		/* Add letter before hyphen		*/
#define kysrChangeBefore	3		/* Change letter before hyphen	*/
#define kysrDeleteBefore	4		/* Delete letter before hyphen	*/
#define kysrChangeAfter		5		/* Change letter after hyphen	*/
#define kysrDelAndChange	6		/* Delete letter before the hyphen and */
									/* change the letter preceding the ... */

#endif /* !LSKYSR_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lslinfo.h ===
#ifndef LSLINFO_DEFINED
#define LSLINFO_DEFINED

#include "lsdefs.h"
#include "endres.h"

typedef struct
{
	long dvpAscent;
	long dvrAscent;
	long dvpDescent;
	long dvrDescent;

	long dvpMultiLineHeight;
	long dvrMultiLineHeight;

	long dvpAscentAutoNumber;
	long dvrAscentAutoNumber;
	long dvpDescentAutoNumber;
	long dvrDescentAutoNumber;

	LSCP cpLim;					/* First cp which is NOT on this line */
	LSDCP dcpDepend;			/* # of chars wrapped to next line  */
	LSCP cpFirstVis;			/* First actual (not hidden) character in a line*/
								/* allows client to use character properties from the correct paragraph */


	ENDRES endr;				/* How line ended */
	BOOL fAdvanced;
	long vaAdvance;				/* Valid iff (fAdvanced != 0) */

	BOOL fFirstLineInPara;
	BOOL fTabInMarginExLine;
	BOOL fForcedBreak;

	DWORD nDepthFormatLineMax;  /* Formatting depth of the line (1--for plain line) */

	UINT EffectsFlags;			/* set of client defined special effects flags */
} LSLINFO;

#endif /* !LSLINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lspap.h ===
#ifndef LSPAP_DEFINED
#define LSPAP_DEFINED

#include "lsdefs.h"
#include "plspap.h"
#include "lskjust.h"
#include "lskalign.h"
#include "lsbrjust.h"
#include "lskeop.h"
#include "lstflow.h"

/* ---------------------------------------------------------------------- */

struct lspap
{
	LSCP cpFirst;						/* 1st cp for this paragraph */
	LSCP cpFirstContent;				/* 1st cp of "content" in the para */

	DWORD grpf;							/* line services format flags (lsffi.h)*/

	long uaLeft;						/* left boundary for line				*/
	long uaRightBreak;					/* right boundary for break */
	long uaRightJustify;					/* right boundary for justification */
	long duaIndent;
	long duaHyphenationZone;

	LSBREAKJUST lsbrj;					/* Break/Justification behavior	*/
	LSKJUST lskj;						/* Justification type */
	LSKALIGN lskal;						/* Alignment type */

	long duaAutoDecimalTab;

	LSKEOP lskeop;						/* kind of paragraph ending */
	
	LSTFLOW lstflow;					/* Main text flow direction */

};

typedef struct lspap LSPAP;

#endif /* !LSPAP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsqline.h ===
#ifndef LSQLINE_DEFINED
#define LSQLINE_DEFINED

#include "lsdefs.h"
#include "plsline.h"
#include "plsqsinf.h"
#include "plscell.h"
#include "pcelldet.h"
#include "gprop.h"

LSERR WINAPI  LsQueryLineCpPpoint(
							PLSLINE,	/* IN: pointer to line info -- opaque to client	*/
							LSCP,		/* IN: cpQuery									*/
							DWORD,      /* IN: nDepthQueryMax							*/
							PLSQSUBINFO,/* OUT: array[nDepthQueryMax] of LSQSUBINFO		*/
							DWORD*,		 /* OUT: nActualDepth							*/
							PLSTEXTCELL);/* OUT: Text cell info							*/


LSERR WINAPI LsQueryLinePointPcp(
							PLSLINE,	/* IN: pointer to line -- opaque to client			*/
						 	PCPOINTUV,	/* IN: query point (uQuery,vQuery) (line text flow)	*/
							DWORD,      /* IN: nDepthQueryMax								*/
							PLSQSUBINFO,/* OUT: array[nDepthQueryMax] of LSQSUBINFO			*/
							DWORD*,      /* OUT: nActualDepth	*/
							PLSTEXTCELL);/* OUT: Text cell info */

LSERR WINAPI LsQueryTextCellDetails(
							PLSLINE,	/* IN: pointer to line -- opaque to client				*/
						 	PCELLDETAILS,/* IN: query point (uQuery,vQuery) (line text flow)	*/
							LSCP,		/* IN: cpStartCell										*/
							DWORD,		/* IN: nCharsInContext									*/
							DWORD,		/* IN: nGlyphsInContext									*/
							WCHAR*,		/* OUT: pointer array[nCharsInContext] of char codes	*/
							PGINDEX,	/* OUT: pointer array[nGlyphsInContext] of glyph indices*/
							long*,		/* OUT: pointer array[nGlyphsInContext] of glyph widths	*/
							PGOFFSET,	/* OUT: pointer array[nGlyphsInContext] of glyph offsets*/
							PGPROP);	/* OUT: pointer array[nGlyphsInContext] of glyph handles*/

/*
 *	Query point and output point are in the coordinate system of the line.
 *	Text flow is the text flow of the line, zero point is at the starting point of the line. 
 */


LSERR WINAPI LsQueryLineDup(PLSLINE,	/* IN: pointer to line -- opaque to client	*/
							long*,		/* OUT: upStartAutonumberingText			*/
							long*,		/* OUT: upLimAutonumberingText				*/
							long*,		/* OUT: upStartMainText						*/
							long*,		/* OUT: upStartTrailing						*/
							long*);		/* OUT: upLimLine							*/

LSERR WINAPI LsQueryFLineEmpty(
							PLSLINE,	/* IN: pointer to line -- opaque to client 	*/
							BOOL*);		/* OUT: Is line empty? 						*/

#endif /* !LSQLINE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsqsinfo.h ===
#ifndef LSQSINFO_DEFINED
#define LSQSINFO_DEFINED

#include "lsdefs.h"
#include "heights.h"
#include "lstflow.h"
#include "plsrun.h"
#include "plsqsinf.h"


typedef struct lsqsubinfo			
{
	LSTFLOW	lstflowSubline;
	LSCP cpFirstSubline;
	LSDCP dcpSubline;
 	POINTUV pointUvStartSubline;	/* In coordinate system of main line/subline */
	HEIGHTS	heightsPresSubline;		/* In direction lstflowSubline */
	long dupSubline;				/* In direction lstflowSubline			*/


	DWORD idobj;
	PLSRUN plsrun;
	LSCP cpFirstRun;
	LSDCP dcpRun;
 	POINTUV pointUvStartRun;		/* In coordinate system of main line/subline */
	HEIGHTS	heightsPresRun;			/* In direction lstflowSubline */
	long dupRun;					/* In direction lstflowSubline			*/
	long dvpPosRun;					/* in direction of lstflowSubline	*/

	long dupBorderBefore;			/* in direction of lstflowSubline	*/
	long dupBorderAfter;			/* in direction of lstflowSubline	*/

 	POINTUV pointUvStartObj;		/* Set by Object, translated to coord system of main line/subline */
	HEIGHTS	heightsPresObj;			/* Set by Object, in direction lstflowSubline */
	long dupObj;					/* Set by Object, in direction lstflowSubline			*/


} LSQSUBINFO;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsqsubl.h ===
#ifndef LSQSUBL_DEFINED
#define LSQSUBL_DEFINED

/* Line services formatter fetch/dispatcher interface (to LsCreateLine())
 */

#include "lsdefs.h"
#include "plssubl.h"
#include "plsqsinf.h"
#include "plscell.h"

LSERR WINAPI LsQueryCpPpointSubline(
							PLSSUBL,		/* IN: subline context			*/
							LSCP, 			/* IN: cpQuery 					*/
							DWORD,      	/* IN: nDepthQueryMax			*/
							PLSQSUBINFO,	/* OUT: array[nDepthQueryMax] of LSQSUBINFO	*/
							DWORD*,			/* OUT: nActualDepth			*/
							PLSTEXTCELL);	/* OUT: Text cell info			*/
							
LSERR WINAPI LsQueryPointPcpSubline(
							PLSSUBL,		/* IN: subline context			*/
						 	PCPOINTUV,		/* IN: query point from the subline beginning */
							DWORD,      	/* IN: nDepthQueryMax			*/
							PLSQSUBINFO,	/* OUT: array[nDepthQueryMax] of LSQSUBINFO */
							DWORD*,		 	/* OUT: nActualDepth			*/
							PLSTEXTCELL);	/* OUT: Text cell info			*/


#endif /* !LSQSUBL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsqout.h ===
#ifndef LSQOUT_DEFINED
#define LSQOUT_DEFINED

#include "lsdefs.h"
#include "heights.h"
#include "lscell.h"
#include "plssubl.h"
#include "plsqout.h"


typedef struct lsqout			
{
 	POINTUV pointUvStartObj;		/* In coordinate system of parent subline
										relative to the beginning of dnode	*/
	HEIGHTS	heightsPresObj;			/* In direction of parent subline */
	long dupObj;					/* In direction lstflowSubline			*/

	LSTEXTCELL lstextcell;			/* in coordinate system of parent subline,
										relative to the beginning of dnode	*/

	PLSSUBL plssubl;
 	POINTUV pointUvStartSubline;	/* In coordinate system of parent subline
										relative to the beginning of dnode	*/

} LSQOUT;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lssetdoc.h ===
#ifndef LSSETDOC_DEFINED
#define LSSETDOC_DEFINED

#include "lsdefs.h"
#include "lsdevres.h"
#include "lspract.h"
#include "lspairac.h"
#include "lsexpan.h"
#include "lsbrk.h"

LSERR WINAPI LsSetDoc(PLSC,				/* IN: ptr to line services context */
					  BOOL,				/* IN: Intend to display? 			*/
					  BOOL,				/* IN: Ref & Pres Devices are equal?*/
					  const LSDEVRES*); /* IN: device resolutions 			*/

LSERR WINAPI LsSetModWidthPairs(
					  PLSC,				/* IN: ptr to line services context */
					  DWORD,			/* IN: Number of mod pairs info units*/ 
					  const LSPAIRACT*,	/* IN: Mod pairs info units array  */
					  DWORD,			/* IN: Number of Mod Width classes	*/
					  const BYTE*);		/* IN: Mod width information(square):
											  indexes in the LSPAIRACT array */
LSERR WINAPI LsSetCompression(
					  PLSC,				/* IN: ptr to line services context */
					  DWORD,			/* IN: Number of compression priorities*/
					  DWORD,			/* IN: Number of compression info units*/
					  const LSPRACT*,	/* IN: Compession info units array 	*/
					  DWORD,			/* IN: Number of Mod Width classes	*/
					  const BYTE*);		/* IN: Compression information:
											  indexes in the LSPRACT array  */
LSERR WINAPI LsSetExpansion(
					  PLSC,				/* IN: ptr to line services context */
					  DWORD,			/* IN: Number of expansion info units*/
					  const LSEXPAN*,	/* IN: Expansion info units array	*/
					  DWORD,			/* IN: Number of Mod Width classes	*/
					  const BYTE*);		/* IN: Expansion information(square):
											  indexes in the LSEXPAN array  */
LSERR WINAPI LsSetBreaking(
					  PLSC,				/* IN: ptr to line services context */
					  DWORD,			/* IN: Number of breaking info units*/
					  const LSBRK*,		/* IN: Breaking info units array	*/
					  DWORD,			/* IN: Number of breaking classes	*/
					  const BYTE*);		/* IN: Breaking information(square):
											  indexes in the LSBRK array  */


#endif /* !LSSETDOC_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lstabs.h ===
#ifndef LSTABS_DEFINED
#define LSTABS_DEFINED

#include "lsdefs.h"
#include "lsktab.h"

/* ---------------------------------------------------------------------- */


/* ---------------------------------------------------------------------- */

typedef struct
{
	enum lsktab lskt;					/* Kind of tab */
	long ua;							/* tab position */
	WCHAR wchTabLeader;					/* character for tab leader */
										/*   if 0, no leader is used*/
	WCHAR wchCharTab;					/* Character for CharTab	*/
} LSTBD;

/* ---------------------------------------------------------------------- */

typedef struct lstabs
{
	long duaIncrementalTab;				/* "Default" tab behavior */
	DWORD iTabUserDefMac;
	LSTBD* pTab;				
} LSTABS;


#endif /* !LSTABS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsstinfo.h ===
#ifndef LSSTINFO_DEFINED
#define LSSTINFO_DEFINED

#include "lsdefs.h"
#include "plsstinf.h"

/* 
 * all strikethrough offsets are relative to the baseline and positive upwards (filled page direction),
 * so normally dvpLowerStrikethroughOffset > 0 and if cNumberOfLines == 2
 * dvpLowerStrikethroughOffset < dvpUpperStrikethroughOffset
 */

struct lsstinfo
{
    UINT  kstbase;						/* base kind of strikethrough  */
    DWORD cNumberOfLines;				/* number of lines: possible values 1,2*/

	long dvpLowerStrikethroughOffset ;	/* if NumberOfLines != 2 only data for 
											lower line should be filled in */
	long dvpLowerStrikethroughSize;
	long dvpUpperStrikethroughOffset;	
	long dvpUpperStrikethroughSize;

};
typedef struct lsstinfo LSSTINFO;


#endif /* !LSSTINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lstflow.h ===
#ifndef LSTFLOW_DEFINED
#define LSTFLOW_DEFINED

#include "lsdefs.h"

typedef DWORD  LSTFLOW;

#define lstflowDefault	0  

#define lstflowES		0  
#define lstflowEN		1  
#define lstflowSE		2  
#define lstflowSW		3  
#define lstflowWS		4  
#define lstflowWN		5  
#define lstflowNE		6  
#define lstflowNW		7  

/*
 *	The eight possible text flows are listed clockwise starting with default (Latin) one.
 *
 *	lstflowES is the coordinate system used when line grows to East and text grows to South.
 *	(Next letter is to the right (east) of previous, next line is created below (south) the previous.) 
 *
 *	For lstflowES positive u moves to the right, positive v moves up. (V axis is always in the direction
 *	of ascender, opposite to text growing direction.
 *
 *	Notice it is not the way axes are pointing in the default Windows mapping mode MM_TEXT. 
 *	In MM_TEXT vertical (y) axis increase from top to bottom, 
 *	in lstflowES vertical (v) axis increase from bottom to top.
 */
 
#define fUDirection			0x00000004L
#define fVDirection			0x00000001L
#define fUVertical			0x00000002L

/*
 *	The three bits that constitute lstflow happens to have well defined meanings.
 *
 *	Middle bit: on for vertical writing, off for horizontal.
 *	First (low value) bit: "on" means v-axis points right or down (positive).
 *	Third bit: "off" means u-axis points right or down (positive).
 *
 * See examples of usage in lstfset.c
 *
 */


#endif /* !LSTFLOW_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lssubset.h ===
#ifndef LSSUBSET_DEFINED
#define LSSUBSET_DEFINED

/* Access routines for contents of DNODES */

#include "lsdefs.h"
#include "plsrun.h"
#include "plssubl.h"
#include "pobjdim.h"
#include "lstflow.h"

			
LSERR WINAPI LssbGetObjDimSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							LSTFLOW*,			/* OUT: subline's lstflow		*/
					 	    POBJDIM);			/* OUT: dimensions of subline	*/
							
LSERR WINAPI LssbGetDupSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							LSTFLOW*,			/* OUT: subline's lstflow		*/
					 	    long*);				/* OUT: dup of subline			*/

LSERR WINAPI LssbFDonePresSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							BOOL*);				/* OUT: Is it CalcPres'd		*/

LSERR WINAPI LssbFDoneDisplay(
							PLSSUBL,			/* IN: Subline Context			*/
							BOOL*);				/* OUT: Is it displayed			*/

LSERR WINAPI LssbGetPlsrunsFromSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							DWORD,				/* IN: N of DNODES in subline	*/
							PLSRUN*);			/* OUT: array of PLSRUN's		*/

LSERR WINAPI LssbGetNumberDnodesInSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							DWORD*);			/* OUT: N of DNODES in subline	*/

LSERR WINAPI LssbGetVisibleDcpInSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							LSDCP*);			/* OUT: N of characters			*/

LSERR WINAPI LssbGetDurTrailInSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							long*);				/* OUT: width of trailing area	*/
	
LSERR WINAPI LssbGetDurTrailWithPensInSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							long*);				/* OUT: width of trailing area
													including pens in subline	*/
LSERR WINAPI LssbFIsSublineEmpty(
							PLSSUBL plssubl,	/* IN: subline					*/
							BOOL*  pfEmpty);	/* OUT:is this subline empty	*/


#endif /* !LSSUBSET_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lsulinfo.h ===
#ifndef LSULINFO_DEFINED
#define LSULINFO_DEFINED

#include "lsdefs.h"
#include "plsulinf.h"

/* 
 * Both Offsets are relative to the local baseline and positive "down" (towards blank page), 
 * so in horizontal Latin case dvpFirstUnderlineOffset usually is bigger than zero. 
 *
 * dvpUnderlineOrigin points to UnderlineOrigin - the place where (main part of the) letter ends and 
 * area for underlining begins. For Latin letters it is the Latin baseline. UnderlineOrigin shows if
 * one run of two runs is higher; runs with the same UnderlineOrigin can have their underlines averaged.
 *
 * dvpFirstUnderlineOffset points to the beginning of the closest to the UnderlineOrigin underline.
 * You have "underlining from above" case if dvpUnderlineOrigin > dvpFirstUnderlineOffset.
 *
 * Everything else should be positive. Instead of dvpSecondUnderlineOffset of the previous version dvpGap 
 * is used. Second underline is further away from the UnderlineOrigin than first underline, so
 * dvpSecondUnderlineOffset = dvpFirstUnderlineOffset + dvpFirstUnderlineSize + dvpGap in normal case.
 * In "underlining from above" case there will be minuses instead of pluses.
 *
 * Main merging rules: 
 *
 * LS will not merge runs with different kulbase or different cNumberOfLines.
 * LS will not merge runs with different negative dvpPos (subscripts)
 * LS will not merge subscripts with superscripts or baseline runs
 * LS will not merge "underlined above" run with "underlined below" run.
 *
 * If merging is possible: 
 * Runs with the same UnderlineOrigin are averaged.
 * If UnderlineOrigins are different, the run with higher UnderlineOrigin takes metrics from neighbor.
 */

struct lsulinfo
{
    UINT  kulbase;						/* base kind of underline */
    DWORD cNumberOfLines;				/* number of lines: possible values 1,2*/

	long dvpUnderlineOriginOffset;		/* UnderlineOrigin decides which run is higher */
	long dvpFirstUnderlineOffset;		/* offset for start of the (first) underline */
	long dvpFirstUnderlineSize;			/* width of the (first) underline */
	
	long dvpGapBetweenLines;			/* If NumberOfLines != 2, dvpGapBetweenLines */
	long dvpSecondUnderlineSize;		/* 	and dvpSecondUnderlineSize are ignored. */
	
};
typedef struct lsulinfo LSULINFO;


#endif /* !LSULINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lstxm.h ===
#ifndef LSTXM_DEFINED
#define LSTXM_DEFINED

#include "lsdefs.h"
#include "plstxm.h"
/*igorzv** good explanation according text flow issue is needed here /
/* A few words about the v-vector and the sign bit: 
 *
 * dvDescent is positive downwards.		
 * v is positive upwards during formatting.
 */

struct lstxm
{
	long dvAscent;
	long dvDescent;

	long dvMultiLineHeight;
	BOOL fMonospaced;
};
typedef struct lstxm LSTXM;


#endif /* !LSTXM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\mwcls.h ===
#ifndef MWCLS_DEFINED
#define MWCLS_DEFINED

#include "lsdefs.h"

typedef BYTE MWCLS;

#endif /* !MWCLS_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\objdim.h ===
#ifndef OBJDIM_DEFINED
#define OBJDIM_DEFINED

#include "lsdefs.h"
#include "pobjdim.h"
#include "heights.h"

typedef struct objdim							/* Object dimensions */
{
	HEIGHTS heightsRef;	
	HEIGHTS heightsPres;	
	long dur;
} OBJDIM;

#endif /* !OBJDIM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lstfset.h ===
#ifndef LSTFSET_DEFINED
#define LSTFSET_DEFINED

/* Service routines for some standard text flow change tasks */

#include "lsdefs.h"
#include "lstflow.h"

/* 
 * LsPointXYFromPointUV calculates pointxyOut given (x,y) pointxyIn and (u,v) vector 
 *  
 *  (pointxyOut = pointxyIn + vectoruv)
 */

LSERR WINAPI LsPointXYFromPointUV(const POINT*, 	/* IN: input point (x,y) */
									LSTFLOW,	 	/* IN: text flow for */
									PCPOINTUV,		/* IN: vector in (u,v) */
									POINT*);		/* OUT: (x,y) point */


/* 
 * LsPointUV1FromPointUV2 calculates vector in uv2 coordinates given begin and end of it in uv1.
 *  
 *  (vectorUV22 = pointUV1b - pointUV1a)
 *
 *	Usually pointUV1a is the starting point of uv2 coordinate system and it is easier to think 
 *		about output vector as a point in it.
 */

LSERR WINAPI LsPointUV2FromPointUV1(LSTFLOW,	 	/* IN: text flow 1 (TF1) */
									PCPOINTUV,	 	/* IN: starting point (TF1) */
									PCPOINTUV,		/* IN: ending point (TF1) */
									LSTFLOW,	 	/* IN: text flow 2 (TF2) */
									PPOINTUV);		/* OUT: vector in TF2 */


#endif /* !LSTFSET_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\lstxtcfg.h ===
#ifndef LSTXTCFG_DEFINED
#define LSTXTCFG_DEFINED

#include "lsdefs.h"
#include "plstxtcf.h"

typedef struct lstxtcfg
{
	long cEstimatedCharsPerLine;

	WCHAR wchUndef;
	WCHAR wchNull;
	WCHAR wchSpace;
	WCHAR wchHyphen;
	WCHAR wchTab;
	WCHAR wchEndPara1;
	WCHAR wchEndPara2;
	WCHAR wchAltEndPara;
	WCHAR wchEndLineInPara;				/* Word "CCRJ", */
	WCHAR wchColumnBreak;
	WCHAR wchSectionBreak;
	WCHAR wchPageBreak;
	WCHAR wchNonBreakSpace;				/* char code of non-breaking space */
	WCHAR wchNonBreakHyphen;
	WCHAR wchNonReqHyphen;				/* discretionary hyphen */
	WCHAR wchEmDash;
	WCHAR wchEnDash;
	WCHAR wchEmSpace;
	WCHAR wchEnSpace;
	WCHAR wchNarrowSpace;
	WCHAR wchOptBreak;
	WCHAR wchNoBreak;
	WCHAR wchFESpace;
	WCHAR wchJoiner;
	WCHAR wchNonJoiner;
	WCHAR wchToReplace;					/* backslash in FE Word				*/
	WCHAR wchReplace;					/* Yen in FE Word				*/


	WCHAR wchVisiNull;					/* visi char for wch==wchNull		*/
	WCHAR wchVisiAltEndPara;			/* visi char for end "table cell"	*/
	WCHAR wchVisiEndLineInPara;			/* visi char for wchEndLineInPara	*/
	WCHAR wchVisiEndPara;				/* visi char for "end para"			*/
	WCHAR wchVisiSpace;					/* visi char for "space"			*/
	WCHAR wchVisiNonBreakSpace;			/* visi char for wchNonBreakSpace	*/
	WCHAR wchVisiNonBreakHyphen;		/* visi char for wchNonBreakHyphen	*/
	WCHAR wchVisiNonReqHyphen;			/* visi char for wchNonReqHyphen	*/
	WCHAR wchVisiTab;					/* visi char for "tab"				*/
	WCHAR wchVisiEmSpace;				/* visi char for wchEmSpace			*/
	WCHAR wchVisiEnSpace;				/* visi char for wchEnSpace			*/
	WCHAR wchVisiNarrowSpace;			/* visi char for wchNarrowSpace		*/
	WCHAR wchVisiOptBreak;              /* visi char for wchOptBreak		*/
	WCHAR wchVisiNoBreak;				/* visi char for wchNoBreak			*/
	WCHAR wchVisiFESpace;				/* visi char for wchOptBreak		*/

	WCHAR wchEscAnmRun;

	WCHAR wchPad;
} LSTXTCFG;

#endif /* !LSTXTCFG_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\pcelldet.h ===
#ifndef PCELLDET_DEFINED
#define PCELLDET_DEFINED

struct celldetails;
typedef struct celldetails* PCELLDETAILS;

#endif /* !PCELLDET_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\pdispi.h ===
#ifndef PDISPI_DEFINED
#define PDISPI_DEFINED

struct dispin;
typedef const struct dispin *PCDISPIN;

#endif /* !PDISPI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\pdobj.h ===
#ifndef PDOBJ_DEFINED
#define PDOBJ_DEFINED

struct dobj;
typedef struct dobj* PDOBJ;

#endif /* PDOBJ_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\pbrko.h ===
#ifndef PBRKO_DEFINED
#define PBRKO_DEFINED

struct brkout;
typedef struct brkout* PBRKOUT;

#endif /* !PBRKO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\pilsobj.h ===
#ifndef PILSOBJ_DEFINED
#define PILSOBJ_DEFINED

struct ilsobj;

typedef struct ilsobj* PILSOBJ;
typedef const PILSOBJ PCILSOBJ;

#endif /* PILSOBJ_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\pheights.h ===
#ifndef PHEIGHTS_DEFINED
#define PHEIGHTS_DEFINED

struct heights;
typedef struct heights* PHEIGHTS;
typedef const struct heights* PCHEIGHTS;

#endif /* !POBJDIME_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\plnobj.h ===
#ifndef PLNOBJ_DEFINED
#define PLNOBJ_DEFINED

struct lnobj;
typedef struct lnobj* PLNOBJ;

#endif /* PLNOBJ_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\pfmti.h ===
#ifndef PFMTI_DEFINED
#define PFMTI_DEFINED

struct fmtin;
typedef const struct fmtin *PCFMTIN;

#endif /* !PFMTI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\plscbk.h ===
#ifndef PLSCBK_DEFINED
#define PLSCBK_DEFINED

struct lscbk;
typedef struct lscbk* PLSCBK;
typedef const struct lscbk* PCLSCBK;

#endif /* !PLSCBK_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\plocchnk.h ===
#ifndef PLOCCHNK_DEFINED
#define PLOCCHNK_DEFINED

struct locchnk;
typedef const struct locchnk* PCLOCCHNK;
typedef struct locchnk* PLOCCHNK;

#endif /* !PLSLOCCH_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\plscell.h ===
#ifndef PLSCELL_DEFINED
#define PLSCELL_DEFINED

struct lstextcell;
typedef struct lstextcell* PLSTEXTCELL;
typedef const struct lstextcell* PCLSTEXTCELL;

#endif /* !PLSCELL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\plsems.h ===
#ifndef PLSEMS_DEFINED
#define PLSEMS_DEFINED

struct lsems;

typedef struct lsems* PLSEMS;

#endif /* !PLSEMS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\plschp.h ===
#ifndef PLSCHP_DEFINED
#define PLSCHP_DEFINED

struct lschp;
typedef struct lschp* PLSCHP;
typedef const struct lschp* PCLSCHP;

#endif /* !PLSCHP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\plsfgi.h ===
#ifndef PLSFGI_DEFINED
#define PLSFGI_DEFINED

struct lsfgi;
typedef struct lsfgi* PLSFGI;

#endif /* !PLSFGI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\plsdocin.h ===
#ifndef PLSDOCINF_DEFINED
#define PLSDOCINF_DEFINED

struct lsdocinf;
typedef const struct lsdocinf* PCLSDOCINF;
#endif /* !PLSDOCINF_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\plsdnode.h ===
#ifndef PLSDNODE_DEFINED
#define PLSDNODE_DEFINED

struct lsdnode;
typedef struct lsdnode* PLSDNODE;

#endif /* PLSDNODE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\plspap.h ===
#ifndef PLSPAP_DEFINED
#define PLSPAP_DEFINED

struct lspap;
typedef struct lspap* PLSPAP;

#endif /* !PLSPAP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\plsqout.h ===
#ifndef PLSQOUT_DEFINED
#define PLSQOUT_DEFINED

struct lsqout;
typedef struct lsqout* PLSQOUT;

#endif /* !PLSQOUT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\plsqsinf.h ===
#ifndef PLSQSINF_DEFINED
#define PLSQSINF_DEFINED

struct lsqsubinfo;
typedef struct lsqsubinfo* PLSQSUBINFO;
typedef const struct lsqsubinfo* PCLSQSUBINFO;

#endif /* !PLSQSINF_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\plsline.h ===
#ifndef PLSLINE_DEFINED
#define PLSLINE_DEFINED

struct lsline;
typedef struct lsline* PLSLINE;

#endif /* PLSLINE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\plsfrun.h ===
#ifndef PLSFRUN_DEFINED
#define PLSFRUN_DEFINED

struct lsfrun;
typedef struct lsfrun* PLSFRUN;
typedef const struct lsfrun* PCLSFRUN;

#endif /* PLSRUN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\plshyph.h ===
#ifndef PLSHYPH_DEFINED
#define PLSHYPH_DEFINED

struct lshyph;
typedef struct lshyph* PLSHYPH;
typedef const struct lshyph* PCLSHYPH;

#endif /* !PLSHYPH_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\plsqin.h ===
#ifndef PLSQIN_DEFINED
#define PLSQIN_DEFINED

struct lsqin;
typedef struct lsqin* PLSQIN;
typedef const struct lsqin* PCLSQIN;

#endif /* !PLSQIN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\plsrun.h ===
#ifndef PLSRUN_DEFINED
#define PLSRUN_DEFINED

struct lsrun;
typedef struct lsrun* PLSRUN;

#endif /* PLSRUN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\plsstinf.h ===
#ifndef PLSSTINFO_DEFINED
#define PLSSTINFO_DEFINED

struct lsstinfo;
typedef struct lsstinfo* PLSSTINFO;

#endif /* !PLSSTINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\plssubl.h ===
#ifndef PLSSUBL_DEFINED
#define PLSSUBL_DEFINED

struct lssubl;
typedef struct lssubl* PLSSUBL;

#endif /* PLSSUBL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\plstxtcf.h ===
#ifndef PLSTXTCF_DEFINED
#define PLSTXTCF_DEFINED

struct lstxtcfg;
typedef struct lstxtcfg *PLSTXTCFG;
typedef const struct lstxtcfg *PCLSTXTCFG;

#endif /* PLSTXTCF_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\plsulinf.h ===
#ifndef PLSULINFO_DEFINED
#define PLSULINFO_DEFINED

struct lsulinfo;
typedef struct lsulinfo* PLSULINFO;

#endif /* !PLSULINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\pobjdim.h ===
#ifndef POBJDIM_DEFINED
#define POBJDIM_DEFINED

struct objdim;
typedef struct objdim* POBJDIM;
typedef const struct objdim* PCOBJDIM;

#endif /* !POBJDIM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\posichnk.h ===
#ifndef POSICHNK_DEFINED
#define POSICHNK_DEFINED

#include "lsdefs.h"
#include "pposichn.h"

#define ichnkOutside 0xFFFFFFFF

typedef struct posichnk					/* position in chunk		*/
{
	long ichnk;							/* index in the chunk array	*/
	LSDCP dcp;							/* from beginning of dobj	*/
} POSICHNK;



#endif /* !POSICHNK_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\plstabs.h ===
#ifndef PLSTABS_DEFINED
#define PLSTABS_DEFINED

struct lstabs;
typedef struct lstabs* PLSTABS;
typedef const struct lstabs* PCLSTABS;

#endif /* PLSTABS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\plstxm.h ===
#ifndef PLSTXM_DEFINED
#define PLSTXM_DEFINED

struct lstxm;
typedef struct lstxm* PLSTXM;

#endif /* !PLSTXM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\pposichn.h ===
#ifndef PPOSICHN_DEFINED
#define PPOSICHN_DEFINED

struct posichnk;
typedef const struct posichnk* PCPOSICHNK;
typedef struct posichnk* PPOSICHNK;

#endif /* !PPOSICHN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\tatenak.h ===
#ifndef TATENAKYOKO_DEFINED
#define TATENAKYOKO_DEFINED

#include "lsimeth.h"

/*
 *
 *	Tatenakayoko object callbacks to client application
 *
 */
typedef struct TATENAKYOKOCBK
{
	LSERR (WINAPI *pfnGetTatenakayokoLinePosition)(
		POLS pols,
		LSCP cp,
		LSTFLOW lstflow,
		PLSRUN plsrun,
		long dvr,
		PHEIGHTS pheightsRef,
		PHEIGHTS pheightsPres,
		long *pdvpDescentReservedForClient);

	/* GetTatenakayokoLinePosition
	 *  pols (IN): The client context for the request.
	 *
	 *  cp (IN): the cp of the Tatenakayoko object.
	 *
	 *  lstflow (IN): the lstflow of Tatenakayoko parent subline
	 *
	 *	plsrun (IN): the plsrun of the Tatenakayoko object.
	 *
	 *	dvr	(IN): the total height of the tatenakayoko object with respect to 
	 *			the current flow of the line in reference units.
	 *
	 *	pheightsRef	(OUT): specifies heights of Tatenakayoko object in reference
	 *			device units. 
	 *
	 *	pdvrDescentReservedForClient (OUT): specifies the part of the descent area 
	 *			that the client is reserving for its own use (usually for the purpose 
	 *			of underlining) in reference device units. The object will begin its 
	 *			display area below the baseline at the difference between *pdvrDescent 
	 *			and *pdvrDescentReservedForClient. 
	 *
	 *	pheightsPres (OUT): specifies heights of Tatenakayoko object in presenatation
	 *			device units. 
	 *
	 *	pdvpDescentReservedForClient (OUT): specifies the part of the descent area 
	 *			that the client is reserving for its own use (usually for the purpose 
	 *			of underlining) in presentation device units. The object will begin its 
	 *			display area below the baseline at the difference between *pdvpDescent 
	 *			and pheightsPres.dvDescent. 
	 *
	 */

	LSERR (WINAPI* pfnTatenakayokoEnum)(
		POLS pols,
		PLSRUN plsrun,		
		PCLSCHP plschp,	
		LSCP cp,		
		LSDCP dcp,		
		LSTFLOW lstflow,	
		BOOL fReverse,		
		BOOL fGeometryNeeded,	
		const POINT* pt,		
		PCHEIGHTS pcheights,	
		long dupRun,
		LSTFLOW lstflowT,
		PLSSUBL plssubl);

	/* TatenakayokoEnum
	 * 
	 *	pols (IN): client context.
	 *
	 *  plsrun (IN): plsrun for the entire Tatenakayoko Object.
	 *
	 *	plschp (IN): is lschp for lead character of Tatenakayoko Object.
	 *
	 *	cp (IN): is cp of first character of Tatenakayoko Object.
	 *
	 *	dcp (IN): is number of characters in Tatenakayoko Object
	 *
	 *	lstflow (IN): is text flow at Tatenakayoko Object.
	 *
	 *	fReverse (IN): is whether text should be reversed for visual order.
	 *
	 *	fGeometryNeeded (IN): is whether Geometry should be returned.
	 *
	 *	pt (IN): is starting position , iff fGeometryNeeded .
	 *
	 *	pcheights (IN):	is height of Tatenakayoko object, iff fGeometryNeeded.
	 *
	 *	dupRun (IN): is length of Tatenakayoko Object, iff fGeometryNeeded.
	 *
	 *	lstflowT (IN): is text flow for Tatenakayoko object.
	 *
	 *	plssubl (IN): is subline for Tatenakayoko object.
	 */

} TATENAKAYOKOCBK;

/*
 *
 *	Tatenakayoko object initialization data that the client application must return
 *	when the Tatenakayoko object handler calls the GetObjectHandlerInfo callback.
 */

#define TATENAKAYOKO_VERSION 0x300

typedef struct TATENAKAYOKOINIT
{
	DWORD				dwVersion;			/* Version. Only TATENAKAYOKO_VERSION is valid. */
	WCHAR				wchEndTatenakayoko;	/* Character marking end of Tatenakayoko object */
	WCHAR				wchUnused1;			/* For alignment */
	WCHAR				wchUnused2;			/* For alignment */
	WCHAR				wchUnused3;			/* For alignment */
	TATENAKAYOKOCBK		tatenakayokocbk;	/* Client application callbacks */
} TATENAKAYOKOINIT, *PTATENAKAYOKOINIT;

LSERR WINAPI LsGetTatenakayokoLsimethods(
	LSIMETHODS *plsim);

/* GetTatenakayokoLsimethods
 *	
 *	plsim (OUT): Tatenakayoko object methods for Line Services
 *
 */

#endif /* TATENAKYOKO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\vruby.h ===
/* Vertical ruby interfaces */
/* Contact: antons */

#ifndef VRUBY_DEFINED
#define VRUBY_DEFINED

#include "lsimeth.h"

/* Only valid version number for Ruby initialization */

#define VRUBY_VERSION 0x300

/* Used for intialization to tell Ruby object which line comes first */

typedef enum vrubysyntax { VRubyPronunciationLineFirst, VRubyMainLineFirst } VRUBYSYNTAX;

/*
 *
 *	Vertical Ruby Object callbacks to client application
 *
 */

typedef struct VRUBYCBK
{
	LSERR (WINAPI *pfnFetchVRubyPosition)
	(
		/* in */

		POLS			pols,
		LSCP			cp,
		LSTFLOW			lstflow,
		PLSRUN			plsrun,
		PCHEIGHTS		pcheightsRefMain,
		PCHEIGHTS		pcheightsPresMain,
		long			dvrRuby,

		/* out */

		PHEIGHTS		pheightsPresRubyT,
		PHEIGHTS		pheightsRefRubyT,
		LONG*			 pdurAdjust
	);

	LSERR (WINAPI* pfnVRubyEnum)
	(
		POLS pols,
		PLSRUN plsrun,		
		PCLSCHP plschp,	
		LSCP cp,		
		LSDCP dcp,		
		LSTFLOW lstflow,	
		BOOL fReverse,		
		BOOL fGeometryNeeded,	
		const POINT* pt,		
		PCHEIGHTS pcheights,	
		long dupRun,		
		const POINT *ptMain,	
		PCHEIGHTS pcheightsMain,
		long dupMain,		
		const POINT *ptRuby,	
		PCHEIGHTS pcheightsRuby,
		long dupRuby,	
		PLSSUBL plssublMain,	
		PLSSUBL plssublRuby
	);

} VRUBYCBK;

/*
 *
 *	Ruby Object initialization data that the client application must return
 *	when the Ruby object handler calls the GetObjectHandlerInfo callback.
 *
 */
typedef struct VRUBYINIT
{
	DWORD				dwVersion;		/* Version of the structure (must be VRUBY_VERSION) */
	VRUBYSYNTAX			vrubysyntax;	/* Used to determine order of lines during format */
	WCHAR				wchEscRuby;		/* Escape char for end of Ruby pronunciation line */
	WCHAR				wchEscMain;		/* Escape char for end of main text */
	VRUBYCBK			vrcbk;			/* Ruby callbacks */

} VRUBYINIT;


LSERR WINAPI LsGetVRubyLsimethods ( LSIMETHODS *plsim );

/* GetRubyLsimethods
 *
 *	plsim (OUT): Ruby object methods for Line Services.
 *
 */


#endif /* VRUBY_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\ruby.h ===
#ifndef RUBY_DEFINED
#define RUBY_DEFINED

#include	"lsimeth.h"

/* Only valid version number for Ruby initialization */
#define RUBY_VERSION 0x300

/* Used for intialization to tell Ruby object which line comes first */
typedef enum rubysyntax { RubyPronunciationLineFirst, RubyMainLineFirst } RUBYSYNTAX;


/* Type of Adjustment for Ruby text returned by FetchRubyPosition callback */
enum rubycharjust { 
	rcjCenter, 		/* Centering occurs on longer text line */

	rcj010, 		/* Difference in space between longer text
					 * and shorter is distributed in the shorter
					 * string evenly between each character 
					 */

	rcj121,			/* Difference in space between longer string
					 * and shorter is distributed in the shorter
					 * using a ratio of 1:2:1 which corresponds
					 * to lead : inter-character : end.
					 */

	rcjLeft,		/* Align ruby with the left of the main line.
					 */

	rcjRight		/* Align ruby with the right of the main line.
					 */
};

/* Location of character input to FetchRubyWidthAdjust callback */
enum rubycharloc {
	rubyBefore,		/* Character preceeds Ruby object */
	rubyAfter		/* Character follows Ruby object */
};

/*
 *
 *	Ruby Object callbacks to client application
 *
 */
typedef struct RUBYCBK
{
	LSERR (WINAPI *pfnFetchRubyPosition)(
		POLS pols,
		LSCP cp,
		LSTFLOW lstflow,
		DWORD cdwMainRuns,
		const PLSRUN *pplsrunMain,
		PCHEIGHTS pcheightsRefMain,
		PCHEIGHTS pcheightsPresMain,
		DWORD cdwRubyRuns,
		const PLSRUN *pplsrunRuby,
		PCHEIGHTS pcheightsRefRuby,
		PCHEIGHTS pcheightsPresRuby,
		PHEIGHTS pheightsRefRubyObj,
		PHEIGHTS pheightsPresRubyObj,
		long *pdvpOffsetMainBaseline,
		long *pdvrOffsetRubyBaseline,
		long *pdvpOffsetRubyBaseline,
		enum rubycharjust *prubycharjust,
		BOOL *pfSpecialLineStartEnd);

	/* FetchRubyPosition
	 *  pols (IN): The client context for the request.
	 *
	 *  cp (IN): the cp of the Ruby object.
	 *
	 *  lstflow (IN): the lstflow of Ruby parent subline
	 *
	 *	pplsrunMain	(IN): array of PLSRUNs created by the client application 
	 *			for each of the runs in the main text for the Ruby object.
	 *
	 *	pcheightsRefMain (IN): height of the line of the main text in reference 
	 *			device units.
	 *
	 *	pcheightsPresMain (IN): height of the line of the main text in presentation
	 *			device units.
	 *
	 *	cdwRubyRuns	(IN): count of pronunciation runs supplied in the following 
	 *			parameter.
	 *
	 *	pplsrunRuby	(IN): array of PLSRUNS created by the client application for 
	 *			each of the runs in the pronunciation text for the Ruby object.
	 *
	 *	pcheightsRefRuby (IN): height of the line of the Ruby pronunciation text in 
	 *			reference device units.
	 *
	 *	pcheightsPresRuby (IN): height of the line of the Ruby pronunciation text in 
	 *			presentation device units.
	 *
	 *	pheightsRefRubyObj	(OUT): returned height values in reference device units
	 *			that ruby object will report back to line services.
	 *
	 *	pheightsPresRubyObj	(OUT): returned height values in presentation device units
	 *			that ruby object will report back to line services.
	 *
	 *	pdvpOffsetMainBaseline (OUT): offset of baseline of main line of Ruby
	 *			text from base line of Ruby object in presentation units. Note
	 *			a negative value puts the baseline of the main line below the 
	 *			base line of the Ruby object.
	 *
	 *	pdvrOffsetRubyBaseline (OUT): offset of baseline of pronunciation line
	 *			of Ruby text from base line of Ruby object in reference units. 
	 *			Note a negative value puts the baseline of the pronunciation line 
	 *			below the base line of the Ruby object.
	 *
	 *	pdvpOffsetRubyBaseline (OUT): offset of baseline of pronunciation line
	 *			of Ruby text from base line of Ruby object in presentation units. 
	 *			Note a negative value puts the baseline of the pronunciation line 
	 *			below the base line of the Ruby object.
	 *
	 *	prubycharjust (OUT): type of justification to use for Ruby Object.
	 *
	 *	pfSpecialLineStartEnd (OUT): specifies that the optional alignment that 
	 *			overrides the usual centering algorithm when the Ruby is the 
	 *			first or last character of the line.
	 *
	 */

	LSERR (WINAPI *pfnFetchRubyWidthAdjust)(
		POLS pols,
		LSCP cp,
		PLSRUN plsrunForChar,
		WCHAR wch,
		MWCLS mwclsForChar,
		PLSRUN plsrunForRuby,
		enum rubycharloc rcl,
		long durMaxOverhang,
		long *pdurAdjustChar,
		long *pdurAdjustRuby);

	/* FetchRubyWidthAdjust
	 *  pols (IN): The client context for the request.
	 *
	 *  cp (IN): the cp of the Ruby object.
	 *
	 *	plsrunForChar (IN): the run that is either previous or following the 
	 *			Ruby object.
	 *
	 *	wch (IN): character that is either before or after the Ruby object.
	 *
	 *	mwcls (IN): mod width class for the character.
	 *
	 *	plsrunForRuby (IN): plsrun for entire ruby object.
	 *
	 *	rcl	(IN): tells the location of the character.
	 *
	 *	durMaxOverhang (IN): designates the maximum amount of overhang that is 
	 *			possible following the JIS spec with respect to overhang. 
	 *			Adjusting the Ruby object by a negative value whose absolute 
	 *			value is greater than durMaxOverhang will cause part of the 
	 *			main text to be clipped. If the value of this parameter is 0, 
	 *			this indicates that there is no possible overhang.
	 *
	 *	pdurAdjustChar (OUT): designates the amount to adjust the width of the 
	 *			character prior to or following the Ruby object. Returing a negative 
	 *			value will decrease the size of the character preceeding or following 
	 *			the Ruby while returning a positive value will increase the size 
	 *			of that character.
	 *
	 *	pdurAdjustRuby (OUT): designates the amount adjust the width of the Ruby 
	 *			object. Returing a negative value will decrease the size of the 
	 *			Ruby object and potentially cause the Ruby pronunciation text to 
	 *			overhang the preceeding or following character while returning a 
	 *			positive value will increase the size of the Ruby object.
	 */

	LSERR (WINAPI* pfnRubyEnum)(
		POLS pols,
		PLSRUN plsrun,		
		PCLSCHP plschp,	
		LSCP cp,		
		LSDCP dcp,		
		LSTFLOW lstflow,	
		BOOL fReverse,		
		BOOL fGeometryNeeded,	
		const POINT* pt,		
		PCHEIGHTS pcheights,	
		long dupRun,		
		const POINT *ptMain,	
		PCHEIGHTS pcheightsMain,
		long dupMain,		
		const POINT *ptRuby,	
		PCHEIGHTS pcheightsRuby,
		long dupRuby,	
		PLSSUBL plssublMain,	
		PLSSUBL plssublRuby);	

	/* RubyEnum
	 * 
	 *	pols (IN): client context.
	 *
	 *  plsrun (IN): plsrun for the entire Ruby Object.
	 *
	 *	plschp (IN): is lschp for lead character of Ruby Object.
	 *
	 *	cp (IN): is cp of first character of Ruby Object.
	 *
	 *	dcp (IN): is number of characters in Ruby Object
	 *
	 *	lstflow (IN): is text flow at Ruby Object.
	 *
	 *	fReverse (IN): is whether text should be reversed for visual order.
	 *
	 *	fGeometryNeeded (IN): is whether Geometry should be returned.
	 *
	 *	pt (IN): is starting position , iff fGeometryNeeded .
	 *
	 *	pcheights (IN):	is height of Ruby object, iff fGeometryNeeded.
	 *
	 *	dupRun (IN): is length of Ruby Object, iff fGeometryNeeded.
	 *
	 *	ptMain (IN): is starting point for main line iff fGeometryNeeded
	 *
	 *	pcheightsMain (IN): is height of main line iff fGeometryNeeded
	 *
	 *	dupMain (IN): is length of main line iff fGeometryNeeded
	 *
	 *	ptRuby (IN): is point for Ruby pronunciation line iff fGeometryNeeded
	 *
	 *	pcheightsRuby (IN): is height for ruby line iff fGeometryNeeded
	 *
	 *	dupRuby (IN): is length of Ruby line iff fGeometryNeeded
	 *
	 *	plssublMain (IN): is main subline.
	 *
	 *	plssublRuby (IN): is Ruby subline.
	 *
	 */

} RUBYCBK;

/*
 *
 *	Ruby Object initialization data that the client application must return
 *	when the Ruby object handler calls the GetObjectHandlerInfo callback.
 *
 */
typedef struct RUBYINIT
{
	DWORD				dwVersion;		/* Version of the structure */
	RUBYSYNTAX			rubysyntax;		/* Used to determine order of lines during format */
	WCHAR				wchEscRuby;		/* Escape char for end of Ruby pronunciation line */
	WCHAR				wchEscMain;		/* Escape char for end of main text */
	WCHAR				wchUnused1;		/* For aligment */
	WCHAR				wchUnused2;		/* For aligment */
	RUBYCBK				rcbk;			/* Ruby callbacks */
} RUBYINIT;

LSERR WINAPI LsGetRubyLsimethods(
	LSIMETHODS *plsim);

/* GetRubyLsimethods
 *
 *	plsim (OUT): Ruby object methods for Line Services.
 *
 */

#endif /* RUBY_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\zqfromza.h ===
#ifndef ZQFROMZQ_DEFINED
#define ZQFROMZQ_DEFINED

#include "lsdefs.h"

#define zqLim	1491309L				/* higher resolution will overflow */

long ZqFromZa_C (long, long);

#ifdef _X86_

long ZqFromZa_Asm (long, long);
__int64 Div64_Asm (__int64, __int64);
__int64 Mul64_Asm (__int64, __int64);

#define ZqFromZa(dzqInch,za) ZqFromZa_Asm ((dzqInch),(za))

#define Div64(DVND,DVSR) Div64_Asm ((DVND),(DVSR))
#define Mul64(A,B) Mul64_Asm ((A),(B))

#else

#define ZqFromZa(dzqInch,za) ZqFromZa_C ((dzqInch),(za))

#define Div64(DVND,DVSR) ((__int64) (DVND) / (__int64) (DVSR))
#define Mul64(A,B) ((__int64) (A) * (__int64) (B))

#endif

long ZaFromZq(long, long);
long LsLwMultDivR(long, long, long);

#define I_UpFromUa(pdevres,ua)	(ZqFromZa((pdevres)->dxpInch, (ua)))
#define I_UrFromUa(pdevres,ua)	(ZqFromZa((pdevres)->dxrInch, (ua)))
#define I_VpFromVa(pdevres,va)	(ZqFromZa((pdevres)->dypInch, (va)))
#define I_VrFromVa(pdevres,va)	(ZqFromZa((pdevres)->dyrInch, (va)))
#define I_UaFromUp(pdevres,up)	(ZaFromZq((pdevres)->dxpInch, (up)))
#define I_VaFromVp(pdevres,vp)	(ZaFromZq((pdevres)->dypInch, (vp)))
#define I_UaFromUr(pdevres,ur)	(ZaFromZq((pdevres)->dxrInch, (ur)))
#define I_VaFromVr(pdevres,vr)	(ZaFromZq((pdevres)->dyrInch, (vr)))



#define UpFromUa(tfl,pdevres,ua) (((tfl) & fUVertical) ? \
		I_VpFromVa(pdevres,ua) :\
		I_UpFromUa(pdevres,ua) \
)

#define UrFromUa(tfl,pdevres,ua) (((tfl) & fUVertical) ? \
		I_VrFromVa(pdevres,ua) :\
		I_UrFromUa(pdevres,ua) \
)

#define VpFromVa(tfl,pdevres,va) ((tfl) & fUVertical) ? \
		I_UpFromUa(pdevres,va) :\
		I_VpFromVa(pdevres,va) \
)

#define VrFromVa(tfl,pdevres,va) (((tfl) & fUVertical) ? \
		I_UrFromUa(pdevres,va) :\
		I_VrFromVa(pdevres,va) \
)

#define UaFromUp(tfl,pdevres,up) (((tfl) & fUVertical) ? \
		I_VaFromVp(pdevres,up) :\
		I_UaFromUp(pdevres,up) \
)

#define VaFromVp(tfl,pdevres,vp)	(((tfl) & fUVertical) ? \
		I_UaFromUp(pdevres,vp) :\
		I_VaFromVp(pdevres,vp) \
)

#define UaFromUr(tfl,pdevres,ur)	(((tfl) & fUVertical) ?	\
		I_VaFromVr(pdevres,ur) :\
		I_UaFromUr(pdevres,ur) \
)

#define VaFromVr(tfl,pdevres,vr)	(((tfl) & fUVertical) ?	\
		I_UaFromUr(pdevres,vr) :\
		I_VaFromVr(pdevres,vr) \
)

/*
#define UpFromUr(pdevres,ur)	UpFromUa(pdevres, UaFromUr(pdevres, ur))
#define VpFromVr(pdevres,vr)	VpFromVa(pdevres, VaFromVr(pdevres, vr))
*/
#define UpFromUr(tfl,pdevres,ur)	(((tfl) & fUVertical) ? \
								LsLwMultDivR(ur, (pdevres)->dypInch, (pdevres)->dyrInch): \
								LsLwMultDivR(ur, (pdevres)->dxpInch, (pdevres)->dxrInch) \
									)
#define VpFromVr(tfl,pdevres,vr)	(((tfl) & fUVertical) ? \
								LsLwMultDivR(vr, (pdevres)->dxpInch, (pdevres)->dxrInch): \
								LsLwMultDivR(vr, (pdevres)->dypInch, (pdevres)->dyrInch) \
									)
#define UrFromUp(tfl,pdevres,up)	(((tfl) & fUVertical) ? \
								LsLwMultDivR(up, (pdevres)->dyrInch, (pdevres)->dypInch): \
								LsLwMultDivR(up, (pdevres)->dxrInch, (pdevres)->dxpInch) \
									)
#define VrFromVp(tfl,pdevres,vp)	(((tfl) & fUVertical) ? \
								LsLwMultDivR(vp, (pdevres)->dxrInch, (pdevres)->dxpInch): \
								LsLwMultDivR(vp, (pdevres)->dyrInch, (pdevres)->dypInch) \
									)

#endif /* ZQFROMZQ_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\robj.h ===
#ifndef ROBJ_DEFINED
#define ROBJ_DEFINED

#include "lsimeth.h"

#define REVERSE_VERSION 0x300

/* Prototype for Reverse Object enumeration callback */
typedef LSERR (WINAPI * PFNREVERSEENUM)(
	POLS pols,				/*(IN): client context */
	PLSRUN plsrun,			/*(IN): from DNODE */
	PCLSCHP plschp,			/*(IN): from DNODE */
	LSCP cp,				/*(IN): from DNODE */
	LSDCP dcp,				/*(IN): from DNODE */
	LSTFLOW lstflow,		/*(IN): text flow */
	BOOL fReverse,			/*(IN): enumerate in reverse order */
	BOOL fGeometryNeeded,	/*(IN): */
	const POINT* pt,		/*(IN): starting position (top left), iff fGeometryNeeded */
	PCHEIGHTS pcheights,	/*(IN): from DNODE, relevant iff fGeometryNeeded */
	long dupRun,			/*(IN): from DNODE, relevant iff fGeometryNeeded */
	LSTFLOW lstflowSubline,	/*(IN): lstflow of subline in reverse object */
	PLSSUBL plssubl);		/*(IN): subline in reverse object. */

/*
 *
 *	Reverse Object initialization data that the client application must return
 *	when the Reverse Object handler calls the GetObjectHandlerInfo callback.
 *
 */


/* Prototype for Reverse Object get info */

typedef LSERR (WINAPI * PFNREVERSEGETINFO)
(
	POLS	pols,
	LSCP	cp,
	PLSRUN	plsrun,

	BOOL	* pfDoNotBreakAround,
	BOOL	* pfSuppressTrailingSpaces
);

typedef struct REVERSEINIT
{
        DWORD					dwVersion;		/* Version. Must be REVERSE_VERSION */
        WCHAR					wchEndReverse;	/* Escape char for end of Reverse Object */

		WCHAR					wchUnused1;		/* Unused for alignment */
		PFNREVERSEGETINFO		pfnGetRobjInfo;	/* Callback GetInfo */
		PFNREVERSEENUM			pfnEnum;		/* Enumeration callback */

} REVERSEINIT;

LSERR WINAPI LsGetReverseLsimethods(
        LSIMETHODS *plsim);

/* GetReverseLsimethods
 *
 *	plsim (OUT): Reverse Object Handler methods for Line Services.
 *
 */

#endif /* ROBJ_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\vbcursor\msr2c.h ===
//---------------------------------------------------------------------------
// MSR2C.h : Main header file for Viaduct phase II
//
// Copyright (c) 1996, 1997 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

  /////////////////////////////////////////////////////////////////////////
  // NOTE - you must define VD_INCLUDE_ROWPOSITION before including this //
  //        header for ICursorFromRowPosition to be defined in your code //
  /////////////////////////////////////////////////////////////////////////

#ifndef __MSR2C_H__
#define __MSR2C_H__

// {5B5E7E70-E653-11cf-84A5-0000C08C00C4}
const GUID CLSID_CCursorFromRowset =	
	{ 0x5b5e7e70, 0xe653, 0x11cf, { 0x84, 0xa5, 0x0, 0x0, 0xc0, 0x8c, 0x0, 0xc4 } };

// {5B5E7E72-E653-11cf-84A5-0000C08C00C4}
const IID IID_ICursorFromRowset = 
	{ 0x5b5e7e72, 0xe653, 0x11cf, { 0x84, 0xa5, 0x0, 0x0, 0xc0, 0x8c, 0x0, 0xc4 } };

#ifdef VD_INCLUDE_ROWPOSITION

// {5B5E7E73-E653-11cf-84A5-0000C08C00C4}
const IID IID_ICursorFromRowPosition = 
	{ 0x5b5e7e73, 0xe653, 0x11cf, { 0x84, 0xa5, 0x0, 0x0, 0xc0, 0x8c, 0x0, 0xc4 } };

#endif //VD_INCLUDE_ROWPOSITION

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICursorFromRowset : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCursor( 
            /* [in]  */ IRowset __RPC_FAR *pRowset,
            /* [out] */ ICursor __RPC_FAR **ppCursor,
            /* [in]  */ LCID lcid) = 0;
    };
    
#ifdef VD_INCLUDE_ROWPOSITION

    interface ICursorFromRowPosition : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCursor( 
            /* [in]  */ IRowPosition __RPC_FAR *pRowPosition,
            /* [out] */ ICursor __RPC_FAR **ppCursor,
            /* [in]  */ LCID lcid) = 0;
    };

#endif //VD_INCLUDE_ROWPOSITION

#else 	/* C style interface */

    typedef struct ICursorFromRowset
    {
        BEGIN_INTERFACE
        
        HRESULT (STDMETHODCALLTYPE __RPC_FAR *QueryInterface)( 
            ICursorFromRowset __RPC_FAR *This,
            /* [in]  */ REFIID riid,
            /* [out] */ void __RPC_FAR **ppvObject);
        
        ULONG (STDMETHODCALLTYPE __RPC_FAR *AddRef)( 
            ICursorFromRowset __RPC_FAR *This);
        
        ULONG (STDMETHODCALLTYPE __RPC_FAR *Release)( 
            ICursorFromRowset __RPC_FAR *This);
        
        HRESULT (STDMETHODCALLTYPE __RPC_FAR *GetCursor)( 
            ICursorFromRowset __RPC_FAR *This,
            /* [in]  */ IRowset __RPC_FAR *pRowset,
            /* [out] */ ICursor __RPC_FAR **ppCursor,
            /* [in]  */ LCID lcid);
        
        END_INTERFACE
    } ICursorFromRowsetVtbl;

    interface ICursorFromRowset
    {
        CONST_VTBL struct ICursorFromRowsetVtbl __RPC_FAR *lpVtbl;
    };

#ifdef VD_INCLUDE_ROWPOSITION

    typedef struct ICursorFromRowPosition
    {
        BEGIN_INTERFACE
        
        HRESULT (STDMETHODCALLTYPE __RPC_FAR *QueryInterface)( 
            ICursorFromRowPosition __RPC_FAR *This,
            /* [in]  */ REFIID riid,
            /* [out] */ void __RPC_FAR **ppvObject);
        
        ULONG (STDMETHODCALLTYPE __RPC_FAR *AddRef)( 
            ICursorFromRowPosition __RPC_FAR *This);
        
        ULONG (STDMETHODCALLTYPE __RPC_FAR *Release)( 
            ICursorFromRowPosition __RPC_FAR *This);
        
        HRESULT (STDMETHODCALLTYPE __RPC_FAR *GetCursor)( 
            ICursorFromRowPosition __RPC_FAR *This,
            /* [in]  */ IRowPosition __RPC_FAR *pRowPosition,
            /* [out] */ ICursor __RPC_FAR **ppCursor,
            /* [in]  */ LCID lcid);
        
        END_INTERFACE
    } ICursorFromRowPositionVtbl;

    interface ICursorFromRowPosition
    {
        CONST_VTBL struct ICursorFromRowPositionVtbl __RPC_FAR *lpVtbl;
    };

#endif //VD_INCLUDE_ROWPOSITION

#endif 	/* C style interface */

#ifdef __cplusplus
extern "C" {
#endif
// old entry point
HRESULT WINAPI VDGetICursorFromIRowset(IRowset * pRowset, 
                                       ICursor ** ppCursor,
                                       LCID lcid);
#ifdef __cplusplus
}
#endif

//
// MessageId: VD_E_CANNOTGETMANDATORYINTERFACE
//
// MessageText:
//
//  Unable to get required interface
//
#define VD_E_CANNOTGETMANDATORYINTERFACE        ((HRESULT)0x80050E00L)

//
// MessageId: VD_E_CANNOTCONNECTIROWSETNOTIFY
//
// MessageText:
//
//  Unable to connect IRowsetNotify
//
#define VD_E_CANNOTCONNECTIROWSETNOTIFY         ((HRESULT)0x80050E31L)

//
// MessageId: VD_E_CANNOTGETCOLUMNINFO
//
// MessageText:
//
//  Unable to get column information
//
#define VD_E_CANNOTGETCOLUMNINFO                ((HRESULT)0x80050E32L)

//
// MessageId: VD_E_CANNOTCREATEBOOKMARKACCESSOR
//
// MessageText:
//
//  Unable to create bookmark accessor
//
#define VD_E_CANNOTCREATEBOOKMARKACCESSOR       ((HRESULT)0x80050E33L)

//
// MessageId: VD_E_REQUIREDPROPERTYNOTSUPPORTED
//
// MessageText:
//
//  Require rowset property is not supported
//
#define VD_E_REQUIREDPROPERTYNOTSUPPORTED       ((HRESULT)0x80050E34L)

//
// MessageId: VD_E_CANNOTGETROWSETINTERFACE
//
// MessageText:
//
//  Unable to get rowset interface
//
#define VD_E_CANNOTGETROWSETINTERFACE			((HRESULT)0x80050E35L)

//
// MessageId: VD_E_CANNOTCONNECTIROWPOSITIONCHANGE
//
// MessageText:
//
//  Unable to connect IRowPositionChange
//
#define VD_E_CANNOTCONNECTIROWPOSITIONCHANGE	((HRESULT)0x80050E36L)

#endif //__MSR2C_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\msls\warichu.h ===
#ifndef WARICHU_DEFINED
#define WARICHU_DEFINED

#include	"lsimeth.h"

/* Character location for pfnFetchWarichuWidthAdjust callback */
enum warichucharloc {
	warichuBegin,				/* Character preceeds Warichu object */
	warichuEnd					/* Character follows Warichu object */
};

/*
 *
 * Warichu Object Callbacks to Client
 *
 */
typedef struct WARICHUCBK
{
	LSERR (WINAPI* pfnGetWarichuInfo)(
		POLS pols,
		LSCP cp,
		LSTFLOW lstflow,
		PCOBJDIM pcobjdimFirst,
		PCOBJDIM pcobjdimSecond,
		PHEIGHTS pheightsRef,
		PHEIGHTS pheightsPres,
		long *pdvpDescentReservedForClient);

	/* GetWarichuInfo
	 *  pols (IN): The client context for the request.
	 *
	 *  cp (IN): the cp of the Warichu object.
	 *
     *  lstflow (IN): the lstflow of Warichu parent subline
	 *
	 *	pcobjdimFirst (IN): dimensions of first line of Warichu.
	 *
	 *	pcobjdimSecond (IN): dimensions of second line of Warichu.
	 *
	 *	pheightsRef (OUT): specifies heights for Warichu object in reference
	 *			device units.
	 *
	 *	pheightsPres (OUT): specifies heights for Warichu object in presentation
	 *			device units.
	 *
	 *	pdvpDescentReservedForClient (OUT): specifies the part of the descent area 
	 *			that the client is reserving for its own use (usually for the purpose 
	 *			of underlining) in presentation device units. The object will begin its 
	 *			display area below the baseline at the difference between 
	 *			pheightsRef->dvDescent and *pdvpDescentReservedForClient. 
	 *
	 */

	LSERR (WINAPI* pfnFetchWarichuWidthAdjust)(
		POLS pols,
		LSCP cp,
		enum warichucharloc wcl,
		PLSRUN plsrunForChar,
		WCHAR wch,
		MWCLS mwclsForChar,
		PLSRUN plsrunWarichuBracket,
		long *pdurAdjustChar,
		long *pdurAdjustBracket);

	/* FetchWarichuWidthAdjust
	 *  pols (IN): The client context for the request.
	 *
	 *  cp (IN): the cp of the Warichu object.
	 *
	 *  wcl (IN): specifies the location of the character and bracket.
	 *
	 *  plsrunForChar (IN): the run of the character that is either previous or 
	 *		following the Warichu object. Whether preceeding or following is 
	 *		determined by value of the wcl parameter above.
	 *
	 *	wch (IN): character that is either preceeding or following the Warichu 
	 *		object.
	 *
	 *	mwclsForChar (IN): mod width class for the wch parameter.
	 *
	 *	plsrunWarichuBracket (IN): plsrun for leading or following bracket of 
	 *		the Warichu.
	 *
	 *	pdurAdjustChar (OUT): the amount that the width of the input character 
	 *		should be adjusted. A negative value means the width of the input 
	 *		character should be made smaller.
	 *
	 *	pdurAdjustBracket (OUT): the amount that the width of the Warichu bracket
	 *		should be adjusted.  A negative value means the width of the Warichu 
	 *		bracket should be made smaller.
	 */

	LSERR (WINAPI* pfnWarichuEnum)(
		POLS pols,
		PLSRUN plsrun,		
		PCLSCHP plschp,	
		LSCP cp,		
		LSDCP dcp,		
		LSTFLOW lstflow,	
		BOOL fReverse,		
		BOOL fGeometryNeeded,	
		const POINT* pt,		
		PCHEIGHTS pcheights,	
		long dupRun,		
		const POINT *ptLeadBracket,	
		PCHEIGHTS pcheightsLeadBracket,
		long dupLeadBracket,		
		const POINT *ptTrailBracket,	
		PCHEIGHTS pcheightsTrailBracket,
		long dupTrailBracket,
		const POINT *ptFirst,	
		PCHEIGHTS pcheightsFirst,
		long dupFirst,		
		const POINT *ptSecond,	
		PCHEIGHTS pcheightsSecond,
		long dupSecond,
		PLSSUBL plssublLeadBracket,
		PLSSUBL plssublTrailBracket,
		PLSSUBL plssublFirst,	
		PLSSUBL plssublSecond);	

	/* WarichuEnum
	 * 
	 *	pols (IN): client context.
	 *
	 *  plsrun (IN): plsrun for the entire Warichu Object.
	 *
	 *	plschp (IN): is lschp for lead character of Warichu Object.
	 *
	 *	cp (IN): is cp of first character of Warichu Object.
	 *
	 *	dcp (IN): is number of characters in Warichu Object
	 *
	 *	lstflow (IN): is text flow at Warichu Object.
	 *
	 *	fReverse (IN): is whether text should be reversed for visual order.
	 *
	 *	fGeometryNeeded (IN): is whether Geometry should be returned.
	 *
	 *	pt (IN): is starting position , iff fGeometryNeeded .
	 *
	 *	pcheights (IN):	is height of Warichu object, iff fGeometryNeeded.
	 *
	 *	dupRun (IN): is length of Warichu Object, iff fGeometryNeeded.
	 *
	 *	ptLeadBracket (IN):	is point for second line iff fGeometryNeeded and 
	 *		plssublLeadBracket not NULL.
	 *
	 *	pcheightsLeadBracket (IN): is height for Warichu line iff fGeometryNeeded 
	 *		and plssublLeadBracket not NULL.
	 *
	 *	dupLeadBracket (IN): is length of Warichu line iff fGeometryNeeded and 
	 *		plssublLeadBracket not NULL.
	 *
	 *	ptTrailBracket (IN): is point for second line iff fGeometryNeeded and 
	 *		plssublLeadBracket not NULL.
	 *
	 *	pcheightsTrailBracket (IN):	is  height for Warichu  line iff fGeometryNeeded 
	 *		and plssublTrailBracket not NULL.
	 *
	 *	dupTrailBracket (IN): is length of Warichu line iff fGeometryNeeded and 
	 *		plssublTrailBracket not NULL.
	 *
	 *	ptFirst (IN): is starting point for main line iff fGeometryNeeded
	 *
	 *	pcheightsFirst (IN): is height of main line iff fGeometryNeeded
	 *
	 *	dupFirst (IN): is length of main line iff fGeometryNeeded
	 *
	 *	ptSecond (IN): is point for second line iff fGeometryNeeded and 
	 *		plssublSecond not NULL.
	 *
	 *	pcheightsSecond (IN): is height for Warichu line iff fGeometryNeeded 
	 *		and plssublSecond not NULL.
	 *
	 *	dupSecond (IN):	is length of Warichu line iff fGeometryNeeded and 
	 *		plssublSecond not NULL.
	 *
	 *	plssublLeadBracket (IN): is subline for lead bracket.
	 *
	 *	plssublTrailBracket (IN): is subline for trail bracket.
	 *
	 *	plssublFirst (IN): is first subline in Warichu object.
	 *
	 *	plssublSecond (IN):	is second subline in Warichu object.
	 *
	 */

} WARICHUCBK;

#define WARICHU_VERSION 0x300

/*
 * 
 *	Warichi object initialization data that the client application must return
 *	when the Warichu object handler calls the GetObjectHandlerInfo callback.
 */
typedef struct WARICHUINIT
{
	DWORD				dwVersion;			/* Version must be WARICHU_VERSION */
	WCHAR				wchEndFirstBracket;	/* Escape char to end first bracket */
	WCHAR				wchEndText;			/* Escape char to end text */
	WCHAR				wchEndWarichu;		/* Escape char to end object */
	WCHAR				wchUnused;			/* For alignment */
	WARICHUCBK			warichcbk;			/* Callbacks */
	BOOL				fContiguousFetch;	/* Always refetch whole subline & closing brace
											   after reformatting inside warichu */
} WARICHUINIT;

LSERR WINAPI LsGetWarichuLsimethods(
	LSIMETHODS *plsim);

/* GetWarichuLsimethods
 *
 *	plsim (OUT): Warichu object callbacks.
 */

#endif /* WARICHU_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\vbcursor\msc2r.h ===
//---------------------------------------------------------------------------
// MSC2R.h : Main header file for the MSC2R DLL
//
// Copyright (c) 1996 Microsoft Corporation, All Rights Reserved
// Developed by Sheridan Software Systems, Inc.
//---------------------------------------------------------------------------

#ifndef __MSC2R_H__
#define __MSC2R_H__

// {E55A7600-E666-11cf-84A5-0000C08C00C4}
const GUID CLSID_CRowsetFromCursor =	
	{ 0xe55a7600, 0xe666, 0x11cf, { 0x84, 0xa5, 0x0, 0x0, 0xc0, 0x8c, 0x0, 0xc4 } };

// {E55A7601-E666-11cf-84A5-0000C08C00C4}
const IID IID_IRowsetFromCursor = 
	{ 0xe55a7601, 0xe666, 0x11cf, { 0x84, 0xa5, 0x0, 0x0, 0xc0, 0x8c, 0x0, 0xc4 } };

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IRowsetFromCursor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRowset( 
            /* [in] */ ICursor __RPC_FAR *pCursor,
            /* [out] */ IRowset __RPC_FAR **ppRowset,
            /* [in] */ LCID lcid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetFromCursor
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRowsetFromCursor __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRowsetFromCursor __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRowsetFromCursor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRowset )( 
            IRowsetFromCursor __RPC_FAR * This,
            /* [in] */ ICursor __RPC_FAR *pCursor,
            /* [out] */ IRowset __RPC_FAR **ppRowset,
            /* [in] */ LCID lcid);
        
        END_INTERFACE
    } IRowsetFromCursorVtbl;

    interface IRowsetFromCursor
    {
        CONST_VTBL struct IRowsetFromCursorVtbl __RPC_FAR *lpVtbl;
    };

#endif 	/* C style interface */

#ifdef __cplusplus
extern "C" {
#endif
// MSC2R entry point
HRESULT WINAPI VDGetIRowsetFromICursor(ICursor * pCursor,
									   IRowset ** ppRowset,
									   LCID lcid);
#ifdef __cplusplus
}
#endif

//
// MessageId: VD_E_CANNOTGETMANDATORYINTERFACE
//
// MessageText:
//
//  Unable to get required interface
//
#define VD_E_CANNOTGETMANDATORYINTERFACE        ((HRESULT)0x80050E00L)

//
// MessageId: VD_E_CANNOTCONNECTINOTIFYDBEVENTS
//
// MessageText:
//
//  Unable to connect INotifyDBEvents
//
#define VD_E_CANNOTCONNECTINOTIFYDBEVENTS       ((HRESULT)0x80050E01L)

//
// MessageId: VD_E_CANNOTSETBINDINGSONCOLUMNSCURSOR
//
// MessageText:
//
//  Unable to set bindings on columns cursor
//
#define VD_E_CANNOTSETBINDINGSONCOLUMNSCURSOR   ((HRESULT)0x80050E02L)

//
// MessageId: VD_E_CANNOTSETBINDINGSONCLONECURSOR
//
// MessageText:
//
//  Unable to set bindings on clone cursor
//
#define VD_E_CANNOTSETBINDINGSONCLONECURSOR     ((HRESULT)0x80050E03L)

#endif //__MSC2R_H__
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\vbcursor\vbdsc.h ===
/*****************************************************************************\
*                                                                             *
* vbdsc.h       DSC interfaces for OLE                                        *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1994, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#if !defined( _VBDSC_H_ )
#define _VBDSC_H_

//#if !defined( INITGUID )
//#include <olectl.h>
//#endif

DEFINE_GUID(IID_IVBDSC,
        0x1ab42240, 0x8c70, 0x11ce, 0x94, 0x21, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57);

typedef interface IVBDSC FAR *LPVBDSC;


typedef enum _tagDSCERROR
  {
  DSCERR_BADDATAFIELD = 0
  }
DSCERROR;


//////////////////////////////////////////////////////////////////////////////
//
//  IVBDSC interface
//
//////////////////////////////////////////////////////////////////////////////

#undef INTERFACE
#define INTERFACE IVBDSC

DECLARE_INTERFACE_(IVBDSC, IUnknown)
{
    //
    //  IUnknown methods
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    //  IVBDSC methods
    //
    STDMETHOD(CancelUnload)(THIS_ BOOL FAR *pfCancel) PURE;
    STDMETHOD(Error)(THIS_ DWORD dwErr, BOOL FAR *pfShowError) PURE;
    STDMETHOD(CreateCursor)(THIS_ ICursor FAR * FAR *ppCursor) PURE;
};

#endif // !defined( _VBDSC_H_ )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\vbcursor\ocdb.h ===
/*=--------------------------------------------------------------------------=
 * ocdb.h
 *=--------------------------------------------------------------------------=
 * defines the interfaces and constants for use with the OLE Controls Data
 * binding interfaces.
 *
 * Copyright (c) 1994-1995 Microsoft Corporation, All Rights Reserved.
 *
 *
 *
 */
#ifndef __OCDB_H_

#undef Delete
#ifdef __cplusplus
extern "C" {
#endif

/* LPDBSTRs are MultiByte in 16bits, and Unicode in 32bits.
 */
#ifdef WIN16

#define LPDBSTR           LPSTR
#define DBCHAR            char
#define ldbstrlen(str)    lstrlen(str)
#define ldbstrcpy(a, b)   lstrcpy((a), (b))
#define ldbstrcpyn(a,b,n) lstrcpyn((a), (b), (n))
#define ldbstrcmp(a, b)   lstrcmp((a), (b))
#define ldbstrcat(a, b)   lstrcat((a), (b))
#define ldbstrcmpi(a,b)   lstrcmpi((a),(b))
#define DBTEXT(quote)     quote

#else

#define LPDBSTR           LPWSTR
#define DBCHAR            WCHAR
#define ldbstrlen(str)    wcslen(str)
#define ldbstrcpy(a, b)   wcscpy((a), (b))
#define ldbstrcpyn(a,b,n) wcsncpy((a), (b), (n))
#define ldbstrcmp(a, b)   wcscmp((a), (b))
#define ldbstrcat(a, b)   wcscat((a), (b))
#define ldbstrcmpi(a,b)   wcsicmp((a),(b))
#define DBTEXT(quote)     L##quote

#endif /* WIN16 */

typedef LPDBSTR FAR *  LPLPDBSTR;


/* Many systems don't have BLOBs defined.
 */
#ifndef _tagBLOB_DEFINED
#define _tagBLOB_DEFINED
#define _BLOB_DEFINED
#define _LPBLOB_DEFINED

typedef struct tagBLOB {

    ULONG cbSize;
    BYTE *pBlobData;

} BLOB, *LPBLOB;

#endif

/*----------------------------------------------------------------------------
 *
 *	dbvar.h
 *
 *----------------------------------------------------------------------------
 */
#ifndef _DBCOLUMNID_DEFINED
#define _DBCOLUMNID_DEFINED
typedef enum tagDBCOLKIND
  {
	DBCOLKIND_GUID_NAME = 0,
	DBCOLKIND_GUID_NUMBER = 1,
        DBCOLKIND_NAME = 2
  }
DBCOLKIND;

#define GUID_NAMEONLY	{0x88c8d398,0x863c,0x101b,{0xac,0x3b,0x00,0xaa,0x00,0x44,0x77,0x3d}}
#define GUID_NUMBERONLY	{0x88c8d399,0x863c,0x101b,{0xac,0x3b,0x00,0xaa,0x00,0x44,0x77,0x3d}}

typedef struct tagDBCOLUMNID
  {
  GUID guid;
  DBCOLKIND dwKind;
union
    {
    LONG lNumber;
    LPDBSTR lpdbsz;
    }
  ;
  }
DBCOLUMNID;
#endif   /* ndef _COLUMNID_DEFINED */

/* "DB" replaced by "OCDB" to avoid conflict with <oledb.h> */
#ifndef _DBVARENUM_DEFINED
#define _DBVARENUM_DEFINED
enum DBVARENUM
  {
	OCDBTYPE_EMPTY = 0,
	OCDBTYPE_NULL = 1,
	OCDBTYPE_I2 = 2,
	OCDBTYPE_I4 = 3,
	OCDBTYPE_R4 = 4,
	OCDBTYPE_R8 = 5,
	OCDBTYPE_CY = 6,
	OCDBTYPE_DATE = 7,
	OCDBTYPE_BOOL = 11,
	OCDBTYPE_UI2 = 18,
	OCDBTYPE_UI4 = 19,
        OCDBTYPE_I8 = 20,
        OCDBTYPE_UI8 = 21,
	OCDBTYPE_HRESULT = 25,
	OCDBTYPE_LPSTR = 30,
	OCDBTYPE_LPWSTR = 31,
	OCDBTYPE_FILETIME = 64,
	OCDBTYPE_BLOB = 65,
	OCDBTYPE_UUID = 72,
	OCDBTYPE_DBEXPR = 503,
	OCDBTYPE_COLUMNID = 507,
	OCDBTYPE_BYTES = 508,
	OCDBTYPE_CHARS = 509,
	OCDBTYPE_WCHARS = 510,
	OCDBTYPE_ANYVARIANT = 511
  }
;
#endif   /* ndef _DBVARENUM_DEFINED */

#define DBTYPE_EXT      0x100
#define DBTYPE_VECTOR	0x1000

typedef struct tagDBVARIANT DBVARIANT;

struct FARSTRUCT tagDBVARIANT{
    VARTYPE vt;
    unsigned short wReserved1;
    unsigned short wReserved2;
    unsigned short wReserved3;
    union {
      unsigned char bVal;	     /* VT_UI1               */
      short	   iVal;             /* VT_I2                */
      long	   lVal;             /* VT_I4                */
      float	   fltVal;           /* VT_R4                */
      double	   dblVal;           /* VT_R8                */
      VARIANT_BOOL boolVal;          /* VT_BOOL              */
      SCODE	   scode;            /* VT_ERROR             */
      CY	   cyVal;            /* VT_CY                */
      DATE	   date;             /* VT_DATE              */
      BSTR	   bstrVal;          /* VT_BSTR              */
      IUnknown	   FAR* punkVal;     /* VT_UNKNOWN           */
      IDispatch	   FAR* pdispVal;    /* VT_DISPATCH          */
      SAFEARRAY	   FAR* parray;	     /* VT_ARRAY|*           */

      unsigned char FAR *pbVal;      /* VT_BYREF|VT_UI1      */
      short	   FAR* piVal;       /* VT_BYREF|VT_I2	     */
      long	   FAR* plVal;       /* VT_BYREF|VT_I4	     */
      float	   FAR* pfltVal;     /* VT_BYREF|VT_R4       */
      double	   FAR* pdblVal;     /* VT_BYREF|VT_R8       */
      VARIANT_BOOL FAR* pbool;       /* VT_BYREF|VT_BOOL     */
      SCODE	   FAR* pscode;      /* VT_BYREF|VT_ERROR    */
      CY	   FAR* pcyVal;      /* VT_BYREF|VT_CY       */
      DATE	   FAR* pdate;       /* VT_BYREF|VT_DATE     */
      BSTR	   FAR* pbstrVal;    /* VT_BYREF|VT_BSTR     */
      IUnknown  FAR* FAR* ppunkVal;  /* VT_BYREF|VT_UNKNOWN  */
      IDispatch FAR* FAR* ppdispVal; /* VT_BYREF|VT_DISPATCH */
      SAFEARRAY FAR* FAR* pparray;   /* VT_BYREF|VT_ARRAY|*  */
      VARIANT	   FAR* pvarVal;     /* VT_BYREF|VT_VARIANT  */

      void	   FAR* byref;	     /* Generic ByRef        */

      // types new to DBVARIANTs
      //
      BLOB         blob;             /* VT_BLOB              */
      DBCOLUMNID  *pColumnid;        /* DBTYPE_COLUMNID      */
      LPSTR        pszVal;           /* VT_LPSTR             */
#ifdef WIN32
      LPWSTR       pwszVal;          /* VT_LPWSTR            */
      LPWSTR FAR  *ppwszVal;         /* VT_LPWSTR|VT_BYREF   */
#endif /* WIN32 */
      BLOB FAR    *pblob;            /* VT_BYREF|VT_BLOB     */
      DBCOLUMNID **ppColumnid;       /* VT_BYREF|DBTYPE_COLID*/
      DBVARIANT   *pdbvarVal;        /* VT_BYREF|DBTYPE_VARIANT */
    }
#if defined(NONAMELESSUNION) || (defined(_MAC) && !defined(__cplusplus) && !defined(_MSC_VER))
    u
#endif
    ;
};

/*----------------------------------------------------------------------------
 *
 *	dbs.h
 *
 *----------------------------------------------------------------------------
 */
typedef enum tagDBROWFETCH
  {
	DBROWFETCH_DEFAULT = 0,
	DBROWFETCH_CALLEEALLOCATES = 1,
	DBROWFETCH_FORCEREFRESH = 2
  }
DBROWFETCH;

typedef struct tagDBFETCHROWS
  {
  ULONG      cRowsRequested;
  DWORD      dwFlags;
  VOID HUGEP *pData;
  VOID HUGEP *pVarData;
  ULONG      cbVarData;
  ULONG      cRowsReturned;
  }
DBFETCHROWS;

#define DB_NOMAXLENGTH   (DWORD)0
#define DB_NOVALUE       (DWORD)0xFFFFFFFF
#define DB_NULL          (DWORD)0xFFFFFFFF
#define DB_EMPTY         (DWORD)0xFFFFFFFE
#define DB_USEENTRYID    (DWORD)0xFFFFFFFD
#define DB_CANTCOERCE    (DWORD)0xFFFFFFFC
#define DB_TRUNCATED     (DWORD)0xFFFFFFFB
#define DB_UNKNOWN       (DWORD)0xFFFFFFFA
#define DB_NOINFO        (DWORD)0xFFFFFFF9

/* "DB" replaced by "OCDB" to avoid conflict with <oledb.h> */
typedef enum tagOCDBBINDING
  {
	OCDBBINDING_DEFAULT = 0,
	OCDBBINDING_VARIANT = 1,
	OCDBBINDING_ENTRYID = 2
  }
OCDBBINDING;

typedef enum tagDBBINDTYPE
  {
        DBBINDTYPE_DATA    = 0,
	DBBINDTYPE_ENTRYID = 1,
	DBBDINTYPE_EITHER  = 2,
	DBBINDTYPE_BOTH    = 3
  }
DBBINDTYPE;

typedef enum tagDBCOMPUTED
  {
	DBCOMPUTED_COMPUTED = 0,
	DBCOMPUTED_DYNAMIC = 1,
	DBCOMPUTED_NOTCOMPUTED =2
  }
DBCOMPUTED;

typedef struct tagDBCOLUMNBINDING
  {
  DBCOLUMNID columnID;
  ULONG obData;
  ULONG cbMaxLen;
  ULONG obVarDataLen;
  ULONG obInfo;
  DWORD dwBinding;
  DWORD dwDataType;
  }
DBCOLUMNBINDING;

typedef struct tagDBBINDPARAMS
  {
  ULONG cbMaxLen;
  DWORD dwBinding;
  DWORD dwDataType;
  ULONG cbVarDataLen;
  DWORD dwInfo;
  void *pData;
  }
DBBINDPARAMS;

#define CID_NUMBER_INVALID            -1
#define CID_NUMBER_AUTOINCREMENT       0
#define CID_NUMBER_BASECOLUMNNAME      1
#define CID_NUMBER_BASENAME            2
#define CID_NUMBER_BINARYCOMPARABLE    3
#define CID_NUMBER_BINDTYPE            4
#define CID_NUMBER_CASESENSITIVE       5
#define CID_NUMBER_COLLATINGORDER      6
#define CID_NUMBER_COLUMNID            7
#define CID_NUMBER_CURSORCOLUMN        8
#define CID_NUMBER_DATACOLUMN          9
#define CID_NUMBER_DEFAULTVALUE        10
#define CID_NUMBER_ENTRYIDMAXLENGTH    11
#define CID_NUMBER_FIXED               12
#define CID_NUMBER_HASDEFAULT          13
#define CID_NUMBER_MAXLENGTH           14
#define CID_NUMBER_MULTIVALUED         15
#define CID_NUMBER_NAME                16
#define CID_NUMBER_NULLABLE            17
#define CID_NUMBER_PHYSICALSORT        18
#define CID_NUMBER_NUMBER              19
#define CID_NUMBER_ROWENTRYID          20
#define CID_NUMBER_SCALE               21
#define CID_NUMBER_SEARCHABLE          22
#define CID_NUMBER_TYPE                23
#define CID_NUMBER_UNIQUE              24
#define CID_NUMBER_UPDATABLE           25
#define CID_NUMBER_VERSION             26
#define CID_NUMBER_STATUS              27

/* c and C++ have different meanings for const.
 */
#ifdef __cplusplus
#define EXTERNAL_DEFN    extern const
#else
#define EXTERNAL_DEFN    const
#endif /* __cplusplus */



/* "DB" replaced by "OCDB" to avoid conflict with <oledb.h> */
#define OCDBCIDGUID {0xfe284700L,0xd188,0x11cd,{0xad,0x48, 0x0,0xaa, 0x0,0x3c,0x9c,0xb6}}
#ifdef DBINITCONSTANTS

EXTERNAL_DEFN DBCOLUMNID NEAR COLUMNID_INVALID         = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, -1};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_AUTOINCREMENT     = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 0};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BASECOLUMNNAME    = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 1};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BASENAME          = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 2};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BINARYCOMPARABLE  = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 3};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BINDTYPE          = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 4};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_CASESENSITIVE     = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 5};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_COLLATINGORDER    = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 6};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_COLUMNID          = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 7};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_CURSORCOLUMN      = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 8};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_DATACOLUMN        = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 9};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_DEFAULTVALUE      = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 10};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_ENTRYIDMAXLENGTH  = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 11};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_FIXED             = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 12};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_HASDEFAULT        = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 13};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_MAXLENGTH         = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 14};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_MULTIVALUED       = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 15};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_NAME              = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 16};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_NULLABLE          = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 17};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_PHYSICALSORT      = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 18};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_NUMBER            = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 19};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_ROWENTRYID        = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 20};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_SCALE             = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 21};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_SEARCHABLE        = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 22};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_TYPE              = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 23};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_UNIQUE            = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 24};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_UPDATABLE         = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 25};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_VERSION           = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 26};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_STATUS            = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 27};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_COMPUTED          = {OCDBCIDGUID, DBCOLKIND_GUID_NUMBER, 28};
#else
extern const DBCOLUMNID NEAR COLUMNID_INVALID;
extern const DBCOLUMNID NEAR COLUMN_AUTOINCREMENT;
extern const DBCOLUMNID NEAR COLUMN_BASECOLUMNNAME;
extern const DBCOLUMNID NEAR COLUMN_BASENAME;
extern const DBCOLUMNID NEAR COLUMN_BINARYCOMPARABLE;
extern const DBCOLUMNID NEAR COLUMN_BINDTYPE;
extern const DBCOLUMNID NEAR COLUMN_CASESENSITIVE;
extern const DBCOLUMNID NEAR COLUMN_COLLATINGORDER;
extern const DBCOLUMNID NEAR COLUMN_COLUMNID;
extern const DBCOLUMNID NEAR COLUMN_CURSORCOLUMN;
extern const DBCOLUMNID NEAR COLUMN_DATACOLUMN;
extern const DBCOLUMNID NEAR COLUMN_DEFAULTVALUE;
extern const DBCOLUMNID NEAR COLUMN_ENTRYIDMAXLENGTH;
extern const DBCOLUMNID NEAR COLUMN_FIXED;
extern const DBCOLUMNID NEAR COLUMN_HASDEFAULT;
extern const DBCOLUMNID NEAR COLUMN_MAXLENGTH;
extern const DBCOLUMNID NEAR COLUMN_MULTIVALUED;
extern const DBCOLUMNID NEAR COLUMN_NAME;
extern const DBCOLUMNID NEAR COLUMN_NULLABLE;
extern const DBCOLUMNID NEAR COLUMN_PHYSICALSORT;
extern const DBCOLUMNID NEAR COLUMN_NUMBER;
extern const DBCOLUMNID NEAR COLUMN_ROWENTRYID;
extern const DBCOLUMNID NEAR COLUMN_SCALE;
extern const DBCOLUMNID NEAR COLUMN_SEARCHABLE;
extern const DBCOLUMNID NEAR COLUMN_TYPE;
extern const DBCOLUMNID NEAR COLUMN_UNIQUE;
extern const DBCOLUMNID NEAR COLUMN_UPDATABLE;
extern const DBCOLUMNID NEAR COLUMN_VERSION;
extern const DBCOLUMNID NEAR COLUMN_STATUS;
extern const DBCOLUMNID NEAR COLUMN_COMPUTED;
#endif

#define BMK_NUMBER_BMKTEMPORARY    0
#define BMK_NUMBER_BMKTEMPORARYREL 1
#define BMK_NUMBER_BMKCURSOR       2
#define BMK_NUMBER_BMKCURSORREL    3
#define BMK_NUMBER_BMKSESSION      4
#define BMK_NUMBER_BMKSESSIONREL   5
#define BMK_NUMBER_BMKPERSIST      6
#define BMK_NUMBER_BMKPERSISTREL   7


#define DBBMKGUID {0xf6304bb0L,0xd188,0x11cd,{0xad,0x48, 0x0,0xaa, 0x0,0x3c,0x9c,0xb6}}
#ifdef DBINITCONSTANTS
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKTEMPORARY      = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 0};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKTEMPORARYREL   = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 1};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKCURSOR         = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 2};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKCURSORREL      = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 3};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKSESSION        = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 4};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKSESSIONREL     = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 5};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKPERSIST        = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 6};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKPERSISTREL     = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 7};
#else
extern const DBCOLUMNID NEAR COLUMN_BMKINVALID;
extern const DBCOLUMNID NEAR COLUMN_BMKTEMPORARY;
extern const DBCOLUMNID NEAR COLUMN_BMKTEMPORARYREL;
extern const DBCOLUMNID NEAR COLUMN_BMKCURSOR;
extern const DBCOLUMNID NEAR COLUMN_BMKCURSORREL;
extern const DBCOLUMNID NEAR COLUMN_BMKSESSION;
extern const DBCOLUMNID NEAR COLUMN_BMKSESSIONREL;
extern const DBCOLUMNID NEAR COLUMN_BMKPERSIST;
extern const DBCOLUMNID NEAR COLUMN_BMKPERSISTREL;
#endif

/* "DB" replaced by "OCDB" to avoid conflict with <oledb.h> */
#define DB_BMK_SIZE        sizeof(BYTE)
#ifdef DBINITCONSTANTS
EXTERNAL_DEFN BYTE NEAR OCDBBMK_INVALID   = 0x0;
EXTERNAL_DEFN BYTE NEAR OCDBBMK_CURRENT   = 0x1;
EXTERNAL_DEFN BYTE NEAR OCDBBMK_BEGINNING = 0x2;
EXTERNAL_DEFN BYTE NEAR OCDBBMK_END       = 0x3;
#else
extern const BYTE NEAR OCDBBMK_INVALID;
extern const BYTE NEAR OCDBBMK_CURRENT;
extern const BYTE NEAR OCDBBMK_BEGINNING;
extern const BYTE NEAR OCDBBMK_END;
#endif

typedef enum tagDBCOLUMNBINDOPTS
  {
	DBCOLUMNBINDOPTS_REPLACE = 0,
	DBCOLUMNBINDOPTS_ADD = 1
  }
DBCOLUMNBINDOPTS;

typedef enum tagDBUPDATELOCK
  {
	DBUPDATELOCK_PESSIMISTIC = 0,
	DBUPDATELOCK_OPTIMISTIC = 1
  }
DBUPDATELOCK;

typedef enum tagDBCOLUMNDATA
  {
	DBCOLUMNDATA_UNCHANGED = 0,
	DBCOLUMNDATA_CHANGED = 1,
        DBCOLUMNDATA_UNKNOWN = 2
  }
DBCOLUMNDATA;

typedef enum tagDBROWACTION
  {
	DBROWACTION_IGNORE = 0,
	DBROWACTION_UPDATE = 1,
	DBROWACTION_DELETE = 2,
	DBROWACTION_ADD = 3,
	DBROWACTION_LOCK = 4,
	DBROWACTION_UNLOCK = 5
  }
DBROWACTION;

typedef enum tagDBUPDATEABLE
  {
	DBUPDATEABLE_UPDATEABLE = 0,
	DBUPDATEABLE_NOTUPDATEABLE = 1,
	DBUPDATEABLE_UNKNOWN = 2
  }
DBUPDATEABLE;

typedef struct tagOCDBROWSTATUS
  {
  HRESULT hrStatus;
  BLOB Bookmark;
  }
OCDBROWSTATUS;

typedef enum tagDBEVENTWHATS
  {
	DBEVENT_CURRENT_ROW_CHANGED = 1,
	DBEVENT_CURRENT_ROW_DATA_CHANGED = 2,
	DBEVENT_NONCURRENT_ROW_DATA_CHANGED = 4,
	DBEVENT_SET_OF_COLUMNS_CHANGED = 8,
	DBEVENT_ORDER_OF_COLUMNS_CHANGED = 16,
	DBEVENT_SET_OF_ROWS_CHANGED = 32,
	DBEVENT_ORDER_OF_ROWS_CHANGED = 64,
	DBEVENT_METADATA_CHANGED = 128,
	DBEVENT_ASYNCH_OP_FINISHED = 256,
	DBEVENT_FIND_CRITERIA_CHANGED = 512
  }
DBEVENTWHATS;

/* "DB" replaced by "OCDB" to avoid conflict with <oledb.h> */
typedef enum tagOCDBREASON
  {
	OCDBREASON_DELETED = 1,
	OCDBREASON_INSERTED = 2,
	OCDBREASON_MODIFIED = 3,
	OCDBREASON_REMOVEDFROMCURSOR = 4,
	OCDBREASON_MOVEDINCURSOR = 5,
	OCDBREASON_MOVE = 6,
	OCDBREASON_FIND = 7,
	OCDBREASON_NEWINDEX = 8,
	OCDBREASON_ROWFIXUP = 9,
	OCDBREASON_RECALC = 10,
	OCDBREASON_REFRESH = 11,
	OCDBREASON_NEWPARAMETERS = 12,
	OCDBREASON_SORTCHANGED = 13,
	OCDBREASON_FILTERCHANGED = 14,
	OCDBREASON_QUERYSPECCHANGED = 15,
	OCDBREASON_SEEK = 16,
	OCDBREASON_PERCENT = 17,
	OCDBREASON_FINDCRITERIACHANGED = 18,
	OCDBREASON_SETRANGECHANGED = 19,
	OCDBREASON_ADDNEW = 20,
	OCDBREASON_MOVEPERCENT = 21,
	OCDBREASON_BEGINTRANSACT = 22,
	OCDBREASON_ROLLBACK = 23,
	OCDBREASON_COMMIT = 24,
	OCDBREASON_CLOSE = 25,
	OCDBREASON_BULK_ERROR = 26,
	OCDBREASON_BULK_NOTTRANSACTABLE = 27,
	OCDBREASON_BULK_ABOUTTOEXECUTE = 28,
        OCDBREASON_CANCELUPDATE = 29,
        OCDBREASON_SETCOLUMN = 30,
        OCDBREASON_EDIT = 31,
        OCDBREASON_UNLOAD = 32
  }
OCDBREASON;

// Arg1 values for DBREASON_FIND
typedef enum tagDBFINDTYPES
  {
  DB_FINDFIRST = 1,
  DB_FINDLAST = 2,
  DB_FINDNEXT = 3,
  DB_FINDPRIOR = 4,
  DB_FIND = 5
  }
DBFINDTYPES;

typedef struct tagDBNOTIFYREASON
  {
  DWORD dwReason;
  DBVARIANT arg1;
  DBVARIANT arg2;
  }
DBNOTIFYREASON;

#define OCDB_E_BADBINDINFO           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e00)
#define OCDB_E_BADBOOKMARK           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e01)
#define OCDB_E_BADCOLUMNID           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e02)
#define OCDB_E_BADCRITERIA           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e03)
#define OCDB_E_BADENTRYID            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e04)
#define OCDB_E_BADFRACTION           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e05)
#define OCDB_E_BADINDEXID            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e06)
#define OCDB_E_BADQUERYSPEC          MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e07)
#define OCDB_E_BADSORTORDER          MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e08)
#define OCDB_E_BADVALUES             MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e09)
#define OCDB_E_CANTCOERCE            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0a)
#define OCDB_E_CANTLOCK              MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0b)
#define OCDB_E_COLUMNUNAVAILABLE     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0c)
#define OCDB_E_DATACHANGED           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0d)
#define OCDB_E_INVALIDCOLUMNORDINAL  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0e)
#define OCDB_E_INVALIDINTERFACE      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0f)
#define OCDB_E_LOCKFAILED            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e10)
#define OCDB_E_ROWDELETED            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e11)
#define OCDB_E_ROWTOOSHORT           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e12)
#define OCDB_E_SCHEMAVIOLATION       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e13)
#define OCDB_E_SEEKKINDNOTSUPPORTED  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e14)
#define OCDB_E_UPDATEINPROGRESS      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e15)
#define OCDB_E_USEENTRYID            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e16)
#define OCDB_E_STATEERROR            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e17)
#define OCDB_E_BADFETCHINFO          MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e18)
#define OCDB_E_NOASYNC               MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e19)
#define OCDB_E_ENTRYIDOPEN           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e1a)
#define OCDB_E_BUFFERTOOSMALL        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e1b)
#define OCDB_S_BUFFERTOOSMALL        MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec0)
#define OCDB_S_CANCEL                MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec1)
#define OCDB_S_DATACHANGED           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec2)
#define OCDB_S_ENDOFCURSOR           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec3)
#define OCDB_S_ENDOFRESULTSET        MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec4)
#define OCDB_S_OPERATIONCANCELLED    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec5)
#define OCDB_S_QUERYINTERFACE        MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec6)
#define OCDB_S_WORKINGASYNC          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec7)

#define OCDB_S_MOVEDTOFIRST          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec9)
#define OCDB_S_CURRENTROWUNCHANGED   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0eca)
#define OCDB_S_ROWADDED              MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ecb)
#define OCDB_S_ROWUPDATED            MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ecc)
#define OCDB_S_ROWDELETED            MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ecd)

/*----------------------------------------------------------------------------
 *
 *	ICursor
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursor ICursor;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursor;

interface ICursor : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE GetColumnsCursor
    (
	REFIID riid,
	IUnknown **ppvColumnsCursor,
	ULONG *pcRows
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetBindings
    (
	ULONG cCol,
	DBCOLUMNBINDING rgBoundColumns[],
	ULONG cbRowLength,
	DWORD dwFlags
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetBindings
    (
	ULONG *pcCol,
	DBCOLUMNBINDING *prgBoundColumns[],
	ULONG *pcbRowLength
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetNextRows
    (
	LARGE_INTEGER udlRowsToSkip,
	DBFETCHROWS *pFetchParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Requery
    (
        void
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursor;

typedef struct ICursorVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursor FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursor FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursor FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumnsCursor)
    (
        ICursor FAR *this,
	REFIID riid,
	IUnknown **ppvColumnsCursor,
	ULONG *pcRows
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetBindings)
    (
        ICursor FAR *this,
	ULONG cCol,
	DBCOLUMNBINDING rgBoundColumns[],
	ULONG cbRowLength,
	DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBindings)
    (
        ICursor FAR *this,
	ULONG *pcCol,
	DBCOLUMNBINDING *prgBoundColumns[],
	ULONG *pcbRowLength
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetNextRows)
    (
        ICursor FAR *this,
	LARGE_INTEGER udlRowsToSkip,
	DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *Requery)
    (
        ICursor FAR *this
    );

} ICursorVtbl;

interface ICursor
{
    ICursorVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursor_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursor_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursor_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursor_GetColumnsCursor(pI, riid, ppvColumnsCursor, pcRows) \
    (*(pI)->lpVtbl->GetColumnsCursor)((pI), riid, ppvColumnsCursor, pcRows)

#define ICursor_SetBindings(pI, cCol, rgBoundColumns, cbRowLength, dwFlags) \
    (*(pI)->lpVtbl->SetBindings)((pI), cCol, rgBoundColumns, cbRowLength, dwFlags)

#define ICursor_GetBindings(pI, pcCol, prgBoundColumns, pcbRowLength) \
    (*(pI)->lpVtbl->GetBindings)((pI), pcCol, prgBoundColumns, pcbRowLength)

#define ICursor_GetNextRows(pI, udlRowsToSkip, pFetchParams) \
    (*(pI)->lpVtbl->GetNextRows)((pI), udlRowsToSkip, pFetchParams)

#define ICursor_Requery(pI) \
    (*(pI)->lpVtbl->Requery)((pI))

#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *	ICursorMove
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorMove ICursorMove;

typedef enum tagDBCLONEOPTS
  {
	DBCLONEOPTS_DEFAULT = 0,
	DBCLONEOPTS_SAMEROW = 1
  }
DBCLONEOPTS;


#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorMove;

interface ICursorMove : public ICursor
{
public:
    virtual HRESULT STDMETHODCALLTYPE Move
    (
	ULONG cbBookmark,
	void *pBookmark,
	LARGE_INTEGER dlOffset,
	DBFETCHROWS *pFetchParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetBookmark
    (
	DBCOLUMNID *pBookmarkType,
	ULONG cbMaxSize,
	ULONG *pcbBookmark,
	void *pBookmark
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Clone
    (
	DWORD dwFlags,
	REFIID riid,
	IUnknown **ppvClonedCursor
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursorMove;

typedef struct ICursorMoveVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorMove FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorMove FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorMove FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumnsCursor)
    (
        ICursorMove FAR *this,
	REFIID riid,
	IUnknown **ppvColumnsCursor,
	ULONG *pcRows
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetBindings)
    (
        ICursorMove FAR *this,
	ULONG cCol,
	DBCOLUMNBINDING rgBoundColumns[],
	ULONG cbRowLength,
	DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBindings)
    (
        ICursorMove FAR *this,
	ULONG *pcCol,
	DBCOLUMNBINDING *prgBoundColumns[],
	ULONG *pcbRowLength
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetNextRows)
    (
        ICursorMove FAR *this,
	LARGE_INTEGER udlRowsToSkip,
	DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *Requery)
    (
        ICursorMove FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *Move)
    (
        ICursorMove FAR *this,
	ULONG cbBookmark,
	void *pBookmark,
	LARGE_INTEGER dlOffset,
	DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBookmark)
    (
        ICursorMove FAR *this,
	DBCOLUMNID *pBookmarkType,
	ULONG cbMaxSize,
	ULONG *pcbBookmark,
	void *pBookmark
    );

    HRESULT (STDMETHODCALLTYPE FAR *Clone)
    (
        ICursorMove FAR *this,
	DWORD dwFlags,
	REFIID riid,
	IUnknown **ppvClonedCursor
    );

} ICursorMoveVtbl;

interface ICursorMove
{
    ICursorMoveVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorMove_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorMove_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorMove_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorMove_GetColumnsCursor(pI, riid, ppvColumnsCursor, pcRows) \
    (*(pI)->lpVtbl->GetColumnsCursor)((pI), riid, ppvColumnsCursor, pcRows)

#define ICursorMove_SetBindings(pI, cCol, rgBoundColumns, cbRowLength, dwFlags) \
    (*(pI)->lpVtbl->SetBindings)((pI), cCol, rgBoundColumns, cbRowLength, dwFlags)

#define ICursorMove_GetBindings(pI, pcCol, prgBoundColumns, pcbRowLength) \
    (*(pI)->lpVtbl->GetBindings)((pI), pcCol, prgBoundColumns, pcbRowLength)

#define ICursorMove_GetNextRows(pI, udlRowsToSkip, pFetchParams) \
    (*(pI)->lpVtbl->GetNextRows)((pI), udlRowsToSkip, pFetchParams)

#define ICursorMove_Requery(pI) \
    (*(pI)->lpVtbl->Requery)((pI))

#define ICursorMove_Move(pI, cbBookmark, pBookmark, dlOffset, pFetchParams) \
    (*(pI)->lpVtbl->Move)((pI), cbBookmark, pBookmark, dlOffset, pFetchParams)

#define ICursorMove_GetBookmark(pI, pBookmarkType, cbMaxSize, pcbBookmark, pBookmark) \
    (*(pI)->lpVtbl->GetBookmark)((pI), pBookmarkType, cbMaxSize, pcbBookmark, pBookmark)

#define ICursorMove_Clone(pI, dwFlags, riid, ppvClonedCursor) \
    (*(pI)->lpVtbl->Clone)((pI), dwFlags, riid, ppvClonedCursor)
#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *	ICursorScroll
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorScroll ICursorScroll;

typedef enum tagDBCURSORPOPULATED
  {
	DBCURSORPOPULATED_FULLY = 0,
	DBCURSORPOPULATED_PARTIALLY = 1
  }
DBCURSORPOPULATED;


#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorScroll;

interface ICursorScroll : public ICursorMove
{
public:
    virtual HRESULT STDMETHODCALLTYPE Scroll
    (
	ULONG ulNumerator,
	ULONG ulDenominator,
	DBFETCHROWS *pFetchParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetApproximatePosition
    (
	ULONG cbBookmark,
	void *pBookmark,
	ULONG *pulNumerator,
	ULONG *pulDenominator
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetApproximateCount
    (
	LARGE_INTEGER *pudlApproxCount,
	DWORD *pdwFullyPopulated
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursorScroll;

typedef struct ICursorScrollVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorScroll FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorScroll FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorScroll FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumnsCursor)
    (
        ICursorScroll FAR *this,
	REFIID riid,
	IUnknown **ppvColumnsCursor,
	ULONG *pcRows
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetBindings)
    (
        ICursorScroll FAR *this,
	ULONG cCol,
	DBCOLUMNBINDING rgBoundColumns[],
	ULONG cbRowLength,
	DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBindings)
    (
        ICursorScroll FAR *this,
	ULONG *pcCol,
	DBCOLUMNBINDING *prgBoundColumns[],
	ULONG *pcbRowLength
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetNextRows)
    (
        ICursorScroll FAR *this,
	LARGE_INTEGER udlRowsToSkip,
	DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *Requery)
    (
        ICursorScroll FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *Move)
    (
        ICursorScroll FAR *this,
	ULONG cbBookmark,
	void *pBookmark,
	LARGE_INTEGER dlOffset,
	DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBookmark)
    (
        ICursorScroll FAR *this,
	DBCOLUMNID *pBookmarkType,
	ULONG cbMaxSize,
	ULONG *pcbBookmark,
	void *pBookmark
    );

    HRESULT (STDMETHODCALLTYPE FAR *Clone)
    (
        ICursorScroll FAR *this,
	DWORD dwFlags,
	REFIID riid,
	IUnknown **ppvClonedCursor
    );

    HRESULT (STDMETHODCALLTYPE FAR *Scroll)
    (
        ICursorScroll FAR *this,
	ULONG ulNumerator,
	ULONG ulDenominator,
	DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetApproximatePosition)
    (
        ICursorScroll FAR *this,
	ULONG cbBookmark,
	void *pBookmark,
	ULONG *pulNumerator,
	ULONG *pulDenominator
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetApproximateCount)
    (
        ICursorScroll FAR *this,
	LARGE_INTEGER *pudlApproxCount,
	DWORD *pdwFullyPopulated
    );

} ICursorScrollVtbl;

interface ICursorScroll
{
    ICursorScrollVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorScroll_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorScroll_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorScroll_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorScroll_GetColumnsCursor(pI, riid, ppvColumnsCursor, pcRows) \
    (*(pI)->lpVtbl->GetColumnsCursor)((pI), riid, ppvColumnsCursor, pcRows)

#define ICursorScroll_SetBindings(pI, cCol, rgBoundColumns, cbRowLength, dwFlags) \
    (*(pI)->lpVtbl->SetBindings)((pI), cCol, rgBoundColumns, cbRowLength, dwFlags)

#define ICursorScroll_GetBindings(pI, pcCol, prgBoundColumns, pcbRowLength) \
    (*(pI)->lpVtbl->GetBindings)((pI), pcCol, prgBoundColumns, pcbRowLength)

#define ICursorScroll_GetNextRows(pI, udlRowsToSkip, pFetchParams) \
    (*(pI)->lpVtbl->GetNextRows)((pI), udlRowsToSkip, pFetchParams)

#define ICursorScroll_Requery(pI) \
    (*(pI)->lpVtbl->Requery)((pI))

#define ICursorScroll_Move(pI, cbBookmark, pBookmark, dlOffset, pFetchParams) \
    (*(pI)->lpVtbl->Move)((pI), cbBookmark, pBookmark, dlOffset, pFetchParams)

#define ICursorScroll_GetBookmark(pI, pBookmarkType, cbMaxSize, pcbBookmark, pBookmark) \
    (*(pI)->lpVtbl->GetBookmark)((pI), pBookmarkType, cbMaxSize, pcbBookmark, pBookmark)

#define ICursorScroll_Clone(pI, dwFlags, riid, ppvClonedCursor) \
    (*(pI)->lpVtbl->Clone)((pI), dwFlags, riid, ppvClonedCursor)

#define ICursorScroll_Scroll(pI, ulNumerator, ulDenominator, pFetchParams) \
    (*(pI)->lpVtbl->Scroll)((pI), ulNumerator, ulDenominator, pFetchParams)

#define ICursorScroll_GetApproximatePosition(pI, cbBookmark, pBookmark, pulNumerator, pulDenominator) \
    (*(pI)->lpVtbl->GetApproximatePosition)((pI), cbBookmark, pBookmark, pulNumerator, pulDenominator)

#define ICursorScroll_GetApproximateCount(pI, pudlApproxCount, pdwFullyPopulated) \
    (*(pI)->lpVtbl->GetApproximateCount)((pI), pudlApproxCount, pdwFullyPopulated)
#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *	ICursorUpdateARow
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorUpdateARow ICursorUpdateARow;

typedef enum tagDBEDITMODE
  {
	DBEDITMODE_NONE = 1,
	DBEDITMODE_UPDATE = 2,
	DBEDITMODE_ADD = 3
  }
DBEDITMODE;


#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorUpdateARow;

interface ICursorUpdateARow : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE BeginUpdate
    (
	DWORD dwFlags
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetColumn
    (
	DBCOLUMNID *pcid,
	DBBINDPARAMS *pBindParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetColumn
    (
	DBCOLUMNID *pcid,
	DBBINDPARAMS *pBindParams,
	DWORD *pdwFlags
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetEditMode
    (
	DWORD *pdwState
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Update
    (
	DBCOLUMNID *pBookmarkType,
	ULONG *pcbBookmark,
	void **ppBookmark
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Cancel
    (
        void
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Delete
    (
	void
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursorUpdateARow;

typedef struct ICursorUpdateARowVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorUpdateARow FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorUpdateARow FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorUpdateARow FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *BeginUpdate)
    (
        ICursorUpdateARow FAR *this,
	DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetColumn)
    (
        ICursorUpdateARow FAR *this,
	DBCOLUMNID *pcid,
	DBBINDPARAMS *pBindParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumn)
    (
        ICursorUpdateARow FAR *this,
	DBCOLUMNID *pcid,
	DBBINDPARAMS *pBindParams,
	DWORD *pdwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetEditMode)
    (
        ICursorUpdateARow FAR *this,
	DWORD *pdwState
    );

    HRESULT (STDMETHODCALLTYPE FAR *Update)
    (
        ICursorUpdateARow FAR *this,
	DBCOLUMNID *pBookmarkType,
	ULONG *pcbBookmark,
	void **ppBookmark
    );

    HRESULT (STDMETHODCALLTYPE FAR *Cancel)
    (
        ICursorUpdateARow FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *Delete)
    (
        ICursorUpdateARow FAR *this
    );

} ICursorUpdateARowVtbl;

interface ICursorUpdateARow
{
    ICursorUpdateARowVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorUpdateARow_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorUpdateARow_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorUpdateARow_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorUpdateARow_BeginUpdate(pI, dwFlags) \
    (*(pI)->lpVtbl->BeginUpdate)((pI), dwFlags)

#define ICursorUpdateARow_SetColumn(pI, pcid, pBindParams) \
    (*(pI)->lpVtbl->SetColumn)((pI), pcid, pBindParams)

#define ICursorUpdateARow_GetColumn(pI, pcid, pBindParams, pdwFlags) \
    (*(pI)->lpVtbl->GetColumn)((pI), pcid, pBindParams, pdwFlags)

#define ICursorUpdateARow_GetEditMode(pI, pdwState) \
    (*(pI)->lpVtbl->GetEditMode)((pI), pdwState)

#define ICursorUpdateARow_Update(pI, pBookmarkType, pcbBookmark, ppBookmark) \
    (*(pI)->lpVtbl->Update)((pI), pBookmarkType, pcbBookmark, ppBookmark)

#define ICursorUpdateARow_Cancel(pI) \
    (*(pI)->lpVtbl->Cancel)((pI))

#define ICursorUpdateARow_Delete(pI) \
    (*(pI)->lpVtbl->Delete)((pI))


#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *	ICursorFind
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorFind ICursorFind;

typedef enum tagDBFINDFLAGS
  {
	DBFINDFLAGS_FINDNEXT = 1,
	DBFINDFLAGS_FINDPRIOR = 2,
	DBFINDFLAGS_INCLUDECURRENT = 4
  }
DBFINDFLAGS;


/* "DB" replaced by "OCDB" to avoid conflict with <oledb.h> */
typedef enum tagOCDBSEEKFLAGS
  {
	OCDBSEEK_LT	 = 1,
	OCDBSEEK_LE	 = 2,
	OCDBSEEK_EQ	 = 3,		// EXACT EQUALITY
	OCDBSEEK_GT	 = 4,
	OCDBSEEK_GE	 = 5,
	OCDBSEEK_PARTIALEQ = 6             // only for strings
  }
OCDBSEEKFLAGS;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorFind;

interface ICursorFind : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE FindByValues
    (
	ULONG            cbBookmark,
	LPVOID           pBookmark,
	DWORD            dwFindFlags,
	ULONG            cValues,
        DBCOLUMNID       rgColumns[],
	DBVARIANT        rgValues[],
	DWORD            rgdwSeekFlags[],
        DBFETCHROWS FAR *pFetchParams
    ) = 0;
};

#else

/* C Language Binding */
//extern const IID IID_ICursorFind;

typedef struct ICursorFindVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorFind FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorFind FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorFind FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *FindByValues)
    (
        ICursorFind FAR *this,
	ULONG            cbBookmark,
	LPVOID           pBookmark,
	DWORD            dwFindFlags,
	ULONG            cValues,
        DBCOLUMNID       rgColumns[],
	DBVARIANT        rgValues[],
	DWORD            rgdwSeekFlags[],
        DBFETCHROWS      pFetchParams
    );


} ICursorFindVtbl;

interface ICursorFind
{
    ICursorFindVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorFind_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorFind_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorFind_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorFind_FindByValues(pI, cbB, pB, dwFF, cV, rgC, rgV, rgSF, pF) \
    (*(pI)->lpVtbl->FindByValues)((pI), cbB, pB, dwFF, cB, rgC, rgV, rgSF, pF)

#endif /* COBJMACROS */

#endif


/*----------------------------------------------------------------------------
 *
 *	IEntryID
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface IEntryID IEntryID;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_IEntryID;

interface IEntryID : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE GetInterface
    (
	ULONG cbEntryID,
	void *pEntryID,
        DWORD dwFlags,
        REFIID riid,
	IUnknown **ppvObj
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_IEntryID;

typedef struct IEntryIDVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        IEntryID FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        IEntryID FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        IEntryID FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetInterface)
    (
        IEntryID FAR *this,
	ULONG cbEntryID,
	void *pEntryID,
        REFIID riid,
	IUnknown **ppvObj
    );

} IEntryIDVtbl;

interface IEntryID
{
    IEntryIDVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define IEntryID_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define IEntryID_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define IEntryID_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define IEntryID_GetInterface(pI, cbEntryID, pEntryID, riid, ppvObj) \
    (*(pI)->lpVtbl->GetInterface)((pI), cbEntryID, pEntryID, riid, ppvObj)
#endif /* COBJMACROS */

#endif


/*----------------------------------------------------------------------------
 *
 *	INotifyDBEvents
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface INotifyDBEvents INotifyDBEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_INotifyDBEvents;

interface INotifyDBEvents : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE OKToDo
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Cancelled
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SyncBefore
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE AboutToDo
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE FailedToDo
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SyncAfter
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DidEvent
    (
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    ) = 0;

};

#else

/* C Language Binding */
extern const IID IID_INotifyDBEvents;

typedef struct INotifyDBEventsVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        INotifyDBEvents FAR *this,
	REFIID riid,
	void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        INotifyDBEvents FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        INotifyDBEvents FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *OKToDo)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *Cancelled)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *SyncBefore)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *AboutToDo)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *FailedToDo)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *SyncAfter)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *DidEvent)
    (
        INotifyDBEvents FAR *this,
	DWORD dwEventWhat,
	ULONG cReasons,
	DBNOTIFYREASON rgReasons[]
    );

} INotifyDBEventsVtbl;

interface INotifyDBEvents
{
    INotifyDBEventsVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define INotifyDBEvents_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define INotifyDBEvents_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define INotifyDBEvents_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define INotifyDBEvents_OKToDo(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->OKToDo)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_Cancelled(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->Cancelled)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_SyncBefore(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->SyncBefore)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_AboutToDo(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->AboutToDo)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_FailedToDo(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->FailedToDo)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_SyncAfter(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->SyncAfter)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_DidEvent(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->DidEvent)((pI), dwEventWhat, cReasons, rgReasons)
#endif /* COBJMACROS */

#endif


#ifdef __cplusplus
}
#endif

#define __OCDB_H_
#endif // __OCDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\vbcursor\olebind.h ===
/*****************************************************************************\
*                                                                             *
* olebind.h     Data binding interfaces for OLE                               *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1994, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#if !defined( _OLEBIND_H_ )
#define _OLEBIND_H_

#if !defined( INITGUID )
#include <olectl.h>
#endif

DEFINE_GUID(IID_IBoundObject,
	0x9BFBBC00,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IBoundObjectSite,
	0x9BFBBC01,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);

typedef interface IBoundObject FAR* LPBOUNDOBJECT;
typedef interface IBoundObjectSite FAR* LPBOUNDOBJECTSITE;

typedef interface ICursor FAR* LPCURSOR;
typedef interface ICursor FAR* FAR* LPLPCURSOR;
typedef interface ICursorMove FAR* LPCURSORMOVE;
typedef interface ICursorScroll FAR* LPCURSORSCROLL;
typedef interface ICursorFind FAR* LPCURSORFIND;
typedef interface ICursorUpdateARow FAR* LPCURSORUPDATEAROW;


//////////////////////////////////////////////////////////////////////////////
//
//  IBoundObject interface
//
//////////////////////////////////////////////////////////////////////////////

#undef  INTERFACE
#define INTERFACE IBoundObject

DECLARE_INTERFACE_(IBoundObject, IUnknown)
{
    //
    //  IUnknown methods
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    //  IBoundObject methods
    //
    STDMETHOD(OnSourceChanged)(THIS_ DISPID dispid, BOOL fBound, BOOL FAR* lpfOwnXferOut) PURE;
    STDMETHOD(IsDirty)(THIS_ DISPID dispid) PURE;
};
//////////////////////////////////////////////////////////////////////////////
//
//  IBoundObjectSite interface
//
//////////////////////////////////////////////////////////////////////////////

#undef  INTERFACE
#define INTERFACE IBoundObjectSite

DECLARE_INTERFACE_(IBoundObjectSite, IUnknown)
{
    //
    //  IUnknown methods
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    //  IBoundObjectSite methods
    //
    STDMETHOD(GetCursor)(THIS_ DISPID dispid, LPLPCURSOR ppCursor, LPVOID FAR* ppcidOut) PURE;
};


#endif // !defined( _OLEBIND_H_ )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\external\inc\vbcursor\ocdbid.h ===
/*=--------------------------------------------------------------------------=
 * ocdbid.h
 *=--------------------------------------------------------------------------=
 * defines all the guids for OLE Controls Data Binding Interfaces interfaces.
 *
 * Copyright (c) 1994-1995 Microsoft Corporation, All Rights Reserved.
 *
 */

/* {9F6AA700-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursor,
0x9f6aa700, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {ACFF0690-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorMove,
0xacff0690, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {BB87E420-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorScroll,
0xbb87e420, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {D14216A0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorUpdateARow,
0xd14216a0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {DB526CC0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_INotifyDBEvents,
0xdb526cc0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {E01D7850-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorFind,
0xe01d7850, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {E4D19810-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_IEntryID,
0xe4d19810, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {E8BF1170-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(_GUID_NAMEONLY,
0xe8bf1170, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {F6304BB0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(_DBBMKGUID,
0xf6304bb0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {FE284700-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(_OCDBCIDGUID,
0xfe284700, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\ancrclk.h ===
// AnchorClick.h
// behavior that grabs a tag and makes it navigate to a folder view

#ifndef __ANCHORCLICK_H__
#define __ANCHORCLICK_H__

#include "iextag.h"
#include "resource.h"

class CAnchorClick :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CAnchorClick, &CLSID_AnchorClick>,
    public IDispatchImpl<IAnchorClick, &IID_IAnchorClick, &LIBID_IEXTagLib>,
    public IElementBehavior
{
public:

    class CEventSink;

    CAnchorClick ();
    ~CAnchorClick ();

DECLARE_REGISTRY_RESOURCEID(IDR_WFOLDERS)

BEGIN_COM_MAP(CAnchorClick) 
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IAnchorClick)
    COM_INTERFACE_ENTRY(IElementBehavior)
END_COM_MAP()

    // IAnchorClick
    STDMETHOD(ProcOnClick)();
    // IElementBehavior
    STDMETHOD(Init)(IElementBehaviorSite *pSite);
    STDMETHOD(Notify)(LONG lNotify, VARIANT * pVarNotify);
    STDMETHOD(Detach)() { return S_OK; };

private:
    // Client site
    IElementBehaviorSite *m_pSite;
    // Event sink
    CEventSink *m_pSink;
    CEventSink *m_pSinkContextMenu;

    // Helper Functions
    HRESULT GetProperty_BSTR  (IDispatch * pDisp, LPWSTR  pchName, LPWSTR * pbstrRes);
    HRESULT GetProperty_Variant  (IDispatch * pDisp, LPWSTR  pchName, VARIANT * pvarRes);

public:

    class CEventSink : public IDispatch
    {
    public:
        CEventSink (CAnchorClick *pAnchorClick);

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IDispatch
        STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
        STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo);
		STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
            LCID lcid, DISPID *rgDispId);
        STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid,
            LCID lcid, WORD wFlags, DISPPARAMS  *pDispParams, VARIANT  *pVarResult,
            EXCEPINFO *pExcepInfo, UINT *puArgErr);
    private:
        CAnchorClick *m_pParent;
    };

};

#endif  // __ANCHORCLICK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\ancrclk.cxx ===
//=================================================
//
//  File : ancrclk.cxx
//
//  purpose : implementation of the 
//            CAnchorClick class
//            Gives anchor tags the ability to 
//            navigate to web folders
//
//=================================================
// Chad Lindhorst, 1998

#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "ancrclk.h"
#include "httpwfh.h"
#include "utils.hxx"

// ========================================================================
// CAnchorClick
// ========================================================================

//+------------------------------------------------------------------------
//
//  Members:    CAnchorClick::CAnchorClick
//              CAnchorClick::~CAnchorClick
//
//  Synopsis:   Constructor/destructor
//
//-------------------------------------------------------------------------

CAnchorClick::CAnchorClick() 
{
    m_pSite = NULL;
    m_pSink = NULL;
    m_pSinkContextMenu = NULL;
}

CAnchorClick::~CAnchorClick() 
{
    if (m_pSite)
        m_pSite->Release();
    if (m_pSink)
        delete m_pSink;
    if (m_pSinkContextMenu) 
        delete m_pSinkContextMenu;
}

// ========================================================================
// IAnchorClick
// ========================================================================

//+------------------------------------------------------------------------
//
//  Member:     CAnchorClick::ProcOnClick
//
//  Synopsis:   Handles the onclick events.
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE 
CAnchorClick::ProcOnClick () 
{
    //BSTR bstrProtocol = NULL; //bug 50463
    BSTR bstrTarget = NULL;
    BSTR bstrUrl = NULL;
    HRESULT hr = E_FAIL;
    IHTMLElement *pElem = NULL;
    IElementBehavior * pPeer = NULL;
    Iwfolders * pWF = NULL;
    CComObject<Cwfolders> *pInstance = NULL; 
    IHTMLEventObj * pEvent = NULL;
    IHTMLWindow2 * pWin = NULL;

    if (FAILED(hr = m_pSite->GetElement (&pElem)))
        goto cleanup;
    
    if ( SUCCEEDED(hr = GetProperty_BSTR (pElem, L"href", &bstrUrl)))
    //bug 50463 && SUCCEEDED(hr = GetProperty_BSTR (pElem, L"navType", &bstrProtocol)) )
    {
        VARIANT vFalse;
        vFalse.vt = VT_BOOL;
        vFalse.boolVal = FALSE;

        /* //bug 50463
        if ((StrCmpIW (bstrProtocol, L"any")) &&
            (StrCmpIW (bstrProtocol, L"dav")) &&
            (StrCmpIW (bstrProtocol, L"wec")))
        {
            // this is a bad protocol.  Let's get outta here.
            goto cleanup;
        }
        */
        // if we got this far, we are gonna do a folder navigate        
        // prevent us from getting handled by anyone else.
        if (FAILED(hr = GetHTMLWindow (m_pSite, &pWin)))
            goto cleanup;

        if (FAILED(hr = pWin->get_event (&pEvent)) ||
            FAILED(hr = pEvent->put_returnValue(vFalse)))
        {
            goto cleanup;
        }
        
        // sets the target frame
        hr = GetProperty_BSTR (pElem, L"target", &bstrTarget);
        if (FAILED(hr) || !bstrTarget)
            bstrTarget = NULL;

        // get a hold of the httpFolder behavior.
        if (FAILED(hr = CComObject<Cwfolders>::CreateInstance(&pInstance)) ||
            FAILED(hr = pInstance->QueryInterface(IID_Iwfolders, (void **)&pWF)))
        {
            goto cleanup;
        }
       
        {
            IUnknown * punk = NULL;
            HWND hwnd = 0;

            // gets browser window handle (for ui)
            hr = GetClientSiteWindow(m_pSite, &hwnd);
            hr = IUnknown_QueryService(m_pSite, SID_SWebBrowserApp, IID_IUnknown, 
                                       (LPVOID *) &punk);          

            // navigates to the folder view of the url specified

            hr = pWF->navigateNoSite (bstrUrl, bstrTarget, /*bstrProtocol,*/ (DWORD)(DWORD_PTR)hwnd, punk);
        }

    }
    else 
        hr = S_OK;  // since the navType wasn't set, and no we ignore everything 

cleanup:
    SysFreeString (bstrTarget);
    SysFreeString (bstrUrl);
    //SysFreeString (bstrProtocol);

    ReleaseInterface (pEvent);
    ReleaseInterface (pWin);    
    ReleaseInterface (pElem);
    ReleaseInterface (pWF);
    ReleaseInterface (pPeer);

    return hr;
}


// ========================================================================
// IElementBehavior
// ========================================================================

//+------------------------------------------------------------------------
//
//  Member:     CAnchorClick::Init
//
//  Synopsis:   Called when this code is initialized as a behavior
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE 
CAnchorClick::Init (IElementBehaviorSite __RPC_FAR *pBehaviorSite) 
{
    HRESULT hr = E_INVALIDARG;
    BSTR bstrEvent = NULL;
    BSTR bstronContextMenu = NULL;
    BSTR bstrUrl = NULL;
    //bug 50463 BSTR bstrProtocol = NULL;
    VARIANT_BOOL vSuccess = VARIANT_FALSE;
    IHTMLElement *pElem = NULL;
    IHTMLElement2 *pElem2 = NULL;

    // this puppy is ref counted when used.
    m_pSink = new CEventSink (this);
    m_pSinkContextMenu = new CEventSink (this);
    
    if (!m_pSink || !m_pSinkContextMenu)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    if (pBehaviorSite != NULL)
    {
        m_pSite = pBehaviorSite;
        m_pSite->AddRef();
    }

    if (FAILED(hr = m_pSite->GetElement (&pElem)))
        goto cleanup;

    hr = pElem->QueryInterface(IID_IHTMLElement2, (void **)&pElem2);
    if (FAILED(hr))
        goto cleanup;

    // we are adding a phony href attribute to the tag if there is
    // a folder attribute set.  This will make sure that the 
    // browser uses the right underlining and colors for anchors
    // that have no href attribute, but do have a folder attribute.
    if ( SUCCEEDED(hr = GetProperty_BSTR (pElem, L"folder", &bstrUrl))) 
    /*    && (FAILED(hr = GetProperty_BSTR (pElem, L"navType", &bstrProtocol)) ||
             ((!StrCmpIW (bstrProtocol, L"any")) ||
              (!StrCmpIW (bstrProtocol, L"dav")) ||
              (!StrCmpIW (bstrProtocol, L"wec")))) )
    */
    {
        VARIANT vbstrUrl;
        vbstrUrl.vt = VT_BSTR;
        vbstrUrl.bstrVal = bstrUrl;

        pElem->setAttribute (L"href", vbstrUrl, VARIANT_FALSE);
    }
    else 
    {
        // If there is no folder specified then we assume this to be a regular anchor tag
        // Bug 54304
        goto cleanup;
    }

    /*
    // now we add a navtype if one wasn't specified and there is a "folder"
    // we add the default "any" protocol
    if ( bstrUrl && !bstrProtocol)
    {
        VARIANT vbstrUrl;
        vbstrUrl.vt = VT_BSTR;
        vbstrUrl.bstrVal = SysAllocString (L"any");
        if (!V_BSTR(&vbstrUrl))
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
        
        pElem->setAttribute (L"navType", vbstrUrl, VARIANT_FALSE);
        SysFreeString (vbstrUrl.bstrVal);
    }
    */
    // we want to sink a few events.
    // we will take over the click and mouseover events because they
    // act differently for folder view anchors
    bstrEvent = SysAllocString (L"onclick");
    if (!bstrEvent)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }
    pElem2->attachEvent (bstrEvent, (IDispatch *) m_pSink, &vSuccess);
    if (vSuccess == VARIANT_TRUE) 
        hr = S_OK;
    else 
    {
        hr = E_FAIL;
        goto cleanup;
    }

    bstronContextMenu = SysAllocString(L"oncontextmenu");
    if (bstronContextMenu) {
        pElem2->attachEvent (bstronContextMenu, (IDispatch *) m_pSinkContextMenu, &vSuccess);
        if (vSuccess == VARIANT_TRUE) 
            hr = S_OK;
        else 
        {
            hr = E_FAIL;
            goto cleanup;
        }
    }    
    
cleanup:
    ReleaseInterface (pElem);
    ReleaseInterface (pElem2);

    SysFreeString (bstrEvent);
    SysFreeString (bstronContextMenu);
    SysFreeString (bstrUrl);
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CAnchorClick::Notify
//
//  Synopsis:   Not really used, but needed by the interface...
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE 
CAnchorClick::Notify (LONG lEvent, VARIANT __RPC_FAR *pVar) 
{
    return S_OK;    
}

//+------------------------------------------------------------------------
//
//  Member:     CAnchorClick::GetProperty_Variant
//
//  Synopsis:   Gets a property from the element passed in as pDisp.
//              Taken from \mshtml\src\f3\drt\activex\peerdecl
//
//-------------------------------------------------------------------------

HRESULT
CAnchorClick::GetProperty_Variant (IDispatch * pDisp, LPWSTR  pchName, VARIANT * pvarRes)
{
    HRESULT     hr = S_OK;
    DISPID      dispid;
    EXCEPINFO   excepinfo;
    UINT        nArgErr;
    DISPPARAMS  dispparams = {NULL, NULL, 0, 0};

    if (!pvarRes || !pDisp)
        return E_POINTER;

    hr = pDisp->GetIDsOfNames(IID_NULL, &pchName, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
    if (hr)
        goto Cleanup;

    hr = pDisp->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYGET,
                       &dispparams, pvarRes, &excepinfo, &nArgErr);

 Cleanup:

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CAnchorClick::GetProperty_BSTR
//
//  Synopsis:   Gets a property from the element passed in as pDisp.
//              Taken from \mshtml\src\f3\drt\activex\peerdecl
//
//-------------------------------------------------------------------------

HRESULT
CAnchorClick::GetProperty_BSTR  (IDispatch * pDisp, LPWSTR  pchName, LPWSTR * pbstrRes)
{
    HRESULT     hr = S_OK;
    VARIANT     varRes;

    if (!pbstrRes)
        return E_POINTER;

    *pbstrRes = NULL;

    hr = GetProperty_Variant (pDisp, pchName, &varRes);
    if (hr)
        goto Cleanup;

    if (VT_BSTR != V_VT(&varRes))
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    (*pbstrRes) = V_BSTR(&varRes);

Cleanup:

    return hr;
}

// ========================================================================
// CEventSink::IDispatch
// ========================================================================

// The event sink's IDispatch interface is what gets called when events
// are fired.

//+------------------------------------------------------------------------
//
//  Member:     CAnchorClick::CEventSink::GetTypeInfoCount
//              CAnchorClick::CEventSink::GetTypeInfo
//              CAnchorClick::CEventSink::GetIDsOfNames
//
//  Synopsis:   We don't really need a nice IDispatch... this minimalist
//              version does just plenty.
//
//-------------------------------------------------------------------------

STDMETHODIMP 
CAnchorClick::CEventSink::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP 
CAnchorClick::CEventSink::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                      /* [in] */ LCID /*lcid*/,
                                      /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP 
CAnchorClick::CEventSink::GetIDsOfNames( REFIID          riid,
                                         OLECHAR**       rgszNames,
                                         UINT            cNames,            
                                         LCID            lcid,
                                         DISPID*         rgDispId)
{
    return E_NOTIMPL;
}

//+------------------------------------------------------------------------
//
//  Member:     CAnchorClick::CEventSink::Invoke
//
//  Synopsis:   This gets called for all events on our object.  (it was 
//              registered to do so in Init with attach_event.)  It calls
//              the appropriate parent functions to handle the events.
//
//-------------------------------------------------------------------------

STDMETHODIMP 
CAnchorClick::CEventSink::Invoke( DISPID dispIdMember,
                                  REFIID, LCID,
                                  WORD wFlags,
                                  DISPPARAMS* pDispParams,
                                  VARIANT* pVarResult,
                                  EXCEPINFO*,
                                  UINT* puArgErr)
{
    HRESULT hr = TRUE;
    if (m_pParent && pDispParams && pDispParams->cArgs>=1)
    {
        if (pDispParams->rgvarg[0].vt == VT_DISPATCH)
        {
            IHTMLEventObj *pObj=NULL;

            if (SUCCEEDED(pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, 
                (void **)&pObj) && pObj))
            {
                BSTR bstrEvent=NULL;

                pObj->get_type(&bstrEvent);

                // user clicked one of our anchors
                if (! StrCmpICW (bstrEvent, L"click"))
                    hr = m_pParent->ProcOnClick();
                else if (! StrCmpICW (bstrEvent, L"ContextMenu")) 
                {
                    VARIANT vboolCancel;
                    vboolCancel.vt = VT_BOOL;
                    vboolCancel.boolVal = FALSE;
                    pObj->put_returnValue(vboolCancel);
                    hr = S_OK;
                }

                pObj->Release();
            }
        }
    }

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CAnchorClick::CEventSink
//
//  Synopsis:   This is used to allow communication between the parent class
//              and the event sink class.  The event sink will call the ProcOn*
//              methods on the parent at the appropriate times.
//
//-------------------------------------------------------------------------

CAnchorClick::CEventSink::CEventSink (CAnchorClick * pParent)
{
    m_pParent = pParent;
}

// ========================================================================
// CEventSink::IUnknown
// ========================================================================

// Vanilla IUnknown implementation for the event sink.

STDMETHODIMP 
CAnchorClick::CEventSink::QueryInterface(REFIID riid, void ** ppUnk)
{
    void * pUnk = NULL;

    if (riid == IID_IDispatch)
        pUnk = (IDispatch *) this;

    if (riid == IID_IUnknown)
        pUnk = (IUnknown *) this;

    if (pUnk)
    {
        *ppUnk = pUnk;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) 
CAnchorClick::CEventSink::AddRef(void)
{
    return ((IElementBehavior *)m_pParent)->AddRef();
}

STDMETHODIMP_(ULONG) 
CAnchorClick::CEventSink::Release(void)
{
    return ((IElementBehavior *)m_pParent)->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\help\f3ctx.h ===
#define f3evtAddControl 2000010
#define f3evtAfterUpdate 2000020
#define f3evtBeforeDragOver 2000030
#define f3evtBeforeDropOrPaste 2000040
#define f3evtBeforeUpdate 2000050
#define f3evtChange 2000060
#define f3evtClick 2000070
#define f3evtDblClick 2000080
#define f3evtDropButtonClick 2000090
#define f3evtError 2000100
#define f3evtGotFocus 2000110
#define f3evtKeyDown 2000120
#define f3evtKeyPress 2000130
#define f3evtKeyUp 2000140
#define f3evtLayout 2000150
#define f3evtLostFocus 2000160
#define f3evtMouseDown 2000170
#define f3evtMouseMove 2000180
#define f3evtMouseUp 2000190
#define f3evtRemoveControl 2000200
#define f3evtScroll 2000210
#define f3evtSpinDown 2000220
#define f3evtSpinUp 2000230
#define f3evtZoom 2000240
#define f3mthAdd 2000250
#define f3mthAddItem 2000260
#define f3mthClear 2000270
#define f3mthCopy 2000280
#define f3mthCut 2000290
#define f3mthDropDown 2000300
#define f3mthItem 2000310
#define f3mthMove 2000320
#define f3mthPaste 2000330
#define f3mthRedoAction 2000340
#define f3mthRefresh 2000350
#define f3mthRemove 2000360
#define f3mthRemoveItem 2000370
#define f3mthRepaint 2000380
#define f3mthScroll 2000390
#define f3mthSelect 2000400
#define f3mthSelectAll 2000410
#define f3mthSetDefaultTabOrder 2000420
#define f3mthSetFocus 2000430
#define f3mthStartDrag 2000440
#define f3mthUndoAction 2000450
#define f3mthZOrder 2000460
#define f3objCheckBox 2000470
#define f3objComboBox 2000480
#define f3objCommandButton 2000490
#define f3objControls 2000500
#define f3objDataObject 2000510
#define f3objFont 2000520
#define f3objForm 2000530
#define f3objFrame 2000535                     // Manually added
#define f3objImage 2000540
#define f3objLabel 2000550
#define f3objListBox 2000560
#define f3objMultiPage 2000570
#define f3objOptionButton 2000580
#define f3objPage 2000590
#define f3objPages 2000600
#define f3objScrollBar 2000610
#define f3objSelected 2000620
#define f3objSpinButton 2000630
#define f3objTab 2000640
#define f3objTabs 2000650
#define f3objTabStrip 2000660
#define f3objTextBox 2000670
#define f3objToggleButton 2000680
#define f3proAccelerator 2000690
#define f3proActiveControl 2000700
#define f3proAlignment 2000710
#define f3proApplication 2000720
#define f3proAutoSelectChild 2000730
#define f3proAutoSize 2000740
#define f3proAutoTab 2000750
#define f3proAutoWordSelect 2000760
#define f3proBackColor 2000770
#define f3proBackStyle 2000780
#define f3proBold 2000790
#define f3proBorderColor 2000800
#define f3proBordersSuppress 2000810
#define f3proBorderStyle 2000820
#define f3proBoundColumn 2000830
#define f3proCancel 2000840
#define f3proCanPaste 2000850
#define f3proCanRedo 2000860
#define f3proCanUndo 2000870
#define f3proCaption 2000880
#define f3proClientHeight 2000890
#define f3proClientLeft 2000900
#define f3proClientTop 2000910
#define f3proClientWidth 2000920
#define f3proColumn 2000930
#define f3proColumnCount 2000940
#define f3proColumnHeads 2000950
#define f3proColumnWidths 2000960
#define f3proControls 2000970
#define f3proControlSource 2000980
#define f3proControlTipText 2000990
#define f3proCount 2001000
#define f3proCurLine 2001010
#define f3proCurTargetX 2001020
#define f3proCurTargetY 2001030
#define f3proCurX 2001040
#define f3proCurY 2001050
#define f3proCycle 2001060
#define f3proDefault 2001070
#define f3proDelay 2001080
#define f3proDragBehavior 2001085               // Added manually
#define f3proDrawBuffer 2001087                  // Added manually
#define f3proDesignMode 2001090
#define f3proDirty 2001100
#define f3proDropButtonStyle 2001110
#define f3proEnabled 2001120
#define f3proEnterFieldBehavior 2001125 // Added manually
#define f3proEnterKeyBehavior 2001130
#define f3proFont 2001140
#define f3proFontBold 2001150
#define f3proFontItalic 2001160
#define f3proFontName 2001170
#define f3proFontSize 2001180
#define f3proFontStrikethru 2001190
#define f3proFontUnderline 2001200
#define f3proFontWeight 2001210
#define f3proForeColor 2001220
#define f3proGridX 2001230
#define f3proGridY 2001240
#define f3proGroupName 2001245          // Added manually, AndrewL, 3/31/96
#define f3proHeight 2001250
#define f3proHelpContextID 2001260
#define f3proHideSelection 2001270
#define f3proIndex 2001280
#define f3proInSelection 2001290
#define f3proInsideHeight 2001300
#define f3proInsideWidth 2001310
#define f3proIntegralHeight 2001320
#define f3proItalic 2001330
#define f3proKeepFocusOnClick 2001340
#define f3proKeepScrollbarsVisible 2001350
#define f3proLargeChange 2001360
#define f3proLayoutEffect 2001370
#define f3proLeft 2001380
#define f3proLineCount 2001390
#define f3proList 2001400
#define f3proListCount 2001410
#define f3proListCursor 2001420
#define f3proListIndex 2001430
#define f3proListRows 2001440
#define f3proListStyle 2001450
#define f3proListWidth 2001460
#define f3proLocked 2001470
#define f3proMatchEntry 2001480
#define f3proMatchFound 2001490
#define f3proMatchRequired 2001500
#define f3proMax 2001510
#define f3proMaxLength 2001520
#define f3proMin 2001530
#define f3proMouseIcon 2001540
#define f3proMousePointer 2001550
#define f3proMultiLine 2001560
#define f3proMultiRow 2001570
#define f3proMultiSelect 2001580
#define f3proName 2001590
#define f3pronewEnum 2001600
#define f3proObject 2001610
#define f3proOldHeight 2001620
#define f3proOldLeft 2001630
#define f3proOldTop 2001640
#define f3proOldWidth 2001650
#define f3proOrientation 2001660
#define f3proPages 2001670
#define f3proParent 2001680
#define f3proPasswordChar 2001690
#define f3proPictureAlignment 2001700
#define f3proPictureData 2001710
#define f3proPicturePosition 2001720
#define f3proPictureSizeMode 2001730
#define f3proPictureTiling 2001740
#define f3proProportionalThumb 2001750
#define f3proRowSource 2001760
#define f3proRowSourceType 2001770
#define f3proScrollBars 2001780
#define f3proScrollHeight 2001790
#define f3proScrollLeft 2001800
#define f3proScrollTop 2001810
#define f3proScrollWidth 2001820
#define f3proSelected 2001830
#define f3proSelectedCount 2001840
#define f3proSelectedItem 2001850
#define f3proSelectionMargin 2001860
#define f3proSelLength 2001870
#define f3proSelStart 2001880
#define f3proSelText 2001890
#define f3proShowDropButtonWhen 2001900
#define f3proShowGridDots 2001910
#define f3proSize 2001920
#define f3proSizeMode 2001930
#define f3proSmallChange 2001940
#define f3proSnapToGrid 2001950
#define f3proSpecialEffect 2001960
#define f3proStrikeThrough 2001970
#define f3proStyle 2001980
#define f3proTabFixedHeight 2001990
#define f3proTabFixedWidth 2002000
#define f3proTabIndex 2002010
#define f3proTabKeyBehavior 2002020
#define f3proTabOrientation 2002030
#define f3proTabs 2002040
#define f3proTabStop 2002050
#define f3proTag 2002060
#define f3proText 2002070
#define f3proTextAlign 2002080
#define f3proTextColumn 2002090
#define f3proTextLength 2002100
#define f3proTop 2002110
#define f3proTopIndex 2002120
#define f3proTransitionEffect 2002130
#define f3proTransitionPeriod 2002140
#define f3proTripleState 2002150
#define f3proUnderline 2002160
#define f3proValid 2002170
#define f3proValue 2002180
#define f3proVerticalScrollbarSide 2002190
#define f3proVisible 2002200
#define f3proWeight 2002210
#define f3proWidth 2002220
#define f3proWordWrap 2002230
#define f3proZoom 2002240
#define IDH_f3defControl 2002250
#define IDH_f3defANSICharacterSet 2002260
#define IDH_f3defAcceleratorKey 2002270
#define IDH_f3defActive 2002280
#define IDH_f3defArgument 2002290
#define IDH_f3defArray 2002300
#define IDH_f3defBackgroundColor 2002310
#define IDH_f3defBound 2002320
#define IDH_f3defCaption 2002330
#define IDH_f3defClass 2002340
#define IDH_f3defClassIdentifier 2002350
#define IDH_f3defClear 2002360
#define IDH_f3defClientRegion 2002370
#define IDH_f3defClip 2002380
#define IDH_f3defCollection 2002390
#define IDH_f3defContainer 2002400
#define IDH_f3defContextID 2002410
#define IDH_f3defControlGroup 2002420
#define IDH_f3defCycle 2002430
#define IDH_f3defDataSource 2002440
#define IDH_f3defDefault 2002450
#define IDH_f3defDesignTime 2002460
#define IDH_f3defDisable 2002470
#define IDH_f3defDoubleclickSpeedSetting 2002480
#define IDH_f3defDraganddropOperation 2002490
#define IDH_f3defDropSource 2002500
#define IDH_f3defDropdownList 2002510
#define IDH_f3defEnable 2002520
#define IDH_f3defEvent 2002530
#define IDH_f3defEventProcedure 2002540
#define IDH_f3defFocus 2002550
#define IDH_f3defForegroundColor 2002560
#define IDH_f3defForm 2002570
#define IDH_f3defFormat 2002580
#define IDH_f3defIME 2002590
#define IDH_f3defInheritedProperty 2002600
#define IDH_f3defInputArea 2002610
#define IDH_f3defInsertionPoint 2002620
#define IDH_f3defKeyboardState 2002630
#define IDH_f3defLabel 2002640
#define IDH_f3defMember 2002650
#define IDH_f3defMemberName 2002660
#define IDH_f3defMethod 2002670
#define IDH_f3defModule 2002680
#define IDH_f3defNamedArgument 2002690
#define IDH_f3defNull 2002700
#define IDH_f3defOLEContainerControls 2002710
#define IDH_f3defOLEObject 2002720
#define IDH_f3defOLEStatusCode 2002730
#define IDH_f3defObject 2002740
#define IDH_f3defObjectBrowser 2002750
#define IDH_f3defPage 2002760
#define IDH_f3defPlaceholder 2002770
#define IDH_f3defPoint 2002780
#define IDH_f3defProcedure 2002790
#define IDH_f3defProject 2002800
#define IDH_f3defProperty 2002810
#define IDH_f3defPropertyPage 2002820
#define IDH_f3defRGB 2002830
#define IDH_f3defRunTime 2002840
#define IDH_f3defSelection 2002850
#define IDH_f3defSendKeysStatement 2002860
#define IDH_f3defSeparator 2002870
#define IDH_f3defSingleprecisionValue 2002880
#define IDH_f3defSizingHandles 2002890
#define IDH_f3defStatement 2002900
#define IDH_f3defSystemColors 2002910
#define IDH_f3defTabOrder 2002920
#define IDH_f3defTarget 2002930
#define IDH_f3defToolbar 2002940
#define IDH_f3defTransparent 2002950
#define IDH_f3defUnbound 2002960
#define IDH_f3defUserInterface 2002970
#define IDH_f3defValue 2002980
#define IDH_f3defVisualBasicForApplications 2002990
#define IDH_f3defVisualGroup 20023000
#define IDH_f3defZorder 20023010
#define f3defDataFormat 20023020        //Added manually 5/17/96
#define f3defDominantControl  20023030  //Added manually 5/17/96
#define f3defGridBlock  20023040        //Added manually 5/17/96
// ***** Begin Dialog Box context IDs
#define f3dlgRename 2010010
#define f3dlgPageOrder 2010020
#define f3dlgCustomControls 2010030
#define f3dlgCustomizeControl 2010040
#define IDH_f3defDataFormat 2010050
#define IDH_f3defDominantControl 2010060
#define IDH_f3defGridBlock 2010070
#define IDH_f3defControlTip 2010080
#define IDH_f3defCursor 2010090
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\basectl.cxx ===
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#include "iextag.h"

#include "utils.hxx"

#include "basectl.hxx"

/////////////////////////////////////////////////////////////////////////////
//
// CBaseCtl - Base class for control behaviors
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////

CBaseCtl::CBaseCtl()
{
}

/////////////////////////////////////////////////////////////////////////////

CBaseCtl::~CBaseCtl()
{
    ReleaseInterface(_pSite);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CBaseCtl::Init(IElementBehaviorSite *pSite)
{
    HRESULT hr = S_OK;

    if (!pSite)
        return E_INVALIDARG;

    _pSite = pSite;
    _pSite->AddRef();

    hr = Init();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CBaseCtl::Notify(LONG lEvent, VARIANT * pVarNotify)
{
    HRESULT     hr = S_OK;

    switch (lEvent)
    {
    case BEHAVIOREVENT_CONTENTREADY:
        hr = OnContentReady();
        break;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//  IPersistPropertyBag2 implementataion
//
/////////////////////////////////////////////////////////////////////////////
//+----------------------------------------------------------------------------
//
//  Member : Load  - IPersistPropertyBag2 property impl
//
//  Synopsis : This gives us a chance to pull properties from the property bag
//      created when the element's attributes were parsed in. Since we handle
//      all the getter/putter logic, our copy of the value will always be the 
//      current one.  This gives this behavior full control over the attribures
//      that it is interested in.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CBaseCtl::Load ( IPropertyBag2 *pPropBag, IErrorLog *pErrLog)
{
    HRESULT          hr = S_OK;
    const PROPDESC * ppropdesc = BaseDesc();
    CDataObj *       pAttribute = GetProps();
    IPropertyBag *   pBag = NULL;

    if (!pPropBag)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = pPropBag->QueryInterface(IID_IPropertyBag, (void**) &pBag);
    if (hr || !pBag)
        goto Cleanup;

    // loop through all the attributes and load them
    while (ppropdesc->_bstrPropName)
    {
        pBag->Read(ppropdesc->_bstrPropName, 
                   &pAttribute->_varValue,
                   pErrLog);

        hr = CheckAttributeType(&pAttribute->_varValue, ppropdesc->_vt);
        // TODO: What should we do if the value is out of range? Right now, 
        // we set it to the default.
        if (hr && !(hr == DISP_E_OVERFLOW))
            goto Cleanup;

        hr = CheckDefaultValue(ppropdesc, pAttribute);
        if (hr)
            goto Cleanup;

        pAttribute++;
        ppropdesc++;
    }


Cleanup:
    ReleaseInterface(pBag);
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member : CheckAttributeType 
//
//  Synopsis : This is a helper function to convert the attribute to 
//  the appropriate type. We need this because many attributes
//  are loaded as VT_BSTR, but we want VT_I4.
//
//-----------------------------------------------------------------------------

HRESULT
CBaseCtl::CheckAttributeType(VARIANT * pvar, VARTYPE vt)
{
    HRESULT hr = S_OK;

    if (V_VT(pvar) != vt && V_VT(pvar) != VT_EMPTY)
    {
        CVariant cvar(vt);
        hr = cvar.CoerceVariantArg(pvar, vt);
        if (hr) 
            goto Cleanup;
        *pvar = cvar;
    }

Cleanup:
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : CheckDefaultValue
//
//  Synopsis : Checks to see whether the value of an attribute has been set.
//  If not, set it to it's default value.
//
//-----------------------------------------------------------------------------

HRESULT
CBaseCtl::CheckDefaultValue(const PROPDESC * ppropdesc, CDataObj * pAttribute)
{
    HRESULT hr = S_OK;

    if (V_VT(&pAttribute->_varValue) == VT_EMPTY)
    {
        V_VT(&pAttribute->_varValue) = ppropdesc->_vt;

        switch (ppropdesc->_vt)
        {
        case VT_BSTR:
            V_BSTR(&pAttribute->_varValue) = SysAllocString(ppropdesc->_bstrDefault);
            break;
        case VT_I4:
            V_I4(&pAttribute->_varValue) = ppropdesc->_lDefault;
            break;
        case VT_BOOL:
            V_BOOL(&pAttribute->_varValue) = ppropdesc->_fDefault;
            break;
        default:
            Assert(FALSE);
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : Save  - IPersistPropertyBag2 property impl
//
//  Synopsis : Like the load, above, this allows us to save the attributes which
//      we control.  This is all part of fully owning our element's behavior, OM
//      and attributes. 
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CBaseCtl::Save ( IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT          hr = S_OK;
    IPropertyBag *   pBag = NULL;
    const PROPDESC * ppropdesc = BaseDesc();
    CDataObj *       pAttribute = GetProps();
    long             i=0;

    // verify parameters
    if (!pPropBag)
    {
        hr = E_POINTER;
        goto Cleanup;
    }


    // now go through our properties and save them if they are dirty, or if
    // a save-All is required.
    //---------------------------------------------------------------------

    hr = pPropBag->QueryInterface(IID_IPropertyBag, (void**) &pBag);
    if (hr || !pBag)
        goto Cleanup;


    while (ppropdesc->_bstrPropName)
    {
        if (pAttribute->IsDirty() || fSaveAllProperties)
        {
            if (V_VT(&pAttribute->_varValue) != VT_DISPATCH)
            {
                pBag->Write(ppropdesc->_bstrPropName, &pAttribute->_varValue);

                if (fClearDirty)
                    pAttribute->_fDirty = FALSE;
            }
        }

        pAttribute++;
        ppropdesc++;
    }

Cleanup:
    ReleaseInterface(pBag);
    return hr;
}

HRESULT 
CBaseCtl::RegisterEvent(IElementBehaviorSiteOM * pSiteOM,
              BSTR   bstrEventName,
              LONG * plBehaviorID,
              LONG   lFlags /*= 0*/)
{
    HRESULT hr = S_OK;

    Assert(pSiteOM);

    Assert(_tcsspn(bstrEventName, L"on") == 2);

    hr = pSiteOM->RegisterEvent (bstrEventName, lFlags, plBehaviorID);
    if (hr)
        goto Cleanup;

Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CBaseCtl::FireEvent(long lCookie, 
                    VARIANT_BOOL * pfContinue /*=NULL*/,
                    BSTR bstrEventName /*=NULL*/)
{
    HRESULT                  hr         = S_OK;
    IHTMLEventObj  *         pEventObj  = NULL;
    IHTMLEventObj2 *         pEventObj2 = NULL;
    IElementBehaviorSiteOM * pSiteOM    = NULL;
    VARIANT                  varRet;

    hr = _pSite->QueryInterface(IID_IElementBehaviorSiteOM, (void **) &pSiteOM);
    if (hr)
        goto Cleanup;

    VariantInit(&varRet);

    // create an event object
    hr = pSiteOM->CreateEventObject(&pEventObj);
    if (hr)
        goto Cleanup;

    // ISSUE: (85045) We need a way put the event name in the event object.
    // Shouldn't FireEvent do this for us? For now, if bstrEventName is 
    // supplied, we'll use it. This is needed for the CIESelectElement::CEventSink::Invoke.
    if (bstrEventName)
    {
        hr = pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**)&pEventObj2);
        if (hr)
            goto Cleanup;

        pEventObj2->put_type( bstrEventName );
    }

    hr = pSiteOM->FireEvent (lCookie, pEventObj);

    if (pfContinue)
    {
        hr = pEventObj->get_returnValue(&varRet);
        if (!hr)
            *pfContinue =  ((V_VT(&varRet) == VT_BOOL) && 
            (V_BOOL(&varRet) == VB_FALSE))? VB_FALSE : VB_TRUE;
    }

Cleanup:
    VariantClear(&varRet);
    ReleaseInterface(pSiteOM);
    ReleaseInterface(pEventObj);
    ReleaseInterface(pEventObj2);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
CBaseCtl::AttachEvent(ENUM_EVENTS event, CContextAccess * pa)
{
    HRESULT                         hr = S_OK;
    IConnectionPointContainer *     pCPC = NULL;
    IConnectionPoint *              pCP = NULL;

    Assert (pa);

    // ( EVENT_SINK_ADDING_STEP ) expand the switch below

    switch (event)
    {
    case EVENT_ONCLICK:
    case EVENT_ONKEYPRESS:
    case EVENT_ONKEYDOWN:
    case EVENT_ONKEYUP:
    case EVENT_ONFOCUS:
    case EVENT_ONBLUR:
    case EVENT_ONPROPERTYCHANGE:
    case EVENT_ONMOUSEOVER:
    case EVENT_ONMOUSEOUT:
    case EVENT_ONMOUSEDOWN:
    case EVENT_ONMOUSEUP:
    case EVENT_ONMOUSEMOVE:
    case EVENT_ONSELECTSTART:
    case EVENT_ONSCROLL:
    case EVENT_ONCONTEXTMENU:


        if (!_fElementEventSinkConnected)
        {
            _fElementEventSinkConnected = TRUE;

            hr = pa->Open(CA_ELEM);
            if (hr)
                goto Cleanup;

            hr = pa->Elem()->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
            if (hr)
                goto Cleanup;
            hr = pCPC->FindConnectionPoint(DIID_HTMLElementEvents2, &pCP);
            if (hr)
                goto Cleanup;

            hr = pCP->Advise((HTMLElementEvents2*)(&_EventSink), &_dwCookie);
            if (hr)
                goto Cleanup;
        }

        break;

    default:
        Assert(FALSE && "missing implementation");
        hr = E_INVALIDARG;
        goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pCPC);
    ReleaseInterface(pCP);

    return hr;   
}

/////////////////////////////////////////////////////////////////////////////
//
//  CBaseCtl::CEventSink
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////

CBaseCtl::CEventSink::CEventSink ()
{
}

/////////////////////////////////////////////////////////////////////////////

CBaseCtl::CEventSink::~CEventSink ()
{
}

/////////////////////////////////////////////////////////////////////////////

ULONG
CBaseCtl::CEventSink::AddRef(void)
{
    return ((IElementBehavior*)Target())->AddRef();
}

/////////////////////////////////////////////////////////////////////////////

ULONG
CBaseCtl::CEventSink::Release(void)
{
    return ((IElementBehavior*)Target())->Release();
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CBaseCtl::CEventSink::QueryInterface(REFIID riid, void ** ppUnk)
{
    if (IsEqualGUID(riid, IID_IUnknown) ||
        IsEqualGUID(riid, IID_IDispatch) ||
        IsEqualGUID(riid, DIID_HTMLElementEvents2))
    {
        *ppUnk = this;
        AddRef();
        return S_OK;
    }

    *ppUnk = NULL;

    return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CBaseCtl::CEventSink::Invoke(
    DISPID          dispid,
    REFIID          riid,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS  *   pDispParams,
    VARIANT  *      pVarResult,
    EXCEPINFO *     pExcepInfo,
    UINT *          puArgErr)
{
    HRESULT             hr = S_OK;
    CEventObjectAccess  eoa(pDispParams);
    LONG                l;
    BSTR                bstr = NULL;

    hr = eoa.Open(EOA_EVENTOBJ);
    if (hr)
        goto Cleanup;

    // ( EVENT_SINK_ADDING_STEP ) expand the switch below

    switch (dispid)
    {
    case DISPID_HTMLELEMENTEVENTS2_ONCLICK:                 hr = Target()->OnClick(&eoa);         break;
    case DISPID_HTMLELEMENTEVENTS2_ONFOCUS:                 hr = Target()->OnFocus(&eoa);         break;
    case DISPID_HTMLELEMENTEVENTS2_ONBLUR:                  hr = Target()->OnBlur(&eoa);          break;

    case DISPID_HTMLELEMENTEVENTS2_ONMOUSEOVER:             hr = Target()->OnMouseOver(&eoa);     break;
    case DISPID_HTMLELEMENTEVENTS2_ONMOUSEOUT:              hr = Target()->OnMouseOut(&eoa);      break;
    case DISPID_HTMLELEMENTEVENTS2_ONMOUSEDOWN:             hr = Target()->OnMouseDown(&eoa);     break;
    case DISPID_HTMLELEMENTEVENTS2_ONMOUSEUP:               hr = Target()->OnMouseUp(&eoa);       break;
    case DISPID_HTMLELEMENTEVENTS2_ONMOUSEMOVE:             hr = Target()->OnMouseMove(&eoa);     break;

    case DISPID_HTMLELEMENTEVENTS2_ONKEYDOWN:               hr = Target()->OnKeyDown(&eoa);       break;
    case DISPID_HTMLELEMENTEVENTS2_ONKEYUP:                 hr = Target()->OnKeyUp(&eoa);         break;
    case DISPID_HTMLELEMENTEVENTS2_ONKEYPRESS:              hr = Target()->OnKeyPress(&eoa);      break;
    case DISPID_HTMLELEMENTEVENTS2_ONSELECTSTART:           hr = Target()->OnSelectStart(&eoa);   break;
    case DISPID_HTMLELEMENTEVENTS2_ONSCROLL:                hr = Target()->OnScroll(&eoa);        break;
    case DISPID_HTMLELEMENTEVENTS2_ONCONTEXTMENU:           hr = Target()->OnContextMenu(&eoa);   break;

    case DISPID_HTMLELEMENTEVENTS2_ONPROPERTYCHANGE:
        hr = eoa.Open(EOA_EVENTOBJ2);
        if (hr)
            goto Cleanup;

        hr = eoa.EventObj2()->get_propertyName(&bstr);
        if (hr)
            goto Cleanup;

        hr = Target()->OnPropertyChange(&eoa, bstr);
        if (hr)
            goto Cleanup;

        break;
    }

Cleanup:
    SysFreeString(bstr);

    return hr;
}

//+------------------------------------------------------------------------
//
//  CBaseCtl::CDataObj : Member function implmentations
//
//-------------------------------------------------------------------------
HRESULT 
CBaseCtl::CDataObj::Set (BSTR bstrValue)
{
    VariantClear(&_varValue);
    _fDirty = TRUE;

    V_VT(&_varValue)   = VT_BSTR;
    if (!bstrValue)
    {
        V_BSTR(&_varValue) = NULL;
        return S_OK;
    }
    else
    {
        V_BSTR(&_varValue) = SysAllocStringLen(bstrValue, SysStringLen(bstrValue));

        return (V_BSTR(&_varValue)) ? S_OK : E_OUTOFMEMORY;
    }
}

HRESULT 
CBaseCtl::CDataObj::Set (VARIANT_BOOL vBool)
{
    VariantClear(&_varValue);
    _fDirty = TRUE;

    V_VT(&_varValue)   = VT_BOOL;
    V_BOOL(&_varValue) = vBool;

    return S_OK;
}

HRESULT
CBaseCtl::CDataObj::Set(IDispatch * pDisp)
{
    VariantClear(&_varValue);
    _fDirty = TRUE;

    V_VT(&_varValue)   = VT_DISPATCH;
    V_DISPATCH(&_varValue) = pDisp;

    if (pDisp)
        pDisp->AddRef();

    return S_OK;
}

HRESULT
CBaseCtl::CDataObj::Set(long l)
{
    VariantClear(&_varValue);
    _fDirty = TRUE;

    V_VT(&_varValue)  = VT_I4;
    V_I4(&_varValue) = l;

    return S_OK;
}

HRESULT 
CBaseCtl::CDataObj::Get (BSTR * pbstr)
{
    HRESULT hr = S_OK;

    Assert(pbstr) ;

    *pbstr = NULL;

    if (V_VT(&_varValue) == VT_BSTR)
    {
        *pbstr = SysAllocStringLen(V_BSTR(&_varValue), 
                                   SysStringLen(V_BSTR(&_varValue)));

        if (!*pbstr)
            hr = E_OUTOFMEMORY;
    }

    return hr;
};


HRESULT 
CBaseCtl::CDataObj::Get (VARIANT_BOOL * pVB)
{
    HRESULT hr = S_OK;

    Assert(pVB); 

    if (V_VT(&_varValue) != VT_BOOL)
    {
        *pVB = VB_FALSE;
        hr = S_FALSE;
    }
    else
    {
        *pVB =  V_BOOL(&_varValue);
    }

    return hr;
};

HRESULT
CBaseCtl::CDataObj::Get (long * pl)
{
    HRESULT hr = S_OK;

    Assert(pl);

    if (V_VT(&_varValue) != VT_I4)
    {
        *pl = 0;
        hr = S_FALSE;
    }
    else
    {
        *pl = V_I4(&_varValue);
    }

    return hr;
}

HRESULT
CBaseCtl::CDataObj::Get (IDispatch ** ppDisp)
{
    HRESULT hr = S_OK;

    Assert(ppDisp);

    *ppDisp = NULL;

    if (V_VT(&_varValue)!= VT_DISPATCH)
    {
        hr = S_FALSE;
    }
    else
    {
        *ppDisp = V_DISPATCH(&_varValue);
        if (*ppDisp)
            (*ppDisp)->AddRef();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\ccaps.h ===
// CCaps.h : Declaration of the CClientCaps

#ifndef __CCAPS_H_
#define __CCAPS_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CClientCaps
class ATL_NO_VTABLE CClientCaps : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CClientCaps, &CLSID_ClientCaps>,
    public IDispatchImpl<IClientCaps, &IID_IClientCaps, &LIBID_IEXTagLib>,

    public IElementBehavior
{
public:
    CClientCaps()
    {
        m_pSite = NULL;
        iComponentNum = 0;
        iComponentCap = 0;
        ppwszComponents = NULL;
    }
    ~CClientCaps()
    {
        if (m_pSite)
            m_pSite->Release();
        if(ppwszComponents)
        {
            clearComponentRequest();
            delete [] ppwszComponents;
        }
    }

DECLARE_REGISTRY_RESOURCEID(IDR_CLIENTCAPS)
DECLARE_NOT_AGGREGATABLE(CClientCaps)

BEGIN_COM_MAP(CClientCaps)
    COM_INTERFACE_ENTRY(IClientCaps)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IElementBehavior)
END_COM_MAP()

// IClientCaps
public:
    STDMETHOD(get_javaEnabled)(/*[out, retval]*/ VARIANT_BOOL *pVal);
    STDMETHOD(get_cookieEnabled)(/*[out, retval]*/ VARIANT_BOOL *pVal);
    STDMETHOD(get_cpuClass)(/*[out, retval]*/ BSTR * p);      
    STDMETHOD(get_systemLanguage)(/*[out, retval]*/ BSTR * p);
    STDMETHOD(get_userLanguage)(/*[out, retval]*/ BSTR * p);  
    STDMETHOD(get_platform)(/*[out, retval]*/ BSTR * p);      
    STDMETHOD(get_connectionSpeed)(/*[out, retval]*/ long * p);
    STDMETHOD(get_onLine)(/*[out, retval]*/ VARIANT_BOOL * p);
    STDMETHOD(get_colorDepth)(/*[out, retval]*/ long * p);    
    STDMETHOD(get_bufferDepth)(/*[out, retval]*/ long * p);   
    STDMETHOD(get_width)(/*[out, retval]*/ long * p);         
    STDMETHOD(get_height)(/*[out, retval]*/ long * p);        
    STDMETHOD(get_availHeight)(/*[out, retval]*/ long * p);   
    STDMETHOD(get_availWidth)(/*[out, retval]*/ long * p); 
    STDMETHOD(get_connectionType)(/*[out, retval]*/ BSTR * p); 
    STDMETHOD(getComponentVersion)(/*[in]*/ BSTR bstrName, /*[in]*/ BSTR bstrType, /*[out,retval]*/ BSTR *pbstrVer);
    STDMETHOD(isComponentInstalled)(/*[in]*/ BSTR bstrName, /*[in]*/ BSTR bstrType, /*[in,optional]*/ BSTR bStrVer, /*[out,retval]*/ VARIANT_BOOL *p);
    STDMETHOD(compareVersions)(/*[in]*/ BSTR bstrVer1, /*[in]*/ BSTR bstrVer2, /*[out,retval]*/long *p); 
    STDMETHOD(addComponentRequest)(/*[in]*/ BSTR bstrName, /*[in]*/ BSTR bstrType, /*[in, optional]*/ BSTR bstrVer);
    STDMETHOD(doComponentRequest)(/*[out]*/ VARIANT_BOOL * pVal);
    STDMETHOD(clearComponentRequest)();

    //IHTMLPeerElement methods
    STDMETHOD(Init)(IElementBehaviorSite *pSite);
    STDMETHOD(Notify)(LONG lNotify, VARIANT * pVarNotify);
    STDMETHOD(Detach)() { return S_OK; };

private:
    STDMETHOD(GetHTMLWindow)(/* out */ IHTMLWindow2 **ppWindow);
    STDMETHOD(GetHTMLDocument)(/* out */IHTMLDocument2 **ppDoc);
    STDMETHOD(GetClientInformation)(/* out */IOmNavigator **ppClientInformation);
    STDMETHOD(GetScreen)(/* out */ IHTMLScreen **ppScreen);
    STDMETHOD(GetVersion)(BSTR bstrName, BSTR bstrType, LPDWORD pdwMS, LPDWORD pdwLS);

private: // helpers functions to convert between version strings and DWORD's
    static HRESULT GetVersionFromString(LPCOLESTR psz, LPDWORD pdwMS, LPDWORD pdwLS);
    static HRESULT GetStringFromVersion(DWORD dwMS, DWORD dwLS, BSTR *pbstrVersion);

private:
    IElementBehaviorSite * m_pSite;
    int iComponentNum;
    int iComponentCap;
    LPWSTR * ppwszComponents;

};

#endif //__CCAPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\checkbox.cxx ===
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"

#include "utils.hxx"

#include "checkbox.hxx"

const CBaseCtl::PROPDESC CCheckBox::s_propdesc[] = 
{
    {_T("value"), VT_BSTR},
    {_T("checked"), VT_BOOL, NULL, NULL, VB_FALSE},
    NULL
};

enum
{
    VALUE = 0,
    CHECKED = 1
};


HRESULT
CCheckBox::Init(CContextAccess * pca)
{
    HRESULT         hr = S_OK;

    hr = pca->Open (CA_SITEOM);
    if (hr)
        goto Cleanup;

    hr = pca->SiteOM()->RegisterName(_T("checkbox"));
    if (hr)
        goto Cleanup;

Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CCheckBox::get_value(BSTR * pv)
{
    return GetProps()[VALUE].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CCheckBox::put_value(BSTR v)
{
    return GetProps()[VALUE].Set(v); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CCheckBox::get_checked(VARIANT_BOOL * pv)
{
    return GetProps()[CHECKED].Get(pv);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CCheckBox::put_checked(VARIANT_BOOL v)
{
    return GetProps()[CHECKED].Set(v);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\ccaps.cxx ===
// ClientCaps.cpp : Implementation of CClientCaps
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"
#include "ccaps.h"

typedef HRESULT STDAPICALLTYPE SHOWHTMLDIALOGFN (HWND hwndParent, IMoniker *pmk, 
                                                 VARIANT *pvarArgIn, WCHAR* pchOptions, 
                                                 VARIANT *pvArgOut);
#define REGKEY_ACTIVESETUP   "Software\\Microsoft\\Active Setup"

/////////////////////////////////////////////////////////////////////////////
// CClientCaps


STDMETHODIMP CClientCaps::get_javaEnabled(VARIANT_BOOL * pVal)
{
    IOmNavigator *pClientInformation;
    HRESULT hr = GetClientInformation(&pClientInformation);

    if (SUCCEEDED(hr))
    {
        hr = pClientInformation->javaEnabled(pVal);
        pClientInformation->Release();
    }
        return hr;
}

STDMETHODIMP CClientCaps::get_cookieEnabled(VARIANT_BOOL * pVal)
{
    IOmNavigator *pClientInformation;
    HRESULT hr = GetClientInformation(&pClientInformation);

    if (SUCCEEDED(hr))
    {
        hr = pClientInformation->get_cookieEnabled(pVal);
        pClientInformation->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_cpuClass(BSTR * p)
{
    IOmNavigator *pClientInformation;
    HRESULT hr = GetClientInformation(&pClientInformation);

    if (SUCCEEDED(hr))
    {
        hr = pClientInformation->get_cpuClass(p);
        pClientInformation->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_systemLanguage(BSTR * p)
{
    IOmNavigator *pClientInformation;
    HRESULT hr = GetClientInformation(&pClientInformation);

    if (SUCCEEDED(hr))
    {
        hr = pClientInformation->get_systemLanguage(p);
        pClientInformation->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_userLanguage(BSTR * p)
{
    IOmNavigator *pClientInformation;
    HRESULT hr = GetClientInformation(&pClientInformation);

    if (SUCCEEDED(hr))
    {
        hr = pClientInformation->get_userLanguage(p);
        pClientInformation->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_platform(BSTR * p)
{
    IOmNavigator *pClientInformation;
    HRESULT hr = GetClientInformation(&pClientInformation);

    if (SUCCEEDED(hr))
    {
        hr = pClientInformation->get_platform(p);
        pClientInformation->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_connectionSpeed(long * p)
{
    IOmNavigator *pClientInformation;
    HRESULT hr = GetClientInformation(&pClientInformation);

    if (SUCCEEDED(hr))
    {
        hr = pClientInformation->get_connectionSpeed(p);
        pClientInformation->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_onLine(VARIANT_BOOL *p)
{
    IOmNavigator *pClientInformation;
    HRESULT hr = GetClientInformation(&pClientInformation);

    if (SUCCEEDED(hr))
    {
        hr = pClientInformation->get_onLine(p);
        pClientInformation->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_colorDepth(long * p)
{
    IHTMLScreen *pScreen;
    HRESULT hr = GetScreen(&pScreen);

    if (SUCCEEDED(hr))
    {
        hr = pScreen->get_colorDepth(p);
        pScreen->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_bufferDepth(long * p)
{
    IHTMLScreen *pScreen;
    HRESULT hr = GetScreen(&pScreen);

    if (SUCCEEDED(hr))
    {
        hr = pScreen->get_bufferDepth(p);
        pScreen->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_width(long * p)
{
    IHTMLScreen *pScreen;
    HRESULT hr = GetScreen(&pScreen);

    if (SUCCEEDED(hr))
    {
        hr = pScreen->get_width(p);
        pScreen->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_height(long * p)
{
    IHTMLScreen *pScreen;
    HRESULT hr = GetScreen(&pScreen);

    if (SUCCEEDED(hr))
    {
        hr = pScreen->get_height(p);
        pScreen->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_availHeight(long * p)
{
    IHTMLScreen *pScreen;
    HRESULT hr = GetScreen(&pScreen);

    if (SUCCEEDED(hr))
    {
        hr = pScreen->get_availHeight(p);
        pScreen->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_availWidth(long * p)
{
    IHTMLScreen *pScreen;
    HRESULT hr = GetScreen(&pScreen);

    if (SUCCEEDED(hr))
    {
        hr = pScreen->get_availWidth(p);
        pScreen->Release();
    }
        return hr;

}

STDMETHODIMP CClientCaps::get_connectionType(BSTR *pbstr)
{
    DWORD dwFlags = 0;
    BOOL bConnected;
    HRESULT hr = S_OK;
    DWORD dwState = 0;
    DWORD dwSize = sizeof(dwState);
    BOOL bGlobalOffline = FALSE ;  // Has the user gone into offline mode, inspite of having a connection.       

    if (InternetQueryOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState, &dwSize))
    {
        if (dwState &  INTERNET_STATE_DISCONNECTED_BY_USER)
            bGlobalOffline = TRUE;
    }

    bConnected = InternetGetConnectedStateEx(&dwFlags, NULL, 0, 0);


    // NOTE: We use literal strings in code and resources so these don't get localized.
    if (bConnected && !bGlobalOffline)
    {
        // If we are connected figure out how.
        if (dwFlags &  INTERNET_CONNECTION_MODEM )
        {
            *pbstr = SysAllocString(L"modem"); 
        }
        else if (dwFlags & INTERNET_CONNECTION_LAN )
        {
            *pbstr = SysAllocString(L"lan");
        }
        else 
        {
            // Don't know what to do here. 
            *pbstr = SysAllocString(L"");
            hr = S_FALSE;
        }
    }
    else 
    {
        *pbstr = SysAllocString(L"offline");
    }                    

    if (!*pbstr)
        hr = E_OUTOFMEMORY;
        
    return hr;
}
        
STDMETHODIMP CClientCaps::isComponentInstalled(BSTR bstrName, BSTR bstrType, BSTR bstrVersion, VARIANT_BOOL *pVal)
{

    if (pVal == NULL)
    {
        return E_POINTER;
    }

    DWORD dwVersionMS;
    DWORD dwVersionLS;
    HRESULT hr = GetVersion(bstrName, bstrType, &dwVersionMS, &dwVersionLS);
    HRESULT hrRet;

    if (hr == S_OK)
    {
        if (bstrVersion && bstrVersion[0] != L'\0')
        {
            // User wants us to check for minimum version number.
            DWORD dwVersionReqdMS;
            DWORD dwVersionReqdLS;
            hr = GetVersionFromString(bstrVersion, &dwVersionReqdMS, &dwVersionReqdLS);
            if (SUCCEEDED(hr))
            {
                if ( (dwVersionMS > dwVersionReqdMS) || 
                     (dwVersionMS == dwVersionReqdMS && dwVersionLS >= dwVersionReqdLS)
                   )
                {
                    *pVal = TRUE;
                }
                else 
                {
                    *pVal = FALSE;
                }
                hrRet = S_OK;
            }
            else
            {
                *pVal = FALSE;
                hrRet = S_FALSE; 
            }
        }
        else 
        {                      
            *pVal = TRUE;
            hrRet = S_OK;
        }
    }
    else if (hr == S_FALSE)
    {
        *pVal = FALSE;
        hrRet = S_OK;
    }
    else
    {
        // This is really an error, but to avoid script error dialogs we still return a success
        // code, but indicate that the component is not installed.
        *pVal = FALSE;
        hrRet = S_FALSE;
    }
                         
        return hrRet;
}

STDMETHODIMP CClientCaps::getComponentVersion(BSTR bstrName, BSTR bstrType, BSTR* pbstrVersion)
{
    if (pbstrVersion == NULL)
        return E_POINTER;

    DWORD dwVersionMS;
    DWORD dwVersionLS;
    HRESULT hr = GetVersion(bstrName, bstrType, &dwVersionMS, &dwVersionLS);

    if (hr == S_OK)
    {
        hr = GetStringFromVersion(dwVersionMS, dwVersionLS, pbstrVersion); 
    }
    else 
    {
        *pbstrVersion = SysAllocString(L"");
        hr = S_OK;
    }                      
         
        return hr;
}

STDMETHODIMP CClientCaps::compareVersions(BSTR bstrVer1, BSTR bstrVer2, long *p)
{
    if ( p == NULL)
        return E_POINTER;

    HRESULT hr = S_OK;
    if (bstrVer1 == NULL || bstrVer2 == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        DWORD dwMS1 = 0 , dwLS1 = 0, dwMS2 = 0, dwLS2 = 0;

        HRESULT hr1 = GetVersionFromString(bstrVer1, &dwMS1, &dwLS1);
        HRESULT hr2 = GetVersionFromString(bstrVer2, &dwMS2, &dwLS2);

        if (SUCCEEDED(hr1) && SUCCEEDED(hr2))
        {
            if (dwMS1 > dwMS2)
                *p = 1;
            else if (dwMS1 < dwMS2)
                *p = -1;
            else  /* dwMS1 == dwMS2 */
            {
                if (dwLS1 > dwLS2)
                    *p = 1;
                else if (dwLS1 < dwLS2)
                    *p = -1;
                else
                    *p = 0;
            }
            hr = S_OK;
        }
        else
        {
            *p = 1;         // ISSUE: what is the right thing to do here.
            hr = S_FALSE;
        }
    }
    return hr;
}


STDMETHODIMP CClientCaps::addComponentRequest(BSTR bstrName, BSTR bstrType, BSTR bstrVer)
// Checks if the passed component is installed (optionally at or above the passed version)
// and if not, adds it to a list of components to be added at a call to DoComponentRequest
{
    HRESULT hr = 0;
    VARIANT_BOOL bInstalled;
    uCLSSPEC classspec;
    int iLength;
    int iRes;
    LPWSTR pwszComponentID = NULL;

    LPSTR pszComponentID = NULL;



    hr = isComponentInstalled(bstrName, bstrType, bstrVer, &bInstalled);

    // Unknown Error
    if(! SUCCEEDED(hr))
    {
        goto Exit;
    }
    // Component is already installed
    if(bInstalled)
    {
        hr = S_OK;
        goto Exit;
    }
    // otherwise, add the comnponent to the list of components to be installed


    // First figure out the type of the component and populate the CLSSPEC appropriately.
    if (0 == StrCmpICW(bstrType, L"mimetype"))
    {
        classspec.tyspec =  TYSPEC_MIMETYPE;
        classspec.tagged_union.pMimeType = bstrName;
    }
    else if (0 == StrCmpICW(bstrType, L"progid"))
    {
        classspec.tyspec = TYSPEC_PROGID;
        classspec.tagged_union.pProgId = bstrName;
    }
    else if (0 == StrCmpICW(bstrType, L"clsid"))
    {
        classspec.tyspec = TYSPEC_CLSID;
        // Convert class-id string to GUID.
        hr = CLSIDFromString(bstrName, &classspec.tagged_union.clsid);
        if (FAILED(hr))
            goto Exit;
    }
    else if (0 == StrCmpICW(bstrType, L"componentid")) //internally called a FeatureID
    {
        classspec.tyspec = TYSPEC_FILENAME;
        classspec.tagged_union.pFileName = bstrName;
    }
    else
    {
        hr = E_INVALIDARG;
        goto Exit;
    }
    
    // Get a ComponentID from the uCLSSPEC
    hr = GetComponentIDFromCLSSPEC(&classspec, &pszComponentID);
    if(FAILED(hr))
    {
        goto Exit;
    }


    // Convert the ComponentID to a wide character string (wide expected by ShowHTMLDialog)
    iLength = lstrlenA(pszComponentID) + 1;
    pwszComponentID = new WCHAR[iLength];
    if(pwszComponentID == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    iRes = MultiByteToWideChar(CP_ACP,0,pszComponentID, iLength,
                             pwszComponentID, iLength);
    if(iRes == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        if(pwszComponentID)
        {
            delete [] pwszComponentID;
            pwszComponentID = NULL;
        }
        goto Exit;
    }


    // initialize array for first time
    if(ppwszComponents == NULL)
    {
        // Hard coded initial size of 10; It's in the right order of magnitude
        // Maybe this should be in a constant, but that seems a lot of overhead
        // for such a small feature
        ppwszComponents = new LPWSTR[10];
        iComponentNum = 0;
        iComponentCap = 10;
    }

    // Resizing the array of Components
    if(iComponentNum >= iComponentCap)
    {
        iComponentCap *= 2;
        LPWSTR * ppwszOldComponents = ppwszComponents;
        ppwszComponents = NULL;
        ppwszComponents = new LPWSTR[iComponentCap];
        if(ppwszComponents == NULL)
        {
            hr = E_OUTOFMEMORY;
            ppwszComponents = ppwszOldComponents;
            if(pwszComponentID)
            {
                delete [] pwszComponentID;
                pwszComponentID = NULL;
            }
            goto Exit;
        }
        for(int i = 0; i < iComponentNum; i++)
        {
            ppwszComponents[i] = ppwszOldComponents[i];
        }
        delete [] ppwszOldComponents;
    }

    ppwszComponents[iComponentNum++] =  pwszComponentID;
    hr = S_OK;    

Exit:

    if(pszComponentID)
    {
        CoTaskMemFree(pszComponentID);
    }
    return hr;
}

STDMETHODIMP CClientCaps::doComponentRequest(VARIANT_BOOL * pVal)
// Uses the url in HKLM\Software\Microsoft\Active Setup\JITSetupPage 
// to add the list of components logged using AddComponentRequest
{
    SHOWHTMLDIALOGFN *pfnShowHTMLDialog = NULL;
    HINSTANCE hInst = 0;
    HRESULT hr = 0;
    LPWSTR pwszFeatures = NULL;
    IMoniker *pMk = NULL;
    VARIANT vtDialogArg;
    VariantInit(&vtDialogArg);
    VARIANT vtRetVal;
    VariantInit(&vtRetVal);
    int i,j,k,iFeatureArgLength;
    TCHAR *pszSETUPPAGE = _T("JITSetupPage");
    WCHAR wszDownLoadPage[MAX_PATH];
    WCHAR wszDownLoadPageReg[MAX_PATH];
//    LPWSTR pwszDownLoadPage = NULL;
    HKEY hkeyActiveSetup = 0;
    LONG lResult = 0;
    DWORD dwType;
    DWORD dwSize = INTERNET_MAX_URL_LENGTH;
    int iLength = 0;
    int iRes = 0;
    OSVERSIONINFO osvi;


    // NT5 should never show JIT dialog.

    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);

    if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
        osvi.dwMajorVersion >= 5) {
        hr = E_ACCESSDENIED;
        goto Exit;
    }

    // No Component Requests to process.  Return success and exit
    if(iComponentNum <= 0)
    {
        if(pVal)
            *pVal = TRUE;
        hr = S_OK;
        goto Exit;
    }


    // calculate space needed
    iFeatureArgLength = 0;
    // Length for the characters in the ComponentIDs
    for(k = 0; k < iComponentNum; k++)
    {
        iFeatureArgLength += lstrlenW(ppwszComponents[k]);
    }
    iFeatureArgLength += 9*iComponentNum - 1;  // "Feature="s and &'s
    iFeatureArgLength += 10;                 // breathing room
    pwszFeatures = new WCHAR[iFeatureArgLength];
    if(!pwszFeatures)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // copy the individual strings to one big string, seperated by "&feature="
    // i.e. "feature=JavaVM&feature=MOBILEPKx86"
    // i is the position in the full string
    // k is the current substring
    for(i = k = 0; k < iComponentNum; k++)
    {
        // "feature="
        StrCpyW(pwszFeatures + i, L"feature=");
        i += 8;
        iLength = lstrlenW(ppwszComponents[k]);
        // componentID
        StrCpyW(pwszFeatures + i, ppwszComponents[k]);
        i += iLength;
        // "&" || '\0'
        if(k + 1 < iComponentNum)
        {
            pwszFeatures[i] = L'&';
            i++;
        }
        else
        {
            pwszFeatures[i] = L'\0';
            i++;
        }
    }

    // Change string to variant
    vtDialogArg.vt = VT_BSTR;
    vtDialogArg.bstrVal = SysAllocString(pwszFeatures);
    if(! vtDialogArg.bstrVal)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // get the download dialog page from the registry
    if ((lResult = RegOpenKeyExA( HKEY_LOCAL_MACHINE, 
            REGKEY_ACTIVESETUP, 0, KEY_READ,
            &hkeyActiveSetup)) != ERROR_SUCCESS) 
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }

    if (lResult = SHQueryValueEx(hkeyActiveSetup, pszSETUPPAGE, NULL, 
        &dwType, wszDownLoadPageReg, &dwSize) != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }

    if (wszDownLoadPageReg) {
        WCHAR             *wszDownLoadPageFile = NULL;

        wszDownLoadPageFile = PathFindFileNameW(wszDownLoadPageReg);
        hr = SHGetWebFolderFilePathW(wszDownLoadPageFile, wszDownLoadPage, MAX_PATH);
        if (FAILED(hr)) {
            goto Exit;
        }
    }

/*    iLength = lstrlenA(szDownLoadPage) + 1;
    pwszDownLoadPage = new WCHAR[iLength];
    iRes = MultiByteToWideChar(CP_ACP,0,szDownLoadPage, iLength,
                             pwszDownLoadPage, iLength);
    if(iRes == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

*/
    // Get Moniker to The JIT Dialog page
    hr =  CreateURLMoniker(NULL, wszDownLoadPage, &pMk);
    if (FAILED(hr))
        goto Exit;


    // Get the ShowHTMLDialog function from the mshtml dll
    hInst = LoadLibraryEx(TEXT("MSHTML.DLL"), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    if (!hInst)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    pfnShowHTMLDialog = (SHOWHTMLDIALOGFN *)GetProcAddress(hInst, "ShowHTMLDialog");
    if (!pfnShowHTMLDialog) 
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }    

    
    // Show the JIT download page; the rest of the work is accomplished there
    hr = (*pfnShowHTMLDialog)(NULL, pMk, &vtDialogArg, NULL, &vtRetVal);

    if(FAILED(hr))
    {
        goto Exit;
    }


    // Process the return value
    if ((vtRetVal.vt == VT_I4) && vtRetVal.lVal != S_OK ) 
    {
        hr = S_FALSE;
        if(pVal)
            *pVal = FALSE;
    }
    else if(vtRetVal.vt != VT_I4)
    {
        hr = S_FALSE;
        if(pVal)
            *pVal = FALSE;
    }
    else
    {
        hr = S_OK;
        if(pVal)
           *pVal = TRUE;
    }

    // Since everything was successful, clear the component list
    clearComponentRequest();



Exit:    // Goto needed because these resources must be cleaned up on all errors and successes

    // clear string
    if(pwszFeatures)
        delete [] pwszFeatures;
    if(pMk)
    {
        pMk->Release();
    }
//    if(pwszDownLoadPage)
//    {
//        delete [] pwszDownLoadPage;
//        pwszDownLoadPage = NULL;
//    }
    VariantClear(&vtRetVal);
    VariantClear(&vtDialogArg);
    if(hInst)
    {
         FreeLibrary(hInst);
    }

    return hr;
}

STDMETHODIMP CClientCaps::clearComponentRequest()
// Clears the list of components logged using AddComponentRequest
{
    int i;
    for(i = 0; i < iComponentNum; i++)
    {
        if(ppwszComponents[i] != NULL)
        {
            // delete the wide string
            delete [] ppwszComponents[i];
            ppwszComponents[i] = NULL;
        }
    }
    iComponentNum = 0;
    return S_OK;
}

    
// IElementBehavior methods

STDMETHODIMP CClientCaps::Init(IElementBehaviorSite *pSite)
{
    HRESULT hr = E_INVALIDARG;

    if (pSite != NULL)
    {
        m_pSite = pSite;
        m_pSite->AddRef();
        hr = S_OK;
    }

    return hr;  
}

STDMETHODIMP CClientCaps::Notify(LONG lNotify, VARIANT * pVarNotify)
{
    return S_OK;
}

// Helper functions for internal use only

STDMETHODIMP CClientCaps::GetHTMLDocument(IHTMLDocument2 **ppDoc)
{
    HRESULT hr = E_FAIL;

    if (m_pSite != NULL)
    {
        IHTMLElement *pElement = NULL;
        hr = m_pSite->GetElement(&pElement);
        if (SUCCEEDED(hr))
        {
            IDispatch * pDispDoc = NULL;
            hr = pElement->get_document(&pDispDoc);
            if (SUCCEEDED(hr))
            {
                hr = pDispDoc->QueryInterface(IID_IHTMLDocument2, (void **)ppDoc);
                pDispDoc->Release();
            }
            pElement->Release();
        }
    }

    return hr;
}


STDMETHODIMP CClientCaps::GetHTMLWindow(IHTMLWindow2 **ppWindow)
{
    HRESULT hr = E_FAIL;
    IHTMLDocument2 *pDoc = NULL;

    hr = GetHTMLDocument(&pDoc);

    if (SUCCEEDED(hr))
    {
        hr = pDoc->get_parentWindow(ppWindow);
        pDoc->Release();
    }

    return hr;
}

STDMETHODIMP CClientCaps::GetClientInformation(IOmNavigator **ppNav)
{
    HRESULT hr = E_FAIL;
    IHTMLWindow2 *pWindow = NULL;

    hr = GetHTMLWindow(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_clientInformation(ppNav);
        pWindow->Release();
    }

    return hr ;
}

STDMETHODIMP CClientCaps::GetScreen(IHTMLScreen **ppScreen)
{
    HRESULT hr = E_FAIL;
    IHTMLWindow2 *pWindow = NULL;

    hr = GetHTMLWindow(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_screen(ppScreen);
        pWindow->Release();
    }

    return hr ;
}

// Returns S_OK if component is installed and the version # in pbstrVersion.
// Returns S_FALSE if component is not installed.
// E_INVALIDARG if the input args are ill-formed or not an IE component.
// E_* if it encounters an error. 

STDMETHODIMP CClientCaps::GetVersion(BSTR bstrName, BSTR bstrType, LPDWORD pdwFileVersionMS, LPDWORD pdwFileVersionLS)
{
    if (bstrName == NULL || bstrType == NULL)
        return E_INVALIDARG;
        
    uCLSSPEC classspec;
    HRESULT hr = E_FAIL;
    QUERYCONTEXT qc = {0};

    // First figure out the type of the component and populate the CLSSPEC appropriately.
    if (0 == StrCmpICW(bstrType, L"mimetype"))
    {
        classspec.tyspec =  TYSPEC_MIMETYPE;
        classspec.tagged_union.pMimeType = bstrName;
    }
    else if (0 == StrCmpICW(bstrType, L"progid"))
    {
        classspec.tyspec = TYSPEC_PROGID;
        classspec.tagged_union.pProgId = bstrName;
    }
    else if (0 == StrCmpICW(bstrType, L"clsid"))
    {
        classspec.tyspec = TYSPEC_CLSID;
        // Convert class-id string to GUID.
        hr = CLSIDFromString(bstrName, &classspec.tagged_union.clsid);
        if (FAILED(hr))
            goto Exit;
    }
    else if (0 == StrCmpICW(bstrType, L"componentid"))
    {
        classspec.tyspec = TYSPEC_FILENAME;
        classspec.tagged_union.pFileName = bstrName;
    }
    else
    {
        hr = E_INVALIDARG;
        goto Exit;
    }                


    hr = FaultInIEFeature(NULL, &classspec, &qc, FIEF_FLAG_PEEK);

    if (hr == S_OK || (qc.dwVersionHi != 0 || qc.dwVersionLo != 0))
    {
        // Put the version #'s that we found in the out args.
        if (pdwFileVersionMS != NULL)
            *pdwFileVersionMS = qc.dwVersionHi;
        if (pdwFileVersionLS != NULL)
            *pdwFileVersionLS = qc.dwVersionLo;

        hr = S_OK;         
    }
    else if ( hr == S_FALSE)
    {
        // this implies the component is not recognized as an IE component.
        // The input argument must be incorrect in this case.
        hr = E_INVALIDARG;
    }
    else if ( hr == HRESULT_FROM_WIN32(ERROR_PRODUCT_UNINSTALLED))
    {
        hr = S_FALSE;
    }

Exit:
    return hr;
} 


// ---------------------------------------------------------------------------
// %%Function: GetVersionFromString
//
//    converts version in text format (a,b,c,d) into two dwords (a,b), (c,d)
//    The printed version number is of format a.b.d (but, we don't care)
// ---------------------------------------------------------------------------
HRESULT
CClientCaps::GetVersionFromString(LPCOLESTR szBuf, LPDWORD pdwFileVersionMS, LPDWORD pdwFileVersionLS)
{
    LPCOLESTR pch = szBuf;
    OLECHAR ch;

    *pdwFileVersionMS = 0;
    *pdwFileVersionLS = 0;

    if (!pch)            // default to zero if none provided
        return S_OK;

    if (StrCmpCW(pch, L"-1,-1,-1,-1") == 0) {
        *pdwFileVersionMS = 0xffffffff;
        *pdwFileVersionLS = 0xffffffff;
        return S_OK;
    }

    USHORT n = 0;

    USHORT a = 0;
    USHORT b = 0;
    USHORT c = 0;
    USHORT d = 0;

    enum HAVE { HAVE_NONE, HAVE_A, HAVE_B, HAVE_C, HAVE_D } have = HAVE_NONE;


    for (ch = *pch++;;ch = *pch++) {

        if ((ch == L',') || (ch == L'\0')) {

            switch (have) {

            case HAVE_NONE:
                a = n;
                have = HAVE_A;
                break;

            case HAVE_A:
                b = n;
                have = HAVE_B;
                break;

            case HAVE_B:
                c = n;
                have = HAVE_C;
                break;

            case HAVE_C:
                d = n;
                have = HAVE_D;
                break;

            case HAVE_D:
                return E_INVALIDARG; // invalid arg
            }

            if (ch == L'\0') {
                // all done convert a,b,c,d into two dwords of version

                *pdwFileVersionMS = ((a << 16)|b);
                *pdwFileVersionLS = ((c << 16)|d);

                return S_OK;
            }

            n = 0; // reset

        } else if ( (ch < L'0') || (ch > L'9'))
            return E_INVALIDARG;    // invalid arg
        else
            n = n*10 + (ch - L'0');


    } /* end forever */

    // NEVERREACHED
}


// ---------------------------------------------------------------------------
// %%Function: GetStringFromVersion
//
//    converts version from two DWORD's to the string format a,b,c,d
// ---------------------------------------------------------------------------

HRESULT CClientCaps::GetStringFromVersion(DWORD dwVersionMS, DWORD dwVersionLS, BSTR *pbstrVersion)
{
    if (pbstrVersion == NULL)
        return E_POINTER;

    // 16-bits is a max of 5 decimal digits * 4 + 3 ','s  + null terminator    
    const int maxStringSize = 5 * 4 + 3 * 1 + 1;                            
    OLECHAR rgch[maxStringSize];

    USHORT a = (USHORT)(dwVersionMS >> 16);
    USHORT b = (USHORT)(dwVersionMS & 0xffff);
    USHORT c = (USHORT)(dwVersionLS >> 16);
    USHORT d = (USHORT)(dwVersionLS & 0xffff);

    OLECHAR rgchFormat[] = L"%hu,%hu,%hu,%hu";

    int nRet = wnsprintfW(rgch, maxStringSize, rgchFormat, a, b, c, d);

    HRESULT hr;
    if (nRet < 7 ) // 0,0,0,0
    {
        hr = E_FAIL;
    }
    else
    {
        *pbstrVersion = SysAllocString(rgch);
        if (*pbstrVersion == NULL)
            hr = E_OUTOFMEMORY;
        else
            hr = S_OK;
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\checkbase.cxx ===
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"

#include "utils.hxx"

#include "checkbase.hxx"

const static SIZE g_sizeStdGlyph    = { 13, 13 };
const static RECT g_offsetsStdGlyph = { 4, 4, 3, 3 };

HRESULT
CCheckBase::Init()
{
    HRESULT         hr = S_OK;
    VARIANT         var;
    CContextAccess  a(_pSite);

    Assert (S_OK == CContextAccess::DbgTest(_pSite));

    hr = a.Open (CA_SITEOM | CA_DEFAULTS | CA_STYLE | CA_DEFSTYLE);
    if (hr)
        goto Cleanup;

    //
    // misc
    //

    hr = a.Defaults()->put_tabStop(VB_TRUE);
    if (hr)
        goto Cleanup;

    //
    // layout
    //

    hr = a.Style()->put_display(_T("inline-block"));
    if (hr)
        goto Cleanup;

    V_VT(&var)  = VT_UI4;
    V_UI4(&var) = g_sizeStdGlyph.cx + g_offsetsStdGlyph.left + g_offsetsStdGlyph.right;

    hr = a.DefStyle()->put_width(var);
    if (hr)
        goto Cleanup;

    V_VT(&var)  = VT_UI4;
    V_UI4(&var) = g_sizeStdGlyph.cy + g_offsetsStdGlyph.top + g_offsetsStdGlyph.bottom;

    hr = a.DefStyle()->put_height(var);
    if (hr)
        goto Cleanup;

    //
    // events
    //

    hr = AttachEvent(EVENT_ONCLICK, &a);
    if (hr)
        goto Cleanup;

    hr = AttachEvent(EVENT_ONKEYPRESS, &a);
    if (hr)
        goto Cleanup;

    hr = Init(&a);
    if (hr)
        goto Cleanup;

Cleanup:

    return hr;
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
CCheckBase::GetRenderInfo(LONG* plRenderInfo)
{
    HRESULT hr = S_OK;

    if (!plRenderInfo)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *plRenderInfo = CHECKBOX_RENDERINFO;

Cleanup:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
CCheckBase::Draw(HDC hdc, LONG lLayer, LPRECT prc, IUnknown * pReserved)
{
    HRESULT      hr = S_OK;
    UINT         dfcs = 0;
    VARIANT_BOOL fChecked = VB_FALSE;

    Assert (lLayer & CHECKBOX_RENDERINFO);

    hr = AdjustRcToGlyph((CRect*)prc);
    if (hr)
        goto Cleanup;

    dfcs |= GlyphStyle();

    hr = get_checked(&fChecked);
    if (hr)
        goto Cleanup;

    if (fChecked)
        dfcs |= DFCS_CHECKED;

    if (!IsEnabled())
        dfcs |= DFCS_INACTIVE;

    // TODO Trident uses FormsDrawGlyph for this. Investigate what stuff from there should go in here too

    hr = DrawFrameControl(hdc, prc, DFC_BUTTON, dfcs) ? S_OK : E_FAIL;

Cleanup:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
CCheckBase::AdjustRcToGlyph(CRect * prc)
{
    HRESULT     hr = S_OK;
    INT         cx = prc->width();
    INT         cy = prc->height();
    INT         cxOffsets = g_offsetsStdGlyph.left + g_offsetsStdGlyph.right;
    INT         cyOffsets = g_offsetsStdGlyph.top + g_offsetsStdGlyph.bottom;

    // adjust width

    if (g_sizeStdGlyph.cx + cxOffsets <= cx)
    {
        // completely fits (including std offsets)
        prc->left  += g_offsetsStdGlyph.left;
        prc->right -= g_offsetsStdGlyph.right;
    }
    else if (g_sizeStdGlyph.cx <= cx)
    {
        // completely fits (but std offsets don't fit entirely)
        cxOffsets = (cx - g_sizeStdGlyph.cx) / 2;
        prc->left  += cxOffsets;
        prc->right -= cxOffsets;
    }

    // adjust height

    if (g_sizeStdGlyph.cy + cyOffsets <= cy)
    {
        // completely fits (including std offsets)
        prc->top    += g_offsetsStdGlyph.top;
        prc->bottom -= g_offsetsStdGlyph.bottom;
    }
    else if (g_sizeStdGlyph.cy <= cy)
    {
        // completely fits (but std offsets don't fit entirely)
        cyOffsets = (cy - g_sizeStdGlyph.cy) / 2;
        prc->top    += cyOffsets;
        prc->bottom -= cyOffsets;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
CCheckBase::ChangeState()
{
    HRESULT         hr = S_OK;
    CContextAccess  a(_pSite);
    VARIANT_BOOL    fChecked = VB_FALSE;

    hr = a.Open(CA_SITERENDER);
    if (hr)
        goto Cleanup;

    hr = get_checked(&fChecked);
    if (hr)
        goto Cleanup;

    hr = put_checked(fChecked ? VB_FALSE : VB_TRUE);
    if (hr)
        goto Cleanup;

    hr = a.SiteRender()->Invalidate(NULL);

Cleanup:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
CCheckBase::OnClick(CEventObjectAccess *pEvent)
{
    return ChangeState();
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
CCheckBase::OnKeyPress(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;
    long    lKeyCode;            

    hr = pEvent->GetKeyCode(&lKeyCode);
    if (hr)
        goto Cleanup;

    // TODO is this the right way to check lKey?
    if (_T(' ') == lKeyCode)
    {
        hr = ChangeState();
    }

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\download.cxx ===
// ClientCaps.cpp : Implementation of CClientCaps
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"

#include "utils.hxx"

#include "download.h"

/////////////////////////////////////////////////////////////////////////////
//
// CDownload
//
/////////////////////////////////////////////////////////////////////////////

CDownload::~CDownload()
{
    ReleaseInterface (_pdispCallback);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CDownload::Download(
    BSTR        bstrURL,
    IDispatch * pdispCallback,
    IUnknown *  pUnkContainer)
{
    HRESULT                 hr;
    CComObject<CDownload> * pDownload;

    hr = CComObject<CDownload>::CreateInstance(&pDownload);
    if (hr)
        goto Cleanup;

    pDownload->_pdispCallback = pdispCallback;
    pdispCallback->AddRef();

    pDownload->StartAsyncDownload(NULL, NULL, bstrURL, pUnkContainer, TRUE);
    // hr can now be S_OK, S_ASYNC, or failure

    // ignore hr
#if 0
    if (FAILED(hr))
    {
        hr = InvokeCallback(NULL, pdispCallback);
    }
#endif

Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// the implementation is similar to CBindStatusCallback::OnDataAvailable,
//  except it waits for the last chunk of data and only then calls OnFinalDataAvailable

HRESULT
CDownload::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
{
    HRESULT             hr = S_OK;
    DWORD               dwActuallyRead;
    BYTE *              pBytes = NULL;
    CComPtr<IStream>    pStream;

    ATLTRACE(_T("CBindStatusCallback::OnDataAvailable\n"));

    if (!(BSCF_LASTDATANOTIFICATION & grfBSCF))
        goto Cleanup;

    ATLTRACE(_T("CBindStatusCallback::OnDataAvailable FINAL\n"));

    if (pstgmed->tymed != TYMED_ISTREAM)
        goto Cleanup;

    pStream = pstgmed->pstm;
    if (!pStream)
        goto Cleanup;

    pBytes = new BYTE[dwSize + 1];
    if (pBytes == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pStream->Read(pBytes, dwSize, &dwActuallyRead);
    if (hr)
        goto Cleanup;

    pBytes[dwActuallyRead] = 0;
    if (0 < dwActuallyRead)
    {
        OnFinalDataAvailable(pBytes, dwActuallyRead);
    }

Cleanup:
    delete[] pBytes;

    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

void
CDownload::OnFinalDataAvailable (BYTE * pBytes, DWORD dwSize)
{
    LPTSTR      pchString = NULL;
    ULONG       cchString;

    //
    // get unicode string
    //

    // get length
    cchString = MultiByteToWideChar(CP_ACP, 0, (LPSTR) pBytes, dwSize, NULL, 0);
    if (!cchString)
        goto Cleanup;

    pchString = new TCHAR[cchString + 1];
    if (!pchString)
        goto Cleanup;

    // convert now
    MultiByteToWideChar(CP_ACP, 0, (LPSTR) pBytes, dwSize, pchString, cchString);
    pchString[cchString] = 0;

    //
    // invoke the callback function
    //

    InvokeCallback(pchString, _pdispCallback);

Cleanup:
    ClearInterface (&_pdispCallback);

    delete pchString;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT
CDownload::InvokeCallback(LPTSTR pchString, IDispatch * pdispCallback)
{
    HRESULT     hr = S_OK;

    if (pdispCallback)
    {
        VARIANT     varArg;
        DISPPARAMS  dispparams = {&varArg, NULL, 1, 0};
        EXCEPINFO   excepinfo;
        UINT        nArgErr;

        if (pchString)
        {
            V_VT(&varArg) = VT_BSTR;
            V_BSTR(&varArg) = SysAllocString(pchString);
            if (!V_BSTR(&varArg))
                return E_OUTOFMEMORY;
        }
        else
        {
            V_VT(&varArg) = VT_NULL;
        }

        hr = pdispCallback->Invoke(
            DISPID_VALUE, IID_NULL, LOCALE_SYSTEM_DEFAULT,
            DISPATCH_METHOD, &dispparams, NULL, &excepinfo, &nArgErr);
        SysFreeString(V_BSTR(&varArg));
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CDownloadBehavior
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////

CDownloadBehavior::CDownloadBehavior()
{
    memset (this, 0, sizeof(*this));
}

/////////////////////////////////////////////////////////////////////////////

CDownloadBehavior::~CDownloadBehavior()
{
    ReleaseInterface(_pSite);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CDownloadBehavior::Init(IElementBehaviorSite *pSite)
{
    if (!pSite)
        return E_INVALIDARG;

    _pSite = pSite;
    _pSite->AddRef();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CDownloadBehavior::Notify(LONG lEvent, VARIANT * pVarNotify)
{
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CDownloadBehavior::startDownload(BSTR bstrUrl, IDispatch * pdispCallback)
{
    HRESULT hr;

    if (!bstrUrl || !pdispCallback)
        return E_INVALIDARG;

    if (!AccessAllowed(bstrUrl, _pSite))
        return E_ACCESSDENIED;

    hr = CDownload::Download(bstrUrl, pdispCallback, _pSite);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\download.h ===
#ifndef __DOWNLOAD_H_
#define __DOWNLOAD_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
//
// CDownloadBehavior
//
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CDownloadBehavior : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDownloadBehavior, &CLSID_CDownloadBehavior>,
    public IDispatchImpl<IDownloadBehavior, &IID_IDownloadBehavior, &LIBID_IEXTagLib>,

    public IElementBehavior
{
public:

    //
    // methods
    //

    CDownloadBehavior ();
    ~CDownloadBehavior ();

    //
    // IElementBehavior
    //

    STDMETHOD(Init)(IElementBehaviorSite *pSite);
    STDMETHOD(Notify)(LONG lEvent, VARIANT * pVarNotify);
    STDMETHOD(Detach)() { return S_OK; };

    //
    // IDownloadBehavior
    //

    STDMETHOD(startDownload)(BSTR bstrUrl, IDispatch * pdispCallback);

    //
    // wiring
    //

DECLARE_REGISTRY_RESOURCEID(IDR_DOWNLOADBEHAVIOR)
DECLARE_NOT_AGGREGATABLE(CDownloadBehavior)

BEGIN_COM_MAP(CDownloadBehavior)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IElementBehavior)
    COM_INTERFACE_ENTRY(IDownloadBehavior)
END_COM_MAP()

    //
    // data
    //

    IElementBehaviorSite *  _pSite;
};

/////////////////////////////////////////////////////////////////////////////
//
// CDownload
//
/////////////////////////////////////////////////////////////////////////////

class CDownload : public CBindStatusCallback<CDownloadBehavior>
{
public:

    //
    // methods
    //

    ~CDownload();

    static HRESULT Download(BSTR bstrURL, IDispatch * pdispCallback, IUnknown * pUnkContainer);

    STDMETHOD(OnDataAvailable)(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed);

    void OnFinalDataAvailable (BYTE * pBytes, DWORD dwSize);

    static HRESULT InvokeCallback(LPTSTR pchString, IDispatch * pdispCallback);

    //
    // data
    //

    IDispatch *     _pdispCallback;
};

#endif // __DOWNLOAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\devicerect.cxx ===
//===============================================================
//
//  devicerect.cxx : Implementation of the CDeviceRect Peer
//
//  Synposis : this behavior enables WYSIWYG layout on an element
//
//===============================================================
                                                              
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef __X_IEXTAG_H_
#define __X_IEXTAG_H_
#include "iextag.h"
#endif

#ifndef __X_DEVICERECT_HXX_
#define __X_DEVICERECT_HXX_
#include "devicerect.hxx"
#endif

#include <docobj.h>

#include <mshtmhst.h>

#include <mshtmcid.h>

//
// GUID and DISPID for private command
//

// define GUID right here
#undef DEFINE_GUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID DECLSPEC_SELECTANY name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
                
// GUID for private command group in CProtectedElement::Exec
DEFINE_GUID(CGID_ProtectedElementPrivate, 0x3050f6dd, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

#define IDM_ELEMENTP_SETREFERENCEMEDIA   7002   // set media on element

//+----------------------------------------------------------------------------
//
//  Member : CDeviceRect constructor
//
//-----------------------------------------------------------------------------
CDeviceRect::CDeviceRect()
{
    memset(this, 0, sizeof(CDeviceRect));

    // Other _hpi members are init'ed to zero by memset above
    _hpi.lFlags        = HTMLPAINTER_TRANSPARENT|HTMLPAINTER_HITTEST|HTMLPAINTER_NOSAVEDC|HTMLPAINTER_NOPHYSICALCLIP|HTMLPAINTER_SUPPORTS_XFORM;
    _hpi.lZOrder       = HTMLPAINT_ZORDER_ABOVE_CONTENT;
}

//+----------------------------------------------------------------------------
//
//  Member : Detach - IElementBehavior method impl
//
//  Synopsis : when the peer is detatched, we will take this oppurtunity 
//      to release our various cached pointers.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CDeviceRect::Detach() 
{ 
    return S_OK; 
}

//+----------------------------------------------------------------------------
//
//  Member : Init - IElementBehavior method impl
//
//  Synopsis : this method is called by MSHTML.dll to initialize peer object.
//      this is where we do all the connection and peer management work.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CDeviceRect::Init(IElementBehaviorSite * pPeerSite)
{
    HRESULT hr = S_OK;
    IHTMLElement            * pElem     = NULL;
    IElementBehaviorSiteOM2 * pIBS2     = NULL;
    IHTMLElementDefaults    * pIPThis   = NULL;
    IOleCommandTarget       * pOCT      = NULL;
    
    mediaType media = mediaTypeNotSet;
    CVariant varMedia;
    VARIANT varRet;

    if (!pPeerSite)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // get media setting
    hr = pPeerSite->GetElement(&pElem);
    if (hr)
        goto Cleanup;
        
    hr = pElem->getAttribute(_T("media"), 0, &varMedia);
    if (hr)
        goto Cleanup;

    // parse media value
    if (varMedia.bstrVal && 0 == _tcsicmp(_T("print"), varMedia.bstrVal))
    {
        media = mediaTypePrint;
    }
    else
    {
        // do nothing if media is not "print". No other medias ar currently supported
        goto Cleanup;
    }

    // get element defaults
    hr = pPeerSite->QueryInterface(IID_IElementBehaviorSiteOM2, (void**)&pIBS2);
    if (FAILED(hr))
        goto Cleanup;

    hr = pIBS2->GetDefaults(&pIPThis);
    if (FAILED(hr))
        goto Cleanup;

    // get commant target interface
    hr = pIPThis->QueryInterface(IID_IOleCommandTarget, (void**)&pOCT);
    if (FAILED(hr))
        goto Cleanup;

    // set reference media
    hr = pOCT->Exec((GUID *)&CGID_ProtectedElementPrivate, 
                    IDM_ELEMENTP_SETREFERENCEMEDIA,
                    media,
                    NULL, &varRet);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pElem);
    ReleaseInterface(pIPThis);
    ReleaseInterface(pIBS2);
    ReleaseInterface(pOCT);
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : Notify - IElementBehavior method impl
//
//  Synopsis : peer Interface, called for notification of document events.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CDeviceRect::Notify(LONG lEvent, VARIANT *pvar)
{
    return S_OK;
}

//+-----------------------------------------------------------------------------
//
//  Method: Draw, IHTMLPainter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDeviceRect::Draw(RECT rcBounds, RECT rcUpdate, LONG lDrawFlags, HDC hdc,
                         LPVOID pvDrawObject)
{
    return E_NOTIMPL;
}

//+-----------------------------------------------------------------------------
//
//  Method: GetRenderInfo, IHTMLPainter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDeviceRect::GetPainterInfo(HTML_PAINTER_INFO * pInfo)
{
    Assert(pInfo != NULL);

    *pInfo = _hpi;

    return S_OK;
}


//+-----------------------------------------------------------------------------
//
//  Method: HitTestPoint, IHTMLPainter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDeviceRect::HitTestPoint(POINT pt, BOOL * pbHit, LONG *plPartID)
{
    Assert(pbHit != NULL);

    *pbHit = TRUE;

    return S_OK;
}

//+-----------------------------------------------------------------------------
//
//  Method: OnResize, IHTMLPainter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDeviceRect::OnResize(SIZE size)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\cvariant.cxx ===
//=================================================
//
//  File : CVariant.cxx
//
//  purpose : implementation of a very usefull VARIANT wrapper class
//
//=================================================


#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "utils.hxx"

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include <dispex.h>
#endif



// IEEE format specifies these...
// +Infinity: 7FF00000 00000000
// -Infinity: FFF00000 00000000
//       NAN: 7FF***** ********
//       NAN: FFF***** ********

// We also test for these, because the MSVC 1.52 CRT produces them for things
// like log(0)...
// +Infinity: 7FEFFFFF FFFFFFFF
// -Infinity: FFEFFFFF FFFFFFFF


// returns true for non-infinite nans.
int isNAN(double dbl)
{
    union
    {
        USHORT rgw[4];
        ULONG  rglu[2];
        double dbl;
    } v;

    v.dbl = dbl;

#ifdef BIG_ENDIAN
    return 0 == (~v.rgw[0] & 0x7FF0) &&
        ((v.rgw[0] & 0x000F) || v.rgw[1] || v.rglu[1]);
#else
    return 0 == (~v.rgw[3] & 0x7FF0) &&
        ((v.rgw[3] & 0x000F) || v.rgw[2] || v.rglu[0]);
#endif
}


// returns false for infinities and nans.
int isFinite(double dbl)
{
    union
    {
        USHORT rgw[4];
        ULONG rglu[2];
        double dbl;
    } v;

    v.dbl = dbl;

#ifdef BIG_ENDIAN
    return (~v.rgw[0] & 0x7FE0) ||
        0 == (v.rgw[0] & 0x0010) &&
        (~v.rglu[1] || ~v.rgw[1] || (~v.rgw[0] & 0x000F));
#else
    return (~v.rgw[3] & 0x7FE0) ||
        0 == (v.rgw[3] & 0x0010) &&
        (~v.rglu[0] || ~v.rgw[2] || (~v.rgw[3] & 0x000F));
#endif
}




//+---------------------------------------------------------------------------
//
//  Function:   VARIANTARGChangeTypeSpecial
//
//  Synopsis:   Helper.
//              Converts a VARIANT of arbitrary type to a VARIANT of type VT,
//              using browswer specific conversion rules, which may differ from
//              standard OLE Automation conversion rules (usually because
//              Netscape does something wierd).
//
//              This was pulled out of VARIANTARGToCVar because its also called
//              from CheckBox databinding.
//  
//  Arguments:  [pVArgDest]     -- Destination VARIANT (should already be init'd).
//              [vt]            -- Type to convert to.
//              [pvarg]         -- Variant to convert.
//              [pv]            -- Location to place C-language variable.
//
//  Modifies:   [pv].
//
//  Returns:    HRESULT.
//
//  History:    1-7-96  cfranks pulled out from VARIANTARGToCVar.
//
//----------------------------------------------------------------------------

HRESULT
VariantChangeTypeSpecial(VARIANT *pVArgDest, 
                         VARIANT *pvarg, 
                         VARTYPE vt,
                         IServiceProvider *pSrvProvider, 
                         WORD wFlags)
{
    HRESULT             hr;
    IVariantChangeType *pVarChangeType = NULL;

    if (pSrvProvider)
    {
        hr = pSrvProvider->QueryService(SID_VariantConversion,
                                            IID_IVariantChangeType,
                                            (void **)&pVarChangeType);
        if (hr)
            goto OldWay;

        // Use script engine conversion routine.
    	hr = pVarChangeType->ChangeType(pVArgDest, pvarg, 0, vt);
        if (!hr)
            goto Cleanup;   // ChangeType suceeded we're done...
    }

    // Fall back to our tried & trusted type coercions
OldWay:

    hr = S_OK;

    if (vt == VT_BSTR && V_VT(pvarg) == VT_NULL)
    {
        // Converting a NULL to BSTR
        V_VT(pVArgDest) = VT_BSTR;
        V_BSTR(pVArgDest) = SysAllocString( L"null");
        if (! V_BSTR(pVArgDest) )
            hr = E_OUTOFMEMORY;

        goto Cleanup;
    }
    else if (vt == VT_BSTR && V_VT(pvarg) == VT_EMPTY)
    {
        // Converting "undefined" to BSTR
        V_VT(pVArgDest) = VT_BSTR;
        V_BSTR(pVArgDest) = SysAllocString( L"undefined");
        if (! V_BSTR(pVArgDest) )
            hr = E_OUTOFMEMORY;

        goto Cleanup;
    }
    else if (vt == VT_BOOL && V_VT(pvarg) == VT_BSTR)
    {
        // Converting from BSTR to BOOL
        // To match Navigator compatibility empty strings implies false when
        // assigned to a boolean type any other string implies true.
        V_VT(pVArgDest) = VT_BOOL;
        V_BOOL(pVArgDest) = SysStringLen(V_BSTR(pvarg)) == 0 ? VB_FALSE : VB_TRUE;
        goto Cleanup;
    }
    else if (  V_VT(pvarg) == VT_BOOL && vt == VT_BSTR )
    {
        // Converting from BOOL to BSTR
        // To match Nav we either get "true" or "false"
        V_VT(pVArgDest) = VT_BSTR;
        V_BSTR(pVArgDest) = SysAllocString( V_BOOL(pvarg) == VB_TRUE ? L"true" : L"false");
        if (! V_BSTR(pVArgDest) )
            hr = E_OUTOFMEMORY;

        goto Cleanup;
    }
    // If we're converting R4 or R8 to a string then we need special handling to
    // map Nan and +/-Inf.
    else if (vt == VT_BSTR && (V_VT(pvarg) == VT_R8 || V_VT(pvarg) == VT_R4))
    {
        double  dblValue = V_VT(pvarg) == VT_R8 ? V_R8(pvarg) : (double)(V_R4(pvarg));

        // Infinity or NAN?
        if (!isFinite(dblValue))
        {
            if (isNAN(dblValue))
            {
                // NAN
                V_BSTR(pVArgDest) = SysAllocString(L"NaN");
                if (! V_BSTR(pVArgDest)) 
                    hr = E_OUTOFMEMORY;
            }
            else
            {
                // Infinity
                V_BSTR(pVArgDest) = SysAllocString((dblValue < 0) ? L"-Infinity" : L"Infinity" );
                if (! V_BSTR(pVArgDest)) 
                    hr = E_OUTOFMEMORY;
            }
        }
        else
            goto DefaultConvert;


        // Any error from allocating string?
        if (hr)
           goto Cleanup;

        V_VT(pVArgDest) = vt;
        goto Cleanup;
    }


DefaultConvert:
    //
    // Default VariantChangeTypeEx.
    //

    // VARIANT_NOUSEROVERRIDE flag is undocumented flag that tells OLEAUT to convert to the lcid
    // given. Without it the conversion is done to user localeid
    hr = VariantChangeTypeEx(pVArgDest, 
                             pvarg, 
                             LCID_SCRIPTING, 
                             wFlags|VARIANT_NOUSEROVERRIDE, 
                             vt);

    
    if (hr == DISP_E_TYPEMISMATCH  )
    {
        if ( V_VT(pvarg) == VT_NULL )
        {
            hr = S_OK;
            switch ( vt )
            {
            case VT_BOOL:
                V_BOOL(pVArgDest) = VB_FALSE;
                V_VT(pVArgDest) = VT_BOOL;
                break;

            // For NS compatability - NS treats NULL args as 0
            default:
                V_I4(pVArgDest)=0;
                break;
            }
        }
        else if (V_VT(pvarg) == VT_DISPATCH )
        {
            // Nav compatability - return the string [object] or null 
            V_VT(pVArgDest) = VT_BSTR;
            V_BSTR(pVArgDest) = SysAllocString ( (V_DISPATCH(pvarg)) ? L"[object]" : L"null");
            if (! V_BSTR(pVArgDest) )
                hr = E_OUTOFMEMORY;

        }
        else if ( V_VT(pvarg) == VT_BSTR && V_BSTRREF(pvarg)  &&
            ( (V_BSTR(pvarg))[0] == _T('\0')) && (  vt == VT_I4 || vt == VT_I2 || vt == VT_UI2 || vt == VT_UI4 || vt == VT_I8 ||
                vt == VT_UI8 || vt == VT_INT || vt == VT_UINT ) )
        {
            // Converting empty string to integer => Zero
            hr = S_OK;
            V_VT(pVArgDest) = vt;
            V_I4(pVArgDest) = 0;
            goto Cleanup;
        }    
    }
    else if (hr == DISP_E_OVERFLOW && vt == VT_I4 && (V_VT(pvarg) == VT_R8 || V_VT(pvarg) == VT_R4))
    {
        // Nav compatability - return MAXLONG on overflow
        V_VT(pVArgDest) = VT_I4;
        V_I4(pVArgDest) = MAXLONG;
        hr = S_OK;
        goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pVarChangeType);

    return hr ;
}



//+--------------------------------------------------------
//
//   Method : CVariant::CoerceVariantArg 
//
//  Synopsis : Coerce current variant into itself or 
//      Coerce pArgFrom into this instance from anyvariant 
//      to a given type
//
//+--------------------------------------------------------

HRESULT CVariant::CoerceVariantArg ( VARIANT *pArgFrom, WORD wCoerceToType)
{
    HRESULT hr = S_OK;
    VARIANT *pvar;

    if( V_VT(pArgFrom) == (VT_BYREF | VT_VARIANT) )
        pvar = V_VARIANTREF(pArgFrom);
    else
        pvar = pArgFrom;

    if ( !(pvar->vt == VT_EMPTY || pvar->vt == VT_ERROR ) )
    {
        hr = VariantChangeTypeSpecial ( (VARIANT *)this, 
                                    pvar,  
                                    wCoerceToType );
    }
    else
    {
        return S_FALSE;
    }

    return hr;
}

HRESULT CVariant::CoerceVariantArg (WORD wCoerceToType)
{
    HRESULT hr = S_OK;

    if ( !(vt == VT_EMPTY || vt == VT_ERROR ) )
    {
        hr = VariantChangeTypeSpecial ( (VARIANT *)this, 
                    (VARIANT *)this, wCoerceToType );
    }
    else
    {
        return S_FALSE;
    }

    return hr;
}


//+--------------------------------------------------------
//
//  Method : CVariant::CoerceNumericToI4 
//
//  Synopsis : Coerce any numeric (VT_I* or  VT_UI*) into a 
//      VT_I4 in this instance
//
//+--------------------------------------------------------
BOOL CVariant::CoerceNumericToI4 ()
{
    switch (vt)
    {
    case VT_I1:
    case VT_UI1:
        lVal = 0x000000FF & (DWORD)bVal;
        break;
    
    case VT_UI2:
    case VT_I2:
        lVal = 0x0000FFFF & (DWORD)iVal;
        break;
    
    case VT_UI4:
    case VT_I4:
    case VT_INT: 
    case VT_UINT:
        break;

    case VT_R8:
        lVal = (LONG)dblVal;
        break;

    case VT_R4:
        lVal = (LONG)fltVal;
        break;

    default:
        return FALSE;
    }

    vt = VT_I4;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\combobox.cxx ===
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"

#include "utils.hxx"

#include "combobox.hxx"


/////////////////////////////////////////////////////////////////////////////
//
// CCombobox
//
/////////////////////////////////////////////////////////////////////////////
const CBaseCtl::PROPDESC CCombobox::s_propdesc[] = 
{
    {_T("value"), VT_BSTR},
    NULL
};

enum
{
    VALUE     = 0
};
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Members:    CCombobox::CCombobox
//              CCombobox::~CCombobox
//
//  Synopsis:   Constructor/destructor
//
//-------------------------------------------------------------------------

CCombobox::CCombobox()
{
}

CCombobox::~CCombobox()
{
    int i;

    if (m_pSink)
        delete m_pSink;

    if (_pSinkBody)
    {
        delete _pSinkBody;
    }

    for (i = 0; i < 2; i++)
    {
        if (_apSinkElem[i])
        {
            delete _apSinkElem[i];
        }
    }
}

HRESULT
CCombobox::Detach()
{
    if (_pPrimaryMarkup)
    {
        _pPrimaryMarkup->Release();
    }
    if (m_pHTMLPopup)
        m_pHTMLPopup->Release();

    return S_OK;
}

HRESULT
CCombobox::Init()
{
    HRESULT         hr          = S_OK;
    BSTR            bstrEvent   = NULL;
    VARIANT_BOOL    vSuccess    = VARIANT_FALSE;
    CContextAccess  a(_pSite);

    hr = a.Open(CA_ELEM | CA_ELEM2);
    if (hr)
        goto Cleanup;

    // this puppy is ref counted when used.
    m_pSink = new CEventSink (this);

    if (!m_pSink)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // we want to sink a few events.
    //

    bstrEvent = SysAllocString (L"onclick");
    if (!bstrEvent)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    a.Elem2()->attachEvent (bstrEvent, (IDispatch *) m_pSink, &vSuccess);
    if (vSuccess == VARIANT_TRUE)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }


Cleanup:
    if (bstrEvent)
    {
        SysFreeString(bstrEvent);
    }

    return hr;
}

HRESULT
CCombobox::put_value(BSTR v)
{
    return GetProps()[VALUE].Set(v);
}

HRESULT
CCombobox::get_value(BSTR * pv)
{
    return GetProps()[VALUE].Get(pv);
}

//+------------------------------------------------------------------------
//
//  Member:     CCombobox::ProcOnClick
//
//  Synopsis:   Handles the onclick events.
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CCombobox::ProcOnClick (CEventSink *pSink)
{
    HRESULT hr = S_OK;
    long    lElemLeft, lElemTop, lElemWidth, lElemHeight;

    IHTMLDocument    *pDoc = NULL;

    IMarkupServices  *pMarkupSrv = NULL;
    IMarkupPointer   *pMarkupPStart = NULL;
    IMarkupPointer   *pMarkupPEnd = NULL;
    IHTMLElement     *pHtml = NULL;
    IHTMLElement     *pBody = NULL;
    IHTMLElement     *pElem = NULL;
    IHTMLElement2    *pElem2 = NULL;
    BSTR              bstrEvent   = NULL;
    VARIANT_BOOL      vSuccess    = VARIANT_FALSE;
    IDispatch        *pDocMain = NULL;
    IOleWindow       *pIOleWnd = NULL;
    HWND              hwndMain;
    RECT              rcClient;

    CContextAccess    a(_pSite);

    hr = a.Open(CA_ELEM);
    if (hr)
        goto Cleanup;

    // VARIANT         var;

    // var.vt == VT_EMPTY;


    if (pSink != m_pSink)
    {
        Assert(m_pHTMLPopup);
        if (pSink == _apSinkElem[0])
        {
            a.Elem()->put_innerText(_T("test1"));
        }
        else
        {
            a.Elem()->put_innerText(_T("test2"));
        }
        m_pHTMLPopup->hide();
        return hr;
    }

    // ISSUE: hr?
    a.Elem()->get_offsetLeft(&lElemLeft);
    a.Elem()->get_offsetTop(&lElemTop);
    a.Elem()->get_offsetWidth(&lElemWidth);
    a.Elem()->get_offsetHeight(&lElemHeight);

    // get the current main doc window location

    // ISSUE: hr?
    a.Elem()->get_document(&pDocMain);

    // get the oleWindow
    hr = pDocMain->QueryInterface(IID_IOleWindow, (void **)&pIOleWnd);

    if (FAILED(hr))
        goto Cleanup;

    pDocMain->Release();

    // this window can be cached
    hr = pIOleWnd->GetWindow(&hwndMain);
    hr = S_OK;

    GetWindowRect(hwndMain, &rcClient);

    lElemTop    = lElemTop + lElemHeight + rcClient.top;
    lElemLeft   = lElemLeft + rcClient.left;

    pIOleWnd->Release();

    if (m_pHTMLPopup)
    {

        //
        // we have the popup
        // just make sure it shows up
        // show it modal
        //

        /*
        hr = m_pHTMLPopup->show(a.Elem(),
                                lElemLeft, lElemTop,
                                lElemWidth, 100,
                                VARIANT_TRUE);
        */

        return hr;
    }

    //
    // create a popup window
    // if there is no window yet
    //

    hr = CoCreateInstance(CLSID_HTMLPopup,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IHTMLPopup,
                              (void **) &m_pHTMLPopup);

    if (FAILED(hr))
        return hr;

    //
    // create elements in the popup doc
    //

    // hr = m_pHTMLPopup->getDoc(&pDoc);
    hr = m_pHTMLPopup->get_document(&pDoc);

    if (FAILED(hr))
        goto Cleanup;

    //
    // get the markup services interface from the doc
    // so that we can construct a markup tree
    //


    hr = pDoc->QueryInterface(IID_IMarkupServices, (void **)&pMarkupSrv);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDoc->QueryInterface(IID_IMarkupContainer, (void **)&_pPrimaryMarkup);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->CreateMarkupPointer(&pMarkupPStart);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->CreateMarkupPointer(&pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupPStart->MoveToContainer(_pPrimaryMarkup, TRUE);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupPEnd->MoveToContainer(_pPrimaryMarkup, FALSE);
    if (FAILED(hr))
        goto Cleanup;

#define METHOD1 1

//
//  ISSUE : METHOD 2 crashes in CHtmInfo::Init
//

#ifdef  METHOD2
    hr = pMarkupSrv->ParseString(_T("<HTML><BODY><INPUT></BODY></HTML>"),
                                0,
                                &_pPrimaryMarkup, pMarkupPStart, pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    ReleaseInterface(pMarkupSrv);
    ReleaseInterface(pMarkupPStart);
    ReleaseInterface(pMarkupPEnd);
#endif

    //
    //  this is the prefered method of creating the content of the popup
    //

#ifdef  METHOD1
    hr = pMarkupSrv->CreateElement(TAGID_HTML, 0, &pHtml);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->InsertElement(pHtml, pMarkupPStart, pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->CreateElement(TAGID_BODY,
                                   _T("style='border:solid 1;overflow:hidden'"),
                                   &pBody);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPStart->MoveAdjacentToElement(pHtml, ELEM_ADJ_AfterBegin);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPEnd->MoveAdjacentToElement(pHtml, ELEM_ADJ_BeforeEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->InsertElement(pBody, pMarkupPStart, pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->CreateElement( TAGID_INPUT,
                                    _T("type=checkbox value='text1' \
                                        style='width:100%;border:0;background:white' \
                                    "),
                                    &pElem);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPStart->MoveAdjacentToElement(pBody, ELEM_ADJ_AfterBegin);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPEnd->MoveAdjacentToElement(pBody, ELEM_ADJ_BeforeEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->InsertElement(pElem, pMarkupPStart, pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPStart->MoveAdjacentToElement(pElem, ELEM_ADJ_AfterEnd);
    if (FAILED(hr))
        goto Cleanup;

    bstrEvent = SysAllocString (L"onclick");
    if (!bstrEvent)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pElem->QueryInterface(IID_IHTMLElement2, (void **)&pElem2);
    if (FAILED(hr))
        goto Cleanup;

    _apSinkElem[0] = new CEventSink (this);

    if (!_apSinkElem[0])
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pElem2->attachEvent (bstrEvent, (IDispatch *) _apSinkElem[0], &vSuccess);
    if (vSuccess == VARIANT_TRUE)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    ReleaseInterface(pElem2);
    pElem2 = NULL;
    ReleaseInterface(pElem);
    pElem = NULL;


    hr = pMarkupSrv->CreateElement( TAGID_INPUT,
                                    _T("type=button value='text2' \
                                        style='width:100%;border:0;background:white' \
                                    "),
                                    &pElem);
    if (FAILED(hr))
        goto Cleanup;

    pMarkupPEnd->MoveAdjacentToElement(pBody, ELEM_ADJ_BeforeEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pMarkupSrv->InsertElement(pElem, pMarkupPStart, pMarkupPEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = pElem->QueryInterface(IID_IHTMLElement2, (void **)&pElem2);
    if (FAILED(hr))
        goto Cleanup;

    _apSinkElem[1] = new CEventSink (this);

    if (!_apSinkElem[1])
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pElem2->attachEvent (bstrEvent, (IDispatch *) _apSinkElem[1], &vSuccess);
    if (vSuccess == VARIANT_TRUE)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
        goto Cleanup;
    }
#endif

    //
    // position the window just under the element
    // not supported due to a pdlparser problem
    //

#ifdef  METHOD3
    var.vt = VT_BSTR;
    var.bstrVal = _T("file://c:\\toto.htm");
#endif

/*
    hr = m_pHTMLPopup->show(a.Elem(),
                            lElemLeft, lElemTop,
                            lElemWidth, 100,
                            VARIANT_TRUE);

    if (FAILED(hr))
        goto Cleanup;
*/

Cleanup:
    if (pDoc)
    {
        pDoc->Release();
    }
    if (bstrEvent)
    {
        SysFreeString(bstrEvent);
    }

    ReleaseInterface(pElem2);
    ReleaseInterface(pElem);
    ReleaseInterface(pMarkupSrv);
    ReleaseInterface(pMarkupPStart);
    ReleaseInterface(pMarkupPEnd);
    ReleaseInterface(pBody);
    ReleaseInterface(pHtml);

    return hr;
}

// ========================================================================
// CEventSink::IDispatch
// ========================================================================

// The event sink's IDispatch interface is what gets called when events
// are fired.

//+------------------------------------------------------------------------
//
//  Member:     CCombobox::CEventSink::GetTypeInfoCount
//              CCombobox::CEventSink::GetTypeInfo
//              CCombobox::CEventSink::GetIDsOfNames
//
//  Synopsis:   We don't really need a nice IDispatch... this minimalist
//              version does just plenty.
//
//-------------------------------------------------------------------------

STDMETHODIMP
CCombobox::CEventSink::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CCombobox::CEventSink::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CCombobox::CEventSink::GetIDsOfNames( REFIID          riid,
                                         OLECHAR**       rgszNames,
                                         UINT            cNames,
                                         LCID            lcid,
                                         DISPID*         rgDispId)
{
    return E_NOTIMPL;
}

//+------------------------------------------------------------------------
//
//  Member:     CCombobox::CEventSink::Invoke
//
//  Synopsis:   This gets called for all events on our object.  (it was
//              registered to do so in Init with attach_event.)  It calls
//              the appropriate parent functions to handle the events.
//
//-------------------------------------------------------------------------
STDMETHODIMP
CCombobox::CEventSink::Invoke( DISPID dispIdMember,
                                  REFIID, LCID,
                                  WORD wFlags,
                                  DISPPARAMS* pDispParams,
                                  VARIANT* pVarResult,
                                  EXCEPINFO*,
                                  UINT* puArgErr)
{
    HRESULT hr = TRUE;
    if (m_pParent && pDispParams && pDispParams->cArgs>=1)
    {
        if (pDispParams->rgvarg[0].vt == VT_DISPATCH)
        {
            IHTMLEventObj *pObj=NULL;

            if (SUCCEEDED(pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj,
                (void **)&pObj) && pObj))
            {
                BSTR bstrEvent=NULL;

                pObj->get_type(&bstrEvent);

                // user clicked one of our anchors
                if (! StrCmpICW (bstrEvent, L"click"))
                {
                    hr = m_pParent->ProcOnClick(this);
                }

                pObj->Release();
            }
        }
    }

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CCombobox::CEventSink
//
//  Synopsis:   This is used to allow communication between the parent class
//              and the event sink class.  The event sink will call the ProcOn*
//              methods on the parent at the appropriate times.
//
//-------------------------------------------------------------------------

CCombobox::CEventSink::CEventSink (CCombobox * pParent)
{
    m_pParent = pParent;
}

// ========================================================================
// CEventSink::IUnknown
// ========================================================================

// Vanilla IUnknown implementation for the event sink.

STDMETHODIMP
CCombobox::CEventSink::QueryInterface(REFIID riid, void ** ppUnk)
{
    void * pUnk = NULL;

    if (riid == IID_IDispatch)
        pUnk = (IDispatch *) this;

    if (riid == IID_IUnknown)
        pUnk = (IUnknown *) this;

    if (pUnk)
    {
        *ppUnk = pUnk;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CCombobox::CEventSink::AddRef(void)
{
    return ((IElementBehavior *)m_pParent)->AddRef();
}

STDMETHODIMP_(ULONG)
CCombobox::CEventSink::Release(void)
{
    return ((IElementBehavior *)m_pParent)->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\headers.h ===
// headers.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__7E8BC444_AEFF_11D1_89C2_00C04FB6BFC4__INCLUDED_)
#define AFX_STDAFX_H__7E8BC444_AEFF_11D1_89C2_00C04FB6BFC4__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// Define the ATL specific macros to get the right set of things
#define _USRDLL

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#ifndef _ATL_STATIC_REGISTRY
#define _ATL_STATIC_REGISTRY
#endif

#ifndef _ATL_NO_SECURITY
#define _ATL_NO_SECURITY
#endif

// link minimally only in ship mode
#if defined(NOT_NT)
#if DBG != 1
#ifndef _ATL_MIN_CRT
#define _ATL_MIN_CRT
#endif
#endif
#endif

// Map KERNEL32 unicode string functions to SHLWAPI
// This is needed way up here.
#define lstrcmpW    StrCmpW
#define lstrcmpiW   StrCmpIW
#define lstrcpyW    StrCpyW
#define lstrcpynW   StrCpyNW
#define lstrcatW    StrCatW

// Define our own SHGetFolderPathA which will use shell32.dll uplevel and
// shfolder.dll downlevel
#define SHGetFolderPathA DLSHGetFolderPathA


#ifndef X_SHLWRAP_H_
#define X_SHLWRAP_H_
#include "shlwrap.h"
#endif

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <atlctl.h>

#include <shlwapi.h>
#include <shlwapip.h>
#include <wininet.h>
#include <winineti.h>
#include <urlmon.h>
#include <mshtml.h>
#include <mshtmdid.h>

// We don't want to have these prototypes declared with __declspec(dllimport)
#define _SHFOLDER_
#include "shlobj.h"
#include "shfolder.h"
#undef _SHFOLDER_



// Internal functions
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);

#define Assert _ASSERTE

#define ARRAY_SIZE(p)    (sizeof(p)/sizeof(p[0]))

void * MemAllocClear(size_t cb);

#define DECLARE_MEMCLEAR_NEW \
    inline void * __cdecl operator new(size_t cb) { return(MemAllocClear(cb)); } \
    inline void * __cdecl operator new[](size_t cb) { return(MemAllocClear(cb)); }

// Global variables
extern HINSTANCE   g_hInst;
extern BOOL        g_fUnicodePlatform;
extern DWORD       g_dwPlatformVersion;            // (dwMajorVersion << 16) + (dwMinorVersion)
extern DWORD       g_dwPlatformID;                 // VER_PLATFORM_WIN32S/WIN32_WINDOWS/WIN32_WINNT
extern DWORD       g_dwPlatformBuild;              // Build number
extern BOOL        g_fUseShell32InsteadOfSHFolder;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#ifdef UNIX
#ifndef _LPCBYTE_DEFINED
#define _LPCBYTE_DEFINED
typedef const BYTE *LPCBYTE;
#endif
#endif // UNIX

// include conditional code segment pragma definitions
#include "..\src\core\include\markcode.hxx"

#endif // !defined(AFX_STDAFX_H__7E8BC444_AEFF_11D1_89C2_00C04FB6BFC4__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\headfoot.cxx ===
//===============================================================
//
//  headfoot.cxx : Implementation of the CHeaderFooter
//
//  Synposis : Provides parsing and HTML header/footer building support.
//      The class has a header and footer strings and a shared table of
//      token types and their corresponding values (&p -> a string of the page #).
//      It uses the string & the tables to create an HTML table header/footer.
//
//===============================================================
                                                              
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HEADFOOT_HXX_
#define X_HEADFOOT_HXX_
#include "headfoot.hxx"
#endif

#ifndef X_IEXTAG_H_
#define X_IEXTAG_H_
#include "iextag.h"
#endif

#ifndef X_UTILS_HXX_
#define X_UTILS_HXX_
#include "utils.hxx"
#endif

TCHAR * aachTokenNames[tokTotal] =
{ _T("Page"),
  _T("PageTotal"),
  _T("Url"),
  _T("Title"),
  _T("TmShort"),
  _T("TmLong"),
  _T("DtShort"),
  _T("DtLong")   };

CHeaderFooter::~CHeaderFooter()
{
    int i;

    //  Dellocate header/footer string
    if (_achTextHead)
        delete []_achTextHead;
    if (_achTextFoot)
        delete []_achTextFoot;

    //  Deallocate the token array.
    if (_ahftTokensHead)
        delete []_ahftTokensHead;
    if (_ahftTokensFoot)
        delete []_ahftTokensFoot;

    //  Deallocate any token-type strings that we may have allocated.
    for (i=0; i<tokTotal; i++)
    {
        if (_aachTokenTypes[i])
            delete []_aachTokenTypes[i];
    }
}


//+----------------------------------------------------------------------------
//
//  Member : Init - IElementBehavior method impl
//
//  Synopsis :  peer Interface, initialization
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CHeaderFooter::Init(IElementBehaviorSite * pPeerSite)
{
    HRESULT hr      = S_OK;
    HKEY    hKey    = NULL;

    if (!pPeerSite)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

Cleanup:
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : Detach - IElementBehavior method impl
//
//  Synopsis :  peer Interface, destruction work upon detaching from document
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CHeaderFooter::Detach() 
{ 
    return S_OK; 
}

//+----------------------------------------------------------------------------
//
//  Member : Notify - IElementBehavior method impl
//
//  Synopsis : peer Interface, called for notification of document events.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CHeaderFooter::Notify(LONG lEvent, VARIANT *)
{
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  (IHeaderFooter) CHeaderFooter::get htmlHead/Foot
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CHeaderFooter::get_htmlHead(BSTR * p)
{
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
    {
        if (!_fHeadHtmlBuilt)
            BuildHtml(_ahftTokensHead, &_achHtmlHead, _cBreaksHead, _cTokensHead, _T("THeader"));

        _fHeadHtmlBuilt = TRUE;

        *p = SysAllocString(_achHtmlHead);
        if (!p)
            hr = E_OUTOFMEMORY;
    }

    return hr;
}
STDMETHODIMP
CHeaderFooter::get_htmlFoot(BSTR * p)
{
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
    {
        if (!_fFootHtmlBuilt)
            BuildHtml(_ahftTokensFoot, &_achHtmlFoot, _cBreaksFoot, _cTokensFoot, _T("TFooter"));

        _fFootHtmlBuilt = TRUE;

        *p = SysAllocString(_achHtmlFoot);
        if (!p)
            hr = E_OUTOFMEMORY;
    }

    return hr;
}
//+----------------------------------------------------------------------------
//
//  (IHeaderFooter) CHeaderFooter::get/put textHead/Foot
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CHeaderFooter::get_textHead(BSTR * p)
{
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
    {
        *p = SysAllocString(_achTextHead);
        if (!p)
            hr = E_OUTOFMEMORY;
    }

    return hr;
}
STDMETHODIMP
CHeaderFooter::get_textFoot(BSTR * p)
{
    HRESULT hr = S_OK;
    
    if (!p)
        hr = E_POINTER;
    else
    {
        *p = SysAllocString(_achTextFoot);
        if (!p)
            hr = E_OUTOFMEMORY;
    }

    return hr;
}
STDMETHODIMP
CHeaderFooter::put_textHead(BSTR v)
{
    HRESULT hr = S_OK;
    TCHAR * achTemp = v;

    if (_achTextHead)
    {
        delete []_achTextHead;
        _achTextHead = NULL;
    }

    if ( !v )
    {
        _fHeadHtmlBuilt = FALSE;
        return hr;
    }

    _achTextHead = new TCHAR[_tcslen(achTemp) + 1];
    if (!_achTextHead)
        hr = E_OUTOFMEMORY;
    else
    {
        _tcscpy(_achTextHead, achTemp);

        hr = DetoxifyString(v, &achTemp, TRUE);     // Reassigns & allocates achTemp.
        if (!hr)
        {
            //  Retokenise for the new string.
            hr = ParseText(achTemp, &_ahftTokensHead, &_cBreaksHead, &_cTokensHead);
            _fHeadHtmlBuilt = FALSE;        //  Need to rebuild HTML because the source string is different
            delete []achTemp;
        }
    }

    return hr;
}
STDMETHODIMP
CHeaderFooter::put_textFoot(BSTR v)
{
    HRESULT hr = S_OK;
    TCHAR * achTemp = v;

    if (_achTextFoot)
    {
        delete []_achTextFoot;
        _achTextFoot = NULL;
    }

    if ( !v )
    {
        _fFootHtmlBuilt = FALSE;
        return hr;
    }

    _achTextFoot = new TCHAR[_tcslen(achTemp) + 1];
    if (!_achTextFoot)
        hr = E_OUTOFMEMORY;
    else
    {
        _tcscpy(_achTextFoot, achTemp);

        hr = DetoxifyString(v, &achTemp, TRUE);     // Reassigns & allocates achTemp.
        if (!hr)
        {
            //  Retokenise for the new string.
            hr = ParseText(achTemp, &_ahftTokensFoot, &_cBreaksFoot, &_cTokensFoot);
            _fFootHtmlBuilt = FALSE;        //  Need to rebuild HTML because the source string is different
            delete []achTemp;
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  (IHeaderFooter) CHeaderFooter::get/put pageNum
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CHeaderFooter::get_page(DWORD * p)
{
    return GetTokenDWORD(p, tokPageNum);
}
STDMETHODIMP
CHeaderFooter::put_page(DWORD v)
{
    return PutTokenDWORD(v, tokPageNum);
}

//+----------------------------------------------------------------------------
//
//  (IHeaderFooter) CHeaderFooter::get/put pageTotal
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CHeaderFooter::get_pageTotal(DWORD * p)
{
    return GetTokenDWORD(p, tokPageTotal);
}
STDMETHODIMP
CHeaderFooter::put_pageTotal(DWORD v)
{
    return PutTokenDWORD(v, tokPageTotal);
}

//+----------------------------------------------------------------------------
//
//  (IHeaderFooter) CHeaderFooter::get/put URL
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CHeaderFooter::get_URL(BSTR * p)
{
    return GetTokenBSTR(p, tokURL);
}
STDMETHODIMP
CHeaderFooter::put_URL(BSTR v)
{
    return PutTokenBSTR(v, tokURL);
}

//+----------------------------------------------------------------------------
//
//  (IHeaderFooter) CHeaderFooter::get/put Title
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CHeaderFooter::get_title(BSTR * p)
{
    return GetTokenBSTR(p, tokTitle);
}
STDMETHODIMP
CHeaderFooter::put_title(BSTR v)
{
    return PutTokenBSTR(v, tokTitle);
}

//+----------------------------------------------------------------------------
//
//  (IHeaderFooter) CHeaderFooter::get/put dateShort
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CHeaderFooter::get_dateShort(BSTR * p)
{
    EnsureDateTime(tokDateShort);
    return GetTokenBSTR(p, tokDateShort);
}
STDMETHODIMP
CHeaderFooter::put_dateShort(BSTR v)
{
    return PutTokenBSTR(v, tokDateShort);
}
//+----------------------------------------------------------------------------
//
//  (IHeaderFooter) CHeaderFooter::get/put dateLong
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CHeaderFooter::get_dateLong(BSTR * p)
{
    EnsureDateTime(tokDateLong);
    return GetTokenBSTR(p, tokDateLong);
}
STDMETHODIMP
CHeaderFooter::put_dateLong(BSTR v)
{
    return PutTokenBSTR(v, tokDateLong);
}
//+----------------------------------------------------------------------------
//
//  (IHeaderFooter) CHeaderFooter::get/put timeShort
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CHeaderFooter::get_timeShort(BSTR * p)
{
    EnsureDateTime(tokTimeShort);
    return GetTokenBSTR(p, tokTimeShort);
}
STDMETHODIMP
CHeaderFooter::put_timeShort(BSTR v)
{
    return PutTokenBSTR(v, tokTimeShort);
}
//+----------------------------------------------------------------------------
//
//  (IHeaderFooter) CHeaderFooter::get/put timeLong
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CHeaderFooter::get_timeLong(BSTR * p)
{
    EnsureDateTime(tokTimeLong);
    return GetTokenBSTR(p, tokTimeLong);
}
STDMETHODIMP
CHeaderFooter::put_timeLong(BSTR v)
{
    return PutTokenBSTR(v, tokTimeLong);
}

//---------------------------------------------------------------------------
//
//  Member:     CHeaderFooter::ParseText
//
//  Synopsis:   Takes a string (achText) and parses it into an array of tokens
//              at (*pphftTokens).  Also sets *cBreaks and *cTokens to the #
//              of &b's and tokens in the array, respectively.
//
//---------------------------------------------------------------------------
HRESULT
CHeaderFooter::ParseText(TCHAR *achText, CHeadFootToken ** pphftTokens, int *cBreaks, int *cTokens)
{  
    HRESULT hr = S_OK;
    int     iLen;

    Assert(achText);
    Assert(pphftTokens);
    Assert(cBreaks);
    Assert(cTokens);

    //  Initialize variables for a new run.
    if (*pphftTokens)            //  If we have a token array, whack it and start over.
        delete [](*pphftTokens);
    *pphftTokens = NULL;
    *cBreaks = 0;               //  Begin a new count of &b's.
    *cTokens = 0;

    iLen = _tcslen(achText);
    if (iLen > 0)
    {
        HEADFOOTTOKENTYPE   hftt;
        TCHAR *             pFront;
        TCHAR *             pRear;
        int                 cMaxTokens;

        //  All that spiffy dynamic array code is privy to Trident.
        //  In place of that, we'll create an array that is at least big enough.
        //  A token is a "special" &n character or literal string.
        //  The most literals are a string like: "(literal) (special) (literal)... (special) (literal)"
        //  which yeilds (specials * 2) + 1 tokens.
        //  So, we count the specials to determine a bounding size.
        for (   pFront = achText, cMaxTokens = 0; (*pFront); pFront++)
        {
            if ((*pFront) == _T('&'))
                cMaxTokens++;
        }
        cMaxTokens = cMaxTokens * 2 + 1;
        *pphftTokens = new CHeadFootToken[cMaxTokens];
        if (!(*pphftTokens))
            return E_OUTOFMEMORY;

        pRear = achText;
        while (*pRear)
        {
            //  Get next position of a '&'
            pFront = _tcschr(pRear, _T('&'));

            //  If there was a literal between us and the '&' or string end, tokenize it.
            if (pFront)
                *pFront = _T('\0');

            if (_tcslen(pRear) > 0)
            {
                Assert((*cTokens) < cMaxTokens);
                (*pphftTokens)[(*cTokens)++].InitText(pRear);
            }
            
            if (pFront)
                *pFront = _T('&');
            else
                break;       // At end of string.  Quit.
        
            //  Move to the character after the '&'.  If we find this is a special character (below),
            //  we'll move pRear in front of it.  Otherwise, we'll leave pRear on it so that it gets included
            //  in the next string literal.
            pFront++;
                pRear = pFront;

            hftt = tokUndefined;
            switch(*pFront)
            {
                case _T('b'):
                    hftt = tokBreak;
                    (*cBreaks)++;
                    break;
                case _T('p'):
                    hftt = tokPageNum;
                    break;
                case _T('P'):
                    hftt = tokPageTotal;
                    break;
                case _T('w'):
                    hftt = tokTitle;
                    break;
                case _T('u'):
                    hftt = tokURL;
                    break;
                case _T('d'):
                    hftt = tokDateShort;
                    break;
                case _T('D'):
                    hftt = tokDateLong;
                    break;
                case _T('t'):
                    hftt = tokTimeShort;
                    break;
                case _T('T'):
                    hftt = tokTimeLong;
                    break;
                case _T('&'):
                    Assert((*cTokens) < cMaxTokens);
                    (*pphftTokens)[(*cTokens)++].InitText(_T("&"));                    
                    pFront++;
                    pRear++;
            }


            if (hftt != tokUndefined)
            {                
                // Pass the token type and (if not a break) the address of entry in our array that
                // contains the token's string.
                Assert((*cTokens) < cMaxTokens);
                (*pphftTokens)[(*cTokens)++].InitSpecial(hftt, (hftt == tokBreak) ? NULL : &_aachTokenTypes[hftt]);

                //  Advance the rear pointer to be in front of the character after the '&'
                pRear++;            
            }
        }
    }

    return hr;
};

//---------------------------------------------------------------------------
//
//  Member:     CHeaderFooter::BuildHtml
//
//  Synopsis:   Takes an array of tokens (ahftTokens) and the # of &b's (cBreaks)
//              and tokens (cTokens) in that array, and builds an HTML table string
//              in the buffered string (*achHtml).
//
//              (greglett)  Backwards compatibility:
//              To bow to compat, we have decided to make (for this release, 5.5) headers and footers
//              one line only, and to apply ellipsis whenever necessary to cut off the header/footer.
//              There are three cases (for back compat):
//              TWO CELLS (xxxx&byyyyy).  yyyy is given as much space as it needs. xxxx gets the rest, and
//                gets ellipsis as necessary.  This is to mimic the behavior for the standard H/F, in which
//                xxxx is a very long title/url.
//              THREE CELLS (&byyyyy&b).  yyyy is given the entire space  This is not true if the first or last
//                cell has contents
//              ANYTHING ELSE.  Cells are given equal amounts of space.
//
//---------------------------------------------------------------------------
HRESULT
CHeaderFooter::BuildHtmlOneBreak(CHeadFootToken * ahftTokens, CBufferedStr *achHtml, int cBreaks, int cTokens, TCHAR *pchTableClass)
{
    HEADFOOTTOKENTYPE hfttContent;
    TCHAR   achCount[MAX_DWORD_ASSTRING];   // For _ltot on the current counter id.
    TCHAR * pchContent;
    int     iBreak;
    int     iToken;

    Assert(cBreaks == 1);       // Function is only for this case.

    _ltot(_cNextId, achCount, 10);   // Get the string for the counter value.

    achHtml->Set(_T("<DIV style=\"text-align:right;position:relative;width:100%;overflow:hidden;text-overflow:ellipsis;font-size:12pt;\" id="));
    WriteElementId(achHtml, pchTableClass, achCount, _T("O"));
    achHtml->QuickAppend(_T(" class="));
    achHtml->QuickAppend(pchTableClass);

    // NB (greglett) Can't use Math.max or other max function here in the expression because of an expressions bug.
    achHtml->QuickAppend(_T("><DIV style=\"position:absolute;width:expression(("));
    WriteElementId(achHtml, pchTableClass, achCount, _T("O"));
    achHtml->QuickAppend(_T(".clientWidth - "));
    WriteElementId(achHtml, pchTableClass, achCount, _T("R"));
    achHtml->QuickAppend(_T(".offsetWidth - 10 > 0) ? ("));
    WriteElementId(achHtml, pchTableClass, achCount, _T("O"));
    achHtml->QuickAppend(_T(".clientWidth - "));
    WriteElementId(achHtml, pchTableClass, achCount, _T("R"));
    achHtml->QuickAppend(_T(".offsetWidth - 10) : 0);overflow:hidden;left:0;text-align:left;text-overflow:ellipsis;\" id="));
    WriteElementId(achHtml, pchTableClass, achCount, _T("L"));
    achHtml->QuickAppend(_T(">"));

    for (iToken=0,iBreak=0; iBreak<=cBreaks; iBreak++)
    {   
        switch (iBreak)
        {
        case 0:
            achHtml->QuickAppend(_T("<NOBR>"));
            break;
        case 1:
            achHtml->QuickAppend(_T("<NOBR id="));
            WriteElementId(achHtml, pchTableClass, achCount, _T("R"));
            achHtml->QuickAppend(_T(">"));
            break;
        }

        // Write contents
        for (;iToken < cTokens; iToken++)
        {                
            hfttContent = ahftTokens[iToken].Type();
            if (hfttContent == tokBreak)
            {
                //  &b, iterate to next table cell.
                iToken++;
                break;
            }
        
            pchContent  = ahftTokens[iToken].Content();
            //  For &d, &D, &t, &T, make a date/time string if we haven't already.
            if (    pchContent == NULL
                &&  (   hfttContent == tokDateShort
                     || hfttContent == tokDateLong
                     || hfttContent == tokTimeShort
                     || hfttContent == tokTimeLong ) )
            {
                EnsureDateTime(hfttContent);
                pchContent = ahftTokens[iToken].Content();
            }

            Assert(hfttContent >= 0 || hfttContent == tokFlatText);

            //  Write this token's content into the cell.
            //  We can be in a state in which we are supposed to print a special token (&w, etc...),
            //  but don't have it's corresponding string value (the title, etc...).  Do pointer check.
            if (hfttContent != tokFlatText)
            {
                achHtml->QuickAppend(_T("<SPAN class=hf"));
                achHtml->QuickAppend(aachTokenNames[hfttContent]);
                achHtml->QuickAppend(_T(">"));
                if (pchContent)
                    achHtml->QuickAppend(pchContent);
                achHtml->QuickAppend(_T("</SPAN>"));
            }
            else if (pchContent)
                achHtml->QuickAppend(pchContent);
        }
        
        achHtml->QuickAppend(_T("</NOBR></DIV>"));  // Either close the HFLeft (iBreak==0) or HFOut (iBreak==1)
    }

    Assert(iBreak == cBreaks+1);
    Assert(iToken == cTokens);

    return S_OK;
}

HRESULT
CHeaderFooter::BuildHtmlCentered(CHeadFootToken * ahftTokens, CBufferedStr *achHtml, int cBreaks, int cTokens, TCHAR *pchTableClass)
{
    HEADFOOTTOKENTYPE hfttContent;
    TCHAR   achCount[MAX_DWORD_ASSTRING];   // For _ltot on the current counter id.
    TCHAR * pchContent;
    int     iBreak;
    int     iToken;

    Assert(cBreaks == 2);       // Function is only for this case.

    _ltot(_cNextId, achCount, 10);   // Get the string for the counter value.

    achHtml->Set(_T("<DIV style=\"text-align:center;overflow:hidden;text-overflow:ellipsis;width:100%;font-size:12pt;\" class="));
    achHtml->QuickAppend(pchTableClass);
    achHtml->QuickAppend(_T("><NOBR>"));

    // <=, because there are (cBreaks + 1) segments to build HTML from
    for (iToken=0,iBreak=0; iBreak<=cBreaks; iBreak++)
    {   
        // Write contents
        for (;iToken < cTokens; iToken++)
        {                
            hfttContent = ahftTokens[iToken].Type();
            if (hfttContent == tokBreak)
            {
                //  &b, iterate to next table cell.
                iToken++;
                break;
            }
        
            pchContent  = ahftTokens[iToken].Content();
            //  For &d, &D, &t, &T, make a date/time string if we haven't already.
            if (    pchContent == NULL
                &&  (   hfttContent == tokDateShort
                     || hfttContent == tokDateLong
                     || hfttContent == tokTimeShort
                     || hfttContent == tokTimeLong ) )
            {
                EnsureDateTime(hfttContent);
                pchContent = ahftTokens[iToken].Content();
            }

            Assert(hfttContent >= 0 || hfttContent == tokFlatText);

            //  Write this token's content into the cell.
            //  We can be in a state in which we are supposed to print a special token (&w, etc...),
            //  but don't have it's corresponding string value (the title, etc...).  Do pointer check.
            if (hfttContent != tokFlatText)
            {
                achHtml->QuickAppend(_T("<SPAN class=hf"));
                achHtml->QuickAppend(aachTokenNames[hfttContent]);
                achHtml->QuickAppend(_T(">"));
                if (pchContent)
                    achHtml->QuickAppend(pchContent);
                achHtml->QuickAppend(_T("</SPAN>"));
            }
            else if (pchContent)
                achHtml->QuickAppend(pchContent);
        }
    }
    achHtml->QuickAppend(_T("</NOBR></DIV>"));

    Assert(iBreak == cBreaks+1);
    Assert(iToken == cTokens);

    return S_OK;
}

HRESULT
CHeaderFooter::BuildHtmlDefault(CHeadFootToken * ahftTokens, CBufferedStr *achHtml, int cBreaks, int cTokens, TCHAR *pchTableClass)
{
    HEADFOOTTOKENTYPE hfttContent;
    TCHAR   achCount[MAX_DWORD_ASSTRING];       // For _ltot on the current counter #.
    TCHAR   achCell[MAX_DWORD_ASSTRING + 1];    // For _ltot on the curren cell #
    TCHAR   achBuf[MAX_DWORD_ASSTRING];         // For _ltot on the width
    TCHAR * pchContent;
    int     iTot = 0;
    int     iInc = 100 / (cBreaks+1);
    int     iBreak;
    int     iToken;

    _ltot(_cNextId, achCount, 10);   // Get the string for the counter value.
    achCell[0] = _T('x');            // Add character to separate this from the counter.

    //  Parse the tokens, creating an HTML table with contents between &b's
    //  in separate table cells.
    achHtml->Set(_T("<TABLE style=\"border:0;width:100%;table-layout:fixed;\""));
    achHtml->QuickAppend(_T(" class="));
    achHtml->QuickAppend(pchTableClass);
    achHtml->QuickAppend(_T("><TR>"));

    // <=, because there are (cBreaks + 1) segments to build HTML from
    for (iToken=0,iBreak=0; iBreak<=cBreaks; iBreak++)
    {
        //  Write this <TD ...>
        if (iBreak == 0)
        {
            //  (greglett)  Backwards compatibility says that we should left align
            //  if _cBreaks = 0, but wouldn't it look more intuitive center aligned?
            achHtml->QuickAppend(_T("<TD style=\"text-align:left;width:"));
            _ltot(iInc, achBuf, 10);

            iTot += iInc;
        }
        else if (iBreak == cBreaks)
        {
            //  (greglett)  We don't distribute in extra percents right now - we just dump all the
            //  extras at the end.  This might look a little weird for (100 % _cBreaks) much larger than 0.
            //  The first two times this happens is at 6 and 11.  Since these are completely unrealistic
            //  cases (I know of *one* person who used 4, once), I don't think we should worry.
            achHtml->QuickAppend(_T("<TD style=\"text-align:right;width:"));
            _ltot(100-iTot, achBuf, 10);
        }
        else
        {                
            achHtml->QuickAppend(_T("<TD style=\"text-align:center;width:"));
            _ltot(iInc, achBuf, 10);

            iTot += iInc;
        }        
        achHtml->QuickAppend(achBuf);
        achHtml->QuickAppend(_T("%;overflow:hidden;text-overflow:ellipsis;font-size:12pt;\"><NOBR>"));
        
        //  Now, write this <TD>'s contents
        for (;iToken < cTokens; iToken++)
        {                
            hfttContent = ahftTokens[iToken].Type();
            if (hfttContent == tokBreak)
            {
                //  &b, iterate to next table cell.
                iToken++;
                break;
            }
        
            pchContent  = ahftTokens[iToken].Content();
            //  For &d, &D, &t, &T, make a date/time string if we haven't already.
            if (    pchContent == NULL
                &&  (   hfttContent == tokDateShort
                     || hfttContent == tokDateLong
                     || hfttContent == tokTimeShort
                     || hfttContent == tokTimeLong ) )
            {
                EnsureDateTime(hfttContent);
                pchContent = ahftTokens[iToken].Content();
            }

            Assert(hfttContent >= 0 || hfttContent == tokFlatText);

            //  Write this token's content into the cell.
            //  We can be in a state in which we are supposed to print a special token (&w, etc...),
            //  but don't have it's corresponding string value (the title, etc...).  Do pointer check.
            if (hfttContent != tokFlatText)
            {
                achHtml->QuickAppend(_T("<SPAN class=hf"));
                achHtml->QuickAppend(aachTokenNames[hfttContent]);
                achHtml->QuickAppend(_T(">"));
                if (pchContent)
                    achHtml->QuickAppend(pchContent);
                achHtml->QuickAppend(_T("</SPAN>"));
            }
            else if (pchContent)
                achHtml->QuickAppend(pchContent);
        }
        
        achHtml->QuickAppend(_T("</NOBR></TD>"));   //  /TD, Unnecessary, but instructive.
    }
    achHtml->QuickAppend(_T("</TR></TABLE>"));      //  /TR, Unnecessary, but instructive.

    Assert(iBreak == cBreaks+1);
    Assert(iToken == cTokens);

    return S_OK;
}

HRESULT
CHeaderFooter::BuildHtml(CHeadFootToken * ahftTokens, CBufferedStr *achHtml, int cBreaks, int cTokens, TCHAR *pchTableClass)
{
    HRESULT hr = S_OK;
    
    Assert(achHtml);
    Assert(cTokens >= cBreaks);
    Assert(pchTableClass);

    if (!ahftTokens)
    {
        achHtml->Set(_T(""));
        goto Cleanup;
    }


    // Case 1 (the default H/F includes this):                  ((~[&b])*)&b((~[&b])*)
    if (cBreaks == 1)
        BuildHtmlOneBreak(ahftTokens, achHtml, cBreaks, cTokens, pchTableClass);

    // Case 2 (centered text with nothing on the right/left):   &b((~[&b])*)&b
    else if (   cBreaks == 2
             && ahftTokens[0].Type() == tokBreak
             && ahftTokens[cTokens-1].Type() == tokBreak)
        BuildHtmlCentered(ahftTokens, achHtml, cBreaks, cTokens, pchTableClass);

    // Case 3 (default)
    else
        BuildHtmlDefault(ahftTokens, achHtml, cBreaks, cTokens, pchTableClass);

    _cNextId++;

Cleanup:
    return hr;
}

//---------------------------------------------------------------------------
//
//  Member:     CHeaderFooter::EnsureDateTime
//
//  Synopsis:   Takes a given date/time token type.  If no string exists for that
//              token type, it ensures the current date/time stamp, and creates
//              the appropriate string.
//
//---------------------------------------------------------------------------
HRESULT
CHeaderFooter::EnsureDateTime(HEADFOOTTOKENTYPE hfttDateTime)
{
    HRESULT hr;
    TCHAR   achDateTime[DATE_STR_LENGTH];

    //  Do we already have a date/time?  If so, we're done.
    if (_aachTokenTypes[hfttDateTime])
    {
        hr = S_OK;
        goto Cleanup;
    }

    //  Get a timestamp, if we don't have one already.
    //  NB  This is so that, when doing something slow like print preview,
    //      a repeated header/footer displays the same time. (greglett)
    if (!_fGotTimeStamp)
    {
        _fGotTimeStamp = TRUE;
        ::GetLocalTime(&_stTimeStamp);
    }

    //  Now, get the string we need to store.
    switch (hfttDateTime)
    {
    // Both date formats should be in sync, otherwise we look bad.
    case tokDateShort:
        {
            hr = ::GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &_stTimeStamp, NULL,
                                 achDateTime, DATE_STR_LENGTH);
        }
        break;
    case tokDateLong:
        {
            hr = ::GetDateFormat(LOCALE_USER_DEFAULT, DATE_LONGDATE, &_stTimeStamp, NULL,
                                 achDateTime, DATE_STR_LENGTH);
        }
        break;
    case tokTimeShort:
        {
            hr = ::GetTimeFormat(LOCALE_USER_DEFAULT, 0, &_stTimeStamp, NULL,
                                 achDateTime, DATE_STR_LENGTH);
        }
        break;
    case tokTimeLong:
        {
            hr = ::GetTimeFormat(LOCALE_USER_DEFAULT, TIME_FORCE24HOURFORMAT, &_stTimeStamp, NULL,
                                 achDateTime, DATE_STR_LENGTH);
        }
        break;
    default:
        Assert(FALSE && "Trying to date/time ensure a non date/time token.");
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Take the string we just generated and stick it in the right pigeonhole.
    if (hr)
    {
        _aachTokenTypes[hfttDateTime] = new TCHAR[_tcslen(achDateTime)+1];
        if (_aachTokenTypes[hfttDateTime])
            _tcscpy(_aachTokenTypes[hfttDateTime], achDateTime);
        hr = S_OK;
    }
    else
        hr = E_FAIL;

Cleanup:
    return hr;
}

//---------------------------------------------------------------------------
//
//  Member:     CHeaderFooter::DetoxifyString
//
//  Synopsis:   Takes the given BSTR, and allocates & generates a TCHAR string
//              that has been secured for writing onto a template.
//
//              Right now, this means NO HTML tags or escaped characters (&...)
//             
//              For a "normal" string, in which ampersand is not special:
//              Replace
//                  "<"     becomes     "&lt" 
//                  "&"     becomes     "&amp"
//              For the "Text" string, where ampersand has a special meaning:
//              Replace
//                  "<"     becomes     "&&lt"
//                  "&&"    becomes     "&&amp"
//
//              (greglett)  This essentially destroys HTML in headers/footers
//              for security.  While this is backward compatible, it isn't nearly
//              as powerful.  A better solution (one that parses out only OBJECTS, or
//              such) should be considered for the post 4/00 release.
//              See (greglett) or (cwilso) for details.
//---------------------------------------------------------------------------
HRESULT
CHeaderFooter::DetoxifyString(BSTR achIn, TCHAR **pachOut, BOOL fAmpSpecial)
{
    HRESULT hr   = S_OK;
    TCHAR * pch;
    TCHAR * pchNew;
    long    cchLen;
#if DBG == 1
    long    cchCheck = 0;   // Make sure we equal length in debug mode.
#endif

    Assert(pachOut);
    *pachOut = NULL;

    if (!achIn)
        goto Cleanup;


    //  How large a string do we need to store the detoxified string?
    // TODO (112557) : BSTRs are not NUL terminated (they may
    // contain embedded NULs).  Use SysStringLen and work with that.  Right now
    // we could AV if we pass the string "&" and fAmpSpecial is true.
    for (pch = achIn, cchLen = 0; *pch != NULL; pch++)
    {
        switch (*pch)
        {
            case _T('<'):       // "<" becomes "&lt" or "&&lt"
                cchLen += (fAmpSpecial) ? 4 : 3;
                break;

            case _T('&'):       // "&" becomes "&amp" or "&&" becomes "&&amp"
                if (fAmpSpecial)
                {
                    if (*(pch + 1) == _T('&'))
                    {
                        cchLen += 5;
                        pch++;
                    }
                    else
                    {
                        cchLen += 1;
                        break;
                    }
                }
                else
                    cchLen += 4;
                break;

            default:
                cchLen++;
                break;
        }
    }

    //  Make the string.
    (*pachOut) = new TCHAR[cchLen+1];
    if (!(*pachOut))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Now, copy over the string with replacements
    // TODO (112557) Same as above, use SysStringLen.
    for (pch = achIn, pchNew = (*pachOut); *pch != NULL; pch++)
    {
        switch (*pch)
        {
            case _T('<'):       
                if (fAmpSpecial)    // "<" becomes "&&lt"
                {
                    _tcsncpy(pchNew, _T("&&lt"), 4);
                    pchNew += 4;
#if DBG == 1
                    cchCheck += 4;
#endif
                }
                else                // "<" becomes "&lt"
                {
                    _tcsncpy(pchNew, _T("&lt"), 3);
                    pchNew += 3;
#if DBG == 1
                    cchCheck += 3;
#endif
                }
                break;

            case _T('&'):       
                if (fAmpSpecial)
                {
                    (*pchNew) = (*pch);
                    pchNew++;
#if DBG == 1
                    cchCheck++;
#endif
                    if ((*(pch + 1)) != _T('&'))
                        break;

                    pch++;
                }
                _tcsncpy(pchNew, _T("&amp"), 4);
                pchNew += 4;
#if DBG == 1
                cchCheck += 4;
#endif
                break;
                
            default:
                (*pchNew) = (*pch);
                pchNew++;
#if DBG == 1
                cchCheck++;
#endif
                break;
        }
    }
    (*pchNew) = _T('\0');

#if DBG == 1
    Assert(cchCheck == cchLen);
#endif

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\homepg.h ===
// Homepg.h : Declaration of CHomePage

#ifndef __HOMEPG_H_
#define __HOMEPG_H_

#include "resource.h"       // main symbols

#define REGSTR_SET_HOMEPAGE_RESTRICTION               TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel")
#define REGVAL_HOMEPAGE_RESTRICTION                   TEXT("HomePage")

#define MAX_HOMEPAGE_MESSAGE_LEN                      (512 + INTERNET_MAX_URL_LENGTH)
#define MAX_HOMEPAGE_TITLE_LEN                        128
            

/////////////////////////////////////////////////////////////////////////////
// CHomePage
class ATL_NO_VTABLE CHomePage : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CHomePage, &CLSID_HomePage>,
    public IDispatchImpl<IHomePage, &IID_IHomePage, &LIBID_IEXTagLib>,

    public IElementBehavior
{
public:
    CHomePage()
    {
        m_pSite = NULL;
    }
    ~CHomePage()
    {
        if (m_pSite)
            m_pSite->Release();
    }

DECLARE_REGISTRY_RESOURCEID(IDR_HOMEPAGE)
DECLARE_NOT_AGGREGATABLE(CHomePage)

BEGIN_COM_MAP(CHomePage)
    COM_INTERFACE_ENTRY(IHomePage)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IElementBehavior)
END_COM_MAP()

// IHomePage
public:
    STDMETHOD(navigateHomePage)();
    STDMETHOD(setHomePage)(/*[in]*/ BSTR bstrURL);
    STDMETHOD(isHomePage)(/*[in]*/ BSTR bstrURL, /*[out,retval]*/ VARIANT_BOOL *p);

    //IHTMLPeerElement methods
    STDMETHOD(Init)(IElementBehaviorSite *pSite);
    STDMETHOD(Notify)(LONG lNotify, VARIANT * pVarNotify);
    STDMETHOD(Detach)() { return S_OK; };

private:
    STDMETHOD(IsSameSecurityID)(IInternetSecurityManager *pISM, BSTR bstrURL, BSTR bstrDocBase);
    STDMETHOD(IsAuthorized)(BSTR bstrURL);
    STDMETHOD(GetWindow)(HWND *phWnd);
    STDMETHOD(GetHTMLWindow)(/* out */ IHTMLWindow2 **ppWindow);
    STDMETHOD(GetHTMLDocument)(/* out */IHTMLDocument2 **ppDoc);
    STDMETHOD(GetHomePage)(BSTR& bstrURL, BSTR& bstrName);
    STDMETHOD(SetUserHomePage)(LPCSTR szURL);
    IElementBehaviorSite * m_pSite;

};

#endif //__HOMEPG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\homepg.cxx ===
// homepg.cxx : Implementation of CHomePage
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"
#include "homepg.h"
#include "shlwapi.h"
#include "inetreg.h"
#include "wininet.h"
#include "urlmon.h"
#include "resource.h"
#include "shfusion.h"

/////////////////////////////////////////////////////////////////////////////
// CHomePage

STDMETHODIMP CHomePage::Init(IElementBehaviorSite *pSite)
{
    HRESULT hr = E_INVALIDARG;

    if (pSite != NULL)
    {
        m_pSite = pSite;
        m_pSite->AddRef();
        hr = S_OK;
    }

    return hr;  
}

STDMETHODIMP CHomePage::Notify(LONG lNotify, VARIANT * pVarNotify)
{
    return S_OK;
}

// Helper functions for internal use only
STDMETHODIMP CHomePage::GetWindow(HWND *phWnd)
{
    HRESULT hr = E_FAIL;
    IWindowForBindingUI *pWindowForBindingUI = NULL;

    if (m_pSite != NULL) {

        // Get IWindowForBindingUI ptr
        hr = m_pSite->QueryInterface(IID_IWindowForBindingUI,
                (LPVOID *)&pWindowForBindingUI);

        if (FAILED(hr)) {
            IServiceProvider *pServProv;
            hr = m_pSite->QueryInterface(IID_IServiceProvider, (LPVOID *)&pServProv);

            if (hr == NOERROR) {
                pServProv->QueryService(IID_IWindowForBindingUI,IID_IWindowForBindingUI,
                    (LPVOID *)&pWindowForBindingUI);
                pServProv->Release();
            }
        }

        if (pWindowForBindingUI) {
            pWindowForBindingUI->GetWindow(IID_IWindowForBindingUI, phWnd);
            pWindowForBindingUI->Release();
        }
    }

    return hr;
}

STDMETHODIMP CHomePage::GetHTMLDocument(IHTMLDocument2 **ppDoc)
{
    HRESULT hr = E_FAIL;

    if (m_pSite != NULL)
    {
        IHTMLElement *pElement = NULL;
        hr = m_pSite->GetElement(&pElement);
        if (SUCCEEDED(hr))
        {
            IDispatch * pDispDoc = NULL;
            hr = pElement->get_document(&pDispDoc);
            if (SUCCEEDED(hr))
            {
                hr = pDispDoc->QueryInterface(IID_IHTMLDocument2, (void **)ppDoc);
                pDispDoc->Release();
            }
            pElement->Release();
        }
    }

    return hr;
}


STDMETHODIMP CHomePage::GetHTMLWindow(IHTMLWindow2 **ppWindow)
{
    HRESULT hr = E_FAIL;
    IHTMLDocument2 *pDoc = NULL;

    hr = GetHTMLDocument(&pDoc);

    if (SUCCEEDED(hr))
    {
        hr = pDoc->get_parentWindow(ppWindow);
        pDoc->Release();
    }

    return hr;
}

STDMETHODIMP CHomePage::IsSameSecurityID(IInternetSecurityManager *pISM, BSTR bstrURL, BSTR bstrDocBase)
{
    HRESULT hrRet = S_FALSE;
    HRESULT hr = S_OK;
    BYTE pbSecIdURL[INTERNET_MAX_URL_LENGTH];
    BYTE pbSecIdDocBase[INTERNET_MAX_URL_LENGTH];
    DWORD dwSecIdURL = INTERNET_MAX_URL_LENGTH, dwSecIdDocBase = INTERNET_MAX_URL_LENGTH;

    hr = pISM->GetSecurityId(bstrDocBase, pbSecIdDocBase, &dwSecIdDocBase, 0);

    _ASSERTE(hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

    if (SUCCEEDED(hr)) {

        hr = pISM->GetSecurityId(bstrURL, pbSecIdURL, &dwSecIdURL, 0);
        _ASSERTE(hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

        if (SUCCEEDED(hr)) {

            if ((dwSecIdURL == dwSecIdDocBase) &&
                (memcmp(pbSecIdURL, pbSecIdDocBase, dwSecIdURL) == 0)) {

                hrRet = S_OK;
            }
        }
    }

    return hrRet;
}

STDMETHODIMP CHomePage::IsAuthorized(BSTR bstrURL)
{
    HRESULT hr = E_FAIL;
    IHTMLDocument2 *pDoc = NULL;
    BSTR bstrDocBase = NULL;
    IInternetSecurityManager *pISM = NULL;

    hr = GetHTMLDocument(&pDoc);

    if (SUCCEEDED(hr))
    {
        hr = pDoc->get_URL(&bstrDocBase);

        if (SUCCEEDED(hr)) {
            if (SUCCEEDED(hr = CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER,
                IID_IInternetSecurityManager, (void **)&pISM))) {


                hr = IsSameSecurityID(pISM, bstrURL, bstrDocBase);
                pISM->Release();
            }

            SysFreeString(bstrDocBase);
        }

        pDoc->Release();
    }

    return SUCCEEDED(hr)?hr:S_FALSE;
}


STDMETHODIMP CHomePage::SetUserHomePage(LPCSTR szURL)
{
    HRESULT hr = S_OK;
    LONG    lResult = ERROR_SUCCESS;
    HKEY    hKey    = NULL;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_MAIN, 0, KEY_SET_VALUE, &hKey) == ERROR_SUCCESS)
    {
        if (((lResult = RegSetValueExA (hKey, REGSTRA_VAL_STARTPAGE, 0, REG_SZ,
                (LPCBYTE)szURL, lstrlenA(szURL)+1))) != ERROR_SUCCESS) {

            hr = HRESULT_FROM_WIN32(lResult);
        }
    }

    if (hKey)
        RegCloseKey(hKey);

    return FAILED(hr)?S_FALSE:hr;
}

STDMETHODIMP CHomePage::GetHomePage(BSTR& bstrURL, BSTR& bstrName)
{
    LPWSTR pwszName = L"_top";
    HRESULT hr = E_FAIL;
    WCHAR wszHomePage[INTERNET_MAX_URL_LENGTH];
    DWORD dwType;
    DWORD dwSize = INTERNET_MAX_URL_LENGTH;

    if (SHRegGetUSValueW(REGSTR_PATH_MAIN, 
                        REGSTR_VAL_STARTPAGE, 
                        &dwType, 
                        wszHomePage, 
                        &dwSize, 
                        0, NULL, 0) == ERROR_SUCCESS) 
    {
        bstrURL = SysAllocString(wszHomePage);
    }

    bstrName = SysAllocString(pwszName);

    return (bstrName && bstrURL) ? S_OK : E_FAIL;
}

STDMETHODIMP CHomePage::setHomePage(BSTR bstrURL)
{
    HRESULT hr = S_FALSE;
    char szMsgTitle[MAX_PATH];
    char szMsgFormat[INTERNET_MAX_URL_LENGTH];
    char szURL[INTERNET_MAX_URL_LENGTH];
    char szPageTitle[INTERNET_MAX_URL_LENGTH];
    char szMsg[2*INTERNET_MAX_URL_LENGTH];
    HWND hWnd = NULL;
    DWORD dwValue = 0;
    DWORD dwLen = sizeof(DWORD);
    WCHAR wzEscaped[INTERNET_MAX_URL_LENGTH];
    DWORD dwCount;
    HKEY hkeyRest = 0;

    // Check if setting home page is restricted

    if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_SET_HOMEPAGE_RESTRICTION, 0,
                     KEY_READ, &hkeyRest) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hkeyRest, REGVAL_HOMEPAGE_RESTRICTION, NULL, NULL,
                            (LPBYTE)&dwValue, &dwLen) == ERROR_SUCCESS
            && dwValue)
        {
            hr = E_ACCESSDENIED;
        }

        RegCloseKey(hkeyRest);

        if (FAILED(hr))
        {
            goto Exit;
        }
    }

    if(FAILED(CoInternetParseUrl(bstrURL, PARSE_CANONICALIZE  , NULL, wzEscaped, ARRAY_SIZE(wzEscaped), &dwCount, 0)))
        goto Exit;
        
    if ( bstrURL && WideCharToMultiByte(CP_ACP, 0, wzEscaped, -1, szURL,
            sizeof(szURL), NULL, NULL) &&
         LoadStringA(g_hInst, IDS_SETHOMEPAGE_TITLE, szMsgTitle, sizeof(szMsgTitle)) &&
         LoadStringA(g_hInst, IDS_SETHOMEPAGE_MSG, szMsgFormat, sizeof(szMsgFormat))) {

         if (wnsprintfA(szMsg, sizeof(szMsg), szMsgFormat, szURL) && GetWindow(&hWnd) == S_OK) {
            MSGBOXPARAMS      mbp;
            WCHAR             wzMsg[MAX_HOMEPAGE_MESSAGE_LEN];
            WCHAR             wzTitle[MAX_HOMEPAGE_TITLE_LEN];

            if (!MultiByteToWideChar(CP_ACP, 0, szMsg, -1, wzMsg,
                                     MAX_HOMEPAGE_MESSAGE_LEN))
            {
                goto Exit;
            }

            if (!MultiByteToWideChar(CP_ACP, 0, szMsgTitle, -1, wzTitle,
                                     MAX_HOMEPAGE_TITLE_LEN))
            {
                goto Exit;
            }
                                                    
            mbp.cbSize = sizeof (MSGBOXPARAMS);
            mbp.hwndOwner = hWnd;
            mbp.hInstance = g_hInst;
            mbp.dwStyle = MB_YESNO | MB_USERICON;
            mbp.lpszCaption = wzTitle;
            mbp.lpszIcon = MAKEINTRESOURCE(IDI_HOMEPAGE);
            mbp.dwContextHelpId = 0;
            mbp.lpfnMsgBoxCallback = NULL;
            mbp.dwLanguageId = MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT);
            mbp.lpszText = wzMsg;

            ULONG_PTR uCookie = 0;
            SHActivateContext(&uCookie);

            if (MessageBoxIndirect(&mbp) == IDYES) {

                // got approval, now stomp the reg key
                hr = SetUserHomePage(szURL);
            }

            if (uCookie)
            {
                SHDeactivateContext(uCookie);
            }
         }
    }

Exit:

    return hr;
}

STDMETHODIMP CHomePage::isHomePage(BSTR bstrURL, VARIANT_BOOL *pVal)
{
    HRESULT hr = S_OK;
    BSTR bstrHome = NULL;
    BSTR bstrName = NULL;

    if (pVal == NULL)
    {
        return E_POINTER;
    }


    hr = GetHomePage(bstrHome, bstrName);
    if (SUCCEEDED(hr)) {

        if (StrCmpIW(bstrHome, bstrURL) == 0) {

            // matches and is the home page
            // now verify that the doc base URL is indeed
            // in the same domain (same security ID and is 
            // therefore authorized to inspect the home page

            hr = IsAuthorized(bstrHome);

        } else {
            hr = S_FALSE;
        }
    }

    if (bstrName)
        SysFreeString(bstrName);

    if (bstrHome)
        SysFreeString(bstrHome);

    hr =  SUCCEEDED(hr)?hr:S_FALSE;

    if (hr == S_FALSE)
        *pVal = FALSE;
    else
        *pVal = TRUE;

    return hr;
}

STDMETHODIMP CHomePage::navigateHomePage()
{
    IHTMLWindow2 *pWindow = NULL;
    IHTMLWindow2 *pWindowNew = NULL;
    HRESULT hr = S_OK;
    BSTR bstrURL = NULL;
    BSTR bstrName = NULL;

    hr = GetHTMLWindow(&pWindow);

    if (SUCCEEDED(hr)) {

        hr = GetHomePage(bstrURL, bstrName);
        if (SUCCEEDED(hr)) {

            hr = pWindow->open(bstrURL, bstrName, NULL, NULL, &pWindowNew);
        }
    }

    if (FAILED(hr))
        hr = S_FALSE;       // script friendly

    if (pWindow)
        pWindow->Release();

    if (pWindowNew)
        pWindowNew->Release();

    if (bstrName)
        SysFreeString(bstrName);

    if (bstrURL)
        SysFreeString(bstrURL);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\makefile.inc ===
#MIDL= $(DEVTOOLS)\midl.exe

$O\iextag.h $O\iextag.tlb iextag.cxx : $(SDK_INC_PATH)\iextag.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\htmlarea.cxx ===
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"

#include "dispex.h"

#ifndef __X_HTMLAREA_HXX_
#define __X_HTMLAREA_HXX_
#include "htmlarea.hxx"
#endif

const CBaseCtl::PROPDESC CHtmlArea::s_propdesc[] = 
{
    {_T("value"), VT_BSTR},
    NULL
};

enum
{
    VALUE = 0
};

/////////////////////////////////////////////////////////////////////////////
//
// CHtmlArea
//
/////////////////////////////////////////////////////////////////////////////

CHtmlArea::CHtmlArea()
{
}

CHtmlArea::~CHtmlArea()
{
    SysFreeString(_bstrDefaultValue);
}

HRESULT
CHtmlArea::Init()
{
    HRESULT         hr = S_OK;
    CContextAccess  a(_pSite);

    hr = a.Open(CA_ELEM | CA_ELEM2 | CA_ELEM3 | CA_SITEOM | CA_DEFAULTS | CA_DEFSTYLE | CA_DEFSTYLE2 | CA_STYLE);
    if (hr)
        goto Cleanup;

    // By hooking into the onpropertychange event, we can set the _fValueChanged flag.
    hr = AttachEvent(EVENT_ONPROPERTYCHANGE, &a);
    if (hr)
        goto Cleanup;

    // By hooking into the onblur event, we can check the _fValueChanged flag
    // and fire the onchange event.
    hr = AttachEvent(EVENT_ONBLUR, &a);
    if (hr)
        goto Cleanup;

    // By hooking into the onfocus event, we can track whether we have the focus.
    hr = AttachEvent(EVENT_ONFOCUS, &a);
    if (hr)
        goto Cleanup;

    hr = RegisterEvent(a.SiteOM(), L"onchange", &_lOnChangeCookie);
    if (hr)
        goto Cleanup;

    hr = a.Defaults()->put_tabStop(VB_TRUE);
    if (hr)
        goto Cleanup;

    hr = a.Elem3()->put_contentEditable(L"true");
    if (hr)
        goto Cleanup;

    //
    //  Set the default style
    //

    hr = SetDefaultStyle(&a);
    if (hr)
        goto Cleanup;

    // set properties on IHTMLElement
    // pElement->setAttribute(_T("editable"), VB_TRUE);

    // force a layout
    hr =  a.Style()->put_display(_T("inline-block"));

Cleanup:

    return hr;
}

HRESULT
CHtmlArea::SetDefaultStyle(CContextAccess * pa)
{
    HRESULT       hr             = S_OK;
    CVariant      cvarTemp(VT_BSTR);

    hr = pa->DefStyle()->put_fontFamily(L"courier new");
    if (hr)
        goto Cleanup;

    V_BSTR(&cvarTemp) = SysAllocString(L"9.5pt");
    hr = pa->DefStyle()->put_fontSize(cvarTemp);
    if (hr)
        goto Cleanup;

    cvarTemp.Clear();
    V_VT(&cvarTemp) = VT_BSTR;
    // (krisma 6/12/99) Why is the width 14.4? This is what makes 
    // it the same width as a textarea.
    V_BSTR(&cvarTemp) = SysAllocString(L"14.4em");
    hr = pa->DefStyle()->put_width(cvarTemp);
    if (hr)
        goto Cleanup;

    cvarTemp.Clear();
    V_VT(&cvarTemp) = VT_BSTR;
    // (krisma 6/12/99) Why is the height 3? This is what makes 
    // it the same height as a textarea.
    V_BSTR(&cvarTemp) = SysAllocString(L"3em");
    hr = pa->DefStyle()->put_height(cvarTemp);
    if (hr)
        goto Cleanup;

    hr = pa->DefStyle()->put_borderStyle(L"inset");
    if (hr)
        goto Cleanup;
    hr = pa->DefStyle()->put_borderWidth(L"thin");
    if (hr)
        goto Cleanup;

    cvarTemp.Clear();
    V_VT(&cvarTemp) = VT_BSTR;
    V_BSTR(&cvarTemp) = SysAllocString(L"1px");
    hr = pa->DefStyle()->put_paddingLeft(cvarTemp);
    if (hr)
        goto Cleanup;

    hr = pa->DefStyle2()->put_overflowY(L"scroll");
    if (hr)
        goto Cleanup;

Cleanup:
    return hr;
}

HRESULT
CHtmlArea::OnContentReady()
{
    HRESULT        hr = S_OK;
    IHTMLElement * pElem = NULL;
    BSTR           bstrInnerHTML = NULL;

    // Get the default value
    hr = _pSite->GetElement(&pElem);
    if (hr)
        goto Cleanup;
    hr = pElem->get_innerHTML(&bstrInnerHTML);
    if (hr)
        goto Cleanup;
    _bstrDefaultValue = SysAllocString(bstrInnerHTML);
    if (!_bstrDefaultValue)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pElem);
    if (bstrInnerHTML)
    {
        SysFreeString(bstrInnerHTML);
        bstrInnerHTML = NULL;
    }
    return hr;
}

HRESULT
CHtmlArea::OnPropertyChange(CEventObjectAccess *pEvent, BSTR bstrProperty)
{
    if (! StrCmpICW (bstrProperty, L"innerHTML"))
    {
        GetProps()[VALUE].Dirty();
        if (GetHaveFocus())
            SetValueChangedWhileWeHadFocus(TRUE);
    }
    return S_OK;
}

HRESULT
CHtmlArea::OnBlur(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    SetHaveFocus(FALSE);
    if (GetValueChangedWhileWeHadFocus())
    {
        Assert(GetProps()[VALUE].IsDirty());
        SetValueChangedWhileWeHadFocus(FALSE);
        hr = FireEvent(_lOnChangeCookie);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    return hr;
}

HRESULT
CHtmlArea::select()
{
    return S_OK;
}

HRESULT
CHtmlArea::put_value(BSTR v)
{
    HRESULT         hr      = S_OK;
    IHTMLElement *  pElem   = NULL;

    if (!v)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = _pSite->GetElement(&pElem);
    if (hr)
        goto Cleanup;
    hr = pElem->put_innerHTML(v);
    if (hr)
        goto Cleanup;

    hr = GetProps()[VALUE].Set(v);
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pElem);
    return hr;
}

HRESULT
CHtmlArea::get_value(BSTR * pv)
{
    HRESULT         hr      = S_OK;
    IHTMLElement *  pElem   = NULL;

    if (!pv)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pv = NULL;

    hr = _pSite->GetElement(&pElem);
    if (hr)
        goto Cleanup;
    hr = pElem->get_innerHTML(pv);
    if (hr)
        goto Cleanup;
    
Cleanup:
    ReleaseInterface(pElem);
    return hr;
}

// IElementBehaviorSubmit methods
HRESULT
CHtmlArea::Reset()
{
    HRESULT         hr      = S_OK;

    if (GetProps()[VALUE].IsDirty())
    {
        hr = put_value(_bstrDefaultValue);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    return hr;
}

HRESULT
CHtmlArea::GetSubmitInfo(IHTMLSubmitData * pSubmitData)
{
    HRESULT         hr          = S_OK;
    IHTMLElement *  pElem       = NULL; //(krisma) Do we want to (can we?) cache the element?
    BSTR            bstrValue   = NULL;
    CVariant        cvarName;

    // See if we have a name
    hr = _pSite->GetElement(&pElem);
    if (hr)
        goto Cleanup;
    hr = pElem->getAttribute(_T("name"), 0, &cvarName);
    if (hr)
        goto Cleanup;

    if (V_VT(&cvarName) != VT_BSTR)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    //Get our innerHTML
    hr, get_value(&bstrValue);
    if (hr)
        goto Cleanup;

    //append our data
    hr = pSubmitData->appendNameValuePair(V_BSTR(&cvarName), bstrValue);
    if (hr)
        goto Cleanup;

Cleanup:
    if (bstrValue)
    {
        SysFreeString(bstrValue);
        bstrValue = NULL;
    }
    ReleaseInterface(pElem);

    if (hr)
        hr = S_FALSE;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\iextag.cxx ===
// iextag.cpp : Implementation file for code common to all xtags..


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f ccapsps.mk in the project directory.
#include <w95wraps.h>
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "resource.h"
#include "initguid.h"
#include "iextag.h"

#include "peerfact.h"
#include "ccaps.h"
#include "homepg.h"
#include "download.h"

#ifndef __X_HTMLAREA_HXX_
#define __X_HTMLAREA_HXX_
#include "htmlarea.hxx"
#endif

#ifndef __X_SELECT_HXX_
#define __X_SELECT_HXX_
#include "select.hxx"
#endif

#ifndef __X_SELITEM_HXX_
#define __X_SELITEM_HXX_
#include "selitem.hxx"
#endif

#ifndef __X_COMBOBOX_HXX_
#define __X_COMBOBOX_HXX_
#include "combobox.hxx"
#endif

#ifndef __X_CHECKBOX_HXX_
#define __X_CHECKBOX_HXX_
#include "checkbox.hxx"
#endif

#ifndef __X_RADIO_HXX_
#define __X_RADIO_HXX_
#include "radio.hxx"
#endif

#ifndef __X_USERDATA_HXX_
#define __X_USERDATA_HXX_
#include "userdata.hxx"
#endif

#ifndef __X_RECTPEER_HXX_
#define __X_RECTPEER_HXX_
#include "rectpeer.hxx"
#endif

#ifndef __X_DEVICERECT_HXX_
#define __X_DEVICERECT_HXX_
#include "devicerect.hxx"
#endif

#ifndef __X_TMPPRINT_HXX_
#define __X_TMPPRINT_HXX_
#include "tmpprint.hxx"
#endif

#ifndef __X_HEADFOOT_HXX_
#define __X_HEADFOOT_HXX_
#include "headfoot.hxx"
#endif

#ifndef __X_SCROLLBAR_HXX_
#define __X_SCROLLBAR_HXX_
#include "scrllbar.hxx"
#endif

#ifndef __X_SPINBTTN_HXX_
#define __X_SPINBTTN_HXX_
#include "spinbttn.hxx"
#endif

#ifndef __X_SLIDEBAR_HXX_
#define __X_SLIDEBAR_HXX_
#include "slidebar.hxx"
#endif

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>


#if 1
// this is according to IE5 bug 65301. (richards, alexz).
#if _MSC_VER < 1200
#pragma comment(linker, "/merge:.CRT=.data")
#endif
#endif


#include "shfusion.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_PeerFactory,         CPeerFactory)
    OBJECT_ENTRY(CLSID_ClientCaps,          CClientCaps)
    OBJECT_ENTRY(CLSID_HomePage,            CHomePage)
    OBJECT_ENTRY(CLSID_CDownloadBehavior,   CDownloadBehavior)
    OBJECT_ENTRY(CLSID_CCombobox,           CCombobox)
    OBJECT_ENTRY(CLSID_CIESelectElement,    CIESelectElement)
    OBJECT_ENTRY(CLSID_CIEOptionElement,    CIEOptionElement)
    OBJECT_ENTRY(CLSID_CHtmlArea,           CHtmlArea)
    OBJECT_ENTRY(CLSID_CCheckBox,           CCheckBox)
    OBJECT_ENTRY(CLSID_CRadioButton,        CRadioButton)
    OBJECT_ENTRY(CLSID_CLayoutRect,         CLayoutRect)
    OBJECT_ENTRY(CLSID_CDeviceRect,         CDeviceRect)
    OBJECT_ENTRY(CLSID_CTemplatePrinter,    CTemplatePrinter)
    OBJECT_ENTRY(CLSID_CHeaderFooter,       CHeaderFooter)
    OBJECT_ENTRY(CLSID_CScrollBar,          CScrollBar)
    OBJECT_ENTRY(CLSID_CSpinButton,         CSpinButton)
    OBJECT_ENTRY(CLSID_CSliderBar,          CSliderBar)
END_OBJECT_MAP()

HINSTANCE   g_hInst             = NULL;
BOOL        g_fUnicodePlatform;
DWORD       g_dwPlatformVersion;            // (dwMajorVersion << 16) + (dwMinorVersion)
DWORD       g_dwPlatformID;                 // VER_PLATFORM_WIN32S/WIN32_WINDOWS/WIN32_WINNT
DWORD       g_dwPlatformBuild;              // Build number
BOOL        g_fUseShell32InsteadOfSHFolder;

// ISSUE: (alexz) find out why ATL leaks during registration and then remove usage of g_fDisableMemLeakReport
#if DBG == 1
BOOL g_fDisableMemLeakReport = FALSE;
#endif

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HANDLE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        {
            SHFusionInitializeFromModule((HMODULE)hInstance);
            OSVERSIONINFOA vi;

#ifdef UNIX // Unix setup program doesn't invoke COM. Needs to do it here.
            CoInitialize(NULL);
#endif // Unix

            vi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
            GetVersionExA(&vi);

            g_dwPlatformVersion     = (vi.dwMajorVersion << 16) + vi.dwMinorVersion;
            g_dwPlatformID          = vi.dwPlatformId;
            g_dwPlatformBuild       = vi.dwBuildNumber;

            g_fUnicodePlatform = (  g_dwPlatformID == VER_PLATFORM_WIN32_NT );
                                 // || vi.dwPlatformId == VER_PLATFORM_WIN32_UNIX);

            // NOTE:    On Millennium or W2k we should use Shell32 for
            //          SHGetFolderPath instead of SHFolder.
            g_fUseShell32InsteadOfSHFolder = (VER_PLATFORM_WIN32_WINDOWS == g_dwPlatformID 
                                                && (g_dwPlatformVersion >= 0x0004005a))
                                             || (VER_PLATFORM_WIN32_NT == g_dwPlatformID 
                                                && g_dwPlatformVersion >= 0x00050000);

            g_hInst = (HINSTANCE)hInstance;

            _Module.Init(ObjectMap, (HINSTANCE)hInstance);
            DisableThreadLibraryCalls((HINSTANCE)hInstance);

            CPersistUserData::GlobalInit();
#ifdef UNIX
            CoUninitialize();
#endif // Unix
        }
        break;

    case DLL_PROCESS_DETACH:
        CPersistUserData::GlobalUninit();

        _Module.Term();

#if DBG == 1
#ifndef UNIX // UNIX doesn't have _CrtDumpMemoryLeaks yet.
        if (!g_fDisableMemLeakReport && _CrtDumpMemoryLeaks())
        {
            if (IDYES == MessageBoxA (
                NULL,
                "MEMORY LEAKS DETECTED\r\n\r\n"
                "Break for instructions how to track the leaks?",
                "IEPEERS.DLL",
                MB_YESNO | MB_SETFOREGROUND))
            {
                DebugBreak();

                //
                // How to track the leaks:
                //
                // Step 1. Look for trace of memory leaks in debug output window, e.g.:
                //
                //      Dumping objects ->
                //      ...
                //      {42} normal block at 0x01A00CC0, 226 bytes long.
                //      Data: <m o n k e y   w > 6D 00 6F 00 6E 00 6B 00 65 00 79 00 20 00 77 00 
                //      ...
                //
                // interesting info: block with serial number 42 leaked
                //
                //  Step 2. Set breakpoint inside debug allocator on block number 42 using one of the 
                //  following methods:
                //      - set break point in DLL_PROCESS_ATTACH case above, go to QuickWatch window,
                //        and evaluate expression "_CrtSetBreakAlloc(42)"; or
                //      - set break point in DLL_PROCESS_ATTACH case above, and set variable _crtBreakAlloc
                //        global debug variable to 42; or
                //      - place a call "_CrtSetBreakAlloc(42)" in DLL_PROCESS_ATTACH case above,
                //        recompile and run.
            }
        }
#endif // UNIX
#endif
        SHFusionUninitialize();
        break;
    }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#if DBG == 1
    g_fDisableMemLeakReport = TRUE;
#endif

    // registers object, typelib and all interfaces in typelib
    HRESULT hr = _Module.RegisterServer(TRUE);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#if DBG == 1
    g_fDisableMemLeakReport = TRUE;
#endif

    _Module.UnregisterServer();

    return S_OK;
}

STDAPI DllEnumClassObjects(int i, CLSID *pclsid, IUnknown **ppUnk)
{
    if (i >= (sizeof(ObjectMap)/sizeof(ObjectMap[0])) - 1)
    {
        return S_FALSE;
    }

    *pclsid = *(ObjectMap[i].pclsid);
    return _Module.GetClassObject(*pclsid, IID_IUnknown, (LPVOID*)ppUnk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\httpwfh.h ===
//=================================================
//
//  File : httpwfh.h
//
//  purpose : definition of the Cwfolders class
//
//=================================================
// Chad Lindhorst, 1998

#ifndef __HTTPWFH_H_
#define __HTTPWFH_H_

#include <mshtmhst.h>

#include "iextag.h"         // for IID_Iwfolders... etc.
#include "resource.h"       // main symbols
#include "oledb.h"

// This is used to fix the max size for strings loaded from the
// string table.
#define MAX_LOADSTRING MAX_PATH

// This is the longest URL we should send to office.  (anything longer
// will get an error dialog.)  (Should be MAX_PATH - talk to office...)
#define MAX_WEB_FOLDER_LENGTH            100

// This is the guid we use for active setup....
static const GUID CLSID_IOD = 
{ 0x73fa19d0, 0x2d75, 0x11d2, { 0x99, 0x5d, 0x00, 0xc0, 0x4f, 0x98, 0xbb, 0xc9 } };

// Just to look nice.
#define BAILOUT(HR)             {hr=HR; goto cleanup;}
#define FAILONBAD_HR(HR)        {if (FAILED(HR)) BAILOUT(HR);}

// These typedefs and statics are for the target frame creation code taken
// out of shdocvw.  
typedef enum _TARGET_TYPE {
TARGET_FRAMENAME,
TARGET_SELF,
TARGET_PARENT,
TARGET_BLANK,
TARGET_TOP,
TARGET_MAIN,
TARGET_SEARCH
} TARGET_TYPE;

typedef struct _TARGETENTRY {
    TARGET_TYPE targetType;
    const WCHAR *pTargetValue;
} TARGETENTRY;

static const TARGETENTRY targetTable[] =
{
    {TARGET_SELF, L"_self"},
    {TARGET_PARENT, L"_parent"},
    {TARGET_BLANK, L"_blank"},
    {TARGET_TOP, L"_top"},
    {TARGET_MAIN, L"_main"},
    {TARGET_SEARCH, L"_search"},
    {TARGET_SELF, NULL}
};

// Custom Window Messages
#define WM_WEBFOLDER_NAV                   WM_USER + 2000
#define WM_WEBFOLDER_CANCEL                WM_WEBFOLDER_NAV + 1
#define WM_WEBFOLDER_DONE                  WM_WEBFOLDER_NAV + 2
#define WM_WEBFOLDER_INIT                  WM_WEBFOLDER_NAV + 3

// Used to keep the state of the message window.  They are void * to cram into
// the window properties.
#define STATUS_READY        (void *) 1
#define STATUS_CANCELED     (void *) 2

// Window Property Names
#define __INFO              L"__WFOLDER_INFO"
#define __CANCEL            L"__WFOLDER_CANCEL"

// Name of the class of windows that handles all the messages from ParseDisplayName
#define WFOLDERSWNDCLASS  L"WebFolderSilentMessageHandlerWindowClass"

// These values help the various parts of this program know what is going on.
// They are to be used in ONE DIRECTION ONLY because they are often carried
// to different threads, and the variable they are used with is NOT 
// synchronized.
#define READY_WORKING            0
#define READY_INITIALIZED        1
#define READY_CANCEL             10
#define READY_DONE               11

// These are my different UI codes.  You pass one (or all) of these to NavigateInternal
// to change what UI gets seen.
#define USE_NO_UI                0
#define USE_ERROR_BOXES          1
#define USE_FAILED_QUESTION      2
#define USE_WEB_PAGE_UI          4

#define USE_ALL_UI               USE_ERROR_BOXES | USE_FAILED_QUESTION | USE_WEB_PAGE_UI

//+------------------------------------------------------------------------
//
//  Class:      Cwfolders
//
//  Synopsis:   Implements a behavior which allows the browser to
//              navigate to a folder view of a given URL.  The most
//              important method here is Navigate.
//
//-------------------------------------------------------------------------

class ATL_NO_VTABLE Cwfolders : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<Cwfolders,&CLSID_wfolders>,
    public IDispatchImpl<Iwfolders, &IID_Iwfolders, &LIBID_IEXTagLib>,
    public IObjectSafetyImpl<Cwfolders>,
    public IElementBehavior
{
// METHODS
// -------

public:
    Cwfolders();

    ~Cwfolders();

DECLARE_REGISTRY_RESOURCEID(IDR_WFOLDERS)

BEGIN_COM_MAP(Cwfolders) 
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(Iwfolders)
    COM_INTERFACE_ENTRY(IElementBehavior)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
END_COM_MAP()

    // Iwfolders
    STDMETHOD(navigate)(BSTR bstrUrl, BSTR * pbstrRetVal);
    STDMETHOD(navigateFrame)(BSTR bstrUrl, BSTR bstrTargetFrame, /*BSTR bstrProtocol,*/ BSTR * pbstrRetVal);
    STDMETHOD(navigateNoSite)(BSTR bstrUrl, BSTR bstrTargetFrame, /*BSTR bstrProtocol,*/
                              DWORD dwhwnd, IUnknown* punk);

    // IObjectSafety
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid,
              DWORD dwSupportedOptions, DWORD dwEnabledOptions);

    // IElementBehavior
    HRESULT STDMETHODCALLTYPE Init (IElementBehaviorSite __RPC_FAR *pBehaviorSite);
    HRESULT STDMETHODCALLTYPE Notify (LONG lEvent, VARIANT __RPC_FAR *pVar);
    STDMETHOD(Detach)() { return S_OK; };


private:
    // The function that actually does all the navigation.
    // all other (including exported) functions call this one.
    STDMETHOD(navigateInternal)(BSTR bstrUrl, BSTR bstrTargetFrame, /*BSTR bstrProtocol,*/ int iUI, IUnknown* punk);

    // show UI for four different kinds of errors.
    void ShowNavigationFailedQuestion (BSTR bstrUrl, BSTR bstrTargetFrame);
    void ShowError (HWND hWnd, unsigned int IDSmessage, unsigned int IDStitle, BSTR bstrUrl);
    void ShowNavigationFailed (HWND hWnd, BSTR bstrUrl, BSTR bstrTargetFrame,
                               WCHAR * wszResource);

// STATIC METHODS
// --------------

public:
    // message handler for my window (the "connecting..." dialog)
    static INT_PTR CALLBACK WaitDlgProc (HWND hDlg, UINT message, 
                               WPARAM wParam, LPARAM lParam);
    // message handler for a silent, invisible message window that
    // stays around to listen for ParseDisplayName to finish
    static INT_PTR CALLBACK NavMessageProc (HWND hDlg, UINT message, WPARAM wParam, 
                                  LPARAM lParam);

private:
    // These two (unexported) functions were taken from the shdocvw code.
    static TARGET_TYPE ParseTargetType(LPCOLESTR pszTarget);
    static HRESULT CreateTargetFrame(LPCOLESTR pszTargetName, LPUNKNOWN *ppunk);

    // Some helper functions for pidl stuffing
    static HRESULT InitVARIANTFromPidl(LPVARIANT pvar, LPITEMIDLIST pidl);
    static LPSAFEARRAY MakeSafeArrayFromData(LPBYTE pData, DWORD cbData);
    static UINT ILGetSize(LPITEMIDLIST pidl);

    // My thread proc
    static DWORD WINAPI RunParseDisplayName (LPVOID pArguments);

    // General helper functions (destined for utils.cxx?)
    static HRESULT NavToPidl (LPITEMIDLIST pidl, BSTR bstrTargetFrame, 
        IWebBrowser2 * pwb);

    // Some code mostly supplied by Chris Guzak that gets a pidl from 
    // an url.
    static HRESULT CreateWebFolderIDList(BSTR bstrUrl, LPITEMIDLIST *ppidl, HWND hwnd, IUnknown *punk);
    static void SetScriptErrorMessage (HRESULT hr, BSTR * pbstr);

// DATA MEMBERS
// ------------

public:
    IWebBrowser2 * m_pwb;
    HWND m_hwndOwner;
    IElementBehaviorSite *m_pSite;
};

// Using this to pass arguments to my child thread.
class CThreadArgs
{
public:
    CThreadArgs()
    {
        m_bstrUrl = NULL;
    }
    ~CThreadArgs()
    {
        SysFreeString (m_bstrUrl);
    }

    // holds the URL ask office for a pidl with
    BSTR m_bstrUrl;
    // holds the hwnd of the message window, once
    // it is created and initialized.  (0 otherwise)
    HWND m_hwndMessage;
    // holds the hwnd of the dialog window, once
    // it is created and initialized.  (0 otherwise)
    HWND m_hwndDialog;
    // holds the HRESULT returned by office
    HRESULT m_hrReady;
    // holds the pidl returned by office 
    // (this actually only carries the pidl between the
    // message window and the navigateInternal call...
    // the pidl gets from the PDN thread to the message
    // window through the WM_WEBFOLDER_NAV message)
    LPITEMIDLIST m_pidl;
    // Holds the status of the message window
    int m_imsgStatus;
    // Holds the status of the PDN thread
    int m_ipdnStatus;
};

#endif //__HTTPWFH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\httpwf.cxx ===
//=========================================================================
//
//  File : httpwf.cxx
//
//  purpose : implementation of the Cwfolders class
//
//=========================================================================
// Chad Lindhorst, 1998

#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "httpwfh.h"
#include "utils.hxx"
#include "iextag.h"
#include "htiface.h"  // for ITargetFrame
#include "msdaipper.h"  // only needed for IPP_E_SERVERTYPE_NOT_SUPPORTED
// This #define was from oledberr.h, but only shows up with some versions
// of OLEDB.  (OLEDBVER = 0x210)  Hopefully this is less destructive than
// setting OLEDBVER.
#define DB_E_TIMEOUT                     ((HRESULT)0x80040E97L)
#define DB_E_CANNOTCONNECT               ((HRESULT)0x80040E96L)
#include "oledberr.h"

#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))

// ========================================================================
// Cwfolders
// ========================================================================

//+------------------------------------------------------------------------
//
//  Members:    Cwfolders::Cwfolders
//              Cwfolders::~Cwfolders
//
//  Synopsis:   Constructor/destructor
//
//-------------------------------------------------------------------------

Cwfolders::Cwfolders() 
{
    m_pSite = NULL;
    m_pwb = NULL;
}

Cwfolders::~Cwfolders() 
{
    ReleaseInterface (m_pwb);
    ReleaseInterface (m_pSite);
}

// ========================================================================
// Iwfolders
// ========================================================================

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::navigate
//
//  Synopsis:   Navigates the browser to a folder view of the URL passed 
//              in.  The function requires that m_hwndOwner and m_pwb are
//              both inited. (done in Cwfolders::Init)
//
//-------------------------------------------------------------------------

STDMETHODIMP
Cwfolders::navigate(BSTR bstrUrl, BSTR * pbstrRetVal)
{
    IUnknown* punk;

    if(!m_pwb)
    {
        return E_FAIL;
    }

    HRESULT hr = m_pwb->QueryInterface(IID_IUnknown, (void **) &punk);
    if (FAILED (hr))
    {
        return hr;
    }
    hr = navigateInternal(bstrUrl, NULL, /*NULL,*/ USE_NO_UI, punk);
    punk->Release();
    SetScriptErrorMessage (hr, pbstrRetVal);
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::navigateFrame
//
//  Synopsis:   Navigates the browser to a folder view of the URL passed 
//              in.  This version also allows for the folder view to be
//              pointed to a specific frame, as indicated by bstrTargetFrame.
//              The Protocol parameter can be either "WEC","DAV", or "any"
//              the latter meaning that the protocol doesn't matter.
//              Protocol selection is currently an ISSUE.  This requires
//              the m_hwndOwner and m_pwb members to be inited.
//
//-------------------------------------------------------------------------

STDMETHODIMP 
Cwfolders::navigateFrame(BSTR bstrUrl, BSTR bstrTargetFrame, /*BSTR bstrProtocol,*/
                         BSTR * pbstrRetVal) 
{
    IUnknown* punk;

    if(!m_pwb)
    {
        return E_FAIL;
    }

    HRESULT hr = m_pwb->QueryInterface(IID_IUnknown, (void **) &punk);
    if (FAILED (hr))
    {
        return hr;
    }

    hr = navigateInternal(bstrUrl, bstrTargetFrame, /*bstrProtocol,*/ USE_NO_UI, punk);
    punk->Release();
    SetScriptErrorMessage (hr, pbstrRetVal);
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::navigateNoSite
//
//  Synopsis:   This does a folder navigation but doesn't require the behavior
//              to be started in the normal way.  (you can just call this
//              with the punk.  That punk should be to an object with an
//              IWebBrowser2 interface.)  
//
//-------------------------------------------------------------------------

STDMETHODIMP
Cwfolders::navigateNoSite (BSTR bstrUrl, BSTR bstrTargetFrame, /*BSTR bstrProtocol,*/
               DWORD dwhwnd, IUnknown* punk)
{
    HRESULT hr = E_FAIL;

    if ((!(m_hwndOwner = (HWND)LongToHandle(dwhwnd))) || !punk)
    {
        goto done;
    }

    // We should release any old members here
    if (m_pwb)
    {
        ReleaseInterface (m_pwb);
        m_pwb = NULL;
    }

    hr = punk->QueryInterface(IID_IWebBrowser2, (void **) &m_pwb);
    if (FAILED (hr))
        m_pwb = NULL;
    
    if (m_pwb)
        hr = navigateInternal(bstrUrl, bstrTargetFrame, /*bstrProtocol,*/ USE_ALL_UI, punk);
    else
        hr = E_FAIL;

done:
    return hr;
}

// ========================================================================
// IElementBehaviorSite
// ========================================================================

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::Init
//
//  Synopsis:   Called when this code is initialized as a behavior.  This
//              sets up the m_pwb, m_pSite, and m_hwndOwner members as 
//              well.
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE 
Cwfolders::Init (IElementBehaviorSite __RPC_FAR *pBehaviorSite) 
{
    HRESULT hr = E_INVALIDARG;

    if (pBehaviorSite != NULL)
    {
        m_pSite = pBehaviorSite;
        m_pSite->AddRef();
    
        if (m_pwb)
        {
            ReleaseInterface(m_pwb);
            m_pwb = NULL;
        }

        // gets browser window handle (for ui)
        hr = GetClientSiteWindow(m_pSite, &m_hwndOwner);
        if (SUCCEEDED(hr))
            // Get the browser
            hr = IUnknown_QueryService(m_pSite, SID_SWebBrowserApp, 
                                       IID_IWebBrowser2, (LPVOID *) &m_pwb);     
    }
    return hr;  
}

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::Notify
//
//  Synopsis:   Not really used, but needed by the interface...
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE 
Cwfolders::Notify (LONG lEvent, VARIANT __RPC_FAR *pVar) 
{
    return S_OK;    
}

// ========================================================================
// IObjectSafety
// ========================================================================

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::SetInterfaceSafetyOptions
//
//  Synopsis:   Prevents those pesky security dialogs from popping up.
//              We are ALWAYS secure.
//
//-------------------------------------------------------------------------

STDMETHODIMP 
Cwfolders::SetInterfaceSafetyOptions (REFIID riid,
    DWORD dwSupportedOptions, DWORD dwEnabledOptions) 
{
    if (riid == IID_Iwfolders) 
    {
        // Since this object is always safe to use, no matter the input,
        // this returns S_OK all the time.
        return S_OK;
    }
    return IObjectSafetyImpl<Cwfolders>::SetInterfaceSafetyOptions (
        riid, dwSupportedOptions, dwEnabledOptions);
}

// ========================================================================
// Internal helper functions
// ========================================================================

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::navigateInternal
//
//  Synopsis:   All the other navigate functions call this one... this is
//              the one that does everything.  It first creates a thread
//              which will run ParseDisplayName from office.  Then, it 
//              makes a window that will recieve messages from the new 
//              thread.  Finally, it spends it's time in a DialogBox
//              call.  The normal flow is like this:
//
//  PDN Thread ---------WM_WEBFOLDER_NAV----------> Message Window
//  (PDN thread dies)
//  Message Window -----WM_WEBFOLDER_DONE---------> Dialog Window
//  (dialog and message windows close, this function returns)
//
//              The dialog we put up has a cancel button though....
//
//  (user hits cancel)
//  Dialog Window ------WM_WEBFOLDER_CANCEL-------> MessageWindow
//  MessageWindow ------WM_WEBFOLDER_DONE---------> DialogWindow
//  (dialog window closes, this function returns)
//  PDN Thread ---------WM_WEBFOLDER_NAV----------> MessageWindow
//  (PDN thread dies and message window closes)
//
//              The argsThreadArgs local variable in this function is
//              used to pass information between this function, the
//              message window, the dialog window, and the PDN thread.
//              Be careful that this variable isn't used by more than one
//              piece of code at once!!
//
//-------------------------------------------------------------------------

STDMETHODIMP
Cwfolders::navigateInternal(BSTR bstrUrl, BSTR bstrTargetFrame, /*BSTR bstrProtocol,*/ int iUI, IUnknown* punk) 
{
    HRESULT hr = E_FAIL;
    DWORD dwScheme;

    // This is what is used to pass all sorts of stuff between the different
    // windows and threads below.
    CThreadArgs argsThreadArgs;

    DWORD dwThread = 0;
    void * pThread = NULL;

    HWND hwndMessage = 0;

    WCHAR wszClassName [] = WFOLDERSWNDCLASS;

    uCLSSPEC classpec;
    URL_COMPONENTS urlcomp;
    VARIANT vTarget;
    LPITEMIDLIST pidl = NULL;

    // sanity check.
    if (!bstrUrl)
        BAILOUT (E_INVALIDARG);

    // Can't be longer than MAX_WEB_FOLDER_LENGTH
    if (SysStringLen(bstrUrl) > MAX_WEB_FOLDER_LENGTH)
    {
        if (iUI & USE_ERROR_BOXES)
            ShowError (m_hwndOwner, IDS_ERRORURLTOOLONG, 
                       IDS_ERRORURLTOOLONGTITLE, NULL); 
        BAILOUT (E_INVALIDARG);
    }

    /*
    // Check and make sure the protocol makes sense.
    if (bstrProtocol && (! (0==StrCmpICW(L"wec", bstrProtocol) ||
                            0==StrCmpICW(L"dav", bstrProtocol) ||
                            0==StrCmpICW(L"any", bstrProtocol))))
    {
        BAILOUT (E_INVALIDARG);
    }
    */

    // if the url is ftp, then we are just going to assume that Office
    // can't handle it.  We save the user the fun of the 10 minute IOD
    memset (&urlcomp, 0, sizeof(urlcomp));
    urlcomp.dwStructSize = sizeof(urlcomp);
    urlcomp.dwHostNameLength = 1;
    urlcomp.dwUrlPathLength = 1;
    urlcomp.dwExtraInfoLength = 1;

    if (!InternetCrackUrlW(bstrUrl, 0, 0, &urlcomp))
        BAILOUT(E_INVALIDARG);

    /*
    if (urlcomp.nScheme != INTERNET_SCHEME_HTTP &&
        urlcomp.nScheme != INTERNET_SCHEME_HTTPS &&
        bstrProtocol && (0==StrCmpICW(L"dav", bstrProtocol) ||
                         0==StrCmpICW(L"wec", bstrProtocol)))
    {
        BAILOUT(E_INVALIDARG);
    }
    */
    
    if (urlcomp.nScheme == INTERNET_SCHEME_FTP ||
        urlcomp.nScheme == INTERNET_SCHEME_FILE)
    {
        if (iUI & USE_FAILED_QUESTION)
        {
            ShowNavigationFailedQuestion (bstrUrl, bstrTargetFrame); 
            goto done;
        }
        else BAILOUT(IPP_E_SERVERTYPE_NOT_SUPPORTED);
        
        //vTarget.vt = VT_BSTR;
        //vTarget.bstrVal = bstrTargetFrame;

        //m_pwb->Navigate (bstrUrl, NULL, &vTarget, NULL, NULL);
        //BAILOUT(S_OK);
    }
    

    // JIT install Office NSE.
    // - note, do not call JIT on NT5 since it is not supported
    OSVERSIONINFO osVersionInfo;
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osVersionInfo) &&
        (osVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ) &&
        (osVersionInfo.dwMajorVersion > 4)   )
    {
      // this is NT5, no need to call JIT
    }
    else
    {
        classpec.tyspec=TYSPEC_CLSID;
        classpec.tagged_union.clsid=CLSID_IOD;    
        if (FAILED(FaultInIEFeature(m_hwndOwner, &classpec, NULL, 0)))
            BAILOUT(S_FALSE);  // this is where the script error code "CANCEL" originates
    }
    
/****************************** DANPOZ    ************************
    // Give office an URL and ask for a pidl back.  Do that in a 
    // seperate thread.  
    argsThreadArgs.m_hwndDialog = 0;     // must be done in case
                                       // the message thread needs to
                                       // find out if the dialog is open
    argsThreadArgs.m_bstrUrl = SysAllocString (bstrUrl);
    argsThreadArgs.m_pidl = NULL;
    argsThreadArgs.m_hrReady = E_FAIL;
    argsThreadArgs.m_ipdnStatus = READY_WORKING;
    argsThreadArgs.m_imsgStatus = READY_WORKING;


    // make message window      
    WNDCLASSEX wcex;
        
    wcex.cbSize         = sizeof(WNDCLASSEX); 
    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = (WNDPROC)NavMessageProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = g_hInst;
    wcex.hIcon          = NULL;
    wcex.hCursor        = NULL;
    wcex.hbrBackground  = NULL;
    wcex.lpszMenuName   = NULL;
    wcex.lpszClassName  = wszClassName;
    wcex.hIconSm        = NULL;

    RegisterClassEx(&wcex);   

    argsThreadArgs.m_hwndMessage = CreateWindow(wszClassName, NULL, NULL,
        0, 0, 0, 0, NULL, NULL, g_hInst, NULL);        
    if (argsThreadArgs.m_hwndMessage == NULL)
        BAILOUT (E_FAIL);
    SendMessage (argsThreadArgs.m_hwndMessage, WM_WEBFOLDER_INIT, 0, (LPARAM) &argsThreadArgs);

    // run Office's ParseDisplayName in a different thread.  It will be
    // sending messages to the argsThreadArgs.hwndMessage.  It copies all
    // information from that structure it needs first, then sets a flag
    // which allows this procedure to deallocate the memory.
    pThread = CreateThread (NULL, 0, RunParseDisplayName, &argsThreadArgs, 0, &dwThread);    

    if (pThread == NULL)
    {
        DestroyWindow (hwndMessage);
        BAILOUT (E_FAIL);
    }

    // Wait until RunParseDisplayName makes copies of the data it needs before
    // deleting it. (which would happen if the function returns)
    while (argsThreadArgs.m_ipdnStatus == READY_WORKING)
        Sleep(0);

    // our fancy dialog (with animation!)
    DialogBoxParam (g_hInst, MAKEINTRESOURCE (IDD_WEBFOLDER_SEARCH), m_hwndOwner, 
        (DLGPROC) WaitDlgProc, (LPARAM) &argsThreadArgs);

    SetFocus (m_hwndOwner);
    
    if (argsThreadArgs.m_imsgStatus == READY_DONE)  //user didn't hit cancel

    {
        hr = argsThreadArgs.m_hrReady;
******************************** DANPOZ *****************************/

/******************************** DANPOZ *****************************/
        hr = CreateWebFolderIDList( bstrUrl, &pidl, m_hwndOwner, punk);
/**********************************************************************/

        switch (hr)
        {
            case S_OK:
                // navigate to the pidl returned by office
                // ---------------------------------------

                // the message handling window packs the pidl it got from
                // office (through WM_WEBFOLDER_NAV) into the .pidl of
                // argsThreadArgs.
                /******** ************** DANPOZ *********************
                hr = NavToPidl (argsThreadArgs.m_pidl, bstrTargetFrame, m_pwb);
                *****************************************************/
                /*********************** DANPOZ NEW ***************/
                hr = NavToPidl (pidl, bstrTargetFrame, m_pwb);
                /*********************************  ***************/
                if (FAILED (hr))
                {
                    hr = E_FAIL;
                    if (iUI & USE_WEB_PAGE_UI)
                        ShowNavigationFailed (m_hwndOwner, bstrUrl, bstrTargetFrame,
                                              L"res://shdoclc.dll/http_gen.htm");
                    goto done;
                }
                else
                    hr = S_OK;
                break;
            case E_OUTOFMEMORY: //handled lower, under cleanup
                break;
            case MK_E_CONNECTMANUALLY: //returned to us if we sent Office an ftp or file url.  Shouldn't
                                       // happen at all (we filter those.) unless called via script
            case IPP_E_SERVERTYPE_NOT_SUPPORTED:
                // The server doesn't support our extensions, but does 
                // exist
                if (iUI & USE_FAILED_QUESTION)
                {
                    ShowNavigationFailedQuestion (bstrUrl, bstrTargetFrame); 
                    goto done;
                }
                break;
            case DB_SEC_E_PERMISSIONDENIED:
                // authentication failed
                if (iUI & USE_WEB_PAGE_UI)
                    ShowNavigationFailed (m_hwndOwner, bstrUrl, bstrTargetFrame,
                                          L"res://shdoclc.dll/http_403.htm");
                break;
            case STG_E_ACCESSDENIED:
            case STG_E_SHAREVIOLATION:
            case IPP_E_OFFLINE:
                hr = IPP_E_OFFLINE;
                if (iUI & USE_ERROR_BOXES)
                    ShowError (m_hwndOwner, IDS_ERROROFFLINE, 
                               IDS_ERROROFFLINETITLE, NULL); 
                break;
            case DB_E_TIMEOUT:
                // bind procedure timed out
                if (iUI & USE_WEB_PAGE_UI)
                    ShowNavigationFailed (m_hwndOwner, bstrUrl, bstrTargetFrame,
                                          L"res://shdoclc.dll/dnserror.htm");
                break;
            case ERROR_MOD_NOT_FOUND:
            case 0x8007007e: // this value is coming back.  VC 6 looks it up like
                             // ERROR_MOD_NOT_FOUND which is really what happened
                             // (office wasn't there)  But ERROR_MOD_NOT_FOUND 
                             // has a different number. 
                // This gets called when the IOD passes, but the namespace
                // extension isn't there.  This should never get called.
                hr = E_FAIL;
                break;
            case MK_E_SYNTAX:
            case MK_E_NOOBJECT:
            case MK_E_UNAVAILABLE:
            case MK_E_NOSTORAGE:
            case E_INVALIDARG:     
                //hr = MK_E_NOOBJECT;
                //if (iUI & USE_WEB_PAGE_UI)
                //    ShowNavigationFailed (m_hwndOwner, bstrUrl, bstrTargetFrame,
                //                          L"res://shdoclc.dll/dnserror.htm");
                //break;

                //ISSUE - hack follows for bug 47127 - We "should" catch most real
                // invalid args in the param checking at the beginning of this method,
                // but forcing hr to IPP_E_SERVERTYPE_NOT_SUPPORTED makes it impossible to
                // detect a real invalid arg situation that we missed above (i.e. targetframe)
                hr = IPP_E_SERVERTYPE_NOT_SUPPORTED; //Force correct error code for script

                //Fall through as per bug 43338
            default:
#ifdef NONB2_HACK                
                hr = E_FAIL;
                // Something went wrong, we know not what.  Give a relatively
                // general error page.
                if (iUI & USE_WEB_PAGE_UI)
                    ShowNavigationFailed (m_hwndOwner, bstrUrl, bstrTargetFrame,
                                          L"res://shdoclc.dll/http_gen.htm");
                goto done;
                break;
#else
                // For beta 2 (bug 43338) we're going to 
                if (iUI & USE_FAILED_QUESTION)
                {
                    ShowNavigationFailedQuestion (bstrUrl, bstrTargetFrame); 
                    goto done;
                }
                break;
#endif
        }
/****************** DANPOZ ***************************
    }
    else
        hr = S_FALSE;
******************************************************/

cleanup:
    if (hr == E_OUTOFMEMORY)
        if (iUI & USE_ERROR_BOXES)
           ShowError (m_hwndOwner, IDS_ERROROUTOFMEMORY, 
                      IDS_ERROROUTOFMEMORYTITLE, NULL); 
    if (hr == E_FAIL)
        if (iUI & USE_ERROR_BOXES)
            ShowError (m_hwndOwner, IDS_ERRORINTERNAL, 
                       IDS_ERRORINTTITLE, NULL); 
    if (hr == E_INVALIDARG)
        if (iUI & USE_WEB_PAGE_UI)
            ShowNavigationFailed (m_hwndOwner, bstrUrl, bstrTargetFrame,
                                  L"res://shdoclc.dll/http_gen.htm");   

done:
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::ShowNavigationFailedQuestion
//
//  Synopsis:   This is what we want to call when we can't get a folder 
//              view of the resource, but we might be able to get a file
//              view (normal).  This asks the user if he/she wants us to
//              try.  Navigates to the target frame.
//
//-------------------------------------------------------------------------

void 
Cwfolders::ShowNavigationFailedQuestion (BSTR bstrUrl, BSTR bstrTargetFrame)
{
    VARIANT vEMPTY;
    VariantInit (&vEMPTY);
    VARIANT * PVAREMPTY = &vEMPTY;
        
    WCHAR wszMessage [MAX_LOADSTRING+1];
    WCHAR wszTitle   [MAX_LOADSTRING+1];

    LoadString(g_hInst, IDS_ERRORBADSERVER, wszMessage, ARRAYSIZE(wszMessage));
    LoadString(g_hInst, IDS_ERRORBADSERVERTITLE, wszTitle, ARRAYSIZE(wszTitle));
    WCHAR * wsErrorMessage = new WCHAR [MAX_LOADSTRING+wcslen(bstrUrl)+1];
    if (!wsErrorMessage)
    {
        ShowError (m_hwndOwner, IDS_ERROROUTOFMEMORY, 
                   IDS_ERROROUTOFMEMORYTITLE, NULL); 
        delete[] wsErrorMessage;
        return;
    }
    wnsprintf (wsErrorMessage, MAX_LOADSTRING+wcslen(bstrUrl), wszMessage, bstrUrl);
    int iButton = MessageBox (m_hwndOwner, 
                              wsErrorMessage,
                              wszTitle,
                              MB_YESNO | MB_ICONQUESTION);
    delete[] wsErrorMessage;
    if (iButton == IDYES)
    {
        VARIANT vTarget;
        vTarget.vt = VT_BSTR;
        vTarget.bstrVal = bstrTargetFrame;

        m_pwb->Navigate (bstrUrl, NULL, &vTarget, NULL, NULL);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::NavToPidl
//
//  Synopsis:   Comparatively low level helper function that navigates
//              a given pidl (from office) to the target frame given.
//              The web browser 2 arg does not have to refer to the
//              correct frame.
//
//-------------------------------------------------------------------------

HRESULT 
Cwfolders::NavToPidl (LPITEMIDLIST pidl, BSTR bstrTargetFrame, IWebBrowser2 * pwb)
{
    VARIANT vPidl;
    HRESULT hr;
    IWebBrowser2 * pwbf = NULL;
    ITargetFrame * ptf = NULL;
    IUnknown * punknown = NULL;
    VARIANT vEMPTY;
    VariantInit (&vEMPTY);
    VARIANT * PVAREMPTY  = &vEMPTY;

    hr = InitVARIANTFromPidl(&vPidl, pidl);
    if (FAILED(hr))
        return hr;

    // This is here to change frames, or to make a new one as the case my
    if (bstrTargetFrame && (0!=StrCmpICW(L"", bstrTargetFrame)))
    {
        hr = pwb->QueryInterface(IID_ITargetFrame, (void **)&ptf);     
        FAILONBAD_HR(hr);
        hr = ptf->FindFrame (bstrTargetFrame, (IUnknown *) pwb, 0, &punknown);
        if (FAILED (hr))
        {
            hr = CreateTargetFrame (bstrTargetFrame, &punknown);
        }
        FAILONBAD_HR(hr);
        hr = punknown->QueryInterface(IID_IWebBrowser2, (void **)&pwbf);
        FAILONBAD_HR(hr);
    }
    else
    {
        pwbf = pwb;
    }

    // the actual navigation!
    hr = pwbf->put_Visible (VARIANT_TRUE);
    if (SUCCEEDED (hr))
    {
        pwbf->Stop();
        hr = pwbf->Navigate2(&vPidl, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY);
    }
cleanup:
    ReleaseInterface (ptf);
    if (pwb != pwbf)
        ReleaseInterface (pwbf);
    ReleaseInterface (punknown);

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::RunParseDisplayName
//
//  Synopsis:   Runs ParseDisplayName.  This is abstracted to use as a
//              seperate thread.
//
//-------------------------------------------------------------------------

DWORD WINAPI 
Cwfolders::RunParseDisplayName (LPVOID pArguments)
{
    HRESULT hr = E_FAIL;

    CThreadArgs *pInfo = (CThreadArgs *)pArguments;
    LPITEMIDLIST pidl = NULL;
    HWND hwndMessage = pInfo->m_hwndMessage;
    BSTR bstrUrl = SysAllocString (pInfo->m_bstrUrl);

    // This will signal that pInfo is safe to be released (we have all the info 
    // we need out of it)  pInfo should NEVER be referenced in this function
    // after this value is set.
    pInfo->m_ipdnStatus = READY_INITIALIZED;

    if (!bstrUrl)
    {
        PostMessage (hwndMessage, WM_WEBFOLDER_NAV, 0, (LPARAM) E_OUTOFMEMORY);
        goto cleanup;
    }

    // calls the appropriate ParseDisplayName
    /******************DANPOZ*********************
    hr = CreateWebFolderIDList(bstrUrl, &pidl);
    **********************************************/
    // because of some OLE restrictions, this call must be PostMesage,
    // not SendMessage.
    PostMessage (hwndMessage, WM_WEBFOLDER_NAV, (WPARAM) pidl, (LPARAM) hr);
    
cleanup:
    SysFreeString (bstrUrl);
    return hr;
}

//+------------------------------------------------------------------------
//
//  NAME:         Cwfolders::WaitDlgProc
//
//  SYNOPSIS:     This is the handler for our little dialog.  It will get
//                a WM_WEBFOLDER_DONE message when it should die.
//
//-------------------------------------------------------------------------

INT_PTR CALLBACK 
Cwfolders::WaitDlgProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CThreadArgs * pInfo = NULL;
    HWND hAnimation;
    HWND hStatic;

    switch (message)
    {
    case WM_COMMAND:
        if (LOWORD(wParam) == IDCANCEL) 
        {
            pInfo = (CThreadArgs *) GetProp (hDlg, __INFO);
            if (!pInfo)
                return E_FAIL;
            PostMessage (pInfo->m_hwndMessage, WM_WEBFOLDER_CANCEL, 0, 0);
        }   
        return TRUE;

    case WM_INITDIALOG:
        if (!lParam)
            return E_INVALIDARG;
        pInfo = (CThreadArgs *) lParam;
        // if this is true then there is no message window (PDN thread closed
        // it before we could even start the wait dialog.)  Just close the
        // dialog because everything is already done.
        if (pInfo->m_imsgStatus == READY_DONE)
            EndDialog (hDlg, 0);
        else
        {
            if (!SetProp (hDlg, __INFO, (void *)lParam))
                return E_FAIL;
            // Change our text string to something with the URL in it.
            // If this section fails for any reason, the dialog will keep
            // the generic "IE is looking for your folder" message.
            {
                WCHAR wsMessage [MAX_LOADSTRING+1]; 
                WCHAR *wsStatus = new WCHAR[wcslen(pInfo->m_bstrUrl)+1+MAX_LOADSTRING];
                if (wsStatus)
                {
                    LoadString ( g_hInst, IDS_WEBFOLDER_FIND, wsMessage, ARRAYSIZE(wsMessage) );

                    DWORD dwResultSize;
                    WCHAR wsResult [INTERNET_MAX_URL_LENGTH]; 

                    if (SUCCEEDED (CoInternetParseUrl(pInfo->m_bstrUrl, PARSE_DOMAIN, 
                         0, wsResult, ARRAYSIZE(wsResult), &dwResultSize, 0)))
                    {
                        wnsprintf (wsStatus, wcslen(pInfo->m_bstrUrl)+MAX_LOADSTRING, 
                            wsMessage, wsResult);
                        hStatic = GetDlgItem (hDlg, IDC_WEBFOLDER_MESSAGE);
                        if (hStatic)
                            SendMessage (hStatic, WM_SETTEXT, 0, (LPARAM) wsStatus);
                    }
                    
                    delete[] wsStatus;
                }
            }
            // At this point, we are ready to get messages from the
            // message window, so let it know our hwnd.
            pInfo->m_hwndDialog = hDlg;
            hAnimation = GetDlgItem (hDlg, IDC_WEBFOLDER_ANIMATE);
            if (hAnimation)
                Animate_Open(hAnimation, MAKEINTRESOURCE(IDA_ISEARCH));
        }
        return S_OK;

    case WM_WEBFOLDER_DONE:
        // The message window is closing us.
        EndDialog (hDlg, 0);
        break;

    case WM_DESTROY:
        hAnimation = GetDlgItem (hDlg, IDC_WEBFOLDER_ANIMATE);
        if (hAnimation)
        {
            Animate_Close(hAnimation);
        }        
        RemoveProp (hDlg, __INFO);
        break;
    }
    return DefWindowProc(hDlg, message, wParam, lParam);
}

//+------------------------------------------------------------------------
//
//  NAME:         Cwfolders::NavMessageProc
//
//  SYNOPSIS:     This is the message handler for the ParseDisplayName call.
//
//-------------------------------------------------------------------------

INT_PTR CALLBACK 
Cwfolders::NavMessageProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CThreadArgs * pInfo = NULL;
    HANDLE hCancel;
    HWND hwndDialog;

    switch (message)
    {
    case WM_CREATE:
        if (!SetProp (hDlg, __CANCEL, STATUS_READY))
            return E_FAIL;
        return S_OK;

    case WM_WEBFOLDER_INIT:
        if (!lParam)
            return E_INVALIDARG;
        pInfo = (CThreadArgs *) lParam;
        if (!SetProp (hDlg, __INFO, (void *)lParam))
            return E_FAIL;
        pInfo->m_hwndMessage = hDlg;
        break;
    
    case WM_WEBFOLDER_CANCEL:
        pInfo = (CThreadArgs *) GetProp (hDlg, __INFO);
        if (!pInfo)
            return E_FAIL;
        if (!SetProp (hDlg, __CANCEL, STATUS_CANCELED))
            return E_FAIL;
        hwndDialog = pInfo->m_hwndDialog;
        // let the navigateInternal call know that we are canceled.
        pInfo->m_imsgStatus = READY_CANCEL;
        if (hwndDialog)
            SendMessage (hwndDialog, WM_WEBFOLDER_DONE, 0, 0);
        return S_OK;

    case WM_WEBFOLDER_NAV:
        hCancel = GetProp (hDlg, __CANCEL);
        if (!hCancel)
            return E_FAIL;
        if (hCancel != STATUS_CANCELED)
        {
            // we wait to get pInfo because if we canceled before, it
            // doesn't exist anymore!
            pInfo = (CThreadArgs *) GetProp (hDlg, __INFO);
            if (!pInfo)
                return E_FAIL;

            pInfo->m_pidl = (LPITEMIDLIST) wParam;
            pInfo->m_hrReady = (HRESULT)lParam;
            hwndDialog = pInfo->m_hwndDialog;
            pInfo->m_imsgStatus = READY_DONE;
            if (hwndDialog)
                SendMessage (hwndDialog, WM_WEBFOLDER_DONE, 0, 0);
        }
        DestroyWindow (hDlg);
        return TRUE;

    case WM_DESTROY:
        RemoveProp (hDlg, __CANCEL);
        RemoveProp (hDlg, __INFO);
        break;
    }
    return DefWindowProc(hDlg, message, wParam, lParam);
}

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::ShowError
//
//  Synopsis:   Throws up a message box.  The two unsinged ints point to
//              entries in the string table.  If the bstr is set, it will
//              be placed in the %s location in the string table.  
//
//-------------------------------------------------------------------------

void 
Cwfolders::ShowError (HWND hwnd, unsigned int IDSmessage, 
                      unsigned int IDStitle, BSTR bstrUrl)
{
    WCHAR wszMessage [MAX_LOADSTRING+1];
    WCHAR wszTitle   [MAX_LOADSTRING+1];

    LoadString(g_hInst, IDSmessage, wszMessage, ARRAYSIZE(wszMessage));
    LoadString(g_hInst, IDStitle, wszTitle, ARRAYSIZE(wszTitle));
    if (bstrUrl)
    {
        WCHAR * wsErrorMessage = new WCHAR [MAX_LOADSTRING+wcslen(bstrUrl)+1];
        if (!wsErrorMessage)
        {
            ShowError (hwnd, IDS_ERROROUTOFMEMORY, IDS_ERROROUTOFMEMORYTITLE, NULL); 
            return;
        }
        wnsprintf (wsErrorMessage, MAX_LOADSTRING+wcslen(bstrUrl), wszMessage, bstrUrl);
        MessageBox (hwnd, wsErrorMessage, wszTitle, MB_OK | MB_ICONERROR);
        delete[] wsErrorMessage;
    }
    else
        MessageBox (hwnd, wszMessage, wszTitle, MB_OK | MB_ICONERROR);
}
    
//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::ShowNavigationFailed
//
//  Synopsis:   This guy gets called when there is no chance we can show
//              the requested resource in ANY view.  For instance, if the
//              DNS lookup fails.
//
//-------------------------------------------------------------------------

void 
Cwfolders::ShowNavigationFailed (HWND hWnd, BSTR bstrUrl, BSTR bstrTargetFrame,
                                 WCHAR * wszResource)
{
    VARIANT vTarget;
    vTarget.vt = VT_BSTR;

    // +1 for \0 and +1 for '#'
    WCHAR * wszResUrl = new WCHAR [wcslen(bstrUrl) + wcslen(wszResource) + 2];
    
    if (wszResUrl)
    {
        // This is how to hack a different URL into the address bar when
        // showing an error page without having the address of the error
        // page in there too.
        wszResUrl [0] = NULL;
        wcscat (wszResUrl, wszResource);
        wcscat (wszResUrl, L"#");
        wcscat (wszResUrl, bstrUrl);

        vTarget.bstrVal = bstrTargetFrame;
        m_pwb->Navigate (wszResUrl, NULL, &vTarget, NULL, NULL);
        delete [] wszResUrl;
    }
    else
    {
        // the memory allocation failed.  Oh well, so the url in
        // the address bar is wrong.  
        vTarget.bstrVal = bstrTargetFrame;
        m_pwb->Navigate (wszResource, NULL, &vTarget, NULL, NULL);
    }
}
     
//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::CreateWebFolderIDList
//
//  Synopsis:   Asks office nse for a pidl, given an URL.  This was written
//              by Chris Guzak to be compatible with NT 5, which puts the 
//              office nse in a different place from NT 4, 9x.
//
//-------------------------------------------------------------------------

HRESULT 
//Cwfolders::CreateWebFolderIDList(BSTR bstrUrl, LPITEMIDLIST *ppidl)
Cwfolders::CreateWebFolderIDList(BSTR bstrUrl, LPITEMIDLIST *ppidl, HWND hwnd, IUnknown* punk)
{
    IShellFolder *psf = NULL;
    HRESULT hr = SHGetDesktopFolder(&psf);
    if (SUCCEEDED(hr))
    {
        IBindCtx *pbc;
        hr = CreateBindCtx(0, &pbc);
        if (SUCCEEDED(hr))
        {        
            hr = pbc->RegisterObjectParam((LPOLESTR)STR_PARSE_PREFER_FOLDER_BROWSING, punk);
            if (SUCCEEDED(hr))
            {
                ULONG ulAttr = SFGAO_FOLDER;
                if (SUCCEEDED(hr = psf->ParseDisplayName(hwnd, pbc, bstrUrl, NULL, ppidl, &ulAttr)))
                {
                    if (!(ulAttr & SFGAO_FOLDER))
                    {
                        // fancy footwork to navigate to the parent folder if one exists
                        WCHAR * wszParentUrl = new WCHAR [1+SysStringLen(bstrUrl)];
                        if (wszParentUrl)
                        {
                            DWORD dwBuffSize = SysStringLen(bstrUrl);
                            // get name of parent folder
                            if (InternetCombineUrlW (bstrUrl, L"", wszParentUrl, &dwBuffSize, ICU_NO_ENCODE))
                            {
                                ulAttr = SFGAO_FOLDER;
                                hr = psf->ParseDisplayName(NULL, pbc, wszParentUrl, NULL, ppidl, &ulAttr);
                                if (SUCCEEDED(hr))
                                {   
                                    if (!(ulAttr & SFGAO_FOLDER))
                                        hr = MK_E_NOSTORAGE;
                                }
                            }
                            else
                            {
                                switch (GetLastError()) 
                                {
                                    case ERROR_BAD_PATHNAME:
                                        hr = MK_E_NOSTORAGE;
                                        break;
                                    case ERROR_INSUFFICIENT_BUFFER:
                                        hr = E_OUTOFMEMORY;
                                        break;
                                    case ERROR_INTERNET_INVALID_URL:
                                        hr = E_INVALIDARG;
                                        break;
                                    default:
                                        hr = E_FAIL;
                                }
                            }
                            delete [] wszParentUrl;
                        }
                        else
                            hr = E_OUTOFMEMORY;
                    }
                }
         
            }                
            pbc->Release();
        }
        psf->Release();
    }

      
   if(FAILED(hr))
   {
   
        IShellFolder *psfb = NULL;
        hr = SHGetDesktopFolder(&psf);

        if (SUCCEEDED(hr))
        {
            IBindCtx *pbc;
            hr = CreateBindCtx(0, &pbc);
            if (SUCCEEDED(hr))
            {
                BIND_OPTS bo;
                memset(&bo, 0, sizeof(bo));
                bo.cbStruct = sizeof(bo);
                bo.grfFlags = BIND_JUSTTESTEXISTENCE;
                bo.grfMode = STGM_CREATE;
                pbc->SetBindOptions(&bo);
                
                // CLSID_MyComputer CLSID_WebFolders
                WCHAR wszPath[] = L"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{BDEADF00-C265-11D0-BCED-00A0C90AB50F}";

                LPITEMIDLIST pidlo = NULL;
                LPITEMIDLIST pidlurl = NULL;
                ULONG chEaten = 0;
                ULONG ulAttr = SFGAO_FOLDER;

                // first PDN gets the Office shell folder pidl, then bind to it, next PDN tries for a pidl
                // to our specific URL
                if (SUCCEEDED(hr = psf->ParseDisplayName(NULL, pbc, wszPath, &chEaten, &pidlo, &ulAttr)) ) 
                {
                    if( SUCCEEDED(hr = psf->BindToObject (pidlo, NULL, IID_IShellFolder, (void **) &psfb)) )
                    { 
                        if( SUCCEEDED(hr = psfb->ParseDisplayName(hwnd, pbc, bstrUrl, &chEaten, &pidlurl, &ulAttr)))
                        {
                            if (!(ulAttr & SFGAO_FOLDER))
                            {
                                // fancy footwork to navigate to the parent folder if one exists
                                WCHAR * wszParentUrl = new WCHAR [1+SysStringLen(bstrUrl)];
                                if (wszParentUrl)
                                {
                                    DWORD dwBuffSize = SysStringLen(bstrUrl);
                                    // get name of parent folder
                                    if (InternetCombineUrlW (bstrUrl, L"", wszParentUrl, &dwBuffSize, ICU_NO_ENCODE))
                                    {
                                        ulAttr = SFGAO_FOLDER;
                                        hr = psfb->ParseDisplayName(NULL, pbc, wszParentUrl, &chEaten, &pidlurl, &ulAttr);
                                        if (SUCCEEDED(hr))
                                        {   
                                            if (!(ulAttr & SFGAO_FOLDER))
                                            hr = MK_E_NOSTORAGE;
                                        }
                                    }
                                    else
                                    {
                                        switch (GetLastError()) 
                                        {
                                            case ERROR_BAD_PATHNAME:
                                                hr = MK_E_NOSTORAGE;
                                                break;
                                            case ERROR_INSUFFICIENT_BUFFER:
                                                hr = E_OUTOFMEMORY;
                                                break;
                                            case ERROR_INTERNET_INVALID_URL:
                                                hr = E_INVALIDARG;
                                                break;
                                            default:
                                                hr = E_FAIL;
                                        }
                                    }
                                    delete [] wszParentUrl;
                                }
                                else
                                    hr = E_OUTOFMEMORY;
                            }
                    
                            if (pidlurl && pidlo)
                                (*ppidl) = ILCombine (pidlo, pidlurl);

                            ILFree(pidlurl);

                        } // psfb->ParseDisplayName

                    } // psf->BindToObject

                    ILFree(pidlo);
                } // psf->ParseDisplayName

                pbc->Release();

            } // CreateBindCtx 
        }

        ReleaseInterface (psf);
        ReleaseInterface (psfb);
    }  
    return hr;
}

// ========================================================================
// The following three functions were taken from an SDK example.
// They are here to facilitate the packing of a PIDL into a 
// VARIANT so that explorer will accept it for an argument to
// Navigate2.
// ========================================================================

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::InitVARIANTFromPidl
//
//  Synopsis:   Packs a pidl into a VARIANT
//
//-------------------------------------------------------------------------

HRESULT 
Cwfolders::InitVARIANTFromPidl(LPVARIANT pvar, LPITEMIDLIST pidl)   
{
    if (!pidl || !pvar) 
    { 
        return E_POINTER;      
    }
    // Get the size of the pidl and allocate a SAFEARRAY of
    // equivalent size      
    UINT cb = ILGetSize(pidl);
    LPSAFEARRAY psa = MakeSafeArrayFromData((LPBYTE)pidl, cb);      
    if (!psa) 
    { 
        VariantInit(pvar);
        return E_OUTOFMEMORY;  
    }
    pvar->vt = VT_ARRAY|VT_UI1;  
    pvar->parray = psa;
    return NOERROR;  
}

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::MakeSafeArrayFromData
//
//  Synopsis:   Allocates a SAFEARRAY of cbData size and packs pData into
//              it.
//
//-------------------------------------------------------------------------

LPSAFEARRAY 
Cwfolders::MakeSafeArrayFromData(LPBYTE pData, DWORD cbData)   
{
    LPSAFEARRAY psa;      

    if (!pData || 0 == cbData) 
    {
        return NULL;  // nothing to do
    }
    // create a one-dimensional safe array of BYTEs
    psa = SafeArrayCreateVector(VT_UI1, 0, cbData);      
    if (psa) 
    {
        // copy data into the area in safe array reserved for data
        // Note we party directly on the pointer instead of using locking/
        // unlocking functions.  Since we just created this and no one
        // else could possibly know about it or be using it, this is okay.
        memcpy(psa->pvData,pData,cbData);      
    }      
    
    return psa;   
}

//+------------------------------------------------------------------------
//
//  Member:     Cwfolders::ILGetSize
//
//  Synopsis:   Gets the size of the PIDL by walking the item id list
//
//-------------------------------------------------------------------------

#define _ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define _ILNext(pidl)           _ILSkip(pidl, (pidl)->mkid.cb)

UINT 
Cwfolders::ILGetSize(LPITEMIDLIST pidl) 
{
    UINT cbTotal = 0;
    if (pidl) 
    {
        cbTotal += sizeof(pidl->mkid.cb); // Null terminator
        while (pidl->mkid.cb) 
        {
            cbTotal += pidl->mkid.cb;
            pidl = _ILNext(pidl);
        }
    }
    return cbTotal;
}

// ========================================================================
// These two functions live in shdocvw.  They are not, unfortunately,
// exported, so they appear here as well.
// ========================================================================

//+------------------------------------------------------------------------
//
//    NAME:       Cwfolders::ParseTargetType
//
//    SYNOPSIS:   Maps pszTarget into a target class.
//
//    IMPLEMENTATION:
//    Treats unknown MAGIC targets as _self
//
//-------------------------------------------------------------------------

TARGET_TYPE 
Cwfolders::ParseTargetType(LPCOLESTR pszTarget)
{
    const TARGETENTRY *pEntry = targetTable;

    if (pszTarget[0] != '_') return TARGET_FRAMENAME;
    while (pEntry->pTargetValue)
    {
        if (!StrCmpW(pszTarget, pEntry->pTargetValue)) return pEntry->targetType;
        pEntry++;
    }
    //  Treat unknown MAGIC targets as regular frame name! <<for NETSCAPE compatibility>>
    return TARGET_FRAMENAME;

}

//+------------------------------------------------------------------------
//
//  NAME:         Cwfolders::CreateTargetFrame
//
//  SYNOPSIS:     Creates a new window, if pszTargetName is not special
//                target, names it pszTargetName.  returns IUnknown for
//                the object that implements ITargetFrame,IHlinkFrame and
//                IWebBrowserApp.
//
//-------------------------------------------------------------------------

HRESULT 
Cwfolders::CreateTargetFrame(LPCOLESTR pszTargetName, LPUNKNOWN /*IN,OUT*/ *ppunk)
{
    LPTARGETFRAME2 ptgfWindowFrame;
    HRESULT hr = S_OK;

    //  Launch a new window, set it's frame name to pszTargetName
    //  return it's IUnknown. If the new window is passed to us,
    //  just set the target name.

    if (NULL == *ppunk)
    {
#ifndef  UNIX
        hr = CoCreateInstance(CLSID_InternetExplorer, NULL,
                              CLSCTX_LOCAL_SERVER, IID_IUnknown, (LPVOID*)ppunk);
#else
        hr = CoCreateInternetExplorer( IID_IUnknown, 
                                       CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER,
                                       (LPVOID*) ppunk );
#endif
    }

    if (SUCCEEDED(hr))
    {
        //  Don't set frame name if target is special or missing
        if (pszTargetName && ParseTargetType(pszTargetName) == TARGET_FRAMENAME)
        {
            HRESULT hrLocal;
            hrLocal = (*ppunk)->QueryInterface(IID_ITargetFrame2, (LPVOID *)&ptgfWindowFrame);
            if (SUCCEEDED(hrLocal))
            {
                ptgfWindowFrame->SetFrameName(pszTargetName);
                ptgfWindowFrame->Release();
            }
        }

        // Even if we don't set the frame name, we still want to return
        // success, otherwise we'd have a blank window hanging around.
    }

    return hr;
}

//+------------------------------------------------------------------------
//
//  NAME:         Cwfolders::SetScriptErrorMessage
//
//  SYNOPSIS:     This converts the hresult we would have returned from
//                navigateInternal to a string to pass back to scripts
//
//-------------------------------------------------------------------------

void
Cwfolders::SetScriptErrorMessage (HRESULT hr, BSTR * pbstr)
{
    // These strings are what the scripting language recieves
    // as our return value to navigate and navigateFrame
    // The hr in the switch is the return value of NavigateInternal
    switch (hr)
    {
    case S_OK:
        *pbstr = SysAllocString (L"OK");
        break;
    case IPP_E_SERVERTYPE_NOT_SUPPORTED:
        *pbstr = SysAllocString (L"PROTOCOL_NOT_SUPPORTED");
        break;
    case MK_E_NOOBJECT:
    case DB_E_CANNOTCONNECT:
        *pbstr = SysAllocString (L"LOCATION_DOES_NOT_EXIST");
        break;
    case DB_SEC_E_PERMISSIONDENIED:
        *pbstr = SysAllocString (L"PERMISSION_DENIED");
        break;
    case E_INVALIDARG:
        *pbstr = SysAllocString (L"INVALIDARG");
        break;
    case IPP_E_OFFLINE:
        *pbstr = SysAllocString (L"OFFLINE");
        break;
    case E_OUTOFMEMORY:
        *pbstr = SysAllocString (L"OUTOFMEMORY");
        break;
    case DB_E_TIMEOUT:
        *pbstr = SysAllocString (L"TIMEOUT");
        break;
    case S_FALSE:
        *pbstr = SysAllocString (L"CANCEL");
        break;
    case MK_E_CONNECTMANUALLY: //returned to us if we sent Office an ftp or file url
        *pbstr = SysAllocString (L"PROTOCOL_NOT_SUPPORTED");
        break;
    default:
        *pbstr = SysAllocString (L"FAILED");
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\peerfact.h ===
// CPeerFactory.h : Declaration of the CPeerFactory

#ifndef __PEERFACT_H_
#define __PEERFACT_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CPeerFactory

class ATL_NO_VTABLE CPeerFactory : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPeerFactory, &CLSID_PeerFactory>,
	public IElementBehaviorFactory,
	public IElementNamespaceFactory
{
public:
    //
    // construction / destruction
    //

    CPeerFactory();
    ~CPeerFactory();

    //
    // IElementBehaviorFactory
    //

    STDMETHOD(FindBehavior)(
        BSTR bstrName, BSTR bstrUrl, IElementBehaviorSite * pSite, IElementBehavior ** ppPeer);

    //
    // IElementNamespaceFactory
    //

    STDMETHOD(Create)(IElementNamespace * pNamespace);

    //
    // macros
    //

DECLARE_REGISTRY_RESOURCEID(IDR_PEERFACTORY)

BEGIN_COM_MAP(CPeerFactory)
    COM_INTERFACE_ENTRY(IElementBehaviorFactory)
    COM_INTERFACE_ENTRY(IElementNamespaceFactory)
END_COM_MAP()

};

#endif //__PEERFACT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\radio.cxx ===
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"

#include "utils.hxx"

#include "radio.hxx"

const CBaseCtl::PROPDESC CRadioButton::s_propdesc[] = 
{
    {_T("value"), VT_BSTR},
    {_T("checked"), VT_BOOL, NULL, NULL, VB_FALSE},
    NULL
};

enum
{
    VALUE = 0,
    CHECKED = 1
};

HRESULT
CRadioButton::Init(CContextAccess * pca)
{
    HRESULT         hr = S_OK;

    hr = pca->Open (CA_SITEOM);
    if (hr)
        goto Cleanup;

    hr = pca->SiteOM()->RegisterName(_T("radiobutton"));
    if (hr)
        goto Cleanup;

Cleanup:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CRadioButton::get_value(BSTR * pv)
{
    return GetProps()[VALUE].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CRadioButton::put_value(BSTR v)
{
    return GetProps()[VALUE].Set(v); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CRadioButton::get_checked(VARIANT_BOOL * pv)
{
    return GetProps()[CHECKED].Get(pv);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CRadioButton::put_checked(VARIANT_BOOL v)
{
    return GetProps()[CHECKED].Set(v);
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
CRadioButton::OnClick(CEventObjectAccess *pEvent)
{
    HRESULT      hr = S_OK;
    VARIANT_BOOL fChecked = FALSE;

    hr = get_checked(&fChecked);
    if (hr)
        goto Cleanup;

    // You can't uncheck a radio button by clicking on it.
    if (!fChecked)
        hr = ChangeState();

Cleanup:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
CRadioButton::OnKeyPress(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;
    long    lKeyCode;

    hr = pEvent->GetKeyCode(&lKeyCode);
    if (hr)
        goto Cleanup;

    // TODO is this the right way to check lKey?
    if (_T(' ') == lKeyCode)
    {
        VARIANT_BOOL fChecked = FALSE;

        hr = get_checked(&fChecked);
        if (hr)
            goto Cleanup;

        // You can't uncheck a radio button by clicking on it.
        if (!fChecked)
            hr = ChangeState();
    }

Cleanup:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////

HRESULT
CRadioButton::ChangeState()
{
    HRESULT         hr = S_OK;
    CContextAccess  a(_pSite);
    VARIANT_BOOL    fChecked = VB_FALSE;
    IHTMLElement * pElem = NULL;

    hr = a.Open(CA_SITERENDER | CA_ELEM);
    if (hr)
        goto Cleanup;

    hr = get_checked(&fChecked);
    if (hr)
        goto Cleanup;

    hr = put_checked(!fChecked);
    if (hr)
        goto Cleanup;

    hr = a.SiteRender()->Invalidate(NULL);

Cleanup:
    ReleaseInterface(pElem);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\rectpeer.cxx ===
//===============================================================
//
//  rectpeer.cxx : Implementation of the CLayoutRect Peer
//
//  Synposis : this class is repsponsible for handling the "generic"
//      containership for view templates. It is the XML-ish tag <layout:Rect>
//
//===============================================================
                                                              
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef __X_IEXTAG_H_
#define __X_IEXTAG_H_
#include "iextag.h"
#endif

#ifndef __X_RECTPEER_HXX_
#define __X_RECTPEER_HXX_
#include "rectpeer.hxx"
#endif

#ifndef __X_UTILS_HXX_
#define __X_UTILS_HXX_
#include "utils.hxx"
#endif

#ifndef X_SHLGUID_H_
#define X_SHLGUID_H_
#include <shlguid.h> 
#endif

#ifndef MSHTMHST_H_
#define MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef MSHTMCID_H_
#define MSHTMCID_H_
#include <mshtmcid.h>
#endif

#define CheckResult(x) { hr = x; if (FAILED(hr)) goto Cleanup; }

//+----------------------------------------------------------------------------
//
//  DTOR
//
//-----------------------------------------------------------------------------

CLayoutRect::~CLayoutRect()
{
    Detach();
}

//+----------------------------------------------------------------------------
//
//  Member : Detach - IElementBehavior method impl
//
//  Synopsis : when the peer is detatched, we will take this oppurtunity 
//      to release our various cached pointers.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CLayoutRect::Detach() 
{ 
    CDataObject  * pDO = NULL;
    long           i=0;

    ClearInterface( &_pPeerSite );

    for (pDO = &_aryAttributes[0], i=0;
         pDO && i< eAttrTotal;
         pDO++, i++)
    {
         pDO->ClearContents();
    }

    return S_OK; 
}

//+----------------------------------------------------------------------------
//
//  Member : Init - IElementBehavior method impl
//
//  Synopsis : this method is called by MSHTML.dll to initialize peer object.
//      this is where we do all the connection and peer management work.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CLayoutRect::Init(IElementBehaviorSite * pPeerSite)
{
    HRESULT          hr = S_OK;
    VARIANT          varParam;
    CContextAccess   ca(pPeerSite);    

    if (!pPeerSite)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // some of our attributes have default values
    V_BOOL(&_aryAttributes[eHonorPageBreaks]._varValue) = VB_TRUE;
    V_VT(&_aryAttributes[eHonorPageBreaks]._varValue) = VT_BOOL;

    V_BOOL(&_aryAttributes[eHonorPageRules]._varValue) = VB_TRUE;
    V_VT(&_aryAttributes[eHonorPageRules]._varValue) = VT_BOOL;


    // cache our peer element
    _pPeerSite = pPeerSite;
    _pPeerSite->AddRef();

    // set up our default style sheet
    ca.Open(CA_SITEOM | CA_DEFAULTS | CA_DEFSTYLE);

    // The contents of layout rects shouldn't inherit styles from outside;
    // we're like frames.
    CheckResult( ca.Defaults()->put_viewInheritStyle( VB_FALSE ) );

    CheckResult( ca.DefStyle()->put_overflow(CComBSTR("hidden")));

    V_VT(&varParam) = VT_BSTR;
    V_BSTR(&varParam) = SysAllocString(_T("300px"));
    if (!V_BSTR(&varParam))
        goto Cleanup;
    CheckResult( ca.DefStyle()->put_width(varParam));
    VariantClear(&varParam);

    V_VT(&varParam) = VT_BSTR;
    V_BSTR(&varParam) = SysAllocString(_T("150px"));
    if (!V_BSTR(&varParam))
        goto Cleanup;
    CheckResult( ca.DefStyle()->put_height(varParam));
    VariantClear(&varParam);

Cleanup:
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : Notify - IElementBehavior method impl
//
//  Synopsis : peer Interface, called for notification of document events.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CLayoutRect::Notify(LONG lEvent, VARIANT *)
{
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member : get_nextRect - ILayoutRect property impl
//         : put_nextRect - ILayoutRect property impl
//
//  Synopsis : property get'er. returns the next element in the container chain
//           : property put'er. sets the next element in the container chain
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CLayoutRect::get_nextRect(BSTR * pbstrNextId)
{
    TEMPLATESECURITYCHECK()

    if ( !pbstrNextId )
        return E_POINTER;

    return _aryAttributes[eNextRect].GetAsBSTR( pbstrNextId );
}


STDMETHODIMP
CLayoutRect::put_nextRect(BSTR bstrNextId )
{
    TEMPLATESECURITYCHECK()

    return _aryAttributes[eNextRect].Set(bstrNextId);
}


STDMETHODIMP
CLayoutRect::get_media(BSTR * pbstrMedia)
{
    TEMPLATESECURITYCHECK()

    // (greglett) This won't ever be used.  Don't confuse the caller.  Let them know.
    return E_NOTIMPL;
}


STDMETHODIMP
CLayoutRect::put_media(BSTR bstrMedia )
{
    TEMPLATESECURITYCHECK()

    // (greglett) This won't ever be used.  Don't confuse the caller.  Let them know.
    return E_NOTIMPL;
}


//+----------------------------------------------------------------------------
//
//  Member : get_contentSrc - ILayoutRect property impl
//         : put_contentSrc - ILayoutRect property impl
//
//  Synopsis : property get'er. returns the String of the content ULR
//           : property put'er. sets the string of the content URL 
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLayoutRect::get_contentSrc(VARIANT * pvarSrc)
{
    TEMPLATESECURITYCHECK()

    if (!pvarSrc)
        return E_POINTER;

    return VariantCopy(pvarSrc, &(_aryAttributes[eContentSrc]._varValue));
}

STDMETHODIMP
CLayoutRect::put_contentSrc(VARIANT varSrc)
{
    HRESULT hr;

    if (!TemplateAccessAllowed(_pPeerSite))
    {
        PutBlankViewLink();
        return E_ACCESSDENIED;
    }

    hr =  VariantCopy(&(_aryAttributes[eContentSrc]._varValue), &varSrc);
    if (hr)
        goto Cleanup;

    if (V_VT(&varSrc) == VT_BSTR)
    {
        hr = PutViewLink(V_BSTR(&varSrc));
    }
    else if (   V_VT(&varSrc) == VT_UNKNOWN
             || V_VT(&varSrc) == VT_DISPATCH)
    {
        hr = PutViewLink(V_UNKNOWN(&varSrc));
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if (hr)
        goto Cleanup;

Cleanup:
    return hr;
}

//+----------------------------------------------------------------------
//
//   Helper : PutViewLink
//
//   Handles an IUnknown and routes it to the relevant PutViewLink function
//
//-----------------------------------------------------------------------
HRESULT
CLayoutRect::PutViewLink(IUnknown * pUnk )
{
    HRESULT           hr            = E_FAIL;
    IHTMLDocument2  * pISlaveDoc    = NULL;     // Slave document
    IStream         * pIStream      = NULL;     // OE Express header stream

    if (!pUnk)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Are we an HTML document?
    if (    !pUnk->QueryInterface(IID_IHTMLDocument2, (void**)&pISlaveDoc)
        &&  pISlaveDoc)
    {
        hr = PutViewLink(pISlaveDoc);
    }
    // Are we a stream from which to load an HTML document?
    else if (   !pUnk->QueryInterface(IID_IStream, (void **)&pIStream)
             && pIStream)
    {
        hr = PutViewLink(pIStream);
    }

Cleanup:
    ReleaseInterface(pISlaveDoc);
    ReleaseInterface(pIStream);
    return hr;
}

//+----------------------------------------------------------------------
//
//   Helper : PutViewLink
//
//   Handles a IHTMLDocument2 input so that we can set up table-of-links.
//   The second one handles strings, so that 
//   we can connect to "document" or to a specific URL
//
//-----------------------------------------------------------------------
HRESULT
CLayoutRect::PutViewLink(IHTMLDocument2 * pISlaveDoc )
{
    HRESULT hr = S_OK;
    IHTMLElement            * pIBody        = NULL;     // From input document
    IHTMLElement            * pIBodyNew     = NULL;     // From (slave) document copy.
    IHTMLDocument           * pINewSlaveDoc = NULL;
    IHTMLDocument4          * pINewSlaveDoc4= NULL;     // Copied document.
    IDispatch               * pIDDocNewSlave= NULL;     // Copied Document
    IElementBehaviorSiteOM2 * pIBS          = NULL;
    IHTMLElementDefaults    * pIPThis       = NULL;
    IOleCommandTarget       * pioctNewSlave = NULL;
    IHTMLElement            * pIElement     = NULL;
    IDispatch               * pIDDoc        = NULL;
    IHTMLDocument2          * pIThisDoc2    = NULL;
    BSTR                      bstrTagName   = NULL;
    BSTR                      bstrHTML      = NULL;
    BSTR                      bstrMedia     = NULL;
    VARIANT var;
    VariantInit(&var);


    if (!pISlaveDoc)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // Get the body and save its innerHTML
    hr = pISlaveDoc->get_body(&pIBody);
    if (FAILED(hr))
        goto Cleanup;
    if (!pIBody)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pIBody->get_innerHTML(&bstrHTML);
    if (FAILED(hr))
        goto Cleanup;
    if (!bstrHTML)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pIBody->get_tagName(&bstrTagName);
    if (FAILED(hr))
        goto Cleanup;
    if (!bstrTagName)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Set the media to print on the BODY markup before we parse in the stream string.
    bstrMedia = SysAllocString(_T("print"));
    if (!bstrMedia)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }


    // Create an element to act as the viewlinked document.
    Assert(_pPeerSite);
    hr = _pPeerSite->GetElement(&pIElement);
    if (FAILED(hr))
        goto Cleanup;
    if (!pIElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pIElement->get_document(&pIDDoc); 
    if (FAILED(hr))
        goto Cleanup;
    if (!pIDDoc)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    hr = pIDDoc->QueryInterface(IID_IHTMLDocument2, (void **)&pIThisDoc2);
    if (FAILED(hr))
        goto Cleanup;
    if (!pIThisDoc2)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pIThisDoc2->createElement(bstrTagName, &pIBodyNew);
    if (FAILED(hr))
        goto Cleanup;
    if (!pIBodyNew)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pIBodyNew->get_document(&pIDDocNewSlave);
    if (FAILED(hr))
        goto Cleanup;
    if (!pIDDocNewSlave)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pIDDocNewSlave->QueryInterface(IID_IHTMLDocument4, (void **)&pINewSlaveDoc4);
    if (FAILED(hr))
        goto Cleanup;
    if (!pINewSlaveDoc4)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    hr = pIDDocNewSlave->QueryInterface(IID_IOleCommandTarget, (void **)&pioctNewSlave);
    if (FAILED(hr))
        goto Cleanup;
    if (!pioctNewSlave)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    //
    //  (greglett) 11/27/2000
    //  There are two types of Print Media
    //  1. (per element) WYSIWYG mesurement. Set by the DeviceRect.
    //  2. (per markup)  A combination of "is paginated media", "is a print content document", and "should apply printing rules like no bg, media styles..."
    //     It is crucial to set the first two here right now.
    //     We only allowed print media to be set on a print template in 5.5 for a few reasons:
    //     1. The combination of the above three properties is arbitrary and confusing enough that it would be impossible to explain.
    //     2. Why would someone who is not a print template be interetsted in displaying as if printing?
    //     3. Incorrect worries about security issues in setting print media (URL spoofing, metafile running, &c...)
    //     The first two reasons are still valid, so Trident still blocks this for anything other than print templates in 6.0.
    //     This used to not be an issue, since print-templateness was a CDoc level thing.  Now that it is per markup...
    //     This is nonsensical. In fact, *no* paginated/print content documents should be print templates, and vice-versa.
    //     For Blackcomb, we really need to refactor what "Print Media" means.
    //     
    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = VB_TRUE;
    hr = pioctNewSlave->Exec( &CGID_MSHTML,
                           IDM_SETPRINTTEMPLATE,
                           NULL, 
                           &var, 
                           NULL);
    if (FAILED(hr))
        goto Cleanup;

    hr = pINewSlaveDoc4->put_media(bstrMedia);
    if (FAILED(hr))
        goto Cleanup;

    V_BOOL(&var) = VB_FALSE;
    hr = pioctNewSlave->Exec( &CGID_MSHTML,
                           IDM_SETPRINTTEMPLATE,
                           NULL, 
                           &var, 
                           NULL);
    if (FAILED(hr))
        goto Cleanup;


    // Reparse in the innerHTML, so that all media properties will get picked up
    hr = pIBodyNew->put_innerHTML(bstrHTML);
    if (FAILED(hr))
        goto Cleanup;

    // Viewlink the slave doc.
    Assert(_pPeerSite);
    hr = _pPeerSite->QueryInterface(IID_IElementBehaviorSiteOM2, (void**)&pIBS);
    if (FAILED(hr))
        goto Cleanup;
    if (!pIBS)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pIBS->GetDefaults(&pIPThis);
    if (FAILED(hr))
        goto Cleanup;
    if (!pIPThis)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pINewSlaveDoc4->QueryInterface(IID_IHTMLDocument, (void**)&pINewSlaveDoc);
    if (FAILED(hr))
        goto Cleanup;
    if (!pINewSlaveDoc)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pIPThis->putref_viewLink(pINewSlaveDoc);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pIBody);
    ReleaseInterface(pIBodyNew);
    ReleaseInterface(pIDDocNewSlave);
    ReleaseInterface(pINewSlaveDoc);
    ReleaseInterface(pINewSlaveDoc4);
    ReleaseInterface(pIPThis);
    ReleaseInterface(pIBS);
    ReleaseInterface(pioctNewSlave);
    ReleaseInterface(pIElement);
    ReleaseInterface(pIDDoc);
    ReleaseInterface(pIThisDoc2);
    SysFreeString(bstrHTML);
    SysFreeString(bstrTagName);
    SysFreeString(bstrMedia);
    return hr;
}

//+----------------------------------------------------------------------
//
//   Helper : PutViewLink
//
//   Handles a IHTMLDocument2 input so that we can set up table-of-links.
//   The second one handles strings, so that 
//   we can connect to "document" or to a specific URL
//
//-----------------------------------------------------------------------
#define UNICODE_MARKER 0xfeff
HRESULT
CLayoutRect::PutViewLink(IStream * pIStream)
{
    HRESULT                   hr            = S_OK;
    IHTMLElement            * pIElement     = NULL;
    IDispatch               * pIDDoc        = NULL;
    IHTMLDocument2          * pIThisDoc2    = NULL;
    IHTMLDocument2          * pISlaveDoc2   = NULL;
    IHTMLDocument4          * pISlaveDoc4   = NULL;
    IDispatch               * pIDDocSlave   = NULL;
    IHTMLElement            * pBodyNew      = NULL;
    IElementBehaviorSiteOM2 * pIBS          = NULL;
    IHTMLElementDefaults    * pIPThis       = NULL;
    IOleCommandTarget       * pioctSlave    = NULL;
    BSTR                      bstrBody      = NULL;
    BSTR                      bstrHTML      = NULL;
    BSTR                      bstrMedia     = NULL;
    VARIANT                   var;
    CBufferedStr              strContent;
    LARGE_INTEGER             lnOffset;

    VariantInit(&var);

    if (!pIStream)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    lnOffset.HighPart   = 0;
    lnOffset.LowPart    = 0;
    pIStream->Seek(lnOffset, STREAM_SEEK_SET, NULL);
    
    // Read the OE header.  We need the *whole* thing to pass in as an innerHTML.
    {
        BOOL    fUnicode;
        WCHAR   chUnicodeMarker = UNICODE_MARKER;
        WCHAR   achBufWC[1024];
        CHAR    achBufMB[1024];
        ULONG   cRead;
    
        hr = pIStream->Read(achBufWC, sizeof(WCHAR), &cRead);
        if (!hr)
        {
            fUnicode = (memcmp(achBufWC, &chUnicodeMarker, sizeof(WCHAR)) == 0);
            if (!fUnicode)
                pIStream->Seek(lnOffset, STREAM_SEEK_SET, NULL);    // Put it back!  We took off two real MB characters
            
            while (     hr == S_OK
                    &&  cRead > 0  )
            {
                if (fUnicode)
                {
                    hr = pIStream->Read(achBufWC, 1023 * sizeof(WCHAR), &cRead);
                    cRead /= sizeof(WCHAR);
                }
                else
                {
                    hr = pIStream->Read(achBufMB, 1023 * sizeof(CHAR), &cRead);
                    cRead = MultiByteToWideChar(CP_ACP, 0, achBufMB, cRead, achBufWC, 1023);
                }

                if (cRead > 0)
                {
                    achBufWC[cRead] = _T('\0');
                    strContent.QuickAppend(achBufWC);
                }
            }
        }
    }

    // Create a BODY to act as the viewlinked document.
    hr = _pPeerSite->GetElement(&pIElement);
    if (FAILED(hr))
        goto Cleanup;
    Assert(pIElement);

    hr = pIElement->get_document(&pIDDoc); 
    if (FAILED(hr))
        goto Cleanup;
    Assert(pIDDoc);
    
    bstrBody = SysAllocString(_T("BODY"));
    if (!bstrBody)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pIDDoc->QueryInterface(IID_IHTMLDocument2, (void **)&pIThisDoc2);
    if (FAILED(hr))
        goto Cleanup;
    Assert(pIThisDoc2);    

    hr = pIThisDoc2->createElement(bstrBody, &pBodyNew);
    if (FAILED(hr))
        goto Cleanup;
    Assert(pBodyNew);    

    bstrHTML = SysAllocString(strContent);
    if (!bstrHTML)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }    
   
    // Set the media to print on the BODY markup before we parse in the stream string.
    bstrMedia = SysAllocString(_T("print"));
    if (!bstrMedia)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pBodyNew->get_document(&pIDDocSlave);
    if (FAILED(hr))
        goto Cleanup;
    Assert(pIDDocSlave);

    hr = pIDDocSlave->QueryInterface(IID_IHTMLDocument4, (void **)&pISlaveDoc4);
    if (FAILED(hr))
        goto Cleanup;
    Assert(pISlaveDoc4);

    hr = pIDDocSlave->QueryInterface(IID_IOleCommandTarget, (void **)&pioctSlave);
    if (FAILED(hr))
        goto Cleanup;
    Assert(pioctSlave);
        
    //
    //  (greglett) 11/27/2000
    //  There are two types of Print Media
    //  1. (per element) WYSIWYG mesurement. Set by the DeviceRect.
    //  2. (per markup)  A combination of "is paginated media", "is a print content document", and "should apply printing rules like no bg, media styles..."
    //     It is crucial to set the first two here right now.
    //     We only allowed print media to be set on a print template in 5.5 for a few reasons:
    //     1. The combination of the above three properties is arbitrary and confusing enough that it would be impossible to explain.
    //     2. Why would someone who is not a print template be interetsted in displaying as if printing?
    //     3. Incorrect worries about security issues in setting print media (URL spoofing, metafile running, &c...)
    //     The first two reasons are still valid, so Trident still blocks this for anything other than print templates in 6.0.
    //     This used to not be an issue, since print-templateness was a CDoc level thing.  Now that it is per markup...
    //     This is nonsensical. In fact, *no* paginated/print content documents should be print templates, and vice-versa.
    //     For Blackcomb, we really need to refactor what "Print Media" means.
    //     
    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = VB_TRUE;
    hr = pioctSlave->Exec( &CGID_MSHTML,
                           IDM_SETPRINTTEMPLATE,
                           NULL, 
                           &var, 
                           NULL);
    if (FAILED(hr))
        goto Cleanup;

    hr = pISlaveDoc4->put_media(bstrMedia);
    if (FAILED(hr))
        goto Cleanup;

    V_BOOL(&var) = VB_FALSE;
    hr = pioctSlave->Exec( &CGID_MSHTML,
                           IDM_SETPRINTTEMPLATE,
                           NULL, 
                           &var, 
                           NULL);
    if (FAILED(hr))
        goto Cleanup;

    // innerHTML in the contents of the stream as the new document...
    hr = pBodyNew->put_innerHTML(bstrHTML);
    if (FAILED(hr))
        goto Cleanup;

    // ...and viewlink the document.
    hr = pIDDocSlave->QueryInterface(IID_IHTMLDocument2, (void **)&pISlaveDoc2);
    if (FAILED(hr))
        goto Cleanup;
    Assert(pISlaveDoc2);
    
    Assert(_pPeerSite);
    hr = _pPeerSite->QueryInterface(IID_IElementBehaviorSiteOM2, (void**)&pIBS);
    if (FAILED(hr))
        goto Cleanup;
    Assert(pIBS);

    hr = pIBS->GetDefaults(&pIPThis);
    if (FAILED(hr))
        goto Cleanup;
    Assert(pIPThis);

    hr = pIPThis->putref_viewLink(pISlaveDoc2);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pIElement);
    ReleaseInterface(pIDDoc);
    ReleaseInterface(pISlaveDoc2);
    ReleaseInterface(pISlaveDoc4);
    ReleaseInterface(pIDDocSlave);
    ReleaseInterface(pIThisDoc2);
    ReleaseInterface(pBodyNew);
    ReleaseInterface(pIPThis);
    ReleaseInterface(pIBS);
    ReleaseInterface(pioctSlave);
    SysFreeString(bstrBody);
    SysFreeString(bstrHTML);
    SysFreeString(bstrMedia);
    return hr;
}

//+----------------------------------------------------------------------
//
//   Helper : PutViewLink
//
//   Handles a BSTR input to connect to "document" or a specific URL.
//
//-----------------------------------------------------------------------
HRESULT
CLayoutRect::PutViewLink(BSTR bstrSrc)
{

    HRESULT                 hr;
    IElementBehaviorSite  * pIPeerSite         = _pPeerSite; // interface to our peer
    IHTMLElement          * pIThis             = NULL;     // Interface to this element
    IHTMLElementDefaults  * pIPThis            = NULL;     // Interface to this's element defaults
    IDispatch             * pIThisDocDispatch  = NULL;     // The doc we're in
    IHTMLDocument4        * pIThisDoc4         = NULL;     // Same, so we can get to contentFromUrl
    IHTMLDocument2        * pISlaveDoc         = NULL;     // Slave document
    IElementBehaviorSiteOM2 * pIBS             = NULL;
    IHTMLDialog           * pIDialog           = NULL;
    IServiceProvider      * pIDocSrvProv       = NULL;
    IHTMLEventObj2        * pIEventObj         = NULL;
    BSTR                    bstrOptions        = NULL;
    BSTR                    bstrURL            = NULL;
    VARIANT                 vunkDialogArg;
    VARIANT                 vbstrContentDoc;
    VARIANT                 vbIsXML;

    VariantInit(&vunkDialogArg);
    VariantInit(&vbstrContentDoc);
    VariantInit(&vbIsXML);

    Assert(bstrSrc);
    if (!bstrSrc)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = pIPeerSite->GetElement(&pIThis);
    if (FAILED(hr))
        goto Cleanup;

    hr = pIThis->get_document(&pIThisDocDispatch); 
    if (FAILED(hr))
        goto Cleanup;

    hr = pIThisDocDispatch->QueryInterface(IID_IHTMLDocument4, (void**)&pIThisDoc4);
    if (FAILED(hr))
        goto Cleanup;

    //  Get the dialog arguments, if they exist
    hr = pIThisDocDispatch->QueryInterface(IID_IServiceProvider, (void **)&pIDocSrvProv);
    if (!FAILED(hr))
    {
        // The keyword "document" maps to the dialog argument __IE_ContentDocumentUrl.  Go after it.
        hr = pIDocSrvProv->QueryService(IID_IHTMLDialog, IID_IHTMLDialog, (void**)&pIDialog);
        if (!FAILED(hr))
        {            
            hr = pIDialog->get_dialogArguments(&vunkDialogArg);
            if (FAILED(hr) || V_VT(&vunkDialogArg) != VT_UNKNOWN)
                goto Cleanup;

            hr = V_UNKNOWN(&vunkDialogArg)->QueryInterface(IID_IHTMLEventObj2, (void**)&pIEventObj);
            if (FAILED(hr))
                goto Cleanup;

        }
    }

    if (V_VT(&vunkDialogArg) != VT_UNKNOWN)
    {
        bstrOptions = SysAllocString( _T("print") );
        bstrURL     = bstrSrc;
    }
    else
    {
        BSTR    bstrTarget=NULL;

        bstrTarget = SysAllocString(_T("__IE_ContentDocumentUrl"));
        if (!bstrTarget)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = pIEventObj->getAttribute(bstrTarget, 0, &vbstrContentDoc);

        SysFreeString(bstrTarget);
        if (FAILED(hr) || V_VT(&vbstrContentDoc) != VT_BSTR)
            goto Cleanup;

        // We now have the content document URL in vbstrContentDoc.  Either
    
        if (    !_tcsicmp(bstrSrc, _T("document"))
            ||  !_tcsicmp(bstrSrc, V_BSTR(&vbstrContentDoc)) )
        {
            bstrTarget = SysAllocString(_T("__IE_ParsedXML"));
            if (!bstrTarget)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            hr = pIEventObj->getAttribute(bstrTarget, 0, &vbIsXML);

            SysFreeString(bstrTarget);

            // Are we an already parsed XML document (with HTML:xxx tags)?
            if (    !FAILED(hr)
                &&  V_VT(&vbIsXML) == VT_BOOL
                &&  V_BOOL(&vbIsXML) == VB_TRUE )
            {
                bstrOptions = SysAllocString( _T("print xml") );
            }
            else
            {
                bstrOptions = SysAllocString( _T("print") );
            }        

            bstrURL = V_BSTR(&vbstrContentDoc);
        }
        else
        {
            bstrOptions = SysAllocString( _T("print") );
            bstrURL     = bstrSrc;            
        }
    }

    if ( !bstrOptions )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    Assert(bstrURL);    
    hr = pIThisDoc4->createDocumentFromUrl(bstrURL, bstrOptions, &pISlaveDoc);

    if (FAILED(hr))
        goto Cleanup;

    hr = pIPeerSite->QueryInterface(IID_IElementBehaviorSiteOM2, (void**)&pIBS);
    if (FAILED(hr))
        goto Cleanup;

    hr = pIBS->GetDefaults(&pIPThis);
    if (FAILED(hr))
        goto Cleanup;

    hr = pIPThis->putref_viewLink(pISlaveDoc);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    SysFreeString( bstrOptions );
    ReleaseInterface(pIThis);
    ReleaseInterface(pIPThis);
    ReleaseInterface(pIThisDocDispatch);
    ReleaseInterface(pIThisDoc4);
    ReleaseInterface(pISlaveDoc);
    ReleaseInterface(pIBS);
    ReleaseInterface(pIDialog);
    ReleaseInterface(pIDocSrvProv);
    ReleaseInterface(pIEventObj);
    VariantClear(&vunkDialogArg);                
    VariantClear(&vbstrContentDoc);
    return hr;
}

//+----------------------------------------------------------------------
//
//   Helper : PutBlankViewLink
//
//   Does a PutViewLink for "about:blank"
//
//-----------------------------------------------------------------------
HRESULT CLayoutRect::PutBlankViewLink()
{
    HRESULT hr;

    BSTR bstrBlank = SysAllocString(_T("about:blank"));
    if (!bstrBlank)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = PutViewLink(bstrBlank);

Cleanup:
    if (bstrBlank)
        SysFreeString(bstrBlank);

    return hr;
}



//+----------------------------------------------------------------------------
//
//  Member : get_honorPageBreaks - ILayoutRect property imple
//         : put_honorPageBreaks - ILayoutRect property imple
//
//  Synopsis : Get'r and put'r for the boolean property on whether to honorPageBreaks
//          within this tag. By default this is true.
//
//+----------------------------------------------------------------------------
STDMETHODIMP
CLayoutRect::get_honorPageBreaks (VARIANT_BOOL * pVB)
{
    TEMPLATESECURITYCHECK()

    return _aryAttributes[eHonorPageBreaks].GetAsBOOL(pVB);
}

STDMETHODIMP
CLayoutRect::put_honorPageBreaks (VARIANT_BOOL v)
{
    TEMPLATESECURITYCHECK()

    return _aryAttributes[eHonorPageBreaks].Set(v);
}

//+----------------------------------------------------------------------------
//
//  Member : get_honorPageRules - ILayoutRect property imple
//         : put_honorPageRules - ILayoutRect property imple
//
//  Synopsis : Get'r and put'r for the boolean property on whether to honorPageRules
//          within this tag. By default this is true.
//
//+----------------------------------------------------------------------------
STDMETHODIMP
CLayoutRect::get_honorPageRules (VARIANT_BOOL * pVB)
{
    TEMPLATESECURITYCHECK()

    return _aryAttributes[eHonorPageRules].GetAsBOOL(pVB);
}

STDMETHODIMP
CLayoutRect::put_honorPageRules (VARIANT_BOOL v)
{
    TEMPLATESECURITYCHECK()

    return _aryAttributes[eHonorPageRules].Set(v);
}

//+----------------------------------------------------------------------------
//
//  Member : get_nextRectElement - ILayoutRect property imple
//         : put_nextRectElement - ILayoutRect property imple
//
//  Synopsis : Get'r and put'r for the IDispatch property for the nextRect.
//
//+----------------------------------------------------------------------------
STDMETHODIMP
CLayoutRect::get_nextRectElement (IDispatch ** ppElem)
{
    TEMPLATESECURITYCHECK()

    // (greglett) This is not currently used, and we don't want to do the work to get this
    // working in the Whistler timeframe.
    return E_NOTIMPL;

    //return _aryAttributes[eNextRectElement].GetAsDispatch( ppElem );
}

STDMETHODIMP
CLayoutRect::put_nextRectElement (IDispatch * pElem)
{
    TEMPLATESECURITYCHECK()

    // (greglett) This is not currently used, and we don't want to do the work to get this
    // working in the Whistler timeframe.
    return E_NOTIMPL;

    //return _aryAttributes[eNextRectElement].Set( pElem );
}

//+----------------------------------------------------------------------------
//
//  Member : get_contentDocument - ILayoutRect property imple
//         : put_contentDocument - ILayoutRect property imple
//
//  Synopsis : Get'r and put'r for the IDispatch property for the contentDocument.
//
//+----------------------------------------------------------------------------

STDMETHODIMP
CLayoutRect::get_contentDocument(IDispatch ** ppDoc)
{
    TEMPLATESECURITYCHECK()

    // get peer, get IHTMLElement, get ViewLink, get document
    HRESULT hr = S_OK;
    IElementBehaviorSite    * pPeerSite     = _pPeerSite;
    IElementBehaviorSiteOM2 * pIBS          = NULL;
    IHTMLElementDefaults    * pIPThis       = NULL;

    if (!ppDoc)
        return E_POINTER;

    *ppDoc = NULL;

    hr = pPeerSite->QueryInterface(IID_IElementBehaviorSiteOM2, (void**)&pIBS);
    if (hr)
        goto Cleanup;

    hr = pIBS->GetDefaults(&pIPThis);
    if (hr)
        goto Cleanup;

    hr = pIPThis->get_viewLink((IHTMLDocument **)ppDoc);
    
    hr = S_OK;

Cleanup:
    ReleaseInterface(pIBS);
    ReleaseInterface(pIPThis);
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member : Load  - IPersistPropertyBag2 property impl
//
//  Synopsis : This gives us a chance to pull properties from the property bag
//      created when the element's attributes were parsed in. Since we handle
//      all the getter/putter logic, our copy of the value will always be the 
//      current one.  This gives this behavior full control over the attribures
//      that it is interested in.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CLayoutRect::Load ( IPropertyBag2 *pPropBag, IErrorLog *pErrLog)
{
    HRESULT        hr = S_OK;
    IPropertyBag * pBag = NULL;
    CDataObject  * pDO = NULL;
    long           i=0;
 
    if (!pPropBag)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = pPropBag->QueryInterface(IID_IPropertyBag, (void**) &pBag);
    if (hr || !pBag)
        goto Cleanup;

    // loop through all the attributes and load them
    for (pDO = &_aryAttributes[0], i=0;
         pDO && i< eAttrTotal;
         pDO++, i++)
    {
        pBag->Read(pDO->_pstrPropertyName, &pDO->_varValue, pErrLog);
    }

    BSTR bstr;
    _aryAttributes[eContentSrc].GetAsBSTR(&bstr);
    if (bstr)
    {
        if (TemplateAccessAllowed(_pPeerSite))
            PutViewLink(bstr);
        else
            PutBlankViewLink();

    }

Cleanup:
    ReleaseInterface(pBag);
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : Save  - IPersistPropertyBag2 property impl
//
//  Synopsis : Like the load, above, this allows us to save the attributes which
//      we control.  This is all part of fully owning our element's behavior, OM
//      and attributes. 
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CLayoutRect::Save ( IPropertyBag2 *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    HRESULT        hr = S_OK;
    IPropertyBag * pBag = NULL;
    CDataObject  * pDO = NULL;
    long           i=0;

    // verify parameters
    if (!pPropBag)
    {
        hr = E_POINTER;
        goto Cleanup;
    }


    // now go through our properties and save them if they are dirty, or if
    // a save-All is required.
    //---------------------------------------------------------------------

    hr = pPropBag->QueryInterface(IID_IPropertyBag, (void**) &pBag);
    if (hr || !pBag)
        goto Cleanup;

    for (pDO = &_aryAttributes[0], i=0;
         pDO && i< eAttrTotal;
         pDO++, i++)
    {
        if (pDO->IsDirty() || fSaveAllProperties)
        {
            if (V_VT(&pDO->_varValue) != VT_DISPATCH)
            {
                pBag->Write(pDO->_pstrPropertyName, &(pDO->_varValue));

                if (fClearDirty)
                    pDO->_fDirty = FALSE;
            }
        }
    }

Cleanup:
    ReleaseInterface(pBag);

    return hr;
}

  
//+-----------------------------------------------------------------------------
//
//  Method: Draw, IHTMLPainter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CLayoutRect::Draw(RECT rcBounds, RECT rcUpdate, LONG lDrawFlags, HDC hdc,
                         LPVOID pvDrawObject)
{
    return E_NOTIMPL;
}

//+-----------------------------------------------------------------------------
//
//  Method: GetRenderInfo, IHTMLPainter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CLayoutRect::GetPainterInfo(HTML_PAINTER_INFO * pInfo)
{
    Assert(pInfo != NULL);

    *pInfo = _hpi;

    return S_OK;
}


//+-----------------------------------------------------------------------------
//
//  Method: HitTestPoint, IHTMLPainter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CLayoutRect::HitTestPoint(POINT pt, BOOL * pbHit, LONG *plPartID)
{
    Assert(pbHit != NULL);

    *pbHit = TRUE;

    return S_OK;
}

//+-----------------------------------------------------------------------------
//
//  Method: OnResize, IHTMLPainter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CLayoutRect::OnResize(SIZE size)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\peerfact.cxx ===
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#include "iextag.h"
#include "peerfact.h"
#include "ccaps.h"
#include "homepg.h"
#include "persist.hxx"
#include "download.h"

#ifndef __X_HTMLAREA_HXX_
#define __X_HTMLAREA_HXX_
#include "htmlarea.hxx"
#endif

#ifndef __X_SELECT_HXX_
#define __X_SELECT_HXX_
#include "select.hxx"
#endif

#ifndef __X_SELITEM_HXX_
#define __X_SELITEM_HXX_
#include "selitem.hxx"
#endif

#ifndef __X_COMBOBOX_HXX_
#define __X_COMBOBOX_HXX_
#include "combobox.hxx"
#endif

#ifndef __X_CHECKBOX_HXX_
#define __X_CHECKBOX_HXX_
#include "checkbox.hxx"
#endif

#ifndef __X_RADIO_HXX_
#define __X_RADIO_HXX_
#include "radio.hxx"
#endif

#ifndef __X_USERDATA_HXX_
#define __X_USERDATA_HXX_
#include "userdata.hxx"
#endif

#ifndef __X_RECTPEER_HXX_
#define __X_RECTPEER_HXX_
#include "rectpeer.hxx"
#endif

#ifndef __X_DEVICERECT_HXX_
#define __X_DEVICERECT_HXX_
#include "devicerect.hxx"
#endif

#ifndef __X_TMPPRINT_HXX_
#define __X_TMPPRINT_HXX_
#include "tmpprint.hxx"
#endif

#ifndef __X_HEADFOOT_HXX_
#define __X_HEADFOOT_HXX_
#include "headfoot.hxx"
#endif

#ifndef __X_SCROLLBAR_HXX_
#define __X_SCROLLBAR_HXX_
#include "scrllbar.hxx"
#endif

#ifndef __X_SPINBTTN_HXX_
#define __X_SPINBTTN_HXX_
#include "spinbttn.hxx"
#endif

#ifndef __X_SLIDEBAR_HXX_
#define __X_SLIDEBAR_HXX_
#include "slidebar.hxx"
#endif

#ifndef UNIX // UNIX doesn't support this.
#include "httpwfh.h"
#include "ancrclk.h"
#endif


//+-----------------------------------------------------------
//
// Member:  CPeerFactory constructor
//
//------------------------------------------------------------

CPeerFactory::CPeerFactory()
{
}

//+-----------------------------------------------------------
//
// Member:  CPeerFactory destructor
//
//------------------------------------------------------------

CPeerFactory::~CPeerFactory()
{
}

//+-----------------------------------------------------------
//
// Member:  behavior desc map macros
//
//------------------------------------------------------------

typedef HRESULT FN_CREATEINSTANCE (IElementBehavior ** ppBehavior);

struct BEHAVIOR_DESC
{
	LPCTSTR                 pchName;
    LPCTSTR                 pchTagName;
    LPCTSTR                 pchBaseTagName;
	FN_CREATEINSTANCE *     pfnCreateInstance;
};

#define DECLARE_BEHAVIOR(className)                                     \
    HRESULT className##_CreateInstance(IElementBehavior ** ppBehavior)  \
    {                                                                   \
        HRESULT                 hr;                                     \
        CComObject<className> * pInstance;                              \
                                                                        \
        hr = CComObject<className>::CreateInstance(&pInstance);         \
        if (hr)                                                         \
            goto Cleanup;                                               \
                                                                        \
        hr = pInstance->QueryInterface(                                 \
                IID_IElementBehavior, (void**) ppBehavior);             \
                                                                        \
    Cleanup:                                                            \
        return hr;                                                      \
    }                                                                   \


#define BEGIN_BEHAVIORS_MAP(x)                                      static BEHAVIOR_DESC x[] = {
#define END_BEHAVIORS_MAP()                                         { NULL, NULL, NULL, NULL }};
#define BEHAVIOR_ENTRY(className, name, tagName, baseTagName)       { name, tagName, baseTagName, className##_CreateInstance},

//+-----------------------------------------------------------
//
//  Behaviors map
//
//  To add a new entry: execute steps 1 and 2
//
//------------------------------------------------------------

//
// STEP 1.
//

DECLARE_BEHAVIOR(CHtmlArea)
DECLARE_BEHAVIOR(CCombobox)
DECLARE_BEHAVIOR(CIESelectElement)
DECLARE_BEHAVIOR(CIEOptionElement)
DECLARE_BEHAVIOR(CCheckBox)
DECLARE_BEHAVIOR(CRadioButton)
DECLARE_BEHAVIOR(CLayoutRect)
DECLARE_BEHAVIOR(CDeviceRect)
DECLARE_BEHAVIOR(CTemplatePrinter)
DECLARE_BEHAVIOR(CHeaderFooter)
DECLARE_BEHAVIOR(CScrollBar)
DECLARE_BEHAVIOR(CSpinButton)
DECLARE_BEHAVIOR(CSliderBar)
DECLARE_BEHAVIOR(CClientCaps)
DECLARE_BEHAVIOR(CHomePage)
DECLARE_BEHAVIOR(CPersistUserData)
DECLARE_BEHAVIOR(CPersistHistory)
DECLARE_BEHAVIOR(CPersistShortcut)
DECLARE_BEHAVIOR(CPersistSnapshot)
DECLARE_BEHAVIOR(CDownloadBehavior)
DECLARE_BEHAVIOR(Cwfolders)
DECLARE_BEHAVIOR(CAnchorClick)

//
// STEP 2.
//

BEGIN_BEHAVIORS_MAP(_BehaviorDescMap)

    //             className            behaviorName            tagName                 baseTagName
#if DBG==1
    BEHAVIOR_ENTRY(CCheckBox,           _T("checkBox"),         _T("CHECKBOX"),         NULL           ) // keep first in the list as it is a perf benchmark (alexz)
    BEHAVIOR_ENTRY(CRadioButton,        _T("radioButton"),      _T("RADIOBUTTON"),      NULL           ) 
    BEHAVIOR_ENTRY(CHtmlArea,           _T("htmlArea"),         _T("HTMLAREA"),         NULL           )
    BEHAVIOR_ENTRY(CCombobox,           _T("comboBox"),         _T("COMBOBOX"),         NULL           )
    BEHAVIOR_ENTRY(CIESelectElement,    _T("select"),           _T("SELECT"),           NULL           )
    BEHAVIOR_ENTRY(CIEOptionElement,    _T("option"),           _T("OPTION"),           NULL           )
    BEHAVIOR_ENTRY(CScrollBar,          _T("scrollBar"),        _T("SCROLLBAR"),        NULL           )
    BEHAVIOR_ENTRY(CSpinButton,         _T("spinButton"),       _T("SPINBUTTON"),       NULL           )
    BEHAVIOR_ENTRY(CSliderBar,          _T("sliderBar"),        _T("SLIDERBAR"),        NULL           )
#endif
    BEHAVIOR_ENTRY(CLayoutRect,         _T("layoutRect"),       _T("LAYOUTRECT"),       NULL           )
    BEHAVIOR_ENTRY(CDeviceRect,         _T("deviceRect"),       _T("DEVICERECT"),       NULL           )
    BEHAVIOR_ENTRY(CTemplatePrinter,    _T("templatePrinter"),  _T("TEMPLATEPRINTER"),  NULL           )
    BEHAVIOR_ENTRY(CHeaderFooter,       _T("headerFooter"),     _T("HEADERFOOTER"),     NULL           )

    BEHAVIOR_ENTRY(CClientCaps,         _T("clientCaps"),    NULL,                   NULL           )
    BEHAVIOR_ENTRY(CHomePage,           _T("homePage"),      NULL,                   NULL           )
    BEHAVIOR_ENTRY(CPersistUserData,    _T("userData"),      NULL,                   NULL           )
    BEHAVIOR_ENTRY(CPersistHistory,     _T("saveHistory"),   NULL,                   NULL           )
    BEHAVIOR_ENTRY(CPersistShortcut,    _T("saveFavorite"),  NULL,                   NULL           )
    BEHAVIOR_ENTRY(CPersistSnapshot,    _T("saveSnapshot"),  NULL,                   NULL           )
    BEHAVIOR_ENTRY(CDownloadBehavior,   _T("download"),      NULL,                   NULL           )

#ifndef UNIX // UNIX doesn't support these
    BEHAVIOR_ENTRY(Cwfolders,           _T("httpFolder"),    NULL,                   NULL           )
    BEHAVIOR_ENTRY(CAnchorClick,        _T("anchorClick"),   NULL,                   NULL           )
#endif

END_BEHAVIORS_MAP()

//+-----------------------------------------------------------
//
// Member:      CPeerFactory::FindBehavior
//
//------------------------------------------------------------

STDMETHODIMP
CPeerFactory::FindBehavior(
    BSTR                    bstrName,
    BSTR	                bstrUrl, 
    IElementBehaviorSite *  pSite,
    IElementBehavior **     ppBehavior)
{
    HRESULT             hr = E_FAIL;
    IHTMLElement *      pElement = NULL;
    BSTR                bstrTagName = NULL;
    IClassFactory *     pFactory = NULL;
    BEHAVIOR_DESC *     pDesc;

    if (!ppBehavior)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // ensure name
    //

    if (!bstrName)
    {
        hr = pSite->GetElement(&pElement);
        if (hr)
            goto Cleanup;

        hr = pElement->get_tagName(&bstrTagName);
        if (hr)
            goto Cleanup;

        bstrName = bstrTagName;
    }

    //
    // lookup
    //

    Assert (bstrName);

    *ppBehavior = NULL;

    for (pDesc = _BehaviorDescMap; pDesc->pchName; pDesc++)
    {
        if (0 == StrCmpICW(bstrName, pDesc->pchName))
        {
            hr = pDesc->pfnCreateInstance(ppBehavior);
            break; // done
        }
    }

Cleanup:
    ReleaseInterface (pElement);
    ReleaseInterface (pFactory);

    if (bstrTagName)
        SysFreeString (bstrTagName);

    return hr;
}

//+-----------------------------------------------------------
//
// Member:      CPeerFactory::Create, per IElementNamespaceFactory
//
//------------------------------------------------------------

HRESULT
CPeerFactory::Create(IElementNamespace * pNamespace)
{
    HRESULT             hr = S_OK;
    BEHAVIOR_DESC *     pDesc;
    BSTR                bstrTagName;

    for (pDesc = _BehaviorDescMap; pDesc->pchName; pDesc++)
    {
        if (pDesc->pchTagName)
        {
            // CONSIDER (alexz) it could be optimized so to avoid these 2 SysAllocString-s
            Assert( !pDesc->pchBaseTagName && "Base tag has been moved to a private debug-only testing interface.  Talk to JHarding" );
            bstrTagName = SysAllocString(pDesc->pchTagName);

            hr = pNamespace->AddTag(bstrTagName, 0);

            SysFreeString(bstrTagName);

            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\scrllbar.cxx ===
//+------------------------------------------------------------------
//
// Microsoft IEPEERS
// Copyright (C) Microsoft Corporation, 1999.
//
// File:        iextags\scrllbar.cxx
//
// Contents:    Scrollbar Control
//
// Classes:     CScrollBar
//
// Interfaces:  IScrollBar
//
//-------------------------------------------------------------------

#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"

#include "utils.hxx"

#include "utbutton.hxx"
#include "scrllbar.hxx"

#define CheckResult(x) { hr = x; if (FAILED(hr)) goto Cleanup; }

/////////////////////////////////////////////////////////////////////////////
//
// CScrollBar
//
/////////////////////////////////////////////////////////////////////////////

const CBaseCtl::PROPDESC CScrollBar::s_propdesc[] = 
{
    {_T("max"), VT_I4, 100},
    {_T("min"), VT_I4, 0},
    {_T("unit"), VT_I4, 1},
    {_T("block"), VT_I4, 10},
    {_T("visible-units"), VT_I4, 20},
    {_T("position"), VT_I4, 0},
    {_T("orientation"), VT_BSTR, 0, _T("horizontal")},
    NULL
};

enum
{
    eMax = 0,
    eMin,
    eUnit,
    eBlock,
    eVisibleUnits,
    ePosition,
    eOrientation,
};

//+------------------------------------------------------------------------
//
//  Members:    CScrollBar::CScrollBar
//              CScrollBar::~CScrollBar
//
//  Synopsis:   Constructor/Destructor
//
//-------------------------------------------------------------------------

CScrollBar::CScrollBar()
{
}

CScrollBar::~CScrollBar()
{
    if (_pSinkBlockInc)
    {
        delete _pSinkBlockInc;
    }
    if (_pSinkBlockDec)
    {
        delete _pSinkBlockDec;
    }
    if (_pSinkSlider)
    {
        delete _pSinkSlider;
    }
    if (_pSinkDelayTimer)
    {
        delete _pSinkDelayTimer;
    }
    if (_pSinkRepeatTimer)
    {
        delete _pSinkRepeatTimer;
    }
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::Init()
//
// Synopsis:    Set up the scroll bar's events
//
// Arguments:   None
//
// Returns:     Success if the control is setup correctly.
//
//-------------------------------------------------------------------


HRESULT
CScrollBar::Init()
{
    HRESULT hr = S_OK;
    CContextAccess  a(_pSite);

    a.Open(CA_ELEM | CA_DEFAULTS | CA_SITEOM | CA_DEFAULTS);

    //
    // Register the scrollbar name
    //

    CheckResult( a.SiteOM()->RegisterName(_T("scrollbar")));

    //
    // Register for events
    //

    CheckResult( AttachEvent(EVENT_ONMOUSEUP, &a));
    CheckResult( AttachEvent(EVENT_ONMOUSEDOWN, &a));
    CheckResult( AttachEvent(EVENT_ONKEYDOWN, &a));
    CheckResult( AttachEvent(EVENT_ONPROPERTYCHANGE, &a));
    CheckResult( AttachEvent(EVENT_ONSELECTSTART, &a));
    CheckResult( AttachEvent(EVENT_ONFOCUS, &a));
    CheckResult( AttachEvent(EVENT_ONBLUR, &a));

    // We want to be able to receive keyboard focus

    CheckResult( a.Defaults()->put_tabStop(VB_TRUE));
    CheckResult( a.Defaults()->put_viewMasterTab(VB_TRUE));

    //
    // Register the scrollbar's events
    //

    CheckResult( RegisterEvent(a.SiteOM(), CComBSTR("onscroll"), &_lOnScrollCookie));
    CheckResult( RegisterEvent(a.SiteOM(), CComBSTR("onchange"), &_lOnChangeCookie));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::Detach()
//
// Synopsis:    Releases interfaces.
//
// Arguments:   None
//
// Returns:     S_OK
//
//-------------------------------------------------------------------

HRESULT
CScrollBar::Detach()
{
    _pIncrementer->Unload();
    _pDecrementer->Unload();
    _pSliderThumb->Unload();

    ReleaseInterface(_pBlockInc);
    ReleaseInterface(_pBlockDec);
    ReleaseInterface(_pSliderBar);
    ReleaseInterface(_pContainer);

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::OnContentReady()
//
// Synopsis:    Called when the HTML content for the control is ready.
//
// Arguments:   None
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------

HRESULT
CScrollBar::OnContentReady()
{
    HRESULT hr = S_OK;

    //
    // Cache the properties
    //

    CheckResult( ReadProperties());

    //
    // Create the button
    //

    CheckResult( BuildContainer());
    CheckResult( BuildDecrementer());
    CheckResult( BuildSliderBar());
    CheckResult( BuildBlockDecrementer());
    CheckResult( BuildSliderThumb());
    CheckResult( BuildBlockIncrementer());
    CheckResult( BuildIncrementer());

    //
    // Calculate dimensions and layout correctly
    //

    CheckResult( Layout());
    
Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::OnPropertyChange()
//
// Synopsis:    Called when the scrollbar property changes.  Gives us the 
//              chance to redraw if the scrollbar is changed dynamically
//
// Arguments:   Names of changes property
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------

HRESULT
CScrollBar::OnPropertyChange(CEventObjectAccess *pEvent, BSTR propertyName)
{
    HRESULT hr = S_OK;

    CheckResult( Layout());

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::OnMouseDown()
//
// Synopsis:    Called to handel 'onmousedown' event; does a page inc/dec
//              Sets focus on element triggering an onfocus event
//
// Arguments:   Event Object
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------


HRESULT
CScrollBar::OnMouseDown(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2))

    CheckResult( a.Elem2()->focus());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::OnKeyDown()
//
// Synopsis:    Called to handle 'onmouseup' event; does a page inc/dec
//
// Arguments:   Event Object
//
// Returns:     Success if the control is handled property.
//
//-------------------------------------------------------------------


HRESULT
CScrollBar::OnKeyDown(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    long lKeyCode;

    CheckResult( pEvent->GetKeyCode(&lKeyCode));

    switch (lKeyCode)
    {
        case VK_END:            
        {
            _lCurrentPosition = _lMaxPosition;

            CheckResult( SetThumbPosition( _lCurrentPosition ));
            break; 
        }

        case VK_HOME:
        {
            _lCurrentPosition = _lMinPosition;

            CheckResult( SetThumbPosition( _lCurrentPosition ));
            break;
        }

        case VK_NEXT:
        {
            _lCurIncrement = _lBlockIncrement;
            
            CheckResult( DoIncrement());
            break;
        }

        case VK_PRIOR:
        {
            _lCurIncrement = - _lBlockIncrement;
            
            CheckResult( DoIncrement());
            break;
        }

        case VK_DOWN:
        case VK_RIGHT:
        {
            _lCurIncrement = _lUnitIncrement;

            CheckResult( DoIncrement());
            break;
        }
        
        case VK_UP:
        case VK_LEFT:
        {
            _lCurIncrement = - _lUnitIncrement;

            CheckResult( DoIncrement());
            break;
        }
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::OnMouseUp()
//
// Synopsis:    Called to handle 'onmouseup' event; does a page inc/dec
//
// Arguments:   Event Object
//
// Returns:     Success if the control is handled property.
//
//-------------------------------------------------------------------


HRESULT
CScrollBar::OnMouseUp(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::OnSelectStart
//
// Synopsis:    Called to handel 'onclick' event
//
// Arguments:   Names of changes property
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------

HRESULT
CScrollBar::OnSelectStart(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CheckResult( pEvent->EventObj()->put_cancelBubble( VARIANT_TRUE ));
    CheckResult( pEvent->EventObj()->put_returnValue( CComVariant(false) ));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::BuildContainer()
//
// Synopsis:    Builds the scrollbar container DIV.
//
// Arguments:   None
//
// Returns:     Success if the control is created correctly.
//
//-------------------------------------------------------------------



HRESULT
CScrollBar::BuildContainer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLStyle> pStyle;

    CComPtr<IDispatch> pDispDocLink;
    CComPtr<IHTMLDocument2> pDocLink;

    CComBSTR    bstr;
    CComVariant color;

    CContextAccess a(_pSite);
    
    CheckResult( GetScrollbarColor(&color));

    hr = a.Open( CA_ELEM | CA_STYLE | CA_DEFAULTS);
    if (FAILED(hr))
        goto Cleanup;

    //
    //  Get the height and width of behavior element object
    //

    hr = a.Style()->get_pixelWidth(&_width);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Style()->get_pixelHeight(&_height);
    if (FAILED(hr))
        goto Cleanup;

    //
    //  Make sure that _width and _height are reasonable
    //

    CheckResult( AdjustHeightAndWidth());

    hr = GetHTMLDocument(_pSite, &pDoc);
    if (FAILED(hr))
        goto Cleanup;

    hr = pDoc->createElement(CComBSTR("div"), &_pContainer);
    if (FAILED(hr))
        goto Cleanup;

    hr = _pContainer->get_style(&pStyle);
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyle->put_pixelWidth(_width);
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyle->put_pixelHeight(_height);
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyle->put_backgroundColor(color);
    if (FAILED(hr))
        goto Cleanup;

    hr = pStyle->put_overflow(CComBSTR("hidden"));
    if (FAILED(hr))
        goto Cleanup;


    //
    // Set up the view link
    //

    CheckResult( _pContainer->get_document(&pDispDocLink));
    CheckResult( pDispDocLink->QueryInterface(IID_IHTMLDocument2, (void**) &pDocLink));
    CheckResult( a.Defaults()->putref_viewLink(pDocLink));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::AdjustHeightAndWidth()
//
// Synopsis:    Verifies that height and width are sane and sets to 
//              rational values if not.
//
// Arguments:   none
//
// Returns:     S_OK if all goes will
//
//-------------------------------------------------------------------

HRESULT 
CScrollBar::AdjustHeightAndWidth()
{
    HRESULT hr = S_OK;

    CVariant        width, height;
    CContextAccess  a(_pSite);

    a.Open( CA_STYLE );

    CheckResult( a.Style()->get_width(&width));
    CheckResult( a.Style()->get_height(&height));

    if(_eoOrientation == Horizontal) 
    {
        if(height.IsEmpty() || ((V_VT(&height) == VT_BSTR) && (V_BSTR(&height) == NULL)) ) 
        {
            _height = GetSystemMetrics(SM_CYHSCROLL);
        }   
        if(width.IsEmpty() || ((V_VT(&width) == VT_BSTR) && (V_BSTR(&width) == NULL)))
        {
            _width  = 100;
        }

        _height = max(_height, 8);
    }
    else
    {
        if(width.IsEmpty() || ((V_VT(&height) == VT_BSTR) && (V_BSTR(&height) == NULL)))
        {
            _width  = GetSystemMetrics(SM_CXVSCROLL);
        }
        if(height.IsEmpty() || ((V_VT(&width) == VT_BSTR) && (V_BSTR(&width) == NULL)))
        {
            _height = 100;
        }

        _width = max(_width, 8);
    }

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::IncrementCallback()
//
// Synopsis:    Called by the increment button
//
// Arguments:   A Utility Button
//
// Returns:     true if button can be incremented, false otherwise
//
//-------------------------------------------------------------------


HRESULT 
CScrollBar::IncrementCallback(CUtilityButton *pButton)
{
    HRESULT hr = S_OK;

    if(pButton->IsPressing()) 
    {

        if(pButton->IsRaised()) 
        {
            CheckResult( ClearTimers());

            _suspended = true;
        }
        
        else 
        {
            if(_suspended)
            {
                CheckResult( StartRepeatTimer());

                _suspended = false;
            }
            else 
            {
                _lCurIncrement = _lUnitIncrement;

                CheckResult( DoIncrement());
                CheckResult( StartDelayTimer());
            }
        }

    }

    else 
    {
        CheckResult( ClearTimers());

        _suspended = false;
    }

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::DecrementCallback()
//
// Synopsis:    Called by the decrement button
//
// Arguments:   A Utility Button
//
// Returns:     true if button can be decremented, false otherwise
//
//-------------------------------------------------------------------


HRESULT 
CScrollBar::DecrementCallback(CUtilityButton *pButton)
{
    HRESULT hr = S_OK;

    if(pButton->IsPressing()) 
    {

        if(pButton->IsRaised()) 
        {
            CheckResult( ClearTimers());

            _suspended = true;
        }
        
        else 
        {
            if(_suspended)
            {
                CheckResult( StartRepeatTimer());

                _suspended = false;
            }
            else 
            {
                _lCurIncrement = - _lUnitIncrement;

                CheckResult( DoIncrement());
                CheckResult( StartDelayTimer());
            }
        }

    }

    else 
    {
        CheckResult( ClearTimers());

        _suspended = false;
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::DoIncrement()
//
// Synopsis:    Increments current position by the current increment amount
//              which is set by the various unit or block incrementers.
//              Fires and event, and sets the thumb position to the new value.
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CScrollBar::DoIncrement()
{
    HRESULT hr = S_OK;

    long _lOldPosition = _lCurrentPosition;

    _lCurrentPosition += _lCurIncrement;
    
    //
    //  Don't let it go below the mininum
    //

    if(_lCurrentPosition < _lMinPosition)
    {
        _lCurrentPosition = _lMinPosition;
    }

    //
    //  Or above the maximum
    //

    else if(_lCurrentPosition > _lMaxPosition)
    {
        _lCurrentPosition = _lMaxPosition;
    }

    //
    //  Move the thumb
    //

    CheckResult( SetThumbPosition( _lCurrentPosition ));

    //
    //  If position has changed, fire an event...
    //

    if(_lOldPosition != _lCurrentPosition) 
    {

        CheckResult( FireEvent( _lOnChangeCookie, NULL, CComBSTR("change")) );

    }

Cleanup:

    return hr;

}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::MouseMoveCallback()
//
// Synopsis:    Performs a sanity check on the proposed coordinate.
//              Called by the slider thumb when an attempt is made to move it
//
// Arguments:   None
//
// Returns:     true if button can be moved, false otherwise
//
//-------------------------------------------------------------------


HRESULT 
CScrollBar::MouseMoveCallback(CUtilityButton *pButton, long &x, long &y)
{
    HRESULT hr = S_OK;

    long max = TrackLength() - ThumbLength();

    if(_eoOrientation == Horizontal) 
    {

        if(x < 0)
            x = 0;

        if(x > max)
            x = max;

        //
        // Reset the current position
        //

        CheckResult( SyncThumbPosition( x ));
    }

    else 
    {

        if(y < 0)
            y = 0;

        if(y > max)
            y = max;

        //
        // Reset the current position
        //

        CheckResult( SyncThumbPosition( y ));
    }

    //
    // This stuff is for performance conciderations, with three divs making up the slider
    // - track, thumb, track - moving the thumb and continuously resizng the track elements 
    // caused wragged movement.  Instead, we won't display them once the thumb starts to move, and
    // turn them back on when the thumb stops.
    //

    if(! pButton->IsMoving()) 
    {
        CheckResult( SetBlockMoverPositions());

        CheckResult( BlockDisplay(_pBlockDec, true));
        CheckResult( BlockDisplay(_pBlockInc, true));

    }
    else 
    {
        CheckResult( BlockDisplay(_pBlockDec, false));
        CheckResult( BlockDisplay(_pBlockInc, false));
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::StartDelayTimer()
//
// Synopsis:    Sets up the Delay timeout and builds its event sink if necessary
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CScrollBar::StartDelayTimer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLWindow2> pWindow;
    CComPtr<IHTMLWindow3> pWindow3;
    CComVariant vDispatch;
    CComVariant vLanguage;

    //
    //  Create a new timer sink if one doesn't exist yet
    //

    if(! _pSinkDelayTimer) 
    {

        _pSinkDelayTimer = new CEventSink(this, NULL, SCROLL_DELAY_TIMER);
        if (!_pSinkDelayTimer)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

    }

    //
    // Setup the Delay Timer
    //

    vDispatch = _pSinkDelayTimer;
    _pSinkDelayTimer->AddRef();

    Assert( _lDelayTimerId == 0);

    CheckResult( GetHTMLDocument(_pSite, &pDoc));
    CheckResult( pDoc->get_parentWindow( &pWindow));
    CheckResult( pWindow->QueryInterface( __uuidof(IHTMLWindow3), (void **) &pWindow3 ));
    CheckResult( pWindow3->setTimeout( &vDispatch, GetDelayRate(), &vLanguage, &_lDelayTimerId ));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::ClearDelayTimer()
//
// Synopsis:    Stops the delay timer
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CScrollBar::ClearDelayTimer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLWindow2> pWindow;

    //
    //  Clear the delay timer
    //

    if(_lDelayTimerId)
    {

        CheckResult( GetHTMLDocument(_pSite, &pDoc));
        CheckResult( pDoc->get_parentWindow( &pWindow));
        CheckResult( pWindow->clearTimeout( _lDelayTimerId ));

        _lDelayTimerId = 0;

    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::OnDelay()
//
// Synopsis:    Called when the Delay timeout fires.  Clears the timer,
//              increments, and then starts the Repeat interval timer
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CScrollBar::OnDelay()
{
    HRESULT hr = S_OK;

    //
    //  Clear the delay timer; start the repeat timer
    //

    CheckResult( ClearDelayTimer());
    CheckResult( DoIncrement());
    CheckResult( StartRepeatTimer());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::StartRepeatTimer()
//
// Synopsis:    Sets up the repeat timer and builds its event sink if necessary
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CScrollBar::StartRepeatTimer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLWindow2> pWindow;
    CComPtr<IHTMLWindow3> pWindow3;
    CComVariant vDispatch;
    CComVariant vLanguage;

    //
    // Setup the Timer interval
    //

    if (! _pSinkRepeatTimer )
    {

        _pSinkRepeatTimer = new CEventSink(this, NULL, SCROLL_REPEAT_TIMER);
        if (!_pSinkRepeatTimer)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

    }

    vDispatch = _pSinkRepeatTimer;
    _pSinkRepeatTimer->AddRef();

    Assert( _lRepeatTimerId == 0);

    CheckResult( GetHTMLDocument(_pSite, &pDoc));
    CheckResult( pDoc->get_parentWindow( &pWindow));
    CheckResult( pWindow->QueryInterface( __uuidof(IHTMLWindow3), (void **) &pWindow3 ));
    CheckResult( pWindow3->setInterval( &vDispatch, GetRepeatRate(), &vLanguage, &_lRepeatTimerId ));

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::ClearRepeatTimer()
//
// Synopsis:    Stops the repeat timer
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT
CScrollBar::ClearRepeatTimer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLWindow2> pWindow;

    if(_lRepeatTimerId)
    {

        CheckResult( GetHTMLDocument(_pSite, &pDoc));
        CheckResult( pDoc->get_parentWindow( &pWindow));
        CheckResult( pWindow->clearInterval( _lRepeatTimerId ));

        _lRepeatTimerId = 0;

    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::OnRepeat()
//
// Synopsis:    Fires the incrementer
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT
CScrollBar::OnRepeat()
{
    HRESULT hr = S_OK;

    CheckResult( DoIncrement());

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::ClearTimers()
//
// Synopsis:    Stops any active timers.  Effectively, this stops repeating actions
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT
CScrollBar::ClearTimers()
{
    HRESULT hr = S_OK;

    CheckResult( ClearDelayTimer());
    CheckResult( ClearRepeatTimer());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::BlockMoveStartInc()
//
// Synopsis:    Start the block increment process
//
// Arguments:   CEventObjectAccess
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CScrollBar::BlockMoveStartInc(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement2> pElement2;

    _moving    = true;
    _pCurBlock = _pBlockInc;

    CheckResult( _pBlockInc->QueryInterface( __uuidof(IHTMLElement2), (void **) &pElement2));
    CheckResult( pElement2->setCapture());
    CheckResult( BlockIncrement());
    CheckResult( BlockHighlight(_pBlockInc, true));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::BlockMoveStartDec()
//
// Synopsis:    Start the block decrement process
//
// Arguments:   CEventObjectAccess
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT 
CScrollBar::BlockMoveStartDec(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement2> pElement2;

    _moving    = true;
    _pCurBlock = _pBlockDec;

    CheckResult( _pBlockDec->QueryInterface( __uuidof(IHTMLElement2), (void **) &pElement2));
    CheckResult( pElement2->setCapture());
    CheckResult( BlockDecrement());
    CheckResult( BlockHighlight(_pBlockDec, true));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::BlockMoveSuspend()
//
// Synopsis:    Used to suspend and restart the repeater timers.  
//
// Arguments:   CEventObjectAccess
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CScrollBar::BlockMoveSuspend(CEventObjectAccess *pEvent, IHTMLElement *pTrack)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement> pSrcElement;

    pEvent->Open(EOA_EVENTOBJ);

    if( _moving ) 
    {
        CheckResult( pEvent->EventObj()->get_srcElement(&pSrcElement))

        if(! IsSameObject( pSrcElement, pTrack) )
        {
            _suspended = true;

            CheckResult( BlockHighlight(pTrack, false));
            CheckResult( ClearRepeatTimer());
        }

        else if( _suspended ) 
        {
            _suspended = false;
    
            CheckResult( BlockHighlight(pTrack, true));
            CheckResult( StartRepeatTimer());

        }
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::BlockMoveResume()
//
// Synopsis:    Resumes the repeating move functionality by restarting the timer
//
// Arguments:   CEventObjectAccess
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CScrollBar::BlockMoveResume(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    if( _moving ) 
    {
        CheckResult( StartRepeatTimer());
    }

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::BlockMoveEnd()
//
// Synopsis:    Shuts down the block move process buy dehighlighting the area
//              and stopping any timers
//
// Arguments:   CEventObjectAccess
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CScrollBar::BlockMoveEnd(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLElement2> pElement2;

    if(_pCurBlock) 
    {
        CheckResult( _pCurBlock->QueryInterface( __uuidof(IHTMLElement2), (void **) &pElement2));
        CheckResult( pElement2->releaseCapture());
    }

    CheckResult( ClearTimers());
    CheckResult( BlockHighlight( _pBlockInc, false));
    CheckResult( BlockHighlight( _pBlockDec, false));

    _moving = false;
    _suspended = false;
    _pCurBlock = NULL;

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::BlockCheck()
//
// Synopsis:    Checks to see if the mouse coordinates of the pEvent object
//              fall withing the bounding box of the current block move element.
//              If not, the repeat action is halted buy clearing the timers
//
// Arguments:   CEventObjectAccess *pEvent
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CScrollBar::BlockMoveCheck(CEventObjectAccess *pEvent)
{
    HRESULT hr = S_OK;

    POINT ptClient;
    CComPtr<IHTMLRect> pRect;
    CComPtr<IHTMLElement2> pElement2;

    long top, left, right, bottom;

    if(! _pCurBlock)
        return S_OK;

    CheckResult( pEvent->GetWindowCoordinates(&ptClient));

    CheckResult( _pCurBlock->QueryInterface( __uuidof(IHTMLElement2), (void **) &pElement2));
    CheckResult( pElement2->getBoundingClientRect(&pRect));

    CheckResult( pRect->get_left(&left));
    CheckResult( pRect->get_top(&top));
    CheckResult( pRect->get_right(&right));
    CheckResult( pRect->get_bottom(&bottom));

    if(! (((ptClient.x >= left) && (ptClient.x <= right)) && 
          ((ptClient.y >= top)  && (ptClient.y <= bottom)))) 
    {
        CheckResult( BlockHighlight(_pCurBlock, false));
        CheckResult( ClearTimers());
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::BlockDisplay()
//
// Synopsis:    Used set the display property to 'none' before move
//              the slider thumb so that it appears to move more smoothly.
//              After the move is completed, the display is set to inline.
//
// Arguments:   IHTMLElement pBlock - the block to hightlight
//              bool flag           - turn on or off
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------


HRESULT   
CScrollBar::BlockDisplay(IHTMLElement *pBlock, bool flag)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLStyle> pStyle;

    CComBSTR bstr;

    bstr       = flag ? _T("inline") : _T("none");

    CheckResult( pBlock->get_style(&pStyle));
    CheckResult( pStyle->put_display(bstr));


Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::BlockHighlight()
//
// Synopsis:    Used set the display property to 'none' before move
//              the slider thumb so that it appears to move more smoothly.
//              After the move is completed, the display is set to inline.
//
// Arguments:   IHTMLElement pBlock - the block to hightlight
//              bool flag           - turn on or off
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------

HRESULT   
CScrollBar::BlockHighlight(IHTMLElement *pBlock, bool flag)
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLStyle> pStyle;

    CComVariant color;

    if(flag) 
    {
        CheckResult( GetShadowColor(&color));
    }
    else
    {
        CheckResult( GetScrollbarColor(&color));
    }

    CheckResult( pBlock->get_style(&pStyle));
    CheckResult( pStyle->put_backgroundColor(color));


Cleanup:

    return hr;

}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::BlockIncrement()
//
// Synopsis:    Increments the scrollbar one page (or as much of one as
//              possible)
//
// Arguments:   None
//
// Returns:     S_OK
//
//-------------------------------------------------------------------


HRESULT  
CScrollBar::BlockIncrement() 
{
    HRESULT hr = S_OK;

    _lCurIncrement = _lBlockIncrement;

    CheckResult( DoIncrement());
    CheckResult( StartDelayTimer());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::BlockDecrement()
//
// Synopsis:    Decrements the scrollbar one page (or as much of one as
//              possible)
//
// Arguments:   None
//
// Returns:     S_OK
//
//-------------------------------------------------------------------


HRESULT  
CScrollBar::BlockDecrement()
{
    HRESULT hr = S_OK;

    _lCurIncrement = - _lBlockIncrement;

    CheckResult( DoIncrement());
    CheckResult( StartDelayTimer());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::SetThumbPosition()
//
// Synopsis:    Set the thumb position to the location determined by the 
//              unit
//
// Arguments:   None
//
// Returns:     S_OK
//
//-------------------------------------------------------------------


HRESULT  
CScrollBar::SetThumbPosition(long position)
{
    HRESULT hr = S_OK;

    double  pixPerUnit;

    //
    //  Update the OM
    //

    GetProps()[ePosition].Set(position); 

    //
    //  Calculate the offset of the thumb
    //

    _sliderOffset = NearestLong( (PixelsPerUnit() * (double) (position - _lMinPosition)));

    if ( _eoOrientation == Horizontal ) 
    {

        CheckResult( _pSliderThumb->SetHorizontalOffset(_sliderOffset));

    }
    else 
    {

        CheckResult( _pSliderThumb->SetVerticalOffset(_sliderOffset));

    }

    CheckResult( SetBlockMoverPositions());

Cleanup:

    return S_OK;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::SyncThumbPosition()
//
// Synopsis:    Essentially the inverse of SetThumbPositoin.  This function
//              sets the _lCurrentPosition from the thumb's location within 
//              the slider bar.
//
// Arguments:   x, y coordinates of thumb (relative to slider bar)
//
// Returns:     S_OK
//
//-------------------------------------------------------------------


HRESULT  
CScrollBar::SyncThumbPosition(long pixels)
{
    HRESULT hr = S_OK;

    long _lOldPosition = _lCurrentPosition;

    _lCurrentPosition   = ((long) (pixels / PixelsPerUnit())) + _lMinPosition;
    _sliderOffset = pixels;

    if(_lOldPosition != _lCurrentPosition)
    {
        CheckResult ( FireEvent( _lOnChangeCookie, NULL, CComBSTR("change")));
        CheckResult ( FireEvent( _lOnScrollCookie, NULL, CComBSTR("scroll")));
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::SetBlockMoverPositions()
//
// Synopsis:    Sets the position of the page move zone based on slider thumb
//
// Arguments:   None
//
// Returns:     HRESULT
//
//-------------------------------------------------------------------



HRESULT
CScrollBar::SetBlockMoverPositions()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLStyle> pIncStyle, pDecStyle;

    //
    //  Calculate dimensions of regions around the slider thumb
    //

    long decPosition  = 0L;
    long decLength    = _sliderOffset;

    long incPosition  = ThumbLength() + _sliderOffset;
    long incLength    = TrackLength() - ThumbLength() - _sliderOffset;

    CheckResult( _pBlockInc->get_style(&pIncStyle));
    CheckResult( _pBlockDec->get_style(&pDecStyle));

    if ( _eoOrientation == Horizontal ) 
    {
        CheckResult( pDecStyle->put_pixelLeft(decPosition));
        CheckResult( pDecStyle->put_pixelWidth(decLength));

        CheckResult( pIncStyle->put_pixelLeft(incPosition));
        CheckResult( pIncStyle->put_pixelWidth(incLength));
    }
    else 
    {
        CheckResult( pDecStyle->put_pixelTop(decPosition));
        CheckResult( pDecStyle->put_pixelHeight(decLength));

        CheckResult( pIncStyle->put_pixelTop(incPosition));
        CheckResult( pIncStyle->put_pixelHeight(incLength));
    }

Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::BuildIncrementer()
//
// Synopsis:    Builds the incrementer button
//
// Arguments:   None
//
// Returns:     S_OK if it can be built
//
//-------------------------------------------------------------------



HRESULT
CScrollBar::BuildIncrementer()
{
    HRESULT hr = S_OK;
    CComVariant arrowColor, faceColor, v3dLightColor, highlightColor, shadowColor, darkShadowColor;

    unsigned arrowStyle = (_eoOrientation == Vertical) ? BUTTON_ARROW_DOWN : BUTTON_ARROW_RIGHT;
    
    CheckResult( CUtilityButton::Create(this, _pContainer, &_pIncrementer));    
    
    CheckResult( GetArrowColor(&arrowColor));
    CheckResult( GetFaceColor(&faceColor));
    CheckResult( Get3DLightColor(&v3dLightColor));
    CheckResult( GetHighlightColor(&highlightColor));
    CheckResult( GetShadowColor(&shadowColor));
    CheckResult( GetDarkShadowColor(&darkShadowColor))

    CheckResult( _pIncrementer->SetAbilities( BUTTON_PRESSABLE ));
    CheckResult( _pIncrementer->SetArrowStyle( arrowStyle ));
    CheckResult( _pIncrementer->SetArrowColor( arrowColor ));
    CheckResult( _pIncrementer->SetFaceColor(  faceColor ));
    CheckResult( _pIncrementer->Set3DLightColor( v3dLightColor ));
    CheckResult( _pIncrementer->SetHighlightColor( highlightColor ));
    CheckResult( _pIncrementer->SetShadowColor( shadowColor ));
    CheckResult( _pIncrementer->SetDarkShadowColor( darkShadowColor ));

    CheckResult( _pIncrementer->SetPressedCallback((PFN_PRESSED) IncrementCallback));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::BuildDecrementer()
//
// Synopsis:    Builds the decrementer button
//
// Arguments:   None
//
// Returns:     S_OK if it can be built
//
//-------------------------------------------------------------------



HRESULT
CScrollBar::BuildDecrementer()
{
    HRESULT hr = S_OK;
    CComVariant arrowColor, faceColor, v3dLightColor, highlightColor, shadowColor, darkShadowColor;

    unsigned arrowStyle = (_eoOrientation == Vertical) ? BUTTON_ARROW_UP : BUTTON_ARROW_LEFT;
    
    CheckResult( CUtilityButton::Create(this, _pContainer, &_pDecrementer));

    CheckResult( GetArrowColor(&arrowColor));
    CheckResult( GetFaceColor(&faceColor));
    CheckResult( Get3DLightColor(&v3dLightColor));
    CheckResult( GetHighlightColor(&highlightColor));
    CheckResult( GetShadowColor(&shadowColor));
    CheckResult( GetDarkShadowColor(&darkShadowColor))

    CheckResult( _pDecrementer->SetAbilities( BUTTON_PRESSABLE ));
    CheckResult( _pDecrementer->SetArrowStyle( arrowStyle ));
    CheckResult( _pDecrementer->SetArrowColor( arrowColor ));
    CheckResult( _pDecrementer->SetFaceColor(  faceColor ));
    CheckResult( _pDecrementer->Set3DLightColor( v3dLightColor ));
    CheckResult( _pDecrementer->SetHighlightColor( highlightColor ));
    CheckResult( _pDecrementer->SetShadowColor( shadowColor ));
    CheckResult( _pDecrementer->SetDarkShadowColor( darkShadowColor ));

    CheckResult( _pDecrementer->SetPressedCallback((PFN_PRESSED) DecrementCallback));

Cleanup:

    return hr;
}



//+------------------------------------------------------------------
//
// Member:      CScrollBar::BuildSliderThumb()
//
// Synopsis:    Builds the slider thumb button
//
// Arguments:   None
//
// Returns:     S_OK if it can be built
//
//-------------------------------------------------------------------



HRESULT
CScrollBar::BuildSliderThumb()
{
    HRESULT hr = S_OK;
    CComVariant faceColor, v3dLightColor, highlightColor, shadowColor, darkShadowColor;

    unsigned freedom = (_eoOrientation == Vertical) ? BUTTON_MOVEABLE_Y : BUTTON_MOVEABLE_X;
    
    CheckResult( CUtilityButton::Create(this, _pSliderBar, &_pSliderThumb));

    CheckResult( GetFaceColor(&faceColor));
    CheckResult( Get3DLightColor(&v3dLightColor));
    CheckResult( GetHighlightColor(&highlightColor));
    CheckResult( GetShadowColor(&shadowColor));
    CheckResult( GetDarkShadowColor(&darkShadowColor))

    CheckResult( _pSliderThumb->SetAbilities( freedom ));

    CheckResult( _pSliderThumb->SetFaceColor(  faceColor ));
    CheckResult( _pSliderThumb->SetFaceColor(  faceColor ));
    CheckResult( _pSliderThumb->Set3DLightColor( v3dLightColor ));
    CheckResult( _pSliderThumb->SetHighlightColor( highlightColor ));
    CheckResult( _pSliderThumb->SetShadowColor( shadowColor ));
    CheckResult( _pSliderThumb->SetDarkShadowColor( darkShadowColor ));

    CheckResult( _pSliderThumb->SetMovedCallback((PFN_MOVED) MouseMoveCallback));

Cleanup:

    return hr;
}



//+------------------------------------------------------------------
//
// Member:      CScrollBar::BuildSliderBar()
//
// Synopsis:    Builds the slider bar which will contain a slider thumb
//
// Arguments:   None
//
// Returns:     S_OK if it can be built
//
//-------------------------------------------------------------------



HRESULT
CScrollBar::BuildSliderBar()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLStyle> pStyle;
    CComBSTR    bstr;

    CheckResult( GetHTMLDocument(_pSite, &pDoc));
    CheckResult( pDoc->createElement(CComBSTR("div"), &_pSliderBar));

    CheckResult( _pSliderBar->get_style(&pStyle));
    CheckResult( pStyle->put_display(CComBSTR("inline")));
    CheckResult( pStyle->put_overflow(CComBSTR("hidden")));
    CheckResult( AppendChild(_pContainer, _pSliderBar));

    _pSinkSlider = new CEventSink(this, _pSliderBar, SCROLL_SLIDER);
    if (!_pSinkSlider)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    bstr = _T("onmousedown");
    CheckResult( AttachEventToSink(_pSliderBar, bstr, _pSinkSlider));

    bstr = _T("onmouseup");
    CheckResult( AttachEventToSink(_pSliderBar, bstr, _pSinkSlider));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::BuildBlockIncrementer()
//
// Synopsis:    Builds the area of the slider bar that handles page incrementing
//
// Arguments:   None
//
// Returns:     S_OK if it can be built
//
//-------------------------------------------------------------------


HRESULT
CScrollBar::BuildBlockIncrementer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLStyle> pStyle;
    CComPtr<IHTMLStyle2> pStyle2;

    CComBSTR    bstr;
    CComVariant color;

    CheckResult( GetScrollbarColor(&color));

    CheckResult( GetHTMLDocument(_pSite, &pDoc));
    CheckResult( pDoc->createElement(CComBSTR("div"), &_pBlockInc));

    CheckResult( _pBlockInc->get_style(&pStyle));
    CheckResult( pStyle->put_backgroundColor(color));
    CheckResult( pStyle->put_display(CComBSTR("inline")));
    CheckResult( pStyle->put_pixelTop(0L));
    CheckResult( pStyle->put_pixelLeft(0L));

    CheckResult( pStyle->QueryInterface(IID_IHTMLStyle2, (void **) &pStyle2));
    CheckResult( pStyle2->put_position(CComBSTR("absolute")));

    CheckResult( AppendChild(_pSliderBar, _pBlockInc));


    _pSinkBlockInc = new CEventSink(this, _pBlockInc, SCROLL_PAGEINC);
    if (!_pSinkBlockInc)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    bstr = _T("onmousedown");
    CheckResult( AttachEventToSink(_pBlockInc, bstr, _pSinkBlockInc));

    bstr = _T("onmouseup");
    CheckResult( AttachEventToSink(_pBlockInc, bstr, _pSinkBlockInc));

    bstr = _T("onmouseenter");
    CheckResult( AttachEventToSink(_pBlockInc, bstr, _pSinkBlockInc));

    bstr = _T("onmousemove");
    CheckResult( AttachEventToSink(_pBlockInc, bstr, _pSinkBlockInc));

    bstr = _T("onresize");
    CheckResult( AttachEventToSink(_pBlockInc, bstr, _pSinkBlockInc));


Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::BuildBlockDecrementer()
//
// Synopsis:    Builds the area of the slider bar that handles page decrementing
//
// Arguments:   None
//
// Returns:     S_OK if it can be built
//
//-------------------------------------------------------------------

HRESULT
CScrollBar::BuildBlockDecrementer()
{
    HRESULT hr = S_OK;

    CComPtr<IHTMLDocument2> pDoc;
    CComPtr<IHTMLStyle> pStyle;
    CComPtr<IHTMLStyle2> pStyle2;

    CComBSTR    bstr;
    CComVariant color;

    CheckResult( GetScrollbarColor(&color));

    CheckResult( GetHTMLDocument(_pSite, &pDoc));
    CheckResult( pDoc->createElement(CComBSTR("div"), &_pBlockDec));

    CheckResult( _pBlockDec->get_style(&pStyle));
    CheckResult( pStyle->put_backgroundColor(color));
    CheckResult( pStyle->put_display(CComBSTR("inline")));
    CheckResult( pStyle->put_pixelTop(0L));
    CheckResult( pStyle->put_pixelLeft(0L));

    CheckResult( pStyle->QueryInterface(IID_IHTMLStyle2, (void **) &pStyle2));
    CheckResult( pStyle2->put_position(CComBSTR("absolute")));

    CheckResult( AppendChild(_pSliderBar, _pBlockDec));


    _pSinkBlockDec = new CEventSink(this, _pBlockDec, SCROLL_PAGEDEC);
    if (!_pSinkBlockDec)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    bstr = _T("onmousedown");
    CheckResult( AttachEventToSink(_pBlockDec, bstr, _pSinkBlockDec));

    bstr = _T("onmouseup");
    CheckResult( AttachEventToSink(_pBlockDec, bstr, _pSinkBlockDec));

    bstr = _T("onmouseenter");
    CheckResult( AttachEventToSink(_pBlockDec, bstr, _pSinkBlockDec));

    bstr = _T("onmousemove");
    CheckResult( AttachEventToSink(_pBlockDec, bstr, _pSinkBlockDec));

    bstr = _T("onresize");
    CheckResult( AttachEventToSink(_pBlockDec, bstr, _pSinkBlockDec));


Cleanup:

    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CScrollBar::CalcConstituentDimensions()
//
// Synopsis:    Determins the pixel dimensions of all controls that make up the scrollbar
//
// Arguments:   None
//
// Returns:     S_OK if they can be calculated
//
//-------------------------------------------------------------------



HRESULT 
CScrollBar::CalcConstituentDimensions()
{
    HRESULT hr = S_OK;

    long  totalSize;

    if (_eoOrientation == Horizontal) 
    {
        _lLength     = _width;
        _lWidth      = _height;
    }

    else if (_eoOrientation == Vertical) 
    {
        _lLength     = _height;
        _lWidth      = _width;
    }

    else 
    {
        Assert( false ); // can't happen
    }

    totalSize     = NearestLong( (PixelsPerUnit() * (double) _lVisibleUnits)) ;

    _lThumbLength = min( totalSize, TrackLength());
    _lThumbLength = max( SCROLL_MIN_THUMBSIZE, _lThumbLength );

    return hr;
}



//+------------------------------------------------------------------
//
// Member:      CScrollBar::SetConstituentDimensions()
//
// Synopsis:    Sets the dimensions of the controls
//
// Arguments:   None
//
// Returns:     S_OK if they can be set
//
//-------------------------------------------------------------------



HRESULT
CScrollBar::SetConstituentDimensions()
{
    HRESULT hr = S_OK;

    CContextAccess a(_pSliderBar);
    CContextAccess i(_pBlockInc);
    CContextAccess d(_pBlockDec);

    CheckResult( a.Open( CA_STYLE ));
    CheckResult( i.Open( CA_STYLE ));
    CheckResult( d.Open( CA_STYLE ));

    if (_eoOrientation == Horizontal) 
    {

        CheckResult( a.Style()->put_pixelHeight( TotalWidth() ));
        CheckResult( a.Style()->put_pixelWidth( TrackLength() ));

        CheckResult( i.Style()->put_pixelHeight( TotalWidth() ));
        CheckResult( i.Style()->put_pixelWidth( ButtonSize() ));

        CheckResult( d.Style()->put_pixelHeight( TotalWidth() ));
        CheckResult( d.Style()->put_pixelWidth( ButtonSize() ));

        CheckResult( _pIncrementer->SetHeight( TotalWidth() ));
        CheckResult( _pIncrementer->SetWidth(  ButtonSize() ));

        CheckResult( _pDecrementer->SetHeight( TotalWidth() ));
        CheckResult( _pDecrementer->SetWidth(  ButtonSize() ));

        CheckResult( _pSliderThumb->SetHeight( TotalWidth() ));
        CheckResult( _pSliderThumb->SetWidth(  ThumbLength() ));

    }
    else 
    {

        CheckResult( a.Style()->put_pixelHeight( TrackLength() ));
        CheckResult( a.Style()->put_pixelWidth( TotalWidth() ));

        CheckResult( i.Style()->put_pixelHeight( ButtonSize() ));
        CheckResult( i.Style()->put_pixelWidth( TotalWidth() ));

        CheckResult( d.Style()->put_pixelHeight( ButtonSize() ));
        CheckResult( d.Style()->put_pixelWidth( TotalWidth() ));

        CheckResult( _pIncrementer->SetHeight(  ButtonSize() ));
        CheckResult( _pIncrementer->SetWidth(   TotalWidth() ));

        CheckResult( _pDecrementer->SetHeight(  ButtonSize() ));
        CheckResult( _pDecrementer->SetWidth(   TotalWidth() ));

        CheckResult( _pSliderThumb->SetHeight( ThumbLength() ));
        CheckResult( _pSliderThumb->SetWidth(   TotalWidth() ));
    
    }

    CheckResult( SetThumbPosition( _lCurrentPosition ));

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
// Member:      CScrollBar::ReadProperties()
//
// Synopsis:    Reads in property values for later calculations
//
// Arguments:   None
//
// Returns:     S_OK if they can be read
//
//-------------------------------------------------------------------



HRESULT 
CScrollBar::ReadProperties()
{
    HRESULT hr = S_OK;
    BSTR orientation;

    CheckResult( get_min(&_lMinPosition));
    CheckResult( get_max(&_lMaxPosition));
    CheckResult( get_position(&_lCurrentPosition));
    CheckResult( get_unit(&_lUnitIncrement));
    CheckResult( get_block(&_lBlockIncrement));
    CheckResult( get_visibleUnits(&_lVisibleUnits));

    CheckResult( get_orientation(&orientation));

    _eoOrientation = _wcsicmp(orientation, _T("vertical")) == 0 ? Vertical : Horizontal;

Cleanup:

    return hr;
}



//+------------------------------------------------------------------
//
// Member:      CScrollBar::Layout()
//
// Synopsis:    Laysout the scrollbar by calculating dimensions
//
// Arguments:   None
//
// Returns:     S_OK if scrollbar can be layed-out
//
//-------------------------------------------------------------------



HRESULT
CScrollBar::Layout()
{
    HRESULT hr = S_OK;

    CheckResult( CalcConstituentDimensions());
    CheckResult( SetConstituentDimensions());

Cleanup:

    return hr;
}


//+------------------------------------------------------------------
//
//
// Synopsis:    Scrollbar Property interigators
//
//
//-------------------------------------------------------------------




/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::get_min(long * pv)
{
    return GetProps()[eMin].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::put_min(long v)
{
    return GetProps()[eMin].Set(v); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::get_max(long * pv)
{
    return GetProps()[eMax].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::put_max(long v)
{
    return GetProps()[eMax].Set(v); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::get_position(long * pv)
{
    return GetProps()[ePosition].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::put_position(long v)
{
    return SetThumbPosition( v ); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::get_unit(long * pv)
{
    return GetProps()[eUnit].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::put_unit(long v)
{
    return GetProps()[eUnit].Set(v); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::get_block(long * pv)
{
    return GetProps()[eBlock].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::put_block(long v)
{
    return GetProps()[eBlock].Set(v); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::get_visibleUnits(long * pv)
{
    return GetProps()[eVisibleUnits].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::put_visibleUnits(long v)
{
    return GetProps()[eVisibleUnits].Set(v); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::get_orientation(BSTR * pv)
{
    return GetProps()[eOrientation].Get(pv); 
}

/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::put_orientation(BSTR v)
{
    return GetProps()[eOrientation].Set(v); 
}


/////////////////////////////////////////////////////////////////////////////

HRESULT
CScrollBar::GetScrollbarColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CVariant color;
    CComVariant defaultColor("scrollbar");

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_STYLE3));
    CheckResult( a.Style3()->get_scrollbarBaseColor ( &color ));

    if(color.IsEmpty() || ((V_VT(&color) == VT_BSTR) && (V_BSTR(&color) == NULL)) ) 
    {   
        return ::VariantCopy(pv, &defaultColor);
    }
    else 
    {
        return ::VariantCopy(pv, &color);
    }

Cleanup:

    return hr;
}

HRESULT
CScrollBar::GetFaceColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbarFaceColor( pv));

Cleanup:

    return hr;
}

HRESULT
CScrollBar::GetArrowColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbarArrowColor( pv));

Cleanup:

    return hr;
}

HRESULT
CScrollBar::Get3DLightColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbar3dLightColor( pv));

Cleanup:

    return hr;
}

HRESULT
CScrollBar::GetShadowColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbarShadowColor( pv));

Cleanup:

    return hr;
}

HRESULT
CScrollBar::GetHighlightColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbarHighlightColor( pv));

Cleanup:

    return hr;
}

HRESULT
CScrollBar::GetDarkShadowColor(VARIANT * pv)
{
    HRESULT hr = S_OK;
    CComPtr<IHTMLCurrentStyle> pStyle;
    CComPtr<IHTMLCurrentStyle2> pStyle2;

    CContextAccess a(_pSite);

    CheckResult( a.Open(CA_ELEM2));

    CheckResult( a.Elem2()->get_currentStyle(&pStyle));
    CheckResult( pStyle->QueryInterface( __uuidof(IHTMLCurrentStyle2), (void **) &pStyle2));
    CheckResult( pStyle2->get_scrollbarDarkShadowColor( pv));

Cleanup:

    return hr;
}



HRESULT
CScrollBar::AttachEventToSink(IHTMLDocument3 *pDoc, CComBSTR& bstr, CEventSink* pSink)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL    vSuccess;

    CheckResult( pDoc->attachEvent(bstr, pSink, &vSuccess));

    if (vSuccess != VARIANT_TRUE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:

    return hr;
}




HRESULT
CScrollBar::AttachEventToSink(IHTMLElement *pElem, CComBSTR& bstr, CEventSink* pSink)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL    vSuccess;
    CComPtr<IHTMLElement2> pElem2;

    CheckResult( pElem->QueryInterface(IID_IHTMLElement2, (void **) &pElem2));
    CheckResult( pElem2->attachEvent(bstr, pSink, &vSuccess));

    if (vSuccess != VARIANT_TRUE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:

    return hr;
}



//+------------------------------------------------------------------------
//
// CScrollBar::CEventSink
//
// IDispatch Implementation
// The event sink's IDispatch interface is what gets called when events
// are fired.
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:     CScrollBar::CEventSink::GetTypeInfoCount
//              CScrollBar::CEventSink::GetTypeInfo
//              CScrollBar::CEventSink::GetIDsOfNames
//
//  Synopsis:   We don't really need a nice IDispatch... this minimalist
//              version does just plenty.
//
//-------------------------------------------------------------------------

STDMETHODIMP
CScrollBar::CEventSink::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CScrollBar::CEventSink::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
                                   /* [in] */ LCID /*lcid*/,
                                   /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CScrollBar::CEventSink::GetIDsOfNames( REFIID          riid,
                                         OLECHAR**       rgszNames,
                                         UINT            cNames,
                                         LCID            lcid,
                                         DISPID*         rgDispId)
{
    return E_NOTIMPL;
}

//+------------------------------------------------------------------------
//
//  Member:     CScrollBar::CEventSink::Invoke
//
//  Synopsis:   This gets called for all events on our object.  (it was
//              registered to do so in Init with attach_event.)  It calls
//              the appropriate parent functions to handle the events.
//
//-------------------------------------------------------------------------
STDMETHODIMP
CScrollBar::CEventSink::Invoke(DISPID dispIdMember,
                                     REFIID, LCID,
                                     WORD wFlags,
                                     DISPPARAMS* pDispParams,
                                     VARIANT* pVarResult,
                                     EXCEPINFO*,
                                     UINT* puArgErr)
{
    HRESULT         hr          = S_OK;
    IHTMLEventObj   *pEventObj  = NULL;
    CComBSTR        bstrOn;
    CComBSTR        bstrEvent;

    Assert(_pParent);

    if (!pDispParams) // || (pDispParams->cArgs < 1))
        goto Cleanup;

    if (pDispParams->cArgs == 0) 
    {
        if (_dwFlags & SCROLL_DELAY_TIMER)
        {
            CheckResult( _pParent->OnDelay() );
        }
        else if (_dwFlags & SCROLL_REPEAT_TIMER)
        {
            CheckResult( _pParent->OnRepeat() );
        }
    }

    else if (pDispParams->rgvarg[0].vt == VT_DISPATCH)
    {
        CEventObjectAccess eoa(pDispParams);
        
        hr = pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&pEventObj);
        if (FAILED(hr))
            goto Cleanup;

        hr = pEventObj->get_type(&bstrEvent);
        if (FAILED(hr))
            goto Cleanup;

        if (_dwFlags & SCROLL_PAGEDEC)
        {
            if (!StrCmpICW(bstrEvent, L"mousedown"))
            {
                CheckResult( _pParent->BlockMoveStartDec(&eoa));
            }
            else if (!StrCmpICW(bstrEvent, L"mouseup"))
            {
                CheckResult( _pParent->BlockMoveEnd(&eoa));
            }
            else if (!StrCmpICW(bstrEvent, L"mousemove"))
            {
                CheckResult( _pParent->BlockMoveSuspend(&eoa, _pElement));
            }
            else if (!StrCmpICW(bstrEvent, L"resize"))
            {
                CheckResult( _pParent->BlockMoveCheck(&eoa));
            }
       }

        else if (_dwFlags & SCROLL_PAGEINC)
        {
            if (!StrCmpICW(bstrEvent, L"mousedown"))
            {
                CheckResult( _pParent->BlockMoveStartInc(&eoa));
            }
            else if (!StrCmpICW(bstrEvent, L"mouseup"))
            {
                CheckResult( _pParent->BlockMoveEnd(&eoa));
            }
            else if (!StrCmpICW(bstrEvent, L"mousemove"))
            {
                CheckResult( _pParent->BlockMoveSuspend(&eoa, _pElement));
            }
             else if (!StrCmpICW(bstrEvent, L"resize"))
            {
                CheckResult( _pParent->BlockMoveCheck(&eoa));
            }
       }

        else if (_dwFlags & SCROLL_SLIDER)
        {
            if (!StrCmpICW(bstrEvent, L"mousedown"))
            {
                CheckResult( _pParent->OnMouseDown(&eoa));
            }
        }
    }

Cleanup:

    ReleaseInterface(pEventObj);

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CScrollBar::CEventSink
//
//  Synopsis:   This is used to allow communication between the parent class
//              and the event sink class.  The event sink will call the ProcOn*
//              methods on the parent at the appropriate times.
//
//-------------------------------------------------------------------------

CScrollBar::CEventSink::CEventSink(CScrollBar *pParent, IHTMLElement *pElement, DWORD dwFlags)
{
    _pParent  = pParent;
    _pElement = pElement;
    _dwFlags  = dwFlags;
}

// ========================================================================
// CScrollBar::CEventSink
//
// IUnknown Implementation
// Vanilla IUnknown implementation for the event sink.
// ========================================================================

STDMETHODIMP
CScrollBar::CEventSink::QueryInterface(REFIID riid, void ** ppUnk)
{
    void * pUnk = NULL;

    if (riid == IID_IDispatch)
        pUnk = (IDispatch*)this;

    if (riid == IID_IUnknown)
        pUnk = (IUnknown*)this;

    if (pUnk)
    {
        *ppUnk = pUnk;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CScrollBar::CEventSink::AddRef(void)
{
    return ((IElementBehavior*) _pParent)->AddRef();
}

STDMETHODIMP_(ULONG)
CScrollBar::CEventSink::Release(void)
{
    return ((IElementBehavior*) _pParent)->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by iextag.rc
//
#define IDI_HOMEPAGE                    206

#define IDS_PROJNAME                    100
#define IDR_PEERFACTORY                 101
#define IDR_CLIENTCAPS                  102
#define IDR_CPERSISTUSERDATA            103
#define IDR_HOMEPAGE                    104
#define IDS_SETHOMEPAGE_TITLE           105
#define IDS_SETHOMEPAGE_MSG             106
#define IDR_CPERSISTSNAPSHOT            107
#define IDR_CPERSISTFAVORITE            108
#define IDR_CPERSISTHISTORY             109
#define IDR_DOWNLOADBEHAVIOR            110
#define IDR_WFOLDERS                    112
#define IDR_ANCHORCLICK                 113
#define IDS_WEBFOLDER_FIND              114
#define IDS_ERRORINTERNAL               115
#define IDS_ERRORINTTITLE               116
#define IDS_ERRORBADURL                 117
#define IDS_ERRORBADURLTITLE            118
#define IDS_ERRORNOURL                  119
#define IDS_ERRORNOURLTITLE             120
#define IDS_ERRORBADSERVER              121
#define IDS_ERRORBADSERVERTITLE         122
#define IDS_ERROROUTOFMEMORY            123
#define IDS_ERROROUTOFMEMORYTITLE       124
#define IDS_ERRORTIMEOUT                125
#define IDS_ERRORTIMEOUTTITLE           126
#define IDS_ERRORURLTOOLONG             127
#define IDS_ERRORURLTOOLONGTITLE        128
#define IDS_ERROROFFLINE                129
#define IDS_ERROROFFLINETITLE           130
#define IDR_HTMLAREA                    131
#define IDR_LAYOUTRECT                  132
#define IDR_COMBOBOX                    135
#define IDR_CHECKBOX                    136
#define IDR_RADIO                       137
#define IDR_SELECT                      138
#define IDR_SELITEM                     139
#define IDR_TEMPLATEPRINTER             140
#define IDR_SCROLLBAR                   141
#define IDR_SPINBUTTON                  142
#define IDR_SLIDERBAR                   143
#define IDR_UTILITYBUTTON               144
#define IDR_HEADERFOOTER                145
#define IDR_DEVICERECT                  146

#define IDC_WEBFOLDER_PROGRESS          201
#define IDD_WEBFOLDER_SEARCH            202
#define IDC_WEBFOLDER_ANIMATE           202
#define IDC_WEBFOLDER_MESSAGE           203
#define IDA_ISEARCH                     204

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        204
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         205
#define _APS_NEXT_SYMED_VALUE           102

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\persist.cxx ===
//+=============================================================================
//
//  File :  persist.cxx
//
//  contents : implementation of CPersistData xtag
//
//=============================================================================
#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MSHTML_H_
#define X_MSHTML_H_
#include "mshtml.h"       // for IHTML*ELement*
#endif

#ifndef X_PERHIST_H_
#define X_PERHIST_H_
#include "perhist.h"      // For IPersistHistory
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include "dispex.h"       // For IDispatchEx
#endif

#ifndef X_PERSIST_HXX_
#define X_PERSIST_HXX_
#include "persist.hxx"
#endif

#ifndef __X_IEXTAG_H_
#define __X_IEXTAG_H_
#include "iextag.h"
#endif

#ifndef __X_UTILS_HXX_
#define __X_UTILS_HXX_
#include "utils.hxx"
#endif


//+----------------------------------------------------------------------------
//
//  Member : Init
//
//  Synopsis : this method is called by MSHTML.dll to initialize peer object
//
//-----------------------------------------------------------------------------

HRESULT
CPersistDataPeer::Init(IElementBehaviorSite * pPeerSite)
{
    _pPeerSite = pPeerSite;
    _pPeerSite->AddRef();

    _pPeerSite->QueryInterface(IID_IElementBehaviorSiteOM, (void**)&_pPeerSiteOM);

    // now register our 2 events
    if (_pPeerSiteOM)
    {
        _pPeerSiteOM->RegisterEvent (_T("onload"), 0, NULL);
        _pPeerSiteOM->RegisterEvent (_T("onsave"), 0, NULL);
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member : Notify
//
//  Synopsis : when document is ready for modifications, setup timer calls
//
//-----------------------------------------------------------------------------

HRESULT
CPersistDataPeer::Notify(LONG lEvent, VARIANT *)
{
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  member : queryType
//
//  Synopsis : IPersistData method, this is used by the calling routines in order
//      to avoid cocreating the XML object.  This way they can query any of the
//      persist Tags, and find out what persist behaiors it supprots. 
//-----------------------------------------------------------------------------
HRESULT
CPersistDataPeer::queryType(long lType, VARIANT_BOOL * pfSupportsType)
{
    if (!pfSupportsType)
        return E_POINTER;

    *pfSupportsType = (lType == (long)_eState) ? VB_TRUE : VB_FALSE;

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member : Save
//
//  Synopsis : Implementation of the IHTMLPersistData method
//
//-----------------------------------------------------------------------------

HRESULT
CPersistDataPeer::save(IUnknown * pUnk, 
                       long lType, 
                       VARIANT_BOOL *pfBroadcast)
{
    HRESULT hr;
    BSTR    bstrEvent;

    if (!pfBroadcast)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pfBroadcast = VB_TRUE;

    // cache the OM pointers
    InitOM(pUnk, lType);

    bstrEvent = SysAllocString(L"onsave");

    if (!bstrEvent)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // allow script to save data
    hr = (FireEvent(bstrEvent, pfBroadcast, TRUE));
    SysFreeString(bstrEvent);

Cleanup:
    return( hr );
}


//+----------------------------------------------------------------------------
//
//  Member : Load
//
//  Synopsis : Implementation of the IHTMLPersistData method
//
//-----------------------------------------------------------------------------

HRESULT
CPersistDataPeer::load(IUnknown * pUnk, 
                       long lType, 
                       VARIANT_BOOL *pfContinue)
{
    HRESULT hr;
    BSTR    bstrEvent;

    if (!pfContinue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pfContinue = VB_TRUE;

    // cache the OM pointers
    InitOM(pUnk, lType, INIT_USE_CACHED);

    bstrEvent = SysAllocString(L"onload");
    if (!bstrEvent)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // allow event handlers the chance to load from the cach
    hr = (FireEvent(bstrEvent, pfContinue, FALSE));
    SysFreeString(bstrEvent);

Cleanup:
    return( hr );
}

//+--------------------------------------------------------------------------------
//
//  Member : FireEvent
//
//  Synopsis : helper method to fire the persistence events
//
//---------------------------------------------------------------------------------

HRESULT
CPersistDataPeer::FireEvent(BSTR bstrEvent, VARIANT_BOOL * pfContinue, BOOL fIsSaveEvent)
{
    IHTMLEventObj  * pEventObj = NULL;
    IHTMLEventObj2 * pEO2 = NULL;
    LONG             lCookie;
    HRESULT          hr = E_PENDING;
    VARIANT          varRet;

    if (!_pPeerSiteOM)
        goto Cleanup;

    VariantInit(&varRet);

    // create an event object
    hr = _pPeerSiteOM->CreateEventObject(&pEventObj);
    if (hr || !pEventObj)
        goto Cleanup;

    // Now populate the event object with whatever properties are
    // appropriate for this event:
    hr = pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**)&pEO2);
    if (hr==S_OK)
    {
        BSTR bstrEventType = SysAllocString( (fIsSaveEvent) ? L"save" : L"load" );

        // we need to set the event type, the event type is either
        // "load" or "save".
        if (bstrEventType)
        {
            pEO2->put_type( bstrEventType );
            SysFreeString(bstrEventType);
        }
    }

    // get the event cookie to fire the event
    hr = _pPeerSiteOM->GetEventCookie (bstrEvent, &lCookie);
    if (hr)
        goto Cleanup;

    hr = _pPeerSiteOM->FireEvent (lCookie, pEventObj);

    if (pfContinue)
    {
        hr = pEventObj->get_returnValue(&varRet);
        if (!hr)
            *pfContinue =  ((V_VT(&varRet) == VT_BOOL) && 
            (V_BOOL(&varRet) == VB_FALSE))? VB_FALSE : VB_TRUE;
    }

Cleanup:
    VariantClear(&varRet);
    ReleaseInterface(pEventObj);
    ReleaseInterface(pEO2);
    return ( hr );
}


//+-----------------------------------------------------------------------
//
//  Member : ClearOMInterfaces ()
//
//  Synopsis : this helper function is called after the Save/Load persistenceCache
//      operations are finished, and is responsible for freeing up any of hte OM 
//      interfaces that were cached.
//
//------------------------------------------------------------------------
void
CPersistDataPeer::ClearOMInterfaces()
{
    ClearInterface(&_pRoot);
    ClearInterface(&_pInnerXMLDoc);
}

//---------------------------------------------------------------------------
//
//  Member:     CPersistDataPeer::InitOM
//
//  Synopsis:   IHTMLPersistData OM method implementation
//
//---------------------------------------------------------------------------

HRESULT
CPersistDataPeer::InitOM(IUnknown * pUnk, long lType, DWORD dwFlags /* ==0*/)
{
    HRESULT            hr = S_OK;
    IHTMLElement     * pPeerElement = NULL;
    long               lElemID = -1;
    BSTR               bstrTag =NULL;
    CBufferedStr       cbsID;
    IXMLDOMNodeList  * pChildren = NULL;
    IXMLDOMElement   * pNewChild = NULL;
    IXMLDOMNode      * pSubTree = NULL;

    if (!pUnk)
        return E_INVALIDARG;

    if (_pInnerXMLDoc)
    {
        if (dwFlags & INIT_USE_CACHED)
            goto Cleanup;
        else
            ClearOMInterfaces();
    }

    // make sure we know what we have been given.
    hr = (pUnk->QueryInterface(IID_IXMLDOMDocument, (void**)&_pInnerXMLDoc));
    if (hr)
        goto Cleanup;

    // find the data value...
    hr = _pInnerXMLDoc->get_documentElement( &_pRoot );
    if (hr)
        goto Cleanup;

    // but in most cases the xmlObject is a big bucket, and we would like
    // to set the _pRoot to the subtree associated with our own _pPeerElement.
    // if this root doesn't exist, create it.  we try to find an ID first, if 
    // if it is not there, then create a unique name for this child subtree 
    // but appending the srcID to the tagName.

    _pPeerSite->GetElement(&pPeerElement);
    if (!pPeerElement)
        goto Cleanup;

    hr = pPeerElement->get_id(&bstrTag);
    if (hr || !bstrTag || !SysStringLen(bstrTag))
    {
        SysFreeString(bstrTag);

        hr = pPeerElement->get_sourceIndex(&lElemID);
        if (hr)
            goto Cleanup;

        hr = pPeerElement->get_tagName(&bstrTag);
        if (hr)
            goto Cleanup;

        hr = cbsID.QuickAppend(bstrTag);
        SysFreeString(bstrTag);
        if (hr)
            goto Cleanup;

        hr = cbsID.QuickAppend(lElemID);
        if (hr)
            goto Cleanup;

        bstrTag = SysAllocString(cbsID);
    }

    if (!bstrTag)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // now we can actually see if there is a child of this name
    //   We need to do this by looping over the childNode collection
    //   and looking for one with our name.
    //--------------------------------------------------------------
    hr = _pRoot->get_childNodes(&pChildren);
    if (FAILED(hr))
        goto Cleanup;

    if (hr == S_OK)
    {
        long i, iLen;
        
        hr = pChildren->get_length(&iLen);
        if (FAILED(hr))
            goto Cleanup;

        for (i=0; i < iLen; i++)
        {
            IXMLDOMNode * pTemp = NULL;
            BSTR       bstrNodeName = NULL;
            BOOL       fEqual = FALSE;

            hr= pChildren->get_item(i, &pTemp);
            if (FAILED(hr))
                break;
            
            hr = pTemp->get_nodeName( &bstrNodeName );
            if (FAILED(hr))
                break;

            fEqual = ! _wcsicmp(bstrTag, bstrNodeName);

            SysFreeString(bstrNodeName);

            if (fEqual)
            {
                // transfer ownership
                pSubTree = pTemp;
                break;
            }

            ClearInterface( &pTemp );
        }
    }

    if(pSubTree)
    {
        // yes there's a child so use it, we have a domnode so we need to
        // qi for the element
        ClearInterface(&_pRoot);
        hr = pSubTree->QueryInterface(IID_IXMLDOMElement, (void**)&_pRoot);
    }
    else
    {
        // no child yet so lets create one.
        hr = _pInnerXMLDoc->createElement(bstrTag, &pNewChild);
        if (hr || ! pNewChild)
            goto Cleanup;

        hr = _pRoot->appendChild(pNewChild, NULL);
        if (hr)
            goto Cleanup;

        ClearInterface(&_pRoot);
        _pRoot=pNewChild;
        pNewChild = NULL;   // transfer ownership
    }


Cleanup:
    ReleaseInterface(pPeerElement);
    SysFreeString(bstrTag);
    ReleaseInterface(pChildren);
    ReleaseInterface(pSubTree);
    ReleaseInterface(pNewChild);
    return( hr );
}


//---------------------------------------------------------------------------
//
//  Member:     CPersistDataPeer::getAttribute
//
//  Synopsis:   IHTMLPersistData OM method implementation
//
//---------------------------------------------------------------------------

HRESULT
CPersistDataPeer::getAttribute (BSTR strName, VARIANT * pvarValue )
{
    HRESULT hr = S_OK;

    if (!pvarValue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    VariantClear(pvarValue);

    if (!strName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = InitOM();
    if (hr) 
    {
        // no OM pointers so fail silently
        hr = S_OK;
        goto Cleanup;
    }

    // get the child of the root that has the name strName
    if (_pRoot)
    {
        hr = _pRoot->getAttribute(strName, pvarValue);
        if (hr ==S_FALSE)
            hr = S_OK;
    }

Cleanup:
    return hr ;
}


//---------------------------------------------------------------------------
//
//  Member:     CPersistDataPeer::setAttribute
//
//  Synopsis:   IHTMLPersistData OM method implementation
//
//---------------------------------------------------------------------------

HRESULT
CPersistDataPeer::setAttribute (BSTR strName, VARIANT varValue)
{
    HRESULT  hr = S_OK;

    if (!strName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = InitOM();
    if (hr) 
    {
        // no OM pointers so fail silently
        hr = S_OK;
        goto Cleanup;
    }

    // save this value as an attribute on the root.
    if (_pRoot)
    {
        // TODO - look into just passing the variant into the xml object
        // and let them worry about all the types... We do the processing below
        // to be safe for now.
        VARIANT * pvar = NULL;
        CVariant cvarTemp;

        if ((V_VT(&varValue)==VT_BSTR) || 
             V_VT(&varValue)==(VT_BYREF|VT_BSTR))
        {
            pvar = (V_VT(&varValue) & VT_BYREF) ?
                    V_VARIANTREF(&varValue) : &varValue;
        }
        else if ((V_VT(&varValue)==VT_BOOL ||
                 V_VT(&varValue)==(VT_BYREF|VT_BOOL)))
        {
            // sadly, do our own bool conversion...
            VARIANT_BOOL vbFlag = (V_VT(&varValue)==VT_BOOL) ?
                                   V_BOOL(&varValue) :
                                   V_BOOL( V_VARIANTREF(&varValue) );

            V_VT(&cvarTemp) = VT_BSTR;
            V_BSTR(&cvarTemp) = vbFlag ? SysAllocString(L"true") :
                                         SysAllocString(L"false");

            pvar = & cvarTemp;
        }
        else
        {
            pvar = &varValue;

            hr = VariantChangeTypeEx(pvar, pvar, LCID_SCRIPTING, 0, VT_BSTR);
            if (hr)
                goto Cleanup;
        }


        hr = _pRoot->setAttribute(strName, *pvar);
        if (hr ==S_FALSE)
            hr = S_OK;
    }

Cleanup:
    return hr;
}

//---------------------------------------------------------------------------
//
//  Member:     CPersistDataPeer::removeDataValue
//
//  Synopsis:   IHTMLPersistData OM method implementation
//
//---------------------------------------------------------------------------

HRESULT
CPersistDataPeer::removeAttribute (BSTR strName)
{
    HRESULT hr = S_OK;

    if (!strName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = InitOM();
    if (hr) 
    {
        // no OM pointers so fail silently
        hr = S_OK;
        goto Cleanup;
    }

    // get the child of the root that has the name strName
    if (_pRoot)
    {
        hr = _pRoot->removeAttribute(strName);
        if (hr ==S_FALSE)
            hr = S_OK;
    }

Cleanup:
    return hr ;
}

//---------------------------------------------------------------------------
//
//  Member:     CPersistDataPeer::get_XMLDocument
//
//  Synopsis:   IHTMLPersistData OM proeprty implementation. this is the default 
//                  property for this object, and as such it exposes the XMLOM
//                  of the user data.
//
//---------------------------------------------------------------------------

HRESULT
CPersistDataPeer::get_XMLDocument (IDispatch ** ppDisp)
{
    HRESULT hr = S_OK;

    if (!ppDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppDisp = NULL;

    hr = InitOM();
    if (hr) 
    {
        // no OM pointers so fail silently
        hr = S_OK;
        goto Cleanup;
    }

    if (_pInnerXMLDoc)
    {
        hr = _pInnerXMLDoc->QueryInterface(IID_IDispatch, 
                                           (void**)ppDisp);
    }

Cleanup:
    return hr;
}


//+-----------------------------------------------------------
//
//  Member : GetSaveCategory
//
//  Synopsis : this helper function turns the tagName fo the 
//      pPeerElement, into the category for its save operations.
//
//+-----------------------------------------------------------
ENUM_SAVE_CATEGORY
CPersistDataPeer::GetSaveCategory()
{
    HRESULT            hr = S_OK;
    CVariant           cvarTag;
    IHTMLElement     * pPeerElement = NULL;
    ENUM_SAVE_CATEGORY escRet = ESC_UNKNOWN;

    _pPeerSite->GetElement(&pPeerElement);
    if (!pPeerElement)
        goto Cleanup;

    V_VT(&cvarTag) = VT_BSTR;
    hr = pPeerElement->get_tagName(&V_BSTR(&cvarTag));
    if (hr)
        goto Cleanup;

    // there's got to be a better way to do this, but for
    // now I will try to put the most common ones in front.
    if (0==_wcsicmp(V_BSTR(&cvarTag), L"input"))
    {
        // but wait!!!! don't save password type inputs
        BSTR     bstrType = SysAllocString(L"type");
        CVariant cvarVal;

        escRet = ESC_INTRINSIC;
        if (!bstrType)
            goto Cleanup;

        hr = (pPeerElement->getAttribute(bstrType, 0, &cvarVal));
        SysFreeString(bstrType);
        if (hr)
            goto Cleanup;

        if (V_VT(&cvarVal) == VT_BSTR &&
            0==_wcsicmp(V_BSTR(&cvarVal), L"password"))
        {
            escRet = ESC_PASSWORD;
            goto Cleanup;
        }
    }
    else if (0==_wcsicmp(V_BSTR(&cvarTag), L"script"))
    {
        escRet = ESC_SCRIPT;
    }
    else if (0==_wcsicmp(V_BSTR(&cvarTag), L"select")   ||
             0==_wcsicmp(V_BSTR(&cvarTag), L"textarea") ||
             0==_wcsicmp(V_BSTR(&cvarTag), L"richtext") ||
             0==_wcsicmp(V_BSTR(&cvarTag), L"button")   ||
             0==_wcsicmp(V_BSTR(&cvarTag), L"fieldset") 
            )
    {
        escRet = ESC_INTRINSIC;
    }
    else if (0==_wcsicmp(V_BSTR(&cvarTag), L"object") || 
             0==_wcsicmp(V_BSTR(&cvarTag), L"embed")  ||
             0==_wcsicmp(V_BSTR(&cvarTag), L"applet")
            )
    {
        escRet = ESC_CONTROL;
    }


Cleanup:
    ReleaseInterface(pPeerElement);
    return escRet;
}

//+-----------------------------------------------------------
//
//  member : GetEngineClsidForLanguage ()
//
//  synopsis : another helper method that returns the CLSID of the
//   scripdEngine associated with the language progID.
//
//+-----------------------------------------------------------
HRESULT
CPersistDataPeer::GetEngineClsidForLanguage(CLSID * pclsid, 
                                            IHTMLDocument2 * pBrowseDoc)
{
    HRESULT hr = S_OK;
    BSTR    bstrLanguage = NULL;
    IHTMLElement * pPeerElement = NULL;


    if (!pclsid)
        return E_POINTER;

    *pclsid = IID_NULL;

    _pPeerSite->GetElement(&pPeerElement);
    if (!pPeerElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // what language script engine to instantiate?
    hr = (pPeerElement->get_language(&bstrLanguage));
    if (hr)
        goto Cleanup;

    if (!bstrLanguage || !SysStringLen(bstrLanguage))
    {
        IHTMLElementCollection * pCollection = NULL;

        hr = E_FAIL;

        if (bstrLanguage)
        {
            SysFreeString(bstrLanguage);
            bstrLanguage = NULL;
        }

        // use the default language, we get this from the language of 
        // first script block in the document.
        if (!FAILED(pBrowseDoc->get_scripts(&pCollection)))
        {
            CVariant    cvarID;
            CVariant    cvarEmpty;
            IDispatch * pDisp;

            V_VT(&cvarID) = VT_I4;
            V_I4(&cvarID) = 0;

            if (!FAILED(pCollection->item(cvarID, cvarEmpty, &pDisp)))
            {
                IHTMLElement     * pFirstScript = NULL;

                if (pDisp &&
                    !FAILED(pDisp->QueryInterface(IID_IHTMLElement, 
                                                      (void**)&pFirstScript)))
                {
                    pFirstScript->get_language(&bstrLanguage);
                    if (bstrLanguage && SysStringLen(bstrLanguage))
                        hr = CLSIDFromProgID ( bstrLanguage, pclsid );

                    ReleaseInterface(pFirstScript);
                }

                ReleaseInterface(pDisp);
            }

            ReleaseInterface(pCollection);
        }

        if (hr)
        {
            hr = CLSIDFromProgID ( L"JScript", pclsid );
        }
    }
    else
    {
        hr = CLSIDFromProgID ( bstrLanguage, pclsid );
    }

Cleanup:
    SysFreeString(bstrLanguage);
    ReleaseInterface(pPeerElement);
    return ( hr );
}
//+-----------------------------------------------------------
//
//  Member  GetScriptEngine
//
//  Synopsis : helper method - this creates the appropriate script 
//      engine, and parses in the text of hte script block that we
//      are interested in.
//
//+-----------------------------------------------------------

IActiveScript * 
CPersistDataPeer::GetScriptEngine(IHTMLDocument2 * pBrowseDoc, ULONG * puFlags)
{
    HRESULT              hr = S_OK;
    BSTR                 bstrCode = NULL;
    CLSID                clsID;
    CLSID                clsIDTarget;
    IActiveScript      * pScriptEngine = NULL;
    IActiveScriptSite  * pScriptSite = NULL;
    IActiveScriptParse * pASP = NULL;
    IHTMLScriptElement * pScriptElem = NULL;
    IHTMLElement       * pPeerElement = NULL;


    hr = (GetEngineClsidForLanguage(&clsID, pBrowseDoc));
    if (hr)
        goto Cleanup;

    // set the return flags, so that these tests only need to be done once
    // some callers need to know if the script block is jscript, vbscript,
    // of something else
    if (!FAILED(CLSIDFromProgID ( _T("JScript"), &clsIDTarget )) &&
        (clsID == clsIDTarget))
    {
        *puFlags = SCRIPT_ENGINE_JSCRIPT;
    }
    else if (!FAILED(CLSIDFromProgID ( _T("VBScript"), &clsIDTarget )) &&
        (clsID == clsIDTarget))
    {
        *puFlags = SCRIPT_ENGINE_VBSCRIPT;
    }
    else
        *puFlags = SCRIPT_ENGINE_OTHER;


    // create the script engine 
    hr = CoCreateInstance( clsID, NULL, CLSCTX_INPROC_SERVER,
            IID_IActiveScript,(void **)&pScriptEngine);
    if ( hr )
        goto Cleanup;

    // get the scriptSite interface from ourselves.
    hr = (QueryInterface(IID_IActiveScriptSite, (void**) &pScriptSite));
    if (hr)
        goto Cleanup;

    hr = pScriptEngine->SetScriptSite(pScriptSite);
    ReleaseInterface(pScriptSite);  // engine should have addref'd 
    if ( FAILED(hr) )
        goto Error;

    // prepare to load out text 
    hr = (pScriptEngine->QueryInterface (IID_IActiveScriptParse, (void**)&pASP));
    if ( hr )
        goto Error;

    hr = (pASP->InitNew());
    if ( hr )
        goto Error;

    _pPeerSite->GetElement(&pPeerElement);
    if (!pPeerElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // get the text of the script element
    hr = (pPeerElement->QueryInterface(IID_IHTMLScriptElement, (void**)&pScriptElem));
    if ( hr )
        goto Error;

    hr = (pScriptElem->get_text(&bstrCode));
    if ( hr || !bstrCode)
        goto Error;

    hr = pASP->ParseScriptText( bstrCode,  
                                NULL,                 // Item Name (Namespace)
                                NULL,                 // context
                                NULL,                 // delimiter
                                0,                    // srcContext Cookie
                                0,                    // ulStarting Line
                                SCRIPTTEXT_ISVISIBLE, //dwFlags
                                NULL,                 // pVarResult
                                NULL );               // pException Info
    if ( hr )
        goto Error;

    hr = pScriptEngine->SetScriptState(SCRIPTSTATE_CONNECTED);
    if ( FAILED(hr) )
        goto Error;

Cleanup:
    SysFreeString(bstrCode);
    ReleaseInterface(pPeerElement);
    ReleaseInterface(pScriptElem);
    ReleaseInterface(pASP);
    return pScriptEngine;

Error:
    ClearInterface(&pScriptEngine);
    goto Cleanup;
}


//+-----------------------------------------------------------
//
//  Member  BuildNewScriptBlock
//
//  Synopsis : helper method, this does the real work of snapshotting a 
//      script block.  IF the script is VBSCRIPT or JSCRIPT the appropriate 
//      syntax is used.  for any other language, we convert to JScript.
//
//+-----------------------------------------------------------
HRESULT
CPersistDataPeer::BuildNewScriptBlock(CBufferedStr * pstrBuffer, ULONG *puFlags)
{
    HRESULT          hr    = S_OK;
    IDispatch      * pScriptNameSpace = NULL;
    IDispatchEx    * pDispScript    = NULL;
    IDispatchEx    * pBrowseWin     = NULL;
    DISPID           dispidName;
    BSTR             bstrName       = NULL;
    IHTMLWindow2   * pWin           = NULL;
    IActiveScript  * pScriptEngine  = NULL;
    IDispatch      * pdispBrowseDoc = NULL;
    IHTMLDocument2 * pBrowseDoc     = NULL;
    IHTMLElement   * pPeerElement   = NULL;


    _pPeerSite->GetElement(&pPeerElement);
    if (!pPeerElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = (pPeerElement->get_document(&pdispBrowseDoc));
    if (hr)
        goto Cleanup;

    hr = (pdispBrowseDoc->QueryInterface(IID_IHTMLDocument2, 
                                            (void**)&pBrowseDoc));
    if (hr)
        goto Cleanup;

    pScriptEngine = GetScriptEngine(pBrowseDoc, puFlags);
    if (!pScriptEngine)
        goto Cleanup;   // fail silently


    // loop over all the dispatches in the script engine's name 
    //   space and get thier values.from..pSrcDoc
    hr = pScriptEngine->GetScriptDispatch( NULL, &pScriptNameSpace );
    if ( hr )
        goto Cleanup;

    hr = (pScriptNameSpace->QueryInterface( IID_IDispatchEx, (void**)&pDispScript));
    if ( hr )
        goto Cleanup;

    // inorder to derefernce the script variables we need the browse
    // documents window.
    hr = (pBrowseDoc->get_parentWindow(&pWin));
    if(hr)
        goto Cleanup;

    hr = (pWin->QueryInterface(IID_IDispatchEx, (void**)&pBrowseWin));
    if (hr)
        goto Cleanup;

    // now run through all the objects in this script engine and 
    // find their values 
    hr = (pDispScript->GetNextDispID(0, DISPID_STARTENUM, &dispidName));
    if (hr)
        goto Cleanup;

    while (dispidName)
    {
        hr = (pDispScript->GetMemberName(dispidName, &bstrName));
        if (!hr && bstrName)
        {
            DISPID  dispidBrowser;

            if (!FAILED(pBrowseWin->GetDispID(bstrName, fdexNameCaseSensitive, &dispidBrowser)))
            {
                DISPPARAMS dp;
                CVariant cvarRes;
                BOOL fNeedsQuotesInScript = FALSE;

                dp.rgvarg = NULL;
                dp.rgdispidNamedArgs = NULL;
                dp.cArgs = 0;
                dp.cNamedArgs = 0;

                hr = (pBrowseWin->Invoke(dispidBrowser,
                                             IID_NULL,  
                                             LCID_SCRIPTING,   
                                             DISPATCH_PROPERTYGET,
                                             &dp,                 
                                             &cvarRes,            
                                             NULL,                
                                             NULL));


                fNeedsQuotesInScript = (V_VT(&cvarRes) == VT_BSTR);

                // Filter out VT_IDISPATCH & VT_UNKNOWN
                if (!hr && 
                    V_VT(&cvarRes) != VT_DISPATCH &&
                    V_VT(&cvarRes) != VT_UNKNOWN   &&
                    !FAILED(cvarRes.CoerceVariantArg(VT_BSTR)))
                {
                    // assume JSCript if not VBScript
                    LPTSTR  pstrAssign = (*puFlags & SCRIPT_ENGINE_VBSCRIPT) ? 
                                                _T("\n\r    dim ") : 
                                                _T("\n\r    var ");


                    // concatenate on the end of the buffer.
                    //  "\n\r    var <name> = " <value>";  "
                    hr = pstrBuffer->QuickAppend(pstrAssign);
                    if (hr)
                        goto Cleanup;
                    hr = pstrBuffer->QuickAppend(bstrName);
                    if (hr)
                        goto Cleanup;

                    // if vbscript, put assignment on its own line.
                    if (*puFlags & SCRIPT_ENGINE_VBSCRIPT)
                    {
                        hr = pstrBuffer->QuickAppend(_T("\n\r        "));
                        if (hr)
                            goto Cleanup;
                        hr = pstrBuffer->QuickAppend(bstrName);
                        if (hr)
                            goto Cleanup;
                    }

                    // now handle outputing the assignment itself, careful
                    // to only put quotes around things that were strings.
                    hr = pstrBuffer->QuickAppend(_T(" = "));
                    if (hr)
                        goto Cleanup;

                    if (fNeedsQuotesInScript )
                    {
                        hr = pstrBuffer->QuickAppend(_T("\""));
                        if (hr)
                            goto Cleanup;
                    }

                    if (V_VT(&cvarRes) != VT_EMPTY)
                    {
                        hr = pstrBuffer->QuickAppend(V_BSTR(&cvarRes));
                    }
                    else
                    {
                        // someone had dim x = Empty in their script
                        // or var x = document.expando
                        // and this doesn't coerc to a bstr (returned S_FALSE)
                        // don't reset the use quotes flag,  
                        // for jscript convert to null, for vb
                        if (!(*puFlags & SCRIPT_ENGINE_VBSCRIPT))
                        {
                            hr = pstrBuffer->QuickAppend(_T("null"));
                        }
                        else
                            hr = pstrBuffer->QuickAppend(_T("Empty"));
                    }
                    if (hr)
                        goto Cleanup;

                    if (fNeedsQuotesInScript )
                    {
                        hr = pstrBuffer->QuickAppend(_T("\""));
                        if (hr)
                            goto Cleanup;
                    }

                    // VBSCRIPT doesn need ';' at the eol
                    if (!(*puFlags & SCRIPT_ENGINE_VBSCRIPT))
                    {
                        hr = pstrBuffer->QuickAppend(_T(";"));
                    }

                    if (hr)
                        goto Cleanup;
                }
            }

            SysFreeString(bstrName);
            bstrName = NULL;
        }
            
        hr = (pDispScript->GetNextDispID(0, dispidName, &dispidName));
        if (hr==S_FALSE)
        {  
            hr = S_OK;
            break;
        }
        else if (hr)
            goto Cleanup;
    }

 
Cleanup:
    if (pScriptEngine)
        pScriptEngine->Close();
    if (bstrName)
        SysFreeString(bstrName);
    ReleaseInterface(pPeerElement);
    ReleaseInterface(pBrowseDoc);
    ReleaseInterface(pScriptEngine);
    ReleaseInterface(pdispBrowseDoc);
    ReleaseInterface(pWin);
    ReleaseInterface(pBrowseWin);
    ReleaseInterface(pDispScript);
    ReleaseInterface(pScriptNameSpace);
    // no partial string in an error case... 
    if (hr)
        pstrBuffer->Set();

    return( hr );
}




//+-----------------------------------------------------------
//
// member : SaveHandler_GenericTag
//
// synopsis : this does the generic handling when a tag has the
//      persistence peer. It simply gets the outerHTML and saves that
//      in the XML object.  on the load the element will be hit
//      with a put_outerHTML of this string.
//
//+-----------------------------------------------------------
HRESULT
CPersistDataPeer::SaveHandler_GenericTag()
{
    HRESULT        hr = S_OK;
    CVariant       cvarOuter;
    IHTMLElement * pPeerParent = NULL;
    IHTMLElement * pPeerElement = NULL;

    _pPeerSite->GetElement(&pPeerElement);
    if (!pPeerElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // for elements in the head, we don't want to do this since
    // there is a tree limitation that doesn't allow the outerHTML
    // to be set.
    hr = pPeerElement->get_parentElement(&pPeerParent);
    if (hr)
        goto Cleanup;

    // the right way to do this is to ask the question:
    // are we in the body/frameset, NOT is our parent the
    // head, so...
    while (pPeerParent)
    {
        CVariant       cvarTag;
        IHTMLElement * pTemp = NULL;

        V_VT(&cvarTag) = VT_BSTR;
        hr = pPeerParent->get_tagName(&V_BSTR(&cvarTag));
        if (hr)
            goto Cleanup;

        if (0==_wcsicmp(V_BSTR(&cvarTag), L"body") ||
            0==_wcsicmp(V_BSTR(&cvarTag), L"frameset"))
            break;

        hr = pPeerParent->get_parentElement(&pTemp);
        if (hr)
            goto Cleanup;

        ClearInterface(&pPeerParent);
        pPeerParent = pTemp;
    }

    if (!pPeerParent)
        goto Cleanup;

    hr = pPeerElement->get_outerHTML(&V_BSTR(&cvarOuter));
    if (hr)
        goto Cleanup;

    V_VT(&cvarOuter) = VT_BSTR;

    // now save the outerHTML string
    hr = _pRoot->setAttribute(_T("__NEW_TAG_OUTER"), cvarOuter);
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pPeerElement);
    ReleaseInterface(pPeerParent);
    return( hr );
}


//+----------------------------------------------------------------------------
//
//  Member : LoadHandler_GenericTag()
//
//  Synopsis : this restores the outerHTML of the tag as it is loaded
//
//+----------------------------------------------------------------------------
HRESULT
CPersistDataPeer::LoadHandler_GenericTag()
{
    HRESULT          hr = S_OK;
    CVariant         cvarOuter;
    IHTMLElement   * pPeerElement   = NULL;

   if (!_pRoot)
        goto Cleanup;

    _pPeerSite->GetElement(&pPeerElement);
    if (!pPeerElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // now get the outerHTML string
    hr = _pRoot->getAttribute(_T("__NEW_TAG_OUTER"), &cvarOuter);
    if (hr)
        goto Cleanup;

    hr = cvarOuter.CoerceVariantArg(VT_BSTR);
    if (hr)
        goto Cleanup;

    hr = pPeerElement->put_outerHTML(V_BSTR(&cvarOuter));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pPeerElement);
    return( hr );
}


//+------------------------------------------------------------------------------
//
//  Member : SaveHandler_ScriptTag()
//
//  Synopsis : saves the script into the xml store.  We do this in the standard way:
//      1- create a private script engin,
//      2- load it with the text of the peer's script block
//      3 - walk through its namespace pulling out the variables
//      4 - create a list of name value pairs as the new script block
//      5 - save this block in the appropriate place
//
//+------------------------------------------------------------------------------

HRESULT
CPersistDataPeer::SaveHandler_ScriptTag()
{
    HRESULT          hr = S_OK;
    CVariant         cvarText;
    BSTR             bstrLanguage = NULL;
    CLSID            clsIDTarget;
    CLSID            clsIDLang;
    CBufferedStr     cbsNewScript;
    IDispatch      * pdispBrowseDoc = NULL;
    IHTMLDocument2 * pBrowseDoc     = NULL;
    IHTMLElement   * pPeerElement   = NULL;
    ULONG            uFlags = 0;


    if (!_pRoot)
        goto Cleanup;

    _pPeerSite->GetElement(&pPeerElement);
    if (!pPeerElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pPeerElement->get_document(&pdispBrowseDoc);
    if (hr)
        goto Cleanup;

    hr = pdispBrowseDoc->QueryInterface(IID_IHTMLDocument2, 
                                            (void**)&pBrowseDoc);
    if (hr)
        goto Cleanup;

    // get the new script block, and the language that it
    // originated from
    hr = BuildNewScriptBlock(&cbsNewScript, &uFlags);
    if (hr)
        goto Cleanup;

    // Language can only be set in design mode,  as a result
    // we can't change the script block since we don't know the
    //  syntax for an arbitrary script engine.  so, only save
    //  script if this is javascript or vbscript.
    if (uFlags & SCRIPT_ENGINE_OTHER)
        goto Cleanup;

    V_VT(&cvarText) = VT_BSTR;
    V_BSTR(&cvarText) = SysAllocString((LPTSTR)cbsNewScript);
    if (!V_BSTR(&cvarText))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    hr = _pRoot->setAttribute(_T("__NEW_SCRIPT_TEXT"), cvarText);
    if (hr)
        goto Cleanup;

Cleanup:
    SysFreeString(bstrLanguage);
    ReleaseInterface(pPeerElement);
    ReleaseInterface(pBrowseDoc);
    ReleaseInterface(pdispBrowseDoc);
    return( hr );
}


//+----------------------------------------------------------------------------
//
//  Member : LoadHandler_ScriptTag()
//
//  Synopsis : does the load - but wait... 
//      NYI - put_text is design time only, so the peer needs a different way
//      of sliding this in.
//
//+----------------------------------------------------------------------------

HRESULT
CPersistDataPeer::LoadHandler_ScriptTag()
{
    HRESULT   hr = S_OK;
    CVariant  cvarText;

    if (!_pRoot)
        goto Cleanup;

    // try to get the new text from the saved XML
    hr = _pRoot->getAttribute(_T("__NEW_SCRIPT_TEXT"), &cvarText);
    if (hr)
        goto Cleanup;

    // if there is script text, then we need to set this into the 
    // browse window's namespace


Cleanup:
    if (hr == S_FALSE) hr = S_OK;
    return( hr );
}


//===============================================================
//
//  Class : CPersistShortcut
//
//  synopsis : derives from CPersistDataPeer and does the special handling 
//       related to the shortcut functionality
//
//===============================================================



//+----------------------------------------------------------------
//
// Member : save
//
//  synopsis: over ride of parent functionality to deal with shortcut
//      specific stuff...
//
//-----------------------------------------------------------------
HRESULT 
CPersistShortcut::save(IUnknown * pUnk, 
                       long lType, 
                       VARIANT_BOOL *pfContinue)
{
    HRESULT hr;

    if (lType != (long)htmlPersistStateFavorite)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = super::save(pUnk, lType, pfContinue);

    if (hr || (*pfContinue == VB_FALSE))
        goto Cleanup;

    // do the particular tag handling related to shortcuts
    switch (GetSaveCategory())
    {
    case ESC_UNKNOWN:
    case ESC_INTRINSIC:
    case ESC_CONTROL:
        hr = SaveHandler_GenericTag();
        break;

//    case ESC_SCRIPT:
//        hr = SaveHandler_ScriptTag();
//        break;

    default:
        break;
    }

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member : Load
//
//  Synopsis : Implementation of the IHTMLPersistenceCache method
//
//-----------------------------------------------------------------------------

HRESULT
CPersistShortcut::load(IUnknown * pUnk, 
                       long lType, 
                       VARIANT_BOOL *pfDoDefault)
{
    HRESULT          hr;

    if (lType != (long)htmlPersistStateFavorite)
    {
        hr = S_OK;
        goto Cleanup;
    }

    // fire the event first, since the pPeerElement is about to be
    //  removed from the tree entirely.  Of course, if the user sets 
    // expandoes on this, they will get lost, but the alternative is to
    // loose access to the xmlcache.  So, if you think about it, they get
    // outerHTML behaviour, and using XMLCache behavior means
    // that you better cancel default behavior.
    hr = super::load(pUnk, lType, pfDoDefault);
    // is default load behavior canceled ?
    if (hr || (*pfDoDefault == VB_FALSE))
        goto Cleanup;

    switch (GetSaveCategory())
    {
    case ESC_UNKNOWN:
    case ESC_INTRINSIC:
    case ESC_CONTROL:
        hr = LoadHandler_GenericTag();
        break;

//    case ESC_SCRIPT:
//        hr = LoadHandler_ScriptTag();
//        break;

    default:
        break;
    }


Cleanup:
    return hr;
}


//===============================================================
//
//  Class : CPersistHistory
//
//  synopsis : derives from CPersistDataPeer and does the special handling 
//       related to the History functionality
//
//===============================================================


//+----------------------------------------------------------------
//
// Member : save
//
//  synopsis: over ride of parent functionality to deal with shortcut
//      specific stuff...
//
//-----------------------------------------------------------------
HRESULT 
CPersistHistory::save(IUnknown * pUnk, 
                       long lType, 
                       VARIANT_BOOL *pfContinue)
{
    HRESULT hr;

    if (lType != (long)htmlPersistStateHistory)
    {
        hr = S_OK;
        goto Cleanup;
    }

     hr = super::save(pUnk, lType, pfContinue);
    if (hr || (*pfContinue == VB_FALSE))
        goto Cleanup;

    // do any tag specific handling that history needs
    switch (GetSaveCategory())
    {
        // if we don't know anything special to do with this tag, just
        // transfer over its outerHTML on the assumption that the author
        // knows what they are doing
    case ESC_UNKNOWN:
    case ESC_INTRINSIC:
        hr = SaveHandler_GenericTag();
        break;

//    case ESC_SCRIPT:
//        hr = SaveHandler_ScriptTag();
//        break;

    default :
        break;
    }

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member : Load
//
//  Synopsis : Implementation of the IHTMLPersistenceCache method
//
//-----------------------------------------------------------------------------

HRESULT
CPersistHistory::load(IUnknown * pUnk, 
                       long lType, 
                       VARIANT_BOOL *pfDoDefault)
{
    HRESULT          hr;

    if (lType != (long)htmlPersistStateHistory)
    {
        hr = S_OK;
        goto Cleanup;
    }

    // cache the OM pointers
    hr = InitOM(pUnk, lType);
    if (hr)
        goto Cleanup;

    hr = super::load(pUnk, lType, pfDoDefault);
    // is default load behavior canceled ?
    if (hr || (*pfDoDefault == VB_FALSE))
        goto Cleanup;

//  ISSUE (carled) NYI - script retoration presents a unique challenge 
//  because this needs to execute inline instead of the original 
//  script block text.
    switch(GetSaveCategory())
    {
//    case ESC_SCRIPT:
//        hr = LoadHandler_ScriptTag();
//        break;

    case ESC_UNKNOWN:
    case ESC_INTRINSIC:
        hr = LoadHandler_GenericTag();
        break;

    default:
        break;
    }

Cleanup:
    return hr;
}


//===============================================================
//
//  Class : CPersistSnapshot
//
//  synopsis : derives from CPersistDataPeer and does the special handling 
//       related to the run-time same (snapshot) functionality
//
//===============================================================


//+----------------------------------------------------------------
//
// Member : CPersistSnapshot::save
//
//  synopsis: over ride of parent functionality to deal with shortcut
//      specific stuff...
//      Since it doesn't make much sense to allow theXMLOM to be acccessed
//      in this case, calling super:: pretty much only fires the event.
//
//-----------------------------------------------------------------
HRESULT 
CPersistSnapshot::save(IUnknown * pUnk, 
                       long lType, 
                       VARIANT_BOOL *pfContinue)
{
    HRESULT          hr;
    CVariant         cvarTag;
    IHTMLDocument2 * pDesignDoc = NULL;

    if (lType != (long)htmlPersistStateSnapshot)
    {
        hr = S_OK;
        goto Cleanup;
    }

    if (!pUnk)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = pUnk->QueryInterface(IID_IHTMLDocument2, (void**)&pDesignDoc);
    if (hr)
        goto Cleanup;

    // allow the onsave event to be fired.
    hr = super::save(NULL, lType, pfContinue);
    if (hr || (*pfContinue == VB_FALSE))
        goto Cleanup;

    // now that the author has had the oppurtunity to set expandoes,
    // and value properties, we start the real work of snapshot saveing.
    switch (GetSaveCategory())
    {
    case ESC_CONTROL:
        hr = TransferControlValues(pDesignDoc);
        break;

    case ESC_SCRIPT:
        hr = TransferScriptValues(pDesignDoc);
        break;

    case ESC_UNKNOWN:
        // if we don't know anything special to do with this tag, just
        // transfer over its outerHTML on the assumption that the author
        // knows what they are doing
    case ESC_INTRINSIC:
        hr = TransferIntrinsicValues(pDesignDoc);
        break;

    default:
        break;
    }

Cleanup:
    ReleaseInterface(pDesignDoc);
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member : CPersistSnapshot::Load
//
//  Synopsis : Implementation of the IHTMLPersistenceCache method
//      Since it doesn't make much sense to allow theXMLOM to be acccessed
//      in this case, calling super:: pretty much only fires the event.
//
//-----------------------------------------------------------------------------

HRESULT
CPersistSnapshot::load(IUnknown * pUnk, 
                       long lType, 
                       VARIANT_BOOL *pfDoDefault)
{
    HRESULT          hr;

    if (lType != (long)htmlPersistStateSnapshot)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = super::load(pUnk, lType, pfDoDefault);

Cleanup:
    return hr;
}


//+-----------------------------------------------------------
//
// member : GetDesignElem
//
// Synposis : this helper function is responsible for finding the
//      design document's element counterpart to our pPeerElement.
//
//+-----------------------------------------------------------
IHTMLElement *
CPersistSnapshot::GetDesignElem(IHTMLDocument2 * pDesignDoc)
{
    HRESULT                  hr = S_OK;
    CVariant                 cvarID;
    CVariant                 cvarEmpty;
    IDispatch              * pDisp = NULL;
    IHTMLElement           * pRetElem = NULL;
    IHTMLElement           * pPeerElement = NULL;
    IHTMLElementCollection * pCollection = NULL;

    _pPeerSite->GetElement(&pPeerElement);
    if (!pPeerElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    V_VT(&cvarID) = VT_BSTR;
    hr = pPeerElement->get_id(&V_BSTR(&cvarID));
    if (hr)
        goto Cleanup;

    // first get the documents all collection.
    hr = pDesignDoc->get_all(&pCollection);
    if (hr)
        goto Cleanup;

    // now find out elements coutner part inthe design document, 
    // if it exits.  Elements that were created by inline scripts,
    // or other script driven means, may not be found.
    hr = pCollection->item(cvarID, cvarEmpty, &pDisp);
    if (hr || !pDisp)
        goto Cleanup;

    // make sure that we do not have a collection...
    hr = pDisp->QueryInterface(IID_IHTMLElement, (void**)&pRetElem);

Cleanup:
    ReleaseInterface(pPeerElement);
    ReleaseInterface(pDisp);
    ReleaseInterface(pCollection);
    return pRetElem;
}

//+-----------------------------------------------------------
//
// member : TransferIntrinsicValues 
//
// synopsis : this transfers the value of the browse-control to the 
//      design control by setting the outerHTML of the design control
//      to that of the browseControl
//
//+-----------------------------------------------------------
HRESULT
CPersistSnapshot::TransferIntrinsicValues (IHTMLDocument2 *pDesignDoc)
{
    HRESULT        hr = S_OK;
    BSTR           bstrOuter = NULL;
    IHTMLElement * pDesignElem = NULL;
    IHTMLElement * pPeerElement = NULL;

    _pPeerSite->GetElement(&pPeerElement);
    if (!pPeerElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pPeerElement->get_outerHTML(&bstrOuter);
    if (hr)
        goto Cleanup;

    pDesignElem = GetDesignElem(pDesignDoc);
    if (!pDesignElem)
        goto Cleanup;

    hr = pDesignElem->put_outerHTML(bstrOuter);

Cleanup:
    SysFreeString(bstrOuter);
    ReleaseInterface(pPeerElement);
    ReleaseInterface(pDesignElem);
    return( hr );
}


//+-----------------------------------------------------------
//
//  Member : TransferControlValues
//
//  Synopsis : Transfers the values of the control by cooking up a 
//      stream and calling IPersitHistory::Save on the browse-control
//      and then feeding that stream into IPersistHistory::Load on
//      the design-control,  Then when the design document is saved,
//      IPersistPropertyBag::save will get called (it is this that finally
//      allows the controls state to be written out as the altHTML attribute.
//
//+-----------------------------------------------------------
HRESULT
CPersistSnapshot::TransferControlValues (IHTMLDocument2 *pDesignDoc)
{
    HRESULT           hr = S_OK;
    IHTMLElement    * pDesignElem = NULL;
    IHTMLElement    * pPeerElement = NULL;
    IPersistHistory * pSrcPH = NULL;
    IPersistHistory * pDesignPH = NULL;
    IStream         * pStream = NULL;
    HGLOBAL           hg = NULL;
    static LARGE_INTEGER i64Zero = {0, 0};

    _pPeerSite->GetElement(&pPeerElement);
    if (!pPeerElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pDesignElem = GetDesignElem(pDesignDoc);
    if (!pDesignElem)
        goto Cleanup;

    // step 1. get the appropriate IPersistHistory interfaces.
    hr = pPeerElement->QueryInterface(IID_IPersistHistory, (void**)&pSrcPH);
    if (hr)
        goto Cleanup;

    hr = (pDesignElem->QueryInterface(IID_IPersistHistory, (void**)&pDesignPH));
    if (hr)
        goto Cleanup;

    // step 2. create a temporary stream
    hg = GlobalAlloc(GMEM_MOVEABLE, 0);
    if (!hg)
    {  
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = (CreateStreamOnHGlobal(hg, TRUE, &pStream));
    if (hr)
        goto Cleanup;

    // Step 3. save the browse object
    hr = (pSrcPH->SaveHistory(pStream));
    if (hr)
        goto Cleanup;

    // Step 4. reset the stream
    hr = (pStream->Seek(i64Zero, STREAM_SEEK_SET, NULL));
    if (hr)
        goto Cleanup;

    // Stpe 5. Load the design object.
    hr = (pDesignPH->LoadHistory(pStream, NULL));
    if (hr)
        goto Cleanup;

Cleanup:
    // ISSUE (carled) is there a memory leak here? the hGlobal was allocated,
    //   a stream was created, and freed but where does the memory get freed?
    ReleaseInterface(pPeerElement);
    ReleaseInterface(pStream);
    ReleaseInterface(pSrcPH);
    ReleaseInterface(pDesignPH);
    ReleaseInterface(pDesignElem);
    return( (hr == E_NOINTERFACE)? S_OK : hr );
}


//+-----------------------------------------------------------
//
//  Member : TransferScriptValues
//
//  Synopsis: transfers the values of script blocks, by loading this
//      script into a private script engine, and then iterating over all
//      the values and getting the current values from the browse document.
//      These (Variable, Value) pairs are then spit out as the new innerHTML
//      of the design-script element.
//
//+-----------------------------------------------------------

HRESULT
CPersistSnapshot::TransferScriptValues (IHTMLDocument2 *pDesignDoc)
{ 
    HRESULT          hr = S_OK;
    IHTMLElement   * pDesignElem  = NULL;
    BSTR             bstrNewBlock = NULL;
    CBufferedStr     cbsNewScript;
    ULONG            uFlags       = 0;
    IHTMLScriptElement * pScriptElem = NULL;

    pDesignElem = GetDesignElem(pDesignDoc);
    if (!pDesignElem)
        goto Cleanup;

    // get the text of the new script block
    hr = (BuildNewScriptBlock(&cbsNewScript, &uFlags));
    if (hr)
        goto Cleanup;

    bstrNewBlock = SysAllocString((LPTSTR)cbsNewScript);
    if (!bstrNewBlock)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Set the new script assignments 
    hr = (pDesignElem->QueryInterface(IID_IHTMLScriptElement, (void**)&pScriptElem));
    if ( hr )
        goto Cleanup;

    hr = (pScriptElem->put_text(bstrNewBlock));
    if ( hr )
        goto Cleanup;

    // since all the namespaces exist on the "window"
    // we need to make sure that the script block we
    // write out is in a language whose syntax we know. As
    // a result a script block from any ActiveScript language
    // will get persisted, but unless it is VBScript or JScript, 
    // in the saveing, it is translated into JScript.
    if (uFlags & SCRIPT_ENGINE_OTHER)
    {
        BSTR  bstrForceLanguage = SysAllocString(L"JScript");
        if (!bstrForceLanguage)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = (pDesignElem->put_language(bstrForceLanguage));
        SysFreeString(bstrForceLanguage);
        if (hr) 
            goto Cleanup;
    }
    
Cleanup:
    SysFreeString(bstrNewBlock);
    ReleaseInterface(pScriptElem);
    ReleaseInterface(pDesignElem);
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\iextag\selitem.cxx ===
//+------------------------------------------------------------------
//
// Microsoft IEPEERS
// Copyright (C) Microsoft Corporation, 1999.
//
// File:        iextags\selitem.cxx
//
// Contents:    The OPTION element.
//
// Classes:     CIEOptionElement
//
// Interfaces:  IHTMLOptionElement2
//              IPrivateOption
//
//-------------------------------------------------------------------

#include "headers.h"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "iextag.h"

#include "utils.hxx"

#ifndef __X_SELECT_HXX_
#define __X_SELECT_HXX_
#include "select.hxx"
#endif

#ifndef __X_SELITEM_HXX_
#define __X_SELITEM_HXX_
#include "selitem.hxx"
#endif



const CBaseCtl::PROPDESC CIEOptionElement::s_propdesc[] = 
{
    {_T("value"), VT_BSTR, NULL, _T("")},
    {_T("selected"), VT_I4, -1},
    {_T("defaultSelected"), VT_BOOL, NULL, NULL, VARIANT_FALSE},
    {_T("index"), VT_I4, -1},
    NULL
};

enum
{
    eValue          = 0,
    eSelected       = 1,
    eDefSelected    = 2,
    eIndex          = 3,
};


/////////////////////////////////////////////////////////////////////////////
//
// CIEOptionElement
//
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::CIEOptionElement()
//
// Synopsis:    Initializes member variables.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
CIEOptionElement::CIEOptionElement()
{
    _fSelectOnMouseDown = TRUE;
    _fFirstSize = TRUE;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::SetupDefaultStyle()
//
// Synopsis:    Sets the default style for OPTION elements, which can
//              be overridden through CSS.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::SetupDefaultStyle()
{
    HRESULT         hr;
#ifndef OPTION_GETSIZE
    CComBSTR        bstr;
#endif
    CComBSTR        bstrNoWrap(_T("nowrap"));
    CComBSTR        bstr100(_T("100%"));
    CComBSTR        bstrBlock(_T("block"));
    CVariant        var;
    CContextAccess  a(_pSite);

    hr = a.Open(CA_DEFSTYLE);
    if (FAILED(hr))
        goto Cleanup;

    // Setup the padding
    V_VT(&var) = VT_I4;
    V_I4(&var) = 2;
    hr = a.DefStyle()->put_paddingLeft(var);
    if (FAILED(hr))
        goto Cleanup;

#ifndef OPTION_GETSIZE
    // Setup overflow
    bstr = _T("hidden");
    hr = a.DefStyle()->put_overflow(bstr);
    if (FAILED(hr))
        goto Cleanup;
#endif

#ifdef OPTION_GETSIZE
    // Setup the whitespace
    hr = a.DefStyle()->put_whiteSpace(bstrNoWrap);
    if (FAILED(hr))
        goto Cleanup;

/*    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstr100;    
    hr = a.DefStyle()->put_width(var);
    if (FAILED(hr))
        goto Cleanup;
*/
    hr = a.DefStyle()->put_display(bstrBlock);
    if (FAILED(hr))
        goto Cleanup;
#endif

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::GetSelect()
//
// Synopsis:    Sets *ppSelect to the parent element, which should
//              be the SELECT element for this OPTION.
//
// Arguments:   IHTMLSelectElement3 **ppSelect 
//                - Receives a pointer to the SELECT which must be
//                  released by the caller.
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::GetSelect(IHTMLSelectElement3 **ppSelect)
{
    HRESULT         hr;
    IHTMLElement    *pParent = NULL;

    Assert(ppSelect);

    hr = GetParent(&pParent);
    if (FAILED(hr))
        goto Cleanup;

    hr = pParent->QueryInterface(IID_IHTMLSelectElement3, (void**)ppSelect);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pParent);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::GetSelect()
//
// Synopsis:    Sets *ppSelect to the parent element, which should
//              be the SELECT element for this OPTION.
//
// Arguments:   IPrivateSelect **ppSelect 
//                - Receives a pointer to the SELECT which must be
//                  released by the caller.
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::GetSelect(IPrivateSelect **ppSelect)
{
    HRESULT         hr;
    IHTMLElement    *pParent = NULL;

    Assert(ppSelect);

    hr = GetParent(&pParent);
    if (FAILED(hr))
        goto Cleanup;

    hr = pParent->QueryInterface(IID_IPrivateSelect, (void**)ppSelect);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pParent);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::GetParent()
//
// Synopsis:    Sets *ppParent to the parent element.
//
// Arguments:   IHTMLElement **ppParent 
//                - Receives a pointer to the parent which must be
//                  released by the caller.
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::GetParent(IHTMLElement **ppParent)
{
    HRESULT         hr;
    CContextAccess  a(_pSite);

    Assert(ppParent);

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_offsetParent(ppParent);
    if (FAILED(hr))
        goto Cleanup;

    if (!*ppParent)
    {
        // If we didn't get a parent element,
        // then this function has failed.
        hr = E_FAIL;
    }

Cleanup:
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// IHTMLOptionElement
//
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::put_value()
//
// Synopsis:    Sets the value property/attribute.
//
// Arguments:   BSTR v - The new value property/attribute
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::put_value(BSTR v)
{
    return GetProps()[eValue].Set(v);
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::get_value()
//
// Synopsis:    Retrieves the value property/attribute.
//
// Arguments:   BSTR *p - Receives the value property/attribute
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::get_value(BSTR *p)
{
    HRESULT         hr;
    CComBSTR        bstr;
    CContextAccess  a(_pSite);

    hr = GetProps()[eValue].Get(&bstr);
    if (FAILED(hr))
        goto Cleanup;

    if (bstr.Length() == 0)
    {
        hr = a.Open(CA_ELEM);
        if (FAILED(hr))
            goto Cleanup;

        hr = a.Elem()->get_innerText(&bstr);
        if (FAILED(hr))
            goto Cleanup;
    }

    *p = bstr;

Cleanup:
    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::put_index()
//
// Synopsis:    Sets the index property.
//              NOTE: Currently not implemented.
//                    This is silently ignored.
//
// Arguments:   long lIndex - The new index property
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::put_index(long lIndex)
{
    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::get_index()
//
// Synopsis:    Retrieves the index property.
//
// Arguments:   long *plIndex - Receives the index property
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::get_index(long *plIndex)
{
    return GetIndex(plIndex);
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::put_selected()
//
// Synopsis:    Sets the selected property.
//
// Arguments:   VARIANT_BOOL bSelected - The new selected property
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::put_selected(VARIANT_BOOL bSelected)
{
    HRESULT         hr;
    long            lIndex;
    VARIANT_BOOL    bPrev;
    IPrivateSelect  *pSelect    = NULL;

    hr = get_selected(&bPrev);
    if (FAILED(hr))
        goto Cleanup;

    if (bPrev == bSelected)
    {
        // No need to do anything
        goto Cleanup;
    }

    hr = get_index(&lIndex);
    if (FAILED(hr))
        goto Cleanup;

    hr = GetSelect(&pSelect);
    if (FAILED(hr))
        goto Cleanup;

    // This will take care of making the option look selected
    hr = pSelect->OnOptionSelected(bSelected, lIndex, SELECT_FIREEVENT);
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    ReleaseInterface(pSelect);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::get_selected()
//
// Synopsis:    Retrieves the selected property.
//
// Arguments:   VARIANT_BOOL *pbSelected - Receives the selected property
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::get_selected(VARIANT_BOOL * pbSelected)
{
    return GetSelected(pbSelected);
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::put_defaultSelected()
//
// Synopsis:    Sets the defaultSelected property.
//
// Arguments:   VARIANT_BOOL *p - The new defaultSelected property
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::put_defaultSelected(VARIANT_BOOL v)
{
    return GetProps()[eDefSelected].Set(v);
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::get_defaultSelected()
//
// Synopsis:    Retrieves the defaultSelected property.
//
// Arguments:   VARIANT_BOOL *p - Receives the defaultSelected property
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::get_defaultSelected(VARIANT_BOOL *p)
{
    return GetProps()[eDefSelected].Get(p);
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::put_text()
//
// Synopsis:    Sets the text of the option.
//
// Arguments:   BSTR pbstrText - The new text
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::put_text(BSTR bstrText)
{
    HRESULT         hr;
    CContextAccess  a(_pSite);

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->put_innerText(bstrText);
    if (FAILED(hr))
        goto Cleanup;
    
Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::get_text()
//
// Synopsis:    Retrieves the text of the option.
//
// Arguments:   BSTR *pbstrText - Receives the value
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::get_text(BSTR *pbstrText)
{
    HRESULT         hr;
    CContextAccess  a(_pSite);

    Assert(pbstrText);

    hr = a.Open(CA_ELEM);
    if (FAILED(hr))
        goto Cleanup;

    hr = a.Elem()->get_innerText(pbstrText);
    if (FAILED(hr))
        goto Cleanup;
    
Cleanup:
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// CBaseCtl overrides
//
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::Init()
//
// Synopsis:    Attaches events sets the default style.
//
// Arguments:   None
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::Init()
{
    HRESULT                     hr;
    CComBSTR                    bstr;
    CContextAccess              a(_pSite);

#ifdef OPTION_GETSIZE
    hr = a.Open(CA_SITEOM | CA_STYLE);
#else
    hr = a.Open(CA_SITEOM);
#endif
    if (FAILED(hr))
        goto Cleanup;

    hr = a.SiteOM()->RegisterName(_T("option"));
    if (FAILED(hr))
        goto Cleanup;

    hr = AttachEvent(EVENT_ONMOUSEOVER, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONMOUSEDOWN, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONMOUSEUP, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONSELECTSTART, &a);
    if (FAILED(hr))
        goto Cleanup;
    hr = AttachEvent(EVENT_ONPROPERTYCHANGE, &a);
    if (FAILED(hr))
        goto Cleanup;

    bstr = _T("onselectstart");
    hr = RegisterEvent(a.SiteOM(), bstr, &_lOnSelectStartCookie);
    if (FAILED(hr))
        goto Cleanup;

#ifdef OPTION_GETSIZE
    // Force a layout
    hr = a.Style()->put_display(_T("inline-block"));
    if (FAILED(hr))
        goto Cleanup;
#endif

    hr = SetupDefaultStyle();
    if (FAILED(hr))
        goto Cleanup;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::OnContentReady()
//
// Synopsis:    Setup the default selection status.
//
// Arguments:   IHTMLEventObj *pEvent - Event object with status info
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::OnContentReady()
{
    HRESULT         hr;
    VARIANT_BOOL    bSelected;
    VARIANT_BOOL    bDefSelected;

    hr = get_selected(&bSelected);
    if (FAILED(hr))
        goto Cleanup;

    hr = get_defaultSelected(&bDefSelected);
    if (FAILED(hr))
        goto Cleanup;

    if (bSelected || bDefSelected)
    {
        _fInitSel = TRUE;
        hr = SetSelected(VARIANT_TRUE);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::OnMouseOver()
//
// Synopsis:    If the option is setup to highlight, then highlight
//              the element.
//
// Arguments:   IHTMLEventObj *pEvent - Event object with status info
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::OnMouseOver(CEventObjectAccess *pEvent)
{
    HRESULT            hr          = S_OK;
    IPrivateSelect     *pSelect    = NULL;
    long               lIndex;

    if (_fHighlightOnMouseOver)
    {
        hr = get_index(&lIndex);
        if (FAILED(hr))
            goto Cleanup;

        hr = GetSelect(&pSelect);
        if (FAILED(hr))
            goto Cleanup;

        hr = pSelect->OnOptionHighlighted(lIndex);
        if (FAILED(hr))
            goto Cleanup;

        hr = pSelect->OnOptionFocus(lIndex);
        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pSelect);
    return hr;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::OnMouseDown()
//
// Synopsis:    Selects this option if this option is set to select
//              on mouse down events.
//
// Arguments:   IHTMLEventObj *pEvent - Event object with status info
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::OnMouseDown(CEventObjectAccess *pEvent)
{
    if (_fSelectOnMouseDown)
    {
        return OptionClicked(pEvent);
    }

    return S_OK;
}

//+------------------------------------------------------------------
//
// Member:      CIEOptionElement::OnMouseUp()
//
// Synopsis:    Select this element if this element is set to select
//              on mouse up events.
//
// Arguments:   IHTMLEventObj *pEvent - Event object with status info
//
// Returns:     Nonzero on errors.
//
//-------------------------------------------------------------------
HRESULT
CIEOptionElement::OnMouseUp(CEventObjectAcce