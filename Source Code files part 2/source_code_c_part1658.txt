KEY_READ );

    if (HKey == NULL) {
        DebugPrint(( TEXT("Cannot open HKEY_CURRENT_USER") ));
        return;
    }

    Config.OnTop =                GetRegistryDword( HKey, REGVAL_ALWAYS_ON_TOP );
    Config.TaskBar =              GetRegistryDword( HKey, REGVAL_TASKBAR );
    Config.VisualNotification =   GetRegistryDword( HKey, REGVAL_VISUAL_NOTIFICATION );
    Config.SoundNotification =    GetRegistryDword( HKey, REGVAL_SOUND_NOTIFICATION );
    Config.ManualAnswerEnabled =  GetRegistryDword( HKey, REGVAL_ENABLE_MANUAL_ANSWER );

    RegCloseKey( HKey );
}

VOID
PlayAnimation(
    HWND hWnd,
    DWORD Animation
    )
{
    static DWORD AnimationPlaying = 0;

    if (Animation == AnimationPlaying) {
        return;
    }

    if (AnimationPlaying == 0) {
        Animate_Close( hWnd );
    }

    Animate_Open( hWnd, MAKEINTRESOURCE( Animation ) );

    Animate_Play( hWnd, 0, -1, -1 );

    AnimationPlaying = Animation;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\faxstat\resource.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Declaration of resource ID constants

Environment:

        Windows NT fax configuration applet

Revision History:

        11/16/96 -GeorgeJe-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _RESOURCE_H_
#define _RESOURCE_H_

#include <winfax.h>

// strings

#define IDS_DIALING                     FEI_DIALING
#define IDS_SENDING                     FEI_SENDING
#define IDS_RECEIVING                   FEI_RECEIVING
#define IDS_COMPLETE                    FEI_COMPLETED
#define IDS_BUSY                        FEI_BUSY
#define IDS_NA                          FEI_NO_ANSWER
#define IDS_BADADDRESS                  FEI_BAD_ADDRESS
#define IDS_NODIALTONE                  FEI_NO_DIAL_TONE
#define IDS_DISCONNECT                  FEI_DISCONNECTED
#define IDS_FATAL                       FEI_FATAL_ERROR
#define IDS_NOTFAX                      FEI_NOT_FAX_CALL
#define IDS_CALLDELAYED                 FEI_CALL_DELAYED
#define IDS_CALLBLACKLIST               FEI_CALL_BLACKLISTED
#define IDS_RING                        FEI_RINGING
#define IDS_ABORTING                    FEI_ABORTING
#define IDS_ROUTING                     FEI_ROUTING
#define IDS_MODEMON                     FEI_MODEM_POWERED_ON
#define IDS_MODEMOFF                    FEI_MODEM_POWERED_OFF
#define IDS_IDLE                        FEI_IDLE
#define IDS_SVCENDED                    FEI_FAXSVC_ENDED
#define IDS_ANSWERED                    FEI_ANSWERED
#define IDS_SVCSTARTED                  FEI_FAXSVC_STARTED

#define IDS_ETIME                       (FEI_NEVENTS + 1)
#define IDS_FROM                        (FEI_NEVENTS + 2)
#define IDS_TO                          (FEI_NEVENTS + 3)
#define IDS_TIMELABEL                   (FEI_NEVENTS + 4)
#define IDS_EVENTLABEL                  (FEI_NEVENTS + 5)

// dialogs
#define IDD_FAXSTATUS                   101
#define IDD_DETAILS                     102
#define IDD_ANSWER                      103

// resources
#define IDR_IDLE                        201
#define IDR_SEND                        202
#define IDR_RECEIVE                     203

// icons
#define IDI_ICON1                       301

// bitmaps
#define IDB_CHECKMARK                   401

// controls
#define IDC_FAXEND                      1000
#define IDC_DETAILS                     1001
#define IDC_ANIMATE1                    1002
#define IDC_STATICTIME                  1003
#define IDC_TIME                        1004
#define IDC_EXIT                        1005
#define IDC_FROMTO                      1006
#define IDC_STATUS                      1007
#define IDC_LIST1                       1008
#define IDC_ANSWER                      1009
#define IDC_ANSWER_NEXT_CALL            1010

#endif  // !_RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\faxstat\server.c ===
#include <windows.h>
#include <faxutil.h>
#include <winfax.h>
#include "faxstat.h"

HANDLE   hFax;
LPBYTE   StatusBuffer;
HANDLE   FaxPortHandle;


VOID
WorkerThread(
    PINSTANCE_DATA InstanceData
    )
{
    PFAX_EVENT FaxEvent;
    HANDLE CompletionPort = NULL;
    BOOL Rval;
    DWORD Bytes;
    DWORD CompletionKey;
    PFAX_PORT_INFO PortInfo;
    DWORD PortCount;
    DWORD LastEventId = 0;
    DWORD EventId;
    PFAX_DEVICE_STATUS FaxDeviceStatus;


    while (TRUE) {

        if (FaxPortHandle) {
            FaxClose( FaxPortHandle );
            FaxPortHandle = NULL;
        }

        if (hFax) {
            FaxClose( hFax );
            hFax = NULL;
        }

        if (CompletionPort) {
            CloseHandle( CompletionPort );
            CompletionPort = NULL;
        }

        if( !FaxConnectFaxServer( InstanceData->ServerName, &hFax ) ){

            hFax = NULL;

            PostMessage( InstanceData->hWnd, STATUSUPDATE, FEI_FAXSVC_ENDED, 0 );

            goto sleep;
        }

        CompletionPort = CreateIoCompletionPort(
            INVALID_HANDLE_VALUE,
            NULL,
            0,
            1
            );

        if (!CompletionPort) {
            goto sleep;
        }

        if (!FaxInitializeEventQueue( hFax, CompletionPort, 0 )) {
            goto sleep;
        }

        PortInfo = MyFaxEnumPorts( hFax, &PortCount );

        if (!PortInfo) {
            goto sleep;
        }

        if (PortCount == 0) {
            //
            // BUGBUG - should do something more intelligent if there are no ports
            //
            ExitProcess(0);
        }

        Rval = FaxOpenPort( hFax, PortInfo[0].DeviceId, PORT_OPEN_EVENTS, &FaxPortHandle );

        if (!Rval) {
            goto sleep;
        }

        FaxFreeBuffer( PortInfo );

        if (StatusBuffer != NULL) {
            FaxFreeBuffer( StatusBuffer );
            StatusBuffer = NULL;
        }

        FaxDeviceStatus = (PFAX_DEVICE_STATUS) StatusBuffer;

        Rval = FaxGetDeviceStatus( FaxPortHandle, &FaxDeviceStatus );

        if (!Rval) {
            goto sleep;
        }

        EventId = MapStatusIdToEventId( FaxDeviceStatus->Status );

        PrintStatus( FaxDeviceStatus );

        SendMessage( InstanceData->hWnd, STATUSUPDATE, EventId, (LPARAM) FaxDeviceStatus );

        while (TRUE) {

            Rval = GetQueuedCompletionStatus(
                CompletionPort,
                &Bytes,
                &CompletionKey,
                (LPOVERLAPPED*) &FaxEvent,
                INFINITE
                );
            if (!Rval) {
                return;
            }

            LastEventId = EventId;

            EventId = FaxEvent->EventId;

            DebugPrint(( TEXT( "Got event %x" ), EventId ));

            switch (EventId) {
                case FEI_SENDING:
                case FEI_RECEIVING:
                case FEI_DIALING:
                    if (EventId != LastEventId) {

                        if (StatusBuffer != NULL) {
                            FaxFreeBuffer( StatusBuffer );
                            StatusBuffer = NULL;
                        }

                        FaxDeviceStatus = (PFAX_DEVICE_STATUS) StatusBuffer;

                        Rval = FaxGetDeviceStatus( FaxPortHandle, &FaxDeviceStatus );

                        PrintStatus( FaxDeviceStatus );
                    }
            }

            SendMessage( InstanceData->hWnd, STATUSUPDATE, EventId, (LPARAM) FaxDeviceStatus );

            LocalFree( FaxEvent );

            if (EventId == FEI_FAXSVC_ENDED) {
                break;
            }
        }
sleep:
        if (EventId != FEI_FAXSVC_ENDED) {
            SendMessage( InstanceData->hWnd, STATUSUPDATE, FEI_FAXSVC_ENDED, 0 );
        }
        Sleep(60000);


    }
}

VOID
WorkerThreadInitialize(
    PINSTANCE_DATA InstanceData
    )
{
    HANDLE WorkerThreadHandle;
    DWORD WorkerThreadId;

    WorkerThreadHandle = CreateThread(
                                NULL,
                                0,
                                (LPTHREAD_START_ROUTINE) WorkerThread,
                                InstanceData,
                                0,
                                &WorkerThreadId
                                );
}

VOID
Disconnect(
    VOID
    )
{
    if (FaxPortHandle) {
        FaxClose( FaxPortHandle );
        FaxPortHandle = NULL;
    }

    if (hFax) {
        FaxClose( hFax );
        hFax = NULL;
    }
}

PFAX_PORT_INFO
MyFaxEnumPorts(
    HANDLE hFaxSvc,
    LPDWORD pcPorts
    )
{
    PVOID   pSvcPorts = NULL;


    if (!FaxEnumPorts(hFaxSvc, (PFAX_PORT_INFO*) &pSvcPorts, pcPorts))
    {
        pSvcPorts = NULL;
    }

    return pSvcPorts;
}

VOID
PrintStatus(
    PFAX_DEVICE_STATUS FaxStatus
    )
{
    DebugPrint(( TEXT( "Status 0x%x" ), FaxStatus->Status ));
    DebugPrint(( TEXT( "Csid %s" ), FaxStatus->Csid ));
    DebugPrint(( TEXT( "Tsid %s" ), FaxStatus->Tsid ));
    DebugPrint(( TEXT( "PhoneNumber %s" ), FaxStatus->PhoneNumber ));
    DebugPrint(( TEXT( "CurrentPage %d" ), FaxStatus->CurrentPage ));
    DebugPrint(( TEXT( "TotalPages %d" ), FaxStatus->TotalPages ));
    DebugPrint(( TEXT( "--------------------") ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\faxstat\faxstat.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxstat.h

Abstract:

    Header file for fax status monitor

Environment:

        Windows NT fax driver user interface

Revision History:

        11/15/96 -GeorgeJe-
                Created it.


--*/


#ifndef _FAXSTAT_H_
#define _FAXSTAT_H_

// user messages
#define TRAYCALLBACK        (WM_USER + 200)
#define INITANIMATION       (WM_USER + 201)
#define STATUSUPDATE        (WM_USER + 202)
#define CONFIGUPDATE        (WM_USER + 203)
#define ACTIVATE            (WM_USER + 204)

#define ID_TIMER            1

#define STR_SIZE    256
#define MAX_EVENTS  100

typedef struct _EVENT_RECORD {
    LIST_ENTRY ListEntry;
    SYSTEMTIME Time;
    DWORD EventId;
    TCHAR StrBuf[STR_SIZE];
} EVENT_RECORD, *PEVENT_RECORD;

typedef struct _CONFIG_OPTIONS {
    DWORD   OnTop;                     // always on top
    DWORD   TaskBar;                   // display on taskbar
    DWORD   VisualNotification;        // pop up on activity
    DWORD   SoundNotification;         // play sound on activity
    DWORD   AnswerNextCall;            // one shot answer
    DWORD   ManualAnswerEnabled;       // pop up manual answer dialog
} CONFIG_OPTIONS, *PCONFIG_OPTIONS;

#define IsOptionOn( _o_ ) ((_o_) == BST_CHECKED)

typedef struct _INSTANCE_DATA {
    LPTSTR      ServerName;             // server to monitor
    HWND        hWnd;                   // handle to main window
    HINSTANCE   hInstance;              // instance handle
    HWND        hEventDlg;              // handle to event dialog box
    HWND        hAnswerDlg;             // handle to answer dailog box
    TCHAR       PrinterName[STR_SIZE];  // printer with active job
    DWORD       JobId;                  // JobId of active job
} INSTANCE_DATA, *PINSTANCE_DATA;


LRESULT
CALLBACK
WndProc(
    HWND hWnd,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
InitializeEventList(
    VOID
    );

PEVENT_RECORD
InsertEventRecord(
    DWORD Event,
    LPTSTR String
    );

VOID
InsertEventDialog(
    HWND hDlg,
    PEVENT_RECORD pEventRecord
    );

DWORD
MapStatusIdToEventId(
    DWORD StatusId
    );

PFAX_PORT_INFO
MyFaxEnumPorts(
    HANDLE hFaxSvc,
    LPDWORD pcPorts
    );

VOID
PrintStatus(
    PFAX_DEVICE_STATUS FaxStatus
    );

VOID
WorkerThread(
    PINSTANCE_DATA InstanceData
    );

VOID
WorkerThreadInitialize(
    PINSTANCE_DATA InstanceData
    );

VOID
CALLBACK
TimerProc(
    HWND hwnd,
    UINT iMsg,
    UINT iTimerID,
    DWORD dwTime
    );

VOID
StatusUpdate(
    HWND hWnd,
    DWORD EventId,
    DWORD LastEventId,
    PFAX_DEVICE_STATUS fds
    );

BOOL
CALLBACK
DlgProc(
    HWND hDlg,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
CenterWindow(
    HWND hwnd,
    HWND hwndToCenterOver
    );

BOOL
CreateOptionsPropertySheet(
    HINSTANCE   hInstance,
    HWND        hwnd
    );

VOID
MyShowWindow(
    HWND hwnd,
    BOOL visible
    );

VOID
GetConfiguration(
    VOID
    );

VOID
SaveConfiguration(
    VOID
    );

BOOL CALLBACK
OptionsDialogProc(
    HWND    hdlg,
    UINT    uMessage,
    WPARAM  wParam,
    LPARAM  lParam
    );

VOID
Disconnect(
    VOID
    );

BOOL
CALLBACK
AnswerDlgProc(
    HWND hDlg,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
PlayAnimation(
    HWND hWnd,
    DWORD Animation
    );

#endif //!_FAXSTAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\inc\imports.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)        07-May-1991
    Paula Tomlinson (paulat)   06-June-1995    Modified for plug-and-play

Revision History:


--*/

#include <windef.h>
#include <winbase.h>
#ifdef MIDL_PASS
#define LPWSTR [string] wchar_t*
#define LPCWSTR [string] wchar_t*
#define HCALL DWORD
#endif

#include <winfax.h>


#ifdef MIDL_PASS
#ifdef UNICODE
#define LPTSTR [string] wchar_t*
#define LPCTSTR [string] wchar_t*
#else
#define LPTSTR [string] LPTSTR
#define LPCTSTR [string] LPCTSTR
#endif
#define LPSTR [string] LPSTR
#define LPCSTR [string] LPCSTR
#define BOOL DWORD
#endif
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\server\faxdev.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxdev.c

Abstract:

    This module contains all access to the
    FAX device providers.

Author:

    Wesley Witt (wesw) 22-Jan-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop


LIST_ENTRY DeviceProviders;



BOOL
LoadDeviceProviders(
    PREG_FAX_SERVICE FaxReg
    )

/*++

Routine Description:

    Initializes all registered device providers.
    This function read the system registry to
    determine what device providers are available.
    All registered device providers are given the
    opportunity to initialize.  Any failure causes
    the device provider to be unloaded.


Arguments:

    None.

Return Value:

    TRUE    - The device providers are initialized.
    FALSE   - The device providers could not be initialized.

--*/

{
    DWORD i;
    HMODULE hModule;
    PDEVICE_PROVIDER DeviceProvider;



    InitializeListHead( &DeviceProviders );


    for (i=0; i<FaxReg->DeviceProviderCount; i++) {

        hModule = LoadLibrary( FaxReg->DeviceProviders[i].ImageName );
        if (!hModule) {
            DebugPrint(( TEXT("LoadLibrary() failed: [%s], ec=%d"), FaxReg->DeviceProviders[i].ImageName, GetLastError() ));
            goto InitializationFailure;
        }

        DeviceProvider = (PDEVICE_PROVIDER) MemAlloc( sizeof(DEVICE_PROVIDER) );
        if (!DeviceProvider) {
            FreeLibrary( hModule );
            DebugPrint(( TEXT("Could not allocate memory for device provider %s"), FaxReg->DeviceProviders[i].ImageName ));
            goto InitializationFailure;
        }

        DeviceProvider->hModule = hModule;

        _tcscpy( DeviceProvider->FriendlyName, FaxReg->DeviceProviders[i].FriendlyName );
        _tcscpy( DeviceProvider->ImageName,    FaxReg->DeviceProviders[i].ImageName    );
        _tcscpy( DeviceProvider->ProviderName, FaxReg->DeviceProviders[i].ProviderName );

        DeviceProvider->FaxDevInitialize = (PFAXDEVINITIALIZE) GetProcAddress(
            hModule,
            "FaxDevInitialize"
            );

        DeviceProvider->FaxDevStartJob = (PFAXDEVSTARTJOB) GetProcAddress(
            hModule,
            "FaxDevStartJob"
            );

        DeviceProvider->FaxDevEndJob = (PFAXDEVENDJOB) GetProcAddress(
            hModule,
            "FaxDevEndJob"
            );

        DeviceProvider->FaxDevSend = (PFAXDEVSEND) GetProcAddress(
            hModule,
            "FaxDevSend"
            );

        DeviceProvider->FaxDevReceive = (PFAXDEVRECEIVE) GetProcAddress(
            hModule,
            "FaxDevReceive"
            );

        DeviceProvider->FaxDevReportStatus = (PFAXDEVREPORTSTATUS) GetProcAddress(
            hModule,
            "FaxDevReportStatus"
            );

        DeviceProvider->FaxDevAbortOperation = (PFAXDEVABORTOPERATION) GetProcAddress(
            hModule,
            "FaxDevAbortOperation"
            );

        DeviceProvider->FaxDevVirtualDeviceCreation = (PFAXDEVVIRTUALDEVICECREATION) GetProcAddress(
            hModule,
            "FaxDevVirtualDeviceCreation"
            );

        if (DeviceProvider->FaxDevInitialize     &&
            DeviceProvider->FaxDevStartJob       &&
            DeviceProvider->FaxDevEndJob         &&
            DeviceProvider->FaxDevSend           &&
            DeviceProvider->FaxDevReceive        &&
            DeviceProvider->FaxDevReportStatus   &&
            DeviceProvider->FaxDevAbortOperation    ) {

                //
                // create the device provider's heap
                //
                DeviceProvider->HeapHandle = HeapCreate( 0, 1024*100, 1024*1024*2 );
                if (!DeviceProvider->HeapHandle) {

                    FreeLibrary( hModule );
                    MemFree( DeviceProvider );
                    goto InitializationFailure;

                } else {

                    InsertTailList( &DeviceProviders, &DeviceProvider->ListEntry );

                }

        } else {

            //
            // the device provider dll does not have a complete export list
            //
            MemFree( DeviceProvider );
            FreeLibrary( hModule );
            DebugPrint(( TEXT("Device provider FAILED to initialized [%s]"), FaxReg->DeviceProviders[i].FriendlyName ));
            goto InitializationFailure;
        }

        goto next;
InitializationFailure:
    FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_NONE,
            2,
            MSG_FSP_INIT_FAILED,
            FaxReg->DeviceProviders[i].FriendlyName,
            FaxReg->DeviceProviders[i].ImageName
          );   

next:
    ;
    }


    return TRUE;
}


BOOL
InitializeDeviceProviders(
    VOID
    )
{
    PLIST_ENTRY         Next;
    PDEVICE_PROVIDER    DeviceProvider;


    Next = DeviceProviders.Flink;
    if (!Next) {
        return FALSE;
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&DeviceProviders) {
        DeviceProvider = CONTAINING_RECORD( Next, DEVICE_PROVIDER, ListEntry );
        Next = DeviceProvider->ListEntry.Flink;

        //
        // the device provider exporta ALL the requisite functions
        // now try to initialize it
        //

        __try {

            if (DeviceProvider->FaxDevInitialize(
                    hLineApp,
                    DeviceProvider->HeapHandle,
                    &DeviceProvider->FaxDevCallback,
                    FaxDeviceProviderCallback)) {

                //
                // all is ok
                //

                DebugPrint(( TEXT("Device provider initialized [%s]"), DeviceProvider->FriendlyName ));

            } else {

                //
                // initialization failed, so unload the provider dll
                //

                FreeLibrary( DeviceProvider->hModule );
                DebugPrint(( TEXT("Device provider FAILED to initialized [%s]"), DeviceProvider->FriendlyName ));
                MemFree( DeviceProvider );

            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            FreeLibrary( DeviceProvider->hModule );
            DebugPrint(( TEXT("Device provider FAILED to initialized [%s]"), DeviceProvider->FriendlyName ));
            MemFree( DeviceProvider );

        }

    }

    return TRUE;
}



PDEVICE_PROVIDER
FindDeviceProvider(
    LPTSTR ProviderName
    )

/*++

Routine Description:

    Locates a device provider in the linked list
    of device providers based on the provider name.
    The device provider name is case sensitive.

Arguments:

    ProviderName    - Specifies the device provider name to locate.
    None.

Return Value:

    Pointer to a DEVICE_PROVIDER structure, or NULL for failure.

--*/

{
    PLIST_ENTRY         Next;
    PDEVICE_PROVIDER    Provider;


    Next = DeviceProviders.Flink;
    if (!Next) {
        return NULL;
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&DeviceProviders) {
        Provider = CONTAINING_RECORD( Next, DEVICE_PROVIDER, ListEntry );
        Next = Provider->ListEntry.Flink;
        if (_tcscmp( Provider->ProviderName, ProviderName ) == 0) {
            return Provider;
        }
    }

    return NULL;
}


BOOL CALLBACK
FaxDeviceProviderCallback(
    IN HANDLE FaxHandle,
    IN DWORD  DeviceId,
    IN DWORD_PTR  Param1,
    IN DWORD_PTR  Param2,
    IN DWORD_PTR  Param3
    )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\registry\faxreg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    registry.cpp

Abstract:

    This module wraps all of the registry access
    for the fax server.

Author:

    Wesley Witt (wesw) 9-June-1996


Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "winfax.h"
#include "faxutil.h"
#include "faxreg.h"
#include "faxsvcrg.h"


#define FAX_EVENT_MSG_FILE              TEXT("%systemroot%\\system32\\faxevent.dll")
#define FAX_CATEGORY_COUNT              4


BOOL
EnumDeviceProviders(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    PREG_FAX_SERVICE FaxReg
    )
{
    if (SubKeyName == NULL) {
        if (Index) {
            FaxReg->DeviceProviders = (PREG_DEVICE_PROVIDER) MemAlloc( Index * sizeof(REG_DEVICE_PROVIDER) );
            if (!FaxReg->DeviceProviders) {
                return FALSE;
            }
        }
        return TRUE;
    }

    if (FaxReg == NULL || FaxReg->DeviceProviders == NULL) {
        return FALSE;
    }

    FaxReg->DeviceProviders[Index].FriendlyName = GetRegistryString( hSubKey, REGVAL_FRIENDLY_NAME, EMPTY_STRING );
    FaxReg->DeviceProviders[Index].ImageName    = GetRegistryStringExpand( hSubKey, REGVAL_IMAGE_NAME, EMPTY_STRING );
    FaxReg->DeviceProviders[Index].ProviderName = GetRegistryString( hSubKey, REGVAL_PROVIDER_NAME,EMPTY_STRING );

    return TRUE;
}


BOOL
EnumDeviceProvidersChange(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    PREG_FAX_SERVICE FaxReg
    )
{
    if (SubKeyName == NULL) {
        //
        // called once for the subkey
        //
        return TRUE;
    }

    if (FaxReg == NULL || FaxReg->DeviceProviders == NULL) {
        return FALSE;
    }

    SetRegistryString( hSubKey, REGVAL_FRIENDLY_NAME, FaxReg->DeviceProviders[Index].FriendlyName );
    SetRegistryStringExpand( hSubKey, REGVAL_IMAGE_NAME, FaxReg->DeviceProviders[Index].ImageName );
    SetRegistryString( hSubKey, REGVAL_PROVIDER_NAME, FaxReg->DeviceProviders[Index].ProviderName );

    return TRUE;
}


BOOL
EnumRoutingMethods(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    PREG_ROUTING_EXTENSION RoutingExtension
    )
{
    if (SubKeyName == NULL) {
        if (Index) {
            RoutingExtension->RoutingMethods = (PREG_ROUTING_METHOD) MemAlloc( Index * sizeof(REG_ROUTING_METHOD) );
            if (!RoutingExtension->RoutingMethods) {
                return FALSE;
            }
        }
        return TRUE;
    }

    if (RoutingExtension == NULL || RoutingExtension->RoutingMethods == NULL) {
        return FALSE;
    }

    RoutingExtension->RoutingMethods[Index].InternalName = StringDup( SubKeyName );
    RoutingExtension->RoutingMethods[Index].FriendlyName = GetRegistryString( hSubKey, REGVAL_FRIENDLY_NAME, EMPTY_STRING );
    RoutingExtension->RoutingMethods[Index].FunctionName = GetRegistryString( hSubKey, REGVAL_FUNCTION_NAME, EMPTY_STRING );
    RoutingExtension->RoutingMethods[Index].Guid         = GetRegistryString( hSubKey, REGVAL_GUID, EMPTY_STRING );
    RoutingExtension->RoutingMethods[Index].Priority     = GetRegistryDword( hSubKey, REGVAL_ROUTING_PRIORITY );

    return TRUE;
}


BOOL
EnumRoutingMethodsChange(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    PREG_ROUTING_EXTENSION RoutingExtension
    )
{
    if (SubKeyName == NULL) {
        //
        // called once for the subkey
        //
        return TRUE;
    }

    if (RoutingExtension == NULL || RoutingExtension->RoutingMethods) {
        return FALSE;
    }

    SetRegistryString( hSubKey, REGVAL_FRIENDLY_NAME,    RoutingExtension->RoutingMethods[Index].FriendlyName );
    SetRegistryString( hSubKey, REGVAL_FUNCTION_NAME,    RoutingExtension->RoutingMethods[Index].FunctionName );
    SetRegistryString( hSubKey, REGVAL_GUID,             RoutingExtension->RoutingMethods[Index].Guid         );
    SetRegistryDword ( hSubKey, REGVAL_ROUTING_PRIORITY, RoutingExtension->RoutingMethods[Index].Priority     );

    return TRUE;
}


BOOL
EnumRoutingExtensions(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    PREG_FAX_SERVICE FaxReg
    )
{
    if (SubKeyName == NULL) {
        if (Index) {
            FaxReg->RoutingExtensions = (PREG_ROUTING_EXTENSION) MemAlloc( Index * sizeof(REG_ROUTING_EXTENSION) );
            if (!FaxReg->RoutingExtensions) {
                return FALSE;
            }
        }
        return TRUE;
    }

    if (FaxReg == NULL || FaxReg->RoutingExtensions == NULL) {
        return FALSE;
    }

    FaxReg->RoutingExtensions[Index].InternalName   = StringDup( SubKeyName );
    FaxReg->RoutingExtensions[Index].FriendlyName = GetRegistryString( hSubKey, REGVAL_FRIENDLY_NAME, EMPTY_STRING );
    FaxReg->RoutingExtensions[Index].ImageName    = GetRegistryStringExpand( hSubKey, REGVAL_IMAGE_NAME, EMPTY_STRING );

    //
    // load the routing methods for this extension
    //

    FaxReg->RoutingExtensions[Index].RoutingMethodsCount = EnumerateRegistryKeys(
        hSubKey,
        REGKEY_ROUTING_METHODS,
        FALSE,
        EnumRoutingMethods,
        &FaxReg->RoutingExtensions[Index]
        );

    return TRUE;
}


BOOL
EnumRoutingExtensionsChange(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    PREG_FAX_SERVICE FaxReg
    )
{
    if (SubKeyName == NULL) {
        //
        // called once for the subkey
        //
        return TRUE;
    }

    if (FaxReg == NULL || FaxReg->RoutingExtensions == NULL) {
        return FALSE;
    }

    SetRegistryString( hSubKey, REGVAL_FRIENDLY_NAME, FaxReg->RoutingExtensions[Index].FriendlyName );
    SetRegistryStringExpand( hSubKey, REGVAL_IMAGE_NAME, FaxReg->RoutingExtensions[Index].ImageName );

    //
    // load the routing methods for this extension
    //

    EnumerateRegistryKeys(
        hSubKey,
        REGKEY_ROUTING_METHODS,
        TRUE,
        EnumRoutingMethodsChange,
        &FaxReg->RoutingExtensions[Index]
        );

    return TRUE;
}


BOOL
EnumDevices(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    PREG_FAX_SERVICE FaxReg
    )
{
    if (SubKeyName == NULL) {
        if (Index) {
            FaxReg->Devices = (PREG_DEVICE) MemAlloc( Index * sizeof(REG_DEVICE) );
            if (!FaxReg->Devices) {
                return FALSE;
            }
        }
        return TRUE;
    }

    if (FaxReg == NULL || FaxReg->Devices == NULL) {
        return FALSE;
    }

    FaxReg->Devices[Index].PermanentLineID = GetRegistryDword( hSubKey, REGVAL_PERMANENT_LINEID );
    FaxReg->Devices[Index].Priority        = GetRegistryDword( hSubKey, REGVAL_PRIORITY );
    FaxReg->Devices[Index].Flags           = GetRegistryDword( hSubKey, REGVAL_FLAGS );
    FaxReg->Devices[Index].Rings           = GetRegistryDword( hSubKey, REGVAL_RINGS );
    FaxReg->Devices[Index].Name            = GetRegistryString( hSubKey, REGVAL_DEVICE_NAME, EMPTY_STRING );
    FaxReg->Devices[Index].Provider        = GetRegistryString( hSubKey, REGVAL_PROVIDER, EMPTY_STRING );
    FaxReg->Devices[Index].Csid            = GetRegistryString( hSubKey, REGVAL_ROUTING_CSID, EMPTY_STRING );
    FaxReg->Devices[Index].Tsid            = GetRegistryString( hSubKey, REGVAL_ROUTING_TSID, EMPTY_STRING );

    return TRUE;
}


BOOL
EnumDevicesCache(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    PREG_FAX_SERVICE FaxReg
    )
{
    if (SubKeyName == NULL) {
        if (Index) {
            FaxReg->DevicesCache = (PREG_DEVICE_CACHE) MemAlloc( Index * sizeof(REG_DEVICE_CACHE) );
            if (!FaxReg->DevicesCache) {
                return FALSE;
            }
        }
        return TRUE;
    }

    if (FaxReg == NULL || FaxReg->DevicesCache == NULL) {
        return FALSE;
    }

    FaxReg->DevicesCache[Index].PermanentLineID = GetRegistryDword( hSubKey, REGVAL_PERMANENT_LINEID );
    //
    // cached devices should not have a priority
    //
    //FaxReg->DevicesCache[Index].Priority        = 0; // GetRegistryDword( hSubKey, REGVAL_PRIORITY );

    FaxReg->DevicesCache[Index].Flags           = GetRegistryDword( hSubKey, REGVAL_FLAGS );
    FaxReg->DevicesCache[Index].Rings           = GetRegistryDword( hSubKey, REGVAL_RINGS );
    FaxReg->DevicesCache[Index].Name            = GetRegistryString( hSubKey, REGVAL_DEVICE_NAME, EMPTY_STRING );
    FaxReg->DevicesCache[Index].Provider        = GetRegistryString( hSubKey, REGVAL_PROVIDER, EMPTY_STRING );
    FaxReg->DevicesCache[Index].Csid            = GetRegistryString( hSubKey, REGVAL_ROUTING_CSID, EMPTY_STRING );
    FaxReg->DevicesCache[Index].Tsid            = GetRegistryString( hSubKey, REGVAL_ROUTING_TSID, EMPTY_STRING );
    FaxReg->DevicesCache[Index].RoutingMask     = GetRegistryDword( hSubKey, REGVAL_ROUTING_MASK );
    FaxReg->DevicesCache[Index].Printer         = GetRegistryString( hSubKey, REGVAL_ROUTING_PRINTER, EMPTY_STRING );
    FaxReg->DevicesCache[Index].Profile         = GetRegistryString( hSubKey, REGVAL_ROUTING_PROFILE, EMPTY_STRING );
    FaxReg->DevicesCache[Index].StoreDir        = GetRegistryString( hSubKey, REGVAL_ROUTING_DIR, EMPTY_STRING );

    return TRUE;
}

VOID
SetDevicesCacheValues(
    HKEY hSubKey,
    DWORD PermanentLineID,
    DWORD Flags,
    DWORD Rings,
    LPTSTR DeviceName,
    LPTSTR ProviderName,
    LPTSTR Csid,
    LPTSTR Tsid,
    DWORD  RouteMask,
    LPTSTR RoutePrinterName,
    LPTSTR RouteDir,
    LPTSTR RouteProfile
    )
{
    SetRegistryDword(  hSubKey, REGVAL_PERMANENT_LINEID, PermanentLineID );
    
    SetRegistryDword(  hSubKey, REGVAL_FLAGS,            Flags           );
    SetRegistryDword(  hSubKey, REGVAL_RINGS,            Rings           );
    SetRegistryString( hSubKey, REGVAL_DEVICE_NAME,      DeviceName      );
    SetRegistryString( hSubKey, REGVAL_PROVIDER,         ProviderName    );
    SetRegistryString( hSubKey, REGVAL_ROUTING_CSID,     Csid            );
    SetRegistryString( hSubKey, REGVAL_ROUTING_TSID,     Tsid            );
    SetRegistryDword(  hSubKey, REGVAL_ROUTING_MASK,     RouteMask       );
    SetRegistryString( hSubKey, REGVAL_ROUTING_PRINTER,  RoutePrinterName);
    SetRegistryString( hSubKey, REGVAL_ROUTING_PROFILE,  RouteProfile    );
    SetRegistryString( hSubKey, REGVAL_ROUTING_DIR,      RouteDir        );
}


VOID
SetDevicesValues(
    HKEY hSubKey,
    DWORD PermanentLineID,
    DWORD Priority,
    DWORD Flags,
    DWORD Rings,
    LPTSTR DeviceName,
    LPTSTR ProviderName,
    LPTSTR Csid,
    LPTSTR Tsid
    )
{
    SetRegistryDword(  hSubKey, REGVAL_PERMANENT_LINEID, PermanentLineID );
    SetRegistryDword(  hSubKey, REGVAL_PRIORITY,         Priority        );
    SetRegistryDword(  hSubKey, REGVAL_FLAGS,            Flags           );
    SetRegistryDword(  hSubKey, REGVAL_RINGS,            Rings           );
    if (DeviceName)   SetRegistryString( hSubKey, REGVAL_DEVICE_NAME,      DeviceName      );
    if (ProviderName) SetRegistryString( hSubKey, REGVAL_PROVIDER,         ProviderName    );
    SetRegistryString( hSubKey, REGVAL_ROUTING_CSID,     Csid            );
    SetRegistryString( hSubKey, REGVAL_ROUTING_TSID,     Tsid            );
}


BOOL
EnumDevicesChange(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    PREG_FAX_SERVICE FaxReg
    )
{
    if (SubKeyName == NULL) {
        //
        // called once for the subkey
        //
        return TRUE;
    }

    if (FaxReg == NULL || FaxReg->Devices == NULL) {
        return FALSE;
    }

    SetDevicesValues(
        hSubKey,
        FaxReg->Devices[Index].PermanentLineID,
        FaxReg->Devices[Index].Priority,
        FaxReg->Devices[Index].Flags,
        FaxReg->Devices[Index].Rings,
        FaxReg->Devices[Index].Name,
        FaxReg->Devices[Index].Provider,
        FaxReg->Devices[Index].Csid,
        FaxReg->Devices[Index].Tsid
        );

    return TRUE;
}


BOOL
EnumDevicesCacheChange(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    PREG_FAX_SERVICE FaxReg
    )
{
    if (SubKeyName == NULL) {
        //
        // called once for the subkey
        //
        return TRUE;
    }

    if (FaxReg == NULL || FaxReg->DevicesCache == NULL) {
        return FALSE;
    }

    SetDevicesCacheValues(
        hSubKey,
        FaxReg->DevicesCache[Index].PermanentLineID,
        FaxReg->DevicesCache[Index].Flags,
        FaxReg->DevicesCache[Index].Rings,
        FaxReg->DevicesCache[Index].Name,
        FaxReg->DevicesCache[Index].Provider,
        FaxReg->DevicesCache[Index].Csid,
        FaxReg->DevicesCache[Index].Tsid,
        FaxReg->DevicesCache[Index].RoutingMask,
        FaxReg->DevicesCache[Index].Printer,
        FaxReg->DevicesCache[Index].StoreDir,
        FaxReg->DevicesCache[Index].Profile
        );

    return TRUE;
}


BOOL
EnumLogging(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    PREG_FAX_SERVICE FaxReg
    )
{
    if (SubKeyName == NULL) {
        if (Index) {
            FaxReg->Logging = (PREG_CATEGORY) MemAlloc( Index * sizeof(REG_CATEGORY) );
            if (!FaxReg->Logging) {
                return FALSE;
            }
        }

        return TRUE;
    }

    if (FaxReg->Logging == NULL) {
        return FALSE;
    }

    FaxReg->Logging[Index].CategoryName = GetRegistryString( hSubKey, REGVAL_CATEGORY_NAME, EMPTY_STRING );
    FaxReg->Logging[Index].Level        = GetRegistryDword( hSubKey, REGVAL_CATEGORY_LEVEL );
    FaxReg->Logging[Index].Number       = GetRegistryDword( hSubKey, REGVAL_CATEGORY_NUMBER );

    return TRUE;
}


BOOL
EnumLoggingChange(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    PREG_FAX_SERVICE FaxReg
    )
{
    if (SubKeyName == NULL) {
        return TRUE;
    }

    SetRegistryString( hSubKey, REGVAL_CATEGORY_NAME, FaxReg->Logging[Index].CategoryName );
    SetRegistryDword( hSubKey, REGVAL_CATEGORY_LEVEL, FaxReg->Logging[Index].Level );
    SetRegistryDword( hSubKey, REGVAL_CATEGORY_NUMBER, FaxReg->Logging[Index].Number );

    return TRUE;
}


PREG_FAX_SERVICE
GetFaxRegistry(
    VOID
    )
{
    PREG_FAX_SERVICE    FaxReg;
    HKEY                hKey;
    DWORD               Tmp;



    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, FALSE, KEY_READ );
    if (!hKey) {
        return NULL;
    }

    FaxReg = (PREG_FAX_SERVICE) MemAlloc( sizeof(REG_FAX_SERVICE) );
    if (!FaxReg) {
        RegCloseKey( hKey );
        return NULL;
    }

    //
    // load the fax service values
    //

    FaxReg->Retries                 = GetRegistryDword( hKey, REGVAL_RETRIES );
    FaxReg->RetryDelay              = GetRegistryDword( hKey, REGVAL_RETRYDELAY );
    FaxReg->DirtyDays               = GetRegistryDword( hKey, REGVAL_DIRTYDAYS );
    FaxReg->QueuePaused             = GetRegistryDword( hKey, REGVAL_QUEUE_PAUSED );
    FaxReg->NextJobNumber           = GetRegistryDword( hKey, REGVAL_JOB_NUMBER );
    FaxReg->ForceReceive            = GetRegistryDword( hKey, REGVAL_FORCE_RECEIVE );
    FaxReg->TerminationDelay        = GetRegistryDword( hKey, REGVAL_TERMINATION_DELAY );
    FaxReg->Branding                = GetRegistryDword( hKey, REGVAL_BRANDING );
    FaxReg->UseDeviceTsid           = GetRegistryDword( hKey, REGVAL_USE_DEVICE_TSID );
    FaxReg->ServerCp                = GetRegistryDword( hKey, REGVAL_SERVERCP );
    Tmp                             = GetRegistryDword( hKey, REGVAL_STARTCHEAP );
    FaxReg->StartCheapTime.Hour     = LOWORD(Tmp);
    FaxReg->StartCheapTime.Minute   = HIWORD(Tmp);
    Tmp                             = GetRegistryDword( hKey, REGVAL_STOPCHEAP );
    FaxReg->StopCheapTime.Hour      = LOWORD(Tmp);
    FaxReg->StopCheapTime.Minute    = HIWORD(Tmp);
    FaxReg->ArchiveOutgoingFaxes    = GetRegistryDword( hKey, REGVAL_ARCHIVEFLAG );

    FaxReg->InboundProfile = GetRegistryString( hKey, REGVAL_INBOUND_PROFILE, EMPTY_STRING );
    FaxReg->ArchiveDirectory = GetRegistryString( hKey, REGVAL_ARCHIVEDIR, EMPTY_STRING );

    //
    // load the device providers
    //

    FaxReg->DeviceProviderCount = EnumerateRegistryKeys(
        hKey,
        REGKEY_DEVICE_PROVIDERS,
        FALSE,
        EnumDeviceProviders,
        FaxReg
        );

    //
    // load the routing extensions
    //

    FaxReg->RoutingExtensionsCount = EnumerateRegistryKeys(
        hKey,
        REGKEY_ROUTING_EXTENSIONS,
        FALSE,
        EnumRoutingExtensions,
        FaxReg
        );

    //
    // load the devices
    //

    FaxReg->DeviceCount = EnumerateRegistryKeys(
        hKey,
        REGKEY_DEVICES,
        FALSE,
        EnumDevices,
        FaxReg
        );

    //
    // load the cached devices
    //

    FaxReg->DeviceCacheCount = EnumerateRegistryKeys(
        hKey,
        REGKEY_DEVICES_CACHE,
        FALSE,
        EnumDevicesCache,
        FaxReg
        );

    //
    // load the logging categories
    //

    FaxReg->LoggingCount = EnumerateRegistryKeys(
        hKey,
        REGKEY_LOGGING,
        FALSE,
        EnumLogging,
        FaxReg
        );

    RegCloseKey( hKey );

    return FaxReg;
}


BOOL
SetFaxRegistry(
    PREG_FAX_SERVICE FaxReg
    )
{
    HKEY    hKey;


    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, FALSE, KEY_ALL_ACCESS );
    if (!hKey) {
        return FALSE;
    }

    //
    // set the fax service values
    //

    SetRegistryDword( hKey, REGVAL_RETRIES, FaxReg->Retries );
    SetRegistryDword( hKey, REGVAL_RETRYDELAY, FaxReg->RetryDelay );
    SetRegistryDword( hKey, REGVAL_DIRTYDAYS, FaxReg->DirtyDays );
    SetRegistryDword( hKey, REGVAL_QUEUE_PAUSED, FaxReg->QueuePaused );
    SetRegistryDword( hKey, REGVAL_BRANDING, FaxReg->Branding );
    SetRegistryDword( hKey, REGVAL_USE_DEVICE_TSID, FaxReg->UseDeviceTsid );
    SetRegistryString( hKey, REGVAL_INBOUND_PROFILE, FaxReg->InboundProfile );

    //
    // set the device providers
    //

    EnumerateRegistryKeys(
        hKey,
        REGKEY_DEVICE_PROVIDERS,
        TRUE,
        EnumDeviceProvidersChange,
        FaxReg
        );

    //
    // set the routing extensions
    //

    EnumerateRegistryKeys(
        hKey,
        REGKEY_ROUTING_EXTENSIONS,
        TRUE,
        EnumRoutingExtensionsChange,
        FaxReg
        );

    //
    // set the devices
    //

    EnumerateRegistryKeys(
        hKey,
        REGKEY_DEVICES,
        TRUE,
        EnumDevicesChange,
        FaxReg
        );

    //
    // set the devices cache
    //

    EnumerateRegistryKeys(
        hKey,
        REGKEY_DEVICES_CACHE,
        TRUE,
        EnumDevicesCacheChange,
        FaxReg
        );

    //
    // set the logging categories
    //

    EnumerateRegistryKeys(
        hKey,
        REGKEY_LOGGING,
        TRUE,
        EnumLoggingChange,
        FaxReg
        );

    return TRUE;
}

VOID
FreeFaxRegistry(
    PREG_FAX_SERVICE FaxReg
    )
{
    DWORD i,j;


    if (!FaxReg) {
        return;
    }

    for (i=0; i<FaxReg->DeviceProviderCount; i++) {
        MemFree( FaxReg->DeviceProviders[i].FriendlyName );
        MemFree( FaxReg->DeviceProviders[i].ImageName );
        MemFree( FaxReg->DeviceProviders[i].ProviderName );
    }

    for (i=0; i<FaxReg->RoutingExtensionsCount; i++) {
        MemFree( FaxReg->RoutingExtensions[i].FriendlyName );
        MemFree( FaxReg->RoutingExtensions[i].ImageName );
        for (j=0; j<FaxReg->RoutingExtensions[i].RoutingMethodsCount; j++) {
            MemFree( FaxReg->RoutingExtensions[i].RoutingMethods[j].FriendlyName );
            MemFree( FaxReg->RoutingExtensions[i].RoutingMethods[j].FunctionName );
            MemFree( FaxReg->RoutingExtensions[i].RoutingMethods[j].Guid );
        }
        MemFree( FaxReg->RoutingExtensions[i].RoutingMethods );
    }

    MemFree( FaxReg->DeviceProviders );
    MemFree( FaxReg->RoutingExtensions );

    for (i=0; i<FaxReg->DeviceCount; i++) {
        MemFree( FaxReg->Devices[i].Name     );
        MemFree( FaxReg->Devices[i].Provider );
        MemFree( FaxReg->Devices[i].Csid  );
        MemFree( FaxReg->Devices[i].Tsid );
    }

    MemFree( FaxReg->Devices );

    for (i=0; i<FaxReg->DeviceCacheCount; i++) {
        MemFree( FaxReg->DevicesCache[i].Name );
        MemFree( FaxReg->DevicesCache[i].Provider );
        MemFree( FaxReg->DevicesCache[i].Printer );
        MemFree( FaxReg->DevicesCache[i].Profile );
        MemFree( FaxReg->DevicesCache[i].StoreDir );
        MemFree( FaxReg->DevicesCache[i].Csid );
        MemFree( FaxReg->DevicesCache[i].Tsid );
    }

    MemFree( FaxReg->DevicesCache );
    

    for (i=0; i<FaxReg->LoggingCount; i++) {
        MemFree( FaxReg->Logging[i].CategoryName );
    }

    MemFree( FaxReg->Logging );

    MemFree( FaxReg );
}


BOOL
SetFaxGlobalsRegistry(
    PFAX_CONFIGURATION FaxConfig
    )
{
    HKEY    hKey;


    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        return FALSE;
    }

    SetRegistryDword(  hKey, REGVAL_RETRIES,          FaxConfig->Retries );
    SetRegistryDword(  hKey, REGVAL_RETRYDELAY,       FaxConfig->RetryDelay );
    SetRegistryDword(  hKey, REGVAL_DIRTYDAYS,        FaxConfig->DirtyDays );
    SetRegistryDword(  hKey, REGVAL_QUEUE_PAUSED,     FaxConfig->PauseServerQueue );
    SetRegistryDword(  hKey, REGVAL_BRANDING,         FaxConfig->Branding );
    SetRegistryDword(  hKey, REGVAL_USE_DEVICE_TSID,  FaxConfig->UseDeviceTsid );
    SetRegistryDword(  hKey, REGVAL_SERVERCP,         FaxConfig->ServerCp );
    SetRegistryDword(  hKey, REGVAL_STARTCHEAP,       MAKELONG( FaxConfig->StartCheapTime.Hour, FaxConfig->StartCheapTime.Minute ) );
    SetRegistryDword(  hKey, REGVAL_STOPCHEAP,        MAKELONG( FaxConfig->StopCheapTime.Hour, FaxConfig->StopCheapTime.Minute ) );
    SetRegistryDword(  hKey, REGVAL_ARCHIVEFLAG,      FaxConfig->ArchiveOutgoingFaxes );
    SetRegistryString( hKey, REGVAL_INBOUND_PROFILE,  FaxConfig->InboundProfile );
    SetRegistryString( hKey, REGVAL_ARCHIVEDIR,       FaxConfig->ArchiveDirectory );

    RegCloseKey( hKey );

    return TRUE;
}


BOOL
SetFaxJobNumberRegistry(
    DWORD NextJobNumber
    )
{
    HKEY    hKey;


    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        return FALSE;
    }

    SetRegistryDword( hKey, REGVAL_JOB_NUMBER, NextJobNumber );

    RegCloseKey( hKey );

    return TRUE;
}


BOOL
GetLoggingCategoriesRegistry(
    PREG_FAX_LOGGING FaxRegLogging
    )
{
    REG_FAX_SERVICE FaxReg = {0};
    HKEY    hKey;


    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, FALSE, KEY_READ );
    if (!hKey) {
        return FALSE;
    }

    FaxRegLogging->LoggingCount = EnumerateRegistryKeys(
        hKey,
        REGKEY_LOGGING,
        FALSE,
        EnumLogging,
        &FaxReg
        );

    RegCloseKey( hKey );

    FaxRegLogging->Logging = FaxReg.Logging;

    return TRUE;
}


BOOL
SetLoggingCategoriesRegistry(
    PREG_FAX_LOGGING FaxRegLogging
    )
{
    REG_FAX_SERVICE FaxReg = {0};
    HKEY    hKey;


    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        return FALSE;
    }

    FaxReg.Logging = FaxRegLogging->Logging;
    FaxReg.LoggingCount = FaxRegLogging->LoggingCount;

    EnumerateRegistryKeys(
        hKey,
        REGKEY_LOGGING,
        TRUE,
        EnumLoggingChange,
        &FaxReg
        );

    RegCloseKey( hKey );

    return TRUE;
}


PREG_FAX_DEVICES
GetFaxDevicesRegistry(
    VOID
    )
{
    PREG_FAX_SERVICE    FaxReg;
    PREG_FAX_DEVICES    FaxRegDevices;
    HKEY                hKey;
    DWORD               i, currentpriority;
    BOOL                foundpriority;
    WCHAR               KeyName[256];


    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, FALSE, KEY_READ );
    if (!hKey) {
        return NULL;
    }

    FaxReg = (PREG_FAX_SERVICE) MemAlloc( sizeof(REG_FAX_SERVICE) );
    if (!FaxReg) {
        RegCloseKey( hKey );
        return NULL;
    }

    FaxRegDevices = (PREG_FAX_DEVICES) MemAlloc( sizeof(REG_FAX_DEVICES) );
    if (!FaxRegDevices) {
        RegCloseKey( hKey );
        return NULL;
    }

    //
    // load the devices
    //

    FaxReg->DeviceCount = EnumerateRegistryKeys(
        hKey,
        REGKEY_DEVICES,
        FALSE,
        EnumDevices,
        FaxReg
        );

    RegCloseKey( hKey );

    FaxRegDevices->Devices = FaxReg->Devices;
    FaxRegDevices->DeviceCount = FaxReg->DeviceCount;

    MemFree( FaxReg );  

    //
    // make sure the device priorities all make sense
    //
    for (currentpriority = 1; currentpriority < FaxRegDevices->DeviceCount; currentpriority++) {
       foundpriority = FALSE;

       for (i = 0; i < FaxRegDevices->DeviceCount; i++) {
          if ( FaxRegDevices->Devices[i].Priority == currentpriority) {
             if (foundpriority) {
                //
                // devices may not have the same priority
                //
                FaxRegDevices->Devices[i].Priority += 1;
             }
             foundpriority = TRUE;
          }
       }

       while (!foundpriority) {
           //
           // out of order priorities
           //
           for (i = 0; i < FaxRegDevices->DeviceCount; i++) {
               if ( FaxRegDevices->Devices[i].Priority > currentpriority) {
                  FaxRegDevices->Devices[i].Priority -=1;
               }
             
               if (FaxRegDevices->Devices[i].Priority == currentpriority) {
                  if (foundpriority) {
                     FaxRegDevices->Devices[i].Priority += 1;
                  }
                  foundpriority = TRUE;
               }                
           }                      
       }                  
    }

    //
    // write the adjusted device priorities into the registry.
    //
    for (i = 0; i < FaxRegDevices->DeviceCount; i++) {
        wsprintf( KeyName, L"%s\\%08d", REGKEY_FAX_DEVICES, FaxRegDevices->Devices[i].PermanentLineID );
        hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, KeyName , FALSE, KEY_ALL_ACCESS );
        if (hKey) {
            SetDevicesValues(
                  hKey,
                  FaxRegDevices->Devices[i].PermanentLineID,
                  FaxRegDevices->Devices[i].Priority,
                  FaxRegDevices->Devices[i].Flags,
                  FaxRegDevices->Devices[i].Rings,
                  NULL,//FaxRegDevices->Devices[i].DeviceName,
                  NULL,//FaxRegDevices->Devices[i].ProviderName,
                  FaxRegDevices->Devices[i].Csid,
                  FaxRegDevices->Devices[i].Tsid
                  );

            RegCloseKey( hKey );
        }
        
    }        

    return FaxRegDevices;
}


PREG_FAX_DEVICES_CACHE
GetFaxDevicesCacheRegistry(
    VOID
    )
{
    PREG_FAX_SERVICE          FaxReg;
    PREG_FAX_DEVICES_CACHE    FaxRegDevices;
    HKEY                hKey;


    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, FALSE, KEY_READ );
    if (!hKey) {
        return NULL;
    }

    FaxReg = (PREG_FAX_SERVICE) MemAlloc( sizeof(REG_FAX_SERVICE) );
    if (!FaxReg) {
        RegCloseKey( hKey );
        return NULL;
    }

    FaxRegDevices = (PREG_FAX_DEVICES_CACHE) MemAlloc( sizeof(REG_FAX_DEVICES_CACHE) );
    if (!FaxRegDevices) {
        RegCloseKey( hKey );
        return NULL;
    }

    //
    // load the devices
    //

    FaxReg->DeviceCacheCount = EnumerateRegistryKeys(
        hKey,
        REGKEY_DEVICES_CACHE,
        FALSE,
        EnumDevicesCache,
        FaxReg
        );

    RegCloseKey( hKey );

    FaxRegDevices->Devices = FaxReg->DevicesCache;
    FaxRegDevices->DeviceCount = FaxReg->DeviceCacheCount;

    MemFree( FaxReg );

    return FaxRegDevices;
}


DWORD
GetNextDevicePriority(
   VOID
   )
{
    #define MAX(i,j) i>j?i:j
    PREG_FAX_SERVICE    FaxReg;
    HKEY                hKey;
    DWORD               nextpriority = 0,i;

    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, FALSE, KEY_READ );
    if (!hKey) {
        return 1;
    }

    FaxReg = (PREG_FAX_SERVICE) MemAlloc( sizeof(REG_FAX_SERVICE) );
    if (!FaxReg) {
        RegCloseKey( hKey );
        return 1;
    }

    //
    // load the devices
    //

    FaxReg->DeviceCount = EnumerateRegistryKeys(
        hKey,
        REGKEY_DEVICES,
        FALSE,
        EnumDevices,
        FaxReg
        );

    RegCloseKey( hKey );

    
   
    for (i = 0; i<FaxReg->DeviceCount; i++) {
       nextpriority = MAX(nextpriority,FaxReg->Devices[i].Priority);

       MemFree( FaxReg->Devices[i].Name );
       MemFree( FaxReg->Devices[i].Provider );
       MemFree( FaxReg->Devices[i].Csid );
       MemFree( FaxReg->Devices[i].Tsid );
    }

    if ( FaxReg->Devices )
        MemFree( FaxReg->Devices );

    MemFree( FaxReg );  

    return nextpriority+1;

}

DWORD
RegAddNewFaxDevice(
    LPTSTR DeviceName,
    LPTSTR ProviderName,
    LPTSTR Csid,
    LPTSTR Tsid,
    DWORD Priority, // -1 means get the next available priority slot
    DWORD PermanentLineID,
    DWORD Flags,
    DWORD Rings,
    LONG RoutingMask,             // -1 means don't set routing
    LPTSTR RoutePrinterName,
    LPTSTR RouteDir,
    LPTSTR RouteProfile
    )
{
    HKEY hKey;
    HKEY hKeyRouting;
    TCHAR SubKeyName[128];
    DWORD localPriority = Priority;


    //
    // create the device's registry key
    //

    _stprintf( SubKeyName, TEXT("%s\\%08d"), REGKEY_FAX_DEVICES, PermanentLineID );

    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, SubKeyName, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        return -1;
    }

    if (Priority == -1) {
        localPriority = GetNextDevicePriority();
    }

    //
    // populate the key with it's values
    //

    SetDevicesValues(
        hKey,
        PermanentLineID,
        localPriority,
        Flags,
        Rings,
        DeviceName,
        ProviderName,
        Csid,
        Tsid
        );

    //
    // now add the routing info
    //

    if (RoutingMask != -1) {
        hKeyRouting = OpenRegistryKey( hKey, REGKEY_ROUTING, TRUE, KEY_ALL_ACCESS );
        if (!hKeyRouting) {
            Assert(( ! TEXT("Could not open routing registry key") ));
            return FALSE;
        }

        if (!SetRegistryString( hKeyRouting, REGVAL_ROUTING_PRINTER, RoutePrinterName )) {
            Assert(( ! TEXT("Could not set printer name registry value") ));
        }

        if (!SetRegistryString( hKeyRouting, REGVAL_ROUTING_DIR, RouteDir )) {
            Assert(( ! TEXT("Could not set routing dir registry value") ));
        }

        if (!SetRegistryString( hKeyRouting, REGVAL_ROUTING_PROFILE, RouteProfile )) {
            Assert(( ! TEXT("Could not set routing profile name registry value") ));
        }

        if (!SetRegistryDword( hKeyRouting, REGVAL_ROUTING_MASK, RoutingMask )) {
            Assert(( ! TEXT("Could not set routing mask registry value") ));
        }

        RegCloseKey( hKeyRouting );
    }

    RegCloseKey( hKey );
    //
    // close the handles and leave
    //


    return localPriority;
}


BOOL
RegAddNewFaxDeviceCache(
    LPTSTR DeviceName,
    LPTSTR ProviderName,
    LPTSTR Csid,
    LPTSTR Tsid,
    DWORD PermanentLineID,
    DWORD Flags,
    DWORD Rings,
    DWORD RoutingMask,             // -1 means don't set routing
    LPTSTR RoutePrinterName,
    LPTSTR RouteDir,
    LPTSTR RouteProfile
    )
{
    HKEY hKey;
    //HKEY hKeyRouting;
    TCHAR SubKeyName[128];


    //
    // create the device's registry key
    //

    _stprintf( SubKeyName, TEXT("%s\\%s\\%s"), REGKEY_SOFTWARE, REGKEY_DEVICES_CACHE,DeviceName );

    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, SubKeyName, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        return FALSE;
    }

    //
    // populate the key with it's values
    //

    SetDevicesCacheValues(
        hKey,
        PermanentLineID,
        Flags,
        Rings,
        DeviceName,
        ProviderName,
        Csid,
        Tsid,
        RoutingMask,
        RoutePrinterName,
        RouteDir,
        RouteProfile
        );

    //
    // close the handle and leave
    //    
    RegCloseKey( hKey );    

    return TRUE;
}


BOOL
SetFaxDeviceFlags(
    DWORD PermanentLineID,
    DWORD Flags
    )
{
    DWORD rVal;
    HKEY hKey;
    TCHAR KeyName[256];


    _stprintf( KeyName, TEXT("%s\\%08d"), REGKEY_FAX_DEVICES, PermanentLineID );

    rVal = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        KeyName,
        &hKey
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not open devices registry key, ec=0x%08x"), rVal ));
        return FALSE;
    }

    RegSetValueEx(
        hKey,
        REGVAL_FLAGS,
        0,
        REG_DWORD,
        (LPBYTE) &Flags,
        sizeof(DWORD)
        );

    RegCloseKey( hKey );

    return TRUE;
}

BOOL
SetFaxRoutingInfo(
    LPTSTR ExtensionName,
    LPTSTR MethodName,
    LPTSTR Guid,
    DWORD  Priority,
    LPTSTR FunctionName,
    LPTSTR FriendlyName
    ) 
{
   HKEY hKey;
   TCHAR KeyName[256];

   wsprintf( KeyName, L"%s\\%s\\%s\\%s", REGKEY_ROUTING_EXTENSION_KEY, ExtensionName,REGKEY_ROUTING_METHODS, MethodName );

   hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, KeyName, FALSE, KEY_ALL_ACCESS );
   if (!hKey) {
      return FALSE;
   }
   
   SetRegistryString( hKey, REGVAL_FRIENDLY_NAME,    FriendlyName );
   SetRegistryString( hKey, REGVAL_FUNCTION_NAME,    FunctionName );
   SetRegistryString( hKey, REGVAL_GUID,             Guid         );
   SetRegistryDword ( hKey, REGVAL_ROUTING_PRIORITY, Priority     );   

   RegCloseKey( hKey );

   return TRUE;
}
    


BOOL
DeleteFaxDevice(
    DWORD PermanentLineID
    )
{    
    TCHAR SubKey[256];
             
    _stprintf( SubKey, TEXT("%s\\%s\\%08d"), REGKEY_SOFTWARE, REGKEY_DEVICES, PermanentLineID );

    DebugPrint(( TEXT("Deleting %s\n"), SubKey ));
    //
    // recursive delete
    //
    return DeleteRegistryKey( HKEY_LOCAL_MACHINE, SubKey ) ;    
}

BOOL
DeleteCachedFaxDevice(
    LPTSTR DeviceName
    )
{
    TCHAR SubKey[256];

    _stprintf( SubKey, TEXT("%s\\%s\\%s"), REGKEY_SOFTWARE, REGKEY_DEVICES_CACHE, DeviceName );

    DebugPrint(( TEXT("Deleting %s\n"), SubKey ));
    //
    // recursive delete
    //
    return DeleteRegistryKey( HKEY_LOCAL_MACHINE, SubKey ) ;
}


VOID
FreeFaxDevicesRegistry(
    PREG_FAX_DEVICES FaxReg
    )
{
    DWORD i;


    if (!FaxReg) {
        return;
    }

    for (i=0; i<FaxReg->DeviceCount; i++) {
        MemFree( FaxReg->Devices[i].Name     );
        MemFree( FaxReg->Devices[i].Provider );
        MemFree( FaxReg->Devices[i].Csid  );
        MemFree( FaxReg->Devices[i].Tsid );
    }

    MemFree( FaxReg->Devices );

    MemFree( FaxReg );
}


VOID
FreeFaxDevicesCacheRegistry(
    PREG_FAX_DEVICES_CACHE FaxReg
    )
{
    DWORD i;


    if (!FaxReg) {
        return;
    }

    for (i=0; i<FaxReg->DeviceCount; i++) {
        MemFree( FaxReg->Devices[i].Name     );
        MemFree( FaxReg->Devices[i].Provider );
        MemFree( FaxReg->Devices[i].Printer  );
        MemFree( FaxReg->Devices[i].Profile  );
        MemFree( FaxReg->Devices[i].StoreDir );
        MemFree( FaxReg->Devices[i].Csid  );
        MemFree( FaxReg->Devices[i].Tsid );
    }

    MemFree( FaxReg->Devices );

    MemFree( FaxReg );
}

VOID
FreeRegRoutingInfo(
    PREG_ROUTING_INFO FaxReg
    )
{
    
    if (!FaxReg) {
        return;
    }

    MemFree( FaxReg->Printer  );
    MemFree( FaxReg->Profile  );
    MemFree( FaxReg->StoreDir );
        
    MemFree( FaxReg );
}


PREG_ROUTING_INFO
RegGetRoutingInfo(
    DWORD PermanentLineID
    )
{
    
    HKEY hKey;
    TCHAR KeyName[256];
    PREG_ROUTING_INFO FaxReg = MemAlloc( sizeof(REG_ROUTING_INFO) );

    if (!FaxReg) {
        return NULL;
    }

    _stprintf( KeyName, TEXT("%s\\%08d\\%s"), REGKEY_FAX_DEVICES, PermanentLineID, REGKEY_ROUTING );

    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, KeyName, FALSE, KEY_READ );
                         
    if (!hKey) {
        MemFree( FaxReg );
        return NULL;
    }
    
    FaxReg->RoutingMask = GetRegistryDword( hKey, REGVAL_ROUTING_MASK );
    FaxReg->Printer     = GetRegistryString( hKey, REGVAL_ROUTING_PRINTER, EMPTY_STRING );
    FaxReg->Profile     = GetRegistryString( hKey, REGVAL_ROUTING_PROFILE, EMPTY_STRING );
    FaxReg->StoreDir         = GetRegistryString( hKey, REGVAL_ROUTING_DIR,     EMPTY_STRING );

    RegCloseKey( hKey );

    return FaxReg;
}


BOOL
CreateFaxEventSource(
    PREG_FAX_SERVICE FaxReg,
    PFAX_LOG_CATEGORY DefaultCategories,
    int DefaultCategoryCount
    )
{
    HKEY hKey;
    HKEY hKeyLogging;
    DWORD Disposition;
    LONG rVal;
    DWORD Types;
    DWORD i;
    WCHAR KeyName[256];


    if (FaxReg->LoggingCount == 0) {

        hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_FAX_LOGGING, TRUE, KEY_ALL_ACCESS );
        if (!hKey) {
            return FALSE;
        }

        FaxReg->Logging = (PREG_CATEGORY) MemAlloc(DefaultCategoryCount * sizeof(REG_CATEGORY) );
        if (!FaxReg->Logging) {
            RegCloseKey( hKey );
            return FALSE;
        }

        for (i=0; i< (DWORD) DefaultCategoryCount; i++) {

            wsprintf( KeyName, L"%d", DefaultCategories[i].Category );
            hKeyLogging = OpenRegistryKey( hKey, KeyName, TRUE, KEY_ALL_ACCESS );
            if (hKeyLogging) {
                SetRegistryString( hKeyLogging, REGVAL_CATEGORY_NAME, DefaultCategories[i].Name );
                FaxReg->Logging[i].CategoryName = StringDup( DefaultCategories[i].Name);

                SetRegistryDword( hKeyLogging, REGVAL_CATEGORY_LEVEL, DefaultCategories[i].Level );
                FaxReg->Logging[i].Level = DefaultCategories[i].Level;

                SetRegistryDword( hKeyLogging, REGVAL_CATEGORY_NUMBER, DefaultCategories[i].Category );
                FaxReg->Logging[i].Number = DefaultCategories[i].Category;

                RegCloseKey( hKeyLogging );
            }
        }

        FaxReg->LoggingCount = DefaultCategoryCount;

        RegCloseKey( hKey );
    }

    //
    // check to see if the required registry
    // entries are present so the event viewer
    // can display the event records
    //

    rVal = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        REGKEY_EVENTLOG,
        0,
        TEXT(""),
        0,
        KEY_ALL_ACCESS,
        NULL,
        &hKey,
        &Disposition
        );

    if (rVal != ERROR_SUCCESS) {
        goto error_exit;
    }

//  if (Disposition != REG_CREATED_NEW_KEY) {
//      RegCloseKey( hKey );
//      return TRUE;
//  }

    //
    // the key was just created so we must now
    // create the value entries
    //

    //
    // set the message file name
    // this is the name of the fax service
    // binary because it contains the
    // resource strings
    //

    rVal = RegSetValueEx(
        hKey,
        REGVAL_EVENTMSGFILE,
        0,
        REG_EXPAND_SZ,
        (LPBYTE) FAX_EVENT_MSG_FILE,
        _tcslen(FAX_EVENT_MSG_FILE) * sizeof(TCHAR)
        );

    if (rVal != ERROR_SUCCESS) {
        goto error_exit;
    }

    rVal = RegSetValueEx(
        hKey,
        REGVAL_CATEGORYMSGFILE,
        0,
        REG_EXPAND_SZ,
        (LPBYTE) FAX_EVENT_MSG_FILE,
        _tcslen(FAX_EVENT_MSG_FILE) * sizeof(TCHAR)
        );

    if (rVal != ERROR_SUCCESS) {
        goto error_exit;
    }


    Types = FAX_CATEGORY_COUNT;

    rVal = RegSetValueEx(
        hKey,
        REGVAL_CATEGORYCOUNT,
        0,
        REG_DWORD,
        (LPBYTE) &Types,
        sizeof(DWORD)
        );

    if (rVal != ERROR_SUCCESS) {
        goto error_exit;
    }

    Types = 7;

    rVal = RegSetValueEx(
        hKey,
        REGVAL_TYPESSUPPORTED,
        0,
        REG_DWORD,
        (LPBYTE) &Types,
        sizeof(DWORD)
        );

    if (rVal != ERROR_SUCCESS) {
        goto error_exit;
    }

    RegCloseKey( hKey );

    return TRUE;

error_exit:
    if (hKey) RegCloseKey( hKey );

    //
    // go ahead and leave FaxReg->Logging allocated on this failure...it will get cleaned up eventually
    //

    return FALSE;
}


BOOL
GetInstallationInfo(
    LPDWORD Installed,
    LPDWORD InstallType,
    LPDWORD InstalledPlatforms,
    LPDWORD ProductType
    )
{
    HKEY hKey;
    LONG rVal;
    DWORD RegType;
    DWORD RegSize;
    TCHAR ProductTypeStr[32];
    DWORD Bytes;
    DWORD Type;


    if (Installed == NULL || InstallType == NULL || InstalledPlatforms == NULL || ProductType == NULL) {
        return FALSE;
    }

    rVal = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        REGKEY_FAX_SETUP,
        &hKey
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not open setup registry key, ec=0x%08x"), rVal ));
        return FALSE;
    }

    RegSize = sizeof(DWORD);

    rVal = RegQueryValueEx(
        hKey,
        REGVAL_FAXINSTALLED,
        0,
        &RegType,
        (LPBYTE) Installed,
        &RegSize
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not query installed registry value, ec=0x%08x"), rVal ));
        *Installed = 0;
    }

    rVal = RegQueryValueEx(
        hKey,
        REGVAL_FAXINSTALL_TYPE,
        0,
        &RegType,
        (LPBYTE) InstallType,
        &RegSize
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not query install type registry value, ec=0x%08x"), rVal ));
        *InstallType = 0;
    }

    rVal = RegQueryValueEx(
        hKey,
        REGVAL_FAXINSTALLED_PLATFORMS,
        0,
        &RegType,
        (LPBYTE) InstalledPlatforms,
        &RegSize
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not query install platforms mask registry value, ec=0x%08x"), rVal ));
        *InstalledPlatforms = 0;
    }

    RegCloseKey( hKey );

    //
    // get the product type
    //

    *ProductType = PRODUCT_TYPE_WINNT;

    rVal = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
        &hKey
        );
    if (rVal == ERROR_SUCCESS) {
        Bytes = sizeof(ProductTypeStr);

        rVal = RegQueryValueEx(
            hKey,
            TEXT("ProductType"),
            NULL,
            &Type,
            (LPBYTE) ProductTypeStr,
            &Bytes
            );
        if (rVal == ERROR_SUCCESS) {
            if ((_tcsicmp( ProductTypeStr, TEXT("SERVERNT") ) == 0) ||
                (_tcsicmp( ProductTypeStr, TEXT("LANMANNT") ) == 0)) {
                *ProductType = PRODUCT_TYPE_SERVER;
            }
        }

        RegCloseKey( hKey );
    }

    return TRUE;
}


BOOL
IsModemClass1(
    LPSTR SubKey,
    LPBOOL Class1Fax
    )
{
    BOOL rVal = TRUE;
    LONG Rslt;
    HKEY hKey;
    DWORD Type;
    DWORD Size;


    *Class1Fax = 0;

    Rslt = RegOpenKeyExA(
        HKEY_LOCAL_MACHINE,
        SubKey,
        0,
        KEY_READ,
        &hKey
        );
    if (Rslt == ERROR_SUCCESS) {
        Size = sizeof(DWORD);
        Rslt = RegQueryValueEx(
            hKey,
            TEXT("FaxClass1"),
            0,
            &Type,
            (LPBYTE) Class1Fax,
            &Size
            );
        if (Rslt != ERROR_SUCCESS) {
            rVal = FALSE;
        }
        RegCloseKey( hKey );
    }

    return rVal;
}


BOOL
SaveModemClass(
    LPSTR SubKey,
    BOOL Class1Fax
    )
{
    BOOL rVal = FALSE;
    LONG Rslt;
    HKEY hKey;


    Rslt = RegOpenKeyExA(
        HKEY_LOCAL_MACHINE,
        SubKey,
        0,
        KEY_WRITE,
        &hKey
        );
    if (Rslt == ERROR_SUCCESS) {
        Rslt = RegSetValueEx(
            hKey,
            TEXT("FaxClass1"),
            0,
            REG_DWORD,
            (LPBYTE) &Class1Fax,
            sizeof(DWORD)
            );
        if (Rslt == ERROR_SUCCESS) {
            rVal = TRUE;
        }
        RegCloseKey( hKey );
    }

    return rVal;
}


BOOL
GetOrigSetupData(
    PREG_SETUP RegSetup
    )
{
    HKEY hKey;
    HKEY hKeySetup;


    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_FAX_SETUP, FALSE, KEY_READ );
    if (!hKey) {
        return FALSE;
    }

    hKeySetup = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SETUP_ORIG, FALSE, KEY_READ );
    if (!hKeySetup) {
        return FALSE;
    }

    RegSetup->Installed          = GetRegistryDword( hKey, REGVAL_FAXINSTALLED );
    RegSetup->InstallType        = GetRegistryDword( hKey, REGVAL_FAXINSTALL_TYPE );
    RegSetup->InstalledPlatforms = GetRegistryDword( hKey, REGVAL_FAXINSTALLED_PLATFORMS );

    RegSetup->Csid     = GetRegistryString( hKeySetup, REGVAL_ROUTING_CSID,    EMPTY_STRING );
    RegSetup->Tsid     = GetRegistryString( hKeySetup, REGVAL_ROUTING_TSID,    EMPTY_STRING );
    RegSetup->Printer  = GetRegistryString( hKeySetup, REGVAL_ROUTING_PRINTER, EMPTY_STRING );
    RegSetup->StoreDir = GetRegistryString( hKeySetup, REGVAL_ROUTING_DIR,     EMPTY_STRING );
    RegSetup->Profile  = GetRegistryString( hKeySetup, REGVAL_ROUTING_PROFILE, EMPTY_STRING );
    RegSetup->Mask     = GetRegistryDword( hKeySetup, REGVAL_ROUTING_MASK );
    RegSetup->Rings    = GetRegistryDword( hKeySetup, REGVAL_RINGS );

    RegCloseKey( hKey );
    RegCloseKey( hKeySetup );

    return TRUE;
}


VOID
FreeOrigSetupData(
    PREG_SETUP RegSetup
    )
{
    MemFree( RegSetup->Csid );
    MemFree( RegSetup->Tsid );
    MemFree( RegSetup->Printer );
    MemFree( RegSetup->StoreDir );
    MemFree( RegSetup->Profile );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\regdump\regdump.c ===
#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <tchar.h>

#include "faxutil.h"
#include "faxreg.h"
#include "winfax.h"


int _cdecl
main(
    int argc,
    char *argvA[]
    )
{
    PREG_FAX_SERVICE RegFaxSvc;
    DWORD i;


    HeapInitialize();

    RegFaxSvc = GetFaxRegistry();
    if (!RegFaxSvc) {
        DebugPrint(( TEXT("could not get the fax registry data") ));
        return 1;
    }

    _tprintf( TEXT("--- global fax service values ---\n\n" ));
    _tprintf( TEXT("\tretries.............0x%08x\n"), RegFaxSvc->Retries          );
    _tprintf( TEXT("\tretry delay.........0x%08x\n"), RegFaxSvc->RetryDelay       );
    _tprintf( TEXT("\tdirty days..........0x%08x\n"), RegFaxSvc->DirtyDays        );
    _tprintf( TEXT("\tarea code...........0x%08x\n"), RegFaxSvc->AreaCode         );
    _tprintf( TEXT("\ttoll prefix count...0x%08x\n"), RegFaxSvc->TollPrefixCount  );
    _tprintf( TEXT("\tbranding............0x%08x\n"), RegFaxSvc->Branding         );
    _tprintf( TEXT("\tuse device tsid.....0x%08x\n"), RegFaxSvc->UseDeviceTsid    );

    _tprintf( TEXT("\n\n--- device providers ---\n\n" ));

    for (i=0; i<RegFaxSvc->DeviceProviderCount; i++) {
        _tprintf( TEXT("\tname ...............%s\n"), RegFaxSvc->DeviceProviders[i].FriendlyName );
        _tprintf( TEXT("\timage name..........%s\n"), RegFaxSvc->DeviceProviders[i].ImageName    );
        _tprintf( TEXT("\tprovider name.......%s\n\n"), RegFaxSvc->DeviceProviders[i].ProviderName );
    }

    _tprintf( TEXT("\n--- fax devices ---\n\n" ));

    for (i=0; i<RegFaxSvc->DeviceCount; i++) {
        _tprintf( TEXT("\tname................%s\n"), RegFaxSvc->Devices[i].Name     );
        _tprintf( TEXT("\tprovider............%s\n"), RegFaxSvc->Devices[i].Provider );
        _tprintf( TEXT("\tpriority............%d\n"), RegFaxSvc->Devices[i].Priority );
        _tprintf( TEXT("\t--- routing ---\n") );
        _tprintf( TEXT("\t\tmask...............0x%08x\n"), RegFaxSvc->Devices[i].Routing->Mask            );
        _tprintf( TEXT("\t\tprinter............%s\n"),     RegFaxSvc->Devices[i].Routing->Printer         );
        _tprintf( TEXT("\t\tdirectory..........%s\n"),     RegFaxSvc->Devices[i].Routing->StoreDirectory  );
        _tprintf( TEXT("\t\tprofile............%s\n"),     RegFaxSvc->Devices[i].Routing->ProfileName     );
        _tprintf( TEXT("\t\tcsid...............%s\n"),     RegFaxSvc->Devices[i].Routing->CSID            );
        _tprintf( TEXT("\t\ttsid...............%s\n"),     RegFaxSvc->Devices[i].Routing->TSID            );
    }

    _tprintf( TEXT("\n--- logging ---\n\n" ));

    for (i=0; i<RegFaxSvc->LoggingCount; i++) {
        _tprintf( TEXT("\tname................%s\n"), RegFaxSvc->Logging[i].CategoryName );
        _tprintf( TEXT("\t\tlevel...............%d\n"), RegFaxSvc->Logging[i].Level        );
        _tprintf( TEXT("\t\tnumber..............%d\n"), RegFaxSvc->Logging[i].Number       );
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\registry\registry.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    registry.cpp

Abstract:

    This header contains the private data structures and
    function prototypes for the fax server registry code.

Author:

    Wesley Witt (wesw) 9-June-1996


Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "winfax.h"
#include "faxutil.h"
#include "faxreg.h"
#include "faxsvcrg.h"
#include "eventlog.h"


typedef struct _REGISTRY_KEY {
    LPTSTR                      Name;               // key name
    BOOL                        Dynamic;            //
    DWORD                       DynamicDataSize;    //
    LPBYTE                      DynamicData;        //
    DWORD                       DynamicDataCount;   //
    DWORD                       SubKeyOffset;       //
} REGISTRY_KEY, *PREGISTRY_KEY;


typedef struct _REGISTRY_VALUE {
    LPTSTR                      Name;               // key or value name
    ULONG                       Type;               // value type
    DWORD                       DataPtr;            // pointer to the data buffer
    ULONG                       Size;               // data size for strings
    ULONG                       Default;            // default if it doesn't exist
} REGISTRY_VALUE, *PREGISTRY_VALUE;


typedef struct _REGISTRY_KEYVALUE {
    REGISTRY_KEY                RegKey;             // registry key data
    DWORD                       ValueCount;         // number of RegValue entries
    PREGISTRY_VALUE             RegValue;           // registry value data
    struct _REGISTRY_KEYVALUE   *SubKey;            // subkey data, NULL is valid
} REGISTRY_KEYVALUE, *PREGISTRY_KEYVALUE;


typedef struct _REGISTRY_TABLE {
    DWORD                       Count;              // number of RegKeyValue entries
    PREGISTRY_KEYVALUE          RegKeyValue[0];     // registry keys & values
} REGISTRY_TABLE, *PREGISTRY_TABLE;



//
// internal function prototypes
//

BOOL
InitializeRegistryTable(
    LPTSTR          RegKeySoftware,
    PREGISTRY_TABLE RegistryTable
    );

BOOL
ChangeRegistryTable(
    LPTSTR          RegKeySoftware,
    PREGISTRY_TABLE RegistryTable
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\registry\faxsvcrg.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxreg.h

Abstract:

    This header defines all of the fax service
    registry data structures and access functions.

Author:

    Wesley Witt (wesw) 9-June-1996


Revision History:

--*/

#ifndef _FAXREG_
#define _FAXREG_


typedef struct _REG_DEVICE_PROVIDER {

    LPTSTR                  FriendlyName;
    LPTSTR                  ImageName;
    LPTSTR                  ProviderName;

} REG_DEVICE_PROVIDER, *PREG_DEVICE_PROVIDER;


typedef struct _REG_ROUTING_METHOD {

    LPTSTR                  FriendlyName;
    LPTSTR                  FunctionName;
    LPTSTR                  Guid;
    LPTSTR                  InternalName;
    DWORD                   Priority;

} REG_ROUTING_METHOD, *PREG_ROUTING_METHOD;


typedef struct _REG_ROUTING_EXTENSION {

    LPTSTR                  FriendlyName;
    LPTSTR                  ImageName;
    LPTSTR                  InternalName;
    DWORD                   RoutingMethodsCount;
    PREG_ROUTING_METHOD     RoutingMethods;

} REG_ROUTING_EXTENSION, *PREG_ROUTING_EXTENSION;


typedef struct _REG_DEVICE {

    DWORD                   PermanentLineID;
    LPTSTR                  Name;
    LPTSTR                  Provider;
    DWORD                   Priority;
    DWORD                   Flags;
    DWORD                   Rings;
    LPTSTR                  Csid;
    LPTSTR                  Tsid;
    BOOL                    DeviceInstalled; // this is not stored, but is used to validate currently 
                                             // installed tapi devices with the devices in the registry

} REG_DEVICE, *PREG_DEVICE;

typedef struct _REG_DEVICE_CACHE {

    DWORD                   PermanentLineID;
    LPTSTR                  Name;
    LPTSTR                  Provider;
    //DWORD                   Priority;
    DWORD                   Flags;
    DWORD                   Rings;
    LPTSTR                  Csid;
    LPTSTR                  Tsid;
    DWORD                   RoutingMask;
    LPTSTR                  Printer;
    LPTSTR                  Profile;
    LPTSTR                  StoreDir;

} REG_DEVICE_CACHE, *PREG_DEVICE_CACHE;


typedef struct _REG_ROUTING_INFO {   

    DWORD                   RoutingMask;
    LPTSTR                  Printer;
    LPTSTR                  Profile;
    LPTSTR                  StoreDir;

} REG_ROUTING_INFO, *PREG_ROUTING_INFO;



typedef struct _REG_CATEGORY {

    LPTSTR                  CategoryName;
    DWORD                   Number;
    DWORD                   Level;

} REG_CATEGORY, *PREG_CATEGORY;

typedef struct _REG_SETUP {

    DWORD                   Installed;
    DWORD                   InstallType;
    DWORD                   InstalledPlatforms;
    LPTSTR                  Csid;
    LPTSTR                  Tsid;
    LPTSTR                  Printer;
    LPTSTR                  StoreDir;
    LPTSTR                  Profile;
    DWORD                   Mask;
    DWORD                   Rings;

} REG_SETUP, *PREG_SETUP;

typedef struct _REG_FAX_SERVICE {

    DWORD                   Retries;
    DWORD                   RetryDelay;
    DWORD                   DirtyDays;
    BOOL                    QueuePaused;
    BOOL                    NextJobNumber;
    BOOL                    Branding;
    BOOL                    UseDeviceTsid;
    BOOL                    ServerCp;
    BOOL                    ForceReceive;
    DWORD                   TerminationDelay;
    FAX_TIME                StartCheapTime;
    FAX_TIME                StopCheapTime;
    BOOL                    ArchiveOutgoingFaxes;
    LPTSTR                  ArchiveDirectory;
    LPTSTR                  InboundProfile;
    PREG_DEVICE_PROVIDER    DeviceProviders;
    DWORD                   DeviceProviderCount;
    PREG_ROUTING_EXTENSION  RoutingExtensions;
    DWORD                   RoutingExtensionsCount;
    PREG_DEVICE             Devices;
    DWORD                   DeviceCount;
    PREG_DEVICE_CACHE       DevicesCache;
    DWORD                   DeviceCacheCount;
    PREG_CATEGORY           Logging;
    DWORD                   LoggingCount;

} REG_FAX_SERVICE, *PREG_FAX_SERVICE;

typedef struct _REG_FAX_DEVICES {

    DWORD                   DeviceCount;
    PREG_DEVICE             Devices;

} REG_FAX_DEVICES, *PREG_FAX_DEVICES;

typedef struct _REG_FAX_DEVICES_CACHE {

    DWORD                   DeviceCount;
    PREG_DEVICE_CACHE       Devices;

} REG_FAX_DEVICES_CACHE, *PREG_FAX_DEVICES_CACHE;

typedef struct _REG_FAX_LOGGING {

    DWORD                   LoggingCount;
    PREG_CATEGORY           Logging;

} REG_FAX_LOGGING, *PREG_FAX_LOGGING;



//
// function prototypes
//

PREG_FAX_SERVICE
GetFaxRegistry(
    VOID
    );

VOID
FreeFaxRegistry(
    PREG_FAX_SERVICE FaxReg
    );

BOOL
CreateFaxEventSource(
    PREG_FAX_SERVICE FaxReg,
    PFAX_LOG_CATEGORY DefaultCategories,
    int DefaultCategoryCount
    );

BOOL
SetFaxRegistry(
    PREG_FAX_SERVICE FaxReg
    );

PREG_FAX_DEVICES
GetFaxDevicesRegistry(
    VOID
    );

PREG_FAX_DEVICES_CACHE
GetFaxDevicesCacheRegistry(
    VOID
    );

PREG_ROUTING_INFO
RegGetRoutingInfo(
    DWORD PermanentLineID 
    );

VOID
FreeRegRoutingInfo(
    PREG_ROUTING_INFO RoutingInfo
    );

BOOL
SetFaxRoutingInfo(
    LPTSTR ExtensionName,
    LPTSTR MethodName,
    LPTSTR Guid,
    DWORD  Priority,
    LPTSTR FunctionName,
    LPTSTR FriendlyName
    ) ;

VOID
FreeFaxDevicesRegistry(
    PREG_FAX_DEVICES FaxReg
    );

VOID
FreeFaxDevicesCacheRegistry(
    PREG_FAX_DEVICES_CACHE FaxReg
    );

BOOL
SetFaxDeviceFlags(
    DWORD PermanentLineID,
    DWORD Flags
    );

BOOL
DeleteFaxDevice(
    DWORD PermanentLineID
    );

BOOL 
DeleteCachedFaxDevice(
    LPTSTR DeviceName
    );

BOOL
GetInstallationInfo(
    LPDWORD Installed,
    LPDWORD InstallType,
    LPDWORD InstalledPlatforms,
    LPDWORD ProductType
    );

BOOL
IsModemClass1(
    LPSTR SubKey,
    LPBOOL Class1Fax
    );

BOOL
SaveModemClass(
    LPSTR SubKey,
    BOOL Class1Fax
    );

DWORD
RegAddNewFaxDevice(
    LPTSTR DeviceName,
    LPTSTR ProviderName,
    LPTSTR Csid,
    LPTSTR Tsid,
    DWORD Priority,
    DWORD PermanentLineID,
    DWORD Flags,
    DWORD Rings,
    LONG RoutingMask,             // -1 means don't set routing
    LPTSTR RoutePrinterName,
    LPTSTR RouteDir,
    LPTSTR RouteProfile
    );

BOOL
RegAddNewFaxDeviceCache(
    LPTSTR DeviceName,
    LPTSTR ProviderName,
    LPTSTR Csid,
    LPTSTR Tsid,
    DWORD PermanentLineID,
    DWORD Flags,
    DWORD Rings,
    DWORD RoutingMask,
    LPTSTR RoutePrinterName,
    LPTSTR RouteDir,
    LPTSTR RouteProfile
    ) ;

BOOL
GetOrigSetupData(
    PREG_SETUP RegSetup
    );

VOID
FreeOrigSetupData(
    PREG_SETUP RegSetup
    );

BOOL
SetFaxGlobalsRegistry(
    PFAX_CONFIGURATION FaxConfig
    );

BOOL
GetLoggingCategoriesRegistry(
    PREG_FAX_LOGGING FaxRegLogging
    );

BOOL
SetLoggingCategoriesRegistry(
    PREG_FAX_LOGGING FaxRegLogging
    );

BOOL
SetFaxJobNumberRegistry(
    DWORD NextJobNumber
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\inc\rpcutil.h ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    ntrpcp.h

Abstract:

    This file contains prototypes for commonly used RPC functionality.
    This includes: bind/unbind functions, MIDL user alloc/free functions,
    and server start/stop functions.

Author:

    Dan Lafferty danl 06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     danl
        Created

    26-Apr-1991 JohnRo
        Added IN and OUT keywords to MIDL functions.  Commented-out
        (nonstandard) identifier on endif.  Deleted tabs.

    03-July-1991    JimK
        Commonly used aspects copied from LM specific file.

--*/
#ifndef _NTRPCP_
#define _NTRPCP_

//
// Function Prototypes - routines called by MIDL-generated code:
//

void * __stdcall
MIDL_user_allocate(
    IN size_t NumBytes
    );

void __stdcall
MIDL_user_free(
    IN void *MemPointer
    );

//
// Function Prototypes - routines to go along with the above, but aren't
// needed by MIDL or any other non-network software.
//

void *
MIDL_user_reallocate(
    IN void * OldPointer OPTIONAL,
    IN size_t NewByteCount
    );

unsigned long
MIDL_user_size(
    IN void * Pointer
    );

//
// client side functions
//


DWORD
RpcpBindRpc(
    IN  LPCWSTR               servername,
    IN  LPCWSTR               servicename,
    IN  LPCWSTR               networkoptions,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    );

DWORD
RpcpUnbindRpc(
    IN  RPC_BINDING_HANDLE BindingHandle
    );

//
// server side functions
//

DWORD
RpcpInitRpcServer(
    VOID
    );

DWORD
RpcpAddInterface(
    IN  LPWSTR              InterfaceName,
    IN  RPC_IF_HANDLE       InterfaceSpecification
    );

DWORD
RpcpStartRpcServer(
    IN  LPWSTR              InterfaceName,
    IN  RPC_IF_HANDLE       InterfaceSpecification
    );

DWORD
RpcpDeleteInterface(
    IN  RPC_IF_HANDLE      InterfaceSpecification
    );

DWORD
RpcpStopRpcServer(
    IN  RPC_IF_HANDLE      InterfaceSpecification
    );

#endif // _NTRPCP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\server\faxsvc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxsvc.c

Abstract:

    This module contains the service specific code.

Author:

    Wesley Witt (wesw) 16-Jan-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop


#if DBGX

//
// this is bad place to have these defines
// because they are already in ntexapi.h, but it
// is difficult to include windows headers and
// nt headers together.  we will just have to be
// aware that if the global flag definitions in
// ntexapi.h change, they must also change here.
//
#define FLG_SHOW_LDR_SNAPS              0x00000002      // user and kernel mode
#define FLG_USER_STACK_TRACE_DB         0x00001000      // x86 user mode only
#define FLG_HEAP_ENABLE_CALL_TRACING    0x00100000      // user mode only
#define FLG_HEAP_PAGE_ALLOCS            0x02000000      // user mode only

IMAGE_LOAD_CONFIG_DIRECTORY _load_config_used =
{
    0,                                   // Reserved
    0,                                   // Reserved
    0,                                   // Reserved
    0,                                   // Reserved
    0,                                   // GlobalFlagsClear
    FLG_USER_STACK_TRACE_DB | FLG_HEAP_ENABLE_CALL_TRACING,
    0,                                   // CriticalSectionTimeout (milliseconds)
    0,                                   // DeCommitFreeBlockThreshold
    0,                                   // DeCommitTotalFreeThreshold
    NULL,                                // LockPrefixTable
    0, 0, 0, 0, 0, 0, 0                  // Reserved
};

#endif



SERVICE_STATUS          FaxServiceStatus;
SERVICE_STATUS_HANDLE   FaxServiceStatusHandle;
BOOL                    ServiceDebug;
HANDLE                  FaxSvcHeapHandle;

SERVICE_TABLE_ENTRY   ServiceDispatchTable[] = {
    { FAX_SERVICE_NAME,   FaxServiceMain    },
    { NULL,               NULL              }
};



int
WINAPI
#ifdef UNICODE
wWinMain(
#else
WinMain(
#endif
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPTSTR    lpCmdLine,
    int       nShowCmd
    )

/*++

Routine Description:

    Main entry point for the TIFF image viewer.


Arguments:

    hInstance       - Instance handle
    hPrevInstance   - Not used
    lpCmdLine       - Command line arguments
    nShowCmd        - How to show the window

Return Value:

    Return code, zero for success.

--*/

{
    int     rVal;
    LPTSTR  p;
    DWORD   Action = 0;
    LPTSTR  Username;
    LPTSTR  Password;


    FaxSvcHeapHandle = HeapInitialize(NULL,NULL,NULL,0);

    FaxTiffInitialize();

    for (p=lpCmdLine; *p; p++) {
        if ((*p == TEXT('-')) || (*p == TEXT('/'))) {
            switch( _totlower( p[1] ) ) {
                case TEXT('i'):
                    Action = 1;
                    p += 2;
                    while( *p == TEXT(' ') ) p++;
                    Username = p;
                    while( *p != TEXT(' ') ) p++;
                    while( *p == TEXT(' ') ) p++;
                    Password = p;
                    while( *p != TEXT(' ') ) p++;
                    break;

                case TEXT('r'):
                    Action = 2;
                    break;

                case TEXT('d'):
                    Action = 3;
                    break;
            }
        }
    }

    switch( Action ) {
        case 1:
            rVal = InstallService( Username, Password );
            if (rVal == 0) {
                LogMessage( MSG_INSTALL_SUCCESS );
            } else {
                LogMessage( MSG_INSTALL_FAIL, GetLastErrorText( rVal ) );
            }
            return rVal;

        case 2:
            rVal = RemoveService();
            if (rVal == 0) {
                LogMessage( MSG_REMOVE_SUCCESS );
            } else {
                LogMessage( MSG_REMOVE_FAIL, GetLastErrorText( rVal ) );
            }
            return rVal;

        case 3:
            ServiceDebug = TRUE;
            ConsoleDebugOutput = TRUE;
            return ServiceStart();
    }

    if (!StartServiceCtrlDispatcher( ServiceDispatchTable)) {
        DebugPrint(( TEXT("StartServiceCtrlDispatcher error =%d"), GetLastError() ));
        return GetLastError();
    }

    return 0;
}

DWORD
InstallService(
    LPTSTR  Username,
    LPTSTR  Password
    )

/*++

Routine Description:

    Service installation function.  This function just
    calls the service controller to install the FAX service.
    It is required that the FAX service run in the context
    of a user so that the service can access MAPI, files on
    disk, the network, etc.

Arguments:

    Username    - User name where the service runs.
    Password    - Password for the user name.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/

{
    DWORD       rVal = 0;
    SC_HANDLE   hSvcMgr;
    SC_HANDLE   hService;

    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        rVal = GetLastError();
        DebugPrint(( TEXT("could not open service manager: error code = %u"), rVal ));
        return rVal;
    }

    hService = CreateService(
            hSvcMgr,
            FAX_SERVICE_NAME,
            FAX_DISPLAY_NAME,
            SERVICE_ALL_ACCESS,
            SERVICE_WIN32_OWN_PROCESS,
            SERVICE_AUTO_START,
            SERVICE_ERROR_NORMAL,
            FAX_IMAGE_NAME,
            NULL,
            NULL,
            NULL,
            Username,
            Password
            );
    if (!hService) {
        rVal = GetLastError();
        DebugPrint(( TEXT("could not create fax service: error code = %u"), rVal ));
        return rVal;
    }

    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}


DWORD
RemoveService(
    void
    )

/*++

Routine Description:

    Service removal function.  This function just
    calls the service controller to remove the FAX service.

Arguments:

    None.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/

{
    DWORD       rVal = 0;
    SC_HANDLE   hSvcMgr;
    SC_HANDLE   hService;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        rVal = GetLastError();
        DebugPrint(( TEXT("could not open service manager: error code = %u"), rVal ));
        return rVal;
    }

    hService = OpenService(
        hSvcMgr,
        FAX_SERVICE_NAME,
        SERVICE_ALL_ACCESS
        );
    if (!hService) {
        rVal = GetLastError();
        DebugPrint(( TEXT("could not open the fax service: error code = %u"), rVal ));
        return rVal;
    }

    if (ControlService( hService, SERVICE_CONTROL_STOP, &FaxServiceStatus )) {
        //
        // wait for 1 second
        //
        Sleep( 1000 );

        while( QueryServiceStatus( hService, &FaxServiceStatus ) ) {
            if ( FaxServiceStatus.dwCurrentState == SERVICE_STOP_PENDING ) {
                Sleep( 1000 );
            } else {
                break;
            }
        }

        if (FaxServiceStatus.dwCurrentState != SERVICE_STOPPED) {
            rVal = GetLastError();
            DebugPrint(( TEXT("could not stop the fax service: error code = %u"), rVal ));
            return rVal;
        }
    }

    if (!DeleteService( hService )) {
        rVal = GetLastError();
        DebugPrint(( TEXT("could not delete the fax service: error code = %u"), rVal ));
        return rVal;
    }

    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}


VOID
FaxServiceMain(
    DWORD argc,
    LPTSTR *argv
    )

/*++

Routine Description:

    This is the service main that is called by the
    service controller.

Arguments:

    argc        - argument count
    argv        - argument array

Return Value:

    None.

--*/

{
    DWORD Rval;


    FaxServiceStatus.dwServiceType        = SERVICE_WIN32;
    FaxServiceStatus.dwCurrentState       = SERVICE_START_PENDING;
    FaxServiceStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE;
    FaxServiceStatus.dwWin32ExitCode      = 0;
    FaxServiceStatus.dwServiceSpecificExitCode = 0;
    FaxServiceStatus.dwCheckPoint         = 0;
    FaxServiceStatus.dwWaitHint           = 0;

    FaxServiceStatusHandle = RegisterServiceCtrlHandler(
        FAX_SERVICE_NAME,
        FaxServiceCtrlHandler
        );

    if (!FaxServiceStatusHandle) {
        DebugPrint(( TEXT("RegisterServiceCtrlHandler failed %d"), GetLastError() ));
        return;
    }

    Rval = ServiceStart();
    if (!Rval) {
        //
        // the service failed to start correctly
        //


    }

    return;
}


VOID
FaxServiceCtrlHandler(
    DWORD Opcode
    )

/*++

Routine Description:

    This is the FAX service control dispatch function.

Arguments:

    Opcode      - requested control code

Return Value:

    None.

--*/

{
    switch(Opcode) {
        case SERVICE_CONTROL_PAUSE:
            ReportServiceStatus( SERVICE_PAUSED, 0, 0 );
            break;

        case SERVICE_CONTROL_CONTINUE:
            ReportServiceStatus( SERVICE_RUNNING, 0, 0 );
            break;

        case SERVICE_CONTROL_STOP:
            EndFaxSvc(FALSE,FAXLOG_LEVEL_NONE);            
            return;

        case SERVICE_CONTROL_INTERROGATE:
            // fall through to send current status
            break;

        default:
            DebugPrint(( TEXT("Unrecognized opcode %ld"), Opcode ));
            break;
    }

    ReportServiceStatus( 0, 0, 0 );

    return;
}


DWORD
ReportServiceStatus(
    DWORD CurrentState,
    DWORD Win32ExitCode,
    DWORD WaitHint
    )

/*++

Routine Description:

    This function updates the service control manager's status information for the FAX service.

Arguments:

    CurrentState    - Indicates the current state of the service
    Win32ExitCode   - Specifies a Win32 error code that the service uses to
                      report an error that occurs when it is starting or stopping.
    WaitHint        - Specifies an estimate of the amount of time, in milliseconds,
                      that the service expects a pending start, stop, or continue
                      operation to take before the service makes its next call to the
                      SetServiceStatus function with either an incremented dwCheckPoint
                      value or a change in dwCurrentState.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/

{
    static DWORD CheckPoint = 1;
    BOOL rVal;


    if (ServiceDebug) {
        return TRUE;
    }

    if (CurrentState == SERVICE_START_PENDING) {
        FaxServiceStatus.dwControlsAccepted = 0;
    } else {
        FaxServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    }

    if (CurrentState) {
        FaxServiceStatus.dwCurrentState = CurrentState;
    }
    FaxServiceStatus.dwWin32ExitCode = Win32ExitCode;
    FaxServiceStatus.dwWaitHint = WaitHint;

    if ((FaxServiceStatus.dwCurrentState == SERVICE_RUNNING) ||
        (FaxServiceStatus.dwCurrentState == SERVICE_STOPPED ) ) {
        FaxServiceStatus.dwCheckPoint = 0;
    } else {
        FaxServiceStatus.dwCheckPoint = CheckPoint++;
    }

    //
    // Report the status of the service to the service control manager.
    //
    rVal = SetServiceStatus( FaxServiceStatusHandle, &FaxServiceStatus );
    if (!rVal) {
        DebugPrint(( TEXT("SetServiceStatus() failed: ec=%d"), GetLastError() ));
    }

    return rVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\server\faxrpc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxrpc.c

Abstract:

    This module contains the functions that are dispatched
    as a result of an rpc call.

Author:

    Wesley Witt (wesw) 16-Jan-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop

//
// version defines
//

#define WINFAX_MAJOR_VERSION        1803
#define WINFAX_MINOR_VERSION        1

#define WINFAX_VERSION              ((WINFAX_MINOR_VERSION<<16) | WINFAX_MAJOR_VERSION)

LIST_ENTRY          ClientsListHead;
CRITICAL_SECTION    CsClients;
LONG                ConnectionCount = 0;        // Represents the number of active rpc connections plus the number
                                                // of devices with receive enabled.   If > zero, the service will not
                                                // shut itself down.



void *
MIDL_user_allocate(
    IN size_t NumBytes
    )
{
    return MemAlloc( NumBytes );
}


void
MIDL_user_free(
    IN void *MemPointer
    )
{
    MemFree( MemPointer );
}


VOID
StoreString(
    LPCTSTR String,
    PULONG_PTR DestString,
    LPBYTE Buffer,
    PULONG_PTR Offset
    )
{
    if (String) {
        _tcscpy( (LPTSTR) (Buffer+*Offset), String );
        *DestString = *Offset;
        *Offset += StringSize( String );
    } else {
        *DestString = 0;
    }

}

error_status_t
FAX_ConnectionRefCount(
    handle_t FaxHandle,
    LPHANDLE FaxConHandle,
    DWORD Connect,
    LPDWORD CanShare
    )
/*++

Routine Description:

    Called on connect.  Maintains an active connection count.  Client unbind rpc and
    the counter is decremented in the rundown routine.  Returns a context handle to the client.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    FaxConHandle    - Context handle
    Connect         - 1 if connecting, 0 if disconnecting
    CanShare        - non-zero if sharing is allowed, zero otherwise

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    PHANDLE_ENTRY HandleEntry;
    error_status_t Rval = 0;
    static int Sharing = -1;

    if (Sharing == -1) {
        Sharing = IsProductSuite() ? 1 : 0 ;        // If running on SBS or Comm Server, sharing is allowed.
    }


    __try {

        *CanShare = Sharing;

        if (Connect == 0) {

            HandleEntry = (PHANDLE_ENTRY) *FaxConHandle;

            *FaxConHandle = NULL;

            CloseFaxHandle( HandleEntry );

            return 0;
        }

        HandleEntry = CreateNewConnectionHandle( FaxHandle );

        if (!HandleEntry) {
            Rval = ERROR_INVALID_HANDLE;
            _leave;
        }

        *FaxConHandle = (HANDLE) HandleEntry;

        InterlockedIncrement( &ConnectionCount );



    } __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // for some reason we crashed, so return the exception code
        //

        Rval = GetExceptionCode();

    }


    return Rval;
}


VOID
RPC_FAX_SVC_HANDLE_rundown(
    IN HANDLE FaxConnectionHandle
    )
{
    PHANDLE_ENTRY HandleEntry = (PHANDLE_ENTRY) FaxConnectionHandle;


    __try {

        DebugPrint(( TEXT("RPC_FAX_SVC_HANDLE_rundown() running for connection handle 0x%08x"), FaxConnectionHandle ));

        CloseFaxHandle( HandleEntry );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        DebugPrint(( TEXT("RPC_FAX_SVC_HANDLE_rundown() crashed, ec=0x%08x"), GetExceptionCode() ));

    }

    return;
}

error_status_t
FAX_GetVersion(
    handle_t FaxHandle,
    LPDWORD Version
    )

/*++

Routine Description:

    Gets the FAX dll's version number.  This
    API is really only used as a ping API.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    Version         - Version number.


Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    if (!Version) {
        return ERROR_INVALID_PARAMETER;
    }
    *Version = WINFAX_VERSION;
    return 0;
}


error_status_t
FAX_GetInstallType(
    IN  handle_t    FaxHandle,
    OUT LPDWORD     InstallType,
    OUT LPDWORD     InstalledPlatforms,
    OUT LPDWORD     ProductType
    )

/*++

Routine Description:

    Gets the FAX dll's version number.  This
    API is really only used as a ping API.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    Version         - Version number.


Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    DWORD Installed;


    if ((!GetInstallationInfo( &Installed, InstallType, InstalledPlatforms, ProductType )) || (!Installed)) {
        return ERROR_INVALID_FUNCTION;
    }

    return 0;
}


error_status_t
FAX_OpenPort(
    handle_t            FaxHandle,
    DWORD               DeviceId,
    DWORD               Flags,
    LPHANDLE            FaxPortHandle
    )

/*++

Routine Description:

    Opens a fax port for subsequent use in other fax APIs.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    DeviceId        - Requested device id
    FaxPortHandle   - The resulting FAX port handle.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t Rval = 0;
    PLINE_INFO LineInfo;
    PHANDLE_ENTRY HandleEntry;


    if (!FaxSvcAccessCheck( SEC_PORT_QUERY, FAX_PORT_QUERY )) {
        return ERROR_ACCESS_DENIED;
    }

    if (!FaxPortHandle) {
        return ERROR_INVALID_PARAMETER;
    }

    EnterCriticalSection( &CsLine );

    __try {

        LineInfo = GetTapiLineFromDeviceId( DeviceId );
        if (LineInfo) {
            if (Flags & PORT_OPEN_MODIFY) {
                //
                // the client wants to open the port for modify
                // access so we must make sure that no other
                // client already has this port open for modify access
                //
                if (IsPortOpenedForModify( LineInfo )) {
                    Rval = ERROR_INVALID_HANDLE;
                    _leave;
                }
            }

            HandleEntry = CreateNewPortHandle( FaxHandle, LineInfo, Flags );
            if (!HandleEntry) {
                Rval = ERROR_INVALID_HANDLE;
                _leave;
            }

            *FaxPortHandle = (HANDLE) HandleEntry;
        } else {
            Rval = ERROR_BAD_UNIT;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // for some reason we crashed, so return the exception code
        //

        Rval = GetExceptionCode();

    }

    LeaveCriticalSection( &CsLine );

    return Rval;
}


error_status_t
FAX_ClosePort(
    OUT LPHANDLE    FaxPortHandle
    )

/*++

Routine Description:

    Closes an open FAX port.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    FaxPortHandle   - FAX port handle obtained from FaxOpenPort.


Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t Rval = 0;


    if (!FaxSvcAccessCheck( SEC_PORT_QUERY, FAX_PORT_QUERY )) {
        return ERROR_ACCESS_DENIED;
    }

    __try {

        CloseFaxHandle( (PHANDLE_ENTRY) *FaxPortHandle );

        *FaxPortHandle = NULL;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // for some reason we crashed, so return the exception code
        //

        Rval = GetExceptionCode();

    }

    return Rval;
}

error_status_t
FAX_SendDocument(
    IN handle_t FaxHandle,
    IN LPCWSTR FileName,
    IN const FAX_JOB_PARAMW *JobParams,
    OUT LPDWORD FaxJobId
    )

/*++

Routine Description:

    Sends a FAX document to the specified recipient.
    This is an asychronous operation.  Use FaxReportStatus
    to determine when the send is completed.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    FileName        - File containing the TIFF-F FAX document.
    JobParams       - pointer to FAX_JOB_PARAM structure describing transmission
    FaxJobId        - receives job id for this transmission.


Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    PJOB_QUEUE JobQueue = NULL, JobQueueEntry = NULL;
    LPCWSTR UserName;
    WCHAR TifFileName[MAX_PATH];
    DWORD rc = ERROR_SUCCESS;

    //
    // do a security check
    //

    if (!FaxSvcAccessCheck( SEC_JOB_SET, FAX_JOB_SUBMIT )) {
        return ERROR_ACCESS_DENIED;
    }

    //
    // argument validation
    //
    if (!JobParams ||
        !FileName  ||
        !FaxJobId  ||
        (wcslen(FileName)+wcslen(FaxQueueDir)+2 > MAX_PATH)) {
        return ERROR_INVALID_PARAMETER;
    }

    if (JobParams->Reserved[0] == 0xfffffffe) {

        if (JobParams->Reserved[1] == 2) {
            if (JobParams->RecipientNumber == NULL) {
                return ERROR_INVALID_PARAMETER;
            }
        } else if (JobParams->Reserved[1] == 1) {
            if (FileName == NULL) {
                return ERROR_INVALID_PARAMETER;
            }
        }

    } else if (JobParams->CallHandle != 0) {

        if (FileName == NULL || JobParams->RecipientNumber == NULL) {
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // get the client's user name
    //

    UserName = GetClientUserName();
    if (!UserName) {
        return GetLastError();
    }

    //
    // create a full path to the file
    //

    swprintf( TifFileName, L"%s\\%s", FaxQueueDir, FileName );

    // 
    // validate the tiff file
    //
    rc =  ValidateTiffFile(TifFileName);
    if (rc != ERROR_SUCCESS) {
        MemFree( (LPBYTE) UserName );
        return rc;
    }
    
    //
    // add the job to the queue
    //

    JobQueueEntry = AddJobQueueEntry(
        JT_SEND,
        TifFileName,
        JobParams,
        UserName,
        TRUE,
        NULL
        );

    MemFree( (LPBYTE) UserName );

    if (!JobQueueEntry) {
        return ERROR_INVALID_PARAMETER;
    }

    EnterCriticalSection( &CsJob) ;
    EnterCriticalSection( &CsQueue );
    __try {
        JobQueue = FindJobQueueEntryByJobQueueEntry(JobQueueEntry);

        if (!JobQueue) {
            __leave;
        }

        if (JobParams->Reserved[0] == 0xffffffff) {
            CreateFaxEvent( (DWORD)JobParams->Reserved[1], FEI_JOB_QUEUED, JobQueue->JobId );
        } else {
            CreateFaxEvent( 0, FEI_JOB_QUEUED, JobQueue->JobId );
        }

        *FaxJobId = JobQueue->JobId;
        rc = ERROR_SUCCESS;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        rc = GetExceptionCode();
        DebugPrint(( TEXT("FAX_SendDocument() crashed, ec=0x%08x"), rc ));        
    }

    LeaveCriticalSection( &CsQueue );
    LeaveCriticalSection( &CsJob );

    return(rc);
}


error_status_t
FAX_GetQueueFileName(
    IN  handle_t FaxHandle,
    OUT LPTSTR FileName,
    IN DWORD FileNameSize
    )
{
    WCHAR QueueFileName[MAX_PATH];
    LPWSTR p;
    RPC_STATUS ec;

    ec = RpcImpersonateClient(FaxHandle);

    if (ec != RPC_S_OK) {
        DebugPrint(( TEXT("RpcImpersonateClient failed, ec = %d\n"),ec ));
        return ec;
    }

    GenerateUniqueFileName( FaxQueueDir, TEXT("tif"), QueueFileName, sizeof(QueueFileName)/sizeof(WCHAR) );

    RpcRevertToSelf();

    p = wcsrchr( QueueFileName, L'\\' );
    if (p) {
        p += 1;
    } else {
        p = QueueFileName;
    }

    wcsncpy( FileName, p , FileNameSize );

    return 0;
}



error_status_t
FAX_EnumJobs(
    IN handle_t FaxHandle,
    OUT LPBYTE *Buffer,
    OUT LPDWORD BufferSize,
    OUT LPDWORD JobsReturned
    )

/*++

Routine Description:

    Enumerates jobs.

Arguments:

    FaxHandle   - FAX handle obtained from FaxConnectFaxServer.
    Buffer      - Buffer to hold the job information
    BufferSize  - Total size of the job info buffer

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    PLIST_ENTRY Next;
    PJOB_QUEUE JobQueue;
    DWORD rVal = 0;
    ULONG_PTR Offset = 0;
    DWORD Size = 0;
    DWORD Count = 0;
    PFAX_JOB_ENTRYW JobEntry;


    if (!FaxSvcAccessCheck( SEC_JOB_SET, FAX_JOB_QUERY )) {
        return ERROR_ACCESS_DENIED;
    }

    if (!Buffer || !BufferSize || !JobsReturned)
        return ERROR_INVALID_PARAMETER;

    EnterCriticalSection( &CsJob) ;
    EnterCriticalSection( &CsQueue );

    Next = QueueListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&QueueListHead) {
        JobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = JobQueue->ListEntry.Flink;
        // don't include broadcast owner jobs, we don't want user to see these
        if (!( JobQueue->BroadcastJob && JobQueue->BroadcastOwner == NULL ) ) {
            Count += 1;
            Size += sizeof(FAX_JOB_ENTRYW);
            Size += StringSize( JobQueue->UserName );
            Size += StringSize( JobQueue->JobParams.RecipientNumber );
            Size += StringSize( JobQueue->JobParams.RecipientName );
            Size += StringSize( JobQueue->JobParams.Tsid );
            Size += StringSize( JobQueue->JobParams.SenderName );
            Size += StringSize( JobQueue->JobParams.SenderCompany );
            Size += StringSize( JobQueue->JobParams.SenderDept );
            Size += StringSize( JobQueue->JobParams.BillingCode );
            Size += StringSize( JobQueue->JobParams.DeliveryReportAddress );
            Size += StringSize( JobQueue->JobParams.DocumentName );
        }
    }

    *BufferSize = Size;
    *Buffer = (LPBYTE) MemAlloc( Size );
    if (*Buffer == NULL) {
        LeaveCriticalSection( &CsQueue );
        LeaveCriticalSection( &CsJob );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Offset = sizeof(FAX_JOB_ENTRYW) * Count;
    JobEntry = (PFAX_JOB_ENTRYW) *Buffer;

    Next = QueueListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&QueueListHead) {

        JobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = JobQueue->ListEntry.Flink;
        // don't include broadcast owner jobs, we don't want user to see these
        if (!( JobQueue->BroadcastJob && JobQueue->BroadcastOwner == NULL ) ) {

            JobEntry->SizeOfStruct = sizeof(FAX_JOB_ENTRYW);
            JobEntry->JobId                  = JobQueue->JobId;
            JobEntry->JobType                = JobQueue->JobType;
            JobEntry->QueueStatus            = JobQueue->JobStatus;

            if (JobQueue->JobEntry && JobQueue->JobEntry->LineInfo) {
                JobEntry->Status             = JobQueue->JobEntry->LineInfo->State;
            } else {
                JobEntry->Status             = 0;
            }
            JobEntry->ScheduleAction         = JobQueue->JobParams.ScheduleAction;
            JobEntry->DeliveryReportType     = JobQueue->DeliveryReportType;
            FileTimeToSystemTime((LPFILETIME) &JobQueue->ScheduleTime, &JobEntry->ScheduleTime);
            JobEntry->PageCount              = JobQueue->PageCount;
            JobEntry->Size                   = JobQueue->FileSize;

            StoreString(
                JobQueue->UserName,
                (PULONG_PTR)&JobEntry->UserName,
                *Buffer,
                &Offset
                );

            StoreString(
                JobQueue->JobParams.RecipientNumber,
                (PULONG_PTR)&JobEntry->RecipientNumber,
                *Buffer,
                &Offset
                );

            StoreString(
                JobQueue->JobParams.RecipientName,
                (PULONG_PTR)&JobEntry->RecipientName,
                *Buffer,
                &Offset
                );

            StoreString(
                JobQueue->JobParams.DocumentName,
                (PULONG_PTR)&JobEntry->DocumentName,
                *Buffer,
                &Offset
                );

            StoreString(
                JobQueue->JobParams.Tsid,
                (PULONG_PTR)&JobEntry->Tsid,
                *Buffer,
                &Offset
                );

            StoreString(
                JobQueue->JobParams.SenderName,
                (PULONG_PTR)&JobEntry->SenderName,
                *Buffer,
                &Offset
                );

            StoreString(
                JobQueue->JobParams.SenderCompany,
                (PULONG_PTR)&JobEntry->SenderCompany,
                *Buffer,
                &Offset
                );

            StoreString(
                JobQueue->JobParams.SenderDept,
                (PULONG_PTR)&JobEntry->SenderDept,
                *Buffer,
                &Offset
                );

            StoreString(
                JobQueue->JobParams.BillingCode,
                (PULONG_PTR)&JobEntry->BillingCode,
                *Buffer,
                &Offset
                );

            StoreString(
                JobQueue->JobParams.DeliveryReportAddress,
                (PULONG_PTR)&JobEntry->DeliveryReportAddress,
                *Buffer,
                &Offset
                );

            JobEntry += 1;
        }
    }

    LeaveCriticalSection( &CsQueue );
    LeaveCriticalSection( &CsJob );

    *JobsReturned = Count;

    return 0;
}

DWORD
GetJobSize(
    PJOB_QUEUE JobQueue
    )
{
    DWORD Size;


    Size = sizeof(FAX_JOB_ENTRYW);
    Size += StringSize( JobQueue->UserName );
    Size += StringSize( JobQueue->JobParams.RecipientNumber );
    Size += StringSize( JobQueue->JobParams.RecipientName );
    Size += StringSize( JobQueue->JobParams.Tsid );
    Size += StringSize( JobQueue->JobParams.SenderName );
    Size += StringSize( JobQueue->JobParams.SenderCompany );
    Size += StringSize( JobQueue->JobParams.SenderDept );
    Size += StringSize( JobQueue->JobParams.BillingCode );
    Size += StringSize( JobQueue->DeliveryReportAddress );
    Size += StringSize( JobQueue->JobParams.DocumentName );

    return Size;
}


VOID
GetJobData(
    LPBYTE JobBuffer,
    PFAX_JOB_ENTRYW FaxJobEntry,
    PJOB_QUEUE JobQueue,
    PULONG_PTR Offset
    )
{

    FaxJobEntry->SizeOfStruct           = sizeof (FAX_JOB_ENTRYW);
    FaxJobEntry->JobId                  = JobQueue->JobId;
    FaxJobEntry->JobType                = JobQueue->JobType;
    FaxJobEntry->QueueStatus            = JobQueue->JobStatus;
    FaxJobEntry->PageCount              = JobQueue->PageCount;
    FaxJobEntry->Size                   = JobQueue->FileSize;
    FaxJobEntry->ScheduleAction         = JobQueue->JobParams.ScheduleAction;
    FaxJobEntry->DeliveryReportType     = JobQueue->DeliveryReportType;

    //
    // copy the schedule time that the user orginally requested
    //
    FileTimeToSystemTime((LPFILETIME) &JobQueue->ScheduleTime, &FaxJobEntry->ScheduleTime);

    //
    // get the device status, this job might not be scheduled yet, though.
    //
    EnterCriticalSection(&CsJob);

    __try {
        if (JobQueue->JobEntry && JobQueue->JobEntry->LineInfo) {
            FaxJobEntry->Status = JobQueue->JobEntry->LineInfo->State;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        LeaveCriticalSection(&CsJob);
    }

    LeaveCriticalSection(&CsJob);


    StoreString( JobQueue->UserName,                  (PULONG_PTR)&FaxJobEntry->UserName,              JobBuffer,  Offset );
    StoreString( JobQueue->JobParams.RecipientNumber, (PULONG_PTR)&FaxJobEntry->RecipientNumber,       JobBuffer,  Offset );
    StoreString( JobQueue->JobParams.RecipientName,   (PULONG_PTR)&FaxJobEntry->RecipientName,         JobBuffer,  Offset );
    StoreString( JobQueue->JobParams.Tsid,            (PULONG_PTR)&FaxJobEntry->Tsid,                  JobBuffer,  Offset );
    StoreString( JobQueue->JobParams.SenderName,      (PULONG_PTR)&FaxJobEntry->SenderName,            JobBuffer,  Offset );
    StoreString( JobQueue->JobParams.SenderCompany,   (PULONG_PTR)&FaxJobEntry->SenderCompany,         JobBuffer,  Offset );
    StoreString( JobQueue->JobParams.SenderDept,      (PULONG_PTR)&FaxJobEntry->SenderDept,            JobBuffer,  Offset );
    StoreString( JobQueue->JobParams.BillingCode,     (PULONG_PTR)&FaxJobEntry->BillingCode,           JobBuffer,  Offset );
    StoreString( JobQueue->DeliveryReportAddress,     (PULONG_PTR)&FaxJobEntry->DeliveryReportAddress, JobBuffer,  Offset );
    StoreString( JobQueue->JobParams.DocumentName,    (PULONG_PTR)&FaxJobEntry->DocumentName,          JobBuffer,  Offset );

    return;
}



error_status_t
FAX_GetJob(
    IN handle_t FaxHandle,
    IN DWORD JobId,
    OUT LPBYTE *Buffer,
    OUT LPDWORD BufferSize
    )
{
    PJOB_QUEUE JobQueue;
    ULONG_PTR Offset = sizeof(FAX_JOB_ENTRYW);
    DWORD Rval = 0;

    if (!FaxSvcAccessCheck( SEC_JOB_SET, FAX_JOB_QUERY )) {
        return ERROR_ACCESS_DENIED;
    }

    EnterCriticalSection( &CsJob );
    EnterCriticalSection( &CsQueue );

    JobQueue = FindJobQueueEntry( JobId );
    // don't include broadcast owner jobs, we don't want user to see these
    if (!JobQueue || (JobQueue->BroadcastJob && JobQueue->BroadcastOwner == NULL) ) {
        Rval = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    __try {
        *BufferSize = GetJobSize(JobQueue);

        *Buffer = MemAlloc( *BufferSize );
        if (!*Buffer) {
            Rval = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        GetJobData(*Buffer,(PFAX_JOB_ENTRYW) *Buffer,JobQueue,&Offset);

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        Rval = GetExceptionCode();
    }

exit:
    LeaveCriticalSection( &CsQueue );
    LeaveCriticalSection( &CsJob );
    return Rval;

}

BOOL
UserOwnsJob(
    PJOB_QUEUE JobQueue
    )
{
    LPWSTR UserName = GetClientUserName();
    BOOL RetVal = FALSE;

    if (JobQueue && JobQueue->UserName && (wcscmp(UserName,JobQueue->UserName)==0) ) {
        RetVal = TRUE;
    }

    MemFree( UserName );

    return RetVal;
}



error_status_t
FAX_SetJob(
    IN handle_t FaxHandle,
    IN DWORD JobId,
    IN DWORD Command,
    IN const FAX_JOB_ENTRYW *JobEntry
    )
{
    PJOB_QUEUE JobQueue;
    DWORD Rval = 0;
    BOOL bAccess = TRUE;

    if (!FaxSvcAccessCheck( SEC_JOB_SET, FAX_JOB_MANAGE )) {
        bAccess = FALSE;
    }

    if (!JobEntry) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // handle abort case up here because we aquire must aquire additional critical sections to avoid deadlock
    //
    if (Command == JC_DELETE) {
        Rval = FAX_Abort(FaxHandle,JobId);
    } else {

        EnterCriticalSection( &CsQueue );

        JobQueue = FindJobQueueEntry( JobId );
        // don't include broadcast owner jobs, we don't want user to see these
        if (!JobQueue || (JobQueue->BroadcastJob && JobQueue->BroadcastOwner == NULL) ) {
            Rval = ERROR_INVALID_PARAMETER;
            goto exit;
        }

        if (!bAccess && !UserOwnsJob( JobQueue ) ) {
            Rval = ERROR_ACCESS_DENIED;
            goto exit;
        }

        switch (Command) {
            case JC_UNKNOWN:
                Rval = ERROR_INVALID_PARAMETER;
                goto exit;
                break;

/*
 * This case is handled above...
 *           case JC_DELETE:
 *               Rval = FAX_Abort(FaxHandle,JobId);
 *               break;
 */
            case JC_PAUSE:
                PauseJobQueueEntry( JobQueue );
                break;

            case JC_RESUME:
                ResumeJobQueueEntry( JobQueue );
                break;

            default:
                Rval = ERROR_INVALID_PARAMETER;
                goto exit;
                break;
        }

exit:
        LeaveCriticalSection( &CsQueue );
    }

    return Rval;
}


error_status_t
FAX_GetPageData(
    IN handle_t FaxHandle,
    IN DWORD JobId,
    OUT LPBYTE *Buffer,
    OUT LPDWORD BufferSize,
    OUT LPDWORD ImageWidth,
    OUT LPDWORD ImageHeight
    )
{
    PJOB_QUEUE JobQueue;
    LPBYTE TiffBuffer;

    if (!FaxSvcAccessCheck( SEC_JOB_SET, FAX_JOB_QUERY )) {
       return ERROR_ACCESS_DENIED;
   }

    if (!Buffer || !BufferSize || !ImageWidth || !ImageHeight) {
        return ERROR_INVALID_PARAMETER;
    }

    EnterCriticalSection( &CsQueue );

    JobQueue = FindJobQueueEntry( JobId );
    if (!JobQueue) {
        LeaveCriticalSection( &CsQueue );
        return ERROR_INVALID_PARAMETER;
    }

    if (JobQueue->JobType != JT_SEND) {
        LeaveCriticalSection( &CsQueue );
        return ERROR_INVALID_DATA;
    }

    TiffExtractFirstPage(
        JobQueue->FileName,
        &TiffBuffer,
        BufferSize,
        ImageWidth,
        ImageHeight
        );

    LeaveCriticalSection( &CsQueue );

    *Buffer = (LPBYTE) MemAlloc( *BufferSize );
    if (*Buffer == NULL) {
        VirtualFree( TiffBuffer, *BufferSize, MEM_RELEASE);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory( *Buffer, TiffBuffer, *BufferSize );

    VirtualFree( TiffBuffer, *BufferSize, MEM_RELEASE);

    return 0;
}


error_status_t
FAX_GetDeviceStatus(
    IN HANDLE FaxPortHandle,
    OUT LPBYTE *StatusBuffer,
    OUT LPDWORD BufferSize
    )

/*++

Routine Description:

    Obtains a status report for the specified FAX job.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    StatusBuffer    - receives FAX_DEVICE_STATUS pointer
    BufferSize      - Pointer to the size of this structure

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    DWORD rVal = 0;
    ULONG_PTR Offset;
    PFAX_DEVICE_STATUS FaxStatus;
    PLINE_INFO LineInfo = ((PHANDLE_ENTRY)FaxPortHandle)->LineInfo;


    if (!FaxSvcAccessCheck( SEC_PORT_QUERY, FAX_PORT_QUERY )) {
        return ERROR_ACCESS_DENIED;
    }

    if (!LineInfo) {
        return ERROR_INVALID_DATA;
    }

    __try {

        EnterCriticalSection( &CsJob );
        EnterCriticalSection( &CsLine );

        //
        // count the number of bytes required
        //

        *BufferSize  = sizeof(FAX_DEVICE_STATUS);
        *BufferSize += StringSize( LineInfo->DeviceName );
        *BufferSize += StringSize( LineInfo->Csid );

        if (LineInfo->JobEntry) {

            *BufferSize += StringSize( LineInfo->JobEntry->PhoneNumber );
            *BufferSize += StringSize( LineInfo->JobEntry->FaxStatus.CallerId );
            *BufferSize += StringSize( LineInfo->JobEntry->FaxStatus.RoutingInfo );
            *BufferSize += StringSize( LineInfo->JobEntry->FaxStatus.CSI );
            *BufferSize += StringSize( LineInfo->JobEntry->JobParam.SenderName );
            *BufferSize += StringSize( LineInfo->JobEntry->JobParam.RecipientName );
            *BufferSize += StringSize( LineInfo->JobEntry->UserName );

        }

        *StatusBuffer = (LPBYTE) MemAlloc( *BufferSize );
        if (*StatusBuffer == NULL) {
            rVal = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        FaxStatus = (PFAX_DEVICE_STATUS) *StatusBuffer;
        Offset = sizeof(FAX_DEVICE_STATUS);

        FaxStatus->SizeOfStruct = sizeof(FAX_DEVICE_STATUS);
        FaxStatus->Status       = LineInfo->State;
        FaxStatus->DeviceId     = LineInfo->PermanentLineID;
        FaxStatus->StatusString = NULL;

        StoreString(
            LineInfo->DeviceName,
            (PULONG_PTR)&FaxStatus->DeviceName,
            *StatusBuffer,
            &Offset
            );

        StoreString(
            LineInfo->Csid,
            (PULONG_PTR)&FaxStatus->Csid,
            *StatusBuffer,
            &Offset
            );

        if (LineInfo->JobEntry) {

            FaxStatus->JobType        = LineInfo->JobEntry->JobType;
            FaxStatus->TotalPages     = LineInfo->JobEntry->PageCount;
            FaxStatus->Size           = FaxStatus->JobType == JT_SEND ?
                                        LineInfo->JobEntry->FileSize :
                                        0; //meaningful for an outbound job only
            FaxStatus->DocumentName   = NULL;

            ZeroMemory( &FaxStatus->SubmittedTime, sizeof(FILETIME) );

            StoreString(
                LineInfo->JobEntry->JobParam.SenderName,
                (PULONG_PTR)&FaxStatus->SenderName,
                *StatusBuffer,
                &Offset
                );

            StoreString(
                LineInfo->JobEntry->JobParam.RecipientName,
                (PULONG_PTR)&FaxStatus->RecipientName,
                *StatusBuffer,
                &Offset
                );

            FaxStatus->CurrentPage = LineInfo->JobEntry->FaxStatus.PageCount;

			CopyMemory(&FaxStatus->StartTime, &LineInfo->JobEntry->StartTime, sizeof(FILETIME));

            StoreString(
                LineInfo->JobEntry->PhoneNumber,
                (PULONG_PTR)&FaxStatus->PhoneNumber,
                *StatusBuffer,
                &Offset
                );

            StoreString(
                LineInfo->JobEntry->FaxStatus.CallerId,
                (PULONG_PTR)&FaxStatus->CallerId,
                *StatusBuffer,
                &Offset
                );

            StoreString(
                LineInfo->JobEntry->FaxStatus.RoutingInfo,
                (PULONG_PTR)&FaxStatus->RoutingString,
                *StatusBuffer,
                &Offset
                );

            StoreString(
                LineInfo->JobEntry->FaxStatus.CSI,
                (PULONG_PTR)&FaxStatus->Tsid,
                *StatusBuffer,
                &Offset
                );

            StoreString(
                LineInfo->JobEntry->UserName,
                (PULONG_PTR)&FaxStatus->UserName,
                *StatusBuffer,
                &Offset
                );

        } else {

            FaxStatus->PhoneNumber    = NULL;
            FaxStatus->CallerId       = NULL;
            FaxStatus->RoutingString  = NULL;
            FaxStatus->CurrentPage    = 0;
            FaxStatus->JobType        = 0;
            FaxStatus->TotalPages     = 0;
            FaxStatus->Size           = 0;
            FaxStatus->DocumentName   = NULL;
            FaxStatus->SenderName     = NULL;
            FaxStatus->RecipientName  = NULL;
            FaxStatus->Tsid           = NULL;

            ZeroMemory( &FaxStatus->SubmittedTime, sizeof(FILETIME) );
            ZeroMemory( &FaxStatus->StartTime,     sizeof(FILETIME) );

        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // for some reason we crashed, so return the exception code
        //

        rVal = GetExceptionCode();

    }

exit:
    LeaveCriticalSection( &CsLine );
    LeaveCriticalSection( &CsJob );
    return rVal;
}


error_status_t
FAX_Abort(
   IN handle_t hBinding,
   IN DWORD JobId
   )

/*++

Routine Description:

    Abort the specified FAX job.  All outstanding FAX
    operations are terminated.

Arguments:

    hBinding        - FAX handle obtained from FaxConnectFaxServer.
    JobId           - FAX job Id

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
   PJOB_QUEUE JobQueueEntry;
   BOOL bAccess = TRUE;
   DWORD Rval;


   if (!FaxSvcAccessCheck( SEC_JOB_SET, FAX_JOB_MANAGE )) {
       bAccess = FALSE;
   }

   EnterCriticalSection( &CsJob) ;
   EnterCriticalSection( &CsQueue );

   JobQueueEntry = FindJobQueueEntry( JobId );
   if (!JobQueueEntry) {
      Rval = ERROR_INVALID_PARAMETER;
      goto exit;
   }

   // don't include broadcast owner jobs, we don't want user to see these
   if (!JobQueueEntry || (JobQueueEntry->BroadcastJob && JobQueueEntry->BroadcastOwner == NULL) ) {
       Rval = ERROR_INVALID_PARAMETER;
       goto exit;
   }

   if (!bAccess && !UserOwnsJob( JobQueueEntry ) ) {
       Rval = ERROR_ACCESS_DENIED;
       goto exit;
   }

   //
   // abort the job if it's in progress
   //
   if (((JobQueueEntry->JobStatus & JS_INPROGRESS) == JS_INPROGRESS)  &&
       ( JobQueueEntry->JobType == JT_SEND ||
         JobQueueEntry->JobType == JT_RECEIVE )) {

      __try {
          // signal the event we may be waiting on
          if (JobQueueEntry->JobEntry->hCallHandleEvent) {
              JobQueueEntry->JobEntry->LineInfo->HandoffCallHandle = 0;
              SetEvent(JobQueueEntry->JobEntry->hCallHandleEvent);
          }
          JobQueueEntry->JobEntry->Aborting = TRUE;
          JobQueueEntry->JobStatus = JS_DELETING;
          CreateFaxEvent(JobQueueEntry->JobEntry->LineInfo->PermanentLineID,
                         FEI_ABORTING,
                         JobId);

          DebugPrint(( TEXT("Attempting FaxDevAbort for job\n") ));
          JobQueueEntry->JobEntry->LineInfo->Provider->FaxDevAbortOperation(
              (HANDLE) JobQueueEntry->JobEntry->InstanceData );
      }
      __except (EXCEPTION_EXECUTE_HANDLER) {
          JobQueueEntry->JobEntry->ErrorCode = GetExceptionCode();
      }



   } else {
       RemoveJobQueueEntry( JobQueueEntry );
   }

   Rval = 0;

exit:
   LeaveCriticalSection( &CsQueue );
   LeaveCriticalSection( &CsJob );

   return Rval;

}


error_status_t
FAX_GetConfiguration(
    IN  handle_t FaxHandle,
    OUT LPBYTE *Buffer,
    IN  LPDWORD BufferSize
    )

/*++

Routine Description:

    Retrieves the FAX configuration from the FAX server.
    The SizeOfStruct in the FaxConfig argument MUST be
    set to a value == sizeof(FAX_CONFIGURATION).  If the BufferSize
    is not big enough, return an error and set BytesNeeded to the
    required size.

Arguments:

    FaxHandle   - FAX handle obtained from FaxConnectFaxServer.
    Buffer      - Pointer to a FAX_CONFIGURATION structure.
    BufferSize  - Size of Buffer
    BytesNeeded - Number of bytes needed

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t rVal = ERROR_SUCCESS;
    PFAX_CONFIGURATION FaxConfig;
    ULONG_PTR Offset;


    if (!FaxSvcAccessCheck( SEC_CONFIG_QUERY, FAX_CONFIG_QUERY )) {
        return ERROR_ACCESS_DENIED;
    }

    if (!Buffer || !BufferSize)
        return ERROR_INVALID_PARAMETER;

    //
    // count up the number of bytes needed
    //

    *BufferSize = sizeof(FAX_CONFIGURATION);
    Offset = sizeof(FAX_CONFIGURATION);

    if (InboundProfileName) {
        *BufferSize += StringSize( InboundProfileName );
    }

    if (ArchiveDirectory) {
        *BufferSize += StringSize( ArchiveDirectory );
    }

    *Buffer = MemAlloc( *BufferSize );
    if (*Buffer == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    FaxConfig = (PFAX_CONFIGURATION)*Buffer;

    FaxConfig->SizeOfStruct          = sizeof(FAX_CONFIGURATION);
    FaxConfig->Retries               = FaxSendRetries;
    FaxConfig->RetryDelay            = FaxSendRetryDelay;
    FaxConfig->DirtyDays             = FaxDirtyDays;
    FaxConfig->Branding              = FaxUseBranding;
    FaxConfig->UseDeviceTsid         = FaxUseDeviceTsid;
    FaxConfig->ServerCp              = ServerCp;
    FaxConfig->StartCheapTime.Hour   = StartCheapTime.Hour;
    FaxConfig->StartCheapTime.Minute = StartCheapTime.Minute;
    FaxConfig->StopCheapTime.Hour    = StopCheapTime.Hour;
    FaxConfig->StopCheapTime.Minute  = StopCheapTime.Minute;
    FaxConfig->ArchiveOutgoingFaxes  = ArchiveOutgoingFaxes;
    FaxConfig->PauseServerQueue      = QueuePaused;

    StoreString(
        ArchiveDirectory,
        (PULONG_PTR)&FaxConfig->ArchiveDirectory,
        *Buffer,
        &Offset
        );

    StoreString(
        InboundProfileName,
        (PULONG_PTR)&FaxConfig->InboundProfile,
        *Buffer,
        &Offset
        );

    return rVal;
}



error_status_t
FAX_SetConfiguration(
    IN handle_t FaxHandle,
    IN const FAX_CONFIGURATION *FaxConfig
    )

/*++

Routine Description:

    Changes the FAX configuration on the FAX server.
    The SizeOfStruct in the FaxConfig argument MUST be
    set to a value == sizeof(FAX_CONFIGURATION).

Arguments:

    FaxHandle   - FAX handle obtained from FaxConnectFaxServer.
    Buffer      - Pointer to a FAX_CONFIGURATION structure.
    BufferSize  - Size of Buffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t rVal = ERROR_SUCCESS;
    LPTSTR s;


    if (!FaxSvcAccessCheck( SEC_CONFIG_SET, FAX_CONFIG_SET )) {
        return ERROR_ACCESS_DENIED;
    }

    if (!FaxConfig || FaxConfig->SizeOfStruct != sizeof(FAX_CONFIGURATION)) {
        return ERROR_INVALID_PARAMETER;
    }

    if (FaxConfig->ArchiveOutgoingFaxes) {
       //
       // make sure they give us something valid for a path if they want us to archive
       //
       if (!FaxConfig->ArchiveDirectory) {
          return ERROR_INVALID_PARAMETER;
       }
    }

    __try {
        if (FaxConfig->InboundProfile) {
            if (!InboundProfileName ||
                wcscmp(FaxConfig->InboundProfile,InboundProfileName) != 0) {
                //
                // profile has changed, let's use the new one.
                //
                InboundProfileInfo = AddNewMapiProfile( FaxConfig->InboundProfile, TRUE, FALSE );
                if (!InboundProfileInfo) {
                    return ERROR_INVALID_DATA;
                }
            }
        }

        s = (LPTSTR) InterlockedExchangePointer(
            (LPVOID *)&InboundProfileName,
            FaxConfig->InboundProfile ? (PVOID)StringDup( FaxConfig->InboundProfile ) : NULL
            );
        if (s) {
            MemFree( s );
        }

        //
        // change the values that the server is currently using
        //

        InterlockedExchange( &FaxUseDeviceTsid,      FaxConfig->UseDeviceTsid );
        InterlockedExchange( &FaxUseBranding,        FaxConfig->Branding );
        InterlockedExchange( &ServerCp,              FaxConfig->ServerCp );
        InterlockedExchange( &ArchiveOutgoingFaxes,  FaxConfig->ArchiveOutgoingFaxes );
        InterlockedExchange( &FaxSendRetries,        FaxConfig->Retries );
        InterlockedExchange( &FaxDirtyDays,          FaxConfig->DirtyDays );
        InterlockedExchange( &FaxSendRetryDelay,     FaxConfig->RetryDelay );

        if ( (MAKELONG(StartCheapTime.Hour,StartCheapTime.Minute) != MAKELONG(FaxConfig->StartCheapTime.Hour,FaxConfig->StartCheapTime.Minute)) ||
             (MAKELONG(StopCheapTime.Hour,StopCheapTime.Minute)  != MAKELONG(FaxConfig->StopCheapTime.Hour, FaxConfig->StopCheapTime.Minute )) ) {
            InterlockedExchange( (LPLONG)&StartCheapTime, MAKELONG(FaxConfig->StartCheapTime.Hour,FaxConfig->StartCheapTime.Minute) );
            InterlockedExchange( (LPLONG)&StopCheapTime, MAKELONG(FaxConfig->StopCheapTime.Hour,FaxConfig->StopCheapTime.Minute) );
            SortJobQueue();
        }

        s = (LPTSTR) InterlockedExchangePointer(
            (LPVOID *)&ArchiveDirectory,
            FaxConfig->ArchiveDirectory ? (PVOID)StringDup( FaxConfig->ArchiveDirectory ) : NULL
            );
        if (s) {
            MemFree( s );
        }

        if (FaxConfig->PauseServerQueue) {
            PauseServerQueue();
        } else {
            ResumeServerQueue();
        }

        //
        // change the values in the registry
        //

        SetFaxGlobalsRegistry( (PFAX_CONFIGURATION) FaxConfig );

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          return GetExceptionCode();
    }

    return ERROR_SUCCESS;
}


DWORD
GetPortSize(
    PLINE_INFO LineInfo
    )
{
    DWORD Size;


    Size = sizeof(FAX_PORT_INFOW);
    Size += StringSize( LineInfo->DeviceName );
    Size += StringSize( LineInfo->Tsid );
    Size += StringSize( LineInfo->Csid );

    return Size;
}


VOID
GetPortData(
    LPBYTE PortBuffer,
    PFAX_PORT_INFOW PortInfo,
    PLINE_INFO LineInfo,
    PULONG_PTR Offset
    )
{
    PortInfo->SizeOfStruct = sizeof(FAX_PORT_INFOW);
    PortInfo->DeviceId   = LineInfo->PermanentLineID;
    PortInfo->State      = LineInfo->State;
    PortInfo->Flags      = LineInfo->Flags & 0x0fffffff;
    PortInfo->Rings      = LineInfo->RingsForAnswer;
    PortInfo->Priority   = LineInfo->Priority;

    StoreString( LineInfo->DeviceName,  (PULONG_PTR)&PortInfo->DeviceName,  PortBuffer, Offset );
    StoreString( LineInfo->Tsid,        (PULONG_PTR)&PortInfo->Tsid,        PortBuffer, Offset );
    StoreString( LineInfo->Csid,        (PULONG_PTR)&PortInfo->Csid,        PortBuffer, Offset );

    return;
}


error_status_t
FAX_EnumPorts(
    handle_t    FaxHandle,
    LPBYTE      *PortBuffer,
    LPDWORD     BufferSize,
    LPDWORD     PortsReturned
    )

/*++

Routine Description:

    Enumerates all of the FAX devices attached to the
    FAX server.  The port state information is returned
    for each device.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer
    PortBuffer      - Buffer to hold the port information
    BufferSize      - Total size of the port info buffer
    PortsReturned   - The number of ports in the buffer

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    DWORD rVal = 0;
    PLIST_ENTRY Next;
    PLINE_INFO LineInfo;
    DWORD i;
    ULONG_PTR Offset;
    DWORD FaxDevices;
    PFAX_PORT_INFOW PortInfo;


    if (!FaxSvcAccessCheck( SEC_PORT_QUERY, FAX_PORT_QUERY )) {
        return ERROR_ACCESS_DENIED;
    }

    __try {

        EnterCriticalSection( &CsLine );

        if (!PortsReturned) {
            rVal = ERROR_INVALID_PARAMETER;
            goto exit;
        }

        if (!TapiLinesListHead.Flink) {
            rVal = ERROR_INVALID_PARAMETER;
            goto exit;
        }

        Next = TapiLinesListHead.Flink;

        *PortsReturned = 0;
        *BufferSize = 0;
        FaxDevices = 0;

        //
        // count the number of bytes required
        //

        *BufferSize = 0;

        while ((ULONG_PTR)Next != (ULONG_PTR)&TapiLinesListHead) {

            LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
            Next = LineInfo->ListEntry.Flink;

            if (LineInfo->PermanentLineID && LineInfo->DeviceName) {
                *BufferSize += sizeof(PFAX_PORT_INFOW);
                *BufferSize += GetPortSize( LineInfo );
                FaxDevices += 1;
            }

        }

        *PortBuffer = (LPBYTE) MemAlloc( *BufferSize );
        if (*PortBuffer == NULL) {
            rVal = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        PortInfo = (PFAX_PORT_INFOW) *PortBuffer;
        Offset = FaxDevices * sizeof(FAX_PORT_INFOW);

        Next = TapiLinesListHead.Flink;
        i = 0;

        while ((ULONG_PTR)Next != (ULONG_PTR)&TapiLinesListHead) {

            LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
            Next = LineInfo->ListEntry.Flink;

            if (LineInfo->PermanentLineID && LineInfo->DeviceName) {

                GetPortData(
                    *PortBuffer,
                    &PortInfo[i],
                    LineInfo,
                    &Offset
                    );
            }
            i++;
        }

        //
        // set the device count
        //

        *PortsReturned = FaxDevices;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // for some reason we crashed, so return the exception code
        //

        rVal = GetExceptionCode();

    }

exit:
    LeaveCriticalSection( &CsLine );
    return rVal;
}


error_status_t
FAX_GetPort(
    HANDLE FaxPortHandle,
    LPBYTE *PortBuffer,
    LPDWORD BufferSize
    )

/*++

Routine Description:

    Returns port status information for a requested port.
    The device id passed in should be optained from FAXEnumPorts.

Arguments:

    FaxHandle   - FAX handle obtained from FaxConnectFaxServer.
    DeviceId    - TAPI device id
    PortBuffer  - Buffer to hold the port information
    BufferSize  - Total size of the port info buffer

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    PLINE_INFO LineInfo = ((PHANDLE_ENTRY)FaxPortHandle)->LineInfo;
    DWORD rVal = 0;
    ULONG_PTR Offset;


    if (!FaxSvcAccessCheck( SEC_PORT_QUERY, FAX_PORT_QUERY )) {
        return ERROR_ACCESS_DENIED;
    }

    if (!LineInfo) {
        return ERROR_INVALID_DATA;
    }

    EnterCriticalSection( &CsLine );

    __try {

        //
        // calculate the required buffer size
        //

        *BufferSize = GetPortSize( LineInfo );

        *PortBuffer = (LPBYTE) MemAlloc( *BufferSize );
        if (*PortBuffer == NULL) {
            rVal = ERROR_NOT_ENOUGH_MEMORY;
            _leave;
        }

        Offset = sizeof(FAX_PORT_INFOW);

        GetPortData(
            *PortBuffer,
            (PFAX_PORT_INFO)*PortBuffer,
            LineInfo,
            &Offset
            );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // for some reason we crashed, so return the exception code
        //

        rVal = GetExceptionCode();

    }

    LeaveCriticalSection( &CsLine );
    return rVal;
}


error_status_t
FAX_SetPort(
    HANDLE FaxPortHandle,
    const FAX_PORT_INFOW *PortInfo
    )

/*++

Routine Description:

    Changes the port capability mask.  This allows the caller to
    enable or disable sending & receiving on a port basis.

Arguments:

    FaxHandle   - FAX handle obtained from FaxConnectFaxServer.
    PortBuffer  - Buffer to hold the port information
    BufferSize  - Total size of the port info buffer

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    DWORD rVal = 0;
    DWORD flags = 0;
    PLINE_INFO LineInfo = ((PHANDLE_ENTRY)FaxPortHandle)->LineInfo;
    DWORD totalDevices;
    BOOL SendEnabled = FALSE;


    if (!FaxSvcAccessCheck( SEC_PORT_SET, FAX_PORT_SET )) {
        return ERROR_ACCESS_DENIED;
    }

    if (!LineInfo) {
        return ERROR_INVALID_DATA;
    }

    EnterCriticalSection( &CsJob );
    EnterCriticalSection( &CsLine );

    __try {

        if (PortInfo->SizeOfStruct != sizeof(FAX_PORT_INFOW)) {
            rVal = ERROR_INVALID_PARAMETER;
            _leave;
        }

        //
        // HACK: we allow the ring count to be set even if the line is in use so that systray will work.  we don't allow
        //  the user to change things like CSID/TSID or tapi related information since that cannot change until the call
        //  transaction is complete.
        //
        LineInfo->RingsForAnswer = PortInfo->Rings;

        if (LineInfo->JobEntry) {

            //
            // changing a line while there is an outstanding
            // job is not allowed
            //

            rVal = ERROR_DEVICE_IN_USE;
            _leave;
        }

        if (LineInfo->Flags & 0x80000000) {
            _leave;
        }

        flags = PortInfo->Flags & (FPF_RECEIVE | FPF_SEND | FPF_VIRTUAL);

        //
        // first change the real time data that the server is using
        //

        if ((!(LineInfo->Flags & FPF_RECEIVE)) && (flags & FPF_RECEIVE)) {
            if (!OpenTapiLine( LineInfo )) {
                DebugPrint(( TEXT("Could not get an open tapi line, FAX_SetPort() failed") ));
            } else {
                InterlockedIncrement( &ConnectionCount );
            }
        } else if ((LineInfo->Flags & FPF_RECEIVE) && (!(flags & FPF_RECEIVE))) {
            EnterCriticalSection( &CsLine );
            if (LineInfo->hLine) {
                lineClose( LineInfo->hLine );
                LineInfo->hLine = 0;
                InterlockedDecrement( &ConnectionCount );
            }
            LeaveCriticalSection( &CsLine );
        }

        if (!(LineInfo->Flags & FPF_SEND) && (flags & FPF_SEND)) {
            SendEnabled = TRUE;
        }

        LineInfo->Flags = (LineInfo->Flags & ~FPF_CLIENT_BITS) | flags;
        LineInfo->RingsForAnswer = PortInfo->Rings;
        //
        // make sure the user sets a reasonable priority
        //
        totalDevices = GetFaxDeviceCount();
        if (PortInfo->Priority <= totalDevices) {
            LineInfo->Priority = PortInfo->Priority ;
        }

        if (PortInfo->Tsid) {
            MemFree( LineInfo->Tsid );
            LineInfo->Tsid = StringDup( PortInfo->Tsid );
        }
        if (PortInfo->Csid) {
            MemFree( LineInfo->Csid );
            LineInfo->Csid = StringDup( PortInfo->Csid );
        }

        SortDevicePriorities();

        //
        // now change the registry so it sticks
        // (need to change all devices, since the priority may have changed)
        //
        CommitDeviceChanges();

        //
        // update virtual devices if they changed
        //
        UpdateVirtualDevices();

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // for some reason we crashed, so return the exception code
        //

        rVal = GetExceptionCode();

    }

    LeaveCriticalSection( &CsLine );
    LeaveCriticalSection( &CsJob );

    if (SendEnabled && JobQueueSemaphore) {
        ReleaseSemaphore( JobQueueSemaphore, 1, NULL );
    }

    return rVal;
}


typedef struct _ENUM_CONTEXT {
    DWORD               Function;
    DWORD               Size;
    ULONG_PTR            Offset;
    PLINE_INFO          LineInfo;
    PFAX_ROUTING_METHOD RoutingInfoMethod;
} ENUM_CONTEXT, *PENUM_CONTEXT;


BOOL CALLBACK
RoutingMethodEnumerator(
    PROUTING_METHOD RoutingMethod,
    PENUM_CONTEXT EnumContext
    )
{
    LPWSTR GuidString;

    //
    // we only access read-only static data in the LINE_INFO structure.
    // make sure that this access is protected if you access dynamic
    // data in the future.
    //

    if (EnumContext->Function == 1) {

        EnumContext->Size += sizeof(FAX_ROUTING_METHOD);

        StringFromIID( &RoutingMethod->Guid, &GuidString );

        EnumContext->Size += StringSize( GuidString );
        EnumContext->Size += StringSize( EnumContext->LineInfo->DeviceName );
        EnumContext->Size += StringSize( RoutingMethod->FunctionName );
        EnumContext->Size += StringSize( RoutingMethod->FriendlyName );
        EnumContext->Size += StringSize( RoutingMethod->RoutingExtension->ImageName );
        EnumContext->Size += StringSize( RoutingMethod->RoutingExtension->FriendlyName );

        CoTaskMemFree( GuidString );

        return TRUE;
    }

    if (EnumContext->Function == 2) {

        StringFromIID( &RoutingMethod->Guid, &GuidString );

        EnumContext->RoutingInfoMethod[EnumContext->Size].SizeOfStruct = sizeof(FAX_ROUTING_METHOD);
        EnumContext->RoutingInfoMethod[EnumContext->Size].DeviceId = EnumContext->LineInfo->PermanentLineID;

        __try {
            EnumContext->RoutingInfoMethod[EnumContext->Size].Enabled =
                RoutingMethod->RoutingExtension->FaxRouteDeviceEnable( GuidString, EnumContext->LineInfo->PermanentLineID, QUERY_STATUS );
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            EnumContext->RoutingInfoMethod[EnumContext->Size].Enabled = FALSE;
        }

        StoreString(
            EnumContext->LineInfo->DeviceName,
            (PULONG_PTR)&EnumContext->RoutingInfoMethod[EnumContext->Size].DeviceName,
            (LPBYTE)EnumContext->RoutingInfoMethod,
            &EnumContext->Offset
            );

        StoreString(
            GuidString,
            (PULONG_PTR)&EnumContext->RoutingInfoMethod[EnumContext->Size].Guid,
            (LPBYTE)EnumContext->RoutingInfoMethod,
            &EnumContext->Offset
            );

        StoreString(
            RoutingMethod->FriendlyName,
            (PULONG_PTR)&EnumContext->RoutingInfoMethod[EnumContext->Size].FriendlyName,
            (LPBYTE)EnumContext->RoutingInfoMethod,
            &EnumContext->Offset
            );

        StoreString(
            RoutingMethod->FunctionName,
            (PULONG_PTR)&EnumContext->RoutingInfoMethod[EnumContext->Size].FunctionName,
            (LPBYTE)EnumContext->RoutingInfoMethod,
            &EnumContext->Offset
            );

        StoreString(
            RoutingMethod->RoutingExtension->ImageName,
            (PULONG_PTR)&EnumContext->RoutingInfoMethod[EnumContext->Size].ExtensionImageName,
            (LPBYTE)EnumContext->RoutingInfoMethod,
            &EnumContext->Offset
            );

        StoreString(
            RoutingMethod->RoutingExtension->FriendlyName,
            (PULONG_PTR)&EnumContext->RoutingInfoMethod[EnumContext->Size].ExtensionFriendlyName,
            (LPBYTE)EnumContext->RoutingInfoMethod,
            &EnumContext->Offset
            );

        EnumContext->Size += 1;
        CoTaskMemFree( GuidString );

        return TRUE;
    }

    return FALSE;
}


error_status_t
FAX_EnumRoutingMethods(
    IN HANDLE FaxPortHandle,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize,
    OUT LPDWORD MethodsReturned
    )
{
    PLINE_INFO      LineInfo = ((PHANDLE_ENTRY)FaxPortHandle)->LineInfo;
    ENUM_CONTEXT    EnumContext;
    DWORD           CountMethods;


    //
    // verify that the client as access rights
    //

    if (!FaxSvcAccessCheck( SEC_PORT_QUERY, FAX_PORT_QUERY )) {
        return ERROR_ACCESS_DENIED;
    }

    if (!RoutingInfoBuffer || !RoutingInfoBufferSize || !MethodsReturned) {
        return ERROR_INVALID_PARAMETER;
    }

    if (!LineInfo) {
        return ERROR_INVALID_DATA;
    }

    //
    // note that the called routines are protected so we don't have any protection here
    //

    //
    // compute the required size of the buffer
    //

    EnumContext.Function = 1;
    EnumContext.Size = 0;
    EnumContext.Offset = 0;
    EnumContext.LineInfo = LineInfo;
    EnumContext.RoutingInfoMethod = NULL;

    CountMethods = EnumerateRoutingMethods( RoutingMethodEnumerator, &EnumContext );
    if (CountMethods == 0) {
        return ERROR_INVALID_FUNCTION;
    }

    //
    // allocate the buffer
    //

    *RoutingInfoBufferSize = EnumContext.Size;
    *RoutingInfoBuffer = (LPBYTE) MemAlloc( *RoutingInfoBufferSize );
    if (*RoutingInfoBuffer == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // fill the buffer with the data
    //

    EnumContext.Function = 2;
    EnumContext.Size = 0;
    EnumContext.Offset = sizeof(FAX_ROUTING_METHODW) * CountMethods;
    EnumContext.LineInfo = LineInfo;
    EnumContext.RoutingInfoMethod = (PFAX_ROUTING_METHOD) *RoutingInfoBuffer;

    if (!EnumerateRoutingMethods( RoutingMethodEnumerator, &EnumContext )) {
        MemFree( *RoutingInfoBuffer );
        *RoutingInfoBuffer = NULL;
        *RoutingInfoBufferSize = 0;
        return ERROR_INVALID_FUNCTION;
    }

    *MethodsReturned = CountMethods;


    return 0;
}


error_status_t
FAX_EnableRoutingMethod(
    IN HANDLE FaxPortHandle,
    IN LPCWSTR RoutingGuidString,
    IN BOOL Enabled
    )
{
    extern CRITICAL_SECTION CsRouting;
    error_status_t  ec = 0;
    PLINE_INFO      LineInfo = ((PHANDLE_ENTRY)FaxPortHandle)->LineInfo;
    PROUTING_METHOD RoutingMethod;


    //
    // verify that the client as access rights
    //

    if (!FaxSvcAccessCheck( SEC_PORT_SET, FAX_PORT_SET )) {
        return ERROR_ACCESS_DENIED;
    }

    if (!LineInfo) {
        return ERROR_INVALID_DATA;
    }

    if (!RoutingGuidString)
        return ERROR_INVALID_PARAMETER;

    EnterCriticalSection( &CsRouting );

    //
    // get the routing method
    //

    RoutingMethod = FindRoutingMethodByGuid( RoutingGuidString );
    if (!RoutingMethod) {
        LeaveCriticalSection( &CsRouting );
        return ERROR_INVALID_DATA;
    }

    //
    // enable/disable the routing method for this device
    //

    __try {
        RoutingMethod->RoutingExtension->FaxRouteDeviceEnable(
                                             (LPWSTR)RoutingGuidString,
                                             LineInfo->PermanentLineID,
                                             Enabled ? STATUS_ENABLE : STATUS_DISABLE);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ec = GetExceptionCode();
    }

    LeaveCriticalSection( &CsRouting );

    return ec;
}


typedef struct _ENUM_GLOBALCONTEXT {
    DWORD               Function;
    DWORD               Size;
    ULONG_PTR            Offset;
    PFAX_GLOBAL_ROUTING_INFO RoutingInfoMethod;
} ENUM_GLOBALCONTEXT, *PENUM_GLOBALCONTEXT;


BOOL CALLBACK
GlobalRoutingInfoMethodEnumerator(
    PROUTING_METHOD RoutingMethod,
    PENUM_GLOBALCONTEXT EnumContext
    )
{
    LPWSTR GuidString;


    if (EnumContext->Function == 1) {

        EnumContext->Size += sizeof(FAX_GLOBAL_ROUTING_INFO);

        StringFromIID( &RoutingMethod->Guid, &GuidString );

        EnumContext->Size += StringSize( GuidString );
        EnumContext->Size += StringSize( RoutingMethod->FunctionName );
        EnumContext->Size += StringSize( RoutingMethod->FriendlyName );
        EnumContext->Size += StringSize( RoutingMethod->RoutingExtension->ImageName );
        EnumContext->Size += StringSize( RoutingMethod->RoutingExtension->FriendlyName );

        CoTaskMemFree( GuidString );

        return TRUE;
    }

    if (EnumContext->Function == 2) {

        StringFromIID( &RoutingMethod->Guid, &GuidString );

        EnumContext->RoutingInfoMethod[EnumContext->Size].SizeOfStruct = sizeof(FAX_GLOBAL_ROUTING_INFO);

        EnumContext->RoutingInfoMethod[EnumContext->Size].Priority = RoutingMethod->Priority;


        StoreString(
            GuidString,
            (PULONG_PTR)&EnumContext->RoutingInfoMethod[EnumContext->Size].Guid,
            (LPBYTE)EnumContext->RoutingInfoMethod,
            &EnumContext->Offset
            );

        StoreString(
            RoutingMethod->FriendlyName,
            (PULONG_PTR)&EnumContext->RoutingInfoMethod[EnumContext->Size].FriendlyName,
            (LPBYTE)EnumContext->RoutingInfoMethod,
            &EnumContext->Offset
            );

        StoreString(
            RoutingMethod->FunctionName,
            (PULONG_PTR)&EnumContext->RoutingInfoMethod[EnumContext->Size].FunctionName,
            (LPBYTE)EnumContext->RoutingInfoMethod,
            &EnumContext->Offset
            );

        StoreString(
            RoutingMethod->RoutingExtension->ImageName,
            (PULONG_PTR)&EnumContext->RoutingInfoMethod[EnumContext->Size].ExtensionImageName,
            (LPBYTE)EnumContext->RoutingInfoMethod,
            &EnumContext->Offset
            );

        StoreString(
            RoutingMethod->RoutingExtension->FriendlyName,
            (PULONG_PTR)&EnumContext->RoutingInfoMethod[EnumContext->Size].ExtensionFriendlyName,
            (LPBYTE)EnumContext->RoutingInfoMethod,
            &EnumContext->Offset
            );

        EnumContext->Size += 1;
        CoTaskMemFree( GuidString );

        return TRUE;
    }

    return FALSE;
}



error_status_t
FAX_EnumGlobalRoutingInfo(
    IN handle_t FaxHandle ,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize,
    OUT LPDWORD MethodsReturned
    )
{

    DWORD           CountMethods;
    ENUM_GLOBALCONTEXT EnumContext;


    //
    // verify that the client as access rights
    //

    if (!FaxSvcAccessCheck( SEC_PORT_QUERY, FAX_CONFIG_QUERY )) {
        return ERROR_ACCESS_DENIED;
    }

    if (!RoutingInfoBuffer || !RoutingInfoBufferSize || !MethodsReturned)
        return ERROR_INVALID_PARAMETER;

    //
    // compute the required size of the buffer
    //

    EnumContext.Function = 1;
    EnumContext.Size = 0;
    EnumContext.Offset = 0;
    EnumContext.RoutingInfoMethod = NULL;

    CountMethods = EnumerateRoutingMethods( GlobalRoutingInfoMethodEnumerator, &EnumContext );
    if (CountMethods == 0) {
        return ERROR_INVALID_FUNCTION;
    }

    //
    // allocate the buffer
    //

    *RoutingInfoBufferSize = EnumContext.Size;
    *RoutingInfoBuffer = (LPBYTE) MemAlloc( *RoutingInfoBufferSize );
    if (*RoutingInfoBuffer == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // fill the buffer with the data
    //

    EnumContext.Function = 2;
    EnumContext.Size = 0;
    EnumContext.Offset = sizeof(FAX_GLOBAL_ROUTING_INFOW) * CountMethods;
    EnumContext.RoutingInfoMethod = (PFAX_GLOBAL_ROUTING_INFO) *RoutingInfoBuffer;

    if (!EnumerateRoutingMethods( GlobalRoutingInfoMethodEnumerator, &EnumContext )) {
        MemFree( *RoutingInfoBuffer );
        *RoutingInfoBuffer = NULL;
        *RoutingInfoBufferSize = 0;
        return ERROR_INVALID_FUNCTION;
    }

    *MethodsReturned = CountMethods;

    return 0;
}


error_status_t
FAX_SetGlobalRoutingInfo(
    IN HANDLE FaxHandle,
    IN const FAX_GLOBAL_ROUTING_INFOW *RoutingInfo
    )
{
    extern CRITICAL_SECTION CsRouting;
    error_status_t  ec = 0;

    PROUTING_METHOD RoutingMethod;

    //
    // verify that the client as access rights
    //

    if (!FaxSvcAccessCheck( SEC_CONFIG_SET, FAX_CONFIG_SET )) {
        return ERROR_ACCESS_DENIED;
    }

    if (!RoutingInfo) {
        return ERROR_INVALID_PARAMETER;
    }

    __try {
        if (RoutingInfo->SizeOfStruct != sizeof(FAX_GLOBAL_ROUTING_INFOW)) {
            return ERROR_INVALID_PARAMETER;
        }

        EnterCriticalSection( &CsRouting );

        //
        // get the routing method
        //

        RoutingMethod = FindRoutingMethodByGuid( RoutingInfo->Guid );
        if (!RoutingMethod) {
            LeaveCriticalSection( &CsRouting );
            return ERROR_INVALID_DATA;
        }

        //
        // change the priority
        //

        RoutingMethod->Priority = RoutingInfo->Priority;
        SortMethodPriorities();
        CommitMethodChanges();
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        ec = GetExceptionCode();

    }

    LeaveCriticalSection( &CsRouting );

    return ec;
}


error_status_t
FAX_GetRoutingInfo(
    IN HANDLE FaxPortHandle,
    IN LPCWSTR RoutingGuidString,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    )
{
    PLINE_INFO          LineInfo = ((PHANDLE_ENTRY)FaxPortHandle)->LineInfo;
    PROUTING_METHOD     RoutingMethod;
    LPBYTE              RoutingInfo = NULL;
    DWORD               RoutingInfoSize = 0;


    if (!FaxSvcAccessCheck( SEC_PORT_QUERY, FAX_PORT_QUERY )) {
        return ERROR_ACCESS_DENIED;
    }

    if (!RoutingGuidString || !RoutingInfoBuffer || !RoutingInfoBufferSize) {
        return ERROR_INVALID_PARAMETER;
    }

    if (!LineInfo) {
        return ERROR_INVALID_DATA;
    }

    RoutingMethod = FindRoutingMethodByGuid( RoutingGuidString );
    if (!RoutingMethod) {
        return ERROR_INVALID_DATA;
    }

    __try {

        //
        // first check to see how big the buffer needs to be
        //

        if (RoutingMethod->RoutingExtension->FaxRouteGetRoutingInfo(
                (LPWSTR) RoutingGuidString,
                LineInfo->PermanentLineID,
                NULL,
                &RoutingInfoSize ))
        {

            //
            // allocate a client buffer
            //

            RoutingInfo = (LPBYTE) MemAlloc( RoutingInfoSize );
            if (RoutingInfo == NULL) {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            //
            // get the routing data
            //

            if (RoutingMethod->RoutingExtension->FaxRouteGetRoutingInfo(
                    RoutingGuidString,
                    LineInfo->PermanentLineID,
                    RoutingInfo,
                    &RoutingInfoSize ))
            {

                //
                // move the data to the return buffer
                //

                *RoutingInfoBuffer = RoutingInfo;
                *RoutingInfoBufferSize = RoutingInfoSize;

                return ERROR_SUCCESS;

            } else {

                return ERROR_INVALID_DATA;

            }

        } else {

            return ERROR_INVALID_DATA;

        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // for some reason we crashed, so return the exception code
        //

        return GetExceptionCode();

    }

    return ERROR_INVALID_FUNCTION;
}


error_status_t
FAX_SetRoutingInfo(
    IN HANDLE FaxPortHandle,
    IN LPCWSTR RoutingGuidString,
    IN const BYTE *RoutingInfoBuffer,
    IN DWORD RoutingInfoBufferSize
    )
{
    PLINE_INFO          LineInfo = ((PHANDLE_ENTRY)FaxPortHandle)->LineInfo;
    PROUTING_METHOD     RoutingMethod;


    if (!FaxSvcAccessCheck( SEC_PORT_SET, FAX_PORT_SET )) {
        return ERROR_ACCESS_DENIED;
    }

    if (!RoutingGuidString || !RoutingInfoBuffer || !RoutingInfoBufferSize) {
        return ERROR_INVALID_PARAMETER;
    }

    if (!LineInfo) {
        return ERROR_INVALID_DATA;
    }

    RoutingMethod = FindRoutingMethodByGuid( RoutingGuidString );
    if (!RoutingMethod) {
        return ERROR_INVALID_DATA;
    }

    __try {

        if (RoutingMethod->RoutingExtension->FaxRouteSetRoutingInfo(
                RoutingGuidString,
                LineInfo->PermanentLineID,
                RoutingInfoBuffer,
                RoutingInfoBufferSize ))
        {

            return ERROR_SUCCESS;

        } else {

            return ERROR_INVALID_DATA;

        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // for some reason we crashed, so return the exception code
        //

        return GetExceptionCode();

    }

    return ERROR_INVALID_FUNCTION;
}


error_status_t
FAX_GetTapiLocations(
    IN  handle_t    FaxHandle,
    OUT LPBYTE      *Buffer,
    OUT LPDWORD     LocationSize
    )

/*++

Routine Description:

    Queries the TAPI location information for the server

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    NumLocations    - Returned number of locations
    LocationSize    - Size of the TapiLocations buffer
    BytesNeeded     - Size required
    TapiLocations   - Data buffer

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    LPLINETRANSLATECAPS LineTransCaps = NULL;
    LPLINELOCATIONENTRY LineLocation = NULL;
    LPTSTR s,p;
    DWORD i,l;
    LONG rVal = ERROR_SUCCESS;
    ULONG_PTR Offset;
    PFAX_TAPI_LOCATION_INFO TapiLocationInfo;


    if (!FaxSvcAccessCheck( SEC_CONFIG_QUERY, FAX_CONFIG_QUERY )) {
        return ERROR_ACCESS_DENIED;
    }

    if (!Buffer || !LocationSize)
        return ERROR_INVALID_PARAMETER;

    __try {

        //
        // get the toll lists
        //

        rVal = MyLineGetTransCaps( &LineTransCaps );
        if (rVal != ERROR_SUCCESS) {
            goto exit;
        }

        *LocationSize = sizeof(FAX_TAPI_LOCATION_INFO) + 32;

        if (LineTransCaps->dwLocationListSize && LineTransCaps->dwLocationListOffset) {
            LineLocation = (LPLINELOCATIONENTRY) ((LPBYTE)LineTransCaps + LineTransCaps->dwLocationListOffset);
            for (i=0; i<LineTransCaps->dwNumLocations; i++) {
                *LocationSize += sizeof(FAX_TAPI_LOCATIONS);
                if (LineLocation[i].dwTollPrefixListSize && LineLocation[i].dwTollPrefixListOffset) {
                    *LocationSize += LineLocation[i].dwLocationNameSize;
                    *LocationSize += LineLocation[i].dwTollPrefixListSize;
                }
            }
        }

        *Buffer = MemAlloc( *LocationSize );
        if (*Buffer == NULL) {
            rVal = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        TapiLocationInfo = (PFAX_TAPI_LOCATION_INFO) *Buffer;

        Offset = sizeof(FAX_TAPI_LOCATION_INFO);

        TapiLocationInfo->CurrentLocationID = LineTransCaps->dwCurrentLocationID;
        TapiLocationInfo->NumLocations = LineTransCaps->dwNumLocations;
        TapiLocationInfo->TapiLocations = (PFAX_TAPI_LOCATIONS) ((LPBYTE) TapiLocationInfo + Offset);

        Offset += (LineTransCaps->dwNumLocations * sizeof(FAX_TAPI_LOCATIONS));

        if (LineTransCaps->dwLocationListSize && LineTransCaps->dwLocationListOffset) {

            LineLocation = (LPLINELOCATIONENTRY) ((LPBYTE)LineTransCaps + LineTransCaps->dwLocationListOffset);

            for (i=0; i<LineTransCaps->dwNumLocations; i++) {

                TapiLocationInfo->TapiLocations[i].PermanentLocationID = LineLocation[i].dwPermanentLocationID;
                TapiLocationInfo->TapiLocations[i].CountryCode = LineLocation[i].dwCountryCode;
                TapiLocationInfo->TapiLocations[i].NumTollPrefixes = 0;

                if (LineLocation[i].dwCityCodeSize && LineLocation[i].dwCityCodeOffset) {
                    TapiLocationInfo->TapiLocations[i].AreaCode =
                        _ttoi( (LPTSTR) ((LPBYTE)LineTransCaps + LineLocation[i].dwCityCodeOffset) );
                } else {
                    TapiLocationInfo->TapiLocations[i].AreaCode = 0;
                }

                if (LineLocation[i].dwTollPrefixListSize && LineLocation[i].dwTollPrefixListOffset) {
                    s = (LPTSTR) ((LPBYTE)LineTransCaps + LineLocation[i].dwTollPrefixListOffset);
                    if (!*s) {
                        TapiLocationInfo->TapiLocations[i].TollPrefixes = NULL;
                    } else {
                        TapiLocationInfo->TapiLocations[i].TollPrefixes =
                            (LPTSTR) ((LPBYTE) TapiLocationInfo + Offset);
                        Offset += LineLocation[i].dwTollPrefixListSize;
                        s = (LPTSTR) ((LPBYTE)LineTransCaps + LineLocation[i].dwTollPrefixListOffset);
                        if (*s == TEXT(',')) {
                            s += 1;
                        }
                        l = _tcslen(s);
                        if (l && s[l-1] == TEXT(',')) {
                            s[l-1] = 0;
                        }
                        _tcscpy(
                            (LPTSTR)TapiLocationInfo->TapiLocations[i].TollPrefixes,
                            s
                            );
                        //
                        // count the number of toll prefixes
                        //
                        s = (LPTSTR)TapiLocationInfo->TapiLocations[i].TollPrefixes;
                        while (*s) {
                            p = _tcschr( s, TEXT(',') );
                            s = (p) ? p + 1 : s + _tcslen( s );
                            TapiLocationInfo->TapiLocations[i].NumTollPrefixes += 1;
                        }
                    }
                } else {
                    TapiLocationInfo->TapiLocations[i].TollPrefixes = NULL;
                }

                if (LineLocation[i].dwLocationNameSize && LineLocation[i].dwLocationNameOffset) {
                    TapiLocationInfo->TapiLocations[i].LocationName =
                        (LPTSTR) ((LPBYTE) TapiLocationInfo + Offset);
                    Offset += LineLocation[i].dwLocationNameSize;
                    _tcscpy(
                        (LPTSTR)TapiLocationInfo->TapiLocations[i].LocationName,
                        (LPTSTR) ((LPBYTE)LineTransCaps + LineLocation[i].dwLocationNameOffset)
                        );
                } else {
                    TapiLocationInfo->TapiLocations[i].LocationName = NULL;
                }
            }
        }

        for (i=0; i<TapiLocationInfo->NumLocations; i++) {
            if (TapiLocationInfo->TapiLocations[i].LocationName) {
                TapiLocationInfo->TapiLocations[i].LocationName =
                    (LPWSTR) ((ULONG_PTR)TapiLocationInfo->TapiLocations[i].LocationName - (ULONG_PTR)TapiLocationInfo);
            }
            if (TapiLocationInfo->TapiLocations[i].TollPrefixes) {
                TapiLocationInfo->TapiLocations[i].TollPrefixes =
                    (LPWSTR) ((ULONG_PTR)TapiLocationInfo->TapiLocations[i].TollPrefixes - (ULONG_PTR)TapiLocationInfo);
            }
        }

        TapiLocationInfo->TapiLocations = (PFAX_TAPI_LOCATIONS) ((LPBYTE)TapiLocationInfo->TapiLocations - (ULONG_PTR)TapiLocationInfo);

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // for some reason we crashed, so return the exception code
        //

        rVal = GetExceptionCode();

    }

exit:
    MemFree( LineTransCaps );
    return rVal;
}


error_status_t
FAX_SetTapiLocations(
    IN  handle_t    FaxHandle,
    IN  LPBYTE      Buffer,
    IN  DWORD       BufferSize
    )

/*++

Routine Description:

    Queries the TAPI location information for the server

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    NumLocations    - Number of locations in the TapiLocations buffer
    TapiLocations   - Data buffer

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    #define TOLL_MASK (LINETRANSLATERESULT_NOTINTOLLLIST|LINETRANSLATERESULT_INTOLLLIST)
    #define SetBit(_bitmap,_bit) (_bitmap[((_bit)>>5)]|=(1<<((_bit)-(((_bit)>>5)*32))))
    #define IsBit(_bitmap,_bit) (_bitmap[((_bit)>>5)]&(1<<((_bit)-(((_bit)>>5)*32))))

    PFAX_TAPI_LOCATION_INFO TapiLocationInfo = (PFAX_TAPI_LOCATION_INFO) Buffer;
    LPLINETRANSLATECAPS LineTransCaps = NULL;
    LPLINELOCATIONENTRY LineLocation = NULL;
    DWORD BitMap[32];
    DWORD BitMapCurr[32];
    LPTSTR s,p;
    DWORD i,j;
    LONG rVal = ERROR_SUCCESS;
    TCHAR Address[32];
    DWORD TollListOption;


    if (!FaxSvcAccessCheck( SEC_CONFIG_SET, FAX_CONFIG_SET )) {
        return ERROR_ACCESS_DENIED;
    }

    __try {

        if (!TapiLocationInfo) {
            rVal = ERROR_INVALID_PARAMETER;
            goto exit;
        }

        TapiLocationInfo->TapiLocations = (PFAX_TAPI_LOCATIONS) (Buffer+ (ULONG_PTR) TapiLocationInfo->TapiLocations);

        for (i=0; i<TapiLocationInfo->NumLocations; i++) {
            TapiLocationInfo->TapiLocations[i].LocationName = (LPWSTR) FixupString(Buffer,TapiLocationInfo->TapiLocations[i].LocationName);
            TapiLocationInfo->TapiLocations[i].TollPrefixes = (LPWSTR) FixupString(Buffer,TapiLocationInfo->TapiLocations[i].TollPrefixes);
        }

        //
        // get the toll lists
        //

        rVal = MyLineGetTransCaps( &LineTransCaps );
        if (rVal != ERROR_SUCCESS) {
            goto exit;
        }

        LineLocation = (LPLINELOCATIONENTRY) ((LPBYTE)LineTransCaps + LineTransCaps->dwLocationListOffset);
        for (i=0; i<TapiLocationInfo->NumLocations; i++) {

            //
            // match the location id for this location entry with
            // one that tapi knows about.
            //

            for (j=0; j<LineTransCaps->dwNumLocations; j++) {
                if (LineLocation[j].dwPermanentLocationID == TapiLocationInfo->TapiLocations[i].PermanentLocationID) {
                    break;
                }
            }
            if (j == LineTransCaps->dwNumLocations) {
                //
                // we got a bogus location id
                //
                continue;
            }

            //
            // set the bitmap for the toll prefixes that
            // tapi location is using.
            //

            ZeroMemory( BitMapCurr, sizeof(BitMapCurr) );

            if (LineLocation[j].dwTollPrefixListOffset) {
                s = (LPTSTR) ((LPBYTE)LineTransCaps + LineLocation[j].dwTollPrefixListOffset);
                if (*s == TEXT(',')) {
                    s += 1;
                }
                while( s && *s ) {
                    p = _tcschr( s, TEXT(',') );
                    if (p) {
                        *p = 0;
                    }
                    SetBit( BitMapCurr, min(_ttoi(s),999) );
                    if (p) {
                        s = p + 1;
                    } else {
                        s += _tcslen( s );
                    }
                }
            }

            //
            // set the bitmap for the toll prefixes
            // that this location is using.
            //

            s = (LPTSTR) TapiLocationInfo->TapiLocations[i].TollPrefixes;

            ZeroMemory( BitMap, sizeof(BitMap) );

            while( s && *s ) {
                p = _tcschr( s, TEXT(',') );
                if (p) {
                    *p = 0;
                }
                SetBit( BitMap, min(_ttoi(s),999) );
                if (p) {
                    s = p + 1;
                } else {
                    s += _tcslen( s );
                }
            }

            //
            // set the current location so that the toll prefix
            // changes affect the correct location.
            //

            rVal = lineSetCurrentLocation( hLineApp, TapiLocationInfo->TapiLocations[i].PermanentLocationID );
            if (rVal != ERROR_SUCCESS) {
                DebugPrint(( TEXT("lineSetCurrentLocation() failed, ec=%08x"), rVal ));
                continue;
            }

            //
            // change the toll list
            //

            for (j=200; j<999; j++) {

                TollListOption = 0;

                if (!IsBit( BitMapCurr, j )) {
                    if (IsBit(BitMap,j)) {
                        TollListOption = LINETOLLLISTOPTION_ADD;
                    }
                } else {
                    if (!IsBit(BitMap,j)) {
                        TollListOption = LINETOLLLISTOPTION_REMOVE;
                    }
                }

                if (TollListOption) {
                    wsprintf(
                        Address,
                        TEXT("+%d (%d) %03d-0000"),
                        TapiLocationInfo->TapiLocations[i].CountryCode,
                        TapiLocationInfo->TapiLocations[i].AreaCode,
                        j
                        );
                    rVal = lineSetTollList( hLineApp, 0, Address, TollListOption );
                    if (rVal != ERROR_SUCCESS) {
                        DebugPrint(( TEXT("lineSetTollList() failed, address=%s, ec=%08x"), Address, rVal ));
                        continue;
                    }
                }

            }

        }

        //
        // reset the current location
        //

        rVal = lineSetCurrentLocation( hLineApp, TapiLocationInfo->CurrentLocationID );
        if (rVal != ERROR_SUCCESS) {
            DebugPrint(( TEXT("lineSetCurrentLocation() failed, ec=%08x"), rVal ));
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // for some reason we crashed, so return the exception code
        //

        rVal = GetExceptionCode();

    }

exit:
    MemFree( LineTransCaps );
    return rVal;
}


error_status_t
FAX_GetMapiProfiles(
    IN  handle_t FaxHandle,
    OUT LPBYTE *MapiProfiles,
    OUT LPDWORD BufferSize
    )

/*++

Routine Description:

    Returns a list of MAPI profiles.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    MapiProfiles    - Multi-SZ string containing all MAPI profiles
    ProfileSize     - Size of the MapiProfiles array

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    error_status_t rVal;


    if (!FaxSvcAccessCheck( SEC_CONFIG_QUERY, FAX_CONFIG_QUERY )) {
        return ERROR_ACCESS_DENIED;
    }

    if (!MapiProfiles || !BufferSize)
        return ERROR_INVALID_PARAMETER;

    __try {

        rVal = (error_status_t) GetMapiProfiles( (LPWSTR*) MapiProfiles, BufferSize );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        rVal = GetExceptionCode();

    }

    return rVal;
}

error_status_t
FAX_GetLoggingCategories(
    IN handle_t hBinding,
    OUT LPBYTE *Buffer,
    OUT LPDWORD BufferSize,
    OUT LPDWORD NumberCategories
    )
{
    PFAX_LOG_CATEGORY Categories;
    REG_FAX_LOGGING FaxRegLogging;
    DWORD i;
    ULONG_PTR Offset;


    if (!FaxSvcAccessCheck( SEC_CONFIG_QUERY, FAX_CONFIG_QUERY )) {
        return ERROR_ACCESS_DENIED;
    }

    if (!Buffer || !BufferSize || !NumberCategories) {
        return ERROR_INVALID_PARAMETER;
    }


    GetLoggingCategoriesRegistry( &FaxRegLogging );

    *BufferSize = sizeof(FAX_LOG_CATEGORY) * FaxRegLogging.LoggingCount;
    Offset = *BufferSize;

    for (i=0; i<FaxRegLogging.LoggingCount; i++) {
        *BufferSize += StringSize( FaxRegLogging.Logging[i].CategoryName );
    }

    *Buffer = (LPBYTE) MemAlloc( *BufferSize );
    if (!*Buffer) {
        *BufferSize = 0;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    *NumberCategories = FaxRegLogging.LoggingCount;
    Categories = (PFAX_LOG_CATEGORY) *Buffer;

    for (i=0; i<FaxRegLogging.LoggingCount; i++) {

        StoreString(
            FaxRegLogging.Logging[i].CategoryName,
            (PULONG_PTR)&Categories[i].Name,
            *Buffer,
            &Offset
            );

        Categories[i].Category  = FaxRegLogging.Logging[i].Number;
        Categories[i].Level     = FaxRegLogging.Logging[i].Level;
    }

    return 0;
}


error_status_t
FAX_SetLoggingCategories(
    IN handle_t hBinding,
    IN const LPBYTE Buffer,
    IN DWORD BufferSize,
    IN DWORD NumberCategories
    )
{
    REG_FAX_LOGGING FaxRegLogging;
    DWORD i;


    if (!FaxSvcAccessCheck( SEC_CONFIG_QUERY, FAX_CONFIG_SET )) {
        return ERROR_ACCESS_DENIED;
    }

    if (!Buffer || !BufferSize)
        return ERROR_INVALID_PARAMETER;

    //
    // setup the data
    //
    FaxRegLogging.LoggingCount = NumberCategories;
    FaxRegLogging.Logging = (PREG_CATEGORY) Buffer;

    for (i=0; i<FaxRegLogging.LoggingCount; i++) {
        FaxRegLogging.Logging[i].CategoryName = (LPWSTR) FixupString(Buffer,FaxRegLogging.Logging[i].CategoryName);
    }

    //
    // first change the real time data that the server is using
    //
    RefreshEventLog( &FaxRegLogging );

    //
    // now change the registry so it sticks
    //
    return SetLoggingCategoriesRegistry( &FaxRegLogging ) ? 0 : GetLastError();
}


error_status_t
FAX_RegisterEventWindow(
   IN  handle_t hBinding,
   IN  ULONG64 hWnd,
   IN  UINT MessageStart,
   IN  LPCWSTR WindowStation,
   IN  LPCWSTR Desktop,
   OUT LPDWORD FaxSvcProcessId
   )
{
    PFAX_CLIENT_DATA ClientData,Current;
    PLIST_ENTRY Next;
    BOOL EntryExists = FALSE;
    RPC_STATUS ec;
    HANDLE hToken;
    HANDLE hThread;

    if (!hWnd || !FaxSvcProcessId)
        return ERROR_INVALID_PARAMETER;

    ClientData = (PFAX_CLIENT_DATA) MemAlloc( sizeof(FAX_CLIENT_DATA) );
    if (!ClientData) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ClientData->hBinding        = hBinding;
    ClientData->MachineName     = NULL;
    ClientData->ClientName      = NULL;
    ClientData->Context         = 0;
    ClientData->hWnd            = (HWND)hWnd;
    ClientData->MessageStart    = MessageStart;
    ClientData->StartedMsg      = FALSE;

    if (MessageStart != 0 ) {

        ec = RpcImpersonateClient(hBinding);
        if (ec != RPC_S_OK) {
            DebugPrint(( TEXT("RpcImpersonateClient failed, ec = %d\n"), ec ));
            goto e0;
        }

        //
        //  need to cross threads, so duplicate thread psuedohandle?
        //
        if (!DuplicateHandle(GetCurrentProcess(),
                            GetCurrentThread(),
                            GetCurrentProcess(),
                            &hThread,
                            THREAD_ALL_ACCESS,
                            FALSE,
                            0 )) {
            ec = GetLastError();
            DebugPrint(( TEXT("DuplicateHandle() failed, ec=%d"), ec ));
            goto e1;
        }

        //
        // different thread will be impersonating so I better open then duplicate the token
        //
        if (!OpenThreadToken(hThread,
                       TOKEN_QUERY | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
                       FALSE,
                       &hToken
                      ) ) {
            ec = GetLastError();
            DebugPrint((TEXT("Couldn't OpenThreadToken, ec = %d.\n"), ec ));
            goto e2;
        }

        if (!DuplicateToken( hToken,
                            SecurityImpersonation,
                            &ClientData->hClientToken )) {
          ec = GetLastError();
          DebugPrint((TEXT("Couldn't DuplicateToken, ec = %d.\n"), ec ));
          goto e3;
        }

        CloseHandle( hToken );
        CloseHandle( hThread );
        RpcRevertToSelf();

        ClientData->WindowStation = StringDup( WindowStation );
        ClientData->Desktop       = StringDup( Desktop );

    }

    __try {
        EnterCriticalSection( &CsClients );

        Next = ClientsListHead.Flink;
        if (Next) {
            while ((ULONG_PTR)Next != (ULONG_PTR)&ClientsListHead) {
                Current = CONTAINING_RECORD( Next, FAX_CLIENT_DATA, ListEntry );

                Next = Current->ListEntry.Flink;

                if (Current->hWnd == ClientData->hWnd 
                    && !lstrcmpi(Current->WindowStation,ClientData->WindowStation)
                    && !lstrcmpi(Current->Desktop,ClientData->Desktop) ) {
                    DebugPrint((TEXT("Already have window handle %d registered.\n"),Current->hWnd));
                    EntryExists = TRUE;
                    if (MessageStart == 0) {
                       //
                       // This means that we have already registered this client.
                       // To allow this client to logoff, we should close the impersonation token
                       // we have for their desktop
                       //
                       CloseHandle( Current->hClientToken );
                       RemoveEntryList( &Current->ListEntry );
                       MemFree( (LPBYTE) Current->WindowStation );
                       MemFree( (LPBYTE) Current->Desktop );
                       MemFree( Current );
                    }
                }
            }
        }

        if (!EntryExists) {
            InsertTailList( &ClientsListHead, &ClientData->ListEntry );
        } else {
            if ( ClientData ) {
               if ( ClientData->WindowStation ) MemFree ( (LPBYTE) ClientData->WindowStation ) ;
               if ( ClientData->Desktop )       MemFree ( (LPBYTE) ClientData->Desktop ) ;
               CloseHandle( ClientData->hClientToken );
               MemFree( ClientData );
            }

            LeaveCriticalSection( &CsClients );

            return 0;

        }

        LeaveCriticalSection( &CsClients );
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        DebugPrint((TEXT("FAX_RegisterEventWindow exception, ec = %d.\n"),GetExceptionCode() ));

        if ( ClientData->WindowStation ) MemFree ( (LPBYTE) ClientData->WindowStation ) ;

        if ( ClientData->Desktop )       MemFree ( (LPBYTE) ClientData->Desktop ) ;

        if ( ClientData ) {

            if ( ClientData->hClientToken) {
                CloseHandle( ClientData->hClientToken );
            }

            MemFree( ClientData );
        }

        LeaveCriticalSection( &CsClients );

        return GetExceptionCode();

    }

    CreateFaxEvent( 0, FEI_FAXSVC_STARTED, 0xffffffff );

    if (FaxSvcProcessId) {
        *FaxSvcProcessId = GetCurrentProcessId();
    }

    return 0;

e3:
    CloseHandle( hToken );
e2:
    CloseHandle( hThread );
e1:
    RpcRevertToSelf();
e0:
    MemFree(ClientData);
    return ec;
}


error_status_t
FAX_StartClientServer(
   IN handle_t   hBinding,
   IN LPCTSTR    MachineName,
   IN LPCTSTR    ClientName,
   IN ULONG64    Context
   )
{
    DWORD Error;
    PFAX_CLIENT_DATA ClientData,Current;
    PLIST_ENTRY Next;
    BOOL EntryExists = FALSE;


    ClientData = (PFAX_CLIENT_DATA) MemAlloc( sizeof(FAX_CLIENT_DATA) );
    if (!ClientData) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ClientData->hBinding        = hBinding;
    ClientData->MachineName     = StringDup( MachineName );
    ClientData->ClientName      = StringDup( ClientName );
    ClientData->Context         = Context;
    ClientData->hWnd            = NULL;
    ClientData->MessageStart    = 0;
    ClientData->StartedMsg      = FALSE;

    __try {
        EnterCriticalSection( &CsClients );

        //
        // make sure we don't register a client twice
        //
        Next = ClientsListHead.Flink;
        if (Next) {
            while ((ULONG_PTR)Next != (ULONG_PTR)&ClientsListHead) {
                Current = CONTAINING_RECORD( Next, FAX_CLIENT_DATA, ListEntry );
                Next = Current->ListEntry.Flink;

                //
                // make sure we're looking at io event-based clients
                //
                if (!Current->hWnd) {

                    if ((_wcsicmp(Current->ClientName ,ClientData->ClientName ) == 0) &&
                        ( ((!Current->MachineName) && (!ClientData->MachineName)) ||
                         (_wcsicmp(Current->MachineName,ClientData->MachineName) == 0) )) {
                        DebugPrint((TEXT("Already have client %s on %s registered.\n"),
                                   Current->ClientName  ? Current->ClientName  : L"NULL",
                                   Current->MachineName ? Current->MachineName : L"NULL" ));
                        EntryExists = TRUE;
                    }
                }
            }
        }

        if (!EntryExists) {
            Error = RpcpBindRpc( MachineName, ClientName, L"Security=identification static true", &ClientData->FaxHandle );
            if (Error) {
                MemFree( ClientData );
                LeaveCriticalSection( &CsClients );
                return Error;
            }
            InsertTailList( &ClientsListHead, &ClientData->ListEntry );
        }

        LeaveCriticalSection( &CsClients );
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        MemFree( ClientData);
        LeaveCriticalSection( &CsClients );
        return (GetExceptionCode() );
    }

    CreateFaxEvent( 0, FEI_FAXSVC_STARTED, 0xffffffff );

    return 0;
}

error_status_t
FAX_AccessCheck(
   IN handle_t  hBinding,
   IN DWORD     AccessMask,
   OUT LPDWORD  fAccess
   )
{
    if (!hBinding || !fAccess) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // we only have one security descriptor, so the first parameter is meaningless
    //
    *fAccess = FaxSvcAccessCheck( SEC_CONFIG_QUERY, AccessMask);

    return 0;
}

VOID
RPC_FAX_PORT_HANDLE_rundown(
    IN HANDLE FaxPortHandle
    )
{
    PHANDLE_ENTRY PortHandleEntry = (PHANDLE_ENTRY) FaxPortHandle;
    PLIST_ENTRY Next;
    PFAX_CLIENT_DATA ClientData;


    EnterCriticalSection( &CsLine );
    EnterCriticalSection( &CsClients );

    __try {

        DebugPrint(( TEXT("RPC_FAX_PORT_HANDLE_rundown() running for port handle 0x%08x"), FaxPortHandle ));

        Next = ClientsListHead.Flink;
        if (Next) {
            while ((ULONG_PTR)Next != (ULONG_PTR)&ClientsListHead) {
                ClientData = CONTAINING_RECORD( Next, FAX_CLIENT_DATA, ListEntry );
                Next = ClientData->ListEntry.Flink;
                if (ClientData->hBinding == PortHandleEntry->hBinding) {
                    RemoveEntryList( &ClientData->ListEntry );
                    MemFree(ClientData);
                }
            }
        }

        CloseFaxHandle( PortHandleEntry );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        DebugPrint(( TEXT("RPC_FAX_PORT_HANDLE_rundown() crashed, ec=0x%08x"), GetExceptionCode() ));

    }

    LeaveCriticalSection( &CsClients );
    LeaveCriticalSection( &CsLine );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\server\handle.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    handle.c

Abstract:

    This module contains the handle table mgmt routines.

Author:

    Wesley Witt (wesw) 12-Nov-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop


LIST_ENTRY          HandleTableListHead;
CRITICAL_SECTION    CsHandleTable;
extern LONG         ConnectionCount;


BOOL
InitializeHandleTable(
    PREG_FAX_SERVICE FaxReg
    )
{
    InitializeCriticalSection( &CsHandleTable );
    InitializeListHead( &HandleTableListHead );

    return TRUE;
}


PHANDLE_ENTRY
CreateNewHandle(
    handle_t    hBinding,
    DWORD       Type,
    PLINE_INFO  LineInfo,
    PJOB_ENTRY  JobEntry,
    DWORD       Flags
    )
{
    PHANDLE_ENTRY HandleEntry;


    HandleEntry = (PHANDLE_ENTRY) MemAlloc( sizeof(HANDLE_ENTRY) );
    if (!HandleEntry) {
        return NULL;
    }

    EnterCriticalSection( &CsHandleTable );

    InsertTailList( &HandleTableListHead, &HandleEntry->ListEntry );

    HandleEntry->hBinding = hBinding;
    HandleEntry->Type     = Type;
    HandleEntry->LineInfo = LineInfo;
    HandleEntry->JobEntry = JobEntry;
    HandleEntry->Flags    = Flags;

    LeaveCriticalSection( &CsHandleTable );

    return HandleEntry;
}


PHANDLE_ENTRY
CreateNewConnectionHandle(
    handle_t    hBinding
    )
{
    return CreateNewHandle(
        hBinding,
        FHT_CON,
        NULL,
        NULL,
        0
        );
}

PHANDLE_ENTRY
CreateNewPortHandle(
    handle_t    hBinding,
    PLINE_INFO  LineInfo,
    DWORD       Flags
    )
{
    return CreateNewHandle(
        hBinding,
        FHT_PORT,
        LineInfo,
        NULL,
        Flags
        );
}

VOID
RemoveClientEntries(
    handle_t hBinding
    )
{
    PFAX_CLIENT_DATA ClientData;
    PLIST_ENTRY Next;
    EnterCriticalSection( &CsClients );

    __try {

        DebugPrint(( TEXT("removing client connections\n") ));

        Next = ClientsListHead.Flink;
        if (Next) {
            while ((ULONG_PTR)Next != (ULONG_PTR)&ClientsListHead) {
                ClientData = CONTAINING_RECORD( Next, FAX_CLIENT_DATA, ListEntry );
                Next = ClientData->ListEntry.Flink;
                if (ClientData->hBinding == hBinding) {
                    RemoveEntryList( &ClientData->ListEntry );
                    MemFree(ClientData);
                }
            }
        }        

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        DebugPrint(( TEXT("RemoveClientEntries crashed, ec=0x%08x"), GetExceptionCode() ));

    }

    LeaveCriticalSection( &CsClients ); 

}


VOID
CloseFaxHandle(
    PHANDLE_ENTRY HandleEntry
    )
{
    //
    // note that the HandleEntry may be a context handle, 
    // which may be NULL in some cases.  Do nothing if 
    // this is the case
    //
    if (!HandleEntry) {
        return;
    }

    EnterCriticalSection( &CsHandleTable );
    RemoveEntryList( &HandleEntry->ListEntry );
    if (HandleEntry->Type == FHT_CON) {
//        RemoveClientEntries(HandleEntry->hBinding);
        InterlockedDecrement( &ConnectionCount );
    }
    MemFree( HandleEntry );
    LeaveCriticalSection( &CsHandleTable );
}


BOOL
IsPortOpenedForModify(
    PLINE_INFO LineInfo
    )
{
    PLIST_ENTRY Next;
    PHANDLE_ENTRY HandleEntry;


    EnterCriticalSection( &CsHandleTable );

    Next = HandleTableListHead.Flink;
    if (Next == NULL) {
        LeaveCriticalSection( &CsHandleTable );
        return FALSE;
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&HandleTableListHead) {

        HandleEntry = CONTAINING_RECORD( Next, HANDLE_ENTRY, ListEntry );
        if (HandleEntry->Type == FHT_PORT && (HandleEntry->Flags & PORT_OPEN_MODIFY) && HandleEntry->LineInfo == LineInfo) {
            LeaveCriticalSection( &CsHandleTable );
            return TRUE;
        }

        Next = HandleEntry->ListEntry.Flink;
    }

    LeaveCriticalSection( &CsHandleTable );

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\server\makefile.inc ===
!IF 0

Copyright (c) 1993  Microsoft Corporation

Module Name:

    makefile.inc

Abstract:

    This file is necessary to cause the message file to be compiled.

Author:

    Wesley Witt (wesw)

!ENDIF

faxmsg.h faxmsg.rc msg00001.bin: messages.mc
    copy messages.mc+..\registry\eventlog.mc faxmsg.mc
    mc -v faxmsg.mc

faxsvc.rc: faxmsg.rc msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\server\job.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    job.c

Abstract:

    This module implements the job creation and deletion.
    Also included in the file are the queue management
    functions and thread managegement.

Author:

    Wesley Witt (wesw) 24-Jan-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop


LIST_ENTRY          JobListHead;
CRITICAL_SECTION    CsJob;
HANDLE              StatusCompletionPortHandle;
DWORD               FaxSendRetries;
DWORD               FaxSendRetryDelay;
DWORD               FaxDirtyDays;
BOOL                FaxUseDeviceTsid;
BOOL                FaxUseBranding;
BOOL                ServerCp;
FAX_TIME            StartCheapTime;
FAX_TIME            StopCheapTime;
BOOL                ArchiveOutgoingFaxes;
LPTSTR              ArchiveDirectory;
DWORD               NextJobId;
BOOL                ForceReceive;
DWORD               TerminationDelay;

extern HANDLE       hServiceEndEvent;               // signal this after letting clients know fax service is ending


PJOB_ENTRY
FindJob(
    IN HANDLE FaxHandle
    )

/*++

Routine Description:

    This fuction locates a FAX job by matching
    the FAX handle value.

Arguments:

    FaxHandle       - FAX handle returned from startjob

Return Value:

    NULL for failure.
    Valid pointer to a JOB_ENTRY on success.

--*/

{
    PLIST_ENTRY Next;
    PJOB_ENTRY JobEntry;


    EnterCriticalSection( &CsJob );

    Next = JobListHead.Flink;
    if (Next == NULL) {
        LeaveCriticalSection( &CsJob );
        return NULL;
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&JobListHead) {

        JobEntry = CONTAINING_RECORD( Next, JOB_ENTRY, ListEntry );

        if (JobEntry->InstanceData == (ULONG_PTR) FaxHandle) {

            LeaveCriticalSection( &CsJob );
            return JobEntry;

        }

        Next = JobEntry->ListEntry.Flink;

    }

    LeaveCriticalSection( &CsJob );
    return NULL;
}


BOOL
FindJobByJob(
    IN PJOB_ENTRY JobEntryToFind
    )

/*++

Routine Description:

    This fuction locates a FAX job by matching
    the FAX handle value.

Arguments:

    FaxHandle       - FAX handle returned from startjob

Return Value:

    NULL for failure.
    Valid pointer to a JOB_ENTRY on success.

--*/

{
    PLIST_ENTRY Next;
    PJOB_ENTRY JobEntry;


    EnterCriticalSection( &CsJob );

    Next = JobListHead.Flink;
    if (Next == NULL) {
        LeaveCriticalSection( &CsJob );
        return FALSE;
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&JobListHead) {

        JobEntry = CONTAINING_RECORD( Next, JOB_ENTRY, ListEntry );

        if (JobEntry == JobEntryToFind) {

            LeaveCriticalSection( &CsJob );
            return TRUE;

        }

        Next = JobEntry->ListEntry.Flink;

    }

    LeaveCriticalSection( &CsJob );
    return FALSE;
}


BOOL
FaxSendCallback(
    IN HANDLE FaxHandle,
    IN HCALL CallHandle,
    IN DWORD Reserved1,
    IN DWORD Reserved2
    )

/*++

Routine Description:

    This fuction is called asychronously by a FAX device
    provider after a call is established.  The sole purpose
    of the callback is to communicate the call handle from the
    device provider to the FAX service.

Arguments:

    FaxHandle       - FAX handle returned from startjob
    CallHandle      - Call handle for newly initiated call
    Reserved1       - Always zero.
    Reserved2       - Always zero.

Return Value:

    TRUE for success, FAX operation continues.
    FALSE for failure, FAX operation is terminated.

--*/

{
    PJOB_ENTRY JobEntry;


    JobEntry = FindJob( FaxHandle );
    if (!JobEntry) {

        return FALSE;

    }

    JobEntry->CallHandle = CallHandle;

    return TRUE;

}


DWORD
FaxSendThread(
    PFAX_SEND_ITEM FaxSendItem
    )

/*++

Routine Description:

    This fuction runs asychronously as a separate thread to
    send a FAX document.  There is one send thread per outstanding
    FAX send operation.  The thread ends when the document is
    either successfuly sent or the operation is aborted.

Arguments:

    FaxSendItem     - pointer to a FAX send item packet that
                      describes the requested FAX send operation.

Return Value:

    Always zero.

--*/

{
    FAX_SEND FaxSend;
    PFAX_DEV_STATUS FaxStatus = NULL;
    DWORD StatusSize;
    BOOL Rslt;
    DWORD BytesNeeded;
    BOOL Retrying = FALSE;    
    BOOL Archived;
    TCHAR PageCountStr[64];
    TCHAR TimeStr[128];
    LPDWORD MsgPtr[6];
    TCHAR MsgStr[2048];
    DWORD MsgCount;
    FILETIME LocalTime;
    TCHAR  lpDate[50];
    int    lenDate;
    TCHAR  lpTime[50];
    int    lenTime;
    TCHAR  lpDateTime[104];

    TCHAR  lpCallerNumberPlusCompanyName[200];
    DWORD  lenCallerNumberPlusCompanyName;
    DWORD  delta;

    BOOL HandoffJob;

    TCHAR  lpBranding[400];
    DWORD  lenBranding;
    TCHAR  lpBrandingEnd[50];
    DWORD  lenBrandingEnd;
    DWORD  BrandingMaxLen = 115;
    INT    BrandingHeight = 22;  // in scan lines.
    DWORD  PageCount = 0;


    //
    // allocate memory for the status packet
    // this is a variable size packet based
    // on the size of the strings contained
    // withing the packet.
    //

    StatusSize = sizeof(FAX_DEV_STATUS) + FAXDEVREPORTSTATUS_SIZE;
    FaxStatus = (PFAX_DEV_STATUS) MemAlloc( StatusSize );

    if (!FaxStatus) {
        DebugPrint(( TEXT("FaxSendThread exiting because it could not allocate memory") ));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    SetThreadExecutionState(ES_SYSTEM_REQUIRED | ES_CONTINUOUS);

    FaxSend.SizeOfStruct    = sizeof(FAX_SEND);
    FaxSend.FileName        = FaxSendItem->FileName;
    FaxSend.CallerName      = FaxSendItem->SenderName;
    FaxSend.CallerNumber    = FaxSendItem->Tsid;
    FaxSend.ReceiverName    = FaxSendItem->RecipientName;
    FaxSend.ReceiverNumber  = FaxSendItem->PhoneNumber;
    FaxSend.CallHandle      = 0; // filled in later via TapiStatusThread, if appropriate
    FaxSend.Reserved[0]     = 0;
    FaxSend.Reserved[1]     = 0;
    FaxSend.Reserved[2]     = 0;


    FaxSendItem->JobQueue->JobStatus = JS_INPROGRESS;
    FaxSendItem->JobEntry->DocumentName = StringDup( FaxSendItem->DocumentName );
    HandoffJob = FaxSendItem->JobEntry->HandoffJob;


    //
    // Replace the original MMR file by one with the Branding on every page.
    //

    if (FaxUseBranding && FaxSendItem->JobQueue->SendRetries == 0) {

        if (FaxSend.CallerNumber == NULL) {
            DebugPrint(( TEXT("FaxSendThread() CallerNumber==0 NO BRANDING job\n") ));
            goto lPostBranding;
        }

        if (FaxSend.ReceiverNumber == NULL) {
            DebugPrint(( TEXT("FaxSendThread() ReceiverNumber==0 NO BRANDING job\n") ));
            goto lPostBranding;
        }


        if ( ! (lenDate = GetDateFormat( LOCALE_SYSTEM_DEFAULT,
                                         DATE_SHORTDATE,
                                         NULL,                // use system date
                                         NULL,                // use locale format
                                         lpDate,
                                         sizeof(lpDate)) ) ) {

            DebugPrint(( TEXT("FaxSendThread() GetDateFormat failed NO BRANDING job\n") ));
            goto lPostBranding;
        }

        if ( ! (lenTime = GetTimeFormat( LOCALE_SYSTEM_DEFAULT,
                                         TIME_NOSECONDS,
                                         NULL,                // use system time
                                         NULL,                // use locale format
                                         lpTime,
                                         sizeof(lpTime)) ) ) {

            DebugPrint(( TEXT("FaxSendThread() GetTimeFormat failed NO BRANDING job\n") ));
            goto lPostBranding;
        }

        _stprintf( lpDateTime, TEXT("%s %s"), lpDate, lpTime);

        //
        // Create  lpCallerNumberPlusCompanyName
        //

        if (FaxSendItem->SenderCompany) {
           _stprintf( lpCallerNumberPlusCompanyName, TEXT("%s %s"), FaxSend.CallerNumber, FaxSendItem->SenderCompany);
        }
        else {
           _stprintf( lpCallerNumberPlusCompanyName, TEXT("%s"), FaxSend.CallerNumber );
        }

        MsgPtr[0] = (LPDWORD) lpDateTime;
        MsgPtr[1] = (LPDWORD) lpCallerNumberPlusCompanyName;
        MsgPtr[2] = (LPDWORD) FaxSend.ReceiverNumber;
        MsgPtr[3] = NULL;

        if ( ! ( lenBranding = FormatMessage(
                            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            NULL,
                            MSG_BRANDING_FULL,
                            0,
                            lpBranding,
                            sizeof(lpBranding),
                            (va_list *) MsgPtr
                            ) ) ) {
            DebugPrint(( TEXT("FaxSendThread() MSG_BRANDING_OF failed NO BRANDING job\n") ));
            goto lPostBranding;
        }


        if ( ! ( lenBrandingEnd = FormatMessage(
                            FORMAT_MESSAGE_FROM_HMODULE,
                            NULL,
                            MSG_BRANDING_END,
                            0,
                            lpBrandingEnd,
                            sizeof(lpBrandingEnd),
                            NULL
                            ) ) ) {
            DebugPrint(( TEXT("FaxSendThread() MSG_BRANDING_OF failed NO BRANDING job\n") ));
            goto lPostBranding;
        }

        //
        // Make sure we can fit everything.
        //

        if (lenBranding + lenBrandingEnd + 8 <= BrandingMaxLen)  {
           goto lDoBranding;
        }

        //
        // Lets try to skip ReceiverNumber. The important part - is the CallerNumberPlusCompanyName.
        //

        MsgPtr[0] = (LPDWORD) lpDateTime;
        MsgPtr[1] = (LPDWORD) lpCallerNumberPlusCompanyName;
        MsgPtr[2] = NULL;



        if ( ! ( lenBranding = FormatMessage(
                            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            NULL,
                            MSG_BRANDING_SHORT,
                            0,
                            lpBranding,
                            sizeof(lpBranding),
                            (va_list *) MsgPtr
                            ) ) ) {
            DebugPrint(( TEXT("FaxSendThread() MSG_BRANDING_SHORT failed NO BRANDING job\n") ));
            goto lPostBranding;
        }


        if (lenBranding + lenBrandingEnd + 8 <= BrandingMaxLen)  {
           goto lDoBranding;
        }

        //
        // We need to truncate CallerNumberPlusCompanyName and re-format the message.
        //

        delta = lenBranding + lenBrandingEnd + 8 - BrandingMaxLen;

        lenCallerNumberPlusCompanyName = _tcslen (lpCallerNumberPlusCompanyName);
        if (lenCallerNumberPlusCompanyName <= delta) {
           DebugPrint(( TEXT("FaxSendThread() DELTA logical error NO BRANDING job\n") ));
           goto lPostBranding;
        }

        lpCallerNumberPlusCompanyName[ lenCallerNumberPlusCompanyName - delta] = TEXT('\0');

        MsgPtr[0] = (LPDWORD) lpDateTime;
        MsgPtr[1] = (LPDWORD) lpCallerNumberPlusCompanyName;
        MsgPtr[2] = NULL;

        if ( ! ( lenBranding = FormatMessage(
                            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            NULL,
                            MSG_BRANDING_SHORT,
                            0,
                            lpBranding,
                            sizeof(lpBranding),
                            (va_list *) MsgPtr
                            ) ) ) {
            DebugPrint(( TEXT("FaxSendThread() 2nd MSG_BRANDING_SHORT failed NO BRANDING job\n") ));
            goto lPostBranding;
        }


        if (lenBranding + lenBrandingEnd + 8 > BrandingMaxLen)  {
           DebugPrint(( TEXT("FaxSendThread() DELTA 2 logical error NO BRANDING job\n") ));
           goto lPostBranding;
        }


lDoBranding:

        __try {

            if (! MmrAddBranding( FaxSend.FileName, lpBranding, lpBrandingEnd, BrandingHeight) ) {
                DebugPrint(( TEXT("FaxSendThread() could not ADD Branding\n") ));
            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {

           DebugPrint(( TEXT("MmrAddBranding() failed: 0x%08x"), GetExceptionCode() ));

        }

    }

lPostBranding:

    if (!HandoffJob) {
        FaxSendItem->JobEntry->LineInfo->State = FPS_INITIALIZING;
    }
    else {
        //
        // We need to wait for TapiWorkerThread to get an existing CallHandle and put it in the lineinfo structure
        //
        WaitForSingleObject(FaxSendItem->JobEntry->hCallHandleEvent,INFINITE);

        if (!FaxSendItem->JobEntry->LineInfo->HandoffCallHandle) {
            //
            // somehow the call handoff failed, we can't send the fax
            //
            FaxSendItem->JobEntry->LineInfo->State = FPS_ABORTING;
            __try {

                Rslt = FaxSendItem->JobEntry->LineInfo->Provider->FaxDevAbortOperation(
                        (HANDLE) FaxSendItem->JobEntry->InstanceData);
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                FaxSendItem->JobEntry->ErrorCode = GetExceptionCode();
            }

        }
        else {
            //
            // Set the call handle, we're ready to send the fax
            //
            FaxSend.CallHandle = FaxSendItem->JobEntry->LineInfo->HandoffCallHandle;
            FaxSendItem->JobEntry->LineInfo->State = FPS_INITIALIZING;
        }
    }


    DebugPrint((TEXT("Started FAX send - File [%s] - Number [%s]"), FaxSend.FileName, FaxSendItem->JobEntry->PhoneNumber  ));

    __try {

        Rslt = FaxSendItem->JobEntry->LineInfo->Provider->FaxDevSend(
            (HANDLE) FaxSendItem->JobEntry->InstanceData,
            &FaxSend,
            FaxSendCallback
            );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        FaxSendItem->JobEntry->ErrorCode = GetExceptionCode();

    }

    __try {

        FaxStatus->SizeOfStruct = sizeof(FAX_DEV_STATUS);

        FaxSendItem->JobEntry->LineInfo->Provider->FaxDevReportStatus(
           (HANDLE) FaxSendItem->JobEntry->InstanceData,
            FaxStatus,
            StatusSize,
            &BytesNeeded
            );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        DebugPrint(( TEXT("FaxDevReportStatus() failed: 0x%08x"), GetExceptionCode() ));

    }

    DebugPrint(( TEXT("Send status: 0x%08x, string: 0x%08x File %s"), FaxStatus->StatusId, FaxStatus->StringId, FaxSend.FileName ));

    //
    // enter critical section to block out FaxStatusThread
    //

    EnterCriticalSection( &CsJob );

    GetSystemTimeAsFileTime( (FILETIME*) &FaxSendItem->JobEntry->EndTime );
    FaxSendItem->JobEntry->ElapsedTime = FaxSendItem->JobEntry->EndTime - FaxSendItem->JobEntry->StartTime;
    PageCount = FaxStatus->PageCount;

    if (!Rslt) {

        switch (FaxStatus->StatusId) {
            case FS_LINE_UNAVAILABLE:
                //
                // this is the glare condition
                //

                if (PerfCounters) {
                    InterlockedIncrement( (PLONG)&PerfCounters->OutboundFailedXmit );
                }

                Retrying = TRUE;
                break;

            case FS_NO_ANSWER:
            case FS_NO_DIAL_TONE:
            case FS_DISCONNECTED:
            case FS_BUSY:
            case FS_NOT_FAX_CALL:
            case FS_FATAL_ERROR:

                if (PerfCounters){
                    InterlockedIncrement( (PLONG)&PerfCounters->OutboundFailedConnections );
                }

                FaxSendItem->JobQueue->SendRetries++;

                if (FaxSendItem->JobQueue->SendRetries <= FaxSendRetries) {
                    Retrying = TRUE;
                } else {
                    //
                    // retries exceeded, mark job as expired
                    //

                    FILETIME CurrentFileTime;
                    LARGE_INTEGER NewTime;

                    FaxSendItem->JobQueue->JobStatus = JS_RETRIES_EXCEEDED ;

                    GetSystemTimeAsFileTime( &CurrentFileTime );
                    NewTime.LowPart  = CurrentFileTime.dwLowDateTime;
                    NewTime.HighPart = CurrentFileTime.dwHighDateTime;

                    FaxSendItem->JobQueue->ScheduleTime = NewTime.QuadPart;
                }

                FaxLogSend(
                    FaxSendItem,
                    Rslt,
                    FaxStatus,
                    Retrying
                    );

                break ;

            case FS_USER_ABORT:

                FaxLogSend(
                    FaxSendItem,
                    Rslt,
                    FaxStatus,
                    FALSE
                    );
                break ;

            default:
                if (PerfCounters){
                    InterlockedIncrement( (PLONG)&PerfCounters->OutboundFailedXmit );
                }
        }

        //
        // clean up the job queue entry
        //
        EnterCriticalSection ( &CsQueue );
        FaxSendItem->JobQueue->RefCount -= 1;

        //
        // don't retry a handoff job
        //
        if (
            FaxSendItem->JobQueue->JobEntry &&
            (FaxSendItem->JobQueue->JobEntry->HandoffJob ||
             FaxSendItem->JobQueue->JobEntry->Aborting)
            ) {
            RemoveJobQueueEntry( FaxSendItem->JobQueue );
            FaxSendItem->JobQueue = NULL;

        } else if (Retrying) {

            FaxSendItem->JobQueue->JobStatus = JS_RETRYING;
            FaxSendItem->JobQueue->JobEntry = NULL;

            RescheduleJobQueueEntry( FaxSendItem->JobQueue );
        }
        LeaveCriticalSection ( &CsQueue );


        //
        // send the negative delivery report
        //

        if (!Retrying &&
            ((FaxSendItem->JobEntry->DeliveryReportType == DRT_INBOX &&
              FaxSendItem->JobEntry->DeliveryReportProfile) ||
              (FaxSendItem->JobEntry->DeliveryReportType == DRT_EMAIL)))
        {
            SYSTEMTIME  SystemTime;

            FileTimeToLocalFileTime( (FILETIME*) &FaxSendItem->JobEntry->StartTime, &LocalTime );
            FileTimeToSystemTime( &LocalTime, &SystemTime );

            GetTimeFormat(
               LOCALE_SYSTEM_DEFAULT,
               LOCALE_NOUSEROVERRIDE,
               &SystemTime,
               NULL,
               TimeStr,
               sizeof(TimeStr)
               );

            MsgPtr[0] = (LPDWORD) FaxSendItem->SenderName;
            MsgPtr[1] = (LPDWORD) FaxSendItem->RecipientName;
            MsgPtr[2] = (LPDWORD) FaxSendItem->JobEntry->PhoneNumber;
            MsgPtr[3] = (LPDWORD) TimeStr;
            MsgPtr[4] = (LPDWORD) FaxSendItem->JobEntry->LineInfo->DeviceName;
            MsgPtr[5] = (LPDWORD) GetString( FaxStatus->StatusId );

            MsgCount = FormatMessage(
                FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                NULL,
                MSG_NDR,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
                MsgStr,
                sizeof(MsgStr),
                (va_list *) MsgPtr
                );

            if (FaxSendItem->JobEntry->DeliveryReportType == DRT_INBOX) {
                StoreMapiMessage(
                    FaxSendItem->JobEntry->DeliveryReportProfile,
                    GetString( IDS_SERVER_NAME ),
                    GetString( IDS_NDR_SUBJECT ),
                    MsgStr,
                    FaxSend.FileName,
                    GetString( IDS_NDR_FILENAME ),
                    IMPORTANCE_HIGH,
                    NULL,
                    &BytesNeeded
                    );
            } else if (FaxSendItem->JobEntry->DeliveryReportType == DRT_EMAIL && InboundProfileInfo) {
                MailMapiMessage(
                    InboundProfileInfo,
                    FaxSendItem->JobEntry->DeliveryReportAddress,
                    GetString( IDS_NDR_SUBJECT ),
                    MsgStr,
                    FaxSend.FileName,
                    GetString( IDS_NDR_FILENAME ),
                    IMPORTANCE_HIGH,
                    &BytesNeeded
                    );
            }
        }


    } else {

        //
        // add MS tiff tags to the sent fax
        // the tiff file is a temp file, so we add the tags to the source file
        //
        AddTiffTags(FaxSend.FileName,
                    FaxSendItem->JobEntry->StartTime,
                    FaxStatus,
                    &FaxSend
                    );

        //
        // if the send was successful, archive the file
        //

        Archived = ArchivePrintJob(
            FaxSend.FileName
            );

        FaxLogSend(
            FaxSendItem,
            Rslt,
            FaxStatus,
            TRUE
            );

        //
        // Increment counters for Performance Monitor
        //

        if (PerfCounters){
            SYSTEMTIME SystemTime ;
            DWORD Seconds ;
            HANDLE FileHandle ;
            DWORD Bytes = 0 ; /// Compute #bytes in the file FaxSend.FileName and stick it here!
            FileHandle = CreateFile(
                FaxSend.FileName,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );
            if(FileHandle != INVALID_HANDLE_VALUE){
                Bytes = GetFileSize( FileHandle, NULL );
                CloseHandle( FileHandle );
            }
            FileTimeToSystemTime(
                (FILETIME*)&FaxSendItem->JobEntry->ElapsedTime,
                &SystemTime
                );
            Seconds = (DWORD)( SystemTime.wSecond + 60 * ( SystemTime.wMinute + 60 * SystemTime.wHour ));
            InterlockedIncrement( (PLONG)&PerfCounters->OutboundFaxes );
            InterlockedIncrement( (PLONG)&PerfCounters->TotalFaxes );
            InterlockedExchangeAdd( (PLONG)&PerfCounters->OutboundPages, (LONG)FaxStatus->PageCount );
            InterlockedExchangeAdd( (PLONG)&PerfCounters->TotalPages, (LONG)FaxStatus->PageCount );

            EnterCriticalSection( &CsPerfCounters );

            OutboundSeconds += Seconds;
            TotalSeconds += Seconds;
            PerfCounters->OutboundMinutes = OutboundSeconds / 60 ;
            PerfCounters->TotalMinutes = TotalSeconds / 60 ;
            PerfCounters->OutboundBytes += Bytes;
            PerfCounters->TotalBytes += Bytes;

            LeaveCriticalSection( &CsPerfCounters );
        }

        //
        // send the positive delivery report
        //
        if ((FaxSendItem->JobEntry->DeliveryReportType == DRT_INBOX &&
             FaxSendItem->JobEntry->DeliveryReportProfile) ||
             (FaxSendItem->JobEntry->DeliveryReportType == DRT_EMAIL)) {
            SYSTEMTIME  SystemTime;

            _ltot( (LONG) PageCount, PageCountStr, 10 );

            FileTimeToLocalFileTime( (FILETIME*) &FaxSendItem->JobEntry->StartTime, &LocalTime );
            FileTimeToSystemTime( &LocalTime, &SystemTime );

            GetTimeFormat(
                LOCALE_SYSTEM_DEFAULT,
                LOCALE_NOUSEROVERRIDE,
                &SystemTime,
                NULL,
                TimeStr,
                sizeof(TimeStr)
                );

            MsgPtr[0] = (LPDWORD) FaxSendItem->SenderName;
            MsgPtr[1] = (LPDWORD) FaxSendItem->RecipientName;
            MsgPtr[2] = (LPDWORD) FaxSendItem->JobEntry->PhoneNumber;
            MsgPtr[3] = (LPDWORD) PageCountStr;
            MsgPtr[4] = (LPDWORD) TimeStr;
            MsgPtr[5] = (LPDWORD) FaxSendItem->JobEntry->LineInfo->DeviceName;
            MsgPtr[6] = NULL;

            MsgCount = FormatMessage(
                FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                NULL,
                MSG_DR,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
                MsgStr,
                sizeof(MsgStr),
                (va_list *) MsgPtr
                );

            if (FaxSendItem->JobEntry->DeliveryReportType == DRT_INBOX) {
                StoreMapiMessage(
                    FaxSendItem->JobEntry->DeliveryReportProfile,
                    GetString( IDS_SERVICE_NAME ),
                    GetString( IDS_DR_SUBJECT ),
                    MsgStr,
                    FaxSend.FileName,
                    GetString( IDS_DR_FILENAME ),
                    IMPORTANCE_NORMAL,
                    NULL,
                    &BytesNeeded
                    );
            } else if (FaxSendItem->JobEntry->DeliveryReportType == DRT_EMAIL && InboundProfileInfo) {
                MailMapiMessage(
                    InboundProfileInfo,
                    FaxSendItem->JobEntry->DeliveryReportAddress,
                    GetString( IDS_DR_SUBJECT ),
                    MsgStr,
                    FaxSend.FileName,
                    GetString( IDS_DR_FILENAME ),
                    IMPORTANCE_NORMAL,
                    &BytesNeeded
                    );
            }
        }

        //
        // remove this queue entry from the queue list
        //

        EnterCriticalSection ( &CsQueue );
        FaxSendItem->JobQueue->RefCount -= 1;
        RemoveJobQueueEntry( FaxSendItem->JobQueue );
        FaxSendItem->JobQueue = NULL;
        LeaveCriticalSection ( &CsQueue );
    }

    //
    // do any special work for a broadcast job
    //

    if (FaxSendItem->JobEntry->BroadcastJob) {
        DeleteFile( FaxSendItem->FileName );
    }

    FaxSendItem->JobEntry->ErrorCode = FaxStatus->StatusId;
    FaxSendItem->JobEntry->RefCount -= 1;
    FaxSendItem->JobEntry->LineInfo->State = FPS_AVAILABLE;

    if (FaxSendItem->JobEntry->RefCount == 0 && FaxSendItem->JobEntry->hEventEnd) {
        SetEvent( FaxSendItem->JobEntry->hEventEnd );
        EndJob( FaxSendItem->JobEntry );

        EnterCriticalSection ( &CsQueue );
        // JobQueue may already be NULL for an aborted job
        if (FaxSendItem->JobQueue) {
            if (!Retrying && (FaxSendItem->JobQueue->JobStatus != JS_RETRIES_EXCEEDED)) {
                FaxSendItem->JobQueue->JobStatus = JS_DELETING;
            }
            FaxSendItem->JobQueue->JobEntry = NULL;
        }
        LeaveCriticalSection ( &CsQueue );

    }

    LeaveCriticalSection( &CsJob );

    if (!Retrying && (!ArchiveOutgoingFaxes || Archived)) {
        DeleteFile( FaxSend.FileName );
    }

    MemFree( FaxSendItem->FileName );
    MemFree( FaxSendItem->PhoneNumber );
    MemFree( FaxSendItem->Tsid );
    MemFree( FaxSendItem->RecipientName );
    MemFree( FaxSendItem->SenderName );
    MemFree( FaxSendItem->SenderDept );
    MemFree( FaxSendItem->SenderCompany );
    MemFree( FaxSendItem->BillingCode );
    MemFree( FaxSendItem->DocumentName );
    MemFree( FaxSendItem );
    MemFree( FaxStatus );
    ReleaseSemaphore( JobQueueSemaphore, 1, NULL );

    SetThreadExecutionState(ES_CONTINUOUS);

    return 0;
}


PJOB_ENTRY
StartJob(
    DWORD DeviceId,
    DWORD JobType,
    LPWSTR FaxNumber
    )

/*++

Routine Description:

    This fuction calls the device provider's StartJob function.

Arguments:

    DeviceId      - Device Id to start the job on, or USE_SERVER_DEVICE.
    JobType       - type of job
    FaxNumber     - phone number for outbound jobs

Return Value:

    Pointer to a JOB_ENTRY, or NULL for failure.

--*/

{
    BOOL Failure = TRUE;
    PJOB_ENTRY JobEntry = NULL;
    PLINE_INFO LineInfo;


    JobEntry = (PJOB_ENTRY) MemAlloc( sizeof(JOB_ENTRY) );
    if (!JobEntry) {
        goto exit;
    }

    if (FaxNumber) {
        //
        // get a cannonical phone number
        //

        LPLINETRANSLATEOUTPUT LineTranslateOutput = NULL;

        if (MyLineTranslateAddress( FaxNumber, 0, &LineTranslateOutput ) == 0) {
            wcsncpy(
                JobEntry->PhoneNumber,
                (LPWSTR) ((LPBYTE)LineTranslateOutput + LineTranslateOutput->dwDisplayableStringOffset),
                SIZEOF_PHONENO
                );

            MemFree( LineTranslateOutput );
        } else {
            wcsncpy( JobEntry->PhoneNumber, FaxNumber, SIZEOF_PHONENO );
        }
    }

    //
    // assume send job without use_server_device is a handoff job
    //
    if (JobType == JT_SEND && DeviceId != USE_SERVER_DEVICE) {
        LineInfo = GetTapiLineForFaxOperation( DeviceId, JobType, JobEntry->PhoneNumber, TRUE );
    }
    else {
        LineInfo = GetTapiLineForFaxOperation( DeviceId, JobType, JobEntry->PhoneNumber, FALSE );
    }
    if (!LineInfo) {
        goto exit;
    }

    JobEntry->JobType = JT_UNKNOWN;
    JobEntry->CallHandle = 0;
    JobEntry->InstanceData = 0;
    JobEntry->ErrorCode = 0;
    JobEntry->LineInfo = LineInfo;
    JobEntry->SendIdx = -1;
    JobEntry->Released = FALSE;
    JobEntry->HandoffJob = (JobType == JT_SEND && DeviceId != USE_SERVER_DEVICE);
    JobEntry->hEventEnd = CreateEvent( NULL, FALSE, FALSE, NULL );
    JobEntry->hCallHandleEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    GetSystemTimeAsFileTime( (FILETIME*) &JobEntry->StartTime );

    __try {

        if ((!(LineInfo->Flags & FPF_VIRTUAL)) && (!LineInfo->hLine) && (!OpenTapiLine( LineInfo ))) {
            DebugPrint(( TEXT("Could not get an open tapi line, StartJob() failed") ));
            goto exit;
        }

        if (LineInfo->Provider->FaxDevStartJob(
                LineInfo->hLine,
                LineInfo->DeviceId,
                (PHANDLE) &JobEntry->InstanceData,
                StatusCompletionPortHandle,
                (ULONG_PTR) LineInfo ))
            {

                EnterCriticalSection( &CsJob );
                InsertTailList( &JobListHead, &JobEntry->ListEntry );
                LeaveCriticalSection( &CsJob );
                Failure = FALSE;

            } else {

                DebugPrint((TEXT("FaxDevStartJob failed")));

            }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    LineInfo->JobEntry = JobEntry;


exit:
    if (Failure) {
        if (LineInfo) {
            ReleaseTapiLine( LineInfo, LineInfo->JobEntry ? LineInfo->JobEntry->CallHandle : 0 );
        }
        if (JobEntry) {
            CloseHandle (JobEntry->hEventEnd);
            CloseHandle (JobEntry->hCallHandleEvent);
            MemFree( JobEntry );
        }
        JobEntry = NULL;
    }

    return JobEntry;
}


BOOL
EndJob(
    IN PJOB_ENTRY JobEntry
    )

/*++

Routine Description:

    This fuction calls the device provider's EndJob function.

Arguments:

    None.

Return Value:

    Error code.

--*/

{
    BOOL rVal;
    PJOB_INFO_1 JobInfo = NULL;

    if (!FindJobByJob( JobEntry )) {

        //
        // if we get here then it means we hit a race
        // condition where the FaxSendThread called EndJob
        // at the same time that a client app did.
        //

        return ERROR_SUCCESS;
    }

    if (JobEntry->RefCount) {

        HANDLE hEventEnd;
        DWORD Result;

        EnterCriticalSection( &CsJob );

        hEventEnd = JobEntry->hEventEnd;

        LeaveCriticalSection( &CsJob );

        while (TRUE) {

            Result = WaitForSingleObject( hEventEnd, 1000 );

            // if the wait timed out and FAX_SendDocument() has been called
            // (SendIdx != -1), then check for a job status change

            if (Result != WAIT_TIMEOUT) {
                //
                // if the event has been signaled or deleted, then return
                //
                break;
            }
        }

        return ERROR_SUCCESS;

    }

    EnterCriticalSection( &CsJob );

    if (!JobEntry->Released) {
        __try {

            rVal = JobEntry->LineInfo->Provider->FaxDevEndJob(
                (HANDLE) JobEntry->InstanceData
                );
            if (!rVal) {
                DebugPrint(( TEXT("FaxDevEndJob() failed") ));
            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            DebugPrint(( TEXT("FaxDevEndJob() crashed, ec=0x%08x"), GetExceptionCode() ));

        }
    }

    if (!JobEntry->Released) {
        if (JobEntry->LineInfo->State != FPS_NOT_FAX_CALL) {
            ReleaseTapiLine( JobEntry->LineInfo, JobEntry->CallHandle );
            JobEntry->CallHandle = 0;
        }
    }

    RemoveEntryList( &JobEntry->ListEntry );

    EnterCriticalSection( &CsLine );
    JobEntry->LineInfo->JobEntry = NULL;
    LeaveCriticalSection( &CsLine );

    CloseHandle( JobEntry->hEventEnd );
    CloseHandle( JobEntry->hCallHandleEvent );

    MemFree( (LPBYTE) JobEntry->JobParam.RecipientNumber );
    MemFree( (LPBYTE) JobEntry->JobParam.RecipientName );
    MemFree( (LPBYTE) JobEntry->JobParam.Tsid );
    MemFree( (LPBYTE) JobEntry->JobParam.SenderName );
    MemFree( (LPBYTE) JobEntry->JobParam.SenderCompany );
    MemFree( (LPBYTE) JobEntry->JobParam.SenderDept );
    MemFree( (LPBYTE) JobEntry->JobParam.BillingCode );

    MemFree( JobEntry->FaxStatus.CSI );
    MemFree( JobEntry->FaxStatus.CallerId );
    MemFree( JobEntry->FaxStatus.RoutingInfo );

    MemFree( JobEntry->DeliveryReportAddress );
    MemFree( JobEntry->DocumentName );
    MemFree( JobEntry->UserName );

    //
    // There could have been a request to change the port status while we were handling this job.
    // We allow the caller to modify a few of these requests to succeed, like the ring count for instance.
    // While we still have the job critical section, let's make sure that we commit any requested changes to the
    // registry.  This should be a fairly quick operation.
    //
    CommitDeviceChanges();

    LeaveCriticalSection( &CsJob );

    MemFree( JobEntry );

    return rVal;
}


BOOL
ReleaseJob(
    IN PJOB_ENTRY JobEntry
    )
{
    BOOL rVal;


    if (!FindJobByJob( JobEntry )) {
        return ERROR_SUCCESS;
    }

    EnterCriticalSection( &CsJob );

    __try {

        rVal = JobEntry->LineInfo->Provider->FaxDevEndJob(
            (HANDLE) JobEntry->InstanceData
            );
        if (!rVal) {
            DebugPrint(( TEXT("FaxDevEndJob() failed") ));
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        DebugPrint(( TEXT("FaxDevEndJob() crashed, ec=0x%08x"), GetExceptionCode() ));

    }

    if (JobEntry->LineInfo->State != FPS_NOT_FAX_CALL) {
        ReleaseTapiLine( JobEntry->LineInfo, JobEntry->CallHandle );
        JobEntry->CallHandle = 0;
    }

    JobEntry->Released = TRUE;

    LeaveCriticalSection( &CsJob );

    return TRUE;
}


DWORD
SendDocument(
    PJOB_ENTRY  JobEntry,
    LPTSTR      FileName,
    PFAX_JOB_PARAM JobParam,
    PJOB_QUEUE JobQueue
    )

/*++

Routine Description:

    This fuction queues a new item that requests a
    FAX document be sent.

Arguments:

    JobEntry    - Pointer to a JOB_ENTRY created by StartJob.
    FileName    - File name containing the TIFF data
    JobParam    - Pointer to FAX_JOB_PARAM struct
Return Value:

    Error code.

--*/

{
    PFAX_SEND_ITEM FaxSendItem;
    DWORD ThreadId;
    HANDLE hThread;


    if (JobEntry->RefCount) {

        //
        // only one operation per job
        //
        return ERROR_IO_PENDING;

    }

    FaxSendItem = (PFAX_SEND_ITEM) MemAlloc(sizeof(FAX_SEND_ITEM));
    if (!FaxSendItem) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    FaxSendItem->JobEntry = JobEntry;
    FaxSendItem->FileName = StringDup( FileName );
    FaxSendItem->PhoneNumber = StringDup( JobParam->RecipientNumber );
    if (JobParam->Tsid == NULL || JobParam->Tsid[0] == 0 || FaxUseDeviceTsid) {
        FaxSendItem->Tsid = StringDup( JobEntry->LineInfo->Tsid );
    }
    else {
        FaxSendItem->Tsid = StringDup( JobParam->Tsid );
    }
    FaxSendItem->RecipientName = StringDup( JobParam->RecipientName );
    FaxSendItem->SenderName = StringDup( JobParam->SenderName );
    FaxSendItem->SenderDept = StringDup( JobParam->SenderDept );
    FaxSendItem->SenderCompany = StringDup( JobParam->SenderCompany );
    FaxSendItem->BillingCode = StringDup( JobParam->BillingCode );
    FaxSendItem->DocumentName = StringDup( JobParam->DocumentName );

    FaxSendItem->JobQueue = JobQueue;
    JobQueue->RefCount += 1;
    JobEntry->RefCount += 1;

    hThread = CreateThread(
        NULL,
        1024*100,
        (LPTHREAD_START_ROUTINE) FaxSendThread,
        (LPVOID) FaxSendItem,
        0,
        &ThreadId
        );

    if (!hThread) {
        MemFree( FaxSendItem->FileName );
        MemFree( FaxSendItem->PhoneNumber );
        MemFree( FaxSendItem->Tsid );
        MemFree( FaxSendItem->RecipientName );
        MemFree( FaxSendItem->SenderName );
        MemFree( FaxSendItem->SenderDept );
        MemFree( FaxSendItem->SenderCompany );
        MemFree( FaxSendItem->BillingCode );
        MemFree( FaxSendItem );
        CloseHandle( hThread );
        return GetLastError();
    }

    CloseHandle( hThread );

    return ERROR_SUCCESS;
}


DWORD
FaxStatusThread(
    LPVOID UnUsed
    )

/*++

Routine Description:

    This fuction runs asychronously as a separate thread to
    query the status of all outstanding fax jobs.  The status
    is updated in the JOB_ENTRY structure and the print job
    is updated with a explanitory string.

Arguments:

    UnUsed          - UnUsed pointer

Return Value:

    Always zero.

--*/

{
    PJOB_ENTRY JobEntry;
    PFAX_DEV_STATUS FaxStatus;
    BOOL Rval;
    DWORD Bytes;
    ULONG_PTR CompletionKey;
    INT PageCount;


    while( TRUE ) {

        Rval = GetQueuedCompletionStatus(
            StatusCompletionPortHandle,
            &Bytes,
            &CompletionKey,
            (LPOVERLAPPED*) &FaxStatus,
            INFINITE
            );
        if (!Rval) {
            DebugPrint(( TEXT("GetQueuedCompletionStatus() failed, ec=0x%08x"), GetLastError() ));
            continue;
        }

        if (CompletionKey == EVENT_COMPLETION_KEY) {
            //
            // Let each registered client know about the fax event
            //
            PLIST_ENTRY Next;
            PFAX_CLIENT_DATA ClientData;
            PFAX_EVENT FaxEvent = (PFAX_EVENT) FaxStatus;

            EnterCriticalSection( &CsClients );

            Next = ClientsListHead.Flink;
            if (Next) {
                while ((ULONG_PTR)Next != (ULONG_PTR)&ClientsListHead) {
                    DWORD i;
                    BOOL fMessageSent = FALSE;

                    ClientData = CONTAINING_RECORD( Next, FAX_CLIENT_DATA, ListEntry );
                    DebugPrint(( TEXT("%d: Current : %08x\t Handle : %08x\t Next : %08x  Head: %08x :  \n"),
                               GetTickCount(),
                               (ULONG_PTR)Next,
                               ClientData->hWnd? (ULONG_PTR) ClientData->hWnd : (ULONG_PTR) ClientData->FaxClientHandle,
                               (ULONG_PTR)ClientData->ListEntry.Flink,
                               (ULONG_PTR)&ClientsListHead ));
                    Next = ClientData->ListEntry.Flink;

                    //
                    // only send the started message once to each client
                    //
                    if ((FaxEvent->EventId == FEI_FAXSVC_STARTED) && ClientData->StartedMsg) {
                        fMessageSent = TRUE;
                        goto next_client;
                    }
                    if (ClientData->hWnd) {

                        fMessageSent = PostClientMessage(ClientData,FaxEvent);
                        ClientData->StartedMsg = (FaxEvent->EventId == FEI_FAXSVC_STARTED) ?
                                                     TRUE :
                                                     ClientData->StartedMsg;
                        goto next_client;

                    }

                    if (!ClientData->FaxClientHandle) {
                        for(i = 0; i < 10; i++){
                            __try {

                                Rval = FAX_OpenConnection( ClientData->FaxHandle, ClientData->Context, &ClientData->FaxClientHandle );
                                if (Rval) {
                                    DebugPrint(( TEXT("FAX_OpenConnection() failed, ec=0x%08x"), Rval ));
                                    continue;
                                } else {
                                    break;
                                }
                            } __except (EXCEPTION_EXECUTE_HANDLER) {
                                DebugPrint(( TEXT("FAX_OpenConnection() crashed: 0x%08x"), GetExceptionCode() ));
                            }

                            Sleep( 1000 );

                        }
                    }

                    //
                    // if we don't have a handle at this point, forget it
                    //
                    if (!ClientData->FaxClientHandle) {
                        goto next_client;
                    }

                    for(i = 0; i < 10; i++){
                        __try {
                            Rval = FAX_ClientEventQueue( ClientData->FaxClientHandle, *FaxEvent );
                            if (Rval) {
                                DebugPrint(( TEXT("FAX_ClientEventQueue() failed, ec=0x%08x"), Rval ));
                                continue;
                            } else {
                                fMessageSent = TRUE;
                                ClientData->StartedMsg = (FaxEvent->EventId == FEI_FAXSVC_STARTED) ?
                                                 TRUE :
                                                 ClientData->StartedMsg;
                                break;
                            }
                        } __except (EXCEPTION_EXECUTE_HANDLER) {
                            DebugPrint(( TEXT("FAX_ClientEventQueue() crashed: 0x%08x"), GetExceptionCode() ));
                        }

                        Sleep( 1000 );

                    }

next_client:
                    if (!fMessageSent) {
                        //
                        // stale list entry, remove the client from our list.
                        //
                        if (ClientData->hWnd && ClientData->hClientToken) {
                           CloseHandle( ClientData->hClientToken );
                           MemFree( (LPBYTE) ClientData->WindowStation );
                           MemFree( (LPBYTE) ClientData->Desktop );
                        }
                        RemoveEntryList( &ClientData->ListEntry );
                        MemFree( ClientData );
                    }
                }
            }

            LeaveCriticalSection( &CsClients );

            //
            // signal event if fax service ended, so we can terminate the process
            //
            if (FaxEvent->EventId == FEI_FAXSVC_ENDED  && hServiceEndEvent != INVALID_HANDLE_VALUE) {
                SetEvent( hServiceEndEvent ) ;
            }

            MemFree( FaxEvent );
            FaxStatus = NULL;

            continue;
        }

        //
        // (else we're dealing with a status update from an FSP)
        //
        EnterCriticalSection( &CsJob );
        JobEntry = ((PLINE_INFO) CompletionKey)->JobEntry;
        if (!JobEntry) {
            //
            // this code path exposes a memory leak.
            // the completion packed is not freed if this
            // path is taken.  the problem is that the
            // memory cannot be freed if we don't have
            // access to the job structure.
            //
            LeaveCriticalSection( &CsJob );

            DebugPrint(( TEXT("FaxStatusThread - NULL JobEntry got StatusId 0x%08x"), FaxStatus->StatusId ));

            continue;
        }

        JobEntry->LineInfo->State = FaxStatus->StatusId;
        CreateFaxEvent( JobEntry->LineInfo->PermanentLineID, MapStatusIdToEventId( FaxStatus->StatusId ), JobEntry->JobId );

        PageCount = FaxStatus->PageCount ? FaxStatus->PageCount : -1;

        MemFree( JobEntry->FaxStatus.CSI );
        MemFree( JobEntry->FaxStatus.CallerId );
        MemFree( JobEntry->FaxStatus.RoutingInfo );

        JobEntry->FaxStatus.SizeOfStruct  = FaxStatus->SizeOfStruct;
        JobEntry->FaxStatus.StatusId      = FaxStatus->StatusId;
        JobEntry->FaxStatus.StringId      = FaxStatus->StringId;
        JobEntry->FaxStatus.PageCount     = FaxStatus->PageCount;
        JobEntry->FaxStatus.CSI           = StringDup( FaxStatus->CSI );
        JobEntry->FaxStatus.CallerId      = StringDup( FaxStatus->CallerId );
        JobEntry->FaxStatus.RoutingInfo   = StringDup( FaxStatus->RoutingInfo );
        JobEntry->FaxStatus.Reserved[0]   = 0;
        JobEntry->FaxStatus.Reserved[1]   = 0;
        JobEntry->FaxStatus.Reserved[2]   = 0;

        HeapFree( JobEntry->LineInfo->Provider->HeapHandle, 0, FaxStatus );

        LeaveCriticalSection( &CsJob );
    }

    return 0;
}


BOOL
InitializeJobManager(
    PREG_FAX_SERVICE FaxReg
    )

/*++

Routine Description:

    This fuction initializes the thread pool and
    FAX service queues.

Arguments:

    ThreadHint  - Number of threads to create in the initial pool.

Return Value:

    Thread return value.

--*/

{
    HANDLE hThread;
    DWORD ThreadId;
    DWORD i;


    InitializeListHead( &JobListHead );
    InitializeCriticalSection( &CsJob );

    InitializeListHead( &QueueListHead );
    InitializeCriticalSection( &CsQueue );

    SetRetryValues( FaxReg );

    if (GetFileAttributes( FaxReceiveDir ) == 0xffffffff) {
        MakeDirectory( FaxReceiveDir );
    }

    if (GetFileAttributes( FaxQueueDir ) == 0xffffffff) {
        MakeDirectory( FaxQueueDir );
    }

    StatusCompletionPortHandle = CreateIoCompletionPort(
        INVALID_HANDLE_VALUE,
        NULL,
        0,
        MAX_STATUS_THREADS
        );
    if (!StatusCompletionPortHandle) {
        DebugPrint(( TEXT("CreateIoCompletionPort() failed, ec=0x%08x"), GetLastError() ));
        return FALSE;
    }

    hThread = CreateThread(
        NULL,
        1024*100,
        (LPTHREAD_START_ROUTINE) JobQueueThread,
        NULL,
        0,
        &ThreadId
        );
    if (!hThread) {
        return FALSE;
    }

    CloseHandle( hThread );

    for (i=0; i<MAX_STATUS_THREADS; i++) {
        hThread = CreateThread(
            NULL,
            1024*100,
            (LPTHREAD_START_ROUTINE) FaxStatusThread,
            NULL,
            0,
            &ThreadId
            );


        if (!hThread) {
            return FALSE;
        }

        CloseHandle( hThread );
    }

    return TRUE;
}

VOID
SetRetryValues(
    PREG_FAX_SERVICE FaxReg
    )
{
    FaxSendRetries          = FaxReg->Retries;
    FaxSendRetryDelay       = (INT) FaxReg->RetryDelay;
    FaxDirtyDays            = FaxReg->DirtyDays;
    QueuePaused             = FaxReg->QueuePaused;
    NextJobId               = FaxReg->NextJobNumber;
    ForceReceive            = FaxReg->ForceReceive;
    TerminationDelay        = FaxReg->TerminationDelay == 0 ? 30 : FaxReg->TerminationDelay;
    FaxUseDeviceTsid        = FaxReg->UseDeviceTsid;
    FaxUseBranding          = FaxReg->Branding;
    ServerCp                = FaxReg->ServerCp;
    StartCheapTime          = FaxReg->StartCheapTime;
    StopCheapTime           = FaxReg->StopCheapTime;
    ArchiveOutgoingFaxes    = FaxReg->ArchiveOutgoingFaxes;
    ArchiveDirectory        = StringDup( FaxReg->ArchiveDirectory );
}

LPTSTR
ExtractFaxTag(
    LPTSTR      pTagKeyword,
    LPTSTR      pTaggedStr,
    INT        *pcch
    )

/*++

Routine Description:

    Find the value of for the specified tag in a tagged string.

Arguments:

    pTagKeyword - specifies the interested tag keyword
    pTaggedStr - points to the tagged string to be searched
    pcch - returns the length of the specified tag value (if found)

Return Value:

    Points to the value for the specified tag.
    NULL if the specified tag is not found

NOTE:

    Tagged strings have the following form:
        <tag>value<tag>value

    The format of tags is defined as:
        <$FAXTAG$ tag-name>

    There is exactly one space between the tag keyword and the tag name.
    Characters in a tag are case-sensitive.

--*/

{
    LPTSTR  pValue;

    if (pValue = _tcsstr(pTaggedStr, pTagKeyword)) {

        pValue += _tcslen(pTagKeyword);

        if (pTaggedStr = _tcsstr(pValue, FAXTAG_PREFIX))
            *pcch = (INT)(pTaggedStr - pValue);
        else
            *pcch = _tcslen(pValue);
    }

    return pValue;
}

BOOL
AddTiffTags(
    LPTSTR FaxFileName,
    DWORDLONG SendTime,
    PFAX_DEV_STATUS FaxStatus,
    PFAX_SEND FaxSend
    )

/*++

Routine Description:

    Add Ms Tiff Tags to a sent fax. Wraps TiffAddMsTags...

Arguments:

    FaxFileName - Name of the file to archive
    SendTime    - time the fax was sent
    FaxStatus   - job status
    FaxSend     - FAX_SEND structure for sent fax, includes CSID.

Return Value:

    TRUE    - The tags were added.
    FALSE   - The tags were not added.

--*/
{
    MS_TAG_INFO MsTagInfo;
    WCHAR       wcZero = L'\0';


    MsTagInfo.RecipName = NULL;
    if (FaxSend->ReceiverName && (FaxSend->ReceiverName[0] != wcZero) ) {
       MsTagInfo.RecipName     = FaxSend->ReceiverName;
    }

    MsTagInfo.RecipNumber   = NULL;
    if (FaxSend->ReceiverNumber && (FaxSend->ReceiverNumber[0] != wcZero) ) {
       MsTagInfo.RecipNumber   = FaxSend->ReceiverNumber;
    }

    MsTagInfo.SenderName    = NULL;
    if (FaxSend->CallerName && (FaxSend->CallerName[0] != wcZero) ) {
       MsTagInfo.SenderName    = FaxSend->CallerName;
    }

    MsTagInfo.Routing       = NULL;
    if (FaxStatus->RoutingInfo && (FaxStatus->RoutingInfo[0] != wcZero) ) {
       MsTagInfo.Routing       = FaxStatus->RoutingInfo;
    }

    MsTagInfo.CallerId      = NULL;
    if (FaxStatus->CallerId && (FaxStatus->CallerId[0] != wcZero) ) {
       MsTagInfo.CallerId      = FaxStatus->CallerId;
    }

    MsTagInfo.Csid          = NULL;
    if (FaxStatus->CSI && (FaxStatus->CSI[0] != wcZero) ) {
       MsTagInfo.Csid          = FaxStatus->CSI;
    }

    MsTagInfo.Tsid          = NULL;
    if (FaxSend->CallerNumber && (FaxSend->CallerNumber[0] != wcZero) ) {
       MsTagInfo.Tsid          = FaxSend->CallerNumber;
    }

    MsTagInfo.FaxTime       = SendTime;

    return TiffAddMsTags( FaxFileName, &MsTagInfo );

}


BOOL
ArchivePrintJob(
    LPTSTR FaxFileName
    )

/*++

Routine Description:

    Archive a tiff file that has been sent by copying the file to an archive
    directory.

Arguments:

    FaxFileName - Name of the file to archive

Return Value:

    TRUE    - The copy was made.
    FALSE   - The copy was not made.

--*/
{
    BOOL        rVal = FALSE;
    WCHAR       ArchiveFileName[MAX_PATH];

    if (!ArchiveOutgoingFaxes) {
        return FALSE;
    }


    //
    // be sure that the dir exists
    //

    MakeDirectory( ArchiveDirectory );

    //
    // get the file name
    //

    if (GenerateUniqueFileName( ArchiveDirectory, NULL, ArchiveFileName, sizeof(ArchiveFileName)/sizeof(WCHAR)) != 0) {
        rVal = TRUE;
    }

    if (rVal) {

        rVal = CopyFile( FaxFileName, ArchiveFileName, FALSE );

    }
    if (rVal) {
        FaxLog(
            FAXLOG_CATEGORY_OUTBOUND,
            FAXLOG_LEVEL_MAX,
            2,
            MSG_FAX_ARCHIVE_SUCCESS,
            FaxFileName,
            ArchiveFileName
            );
    } else {
        FaxLog(
            FAXLOG_CATEGORY_OUTBOUND,
            FAXLOG_LEVEL_MIN,
            3,
            MSG_FAX_ARCHIVE_FAILED,
            FaxFileName,
            ArchiveFileName,
            GetLastErrorText(GetLastError())
            );
    }

    return rVal;

}


PVOID
MyGetJob(
    HANDLE  hPrinter,
    DWORD   level,
    DWORD   jobId
    )

/*++

Routine Description:

    Wrapper function for spooler API GetJob

Arguments:

    hPrinter - Handle to the printer object
    level - Level of JOB_INFO structure interested
    jobId - Specifies the job ID

Return Value:

    Pointer to a JOB_INFO structure, NULL if there is an error

--*/

{
    PBYTE   pJobInfo = NULL;
    DWORD   cbNeeded;

    if (!GetJob(hPrinter, jobId, level, NULL, 0, &cbNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pJobInfo = MemAlloc(cbNeeded)) &&
        GetJob(hPrinter, jobId, level, pJobInfo, cbNeeded, &cbNeeded))
    {
        return pJobInfo;
    }

    MemFree(pJobInfo);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\server\faxsvc.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxsvc.h

Abstract:

    This is the main fax service header file.  All
    source modules should include this file ONLY.

Author:

    Wesley Witt (wesw) 16-Jan-1996


Revision History:

--*/

#ifndef _FAXSVC_
#define _FAXSVC_

#include <windows.h>
#include <shellapi.h>
#include <winspool.h>
#include <winsprlp.h>
#include <imagehlp.h>
#include <winsock2.h>
#include <userenv.h>
#include <setupapi.h>
#include <ole2.h>
#include <tapi.h>
#include <rpc.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <time.h>
#include <shlobj.h>

#include <winfax.h>
#include <faxroute.h>
#include <faxdev.h>

#include "winfaxp.h"
#include "faxrpc.h"
#include "faxcli.h"
#include "faxutil.h"
#include "messages.h"
#include "faxsvmsg.h"
#include "tifflib.h"
#include "faxreg.h"
#include "faxsvcrg.h"
#include "jobtag.h"
#include "faxperf.h"
#include "resource.h"
#include "rpcutil.h"
#include "faxmapi.h"
#include "faxevent.h"

#ifdef DBG
#define EnterCriticalSection(cs)   pEnterCriticalSection(cs,__LINE__,TEXT(__FILE__))
#define LeaveCriticalSection(cs)   pLeaveCriticalSection(cs,__LINE__,TEXT(__FILE__))
#define InitializeCriticalSection(cs)   pInitializeCriticalSection(cs,__LINE__,TEXT(__FILE__))

VOID pEnterCriticalSection(
    LPCRITICAL_SECTION cs,
    DWORD line,
    LPTSTR file
    );

VOID pLeaveCriticalSection(
    LPCRITICAL_SECTION cs,
    DWORD line,
    LPTSTR file
    );

VOID pInitializeCriticalSection(
    LPCRITICAL_SECTION cs,
    DWORD line,
    LPTSTR file
    );

typedef struct {
    LIST_ENTRY  ListEntry;
    ULONG_PTR    CritSecAddr;
    DWORD       ThreadId;
    DWORD       AquiredTime;
    DWORD       ReleasedTime;
} DBGCRITSEC, * PDBGCRITSEC;

#endif

#define FAX_SERVICE_NAME            TEXT("Fax")
#define FAX_DISPLAY_NAME            TEXT("Fax Service")
#define FAX_DRIVER_NAME             TEXT("Windows NT Fax Driver")
#define FAX_MONITOR_NAME            TEXT("Windows NT Fax Monitor")
#define FAX_IMAGE_NAME              TEXT("%systemroot%\\system32\\faxsvc.exe")
#define FAX_FILE_PREFIX             TEXT("Fax")
#define RAS_MODULE_NAME             TEXT("rastapi.dll")
#define FAX_EXTENSION_NAME          TEXT("Microsoft Routing Extension")

#define MAX_CLIENTS                 1
#define MIN_THREADS                 1
#define MAX_STATUS_THREADS          1
#define SIZEOF_PHONENO              64

#define MIN_RINGS_ALLOWED           2
#define MAX_MODEM_POPUPS            2
#define MAX_HANDLES                 1024

#define WM_SERVICE_INIT             (WM_USER+101)
#define MilliToNano(_ms)            ((LONGLONG)(_ms) * 1000 * 10)
#define SecToNano(_sec)             (DWORDLONG)((_sec) * 1000 * 1000 * 10)

#define FILLORDER_MSB2LSB           1

#define LINE_SIGNATURE              0x454e494c    // 'LINE'
#define ROUTING_SIGNATURE           'RI01'

#define TAPI_COMPLETION_KEY         0x80000001
#define EVENT_COMPLETION_KEY        0x80000002
#define FAXDEV_EVENT_KEY            0x80000003

#define FixupString(_b, _s) (_s) = ((_s) ? (LPTSTR) ((LPBYTE)(_b) + (ULONG_PTR)_s) : 0)

#define USE_SERVER_DEVICE           0xffffffff

//
// delivery report types
//

#define DRT_NONE                    0
#define DRT_EMAIL                   1
#define DRT_INBOX                   2

//
// mapi message importance flags
//

#define IMPORTANCE_LOW              0
#define IMPORTANCE_NORMAL           1
#define IMPORTANCE_HIGH             2

//
// private fax port state masks
// this bits must not conflict with FPS_?? in winfax.h or FS_??? in faxdev.h
//

#define FPS_SENDRETRY               0x2000f001
#define FPS_SENDFAILED              0x2000f002
#define FPS_BLANKSTR                0x2000f003
#define FPS_ROUTERETRY              0x2000f004

#define FPF_USED                    0x10000000
#define FPF_POWERED_OFF             0x20000000
#define FPF_RECEIVE_OK              0x40000000

#define FPF_CLIENT_BITS             (FPF_RECEIVE | FPF_SEND)


//
// security types
//

// Note - Georgeje
//
// The number of security descriptors has been reduced from six
// to one.  The tables in security.c have been left in place in
// case we need to add more security descriptos later.

#define SEC_CONFIG_SET              0
#define SEC_CONFIG_QUERY            0
#define SEC_PORT_SET                0
#define SEC_PORT_QUERY              0
#define SEC_JOB_SET                 0
#define SEC_JOB_QUERY               0




typedef struct _DEVICE_PROVIDER {
    LIST_ENTRY                      ListEntry;
    HMODULE                         hModule;
    TCHAR                           FriendlyName[MAX_PATH];
    TCHAR                           ImageName[MAX_PATH];
    TCHAR                           ProviderName[MAX_PATH];
    HANDLE                          HeapHandle;
    PFAXDEVINITIALIZE               FaxDevInitialize;
    PFAXDEVSTARTJOB                 FaxDevStartJob;
    PFAXDEVENDJOB                   FaxDevEndJob;
    PFAXDEVSEND                     FaxDevSend;
    PFAXDEVRECEIVE                  FaxDevReceive;
    PFAXDEVREPORTSTATUS             FaxDevReportStatus;
    PFAXDEVABORTOPERATION           FaxDevAbortOperation;
    PFAX_LINECALLBACK               FaxDevCallback;
    PFAXDEVVIRTUALDEVICECREATION    FaxDevVirtualDeviceCreation;
} DEVICE_PROVIDER, *PDEVICE_PROVIDER;

typedef struct _ROUTING_EXTENSION {
    LIST_ENTRY                          ListEntry;
    HMODULE                             hModule;
    TCHAR                               FriendlyName[MAX_PATH];
    TCHAR                               ImageName[MAX_PATH];
    TCHAR                               InternalName[MAX_PATH];
    HANDLE                              HeapHandle;
    BOOL                                MicrosoftExtension;
    PFAXROUTEINITIALIZE                 FaxRouteInitialize;
    PFAXROUTEGETROUTINGINFO             FaxRouteGetRoutingInfo;
    PFAXROUTESETROUTINGINFO             FaxRouteSetRoutingInfo;
    PFAXROUTEDEVICEENABLE               FaxRouteDeviceEnable;
    PFAXROUTEDEVICECHANGENOTIFICATION   FaxRouteDeviceChangeNotification;
    LIST_ENTRY                          RoutingMethods;
} ROUTING_EXTENSION, *PROUTING_EXTENSION;

typedef struct _ROUTING_METHOD {
    LIST_ENTRY                      ListEntry;
    LIST_ENTRY                      ListEntryMethod;
    GUID                            Guid;
    DWORD                           Priority;
    LPTSTR                          FunctionName;
    LPTSTR                          FriendlyName;
    LPTSTR                          InternalName;
    PFAXROUTEMETHOD                 FaxRouteMethod;
    PROUTING_EXTENSION              RoutingExtension;
} ROUTING_METHOD, *PROUTING_METHOD;

typedef BOOL (CALLBACK *PFAXROUTEMETHODENUM)(PROUTING_METHOD,LPVOID);

typedef struct _FAX_ROUTE_FILE {
    LIST_ENTRY      ListEntry;                      // linked list pointers
    LPWSTR          FileName;                       // file name on disk
    GUID            Guid;                           // routing method that created the file
} FAX_ROUTE_FILE, *PFAX_ROUTE_FILE;

typedef struct _LINE_INFO {
    LIST_ENTRY          ListEntry;                  // linked list pointers
    DWORD               Signature;                  // verification signature
    DWORD               DeviceId;                   // tapi device id
    DWORD               PermanentLineID;            // permanent tapi device id
    HLINE               hLine;                      // tapi line handle
    PDEVICE_PROVIDER    Provider;                   // fax service device provider
    struct _JOB_ENTRY   *JobEntry;                  // non-null if there is an outstanding job
    LPTSTR              DeviceName;                 // device name
    DWORD               State;                      // device state
    DWORD               Flags;                      // device use flags
    LPTSTR              Csid;                       // calling station's identifier
    LPTSTR              Tsid;                       // transmittion station's identifier
    DWORD               Priority;                   // sending priority
    BOOL                UnimodemDevice;             // true if this device is a modem
    HANDLE              InitEvent;                  // part of the init phase
    DWORD               RequestId;                  //
    DWORD               Result;                     //
    DWORD               RingsForAnswer;             //
    DWORD               RingCount;                  //
    LINEMESSAGE         LineMsgOffering;            //
    DWORD               ModemPopUps;                //
    DWORD               ModemPopupActive;           //
    BOOL                ModemInUse;                 // TRUE if the modem is in use by another TAPI app
    BOOL                OpenInProgress;             //
    DWORD               LineStates;                 //
    HCALL               RasCallHandle;              // used to track call when handed to RAS
    BOOL                NewCall;                    // A new call is coming in
    HCALL               HandoffCallHandle;          // call handle for a handoff job
} LINE_INFO, *PLINE_INFO;

typedef struct {
    HANDLE              hComm;
    CHAR                szDeviceName[1];
} DEVICEID, *PDEVICEID;

typedef struct _ROUTING_DATA_OVERRIDE {
    LIST_ENTRY          ListEntry;                  //
    LPBYTE              RoutingData;                //
    DWORD               RoutingDataSize;            //
    PROUTING_METHOD     RoutingMethod;              //
} ROUTING_DATA_OVERRIDE, *PROUTING_DATA_OVERRIDE;

typedef struct _ROUTE_FAILURE_INFO {
    WCHAR   GuidString[MAX_GUID_STRING_LEN];        // GUID of the rounting method that failed
    PVOID   FailureData;                            // pointer to the routing method's data
    DWORD   FailureSize;                            // routing method's data size in bytes
} ROUTE_FAILURE_INFO, *PROUTE_FAILURE_INFO;

typedef struct _JOB_ENTRY {
    LIST_ENTRY          ListEntry;                  //
    DWORD               JobId;                      // fax job id
    DWORD               JobType;                    // send or receive?
    PLINE_INFO          LineInfo;                   //
    HCALL               CallHandle;                 //
    DWORD               InstanceData;               //
    DWORD               ErrorCode;                  //
    DWORDLONG           StartTime;                  //
    DWORDLONG           EndTime;                    //
    DWORDLONG           ElapsedTime;                //
    DWORD               RefCount;                   //
    BOOL                Aborting;                   // is the job being aborted?
    INT                 SendIdx;                    //
    TCHAR               PhoneNumber[SIZEOF_PHONENO];// phone number for current send job
    HANDLE              hEventEnd;                  //
    FAX_DEV_STATUS      FaxStatus;                  // most recent FAX_DEV_STATUS for this job
    FAX_JOB_PARAM       JobParam;                   // job params for send jobs
    DWORD               DeliveryReportType;         //
    LPTSTR              DeliveryReportAddress;      //
    LPVOID              DeliveryReportProfile;      //
    BOOL                Released;                   //
    LPTSTR              DocumentName;               //
    LPTSTR              UserName;                   // user that submitted job (needed for FAX_GetDeviceStatus)
    DWORD               PageCount;                  // total pages for outbound job (needed for FAX_GetDeviceStatus)
    DWORD               FileSize;                   // total pages for outbound job (needed for FAX_GetDeviceStatus)    
    BOOL                BroadcastJob;               // is this a broadcast fax job?
    BOOL                HandoffJob;                 // is this a handoff job?
    HANDLE              hCallHandleEvent;           // event for signalling line handoff
} JOB_ENTRY, *PJOB_ENTRY;

typedef struct _JOB_QUEUE {
    LIST_ENTRY          ListEntry;                  // linked list pointers
    DWORDLONG           UniqueId;                   //
    DWORDLONG           ScheduleTime;               // schedule time in 64bit version
    DWORD               JobId;                      // fax job id
    DWORD               JobType;                    // job type, see JT defines
    BOOL                Paused;                     // should the job be started?    
    LPTSTR              DeliveryReportAddress;      //
    DWORD               DeliveryReportType;         //
    LPVOID              DeliveryReportProfile;      //
    LPTSTR              FileName;                   //
    LPTSTR              UserName;                   //
    FAX_JOB_PARAMW      JobParams;                  //
    PJOB_ENTRY          JobEntry;                   //
    LPTSTR              QueueFileName;              //
    DWORD               JobStatus;                  // job status, see JS defines
    DWORD               PageCount;                  // total pages
    DWORD               FileSize;                   // file size in bytes, up to 4Gb
    BOOL                BroadcastJob;               // is this a broadcast fax job?
    struct _JOB_QUEUE   *BroadcastOwner;            // queue entry for the owner job
    DWORDLONG           BroadcastOwnerUniqueId;     // used only for queue restore
    DWORD               BroadcastCount;             // owner's count of his children
    DWORD               RefCount;                   //
    DWORD               DeviceId;                   // device ID for a handoff job
    LIST_ENTRY          FaxRouteFiles;              // list of files to be routed
    DWORD               CountFaxRouteFiles;         // count of files to be routed
    CRITICAL_SECTION    CsFileList;                 // file list lock
    LIST_ENTRY          RoutingDataOverride;        //
    CRITICAL_SECTION    CsRoutingDataOverride;      //
    DWORD               SendRetries;                // number of times send attempt has been made
    PFAX_ROUTE          FaxRoute;
    DWORD               CountFailureInfo;           // number of ROUTE_FAILURE_INFO structs that follow
    ROUTE_FAILURE_INFO  RouteFailureInfo[1];        // array of ROUTE_FAILURE_INFO structs
} JOB_QUEUE, *PJOB_QUEUE;

typedef struct _JOB_QUEUE_FILE {
    DWORD               SizeOfStruct;               // size of this structure
    DWORDLONG           UniqueId;                   //
    DWORD               JobType;                    // job type, see JT defines
    LPTSTR              FileName;                   //
    LPTSTR              QueueFileName;              //
    LPTSTR              UserName;                   //
    LPTSTR              RecipientNumber;            // recipient fax number
    LPTSTR              RecipientName;              // recipient name
    LPTSTR              Tsid;                       // transmitter's id
    LPTSTR              SenderName;                 // sender name
    LPTSTR              SenderCompany;              // sender company
    LPTSTR              SenderDept;                 // sender department
    LPTSTR              BillingCode;                // billing code
    LPTSTR              DeliveryReportAddress;      //
    LPTSTR              DocumentName;               //
    DWORD               PageCount;                  // total pages
    DWORD               FileSize;                   // file size in bytes, up to 4Gb
    DWORD               DeliveryReportType;         //
    DWORD               ScheduleAction;             // when to schedule the fax, see JSA defines
    DWORDLONG           ScheduleTime;               // schedule time in 64bit version
    BOOL                BroadcastJob;               // is this a broadcast fax job?
    DWORDLONG           BroadcastOwner;             // unique id of the broadcast owner
    DWORD               SendRetries;                // number of times send attempt has been made
    DWORD               FaxRouteSize;
    PFAX_ROUTE          FaxRoute;
    DWORD               CountFaxRouteFiles;         // count of files to be routed
    DWORD               FaxRouteFileGuid;           // offset array of GUID's
    DWORD               FaxRouteFiles;              // offset to a multi-sz of filenames
    DWORD               CountFailureInfo;           // number of ROUTE_FAILURE_INFO structs that follow
    ROUTE_FAILURE_INFO  RouteFailureInfo[1];        // array of ROUTE_FAILURE_INFO structs
} JOB_QUEUE_FILE, *PJOB_QUEUE_FILE;

typedef struct _FAX_SEND_ITEM {
    PJOB_ENTRY          JobEntry;                   //
    LPTSTR              FileName;                   // The following items are copied from the FAX_JOB_PARAM struct
    LPTSTR              PhoneNumber;                // RecipientNumber
    LPTSTR              Tsid;                       // TSID
    LPTSTR              RecipientName;              //
    LPTSTR              SenderName;                 //
    LPTSTR              SenderCompany;              //
    LPTSTR              SenderDept;                 //
    LPTSTR              BillingCode;                //
    PJOB_QUEUE          JobQueue;                   //
    LPTSTR              DocumentName;               //
} FAX_SEND_ITEM, *PFAX_SEND_ITEM;

typedef struct _ROUTE_INFO {
    DWORD               Signature;                  // file signature
    DWORD               StringSize;                 // size of strings in bytes
    DWORD               FailureSize;                // size of failure data in bytes
    LPWSTR              TiffFileName;               // original tiff file name
    LPWSTR              ReceiverName;               // receiver's name
    LPWSTR              ReceiverNumber;             // receiver's fax number
    LPWSTR              DeviceName;                 // device name on which the fax was received
    LPWSTR              Csid;                       // calling station's identifier
    LPWSTR              Tsid;                       // transmitter's station identifier
    LPWSTR              CallerId;                   // caller id information
    LPWSTR              RoutingInfo;                // routing info: DID, T.30 subaddress, etc.
    DWORDLONG           ElapsedTime;                // elapsed time for fax receive
//  DWORD               RouteFailureCount;          // number of failure data blocks
//  ROUTE_FAILURE_INFO  RouteFailure[...];          // routing failure data blocks
} ROUTE_INFO, *PROUTE_INFO;

typedef struct _MESSAGEBOX_DATA {
    LPTSTR              Text;                       //
    LPDWORD             Response;                   //
    DWORD               Type;                       //
} MESSAGEBOX_DATA, *PMESSAGEBOX_DATA;

typedef struct _FAX_RECEIVE_ITEM {
    PJOB_ENTRY          JobEntry;                   //
    HCALL               hCall;                      //
    PLINE_INFO          LineInfo;                   //
    LPTSTR              FileName;                   //
} FAX_RECEIVE_ITEM, *PFAX_RECEIVE_ITEM;

typedef struct _FAX_CLIENT_DATA {
    LIST_ENTRY          ListEntry;                  //
    handle_t            hBinding;                   //
    handle_t            FaxHandle;                  //
    LPCTSTR             MachineName;                //
    LPCTSTR             ClientName;                 //
    ULONG64             Context;                    //
    HANDLE              FaxClientHandle;            //
    HWND                hWnd;                       //
    DWORD               MessageStart;               //
    BOOL                StartedMsg;                 // only send FEI_FAXSVC_STARTED once to each client
    HANDLE              hClientToken;               // to impersonate client's desktop
    LPCTSTR             WindowStation;
    LPCTSTR             Desktop;
} FAX_CLIENT_DATA, *PFAX_CLIENT_DATA;

typedef struct _MDM_DEVSPEC {
    DWORD Contents;     // Set to 1 (indicates containing key)
    DWORD KeyOffset;    // Offset to key from start of this struct.
                        // (not from start of LINEDEVCAPS ).
                        //  8 in our case.
    CHAR String[1];     // place containing null-terminated registry key.
} MDM_DEVSPEC, *PMDM_DEVSPEC;

//
// fax handle defines & structs
//

#define FHT_PORT    1
#define FHT_CON     2       // connection handle

typedef struct _HANDLE_ENTRY {
    LIST_ENTRY          ListEntry;                  // linked list pointers
    handle_t            hBinding;                   //
    DWORD               Type;                       // handle type, see FHT defines
    PLINE_INFO          LineInfo;                   // pointer to line information
    PJOB_ENTRY          JobEntry;                   // pointer to job entry
    DWORD               Flags;                      // open flags
} HANDLE_ENTRY, *PHANDLE_ENTRY;

typedef struct _DEVICE_SORT {
    DWORD       Priority;
    PLINE_INFO  LineInfo;
} DEVICE_SORT, *PDEVICE_SORT;

typedef struct _METHOD_SORT {
    DWORD               Priority;
    PROUTING_METHOD     RoutingMethod;
} METHOD_SORT, *PMETHOD_SORT;

typedef struct _QUEUE_SORT {
    DWORDLONG           ScheduleTime;    
    PJOB_QUEUE          QueueEntry;
} QUEUE_SORT, *PQUEUE_SORT;


//
// externs
//

extern BOOL                ServiceDebug;            //
extern HLINEAPP            hLineApp;                //
extern CRITICAL_SECTION    CsJob;                   // protects the job list
extern CRITICAL_SECTION    CsSession;               // protects the session list
extern DWORD               Installed;               //
extern DWORD               InstallType;             //
extern DWORD               InstalledPlatforms;      //
extern DWORD               ProductType;             //
extern PFAX_PERF_COUNTERS  PerfCounters;            //
extern LIST_ENTRY          JobListHead;             //
extern LPVOID              InboundProfileInfo;      //
extern CRITICAL_SECTION    CsLine;                  // critical section for accessing tapi lines
extern CRITICAL_SECTION    CsPerfCounters;          // critical section for performance monitor counters
extern DWORD               TotalSeconds;            // use to compute PerfCounters->TotalMinutes
extern DWORD               InboundSeconds;          //
extern DWORD               OutboundSeconds;         //
extern DWORD               TapiDevices;             // number of tapi devices
extern LIST_ENTRY          TapiLinesListHead;       // linked list of tapi lines
extern HANDLE              FaxStatusEvent;          //
extern LIST_ENTRY          ClientsListHead;         //
extern CRITICAL_SECTION    CsClients;               //
extern HANDLE              TapiCompletionPort;      //
extern HANDLE              StatusCompletionPortHandle; 
extern HANDLE              FaxSvcHeapHandle;        //
extern DWORD               CountRoutingMethods;     // total number of routing methods for ALL extensions
//extern LPTSTR              FaxReceiveDir;           //
//extern LPTSTR              FaxQueueDir;             //
extern LIST_ENTRY          QueueListHead;           //
extern CRITICAL_SECTION    CsQueue;                 //
extern DWORD               QueueCount;              //
extern BOOL                QueuePaused;             //
extern HANDLE              QueueTimer;              //
extern DWORD               NextJobId;               //
extern GUID                FaxSvcGuid;              //
extern LPTSTR              InboundProfileName;      //
extern DWORD               FaxSendRetries;          //
extern DWORD               FaxSendRetryDelay;       //
extern DWORD               FaxDirtyDays;            //
extern BOOL                FaxUseDeviceTsid;        //
extern BOOL                FaxUseBranding;          //
extern BOOL                ServerCp;                //
extern FAX_TIME            StartCheapTime;          //
extern FAX_TIME            StopCheapTime;           //
extern BOOL                ArchiveOutgoingFaxes;    //
extern LPTSTR              ArchiveDirectory;        //
extern BOOL                ForceReceive;            //
extern DWORD               TerminationDelay;        //
extern WCHAR               FaxDir[MAX_PATH];        //
extern WCHAR               FaxQueueDir[MAX_PATH];   //
extern WCHAR               FaxReceiveDir[MAX_PATH]; //
extern HANDLE              JobQueueSemaphore;       //





//
// prototypes
//
BOOL
CommitQueueEntry(
    PJOB_QUEUE JobQueue,
    LPTSTR QueueFileName,
    DWORDLONG UniqueId
    );

VOID
FaxServiceMain(
    DWORD argc,
    LPTSTR  *argv
    );

VOID
FaxServiceCtrlHandler(
    DWORD Opcode
    );

DWORD
InstallService(
    LPTSTR  Username,
    LPTSTR  Password
    );

DWORD
RemoveService(
    void
    );

int
DebugService(
    VOID
    );

DWORD
ServiceStart(
    VOID
    );

void
ServiceStop(
    void
    );

void EndFaxSvc(
    BOOL bEndProcess,
    DWORD Severity
    );

DWORD
ReportServiceStatus(
    DWORD CurrentState,
    DWORD Win32ExitCode,
    DWORD WaitHint
    );

//
// util.c
//

void
LogMessage(
    DWORD   FormatId,
    ...
    );

LPTSTR
GetLastErrorText(
    DWORD ErrorCode
    );


DWORD MyGetFileSize(
    LPCTSTR FileName
    );

//
// tapi.c
//

DWORD
TapiInitialize(
    PREG_FAX_SERVICE FaxReg
    );

PLINE_INFO
GetTapiLineFromDeviceId(
    DWORD DeviceId
    );

PLINE_INFO
GetTapiLineForFaxOperation(
    DWORD DeviceId,
    DWORD JobType,
    LPWSTR FaxNumber,
    BOOL Handoff
    );

BOOL
ReleaseTapiLine(
    PLINE_INFO LineInfo,
    HCALL hCall
    );

DWORD
QueueTapiCallback(
    PLINE_INFO  LineInfo,
    DWORD       hDevice,
    DWORD       dwMessage,
    DWORD       dwInstance,
    DWORD       dwParam1,
    DWORD       dwParam2,
    DWORD       dwParam3
    );

VOID
SpoolerSetAllTapiLinesActive(
    VOID
    );

//
// tapidbg.c
//

VOID
ShowLineEvent(
    HLINE       htLine,
    HCALL       htCall,
    LPTSTR      MsgStr,
    DWORD_PTR   dwCallbackInstance,
    DWORD       dwMsg,
    DWORD_PTR   dwParam1,
    DWORD_PTR   dwParam2,
    DWORD_PTR   dwParam3
    );

//
// faxdev.c
//

BOOL
LoadDeviceProviders(
    PREG_FAX_SERVICE FaxReg
    );

BOOL
InitializeDeviceProviders(
    VOID
    );

PDEVICE_PROVIDER
FindDeviceProvider(
    LPTSTR ProviderName
    );

//
// job.c
//

BOOL
InitializeJobManager(
        PREG_FAX_SERVICE FaxReg
    );

PJOB_ENTRY
StartJob(
    DWORD DeviceId,
    DWORD JobType,
    LPWSTR FaxNumber
    );

BOOL
EndJob(
    PJOB_ENTRY JobEntry
    );

BOOL
ReleaseJob(
    IN PJOB_ENTRY JobEntry
    );

DWORD
SendDocument(
    PJOB_ENTRY  JobEntry,
    LPTSTR      FileName,
    PFAX_JOB_PARAM JobParam,
    PJOB_QUEUE JobQueue
    );

VOID
SetRetryValues(
    PREG_FAX_SERVICE FaxReg
    );

VOID
FaxLogSend(
    PFAX_SEND_ITEM  FaxSendItem,
    BOOL Rslt,
    PFAX_DEV_STATUS FaxStatus,
    BOOL Retrying
    );

LPTSTR
ExtractFaxTag(
    LPTSTR      pTagKeyword,
    LPTSTR      pTaggedStr,
    INT        *pcch
    );

BOOL
AddTiffTags(
    LPTSTR FaxFileName,
    DWORDLONG SendTime,
    PFAX_DEV_STATUS FaxStatus,
    PFAX_SEND FaxSend
    );


//
// receive.c
//

DWORD
StartFaxReceive(
    PJOB_ENTRY      JobEntry,
    HCALL           hCall,
    PLINE_INFO      LineInfo,
    LPTSTR          FileName,
    DWORD           FileNameSize
    );

//
// route.c
//


BOOL
InitializeRouting(
    PREG_FAX_SERVICE FaxReg
    );

BOOL
FaxRoute(
    PJOB_QUEUE          JobQueue,
    LPTSTR              TiffFileName,
    PFAX_ROUTE          FaxRoute,
    PROUTE_FAILURE_INFO *RouteFailureInfo,
    LPDWORD             RouteFailureCount
    );

LPTSTR
TiffFileNameToRouteFileName(
    LPTSTR  TiffFileName
    );

BOOL
LoadRouteInfo(
    IN  LPWSTR              RouteFileName,
    OUT PROUTE_INFO         *RouteInfo,
    OUT PROUTE_FAILURE_INFO *RouteFailure,
    OUT LPDWORD             RouteFailureCount
    );

PFAX_ROUTE
SerializeFaxRoute(
    IN PFAX_ROUTE FaxRoute,
    IN LPDWORD Size
    );

PFAX_ROUTE
DeSerializeFaxRoute(
    IN PFAX_ROUTE FaxRoute
    );

BOOL
FaxRouteRetry(
    PFAX_ROUTE FaxRoute,
    PROUTE_FAILURE_INFO RouteFailureInfo
    );

//
// modem.c
//

DWORD
GetModemClass(
    HANDLE hFile
    );

//
// print.c
//

BOOL
ArchivePrintJob(
    LPTSTR FaxFileName
    );

LPTSTR
GetString(
    DWORD InternalId
    );

BOOL
IsPrinterFaxPrinter(
    LPTSTR PrinterName
    );

BOOL CALLBACK
FaxDeviceProviderCallback(
    IN HANDLE FaxHandle,
    IN DWORD  DeviceId,
    IN DWORD_PTR  Param1,
    IN DWORD_PTR  Param2,
    IN DWORD_PTR  Param3
    );

BOOL
InitializePrinting(
    VOID
    );

PJOB_ENTRY
FindJob(
    IN HANDLE FaxHandle
    );

PJOB_ENTRY
FindJobByPrintJob(
    IN DWORD PrintJobId
    );

BOOL
HandoffCallToRas(
    PLINE_INFO LineInfo,
    HCALL hCall
    );


VOID
StoreString(
    LPCTSTR String,
    PULONG_PTR DestString,
    LPBYTE Buffer,
    PULONG_PTR Offset
    );

VOID
InitializeStringTable(
    VOID
    );

BOOL
InitializeFaxDirectories(
    VOID
    );

BOOL
OpenTapiLine(
    PLINE_INFO LineInfo
    );

PVOID
MyGetJob(
    HANDLE  hPrinter,
    DWORD   level,
    DWORD   jobId
    );

LPLINEDEVCAPS
MyLineGetDevCaps(
    DWORD DeviceId
    );

LONG
MyLineGetTransCaps(
    LPLINETRANSLATECAPS *LineTransCaps
    );

LONG
MyLineTranslateAddress(
    LPTSTR Address,
    DWORD DeviceId,
    LPLINETRANSLATEOUTPUT *TranslateOutput
    );

DWORDLONG
GenerateUniqueFileName(
    LPTSTR Directory,
    LPTSTR Extension,
    LPTSTR FileName,
    DWORD  FileNameSize
    );

BOOL
ServiceMessageBox(
    IN LPCTSTR MsgString,
    IN DWORD Type,
    IN BOOL UseThread,
    IN LPDWORD Response,
    IN ...
    );

VOID
SetLineState(
    PLINE_INFO LineInfo,
    DWORD State
    );

BOOL
CreateFaxEvent(
    DWORD DeviceId,
    DWORD EventId,
    DWORD JobId
    );

BOOL
GetFaxEvent(
    PLINE_INFO LineInfo,
    PFAX_EVENT Event
    );

DWORD
MapStatusIdToEventId(
    DWORD StatusId
    );

BOOL
InitializeHandleTable(
    PREG_FAX_SERVICE FaxReg
    );

PHANDLE_ENTRY
CreateNewPortHandle(
    handle_t    hBinding,
    PLINE_INFO  LineInfo,
    DWORD       Flags
    );

PHANDLE_ENTRY
CreateNewConnectionHandle(
    handle_t    hBinding
    );

BOOL
IsPortOpenedForModify(
    PLINE_INFO LineInfo
    );

VOID
CloseFaxHandle(
    PHANDLE_ENTRY HandleEntry
    );

LPLINEDEVSTATUS
MyLineGetLineDevStatus(
    HLINE hLine
    );

DWORD
InitializeFaxSecurityDescriptors(
    VOID
    );

BOOL
FaxSvcAccessCheck(
    DWORD SecurityType,
    ACCESS_MASK DesiredAccess
    );

BOOL
PostClientMessage(
   PFAX_CLIENT_DATA ClientData,
   PFAX_EVENT FaxEvent
   );

BOOL
BuildSecureSD(
    OUT PSECURITY_DESCRIPTOR *Dacl
    );

PROUTING_METHOD
FindRoutingMethodByGuid(
    IN LPCWSTR RoutingGuidString
    );

DWORD
EnumerateRoutingMethods(
    IN PFAXROUTEMETHODENUM Enumerator,
    IN LPVOID Context
    );
VOID
RescheduleJobQueueEntry(
    IN PJOB_QUEUE JobQueue
    );

VOID
SortJobQueue(
    VOID
    );

PJOB_QUEUE
AddJobQueueEntry(
    IN DWORD JobType,
    IN LPCTSTR FileName,
    IN const FAX_JOB_PARAMW *JobParams,
    IN LPCWSTR UserName,
    IN BOOL CreateQueueFile,
    IN PJOB_ENTRY JobEntry
    );

VOID
SetDiscountTime(
    IN OUT LPSYSTEMTIME SystemTime
    );

LPWSTR
GetClientUserName(
    VOID
    );

BOOL
RestoreFaxQueue(
    VOID
    );

PJOB_QUEUE
FindJobQueueEntryByJobQueueEntry(
    IN PJOB_QUEUE JobQueueEntry
    );

PJOB_QUEUE
FindJobQueueEntry(
    IN DWORD JobId
    );

PJOB_QUEUE
FindJobQueueEntryByUniqueId(
    IN DWORDLONG UniqueId
    );

BOOL
RemoveJobQueueEntry(
    IN PJOB_QUEUE JobQueue
    );

DWORD
JobQueueThread(
    LPVOID UnUsed
    );

BOOL
ResumeJobQueueEntry(
    IN PJOB_QUEUE JobQueue
    );

BOOL
PauseJobQueueEntry(
    IN PJOB_QUEUE JobQueue
    );

VOID
PauseServerQueue(
    VOID
    );

VOID
ResumeServerQueue(
    VOID
    );

BOOL
SetFaxServiceAutoStart(
    VOID
    );

BOOL
SortDevicePriorities(
    VOID
    );

DWORD
GetFaxDeviceCount(
    VOID
    );

BOOL
CommitDeviceChanges(
    VOID
    );

BOOL
SortMethodPriorities(
    VOID
    );

BOOL
CommitMethodChanges(
    VOID
    );

VOID
UpdateVirtualDevices(
    VOID
    );

BOOL
IsVirtualDevice(
    PLINE_INFO LineInfo
    );

DWORD
ValidateTiffFile(
    LPCWSTR TiffFile
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\server\mapi.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mapi.c

Abstract:

    This file implements wrappers for all mapi apis.
    The wrappers are necessary because mapi does not
    implement unicode and this code must be non-unicode.

Author:

    Wesley Witt (wesw) 13-Sept-1996

Revision History:

--*/

#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <mapiwin.h>
#include <mapix.h>
#include <mapiutil.h>
#include <stdio.h>

#include "profinfo.h"
#include "faxutil.h"



typedef ULONG (STDAPIVCALLTYPE*ULRELEASE)(LPVOID);
typedef VOID  (STDAPIVCALLTYPE*FREEPADRLIST)(LPADRLIST);
typedef ULONG (STDAPIVCALLTYPE*HRQUERYALLROWS)(LPMAPITABLE,LPSPropTagArray,LPSRestriction,LPSSortOrderSet,LONG,LPSRowSet*);
typedef SCODE (STDAPIVCALLTYPE*SCDUPPROPSET)(int, LPSPropValue,LPALLOCATEBUFFER, LPSPropValue*);



static LPMAPIINITIALIZE     MapiInitialize;
static LPMAPIUNINITIALIZE   MapiUnInitialize;
static LPMAPILOGONEX        MapiLogonEx;
static LPMAPIFREEBUFFER     MapiFreeBuffer;
static LPMAPIALLOCATEBUFFER MapiAllocateBuffer;
static LPMAPIADMINPROFILES  MapiAdminProfiles;
static ULRELEASE            pUlRelease;
static FREEPADRLIST         pFreePadrlist;
static HRQUERYALLROWS       pHrQueryAllRows;
static SCDUPPROPSET         pScDupPropset;


static MAPIINIT_0           MapiInit;

extern "C" BOOL  MapiIsInitialized = FALSE;

extern "C" DWORD ServiceDebug;


extern "C"
LPSTR
UnicodeStringToAnsiString(
    LPWSTR UnicodeString
    );

extern "C"
VOID
FreeString(
    LPVOID String
    );


extern "C"
BOOL
InitializeMapi(
    VOID
    )

/*++

Routine Description:

    Initializes MAPI.

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if not

--*/

{

    HMODULE MapiMod = NULL;
    HRESULT Result;

    //
    // load the mapi dll
    //

    MapiMod = LoadLibrary( "mapi32.dll" );
    if (!MapiMod) {
        return FALSE;
    }

    //
    // get the addresses of the mapi functions that we need
    //

    MapiInitialize = (LPMAPIINITIALIZE) GetProcAddress( MapiMod, "MAPIInitialize" );
    MapiUnInitialize = (LPMAPIUNINITIALIZE) GetProcAddress( MapiMod, "MAPIUninitialize" );
    MapiLogonEx = (LPMAPILOGONEX) GetProcAddress( MapiMod, "MAPILogonEx" );
    MapiFreeBuffer = (LPMAPIFREEBUFFER) GetProcAddress( MapiMod, "MAPIFreeBuffer" );
    MapiAllocateBuffer = (LPMAPIALLOCATEBUFFER) GetProcAddress( MapiMod, "MAPIAllocateBuffer" );
    MapiAdminProfiles = (LPMAPIADMINPROFILES) GetProcAddress( MapiMod, "MAPIAdminProfiles" );
    pUlRelease = (ULRELEASE) GetProcAddress( MapiMod, "UlRelease@4" );
    pFreePadrlist = (FREEPADRLIST) GetProcAddress( MapiMod, "FreePadrlist@4" );
    pHrQueryAllRows = (HRQUERYALLROWS) GetProcAddress( MapiMod, "HrQueryAllRows@24" );
    pScDupPropset = (SCDUPPROPSET) GetProcAddress( MapiMod, "ScDupPropset@16" );

    if ((!MapiInitialize) || (!MapiUnInitialize) ||
        (!MapiLogonEx) || (!MapiAllocateBuffer) ||
        (!MapiFreeBuffer) || (!MapiAdminProfiles) ||
        (!pUlRelease) || (!pFreePadrlist) ||
        (!pHrQueryAllRows) || (!pScDupPropset)) {
        return FALSE;
    }

    MapiInit.ulFlags = MAPI_MULTITHREAD_NOTIFICATIONS;

    if (!ServiceDebug) {
        MapiInit.ulFlags |= MAPI_NT_SERVICE;
    }

    Result = MapiInitialize(&MapiInit);

    if (Result != S_OK) {
        return FALSE;
    }

    return MapiIsInitialized = TRUE;
}


VOID
FreeProws(
    LPSRowSet prows
    )

/*++

Routine Description:

    Destroy SRowSet structure.  Copied from MAPI.

Arguments:

    hFile      - Pointer to SRowSet

Return value:

    NONE

--*/

{
    ULONG irow;

    if (!prows) {
        return;
    }

    for (irow = 0; irow < prows->cRows; ++irow) {
        MapiFreeBuffer(prows->aRow[irow].lpProps);
    }

    MapiFreeBuffer( prows );
}


HRESULT
HrMAPIFindInbox(
    IN LPMDB lpMdb,
    OUT ULONG *lpcbeid,
    OUT LPENTRYID *lppeid
    )

/*++

Routine Description:

    Find IPM inbox folder.  Copied from Exchange SDK.

Arguments:

    lpMdb            - pointer to message store
    lpcbeid          - count of bytes in entry ID
    lppeid           - entry ID of IPM inbox

Return value:

    HRESULT (see MAPI docs)

--*/

{
    HRESULT hr = NOERROR;
    SCODE sc = 0;


    *lpcbeid = 0;
    *lppeid  = NULL;

    //
    // Get the entry ID of the Inbox from the message store
    //
    hr = lpMdb->GetReceiveFolder(
        NULL,
        0,
        lpcbeid,
        lppeid,
        NULL
        );

    return hr;
}

HRESULT
HrMAPIFindOutbox(
    IN LPMDB lpMdb,
    OUT ULONG *lpcbeid,
    OUT LPENTRYID *lppeid
    )
/*++

Routine Description:

    Find IPM outbox folder.  Copied from Exchange SDK.

Arguments:

    lpMdb            - pointer to message store
    lpcbeid          - count of bytes in entry ID
    lppeid           - entry ID of IPM inbox

Return value:

    HRESULT (see MAPI docs)

--*/
{
    HRESULT       hr          = NOERROR;
    SCODE         sc          = 0;
    ULONG         cValues     = 0;
    LPSPropValue  lpPropValue = NULL;
    ULONG         cbeid       = 0;
    SPropTagArray rgPropTag   = { 1, { PR_IPM_OUTBOX_ENTRYID } };


    *lpcbeid = 0;
    *lppeid  = NULL;

    //
    // Get the outbox entry ID property.
    //
    hr = lpMdb->GetProps(
        &rgPropTag,
        0,
        &cValues,
        &lpPropValue
        );

    if (hr == MAPI_W_ERRORS_RETURNED) {
        goto cleanup;
    }

    if (FAILED(hr)) {
        lpPropValue = NULL;
        goto cleanup;
    }

    //
    // Check to make sure we got the right property.
    //
    if (lpPropValue->ulPropTag != PR_IPM_OUTBOX_ENTRYID) {
        goto cleanup;
    }

    cbeid = lpPropValue->Value.bin.cb;

    sc = MapiAllocateBuffer( cbeid, (void **)lppeid );

    if(FAILED(sc)) {
        goto cleanup;
    }

    //
    // Copy outbox Entry ID
    //
    CopyMemory(
        *lppeid,
        lpPropValue->Value.bin.lpb,
        cbeid
        );

    *lpcbeid = cbeid;

cleanup:

    MapiFreeBuffer( lpPropValue );

    return hr;
}


HRESULT
HrMAPIFindDefaultMsgStore(
    IN LPMAPISESSION lplhSession,
    OUT ULONG *lpcbeid,
    OUT LPENTRYID *lppeid
    )

/*++

Routine Description:

    Get the entry ID of the default message store.  Copied from Exchange SDK.

Arguments:

       lplhSession      - session pointer
       lpcbeid          - count of bytes in entry ID
       lppeid           - entry ID default store

Return value:

    HRESULT (see MAPI docs)

--*/

{
    HRESULT     hr      = NOERROR;
    SCODE       sc      = 0;
    LPMAPITABLE lpTable = NULL;
    LPSRowSet   lpRows  = NULL;
    LPENTRYID   lpeid   = NULL;
    ULONG       cbeid   = 0;
    ULONG       cRows   = 0;
    ULONG       i       = 0;

    SizedSPropTagArray(2, rgPropTagArray) =
    {
        2,
        {
            PR_DEFAULT_STORE,
            PR_ENTRYID
        }
    };

    //
    // Get the list of available message stores from MAPI
    //
    hr = lplhSession->GetMsgStoresTable( 0, &lpTable );
    if (FAILED(hr)) {
        goto cleanup;
    }

    //
    // Get the row count for the message recipient table
    //
    hr = lpTable->GetRowCount( 0, &cRows );
    if (FAILED(hr)) {
        goto cleanup;
    }

    //
    // Set the columns to return
    //
    hr = lpTable->SetColumns( (LPSPropTagArray)&rgPropTagArray, 0 );
    if (FAILED(hr)) {
        goto cleanup;
    }

    //
    // Go to the beginning of the recipient table for the envelope
    //
    hr = lpTable->SeekRow( BOOKMARK_BEGINNING, 0, NULL );
    if (FAILED(hr)) {
        goto cleanup;
    }

    //
    // Read all the rows of the table
    //
    hr = lpTable->QueryRows( cRows, 0, &lpRows );
    if (SUCCEEDED(hr) && (lpRows != NULL) && (lpRows->cRows == 0)) {
        FreeProws( lpRows );
        hr = MAPI_E_NOT_FOUND;
    }

    if (FAILED(hr) || (lpRows == NULL)) {
        goto cleanup;
    }

    for (i = 0; i < cRows; i++) {
        if(lpRows->aRow[i].lpProps[0].Value.b == TRUE) {
            cbeid = lpRows->aRow[i].lpProps[1].Value.bin.cb;

            sc = MapiAllocateBuffer( cbeid, (void **)&lpeid );

            if(FAILED(sc)) {
                cbeid = 0;
                lpeid = NULL;
                goto cleanup;
            }

            //
            // Copy entry ID of message store
            //
            CopyMemory(
                lpeid,
                lpRows->aRow[i].lpProps[1].Value.bin.lpb,
                cbeid
                );

            break;
        }
    }

cleanup:

    if(!lpRows) {
        FreeProws( lpRows );
    }

    lpTable->Release();

    *lpcbeid = cbeid;
    *lppeid = lpeid;

    return hr;
}


HRESULT
HrMAPIWriteFileToStream(
    IN HANDLE hFile,
    OUT LPSTREAM lpStream
    )

/*++

Routine Description:

    Write file to a stream given a stream pointer.  Copied from Exchange SDK.

Arguments:

       hFile      - Handle to file
       lpStream   - Pointer to stream

Return value:

    HRESULT (see MAPI docs)

--*/
{
    HRESULT hr              = NOERROR;
    DWORD   cBytesRead      = 0;
    ULONG   cBytesWritten   = 0;
    BYTE    byteBuffer[128] = {0};
    BOOL    fReadOk         = FALSE;

    for(;;) {
        fReadOk = ReadFile(
            hFile,
            byteBuffer,
            sizeof(byteBuffer),
            &cBytesRead,
            NULL
            );

        if (!fReadOk) {
            break;
        }

        if (!cBytesRead) {
            hr = NOERROR;
            break;
        }

        hr = lpStream->Write(
            byteBuffer,
            cBytesRead,
            &cBytesWritten
            );
        if (FAILED(hr)) {
            break;
        }

        if(cBytesWritten != cBytesRead) {
            break;
        }
    }

    return hr;
}


extern "C"
VOID
DoMapiLogon(
    PPROFILE_INFO ProfileInfo
    )
{
    HRESULT HResult = 0;
    FLAGS MAPILogonFlags = MAPI_NEW_SESSION | MAPI_EXTENDED | MAPI_NO_MAIL;
    LPSTR ProfileName;
    LPMAPISESSION Session = NULL;


    if (!MapiIsInitialized) {
        ProfileInfo->Session = NULL;
        SetEvent( ProfileInfo->EventHandle );
        return;

    }

    if (!ServiceDebug) {
        MAPILogonFlags |= MAPI_NT_SERVICE;
    }

    if (ProfileInfo->UseMail) {
        MAPILogonFlags &= ~MAPI_NO_MAIL;
    }

    if (ProfileInfo->ProfileName[0] == 0) {
        MAPILogonFlags |= MAPI_USE_DEFAULT;
    }

    ProfileName = UnicodeStringToAnsiString( ProfileInfo->ProfileName );

    __try {
        HResult = MapiLogonEx(
            0,
            ProfileName,
            NULL,
            MAPILogonFlags,
            &Session
            );
    } __except (EXCEPTION_EXECUTE_HANDLER) {

        HResult = GetExceptionCode();
    }

    if (HR_FAILED(HResult)) {
        SetLastError( HResult );
        ProfileInfo->Session = NULL;
    } else {
        InitializeCriticalSection( &ProfileInfo->CsSession );
        ProfileInfo->Session = Session;
    }

    FreeString( ProfileName );

    SetEvent( ProfileInfo->EventHandle );
}


extern "C"
BOOL
DoMapiLogoff(
    LPMAPISESSION Session
    )
{
    HRESULT HResult = Session->Logoff( 0, 0, 0 );
    if (HR_FAILED(HResult)) {
        return FALSE;
    }
    return TRUE;
}


extern "C"
BOOL
StoreMapiMessage(
    LPMAPISESSION   Session,
    LPWSTR          MsgSenderNameW,
    LPWSTR          MsgSubjectW,
    LPWSTR          MsgBodyW,
    LPWSTR          MsgAttachmentFileNameW,
    LPWSTR          MsgAttachmentTitleW,
    DWORD           MsgImportance,
    LPFILETIME      MsgTime,
    PULONG          ResultCode
    )

/*++

Routine Description:

    Mails a TIFF file to the inbox in the specified profile.

Arguments:

    TiffFileName            - Name of TIFF file to mail
    ProfileName             - Profile name to use
    ResultCode              - The result of the failed API call

Return Value:

    TRUE for success, FALSE on error

--*/

{
    LPATTACH            Attach = NULL;
    ULONG               AttachmentNum;
    CHAR                FileExt[_MAX_EXT];
    CHAR                FileName[MAX_PATH];
    HRESULT             HResult = 0;
    LPMAPIFOLDER        Inbox = NULL;
    LPMESSAGE           Message = NULL;
    LPSTR               MsgAttachmentFileName = NULL;
    LPSTR               MsgAttachmentTitle = NULL;
    LPSTR               MsgBody = NULL;
    LPSTR               MsgSenderName = NULL;
    LPSTR               MsgSubject = NULL;
    DWORD               RenderingPosition = 0;
    LPMDB               Store = NULL;
    LPSTREAM            Stream = NULL;
    ULONG               cbInEntryID = 0;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    LPENTRYID           lpInEntryID = NULL;
    LPSPropProblemArray lppProblems;
    ULONG               lpulObjType;
    SPropValue          spvAttachProps[5] = { 0 };
    SPropValue          spvMsgProps[9] = { 0 };
    FILETIME            CurrentTime;


    _try {

        //
        // get the time if the caller wants us to
        //

        if (!MsgTime) {
            MsgTime = &CurrentTime;
            GetSystemTimeAsFileTime( MsgTime );
        }

        //
        // find the default message store
        //

        HResult = HrMAPIFindDefaultMsgStore( Session, &cbInEntryID, &lpInEntryID );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        //
        // open the message store
        //

        HResult = Session->OpenMsgStore(
            0,
            cbInEntryID,
            lpInEntryID,
            NULL,
            MDB_NO_DIALOG | MDB_WRITE,
            &Store
            );
        if (HR_FAILED(HResult)) {
            _leave;
        }

        MapiFreeBuffer( lpInEntryID );

        //
        // find the inbox
        //

        HResult= HrMAPIFindInbox( Store, &cbInEntryID, &lpInEntryID );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        //
        // open the inbox
        //

        HResult = Session->OpenEntry(
            cbInEntryID,
            lpInEntryID,
            NULL,
            MAPI_MODIFY,
            &lpulObjType,
            (LPUNKNOWN *) &Inbox
            );
        if (HR_FAILED(HResult)) {
            _leave;
        }

        //
        // Create a message
        //

        HResult = Inbox->CreateMessage(
            NULL,
            0,
            &Message
            );
        if (HR_FAILED(HResult)) {
            _leave;
        }

        //
        // convert all of the strings to ansi strings
        //

        MsgSenderName = UnicodeStringToAnsiString( MsgSenderNameW );
        MsgSubject = UnicodeStringToAnsiString( MsgSubjectW );
        MsgBody = UnicodeStringToAnsiString( MsgBodyW );
        MsgAttachmentFileName = UnicodeStringToAnsiString( MsgAttachmentFileNameW );
        MsgAttachmentTitle = UnicodeStringToAnsiString( MsgAttachmentTitleW );

        //
        // Fill in message properties and set them
        //

        spvMsgProps[0].ulPropTag     = PR_SENDER_NAME;
        spvMsgProps[1].ulPropTag     = PR_SENT_REPRESENTING_NAME;
        spvMsgProps[2].ulPropTag     = PR_SUBJECT;
        spvMsgProps[3].ulPropTag     = PR_MESSAGE_CLASS;
        spvMsgProps[4].ulPropTag     = PR_BODY;
        spvMsgProps[5].ulPropTag     = PR_MESSAGE_DELIVERY_TIME;
        spvMsgProps[6].ulPropTag     = PR_CLIENT_SUBMIT_TIME;
        spvMsgProps[7].ulPropTag     = PR_MESSAGE_FLAGS;
        spvMsgProps[8].ulPropTag     = PR_IMPORTANCE;
        spvMsgProps[0].Value.lpszA   = MsgSenderName;
        spvMsgProps[1].Value.lpszA   = MsgSenderName;
        spvMsgProps[2].Value.lpszA   = MsgSubject;
        spvMsgProps[3].Value.lpszA   = "IPM.Note";
        spvMsgProps[4].Value.lpszA   = MsgBody;
        spvMsgProps[5].Value.ft      = *MsgTime;
        spvMsgProps[6].Value.ft      = *MsgTime;
        spvMsgProps[7].Value.ul      = 0;
        spvMsgProps[8].Value.ul      = MsgImportance;

        HResult = Message->SetProps(
            sizeof(spvMsgProps)/sizeof(SPropValue),
            (LPSPropValue) spvMsgProps,
            &lppProblems
            );
        if (HR_FAILED(HResult)) {
            _leave;
        }

        MapiFreeBuffer( lppProblems );

        if (MsgAttachmentFileName) {

            //
            // Create an attachment
            //

            HResult = Message->CreateAttach(
                NULL,
                0,
                &AttachmentNum,
                &Attach
                );
            if (HR_FAILED(HResult)) {
                _leave;
            }

            _splitpath( MsgAttachmentFileName, NULL, NULL, FileName, FileExt );
            strcat( FileName, FileExt );

            //
            // Fill in attachment properties and set them
            //

            if (!MsgAttachmentTitle) {
                MsgAttachmentTitle = FileName;
            }

            RenderingPosition = strlen(MsgBody);

            spvAttachProps[0].ulPropTag     = PR_RENDERING_POSITION;
            spvAttachProps[1].ulPropTag     = PR_ATTACH_METHOD;
            spvAttachProps[2].ulPropTag     = PR_ATTACH_LONG_FILENAME;
            spvAttachProps[3].ulPropTag     = PR_DISPLAY_NAME;
            spvAttachProps[4].ulPropTag     = PR_ATTACH_EXTENSION;
            spvAttachProps[0].Value.ul      = RenderingPosition;
            spvAttachProps[1].Value.ul      = ATTACH_BY_VALUE;
            spvAttachProps[2].Value.lpszA   = MsgAttachmentTitle;
            spvAttachProps[3].Value.lpszA   = MsgAttachmentTitle;
            spvAttachProps[4].Value.lpszA   = FileExt;

            HResult = Attach->SetProps(
                sizeof(spvAttachProps)/sizeof(SPropValue),
                (LPSPropValue) spvAttachProps,
                &lppProblems
                );
            if (HR_FAILED(HResult)) {
                _leave;
            }

            MapiFreeBuffer( lppProblems );

            //
            // Attach a data property to the attachment
            //

            HResult = Attach->OpenProperty(
                PR_ATTACH_DATA_BIN,
                &IID_IStream,
                0,
                MAPI_CREATE | MAPI_MODIFY,
                (LPUNKNOWN *) &Stream
                );
            if (HR_FAILED(HResult)) {
                _leave;
            }

            //
            // open the message attachment file
            //

            hFile = CreateFile(
                MsgAttachmentFileName,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
            if (hFile == INVALID_HANDLE_VALUE) {
                _leave;
            }

            //
            // Write the file to the data property
            //

            HResult = HrMAPIWriteFileToStream( hFile, Stream );
            if (HR_FAILED(HResult)) {
                _leave;
            }
        }

        //
        // Save the changes and logoff
        //

        HResult = Attach->SaveChanges(
            FORCE_SAVE
            );
        if (HR_FAILED(HResult)) {
            _leave;
        }

        HResult = Message->SaveChanges(
            FORCE_SAVE
            );
        if (HR_FAILED(HResult)) {
            _leave;
        }

    }
    _finally {

        MapiFreeBuffer( lpInEntryID );

        if (Store) {
            Store->Release();
        }
        if (Inbox) {
            Inbox->Release();
        }
        if (Message) {
            Message->Release();
        }
        if (Attach) {
            Attach->Release();
        }
        if (Stream) {
            Stream->Release();
        }

        FreeString( MsgSenderName );
        FreeString( MsgSubject );
        FreeString( MsgBody );
        FreeString( MsgAttachmentFileName );
        if (MsgAttachmentTitleW && MsgAttachmentTitle) {
            FreeString( MsgAttachmentTitle );
        }

        CloseHandle( hFile );

    }

    *ResultCode = HResult;
    return HResult == 0;
}

extern "C"
LONG
GetMapiProfiles(
    LPWSTR *OutBuffer,
    LPDWORD OutBufferSize
    )
{
    HMODULE MapiMod = NULL;
    LPMAPITABLE pmt = NULL;
    LPSRowSet prws = NULL;
    LPSPropValue pval;
    LPPROFADMIN lpProfAdmin;
    DWORD i;
    HRESULT hr;
    DWORD Count;
    LPWSTR Buffer;
    DWORD BytesNeeded;
    DWORD Offset = 0;


    if (!MapiIsInitialized) {
        return MAPI_E_NO_SUPPORT;
    }

    if (hr = MapiAdminProfiles( 0, &lpProfAdmin )) {
        return hr;
    }

    //
    // get the mapi table object
    //

    if (hr = lpProfAdmin->GetProfileTable( 0, &pmt )) {
        goto exit;
    }

    //
    // get the actual profile data, FINALLY
    //

    if (hr = pmt->QueryRows( 4000, 0, &prws )) {
        goto exit;
    }

    //
    // enumerate the profiles and put the name
    // of each profile in the combo box
    //

    BytesNeeded = 0;

    for (i=0; i<prws->cRows; i++) {

        pval = prws->aRow[i].lpProps;


        Count = MultiByteToWideChar(
            CP_ACP,
            MB_PRECOMPOSED,
            pval[0].Value.lpszA,
            -1,
            NULL,
            0
            );

        if (Count == 0) {

            hr = GetLastError();

            goto exit;

        } else {

            BytesNeeded += Count * sizeof(WCHAR);

        }
    }

    BytesNeeded += sizeof(UNICODE_NULL);

    Buffer = (LPWSTR) MemAlloc( BytesNeeded );
    if (Buffer == NULL) {
        hr = ERROR_INSUFFICIENT_BUFFER;
        goto exit;
    }

    for (i=0; i<prws->cRows; i++) {

        pval = prws->aRow[i].lpProps;

        Count = MultiByteToWideChar(
            CP_ACP,
            MB_PRECOMPOSED,
            pval[0].Value.lpszA,
            -1,
            &Buffer[Offset],
            BytesNeeded - (Offset * sizeof(WCHAR))
            );

        if (Count == 0) {

            hr = GetLastError();

            goto exit;

        } else {

            Offset += Count;
        }

    }

    Buffer[Offset] = 0;

    *OutBuffer = Buffer;
    *OutBufferSize = BytesNeeded;

    hr = ERROR_SUCCESS;

exit:
    FreeProws( prws );

    if (pmt) {
        pmt->Release();
    }

    if (lpProfAdmin) {
        lpProfAdmin->Release();
    }

    return hr;
}

extern "C"
BOOL
GetDefaultMapiProfile(
    LPWSTR ProfileName
    )
{
    BOOL rVal = FALSE;
    LPMAPITABLE pmt = NULL;
    LPSRowSet prws = NULL;
    LPSPropValue pval;
    LPPROFADMIN lpProfAdmin;
    DWORD i;
    DWORD j;

    if (!MapiIsInitialized) {
        goto exit;
    }

    if (MapiAdminProfiles( 0, &lpProfAdmin )) {
        goto exit;
    }

    //
    // get the mapi profile table object
    //

    if (lpProfAdmin->GetProfileTable( 0, &pmt )) {
        goto exit;
    }

    //
    // get the actual profile data, FINALLY
    //

    if (pmt->QueryRows( 4000, 0, &prws )) {
        goto exit;
    }

    //
    // enumerate the profiles looking for the default profile
    //

    for (i=0; i<prws->cRows; i++) {
        pval = prws->aRow[i].lpProps;
        for (j = 0; j < 2; j++) {
            if (pval[j].ulPropTag == PR_DEFAULT_PROFILE && pval[j].Value.b) {
                //
                // this is the default profile
                //
                MultiByteToWideChar(
                    CP_ACP,
                    MB_PRECOMPOSED,
                    pval[0].Value.lpszA,
                    -1,
                    ProfileName,
                    (cchProfileNameMax + 1) * sizeof(WCHAR)
                    );
                rVal = TRUE;
                break;
            }
        }
    }

exit:
    FreeProws( prws );

    if (pmt) {
        pmt->Release();
    }

    return rVal;
}


#define IADDRTYPE  0
#define IEMAILADDR 1
#define IMAPIRECIP 2
#define IPROXYADDR 3
#define PR_EMS_AB_CONTAINERID  PROP_TAG(PT_LONG, 0xFFFD)
#define PR_EMS_AB_PROXY_ADDRESSES_A PROP_TAG(PT_MV_STRING8, 0x800F)
#define MUIDEMSAB {0xDC, 0xA7, 0x40, 0xC8, 0xC0, 0x42, 0x10, 0x1A, 0xB4, 0xB9, 0x08, 0x00, 0x2B, 0x2F, 0xE1, 0x82}
#define CbNewFlagList(_cflag) (offsetof(FlagList,ulFlag) + (_cflag)*sizeof(ULONG))


HRESULT
HrMAPICreateSizedAddressList(        // RETURNS: return code
    IN ULONG cEntries,               // count of entries in address list
    OUT LPADRLIST *lppAdrList        // pointer to address list pointer
    )
{
    HRESULT         hr              = NOERROR;
    SCODE           sc              = 0;
    ULONG           cBytes          = 0;


    *lppAdrList = NULL;

    cBytes = CbNewADRLIST(cEntries);

    sc = MapiAllocateBuffer(cBytes, (PVOID*) lppAdrList);
    if(FAILED(sc))
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    // Initialize ADRLIST structure
    ZeroMemory(*lppAdrList, cBytes);

    (*lppAdrList)->cEntries = cEntries;

cleanup:

    return hr;
}


HRESULT
HrMAPISetAddressList(                // RETURNS: return code
    IN ULONG iEntry,                 // index of address list entry
    IN ULONG cProps,                 // count of values in address list entry
    IN LPSPropValue lpPropValues,    // pointer to address list entry
    IN OUT LPADRLIST lpAdrList       // pointer to address list pointer
    )
{
    HRESULT         hr              = NOERROR;
    SCODE           sc              = 0;
    LPSPropValue    lpNewPropValues = NULL;
    ULONG           cBytes          = 0;


    if(iEntry >= lpAdrList->cEntries)
    {
        hr = E_FAIL;
        goto cleanup;
    }

    sc = pScDupPropset(
        cProps,
        lpPropValues,
        MapiAllocateBuffer,
        &lpNewPropValues
        );

    if(FAILED(sc))
    {
        hr = E_FAIL;
        goto cleanup;
    }

    if(lpAdrList->aEntries[iEntry].rgPropVals != NULL)
    {
        MapiFreeBuffer(lpAdrList->aEntries[iEntry].rgPropVals);
    }

    lpAdrList->aEntries[iEntry].cValues = cProps;
    lpAdrList->aEntries[iEntry].rgPropVals = lpNewPropValues;

cleanup:

    return hr;
}


HRESULT
HrCheckForTypeA(                // RETURNS: return code
    IN  LPCSTR lpszAddrType,    // pointer to address type
    IN  LPCSTR lpszProxy,       // pointer to proxy address
    OUT LPSTR * lppszAddress    // pointer to address pointer
    )
{
    HRESULT hr              = E_FAIL;
    LPCSTR  lpszProxyAddr   = NULL;
    ULONG   cbAddress       = 0;
    SCODE   sc              = 0;
    ULONG   cchProxy        = 0;
    ULONG   cchProxyType    = 0;


    // Initialize output parameter

    *lppszAddress = NULL;

    // find the ':' separator.

    cchProxy     = lstrlenA(lpszProxy);
    cchProxyType = strcspn(lpszProxy, ":");

    if((cchProxyType == 0) || (cchProxyType >= cchProxy))
    {
        hr = E_FAIL;
        goto cleanup;
    }

    hr = MAPI_E_NOT_FOUND;

    // does the address type match?
    if((cchProxyType == (ULONG)lstrlenA(lpszAddrType)) &&
       (_strnicmp(lpszProxy, lpszAddrType, cchProxyType) == 0))
    {
        // specified address type found
        lpszProxyAddr = lpszProxy + cchProxyType + 1;

        cbAddress = strlen(lpszProxyAddr);

        // make a buffer to hold it.
        sc = MapiAllocateBuffer(cbAddress, (void **)lppszAddress);

        if(FAILED(sc))
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            CopyMemory(*lppszAddress, lpszProxyAddr, cbAddress);

            hr = NOERROR;
        }
    }

cleanup:

    return hr;
}


HRESULT
HrFindExchangeGlobalAddressList(
    IN  LPADRBOOK  lpAdrBook,
    OUT ULONG      *lpcbeid,
    OUT LPENTRYID  *lppeid
    )
{
    HRESULT         hr                  = NOERROR;
    ULONG           ulObjType           = 0;
    ULONG           i                   = 0;
    LPMAPIPROP      lpRootContainer     = NULL;
    LPMAPIPROP      lpContainer         = NULL;
    LPMAPITABLE     lpContainerTable    = NULL;
    LPSRowSet       lpRows              = NULL;
    ULONG           cbContainerEntryId  = 0;
    LPENTRYID       lpContainerEntryId  = NULL;
    LPSPropValue    lpCurrProp          = NULL;
    SRestriction    SRestrictAnd[2]     = {0};
    SRestriction    SRestrictGAL        = {0};
    SPropValue      SPropID             = {0};
    SPropValue      SPropProvider       = {0};
    BYTE            muid[]              = MUIDEMSAB;

    SizedSPropTagArray(1, rgPropTags) =
    {
        1,
        {
            PR_ENTRYID,
        }
    };


    *lpcbeid = 0;
    *lppeid  = NULL;

    // Open the root container of the address book
    hr = lpAdrBook->OpenEntry(
        0,
        NULL,
        NULL,
        MAPI_DEFERRED_ERRORS,
        &ulObjType,
        (LPUNKNOWN FAR *)&lpRootContainer
        );

    if(FAILED(hr))
    {
        goto cleanup;
    }

    if(ulObjType != MAPI_ABCONT)
    {
        hr = E_FAIL;
        goto cleanup;
    }

    // Get the hierarchy table of the root container
    hr = ((LPABCONT)lpRootContainer)->GetHierarchyTable(
        MAPI_DEFERRED_ERRORS|CONVENIENT_DEPTH,
        &lpContainerTable
        );

    if(FAILED(hr))
    {
        goto cleanup;
    }

    // Restrict the table to the global address list (GAL)
    // ---------------------------------------------------

    // Initialize provider restriction to only Exchange providers

    SRestrictAnd[0].rt                          = RES_PROPERTY;
    SRestrictAnd[0].res.resProperty.relop       = RELOP_EQ;
    SRestrictAnd[0].res.resProperty.ulPropTag   = PR_AB_PROVIDER_ID;
    SPropProvider.ulPropTag                     = PR_AB_PROVIDER_ID;

    SPropProvider.Value.bin.cb                  = 16;
    SPropProvider.Value.bin.lpb                 = (LPBYTE)muid;
    SRestrictAnd[0].res.resProperty.lpProp      = &SPropProvider;

    // Initialize container ID restriction to only GAL container

    SRestrictAnd[1].rt                          = RES_PROPERTY;
    SRestrictAnd[1].res.resProperty.relop       = RELOP_EQ;
    SRestrictAnd[1].res.resProperty.ulPropTag   = PR_EMS_AB_CONTAINERID;
    SPropID.ulPropTag                           = PR_EMS_AB_CONTAINERID;
    SPropID.Value.l                             = 0;
    SRestrictAnd[1].res.resProperty.lpProp      = &SPropID;

    // Initialize AND restriction

    SRestrictGAL.rt                             = RES_AND;
    SRestrictGAL.res.resAnd.cRes                = 2;
    SRestrictGAL.res.resAnd.lpRes               = &SRestrictAnd[0];

    // Restrict the table to the GAL - only a single row should remain

    // Get the row corresponding to the GAL

        //
        //  Query all the rows
        //

        hr = pHrQueryAllRows(
            lpContainerTable,
                (LPSPropTagArray)&rgPropTags,
                &SRestrictGAL,
                NULL,
                0,
                &lpRows
                );

    if(FAILED(hr) || (lpRows == NULL) || (lpRows->cRows != 1))
    {
        hr = E_FAIL;
        goto cleanup;
    }

    // Get the entry ID for the GAL

    lpCurrProp = &(lpRows->aRow[0].lpProps[0]);

    if(lpCurrProp->ulPropTag == PR_ENTRYID)
    {
        cbContainerEntryId = lpCurrProp->Value.bin.cb;
        lpContainerEntryId = (LPENTRYID)lpCurrProp->Value.bin.lpb;
    }
    else
    {
        hr = E_FAIL;
        goto cleanup;
    }

    hr = MapiAllocateBuffer( cbContainerEntryId, (LPVOID *)lppeid );

    if(FAILED(hr))
    {
        *lpcbeid = 0;
        *lppeid = NULL;
    }
    else
    {
        CopyMemory(
            *lppeid,
            lpContainerEntryId,
            cbContainerEntryId);

        *lpcbeid = cbContainerEntryId;
    }

cleanup:

    pUlRelease(lpRootContainer);
    pUlRelease(lpContainerTable);
    pUlRelease(lpContainer);
    FreeProws( lpRows );

    if(FAILED(hr)) {
        MapiFreeBuffer( *lppeid );
        *lpcbeid = 0;
        *lppeid = NULL;
    }

    return hr;
}


HRESULT
HrGWResolveProxy(
    IN  LPADRBOOK   lpAdrBook,      // pointer to address book
    IN  ULONG       cbeid,          // count of bytes in the entry ID
    IN  LPENTRYID   lpeid,          // pointer to the entry ID
    IN  LPCSTR      lpszAddrType,   // pointer to the address type
    OUT BOOL        *lpfMapiRecip,  // MAPI recipient
    OUT LPSTR       *lppszAddress   // pointer to the address pointer
    )
{
    HRESULT         hr              = E_FAIL;
    HRESULT         hrT             = 0;
    SCODE           sc              = 0;
    ULONG           i               = 0;
    ULONG           cbAddress       = 0;
    ULONG           cProxy          = 0;
    LPSPropValue    lpProps         = NULL;
    LPADRLIST       lpAdrList       = NULL;
    SPropValue      prop[2]         = {0};

    SizedSPropTagArray(4, rgPropTags) =
    {
        4,
        {
            PR_ADDRTYPE_A,
            PR_EMAIL_ADDRESS_A,
            PR_SEND_RICH_INFO,
            PR_EMS_AB_PROXY_ADDRESSES_A
        }
    };


    // Initialize output parameters

    *lpfMapiRecip = FALSE;
    *lppszAddress = NULL;

    hr = HrMAPICreateSizedAddressList(1, &lpAdrList);

    if(FAILED(hr))
    {
        goto cleanup;
    }

    prop[0].ulPropTag       = PR_ENTRYID;
    prop[0].Value.bin.cb    = cbeid;
    prop[0].Value.bin.lpb   = (LPBYTE)lpeid;
    prop[1].ulPropTag       = PR_RECIPIENT_TYPE;
    prop[1].Value.ul        = MAPI_TO;

    hr = HrMAPISetAddressList(
        0,
        2,
        prop,
        lpAdrList
        );

    if(FAILED(hr))
    {
        goto cleanup;
    }

    hrT = lpAdrBook->PrepareRecips(
        0,
        (LPSPropTagArray)&rgPropTags,
        lpAdrList
        );

    if(FAILED(hrT))
    {
        goto cleanup;
    }

    lpProps = lpAdrList->aEntries[0].rgPropVals;

    //
    //  Hack:  detect the case where prepare recips doesn't work correctly.
    //      This happens when trying to look up a recipient that is in
    //      a replicated directory but not in the local directory.
    //
    if (lpAdrList->aEntries[0].cValues == 3)
    {
        hr = E_FAIL;
        goto cleanup;
    }

    // If the given address type matches the PR_ADDRTYPE value,
    // return the PR_EMAIL_ADDRESS value

    if((PROP_TYPE(lpProps[IADDRTYPE].ulPropTag) != PT_ERROR) &&
       (PROP_TYPE(lpProps[IEMAILADDR].ulPropTag) != PT_ERROR) &&
       (_strcmpi(lpProps[IADDRTYPE].Value.lpszA, lpszAddrType) == 0))
    {
        cbAddress = strlen(lpProps[IEMAILADDR].Value.lpszA);

        sc = MapiAllocateBuffer(cbAddress, (void **)lppszAddress);

        if(FAILED(sc))
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            CopyMemory(*lppszAddress, lpProps[IEMAILADDR].Value.lpszW, cbAddress);
            hr = NOERROR;
        }

        goto cleanup;
    }

    // Search for a PR_EMS_AB_PROXY_ADDRESSES of the given type if present.

    else if(PROP_TYPE(lpProps[IPROXYADDR].ulPropTag) != PT_ERROR)
    {
        // count of proxy addresses
        cProxy = lpAdrList->aEntries[0].rgPropVals[IPROXYADDR].Value.MVszA.cValues;

        for(i = 0; i < cProxy; i++)
        {
            hr = HrCheckForTypeA(
                lpszAddrType,
                lpProps[IPROXYADDR].Value.MVszA.lppszA[i],
                lppszAddress
                );

            if(hr == MAPI_E_NOT_FOUND)
            {
                continue;
            }
            else if(FAILED(hr))
            {
                goto cleanup;
            }
            else
            {
                //
                // Found a matching proxy address.
                //

                goto cleanup;
            }
        }
    }
    else
    {
        hr = E_FAIL;
        goto cleanup;
    }

cleanup:

    if(SUCCEEDED(hr))
    {
        *lpfMapiRecip = lpAdrList->aEntries[0].rgPropVals[IMAPIRECIP].Value.b;
    }

    pFreePadrlist(lpAdrList);

    return hr;
}


HRESULT
HrGWResolveAddress(
    IN LPABCONT lpGalABCont,        // pointer to GAL container
    IN LPCSTR lpszAddress,          // pointer to proxy address
    OUT BOOL *lpfMapiRecip,         // MAPI recipient
    OUT ULONG *lpcbEntryID,         // count of bytes in entry ID
    OUT LPENTRYID *lppEntryID,      // pointer to entry ID
    OUT LPADRLIST *lpAdrList        // address list
    )
{
    HRESULT     hr          = NOERROR;
    HRESULT     hrT         = 0;
    SCODE       sc          = 0;
    LPFlagList  lpFlagList  = NULL;
    SPropValue  prop[2]     = {0};
    ULONG       cbEntryID   = 0;
    LPENTRYID   lpEntryID   = NULL;

    static const SizedSPropTagArray(2, rgPropTags) =
    { 2,
        {
            PR_ENTRYID,
            PR_SEND_RICH_INFO
        }
    };

    *lpfMapiRecip = FALSE;
    *lpcbEntryID  = 0;
    *lppEntryID   = NULL;
    *lpAdrList    = NULL;

    sc = MapiAllocateBuffer( CbNewFlagList(1), (LPVOID*)&lpFlagList);

    if(FAILED(sc))
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    lpFlagList->cFlags    = 1;
    lpFlagList->ulFlag[0] = MAPI_UNRESOLVED;

    hr = HrMAPICreateSizedAddressList(
        1,
        lpAdrList
        );
    if(FAILED(hr)) {
        goto cleanup;
    }

    prop[0].ulPropTag = PR_DISPLAY_NAME_A;
    prop[0].Value.lpszA = (LPSTR)lpszAddress;
    prop[1].ulPropTag = PR_RECIPIENT_TYPE;
    prop[1].Value.ul = MAPI_TO;

    hr = HrMAPISetAddressList(
        0,
        2,
        prop,
        *lpAdrList
        );
    if(FAILED(hr)) {
        goto cleanup;
    }

    hrT = lpGalABCont->ResolveNames(
        (LPSPropTagArray)&rgPropTags,
        0,
        *lpAdrList,
        lpFlagList
        );

    if(lpFlagList->ulFlag[0] != MAPI_RESOLVED)
    {
        if(lpFlagList->ulFlag[0] == MAPI_AMBIGUOUS)
        {
            hrT = MAPI_E_AMBIGUOUS_RECIP;
        }
        else
        {
            hrT = MAPI_E_NOT_FOUND;
        }
    }

    if(FAILED(hrT))
    {
        if(hrT == MAPI_E_NOT_FOUND)
        {
            hr = MAPI_E_NOT_FOUND;
        }
        else
        {
            hr = E_FAIL;
        }

        goto cleanup;
    }

    cbEntryID = (*lpAdrList)->aEntries[0].rgPropVals[0].Value.bin.cb;
    lpEntryID = (LPENTRYID)(*lpAdrList)->aEntries[0].rgPropVals[0].Value.bin.lpb;

    sc = MapiAllocateBuffer( cbEntryID, (LPVOID*)lppEntryID);

    if(FAILED(sc))
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    CopyMemory(*lppEntryID, lpEntryID, cbEntryID);
    *lpcbEntryID  = cbEntryID;
    *lpfMapiRecip = (*lpAdrList)->aEntries[0].rgPropVals[1].Value.b;

cleanup:

    MapiFreeBuffer(lpFlagList);

    return hr;
}


extern "C"
BOOL
MailMapiMessage(
    LPMAPISESSION   Session,
    LPWSTR          RecipientNameW,
    LPWSTR          MsgSubjectW,
    LPWSTR          MsgBodyW,
    LPWSTR          MsgAttachmentFileNameW,
    LPWSTR          MsgAttachmentTitleW,
    DWORD           MsgImportance,
    PULONG          ResultCode
    )

/*++

Routine Description:

    Mails a TIFF file to the addressbook recipient in the specified profile.

Arguments:

    TiffFileName            - Name of TIFF file to mail
    ProfileName             - Profile name to use
    ResultCode              - The result of the failed API call

Return Value:

    TRUE for success, FALSE on error

--*/

{
    ULONG               cbInEntryID = 0;
    LPENTRYID           lpInEntryID = NULL;
    LPMDB               Store       = NULL;
    ULONG               lpulObjType;
    LPMAPIFOLDER        Inbox       = NULL;
    LPMAPIFOLDER        Outbox      = NULL;
    LPMESSAGE           Message     = NULL;
    LPATTACH            Attach      = NULL;
    LPSTREAM            Stream      = NULL;
    ULONG               AttachmentNum;
    HRESULT             HResult     = 0;
    LPSTR               MsgAttachmentFileName = NULL;
    LPSTR               MsgAttachmentTitle = NULL;
    LPSTR               MsgBody = NULL;
    LPSTR               MsgSubject = NULL;
    LPSTR               BodyStrA = NULL;
    LPSTR               SubjectStrA = NULL;
    LPSTR               SenderStrA = NULL;
    LPSTR               LongFileNameA = NULL;
    LPSTR               RecipientName = NULL;
    DWORD               RenderingPosition = 0;
    LPADRBOOK           AddrBook;
    LPADRLIST           lpAddrList = NULL;
    ULONG               ulFlags = LOGOFF_PURGE;
    LPSPropProblemArray lppProblems;
    ULONG               cbGalEid = 0;
    LPENTRYID           lpGalEid = NULL;
    LPSTR               lpszProxyAddr = NULL;
    BOOL                fMapiRecip = FALSE;
    ULONG               ulObjType = 0;
    LPABCONT            lpGalABCont = NULL;
    ULONG               cbEntryID = 0;
    LPENTRYID           lpEntryID = NULL;
    SPropValue          spvAttachProps[5] = { 0 };
    SPropValue          spvMsgProps[5] = { 0 };
    CHAR                FileExt[_MAX_EXT];
    CHAR                FileName[MAX_PATH];
    HANDLE              hFile = INVALID_HANDLE_VALUE;


    _try {

        //
        // convert all of the strings to ansi strings
        //

        RecipientName = UnicodeStringToAnsiString( RecipientNameW );
        MsgSubject = UnicodeStringToAnsiString( MsgSubjectW );
        MsgBody = UnicodeStringToAnsiString( MsgBodyW );
        MsgAttachmentFileName = UnicodeStringToAnsiString( MsgAttachmentFileNameW );
        MsgAttachmentTitle = UnicodeStringToAnsiString( MsgAttachmentTitleW );


        HResult = Session->OpenAddressBook(
            0,
            NULL,
            AB_NO_DIALOG,
            &AddrBook
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        HResult = HrFindExchangeGlobalAddressList(
            AddrBook,
            &cbGalEid,
            &lpGalEid
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        HResult = AddrBook->OpenEntry(
            cbGalEid,
            lpGalEid,
            NULL,
            MAPI_DEFERRED_ERRORS,
            &ulObjType,
            (LPUNKNOWN FAR *)&lpGalABCont
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        HResult = HrGWResolveAddress(
            lpGalABCont,
            RecipientName,
            &fMapiRecip,
            &cbEntryID,
            &lpEntryID,
            &lpAddrList
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        //
        // Find the default message store
        //
        HResult = HrMAPIFindDefaultMsgStore(
            Session,
            &cbInEntryID,
            &lpInEntryID
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        //
        // Open it
        //
        HResult = Session->OpenMsgStore(
            (ULONG)0,
            cbInEntryID,
            lpInEntryID,
            NULL,
            MDB_NO_DIALOG | MDB_WRITE,
            &Store
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        MapiFreeBuffer(lpInEntryID);

        //
        // Find the outbox
        //
        HResult= HrMAPIFindOutbox(
            Store,
            &cbInEntryID,
            &lpInEntryID
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        //
        // Open it
        //
        HResult = Store->OpenEntry(
            cbInEntryID,
            lpInEntryID,
            NULL,
            MAPI_MODIFY | MAPI_DEFERRED_ERRORS,
            &lpulObjType,
            (LPUNKNOWN *) &Outbox
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        //
        // Create a message
        //
        HResult = Outbox->CreateMessage(
            NULL,
            0,
            &Message
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        HResult = Message->ModifyRecipients(
            0,
            lpAddrList
            );

        if(HR_FAILED(HResult)) {
            _leave;
        }

        //
        // Fill in message properties and set them
        //

        spvMsgProps[0].ulPropTag     = PR_SUBJECT;
        spvMsgProps[1].ulPropTag     = PR_MESSAGE_CLASS;
        spvMsgProps[2].ulPropTag     = PR_BODY;
        spvMsgProps[3].ulPropTag     = PR_IMPORTANCE;
        spvMsgProps[4].ulPropTag     = PR_DELETE_AFTER_SUBMIT;

        spvMsgProps[0].Value.lpszA   = MsgSubject;
        spvMsgProps[1].Value.lpszA   = "IPM.Note";
        spvMsgProps[2].Value.lpszA   = MsgBody;
        spvMsgProps[3].Value.ul      = MsgImportance;
        spvMsgProps[4].Value.ul      = TRUE;

        HResult = Message->SetProps(
            sizeof(spvMsgProps)/sizeof(SPropValue),
            (LPSPropValue) spvMsgProps,
            &lppProblems
            );
        if (HR_FAILED(HResult)) {
            _leave;
        }

        MapiFreeBuffer( lppProblems );

        if (MsgAttachmentFileName) {

            //
            // Create an attachment
            //

            HResult = Message->CreateAttach(
                NULL,
                0,
                &AttachmentNum,
                &Attach
                );
            if (HR_FAILED(HResult)) {
                _leave;
            }

            _splitpath( MsgAttachmentFileName, NULL, NULL, FileName, FileExt );
            strcat( FileName, FileExt );

            //
            // Fill in attachment properties and set them
            //

            if (!MsgAttachmentTitle) {
                MsgAttachmentTitle = FileName;
            }

            RenderingPosition = strlen(MsgBody);

            spvAttachProps[0].ulPropTag     = PR_RENDERING_POSITION;
            spvAttachProps[1].ulPropTag     = PR_ATTACH_METHOD;
            spvAttachProps[2].ulPropTag     = PR_ATTACH_LONG_FILENAME;
            spvAttachProps[3].ulPropTag     = PR_DISPLAY_NAME;
            spvAttachProps[4].ulPropTag     = PR_ATTACH_EXTENSION;

            spvAttachProps[0].Value.ul      = RenderingPosition;
            spvAttachProps[1].Value.ul      = ATTACH_BY_VALUE;
            spvAttachProps[2].Value.lpszA   = MsgAttachmentTitle;
            spvAttachProps[3].Value.lpszA   = MsgAttachmentTitle;
            spvAttachProps[4].Value.lpszA   = FileExt;

            HResult = Attach->SetProps(
                sizeof(spvAttachProps)/sizeof(SPropValue),
                (LPSPropValue) spvAttachProps,
                &lppProblems
                );
            if (HR_FAILED(HResult)) {
                _leave;
            }

            MapiFreeBuffer( lppProblems );

            //
            // Attach a data property to the attachment
            //

            HResult = Attach->OpenProperty(
                PR_ATTACH_DATA_BIN,
                &IID_IStream,
                0,
                MAPI_CREATE | MAPI_MODIFY,
                (LPUNKNOWN *) &Stream
                );
            if (HR_FAILED(HResult)) {
                _leave;
            }

            //
            // open the message attachment file
            //

            hFile = CreateFile(
                MsgAttachmentFileName,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
            if (hFile == INVALID_HANDLE_VALUE) {
                _leave;
            }

            //
            // Write the file to the data property
            //

            HResult = HrMAPIWriteFileToStream( hFile, Stream );
            if (HR_FAILED(HResult)) {
                _leave;
            }

            HResult = Attach->SaveChanges(
                FORCE_SAVE
                );
            if (HR_FAILED(HResult)) {
                _leave;
            }
        }

        //
        // mail the message
        //
        HResult = Message->SubmitMessage(
            0
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

        HResult = Store->StoreLogoff(
            &ulFlags
            );
        if(HR_FAILED(HResult)) {
            _leave;
        }

    }
    _finally {

        if (Store) {
            Store->Release();
        }
        if (Inbox) {
            Inbox->Release();
        }
        if (Message) {
            Message->Release();
        }
        if (Attach) {
            Attach->Release();
        }
        if (Stream) {
            Stream->Release();
        }
        if (AddrBook) {
            AddrBook->Release();
        }
        if (lpAddrList) {
            pFreePadrlist( lpAddrList );
        }

        if (lpEntryID) {
            MapiFreeBuffer( lpEntryID );
        }
        if (lpszProxyAddr) {
            MapiFreeBuffer( lpszProxyAddr );
        }
        if (lpInEntryID) {
            MapiFreeBuffer( lpInEntryID );
        }

        FreeString( MsgSubject );
        FreeString( MsgBody );
        FreeString( MsgAttachmentFileName );
        if (MsgAttachmentTitleW && MsgAttachmentTitle) {
            FreeString( MsgAttachmentTitle );
        }

        CloseHandle( hFile );
        goto exit;
    }
exit:
    *ResultCode = HResult;
    return HResult == 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\server\modem.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    modem.c

Abstract:

    This module provides access to modems.

Author:

    Wesley Witt (wesw) 22-Jan-1996


Revision History:

--*/




BOOL
SendModemCommand(
    HANDLE hFile,
    LPOVERLAPPED OverlappedWrite,
    LPSTR Command
    )

/*++

Routine Description:

    Sends an AT command to the modem.

Arguments:

    hFile       - File handle for the comm port.
    Command     - AT Command

Return Value:

    TRUE if the command is sent, FALSE otherwise

--*/

{
    DWORD Bytes;
    DWORD ec;


    if (!WriteFile(
        hFile,
        Command,
        strlen(Command),
        &Bytes,
        OverlappedWrite
        )) {

        //
        // the write failed
        //

        ec = GetLastError();

        if (ec == ERROR_IO_PENDING) {

            if (WaitForSingleObject( OverlappedWrite->hEvent, 10000 ) == WAIT_TIMEOUT) {
                //
                // write never completed
                //
                return FALSE;
            }

            if (!GetOverlappedResult( hFile, OverlappedWrite, &Bytes, FALSE )) {
                //
                // the write failed
                //
                return FALSE;
            }

        } else {

            return FALSE;

        }

    }

    return TRUE;
}


BOOL
ReceiveModemResponse(
    HANDLE hFile,
    LPOVERLAPPED OverlappedRead,
    LPSTR Response,
    DWORD ResponseSize
    )

/*++

Routine Description:

    Receives a response from a modem.

Arguments:

    hFile           - File handle for the comm port.
    Response        - Buffer to put the response into
    ResponseSize    - Size of the response buffer

Return Value:

    TRUE if the response is received, FALSE otherwise

--*/

{
    DWORD Bytes;
    DWORD ec;


    if (!ReadFile(
        hFile,
        Response,
        ResponseSize,
        &Bytes,
        OverlappedRead
        )) {

        //
        // the read failed
        //

        ec = GetLastError();

        if (ec == ERROR_IO_PENDING) {

            if (WaitForSingleObject( OverlappedRead->hEvent, 10000 ) == WAIT_TIMEOUT) {
                //
                // write never completed
                //
                return FALSE;
            }

            if (!GetOverlappedResult( hFile, OverlappedRead, &Bytes, FALSE )) {
                //
                // the write failed
                //
                return FALSE;
            }

        } else {

            return FALSE;

        }

    }

    Response[Bytes] = 0;

//  {
//      LPTSTR ResponseW = AnsiStringToUnicodeString( Response );
//      DebugPrint(( TEXT("bytes=%d, [%s]"), Bytes, ResponseW ));
//      MemFree( ResponseW );
//  }

    return TRUE;
}


BOOL
IsResponseOk(
    LPSTR Response
    )

/*++

Routine Description:

    Verifies that a modem response is positive,
    that it contains the string "OK"

Arguments:

    Response        - Modem response

Return Value:

    TRUE if the response is positive, FALSE otherwise

--*/

{
    Response = strchr( Response, 'O' );
    if (Response && Response[1] == 'K') {
        return TRUE;
    }

    return FALSE;
}


DWORD
GetModemClass(
    HANDLE hFile
    )

/*++

Routine Description:

    Determines the lowest FAX class that the modem
    connected to the requested port supports.

Arguments:

    PortName    - Communications port name.

Return Value:

    Class number.

--*/

{
    DWORD ModemClass = 0;
    DCB Dcb;
    CHAR Response[64];
    COMMTIMEOUTS cto;
    OVERLAPPED OverlappedRead;
    OVERLAPPED OverlappedWrite;


    ZeroMemory( &OverlappedRead, sizeof(OVERLAPPED) );
    ZeroMemory( &OverlappedWrite, sizeof(OVERLAPPED) );

    OverlappedRead.hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    OverlappedWrite.hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    if (!GetCommState( hFile, &Dcb )) {
        goto exit;
    }

    Dcb.BaudRate     = CBR_2400;
    Dcb.fDtrControl  = DTR_CONTROL_ENABLE;
    Dcb.fRtsControl  = RTS_CONTROL_ENABLE;

    if (!SetCommState( hFile, &Dcb )) {
        goto exit;
    }

    cto.ReadIntervalTimeout         = 1000;
    cto.ReadTotalTimeoutMultiplier  = 0;
    cto.ReadTotalTimeoutConstant    = 4 * 1000;
    cto.WriteTotalTimeoutMultiplier = 0;
    cto.WriteTotalTimeoutConstant   = 4 * 1000;
    SetCommTimeouts( hFile, &cto );

    //
    // reset the modem
    //

    if (!SendModemCommand( hFile, &OverlappedWrite, "ATZ0\r" )) {
        goto exit;
    }

    if (!ReceiveModemResponse( hFile, &OverlappedRead, Response, sizeof(Response) )) {
        goto exit;
    }

    //
    // turn off echo
    //

    if (!SendModemCommand( hFile, &OverlappedWrite, "ATE0\r" )) {
        goto exit;
    }

    if (!ReceiveModemResponse( hFile, &OverlappedRead, Response, sizeof(Response) )) {
        goto exit;
    }

    //
    // H0    - go on hook
    // Q0    - enable modem responses
    // V1    - verbal modem responses (ok, error, etc)
    //

    if (!SendModemCommand( hFile, &OverlappedWrite, "ATH0Q0V1\r" )) {
        goto exit;
    }

    if (!ReceiveModemResponse( hFile, &OverlappedRead, Response, sizeof(Response) )) {
        goto exit;
    }

    if (!IsResponseOk( Response )) {
        goto exit;
    }

    if (!SendModemCommand( hFile, &OverlappedWrite, "AT+FCLASS=?\r" )) {
        goto exit;
    }

    if (!ReceiveModemResponse( hFile, &OverlappedRead, Response, sizeof(Response) )) {
        goto exit;
    }

    if (!IsResponseOk( Response )) {
        DebugPrint(( TEXT("bad modem response #2 [%s]"), Response ));
        goto exit;
    }

    if (strchr( Response, '1' )) {
        ModemClass = 1;
    } else if (strchr( Response, '2' )) {
        ModemClass = 2;
    }

    if (!SendModemCommand( hFile, &OverlappedWrite, "AT+FAE=1\r" )) {
        goto exit;
    }

    if (!ReceiveModemResponse( hFile, &OverlappedRead, Response, sizeof(Response) )) {
        goto exit;
    }

exit:
    CloseHandle( OverlappedRead.hEvent );
    CloseHandle( OverlappedWrite.hEvent );

    if (ModemClass == 0) {
        DebugPrint(( TEXT("Could not detect modem class") ));
    }

    return ModemClass;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\server\profinfo.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    profinfo.h

Abstract:

    This header file declares the structure used to do mapi logon's

Author:

    George Jenkins (georgeje) 10-8-1996


Revision History:

--*/

typedef struct _PROFILE_INFO {
    LIST_ENTRY          ListEntry;                  // linked list pointers
    WCHAR               ProfileName[64];            // mapi profile name
    LPVOID              Session;                    // opened session handle
    CRITICAL_SECTION    CsSession;                  // synchronization object for this session handle
    HANDLE              EventHandle;                // event to set after logging on
    BOOL                UseMail;
} PROFILE_INFO, *PPROFILE_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\server\queue.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    queue.c

Abstract:

    This module implements the jobqueue

Author:

    Wesley Witt (wesw) 22-Jan-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop

#if DBG
VOID
DebugPrintDateTime(
    LPTSTR Heading,
    DWORDLONG DateTime
    )
{
    SYSTEMTIME SystemTime;
    TCHAR DateBuffer[256];
    TCHAR TimeBuffer[256];

    FileTimeToSystemTime( (LPFILETIME) &DateTime, &SystemTime );
    
    GetDateFormat(
        LOCALE_SYSTEM_DEFAULT,
        0,
        &SystemTime,
        NULL,
        DateBuffer,
        sizeof(TimeBuffer)
        );
        
    GetTimeFormat(
        LOCALE_SYSTEM_DEFAULT,
        0,
        &SystemTime,
        NULL,
        TimeBuffer,
        sizeof(TimeBuffer)
        );

    if (Heading) {
        DebugPrint((TEXT("%s %s %s (GMT)"), Heading, DateBuffer, TimeBuffer));    
    } else {
        DebugPrint((TEXT("%s %s (GMT)"), DateBuffer, TimeBuffer));    
    }
    
}

#define PrintJobQueue( str, Queue ) \
    {   \
        PLIST_ENTRY Next;   \
        PJOB_QUEUE QueueEntry;  \
                               \
        Next = (Queue).Flink; \
        if ((ULONG_PTR)Next == (ULONG_PTR)&(Queue)) { \
            DebugPrint(( TEXT("Queue empty") ));    \
        } else {    \
            while ((ULONG_PTR)Next != (ULONG_PTR)&(Queue)) {    \
                QueueEntry = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );   \
                Next = QueueEntry->ListEntry.Flink; \
                DebugPrint(( \
                    TEXT("'%s' JobId = %d JobType = %d ScheduleAction = %d ScheduleTime = "), \
                    (str),  \
                    QueueEntry->JobId,  \
                    QueueEntry->JobType,    \
                    QueueEntry->JobParams.ScheduleAction   \
                    ));   \
                DebugPrintDateTime( NULL, QueueEntry->ScheduleTime );   \
            }   \
        }   \
    }
                
#else
#define PrintJobQueue( str, Queue )
#define DebugPrintDateTime( Heading, DateTime )
#endif

extern ULONG        ConnectionCount;
extern BOOL         RoutingIsInitialized;

LIST_ENTRY          QueueListHead;
LIST_ENTRY          RescheduleQueueHead;

CRITICAL_SECTION    CsQueue;
DWORD               QueueCount;
BOOL                QueuePaused;
HANDLE              QueueTimer;
HANDLE              IdleTimer;
HANDLE              JobQueueSemaphore = INVALID_HANDLE_VALUE;
DWORD               JobQueueTrips;
DWORD               SemaphoreSignaled;

VOID
StartIdleTimer(
    VOID
    )
{
    LARGE_INTEGER DueTime;


    if (TerminationDelay == (DWORD)-1) {
        return;
    }

    DueTime.QuadPart = -(LONGLONG)(SecToNano( TerminationDelay ));

    SetWaitableTimer( IdleTimer, &DueTime, 0, NULL, NULL, FALSE );
}


VOID
StopIdleTimer(
    VOID
    )
{
    CancelWaitableTimer( IdleTimer );
}


LARGE_INTEGER LastDueTime;

VOID
StartJobQueueTimer(
    PJOB_QUEUE JobQueue
    )
{
    PLIST_ENTRY Next;
    PJOB_QUEUE QueueEntry;
    SYSTEMTIME CurrentTime;
    LARGE_INTEGER DueTime;
    BOOL Found = FALSE;


    EnterCriticalSection( &CsQueue );

    if ((ULONG_PTR) QueueListHead.Flink == (ULONG_PTR) &QueueListHead) {
        //
        // empty list, cancel the timer
        //
        CancelWaitableTimer( QueueTimer );
        LastDueTime.QuadPart = 0;
        StartIdleTimer();
        LeaveCriticalSection( &CsQueue );
        return;
    }

    if (!JobQueue) {
        if (QueuePaused) {
            CancelWaitableTimer( QueueTimer );
            LastDueTime.QuadPart = 0;
            LeaveCriticalSection( &CsQueue );
            return;
        }

        PrintJobQueue( TEXT("StartJobQueueTimer"), QueueListHead );

        //
        // set the timer so that the job will get started
        //

        Next = QueueListHead.Flink;
        while ((ULONG_PTR)Next != (ULONG_PTR)&QueueListHead) {
            QueueEntry = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
            Next = QueueEntry->ListEntry.Flink;
            
            if (QueueEntry->JobType == JT_ROUTING && QueueEntry->SendRetries < FaxSendRetries ) {

                Found = TRUE;
                break;
            }

            //
            // Don't bother setting the queue timer if we have any jobs in the NOLINE state
            // we should just wait for the job queue semaphore to get set, which will allow
            // those jobs to be sent.  
            //
            //BUGBUG: You can get into the NO_LINE case if you already have a device sending 
            // to the number you want to send to.  So some jobs will not get serviced until
            // that job completes, and there can be a situation where not all of the lines
            // are being used.  This case should be rare, however, and is better than 
            // having the queue scheduler constantly getting signalled when no practical 
            // work can be completed
            //
            if (QueueEntry->JobType == JT_SEND && (QueueEntry->JobStatus & JS_NOLINE)) {
                Found = FALSE;
                break;
            }
            
            if (
                QueueEntry->JobType == JT_SEND && 
                !(QueueEntry->JobStatus & (JS_NOLINE | JS_RETRIES_EXCEEDED)) &&
                QueueEntry->JobEntry == NULL && 
                QueueEntry->Paused == FALSE
                ) {
                    Found = TRUE;
                    break;
            }
        }

        if (!Found) {
            //
            // all jobs in the queue are paused
            //
            
            //
            // cause queue to get processed regularly so nothing gets stuck
            //
                
            GetSystemTime( &CurrentTime );
            SystemTimeToFileTime( &CurrentTime, (LPFILETIME)&DueTime.QuadPart );
            DueTime.QuadPart += SecToNano( (DWORDLONG) FaxSendRetryDelay ? (FaxSendRetryDelay * 60) : (2 * 60) );
            SetWaitableTimer( QueueTimer, &DueTime, 0, NULL, NULL, FALSE );
            
            LastDueTime = DueTime;
        
            LeaveCriticalSection( &CsQueue );
            return;        
        }
    
    } else {
        QueueEntry = JobQueue;
    }

    if (QueueEntry->BroadcastJob && QueueEntry->BroadcastOwner == NULL) {
        LeaveCriticalSection( &CsQueue );
        return;
    }

    switch (QueueEntry->JobParams.ScheduleAction) {
        case JSA_NOW:
            DueTime.QuadPart = -(LONGLONG)(SecToNano( 1 ));
            break;

        case JSA_SPECIFIC_TIME:
            DueTime.QuadPart = QueueEntry->ScheduleTime;
            break;

        case JSA_DISCOUNT_PERIOD:
            GetSystemTime( &CurrentTime );
            SetDiscountTime( &CurrentTime );
            SystemTimeToFileTime( &CurrentTime, (LPFILETIME)&QueueEntry->ScheduleTime );
            SystemTimeToFileTime( &CurrentTime, (LPFILETIME)&DueTime.QuadPart );
            break;
    }

    // send a handoff job immediately
    if (QueueEntry->DeviceId) {
        DueTime.QuadPart = -(LONGLONG)(SecToNano( 1 ));
    }

    SetWaitableTimer( QueueTimer, &DueTime, 0, NULL, NULL, FALSE );

    LastDueTime = DueTime;

    DebugPrint(( TEXT("Scheduling JobId %d at "), QueueEntry->JobId ));
    DebugPrintDateTime( NULL, DueTime.QuadPart );
    
    LeaveCriticalSection( &CsQueue );
}




int
__cdecl
QueueCompare(
    const void *arg1,
    const void *arg2
    )
{        
    if (((PQUEUE_SORT)arg1)->ScheduleTime < ((PQUEUE_SORT)arg2)->ScheduleTime) {
        return -1;
    }
    if (((PQUEUE_SORT)arg1)->ScheduleTime > ((PQUEUE_SORT)arg2)->ScheduleTime) {
        return 1;
    }
    return 0;
}


VOID
SortJobQueue(
    VOID
    )
/*++

Routine Description:

    Sorts the job queue list, ostensibly because the discount rate time has changed.       

Arguments:

    none.
    
Return Value:

    none. modifies JobQueue linked list.

--*/
{
    DWORDLONG DiscountTime;
    SYSTEMTIME CurrentTime;
    PLIST_ENTRY Next;
    PJOB_QUEUE QueueEntry;    
    DWORD JobCount=0, i = 0;
    BOOL SortNeeded = FALSE;
    PQUEUE_SORT QueueSort;


    GetSystemTime( &CurrentTime );
    SetDiscountTime( &CurrentTime );
    SystemTimeToFileTime( &CurrentTime, (LPFILETIME)&DiscountTime );    
    
    
    EnterCriticalSection( &CsQueue );

    Next = QueueListHead.Flink;

    while ((ULONG_PTR)Next != (ULONG_PTR)&QueueListHead) {
        QueueEntry = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = QueueEntry->ListEntry.Flink;
        JobCount++;
        if (!SortNeeded && QueueEntry->JobParams.ScheduleAction != JSA_NOW) {
            SortNeeded = TRUE;
        }
    }

    //
    // optimization...if there are no jobs, or if there aren't any jobs with a
    // schedule time then we don't need to sort anything
    //
    if (!SortNeeded) {
        goto exit;
    }

    Assert( JobCount != 0 );
                             
    QueueSort = MemAlloc (JobCount * sizeof(QUEUE_SORT));
    if (!QueueSort) {
        goto exit;
    }

    Next = QueueListHead.Flink;

    while ((ULONG_PTR)Next != (ULONG_PTR)&QueueListHead) {
        QueueEntry = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = QueueEntry->ListEntry.Flink;
        
        QueueSort[i].ScheduleTime   = QueueEntry->ScheduleTime;
        QueueSort[i].QueueEntry     = QueueEntry;

        if (QueueEntry->JobParams.ScheduleAction == JSA_DISCOUNT_PERIOD) {
            QueueEntry->ScheduleTime = DiscountTime;
        }

        i += 1;
    }

    Assert (i == JobCount);
    
    qsort(
    (PVOID)QueueSort,
    (int)JobCount,
    sizeof(QUEUE_SORT),
    QueueCompare
    );

    InitializeListHead(&QueueListHead);
    
    for (i = 0; i < JobCount; i++) {
        QueueSort[i].QueueEntry->ListEntry.Flink = QueueSort[i].QueueEntry->ListEntry.Blink = NULL;
        InsertTailList( &QueueListHead, &QueueSort[i].QueueEntry->ListEntry );
    }

    MemFree( QueueSort );
        
exit:

    LeaveCriticalSection( &CsQueue );
}


VOID
PauseServerQueue(
    VOID
    )
{
    EnterCriticalSection( &CsQueue );
    if (QueuePaused) {
        LeaveCriticalSection( &CsQueue );
        return;
    }
    QueuePaused = TRUE;
    CancelWaitableTimer( QueueTimer );
    LastDueTime.QuadPart = 0;
    LeaveCriticalSection( &CsQueue );
}


VOID
ResumeServerQueue(
    VOID
    )
{
    EnterCriticalSection( &CsQueue );
    if (!QueuePaused) {
        LeaveCriticalSection( &CsQueue );
        return;
    }
    QueuePaused = FALSE;
    StartJobQueueTimer( NULL );
    LeaveCriticalSection( &CsQueue );
}


BOOL
RestoreFaxQueue(
    VOID
    )
{
    PLIST_ENTRY Next;
    PJOB_QUEUE_FILE JobQueueFile;
    PJOB_QUEUE JobQueue;
    WIN32_FIND_DATA FindData;
    HANDLE hFind;
    WCHAR FileName[MAX_PATH];
    HANDLE hFile;
    DWORD Size;
    FAX_JOB_PARAMW JobParams;
    PJOB_QUEUE JobQueueBroadcast;
    DWORD i;
    PGUID Guid;
    LPTSTR FaxRouteFileName;
    PFAX_ROUTE_FILE FaxRouteFile;
    WCHAR FullPathName[MAX_PATH];
    LPWSTR fnp;

    BOOL bAnyFailed = FALSE;


    _stprintf( FileName, TEXT("%s\\*.fqe"), FaxQueueDir );

    hFind = FindFirstFile( FileName, &FindData );
    if (hFind == INVALID_HANDLE_VALUE) {
        //
        // succeed at doing nothing
        //
        return TRUE;
    }

    do {
        _stprintf( FileName, TEXT("%s\\%s"), FaxQueueDir, FindData.cFileName );

        hFile = CreateFile(
            FileName,
            GENERIC_READ,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        if (hFile == INVALID_HANDLE_VALUE) {
            bAnyFailed = TRUE;
            continue;
        }

        Size = GetFileSize( hFile, NULL );
        if (Size < sizeof(JOB_QUEUE_FILE) ) {
           //
           // we've got some funky downlevel file, let's skip it rather than choke on it.
           //
           CloseHandle( hFile );
           DeleteFile( FileName );
           bAnyFailed = TRUE;
           continue;
        }

        JobQueueFile = (PJOB_QUEUE_FILE) MemAlloc( Size );
        if (!JobQueueFile) {
            bAnyFailed = TRUE;
            CloseHandle( hFile );
            continue;
        }

        if (!ReadFile( hFile, JobQueueFile, Size, &Size, NULL )) {
            bAnyFailed = TRUE;
            CloseHandle( hFile );
            MemFree( JobQueueFile );
            continue;
        }

        CloseHandle( hFile );

        FixupString(JobQueueFile, JobQueueFile->FileName);
        
        FixupString(JobQueueFile, JobQueueFile->QueueFileName);

        FixupString(JobQueueFile, JobQueueFile->UserName);

        FixupString(JobQueueFile, JobQueueFile->RecipientNumber);

        FixupString(JobQueueFile, JobQueueFile->RecipientName);

        FixupString(JobQueueFile, JobQueueFile->Tsid);

        FixupString(JobQueueFile, JobQueueFile->SenderName);

        FixupString(JobQueueFile, JobQueueFile->SenderCompany);

        FixupString(JobQueueFile, JobQueueFile->SenderDept);

        FixupString(JobQueueFile, JobQueueFile->BillingCode);

        FixupString(JobQueueFile, JobQueueFile->DeliveryReportAddress);

        FixupString(JobQueueFile, JobQueueFile->DocumentName);

        if (GetFileAttributes(JobQueueFile->FileName)==0xFFFFFFFF) {
            DebugPrint(( TEXT("fqe file pointing to missing .tif file\n") ));
            bAnyFailed = TRUE;
            CloseHandle( hFile );
            DeleteFile( FileName );
            MemFree( JobQueueFile );
            continue;
        }

        JobParams.SizeOfStruct           = sizeof(FAX_JOB_PARAM);
        JobParams.RecipientNumber        = JobQueueFile->RecipientNumber;
        JobParams.RecipientName          = JobQueueFile->RecipientName;
        JobParams.Tsid                   = JobQueueFile->Tsid;
        JobParams.SenderName             = JobQueueFile->SenderName;
        JobParams.SenderCompany          = JobQueueFile->SenderCompany;
        JobParams.SenderDept             = JobQueueFile->SenderDept;
        JobParams.BillingCode            = JobQueueFile->BillingCode;
        JobParams.ScheduleAction         = JobQueueFile->ScheduleAction;
        JobParams.DeliveryReportType     = JobQueueFile->DeliveryReportType;
        JobParams.DeliveryReportAddress  = JobQueueFile->DeliveryReportAddress;
        JobParams.DocumentName           = JobQueueFile->DocumentName;
        JobParams.CallHandle             = 0;
        JobParams.Reserved[0]            = 0;
        JobParams.Reserved[1]            = 0;
        JobParams.Reserved[2]            = 0;


        if (JobQueueFile->ScheduleTime == 0) {
            ZeroMemory( &JobParams.ScheduleTime, sizeof(SYSTEMTIME) );
        } else {
            FileTimeToSystemTime( (LPFILETIME)&JobQueueFile->ScheduleTime, &JobParams.ScheduleTime );
        }

        JobQueue = AddJobQueueEntry(
            JobQueueFile->JobType,
            JobQueueFile->FileName,
            &JobParams,
            JobQueueFile->UserName,
            FALSE,
            NULL
            );

        if (!JobQueue) {
            bAnyFailed = TRUE;
            MemFree( JobQueueFile );
            continue;
        }
        
      
        JobQueue->PageCount = JobQueueFile->PageCount;
        JobQueue->FileSize = JobQueueFile->FileSize;
        JobQueue->QueueFileName = StringDup( FileName );
        JobQueue->UniqueId = JobQueueFile->UniqueId;
        JobQueue->BroadcastJob = JobQueueFile->BroadcastJob;
        JobQueue->BroadcastOwnerUniqueId = JobQueueFile->BroadcastOwner;
        JobQueue->SendRetries = JobQueueFile->SendRetries;
        if (JobQueue->SendRetries >= FaxSendRetries) {
            JobQueue->JobStatus |= JS_RETRIES_EXCEEDED;
        }

        JobQueue->CountFailureInfo = JobQueueFile->CountFailureInfo;

        //
        // we don't necessarily allocate enough space for a job queue entry when we restore the fax queue
        // since the routing engine isn't initialized.  We add some more space here.  we have to patch up
        // the list entry members by hand
        if (JobQueue->CountFailureInfo > 1) {
             
             EnterCriticalSection( &CsQueue );
             RemoveEntryList( &JobQueue->ListEntry );
             
             JobQueue = MemReAlloc(
                            JobQueue, 
                            sizeof(JOB_QUEUE) + 
                            (sizeof(ROUTE_FAILURE_INFO) * (JobQueueFile->CountFailureInfo -1) ));

             if (!JobQueue) {
                 bAnyFailed = TRUE;
                 continue;
             }
             
             InitializeCriticalSection( &JobQueue->CsFileList );
             InitializeCriticalSection( &JobQueue->CsRoutingDataOverride );
             InitializeListHead( &JobQueue->RoutingDataOverride );
             InitializeListHead( &JobQueue->FaxRouteFiles );
             
             InsertTailList( &QueueListHead, &JobQueue->ListEntry );

             LeaveCriticalSection( &CsQueue );
             
        }
        //
        // handle the failure data, which must be alloc'd with LocalAlloc.
        //

        for (i = 0; i < JobQueue->CountFailureInfo; i++) {
            CopyMemory( 
                &JobQueue->RouteFailureInfo[i], 
                &JobQueueFile->RouteFailureInfo[i], 
                sizeof(ROUTE_FAILURE_INFO) 
                );

            JobQueue->RouteFailureInfo[i].FailureData = LocalAlloc(LPTR,
                                                                   JobQueueFile->RouteFailureInfo[i].FailureSize);
            
            if (JobQueue->RouteFailureInfo[i].FailureData) {
               CopyMemory( 
                JobQueue->RouteFailureInfo[i].FailureData,
                (LPBYTE) JobQueueFile + (ULONG_PTR) JobQueueFile->RouteFailureInfo[i].FailureData,
                JobQueueFile->RouteFailureInfo[i].FailureSize
                );               
               
            } else {
                bAnyFailed = TRUE;
            }
            
        }
        
        if (JobQueueFile->FaxRoute) {
            JobQueue->FaxRoute = MemAlloc( JobQueueFile->FaxRouteSize );
    
            if (JobQueue->FaxRoute) {
                CopyMemory(
                    JobQueue->FaxRoute,
                    (LPBYTE) JobQueueFile + (ULONG_PTR) JobQueueFile->FaxRoute,
                    JobQueueFile->FaxRouteSize
                    );
                
                JobQueue->FaxRoute = DeSerializeFaxRoute( JobQueue->FaxRoute );   
                if (JobQueue->FaxRoute) {
                    JobQueue->FaxRoute->JobId = JobQueue->JobId;
                } else {
                    bAnyFailed = TRUE;
                }
            } else {
                bAnyFailed = TRUE;
            }
        }

        Guid = (PGUID) (((LPBYTE) JobQueueFile) + JobQueueFile->FaxRouteFileGuid);
        FaxRouteFileName = (LPTSTR) (((LPBYTE) JobQueueFile) + JobQueueFile->FaxRouteFiles);

        for (i = 0; i < JobQueueFile->CountFaxRouteFiles; i++) {
            if (GetFullPathName( FaxRouteFileName, sizeof(FullPathName)/sizeof(WCHAR), FullPathName, &fnp )) {
                FaxRouteFile = (PFAX_ROUTE_FILE) MemAlloc( sizeof(FAX_ROUTE_FILE) );
                
                if (FaxRouteFile) {

                    FaxRouteFile->FileName = StringDup( FullPathName );
                
                    CopyMemory( &FaxRouteFile->Guid, &Guid, sizeof(GUID) );
                
                    InsertTailList( &JobQueue->FaxRouteFiles, &FaxRouteFile->ListEntry );
                    
                    JobQueue->CountFaxRouteFiles += 1;
                } else {
                    bAnyFailed = TRUE;
                }
            }
        
            Guid++;
            
            while(*FaxRouteFileName++)
                ;
        }
        
        MemFree( JobQueueFile );

    } while(FindNextFile( hFind, &FindData ));

    FindClose( hFind );
    
    //
    // fixup the broadcast pointers
    //

    Next = QueueListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&QueueListHead) {
        JobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = JobQueue->ListEntry.Flink;
        if (JobQueue->BroadcastJob) {
            if (JobQueue->BroadcastOwnerUniqueId) {
                JobQueueBroadcast = FindJobQueueEntryByUniqueId( JobQueue->BroadcastOwnerUniqueId );
                if (JobQueueBroadcast) {
                    JobQueue->BroadcastOwner = JobQueueBroadcast;
                    JobQueueBroadcast->BroadcastCount += 1;

                } else {
                    JobQueue->BroadcastOwner = NULL;
                }
            }
        }
    }

    PrintJobQueue( TEXT("RestoreFaxQueue"), QueueListHead );

    return bAnyFailed ? FALSE : TRUE;
}


BOOL
CommitQueueEntry(
    PJOB_QUEUE JobQueue,
    LPTSTR QueueFileName,
    DWORDLONG UniqueId
    )
{
    HANDLE hFile;
    DWORD Size = 0;
    PJOB_QUEUE_FILE JobQueueFile;
    ULONG_PTR Offset;
    DWORD i;
    PFAX_ROUTE FaxRoute = NULL;
    DWORD RouteSize;
    PLIST_ENTRY Next;
    PFAX_ROUTE_FILE FaxRouteFile;
    BOOL rVal = TRUE;

    hFile = CreateFile(
        QueueFileName,
        GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
        NULL
        );
    if (hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // calculate the size
    //

    Size = sizeof(JOB_QUEUE_FILE);

    Size += StringSize( JobQueue->FileName );
    Size += StringSize( JobQueue->QueueFileName );
    Size += StringSize( JobQueue->UserName );
    Size += StringSize( JobQueue->JobParams.RecipientNumber );
    Size += StringSize( JobQueue->JobParams.RecipientName );
    Size += StringSize( JobQueue->JobParams.Tsid );
    Size += StringSize( JobQueue->JobParams.SenderName );
    Size += StringSize( JobQueue->JobParams.SenderCompany );
    Size += StringSize( JobQueue->JobParams.SenderDept );
    Size += StringSize( JobQueue->JobParams.BillingCode );
    Size += StringSize( JobQueue->JobParams.DocumentName );
    Size += StringSize( JobQueue->DeliveryReportAddress );
    
    for (i = 0; i < JobQueue->CountFailureInfo; i++) {
        
        Size += JobQueue->RouteFailureInfo[i].FailureSize;
        
        if (i > 0) {        // Allocate more space if it's not the first one
            Size += sizeof(ROUTE_FAILURE_INFO);
        }
    }
    
    Next = JobQueue->FaxRouteFiles.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&JobQueue->FaxRouteFiles) {
        FaxRouteFile = CONTAINING_RECORD( Next, FAX_ROUTE_FILE, ListEntry );
        Next = FaxRouteFile->ListEntry.Flink;
        Size += sizeof(GUID);
        Size += StringSize( FaxRouteFile->FileName );
    }
    
    if (JobQueue->JobType == JT_ROUTING) {
        FaxRoute = SerializeFaxRoute( JobQueue->FaxRoute, &RouteSize );
        Size += RouteSize;
    }
    
    JobQueueFile = (PJOB_QUEUE_FILE) MemAlloc( Size );
    
    if (!JobQueueFile) {
        CloseHandle( hFile );
        DeleteFile( QueueFileName );
        return FALSE;
    }

    ZeroMemory( JobQueueFile, Size );

    Offset = sizeof(JOB_QUEUE_FILE);
    
    if (JobQueue->CountFailureInfo) {
        
        Offset += sizeof(ROUTE_FAILURE_INFO) * (JobQueue->CountFailureInfo - 1);
    
    }

    JobQueueFile->SizeOfStruct = sizeof(JOB_QUEUE_FILE);
    JobQueueFile->JobType = JobQueue->JobType;
    JobQueueFile->PageCount = JobQueue->PageCount;
    JobQueueFile->FileSize = JobQueue->FileSize;
    JobQueueFile->DeliveryReportType = JobQueue->DeliveryReportType;
    JobQueueFile->ScheduleAction = JobQueue->JobParams.ScheduleAction;
    JobQueueFile->ScheduleTime = JobQueue->ScheduleTime;
    JobQueueFile->SendRetries = JobQueue->SendRetries;
    JobQueueFile->BroadcastJob = JobQueue->BroadcastJob;
    JobQueueFile->UniqueId = JobQueue->UniqueId;
    

    if (JobQueue->BroadcastJob && JobQueue->BroadcastOwner) {
        JobQueueFile->BroadcastOwner = JobQueue->BroadcastOwner->UniqueId;
    }

    StoreString(
        JobQueue->QueueFileName,
        (PULONG_PTR)&JobQueueFile->QueueFileName,
        (LPBYTE)JobQueueFile,
        &Offset
        );

    StoreString(
        JobQueue->FileName,
        (PULONG_PTR)&JobQueueFile->FileName,
        (LPBYTE)JobQueueFile,
        &Offset
        );

    StoreString(
        JobQueue->UserName,
        (PULONG_PTR)&JobQueueFile->UserName,
        (LPBYTE)JobQueueFile,
        &Offset
        );

    StoreString(
        JobQueue->DeliveryReportAddress,
        (PULONG_PTR)&JobQueueFile->DeliveryReportAddress,
        (LPBYTE)JobQueueFile,
        &Offset
        );

    StoreString(
        JobQueue->JobParams.RecipientNumber,
        (PULONG_PTR)&JobQueueFile->RecipientNumber,
        (LPBYTE)JobQueueFile,
        &Offset
        );

    StoreString(
        JobQueue->JobParams.RecipientName,
        (PULONG_PTR)&JobQueueFile->RecipientName,
        (LPBYTE)JobQueueFile,
        &Offset
        );

    StoreString(
        JobQueue->JobParams.Tsid,
        (PULONG_PTR)&JobQueueFile->Tsid,
        (LPBYTE)JobQueueFile,
        &Offset
        );

    StoreString(
        JobQueue->JobParams.SenderName,
        (PULONG_PTR)&JobQueueFile->SenderName,
        (LPBYTE)JobQueueFile,
        &Offset
        );

    StoreString(
        JobQueue->JobParams.SenderCompany,
        (PULONG_PTR)&JobQueueFile->SenderCompany,
        (LPBYTE)JobQueueFile,
        &Offset
        );

    StoreString(
        JobQueue->JobParams.SenderDept,
        (PULONG_PTR)&JobQueueFile->SenderDept,
        (LPBYTE)JobQueueFile,
        &Offset
        );

    StoreString(
        JobQueue->JobParams.BillingCode,
        (PULONG_PTR)&JobQueueFile->BillingCode,
        (LPBYTE)JobQueueFile,
        &Offset
        );

    StoreString(
        JobQueue->JobParams.DocumentName,
        (PULONG_PTR)&JobQueueFile->DocumentName,
        (LPBYTE)JobQueueFile,
        &Offset
        );

    if (FaxRoute) {
        
        JobQueueFile->CountFailureInfo = JobQueue->CountFailureInfo;
    
        for (i = 0; i < JobQueue->CountFailureInfo; i++) {
    
            CopyMemory(
                &JobQueueFile->RouteFailureInfo[i],
                &JobQueue->RouteFailureInfo[i],
                sizeof(ROUTE_FAILURE_INFO)
            );
           
            JobQueueFile->RouteFailureInfo[i].FailureData = (PVOID) Offset;
            
            //
            // protect ourselves since this comes from a routing extension that may be misbehaving
            //
            __try {
               CopyMemory( 
                   (LPBYTE) JobQueueFile + Offset, 
                   JobQueue->RouteFailureInfo[i].FailureData, 
                   JobQueue->RouteFailureInfo[i].FailureSize 
                   );
            } __except(EXCEPTION_EXECUTE_HANDLER) {

            }
        
            Offset += JobQueue->RouteFailureInfo[i].FailureSize;
        }
        
        JobQueueFile->FaxRoute = (PFAX_ROUTE) Offset;
    
        CopyMemory( 
            (LPBYTE) JobQueueFile + Offset, 
            FaxRoute, 
            RouteSize 
            );
    
        JobQueueFile->FaxRouteSize = RouteSize;
    
        Offset += RouteSize;
    }
    
    JobQueueFile->CountFaxRouteFiles = 0;
    
    Next = JobQueue->FaxRouteFiles.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&JobQueue->FaxRouteFiles) {
        DWORD TmpSize;

        FaxRouteFile = CONTAINING_RECORD( Next, FAX_ROUTE_FILE, ListEntry );
        Next = FaxRouteFile->ListEntry.Flink;
        
        CopyMemory( (LPBYTE) JobQueueFile + Offset, (LPBYTE) &FaxRouteFile->Guid, sizeof(GUID) );
        
        if (JobQueueFile->CountFaxRouteFiles == 0) {
            JobQueueFile->FaxRouteFileGuid = (ULONG)Offset;
        }
        
        Offset += sizeof(GUID);
        
        TmpSize = StringSize( FaxRouteFile->FileName );
        
        CopyMemory( (LPBYTE) JobQueueFile + Offset, FaxRouteFile->FileName, TmpSize );
        
        if (JobQueueFile->CountFaxRouteFiles == 0) {
            JobQueueFile->FaxRouteFiles = (ULONG)Offset;
        }
        
        Offset += TmpSize;
        
        JobQueueFile->CountFaxRouteFiles++;
    }

    if (!WriteFile( hFile, JobQueueFile, Size, &Size, NULL )) {
        DeleteFile( QueueFileName );
        rVal = FALSE;
    }

    CloseHandle( hFile );

    MemFree( JobQueueFile );

    return rVal;
}

VOID
RescheduleJobQueueEntry(
    IN PJOB_QUEUE JobQueue
    )
{
    FILETIME CurrentFileTime;
    LARGE_INTEGER NewTime;

    PLIST_ENTRY Next;
    PJOB_QUEUE QueueEntry;

    EnterCriticalSection( &CsQueue );
    
    RemoveEntryList( &JobQueue->ListEntry );

    GetSystemTimeAsFileTime( &CurrentFileTime );

    NewTime.LowPart = CurrentFileTime.dwLowDateTime;
    NewTime.HighPart = CurrentFileTime.dwHighDateTime;

    NewTime.QuadPart += SecToNano( (DWORDLONG)(FaxSendRetryDelay * 60) );
    
    JobQueue->ScheduleTime = NewTime.QuadPart;

    JobQueue->JobParams.ScheduleAction = JSA_SPECIFIC_TIME;

    //
    // insert the queue entry into the list in a sorted order
    //

    Next = QueueListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&QueueListHead) {
        QueueEntry = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = QueueEntry->ListEntry.Flink;
        if (JobQueue->ScheduleTime <= QueueEntry->ScheduleTime) {
            InsertTailList( &QueueEntry->ListEntry, &JobQueue->ListEntry );
            Next = NULL;
            break;
        }
    }
    if ((ULONG_PTR)Next == (ULONG_PTR)&QueueListHead) {
        InsertTailList( &QueueListHead, &JobQueue->ListEntry );
    }
    
    CommitQueueEntry( JobQueue, JobQueue->QueueFileName, JobQueue->UniqueId );
    
    DebugPrintDateTime( TEXT("Rescheduling JobId %d at"), JobQueue->JobId );

    StartJobQueueTimer( NULL );

    LeaveCriticalSection( &CsQueue );
}

PJOB_QUEUE
AddJobQueueEntry(
    IN DWORD JobType,
    IN LPCTSTR FileName,
    IN const FAX_JOB_PARAMW *JobParams,
    IN LPCWSTR UserName,
    IN BOOL CreateQueueFile,
    IN PJOB_ENTRY JobEntry                  // receive only
    )
{
    PLIST_ENTRY Next;
    PJOB_QUEUE JobQueue;
    PJOB_QUEUE JobQueueBroadcast;
    PJOB_QUEUE QueueEntry;
    WCHAR QueueFileName[MAX_PATH];
    HANDLE hTiff;
    TIFF_INFO TiffInfo;
    LPLINEDEVCAPS LineDevCaps;
    DWORD Size = sizeof(JOB_QUEUE);


    if (JobType == JT_RECEIVE || JobType == JT_ROUTING) {
       if (CountRoutingMethods > 1) {
          Size += (sizeof(ROUTE_FAILURE_INFO)*(CountRoutingMethods-1));          
       }
    } 
    
    JobQueue = MemAlloc( Size );
    if (!JobQueue) {
      return NULL;
    }
    
    ZeroMemory( JobQueue, Size );                   

    JobQueue->JobId                     = InterlockedIncrement( &NextJobId );
    JobQueue->FileName                  = StringDup( FileName );
    JobQueue->JobType                   = JobType;
    JobQueue->BroadcastCount            = 0;
    JobQueue->RefCount                  = 0;

    if (JobType != JT_RECEIVE && JobType != JT_FAIL_RECEIVE ) {
        JobQueue->UserName                  = StringDup( UserName );
        JobQueue->JobParams.SizeOfStruct    = JobParams->SizeOfStruct;
        JobQueue->JobParams.RecipientNumber = StringDup( JobParams->RecipientNumber );
        JobQueue->JobParams.RecipientName   = StringDup( JobParams->RecipientName );
        JobQueue->JobParams.Tsid            = StringDup( JobParams->Tsid );
        JobQueue->JobParams.SenderName      = StringDup( JobParams->SenderName );
        JobQueue->JobParams.SenderCompany   = StringDup( JobParams->SenderCompany );
        JobQueue->JobParams.SenderDept      = StringDup( JobParams->SenderDept );
        JobQueue->JobParams.BillingCode     = StringDup( JobParams->BillingCode );
        JobQueue->JobParams.DocumentName    = StringDup( JobParams->DocumentName );
        JobQueue->JobParams.ScheduleAction  = JobParams->ScheduleAction;
        JobQueue->JobParams.ScheduleTime    = JobParams->ScheduleTime;
        JobQueue->DeliveryReportAddress     = StringDup( JobParams->DeliveryReportAddress );
        JobQueue->DeliveryReportType        = JobParams->DeliveryReportType;
        JobQueue->JobStatus                 = JS_PENDING;
    } else {
        LPTSTR TempFileName = _tcsrchr( FileName, '\\' ) + 1;
        //JobQueue->DocumentName              = StringDup( GetString( (JobType == JT_RECEIVE) ? IDS_RECEIVE_DOCUMENT : IDS_RECEIVE_FAILURE ) );
        JobQueue->UserName                  = StringDup( GetString( IDS_SERVICE_NAME ) );
        JobQueue->JobParams.DocumentName    = StringDup( TempFileName );
        JobQueue->JobStatus                 = JS_INPROGRESS;
        JobQueue->JobEntry                  = JobEntry;
        JobQueue->JobEntry->JobId           = JobQueue->JobId;
    }

    InitializeListHead( &JobQueue->FaxRouteFiles );
    InitializeCriticalSection( &JobQueue->CsFileList );
    InitializeListHead( &JobQueue->RoutingDataOverride );
    InitializeCriticalSection( &JobQueue->CsRoutingDataOverride );
    
    if (JobType == JT_RECEIVE || JobType == JT_FAIL_RECEIVE) {
        EnterCriticalSection( &CsQueue );
        InsertHeadList( &QueueListHead, &JobQueue->ListEntry );
        LeaveCriticalSection( &CsQueue );

        QueueCount += 1;
        SetFaxJobNumberRegistry( NextJobId );
        
        return JobQueue;
    }
    
    if (JobParams->CallHandle) {
        DebugPrint((TEXT("getting permanent device id for deviceId %d\n"),JobParams->Reserved[2]));
        LineDevCaps = MyLineGetDevCaps ((DWORD)JobParams->Reserved[2]);
        if (LineDevCaps) {
            JobQueue->DeviceId = LineDevCaps->dwPermanentLineID;
            MemFree( LineDevCaps ) ;
        } else {
            MemFree( (LPBYTE) JobQueue->DeliveryReportAddress );
            MemFree( (LPBYTE) JobQueue->FileName );
            MemFree( (LPBYTE) JobQueue->UserName );
            MemFree( (LPBYTE) JobQueue->QueueFileName );
            MemFree( (LPBYTE) JobQueue->JobParams.RecipientNumber );
            MemFree( (LPBYTE) JobQueue->JobParams.RecipientName );
            MemFree( (LPBYTE) JobQueue->JobParams.Tsid );
            MemFree( (LPBYTE) JobQueue->JobParams.SenderName );
            MemFree( (LPBYTE) JobQueue->JobParams.SenderCompany );
            MemFree( (LPBYTE) JobQueue->JobParams.SenderDept );
            MemFree( (LPBYTE) JobQueue->JobParams.BillingCode );
            MemFree( (LPBYTE) JobQueue->JobParams.DeliveryReportAddress );
            MemFree( (LPBYTE) JobQueue->JobParams.DocumentName );
            MemFree( JobQueue );

            return NULL;
        }
    }
    

    if (JobParams->Reserved[0] == 0xfffffffe) {
        JobQueue->BroadcastJob = TRUE;
        if (JobParams->Reserved[1] == 2) {
            JobQueueBroadcast = FindJobQueueEntry( (DWORD)JobParams->Reserved[2] );
            if (JobQueueBroadcast == NULL) {
                MemFree( (LPBYTE) JobQueue->DeliveryReportAddress );
                MemFree( (LPBYTE) JobQueue->FileName );
                MemFree( (LPBYTE) JobQueue->UserName );
                MemFree( (LPBYTE) JobQueue->QueueFileName );
                MemFree( (LPBYTE) JobQueue->JobParams.RecipientNumber );
                MemFree( (LPBYTE) JobQueue->JobParams.RecipientName );
                MemFree( (LPBYTE) JobQueue->JobParams.Tsid );
                MemFree( (LPBYTE) JobQueue->JobParams.SenderName );
                MemFree( (LPBYTE) JobQueue->JobParams.SenderCompany );
                MemFree( (LPBYTE) JobQueue->JobParams.SenderDept );
                MemFree( (LPBYTE) JobQueue->JobParams.BillingCode );
                MemFree( (LPBYTE) JobQueue->JobParams.DeliveryReportAddress );
                MemFree( (LPBYTE) JobQueue->JobParams.DocumentName );
                MemFree( JobQueue );
                return NULL;
            }
            JobQueue->BroadcastOwner = JobQueueBroadcast;
            JobQueueBroadcast->BroadcastCount += 1;
        }
    }

    //
    // get the page count and file size  
    //

    if (FileName) {
        hTiff = TiffOpen( (LPWSTR) FileName, &TiffInfo, TRUE, FILLORDER_MSB2LSB );
        if (hTiff) {
            JobQueue->PageCount = TiffInfo.PageCount;
            TiffClose( hTiff );
            JobQueue->FileSize  = MyGetFileSize(FileName) ;
            
        }
    }

    if (JobQueue->DeliveryReportAddress && JobQueue->DeliveryReportType == DRT_INBOX) {
        JobQueue->DeliveryReportProfile = AddNewMapiProfile( JobQueue->DeliveryReportAddress, FALSE, FALSE );
    } else {
        JobQueue->DeliveryReportProfile = NULL;
    }

    if (JobQueue->JobParams.ScheduleAction == JSA_SPECIFIC_TIME) {
        SystemTimeToFileTime( &JobQueue->JobParams.ScheduleTime, (FILETIME*) &JobQueue->ScheduleTime );
    } else if (JobQueue->JobParams.ScheduleAction == JSA_DISCOUNT_PERIOD) {
        SYSTEMTIME CurrentTime;
        GetSystemTime( &CurrentTime );
        SetDiscountTime( &CurrentTime );
        SystemTimeToFileTime( &CurrentTime, (LPFILETIME)&JobQueue->ScheduleTime );
    }

    EnterCriticalSection( &CsQueue );

    if ((JobQueue->JobParams.ScheduleAction == JSA_NOW) || 
        ((ULONG_PTR) QueueListHead.Flink == (ULONG_PTR)&QueueListHead) || 
        (JobQueue->DeviceId != 0)) {

        //
        // just put it at the head of the list
        //


        InsertHeadList( &QueueListHead, &JobQueue->ListEntry );

    } else {

        //
        // insert the queue entry into the list in a sorted order
        //

        Next = QueueListHead.Flink;
        while ((ULONG_PTR)Next != (ULONG_PTR)&QueueListHead) {
            QueueEntry = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
            Next = QueueEntry->ListEntry.Flink;
            if (JobQueue->ScheduleTime <= QueueEntry->ScheduleTime) {
                InsertTailList( &QueueEntry->ListEntry, &JobQueue->ListEntry );
                Next = NULL;
                break;
            }
        }
        if ((ULONG_PTR)Next == (ULONG_PTR)&QueueListHead) {
            InsertTailList( &QueueListHead, &JobQueue->ListEntry );
        }
    }

    //
    // this is a persistent queue, so commit the data to a disk file
    //

    // don't commit a handoff job to the queue
    if (CreateQueueFile && JobQueue->DeviceId == 0) {
        JobQueue->UniqueId = GenerateUniqueFileName( FaxQueueDir, TEXT("fqe"), QueueFileName, sizeof(QueueFileName)/sizeof(WCHAR) );
        JobQueue->QueueFileName = StringDup( QueueFileName );
        CommitQueueEntry( JobQueue, QueueFileName, JobQueue->UniqueId );
    }

    DebugPrint(( TEXT("Added JobId %d"), JobQueue->JobId ));
    //
    // set the timer so that the job will get started
    //

    StartJobQueueTimer( NULL );

    LeaveCriticalSection( &CsQueue );

    QueueCount += 1;
    SetFaxJobNumberRegistry( NextJobId );

    StopIdleTimer();

    return JobQueue;
}


BOOL
RemoveJobQueueEntry(
    IN PJOB_QUEUE JobQueueEntry
    )
{
    PJOB_QUEUE JobQueue, JobQueueBroadcast = NULL;
    BOOL RemoveMasterBroadcast = FALSE;
    PROUTING_DATA_OVERRIDE  RoutingDataOverride;
    PFAX_ROUTE_FILE FaxRouteFile;
    PLIST_ENTRY Next;
    DWORD i, JobId;


    if (JobQueueEntry == NULL) {
        return TRUE;
    }

    EnterCriticalSection( &CsQueue );    

    __try {


        //
        // need to make sure that the job queue entry we want to remove
        // is still in the list of job queue entries
        //
        JobQueue = FindJobQueueEntryByJobQueueEntry( JobQueueEntry );

        if (JobQueue == NULL) {
            LeaveCriticalSection( &CsQueue );
            return TRUE;
        }
    
        DebugPrint(( TEXT("Removing JobId %d"), JobQueue->JobId ));
        JobId = JobQueue->JobId;
        
        if (JobQueue->RefCount == 0) {
            
        
            if (JobQueue->BroadcastJob && JobQueue->BroadcastOwner) {
                JobQueueBroadcast = JobQueue->BroadcastOwner;
                JobQueueBroadcast->BroadcastCount -= 1;
                if (JobQueueBroadcast->BroadcastCount == 0) {
                    RemoveMasterBroadcast = TRUE;
                }
            }
        
            RemoveEntryList( &JobQueue->ListEntry );
        
            CancelWaitableTimer( QueueTimer );
            StartJobQueueTimer( NULL );
        
            DebugPrint(( TEXT("Deleting QueueFileName %s\n"), JobQueue->QueueFileName ));
            DeleteFile( JobQueue->QueueFileName );
    
            DebugPrint(( TEXT("Deleting FileName %s\n"), JobQueue->FileName ));
            DeleteFile( JobQueue->FileName );        
        

            DebugPrint(( TEXT("Freeing JobQueue.JobParams...") ));
            MemFree( (LPBYTE) JobQueue->DeliveryReportAddress );
            MemFree( (LPBYTE) JobQueue->FileName );
            MemFree( (LPBYTE) JobQueue->UserName );
            MemFree( (LPBYTE) JobQueue->QueueFileName );
            
            MemFree( (LPBYTE) JobQueue->JobParams.RecipientNumber );
            MemFree( (LPBYTE) JobQueue->JobParams.RecipientName );
            MemFree( (LPBYTE) JobQueue->JobParams.Tsid );
            MemFree( (LPBYTE) JobQueue->JobParams.SenderName );
            MemFree( (LPBYTE) JobQueue->JobParams.SenderCompany );
            MemFree( (LPBYTE) JobQueue->JobParams.SenderDept );
            MemFree( (LPBYTE) JobQueue->JobParams.BillingCode );
            MemFree( (LPBYTE) JobQueue->JobParams.DeliveryReportAddress );
            MemFree( (LPBYTE) JobQueue->JobParams.DocumentName );
        
            if (JobQueue->FaxRoute) {
                PFAX_ROUTE FaxRoute = JobQueue->FaxRoute;
                DebugPrint(( TEXT("Freeing JobQueue.FaxRoute...") ));

                MemFree( (LPBYTE) FaxRoute->Csid );
                MemFree( (LPBYTE) FaxRoute->Tsid );
                MemFree( (LPBYTE) FaxRoute->CallerId );
                MemFree( (LPBYTE) FaxRoute->ReceiverName );
                MemFree( (LPBYTE) FaxRoute->ReceiverNumber );
                MemFree( (LPBYTE) FaxRoute->RoutingInfo );
                MemFree( (LPBYTE) FaxRoute );
            }
    
            //
            // walk the file list and remove any files
            //
        
            DebugPrint(( TEXT("Freeing JobQueue.FaxRouteFiles...") ));
            Next = JobQueue->FaxRouteFiles.Flink;
            if (Next != NULL) {
                while ((ULONG_PTR)Next != (ULONG_PTR)&JobQueue->FaxRouteFiles) {
                    FaxRouteFile = CONTAINING_RECORD( Next, FAX_ROUTE_FILE, ListEntry );
                    Next = FaxRouteFile->ListEntry.Flink;
                    DeleteFile( FaxRouteFile->FileName );
                    MemFree( FaxRouteFile->FileName );
                    MemFree( FaxRouteFile );
                }
            }
        
            //
            // walk the routing data override list and free all memory
            //
            DebugPrint(( TEXT("Freeing JobQueue.RoutingDataOverride...") ));
            Next = JobQueue->RoutingDataOverride.Flink;
            if (Next != NULL) {
                while ((ULONG_PTR)Next != (ULONG_PTR)&JobQueue->RoutingDataOverride) {
                    RoutingDataOverride = CONTAINING_RECORD( Next, ROUTING_DATA_OVERRIDE, ListEntry );
                    Next = RoutingDataOverride->ListEntry.Flink;
                    MemFree( RoutingDataOverride->RoutingData );
                    MemFree( RoutingDataOverride );
                }
            }
                    
            //
            // free any routing failure data
            //
            for (i =0; i<JobQueue->CountFailureInfo; i++) {
                DebugPrint(( TEXT("Freeing JobQueue.RouteFailureInfo...") ));
                if ( JobQueue->RouteFailureInfo[i].FailureData ) {
                    //
                    // memory was allocated with local alloc
                    //
                    __try {
                       LocalFree(JobQueue->RouteFailureInfo[i].FailureData);
                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                       DebugPrint(( TEXT("Couldn't LocalFree routing failure data, ec = %x\n"), GetExceptionCode() ));
                    }                                
                }
            }
    
        
            DebugPrint(( TEXT("Freeing JobQueue") ));
            MemFree( JobQueue );
    
            CreateFaxEvent(0, FEI_DELETED, JobId);
        
            QueueCount -= 1;
        
            if (RemoveMasterBroadcast) {
                RemoveJobQueueEntry( JobQueueBroadcast );
            }
        
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        DebugPrint(( TEXT("RemoveJobQueueEntry exception, ec = 0x%08x\n"), GetExceptionCode() ));
        Assert(FALSE);
    }

    LeaveCriticalSection( &CsQueue );

    return TRUE;
}


BOOL
PauseJobQueueEntry(
    IN PJOB_QUEUE JobQueue
    )
{
    EnterCriticalSection( &CsQueue );
    CancelWaitableTimer( QueueTimer );
    JobQueue->Paused = TRUE;
    JobQueue->JobStatus |= JS_PAUSED;
    StartJobQueueTimer( NULL );
    LeaveCriticalSection( &CsQueue );
    StartIdleTimer();
    return TRUE;
}


BOOL
ResumeJobQueueEntry(
    IN PJOB_QUEUE JobQueue
    )
{
    EnterCriticalSection( &CsQueue );
    CancelWaitableTimer( QueueTimer );
    JobQueue->Paused = FALSE;
    JobQueue->JobStatus &= ~JS_PAUSED;
    //
    // BugBug Should we allow "resume" of jobs whose retries have been exceeded?
    //        This would be like "restarting" the job.
    //
    StartJobQueueTimer( JobQueue );
    LeaveCriticalSection( &CsQueue );
    StopIdleTimer();
    return TRUE;
}


PJOB_QUEUE
FindJobQueueEntryByJobQueueEntry(
    IN PJOB_QUEUE JobQueueEntry
    )
{
    PLIST_ENTRY Next;
    PJOB_QUEUE JobQueue;


    Next = QueueListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&QueueListHead) {
        JobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = JobQueue->ListEntry.Flink;
        if ((ULONG_PTR)JobQueue == (ULONG_PTR)JobQueueEntry) {
            return JobQueue;
        }
    }

    return NULL;
}



PJOB_QUEUE
FindJobQueueEntry(
    DWORD JobId
    )
{
    PLIST_ENTRY Next;
    PJOB_QUEUE JobQueue;


    Next = QueueListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&QueueListHead) {
        JobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = JobQueue->ListEntry.Flink;
        if (JobQueue->JobId == JobId) {
            return JobQueue;
        }
    }

    return NULL;
}

PJOB_QUEUE
FindJobQueueEntryByUniqueId(
    DWORDLONG UniqueId
    )
{
    PLIST_ENTRY Next;
    PJOB_QUEUE JobQueue;


    Next = QueueListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&QueueListHead) {
        JobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = JobQueue->ListEntry.Flink;
        if (JobQueue->UniqueId == UniqueId) {
            return JobQueue;
        }
    }

    return NULL;
}


DWORD
JobQueueThread(
    LPVOID UnUsed
    )
{
    DWORD Rslt;
    SYSTEMTIME CurrentTime;
    DWORDLONG DueTime;
    PLIST_ENTRY Next;
    PJOB_QUEUE JobQueue;
    PJOB_ENTRY JobEntry;
    PLINE_INFO LineInfo;
    HANDLE Handles[3];
    HANDLE hLineMutex;
    WCHAR LineMutexName[64];
    DWORD WaitObject;
    WCHAR TempFile[MAX_PATH];
    static DWORDLONG DirtyDays = 0;
    BOOL InitializationOk = TRUE;

    QueueTimer = CreateWaitableTimer( NULL, FALSE, NULL );
    IdleTimer = CreateWaitableTimer( NULL, FALSE, NULL );
    JobQueueSemaphore = CreateSemaphore( NULL, 0, 1024, NULL );
    
    Handles[0] = IdleTimer;
    Handles[1] = QueueTimer;
    Handles[2] = JobQueueSemaphore;

    InitializeListHead( &RescheduleQueueHead );

    StartIdleTimer();

    __try{
      InitializationOk = RestoreFaxQueue();
    } __except (EXCEPTION_EXECUTE_HANDLER) {
      DebugPrint(( TEXT("RestoreFaxQueue() crashed, ec = %x\n"), GetExceptionCode() ));
      InitializationOk = FALSE;
    }

    if (!Handles[0] || !Handles[1] || !Handles[2]) {
        InitializationOk = FALSE;
    }

    if (!InitializationOk) {
        FaxLog(
                FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_NONE,
                0,
                MSG_QUEUE_INIT_FAILED
              );
    }

    //
    // sort the job queue just in case our discount time has changed for the restored jobs
    //
    SortJobQueue();

    while (TRUE) {

        WaitObject = WaitForMultipleObjects( 3, Handles, FALSE, INFINITE );
        if (WaitObject == WAIT_OBJECT_0) {
            
            if (ConnectionCount != 0) {
                StartIdleTimer();
                continue;
            } else {
                EndFaxSvc(TRUE,FAXLOG_LEVEL_MAX);                
            }

        }

        //
        // find the jobs that need servicing in the queue
        //

        JobQueueTrips++;

        EnterCriticalSection( &CsJob );
        EnterCriticalSection( &CsQueue );

        GetSystemTime( &CurrentTime );
        SystemTimeToFileTime( &CurrentTime, (LPFILETIME) &DueTime );

        if (WaitObject - WAIT_OBJECT_0 == 2) {
            SemaphoreSignaled++;
            DebugPrintDateTime( TEXT("Semaphore signaled at "), DueTime );
            
        } else {
            DebugPrintDateTime( TEXT("Timer signaled at "), DueTime );
        }
        
        PrintJobQueue( TEXT("JobQueueThread"), QueueListHead );

        Next = QueueListHead.Flink;
        while ((ULONG_PTR)Next != (ULONG_PTR)&QueueListHead) {
            JobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
            Next = JobQueue->ListEntry.Flink;

            if (JobQueue->Paused || JobQueue->JobType == JT_RECEIVE || JobQueue->JobType == JT_FAIL_RECEIVE) {
                continue;
            }

            if (JobQueue->JobStatus & JS_RETRIES_EXCEEDED){
                //
                // recalculate dirty days
                //
                if (FaxDirtyDays == (DWORD) -1) {
                    //
                    // this means disable dirty days functionality
                    //
                    DirtyDays = (DWORDLONG) -1;
                }
                else {
                    DirtyDays = FaxDirtyDays * 24I64 * 60I64 * 60I64 * 1000I64 * 1000I64 * 10I64;
                }

                if ( DirtyDays != (DWORDLONG)-1 && 
                     (JobQueue->ScheduleTime + DirtyDays < DueTime)){
                    
                    RemoveJobQueueEntry( JobQueue );
                                
                }
                
                continue;
            }
            
            if (JobQueue->JobType == JT_ROUTING) {
                DWORD i;
                BOOL Routed = TRUE;

                 
                if (JobQueue->ScheduleTime != 0 && DueTime < JobQueue->ScheduleTime){
                    continue;
                }
                
                if (!RoutingIsInitialized) {
                    
                    RemoveEntryList( &JobQueue->ListEntry );
                    
                    InsertTailList( &RescheduleQueueHead, &JobQueue->ListEntry );
                    
                    continue;
                }
                
                JobQueue->SendRetries++;
                JobQueue->JobStatus = JS_RETRYING ;

                for (i = 0; i < JobQueue->CountFailureInfo; i++) {

                    Routed &= FaxRouteRetry( JobQueue->FaxRoute, &JobQueue->RouteFailureInfo[i] );
                    
                }
                
                if ( Routed ) {
                    
                    RemoveJobQueueEntry( JobQueue );
                
                } else {
                
                    RemoveEntryList( &JobQueue->ListEntry );
                    
                    InsertTailList( &RescheduleQueueHead, &JobQueue->ListEntry );
                                        
                    if (JobQueue->SendRetries >= FaxSendRetries) {
                        //
                        // retries exceeded, mark job as expired
                        //
                        JobQueue->JobStatus = JS_RETRIES_EXCEEDED ;
                    }
                }

                continue;
            }

            //
            // outbound job
            //

            //
            // if the queue is paused or the job is already in progress, don't send it again
            //
            if (QueuePaused || ((JobQueue->JobStatus & JS_INPROGRESS) == JS_INPROGRESS)) {
                continue;
            }

            if (JobQueue->BroadcastJob && JobQueue->BroadcastOwner == NULL) {
                continue;
            }

            if (JobQueue->DeviceId || JobQueue->ScheduleTime == 0 || DueTime >= JobQueue->ScheduleTime) {

                //
                // start the job
                //
                if (JobQueue->DeviceId != 0) {

                    //
                    // we're doing a handoff job, create a mutex based on deviceId
                    //
                    DebugPrint((TEXT("Creating a handoff job for device %d\n"),JobQueue->DeviceId));
                    
                    wsprintf(LineMutexName,L"FaxLineHandoff%d",JobQueue->DeviceId);
                    
                    hLineMutex = CreateMutex(NULL,TRUE,LineMutexName);

                    if (!hLineMutex) {
                        DebugPrint((TEXT("CreateMutex failed, ec = %d\n"),GetLastError() ));
                        continue;
                    } 
                    else {
                        JobEntry = StartJob( JobQueue->DeviceId, JobQueue->JobType, (LPTSTR) JobQueue->JobParams.RecipientNumber );
                        // startjob will take ownership of the line
                        DebugPrint((TEXT("Signalling line ownership mutex \"FaxLineHandoff%d\""),JobQueue->DeviceId));
                        ReleaseMutex(hLineMutex);
                        CloseHandle(hLineMutex);
                        }
                } else {
                    JobEntry = StartJob( USE_SERVER_DEVICE, JobQueue->JobType, (LPTSTR) JobQueue->JobParams.RecipientNumber );
                }
                if (!JobEntry) {
                    
                    JobQueue->JobStatus |= JS_NOLINE;
                    DebugPrint(( TEXT("Job Id %d no line"), JobQueue->JobId));
                    break;
                } else {
                    JobQueue->JobStatus &= (0xFFFFFFFF ^ JS_NOLINE);
                }

                if (JobQueue->BroadcastJob) {
                    GenerateUniqueFileName( FaxQueueDir, TEXT("tif"), TempFile, sizeof(TempFile)/sizeof(WCHAR) );
                    if (JobQueue->FileName) {
                        CopyFile( JobQueue->FileName, TempFile, FALSE );
                        MergeTiffFiles( TempFile, JobQueue->BroadcastOwner->FileName );
                    } else {
                        CopyFile( JobQueue->BroadcastOwner->FileName, TempFile, FALSE );
                    }
                }

                LineInfo = JobEntry->LineInfo;
                JobQueue->JobEntry = JobEntry;

                //
                // set the job type
                //

                JobEntry->JobType = JobQueue->JobType;
                JobEntry->JobId = JobQueue->JobId;

                //
                // save the job params
                //

                JobEntry->JobParam.SizeOfStruct      = JobQueue->JobParams.SizeOfStruct;
                JobEntry->JobParam.RecipientNumber   = StringDup( JobQueue->JobParams.RecipientNumber );
                JobEntry->JobParam.RecipientName     = StringDup( JobQueue->JobParams.RecipientName );
                JobEntry->JobParam.Tsid              = StringDup( JobQueue->JobParams.Tsid );
                JobEntry->JobParam.SenderName        = StringDup( JobQueue->JobParams.SenderName );
                JobEntry->JobParam.SenderCompany     = StringDup( JobQueue->JobParams.SenderCompany );
                JobEntry->JobParam.SenderDept        = StringDup( JobQueue->JobParams.SenderDept );
                JobEntry->JobParam.BillingCode       = StringDup( JobQueue->JobParams.BillingCode );
                JobEntry->JobParam.Reserved[0]       = JobQueue->JobParams.Reserved[0];
                JobEntry->JobParam.Reserved[1]       = JobQueue->JobParams.Reserved[1];
                JobEntry->JobParam.Reserved[2]       = JobQueue->JobParams.Reserved[2];                
                JobEntry->PageCount                  = JobQueue->PageCount;
                JobEntry->FileSize                   = JobQueue->FileSize; //only meaningful for outbound job
                JobEntry->UserName                   = StringDup ( JobQueue->UserName );
                JobEntry->DeliveryReportType         = JobQueue->DeliveryReportType;
                JobEntry->DeliveryReportProfile      = JobQueue->DeliveryReportProfile;
                JobEntry->DeliveryReportAddress      = StringDup ( JobQueue->DeliveryReportAddress );
                
                if (JobQueue->BroadcastJob) {
                    JobEntry->BroadcastJob = TRUE;
                }

                //
                // start the send job
                //

                Rslt = SendDocument(
                    JobEntry,
                    JobQueue->BroadcastJob ? TempFile : JobQueue->FileName,
                    &JobQueue->JobParams,
                    JobQueue
                    );
            }
        }

        Next = RescheduleQueueHead.Flink;
        while ((ULONG_PTR)Next != (ULONG_PTR)&RescheduleQueueHead) {
            
            JobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
            
            Next = JobQueue->ListEntry.Flink;
            
            RescheduleJobQueueEntry( JobQueue );
        
        }

        //
        // restart the timer
        //

        
        StartJobQueueTimer( NULL );
        LeaveCriticalSection( &CsQueue );
        LeaveCriticalSection( &CsJob );
    }

    return 0;
}

                        
VOID
SetDiscountTime(
   LPSYSTEMTIME CurrentTime
   )
/*++

Routine Description:

    Sets the passed in systemtime to a time inside the discount rate period.
    Some care must be taken here because the time passed in is in UTC time and the discount rate is
    for the current time zone.  Delineating a day must be done using the current time zone.  We convert the
    current time into the time zone specific time, run our time-setting algorithm, and then use an offset 
    of the change in the time-zone specific time to set the passed in UTC time.
    
    Also, note that there are a few subtle subcases that depend on the order of the start and ending time 
    for the discount period.        

Arguments:

    CurrentTime - the current time of the job
    
Return Value:

    none. modifies CurrentTime.

--*/
{
   //              nano   microsec  millisec  sec      min    hours
   #define ONE_DAY 10I64 *1000I64*  1000I64 * 60I64 * 60I64 * 24I64
   LONGLONG Time, TzTimeBefore, TzTimeAfter,ftCurrent;   
   SYSTEMTIME tzTime;

   //
   // convert our discount rates into UTC rates
   //

   SystemTimeToTzSpecificLocalTime(NULL, CurrentTime, &tzTime);
   SystemTimeToFileTime(&tzTime, (FILETIME * )&TzTimeBefore); 

   //
   // there are 2 general cases with several subcases
   //
   
   //
   // case 1: discount start time is before discount stop time (don't overlap a day)
   //
   if ( StartCheapTime.Hour < StopCheapTime.Hour ||
        (StartCheapTime.Hour == StopCheapTime.Hour && StartCheapTime.Minute < StopCheapTime.Minute )) {
      //
      // subcase 1: sometime before cheap time starts in the current day. 
      //  just set it to the correct hour and minute today.
      //
      if ( tzTime.wHour < StartCheapTime.Hour ||
           (tzTime.wHour == StartCheapTime.Hour  && tzTime.wMinute <= StartCheapTime.Minute) ) {
         tzTime.wHour   =  StartCheapTime.Hour;
         tzTime.wMinute =  StartCheapTime.Minute;
         goto convert;
      }
                                 
      //
      // subcase 2: inside the current cheap time range
      // don't change anything, just send immediately
      if ( tzTime.wHour <  StopCheapTime.Hour ||
           (tzTime.wHour == StopCheapTime.Hour && tzTime.wMinute <= StopCheapTime.Minute)) {
         goto convert;
      }
   
      //
      // subcase 3: we've passed the cheap time range for today.  
      //  Increment 1 day and set to the start of the cheap time period
      //
      SystemTimeToFileTime(&tzTime, (FILETIME * )&Time);
      Time += ONE_DAY;
      FileTimeToSystemTime((FILETIME *)&Time, &tzTime);
      tzTime.wHour   = StartCheapTime.Hour;
      tzTime.wMinute = StartCheapTime.Minute;
      goto convert;

   } else {
      //
      // case 2: discount start time is after discount stop time (we overlap over midnight)
      //
            
      //
      // subcase 1: sometime aftert cheap time ended today, but before it starts later in the current day. 
      //  set it to the start of the cheap time period today
      //
      if ( ( tzTime.wHour   > StopCheapTime.Hour ||
             (tzTime.wHour == StopCheapTime.Hour  && tzTime.wMinute >= StopCheapTime.Minute) ) &&
           ( tzTime.wHour   < StartCheapTime.Hour ||
             (tzTime.wHour == StartCheapTime.Hour && tzTime.wMinute <= StartCheapTime.Minute) )) {
         tzTime.wHour   =  StartCheapTime.Hour;
         tzTime.wMinute =  StartCheapTime.Minute;
         goto convert;         
      }
                                 
      //
      // subcase 2: sometime after cheap time started today, but before midnight.
      // don't change anything, just send immediately
      if ( ( tzTime.wHour >= StartCheapTime.Hour ||
             (tzTime.wHour == StartCheapTime.Hour  && tzTime.wMinute >= StartCheapTime.Minute) )) {
         goto convert;
      }
   
      //
      // subcase 3: somtime in next day before cheap time ends
      //  don't change anything, send immediately
      //
      if ( ( tzTime.wHour <= StopCheapTime.Hour ||
             (tzTime.wHour == StopCheapTime.Hour  && tzTime.wMinute <= StopCheapTime.Minute) )) {
         goto convert;
      }
            
      //
      // subcase 4: we've passed the cheap time range for today.
      //  since start time comes after stop time, just set it to the start time later on today.
      
      tzTime.wHour   =  StartCheapTime.Hour;
      tzTime.wMinute =  StartCheapTime.Minute;
      goto convert;

   }

convert:

   SystemTimeToFileTime(&tzTime, (FILETIME * )&TzTimeAfter);
   SystemTimeToFileTime(CurrentTime, (FILETIME * )&ftCurrent);                        

   ftCurrent += (TzTimeAfter - TzTimeBefore);

   FileTimeToSystemTime((FILETIME *)&ftCurrent, CurrentTime);
   
   return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\server\print.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    print.c

Abstract:

    This module handles the FAX receive case.

Author:

    Wesley Witt (wesw) 24-April-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop

#define INTERNAL 1
#include "common.h"


PFAX_PRINTER_INFO FaxPrinterInfo;
DWORD FaxPrinters;
PHANDLE FaxPrinterNotifyHandles;
DWORD HandleCount;
HANDLE SpoolerProcessHandle;
DWORD SpoolerProcessIdx;
DWORD ReservedHandles;
HANDLE DirtyTimerHandle = INVALID_HANDLE_VALUE;
DWORD DirtyTimerIdx;
HANDLE ModemTimerHandle = INVALID_HANDLE_VALUE;
DWORD ModemTimerIdx;

extern DWORD FaxDirtyDays;
extern HANDLE FaxServerEvent;

LPTSTR PrintPlatforms[] =
{
    TEXT("Windows NT x86"),
    TEXT("Windows NT R4000"),
    TEXT("Windows NT Alpha_AXP"),
    TEXT("Windows NT PowerPC")
};


WORD PrinterFieldType1[] =
{
    JOB_NOTIFY_FIELD_STATUS
};

WORD PrinterFieldType2[] =
{
    PRINTER_NOTIFY_FIELD_PRINTER_NAME
};


PRINTER_NOTIFY_OPTIONS_TYPE PrinterNotifyOptionsType[] =
{
    {
        JOB_NOTIFY_TYPE,
        0,
        0,
        0,
        sizeof(PrinterFieldType1) / sizeof(WORD),
        PrinterFieldType1
    },
    {
        PRINTER_NOTIFY_TYPE,
        0,
        0,
        0,
        sizeof(PrinterFieldType2) / sizeof(WORD),
        PrinterFieldType2
    }
};


PRINTER_NOTIFY_OPTIONS PrinterNotifyOptions =
{
    2,
    0,
    sizeof(PrinterNotifyOptionsType) / sizeof(PRINTER_NOTIFY_OPTIONS_TYPE),
    PrinterNotifyOptionsType
};

BOOL
AddPortExW(
    LPWSTR   pName,
    DWORD    Level,
    LPBYTE   pBuffer,
    LPWSTR   pMonitorName
    );

VOID
CleanDirtyQueues(
    VOID
    );

PVOID
MyEnumPrinters(
    LPTSTR  pServerName,
    DWORD   level,
    PDWORD  pcPrinters
    )

/*++

Routine Description:

    Wrapper function for spooler API EnumPrinters

Arguments:

    pServerName - Specifies the name of the print server
    level - Level of PRINTER_INFO_x structure
    pcPrinters - Returns the number of printers enumerated

Return Value:

    Pointer to an array of PRINTER_INFO_x structures
    NULL if there is an error

--*/

{
    PBYTE   pPrinterInfo = NULL;
    DWORD   cb;

    if (! EnumPrinters(PRINTER_ENUM_LOCAL,
                       pServerName,
                       level,
                       NULL,
                       0,
                       &cb,
                       pcPrinters) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pPrinterInfo = MemAlloc(cb)) &&
        EnumPrinters(PRINTER_ENUM_LOCAL,
                     pServerName,
                     level,
                     pPrinterInfo,
                     cb,
                     &cb,
                     pcPrinters))
    {
        return pPrinterInfo;
    }

    MemFree(pPrinterInfo);
    return NULL;
}


PVOID
MyEnumPorts(
    LPTSTR  pServerName,
    DWORD   level,
    PDWORD  pcPorts
    )

/*++

Routine Description:

    Wrapper function for spooler API EnumPrinters

Arguments:

    pServerName - Specifies the name of the print server
    level - Level of PRINTER_INFO_x structure
    pcPrinters - Returns the number of printers enumerated

Return Value:

    Pointer to an array of PRINTER_INFO_x structures
    NULL if there is an error

--*/

{
    PBYTE   pPortInfo = NULL;
    DWORD   cb;

    if (! EnumPorts( NULL, level, NULL, 0, &cb, pcPorts ) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pPortInfo = MemAlloc(cb)) &&
        EnumPorts( NULL, level, pPortInfo, cb, &cb, pcPorts ))
    {
        return pPortInfo;
    }

    MemFree( pPortInfo );

    return NULL;
}


PVOID
MyGetJob(
    HANDLE  hPrinter,
    DWORD   level,
    DWORD   jobId
    )

/*++

Routine Description:

    Wrapper function for spooler API GetJob

Arguments:

    hPrinter - Handle to the printer object
    level - Level of JOB_INFO structure interested
    jobId - Specifies the job ID

Return Value:

    Pointer to a JOB_INFO structure, NULL if there is an error

--*/

{
    PBYTE   pJobInfo = NULL;
    DWORD   cbNeeded;

    if (!GetJob(hPrinter, jobId, level, NULL, 0, &cbNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pJobInfo = MemAlloc(cbNeeded)) &&
        GetJob(hPrinter, jobId, level, pJobInfo, cbNeeded, &cbNeeded))
    {
        return pJobInfo;
    }

    MemFree(pJobInfo);
    return NULL;
}


DWORD
GetPrinterDataDWord(
    HANDLE  hPrinter,
    PWSTR   pRegKey,
    DWORD   defaultValue
    )

/*++

Routine Description:

    Retrieve a DWORD value under PrinterData registry key

Arguments:

    hPrinter - Specifies the printer in question
    pRegKey - Specifies the name of registry value
    defaultValue - Specifies the default value to be used if no data exists in registry

Return Value:

    Current value for the requested registry key

--*/

{
    DWORD   value, type, cb;

    if (GetPrinterData(hPrinter,
                       pRegKey,
                       &type,
                       (PBYTE) &value,
                       sizeof(value),
                       &cb) == ERROR_SUCCESS)
    {
        return value;
    }

    return defaultValue;
}


LPTSTR
GetPrinterDataStr(
    HANDLE  hPrinter,
    LPTSTR  pRegKey
    )

/*++

Routine Description:

    Get a string value from the PrinterData registry key

Arguments:

    hPrinter - Identifies the printer object
    pRegKey - Specifies the name of registry value

Return Value:

    pBuffer

--*/

{
    DWORD   type, cb;
    PVOID   pBuffer = NULL;

    //
    // We should really pass NULL for pData parameter here. But to workaround
    // a bug in the spooler API GetPrinterData, we must pass in a valid pointer here.
    //

    if (GetPrinterData( hPrinter, pRegKey, &type, (PBYTE) &type, 0, &cb ) == ERROR_MORE_DATA &&
        (pBuffer = MemAlloc( cb )) &&
        GetPrinterData( hPrinter, pRegKey, &type, pBuffer, cb, &cb ) == ERROR_SUCCESS &&
        (type == REG_SZ || type == REG_MULTI_SZ || type == REG_EXPAND_SZ))
    {
        return pBuffer;
    }

    DebugPrint(( TEXT("Couldn't get printer data string %ws: %d\n"), pRegKey, GetLastError() ));
    MemFree( pBuffer );
    return NULL;
}


BOOL
DeletePortInternal(
    HANDLE hPrinter,
    LPTSTR PortName
    )
{
    BOOL Rval = TRUE;
    BOOL PortFound = FALSE;
    DWORD i;
    LPPRINTER_INFO_2 PrinterInfo = NULL;
    LPTSTR p;
    LPTSTR s2;
    LPTSTR s;


    if ((!GetPrinter( hPrinter, 2, NULL, 0, &i )) && (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {
        DebugPrint(( TEXT("GetPrinter() failed, ec=%d"), GetLastError() ));
        Rval = FALSE;
        goto exit;
    }

    PrinterInfo = (LPPRINTER_INFO_2) MemAlloc( i );
    if (!PrinterInfo) {
        DebugPrint(( TEXT("MemAlloc() failed, size=%d"), i ));
        Rval = FALSE;
        goto exit;
    }

    if (!GetPrinter( hPrinter, 2, (LPBYTE) PrinterInfo, i, &i )) {
        DebugPrint(( TEXT("GetPrinter() failed, ec=%d"), GetLastError() ));
        Rval = FALSE;
        goto exit;
    }

    p = PrinterInfo->pPortName;
    while (p && *p) {
        s = _tcschr( p, TEXT(',') );
        if (s) {
            s2 = s;
            *s = 0;
        } else {
            s2 = NULL;
        }
        if (_tcscmp( p, PortName ) == 0) {
            PortFound = TRUE;
            if (s2) {
                _tcscpy( p, s2+1 );
            } else {
                *p = 0;
                break;
            }
        } else {
            p += _tcslen(p);
            if (s2) {
                *s2 = TEXT(',');
                p += 1;
            }
        }
    }

    if (PortFound) {
        if (!SetPrinter( hPrinter, 2, (LPBYTE) PrinterInfo, 0 )) {
            DebugPrint(( TEXT("SetPrinter() failed, ec=%d"), GetLastError() ));
            goto exit;
        }
    }

exit:
    MemFree( PrinterInfo );
    return Rval;
}


BOOL
DeletePrinterPort(
    LPTSTR PortName
    )
{
    BOOL Rval = TRUE;
    DWORD i;
    PPRINTER_INFO_2 PrinterInfo = NULL;
    DWORD PrinterCount;
    PRINTER_DEFAULTS PrinterDefaults;
    HANDLE hPrinter;


    PrinterInfo = MyEnumPrinters( NULL, 2, &PrinterCount );
    if (!PrinterInfo) {
        DebugPrint(( TEXT("MyEnumPrinters() failed, ec=%d"), GetLastError() ));
        return FALSE;
    }

    //
    // first remove the port name from the list
    // associated with each fax printer.  this is
    // necessary because the DeletePort() api will
    // not work if the port is associated with a
    // printer
    //

    for (i=0; i<PrinterCount; i++) {
        if (_tcsicmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0) {

            PrinterDefaults.pDatatype     = NULL;
            PrinterDefaults.pDevMode      = NULL;
            PrinterDefaults.DesiredAccess = PRINTER_ALL_ACCESS;

            if (!OpenPrinter( PrinterInfo[i].pPrinterName, &hPrinter, &PrinterDefaults )) {
                DebugPrint(( TEXT("OpenPrinter() failed, ec=%d"), GetLastError() ));
                continue;
            }

            if (!DeletePortInternal( hPrinter, PortName )) {
                Rval = FALSE;
            }

            ClosePrinter( hPrinter );
        }
    }

    MemFree( PrinterInfo );

    //
    // next, if the port was dis-associated from all
    // printers, then ask the spooler to delete it.
    //

    if (Rval) {
        DeletePort( NULL, NULL, PortName );
    }

    return Rval;
}


BOOL
IsValidPort(
    PPORT_INFO_2 PortInfo,
    DWORD PortCount,
    LPTSTR PortName
    )
{
    DWORD i;

    for (i=0; i<PortCount; i++) {
        if (_tcscmp( PortName, PortInfo[i].pPortName ) == 0) {
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
AddPrinterPort(
    LPTSTR PortName
    )
{
    BOOL Rval = TRUE;
    DWORD i;
    PORT_INFO_1W PortInfo;
    PPRINTER_INFO_2 PrinterInfo = NULL;
    PPRINTER_INFO_2 ThisPrinterInfo = NULL;
    DWORD PrinterCount;
    LPTSTR p,s;
    PPORT_INFO_2 PortInfo2 = NULL;
    DWORD PortCount;
    LPTSTR NewPort = NULL;
    PRINTER_DEFAULTS PrinterDefaults;
    HANDLE hPrinter;
    DWORD Bytes;


    PortInfo.pName = PortName;

    Rval = AddPortExW(
        NULL,
        1,
        (LPBYTE) &PortInfo,
        FAX_MONITOR_NAME
        );
    if (!Rval) {
        DebugPrint(( TEXT("AddPortExW() failed, ec=%d"), GetLastError() ));
        Rval = FALSE;
        goto exit;
    }

    PortInfo2 = (PPORT_INFO_2) MyEnumPorts( NULL, 2, &PortCount );
    if (!PortInfo2) {
        DebugPrint(( TEXT("MyEnumPorts() failed, ec=%d"), GetLastError() ));
        Rval = FALSE;
        goto exit;
    }

    PrinterInfo = MyEnumPrinters( NULL, 2, &PrinterCount );
    if (!PrinterInfo) {
        DebugPrint(( TEXT("MyEnumPrinters() failed, ec=%d"), GetLastError() ));
        Rval = FALSE;
        goto exit;
    }

    for (i=0; i<PrinterCount; i++) {

        if (_tcsicmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0) {

            MemFree( NewPort );

            NewPort = MemAlloc( StringSize( PrinterInfo[i].pPortName ) + StringSize( PortName ) + 4 );
            if (!NewPort) {
                DebugPrint(( TEXT("Could not allocate memory for NewPort") ));
                Rval = FALSE;
                goto exit;
            }

            _tcscpy( NewPort, PortName );
            p = PrinterInfo[i].pPortName;

            while( p && *p ) {
                s = _tcschr( p, TEXT(',') );
                if (s) {
                    *s = 0;
                }
                if (IsValidPort( PortInfo2, PortCount, p )) {
                    if (*NewPort) {
                        _tcscat( NewPort, TEXT(",") );
                    }
                    _tcscat( NewPort, p );
                }
                if (s) {
                    *s = TEXT(',');
                    p = s + 1;
                } else {
                    break;
                }
            }

            PrinterDefaults.pDatatype     = NULL;
            PrinterDefaults.pDevMode      = NULL;
            PrinterDefaults.DesiredAccess = PRINTER_ALL_ACCESS;

            if (!OpenPrinter( PrinterInfo[i].pPrinterName, &hPrinter, &PrinterDefaults )) {
                DebugPrint(( TEXT("OpenPrinter() failed, ec=%d"), GetLastError() ));
                Rval = FALSE;
                goto exit;
            }

            if ((!GetPrinter( hPrinter, 2, NULL, 0, &Bytes )) && (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {
                DebugPrint(( TEXT("GetPrinter() failed, ec=%d"), GetLastError() ));
                Rval = FALSE;
                goto exit;
            }

            MemFree( ThisPrinterInfo );

            ThisPrinterInfo = (LPPRINTER_INFO_2) MemAlloc( Bytes );
            if (!ThisPrinterInfo) {
                DebugPrint(( TEXT("MemAlloc() failed, size=%d"), Bytes ));
                Rval = FALSE;
                goto exit;
            }

            if (!GetPrinter( hPrinter, 2, (LPBYTE) ThisPrinterInfo, Bytes, &Bytes )) {
                DebugPrint(( TEXT("GetPrinter() failed, ec=%d"), GetLastError() ));
                Rval = FALSE;
                goto exit;
            }

            ThisPrinterInfo->pPortName = NewPort;

            if (!SetPrinter( hPrinter, 2, (LPBYTE) ThisPrinterInfo, 0 )) {
                DebugPrint(( TEXT("SetPrinter() failed, ec=%d"), GetLastError() ));
                Rval = FALSE;
                goto exit;
            }

            ClosePrinter( hPrinter );

        }

    }

exit:

    MemFree( ThisPrinterInfo );
    MemFree( PrinterInfo );
    MemFree( PortInfo2 );
    MemFree( NewPort );

    return Rval;
}


BOOL
CreateNullPrintJobs(
    PJOB_ENTRY JobEntry
    )

/*++

Routine Description:

    Creates a NULL print job on each FAX printer in the
    system.  This is necessary to that status information
    is displayed for incoming fax jobs.


Arguments:

    JobEntry    - Pointer to a FAX job entry.

Return Value:

    TRUE    - The print jobs are all created.
    FALSE   - Some or all of the print jobs were not created.

--*/

{
    DWORD i;
    DOC_INFO_1 DocInfo;
    BOOL Rval = TRUE;
    PRINTER_DEFAULTS PrinterDefaults;



    //
    // loop thru the printers and create a job on each one
    //

    EnterCriticalSection( &CsJob );

    for (i=0; i<FaxPrinters; i++) {

        //
        // create the print job
        //

        DocInfo.pDocName    = GetString( IDS_SERVER_NAME );
        DocInfo.pOutputFile = NULL;
        DocInfo.pDatatype   = 0;

        PrinterDefaults.pDatatype     = NULL;
        PrinterDefaults.pDevMode      = NULL;
        PrinterDefaults.DesiredAccess = PRINTER_ALL_ACCESS;

        if (!OpenPrinter( FaxPrinterInfo[i].PrinterName, &JobEntry->hPrinter[i], &PrinterDefaults )) {
            DebugPrint(( TEXT("OpenPrinter() failed, ec=%d"), GetLastError() ));
            Rval = FALSE;
            goto exit;
        }

        JobEntry->PrintJobIds[i] = StartDocPrinter(
            JobEntry->hPrinter[i],
            1,
            (LPBYTE) &DocInfo
            );
        if (JobEntry->PrintJobIds[i]) {

            DebugPrint((TEXT("Started receive print JobId %d"), JobEntry->PrintJobIds[i]));

            //
            // pause the job so nothing really happens
            //

            if (!SetJob( FaxPrinterInfo[i].hPrinter, JobEntry->PrintJobIds[i], 0, NULL, JOB_CONTROL_PAUSE )) {
                DebugPrint(( TEXT("SetJob() failed, ec=%d"), GetLastError() ));

            }

            //
            // set the initial status string
            //

            SetPrintJobStatus(
                JobEntry->hPrinter[i],
                JobEntry->PrintJobIds[i],
                FPS_INITIALIZING,
                NULL,
                -1
                );
        } else {

            DebugPrint(( TEXT("StartDocPrinter() failed, ec=%d"), GetLastError() ));
            Rval = FALSE;

        }

    }

exit:

    LeaveCriticalSection( &CsJob );
    return Rval;
}


BOOL
DeleteNullPrintJobs(
    PFAX_PRINTER_INFO RecvFaxPrinterInfo
    )

/*++

Routine Description:

    Deletes the NULL print jobs for all FAX printers
    on the system.

Arguments:

    RecvFaxPrinterInfo    - Pointer to array of structs holding printer handles to close.

Return Value:

    TRUE    - The print jobs are all deleted.
    FALSE   - Some or all of the print jobs were not deleted.

--*/

{
    DWORD i;
    BOOL Rval = TRUE;
    DWORD JobId;
    HANDLE hPrinter;


    EnterCriticalSection( &CsJob );

    for (i=0; i<FaxPrinters; i++) {

        JobId = RecvFaxPrinterInfo[i].PrintJobId;
        hPrinter = RecvFaxPrinterInfo[i].hPrinter;

        if (!SetJob(
                hPrinter,
                JobId,
                0,
                NULL,
                JOB_CONTROL_CANCEL
                )) {

                    DebugPrint(( TEXT("SetJob() failed, ec=%d"), GetLastError() ));
                    Rval = FALSE;

        }

        DebugPrint((TEXT("Ended receive print JobId %d"), JobId));

        if (!EndDocPrinter( hPrinter )) {

            DebugPrint(( TEXT("EndDocPrinter() failed, ec=%d"), GetLastError() ));

        }

        ClosePrinter( hPrinter );

    }

    LeaveCriticalSection( &CsJob );

    return Rval;
}



BOOL
EnableSpoolerPort(
    LPTSTR PortName,
    BOOL Enable
    )

/*++

Routine Description:

    Enables or disables a spooler port.

Arguments:

    PortName    - Name of the port to be changes
    Enable      - TRUE = enable, FAlSE = disable

Return Value:

    TRUE    - The port status is changed.
    FALSE   - The port status is not changed.

--*/

{
    PORT_INFO_3 PortInfo;


    //
    // change the spooler's port status
    //

    PortInfo.dwStatus   = 0;
    PortInfo.pszStatus  = NULL,
    PortInfo.dwSeverity = Enable ? PORT_STATUS_TYPE_INFO : PORT_STATUS_TYPE_ERROR;

    if (!SetPort( NULL, PortName, 3, (LPBYTE) &PortInfo )) {
        DebugPrint(( TEXT("SetPort() failed, ec=%d"), GetLastError() ));
        return FALSE;
    }

    return TRUE;
}

BOOL
SetPrintJobCompleted(
    HANDLE hPrinter,
    DWORD PrintJobId
    )

/*++

Routine Description:

    Causes the spooler to complete a print job.
    The result is the print job is removed from the
    print queue.

Arguments:

    PrinterName - Name of the printer that owns the job
    PrintJobId  - Id of the job to be restarted

Return Value:

    TRUE    - The print job is completed.
    FALSE   - The print job is not completed.

--*/

{
    if (!PrintJobId) {
        DebugPrint(( TEXT("SetPrintJobCompleted() failed: 0x%d"), PrintJobId ));
        return FALSE;
    }


    DebugPrint((TEXT("Setting job status for job %d - JOB_CONTROL_SENT_TO_PRINTER"), PrintJobId));
    if (!SetJob(
        hPrinter,
        PrintJobId,
        0,
        NULL,
        JOB_CONTROL_SENT_TO_PRINTER
        )) {

            DebugPrint(( TEXT("SetJob() failed: 0x%08x"), GetLastError() ));
            return FALSE;
    }

    return TRUE;
}

BOOL
SetPrintJobPaused(
    HANDLE hPrinter,
    DWORD PrintJobId
    )

/*++

Routine Description:

    Causes the spooler to pause a print job.

Arguments:

    PrinterName - Name of the printer that owns the job
    PrintJobId  - Id of the job to be restarted

Return Value:

    TRUE    - The print job is paused.
    FALSE   - The print job is not paused.

--*/

{

    if (!PrintJobId) {
        DebugPrint(( TEXT("SetPrintJobPaused() failed: 0x%d"), PrintJobId ));
        return FALSE;
    }


    DebugPrint((TEXT("Setting job status for job %d -  JOB_CONTROL_PAUSE"), PrintJobId));
    if (!SetJob(
        hPrinter,
        PrintJobId,
        0,
        NULL,
        JOB_CONTROL_PAUSE
        )) {

            DebugPrint(( TEXT("SetJob() failed: 0x%08x"), GetLastError() ));
            return FALSE;
    }

    return TRUE;
}


BOOL
ArchivePrintJob(
    HANDLE hPrinter,
    LPTSTR FaxFileName,
    DWORDLONG SendTime,
    PFAX_DEV_STATUS FaxStatus,
    PFAX_SEND FaxSend
    )

/*++

Routine Description:

    Archive a tiff file that has been sent by copying the file to an archive
    directory.

Arguments:

    FaxFileName - Name of the file to archive

Return Value:

    TRUE    - The copy was made.
    FALSE   - The copy was not made.

--*/
{
    BOOL        rVal = FALSE;
    DWORD       ByteCount;
    LPTSTR      ArchiveDirStr = NULL;
    LPTSTR      ArchiveDir = NULL;
    LPTSTR      ArchiveFileName = NULL;
    MS_TAG_INFO MsTagInfo;
    WCHAR       wcZero = L'\0';



    if (!GetPrinterDataDWord( hPrinter, PRNDATA_ARCHIVEFLAG, 0 )) {
        return TRUE;
    }

    ArchiveDirStr = GetPrinterDataStr( hPrinter, PRNDATA_ARCHIVEDIR );
    if (!ArchiveDirStr) {
        goto exit;
    }

    //
    // get the dir name
    //

    ByteCount = ExpandEnvironmentStrings( ArchiveDirStr, ArchiveDir, 0 );

    ArchiveDir = MemAlloc( ByteCount * sizeof(TCHAR) );
    if (!ArchiveDir) {
        goto exit;
    }
    ExpandEnvironmentStrings( ArchiveDirStr, ArchiveDir, ByteCount );

    //
    // be sure that the dir exists
    //

    MakeDirectory( ArchiveDir );

    //
    // get the file name
    //

    ByteCount = (ByteCount + 20) * sizeof(TCHAR);
    ArchiveFileName = MemAlloc( ByteCount );
    if (!ArchiveFileName) {
        goto exit;
    }

    rVal = GenerateUniqueFileName( ArchiveDir, ArchiveFileName, ByteCount );

    if (rVal) {

        rVal = CopyFile( FaxFileName, ArchiveFileName, FALSE );

        //
        // add the microsoft fax tags to the file
        // this is necessary ONLY when we archive the
        // file when doing a send.  if we are not
        // archiving the file then it is deleted, so
        // adding the tags is not necessary.
        //

        if (rVal) {

           MsTagInfo.RecipName = NULL;
           if (FaxSend->ReceiverName && (FaxSend->ReceiverName[0] != wcZero) ) {
              MsTagInfo.RecipName     = FaxSend->ReceiverName;
           }

           MsTagInfo.RecipNumber   = NULL;
           if (FaxSend->ReceiverNumber && (FaxSend->ReceiverNumber[0] != wcZero) ) {
              MsTagInfo.RecipNumber   = FaxSend->ReceiverNumber;
           }

           MsTagInfo.SenderName    = NULL;
           if (FaxSend->CallerName && (FaxSend->CallerName[0] != wcZero) ) {
              MsTagInfo.SenderName    = FaxSend->CallerName;
           }

           MsTagInfo.Routing       = NULL;
           if (FaxStatus->RoutingInfo && (FaxStatus->RoutingInfo[0] != wcZero) ) {
              MsTagInfo.Routing       = FaxStatus->RoutingInfo;
           }

           MsTagInfo.CallerId      = NULL;
           if (FaxStatus->CallerId && (FaxStatus->CallerId[0] != wcZero) ) {
              MsTagInfo.CallerId      = FaxStatus->CallerId;
           }

           MsTagInfo.Csid          = NULL;
           if (FaxStatus->CSI && (FaxStatus->CSI[0] != wcZero) ) {
              MsTagInfo.Csid          = FaxStatus->CSI;
           }

           MsTagInfo.Tsid          = NULL;
           if (FaxSend->CallerNumber && (FaxSend->CallerNumber[0] != wcZero) ) {
              MsTagInfo.Tsid          = FaxSend->CallerNumber;
           }

           MsTagInfo.FaxTime       = SendTime;

           TiffAddMsTags( ArchiveFileName, &MsTagInfo );
        }
    }

    if (rVal) {
        FaxLog(
            FAXLOG_CATEGORY_OUTBOUND,
            FAXLOG_LEVEL_MAX,
            2,
            MSG_FAX_ARCHIVE_SUCCESS,
            FaxFileName,
            ArchiveFileName
            );
    } else {
        FaxLog(
            FAXLOG_CATEGORY_OUTBOUND,
            FAXLOG_LEVEL_MIN,
            3,
            MSG_FAX_ARCHIVE_FAILED,
            FaxFileName,
            ArchiveFileName,
            GetLastErrorText(GetLastError())
            );
    }

exit:
    MemFree( ArchiveDirStr );
    MemFree( ArchiveDir );
    MemFree( ArchiveFileName );

    return rVal;
}


BOOL
RestartPrintJob(
    HANDLE hPrinter,
    DWORD PrintJobId
    )

/*++

Routine Description:

    Causes a print job to be restarted.

Arguments:

    hPrinter - Handle to printer that owns the job
    PrintJobId  - Id of the job to be restarted

Return Value:

    TRUE    - The print job is restarted
    FALSE   - The print job is not restarted

--*/

{
    PJOB_INFO_2 pJobInfo;
    SYSTEMTIME SystemTime;
    DWORD Minutes;

    if (!PrintJobId) {
        return FALSE;
    }

    DebugPrint((TEXT("Setting job status for job %d - JOB_CONTROL_RESTART"), PrintJobId));

    pJobInfo = (PJOB_INFO_2) MyGetJob( hPrinter, 2, PrintJobId );

    if (pJobInfo == NULL) {
        return FALSE;
    }

    GetSystemTime(&SystemTime);

    // wait a couple of minutes to restart the job

    Minutes = SystemTime.wHour * MINUTES_PER_HOUR + SystemTime.wMinute;
    Minutes += 2;
    Minutes %= MINUTES_PER_DAY;

    pJobInfo->StartTime = Minutes;

    if (!SetJob(
        hPrinter,
        PrintJobId,
        2,
        (LPBYTE) pJobInfo,
        JOB_CONTROL_RESTART
        )) {

            DebugPrint(( TEXT("SetJob() failed: 0x%08x"), GetLastError() ));
            MemFree( pJobInfo );
            return FALSE;
    }
    MemFree( pJobInfo );
    return TRUE;
}


BOOL
SetPrintJobStatus(
    HANDLE hPrinter,
    DWORD PrintJobId,
    DWORD Status,
    LPTSTR PhoneNumber,
    INT PageCount
    )

/*++

Routine Description:

    Changes the status string for a print job.

Arguments:

    PrinterName - Name of the printer that owns the job
    PrintJobId  - Id of the job to be restarted
    Status      - Status is

Return Value:

    TRUE    - The status is changed.
    FALSE   - The status is NOT changed.

--*/

{
    LPJOB_INFO_1 JobInfo = NULL;
    LPTSTR StatusString = NULL;
    BOOL Rval = FALSE;
    DWORD BytesNeeded;
    DWORD Size;


    if ((!GetJob(
        hPrinter,
        PrintJobId,
        1,
        NULL,
        0,
        &BytesNeeded )) && GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            DebugPrint(( TEXT("SetPrintJobStatus GetJob(0) JobId %d failed: 0x%08x"), PrintJobId, GetLastError() ));
            goto exit;

    }

    Size = BytesNeeded;
    BytesNeeded += 256;

    JobInfo = (LPJOB_INFO_1) MemAlloc( BytesNeeded );
    if (!JobInfo) {
        DebugPrint(( TEXT("MemAlloc() failed: 0x%08x"), BytesNeeded ));
        goto exit;
    }

    if (!GetJob(
        hPrinter,
        PrintJobId,
        1,
        (LPBYTE) JobInfo,
        Size,
        &Size
        )) {
            DebugPrint(( TEXT("SetPrintJobStatus GetJob(1) JobId %d failed: 0x%08x"), PrintJobId, GetLastError() ));
            goto exit;

    }

    StatusString = GetString( Status );
    if (StatusString) {
        JobInfo->pStatus = (LPTSTR) ((LPBYTE)JobInfo + Size);
        if (Status == FS_DIALING || Status == FS_TRANSMITTING) {
            _stprintf( JobInfo->pStatus, StatusString, PhoneNumber );
        } else {
            _tcscpy( JobInfo->pStatus, StatusString );
        }
    }

    if (PageCount != -1) {
        JobInfo->PagesPrinted = (DWORD) PageCount;
    }

    DebugPrint((TEXT("Setting job status for job %d - %s"), PrintJobId, StatusString));

    if (!SetJob(
        hPrinter,
        PrintJobId,
        1,
        (LPBYTE) JobInfo,
        0
        )) {

            DebugPrint(( TEXT("SetJob() failed: 0x%08x"), GetLastError() ));
            goto exit;
    }

    Rval = TRUE;

exit:
    if (JobInfo) {
        MemFree( JobInfo );
    }

    return Rval;
}


BOOL
IsPrinterFaxPrinter(
    LPTSTR PrinterName
    )

/*++

Routine Description:

    Determines if a printer is a fax printer.

Arguments:

    PrinterName - Name of the printer

Return Value:

    TRUE for success.
    FALSE for failure.

--*/

{
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults;
    SYSTEM_INFO SystemInfo;
    DWORD Size;
    DWORD Rval = FALSE;
    LPDRIVER_INFO_2 DriverInfo = NULL;


    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_READ;

    if (!OpenPrinter( PrinterName, &hPrinter, &PrinterDefaults )) {

        DebugPrint(( TEXT("OpenPrinter(%d) failed, ec=%d"), __LINE__, GetLastError() ));
        return FALSE;

    }

    GetSystemInfo( &SystemInfo );

    Size = 4096;

    DriverInfo = (LPDRIVER_INFO_2) MemAlloc( Size );
    if (!DriverInfo) {
        DebugPrint(( TEXT("Memory allocation failed, size=%d"), Size ));
        goto exit;
    }

    Rval = GetPrinterDriver(
        hPrinter,
        PrintPlatforms[SystemInfo.wProcessorArchitecture],
        2,
        (LPBYTE) DriverInfo,
        Size,
        &Size
        );
    if (!Rval) {
        DebugPrint(( TEXT("GetPrinterDriver() failed, ec=%d"), GetLastError() ));
        goto exit;
    }

    if (_tcscmp( DriverInfo->pName, FAX_DRIVER_NAME ) == 0) {
        Rval = TRUE;
    } else {
        Rval = FALSE;
    }

exit:

    MemFree( DriverInfo );
    ClosePrinter( hPrinter );
    return Rval;
}


BOOL
RefreshPrinterInfo(
    VOID
    )

/*++

Routine Description:

    This function allocates the necessary data structures
    to track the fax printers on the server.  The data
    structures are then populated with the necessary data.

Arguments:

    None.

Return Value:

    TRUE for success.
    FALSE for failure.

--*/

{
    DWORD PrinterCount;
    PPRINTER_INFO_2 PrinterInfo;
    DWORD i;
    DWORD j;
    HANDLE hPrinter;
    HANDLE hNotify;
    PRINTER_DEFAULTS PrinterDefaults;
    BOOL Rval = FALSE;



    EnterCriticalSection( &CsJob );

    //
    // close all handles and release all memory
    //

    if (FaxPrinterInfo) {
        for (i=0; i<FaxPrinters+1; i++) {
            FindClosePrinterChangeNotification( FaxPrinterInfo[i].hNotify );
            ClosePrinter( FaxPrinterInfo[i].hPrinter );
            MemFree( FaxPrinterInfo[i].PrinterName );
        }
    }

    MemFree( FaxPrinterInfo );
    MemFree( FaxPrinterNotifyHandles );
    FaxPrinterInfo = NULL;
    FaxPrinterNotifyHandles = NULL;

    FaxPrinters = 0;
    HandleCount = 0;

    //
    // enumerate all of the printers on this server
    //

    PrinterInfo = MyEnumPrinters( NULL, 2, &PrinterCount );
    if (!PrinterInfo) {
        PrinterCount = 0;
    }

    //
    // count the fax printers
    //

    for (i=0; i<PrinterCount; i++) {

        //
        // is this a fax printer??
        //

        if (_tcsicmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0) {
            FaxPrinters += 1;
        }

    }

    //
    // allocate the fax printer info structures
    //

    FaxPrinterInfo = (PFAX_PRINTER_INFO) MemAlloc( (FaxPrinters+1) * sizeof(FAX_PRINTER_INFO) );
    if (!FaxPrinterInfo) {
        DebugPrint(( TEXT("Memory allocation failed\n") ));
        goto exit;
    }

    ZeroMemory( FaxPrinterInfo, (FaxPrinters+1) * sizeof(FAX_PRINTER_INFO) );

    //
    // get a server handle
    //

    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = SERVER_ALL_ACCESS;

    if (!OpenPrinter( NULL, &hPrinter, &PrinterDefaults )) {
        DebugPrint(( TEXT("OpenPrinter() failed, ec=%d"), GetLastError() ));
        goto exit;
    }

    hNotify = FindFirstPrinterChangeNotification(
        hPrinter,
        PRINTER_CHANGE_ADD_PRINTER | PRINTER_CHANGE_DELETE_PRINTER,
        0,
        &PrinterNotifyOptions
        );
    if (hNotify == INVALID_HANDLE_VALUE) {
        ClosePrinter ( hPrinter );
        DebugPrint(( TEXT("FindFirstPrinterChangeNotification() failed, ec=%d"), GetLastError() ));
        goto exit;
    }

    FaxPrinterInfo[FaxPrinters].hPrinter    = hPrinter;
    FaxPrinterInfo[FaxPrinters].hNotify     = hNotify;
    FaxPrinterInfo[FaxPrinters].PrinterName = NULL;

    //
    // set the notification function for all fax printers
    //

    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_ALL_ACCESS;

    for (i=0,j=0; i<PrinterCount; i++) {

        //
        // is this a fax printer??
        //

        if (_tcsicmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0) {

            if (!OpenPrinter( PrinterInfo[i].pPrinterName, &hPrinter, &PrinterDefaults )) {
                DebugPrint(( TEXT("OpenPrinter() failed, ec=%d"), GetLastError() ));
                goto exit;
            }

            hNotify = FindFirstPrinterChangeNotification(
                hPrinter,
                PRINTER_CHANGE_DELETE_JOB,
                0,
                &PrinterNotifyOptions
                );
            if (hNotify == INVALID_HANDLE_VALUE) {
                DebugPrint(( TEXT("FindFirstPrinterChangeNotification() failed, ec=%d"), GetLastError() ));
                goto exit;
            }

            FaxPrinterInfo[j].hPrinter    = hPrinter;
            FaxPrinterInfo[j].hNotify     = hNotify;
            FaxPrinterInfo[j].PrinterName = StringDup( PrinterInfo[i].pPrinterName );

            j += 1;


        }
    }

    ReservedHandles = (SpoolerProcessHandle == NULL) ? 3 : 4;

    HandleCount = FaxPrinters + ReservedHandles;

    FaxPrinterNotifyHandles = (PHANDLE) MemAlloc( HandleCount * sizeof(HANDLE) );

    if (!FaxPrinterNotifyHandles) {
        DebugPrint(( TEXT("Memory allocation failed\n") ));
        return FALSE;
    }

    for (i=0; i<HandleCount-ReservedHandles+1; i++) {
        FaxPrinterNotifyHandles[i] = FaxPrinterInfo[i].hNotify;
    }

    if (SpoolerProcessHandle) {
        SpoolerProcessIdx = i;
        FaxPrinterNotifyHandles[i++] = SpoolerProcessHandle;
    }

    //
    // initialize the dirty days queue cleaner timer
    //

    if (DirtyTimerHandle == INVALID_HANDLE_VALUE) {

        DirtyTimerIdx = i;
        DirtyTimerHandle = CreateWaitableTimer( NULL, FALSE, NULL );

        if (DirtyTimerHandle == INVALID_HANDLE_VALUE) {
            DebugPrint(( TEXT("CreateWaitableTimer failed ec=%d"), GetLastError() ));
        } else {
            LARGE_INTEGER DueTime;
            LONG lPeriod = MILLISECONDS_PER_SECOND * SECONDS_PER_HOUR;      // once per hour

            DueTime.QuadPart = 0;

            if( !SetWaitableTimer( DirtyTimerHandle, &DueTime, lPeriod, NULL, NULL, FALSE ) ) {
                DebugPrint(( TEXT("SetWaitableTimer failed ec=%d"), GetLastError() ));
            }

            FaxPrinterNotifyHandles[i] = DirtyTimerHandle;

        }
    } else {

        DirtyTimerIdx = i;
        FaxPrinterNotifyHandles[i] = DirtyTimerHandle;

    }

    i += 1;

    //
    // initialize the modem delayed initialization timer
    //

    if (ModemTimerHandle == INVALID_HANDLE_VALUE) {

        ModemTimerIdx = i;
        ModemTimerHandle = CreateWaitableTimer( NULL, FALSE, NULL );

        if (ModemTimerHandle == INVALID_HANDLE_VALUE) {
            DebugPrint(( TEXT("CreateWaitableTimer failed ec=%d"), GetLastError() ));
        } else {
            LARGE_INTEGER DueTime;
            LONG lPeriod = MILLISECONDS_PER_SECOND * 15;

            DueTime.QuadPart = 0;

            if( !SetWaitableTimer( ModemTimerHandle, &DueTime, lPeriod, NULL, NULL, FALSE ) ) {
                DebugPrint(( TEXT("SetWaitableTimer failed ec=%d"), GetLastError() ));
            }

            FaxPrinterNotifyHandles[i] = ModemTimerHandle;

        }
    } else {

        ModemTimerIdx = i;
        FaxPrinterNotifyHandles[i] = ModemTimerHandle;

    }

    Rval = TRUE;

exit:
    LeaveCriticalSection( &CsJob );
    MemFree( PrinterInfo );
    return Rval;
}


BOOL
HandleJobChange(
    PFAX_PRINTER_INFO FaxPrinterInfo,
    DWORD JobStatus,
    DWORD JobId
    )

/*++

Routine Description:

    This function handles a print job change.  We only care
    about job deletions.  When a user deletes a fax print job
    we must call the device provider's abort function so
    that the fax operation can be terminated.

Arguments:

    FaxPrinterInfo  - Printer info structure for the printer that owns this job
    JobStatus       - The new status of the job
    JobId           - The print job id

Return Value:

    TRUE for success.
    FALSE for failure.

--*/

{
    PJOB_ENTRY JobEntry;


    EnterCriticalSection( &CsJob );

    //
    // is the job being deleted?
    //

    if (!(JobStatus & JOB_STATUS_DELETING)) {
        LeaveCriticalSection( &CsJob );
        return FALSE;
    }

    //
    // get the fax job
    //

    JobEntry = FindJobByPrintJob( JobId );

    if (JobEntry == NULL || JobEntry->Aborting) {
        //
        // either the job does not exist or it is already aborting
        //

        LeaveCriticalSection( &CsJob );
        return FALSE;
    }

    SetPrintJobStatus(
        FaxPrinterInfo->hPrinter,
        JobId,
        FPS_ABORTING,
        NULL,
        -1
        );

    //
    // call the device provider's abort function
    //

    __try {

        JobEntry->LineInfo->Provider->FaxDevAbortOperation(
            (HANDLE) JobEntry->InstanceData
            );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        JobEntry->ErrorCode = GetExceptionCode();

    }

    JobEntry->Aborting = TRUE;

    LeaveCriticalSection( &CsJob );

    return TRUE;
}


HANDLE
GetSpoolerProcessHandle(
    VOID
    )

/*++

Routine Description:

    This function gets a handles to the spooler's
    process object.  It does this by enumerating the
    task list on the system and then looks for a
    process called "spoolss.exe".  This task's process
    identifier is used to open a process handle.

Arguments:

    None.

Return Value:

    NULL    - Could not get the spooler's process handle
    HANDLE  - The spooler's process handle

--*/

{
    #define MAX_TASKS 256
    DWORD TaskCount;
    PTASK_LIST TaskList = NULL;
    DWORD SpoolerPid = 0;
    DWORD i;
    HANDLE SpoolerProcessHandle = NULL;


    TaskList = (PTASK_LIST) MemAlloc( MAX_TASKS * sizeof(TASK_LIST) );
    if (!TaskList) {
        goto exit;
    }

    TaskCount = GetTaskList( TaskList, MAX_TASKS );
    if (!TaskCount) {
        goto exit;
    }

    for (i=0; i<TaskCount; i++) {
        if (_stricmp( TaskList[i].ProcessName, "spoolss.exe" ) == 0) {
            SpoolerPid = TaskList[i].dwProcessId;
            break;
        }
    }

    if (i == TaskCount) {
        goto exit;
    }

    if (SpoolerProcessHandle) {
        CloseHandle( SpoolerProcessHandle );
    }

    SpoolerProcessHandle = OpenProcess( SYNCHRONIZE, FALSE, SpoolerPid );

exit:
    MemFree( TaskList );
    return SpoolerProcessHandle;
}


DWORD
WaitForSpoolerToStart(
    VOID
    )

/*++

Routine Description:

    This function waits for the spooler service to start.
    It calls the service controller and queries the status
    of the spooler every 2 seconds (polled).

Arguments:

    None.

Return Value:

    Error code.

--*/

{
    DWORD                   rVal = 0;
    SC_HANDLE               hSvcMgr = NULL;
    SC_HANDLE               hService = NULL;
    SERVICE_STATUS          Status;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        rVal = GetLastError();
        DebugPrint(( TEXT("could not open service manager: error code = %u"), rVal ));
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        TEXT("Spooler"),
        SERVICE_ALL_ACCESS
        );
    if (!hService) {
        rVal = GetLastError();
        DebugPrint((
            TEXT("could not open the Spooler service: error code = %u"),
            rVal
            ));
        goto exit;
    }

    if (!QueryServiceStatus( hService, &Status )) {
        rVal = GetLastError();
        DebugPrint((
            TEXT("could not query status for the Spooler service: error code = %u"),
            rVal
            ));
        goto exit;
    }

    while (Status.dwCurrentState != SERVICE_RUNNING) {

        Sleep( 1000 * 2 );

        if (!QueryServiceStatus( hService, &Status )) {
            break;
        }

    }

    if (Status.dwCurrentState != SERVICE_RUNNING) {
        rVal = GetLastError();
        DebugPrint((
            TEXT("could not start the Spooler service: error code = %u"),
            rVal
            ));
        goto exit;
    }

    rVal = ERROR_SUCCESS;

    //
    // get the spooler's process handle
    //

    SpoolerProcessHandle = GetSpoolerProcessHandle();

exit:

    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}


DWORD
PrintStatusThread(
    LPVOID NotUsed
    )

/*++

Routine Description:

    This function runs as a thread to process print
    status changes.  Each fax printer sends status changes
    in the form of events to this thread.  When it is
    determined that a job is being deleted, the abort
    function for the device provider is called to
    terminate the fax send operation.

Arguments:

    None.

Return Value:

    Error code.

--*/

{
    DWORD FailCount = 0;
    PPRINTER_NOTIFY_INFO PrinterNotifyInfo;
    DWORD WaitObject;
    DWORD Change;
    HANDLE CleanQueueHandle = NULL;


    while (TRUE) {

        //
        // wat for a job notification change
        //

        if (!HandleCount) {
            if (WaitForSpoolerToStart() != ERROR_SUCCESS) {
                FaxLog(
                    FAXLOG_CATEGORY_UNKNOWN,
                    FAXLOG_LEVEL_MIN,
                    0,
                    MSG_PRINTER_FAILURE
                    );
                ReportServiceStatus( SERVICE_STOPPED, 0, 0 );
                ExitProcess(0);
            }
            if (!RefreshPrinterInfo()) {
                FailCount += 1;
                Sleep( 1000 );
                if (FailCount == 20) {
                    FaxLog(
                        FAXLOG_CATEGORY_UNKNOWN,
                        FAXLOG_LEVEL_MIN,
                        0,
                        MSG_PRINTER_FAILURE
                        );
                    ReportServiceStatus( SERVICE_STOPPED, 0, 0 );
                    ExitProcess(0);
                }
            }
            continue;
        }

        WaitObject = WaitForMultipleObjects(
            HandleCount,
            FaxPrinterNotifyHandles,
            FALSE,
            INFINITE
            );

        if (WaitObject == WAIT_FAILED || (WaitObject >= HandleCount && WaitObject < MAXIMUM_WAIT_OBJECTS)) {

            //
            // there was some problem in receiving the event
            //

            DebugPrint(( TEXT("WaitForMultipleObjects() failed, ec=%d"), GetLastError() ));
            continue;
        }

        if (WaitObject == SpoolerProcessIdx) {

            //
            // the spooler just ended
            //

            SpoolerProcessHandle = 0;
            SpoolerProcessIdx = 0;

            WaitForSpoolerToStart();

            RefreshPrinterInfo();

            continue;
        }

        if (WaitObject == DirtyTimerIdx) {
            DWORD ThreadId;
            DWORD WaitObject;

            //
            // if the thread is still running, don't create another one
            //

            if (CleanQueueHandle != NULL) {

                WaitObject = WaitForSingleObject( CleanQueueHandle, 0 );

                if (WaitObject == WAIT_TIMEOUT) {
                    continue;
                }

                CloseHandle( CleanQueueHandle );
            }

            CleanQueueHandle = CreateThread(
                NULL,
                1024*100,
                (LPTHREAD_START_ROUTINE) CleanDirtyQueues,
                NULL,
                0,
                &ThreadId
                );

            if (CleanQueueHandle == NULL) {
                DebugPrint(( TEXT("Cannot create CleanDirtyQueues thread") ));
            }

            continue;

        }

        if (WaitObject == ModemTimerIdx) {

            PLIST_ENTRY Next;
            PLINE_INFO LineInfo;

            EnterCriticalSection( &CsLine );

            Next = TapiLinesListHead.Flink;
            if (Next) {
                while ((ULONG)Next != (ULONG)&TapiLinesListHead) {

                    LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
                    Next = LineInfo->ListEntry.Flink;

                    if (LineInfo->UnimodemDevice && (LineInfo->Flags & FPF_POWERED_OFF) &&
                        (LineInfo->Flags & FPF_RECEIVE_OK)) {

                        //
                        // put a popup on the currently active desktop
                        // we only allow 1 popup per device at a time
                        // and we only present the popup twice
                        //

                        if (!LineInfo->ModemInUse &&
                            LineInfo->ModemPopupActive &&
                            LineInfo->ModemPopUps < MAX_MODEM_POPUPS)
                        {

                            LineInfo->ModemPopupActive = 0;
                            LineInfo->ModemPopUps += 1;

                            ServiceMessageBox(
                                GetString( IDS_POWERED_OFF_MODEM ),
                                MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND,
                                TRUE,
                                &LineInfo->ModemPopupActive
                                );

                        }

                        //
                        // see if we can revive the device
                        //

                        if (OpenTapiLine( LineInfo )) {

                            LPLINEDEVSTATUS LineDevStatus;

                            //
                            // check to see if the line is in use
                            //

                            LineDevStatus = MyLineGetLineDevStatus( LineInfo->hLine );
                            if (LineDevStatus) {
                                if (LineDevStatus->dwNumOpens > 0 && LineDevStatus->dwNumActiveCalls > 0) {
                                    LineInfo->ModemInUse = TRUE;
                                } else {
                                    LineInfo->ModemInUse = FALSE;
                                }
                                MemFree( LineDevStatus );
                            }

                            if (!LineInfo->ModemInUse) {

                                DebugPrint(( TEXT("Device %s is now powered on, connected, and ready for use"), LineInfo->DeviceName ));

                                LineInfo->Flags &= ~FPF_POWERED_OFF;
                                LineInfo->Flags &= ~FPF_RECEIVE_OK;
                                LineInfo->Flags |= FPF_RECEIVE;

                                LineInfo->State = FPS_AVAILABLE;

                                CreateFaxEvent( LineInfo->PermanentLineID, FEI_MODEM_POWERED_ON );
                            }
                        }

                        if (LineInfo->Flags & FPF_POWERED_OFF) {
                            DebugPrint(( TEXT("Could not revive device [%s]"), LineInfo->DeviceName ));
                        }
                    }
                }
            }

            LeaveCriticalSection( &CsLine );

            continue;

        }

        //
        // get the status information from the spooler
        //

        if (!FindNextPrinterChangeNotification( FaxPrinterNotifyHandles[WaitObject], &Change, NULL, &PrinterNotifyInfo )) {
            DebugPrint(( TEXT("FindNextPrinterChangeNotification() failed, ec=%d"), GetLastError() ));
            continue;
        }

        if (Change == PRINTER_CHANGE_ADD_PRINTER || Change == PRINTER_CHANGE_DELETE_PRINTER) {

            //
            // get the current printer info
            //

            RefreshPrinterInfo();

        } else if (PrinterNotifyInfo && PrinterNotifyInfo->aData[0].Field == JOB_NOTIFY_FIELD_STATUS) {

            HandleJobChange(
                &FaxPrinterInfo[WaitObject],
                PrinterNotifyInfo->aData[0].NotifyData.adwData[0],
                PrinterNotifyInfo->aData[0].Id
                );

        }

        //
        // free the spooler allocated memory
        //

        FreePrinterNotifyInfo( PrinterNotifyInfo );
    }

    return 0;
}


VOID
DisallowFaxSharing(
    VOID
    )
{
    HANDLE hPrinterServer;
    PRINTER_DEFAULTS PrinterDefaults;
    TCHAR String[128];
    LONG Rslt;
    DWORD Size;


    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = SERVER_ACCESS_ADMINISTER;

    if (!OpenPrinter( NULL, &hPrinterServer, &PrinterDefaults )) {
        DebugPrint(( TEXT("OpenPrinter() failed, ec=%d"), GetLastError() ));
        return;
    }

    _tcscpy( String, FAX_DRIVER_NAME );
    Size = StringSize( String );

    Rslt = SetPrinterData(
        hPrinterServer,
        SPLREG_NO_REMOTE_PRINTER_DRIVERS,
        REG_SZ,
        (LPBYTE) String,
        Size
        );
    if ((Rslt != ERROR_SUCCESS) && (Rslt != ERROR_SUCCESS_RESTART_REQUIRED)) {
        DebugPrint(( TEXT("SetPrinterData() failed, ec=%d"), Rslt ));
    }

    ClosePrinter( hPrinterServer );

    return;
}



BOOL
InitializePrinting(
    VOID
    )

/*++

Routine Description:

    This function initializes the printing thread.  The thread
    is used to handle the case where the user that started a
    fax send wants to delete the print job.

Arguments:

    None.

Return Value:

    TRUE for success.
    FALSE for failure.

--*/

{
    DWORD ThreadId;
    HANDLE hThread;


    //
    // this shouldn't be necessary, but someone might
    // figure out how to subvert our security
    //

    if (InstallType & FAX_INSTALL_WORKSTATION) {
        DisallowFaxSharing();
    }

    //
    // get the spooler's process handle
    //

    SpoolerProcessHandle = GetSpoolerProcessHandle();

    //
    // get the current printer info
    //

    RefreshPrinterInfo();

    //
    // start the thread that will do the actual
    // status processing
    //

    hThread = CreateThread(
        NULL,
        1024*100,
        (LPTHREAD_START_ROUTINE) PrintStatusThread,
        NULL,
        0,
        &ThreadId
        );

    if (!hThread) {
        return GetLastError();
    }

    CloseHandle( hThread );

    return TRUE;
}

VOID
CleanDirtyQueues(
    VOID
    )
/*++

Routine Description:

    This function is invoked periodically by PrintStatusThread to clean the fax printer queues of
    print jobs that have failed to be sent and have been in the queue longer than FaxDirtyDays.

    This function also attempts to route inbound faxes that have failed previous routing attempts.

Arguments:

    None.

Return Value:

    None.

--*/
{
#if 0
    DWORD i;
    DWORD j;
    PJOB_INFO_2 JobInfo;
    BYTE JobBuffer[4096];
    BOOL Result;
    DWORD cbData;
    DWORD cJobs;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER SubmitTime;
    DWORD cBytes;
    DWORD Retries;
    LPTSTR RetryTag;
    LPTSTR RouteTag;
    DWORD WaitObject;

    // wait for the server to come up completely

    WaitObject = WaitForSingleObject( FaxServerEvent, INFINITE );

    DebugPrint(( TEXT("Cleaning print queues") ));

    GetSystemTimeAsFileTime( (FILETIME *) &CurrentTime );

    // enumerate all of the print jobs in all of the fax printers

    for (i = 0; i < FaxPrinters; i++) {

        for (j = 0; TRUE ; j++) {

            Result = EnumJobs(
                FaxPrinterInfo[i].hPrinter,
                j,
                1,
                2,
                JobBuffer,
                sizeof(JobBuffer),
                &cbData,
                &cJobs
                );

            JobInfo = (PJOB_INFO_2) JobBuffer;

            if (!Result || cJobs == 0) {
                break;
            }

            // only consider the jobs that are paused

            if (!(JobInfo->Status & JOB_STATUS_PAUSED) || JobInfo->pParameters == NULL) {
                continue;
            }

            // if it is a send retry that has maxed out, delete the job

            RetryTag = ExtractFaxTag(FAXTAG_SEND_RETRY, JobInfo->pParameters, &cBytes);

            if (RetryTag) {

                Retries = _ttoi( RetryTag );

                if (Retries == 0) {

                    SystemTimeToFileTime( &JobInfo->Submitted, (FILETIME *) &SubmitTime);

                    if (SubmitTime.QuadPart + (FaxDirtyDays * FILETIMETICKS_PER_DAY) < CurrentTime.QuadPart) {

                        while (SetPrintJobCompleted( FaxPrinterInfo[i].hPrinter, JobInfo->JobId ))
                            ;
                    }
                }
                continue;
            }

            // if it is an inbound routing failure, try to route it again

            RouteTag = ExtractFaxTag(FAXTAG_ROUTE_FILE, JobInfo->pParameters, &cBytes);

            if (RouteTag) {

                PROUTE_INFO RouteInfo;

                RouteTag++;     // skip over the space

                RouteInfo = LoadRouteInfo( RouteTag );

                if (RouteInfo != NULL) {

                    __try {

                        FaxRoute(
                            &RouteInfo->FaxReceive,
                            &RouteInfo->LineInfo,
                            &RouteInfo->FaxStatus,
                            NULL,
                            0,
                            RouteInfo->ElapsedTime
                            );

                    } __except (EXCEPTION_EXECUTE_HANDLER) {

                        // if the file is corrupt and causes an exception, delete it and cancel the print job

                        DebugPrint(( TEXT("Exception processing routing information file") ));

                        DeleteFile( RouteTag );

                    }

                    MemFree( RouteInfo );

                    if (GetFileAttributes( RouteTag ) == 0xffffffff) {

                        if(!SetJob(
                            FaxPrinterInfo[i].hPrinter,
                            JobInfo->JobId,
                            0,
                            NULL,
                            JOB_CONTROL_CANCEL
                            )) {
                                DebugPrint(( TEXT("CleanDirtyQueues - SetJob failed - ec %d"), GetLastError() ));
                            }
                    } else {

                        SetPrintJobStatus(
                            FaxPrinterInfo[i].hPrinter,
                            JobInfo->JobId,
                            FPS_ROUTERETRY,
                            NULL,
                            -1
                            );

                    }
                }
            }
        }
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\server\resource.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    This file contains all manafest contants for TIFFVIEW's resources.

Author:

    Wesley Witt (wesw) 27-June-1995

Environment:

    User Mode

--*/


//
// icons
//
#define IDI_APPICON                     501

#define IDS_DIALING                     601
#define IDS_SENDING                     602
#define IDS_RECEIVING                   603
#define IDS_COMPLETED                   604
#define IDS_HANDLED                     605
#define IDS_LINE_UNAVAILABLE            606
#define IDS_BUSY                        607
#define IDS_NO_ANSWER                   608
#define IDS_BAD_ADDRESS                 609
#define IDS_NO_DIAL_TONE                610
#define IDS_DISCONNECTED                611
#define IDS_FATAL_ERROR                 612
#define IDS_NOT_FAX_CALL                613
#define IDS_CALL_DELAYED                614
#define IDS_CALL_BLACKLISTED            615
#define IDS_UNAVAILABLE                 616
#define IDS_AVAILABLE                   617
#define IDS_ABORTING                    618
#define IDS_ROUTING                     619
#define IDS_INITIALIZING                620
#define IDS_SENDFAILED                  621
#define IDS_SENDRETRY                   622
#define IDS_BLANKSTR                    623
#define IDS_ROUTERETRY                  624
#define IDS_DR_SUBJECT                  625
#define IDS_DR_FILENAME                 626
#define IDS_NDR_SUBJECT                 627
#define IDS_NDR_FILENAME                628
#define IDS_POWERED_OFF_MODEM           629
#define IDS_SERVICE_NAME                630
#define IDS_SERVER_NAME                 631
#define IDS_ANSWERED                    633
#define IDS_NO_MAPI_LOGON               634
#define IDS_DEFAULT                     635
#define IDS_NO_SEND_DEVICES             636
#define IDS_FAX_LOG_CATEGORY_INIT_TERM  637
#define IDS_FAX_LOG_CATEGORY_OUTBOUND   638
#define IDS_FAX_LOG_CATEGORY_INBOUND    639
#define IDS_FAX_LOG_CATEGORY_UNKNOWN    640
#define IDS_SET_CONFIG                  641
#define IDS_MODEM_PROVIDER_NAME         642
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\server\receive.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    receive.c

Abstract:

    This module handles the FAX receive case.

Author:

    Wesley Witt (wesw) 6-Mar-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop


DWORD
FaxReceiveThread(
    PFAX_RECEIVE_ITEM FaxReceiveItem
    )

/*++

Routine Description:

    This function process a FAX send operation.  This runs
    asynchronously as a separate thread.  There is one
    thread for each outstanding FAX operation.

Arguments:

    FaxReceiveItem  - FAX receive packet

Return Value:

    Error code.

--*/

{
    DWORD rVal = ERROR_SUCCESS;
    PJOB_ENTRY JobEntry;
    DWORD JobId;
    PLINE_INFO LineInfo;
    PFAX_RECEIVE FaxReceive = NULL;
    PFAX_DEV_STATUS FaxStatus = NULL;
    DWORD ReceiveSize;
    DWORD StatusSize;
    BOOL Result;
    DWORD BytesNeeded;
    DWORDLONG ElapsedTime = 0;
    DWORDLONG ReceiveTime = 0;
    BOOL DoFaxRoute = FALSE;
    DWORD Attrib;
    DWORD RecoveredPages,TotalPages;
    MS_TAG_INFO MsTagInfo;
    BOOL fReceiveNoFile = FALSE;
    BOOL ReceiveFailed = FALSE;
    PJOB_QUEUE JobQueue = NULL;
    BOOL DeviceCanSend;

    __try {

        LineInfo = FaxReceiveItem->LineInfo;
        JobEntry = FaxReceiveItem->JobEntry;

        JobQueue = AddJobQueueEntry(
            JT_RECEIVE,
            FaxReceiveItem->FileName,
            NULL,
            NULL,
            FALSE,
            JobEntry
            );

        if (!JobQueue) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        JobId = JobQueue->JobId;
        DeviceCanSend = ((LineInfo->Flags & FPF_SEND) == FPF_SEND);

        //
        // allocate memory for the receive packet
        // this is a variable size packet based
        // on the size of the strings contained
        // withing the packet.
        //

        ReceiveSize = sizeof(FAX_RECEIVE) + FAXDEVRECEIVE_SIZE;
        FaxReceive = MemAlloc( ReceiveSize );
        if (!FaxReceive) {
            RemoveJobQueueEntry( JobQueue );
            JobQueue = NULL;
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // allocate memory for the status packet
        // this is a variable size packet based
        // on the size of the strings contained
        // withing the packet.
        //

        StatusSize = sizeof(FAX_DEV_STATUS) + FAXDEVREPORTSTATUS_SIZE;
        FaxStatus = (PFAX_DEV_STATUS) MemAlloc( StatusSize );
        if (!FaxStatus) {
            RemoveJobQueueEntry( JobQueue );
            JobQueue = NULL;
            MemFree( JobQueue );
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        SetThreadExecutionState(ES_SYSTEM_REQUIRED | ES_CONTINUOUS);

        //
        // setup the status packet
        //

        FaxStatus->SizeOfStruct = StatusSize;

        //
        // setup the receive packet
        //

        FaxReceive->SizeOfStruct    = ReceiveSize;

        //
        // copy filename into place
        //
        FaxReceive->FileName        = (LPTSTR) ((LPBYTE)FaxReceive + sizeof(FAX_RECEIVE));
        _tcscpy( FaxReceive->FileName, FaxReceiveItem->FileName );

        FaxReceive->ReceiverName    = NULL;
        
        //
        // copy number into place right after filename
        //
        FaxReceive->ReceiverNumber  = (LPTSTR) ( (LPBYTE)FaxReceive->FileName +
                            sizeof(TCHAR)*(_tcslen(FaxReceive->FileName) + 1));
        _tcscpy( FaxReceive->ReceiverNumber, LineInfo->Csid );
                    
        FaxReceive->Reserved[0]     = 0;
        FaxReceive->Reserved[1]     = 0;
        FaxReceive->Reserved[2]     = 0;
        FaxReceive->Reserved[3]     = 0;

        

        Attrib = GetFileAttributes( FaxReceiveDir );
        if (Attrib == 0xffffffff) {
            MakeDirectory( FaxReceiveDir );
        }
        Attrib = GetFileAttributes( FaxReceiveDir );
        if (Attrib == 0xffffffff) {
            FaxLog(
                FAXLOG_CATEGORY_INBOUND,
                FAXLOG_LEVEL_MAX,
                1,
                MSG_FAX_RECEIVE_NODIR,
                FaxReceiveDir
                );
        }

        Attrib = GetFileAttributes( FaxReceive->FileName );
        if (Attrib == 0xffffffff) {
            FaxLog(
                FAXLOG_CATEGORY_INBOUND,
                FAXLOG_LEVEL_MIN,
                1,
                MSG_FAX_RECEIVE_NOFILE,
                FaxReceive->FileName
                );
            fReceiveNoFile = TRUE;
            DebugPrint(( TEXT("FaxReceive - %s does not exist"), FaxReceive->FileName ));

        } else {
            DebugPrint(( TEXT("Starting FAX receive into %s"), FaxReceive->FileName ));
        }

        //
        // do the actual receive
        //

        __try {

            Result = LineInfo->Provider->FaxDevReceive(
                    (HANDLE) JobEntry->InstanceData,
                    FaxReceiveItem->hCall,
                    FaxReceive
                    );

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            Result = FALSE;
            DebugPrint(( TEXT("FaxDevReceive() failed: 0x%08x"), GetExceptionCode() ));
            ReceiveFailed = TRUE;

        }

        __try {

            LineInfo->Provider->FaxDevReportStatus(
               (HANDLE) JobEntry->InstanceData,
                FaxStatus,
                StatusSize,
                &BytesNeeded
                );

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            DebugPrint(( TEXT("FaxDevReportStatus() failed: 0x%08x"), GetExceptionCode() ));

        }

        if (!Result) {

            DebugPrint(( TEXT("FAX receive failed: 0x%08x"), FaxStatus->StatusId ));
            ReceiveFailed = TRUE;

            if (FaxStatus->StatusId == FS_NOT_FAX_CALL) {
                if (HandoffCallToRas( LineInfo, FaxReceiveItem->hCall )) {
                    FaxReceiveItem->hCall = 0;
                    LineInfo->State = FPS_NOT_FAX_CALL;
                    DeviceCanSend = FALSE;
                }
                RemoveJobQueueEntry( JobQueue );
                JobQueue = NULL;
                DeleteFile( FaxReceive->FileName );
            }

            if ( (FaxStatus->StatusId == FS_FATAL_ERROR) && (! fReceiveNoFile) ) {
                //
                // try to recover one or more pages of the received fax
                //
                if (!TiffRecoverGoodPages(FaxReceive->FileName,&RecoveredPages,&TotalPages) ) {
                    //
                    // couldn't recover any pages, just log an error and delete the received fax.
                    //
rxerr:
                    FaxLog(
                           FAXLOG_CATEGORY_INBOUND,
                           FAXLOG_LEVEL_MIN,
                           0,
                           MSG_FAX_RECEIVE_FAILED
                           );
                    //DeleteFile( FaxReceive->FileName );
                } else {
                    //
                    // recovered some pages, log a message and add to job queue
                    //
                    TCHAR RecoverCountStrBuf[64];
                    TCHAR TotalCountStrBuf[64];
                    TCHAR TimeStr[128];
                    LPTSTR ToStr;
                    TCHAR RecoverFileName[MAX_PATH];
                    
                    GenerateUniqueFileName( FaxReceiveDir, TEXT("tif"), RecoverFileName, MAX_PATH );
                    if (!CopyFile(FaxReceive->FileName,RecoverFileName,FALSE)) {
                        goto rxerr;
                    }
                     
                    FormatElapsedTimeStr(
                        (FILETIME*)&JobEntry->ElapsedTime,
                        TimeStr,
                        sizeof(TimeStr)
                        );

                    _ltot((LONG) RecoveredPages, RecoverCountStrBuf, 10);
                    _ltot((LONG) TotalPages, TotalCountStrBuf, 10);

                    if (FaxStatus->RoutingInfo == NULL || FaxStatus->RoutingInfo[0] == 0) {
                        ToStr = FaxReceive->ReceiverNumber;
                    } else {
                        ToStr = FaxStatus->RoutingInfo;

                    }
                    FaxLog(
                           FAXLOG_CATEGORY_INBOUND,
                           FAXLOG_LEVEL_MIN,
                           8,
                           MSG_FAX_RECEIVE_FAIL_RECOVER,
                           RecoverFileName,
                           FaxStatus->CSI,
                           FaxStatus->CallerId,
                           ToStr,
                           RecoverCountStrBuf,
                           TotalCountStrBuf,
                           TimeStr,
                           JobEntry->LineInfo->DeviceName
                          );
                    AddJobQueueEntry( JT_FAIL_RECEIVE,
                                      RecoverFileName,
                                      NULL,
                                      NULL,
                                      FALSE,
                                      NULL );
                }

                RemoveJobQueueEntry( JobQueue );
                JobQueue = NULL;

            }

            if (FaxStatus->StatusId == FS_USER_ABORT) {
                FaxLog(
                    FAXLOG_CATEGORY_INBOUND,
                    FAXLOG_LEVEL_MED,
                    0,
                    MSG_FAX_RECEIVE_USER_ABORT
                    );
                RemoveJobQueueEntry( JobQueue );
                JobQueue = NULL;
                //DeleteFile( FaxReceive->FileName);
            }
        } else {

            __try {

                GetSystemTimeAsFileTime( (FILETIME*) &JobEntry->EndTime );
                ReceiveTime = JobEntry->StartTime;
                JobEntry->ElapsedTime = JobEntry->EndTime - JobEntry->StartTime;

                if (!TiffPostProcessFast( FaxReceive->FileName, NULL )) {

                    DebugPrint(( TEXT("failed to post process the TIFF file") ));
                    DebugPrint(( TEXT("FAX receive %d failed"), JobId ));
                    ReceiveFailed = TRUE;

                    FaxLog(
                           FAXLOG_CATEGORY_INBOUND,
                           FAXLOG_LEVEL_MIN,
                           0,
                           MSG_FAX_RECEIVE_FAILED
                           );

                    RemoveJobQueueEntry( JobQueue );
                    JobQueue = NULL;
                } else {

                    TCHAR PageCountStrBuf[64];
                    TCHAR TimeStr[128];
                    LPTSTR ToStr;

                    DebugPrint(( TEXT("FAX receive %d succeeded"), JobId ));

                    FormatElapsedTimeStr(
                        (FILETIME*)&JobEntry->ElapsedTime,
                        TimeStr,
                        sizeof(TimeStr)
                        );

                    _ltot((LONG) FaxStatus->PageCount, PageCountStrBuf, 10);

                    if (FaxStatus->RoutingInfo == NULL || FaxStatus->RoutingInfo[0] == 0) {
                        ToStr = FaxReceive->ReceiverNumber;
                    } else {
                        ToStr = FaxStatus->RoutingInfo;

                    }
                    FaxLog(
                        FAXLOG_CATEGORY_INBOUND,
                        FAXLOG_LEVEL_MED,
                        7,
                        MSG_FAX_RECEIVE_SUCCESS,
                        FaxReceive->FileName,
                        FaxStatus->CSI,
                        FaxStatus->CallerId,
                        ToStr,
                        PageCountStrBuf,
                        TimeStr,
                        JobEntry->LineInfo->DeviceName
                        );

                    ElapsedTime = JobEntry->ElapsedTime;
                    DoFaxRoute = TRUE;
                }

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                DebugPrint(( TEXT("failed to post process the TIFF file, ec=%x"), GetExceptionCode() ));
                ReceiveFailed = TRUE;
                RemoveJobQueueEntry( JobQueue );
                JobQueue = NULL;
            }

        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        DebugPrint(( TEXT("FAX receive failed due to exception in device provider, ec=0x%08x"), GetExceptionCode() ));

        ReceiveFailed = TRUE;
        RemoveJobQueueEntry( JobQueue );
        JobQueue = NULL;
    }

    if (PerfCounters && ReceiveFailed && LineInfo->State != FPS_NOT_FAX_CALL) {
        InterlockedIncrement( (PLONG)&PerfCounters->InboundFailedReceive );
    }

    //
    // end the job
    //

    JobEntry->RefCount -= 1;
    if (JobEntry->RefCount == 0 && JobEntry->hEventEnd) {
        SetEvent( JobEntry->hEventEnd );
    }

    ReleaseJob( JobEntry );

    //
    // add the microsoft fax tags to the file
    // this is necessary ONLY when we route the
    // file when doing a receive.  if we are not
    // routing the file then it is deleted, so
    // adding the tags is not necessary.
    //

    MsTagInfo.RecipName     = FaxReceive->ReceiverName;
    MsTagInfo.RecipNumber   = FaxReceive->ReceiverNumber;
    MsTagInfo.SenderName    = NULL;
    MsTagInfo.Routing       = FaxStatus->RoutingInfo;
    MsTagInfo.CallerId      = FaxStatus->CallerId;
    MsTagInfo.Csid          = FaxReceive->ReceiverNumber;
    MsTagInfo.Tsid          = FaxStatus->CSI;
    MsTagInfo.FaxTime       = ReceiveTime;

    TiffAddMsTags( FaxReceive->FileName, &MsTagInfo );

    //
    // route the newly received fax
    //

    if (DoFaxRoute) {

        if (PerfCounters){
            SYSTEMTIME SystemTime ;
            DWORD Seconds ;
            HANDLE hFileHandle;
            DWORD Bytes = 0 ;
            InterlockedIncrement( (LPLONG) &PerfCounters->InboundFaxes ) ;
            InterlockedIncrement( (LPLONG) &PerfCounters->TotalFaxes ) ;
            FileTimeToSystemTime( (FILETIME*)&ElapsedTime, &SystemTime );
            Seconds = (DWORD)( SystemTime.wSecond + 60 * ( SystemTime.wMinute + 60 * SystemTime.wHour ));
            InterlockedExchangeAdd( (PLONG)&PerfCounters->InboundPages, (LONG)FaxStatus->PageCount );
            InterlockedExchangeAdd( (PLONG)&PerfCounters->TotalPages, (LONG)FaxStatus->PageCount );
            hFileHandle = CreateFile(
                FaxReceive->FileName,
                GENERIC_READ,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );
            if ( hFileHandle != INVALID_HANDLE_VALUE ){
                Bytes = GetFileSize( hFileHandle, NULL );
                CloseHandle( hFileHandle );
            }
            EnterCriticalSection( &CsPerfCounters );

            InboundSeconds += Seconds;
            TotalSeconds += Seconds;
            PerfCounters->InboundMinutes = InboundSeconds/60 ;
            PerfCounters->TotalMinutes = TotalSeconds/60;
            PerfCounters->InboundBytes += Bytes;
            PerfCounters->TotalBytes += Bytes;

            LeaveCriticalSection( &CsPerfCounters );
        }

        __try {

            BOOL RouteSucceeded;
            PROUTE_FAILURE_INFO RouteFailureInfo;
            DWORD CountFailureInfo;
            PFAX_ROUTE Route = MemAlloc( sizeof(FAX_ROUTE) );


            if (Route == NULL) {
                __leave;
            }
            //
            // now setup the fax routing data structure
            //

            Route->SizeOfStruct    = sizeof(FAX_ROUTE);
            Route->JobId           = JobId;
            Route->ElapsedTime     = ElapsedTime;
            Route->ReceiveTime     = ReceiveTime;
            Route->PageCount       = FaxStatus->PageCount;
            Route->Csid            = StringDup( FaxReceive->ReceiverNumber );
            Route->Tsid            = StringDup( FaxStatus->CSI );
            Route->CallerId        = StringDup( FaxStatus->CallerId );
            Route->ReceiverName    = StringDup( FaxReceive->ReceiverName );
            Route->ReceiverNumber  = StringDup( FaxReceive->ReceiverNumber );
            Route->DeviceName      = LineInfo->DeviceName;
            Route->DeviceId        = LineInfo->PermanentLineID;
            Route->RoutingInfo     = StringDup( FaxStatus->RoutingInfo );
            JobQueue->FaxRoute     = Route;

            JobQueue->FaxRoute =    Route;

            RouteSucceeded = FaxRoute(
                JobQueue,
                FaxReceive->FileName,
                Route,
                &RouteFailureInfo,
                &CountFailureInfo
                );


            if (!RouteSucceeded)
            {
                INT i;
                TCHAR QueueFileName[MAX_PATH];

                EnterCriticalSection( &CsQueue );
                //
                // wrap the critical section stuff in try block so we always release CsQueue
                //
                __try {

                   JobQueue->CountFailureInfo = CountFailureInfo;

                   for (i = 0; i < (INT) CountFailureInfo; i++) {
                       JobQueue->RouteFailureInfo[i] = RouteFailureInfo[i];
                   }

                   GenerateUniqueFileName( FaxQueueDir, TEXT("fqe"), QueueFileName, sizeof(QueueFileName)/sizeof(WCHAR) );

                   JobQueue->QueueFileName = StringDup( QueueFileName );
                   JobQueue->JobType = JT_ROUTING;
                   JobQueue->JobStatus = JS_RETRYING;
                   RescheduleJobQueueEntry( JobQueue );
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                   DebugPrint(( TEXT("FaxRoute() crashed, ec=0x%08x"), GetExceptionCode() ));
                }

                LeaveCriticalSection( &CsQueue );

            } else {

                RemoveJobQueueEntry( JobQueue );

                JobQueue = NULL;
            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            DebugPrint(( TEXT("FaxRoute() crashed, ec=0x%08x"), GetExceptionCode() ));

        }

    }

    EnterCriticalSection( &CsQueue );

    if (JobQueue && JobQueue->JobEntry && (JobQueue->JobType != JT_ROUTING)) {        
        JobQueue->JobStatus = JS_DELETING;
        JobQueue->JobEntry = NULL;
    }

    LeaveCriticalSection( &CsQueue );

    EndJob( JobEntry );

    //
    // clean up and exit
    //

    MemFree( FaxReceiveItem->FileName );
    MemFree( FaxReceiveItem );    
    MemFree( FaxReceive );
    MemFree( FaxStatus );

    //
    // signal our queue if we now have a send capable device available.
    // (also false if we're did a RAS handoff, since the device is still in use
    //
    if (DeviceCanSend) {
        ReleaseSemaphore( JobQueueSemaphore, 1, NULL );
    }

    SetThreadExecutionState(ES_CONTINUOUS);

    return rVal;
}


DWORD
StartFaxReceive(
    PJOB_ENTRY      JobEntry,
    HCALL           hCall,
    PLINE_INFO      LineInfo,
    LPTSTR          FileName,
    DWORD           FileNameSize
    )

/*++

Routine Description:

    This function start a FAX receive operation by creating
    a thread that calls the appropriate device provider.

Arguments:

    hCall       - Call handle
    dwMessage   - Reason for the callback
    dwInstance  - LINE_INFO pointer
    dwParam1    - Callback parameter #1
    dwParam2    - Callback parameter #2
    dwParam3    - Callback parameter #3

Return Value:

    Error code.

--*/

{
    PFAX_RECEIVE_ITEM FaxReceiveItem = NULL;
    DWORD rVal = ERROR_SUCCESS;
    HANDLE hThread;
    DWORD ThreadId;



    //
    // generate a filename for the received fax
    //

    GenerateUniqueFileName( FaxReceiveDir, TEXT("tif"), FileName, FileNameSize );

    //
    // allocate the fax receive structure
    //

    FaxReceiveItem = MemAlloc( sizeof(FAX_RECEIVE_ITEM) );
    if (!FaxReceiveItem) {
        rVal = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // setup the fax receive values
    //

    FaxReceiveItem->hCall      = hCall;
    FaxReceiveItem->LineInfo   = LineInfo;
    FaxReceiveItem->JobEntry   = JobEntry;
    FaxReceiveItem->FileName   = StringDup( FileName );

    JobEntry->JobType          = JT_RECEIVE;
    JobEntry->CallHandle       = hCall;
    JobEntry->RefCount        += 1;

    LineInfo->State            = FPS_INITIALIZING;

    //
    // start the receive operation
    //

    hThread = CreateThread(
        NULL,
        1024*100,
        (LPTHREAD_START_ROUTINE) FaxReceiveThread,
        (LPVOID) FaxReceiveItem,
        0,
        &ThreadId
        );

    if (!hThread) {
        MemFree( FaxReceiveItem );
        rVal = GetLastError();
    } else {
        CloseHandle( hThread );
    }

exit:
    return rVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\server\route.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    route.c

Abstract:

    This module implements the inbound routing rules.

Author:

    Wesley Witt (wesw) 1-Apr-1997

Revision History:

--*/

#include "faxsvc.h"
#include "tiff.h"
#pragma hdrstop



BOOL
BuildRouteInfo(
    LPWSTR              TiffFileName,
    PROUTE_FAILURE_INFO RouteFailure,
    DWORD               RouteFailureCount,
    LPWSTR              ReceiverName,
    LPWSTR              ReceiverNumber,
    LPWSTR              DeviceName,
    LPWSTR              Tsid,
    LPWSTR              Csid,
    LPWSTR              CallerId,
    LPWSTR              RoutingInfo,
    DWORDLONG           ElapsedTime
    );

extern DWORD FaxPrinters;

LPVOID InboundProfileInfo;
LPTSTR InboundProfileName;
LIST_ENTRY RoutingExtensions;
LIST_ENTRY RoutingMethods;
DWORD CountRoutingMethods;
CRITICAL_SECTION CsRouting;
BOOL RoutingIsInitialized = FALSE;

LONG WINAPI
FaxRouteAddFile(
    IN DWORD JobId,
    IN LPCWSTR FileName,
    IN GUID *Guid
    )
{
    PJOB_QUEUE JobQueueEntry;
    PFAX_ROUTE_FILE FaxRouteFile;
    WCHAR FullPathName[MAX_PATH];
    LPWSTR fnp;
    DWORD Count;
    WCHAR RouteGuid[MAX_GUID_STRING_LEN];

    StringFromGUID2( Guid, RouteGuid, MAX_GUID_STRING_LEN );

    if (!JobId || !Guid || !FileName) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return -1;
    }

    JobQueueEntry = FindJobQueueEntry( JobId );
    if (!JobQueueEntry) {
        SetLastError( ERROR_INVALID_DATA );
        return -1;
    }

    if ((!IsEqualGUID(Guid,&FaxSvcGuid)) && (!FindRoutingMethodByGuid(RouteGuid))) {
        SetLastError( ERROR_INVALID_DATA );
        return -1;
    }

    if (!GetFullPathName( FileName, sizeof(FullPathName)/sizeof(WCHAR), FullPathName, &fnp )) {
        return -1;
    }

    FaxRouteFile = (PFAX_ROUTE_FILE) MemAlloc( sizeof(FAX_ROUTE_FILE) );
    if (!FaxRouteFile) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return -1;
    }

    FaxRouteFile->FileName = StringDup( FullPathName );

    CopyMemory( &FaxRouteFile->Guid, Guid, sizeof(GUID) );

    EnterCriticalSection( &JobQueueEntry->CsFileList );

    InsertTailList( &JobQueueEntry->FaxRouteFiles, &FaxRouteFile->ListEntry );

    LeaveCriticalSection( &JobQueueEntry->CsFileList );

    //
    // increment file count
    //
    EnterCriticalSection( &CsJob );
        EnterCriticalSection( &CsQueue );
            JobQueueEntry->CountFaxRouteFiles += 1;
            Count = JobQueueEntry->CountFaxRouteFiles;
        LeaveCriticalSection( &CsQueue );
    LeaveCriticalSection( &CsJob );



    return Count;
}


LONG WINAPI
FaxRouteDeleteFile(
    IN DWORD JobId,
    IN LPCWSTR FileName
    )
{
    PJOB_QUEUE JobQueueEntry;
    PFAX_ROUTE_FILE FaxRouteFile;
    PLIST_ENTRY Next;
    LONG Index = 1;

    if (!FileName) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return -1;
    }

    JobQueueEntry = FindJobQueueEntry( JobId );
    if (!JobQueueEntry) {
        SetLastError( ERROR_INVALID_DATA );
        return -1;
    }

    Next = JobQueueEntry->FaxRouteFiles.Flink;
    if (Next == &JobQueueEntry->FaxRouteFiles) {
        SetLastError( ERROR_NO_MORE_FILES );
        return -1;
    }

    EnterCriticalSection( &JobQueueEntry->CsFileList );

    while ((ULONG_PTR)Next != (ULONG_PTR)&JobQueueEntry->FaxRouteFiles) {
        FaxRouteFile = CONTAINING_RECORD( Next, FAX_ROUTE_FILE, ListEntry );
        Next = FaxRouteFile->ListEntry.Flink;
        if (_wcsicmp( FileName, FaxRouteFile->FileName ) == 0) {
            //
            // the initial file is read-only for all extensions
            //
            if (Index == 1) {
                SetLastError( ERROR_INVALID_DATA );
                LeaveCriticalSection( &JobQueueEntry->CsFileList );
                return -1;
            }

            //
            // remove from list, delete the file, cleanup memory
            //
            RemoveEntryList( &FaxRouteFile->ListEntry );
            DeleteFile( FaxRouteFile->FileName );
            MemFree ( FaxRouteFile->FileName ) ;
            MemFree ( FaxRouteFile );

            //
            // decrement file count
            //
            LeaveCriticalSection( &JobQueueEntry->CsFileList );
            EnterCriticalSection( &CsJob );
                EnterCriticalSection( &CsQueue );
                    JobQueueEntry->CountFaxRouteFiles -= 1;
                LeaveCriticalSection( &CsQueue );
            LeaveCriticalSection( &CsJob );

            return Index;
        }
        Index += 1;
    }

    LeaveCriticalSection( &JobQueueEntry->CsFileList );
    SetLastError( ERROR_FILE_NOT_FOUND );
    return -1;

}


BOOL WINAPI
FaxRouteGetFile(
    IN DWORD JobId,
    IN DWORD FileNumber,
    OUT LPWSTR FileNameBuffer,
    OUT LPDWORD RequiredSize
    )
{
    PJOB_QUEUE JobQueueEntry;
    PFAX_ROUTE_FILE FaxRouteFile;
    PLIST_ENTRY Next;
    ULONG Index = 1;

    if (RequiredSize == NULL) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    JobQueueEntry = FindJobQueueEntry( JobId );
    if (!JobQueueEntry) {
        SetLastError( ERROR_INVALID_DATA );
        return FALSE;
    }

    if (JobQueueEntry->CountFaxRouteFiles < Index) {
        SetLastError( ERROR_INVALID_DATA );
    }

    Next = JobQueueEntry->FaxRouteFiles.Flink;
    //
    // make sure list isn't empty
    //
    if (Next == &JobQueueEntry->FaxRouteFiles) {
        SetLastError( ERROR_NO_MORE_FILES );
        return FALSE;
    }

    EnterCriticalSection( &JobQueueEntry->CsFileList );

    while ((ULONG_PTR)Next != (ULONG_PTR)&JobQueueEntry->FaxRouteFiles) {
        FaxRouteFile = CONTAINING_RECORD( Next, FAX_ROUTE_FILE, ListEntry );
        Next = FaxRouteFile->ListEntry.Flink;
        if (Index ==  FileNumber) {
            if (*RequiredSize < (wcslen(FaxRouteFile->FileName)+1)*sizeof(WCHAR)) {
                if (FileNameBuffer == NULL) {
                    *RequiredSize = (wcslen(FaxRouteFile->FileName) + 1)*sizeof(WCHAR);
                }
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
                LeaveCriticalSection( &JobQueueEntry->CsFileList );
                return FALSE;
            } else if (FileNameBuffer) {
                wcscpy( FileNameBuffer, FaxRouteFile->FileName );
                LeaveCriticalSection( &JobQueueEntry->CsFileList );
                return TRUE;
            } else {
                LeaveCriticalSection( &JobQueueEntry->CsFileList );
                SetLastError( ERROR_INVALID_PARAMETER );
                return TRUE;
            }
        }
        Index += 1;
    }

    LeaveCriticalSection( &JobQueueEntry->CsFileList );
    SetLastError( ERROR_NO_MORE_FILES );

    return FALSE;
}


BOOL WINAPI
FaxRouteEnumFiles(
    IN DWORD JobId,
    IN GUID *Guid,
    IN PFAXROUTEENUMFILE FileEnumerator,
    IN PVOID Context
    )
{
    PJOB_QUEUE JobQueueEntry;
    PFAX_ROUTE_FILE FaxRouteFile;
    PLIST_ENTRY Next;

    if (!FileEnumerator) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    JobQueueEntry = FindJobQueueEntry( JobId );
    if (!JobQueueEntry) {
        SetLastError( ERROR_INVALID_DATA );
        return FALSE;
    }

    Next = JobQueueEntry->FaxRouteFiles.Flink;
    if (Next == &JobQueueEntry->FaxRouteFiles) {
        SetLastError( ERROR_NO_MORE_FILES );
        return FALSE;
    }

    EnterCriticalSection( &JobQueueEntry->CsFileList );

    while ((ULONG_PTR)Next != (ULONG_PTR)&JobQueueEntry->FaxRouteFiles) {
        FaxRouteFile = CONTAINING_RECORD( Next, FAX_ROUTE_FILE, ListEntry );
        Next = FaxRouteFile->ListEntry.Flink;
        if (!FileEnumerator( JobId, &FaxRouteFile->Guid, Guid, FaxRouteFile->FileName, Context )) {
            LeaveCriticalSection( &JobQueueEntry->CsFileList );
            return FALSE;
        }
    }

    LeaveCriticalSection( &JobQueueEntry->CsFileList );

    SetLastError( ERROR_NO_MORE_FILES );
    return TRUE;
}


PROUTING_METHOD
FindRoutingMethodByGuid(
    IN LPCWSTR RoutingGuidString
    )
{
    PLIST_ENTRY         NextMethod;
    PROUTING_METHOD     RoutingMethod;
    GUID                RoutingGuid;


    IIDFromString( (LPWSTR)RoutingGuidString, &RoutingGuid );

    EnterCriticalSection( &CsRouting );

    NextMethod = RoutingMethods.Flink;
    if (NextMethod == NULL) {
        LeaveCriticalSection( &CsRouting );
        return NULL;
    }

    while ((ULONG_PTR)NextMethod != (ULONG_PTR)&RoutingMethods) {
        RoutingMethod = CONTAINING_RECORD( NextMethod, ROUTING_METHOD, ListEntryMethod );
        NextMethod = RoutingMethod->ListEntryMethod.Flink;
        if (IsEqualGUID( &RoutingGuid, &RoutingMethod->Guid )) {
            LeaveCriticalSection( &CsRouting );
            return RoutingMethod;
        }
    }

    LeaveCriticalSection( &CsRouting );

    return NULL;
}


DWORD
EnumerateRoutingMethods(
    IN PFAXROUTEMETHODENUM Enumerator,
    IN LPVOID Context
    )
{
    PLIST_ENTRY         NextMethod;
    PROUTING_METHOD     RoutingMethod;
    DWORD               Count = 0;


    EnterCriticalSection( &CsRouting );

    __try {

        NextMethod = RoutingMethods.Flink;
        if (NextMethod == NULL) {
            LeaveCriticalSection( &CsRouting );
            return Count;
        }


        while ((ULONG_PTR)NextMethod != (ULONG_PTR)&RoutingMethods) {
            RoutingMethod = CONTAINING_RECORD( NextMethod, ROUTING_METHOD, ListEntryMethod );
            NextMethod = RoutingMethod->ListEntryMethod.Flink;
            if (!Enumerator( RoutingMethod, Context )) {
                LeaveCriticalSection( &CsRouting );
                return Count;
            }
            Count += 1;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          DebugPrint(( TEXT("EnumerateRoutingMethods crashed, ec = %x\n"), GetExceptionCode() ));
    }

    LeaveCriticalSection( &CsRouting );

    return Count;
}


BOOL
FaxRouteModifyRoutingData(
    DWORD JobId,
    LPCWSTR RoutingGuid,
    LPBYTE RoutingData,
    DWORD RoutingDataSize
    )
{
    PJOB_QUEUE JobQueueEntry = NULL;
    PROUTING_METHOD RoutingMethod = NULL;
    PROUTING_DATA_OVERRIDE RoutingDataOverride = NULL;


    if (JobId == 0 || RoutingGuid == NULL || RoutingData == NULL || RoutingDataSize == 0) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    JobQueueEntry = FindJobQueueEntry( JobId );
    if (!JobQueueEntry) {
        SetLastError( ERROR_INVALID_DATA );
        return FALSE;
    }

    RoutingMethod = FindRoutingMethodByGuid( RoutingGuid );
    if (RoutingMethod == NULL) {
        SetLastError( ERROR_INVALID_DATA );
        return FALSE;
    }

    RoutingDataOverride = (PROUTING_DATA_OVERRIDE) MemAlloc( sizeof(ROUTING_DATA_OVERRIDE) );
    if (RoutingDataOverride == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    RoutingDataOverride->RoutingData = (LPBYTE)MemAlloc( RoutingDataSize );
    if (RoutingDataOverride->RoutingData == NULL) {
        MemFree( RoutingDataOverride );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    RoutingDataOverride->RoutingDataSize = RoutingDataSize;
    RoutingDataOverride->RoutingMethod = RoutingMethod;

    CopyMemory( RoutingDataOverride->RoutingData, RoutingData, RoutingDataSize );

    EnterCriticalSection( &JobQueueEntry->CsRoutingDataOverride );
    InsertTailList( &JobQueueEntry->RoutingDataOverride, &RoutingDataOverride->ListEntry );
    LeaveCriticalSection( &JobQueueEntry->CsRoutingDataOverride );

    return TRUE;
}


int
__cdecl
MethodPriorityCompare(
    const void *arg1,
    const void *arg2
    )
{
    if (((PMETHOD_SORT)arg1)->Priority < ((PMETHOD_SORT)arg2)->Priority) {
        return -1;
    }
    if (((PMETHOD_SORT)arg1)->Priority > ((PMETHOD_SORT)arg2)->Priority) {
        return 1;
    }
    return 0;
}


BOOL
SortMethodPriorities(
    VOID
    )
{
    PLIST_ENTRY Next;
    PROUTING_METHOD RoutingMethod;
    PMETHOD_SORT MethodSort;
    DWORD i;


    EnterCriticalSection( &CsRouting );

    Next = RoutingMethods.Flink;
    if (Next == NULL) {
        LeaveCriticalSection( &CsRouting );
        return FALSE;
    }

    MethodSort = (PMETHOD_SORT) MemAlloc( CountRoutingMethods * sizeof(METHOD_SORT) );
    if (MethodSort == NULL) {
        LeaveCriticalSection( &CsRouting );
        return FALSE;
    }

    i = 0;

    while ((ULONG_PTR)Next != (ULONG_PTR)&RoutingMethods) {
        RoutingMethod = CONTAINING_RECORD( Next, ROUTING_METHOD, ListEntryMethod );
        Next = RoutingMethod->ListEntryMethod.Flink;
        MethodSort[i].Priority = RoutingMethod->Priority;
        MethodSort[i].RoutingMethod = RoutingMethod;
        i += 1;
    }

    qsort(
        (PVOID)MethodSort,
        (int)CountRoutingMethods,
        sizeof(METHOD_SORT),
        MethodPriorityCompare
        );

    InitializeListHead( &RoutingMethods );

    for (i=0; i<CountRoutingMethods; i++) {
        MethodSort[i].RoutingMethod->Priority = i + 1;
        MethodSort[i].RoutingMethod->ListEntryMethod.Flink = NULL;
        MethodSort[i].RoutingMethod->ListEntryMethod.Blink = NULL;
        InsertTailList( &RoutingMethods, &MethodSort[i].RoutingMethod->ListEntryMethod );
    }

    MemFree( MethodSort );

    LeaveCriticalSection( &CsRouting );

    return TRUE;
}

BOOL
CommitMethodChanges(
    VOID
    )
/*++

Routine Description:

    sticks changes to routing into the registry

Arguments:

    NONE

Return Value:

    TRUE for success

--*/
{
    PLIST_ENTRY Next;
    PROUTING_METHOD RoutingMethod;
    TCHAR StrGuid[100];

__try {
    EnterCriticalSection(&CsRouting);

    Next = RoutingMethods.Flink;

    while ((UINT_PTR)Next != (UINT_PTR)&RoutingMethods) {

        RoutingMethod = CONTAINING_RECORD( Next, ROUTING_METHOD , ListEntryMethod );
        Next = RoutingMethod->ListEntryMethod.Flink;

        StringFromGUID2( &RoutingMethod->Guid,
                         StrGuid,
                         sizeof(StrGuid)/sizeof(TCHAR)
                        );

        SetFaxRoutingInfo( RoutingMethod->RoutingExtension->InternalName,
                           RoutingMethod->InternalName,
                           StrGuid,
                           RoutingMethod->Priority,
                           RoutingMethod->FunctionName,
                           RoutingMethod->FriendlyName
                        );
    }

    LeaveCriticalSection(&CsRouting);
} __except (EXCEPTION_EXECUTE_HANDLER) {
    LeaveCriticalSection(&CsRouting);
}

return TRUE;

}

BOOL
InitializeRouting(
    PREG_FAX_SERVICE FaxReg
    )

/*++

Routine Description:

    Initializes routing

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    DWORD i,j;
    HMODULE hModule;
    PROUTING_EXTENSION RoutingExtension;
    PROUTING_METHOD RoutingMethod;
    LPSTR ProcName;
    FAX_ROUTE_CALLBACKROUTINES Callbacks;
    BOOL InitializationSuccess;


    FaxMapiInitialize( FaxSvcHeapHandle, ServiceMessageBox, ServiceDebug );

    InitializeListHead( &RoutingExtensions );
    InitializeListHead( &RoutingMethods );

    Callbacks.SizeOfStruct              = sizeof(FAX_ROUTE_CALLBACKROUTINES);
    Callbacks.FaxRouteAddFile           = FaxRouteAddFile;
    Callbacks.FaxRouteDeleteFile        = FaxRouteDeleteFile;
    Callbacks.FaxRouteGetFile           = FaxRouteGetFile;
    Callbacks.FaxRouteEnumFiles         = FaxRouteEnumFiles;
    Callbacks.FaxRouteModifyRoutingData = FaxRouteModifyRoutingData;

    InitializationSuccess = TRUE;
    for (i=0; i<FaxReg->RoutingExtensionsCount; i++) {


        hModule = LoadLibrary( FaxReg->RoutingExtensions[i].ImageName );
        if (!hModule) {
            DebugStop(( L"LoadLibrary() failed: [%s], ec=%d", FaxReg->RoutingExtensions[i].ImageName, GetLastError() ));
            goto InitializationFailed;
        }

        RoutingExtension = (PROUTING_EXTENSION) MemAlloc( sizeof(ROUTING_EXTENSION) );
        if (!RoutingExtension) {
            FreeLibrary( hModule );
            DebugStop(( L"Could not allocate memory for routing extension %s", FaxReg->RoutingExtensions[i].ImageName ));
            goto InitializationFailed;
        }

        RoutingExtension->hModule = hModule;

        wcscpy( RoutingExtension->FriendlyName, FaxReg->RoutingExtensions[i].FriendlyName );
        wcscpy( RoutingExtension->ImageName,    FaxReg->RoutingExtensions[i].ImageName    );
        wcscpy( RoutingExtension->InternalName, FaxReg->RoutingExtensions[i].InternalName );

        if (wcscmp( RoutingExtension->FriendlyName, FAX_EXTENSION_NAME ) == 0) {
            RoutingExtension->MicrosoftExtension = TRUE;
        }

        RoutingExtension->FaxRouteInitialize = (PFAXROUTEINITIALIZE) GetProcAddress(
            hModule,
            "FaxRouteInitialize"
            );

        RoutingExtension->FaxRouteGetRoutingInfo = (PFAXROUTEGETROUTINGINFO) GetProcAddress(
            hModule,
            "FaxRouteGetRoutingInfo"
            );

        RoutingExtension->FaxRouteSetRoutingInfo = (PFAXROUTESETROUTINGINFO) GetProcAddress(
            hModule,
            "FaxRouteSetRoutingInfo"
            );

        RoutingExtension->FaxRouteDeviceEnable = (PFAXROUTEDEVICEENABLE) GetProcAddress(
            hModule,
            "FaxRouteDeviceEnable"
            );

        RoutingExtension->FaxRouteDeviceChangeNotification = (PFAXROUTEDEVICECHANGENOTIFICATION) GetProcAddress(
            hModule,
            "FaxRouteDeviceChangeNotification"
            );

        if (RoutingExtension->FaxRouteInitialize == NULL ||
            RoutingExtension->FaxRouteGetRoutingInfo == NULL ||
            RoutingExtension->FaxRouteSetRoutingInfo == NULL ||
            RoutingExtension->FaxRouteDeviceChangeNotification == NULL ||
            RoutingExtension->FaxRouteDeviceEnable == NULL)
        {
            //
            // the routing extension dll does not have a complete export list
            //

            MemFree( RoutingExtension );
            FreeLibrary( hModule );
            DebugStop(( L"Routing extension FAILED to initialized [%s]", FaxReg->RoutingExtensions[i].FriendlyName ));
            goto InitializationFailed;

        }

        //
        // create the routing extension's heap and add it to the list
        //

        RoutingExtension->HeapHandle = RoutingExtension->MicrosoftExtension ? FaxSvcHeapHandle : HeapCreate( 0, 1024*100, 1024*1024*2 );
        if (!RoutingExtension->HeapHandle) {

            FreeLibrary( hModule );
            MemFree( RoutingExtension );
            goto InitializationFailed;

        } else {

            __try {
                if (RoutingExtension->FaxRouteInitialize( RoutingExtension->HeapHandle, &Callbacks )) {

                    InsertTailList( &RoutingExtensions, &RoutingExtension->ListEntry );
                    InitializeListHead( &RoutingExtension->RoutingMethods );
                    for (j=0; j<FaxReg->RoutingExtensions[i].RoutingMethodsCount; j++) {

                        RoutingMethod = (PROUTING_METHOD) MemAlloc( sizeof(ROUTING_METHOD) );
                        if (!RoutingMethod) {
                            DebugStop(( L"Could not allocate memory for routing method %s", FaxReg->RoutingExtensions[i].RoutingMethods[j].FunctionName ));
                            goto InitializationFailed;
                        }

                        RoutingMethod->RoutingExtension = RoutingExtension;

                        RoutingMethod->Priority = FaxReg->RoutingExtensions[i].RoutingMethods[j].Priority;

                        RoutingMethod->FriendlyName = StringDup( FaxReg->RoutingExtensions[i].RoutingMethods[j].FriendlyName );
                        if (!RoutingMethod->FriendlyName) {
                            DebugStop(( L"Could not create routing function name [%s]", FaxReg->RoutingExtensions[i].RoutingMethods[j].FunctionName ));
                            MemFree( RoutingMethod );
                            goto InitializationFailed;
                        }

                        RoutingMethod->FunctionName = StringDup( FaxReg->RoutingExtensions[i].RoutingMethods[j].FunctionName );
                        if (!RoutingMethod->FunctionName) {
                            DebugStop(( L"Could not create routing function name [%s]", FaxReg->RoutingExtensions[i].RoutingMethods[j].FunctionName ));
                            MemFree( RoutingMethod );
                            goto InitializationFailed;
                        }

                        RoutingMethod->InternalName = StringDup( FaxReg->RoutingExtensions[i].RoutingMethods[j].InternalName );
                        if (!RoutingMethod->InternalName) {
                            DebugStop(( L"Could not create routing internal name [%s]", FaxReg->RoutingExtensions[i].RoutingMethods[j].InternalName ));
                            MemFree( RoutingMethod );
                            goto InitializationFailed;
                        }

                        ProcName = UnicodeStringToAnsiString( RoutingMethod->FunctionName );
                        if (!ProcName) {
                            DebugStop(( L"Could not create routing function name [%s]", RoutingMethod->FunctionName ));
                            MemFree( RoutingMethod );
                            goto InitializationFailed;
                        }

                        if (IIDFromString( FaxReg->RoutingExtensions[i].RoutingMethods[j].Guid, &RoutingMethod->Guid ) != S_OK) {
                            DebugStop(( L"Invalid GUID string [%s]", FaxReg->RoutingExtensions[i].RoutingMethods[j].Guid ));
                            MemFree( RoutingMethod );
                            goto InitializationFailed;
                        }

                        RoutingMethod->FaxRouteMethod = (PFAXROUTEMETHOD) GetProcAddress(
                            hModule,
                            ProcName
                            );
                        if (!RoutingMethod->FaxRouteMethod) {

                            DebugStop(( L"Could not get function address [%s]", ProcName ));
                            MemFree( RoutingMethod );
                            MemFree( ProcName );

                        } else {

                            MemFree( ProcName );
                            InsertTailList( &RoutingExtension->RoutingMethods, &RoutingMethod->ListEntry );
                            InsertTailList( &RoutingMethods, &RoutingMethod->ListEntryMethod );
                            CountRoutingMethods += 1;

                        }
                    }

                } else {
                    FreeLibrary( hModule );
                    MemFree( RoutingExtension );
                }
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                DebugStop(( L"FaxRouteInitialize() faulted: 0x%08x", GetExceptionCode() ));
                goto InitializationFailed;
            }
        }
        //
        // success initializing this extension
        //
        goto next;

InitializationFailed:
        FaxLog(
                FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_NONE,
                2,
                MSG_ROUTE_INIT_FAILED,
                FaxReg->RoutingExtensions[i].FriendlyName,
                FaxReg->RoutingExtensions[i].ImageName
              );

next:
        ;
    }

    if (FaxReg->InboundProfile && FaxReg->InboundProfile[0]) {
        InboundProfileName = StringDup( FaxReg->InboundProfile );
        InboundProfileInfo = AddNewMapiProfile( FaxReg->InboundProfile, TRUE, TRUE );
        if (!InboundProfileInfo) {
            DebugStop(( L"Could not initialize inbound mapi profile [%s]", FaxReg->InboundProfile ));
        }
    }

    SortMethodPriorities();

    RoutingIsInitialized = TRUE;

    return TRUE;
}


LPWSTR
TiffFileNameToRouteFileName(
    LPWSTR  TiffFileName
    )

/*++

Routine Description:

    Convert a tiff file name to a routing information file name.  The call MUST free
    the memory allocated by this routine.

Arguments:

    TiffFileName    - pointer to tiff file name

Return value:

    A pointer to a routing information file name on success, NULL on fail.

--*/

{
    LPWSTR RouteFileName;
    LPWSTR Ext;

    RouteFileName = StringDup( TiffFileName );

    if (!RouteFileName) {
        return NULL;
    }

    Ext = wcsrchr( RouteFileName, L'.' );

    if (Ext) {

        wcscpy( Ext, L".rte" );
        return RouteFileName;

    } else {

        return NULL;

    }
}


BOOL
FaxRoute(
    PJOB_QUEUE          JobQueueEntry,
    LPTSTR              TiffFileName,
    PFAX_ROUTE          FaxRoute,
    PROUTE_FAILURE_INFO *RouteFailureInfo,
    LPDWORD             RouteFailureCount
    )

/*++

Routine Description:

    Routes a FAX.

Arguments:

    JobQueueEntry           - the job queue entry for the job
    TiffFileName            - filename of the received fax
    FaxRoute                - struct describing received FAX
    RouteFailureInfo        - pointer to receive pointr to eceive buffer ROUTE_FAILURE_INFO structures
    RouteFailureCount       - receives the total number of route failures recorded

Return Value:

    ignored for now

--*/

{
    LPWSTR                  FullPath = NULL;
    LPWSTR                  RouteFileName = TiffFileNameToRouteFileName( TiffFileName );
    LPJOB_INFO_2            JobInfo = NULL;
    PLIST_ENTRY             NextMethod;
    PROUTING_METHOD         RoutingMethod;
    DWORD                   FailureCount = 0;
    PROUTE_FAILURE_INFO     RouteFailure;
    PLIST_ENTRY             NextRoutingOverride;
    PROUTING_DATA_OVERRIDE  RoutingDataOverride;
    BOOL                    RetVal = TRUE;

    *RouteFailureInfo = NULL;
    *RouteFailureCount = 0;

    //
    // if the tiff file has been deleted, delete the routing info file and return
    //

    if (GetFileAttributes( TiffFileName ) == 0xffffffff) {
        DeleteFile( RouteFileName );
        MemFree( RouteFileName );
        return FALSE;
    }

    EnterCriticalSection( &CsRouting );

    NextMethod = RoutingMethods.Flink;
    if (NextMethod) {

        //
        // allocate memory to record the GUIDs of the failed routing methods
        //

        RouteFailure = (PROUTE_FAILURE_INFO) MemAlloc( CountRoutingMethods * sizeof(ROUTE_FAILURE_INFO) );
        if (RouteFailure == NULL) {
            MemFree( RouteFileName );
            LeaveCriticalSection( &CsRouting );
            return FALSE;
        }

        //
        // add the tiff file as the first file
        // in the file name list, the owner is the fax service
        //

        if (FaxRouteAddFile( FaxRoute->JobId, TiffFileName, &FaxSvcGuid ) < 1) {
            LeaveCriticalSection( &CsRouting );
            return FALSE;
        }

        //
        // walk thru all of the routing methods and call them
        //

        while ((ULONG_PTR)NextMethod != (ULONG_PTR)&RoutingMethods) {
            RoutingMethod = CONTAINING_RECORD( NextMethod, ROUTING_METHOD, ListEntryMethod );
            NextMethod = RoutingMethod->ListEntryMethod.Flink;

            __try {

                FaxRoute->RoutingInfoData = NULL;
                FaxRoute->RoutingInfoDataSize = 0;

                EnterCriticalSection( &JobQueueEntry->CsRoutingDataOverride );

                NextRoutingOverride = JobQueueEntry->RoutingDataOverride.Flink;
                if (NextRoutingOverride != NULL) {
                    while ((ULONG_PTR)NextRoutingOverride != (ULONG_PTR)&JobQueueEntry->RoutingDataOverride) {
                        RoutingDataOverride = CONTAINING_RECORD( NextRoutingOverride, ROUTING_DATA_OVERRIDE, ListEntry );
                        NextRoutingOverride = RoutingDataOverride->ListEntry.Flink;
                        if (RoutingDataOverride->RoutingMethod == RoutingMethod) {
                            FaxRoute->RoutingInfoData = RoutingDataOverride->RoutingData;
                            FaxRoute->RoutingInfoDataSize = RoutingDataOverride->RoutingDataSize;
                        }
                    }
                }

                LeaveCriticalSection( &JobQueueEntry->CsRoutingDataOverride );

                RouteFailure[FailureCount].FailureData = NULL;
                RouteFailure[FailureCount].FailureSize = 0;

                if (!RoutingMethod->FaxRouteMethod(
                        FaxRoute,
                        &RouteFailure[FailureCount].FailureData,
                        &RouteFailure[FailureCount].FailureSize ))
                {
                    StringFromGUID2(
                        &RoutingMethod->Guid,
                        RouteFailure[FailureCount++].GuidString,
                        MAX_GUID_STRING_LEN
                        );
                    RetVal = FALSE;
                }

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                DebugStop(( L"FaxRouteProcess() faulted: 0x%08x", GetExceptionCode() ));
                StringFromGUID2(
                    &RoutingMethod->Guid,
                    RouteFailure[FailureCount++].GuidString,
                    MAX_GUID_STRING_LEN
                    );

            }
        }
    }

    if (FailureCount == 0) {

        DeleteFile( TiffFileName );
        MemFree( RouteFailure );

    } else {
        *RouteFailureInfo = RouteFailure;
        *RouteFailureCount = FailureCount;
    }

    MemFree( JobInfo );
    MemFree( RouteFileName );

    LeaveCriticalSection( &CsRouting );

    return RetVal;
}


BOOL
LoadRouteInfo(
    IN  LPWSTR              RouteFileName,
    OUT PROUTE_INFO         *RouteInfo,
    OUT PROUTE_FAILURE_INFO *RouteFailure,
    OUT LPDWORD             RouteFailureCount
    )

/*++

Routine Description:

    Load routing information from a routing information file.

Arguments:

    RouteFileName - Name of routing information file.

Return value:

    Pointer to routing information structure if success.  NULL if fail.

--*/

{
#if 0
    HANDLE RouteHandle;
    PROUTE_INFO pRouteInfo = NULL;
    DWORD FileSize;
    DWORD BytesRead;
    LPBYTE Buffer;
    PROUTE_FAILURE_INFO pRouteFailure = NULL;
    DWORD pRouteFailureCount = 0;


    RouteHandle = CreateFile(
        RouteFileName,
        GENERIC_READ,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (RouteHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // the size of the file is the size of the structure
    //

    FileSize = GetFileSize( RouteHandle, NULL );
    if (FileSize == 0xffffffff) {
        CloseHandle( RouteHandle );
        return FALSE;
    }

    Buffer = MemAlloc( FileSize );
    pRouteInfo = (PROUTE_INFO) Buffer;
    if (Buffer == NULL) {
        CloseHandle( RouteHandle );
        return FALSE;
    }

    if (!ReadFile( RouteHandle, Buffer, FileSize, &BytesRead, NULL) || BytesRead != FileSize ) {
        CloseHandle( RouteHandle );
        return FALSE;
    }

    CloseHandle( RouteHandle );

    if (pRouteInfo->Signature != ROUTING_SIGNATURE) {
        CloseHandle( RouteHandle );
        return FALSE;
    }

    pRouteInfo->TiffFileName   = OffsetToString( pRouteInfo->TiffFileName,   Buffer );
    pRouteInfo->ReceiverName   = OffsetToString( pRouteInfo->ReceiverName,   Buffer );
    pRouteInfo->ReceiverNumber = OffsetToString( pRouteInfo->ReceiverNumber, Buffer );
    pRouteInfo->Csid           = OffsetToString( pRouteInfo->Csid,           Buffer );
    pRouteInfo->CallerId       = OffsetToString( pRouteInfo->CallerId,       Buffer );
    pRouteInfo->RoutingInfo    = OffsetToString( pRouteInfo->RoutingInfo,    Buffer );
    pRouteInfo->DeviceName     = OffsetToString( pRouteInfo->DeviceName,     Buffer );
    pRouteInfo->Tsid           = OffsetToString( pRouteInfo->Tsid,           Buffer );


    //
    // return the data
    //

    RouteInfo = pRouteInfo;

#endif
    return TRUE;
}


BOOL
BuildRouteInfo(
    LPWSTR              TiffFileName,
    PROUTE_FAILURE_INFO RouteFailure,
    DWORD               RouteFailureCount,
    LPWSTR              ReceiverName,
    LPWSTR              ReceiverNumber,
    LPWSTR              DeviceName,
    LPWSTR              Tsid,
    LPWSTR              Csid,
    LPWSTR              CallerId,
    LPWSTR              RoutingInfo,
    DWORDLONG           ElapsedTime
    )

/*++

Routine Description:

    Build a routing info structure.  The caller MUST free the memory allocated by this routine.

Arguments:

    TiffFileName        - File containing the fax tiff data
    ReceiverName        - Receiver's name
    ReceiverNumber      - Receiver's fax number
    DeviceName          - Device name on which the fax was received
    Tsid                - Transmitting station identifier
    Csid                - Calling station's identifier
    CallerId            - Caller id data, if any
    RoutingInfo         - Routing info, such as DID, T.30 subaddress, etc

Return value:

    A pointer to a ROUTE_INFO struct on success, NULL on failure.

--*/

{
    BOOL Rval = FALSE;
    LPWSTR RouteFileName = NULL;
    HANDLE RouteHandle = INVALID_HANDLE_VALUE;
    DWORD StringSize = 0;
    DWORD FailureSize = 0;
    LPBYTE Buffer = NULL;
    ULONG_PTR Offset = 0;
    PROUTE_INFO RouteInfo = NULL;
    DWORD i = 0;


    StringSize += StringSize( TiffFileName );
    StringSize += StringSize( ReceiverName );
    StringSize += StringSize( ReceiverNumber );

    StringSize += StringSize( Csid );
    StringSize += StringSize( CallerId );
    StringSize += StringSize( RoutingInfo );

    StringSize += StringSize( DeviceName );
    StringSize += StringSize( Tsid );

    for (i=0; i<RouteFailureCount; i++) {
        FailureSize += RouteFailure[i].FailureSize;
        FailureSize += MAX_GUID_STRING_LEN;
    }

    Buffer = MemAlloc( sizeof(ROUTE_INFO) + StringSize + FailureSize );
    if (!Buffer) {
        goto exit;
    }

    RouteInfo = (PROUTE_INFO) Buffer;

    RouteInfo->Signature = ROUTING_SIGNATURE;
    RouteInfo->StringSize = StringSize;
    RouteInfo->FailureSize = FailureSize;
    RouteInfo->ElapsedTime = ElapsedTime;

    Offset = sizeof(ROUTE_INFO);

    //
    // convert string pointers to offsets
    // and store the strings at the end of the buffer
    //

    StoreString(
        TiffFileName,
        (PULONG_PTR) &RouteInfo->TiffFileName,
        Buffer,
        &Offset
        );

    StoreString(
        ReceiverName,
        (PULONG_PTR) &RouteInfo->ReceiverName,
        Buffer,
        &Offset
        );

    StoreString(
        ReceiverNumber,
        (PULONG_PTR) &RouteInfo->ReceiverNumber,
        Buffer,
        &Offset
        );

    StoreString(
        Csid,
        (PULONG_PTR) &RouteInfo->Csid,
        Buffer,
        &Offset
        );

    StoreString(
        Tsid,
        (PULONG_PTR) &RouteInfo->Tsid,
        Buffer,
        &Offset
        );

    StoreString(
        CallerId,
        (PULONG_PTR) &RouteInfo->CallerId,
        Buffer,
        &Offset
        );

    StoreString(
        RoutingInfo,
        (PULONG_PTR) &RouteInfo->RoutingInfo,
        Buffer,
        &Offset
        );

    StoreString(
        DeviceName,
        (PULONG_PTR) &RouteInfo->DeviceName,
        Buffer,
        &Offset
        );

    //
    // store the routing failure data
    //

    *(LPDWORD) (Buffer + Offset) = RouteFailureCount;
    Offset += sizeof(DWORD);

    for (i=0; i<RouteFailureCount; i++) {
        CopyMemory( Buffer+Offset, RouteFailure[i].FailureData, RouteFailure[i].FailureSize );
        Offset += RouteFailure[i].FailureSize;
    }


    RouteFileName = TiffFileNameToRouteFileName( TiffFileName );

    RouteHandle = CreateFile(
        RouteFileName,
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (RouteHandle == INVALID_HANDLE_VALUE) {
        goto exit;
    }

    WriteFile(
        RouteHandle,
        Buffer,
        sizeof(ROUTE_INFO) + StringSize + FailureSize,
        &i,
        NULL
        );

    Rval = TRUE;

exit:

    if (RouteHandle != INVALID_HANDLE_VALUE) {
        CloseHandle( RouteHandle );
    }

    MemFree( Buffer );
    MemFree( RouteFileName );

    return Rval;
}

BOOL
FaxRouteRetry(
    PFAX_ROUTE FaxRoute,
    PROUTE_FAILURE_INFO RouteFailureInfo
    )
{
    PROUTING_METHOD         RoutingMethod;
    DWORD                   FailureCount = 0;
    BOOL                    RetVal = TRUE;


    //
    // in this case, we've already retried this method and it succeeded.
    //
    if (!*RouteFailureInfo->GuidString) {
       return TRUE;
    }

    RoutingMethod = FindRoutingMethodByGuid( RouteFailureInfo->GuidString );

    if (RoutingMethod) {
        __try {

          if (!RoutingMethod->FaxRouteMethod(
                  FaxRoute,
                  &RouteFailureInfo->FailureData,
                  &RouteFailureInfo->FailureSize ))
          {
              RetVal = FALSE;
          } else {
             //
             // set the routing guid to zero so we don't try to route this guy again.  He is
             // deallocated when we delete the queue entry.
             //
             ZeroMemory(RouteFailureInfo->GuidString, MAX_GUID_STRING_LEN*sizeof(WCHAR) );
          }

        } __except (EXCEPTION_EXECUTE_HANDLER) {

          DebugStop(( L"FaxRouteProcess() faulted: 0x%08x", GetExceptionCode() ));

        }
    } else {
        return FALSE;
    }

    return RetVal;
}

PFAX_ROUTE
SerializeFaxRoute(
    PFAX_ROUTE FaxRoute,
    LPDWORD Size
    )
{
    DWORD ByteCount = sizeof(FAX_ROUTE);
    DWORD_PTR Offset;
    PFAX_ROUTE SerFaxRoute;             // the serialized version


    *Size = 0;

    // Add the size of the strings

    ByteCount += StringSize( FaxRoute->Csid );
    ByteCount += StringSize( FaxRoute->Tsid );
    ByteCount += StringSize( FaxRoute->CallerId );
    ByteCount += StringSize( FaxRoute->RoutingInfo );
    ByteCount += StringSize( FaxRoute->ReceiverName );
    ByteCount += StringSize( FaxRoute->ReceiverNumber );
    ByteCount += StringSize( FaxRoute->DeviceName );

    ByteCount += FaxRoute->RoutingInfoDataSize;

    SerFaxRoute = (PFAX_ROUTE) MemAlloc( ByteCount );


    if (SerFaxRoute == NULL) {
        return NULL;
    }

    *Size = ByteCount;

    CopyMemory( (PVOID) SerFaxRoute, (PVOID) FaxRoute, sizeof(FAX_ROUTE) );

    Offset = sizeof( FAX_ROUTE );

    StoreString( FaxRoute->Csid, (PDWORD_PTR)&SerFaxRoute->Csid, (LPBYTE) SerFaxRoute, &Offset );
    StoreString( FaxRoute->Tsid, (PDWORD_PTR)&SerFaxRoute->Tsid, (LPBYTE) SerFaxRoute, &Offset );
    StoreString( FaxRoute->CallerId, (PDWORD_PTR)&SerFaxRoute->CallerId, (LPBYTE) SerFaxRoute, &Offset );
    StoreString( FaxRoute->RoutingInfo, (PDWORD_PTR)&SerFaxRoute->RoutingInfo, (LPBYTE) SerFaxRoute, &Offset );
    StoreString( FaxRoute->ReceiverName, (PDWORD_PTR)&SerFaxRoute->ReceiverName, (LPBYTE) SerFaxRoute, &Offset );
    StoreString( FaxRoute->ReceiverNumber, (PDWORD_PTR)&SerFaxRoute->ReceiverNumber, (LPBYTE) SerFaxRoute, &Offset );
    StoreString( FaxRoute->DeviceName, (PDWORD_PTR)&SerFaxRoute->DeviceName, (LPBYTE) SerFaxRoute, &Offset );

    FaxRoute->RoutingInfoData = (LPBYTE) Offset;
    Offset += FaxRoute->RoutingInfoDataSize;

    CopyMemory(
        (PVOID) ((LPBYTE) &SerFaxRoute + Offset),
        (PVOID) FaxRoute->RoutingInfoData,
        FaxRoute->RoutingInfoDataSize
        );

    return SerFaxRoute;
}

PFAX_ROUTE
DeSerializeFaxRoute(
    PFAX_ROUTE FaxRoute
    )
{
    PFAX_ROUTE NewFaxRoute;

    FixupString( FaxRoute, FaxRoute->Csid );
    FixupString( FaxRoute, FaxRoute->Tsid );
    FixupString( FaxRoute, FaxRoute->CallerId );
    FixupString( FaxRoute, FaxRoute->RoutingInfo );
    FixupString( FaxRoute, FaxRoute->ReceiverName );
    FixupString( FaxRoute, FaxRoute->DeviceName );
    FixupString( FaxRoute, FaxRoute->ReceiverNumber );

    FaxRoute->RoutingInfoData = (LPBYTE) FaxRoute + (ULONG_PTR) FaxRoute->RoutingInfoData;

    //
    // Make a copy where each item is individually malloced so it can be freed properly
    //

    NewFaxRoute = MemAlloc( sizeof( FAX_ROUTE ) );

    if (NewFaxRoute) {

        CopyMemory( (LPBYTE) NewFaxRoute, (LPBYTE) FaxRoute, sizeof(FAX_ROUTE) );

        NewFaxRoute->Csid = StringDup( FaxRoute->Csid );
        NewFaxRoute->Tsid = StringDup( FaxRoute->Tsid );
        NewFaxRoute->CallerId = StringDup( FaxRoute->CallerId );
        NewFaxRoute->RoutingInfo = StringDup( FaxRoute->RoutingInfo );
        NewFaxRoute->ReceiverName = StringDup( FaxRoute->ReceiverName );
        NewFaxRoute->DeviceName = StringDup( FaxRoute->DeviceName );
        NewFaxRoute->ReceiverNumber = StringDup( FaxRoute->ReceiverNumber );

        NewFaxRoute->RoutingInfoData = MemAlloc( FaxRoute->RoutingInfoDataSize );

        if (NewFaxRoute->RoutingInfoData) {
            CopyMemory( NewFaxRoute->RoutingInfoData, FaxRoute->RoutingInfoData, FaxRoute->RoutingInfoDataSize );
        }

    }

    MemFree( FaxRoute );

    return NewFaxRoute;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\server\security.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    security.c

Abstract:

    This module provides security for the service.

Author:

    Wesley Witt (wesw) 2-Dec-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop

//
// do this to avoid dragging in ntrtl.h since we already include some stuff 
// from ntrtl.h 
//
NTSYSAPI
BOOLEAN
NTAPI
RtlValidRelativeSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptorInput,
    IN ULONG SecurityDescriptorLength,
    IN SECURITY_INFORMATION RequiredInformation
    );



//
// Number of ACEs currently defined for fax.
//
#define FAX_ACE_COUNT 26


typedef struct _FAX_SECURITY {
    LPCTSTR                 RegKey;
    PSECURITY_DESCRIPTOR    SecurityDescriptor;
    PGENERIC_MAPPING        GenericMapping;
    DWORD                   AceCount;
    DWORD                   AceIdx[FAX_ACE_COUNT];
    DWORD                   StringResource;         // Resource Id of friendly name
} FAX_SECURITY, *PFAX_SECURITY;

typedef struct _ACE_DATA {
    ACCESS_MASK AccessMask;
    PSID        *Sid;
    UCHAR       AceType;
    UCHAR       AceFlags;
} ACE_DATA, *PACE_DATA;

typedef struct _ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    //
    // The SID follows in the buffer
    //
} ACE, *PACE;


//
// Universal well known SIDs
//
PSID NullSid;
PSID WorldSid;
PSID LocalSid;
PSID CreatorOwnerSid;
PSID CreatorGroupSid;

//
// SIDs defined by NT
//
PSID DialupSid;
PSID NetworkSid;
PSID BatchSid;
PSID InteractiveSid;
PSID ServiceSid;
PSID LocalSystemSid;
PSID AliasAdminsSid;
PSID AliasUsersSid;
PSID AliasGuestsSid;
PSID AliasPowerUsersSid;
PSID AliasAccountOpsSid;
PSID AliasSystemOpsSid;
PSID AliasPrintOpsSid;
PSID AliasBackupOpsSid;
PSID AliasReplicatorSid;

// Note - Georgeje
//
// The number of security descriptors has been reduced from six
// to one.  The tables in security.c have been left in place in
// case we need to add more security descriptos later.

GENERIC_MAPPING FaxGenericMapping[] =
{
    { STANDARD_RIGHTS_READ,
      STANDARD_RIGHTS_WRITE,
      STANDARD_RIGHTS_EXECUTE,
      STANDARD_RIGHTS_REQUIRED
    }
};


//
// Indexes for the ACE Data Array:
//
//     ACE  0 - unused
//     ACE  1 - ADMIN Full
//     ACE  2 - ADMIN Read
//     ACE  3 - ADMIN Read Write
//     ACE  4 - ADMIN Read Write Delete
//     ACE  5 - Creator Full
//     ACE  6 - Creator Read Write
//     ACE  7 - World Full
//     ACE  8 - World Read
//     ACE  9 - World Read Write
//     ACE 10 - World Read Write Delete
//     ACE 11 - PowerUser Full
//     ACE 12 - PowerUser Read Write
//     ACE 13 - PowerUser Read Write Delete
//     ACE 14 - System Ops Full
//     ACE 15 - System Ops Read Write
//     ACE 16 - System Ops Read Write Delete
//     ACE 17 - System Full
//     ACE 18 - System Read Write
//     ACE 19 - System Read
//     ACE 20 - ADMIN Read Write Execute
//     ACE 21 - Interactive User Full
//     ACE 22 - Interactive User Read
//     ACE 23 - Interactive User Read Write
//     ACE 24 - Interactive User Read Write Delete
//     ACE 25 - Normal Users Read / Write
//

FAX_SECURITY FaxSecurity[] =
{
    { REGVAL_CONFIG_SET,     NULL,  &FaxGenericMapping[0], 5, {1,5,9,11,17}, IDS_SET_CONFIG }
};

#define FaxSecurityCount (sizeof(FaxSecurity)/sizeof(FAX_SECURITY))


//
// Array of ACEs to be applied to fax. They will be
// initialized during program startup based on the data in the
// FaxAceDataTable. The index of each element corresponds to the
// ordinals used in the [ACL] section of perms.inf.
//
PACE AcesForFax[FAX_ACE_COUNT];

//
// Array that contains the size of each ACE in the
// array AceSizesForFax. These sizes are needed
// in order to allocate a buffer of the right size
// when we build an ACL.
//
ULONG AceSizesForFax[FAX_ACE_COUNT];

//
// Table describing the data to put into each ACE for fax.
//
// This table will be read during initialization and used to construct a
// series of ACEs.  The index of each ACE in the FaxAces array defined below
// corresponds to fax ordinals used in the ACL section of perms.inf
//
ACE_DATA AceDataTableForFax[FAX_ACE_COUNT] = {

    //
    // Index 0 is unused
    //
    { 0,NULL,0,0 },

    //
    //
    // ACE 1 - ADMIN Full
    // (for fax)
    //
    {
        FAX_ALL_ACCESS,
        &AliasAdminsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 2 - ADMIN Read
    // (for fax)
    //
    {
        FAX_READ,
        &AliasAdminsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 3 - ADMIN Read Write
    // (for fax)
    //
    {
        FAX_READ | FAX_WRITE,
        &AliasAdminsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 4 - ADMIN Read Write Delete
    // (for fax)
    //
    {
        FAX_READ | FAX_WRITE | FAX_JOB_MANAGE,
        &AliasAdminsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 5 - Creator Full
    // (for fax)
    //
    {
        FAX_ALL_ACCESS,
        &CreatorOwnerSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 6 - Creator Read Write
    // (for fax)
    //
    {
        FAX_READ | FAX_WRITE,
        &CreatorOwnerSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 7 - World Full
    // (for fax)
    //
    {
        FAX_ALL_ACCESS,
        &WorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 8 - World Read
    // (for fax)
    //
    {
        FAX_READ,
        &WorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 9 - World Read Write
    // (for fax)
    //
    {
        FAX_READ | FAX_WRITE,
        &WorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 10 - World Read Write Delete
    // (for fax)
    //
    {
        FAX_READ | FAX_WRITE | FAX_JOB_MANAGE,
        &WorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 11 - PowerUser Full
    // (for fax)
    //
    {
        FAX_ALL_ACCESS,
        &AliasPowerUsersSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 12 - PowerUser Read Write
    // (for fax)
    //
    {
        FAX_READ | FAX_WRITE,
        &AliasPowerUsersSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 13 - PowerUser Read Write Delete
    // (for fax)
    //
    {
        FAX_READ | FAX_WRITE | FAX_JOB_MANAGE,
        &AliasPowerUsersSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 14 - System Ops Full
    // (for fax)
    //
    {
        FAX_ALL_ACCESS,
        &AliasSystemOpsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 15 - System Ops Read Write
    // (for fax)
    //
    {
        FAX_READ | FAX_WRITE,
        &AliasSystemOpsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 16 - System Ops Read Write Delete
    // (for fax)
    //
    {
        FAX_READ | FAX_WRITE | FAX_JOB_MANAGE,
        &AliasSystemOpsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 17 - System Full
    // (for fax)
    //
    {
        FAX_ALL_ACCESS,
        &LocalSystemSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 18 - System Read Write
    // (for fax)
    //
    {
        FAX_READ | FAX_WRITE| FAX_JOB_MANAGE,
        &LocalSystemSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 19 - System Read
    // (for fax)
    //
    {
        FAX_READ,
        &LocalSystemSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 20 - ADMIN Read Write Execute
    // (for fax)
    //
    {
        FAX_READ | FAX_WRITE,
        &AliasAdminsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 21 - Interactive User Full
    // (for fax)
    //
    {
        FAX_ALL_ACCESS,
        &InteractiveSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 22 - Interactive User Read
    // (for fax)
    //
    {
        FAX_READ,
        &InteractiveSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 23 - Interactive User Read Write
    // (for fax)
    //
    {
        FAX_READ | FAX_WRITE,
        &InteractiveSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 24 - Interactive User Read Write Delete
    // (for fax)
    //
    {
        FAX_READ | FAX_WRITE| FAX_JOB_MANAGE,
        &InteractiveSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 25 - Normal Users Read / Write
    // (for fax)
    //
    {
        FAX_READ | FAX_WRITE,
        &AliasUsersSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

};

static CRITICAL_SECTION CsSecurity;
static BOOL CsInit = FALSE;

DWORD
InitializeSids(
    VOID
    );

VOID
TearDownSids(
    VOID
    );

DWORD
InitializeAces(
    IN OUT PACE_DATA    DataTable,
    IN OUT PACE*        AcesArray,
    IN OUT PULONG       AceSizesArray,
    IN     ULONG        ArrayCount
    );

VOID
TearDownAces(
    IN OUT PACE*        AcesArray,
    IN     ULONG        ArrayCount
    );



DWORD
InitializeSids(
    VOID
    )

/*++

Routine Description:

    This function initializes the global variables used by and exposed
    by security.

Arguments:

    None.

Return Value:

    Win32 error indicating outcome.

--*/

{
    SID_IDENTIFIER_AUTHORITY NullSidAuthority    = SECURITY_NULL_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY LocalSidAuthority   = SECURITY_LOCAL_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY NtAuthority         = SECURITY_NT_AUTHORITY;

    BOOL b = TRUE;

    //
    // Ensure the SIDs are in a well-known state
    //
    NullSid = NULL;
    WorldSid = NULL;
    LocalSid = NULL;
    CreatorOwnerSid = NULL;
    CreatorGroupSid = NULL;
    DialupSid = NULL;
    NetworkSid = NULL;
    BatchSid = NULL;
    InteractiveSid = NULL;
    ServiceSid = NULL;
    LocalSystemSid = NULL;
    AliasAdminsSid = NULL;
    AliasUsersSid = NULL;
    AliasGuestsSid = NULL;
    AliasPowerUsersSid = NULL;
    AliasAccountOpsSid = NULL;
    AliasSystemOpsSid = NULL;
    AliasPrintOpsSid = NULL;
    AliasBackupOpsSid = NULL;
    AliasReplicatorSid = NULL;

    //
    // Allocate and initialize the universal SIDs
    //
    b = b && AllocateAndInitializeSid(
                &NullSidAuthority,
                1,
                SECURITY_NULL_RID,
                0,0,0,0,0,0,0,
                &NullSid
                );

    b = b && AllocateAndInitializeSid(
                &WorldSidAuthority,
                1,
                SECURITY_WORLD_RID,
                0,0,0,0,0,0,0,
                &WorldSid
                );

    b = b && AllocateAndInitializeSid(
                &LocalSidAuthority,
                1,
                SECURITY_LOCAL_RID,
                0,0,0,0,0,0,0,
                &LocalSid
                );

    b = b && AllocateAndInitializeSid(
                &CreatorSidAuthority,
                1,
                SECURITY_CREATOR_OWNER_RID,
                0,0,0,0,0,0,0,
                &CreatorOwnerSid
                );

    b = b && AllocateAndInitializeSid(
                &CreatorSidAuthority,
                1,
                SECURITY_CREATOR_GROUP_RID,
                0,0,0,0,0,0,0,
                &CreatorGroupSid
                );

    //
    // Allocate and initialize the NT defined SIDs
    //
    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_DIALUP_RID,
                0,0,0,0,0,0,0,
                &DialupSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_NETWORK_RID,
                0,0,0,0,0,0,0,
                &NetworkSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_BATCH_RID,
                0,0,0,0,0,0,0,
                &BatchSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_INTERACTIVE_RID,
                0,0,0,0,0,0,0,
                &InteractiveSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_SERVICE_RID,
                0,0,0,0,0,0,0,
                &ServiceSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0,0,0,0,0,0,0,
                &LocalSystemSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0,0,0,0,0,0,
                &AliasAdminsSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_USERS,
                0,0,0,0,0,0,
                &AliasUsersSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_GUESTS,
                0,0,0,0,0,0,
                &AliasGuestsSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_POWER_USERS,
                0,0,0,0,0,0,
                &AliasPowerUsersSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ACCOUNT_OPS,
                0,0,0,0,0,0,
                &AliasAccountOpsSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_SYSTEM_OPS,
                0,0,0,0,0,0,
                &AliasSystemOpsSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_PRINT_OPS,
                0,0,0,0,0,0,
                &AliasPrintOpsSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_BACKUP_OPS,
                0,0,0,0,0,0,
                &AliasBackupOpsSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_REPLICATOR,
                0,0,0,0,0,0,
                &AliasReplicatorSid
                );

    if(!b) {
        TearDownSids();
    }

    return(b ? NO_ERROR : GetLastError() ? GetLastError() : 1  );
}


VOID
TearDownSids(
    VOID
    )
{
    if(NullSid) {
        FreeSid(NullSid);
    }
    if(WorldSid) {
        FreeSid(WorldSid);
    }
    if(LocalSid) {
        FreeSid(LocalSid);
    }
    if(CreatorOwnerSid) {
        FreeSid(CreatorOwnerSid);
    }
    if(CreatorGroupSid) {
        FreeSid(CreatorGroupSid);
    }
    if(DialupSid) {
        FreeSid(DialupSid);
    }
    if(NetworkSid) {
        FreeSid(NetworkSid);
    }
    if(BatchSid) {
        FreeSid(BatchSid);
    }
    if(InteractiveSid) {
        FreeSid(InteractiveSid);
    }
    if(ServiceSid) {
        FreeSid(ServiceSid);
    }
    if(LocalSystemSid) {
        FreeSid(LocalSystemSid);
    }
    if(AliasAdminsSid) {
        FreeSid(AliasAdminsSid);
    }
    if(AliasUsersSid) {
        FreeSid(AliasUsersSid);
    }
    if(AliasGuestsSid) {
        FreeSid(AliasGuestsSid);
    }
    if(AliasPowerUsersSid) {
        FreeSid(AliasPowerUsersSid);
    }
    if(AliasAccountOpsSid) {
        FreeSid(AliasAccountOpsSid);
    }
    if(AliasSystemOpsSid) {
        FreeSid(AliasSystemOpsSid);
    }
    if(AliasPrintOpsSid) {
        FreeSid(AliasPrintOpsSid);
    }
    if(AliasBackupOpsSid) {
        FreeSid(AliasBackupOpsSid);
    }
    if(AliasReplicatorSid) {
        FreeSid(AliasReplicatorSid);
    }
}


DWORD
InitializeAces(
    IN OUT PACE_DATA    DataTable,
    IN OUT PACE*        AcesArray,
    IN OUT PULONG       AceSizesArray,
    IN     ULONG        ArrayCount
    )

/*++

Routine Description:

    Initializes the array of ACEs as described in the DataTable

Arguments:

    DataTable - Pointer to the array that contains the data
                describing each ACE.
    AcesArray - Array that will contain the ACEs.

    AceSizesArray - Array that contains the sizes for each ACE.

    ArrayCount - Number of elements in each array.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    unsigned u;
    DWORD Length;
    DWORD rc;
    BOOL b;
    DWORD SidLength;

    //
    // Initialize to a known state.
    //
    ZeroMemory(AcesArray,ArrayCount*sizeof(PACE));

    //
    // Create ACEs for each item in the data table.
    // This involves merging the ace data with the SID data, which
    // are initialized in an earlier step.
    //
    for(u=1; u<ArrayCount; u++) {

        SidLength = GetLengthSid(*(DataTable[u].Sid));
        Length = SidLength + sizeof(ACE) + sizeof(ACCESS_MASK)- sizeof(ULONG);
        AceSizesArray[u] = Length;

        AcesArray[u] = MemAlloc(Length);
        if(!AcesArray[u]) {
            TearDownAces(AcesArray, ArrayCount);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        AcesArray[u]->Header.AceType  = DataTable[u].AceType;
        AcesArray[u]->Header.AceFlags = DataTable[u].AceFlags;
        AcesArray[u]->Header.AceSize  = (WORD)Length;

        AcesArray[u]->Mask = DataTable[u].AccessMask;

        b = CopySid(
                SidLength,                           // Length - sizeof(ACE) + sizeof(ULONG),
                (PUCHAR)AcesArray[u] + sizeof(ACE),
                *(DataTable[u].Sid)
                );

        if(!b) {
            rc = GetLastError();
            TearDownAces(AcesArray, ArrayCount);
            return(rc);
        }
    }

    return(NO_ERROR);
}


VOID
TearDownAces(
    IN OUT PACE*        AcesArray,
    IN     ULONG        ArrayCount
    )

/*++

Routine Description:

    Destroys the array of ACEs as described in the DataTable

Arguments:

    None

Return Value:

    None

--*/

{
    unsigned u;


    for(u=1; u<ArrayCount; u++) {

        if(AcesArray[u]) {
            MemFree(AcesArray[u]);
        }
    }
}


BOOL
FaxSvcAccessCheck(
    DWORD SecurityType,
    ACCESS_MASK DesiredAccess
    )
{
    DWORD rc;
    DWORD GrantedAccess;
    BOOL AccessStatus;
    HANDLE ClientToken = NULL;
    BYTE PrivilegeSet[512];
    DWORD PrivilegeSetSize;


    //
    // sanity check
    //

    if (SecurityType >= FaxSecurityCount) {
        return FALSE;
    }

    //
    // Impersonate the client.
    //

    if ((rc = RpcImpersonateClient(NULL)) != RPC_S_OK) {
        return FALSE;
    }

    EnterCriticalSection( &CsSecurity );
    
    //
    // Open the impersonated token.
    //

    if (!OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, TRUE, &ClientToken )) {
        rc = GetLastError();
        goto exit;
    }

    //
    // purify the access mask
    //

    MapGenericMask( &DesiredAccess, FaxSecurity[SecurityType].GenericMapping );

    //
    // Check if the client has the required access.
    //

    PrivilegeSetSize = sizeof(PrivilegeSet);

    if (!AccessCheck( FaxSecurity[SecurityType].SecurityDescriptor,
                      ClientToken,
                      DesiredAccess,
                      FaxSecurity[SecurityType].GenericMapping,
                      (PPRIVILEGE_SET) PrivilegeSet,
                      &PrivilegeSetSize,
                      &GrantedAccess,
                      &AccessStatus ) )
    {
        rc = GetLastError();
        goto exit;
    }

    if (!AccessStatus) {
        rc = GetLastError();
        goto exit;
    }

    rc = 0;

exit:
    RpcRevertToSelf();

    if (ClientToken) {
        CloseHandle( ClientToken );
    }

    if (rc != 0) {
        DebugPrint(( TEXT("FaxSvcAccessCheck() failed to authenticate, 0x%08x, 0x%08x\n"), SecurityType, DesiredAccess ));
    }

    LeaveCriticalSection( &CsSecurity );

    return rc == 0;
}


PVOID
MyGetTokenInformation(
    HANDLE  hToken,
    TOKEN_INFORMATION_CLASS TokenInformationClass
    )
{
    PVOID TokenInformation = NULL;
    DWORD Size = 0;


    if (!GetTokenInformation( hToken, TokenInformationClass, NULL, 0, &Size ) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (TokenInformation = MemAlloc( Size )) &&
        GetTokenInformation( hToken, TokenInformationClass, TokenInformation, Size, &Size ))
    {
        return TokenInformation;
    }

    MemFree( TokenInformation );
    return NULL;
}


DWORD
InitializeFaxSecurityDescriptors(
    VOID
    )
{
    #define BUFFER_SIZE 4096
    DWORD i,j;
    DWORD rc = ERROR_SUCCESS;
    DWORD Ace;
    DWORD Size;
    HKEY hKey = NULL;
    DWORD Disposition;
    LPBYTE Buffer = NULL;
    BYTE AclBuffer[512];
    SECURITY_DESCRIPTOR SecurityDescriptor;
    DWORD Type;
    PACL Acl;
    HANDLE ServiceToken;
    PTOKEN_OWNER Owner;
    PTOKEN_GROUPS Groups;
    PSECURITY_DESCRIPTOR AbsSD;
    DWORD AbsSdSize = 0;
    DWORD DaclSize = 0;
    DWORD SaclSize = 0;
    DWORD OwnerSize = 0;
    DWORD GroupSize = 0;
    PACL pAbsDacl = NULL;
    PACL pAbsSacl = NULL;
    PSID pAbsOwner = NULL;
    PSID pAbsGroup = NULL;


    if (!CsInit) {
        InitializeCriticalSection( &CsSecurity );
        CsInit = TRUE;
    }
    
    //
    // Initialize SIDs
    //

    rc = InitializeSids();
    if (rc != NO_ERROR) {
        goto exit;
    }

    //
    // Initialize Fax ACEs
    //

    rc = InitializeAces( AceDataTableForFax, AcesForFax, AceSizesForFax, FAX_ACE_COUNT );
    if (rc != NO_ERROR) {
        goto exit;
    }

    if (!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &ServiceToken )) {
        rc = GetLastError();
        goto exit;
    }

    Owner = MyGetTokenInformation( ServiceToken, TokenOwner );
    if (!Owner) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    Groups = MyGetTokenInformation( ServiceToken, TokenGroups );
    if (!Groups) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    CloseHandle( ServiceToken );

    rc = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        REGKEY_FAX_SECURITY,
        0,
        TEXT(""),
        0,
        KEY_ALL_ACCESS,
        NULL,
        &hKey,
        &Disposition
        );
    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    Buffer = (LPBYTE) MemAlloc( BUFFER_SIZE );
    if (!Buffer) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    for (i=0; i<FaxSecurityCount; i++) {
        Size = BUFFER_SIZE;
        ZeroMemory( Buffer, Size );
        rc = RegQueryValueEx(
            hKey,
            FaxSecurity[i].RegKey,
            0,
            &Type,
            Buffer,
            &Size
            );
        if (rc == ERROR_SUCCESS) {

            if (!IsValidSecurityDescriptor( (PSECURITY_DESCRIPTOR) Buffer )) {
                rc = GetLastError();
                DebugPrint(( TEXT("IsValidSecurityDescriptor() failed, ec=%d"), rc ));
                goto exit;
            }

            //
            // the security descriptor needs to be converted to absolute format.
            //

            AbsSdSize = 0;
            DaclSize  = 0;
            SaclSize  = 0;
            OwnerSize = 0;
            GroupSize = 0;

            rc = MakeAbsoluteSD(
                (PSECURITY_DESCRIPTOR) Buffer,
                NULL,
                &AbsSdSize,
                NULL,
                &DaclSize,
                NULL,
                &SaclSize,
                NULL,
                &OwnerSize,
                NULL,
                &GroupSize
                );
            if (rc || GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
                rc = GetLastError();
                goto exit;
            }

            AbsSD = MemAlloc(AbsSdSize);
            pAbsDacl = MemAlloc(DaclSize);
            pAbsSacl = MemAlloc(SaclSize);
            pAbsOwner = MemAlloc(OwnerSize);
            pAbsGroup = MemAlloc(GroupSize);

            if (NULL == AbsSD || NULL == pAbsDacl || NULL == pAbsSacl || NULL == pAbsOwner || NULL == pAbsGroup) {
                rc = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }

            MakeAbsoluteSD(
                (PSECURITY_DESCRIPTOR) Buffer,
                AbsSD,
                &AbsSdSize,
                pAbsDacl,
                &DaclSize,
                pAbsSacl,
                &SaclSize,
                pAbsOwner,
                &OwnerSize,
                pAbsGroup,
                &GroupSize
                );

            FaxSecurity[i].SecurityDescriptor = AbsSD;

            if (!IsValidSecurityDescriptor( FaxSecurity[i].SecurityDescriptor )) {
                rc = GetLastError();
                DebugPrint(( TEXT("IsValidSecurityDescriptor() failed, ec=%d"), rc ));
                goto exit;
            }

            continue;
        }

        //
        // Initialize a security descriptor and an ACL.
        // We use a large static buffer to contain the ACL.
        //

        ZeroMemory( AclBuffer, sizeof(AclBuffer) );

        Acl = (PACL)AclBuffer;
        if(!InitializeAcl( Acl, sizeof(AclBuffer), ACL_REVISION2) ||
           !InitializeSecurityDescriptor( &SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION ))
        {
            rc = GetLastError();
            goto exit;
        }

        //
        // Build up the DACL from the indices
        //

        for (Ace=0; Ace<FaxSecurity[i].AceCount; Ace++) {

            if (!AddAce(
                Acl,
                ACL_REVISION2,
                MAXDWORD,
                AcesForFax[FaxSecurity[i].AceIdx[Ace]],
                AcesForFax[FaxSecurity[i].AceIdx[Ace]]->Header.AceSize
                ))
            {
                rc = GetLastError();
                goto exit;
            }
        }

        //
        // Add the ACL to the security descriptor as the DACL
        //

        if (!SetSecurityDescriptorDacl( &SecurityDescriptor, TRUE, Acl, FALSE )) {
            rc = GetLastError();
            goto exit;
        }

        //
        // set the owner
        //

        if (!SetSecurityDescriptorOwner( &SecurityDescriptor, Owner->Owner, FALSE )) {
            rc = GetLastError();
            goto exit;
        }

        //
        // set the groups
        //

        for (j=0; j<Groups->GroupCount; j++) {
            if (!SetSecurityDescriptorGroup( &SecurityDescriptor, Groups->Groups[j].Sid, FALSE )) {
                rc = GetLastError();
                goto exit;
            }
        }

        //
        // make the security descriptor self relative
        //

        Size = BUFFER_SIZE;
        if (!MakeSelfRelativeSD( &SecurityDescriptor, (PSECURITY_DESCRIPTOR) Buffer, &Size )) {
            rc = GetLastError();
            goto exit;
        }

        //
        // store the security descriptor in the registry
        //

        Size = GetSecurityDescriptorLength( (PSECURITY_DESCRIPTOR) Buffer );

        FaxSecurity[i].SecurityDescriptor = (PSECURITY_DESCRIPTOR) MemAlloc( Size );
        if (!FaxSecurity[i].SecurityDescriptor) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        CopyMemory( FaxSecurity[i].SecurityDescriptor, Buffer, Size );

        rc = RegSetValueEx(
            hKey,
            FaxSecurity[i].RegKey,
            0,
            REG_BINARY,
            (LPBYTE) FaxSecurity[i].SecurityDescriptor,
            Size
            );
        if (rc) {
            goto exit;
        }
    }

exit:
    if (hKey) {
        RegCloseKey( hKey );
    }
    if (Buffer) {
        MemFree( Buffer );
    }
    if (Owner) {
        MemFree( Owner );
    }
    if (Groups) {
        MemFree( Groups );
    }
    return rc;
}


LPWSTR
GetClientUserName(
    VOID
    )
{
    WCHAR UserName[128];
    DWORD Size;


    if (RpcImpersonateClient(NULL) != RPC_S_OK) {
        return NULL;
    }

    Size = sizeof(UserName) / sizeof(WCHAR);
    if (!GetUserName( UserName, &Size )) {
        RpcRevertToSelf();
        return NULL;
    }

    RpcRevertToSelf();

    return StringDup( UserName );
}


error_status_t
FAX_GetSecurityDescriptorCount(
    IN  handle_t FaxHandle,
    OUT LPDWORD Count
    )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
    
    *Count = FaxSecurityCount;
    return ERROR_SUCCESS;
}

error_status_t
FAX_SetSecurityDescriptor(
    IN  handle_t FaxHandle,
    IN const LPBYTE Buffer,
    IN DWORD BufferSize
    )
{
    DWORD rVal = ERROR_SUCCESS;
    PFAX_SECURITY_DESCRIPTOR FaxSecDesc = (PFAX_SECURITY_DESCRIPTOR) Buffer;
    HKEY hKey;
    DWORD Disposition;
    DWORD SecDescBufferSize;

    if (!FaxSvcAccessCheck( SEC_CONFIG_SET, FAX_CONFIG_SET )) {
        return ERROR_ACCESS_DENIED;
    }

    // Check that the buffer is large enough to hold a FAX_SECURITY_DESCRIPTOR

    if (BufferSize < sizeof (FAX_SECURITY_DESCRIPTOR)) {
        return ERROR_INVALID_PARAMETER;
    }

    if (FaxSecDesc->Id > FaxSecurityCount) {
        return ERROR_INVALID_CATEGORY;
    }

    // Check that the offset is within the buffer.

    if (PtrToUlong(FaxSecDesc->SecurityDescriptor) >= BufferSize) {
        return ERROR_INVALID_PARAMETER;
    }

    // Calculate the size of the security descriptor buffer for validation

    SecDescBufferSize = BufferSize - PtrToUlong(FaxSecDesc->SecurityDescriptor);

    FaxSecDesc->SecurityDescriptor = (PSECURITY_DESCRIPTOR) FixupString(Buffer,
                                                                        FaxSecDesc->SecurityDescriptor);

    // Validate the passed security descriptor.

    if (!RtlValidRelativeSecurityDescriptor(FaxSecDesc->SecurityDescriptor,
                                            SecDescBufferSize,
                                            0)) {
        return ERROR_INVALID_DATA;
    }
    
    rVal = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        REGKEY_FAX_SECURITY,
        0,
        TEXT(""),
        0,
        KEY_ALL_ACCESS,
        NULL,
        &hKey,
        &Disposition
        );
    if (rVal != ERROR_SUCCESS) {
        return rVal;
    }

    rVal = RegSetValueEx(
       hKey,
       FaxSecurity[FaxSecDesc->Id].RegKey,
       0,
       REG_BINARY,
       (LPBYTE) FaxSecDesc->SecurityDescriptor,
       GetSecurityDescriptorLength( FaxSecDesc->SecurityDescriptor )
       );

    if (FaxSecurity[FaxSecDesc->Id].SecurityDescriptor) {
        MemFree( FaxSecurity[FaxSecDesc->Id].SecurityDescriptor );
    }
    
    rVal = InitializeFaxSecurityDescriptors();
    
    RegCloseKey( hKey );

    return rVal;
}

error_status_t
FAX_GetSecurityDescriptor(
    IN  handle_t FaxHandle,
    IN  DWORD Id,
    OUT LPBYTE *Buffer,
    OUT LPDWORD BufferSize
    )

/*++

Routine Description:

    Retrieves the FAX configuration from the FAX server.
    The SizeOfStruct in the FaxConfig argument MUST be
    set to a value == sizeof(FAX_CONFIGURATION).  If the BufferSize
    is not big enough, return an error and set BytesNeeded to the
    required size.

Arguments:

    FaxHandle   - FAX handle obtained from FaxConnectFaxServer.
    Buffer      - Pointer to a FAX_CONFIGURATION structure.
    BufferSize  - Size of Buffer
    BytesNeeded - Number of bytes needed

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t rVal = ERROR_SUCCESS;
    PFAX_SECURITY_DESCRIPTOR FaxSecDesc;
    ULONG_PTR Offset;
    LPWSTR FriendlyName;
    DWORD DescLength;
    HKEY hKey;
    DWORD Type;
    DWORD Size;
    DWORD Disposition;

    if (!FaxSvcAccessCheck( SEC_CONFIG_QUERY, FAX_CONFIG_QUERY )) {
        return ERROR_ACCESS_DENIED;
    }

    if (Id > FaxSecurityCount) {
        return ERROR_INVALID_CATEGORY;
    }
    
    rVal = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        REGKEY_FAX_SECURITY,
        0,
        TEXT(""),
        0,
        KEY_ALL_ACCESS,
        NULL,
        &hKey,
        &Disposition
        );
    if (rVal != ERROR_SUCCESS) {
        return rVal;
    }

    FriendlyName = GetString( FaxSecurity[Id].StringResource );
    
    //
    // count up the number of bytes needed
    //

    rVal = RegQueryValueEx(
        hKey,
        FaxSecurity[Id].RegKey,
        0,
        &Type,
        NULL,
        &DescLength
        );
    
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }
    
    Offset = sizeof(FAX_SECURITY_DESCRIPTOR);

    *BufferSize = (DWORD)(Offset +
                          DescLength +
                          (wcslen(FriendlyName) + 1) * sizeof(WCHAR));

    
    *Buffer = MemAlloc( *BufferSize );
    
    if (*Buffer == NULL) {
        rVal = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    
    FaxSecDesc = (PFAX_SECURITY_DESCRIPTOR) *Buffer;

    FaxSecDesc->Id = Id;
    
    StoreString(
        FriendlyName,
        (PULONG_PTR)&FaxSecDesc->FriendlyName,
        *Buffer,
        &Offset
        );
    
    rVal = RegQueryValueEx(
        hKey,
        FaxSecurity[Id].RegKey,
        0,
        &Type,
        *Buffer + Offset,
        &Size
        );

    FaxSecDesc->SecurityDescriptor = (LPBYTE) Offset;

exit:
    RegCloseKey( hKey );
    return rVal;
}

BOOL
PostClientMessage(
   PFAX_CLIENT_DATA ClientData,
   PFAX_EVENT FaxEvent
   )

/*++

Routine Description:

    attempts to post a message to client on another windowstation and desktop

Arguments:

    ClientData   - pointer to a FAX_CLIENT_DATA structure.
    FaxEvent     - pointer to a FAX_EVENT structure.
    
Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{   
   HWINSTA hWindowStation, hOldWindowStation=NULL;
   HDESK hDesktop, hOldDesktop=NULL;
   BOOL bStatus = FALSE;


   //
   // need to restore windowstation and desktop
   //
   if (! (hOldWindowStation = GetProcessWindowStation()) ) {
      DebugPrint(( TEXT("GetProcessWindowStation failed, ec = %d\n"), GetLastError() ));
      return FALSE;
   }

   if (! (hOldDesktop = GetThreadDesktop( GetCurrentThreadId() )) ) {
      DebugPrint(( TEXT("GetThreadDesktop failed, ec = %d\n"), GetLastError() ));
      return FALSE;
   }

   //
   // impersonate the client
   //
   if (! SetThreadToken( NULL, ClientData->hClientToken ) ) {
      DebugPrint(( TEXT("SetThreadToken failed, ec = %d\n"), GetLastError() ));
      return FALSE;
   }

   //
   // get a handle to the windowstation, switch to new windowstation
   //
   if (! (hWindowStation = OpenWindowStation(ClientData->WindowStation,
                                            FALSE, //bInherit,
                                            WINSTA_READATTRIBUTES | WINSTA_WRITEATTRIBUTES)) ) {
      DebugPrint(( TEXT("OpenWindowStation failed, ec = %d\n"), GetLastError() ));
      goto exit;
   }

   if (! SetProcessWindowStation( hWindowStation ) ) {
      DebugPrint(( TEXT("SetProcessWindowStation failed, ec = %d\n"), GetLastError() ));
      goto exit;
   }

   //
   // get a handle to the desktop, switch to new desktop
   //
   if (! (hDesktop = OpenDesktop(ClientData->Desktop,
                                 0,
                                 FALSE,
                                 DESKTOP_READOBJECTS | DESKTOP_WRITEOBJECTS)) ) {
      DebugPrint(( TEXT("OpenDesktop failed, ec = %d\n"), GetLastError() ));
      goto exit;
   }

   if (! SetThreadDesktop( hDesktop ) ) {
      DebugPrint(( TEXT("SetThreadDesktop failed, ec = %d\n"), GetLastError() ));
      goto exit;
   }

   //
   // post the message to the proper window if it exits
   //
   if (! IsWindow( ClientData->hWnd )) {
      DebugPrint(( TEXT("Hwnd %x doesn't exist on current desktop\n"), ClientData->hWnd ));
      goto exit;
   }

   if (! PostMessage( ClientData->hWnd,
                      ClientData->MessageStart + FaxEvent->EventId,
                      (WPARAM)FaxEvent->DeviceId,
                      (LPARAM)FaxEvent->JobId )) {
      DebugPrint(( TEXT("PostMessage failed, ec = %d\n"), GetLastError() ));
      goto exit;
   }

   bStatus = TRUE;

exit:

   //
   // revert to old thread context (NULL means stop impersonating)
   //

   SetThreadToken( NULL, NULL );
   if (hOldWindowStation) {
       SetProcessWindowStation( hOldWindowStation );
       CloseWindowStation( hWindowStation );
   }
   if (hOldDesktop) {
       SetThreadDesktop( hOldDesktop );
       CloseDesktop( hDesktop );
   }
   return bStatus;

}

BOOL
BuildSecureSD(
    OUT PSECURITY_DESCRIPTOR *SDIn
    )
/*++

Routine Description:

    builds a secure security descriptor to be used in securing a globally
    named object. Our "secure" SD's DACL consists of the following permissions:
    
    Authenticated users get "generic read" access.
    Administrators get "generic all" access.    

Arguments:

    SDIn    - pointer to the PSECURITY_DESCRIPTOR to be created.
    
Return Value:

    TRUE    - Success, the SECURITY_DESCRIPTOR was created successfully.  
              The caller is responsible for freeing the SECURITY_DESCRIPTOR

--*/
{
    SID_IDENTIFIER_AUTHORITY NtAuthority         = SECURITY_NT_AUTHORITY;
    PSID                    AuthenticatedUsers;
    PSID                    BuiltInAdministrators;
    PSECURITY_DESCRIPTOR    Sd = NULL;
    ACL                     *Acl;
    ULONG                   AclSize;
    BOOL                    RetVal = TRUE;
    
    *SDIn = NULL;

    //
    // Allocate and initialize the required SIDs
    //
    if (!AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0,0,0,0,0,0,
                &BuiltInAdministrators)) {
        return(FALSE);
    }

    if (!AllocateAndInitializeSid(
            &NtAuthority,
            1,
            SECURITY_AUTHENTICATED_USER_RID,
            0,0,0,0,0,0,0,
            &AuthenticatedUsers)) {
        RetVal = FALSE;
        goto e0;
    }
    
    


    //
    // "- sizeof (ULONG)" represents the SidStart field of the
    // ACCESS_ALLOWED_ACE.  Since we're adding the entire length of the
    // SID, this field is counted twice.
    //

    AclSize = sizeof (ACL) +
        (2 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))) +
        GetLengthSid(AuthenticatedUsers) +
        GetLengthSid(BuiltInAdministrators);

    Sd = MemAlloc(SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);

    if (!Sd) {

        RetVal = FALSE;
        goto e1;

    } 

        

    Acl = (ACL *)((BYTE *)Sd + SECURITY_DESCRIPTOR_MIN_LENGTH);

    if (!InitializeAcl(Acl,
                       AclSize,
                       ACL_REVISION)) {
        RetVal = FALSE;
        goto e2;

    } else if (!AddAccessAllowedAce(Acl,
                                    ACL_REVISION,
                                    SYNCHRONIZE | GENERIC_READ,
                                    AuthenticatedUsers)) {

        // Failed to build the ACE granting "Authenticated users"
        // (SYNCHRONIZE | GENERIC_READ) access.
        RetVal = FALSE;
        goto e2;

    } else if (!AddAccessAllowedAce(Acl,
                                    ACL_REVISION,
                                    GENERIC_ALL,
                                    BuiltInAdministrators)) {

        // Failed to build the ACE granting "Built-in Administrators"
        // GENERIC_ALL access.
        RetVal = FALSE;
        goto e2;

    } else if (!InitializeSecurityDescriptor(Sd,
                                             SECURITY_DESCRIPTOR_REVISION)) {
        RetVal = FALSE;
        goto e2;

    } else if (!SetSecurityDescriptorDacl(Sd,
                                          TRUE,
                                          Acl,
                                          FALSE)) {

        // error
        RetVal = FALSE;
        goto e2;
    }

    if (!IsValidSecurityDescriptor(Sd)) {
        DebugPrint(( TEXT("invalid security descriptor, ec = %d\n"), GetLastError() ));
        RetVal = FALSE;
        goto e2;
    }

    //
    // success
    //
    *SDIn = Sd;
    goto e1;    

e2:
    MemFree(Sd);
e1:
    FreeSid(AuthenticatedUsers);
e0:
    FreeSid(BuiltInAdministrators);    

    return(RetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\server\svccon.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxsvc.c

Abstract:

    This module contains the windows code for the
    FAX service debug window.

Author:

    Wesley Witt (wesw) 28-Feb-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop




int
DebugService(
    VOID
    )

/*++

Routine Description:

    Starts the service in debug mode.  In this mode the FAX service
    runs as a regular WIN32 process.  This is implemented as an aid
    to debugging the service.

Arguments:

    argc        - argument count
    argv        - argument array

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/

{
    ServiceDebug = TRUE;
    ConsoleDebugOutput = TRUE;
    return ServiceStart();
}


VOID
ConsoleDebugPrint(
    LPTSTR buf
    )
{
    if (ConsoleDebugOutput) {
        _tprintf( TEXT("%s\n"), buf );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\server\server.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    server.c

Abstract:

    This module contains the code to provide the RPC server.

Author:

    Wesley Witt (wesw) 16-Jan-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop


GUID FaxSvcGuid = { 0xc3a9d640, 0xab07, 0x11d0, { 0x92, 0xbf, 0x0, 0xa0, 0x24, 0xaa, 0x1c, 0x1 } };

CRITICAL_SECTION CsPerfCounters;
DWORD OutboundSeconds;
DWORD InboundSeconds;
DWORD TotalSeconds;

CHAR Buffer[4096];

PFAX_PERF_COUNTERS PerfCounters;
HANDLE hServiceEndEvent; // signalled by tapiworkerthread after letting clients know fax service is ending
#ifdef DBG
HANDLE hLogFile = INVALID_HANDLE_VALUE;
LIST_ENTRY CritSecListHead;
#endif

typedef struct _RPC_PROTOCOL {
    LPTSTR  ProtName;
    LPTSTR  EndPoint;
} RPC_PROTOCOL, *PRPC_PROTOCOL;


RPC_PROTOCOL Protocols[] =
{
    TEXT("ncalrpc"),       NULL,
    TEXT("ncacn_ip_tcp"),  NULL,
    TEXT("ncacn_np"),      TEXT("\\PIPE\\faxsvc"),
    TEXT("ncadg_ip_udp"),  NULL
};

#define PROTOCOL_COUNT (sizeof(Protocols)/sizeof(Protocols[0]))


DWORD   Installed;
DWORD   InstallType;
DWORD   InstalledPlatforms;
DWORD   ProductType;

WCHAR   FaxDir[MAX_PATH];
WCHAR   FaxQueueDir[MAX_PATH];
WCHAR   FaxReceiveDir[MAX_PATH];


DWORD
FaxInitThread(
    LPVOID
    );


VOID
ConsoleDebugPrint(
    LPCTSTR buf
    )
{
    if (ConsoleDebugOutput) {
        _tprintf( TEXT("\r%s\n> "), buf );
    }
}

BOOL
ConsoleHandlerRoutine(
    DWORD CtrlType
   )
{
    if (CtrlType == CTRL_C_EVENT) {
        _tprintf( TEXT("\n\n-----------------------------------------\n") );
        _tprintf( TEXT("Control-C pressed\n") );
        _tprintf( TEXT("Fax Service ending\n") );
        _tprintf( TEXT("-----------------------------------------\n") );
        ExitProcess(0);
    }

    return FALSE;
}


VOID
PrintBanner(
    VOID
    )
{
#ifdef DBG
    DWORD LinkTime;
    TCHAR FileName[MAX_PATH];
    DWORD VerSize;
    LPVOID VerInfo;
    VS_FIXEDFILEINFO *pvs;
    DWORD Tmp;
    LPTSTR TimeString;


    LinkTime = GetTimestampForLoadedLibrary( GetModuleHandle(NULL) );
    TimeString = _tctime( (time_t*) &LinkTime );
    TimeString[_tcslen(TimeString)-1] = 0;

    if (!GetModuleFileName( NULL, FileName, sizeof(FileName) )) {
        return;
    }

    VerSize = GetFileVersionInfoSize( FileName, &Tmp );
    if (!VerSize) {
        return;
    }

    VerInfo = MemAlloc( VerSize );
    if (!VerInfo) {
        return;
    }

    if (!GetFileVersionInfo( FileName, 0, VerSize, VerInfo )) {
        return;
    }

    if (!VerQueryValue( VerInfo, TEXT("\\"), (LPVOID *)&pvs, &VerSize )) {
        MemFree( VerInfo );
        return;
    }

    DebugPrint(( TEXT("------------------------------------------------------------") ));
    DebugPrint(( TEXT("Windows NT Fax Server") ));
    DebugPrint(( TEXT("Copyright (C) Microsoft Corp 1996. All rights reserved.") ));
    DebugPrint(( TEXT("Built: %s"), TimeString ));
    DebugPrint(( TEXT("Version: %d.%d:%d.%d"),
        HIWORD(pvs->dwFileVersionMS), LOWORD(pvs->dwFileVersionMS),
        HIWORD(pvs->dwFileVersionLS), LOWORD(pvs->dwFileVersionLS)
        ));
    DebugPrint(( TEXT("------------------------------------------------------------") ));

    MemFree( VerInfo );

#endif //DBG
}



/*
 *  InitializeDefaultLogCategoryNames
 *
 *  Purpose:
 *          This function initializes the Name members of DefaultCategories,
 *          the global array of type FAX_LOG_CATEGORY.
 *
 *  Arguments:
 *          DefaultCategories - points to an array of FAX_LOG_CATEGORY structures.
 *          DefaultCategoryCount - the number of entries in DefaultCategories
 *
 *
 *  Returns:
 *          TRUE - indicates that the Name members of the DefaultCategories were
 *                 initialized without error
 *          FALSE - indicates that some error occured.
 *
 */

BOOL InitializeDefaultLogCategoryNames( PFAX_LOG_CATEGORY DefaultCategories,
                                        int DefaultCategoryCount )
{
   BOOL        fReturnValue = (BOOL) TRUE;

   int         xCategoryIndex;
   int         xStringResourceId;

   LPTSTR      ptszCategoryName;

      for ( xCategoryIndex = 0;
            xCategoryIndex < DefaultCategoryCount;
            xCategoryIndex++ )
      {
         xStringResourceId = IDS_FAX_LOG_CATEGORY_INIT_TERM + xCategoryIndex;

         ptszCategoryName = GetString( xStringResourceId );

         if ( ptszCategoryName != (LPTSTR) NULL )
         {
            DefaultCategories[xCategoryIndex].Name = ptszCategoryName;
         }
         else
         {
            DefaultCategories[xCategoryIndex].Name = TEXT("");
         }
      }

   return ( fReturnValue );
}


DWORD
ServiceStart(
    VOID
    )

/*++

Routine Description:

    Starts the RPC server.  This implementation listens on
    a list of protocols.  Hopefully this list is inclusive
    enough to handle RPC requests from most clients.

Arguments:

    None.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/

{
    DWORD Rval;
    SECURITY_ATTRIBUTES systraysa;
    SECURITY_DESCRIPTOR systraysd;
    SECURITY_ATTRIBUTES perfsa;
    PSECURITY_DESCRIPTOR perfsd;
    PREG_FAX_SERVICE FaxReg;
    HANDLE WaitHandles[3];
    DWORD WaitObject;
    HANDLE hMap;
    HANDLE hFaxStartedEvent;
//    HWND hWndSystray;
    RPC_STATUS RpcStatus;
    RPC_BINDING_VECTOR *BindingVector = NULL;
#if DBG
    HKEY hKeyLog;
    LPTSTR LogFileName;
#endif
    WCHAR CoverpageDir[MAX_PATH];



   FAX_LOG_CATEGORY DefaultCategories[] =
   {
       { NULL, FAXLOG_CATEGORY_INIT,     FAXLOG_LEVEL_MED },
       { NULL, FAXLOG_CATEGORY_OUTBOUND, FAXLOG_LEVEL_MED },
       { NULL, FAXLOG_CATEGORY_INBOUND,  FAXLOG_LEVEL_MED },
       { NULL, FAXLOG_CATEGORY_UNKNOWN,  FAXLOG_LEVEL_MED }
   };

#define DefaultCategoryCount  (sizeof(DefaultCategories) / sizeof(FAX_LOG_CATEGORY))

    ReportServiceStatus( SERVICE_START_PENDING, 0, 3000 );

#ifdef DBG
    InitializeListHead( &CritSecListHead );
    hKeyLog = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_SOFTWARE,FALSE,KEY_READ);
    if (hKeyLog) {
        LogFileName = GetRegistryString(hKeyLog,TEXT("CritSecLogFile"),TEXT("NOFILE"));

        if (_wcsicmp(LogFileName, TEXT("NOFILE")) != 0 ) {

            hLogFile = CreateFile(LogFileName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ,
                                  NULL,
                                  OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_ARCHIVE,
                                  NULL);
            if (hLogFile != INVALID_HANDLE_VALUE) {
                char AnsiBuffer[300];
                DWORD BytesWritten;

                wsprintfA(AnsiBuffer,
                          "Initializing log at %d\r\nTickCount\tObject\tObject Name\tCritical Section API\tFile\tLine\t(Time Held)\r\n",
                          GetTickCount()
                         );

                SetFilePointer(hLogFile,0,0,FILE_END);

                WriteFile(hLogFile,(LPBYTE)AnsiBuffer,strlen(AnsiBuffer) * sizeof(CHAR),&BytesWritten,NULL);
            }
        }

        MemFree( LogFileName );

        RegCloseKey( hKeyLog );

    }
#endif

    PrintBanner();

    if (!InitializeFaxDirectories()) {
       DebugPrint(( TEXT("Couldn't InitFaxDirectories, ec = %d\n"), GetLastError() ));
       return GetLastError();
    }

    //
    // create the perf counters. since fax service might be running under the system account,
    //  we must setup a security descriptor so other account (and other desktops) may access
    //  the shared memory region

    if (!BuildSecureSD(&perfsd)) {
        Rval = GetLastError();
        DebugPrint(( TEXT("BuildSecureSD() failed: err = %d"), Rval ));
        return Rval;
    }

    perfsa.nLength = sizeof(SECURITY_ATTRIBUTES);
    perfsa.bInheritHandle = TRUE;
    perfsa.lpSecurityDescriptor = perfsd;
    
    hMap = CreateFileMapping(
        INVALID_HANDLE_VALUE,
        &perfsa,
        PAGE_READWRITE | SEC_COMMIT,
        0,
        sizeof(FAX_PERF_COUNTERS),
        FAXPERF_SHARED_MEMORY
        );
    if (hMap) {
        PerfCounters = (PFAX_PERF_COUNTERS) MapViewOfFile(
            hMap,
            FILE_MAP_WRITE,
            0,
            0,
            0
            );
        if (!PerfCounters) {
            DebugPrint(( TEXT("Could not MapViewOfFile() for perf counters: err = %d"), GetLastError() ));
        }
        else {
            DebugPrint((TEXT("PerfCounters initialized successfully")));
        }
        InitializeCriticalSection( &CsPerfCounters );

        EnterCriticalSection( &CsPerfCounters );

        InboundSeconds = 0;  // Running totals used in computing PerfCounter->InboundMinutes ;
        TotalSeconds = 0;
        OutboundSeconds = 0;

        LeaveCriticalSection( &CsPerfCounters );

    } else {
        DebugPrint(( TEXT("Could not CreateFileMapping() for perf counters: err = %d"), GetLastError() ));
    }

    //
    // initialize the string table
    //

    InitializeStringTable();

    SetErrorMode( SetErrorMode( 0 ) | SEM_FAILCRITICALERRORS );

    //
    // get the registry data
    // the FaxInitThread will free this structure
    //

    FaxReg = GetFaxRegistry();
    if (!FaxReg) {
        return GetLastError();
    }

    // Initialize the Name members of the elements of DefaultCategories, the array
    // of FAX_LOG_CATEGORY structures.

    if ( InitializeDefaultLogCategoryNames( DefaultCategories,
                                            DefaultCategoryCount) == (BOOL) FALSE )
    {
       ExitProcess(0);
    }


    //
    // initialize the event log so we can log shit
    //

    if (!InitializeEventLog( FaxSvcHeapHandle, FaxReg, DefaultCategories, DefaultCategoryCount )) {
        DebugPrint(( TEXT("InitializeEventLog() failed: err = %d"), GetLastError() ));
    }

    //
    // Create a thread to do the rest of the initialization.
    // See FaxInitThread comments for details.
    //

    Rval = FaxInitThread( FaxReg );

    //
    // mark the service in the running state
    //

    ReportServiceStatus( SERVICE_RUNNING, 0, 0 );

    FaxLog(
        FAXLOG_CATEGORY_INIT,
        FAXLOG_LEVEL_MAX,
        0,
        MSG_SERVICE_STARTED
        );

    //
    // wait for the init to fail or the service to end
    //


    if (ServiceDebug) {

        WaitHandles[0] = GetStdHandle( STD_INPUT_HANDLE );

        SetConsoleCtrlHandler( ConsoleHandlerRoutine, TRUE );

        while( TRUE ) {
            WaitObject = WaitForSingleObject( WaitHandles[0], INFINITE );
            if (WaitObject != WAIT_OBJECT_0) {
                break;
            }

            //
            // input characters are available
            //

            gets( Buffer );

            switch( tolower(Buffer[0]) ) {
                case '?':
                    _tprintf( TEXT("\nFax Service Command Help:\n") );
                    _tprintf( TEXT("\t?      Help\n") );
                    _tprintf( TEXT("\tquit   Quit the Fax Service\n") );
                    _tprintf( TEXT("\tp      List ports\n") );
                    _tprintf( TEXT("\tj      List active jobs\n") );
                    _tprintf( TEXT("\te      List routing extensions\n") );
                    _tprintf( TEXT("\tq      List job queue entries\n") );
                    _tprintf( TEXT("\tm      Print memory allocations\n") );
                    _tprintf( TEXT("\tc      List RPC Client connections\n") );
                    _tprintf( TEXT("\n") );
                    break;

                case 'q':
                    if (tolower(Buffer[1]) == 'u' && tolower(Buffer[2]) == 'i' && tolower(Buffer[3]) == 't') {
                        EndFaxSvc(TRUE,FAXLOG_LEVEL_NONE);
                    } else {
                        extern LIST_ENTRY QueueListHead;
                        PLIST_ENTRY Next;
                        PJOB_QUEUE JobQueue;

                        Next = QueueListHead.Flink;
                        if (Next && ((ULONG_PTR)Next != (ULONG_PTR)&QueueListHead)) {
                            _tprintf( TEXT("Job Queue List\n") );
                            _tprintf( TEXT("\tUniqueId    JobId  Type  State   UserName          SendType   Cnt/Link\n") );
                            while ((ULONG_PTR)Next != (ULONG_PTR)&QueueListHead) {
                                JobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
                                Next = JobQueue->ListEntry.Flink;
                                _tprintf( TEXT("\t%-10I64x  %04d   %s  %s  %-16s  %s  "),
                                    JobQueue->UniqueId,
                                    JobQueue->JobId,
                                    JobQueue->JobType == JT_SEND ? TEXT("send") : TEXT("recv"),
                                    JobQueue->Paused ? TEXT("paused") : TEXT("ready "),
                                    JobQueue->UserName,
                                    JobQueue->BroadcastJob ? TEXT("broadcast") : TEXT("         ")
                                    );
                                if (JobQueue->BroadcastJob) {
                                    if (JobQueue->BroadcastOwner == NULL) {
                                        _tprintf( TEXT("%-d\n"), JobQueue->BroadcastCount );
                                    } else {
                                        _tprintf( TEXT(">>%-10I64x\n"), JobQueue->BroadcastOwner->UniqueId );
                                    }
                                }
                            }
                        } else {
                            _tprintf( TEXT("Job Queue is Empty\n") );
                        }
                    }
                    break;

                case 'p':
                case 'd':
                    {
                        PLIST_ENTRY Next;
                        PLINE_INFO LineInfo;

                        EnterCriticalSection( &CsLine );
                        Next = TapiLinesListHead.Flink;
                        if (Next && ((ULONG_PTR)Next != (ULONG_PTR)&TapiLinesListHead)) {
                            _tprintf( TEXT("Device List\n") );
                            _tprintf( TEXT("\tLineId      JobId       Device Name\n") );
                            while ((ULONG_PTR)Next != (ULONG_PTR)&TapiLinesListHead) {
                                LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
                                Next = LineInfo->ListEntry.Flink;
                                if (LineInfo->PermanentLineID && LineInfo->DeviceName) {
                                    _tprintf( TEXT("\t0x%08x  0x%08x  %s\n"),
                                        LineInfo->PermanentLineID,
                                        LineInfo->JobEntry,
                                        LineInfo->DeviceName
                                        );
                                }
                            }
                        } else {
                            _tprintf( TEXT("Device List is Empty\n") );
                        }
                        LeaveCriticalSection( &CsLine );
                    }
                    break;

                case 'j':
                    {
                        PLIST_ENTRY Next;
                        PJOB_ENTRY JobEntry;


                        EnterCriticalSection( &CsJob );
                        Next = JobListHead.Flink;
                        if (Next && ((ULONG_PTR)Next != (ULONG_PTR)&JobListHead)) {
                            _tprintf( TEXT("Job List\n") );
                            while ((ULONG_PTR)Next != (ULONG_PTR)&JobListHead) {
                                JobEntry = CONTAINING_RECORD( Next, JOB_ENTRY, ListEntry );
                                Next = JobEntry->ListEntry.Flink;
                                _tprintf( TEXT("\t") );
                                switch (JobEntry->JobType) {
                                    case JT_RECEIVE:
                                        _tprintf( TEXT("-->  ") );
                                        break;

                                    case JT_SEND:
                                        _tprintf( TEXT("<--  ") );
                                        break;

                                    default:
                                        _tprintf( TEXT("???  ") );
                                        break;
                                }
                                _tprintf( TEXT("0x%08\n" ), (ULONG_PTR) JobEntry );
                            }
                        } else {
                            _tprintf( TEXT("Job List is Empty\n") );
                        }
                        LeaveCriticalSection( &CsJob );
                    }
                    break;

                case 'c':
                    {
                        PLIST_ENTRY Next;
                        PFAX_CLIENT_DATA ClientData;


                        EnterCriticalSection( &CsClients );
                        Next = ClientsListHead.Flink;
                        if (Next && ((ULONG_PTR)Next != (ULONG_PTR)&ClientsListHead)) {
                            _tprintf( TEXT("RPC Client List\n") );
                            while ((ULONG_PTR)Next != (ULONG_PTR)&ClientsListHead) {
                                ClientData = CONTAINING_RECORD( Next, FAX_CLIENT_DATA, ListEntry );
                                Next = ClientData->ListEntry.Flink;
                                _tprintf( TEXT("\t") );
                                if (ClientData->hWnd) {
                                    _tprintf( TEXT("HWND Client         : ") );
                                } else if (ClientData->FaxClientHandle) {
                                    _tprintf( TEXT("IOCompletion Client : ") );
                                } else {
                                    _tprintf( TEXT("Unknown Client      : ") );
                                }

                                _tprintf( TEXT("0x%08\n" ), (ULONG_PTR) ClientData );
                            }
                        } else {
                            _tprintf( TEXT("RPC Client List is Empty\n") );
                        }
                        LeaveCriticalSection( &CsClients );
                    }
                    break;

                case 'e':
                    {
                        extern LIST_ENTRY RoutingExtensions;

                        PLIST_ENTRY         NextExtension;
                        PLIST_ENTRY         NextMethod;
                        PROUTING_EXTENSION  RoutingExtension;
                        PROUTING_METHOD     RoutingMethod;
                        TCHAR               GuidString[MAX_GUID_STRING_LEN];


                        NextExtension = RoutingExtensions.Flink;
                        if (NextExtension) {
                            _tprintf( TEXT("Routing Extension List\n") );
                            while ((ULONG_PTR)NextExtension != (ULONG_PTR)&RoutingExtensions) {
                                RoutingExtension = CONTAINING_RECORD( NextExtension, ROUTING_EXTENSION, ListEntry );
                                NextExtension = RoutingExtension->ListEntry.Flink;
                                _tprintf( TEXT("    %s\n"), RoutingExtension->FriendlyName );
                                NextMethod = RoutingExtension->RoutingMethods.Flink;
                                if (NextMethod) {
                                    while ((ULONG_PTR)NextMethod != (ULONG_PTR)&RoutingExtension->RoutingMethods) {
                                        RoutingMethod = CONTAINING_RECORD( NextMethod, ROUTING_METHOD, ListEntry );
                                        NextMethod = RoutingMethod->ListEntry.Flink;
                                        StringFromGUID2( &RoutingMethod->Guid, GuidString, MAX_GUID_STRING_LEN );
                                        _tprintf( TEXT("        %s\t%s\t0x%08x\n"), RoutingMethod->FunctionName, GuidString, RoutingMethod->FaxRouteMethod );
                                    }
                                }
                            }
                        }
                    }
                    break;

                case 'm':
                    PrintAllocations();
                    break;

                case '\0':
                    break;

                default:
                    _tprintf( TEXT("Invalid command\n") );
                    break;
            }

            _tprintf( TEXT("\r> ") );

        }

    }

    //
    // get rpc going
    //

    RpcpInitRpcServer();

    Rval = RpcpStartRpcServer( TEXT("FaxSvc"), fax_ServerIfHandle );

    if (ServiceDebug) {
        DebugPrint(( TEXT("FAX Service Initialized") ));
    }

    //
    // let systray know that we're initialized
    // BugBug: if the fax service is running under a user account context instead
    // of localsystem that this won't work since we have no way of impersonating
    // the client and getting to their desktop.  The solution is to open a named event
    // that we signal when we startup.
    //

    systraysa.nLength = sizeof(SECURITY_ATTRIBUTES);
    systraysa.bInheritHandle = TRUE;
    systraysa.lpSecurityDescriptor = &systraysd;

    if(!InitializeSecurityDescriptor(&systraysd, SECURITY_DESCRIPTOR_REVISION)) {
        Rval = GetLastError();
        DebugPrint(( TEXT("InitializeSecurityDescriptor() failed: err = %d"), Rval ));
        return Rval;
    }

    if(!SetSecurityDescriptorDacl(&systraysd, TRUE, (PACL)NULL, FALSE)) {
        Rval = GetLastError();
        DebugPrint(( TEXT("SetSecurityDescriptorDacl() failed: err = %d"), Rval ));
        return Rval;
    }

    hFaxStartedEvent = CreateEvent(&systraysa, FALSE, FALSE, FAX_STARTED_EVENT_NAME);
    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        SetEvent(hFaxStartedEvent);
    }
    CloseHandle(hFaxStartedEvent);

    //
    // the fax dir is initially superhidden.  we un-superhide it whenever the
    // fax service starts up since this means the user has tried fax out...
    //
    GetServerCpDir(NULL,CoverpageDir,MAX_PATH);
    if (CoverpageDir && *CoverpageDir) {
        DWORD attrib;
        LPWSTR p;

        p = wcsrchr( CoverpageDir, L'\\' );
        if (p) {
            *p = (TCHAR)NULL;
        }

        attrib = GetFileAttributes( CoverpageDir );
        attrib &= ~(FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);

        SetFileAttributes( CoverpageDir, attrib );
    }

#if 0
    if ((hWndSystray = FindWindow(FAXSTAT_WINCLASS,NULL)) != NULL) {
        PostMessage(hWndSystray, WM_FAX_START, 0, 0);
    }
#endif

    RpcStatus = RpcMgmtWaitServerListen();
    if (RpcStatus == RPC_S_OK) {
        Rval = 0;
    } else {
        Rval = RpcStatus;
    }

    if (Rval) {
        //
        // the fax server did not initialize correctly
        //
        EndFaxSvc(TRUE,FAXLOG_LEVEL_NONE);

        return Rval;
    }

    return 0;
}

void EndFaxSvc(
    BOOL bEndProcess,
    DWORD SeverityLevel
    )
/*++

Routine Description:

    End the fax service.

Arguments:

    None.

Return Value:

    None.

--*/
{
    hServiceEndEvent = CreateEvent(NULL,FALSE,FALSE,NULL);

    //
    // let our RPC clients know we're ending
    //
    CreateFaxEvent(0,FEI_FAXSVC_ENDED,0xFFFFFFFF);

    // wait 5 seconds
    WaitForSingleObject(hServiceEndEvent,5*MILLISECONDS_PER_SECOND);

    FaxLog(
        FAXLOG_CATEGORY_INIT,
        SeverityLevel,
        0,
        MSG_SERVICE_STOPPED
        );

#if DBG
    if (hLogFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hLogFile);
    }
#endif

    ServiceStop();

    ReportServiceStatus( SERVICE_STOPPED, 0 , 0);

    if (bEndProcess) {
        ExitProcess(0);
    }
}



void
ServiceStop(
    void
    )

/*++

Routine Description:

    Stops the RPC server.

Arguments:

    None.

Return Value:

    None.

--*/

{
    RpcMgmtStopServerListening( 0 );
}


DWORD
FaxInitThread(
    PREG_FAX_SERVICE FaxReg
    )

/*++

Routine Description:

    Initialize device providers, TAPI, job manager and router.
    This is done in a separate thread because NT Services should
    not block for long periods of time before setting the service status
    to SERVICE_RUNNING.  While a service is marked as START_PENDING, the SCM
    blocks all calls to StartService.  During TAPI initialization, StartService
    is called to start tapisrv and then tapisrv calls UNIMODEM that in turn
    calls StartService.

    Starts the RPC server.  This implementation listens on
    a list of protocols.  Hopefully this list is inclusive
    enough to handle RPC requests from most clients.

Arguments:

    None.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/

{
    DWORD Rval;
    ULONG i = 0;
    BOOL GoodProt = FALSE;


    GetInstallationInfo( &Installed, &InstallType, &InstalledPlatforms, &ProductType );

    InitializeCriticalSection( &CsClients );
    InitializeListHead( &ClientsListHead );

    InitializeFaxSecurityDescriptors();

    //
    // load the device providers
    //

    if (!LoadDeviceProviders( FaxReg )) {
        Rval = ERROR_BAD_DEVICE;
        goto exit;
    }

    //
    // get the handle table
    //

    if (!InitializeHandleTable( FaxReg )) {
        Rval = ERROR_GEN_FAILURE;
        goto exit;
    }

    //
    // get the job manager and it's threads going
    //

    if (!InitializeJobManager( FaxReg )) {
        Rval = ERROR_GEN_FAILURE;
        goto exit;
    }

    //
    // initialize TAPI
    //
    Rval = TapiInitialize( FaxReg );
    if (Rval) {
        goto exit;
    }

    //
    // initialize the device providers
    //

    if (!InitializeDeviceProviders()) {
        Rval = ERROR_BAD_DEVICE;
        goto exit;
    }

    UpdateVirtualDevices();

    //
    // get the inbound fax router up and running
    //

    if (!InitializeRouting( FaxReg )) {
//      Rval = ERROR_GEN_FAILURE;
//      goto exit;
    }

    //
    // free the registry data
    //

    FreeFaxRegistry( FaxReg );

exit:
    return Rval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\stattest\stattest.c ===
#include <windows.h>
#include <stdio.h>

#include "faxutil.h"
#include "winfax.h"


typedef struct _EVENT_STRINGS {
    DWORD   EventId;
    LPWSTR  EventStr;
} EVENT_STRINGS, *PEVENT_STRINGS;

EVENT_STRINGS EventStrings[] =
{
    FEI_DIALING,              L"Dialing",
    FEI_SENDING,              L"Sending",
    FEI_RECEIVING,            L"Receiving",
    FEI_COMPLETED,            L"Completed",
    FEI_BUSY,                 L"Busy",
    FEI_NO_ANSWER,            L"No Answer",
    FEI_BAD_ADDRESS,          L"Bad Address",
    FEI_NO_DIAL_TONE,         L"No Dial Tone",
    FEI_DISCONNECTED,         L"Disconnected",
    FEI_FATAL_ERROR,          L"Fatal Error",
    FEI_NOT_FAX_CALL,         L"Not a Fax Call",
    FEI_CALL_DELAYED,         L"Call Delayed",
    FEI_CALL_BLACKLISTED,     L"Call Blacklisted",
    FEI_RINGING,              L"Ringing",
    FEI_ABORTING,             L"Aborting",
    FEI_ROUTING,              L"Routing",
    FEI_MODEM_POWERED_ON,     L"Modem Powered Off",
    FEI_MODEM_POWERED_OFF,    L"Modem Powered On",
    FEI_IDLE,                 L"Idle",
    FEI_FAXSVC_ENDED,         L"Fax Service Ended",
    0,                        L"Unknown Event"
};

#define NumEventStrings ((sizeof(EventStrings)/sizeof(EVENT_STRINGS))-1)

HANDLE CompletionPort;


BOOL
ConsoleHandlerRoutine(
    DWORD CtrlType
   )
{
    if (CtrlType == CTRL_C_EVENT) {
        PostQueuedCompletionStatus( CompletionPort, 0, (DWORD) -1, 0 );
        return TRUE;
    }

    return FALSE;
}


PFAX_PORT_INFO_1
MyFaxEnumPorts(
    HFAX    hFaxSvc,
    LPDWORD pcPorts
    )
{
    PVOID   pSvcPorts = NULL;
    DWORD   cb;

    if (!FaxEnumPorts(hFaxSvc, (LPBYTE*) &pSvcPorts, &cb, 1, pcPorts))
    {
        pSvcPorts = NULL;
    }

    return pSvcPorts;
}


int _cdecl
wmain(
    int argc,
    wchar_t *argv[]
    )
{
    HFAX hFax = NULL;
    PFAX_EVENT FaxEvent;
    BOOL Rval;
    DWORD Bytes;
    DWORD CompletionKey;
    SYSTEMTIME EvtTime;
    PFAX_PORT_INFO_1 PortInfo;
    DWORD PortCount;
    DWORD i;
    FAX_PORT_HANDLE FaxPortHandle = 0;
    LPWSTR ComputerName = NULL;


    HeapInitialize(NULL,NULL,NULL,0);

    if (argc > 1) {
        ComputerName = argv[1];
    }

    if( !FaxConnectFaxServer( ComputerName, &hFax ) ){
        wprintf( L"FaxConnectFaxServer failed ec = %d\n", GetLastError() );
        return -1;
    }

    CompletionPort = CreateIoCompletionPort(
        INVALID_HANDLE_VALUE,
        NULL,
        0,
        1
        );
    if (!CompletionPort) {
        wprintf( L"CreateIoCompletionPort() failed, ec=0x%08x\n", GetLastError() );
        return -1;
    }

    PortInfo = MyFaxEnumPorts( hFax, &PortCount );
    if (!PortInfo) {
        wprintf( L"MyFaxEnumPorts() failed, ec=0x%08x\n", GetLastError() );
        return -1;
    }

    for (i=0; i<PortCount; i++) {
        Rval = FaxOpenPort( hFax, PortInfo[i].DeviceId, PORT_OPEN_EVENTS, &FaxPortHandle );
        if (!Rval) {
            wprintf( L"FaxOpenPort() failed, ec=0x%08x\n", GetLastError() );
        }
    }

    if (!FaxInitializeEventQueue( hFax, CompletionPort, 0 )) {
        wprintf( L"FaxInitializeEvent() failed, ec=0x%08x\n", GetLastError() );
        return -1;
    }

    SetConsoleCtrlHandler( ConsoleHandlerRoutine, TRUE );

    while (TRUE) {

        Rval = GetQueuedCompletionStatus(
            CompletionPort,
            &Bytes,
            &CompletionKey,
            (LPOVERLAPPED*) &FaxEvent,
            INFINITE
            );
        if (!Rval) {
            wprintf( L"GetQueuedCompletionStatus() failed, ec=0x%08x\n", GetLastError() );
            return -1;
        }

        if (CompletionKey == (DWORD)-1) {
            wprintf( L"\n\n-----------------------------------------\n" );
            wprintf( L"Control-C pressed\n" );
            wprintf( L"StatTest Ending\n" );
            wprintf( L"-----------------------------------------\n" );
            break;
        }

        FileTimeToSystemTime( &FaxEvent->TimeStamp, &EvtTime );

        for (i=0; i<NumEventStrings; i++) {
            if (FaxEvent->EventId == EventStrings[i].EventId) {
                break;
            }
        }

        wprintf( L"%02d:%02d:%02d.%03d  hServer=0x%08x, hPort=0x%08x, device=0x%08x, event=0x%08x  %ws\n",
            EvtTime.wHour,
            EvtTime.wMinute,
            EvtTime.wSecond,
            EvtTime.wMilliseconds,
            FaxEvent->FaxServerHandle,
            FaxEvent->FaxPortHandle,
            FaxEvent->DeviceId,
            FaxEvent->EventId,
            EventStrings[i].EventStr
            );

        LocalFree( FaxEvent );
    }

    if (hFax) {
        Rval = FaxDisconnectFaxServer( hFax );
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\server\tapi.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tapi.c

Abstract:

    This module wraps all of the TAPI calls.

Author:

    Wesley Witt (wesw) 22-Jan-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop


//
// globals
//
HLINEAPP            hLineApp;                       // application line handle
DWORD               TapiApiVersion;                 //
HANDLE              TapiCompletionPort;             //
DWORD               DeviceInstalled;                //


CRITICAL_SECTION    CsLine;                         // critical section for accessing tapi lines
DWORD               TapiDevices;                    // number of tapi devices
DWORD               DeviceCount;                    // number of devices in the TapiLinesListHead
LIST_ENTRY          TapiLinesListHead;              // linked list of tapi lines
LPBYTE              AdaptiveFileBuffer;             // list of approved adaptive answer modems

extern LONG         ConnectionCount;


#include "modem.c"


BOOL
AddNewDevice(
    DWORD DeviceId,
    LPLINEDEVCAPS LineDevCaps,
    BOOL InitDevice
    );

DWORD
InitializeTapiLine(
    DWORD DeviceId,
    LPLINEDEVCAPS LineDevCaps,
    DWORD Priority,
    DWORD Rings,
    DWORD Flags,
    LPTSTR Csid,
    LPTSTR Tsid
    );



LPTSTR
FixupDeviceName(
    LPTSTR OrigDeviceName
    )
{
    LPTSTR NewDeviceName;
    LPTSTR p;


    NewDeviceName = StringDup( OrigDeviceName );
    if (!NewDeviceName) {
        return NULL;
    }

    p = _tcschr( NewDeviceName, TEXT(',') );
    if (!p) {
        return NewDeviceName;
    }

    p = NewDeviceName;

    while( p ) {
        p = _tcschr( p, TEXT(',') );
        if (p) {
            *p = TEXT('_');
        }
    }

    return NewDeviceName;
}


VOID
FreeTapiLine(
    PLINE_INFO LineInfo
    )
{
    HLINE hLine = 0;


    if (!LineInfo) {
        return;
    }

    if (LineInfo->hLine) {
        hLine = LineInfo->hLine;
        LineInfo->hLine = 0;
    }

    MemFree( LineInfo->DeviceName );
    MemFree( LineInfo->Tsid );

    MemFree( LineInfo );

    if (hLine) {
        lineClose( hLine );
    }
}


int
__cdecl
DevicePriorityCompare(
    const void *arg1,
    const void *arg2
    )
{
    if (((PDEVICE_SORT)arg1)->Priority < ((PDEVICE_SORT)arg2)->Priority) {
        return -1;
    }
    if (((PDEVICE_SORT)arg1)->Priority > ((PDEVICE_SORT)arg2)->Priority) {
        return 1;
    }
    return 0;
}


BOOL
SortDevicePriorities(
    VOID
    )
{
    PLIST_ENTRY Next;
    PLINE_INFO LineInfo;
    PDEVICE_SORT DeviceSort;
    DWORD i = 0;


    EnterCriticalSection( &CsLine );

    Next = TapiLinesListHead.Flink;
    if (Next == NULL) {
        LeaveCriticalSection( &CsLine );
        return FALSE;
    }

    DeviceSort = (PDEVICE_SORT) MemAlloc( DeviceCount * sizeof(DEVICE_SORT) );
    if (DeviceSort == NULL) {
        LeaveCriticalSection( &CsLine );
        return FALSE;
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&TapiLinesListHead) {
        LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        Next = LineInfo->ListEntry.Flink;
        DeviceSort[i].Priority = LineInfo->Priority;
        DeviceSort[i].LineInfo = LineInfo;
        i += 1;
    }

    qsort(
        (PVOID)DeviceSort,
        (int)DeviceCount,
        sizeof(DEVICE_SORT),
        DevicePriorityCompare
        );

    InitializeListHead( &TapiLinesListHead );

    for (i=0; i<DeviceCount; i++) {
        DeviceSort[i].LineInfo->Priority = i + 1;
        DeviceSort[i].LineInfo->ListEntry.Flink = NULL;
        DeviceSort[i].LineInfo->ListEntry.Blink = NULL;
        InsertTailList( &TapiLinesListHead, &DeviceSort[i].LineInfo->ListEntry );
    }

    LeaveCriticalSection( &CsLine );

    MemFree( DeviceSort );

    return TRUE;
}


DWORD GetFaxDeviceCount(
    VOID
    )
/*++
Routine Description:

    counts the number of installed fax devices

Arguments:

    NONE.

Return Value:

    number of devices

--*/
{
    DWORD FaxDevices = 0;
    PLIST_ENTRY Next;
    PLINE_INFO LineInfo;


    __try {
        EnterCriticalSection(&CsLine);

        Next = TapiLinesListHead.Flink;

        while ((ULONG_PTR)Next != (ULONG_PTR)&TapiLinesListHead) {

            LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
            Next = LineInfo->ListEntry.Flink;

            if (LineInfo->PermanentLineID && LineInfo->DeviceName) {
                FaxDevices += 1;
            }
        }

        LeaveCriticalSection(&CsLine);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        LeaveCriticalSection(&CsLine);
    }

    return FaxDevices;
}


BOOL GetDeviceTypeCount(
    LPDWORD SendDevices,
    LPDWORD ReceiveDevices
    )
/*++
Routine Description:

    counts the number of devices with receive enabled, number with send enabled

Arguments:

    SendDevices - receives number of send devices
    ReceiveDevices - receives number of receive devices

Return Value:

    number of devices

--*/
{
    DWORD Rx = 0, Tx = 0;
    PLIST_ENTRY Next;
    PLINE_INFO LineInfo;

    __try {
        EnterCriticalSection(&CsLine);

        Next = TapiLinesListHead.Flink;

        while ((ULONG_PTR)Next != (ULONG_PTR)&TapiLinesListHead) {

            LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
            Next = LineInfo->ListEntry.Flink;

            if (LineInfo->PermanentLineID && LineInfo->DeviceName) {
                if ((LineInfo->Flags & FPF_SEND) == FPF_SEND) {
                    Tx++;
                }

                if ((LineInfo->Flags & FPF_RECEIVE) == FPF_RECEIVE) {
                    Rx++;
                }
            }
        }

        LeaveCriticalSection(&CsLine);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        LeaveCriticalSection(&CsLine);
    }

    if (SendDevices) {
        *SendDevices = Tx;
    }

    if (ReceiveDevices) {
        *ReceiveDevices = Rx;
    }

    return TRUE;
}

BOOL
CommitDeviceChanges(
    VOID
    )
/*++
Routine Description:

    commit device changes to registry.
    note that we commit all devices to registry since priority may have changed

Arguments:

    NONE.

Return Value:

    TRUE for success.

--*/
{
    PLIST_ENTRY Next;
    PLINE_INFO LineInfo;

    __try {
        EnterCriticalSection(&CsLine);

        Next = TapiLinesListHead.Flink;

        while ((ULONG_PTR)Next != (ULONG_PTR)&TapiLinesListHead) {

            LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
            Next = LineInfo->ListEntry.Flink;

            if (LineInfo->PermanentLineID && LineInfo->DeviceName) {
                RegAddNewFaxDevice(
                                   LineInfo->DeviceName,
                                   LineInfo->Provider->ProviderName,
                                   LineInfo->Csid,
                                   LineInfo->Tsid,
                                   LineInfo->Priority,
                                   LineInfo->PermanentLineID,
                                   LineInfo->Flags & 0x0fffffff,
                                   LineInfo->RingsForAnswer,
                                   -1,
                                   NULL,
                                   NULL,
                                   NULL
                                   );
            }
        }

        LeaveCriticalSection(&CsLine);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        LeaveCriticalSection(&CsLine);
    }

    return TRUE;


}


ULONG
TapiWorkerThread(
    LPVOID UnUsed
    )

/*++

Routine Description:

    This is worker thread for the FAX service.  All queued
    requests are processed here.

Arguments:

    None.

Return Value:

    Thread return value.

--*/

{
    PLINE_INFO LineInfo;
    BOOL Rval;
    DWORD Bytes;
    ULONG_PTR CompletionKey;
    LPLINEMESSAGE LineMsg = NULL;


    while( TRUE ) {

        if (LineMsg) {
            LocalFree( LineMsg );
        }

        Rval = GetQueuedCompletionStatus(
            TapiCompletionPort,
            &Bytes,
            &CompletionKey,
            (LPOVERLAPPED*) &LineMsg,
            INFINITE
            );

        if (!Rval) {

            Rval = GetLastError();
            LineMsg = NULL;
            DebugPrint(( TEXT("GetQueuedCompletionStatus() failed, ec=0x%08x"), Rval ));
            continue;

        }

        SetThreadExecutionState(ES_SYSTEM_REQUIRED | ES_CONTINUOUS);

        if (CompletionKey == FAXDEV_EVENT_KEY) {

            //
            // this is an event from a fax service provider
            // that has enumerated virtual device(s)
            //
            // the LINEMESSAGE structure must be filled out
            // as follows:
            //
            //     LineMsg->hDevice               ==  DeviceId from FaxDevStartJob()
            //     LineMsg->dwMessageID           ==  0
            //     LineMsg->dwCallbackInstance    ==  0
            //     LineMsg->dwParam1              ==  LINEDEVSTATE_RINGING
            //     LineMsg->dwParam2              ==  0
            //     LineMsg->dwParam3              ==  0
            //

            EnterCriticalSection( &CsJob );
            EnterCriticalSection( &CsLine );

            LineInfo = GetTapiLineFromDeviceId( (DWORD) LineMsg->hDevice );
            if (!LineInfo) {
                goto next_event;
            }

            if (LineMsg->dwParam1 == LINEDEVSTATE_RINGING) {

                LineInfo->RingCount += 1;
                CreateFaxEvent( LineInfo->PermanentLineID, FEI_RINGING, 0xffffffff );
                if ((LineInfo->Flags & FPF_RECEIVE) && (LineInfo->State == FPS_AVAILABLE)) {

                    PJOB_ENTRY JobEntry;
                    TCHAR FileName[MAX_PATH];

                    //
                    // start a fax job
                    //

                    JobEntry = StartJob( LineInfo->PermanentLineID, JT_RECEIVE, NULL );
                    if (JobEntry) {

                        //
                        // receive the fax
                        //

                        StartFaxReceive(
                            JobEntry,
                            0,
                            LineInfo,
                            FileName,
                            sizeof(FileName)
                            );

                    } else {

                        DebugPrint(( TEXT("StartJob() failed, cannot receive incoming fax") ));

                    }
                }
            }

            goto next_event;
        }

        LineInfo = (PLINE_INFO) LineMsg->dwCallbackInstance;

        ShowLineEvent(
            (HLINE) LineMsg->hDevice,
            (HCALL) LineMsg->hDevice,
            LineInfo == NULL ? TEXT("*NULL LineInfo*") : (LineInfo->JobEntry == NULL) ? TEXT("*NULL Job*") : NULL,
            LineMsg->dwCallbackInstance,
            LineMsg->dwMessageID,
            LineMsg->dwParam1,
            LineMsg->dwParam2,
            LineMsg->dwParam3
            );

        EnterCriticalSection( &CsJob );
        EnterCriticalSection( &CsLine );

        __try {

            switch( LineMsg->dwMessageID ) {
                case LINE_ADDRESSSTATE:

                    if (LineMsg->dwParam2 == LINEADDRESSSTATE_INUSEONE ||
                        LineMsg->dwParam2 == LINEADDRESSSTATE_INUSEMANY) {

                        //
                        // the port is now unavailable
                        //
                        LineInfo->State = FPS_AVAILABLE;

                    }

                    if (LineMsg->dwParam2 == LINEADDRESSSTATE_INUSEZERO) {

                        //
                        // the port is now available
                        //
                        LineInfo->State = FPS_UNAVAILABLE;

                    }

                    break;

                case LINE_CALLINFO:
                    break;

                case LINE_CALLSTATE:
                    if (LineMsg->dwParam3 == LINECALLPRIVILEGE_OWNER && LineInfo->JobEntry && LineInfo->JobEntry->HandoffJob) {
                        //
                        // call was just handed off to us
                        //
                        if (LineInfo->JobEntry  && LineInfo->JobEntry->HandoffJob) {
                            LineInfo->HandoffCallHandle = (HCALL) LineMsg->hDevice;
                            SetEvent( LineInfo->JobEntry->hCallHandleEvent );
                        }
                        else {
                            lineDeallocateCall( (HCALL) LineMsg->hDevice );
                        }

                    }
                    if (LineMsg->dwParam1 == LINECALLSTATE_IDLE) {
                        ReleaseTapiLine( LineInfo, (HCALL) LineMsg->hDevice );
                        LineInfo->NewCall = FALSE;
                        CreateFaxEvent( LineInfo->PermanentLineID, FEI_IDLE, 0xffffffff );
                    }

                    if (LineInfo->NewCall && LineMsg->dwParam1 != LINECALLSTATE_OFFERING && LineInfo->State == FPS_AVAILABLE) {
                        LineInfo->State = FPS_NOT_FAX_CALL;
                        LineInfo->NewCall = FALSE;
                    }
                    break;

                case LINE_CLOSE:
                    //
                    // this usually happens when something bad happens to the modem device. before we go off and scare the
                    // user with a popup, let's try to revive the device once.  Then we can let them know that the device is
                    // messed up or powered off.
                    //
                    DebugPrint(( TEXT("Received a LINE_CLOSE message for device %x [%s]."),
                                 LineInfo->DeviceId,
                                 LineInfo->DeviceName ));

                    if (OpenTapiLine( LineInfo )) {

                            DebugPrint(( TEXT("Device [%s] was revived"), LineInfo->DeviceName ));
                            LineInfo->Flags &= ~FPF_POWERED_OFF;

                            LineInfo->State = 0;

                            if (LineInfo->Flags & FPF_RECEIVE_OK) {
                                LineInfo->Flags |= FPF_RECEIVE;
                                LineInfo->Flags &= ~FPF_RECEIVE_OK;
                            }
                    } else {
                        //
                        // the modem is really messed up or powered off, so it's ok to scare the user. :)
                        //

                        if (LineInfo->Flags & FPF_RECEIVE) {
                            LineInfo->Flags &= ~FPF_RECEIVE;
                            LineInfo->Flags |= FPF_RECEIVE_OK;
                        }
                        LineInfo->Flags |= FPF_POWERED_OFF;

                        LineInfo->State = FPS_OFFLINE;

                        LineInfo->hLine = 0;

                        CreateFaxEvent( LineInfo->PermanentLineID, FEI_MODEM_POWERED_OFF, 0xffffffff );


                        //
                        // put a popup on the currently active desktop
                        // we only allow 1 popup per device at a time
                        // and we only present the popup twice
                        //

                        if (!LineInfo->ModemInUse &&
                            LineInfo->ModemPopupActive &&
                            LineInfo->ModemPopUps < MAX_MODEM_POPUPS)
                        {

                            LineInfo->ModemPopupActive = 0;
                            LineInfo->ModemPopUps += 1;

                            ServiceMessageBox(
                                GetString( IDS_POWERED_OFF_MODEM ),
                                MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND,
                                TRUE,
                                &LineInfo->ModemPopupActive
                                );

                        }

                    }

                    //
                    // if we were waiting for a handoff, give up on it!
                    //
                    if (LineInfo->JobEntry && LineInfo->JobEntry->HandoffJob) {
                        LineInfo->HandoffCallHandle = 0;
                        SetEvent(LineInfo->JobEntry->hCallHandleEvent);
                    }

                    break;

                case LINE_DEVSPECIFIC:
                    break;

                case LINE_DEVSPECIFICFEATURE:
                    break;

                case LINE_GATHERDIGITS:
                    break;

                case LINE_GENERATE:
                    break;

                case LINE_LINEDEVSTATE:
                    if (LineMsg->dwParam1 == LINEDEVSTATE_RINGING) {

                        LineInfo->RingCount = (DWORD)LineMsg->dwParam3 + 1;

                        CreateFaxEvent( LineInfo->PermanentLineID, FEI_RINGING, 0xffffffff );

                        //
                        // Pick up the line only if the last inbound job has completed
                        //

                        if (LineInfo->State != FPS_AVAILABLE) {
                            break;
                        }

                        if ((LineInfo->Flags & FPF_RECEIVE) && (LineInfo->State == FPS_AVAILABLE)) {

                            if (LineInfo->LineMsgOffering.hDevice == 0) {
                                //
                                // wait for the offering message
                                //
                                break;
                            }

                            if ((LineInfo->RingCount > LineInfo->RingsForAnswer) && !LineInfo->JobEntry) {

                                PJOB_ENTRY JobEntry;
                                TCHAR FileName[MAX_PATH];

                                //
                                // start a fax job
                                //

                                JobEntry = StartJob( LineInfo->PermanentLineID, JT_RECEIVE, NULL );
                                if (JobEntry) {

                                    //
                                    // receive the fax
                                    //

                                    StartFaxReceive(
                                        JobEntry,
                                        (HCALL) LineInfo->LineMsgOffering.hDevice,
                                        LineInfo,
                                        FileName,
                                        sizeof(FileName)
                                        );

                                } else {

                                    DebugPrint(( TEXT("StartJob() failed, cannot receive incoming fax") ));

                                }
                            }

                        } else {

                            //
                            // we are not supposed to answer the call, so give it to ras
                            //

                            HandoffCallToRas( LineInfo, (HCALL) LineInfo->LineMsgOffering.hDevice );

                        }
                    }
                    break;

                case LINE_MONITORDIGITS:
                    break;

                case LINE_MONITORMEDIA:
                    break;

                case LINE_MONITORTONE:
                    break;

                case LINE_REPLY:
                    if (LineInfo->InitEvent && LineInfo->RequestId == LineMsg->dwParam1) {
                        LineInfo->Result = (DWORD)LineMsg->dwParam2;
                        SetEvent( LineInfo->InitEvent );
                    }
                    break;

                case LINE_REQUEST:
                    break;

                case PHONE_BUTTON:
                    break;

                case PHONE_CLOSE:
                    break;

                case PHONE_DEVSPECIFIC:
                    break;

                case PHONE_REPLY:
                    break;

                case PHONE_STATE:
                    break;

                case LINE_CREATE:
                    {
                        LPLINEDEVCAPS LineDevCaps;
                        LINEEXTENSIONID lineExtensionID;
                        DWORD LocalTapiApiVersion;
                        DWORD Rslt;
                        DWORD DeviceId;

                        DeviceId = (DWORD)LineMsg->dwParam1;


                        Rslt = lineNegotiateAPIVersion(
                            hLineApp,
                            DeviceId,
                            0x00010003,
                            TapiApiVersion,
                            &LocalTapiApiVersion,
                            &lineExtensionID
                            );
                        if (Rslt == 0) {
                            LineDevCaps = MyLineGetDevCaps( DeviceId );
                            if (LineDevCaps) {
                                AddNewDevice( DeviceId, LineDevCaps, TRUE );
                                MemFree( LineDevCaps );
                            }
                        }
                    }
                    break;

                case PHONE_CREATE:
                    break;

                case LINE_AGENTSPECIFIC:
                    break;

                case LINE_AGENTSTATUS:
                    break;

                case LINE_APPNEWCALL:
                    LineInfo->NewCall = TRUE;
                    break;

                case LINE_PROXYREQUEST:
                    break;

                case LINE_REMOVE:
                    break;

                case PHONE_REMOVE:
                    break;
            }

            if (LineInfo && ((!LineInfo->Provider) || (!LineInfo->Provider->FaxDevCallback))) {

                DebugPrint(( TEXT("Unhandled tapi callback event") ));
                goto next_event;

            }

            //
            // call the device provider's line callback function
            //

            __try {

                if (LineInfo && LineInfo->JobEntry) {

                    LineInfo->Provider->FaxDevCallback(
                        LineInfo->JobEntry ? (HANDLE) LineInfo->JobEntry->InstanceData : NULL,
                        LineMsg->hDevice,
                        LineMsg->dwMessageID,
                        LineMsg->dwCallbackInstance,
                        LineMsg->dwParam1,
                        LineMsg->dwParam2,
                        LineMsg->dwParam3
                        );

                }

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                DebugPrint(( TEXT("Device provider tapi callback crashed: 0x%08x"), GetExceptionCode() ));

            }

            if (LineMsg->dwMessageID == LINE_CALLSTATE && LineMsg->dwParam1 == LINECALLSTATE_OFFERING) {
                // we'll get a LINE_LINEDEVSTATE (RINGING) event, so we'll post the ring event there or we'll get a duplicate event
                //CreateFaxEvent( LineInfo->PermanentLineID, FEI_RINGING, 0xffffffff );
                LineInfo->NewCall = FALSE;

                if ((LineInfo->Flags & FPF_RECEIVE) && (LineInfo->State == FPS_AVAILABLE)) {

                    if ((LineInfo->RingCount > LineInfo->RingsForAnswer) && !LineInfo->JobEntry) {

                        PJOB_ENTRY JobEntry;
                        TCHAR FileName[MAX_PATH];

                        //
                        // start a fax job
                        //

                        JobEntry = StartJob( LineInfo->PermanentLineID, JT_RECEIVE, NULL );
                        if (JobEntry) {

                            //
                            // receive the fax
                            //

                            StartFaxReceive(
                                JobEntry,
                                (HCALL) LineMsg->hDevice,
                                LineInfo,
                                FileName,
                                sizeof(FileName)
                                );

                        } else {

                            DebugPrint(( TEXT("StartJob() failed, cannot receive incoming fax") ));

                        }

                    } else {

                        //
                        // save the line msg
                        //

                        CopyMemory( &LineInfo->LineMsgOffering, LineMsg, sizeof(LINEMESSAGE) );

                    }


                } else {

                    //
                    // we are not supposed to answer the call, so give it to ras
                    //

                    HandoffCallToRas( LineInfo, (HCALL) LineMsg->hDevice );

                }
            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            DebugPrint(( TEXT("TapiWorkerThread() crashed: 0x%08x"), GetExceptionCode() ));

        }

next_event:
        LeaveCriticalSection( &CsLine );
        LeaveCriticalSection( &CsJob );

        SetThreadExecutionState(ES_CONTINUOUS);
    }

    return 0;
}


BOOL
HandoffCallToRas(
    PLINE_INFO LineInfo,
    HCALL hCall
    )

/*++

Routine Description:

    This function will try to hand a call of to RAS.
    We do this under 2 circumstances:
        1) we've answered an incoming call and
           determined that the call is NOT a fax call
        2) the configuration for the line that is
           ringing is not configured for receiving faxes
    If the handoff fails and we have an open job for the
    line, then we have to call the device provider so that
    the line can be put on hook.

Arguments:

    LineInfo    - LineInfo structure for the line this call is on
    hCall       - TAPI call handle

Return Value:

    TRUE for success
    FALSE for failure

--*/

{
    LONG Rval;


    //
    // need to hand the call off to RAS
    //

    Rval = lineHandoff(
        hCall,
        RAS_MODULE_NAME,
        LINEMEDIAMODE_DATAMODEM
        );
    if (Rval != 0 && LineInfo && LineInfo->JobEntry) {

        DebugPrint(( TEXT("lineHandoff() failed, ec=0x%08x"), Rval ));

        //
        // since the handoff failed we must notify
        // the fsp so that the call can be put onhook
        //

        __try {

            LineInfo->Provider->FaxDevAbortOperation(
                    (HANDLE) LineInfo->JobEntry->InstanceData
                    );

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            DebugPrint(( TEXT("FaxDevAbortOperation() failed: 0x%08x"), GetExceptionCode() ));

        }

    } else {
        DebugPrint(( TEXT("call handed off to RAS") ));
    }

    return Rval == 0;
}


PLINE_INFO
GetTapiLineFromDeviceId(
    DWORD DeviceId
    )
{
    PLIST_ENTRY Next;
    PLINE_INFO LineInfo;


    Next = TapiLinesListHead.Flink;
    if (!Next) {
        return NULL;
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&TapiLinesListHead) {

        LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        Next = LineInfo->ListEntry.Flink;

        if (LineInfo->PermanentLineID == DeviceId) {
            return LineInfo;
        }

    }

    return NULL;
}


PLINE_INFO
GetTapiLineForFaxOperation(
    DWORD DeviceId,
    DWORD JobType,
    LPWSTR FaxNumber,
    BOOL Handoff
    )

/*++

Routine Description:

    Locates an avaliable TAPI device for use in a
    FAX operation.  The selection is based on the
    available devices and their assigned priority.

Arguments:

    DeviceId      - device for operation
    JobType       - send or receive job
    FaxNumber     - the number for a send
    Handoff       - will this be a handoff job?

Return Value:

    Pointer to a LINE_INFO structure or NULL is the
    function fails.

--*/

{
    static NoDevicePopupCount = 0;
    PLIST_ENTRY Next;
    PLINE_INFO LineInfo;
    PLINE_INFO SelectedLine = NULL;


    EnterCriticalSection( &CsLine );

    Next = TapiLinesListHead.Flink;
    //
    // only makes sense for a send job
    //
    if (Next && (JobType == JT_SEND) && FaxNumber) {
        while ((ULONG_PTR)Next != (ULONG_PTR)&TapiLinesListHead) {
            LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
            Next = LineInfo->ListEntry.Flink;

            //
            // prevent a race condition?
            //
            if (LineInfo->JobEntry && LineInfo->JobEntry->PhoneNumber[0]) {
                if (_wcsicmp( LineInfo->JobEntry->PhoneNumber, FaxNumber ) == 0) {
                    LeaveCriticalSection( &CsLine );
                    return NULL;
                }
            }
        }
    }

    Next = TapiLinesListHead.Flink;
    if (Next) {
        while ((ULONG_PTR)Next != (ULONG_PTR)&TapiLinesListHead) {

            LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
            Next = LineInfo->ListEntry.Flink;

            if (DeviceId != USE_SERVER_DEVICE) {

                // find the specified device
                if (LineInfo->PermanentLineID == DeviceId) {

                    if (Handoff) {
                        if (JobType!= JT_SEND) {
                            break;
                        }
                        SelectedLine = LineInfo;
                        // LineInfo->State = FPS_???;
                        break;
                    }

                    if ((LineInfo->State == FPS_AVAILABLE) &&
                        ((JobType == JT_SEND && (LineInfo->Flags & FPF_SEND)) ||
                         (JobType == JT_RECEIVE && (LineInfo->Flags & FPF_RECEIVE))))
                    {
                        LineInfo->State = 0;
                        SelectedLine = LineInfo;
                        break;

                    } else if (LineInfo->UnimodemDevice && (LineInfo->Flags & FPF_POWERED_OFF)) {
                        //
                        // see if we can revive the device
                        //
                        if (OpenTapiLine( LineInfo )) {

                            DebugPrint(( TEXT("Device [%s] is now powered on"), LineInfo->DeviceName ));
                            LineInfo->Flags &= ~FPF_POWERED_OFF;

                            LineInfo->State = 0;

                            if (LineInfo->Flags & FPF_RECEIVE_OK) {
                                LineInfo->Flags |= FPF_RECEIVE;
                                LineInfo->Flags &= ~FPF_RECEIVE_OK;
                            }

                            CreateFaxEvent( LineInfo->PermanentLineID, FEI_MODEM_POWERED_ON, 0xffffffff );

                            SelectedLine = LineInfo;
                        }
                    }

                    break;

                }

            } else {

                Assert( JobType != JT_RECEIVE );

                if ((LineInfo->State == FPS_AVAILABLE) &&
                    ((JobType == JT_SEND && (LineInfo->Flags & FPF_SEND)) ||
                     (JobType == JT_RECEIVE && (LineInfo->Flags & FPF_RECEIVE))))
                {
                    LineInfo->State = 0;
                    SelectedLine = LineInfo;
                    break;
                }
            }
        }
    }

    LeaveCriticalSection( &CsLine );

    if (SelectedLine) {
        DebugPrint((
            TEXT("Line selected for FAX operation: %d, %d"),
            SelectedLine->DeviceId,
            SelectedLine->PermanentLineID
            ));
    } else if (JobType == JT_SEND) {
        DWORD SendDevices;

        GetDeviceTypeCount(&SendDevices,NULL);

        if (SendDevices == 0  && NoDevicePopupCount < 2 ) {
            //
            // no devices configured to send faxes
            //
            ServiceMessageBox(GetString(IDS_NO_SEND_DEVICES),MB_OK|MB_ICONEXCLAMATION, TRUE,NULL);
            NoDevicePopupCount++;
        }
    }

    return SelectedLine;
}


BOOL
ReleaseTapiLine(
    PLINE_INFO LineInfo,
    HCALL hCall
    )

/*++

Routine Description:

    Releases the specified TAPI line back into
    the list as an available device.

Arguments:

    LineInfo    - Pointer to the TAPI line to be released

Return Value:

    TRUE    - The line is release.
    FALSE   - The line is not released.

--*/

{
    LONG rVal;
    HLINE hLine;


    if (!LineInfo) {
        return FALSE;
    }

    EnterCriticalSection( &CsLine );

    LineInfo->State = FPS_AVAILABLE;
    LineInfo->RingCount = 0;

    ZeroMemory( &LineInfo->LineMsgOffering, sizeof(LINEMESSAGE) );

    if ((!(LineInfo->Flags & FPF_RECEIVE)) && LineInfo->hLine) {
        hLine = LineInfo->hLine;
        LineInfo->hLine = 0;
        lineClose( hLine );
        DebugPrint(( TEXT("ReleaseTapiLine(): lineClose on hLine=%08x "), hLine ));
    }

    if (hCall) {
        rVal = lineDeallocateCall( hCall );
        if (rVal != 0) {
            DebugPrint(( TEXT("ReleaseTapiLine(): lineDeallocateCall() failed, ec=0x%08x, hCall=%08x"),
                rVal, hCall ));
        } else {
            if (LineInfo->JobEntry && LineInfo->JobEntry->CallHandle == hCall) {
                LineInfo->JobEntry->CallHandle = 0;
            }
        }
    } else {
        DebugPrint(( TEXT("ReleaseTapiLine(): cannot deallocate call, NULL call handle") ));
    }

    LeaveCriticalSection( &CsLine );

    return TRUE;
}


LPLINEDEVCAPS
MyLineGetDevCaps(
    DWORD DeviceId
    )
{
    DWORD LineDevCapsSize;
    LPLINEDEVCAPS LineDevCaps = NULL;
    LONG Rslt = ERROR_SUCCESS;

    //
    // allocate the initial linedevcaps structure
    //

    LineDevCapsSize = sizeof(LINEDEVCAPS) + 4096;
    LineDevCaps = (LPLINEDEVCAPS) MemAlloc( LineDevCapsSize );
    if (!LineDevCaps) {
        return NULL;
    }

    LineDevCaps->dwTotalSize = LineDevCapsSize;

    Rslt = lineGetDevCaps(
        hLineApp,
        DeviceId,
        TapiApiVersion,
        0,
        LineDevCaps
        );

    if (Rslt != 0) {
        //
        // lineGetDevCaps() can fail with error code 0x8000004b
        // if a device has been deleted and tapi has not been
        // cycled.  this is caused by the fact that tapi leaves
        // a phantom device in it's device list.  the error is
        // benign and the device can safely be ignored.
        //
        if (Rslt != LINEERR_INCOMPATIBLEAPIVERSION) {
            DebugPrint(( TEXT("lineGetDevCaps() failed, ec=0x%08x"), Rslt ));
        }
        goto exit;
    }

    if (LineDevCaps->dwNeededSize > LineDevCaps->dwTotalSize) {

        //
        // re-allocate the linedevcaps structure
        //

        LineDevCapsSize = LineDevCaps->dwNeededSize;

        MemFree( LineDevCaps );

        LineDevCaps = (LPLINEDEVCAPS) MemAlloc( LineDevCapsSize );
        if (!LineDevCaps) {
            Rslt = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        Rslt = lineGetDevCaps(
            hLineApp,
            DeviceId,
            TapiApiVersion,
            0,
            LineDevCaps
            );

        if (Rslt != 0) {
            DebugPrint(( TEXT("lineGetDevCaps() failed, ec=0x%08x"), Rslt ));
            goto exit;
        }

    }

exit:
    if (Rslt != ERROR_SUCCESS) {
        MemFree( LineDevCaps );
        LineDevCaps = NULL;
    }

    return LineDevCaps;
}


LPLINEDEVSTATUS
MyLineGetLineDevStatus(
    HLINE hLine
    )
{
    DWORD LineDevStatusSize;
    LPLINEDEVSTATUS LineDevStatus = NULL;
    LONG Rslt = ERROR_SUCCESS;


    //
    // allocate the initial linedevstatus structure
    //

    LineDevStatusSize = sizeof(LINEDEVSTATUS) + 4096;
    LineDevStatus = (LPLINEDEVSTATUS) MemAlloc( LineDevStatusSize );
    if (!LineDevStatus) {
        return NULL;
    }

    LineDevStatus->dwTotalSize = LineDevStatusSize;

    Rslt = lineGetLineDevStatus(
        hLine,
        LineDevStatus
        );

    if (Rslt != 0) {
        DebugPrint(( TEXT("lineGetLineDevStatus() failed, ec=0x%08x"), Rslt ));
        goto exit;
    }

    if (LineDevStatus->dwNeededSize > LineDevStatus->dwTotalSize) {

        //
        // re-allocate the LineDevStatus structure
        //

        LineDevStatusSize = LineDevStatus->dwNeededSize;

        MemFree( LineDevStatus );

        LineDevStatus = (LPLINEDEVSTATUS) MemAlloc( LineDevStatusSize );
        if (!LineDevStatus) {
            Rslt = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        Rslt = lineGetLineDevStatus(
            hLine,
            LineDevStatus
            );

        if (Rslt != 0) {
            DebugPrint(( TEXT("lineGetLineDevStatus() failed, ec=0x%08x"), Rslt ));
            goto exit;
        }

    }

exit:
    if (Rslt != ERROR_SUCCESS) {
        MemFree( LineDevStatus );
        LineDevStatus = NULL;
    }

    return LineDevStatus;
}


LONG
MyLineGetTransCaps(
    LPLINETRANSLATECAPS *LineTransCaps
    )
{
    DWORD LineTransCapsSize;
    LONG Rslt = ERROR_SUCCESS;


    //
    // allocate the initial linetranscaps structure
    //

    LineTransCapsSize = sizeof(LINETRANSLATECAPS) + 4096;
    *LineTransCaps = (LPLINETRANSLATECAPS) MemAlloc( LineTransCapsSize );
    if (!*LineTransCaps) {
        DebugPrint(( TEXT("MemAlloc() failed, sz=0x%08x"), LineTransCapsSize ));
        Rslt = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    (*LineTransCaps)->dwTotalSize = LineTransCapsSize;

    Rslt = lineGetTranslateCaps(
        hLineApp,
        TapiApiVersion,
        *LineTransCaps
        );

    if (Rslt != 0) {
        DebugPrint(( TEXT("lineGetTranslateCaps() failed, ec=0x%08x"), Rslt ));
        goto exit;
    }

    if ((*LineTransCaps)->dwNeededSize > (*LineTransCaps)->dwTotalSize) {

        //
        // re-allocate the LineTransCaps structure
        //

        LineTransCapsSize = (*LineTransCaps)->dwNeededSize;

        MemFree( *LineTransCaps );

        *LineTransCaps = (LPLINETRANSLATECAPS) MemAlloc( LineTransCapsSize );
        if (!*LineTransCaps) {
            DebugPrint(( TEXT("MemAlloc() failed, sz=0x%08x"), LineTransCapsSize ));
            Rslt = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        (*LineTransCaps)->dwTotalSize = LineTransCapsSize;

        Rslt = lineGetTranslateCaps(
            hLineApp,
            TapiApiVersion,
            *LineTransCaps
            );

        if (Rslt != 0) {
            DebugPrint(( TEXT("lineGetTranslateCaps() failed, ec=0x%08x"), Rslt ));
            goto exit;
        }

    }

exit:
    if (Rslt != ERROR_SUCCESS) {
        MemFree( *LineTransCaps );
        *LineTransCaps = NULL;
    }

    return Rslt;
}


LONG
MyLineTranslateAddress(
    LPTSTR Address,
    DWORD DeviceId,
    LPLINETRANSLATEOUTPUT *TranslateOutput
    )
{
    DWORD LineTransOutSize;
    LONG Rslt = ERROR_SUCCESS;


    //
    // allocate the initial linetranscaps structure
    //

    LineTransOutSize = sizeof(LINETRANSLATEOUTPUT) + 4096;
    *TranslateOutput = (LPLINETRANSLATEOUTPUT) MemAlloc( LineTransOutSize );
    if (!*TranslateOutput) {
        DebugPrint(( TEXT("MemAlloc() failed, sz=0x%08x"), LineTransOutSize ));
        Rslt = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    (*TranslateOutput)->dwTotalSize = LineTransOutSize;

    Rslt = lineTranslateAddress(
        hLineApp,
        DeviceId,
        TapiApiVersion,
        Address,
        0,
        0,
        *TranslateOutput
        );

    if (Rslt != 0) {
        DebugPrint(( TEXT("lineGetTranslateAddress() failed, ec=0x%08x"), Rslt ));
        goto exit;
    }

    if ((*TranslateOutput)->dwNeededSize > (*TranslateOutput)->dwTotalSize) {

        //
        // re-allocate the LineTransCaps structure
        //

        LineTransOutSize = (*TranslateOutput)->dwNeededSize;

        MemFree( *TranslateOutput );

        *TranslateOutput = (LPLINETRANSLATEOUTPUT) MemAlloc( LineTransOutSize );
        if (!*TranslateOutput) {
            DebugPrint(( TEXT("MemAlloc() failed, sz=0x%08x"), LineTransOutSize ));
            Rslt = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        (*TranslateOutput)->dwTotalSize = LineTransOutSize;

        Rslt = lineTranslateAddress(
            hLineApp,
            DeviceId,
            TapiApiVersion,
            Address,
            0,
            0,
            *TranslateOutput
            );

        if (Rslt != 0) {
            DebugPrint(( TEXT("lineGetTranslateAddress() failed, ec=0x%08x"), Rslt ));
            goto exit;
        }

    }

exit:
    if (Rslt != ERROR_SUCCESS) {
        MemFree( *TranslateOutput );
        *TranslateOutput = NULL;
    }

    return Rslt;
}


BOOL
OpenTapiLine(
    PLINE_INFO LineInfo
    )
{
    LONG Rslt = ERROR_SUCCESS;
    HLINE hLine;
    DWORD LineStates = 0;
    DWORD AddressStates = 0;


    EnterCriticalSection( &CsLine );

    if (LineInfo->UnimodemDevice) {
        Rslt = lineOpen(
            hLineApp,
            LineInfo->DeviceId,
            &hLine,
            TapiApiVersion,
            0,
            (DWORD_PTR) LineInfo,
            LINECALLPRIVILEGE_OWNER + LINECALLPRIVILEGE_MONITOR,
            LINEMEDIAMODE_DATAMODEM | LINEMEDIAMODE_UNKNOWN,
            NULL
            );

        if (Rslt != 0) {
            Rslt = lineOpen(
                hLineApp,
                LineInfo->DeviceId,
                &hLine,
                TapiApiVersion,
                0,
                (DWORD_PTR) LineInfo,
                LINECALLPRIVILEGE_OWNER + LINECALLPRIVILEGE_MONITOR,
                LINEMEDIAMODE_DATAMODEM,
                NULL
                );
        }
    } else {
        Rslt = lineOpen(
            hLineApp,
            LineInfo->DeviceId,
            &hLine,
            TapiApiVersion,
            0,
            (DWORD_PTR) LineInfo,
            LINECALLPRIVILEGE_OWNER + LINECALLPRIVILEGE_MONITOR,
            LINEMEDIAMODE_G3FAX,
            NULL
            );
    }

    if (Rslt != 0) {
        DebugPrint(( TEXT("Device %s FAILED to initialize, ec=%08x"), LineInfo->DeviceName, Rslt ));
    } else {
        LineInfo->hLine = hLine;

        //
        // set the line status that we need
        //

        LineStates |= LineInfo->LineStates & LINEDEVSTATE_OPEN     ? LINEDEVSTATE_OPEN     : 0;
        LineStates |= LineInfo->LineStates & LINEDEVSTATE_CLOSE    ? LINEDEVSTATE_CLOSE    : 0;
        LineStates |= LineInfo->LineStates & LINEDEVSTATE_RINGING  ? LINEDEVSTATE_RINGING  : 0;
        LineStates |= LineInfo->LineStates & LINEDEVSTATE_NUMCALLS ? LINEDEVSTATE_NUMCALLS : 0;
        LineStates |= LineInfo->LineStates & LINEDEVSTATE_REMOVED  ? LINEDEVSTATE_REMOVED  : 0;

        AddressStates = LINEADDRESSSTATE_INUSEZERO | LINEADDRESSSTATE_INUSEONE |
                        LINEADDRESSSTATE_INUSEMANY | LINEADDRESSSTATE_NUMCALLS;

        Rslt = lineSetStatusMessages( hLine, LineStates, AddressStates );
        if (Rslt != 0) {
            DebugPrint(( TEXT("lineSetStatusMessages() failed, [0x%08x:0x%08x], ec=0x%08x"), LineStates, AddressStates, Rslt ));
            Rslt = ERROR_SUCCESS;
        }

    }

    LeaveCriticalSection( &CsLine );

    return Rslt == ERROR_SUCCESS;
}


BOOL
IsDeviceModem(
    LPLINEDEVCAPS LineDevCaps
    )
{
    LPTSTR DeviceClassList;
    BOOL UnimodemDevice = FALSE;

    if (LineDevCaps->dwDeviceClassesSize && LineDevCaps->dwDeviceClassesOffset) {
        DeviceClassList = (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwDeviceClassesOffset);
        while (*DeviceClassList) {
            if (_tcscmp(DeviceClassList,TEXT("comm/datamodem")) == 0) {
                UnimodemDevice = TRUE;
                break;
            }
            DeviceClassList += (_tcslen(DeviceClassList) + 1);
        }
    }

    if ((!(LineDevCaps->dwBearerModes & LINEBEARERMODE_VOICE)) ||
        (!(LineDevCaps->dwBearerModes & LINEBEARERMODE_PASSTHROUGH))) {
            //
            // unacceptable modem device type
            //
            UnimodemDevice = FALSE;
    }

    //
    // modem fsp only works with unimodem TSP
    //
    if (wcscmp((LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwProviderInfoOffset),
        GetString(IDS_MODEM_PROVIDER_NAME)) != 0) {
        UnimodemDevice = FALSE;
    }

    return UnimodemDevice;
}


BOOL CALLBACK
NewDeviceRoutingMethodEnumerator(
    PROUTING_METHOD RoutingMethod,
    DWORD DeviceId
    )
{
    BOOL Rslt = FALSE;

    __try {
        Rslt = RoutingMethod->RoutingExtension->FaxRouteDeviceChangeNotification( DeviceId, TRUE );
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        DebugPrint(( TEXT("FaxRouteDeviceChangeNotification() crashed: 0x%08x"), GetExceptionCode() ));
    }

    return Rslt;
}

BOOL
CloseDevicesMatch(
    LPWSTR DeviceName,
    LPWSTR CacheName
    )
{
    //
    // deal with the fact that the device name might have changed slightly (add #1 to end, etc.)
    //  assumption: devices are for same TSP
    //
    DWORD len;
    BOOL rVal = FALSE;
    LPTSTR NewCacheName;
    LPTSTR NewDeviceName;

    if (!DeviceName || !CacheName) {
        return FALSE;
    }

    //
    // check if one is a shorted version of the other name
    //
    len = min( wcslen(CacheName), wcslen(DeviceName) );


    if (_wcsnicmp( CacheName, DeviceName, len ) == 0 ) {
        return TRUE;
    }

    //
    // check if we have different numbered devices that are similar
    //
    NewDeviceName = wcsrchr(DeviceName,L'#');
    if (NewDeviceName) *NewDeviceName = (WCHAR)0;

    NewCacheName = wcsrchr(CacheName,L'#');
    if (NewCacheName) *NewCacheName = (WCHAR)0;

    len = min( wcslen(CacheName), wcslen(DeviceName) );
    if (_wcsnicmp( CacheName, DeviceName, len ) == 0) {
        rVal = TRUE;
    }

    //
    // put back the device name to normal
    //
    if (NewDeviceName) *NewDeviceName = (WCHAR) L'#';
    if (NewCacheName) *NewCacheName = (WCHAR) L'#';

    return rVal;
}

BOOL
AddNewDevice(
    DWORD DeviceId,
    LPLINEDEVCAPS LineDevCaps,
    BOOL InitDevice
    )
{
    BOOL rVal = FALSE;
    BOOL UnimodemDevice = FALSE;
    PMDM_DEVSPEC MdmDevSpec = NULL;
    LPSTR ModemKey = NULL;
    DWORD Flags;
    DWORD Priority = 1;
    LPTSTR DeviceName = NULL;
    REG_SETUP RegSetup;
    PREG_FAX_DEVICES_CACHE RegDevicesCache;
    DWORD i;
    DWORD CloseMatchIndex = -1, UseIndex = -1;


    if (IsSmallBiz() && DeviceCount >= 4) {
        return FALSE;
    } else  if (!IsCommServer() && DeviceCount >= 2) {
        return FALSE;
    }

    //
    // only add devices that support fax
    //

    if (! ( ((LineDevCaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM) &&
             (UnimodemDevice = IsDeviceModem( LineDevCaps ) )) ||
            (LineDevCaps->dwMediaModes & LINEMEDIAMODE_G3FAX) )) {
        return FALSE;
    }

    //
    // we have a fax capable device to be added, so let's retreive configuration
    // data about fax devices on the system to decide how to configure this 
    // device
    //
    if (!GetOrigSetupData( &RegSetup ) || !(RegDevicesCache = GetFaxDevicesCacheRegistry()) ) {
        return FALSE;
    }    

    if (UnimodemDevice) {
        Flags = FPF_SEND;
        if (ForceReceive) {
            Flags |= FPF_RECEIVE;
        }
    } else {
        Flags = FPF_RECEIVE | FPF_SEND;
    }

    if (Flags & FPF_RECEIVE) {
        InterlockedIncrement( &ConnectionCount );
    }

    DeviceName = FixupDeviceName( (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwLineNameOffset) );

    //
    // check in the device cache for an old instantiation of this device
    //
    for (i=0; i<RegDevicesCache->DeviceCount ; i++ ) {
        if (RegDevicesCache->Devices[i].Provider &&
            RegDevicesCache->Devices[i].Name     &&
            (wcscmp((LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwProviderInfoOffset),
                    RegDevicesCache->Devices[i].Provider) == 0)) {

            if (wcscmp(DeviceName,RegDevicesCache->Devices[i].Name) == 0) {
                //
                // exact match, use it
                //
                UseIndex = i;
                break;
            } else if (CloseDevicesMatch(DeviceName,RegDevicesCache->Devices[i].Name)) {
                CloseMatchIndex = i;
            }
        }
    }

    if (UseIndex == (DWORD) -1) {
        UseIndex = CloseMatchIndex;
    } else {
        CloseMatchIndex = -1;
    }

    if (UseIndex != (DWORD) -1) {
        Priority = RegAddNewFaxDevice(
            DeviceName,
            RegDevicesCache->Devices[UseIndex].Provider,
            RegDevicesCache->Devices[UseIndex].Csid,
            RegDevicesCache->Devices[UseIndex].Tsid,
            -1, // BugBug what priority ???
            LineDevCaps->dwPermanentLineID,
            Flags,
            RegDevicesCache->Devices[UseIndex].Rings,
            RegDevicesCache->Devices[UseIndex].RoutingMask,
            RegDevicesCache->Devices[UseIndex].Printer,
            RegDevicesCache->Devices[UseIndex].StoreDir,
            RegDevicesCache->Devices[UseIndex].Profile
            );

        //
        // get rid of the cached entry
        //
        if (CloseMatchIndex == -1) {
            DeleteCachedFaxDevice( RegDevicesCache->Devices[UseIndex].Name );
        }

    } else {
        Priority = RegAddNewFaxDevice(
            DeviceName,
            (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwProviderInfoOffset),
            RegSetup.Csid,
            RegSetup.Tsid,
            -1,
            LineDevCaps->dwPermanentLineID,
            Flags,
            RegSetup.Rings,
            RegSetup.Mask,
            RegSetup.Printer,
            RegSetup.StoreDir,
            RegSetup.Profile
            );
    }


    if (InitDevice) {
        DeviceCount += 1;
        InitializeTapiLine(
            DeviceId,
            LineDevCaps,
            Priority,
            RegSetup.Rings,
            Flags,
            RegSetup.Csid,
            RegSetup.Tsid
            );
    }

    rVal = TRUE;

    if (DeviceName) {
        MemFree( DeviceName );
    }

    FreeFaxDevicesCacheRegistry( RegDevicesCache );

    FreeOrigSetupData( &RegSetup );

    EnumerateRoutingMethods( (PFAXROUTEMETHODENUM)NewDeviceRoutingMethodEnumerator, (LPVOID)LineDevCaps->dwPermanentLineID );

    return rVal;
}


DWORD
InitializeTapiLine(
    DWORD DeviceId,
    LPLINEDEVCAPS LineDevCaps,
    DWORD Priority,
    DWORD Rings,
    DWORD Flags,
    LPTSTR Csid,
    LPTSTR Tsid
    )
{
    PLINE_INFO LineInfo = NULL;
    LONG Rslt = ERROR_SUCCESS;
    DWORD len;
    PDEVICE_PROVIDER Provider;
    BOOL UnimodemDevice;
    HLINE hLine = 0;
    LPTSTR ProviderName = NULL;
    LPTSTR DeviceName = NULL;
    BOOL NewDevice = TRUE;
    DWORD LineStates = 0;
    DWORD AddressStates = 0;
    LPLINEDEVSTATUS LineDevStatus;


    //
    // allocate the LINE_INFO structure
    //

    LineInfo = (PLINE_INFO) MemAlloc( sizeof(LINE_INFO) );
    if (!LineInfo) {
        Rslt = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // get the provider name
    //

    len = _tcslen( (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwProviderInfoOffset) );
    ProviderName = MemAlloc( (len + 1) * sizeof(TCHAR) );
    if (!ProviderName) {
        Rslt = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }
    _tcscpy( ProviderName, (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwProviderInfoOffset) );

    //
    // get the device name
    //

    DeviceName = FixupDeviceName( (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwLineNameOffset) );
    if (!DeviceName) {
        Rslt = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // verify that the line id is good
    //

    if (LineDevCaps->dwPermanentLineID == 0) {
        DebugPrint((
            TEXT("TAPI lines must have a non-zero line id [%s]"),
            DeviceName
            ));
        Rslt = ERROR_BAD_DEVICE;
        goto exit;
    }

    //
    // check for a modem device
    //

    UnimodemDevice = IsDeviceModem( LineDevCaps );

    //
    // assign the device provider
    //

    Provider = FindDeviceProvider( ProviderName );
    if (!Provider) {
        DebugPrint(( TEXT("Could not find a valid device provider for device: %s"), DeviceName ));
        Rslt = ERROR_BAD_PROVIDER;
        goto exit;
    }

    //
    // open the line
    //

    if (UnimodemDevice) {
        Rslt = lineOpen(
            hLineApp,
            DeviceId,
            &hLine,
            TapiApiVersion,
            0,
            (DWORD_PTR) LineInfo,
            LINECALLPRIVILEGE_OWNER + LINECALLPRIVILEGE_MONITOR,
            LINEMEDIAMODE_DATAMODEM | LINEMEDIAMODE_UNKNOWN,
            NULL
            );

        if (Rslt != 0) {
            Rslt = lineOpen(
                hLineApp,
                DeviceId,
                &hLine,
                TapiApiVersion,
                0,
                (DWORD_PTR) LineInfo,
                LINECALLPRIVILEGE_OWNER + LINECALLPRIVILEGE_MONITOR,
                LINEMEDIAMODE_DATAMODEM,
                NULL
                );
        }
    } else {
        Rslt = lineOpen(
            hLineApp,
            DeviceId,
            &hLine,
            TapiApiVersion,
            0,
            (DWORD_PTR) LineInfo,
            LINECALLPRIVILEGE_OWNER + LINECALLPRIVILEGE_MONITOR,
            LINEMEDIAMODE_G3FAX,
            NULL
            );
    }

    if (Rslt != 0) {
        DebugPrint(( TEXT("Device %s FAILED to initialize, ec=%08x"), DeviceName, Rslt ));
        goto exit;
    }

    //
    // set the line status that we need
    //

    LineStates |= LineDevCaps->dwLineStates & LINEDEVSTATE_OPEN     ? LINEDEVSTATE_OPEN     : 0;
    LineStates |= LineDevCaps->dwLineStates & LINEDEVSTATE_CLOSE    ? LINEDEVSTATE_CLOSE    : 0;
    LineStates |= LineDevCaps->dwLineStates & LINEDEVSTATE_RINGING  ? LINEDEVSTATE_RINGING  : 0;
    LineStates |= LineDevCaps->dwLineStates & LINEDEVSTATE_NUMCALLS ? LINEDEVSTATE_NUMCALLS : 0;
    LineStates |= LineDevCaps->dwLineStates & LINEDEVSTATE_REMOVED  ? LINEDEVSTATE_REMOVED  : 0;

    AddressStates = LINEADDRESSSTATE_INUSEZERO | LINEADDRESSSTATE_INUSEONE |
                    LINEADDRESSSTATE_INUSEMANY | LINEADDRESSSTATE_NUMCALLS;

    Rslt = lineSetStatusMessages( hLine, LineStates, AddressStates );
    if (Rslt != 0) {
        DebugPrint(( TEXT("lineSetStatusMessages() failed, [0x%08x:0x%08x], ec=0x%08x"), LineStates, AddressStates, Rslt ));
        if (Rslt == LINEERR_INVALLINEHANDLE) {
            hLine = 0;
        }
        Rslt = 0;
    }

    //
    // now assign the necessary values to the line info struct
    //

    LineInfo->Signature             = LINE_SIGNATURE;
    LineInfo->DeviceId              = DeviceId;
    LineInfo->PermanentLineID       = LineDevCaps->dwPermanentLineID;
    LineInfo->hLine                 = hLine;
    LineInfo->Provider              = Provider;
    LineInfo->DeviceName            = StringDup( DeviceName );
    LineInfo->UnimodemDevice        = UnimodemDevice;
    LineInfo->State                 = FPS_AVAILABLE;
    LineInfo->Csid                  = StringDup( Csid );
    LineInfo->Tsid                  = StringDup( Tsid );
    LineInfo->Priority              = Priority;
    LineInfo->RingsForAnswer        = (LineDevCaps->dwLineStates & LINEDEVSTATE_RINGING) ? Rings : 0;
    LineInfo->Flags                 = Flags;
    LineInfo->RingCount             = 0;
    LineInfo->ModemPopUps           = 0;
    LineInfo->ModemPopupActive      = 1;
    LineInfo->LineStates            = LineDevCaps->dwLineStates;

    if (LineInfo->Flags & FPF_RECEIVE) {
        InterlockedIncrement( &ConnectionCount );
    }

    if (hLine) {
        //
        // check to see if the line is in use
        //

        LineDevStatus = MyLineGetLineDevStatus( hLine );
        if (LineDevStatus) {
            if (LineDevStatus->dwNumOpens > 0 && LineDevStatus->dwNumActiveCalls > 0) {
                LineInfo->ModemInUse = TRUE;
            }
            MemFree( LineDevStatus );
        }
    } else {
        //
        // if we don't have a line handle at this time then the
        // device must be powered off
        //
        DebugPrint(( TEXT("Device %s is powered off or disconnected"), DeviceName ));

        if (LineInfo->Flags & FPF_RECEIVE) {
            LineInfo->Flags &= ~FPF_RECEIVE;
            LineInfo->Flags |= FPF_RECEIVE_OK;
        }
        LineInfo->Flags |= FPF_POWERED_OFF;

        LineInfo->State = FPS_OFFLINE;
    }

exit:

    MemFree( DeviceName );
    MemFree( ProviderName );

    if (Rslt == ERROR_SUCCESS) {
        InsertTailList( &TapiLinesListHead, &LineInfo->ListEntry );
    } else {
        FreeTapiLine( LineInfo );
    }

    return Rslt;
}

BOOL MoveToDeviceCache(
    PREG_DEVICE FaxDevice
    )
{
    PREG_ROUTING_INFO pRouting = RegGetRoutingInfo( FaxDevice->PermanentLineID );

    if (!pRouting) {
        return FALSE;
    }

    if (!RegAddNewFaxDeviceCache(
                                 FaxDevice->Name,
                                 FaxDevice->Provider,
                                 FaxDevice->Csid,
                                 FaxDevice->Tsid,
                                 FaxDevice->PermanentLineID,
                                 FaxDevice->Flags,
                                 FaxDevice->Rings,
                                 pRouting->RoutingMask,
                                 pRouting->Printer,
                                 pRouting->StoreDir,
                                 pRouting->Profile
                                 ) ) {
        DebugPrint(( TEXT("Couldn't RegAddNewFaxDeviceCache(%s), ec = %d\n"),
                   FaxDevice->Name,
                   GetLastError() ));
        return FALSE;
    }

    FreeRegRoutingInfo( pRouting );

    return DeleteFaxDevice( FaxDevice->PermanentLineID );

}

BOOL
IsVirtualDevice(
    PLINE_INFO LineInfo
    )
{
    if (!LineInfo) {
        return FALSE;
    }

    return (LineInfo->Provider->FaxDevVirtualDeviceCreation) ? TRUE : FALSE;

}


VOID
UpdateVirtualDevices(
    VOID
    )
{
    PLIST_ENTRY         Next;
    PLINE_INFO          LineInfo = NULL;

    EnterCriticalSection( &CsLine );

    Next = TapiLinesListHead.Flink;
    if (Next == NULL) {
        LeaveCriticalSection( &CsLine );
        return;
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&TapiLinesListHead) {
        LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        Next = LineInfo->ListEntry.Flink;
        if (IsVirtualDevice(LineInfo) && LineInfo->Provider->FaxDevCallback) {
            __try {
                LineInfo->Provider->FaxDevCallback( NULL,
                                                    LineInfo->PermanentLineID,
                                                    LINE_DEVSPECIFIC,
                                                    0,
                                                    (LineInfo->Flags & FPF_RECEIVE),
                                                    (LineInfo->Flags & FPF_SEND),
                                                    0
                                                  );
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                  DebugPrint(( TEXT("Exception in FaxDevCallback, ec = %d\n"),GetExceptionCode() ));
            }
        }

    }

    LeaveCriticalSection( &CsLine );

}


DWORD
CreateVirtualDevices(
    PREG_FAX_SERVICE FaxReg
    )
{
    extern LIST_ENTRY DeviceProviders;
    PLIST_ENTRY         Next;
    PDEVICE_PROVIDER    Provider;
    DWORD               VirtualDeviceCount;
    WCHAR               DevicePrefix[128];
    DWORD               DeviceIdPrefix;
    LPWSTR              DeviceName;
    DWORD               i,j;
    PLINE_INFO          LineInfo = NULL;
    PREG_DEVICE         FaxDevice = NULL;
    PREG_FAX_DEVICES    FaxDevices = NULL;
    BOOL                NewDevice;
    DWORD               DeviceCount = 0;
    REG_SETUP           RegSetup;


    Next = DeviceProviders.Flink;
    if (!Next) {
        return DeviceCount;
    }

    if (!GetOrigSetupData( &RegSetup )) {
        return DeviceCount;
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&DeviceProviders) {
        Provider = CONTAINING_RECORD( Next, DEVICE_PROVIDER, ListEntry );
        Next = Provider->ListEntry.Flink;
        if (Provider->FaxDevVirtualDeviceCreation) {
            __try {

                VirtualDeviceCount = 0;
                ZeroMemory(DevicePrefix, sizeof(DevicePrefix));
                DeviceIdPrefix = 0;

                if (Provider->FaxDevVirtualDeviceCreation(
                        &VirtualDeviceCount,
                        DevicePrefix,
                        &DeviceIdPrefix,
                        TapiCompletionPort,
                        FAXDEV_EVENT_KEY
                        ))
                {
                    for (i=0; i<VirtualDeviceCount; i++) {

                        //
                        // create the device name
                        //

                        DeviceName = (LPWSTR) MemAlloc( StringSize(DevicePrefix) + 16 );
                        if (!DeviceName) {
                            goto InitializationFailure;
                        }

                        swprintf( DeviceName, L"%s%d", DevicePrefix, i );

                        //
                        // find the registry information for this device
                        //

                        for (j=0,FaxDevice=NULL; j<FaxReg->DeviceCount; j++) {
                            if (FaxReg->Devices[j].PermanentLineID == DeviceIdPrefix+i) {
                                FaxDevice = &FaxReg->Devices[j];
                                break;
                            }
                        }

                        //
                        // if the device is new then add it to the registry
                        //

                        if (!FaxDevice) {
                            RegAddNewFaxDevice(
                                DeviceName,
                                Provider->ProviderName,
                                RegSetup.Csid,
                                RegSetup.Tsid,
                                1,  // priority
                                DeviceIdPrefix + i,
                                FPF_SEND | FPF_VIRTUAL,
                                RegSetup.Rings,
                                RegSetup.Mask,
                                RegSetup.Printer,
                                RegSetup.StoreDir,
                                RegSetup.Profile
                                );
                            NewDevice = TRUE;
                        } else {
                            NewDevice = FALSE;
                        }

                        //
                        // allocate the LINE_INFO structure
                        //

                        LineInfo = (PLINE_INFO) MemAlloc( sizeof(LINE_INFO) );
                        if (!LineInfo) {
                            goto InitializationFailure;
                        }

                        //
                        // now assign the necessary values to the line info struct
                        //

                        LineInfo->Signature             = LINE_SIGNATURE;
                        LineInfo->DeviceId              = i;
                        LineInfo->PermanentLineID       = DeviceIdPrefix + i;
                        LineInfo->hLine                 = 0;
                        LineInfo->Provider              = Provider;
                        LineInfo->DeviceName            = DeviceName;
                        LineInfo->UnimodemDevice        = FALSE;
                        LineInfo->State                 = FPS_AVAILABLE;
                        LineInfo->Csid                  = StringDup( FaxDevice ? FaxDevice->Csid : RegSetup.Csid );
                        LineInfo->Tsid                  = StringDup( FaxDevice ? FaxDevice->Tsid : RegSetup.Tsid );
                        LineInfo->Priority              = FaxDevice ? FaxDevice->Priority : 1;
                        LineInfo->RingsForAnswer        = 0;
                        LineInfo->Flags                 = FaxDevice ? FaxDevice->Flags : FPF_SEND | FPF_VIRTUAL;
                        LineInfo->RingCount             = 0;
                        LineInfo->ModemPopUps           = 0;
                        LineInfo->ModemPopupActive      = 1;
                        LineInfo->LineStates            = 0;

                        InsertTailList( &TapiLinesListHead, &LineInfo->ListEntry );

                        if (LineInfo->Flags & FPF_RECEIVE) {
                            InterlockedIncrement( &ConnectionCount );
                        }

                        DeviceCount += 1;

                        if (NewDevice) {
                            FreeFaxDevicesRegistry( FaxDevices );
                        }
                    }
                }
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                DebugPrint(( TEXT("FaxDevVirtualDeviceCreation() crashed: 0x%08x"), GetExceptionCode() ));
                goto InitializationFailure;
            }
        }

        goto next;
InitializationFailure:
        FaxLog(
                FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_NONE,
                1,
                MSG_VIRTUAL_DEVICE_INIT_FAILED,
                Provider->FriendlyName
              );

next:
    ;
    }

    DebugPrint(( TEXT("Virtual devices initialized, devices=%d"), DeviceCount ));

    FreeOrigSetupData( &RegSetup );

    return DeviceCount;
}


DWORD
TapiInitialize(
    PREG_FAX_SERVICE FaxReg
    )

/*++

Routine Description:

    This function performs all necessary TAPI initialization.
    This includes device enumeration, message pump creation,
    device capabilities caputure, etc.  It is required that
    the device provider initialization is completed before
    calling this function.

Arguments:

    None.

Return Value:

    Error code.

--*/

{
    extern CRITICAL_SECTION CsRouting;
    LONG Rslt;
    DWORD i,j;
    HANDLE hThread;
    DWORD ThreadId;
    PLIST_ENTRY Next;
    PLINE_INFO LineInfo;
    LPLINEDEVCAPS LineDevCaps = NULL;
    PREG_FAX_DEVICES FaxDevices = NULL;
    HLINE hLine;
    LINEINITIALIZEEXPARAMS LineInitializeExParams;
    TCHAR FaxSvcName[MAX_PATH*2];
    TCHAR Fname[_MAX_FNAME];
    TCHAR Ext[_MAX_EXT];
    DWORD LocalTapiApiVersion;
    LINEEXTENSIONID lineExtensionID;
    LPTSTR AdaptiveFileName;
    HANDLE AdaptiveFileHandle;
    BOOL Found = FALSE;
    DWORD DeviceLimit;


    InitializeListHead( &TapiLinesListHead );
    InitializeCriticalSection( &CsLine );
    InitializeCriticalSection( &CsRouting );

    //
    // we need to hold onto this cs until tapi is up and ready to serve
    //
    EnterCriticalSection( &CsLine );


    //
    // set the device limit
    //
    if (IsSmallBiz()) {
        DeviceLimit = 4;
    } else if (IsCommServer()) {
        DeviceLimit = 0xFFFFFFFF;
    } else {
        DeviceLimit = 2;
    }

    //
    // open faxadapt.lst file to decide on enabling rx
    //

    AdaptiveFileName = ExpandEnvironmentString( TEXT("%systemroot%\\system32\\faxadapt.lst") );
    if (AdaptiveFileName) {
        AdaptiveFileHandle = CreateFile(
            AdaptiveFileName,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            0,
            NULL
            );
        if (AdaptiveFileHandle == INVALID_HANDLE_VALUE ) {
            DebugPrint(( TEXT("Could not open adaptive file [%s], ec=0x%08x"), _tcslwr(AdaptiveFileName), GetLastError() ));
        } else {
            i = GetFileSize( AdaptiveFileHandle, NULL );
            if (i != 0xffffffff) {
                AdaptiveFileBuffer = MemAlloc( i + 16 );
                if (AdaptiveFileBuffer) {
                    if (!ReadFile( AdaptiveFileHandle, AdaptiveFileBuffer, i, &j, NULL ) ) {
                        DebugPrint(( TEXT("Could not read adaptive file [%s], ec=0x%08x"), _tcslwr(AdaptiveFileName), GetLastError() ));
                        MemFree( AdaptiveFileBuffer );
                        AdaptiveFileBuffer = NULL;
                    } else {
                        AdaptiveFileBuffer[j] = 0;  // need a string
                    }
                }
            }
            CloseHandle( AdaptiveFileHandle );
        }
    }

    //
    // initialize tapi
    //

    TapiCompletionPort = CreateIoCompletionPort(
        INVALID_HANDLE_VALUE,
        NULL,
        0,
        1
        );
    if (!TapiCompletionPort) {
        DebugPrint(( TEXT("CreateIoCompletionPort() failed, ec=0x%08x"), GetLastError() ));
        goto no_devices_exit;
    }

    LineInitializeExParams.dwTotalSize              = sizeof(LINEINITIALIZEEXPARAMS);
    LineInitializeExParams.dwNeededSize             = 0;
    LineInitializeExParams.dwUsedSize               = 0;
    LineInitializeExParams.dwOptions                = LINEINITIALIZEEXOPTION_USECOMPLETIONPORT;
    LineInitializeExParams.Handles.hCompletionPort  = TapiCompletionPort;
    LineInitializeExParams.dwCompletionKey          = TAPI_COMPLETION_KEY;

    LocalTapiApiVersion = TapiApiVersion = 0x00020000;

    Rslt = lineInitializeEx(
        &hLineApp,
        GetModuleHandle(NULL),
        NULL,
        FAX_DISPLAY_NAME,
        &TapiDevices,
        &LocalTapiApiVersion,
        &LineInitializeExParams
        );

    if (Rslt != 0 || LocalTapiApiVersion < 0x00020000) {
        DebugPrint(( TEXT("lineInitializeEx() failed, ec=0x%08x, devices=%d"), Rslt, TapiDevices ));
        goto no_devices_exit;
    }

    //
    // add any new devices to the registry
    //

    for (i=0; i<TapiDevices; i++) {
        Rslt = lineNegotiateAPIVersion(
            hLineApp,
            i,
            0x00010003,
            TapiApiVersion,
            &LocalTapiApiVersion,
            &lineExtensionID
            );
        if (Rslt == 0) {
            LineDevCaps = MyLineGetDevCaps( i );
            if (LineDevCaps) {
                for (j=0; j<FaxReg->DeviceCount; j++) {
                    if (FaxReg->Devices[j].PermanentLineID == LineDevCaps->dwPermanentLineID) {
                        MemFree( LineDevCaps );
                        FaxReg->Devices[j].DeviceInstalled = TRUE;
                        goto next_device;
                    }
                }
                AddNewDevice( i, LineDevCaps, FALSE );
                MemFree( LineDevCaps );
            }
        } else {
            DebugPrint(( TEXT("lineNegotiateAPIVersion() failed, ec=0x%08x"), Rslt ));
        }
next_device:;
    }

    //
    // move any devices that aren't current installed into the device cache
    //  don't cache virtual devices!
    //
    for (j=0; j<FaxReg->DeviceCount; j++) {
        if (!FaxReg->Devices[j].DeviceInstalled && !(FaxReg->Devices[j].Flags & FPF_VIRTUAL)) {
            MoveToDeviceCache(&FaxReg->Devices[j]);
        }
    }

    //
    // get a current list of valid devices
    //

    FaxDevices = GetFaxDevicesRegistry();
    if (!FaxDevices) {
        goto no_devices_exit;
    }

    //
    // create the virtual devices
    //

    DeviceCount += CreateVirtualDevices( FaxReg );

    if (GetModuleFileName( NULL, FaxSvcName, sizeof(FaxSvcName) )) {

        _tsplitpath( FaxSvcName, NULL, NULL, Fname, Ext );
        _stprintf( FaxSvcName, TEXT("%s%s"), Fname, Ext );

        Rslt = lineSetAppPriority(
            FaxSvcName,
            LINEMEDIAMODE_UNKNOWN,
            0,
            0,
            NULL,
            1
            );

        Rslt = lineSetAppPriority(
            FaxSvcName,
            LINEMEDIAMODE_DATAMODEM,
            0,
            0,
            NULL,
            1
            );

        if (Rslt != 0) {
            DebugPrint(( TEXT("lineSetAppPriority() failed, ec=0x%08x"), Rslt ));
        }

    }

    if (DeviceCount == 0 && FaxDevices->DeviceCount == 0) {
        goto no_devices_exit;
    }

    //
    // create a thread to service the tapi callback events
    //

    hThread = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE) TapiWorkerThread,
        NULL,
        0,
        &ThreadId
        );

    if (!hThread) {

        Rslt = GetLastError();
        DebugPrint(( TEXT("Could not start a FAX worker thread, ec=0x%08x"), Rslt ));

    } else {

        CloseHandle( hThread );

    }

    //
    // enumerate and initialize all of the tapi devices
    //

    for (i=0; (i<TapiDevices) && (DeviceCount < DeviceLimit) ; i++) {

        Rslt = lineNegotiateAPIVersion(
            hLineApp,
            i,
            0x00010003,
            TapiApiVersion,
            &LocalTapiApiVersion,
            &lineExtensionID
            );
        if (Rslt != 0) {
            DebugPrint(( TEXT("lineNegotiateAPIVersion() failed, ec=0x%08x"), Rslt ));
        }

        LineDevCaps = MyLineGetDevCaps( i );
        if (LineDevCaps) {
            for (j=0; j<FaxDevices->DeviceCount; j++) {
                if (FaxDevices->Devices[j].PermanentLineID == LineDevCaps->dwPermanentLineID) {
                    Rslt = InitializeTapiLine(
                        i,
                        LineDevCaps,
                        FaxDevices->Devices[j].Priority,
                        FaxDevices->Devices[j].Rings,
                        FaxDevices->Devices[j].Flags,
                        FaxDevices->Devices[j].Csid,
                        FaxDevices->Devices[j].Tsid
                        );
                    if (Rslt != 0) {
                        DebugPrint(( TEXT("InitializeTapiLine() failed, ec=0x%08x"), Rslt ));
                    } else {
                        DeviceCount += 1;
                    }
                }
            }

            MemFree( LineDevCaps );

        }
    }

    FreeFaxDevicesRegistry( FaxDevices );

    //
    // loop thru the devices and close the line handles
    // for all devices that are NOT set to receive
    //

    Next = TapiLinesListHead.Flink;
    if (Next) {
        while ((ULONG_PTR)Next != (ULONG_PTR)&TapiLinesListHead) {

            LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
            Next = LineInfo->ListEntry.Flink;

            if (LineInfo->Flags & FPF_RECEIVE) {
                TerminationDelay = (DWORD)-1;
            } else {
                if (LineInfo->hLine) {
                    hLine = LineInfo->hLine;
                    LineInfo->hLine = 0;
                    lineClose( hLine );
                }
            }
        }
    }

    SortDevicePriorities();

    LeaveCriticalSection( &CsLine );

    return 0;

no_devices_exit:
    FaxLog(
        FAXLOG_CATEGORY_INIT,
        FAXLOG_LEVEL_NONE,
        0,
        MSG_NO_FAX_DEVICES
        );

    ReportServiceStatus( SERVICE_STOPPED, 0, 0 );

    FaxLog(
        FAXLOG_CATEGORY_INIT,
        FAXLOG_LEVEL_NONE,
        0,
        MSG_SERVICE_STOPPED
        );

    ExitProcess(0);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\server\svcwin.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxsvc.c

Abstract:

    This module contains the windows code for the
    FAX service debug window.

Author:

    Wesley Witt (wesw) 28-Feb-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop

#include "resource.h"


HWND            hwndSvcMain;
HWND            hwndEdit;
HWND            hwndListMsg;
HWND            hwndListLines;
HWND            hwndListState;
DWORD           EditHeight;
DWORD           ListMsgHeight;
DWORD           ListLinesHeight;
DWORD           ListStateHeight;






DWORD
DebugServiceWindowThread(
    HANDLE hEvent
    );

LRESULT
WndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );


int
DebugService(
    VOID
    )

/*++

Routine Description:

    Starts the service in debug mode.  In this mode the FAX service
    runs as a regular WIN32 process.  This is implemented as an aid
    to debugging the service.

Arguments:

    argc        - argument count
    argv        - argument array

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/

{
    LONG        Rslt;
    HANDLE      WaitHandles[2];


    ServiceDebug = TRUE;
    ConsoleDebugOutput = TRUE;

    WaitHandles[1] = CreateEvent( NULL, FALSE, FALSE, NULL );

    WaitHandles[0] = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE) DebugServiceWindowThread,
        WaitHandles[1],
        0,
        &Rslt
        );

    if (!WaitHandles[0]) {
        return GetLastError();
    }

    if (WaitForMultipleObjects( 2, WaitHandles, FALSE, INFINITE ) == WAIT_OBJECT_0) {
        //
        // the window initialization did not complete successfuly
        //
        GetExitCodeThread( WaitHandles[0], &Rslt );
        return Rslt;
    }

    return ServiceStart();
}


DWORD
DebugServiceWindowThread(
    HANDLE hEvent
    )
{
    WNDCLASS    wndclass;
    MSG         msg;
    HINSTANCE   hInstance;


    hInstance = GetModuleHandle( NULL );

    wndclass.style          = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc    = (WNDPROC) WndProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = 0;
    wndclass.hInstance      = hInstance;
    wndclass.hIcon          = LoadIcon( hInstance, MAKEINTRESOURCE(IDI_APPICON) );
    wndclass.hCursor        = LoadCursor( NULL, IDC_ARROW );
    wndclass.hbrBackground  = (HBRUSH) (COLOR_3DFACE + 1);
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = TEXT("FaxService");

    RegisterClass( &wndclass );

    hwndSvcMain = CreateWindow (
        TEXT("FaxService"),      // window class name
        TEXT("Fax Service"),     // window caption
        WS_OVERLAPPEDWINDOW,     // window style
        CW_USEDEFAULT,           // initial x position
        CW_USEDEFAULT,           // initial y position
        CW_USEDEFAULT,           // initial x size
        CW_USEDEFAULT,           // initial y size
        NULL,                    // parent window handle
        NULL,                    // window menu handle
        hInstance,               // program instance handle
        NULL                     // creation parameters
        );

    if (!hwndSvcMain) {
        return 0;
    }

    ShowWindow( hwndSvcMain, SW_SHOWNORMAL );
    UpdateWindow (hwndSvcMain) ;

    SetEvent( hEvent );

    while (GetMessage (&msg, NULL, 0, 0)) {
        TranslateMessage (&msg) ;
        DispatchMessage (&msg) ;
    }

    return 0;
}


VOID
ConsoleDebugPrint(
    LPTSTR buf
    )
{
    static WPARAM   cxExtent = 0;
    static DWORD    MsgCount = 0;
    SIZE            size;
    HDC             hdc;
    HFONT           hFont;


    if (!ConsoleDebugOutput) {
        return;
    }

    SendMessage( hwndListMsg, LB_ADDSTRING, 0, (LPARAM) buf );
    SendMessage( hwndListMsg, LB_SETCURSEL, MsgCount, 0 );

    MsgCount += 1;

    hdc = GetDC( hwndListMsg );
    hFont = (HFONT)SendMessage( hwndListMsg, WM_GETFONT, 0, 0 );
    if (hFont != NULL) {
        SelectObject( hdc, hFont );
    }
    GetTextExtentPoint( hdc, buf, _tcslen(buf), &size );
    if (size.cx > (LONG)cxExtent) {
        cxExtent = size.cx;
    }
    ReleaseDC( hwndListMsg, hdc );

    SendMessage( hwndListMsg, LB_SETHORIZONTALEXTENT, cxExtent, 0 );
}


void
lbprintf(
    HWND hwndList,
    LPTSTR Format,
    ...
    )

/*++

Routine Description:

    Prints a debug string

Arguments:

    format      - printf() format string
    ...         - Variable data

Return Value:

    None.

--*/

{
    TCHAR buf[1024];
    va_list arg_ptr;
    va_start(arg_ptr, Format);
    _vsntprintf(buf, sizeof(buf), Format, arg_ptr);
    va_end(arg_ptr);
    SendMessage( hwndList, LB_ADDSTRING, 0, (LPARAM) buf );
}


LRESULT
WndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Window procedure for the TIFF image viewer main window.

Arguments:

    hwnd            - Window handle
    message         - message identifier
    wParam          - Parameter
    lParam          - Parameter

Return Value:

    Return result, zero for success.

--*/

{
    RECT                   Rect;
    HDC                    hDC;
    TEXTMETRIC             tm;
    HFONT                  hFont;
    DWORD                  Height;
    TCHAR                  CmdBuf[128];
    DWORD                  i;


    switch (message) {
        case WM_CREATE:

            GetClientRect( hwnd, &Rect );

            hFont = GetStockObject( SYSTEM_FIXED_FONT );
            SendMessage( hwnd, WM_SETFONT, (WPARAM)hFont, (LPARAM)FALSE );

            hDC = GetDC( hwnd );
            GetTextMetrics( hDC, &tm );
            ReleaseDC( hwnd, hDC );

            EditHeight      = (DWORD)(tm.tmHeight * 1.5);
            Height          = (Rect.bottom - Rect.top) - EditHeight;
            ListMsgHeight   = (DWORD) (Height * .40);
            ListLinesHeight = (DWORD) (Height * .60);
            ListStateHeight = (DWORD) (Height * .60);

            hwndEdit = CreateWindowEx(
                WS_EX_CLIENTEDGE,
                TEXT("EDIT"),
                NULL,
                WS_CHILD | WS_VISIBLE | WS_BORDER | WS_TABSTOP | ES_LEFT | ES_WANTRETURN | ES_MULTILINE | ES_AUTOVSCROLL,
                Rect.left,
                Rect.bottom - EditHeight,
                Rect.right  - Rect.left,
                EditHeight,
                hwnd,
                NULL,
                GetModuleHandle(NULL),
                NULL
                );

            SendMessage( hwndEdit, EM_LIMITTEXT, 128, 0 );
            SendMessage( hwndEdit, WM_SETFONT, (WPARAM)hFont, (LPARAM)FALSE );

            hwndListMsg = CreateWindowEx(
                WS_EX_CLIENTEDGE,
                TEXT("LISTBOX"),
                NULL,
                WS_VSCROLL           |
                WS_HSCROLL           |
                WS_CHILD             |
                WS_VISIBLE           |
                WS_BORDER            |
                LBS_NOTIFY           |
                LBS_NOINTEGRALHEIGHT |
                LBS_WANTKEYBOARDINPUT,
                Rect.left,
                Rect.bottom - EditHeight - ListMsgHeight,
                Rect.right  - Rect.left,
                ListMsgHeight,
                hwnd,
                NULL,
                GetModuleHandle(NULL),
                NULL
                );

            SendMessage( hwndListMsg, WM_SETFONT, (WPARAM)hFont, (LPARAM)FALSE );

            hwndListLines = CreateWindowEx(
                WS_EX_CLIENTEDGE,
                TEXT("LISTBOX"),
                NULL,
                WS_VSCROLL           |
                WS_HSCROLL           |
                WS_CHILD             |
                WS_VISIBLE           |
                WS_BORDER            |
                LBS_NOTIFY           |
                LBS_NOINTEGRALHEIGHT |
                LBS_WANTKEYBOARDINPUT,
                Rect.left,
                Rect.bottom - EditHeight - ListMsgHeight - ListLinesHeight,
                (Rect.right  - Rect.left) / 2,
                ListLinesHeight,
                hwnd,
                NULL,
                GetModuleHandle(NULL),
                NULL
                );

            SendMessage( hwndListLines, WM_SETFONT, (WPARAM)hFont, (LPARAM)FALSE );

            hwndListState = CreateWindowEx(
                WS_EX_CLIENTEDGE,
                TEXT("LISTBOX"),
                NULL,
                WS_VSCROLL           |
                WS_HSCROLL           |
                WS_CHILD             |
                WS_VISIBLE           |
                WS_BORDER            |
                LBS_NOTIFY           |
                LBS_NOINTEGRALHEIGHT |
                LBS_WANTKEYBOARDINPUT,
                Rect.left + ((Rect.right  - Rect.left) / 2),
                Rect.bottom - EditHeight - ListMsgHeight,
                (Rect.right  - Rect.left) / 2,
                ListStateHeight,
                hwnd,
                NULL,
                GetModuleHandle(NULL),
                NULL
                );

            SendMessage( hwndListState, WM_SETFONT, (WPARAM)hFont, (LPARAM)FALSE );

            SetFocus( hwndEdit );

            return 0;

        case WM_ACTIVATEAPP:
        case WM_SETFOCUS:
            SetFocus( hwndEdit );
            return 0;

        case WM_WINDOWPOSCHANGED:
            GetClientRect( hwnd, &Rect );

            Height          = (Rect.bottom - Rect.top) - EditHeight;
            ListMsgHeight   = (DWORD) (Height * .40);
            ListLinesHeight = (DWORD) (Height * .60);
            ListStateHeight = (DWORD) (Height * .60);

            MoveWindow(
                hwndEdit,
                Rect.left,
                Rect.bottom - Rect.top - EditHeight,
                Rect.right - Rect.left,
                EditHeight,
                TRUE
                );
            MoveWindow(
                hwndListMsg,
                Rect.left,
                Rect.bottom - Rect.top - EditHeight - ListMsgHeight,
                Rect.right - Rect.left,
                ListMsgHeight,
                TRUE
                );
            MoveWindow(
                hwndListLines,
                Rect.left,
                Rect.bottom - Rect.top - EditHeight - ListMsgHeight - ListLinesHeight,
                (Rect.right  - Rect.left) / 2,
                ListLinesHeight,
                TRUE
                );
            MoveWindow(
                hwndListState,
                Rect.left + ((Rect.right  - Rect.left) / 2),
                Rect.bottom - Rect.top - EditHeight - ListMsgHeight - ListLinesHeight,
                (Rect.right  - Rect.left) / 2,
                ListStateHeight,
                TRUE
                );
            return 0;

        case WM_COMMAND:
            switch ( HIWORD(wParam) ) {
                case EN_CHANGE:
                    GetWindowText( hwndEdit, CmdBuf, sizeof(CmdBuf) );
                    i = _tcslen(CmdBuf);
                    if (i && CmdBuf[i-1] == TEXT('\n')) {
                        SetWindowText( hwndEdit, TEXT("") );
                        CmdBuf[i-2] = 0;
                        ConsoleDebugPrint( CmdBuf );
                        switch( _totlower( CmdBuf[0] ) ) {
                            case TEXT('q'):
                                DestroyWindow( hwnd );
                                break;

                            default:
                                break;
                        }
                    }
                    break;

                case LBN_SELCHANGE:
                    if ((HWND)lParam == hwndListLines) {
                        extern PLINE_INFO TapiLines;
                        extern CRITICAL_SECTION CsLine;

print_line_state:
                        i = SendMessage( hwndListLines, LB_GETCURSEL, 0, 0 );

                        if (i != LB_ERR) {

                            SendMessage( hwndListState, WM_SETREDRAW, FALSE, 0 );
                            SendMessage( hwndListState, LB_RESETCONTENT, 0, 0 );

                            if (TapiLines[i].Provider) {
                                lbprintf( hwndListState, TEXT("Provider:    %s"),     TapiLines[i].Provider->ProviderName );
                                lbprintf( hwndListState, TEXT("Heap:        0x%08x"), TapiLines[i].Provider->HeapHandle   );
                                lbprintf( hwndListState, TEXT("Base:        0x%08x"), TapiLines[i].Provider->hModule      );
                            }

                            lbprintf( hwndListState, TEXT("DeviceId:    %d"),     TapiLines[i].DeviceId               );
                            lbprintf( hwndListState, TEXT("Line Handle: 0x%08x"), TapiLines[i].hLine                  );
                            lbprintf( hwndListState, TEXT("Job:         0x%08x"), TapiLines[i].JobEntry               );

                            SendMessage( hwndListState, WM_SETREDRAW, TRUE, 0 );

                        }

                    }

                    break;


                default:
                    break;
            }
            return 0;

        case WM_SERVICE_INIT:
            SendMessage( hwndListLines, LB_SETCURSEL, 0, 0 );
            goto print_line_state;
            return 0;

        case WM_CTLCOLOREDIT:
            SetBkColor( (HDC)wParam, RGB(128,128,0) );
            return (LPARAM)CreateSolidBrush( RGB(128,128,0) );

        case WM_CTLCOLORLISTBOX:
            if ((HWND)lParam == hwndListLines || (HWND)lParam == hwndListState) {
                SetBkColor( (HDC)wParam, RGB(192,192,192) );
                return (LPARAM)CreateSolidBrush( RGB(192,192,192) );
            }
            if ((HWND)lParam == hwndListMsg) {
                SetBkColor( (HDC)wParam, RGB(192,192,192) );
                return (LPARAM)CreateSolidBrush( RGB(192,192,192) );
            }
            return 0;

        case WM_DESTROY:
            ServiceStop();
#ifdef FAX_HEAP_DEBUG
            PrintAllocations();
#endif
            PostQuitMessage( 0 );
            return 0;
    }

    return DefWindowProc( hwnd, message, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\stress\faxstres.c ===
#include <windows.h>
#include <commctrl.h>
#include <winspool.h>
#include <shellapi.h>
#include <shlapip.h>
#include <stdio.h>
#include <stdlib.h>
#include <mapi.h>

#include "faxutil.h"
#include "winfax.h"
#include "resource.h"

typedef struct _RECIPIENT {
    WCHAR   Name[256];
    WCHAR   Address[256];
    DWORD   NameLen;
    DWORD   AddressLen;
    DWORD   MultiAddrCnt;
} RECIPIENT, *PRECIPIENT;

typedef struct _DOCUMENT {
    WCHAR   Name[256];
    LPSTR   Text;
    DWORD   TextSize;
} DOCUMENT, *PDOCUMENT;


LPWSTR          FaxPrinterName;
int             x;
int             y;
LPMAPILOGON     pMAPILogon;
LPMAPISENDMAIL  pMAPISendMail;
LPMAPILOGOFF    pMAPILogoff;
RECIPIENT       Recipients[100];
DOCUMENT        Documents[100];
HANDLE          ExchangeEvent;
BOOL            UseExchange;
DWORD           DocCount;
DWORD           RecipCount;
BOOL            NoGuiMode = TRUE;
DWORD           Copies = 1;
BOOL            DontResetOnExit;


#define LEFT_MARGIN                         1  // ---|
#define RIGHT_MARGIN                        1  //    |
#define TOP_MARGIN                          1  //    |---> in inches
#define BOTTOM_MARGIN                       1  // ---|

#define InchesToCM(_x)                      (((_x) * 254L + 50) / 100)
#define CMToInches(_x)                      (((_x) * 100L + 127) / 254)



int
PopUpMsg(
    LPWSTR Format,
    ...
    )
{
    WCHAR buf[1024];
    va_list arg_ptr;


    va_start( arg_ptr, Format );
    _vsnwprintf( buf, sizeof(buf), Format, arg_ptr );
    va_end(arg_ptr);

    return MessageBox(
        NULL,
        buf,
        L"Fax Stress Error",
        MB_SETFOREGROUND | MB_ICONEXCLAMATION | MB_OK
        );
}


BOOL
SetPrinterDataStr(
    HANDLE  hPrinter,
    LPWSTR  pRegKey,
    LPWSTR  pValue,
    DWORD   Length
    )
{
    if (SetPrinterData(hPrinter,
                       pRegKey,
                       REG_MULTI_SZ,
                       (PBYTE) pValue,
                       Length) != ERROR_SUCCESS)
    {
        DebugPrint((L"Couldn't save registry key %ws: %d\n", pRegKey, GetLastError()));
        return FALSE;
    }

    return TRUE;
}


BOOL
SetPrinterDataDWord(
    HANDLE  hPrinter,
    PWSTR   pRegKey,
    DWORD   value
    )
{
    if (SetPrinterData(hPrinter,
                       pRegKey,
                       REG_DWORD,
                       (PBYTE) &value,
                       sizeof(value)) != ERROR_SUCCESS)
    {
        DebugPrint((L"Couldn't save registry key %ws: %d\n", pRegKey, GetLastError()));
        return FALSE;
    }

    return TRUE;
}


LPWSTR
GetPrinterDataStr(
    HANDLE  hPrinter,
    LPWSTR  pRegKey
    )
{
    DWORD   type, cb;
    PVOID   pBuffer = NULL;

    //
    // We should really pass NULL for pData parameter here. But to workaround
    // a bug in the spooler API GetPrinterData, we must pass in a valid pointer here.
    //

    if (GetPrinterData(hPrinter, pRegKey, &type, (PBYTE) &type, 0, &cb) == ERROR_MORE_DATA &&
        (pBuffer = MemAlloc(cb)) &&
        GetPrinterData(hPrinter, pRegKey, &type, pBuffer, cb, &cb) == ERROR_SUCCESS &&
        (type == REG_SZ || type == REG_MULTI_SZ || type == REG_EXPAND_SZ))
    {
        return pBuffer;
    }

    DebugPrint((L"Couldn't get printer data string %ws: %d\n", pRegKey, GetLastError()));
    MemFree(pBuffer);
    return NULL;
}



DWORD
GetPrinterDataDWord(
    HANDLE  hPrinter,
    PWSTR   pRegKey,
    DWORD   defaultValue
    )
{
    DWORD   value, type, cb;

    if (GetPrinterData(hPrinter,
                       pRegKey,
                       &type,
                       (PBYTE) &value,
                       sizeof(value),
                       &cb) == ERROR_SUCCESS)
    {
        return value;
    }

    return defaultValue;
}


void
pprintf(
    HDC hDC,
    HFONT hFont,
    LPWSTR Format,
    ...
    )
{
    WCHAR buf[1024];
    va_list arg_ptr;
    INT len;
    BOOL cr = FALSE;
    TEXTMETRIC tm;
    SIZE Size;
    INT Fit;


    va_start(arg_ptr, Format);
    _vsnwprintf( buf, sizeof(buf), Format, arg_ptr );
    va_end(arg_ptr);
    len = wcslen(buf);
    if (buf[len-1] == TEXT('\n')) {
        len -= 1;
        buf[len] = 0;
        cr = TRUE;
    }
    SelectObject( hDC, hFont );
    GetTextMetrics( hDC, &tm );
    TextOut( hDC, x, y, buf, len );
    if (cr) {
        y += tm.tmHeight;
        x = 0;
    } else {
        GetTextExtentExPoint(
            hDC,
            buf,
            len,
            len * tm.tmMaxCharWidth,
            &Fit,
            NULL,
            &Size
            );
        x += Fit;
    }
}


LPSTR
GetDefaultMessagingProfile(
    VOID
    )
{
    #define KeyPath L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows Messaging Subsystem\\Profiles"
    #define Value   L"DefaultProfile"

    HKEY    hkey;
    WCHAR   UserProfileStringW[64];
    DWORD   buf_sz = sizeof(UserProfileStringW);
    DWORD   val_type;


    if( RegOpenKeyEx( HKEY_CURRENT_USER, KeyPath, 0, KEY_READ, &hkey ) == ERROR_SUCCESS )
    {
        if ( RegQueryValueEx( hkey, Value, NULL, &val_type, (LPBYTE) UserProfileStringW, &buf_sz ) == ERROR_SUCCESS )
        {
            if ( val_type == REG_SZ )
            {
                RegCloseKey( hkey );
                return UnicodeStringToAnsiString( UserProfileStringW );
            }
        }

        RegCloseKey( hkey );
    }

    return NULL;
}


BOOL
PrintText(
    HDC hDC,
    LPSTR Text,
    DWORD TextSize
    )
{
    LPWSTR lpLine;
    LPWSTR pLineEOL;
    LPWSTR pNextLine;
    LPWSTR BodyText;
    DWORD Chars;
    HFONT hFont = NULL;
    HFONT hPrevFont = NULL;
    TEXTMETRIC tm;
    BOOL rVal = TRUE;
    INT nLinesPerPage;
    INT dyTop;              // width of top border (pixels)
    INT dyBottom;           // width of bottom border
    INT dxLeft;             // width of left border
    INT dxRight;            // width of right border
    INT yPrinWCHAR;         // height of a character
    INT tabSize;            // Size of a tab for print device in device units
    INT yCurpos = 0;
    INT xCurpos = 0;
    INT nPixelsLeft = 0;
    INT guess = 0;
    SIZE Size;                 // to see if text will fit in space left
    INT nPrintedLines = 0;
    BOOL fPageStarted = FALSE;
    INT iPageNum = 0;
    INT xPrintRes;          // printer resolution in x direction
    INT yPrintRes;          // printer resolution in y direction
    INT yPixInch;           // pixels/inch
    INT xPixInch;           // pixels/inch
    INT xPixUnit;           // pixels/local measurement unit
    INT yPixUnit;           // pixels/local measurement unit
    BOOL fEnglish;
    INT PrevBkMode = 0;



    BodyText = (LPWSTR) MemAlloc( (TextSize + 4) * sizeof(WCHAR) );
    if (!BodyText) {
        return FALSE;
    }

    MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        Text,
        -1,
        BodyText,
        TextSize
        );

    lpLine = BodyText;

    fEnglish = GetProfileInt( L"intl", L"iMeasure", 1 );

    xPrintRes = GetDeviceCaps( hDC, HORZRES );
    yPrintRes = GetDeviceCaps( hDC, VERTRES );
    xPixInch  = GetDeviceCaps( hDC, LOGPIXELSX );
    yPixInch  = GetDeviceCaps( hDC, LOGPIXELSY );
    //
    // compute x and y pixels per local measurement unit
    //
    if (fEnglish) {
        xPixUnit= xPixInch;
        yPixUnit= yPixInch;
    } else {
        xPixUnit= CMToInches( xPixInch );
        yPixUnit= CMToInches( yPixInch );
    }

    SetMapMode( hDC, MM_TEXT );

    hFont = GetStockObject( SYSTEM_FIXED_FONT );

    hPrevFont = (HFONT) SelectObject( hDC, hFont );
    SetBkMode( hDC, TRANSPARENT );
    if (!GetTextMetrics( hDC, &tm )) {
        rVal = FALSE;
        goto exit;
    }

    yPrinWCHAR = tm.tmHeight + tm.tmExternalLeading;
    tabSize = tm.tmAveCharWidth * 8;

    //
    // compute margins in pixels
    //
    dxLeft     = LEFT_MARGIN    *  xPixUnit;
    dxRight    = RIGHT_MARGIN   *  xPixUnit;
    dyTop      = TOP_MARGIN     *  yPixUnit;
    dyBottom   = BOTTOM_MARGIN  *  yPixUnit;

    //
    // Number of lines on a page with margins
    //
    nLinesPerPage = ((yPrintRes - dyTop - dyBottom) / yPrinWCHAR);

    while (*lpLine) {

        if (*lpLine == '\r') {
            lpLine += 2;
            yCurpos += yPrinWCHAR;
            nPrintedLines++;
            xCurpos= 0;
            continue;
        }

        pLineEOL = lpLine;
        while (*pLineEOL && *pLineEOL != '\r') pLineEOL++;

        do {
            if ((nPrintedLines == 0) && (!fPageStarted)) {

                StartPage( hDC );
                fPageStarted = TRUE;
                yCurpos = 0;
                xCurpos = 0;

            }

            if (*lpLine == '\t') {

                //
                // round up to the next tab stop
                // if the current position is on the tabstop, goto next one
                //
                xCurpos = ((xCurpos + tabSize) / tabSize ) * tabSize;
                lpLine++;

            } else {

                //
                // find end of line or tab
                //
                pNextLine = lpLine;
                while ((pNextLine != pLineEOL) && *pNextLine != '\t') pNextLine++;

                //
                // find out how many characters will fit on line
                //
                Chars = pNextLine - lpLine;
                nPixelsLeft = xPrintRes - dxRight - dxLeft - xCurpos;
                GetTextExtentExPoint( hDC, lpLine, Chars, nPixelsLeft, &guess, NULL, &Size );


                if (guess) {
                    //
                    // at least one character fits - print
                    //

                    TextOut( hDC, dxLeft+xCurpos, yCurpos+dyTop, lpLine, guess );

                    xCurpos += Size.cx;   // account for printing
                    lpLine  += guess;     // printed characters

                } else {

                    //
                    // no characters fit what's left
                    // no characters will fit in space left
                    // if none ever will, just print one
                    // character to keep progressing through
                    // input file.
                    //
                    if (xCurpos == 0) {
                        if( lpLine != pNextLine ) {
                            //
                            // print something if not null line
                            // could use exttextout here to clip
                            //
                            TextOut( hDC, dxLeft+xCurpos, yCurpos+dyTop, lpLine, 1 );
                            lpLine++;
                        }
                    } else {
                        //
                        // perhaps the next line will get it
                        //
                        xCurpos = xPrintRes;  // force to next line
                    }
                }

                //
                // move printhead in y-direction
                //
                if ((xCurpos >= (xPrintRes - dxRight - dxLeft) ) || (lpLine == pLineEOL)) {
                   yCurpos += yPrinWCHAR;
                   nPrintedLines++;
                   xCurpos = 0;
                }

                if (nPrintedLines >= nLinesPerPage) {
                   EndPage( hDC );
                   fPageStarted = FALSE;
                   nPrintedLines = 0;
                   xCurpos = 0;
                   yCurpos = 0;
                   iPageNum++;
                }

            }

        } while( lpLine != pLineEOL );

        if (*lpLine == '\r') {
            lpLine += 1;
        }
        if (*lpLine == '\n') {
            lpLine += 1;
        }

    }

    if (fPageStarted) {
        EndPage( hDC );
    }

exit:
    MemFree( BodyText );
    if (hPrevFont) {
        SelectObject( hDC, hPrevFont );
        DeleteObject( hFont );
    }
    if (PrevBkMode) {
        SetBkMode( hDC, PrevBkMode );
    }
    return rVal;
}


BOOL
GetSettings(
    VOID
    )
{
    DWORD i;
    LPWSTR p;
    LPWSTR s;
    WCHAR MsgTypeString[64];
    WCHAR RecipientName[128];
    WCHAR RecipientNumber[128];
    WCHAR DocKeys[4096];
    DWORD RecipientCount;
    WCHAR Sections[4096];



    //
    // get the doc type
    //

    GetPrivateProfileString(
        L"General",
        L"MessageType",
        L"Printer",
        MsgTypeString,
        sizeof(MsgTypeString),
        L".\\faxstres.ini"
        );
    if (_wcsicmp( MsgTypeString, L"Exchange" ) == 0) {
        UseExchange = TRUE;
    }

    //
    // get the document names
    //

    DocCount = 0;

    GetPrivateProfileString(
        L"Documents",
        NULL,
        L"",
        DocKeys,
        sizeof(DocKeys),
        L".\\faxstres.ini"
        );

    p = DocKeys;
    while (*p) {
        GetPrivateProfileString(
            L"Documents",
            p,
            L"",
            Documents[DocCount].Name,
            sizeof(Documents[DocCount].Name),
            L".\\faxstres.ini"
            );
        DocCount += 1;
        p += (wcslen(p) + 1);
    }

    for (i=0; i<DocCount; i++) {
        HANDLE hFile = CreateFile(
            Documents[i].Name,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            0,
            NULL
            );
        if (hFile != INVALID_HANDLE_VALUE) {
            DWORD sz = GetFileSize( hFile, NULL );
            Documents[i].Text = MemAlloc( sz + 4 );
            if (Documents[i].Text) {
                ReadFile( hFile, Documents[i].Text, sz, &sz, NULL );
                Documents[i].TextSize = sz;
            }
            CloseHandle( hFile );
        }
    }

    RecipientCount = 0;

    //
    // get all of the section names
    //

    GetPrivateProfileString(
        NULL,
        NULL,
        L"",
        Sections,
        sizeof(Sections),
        L".\\faxstres.ini"
        );

    //
    // count the number of sections
    //

    p = Sections;
    while (*p) {
        if (wcscmp( p, L"Documents" ) != 0) {
            RecipientCount += 1;
        }
        p += (wcslen(p) + 1);
    }

    //
    // read the recipient info for each receipient
    //

    p = Sections;
    i = 0;
    RecipCount = 0;
    while (*p) {
        if ((wcscmp( p, L"Documents" ) == 0) ||
            (wcscmp( p, L"General" )   == 0)) {
            p += (wcslen(p) + 1);
            continue;
        }

        ZeroMemory( RecipientName, sizeof(RecipientName) );

        GetPrivateProfileString(
            p,
            L"Name",
            L"",
            RecipientName,
            sizeof(RecipientName),
            L".\\faxstres.ini"
            );

        GetPrivateProfileString(
            p,
            L"Number",
            L"",
            RecipientNumber,
            sizeof(RecipientNumber),
            L".\\faxstres.ini"
            );

        wcscpy( Recipients[RecipCount].Name,    RecipientName   );
        wcscpy( Recipients[RecipCount].Address, RecipientNumber );

        Recipients[RecipCount].NameLen = wcslen( Recipients[RecipCount].Name );
        s = wcschr( Recipients[RecipCount].Name, L',' );
        Recipients[RecipCount].MultiAddrCnt = 1;
        while( s ) {
            *s = UNICODE_NULL;
            s = wcschr( s+1, L',' );
            Recipients[RecipCount].MultiAddrCnt += 1;
        }

        Recipients[RecipCount].AddressLen = wcslen( Recipients[RecipCount].Address );
        s = wcschr( Recipients[RecipCount].Address, L',' );
        while( s ) {
            *s = UNICODE_NULL;
            s = wcschr( s+1, L',' );
        }

        RecipCount += 1;

        i += 1;
        p += (wcslen(p) + 1);
    }

    return TRUE;
}


DWORD
ConcatStrings(
    LPWSTR DestStr,
    LPWSTR Str1,
    LPWSTR Str2
    )
{
    DWORD len = 0;
    wcscpy( DestStr, Str1 );
    len += wcslen(DestStr) + 1;
    DestStr += wcslen(DestStr) + 1;
    wcscpy( DestStr, Str2 );
    len += wcslen(DestStr) + 1;
    DestStr += wcslen(DestStr) + 1;
    return len;
}


BOOL
SetFakeRecipientInfo(
    VOID
    )
{
    HANDLE hPrinter;
    PRINTER_DEFAULTS PrinterDefaults;
    WCHAR SubKeyName[256];
    WCHAR Buffer[256];
    DWORD i;
    DWORD len;
    DWORD blen;
    LPWSTR s;
    LPWSTR Name,Addr;


    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_ACCESS_USE;

    if (!OpenPrinter( FaxPrinterName, &hPrinter, &PrinterDefaults )) {
        DebugPrint(( L"OpenPrinter#1() failed, ec=%d", GetLastError() ));
        return FALSE;
    }

    if (GetPrinterDataDWord( hPrinter, L"FakeRecipientCount", 0 )) {
        DontResetOnExit = TRUE;
        ClosePrinter( hPrinter );
        return TRUE;
    }

    ClosePrinter( hPrinter );

    PrinterDefaults.DesiredAccess = PRINTER_ALL_ACCESS;

    if (!OpenPrinter( FaxPrinterName, &hPrinter, &PrinterDefaults )) {
        DebugPrint(( L"OpenPrinter#2() failed, ec=%d", GetLastError() ));
        return FALSE;
    }

    SetPrinterDataDWord( hPrinter, L"FakeRecipientCount", UseExchange ? 0 : RecipCount );

    if (!UseExchange) {
        for (i=0; i<RecipCount; i++) {
            ZeroMemory( Buffer, sizeof(Buffer) );
            swprintf( SubKeyName, L"FakeRecipient%d", i );
            if (Recipients[i].MultiAddrCnt > 1) {
                Name = Recipients[i].Name;
                Addr = Recipients[i].Address;
                s = Buffer;
                len = 2;
                do {
                    blen = ConcatStrings( s, Name, Addr );
                    s += blen;
                    Name += wcslen(Name) + 1;
                    Addr += wcslen(Addr) + 1;
                    len += blen;
                } while( *Name );
                len = len * sizeof(WCHAR);
            } else {
                ConcatStrings( Buffer, Recipients[i].Name, Recipients[i].Address );
                len = (wcslen(Recipients[i].Name) + wcslen(Recipients[i].Address) + 3) * sizeof(WCHAR);
            }
            SetPrinterDataStr( hPrinter, SubKeyName, Buffer, len );
        }
    }

    ClosePrinter( hPrinter );
}


BOOL
ExchangeStress(
    VOID
    )
{
    LPSTR UserProfile;
    MapiRecipDesc rgRecipDescStruct[30];
    MapiMessage MessageStruct = {0, NULL, NULL, NULL, NULL, NULL, 0, NULL, 0, NULL, 0, NULL};
    MapiFileDesc MAPIFileDesc = {0, 0, 0, NULL, NULL, NULL};
    HMODULE hMapiMod;
    DWORD rslt;
    LHANDLE hSession;
    DWORD RecipIdx;
    DWORD DocIdx;


    hMapiMod = LoadLibrary( L"mapi32.dll" );

    pMAPILogon    = (LPMAPILOGON)    GetProcAddress( hMapiMod, "MAPILogon"    );
    pMAPISendMail = (LPMAPISENDMAIL) GetProcAddress( hMapiMod, "MAPISendMail" );
    pMAPILogoff   = (LPMAPILOGOFF)   GetProcAddress( hMapiMod, "MAPILogoff"   );

    if (pMAPILogon == NULL || pMAPISendMail == NULL || pMAPILogoff == NULL) {
        PopUpMsg( L"cannot link to exchange" );
        return FALSE;
    }

    UserProfile = GetDefaultMessagingProfile();

    rslt = pMAPILogon( 0, UserProfile, NULL, MAPI_NEW_SESSION, 0, &hSession );
    if (rslt != SUCCESS_SUCCESS) {
        PopUpMsg( L"cannot logon to exchange: [%d]", rslt );
        return FALSE;
    }

    rgRecipDescStruct[0].ulReserved = 0;
    rgRecipDescStruct[0].ulRecipClass = MAPI_TO;
    rgRecipDescStruct[0].lpszName = NULL;
    rgRecipDescStruct[0].lpszAddress = NULL;
    rgRecipDescStruct[0].ulEIDSize = 0;
    rgRecipDescStruct[0].lpEntryID = NULL;

    MessageStruct.lpRecips = rgRecipDescStruct;
    MessageStruct.nRecipCount = 1;
    MessageStruct.lpszSubject = "Test Message";
    MessageStruct.lpszNoteText = NULL;

    RecipIdx = 0;
    DocIdx = 0;

    while( Copies ) {

        rgRecipDescStruct[0].lpszName = UnicodeStringToAnsiString( Recipients[RecipIdx].Name );
        MessageStruct.lpszNoteText = Documents[DocIdx].Text;

        rslt = pMAPISendMail( 0, 0, &MessageStruct, 0, 0 );

        MemFree( rgRecipDescStruct[0].lpszName );

        DocIdx += 1;
        if (DocIdx == DocCount) {
            DocIdx = 0;
        }

        RecipIdx += 1;
        if (RecipIdx == RecipCount) {
            RecipIdx = 0;
        }

    }

    ExchangeEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    PopUpMsg( L"**** when all documents have been queued to the printer then ^C this..." );
    WaitForSingleObject( ExchangeEvent, INFINITE );
    pMAPILogoff( hSession, 0, 0, 0 );


}


BOOL
PrintStress(
    VOID
    )
{
    LPWSTR MachineName = NULL;
    HANDLE hPrinter;
    HDC hDC;
    DOCINFO di;
    HPEN hPenWide;
    HFONT hFontBig;
    HFONT hFontNormal;
    SYSTEMTIME Time;
    DWORD DocIdx = 0;
    PRINTER_DEFAULTS PrinterDefaults;


    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_ACCESS_USE;

    if (!OpenPrinter( FaxPrinterName, &hPrinter, &PrinterDefaults )) {
        DebugPrint(( L"OpenPrinter() failed, ec=%d", GetLastError() ));
        return FALSE;
    }

    hPenWide    = CreatePen( PS_SOLID, 7, RGB(0,0,0) );
    hFontBig    = CreateFont( 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, L"Arial" );
    hFontNormal = CreateFont( 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, L"Arial" );

    while( Copies ) {

        hDC = CreateDC( L"WINSPOOL", FaxPrinterName, NULL, NULL );
        if (!hDC) {
            return FALSE;
        }

        ZeroMemory( &di, sizeof( DOCINFO ) );
        di.cbSize = sizeof( DOCINFO );
        di.lpszDocName = L"Fax Stress Document";

        StartDoc( hDC, &di );


        if (DocCount) {

            PrintText( hDC, Documents[DocIdx].Text, Documents[DocIdx].TextSize );

            DocIdx += 1;
            if (DocIdx == DocCount) {
                DocIdx = 0;
            }

        } else {

            StartPage( hDC );

            x = 10;
            y = 50;

            pprintf( hDC, hFontBig, L"This is a TEST Fax!\n" );

            GetLocalTime( &Time );

            pprintf( hDC, hFontNormal, L"Document generated @ %02d:%02d:%02d.%03d\n",
                Time.wHour,
                Time.wMinute,
                Time.wSecond,
                Time.wMilliseconds
                );


            EndPage( hDC );

        }

        EndDoc( hDC );

        DeleteDC( hDC );

        Copies -= 1;

    }

    ClosePrinter( hPrinter );

    return TRUE;
}


LRESULT
StressWndProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    switch (message) {
        case WM_CREATE:
            return 0;

        case WM_COMMAND:
            switch (wParam) {
                case IDCANCEL:
                    SendMessage( hwnd, WM_CLOSE, 0, 0 );
                    break;

                case IDOK:
                    SendMessage( hwnd, WM_CLOSE, 0, 0 );
                    break;
            }
            return 0;

        case WM_DESTROY:
            PostQuitMessage( 0 );
            return 0;

        default:
            break;
    }

    return DefWindowProc( hwnd, message, wParam, lParam );
}


int
WINAPI
wWinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPWSTR    lpCmdLine,
    int       nShowCmd
    )
{
    int argc;
    LPWSTR *argv;
    int i;
    MSG msg;
    HWND hwnd;
    WNDCLASS wndclass;


    HeapInitialize(NULL,NULL,NULL,0);

    //
    // process any command line arguments
    //

    argv = CommandLineToArgvW( lpCmdLine, &argc );

    if (argv) {
        for (i=0; i<argc; i++) {
            if ((argv[i][0] == L'/') || (argv[i][0] == L'-')) {
                switch (towlower(argv[i][1])) {
                    case 'q':
                        NoGuiMode = TRUE;
                        break;

                    case 'c':
                        i += 1;
                        Copies = _wtoi( argv[i] );
                        break;

                    case 'p':
                        i += 1;
                        FaxPrinterName = argv[i];
                        break;

                    default:
                        break;
                }
            }
        }
    } else {
        argc = 0;
    }

    GetSettings();

    if (RecipCount == 0) {
        PopUpMsg( L"you must supply at least 1 recipient" );
        return FALSE;
    }

    if (UseExchange && DocCount == 0) {
        PopUpMsg( L"you must supply at least 1 document when using exchange stress" );
        return FALSE;
    }

    if ((!UseExchange) && (!FaxPrinterName)) {
        PopUpMsg( L"you must supply at fax printer name" );
        return FALSE;
    }

    if (!UseExchange) {
        SetFakeRecipientInfo();
    }

    if (NoGuiMode) {
        if (UseExchange) {
            ExchangeStress();
        } else {
            PrintStress();
        }
        if ((!UseExchange) && (!DontResetOnExit)) {
            RecipCount = 0;
            SetFakeRecipientInfo();
        }
        return 0;
    }

    InitCommonControls();

    wndclass.style          = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc    = StressWndProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = DLGWINDOWEXTRA;
    wndclass.hInstance      = hInstance;
    wndclass.hIcon          = LoadIcon( hInstance, MAKEINTRESOURCE(APPICON) );
    wndclass.hCursor        = LoadCursor (NULL, IDC_ARROW) ;
    wndclass.hbrBackground  = (HBRUSH) (COLOR_APPWORKSPACE);
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = L"FaxStress";

    RegisterClass( &wndclass );

    hwnd = CreateDialog(
        hInstance,
        MAKEINTRESOURCE(IDD_STRESS),
        0,
        StressWndProc
        );

    ShowWindow( hwnd, SW_SHOWNORMAL );

    while (GetMessage (&msg, NULL, 0, 0)) {
        if (!IsDialogMessage( hwnd, &msg )) {
            TranslateMessage (&msg) ;
            DispatchMessage (&msg) ;
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\server\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module contains various utility functions.

Author:

    Wesley Witt (wesw) 16-Jan-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop


#if DBG
extern HANDLE hLogFile;
extern LIST_ENTRY CritSecListHead;
#endif

typedef struct _STRING_TABLE {
    DWORD   ResourceId;
    DWORD   InternalId;
    LPTSTR  String;
} STRING_TABLE, *PSTRING_TABLE;


static STRING_TABLE StringTable[] =
{
    { IDS_DIALING,                    FPS_DIALING,             NULL },
    { IDS_SENDING,                    FPS_SENDING,             NULL },
    { IDS_RECEIVING,                  FPS_RECEIVING,           NULL },
    { IDS_COMPLETED,                  FPS_COMPLETED,           NULL },
    { IDS_HANDLED,                    FPS_HANDLED,             NULL },
    { IDS_BUSY,                       FPS_BUSY,                NULL },
    { IDS_NO_ANSWER,                  FPS_NO_ANSWER,           NULL },
    { IDS_BAD_ADDRESS,                FPS_BAD_ADDRESS,         NULL },
    { IDS_NO_DIAL_TONE,               FPS_NO_DIAL_TONE,        NULL },
    { IDS_DISCONNECTED,               FPS_DISCONNECTED,        NULL },
    { IDS_FATAL_ERROR,                FPS_FATAL_ERROR,         NULL },
    { IDS_NOT_FAX_CALL,               FPS_NOT_FAX_CALL,        NULL },
    { IDS_CALL_DELAYED,               FPS_CALL_DELAYED,        NULL },
    { IDS_CALL_BLACKLISTED,           FPS_CALL_BLACKLISTED,    NULL },
    { IDS_UNAVAILABLE,                FPS_UNAVAILABLE,         NULL },
    { IDS_AVAILABLE,                  FPS_AVAILABLE,           NULL },
    { IDS_ABORTING,                   FPS_ABORTING,            NULL },
    { IDS_ROUTING,                    FPS_ROUTING,             NULL },
    { IDS_INITIALIZING,               FPS_INITIALIZING,        NULL },
    { IDS_SENDFAILED,                 FPS_SENDFAILED,          NULL },
    { IDS_SENDRETRY,                  FPS_SENDRETRY,           NULL },
    { IDS_BLANKSTR,                   FPS_BLANKSTR,            NULL },
    { IDS_ROUTERETRY,                 FPS_ROUTERETRY,          NULL },
    { IDS_ANSWERED,                   FPS_ANSWERED,            NULL },
    { IDS_DR_SUBJECT,                 IDS_DR_SUBJECT,          NULL },
    { IDS_DR_FILENAME,                IDS_DR_FILENAME,         NULL },
    { IDS_NDR_SUBJECT,                IDS_NDR_SUBJECT,         NULL },
    { IDS_NDR_FILENAME,               IDS_NDR_FILENAME,        NULL },
    { IDS_POWERED_OFF_MODEM,          IDS_POWERED_OFF_MODEM,   NULL },
    { IDS_SERVICE_NAME,               IDS_SERVICE_NAME,        NULL },
    { IDS_NO_MAPI_LOGON,              IDS_NO_MAPI_LOGON,       NULL },
    { IDS_DEFAULT,                    IDS_DEFAULT,             NULL },
    { IDS_SERVER_NAME,                IDS_SERVER_NAME,         NULL },
    { IDS_FAX_LOG_CATEGORY_INIT_TERM, IDS_FAX_LOG_CATEGORY_INIT_TERM, NULL },
    { IDS_FAX_LOG_CATEGORY_OUTBOUND,  IDS_FAX_LOG_CATEGORY_OUTBOUND,  NULL },
    { IDS_FAX_LOG_CATEGORY_INBOUND,   IDS_FAX_LOG_CATEGORY_INBOUND,   NULL },
    { IDS_FAX_LOG_CATEGORY_UNKNOWN,   IDS_FAX_LOG_CATEGORY_UNKNOWN,   NULL },
    { IDS_SET_CONFIG,                 IDS_SET_CONFIG,          NULL },
    { IDS_NO_SEND_DEVICES,            IDS_NO_SEND_DEVICES,     NULL},
    { IDS_MODEM_PROVIDER_NAME,        IDS_MODEM_PROVIDER_NAME, NULL}

};

#define CountStringTable (sizeof(StringTable)/sizeof(STRING_TABLE))





VOID
InitializeStringTable(
    VOID
    )
{
    DWORD i;
    HINSTANCE hInstance;
    TCHAR Buffer[256];


    hInstance = GetModuleHandle(NULL);

    for (i=0; i<CountStringTable; i++) {

        if (LoadString(
            hInstance,
            StringTable[i].ResourceId,
            Buffer,
            sizeof(Buffer)/sizeof(TCHAR)
            )) {

            StringTable[i].String = (LPTSTR) MemAlloc( StringSize( Buffer ) );
            if (!StringTable[i].String) {
                StringTable[i].String = TEXT("");
            } else {
                _tcscpy( StringTable[i].String, Buffer );
            }

        } else {

            StringTable[i].String = TEXT("");

        }
    }
}


VOID
LogMessage(
    DWORD   FormatId,
    ...
    )

/*++

Routine Description:

    Prints a pre-formatted message to stdout.

Arguments:

    FormatId    - Resource id for a printf style format string
    ...         - all other arguments

Return Value:

    None.

--*/

{
    TCHAR       buf[1024];
    DWORD       Count;
    va_list     args;

    va_start( args, FormatId );

    Count = FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE,
        NULL,
        FormatId,
        0,
        buf,
        sizeof(buf),
        &args
        );

    va_end( args );

    DebugPrint(( TEXT("%s"), buf ));
}

LPTSTR
GetLastErrorText(
    DWORD ErrorCode
    )

/*++

Routine Description:

    Gets a string for a given WIN32 error code.

Arguments:

    ErrorCode   - WIN32 error code.

Return Value:

    Pointer to a string representing the ErrorCode.

--*/

{
    static TCHAR ErrorBuf[256];
    DWORD Count;

    Count = FormatMessage(
        FORMAT_MESSAGE_FROM_SYSTEM |FORMAT_MESSAGE_ARGUMENT_ARRAY,
        NULL,
        ErrorCode,
        LANG_NEUTRAL,
        ErrorBuf,
        sizeof(ErrorBuf),
        NULL
        );

    if (Count) {
        if (ErrorBuf[Count-1] == TEXT('\n')) {
            ErrorBuf[Count-1] = 0;
        }
        if ((Count>1) && (ErrorBuf[Count-2] == TEXT('\r'))) {
            ErrorBuf[Count-2] = 0;
        }
    }

    return ErrorBuf;
}

LPTSTR
GetString(
    DWORD InternalId
    )

/*++

Routine Description:

    Loads a resource string and returns a pointer to the string.
    The caller must free the memory.

Arguments:

    ResourceId      - resource string id

Return Value:

    pointer to the string

--*/

{
    DWORD i;

    for (i=0; i<CountStringTable; i++) {
        if (StringTable[i].InternalId == InternalId) {
            return StringTable[i].String;
        }
    }

    return NULL;
}


BOOL
InitializeFaxDirectories(
    VOID
    )
/*++

Routine Description:

    Initializes the directories that fax will use.
    We call into the shell to get the correct base path for fax directories and then tack on a relative path.

Arguments:

    None.

Return Value:

    TRUE if successful. modifies path globals

--*/
{
   if (!GetSpecialPath( CSIDL_COMMON_APPDATA, FaxDir ) ) {
       DebugPrint(( TEXT("Couldn't GetSpecialPath, ec = %d\n"), GetLastError() ));
       return FALSE;
   }

   wcscpy(FaxReceiveDir,FaxDir);
   wcscpy(FaxQueueDir,FaxDir);

   ConcatenatePaths(FaxDir, FAX_DIR);
   ConcatenatePaths(FaxReceiveDir, FAX_RECEIVE_DIR);
   ConcatenatePaths(FaxQueueDir, FAX_QUEUE_DIR);

//
// BugBug remove me
//
DebugPrint(( TEXT("FaxDir : %s\n"), FaxDir ));
DebugPrint(( TEXT("FaxReceiveDir : %s\n"), FaxReceiveDir ));
DebugPrint(( TEXT("FaxQueueDir : %s\n"), FaxQueueDir ));

   return TRUE;       

}


DWORDLONG
GenerateUniqueFileName(
    LPTSTR Directory,
    LPTSTR Extension,
    LPTSTR FileName,
    DWORD  FileNameSize
    )
{
    SYSTEMTIME SystemTime;
    FILETIME FileTime;
    DWORD i;
    WORD FatDate;
    WORD FatTime;
    TCHAR TempPath[MAX_PATH];
    
    FileName[0] = '\0';

    GetLocalTime( &SystemTime );
    SystemTimeToFileTime( &SystemTime, &FileTime );
    FileTimeToDosDateTime( &FileTime, &FatDate, &FatTime );

    if (!Directory) {
        GetTempPath( sizeof(TempPath)/sizeof(TCHAR), TempPath );
        Directory = TempPath;
    }

    if (Directory[_tcslen(Directory)-1] == TEXT('\\')) {
        Directory[_tcslen(Directory)-1] = 0;
    }

    if (!Extension) {
        Extension = TEXT("tif");
    }

    //
    // directory + '\' + 10 character filename + '.' + extension + NULL 
    // terminator
    //
    if ((_tcslen(Directory)+1+10+1+_tcslen(Extension)+1) > FileNameSize) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return 0;
    }

    for (i=0; i<256; i++) {

        HANDLE hFile = INVALID_HANDLE_VALUE;

        _stprintf(
            FileName,
            TEXT("%s\\%04x%04x%02x.%s"),
            Directory,
            FatTime,
            FatDate,
            i,
            Extension
            );

        hFile = CreateFile(
            FileName,
            GENERIC_WRITE,
            0,
            NULL,
            CREATE_NEW,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

        if (hFile == INVALID_HANDLE_VALUE) {

            DWORD Error = GetLastError();

            if (Error == ERROR_ALREADY_EXISTS || Error == ERROR_FILE_EXISTS) {

                continue;

            } else {

                return 0;

            }

        } else {

            CloseHandle( hFile );
            break;

        }
    }

    if (i == 256) {
        SetLastError( ERROR_TOO_MANY_OPEN_FILES );
        return 0;
    }

    return MAKELONGLONG( MAKELONG( FatDate, FatTime ), i );
}

DWORD
MessageBoxThread(
    IN PMESSAGEBOX_DATA MsgBox
    )
{
    DWORD Answer = (DWORD) MessageBox(
        NULL,
        MsgBox->Text,
        GetString( IDS_SERVICE_NAME ),
        MsgBox->Type | MB_SERVICE_NOTIFICATION
        );

    if (MsgBox->Response) {
        *MsgBox->Response = Answer;
    }

    MemFree( MsgBox->Text );
    MemFree( MsgBox );

    return 0;
}


BOOL
ServiceMessageBox(
    IN LPCTSTR MsgString,
    IN DWORD Type,
    IN BOOL UseThread,
    IN LPDWORD Response,
    IN ...
    )
{
    #define BUFSIZE 1024
    PMESSAGEBOX_DATA MsgBox;
    DWORD ThreadId;
    HANDLE hThread;
    DWORD Answer;
    LPTSTR buf;
    va_list arg_ptr;



    buf = (LPTSTR) MemAlloc( BUFSIZE );
    if (!buf) {
        return FALSE;
    }

    va_start( arg_ptr, Response );
    _vsntprintf( buf, BUFSIZE, MsgString, arg_ptr );
    va_end( arg_ptr );

    if (UseThread) {

        MsgBox = MemAlloc( sizeof(MESSAGEBOX_DATA) );
        if (!MsgBox) {
            MemFree( buf );
            return FALSE;
        }

        MsgBox->Text       = buf;
        MsgBox->Response   = Response;
        MsgBox->Type       = Type;

        hThread = CreateThread(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE) MessageBoxThread,
            (LPVOID) MsgBox,
            0,
            &ThreadId
            );

        if (!hThread) {
            MemFree( buf );
            MemFree( MsgBox );            
            return FALSE;
        }

        CloseHandle( hThread );

        return TRUE;
    }

    Answer = MessageBox(
        NULL,
        buf,
        GetString( IDS_SERVICE_NAME ),
        Type | MB_SERVICE_NOTIFICATION
        );
    if (Response) {
        *Response = Answer;
    }

    MemFree( buf );

    return TRUE;
}

BOOL
CreateFaxEvent(
    DWORD DeviceId,
    DWORD EventId,
    DWORD JobId
    )
{
    PFAX_EVENT FaxEvent;

    Assert(EventId != 0);

    FaxEvent = MemAlloc( sizeof(FAX_EVENT) );
    if (!FaxEvent) {
        return FALSE;
    }

    FaxEvent->SizeOfStruct = sizeof(FAX_EVENT);
    GetSystemTimeAsFileTime( &FaxEvent->TimeStamp );
    FaxEvent->EventId = EventId;
    FaxEvent->DeviceId = DeviceId;
    FaxEvent->JobId = JobId;

    PostQueuedCompletionStatus(
        StatusCompletionPortHandle,
        sizeof(FAX_EVENT),
        EVENT_COMPLETION_KEY,
        (LPOVERLAPPED) FaxEvent
        );

    return TRUE;
}


DWORD
MapStatusIdToEventId(
    DWORD StatusId
    )
{
    DWORD EventId = 0;

    switch( StatusId ) {
        case FS_INITIALIZING:
            EventId = FEI_INITIALIZING;
            break;
        case FS_DIALING:              
            EventId = FEI_DIALING;
            break;
        case FS_TRANSMITTING:         
            EventId = FEI_SENDING;
            break;
        case FS_RECEIVING:            
            EventId = FEI_RECEIVING;
            break;
        case FS_COMPLETED:
            EventId = FEI_COMPLETED;
            break;
        case FS_HANDLED:        
            EventId = FEI_HANDLED;
            break;    
        case FS_LINE_UNAVAILABLE:     
            EventId = FEI_LINE_UNAVAILABLE;
            break;
        case FS_BUSY:                 
            EventId = FEI_BUSY;
            break;
        case FS_NO_ANSWER:            
            EventId = FEI_NO_ANSWER;
            break;
        case FS_BAD_ADDRESS:          
            EventId = FEI_BAD_ADDRESS;
            break;
        case FS_NO_DIAL_TONE:         
            EventId = FEI_NO_DIAL_TONE;
            break;
        case FS_DISCONNECTED:         
            EventId = FEI_DISCONNECTED;
            break;
        case FS_FATAL_ERROR:          
            EventId = FEI_FATAL_ERROR;
            break;
        case FS_NOT_FAX_CALL:         
            EventId = FEI_NOT_FAX_CALL;
            break;
        case FS_CALL_DELAYED:         
            EventId = FEI_CALL_DELAYED;
            break;
        case FS_CALL_BLACKLISTED:     
            EventId = FEI_CALL_BLACKLISTED;
            break;
        case FS_USER_ABORT:           
            EventId = FEI_ABORTING;
            break;
        case FS_ANSWERED:             
             EventId = FEI_ANSWERED;
            break;
                                
    }

    return EventId;

}


VOID
FaxLogSend(
    PFAX_SEND_ITEM  FaxSendItem,
    BOOL Rslt,
    PFAX_DEV_STATUS FaxStatus,
    BOOL Retrying
    )
/*++

Routine Description:

    Log a fax send event.

Arguments:

    FaxSendItem - Pointer to FAX_SEND_ITEM structure for this fax.
    Rslt        - BOOL returned from device provider.  TRUE means fax was sent.
    FaxStatus   - Pointer to FAX_DEV_STATUS for this fax.
    PrinterName - Name of fax printer.
    Retrying    - TRUE if another send attempt will be made.


Return Value:

    VOID

--*/


{
    DWORD Level;
    DWORD FormatId;
    TCHAR PageCountStr[64];
    TCHAR TimeStr[128];
    BOOL fLog = TRUE;

    FormatElapsedTimeStr(
        (FILETIME*)&FaxSendItem->JobEntry->ElapsedTime,
        TimeStr,
        128
        );
    _ltot((LONG) FaxStatus->PageCount, PageCountStr, 10);
    if (Rslt) {
        FaxLog(
            FAXLOG_CATEGORY_OUTBOUND,
            FAXLOG_LEVEL_MED,
            10,
            MSG_FAX_SEND_SUCCESS,
            FaxSendItem->SenderName,
            FaxSendItem->BillingCode,
            FaxSendItem->SenderCompany,
            FaxSendItem->SenderDept,
            FaxSendItem->RecipientName,
            FaxSendItem->JobEntry->PhoneNumber,
            FaxStatus->CSI,
            PageCountStr,
            TimeStr,
            FaxSendItem->JobEntry->LineInfo->DeviceName
            );
    }
    else {
        switch (FaxStatus->StatusId) {
        case FS_FATAL_ERROR:
            Level = Retrying ? FAXLOG_LEVEL_MED : FAXLOG_LEVEL_MIN;
            FormatId = Retrying ? MSG_FAX_SEND_FATAL_RETRY : MSG_FAX_SEND_FATAL_ABORT;
            break;
        case FS_NO_DIAL_TONE:
            Level = Retrying ? FAXLOG_LEVEL_MED : FAXLOG_LEVEL_MIN;
            FormatId = Retrying ? MSG_FAX_SEND_NDT_RETRY : MSG_FAX_SEND_NDT_ABORT;
            break;
        case FS_NO_ANSWER:
            Level = Retrying ? FAXLOG_LEVEL_MED : FAXLOG_LEVEL_MIN;
            FormatId = Retrying ? MSG_FAX_SEND_NA_RETRY : MSG_FAX_SEND_NA_ABORT;
            break;
        case FS_DISCONNECTED:
            Level = Retrying ? FAXLOG_LEVEL_MED : FAXLOG_LEVEL_MIN;
            FormatId = Retrying ? MSG_FAX_SEND_INTERRUPT_RETRY : MSG_FAX_SEND_INTERRUPT_ABORT;
            break;
        case FS_NOT_FAX_CALL:
            Level = Retrying ? FAXLOG_LEVEL_MED : FAXLOG_LEVEL_MIN;
            FormatId = Retrying ? MSG_FAX_SEND_NOTFAX_RETRY : MSG_FAX_SEND_NOTFAX_ABORT;
            break;
        case FS_BUSY:
            Level = Retrying ? FAXLOG_LEVEL_MAX : FAXLOG_LEVEL_MIN;
            FormatId = Retrying ? MSG_FAX_SEND_BUSY_RETRY : MSG_FAX_SEND_BUSY_ABORT;
            break;
        case FS_USER_ABORT:
            Level = FAXLOG_LEVEL_MED;
            FormatId = MSG_FAX_SEND_USER_ABORT;
            break;
        default:
            fLog = FALSE;
        }

        if(fLog) {
            FaxLog(
                FAXLOG_CATEGORY_OUTBOUND,
                Level,
                7,
                FormatId,
                FaxSendItem->SenderName,
                FaxSendItem->BillingCode,
                FaxSendItem->SenderCompany,
                FaxSendItem->SenderDept,
                FaxSendItem->RecipientName,
                FaxSendItem->JobEntry->PhoneNumber,
                FaxSendItem->JobEntry->LineInfo->DeviceName
                );
        }
    }
}


BOOL
SetServiceStart(
    LPTSTR ServiceName,
    DWORD StartType
    )
{
    BOOL            rVal = FALSE;
    SC_HANDLE       hSvcMgr;
    SC_HANDLE       hService;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        DebugPrint(( TEXT("could not open service manager: error code = %u"), GetLastError() ));
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        DebugPrint((
            TEXT("could not open the %s service: error code = %u"),
            ServiceName,
            GetLastError()
            ));
        goto exit;
    }


    if (!ChangeServiceConfig(
        hService,                        // handle to service
        SERVICE_NO_CHANGE,               // type of service
        StartType,                       // when to start service
        SERVICE_NO_CHANGE,               // severity if service fails to start
        NULL,                            // pointer to service binary file name
        NULL,                            // pointer to load ordering group name
        NULL,                            // pointer to variable to get tag identifier
        NULL,                            // pointer to array of dependency names
        NULL,                            // pointer to account name of service
        NULL,                            // pointer to password for service account
        NULL                             // pointer to display name
        ))
    {
        DebugPrint(( TEXT("could not open change service configuration, ec=%d"), GetLastError() ));
        goto exit;
    }

    rVal = TRUE;

exit:
    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}



DWORD MyGetFileSize(LPCTSTR FileName)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD sizelow=0, sizehigh=0;

    hFile = CreateFile(
        FileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );

    if (hFile == INVALID_HANDLE_VALUE) {
        return 0;
    }

    sizelow = GetFileSize(hFile,&sizehigh);
 
    if (sizehigh == 0xFFFFFFFFF) {
        sizelow = 0;
    } else if (sizehigh!=0) {
        sizelow=0xFFFFFFFF;
    }

    CloseHandle(hFile);

    return sizelow;
}

extern CRITICAL_SECTION CsClients;
extern CRITICAL_SECTION CsHandleTable;
extern CRITICAL_SECTION CsJob;
extern CRITICAL_SECTION CsLine;
extern CRITICAL_SECTION CsPerfCounters;
extern CRITICAL_SECTION CsQueue;
extern CRITICAL_SECTION CsRouting;
LPCWSTR szCsClients = L"CsClients";
LPCWSTR szCsHandleTable = L"CsHandleTable";
LPCWSTR szCsJob = L"CsJob";
LPCWSTR szCsLine = L"CsLine";
LPCWSTR szCsPerfCounters = L"CsPerfCounters";
LPCWSTR szCsQueue = L"CsQueue";
LPCWSTR szCsRouting = L"CsRouting";
LPCWSTR szCsUnknown = L"Other CS";

LPCWSTR GetSzCs(
    LPCRITICAL_SECTION cs
    )
{


    
    if (cs == &CsClients) {
        return szCsClients;
    } else if (cs == &CsHandleTable) {
        return szCsHandleTable;
    } else if (cs == &CsJob) {
        return szCsJob;
    } else if (cs == &CsLine) {
        return szCsLine;
    } else if (cs == &CsPerfCounters) {
        return szCsPerfCounters;
    } else if (cs == &CsQueue) {
        return szCsQueue;
    } else if (cs == &CsRouting) {
        return szCsRouting;
    }

    return szCsUnknown;

       
}

#if DBG
VOID AppendToLogFile(
    LPWSTR String
    )
{
    DWORD BytesWritten;
    LPSTR AnsiBuffer = UnicodeStringToAnsiString( String );

    if (hLogFile != INVALID_HANDLE_VALUE) {
        WriteFile(hLogFile,(LPBYTE)AnsiBuffer,strlen(AnsiBuffer) * sizeof(CHAR),&BytesWritten,NULL);
    }

    MemFree(AnsiBuffer);

}

VOID AppendFuncToLogFile(
    LPCRITICAL_SECTION cs,
    LPTSTR szFunc,
    DWORD line,
    LPTSTR file,
    PDBGCRITSEC CritSec
    )
{
    WCHAR Buffer[300];
    LPWSTR FileName;
    LPCWSTR szcs = GetSzCs(cs);

    FileName = wcsrchr(file,'\\');
    if (!FileName) {
        FileName = TEXT("Unknown  ");
    } else {
        FileName += 1;
    }
    if (CritSec) {
        wsprintf(Buffer,TEXT("%d\t%x\t%s\t%s\t%s\t%d\t%d\r\n"),
                 GetTickCount(),
                 (PULONG_PTR)cs,
                 szcs,
                 szFunc,
                 FileName,
                 line,
                 CritSec->ReleasedTime - CritSec->AquiredTime);
    } else {
        wsprintf(Buffer,TEXT("%d\t%x\t%s\t%s\t%s\t%d\r\n"),GetTickCount(),(PULONG_PTR)cs,szcs,szFunc, FileName,line);
    }
    
    AppendToLogFile( Buffer );
    
    return;

}

VOID pEnterCriticalSection(
    LPCRITICAL_SECTION cs,
    DWORD line,
    LPTSTR file
    )
{
    extern CRITICAL_SECTION CsJob;
    extern CRITICAL_SECTION CsQueue;
    //PDBGCRITSEC CritSec;

    PDBGCRITSEC pCritSec = MemAlloc(sizeof(DBGCRITSEC));
    pCritSec->CritSecAddr = (ULONG_PTR) cs;
    pCritSec->AquiredTime = GetTickCount();
    pCritSec->ThreadId = GetCurrentThreadId();

    InsertHeadList( &CritSecListHead, &pCritSec->ListEntry );

    AppendFuncToLogFile(cs,TEXT("EnterCriticalSection"), line, file, NULL );
    
#ifdef EnterCriticalSection
    #undef EnterCriticalSection
    //
    // check ordering of threads. ALWAYS aquire CsJob before aquiring CsQueue!!!
    //
    if ((LPCRITICAL_SECTION)cs == (LPCRITICAL_SECTION)&CsQueue) {
        if ((DWORD)GetCurrentThreadId() != PtrToUlong(CsJob.OwningThread)) {
            WCHAR DebugBuf[300];
            wsprintf(DebugBuf, TEXT("%d : Attempting to aquire CsQueue (thread %x) without aquiring CsJob (thread %x, lock count %x) first, possible deadlock!\r\n"),
                         GetTickCount(),
                         GetCurrentThreadId(),
                         CsJob.OwningThread,
                         CsJob.LockCount );
            AppendToLogFile( DebugBuf );
        }
    }
    EnterCriticalSection(cs);
#endif
}

VOID pLeaveCriticalSection(
    LPCRITICAL_SECTION cs,
    DWORD line,
    LPTSTR file
    )
{
    PDBGCRITSEC CritSec;
    PLIST_ENTRY Next = CritSecListHead.Flink;
    
    while ((ULONG_PTR)Next != (ULONG_PTR) &CritSecListHead) {
        CritSec = CONTAINING_RECORD( Next, DBGCRITSEC, ListEntry );
        if ((ULONG_PTR)CritSec->CritSecAddr == (ULONG_PTR) cs &&
            ( GetCurrentThreadId() == CritSec->ThreadId ) ) {
            CritSec->ReleasedTime = GetTickCount();
            break;
        }
        Next = Next->Flink;
    }    

    AppendFuncToLogFile(cs,TEXT("LeaveCriticalSection"),line, file, CritSec );

    if (CritSec) {
        RemoveEntryList( &CritSec->ListEntry );
        MemFree( CritSec );
    }

#ifdef LeaveCriticalSection
    #undef LeaveCriticalSection
    LeaveCriticalSection(cs);
#endif

}

VOID pInitializeCriticalSection(
    LPCRITICAL_SECTION cs,
    DWORD line,
    LPTSTR file
    ) 
{
    
    AppendFuncToLogFile(cs,TEXT("InitializeCriticalSection"),line, file, NULL);

    

#ifdef InitializeCriticalSection
    #undef InitializeCriticalSection
    InitializeCriticalSection(cs);
#endif

}

#endif


DWORD
ValidateTiffFile(
    LPCWSTR TifFileName
    )
{

    HANDLE hTiff;
    DWORD rc = ERROR_SUCCESS;
    TIFF_INFO TiffInfo;

    //
    // impersonate the client
    //
    if (RpcImpersonateClient(NULL) != RPC_S_OK) {
        rc = GetLastError();
        goto e0;
    }

    //
    // make sure the client can see the file
    //
    if (GetFileAttributes(TifFileName) == 0xFFFFFFFF) {
        rc = GetLastError();
        goto e1;
    }

    //
    // make sure the client has read-write access to the file
    //
    hTiff = TiffOpen( (LPWSTR)TifFileName, &TiffInfo, FALSE, FILLORDER_MSB2LSB );
    if (!hTiff) {
        rc = GetLastError();
        goto e1;
    }
    
    TiffClose( hTiff );
e1:
    RpcRevertToSelf();
e0:
    return rc;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\server\tapidbg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tapidbg.c

Abstract:

    This module provides tapi specific debug support

Author:

    Wesley Witt (wesw) 22-Jan-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop


typedef struct _LOOKUP {
    DWORD   dwVal;
    LPTSTR   lpszVal;
} LOOKUP, *PLOOKUP;

typedef struct _MSGTYPE {
    DWORD   MsgId;
    BOOL    LineMsg;
    LPTSTR  Text;
} MSGTYPE, *PMSGTYPE;


MSGTYPE  aMsgs[] =
{
    { LINE_ADDRESSSTATE,             TRUE,     TEXT("LINE_ADDRESSSTATE")         },
    { LINE_AGENTSPECIFIC,            TRUE,     TEXT("LINE_AGENTSPECIFIC")        },
    { LINE_AGENTSTATUS,              TRUE,     TEXT("LINE_AGENTSTATUS")          },
    { LINE_APPNEWCALL,               TRUE,     TEXT("LINE_APPNEWCALL")           },
    { LINE_CALLINFO,                 TRUE,     TEXT("LINE_CALLINFO")             },
    { LINE_CALLSTATE,                TRUE,     TEXT("LINE_CALLSTATE")            },
    { LINE_CLOSE,                    TRUE,     TEXT("LINE_CLOSE")                },
    { LINE_CREATE,                   TRUE,     TEXT("LINE_CREATE")               },
    { LINE_CREATE,                   TRUE,     TEXT("LINE_CREATE")               },
    { LINE_DEVSPECIFIC,              TRUE,     TEXT("LINE_DEVSPECIFIC")          },
    { LINE_DEVSPECIFICFEATURE,       TRUE,     TEXT("LINE_DEVSPECIFICFEATURE")   },
    { LINE_GATHERDIGITS,             TRUE,     TEXT("LINE_GATHERDIGITS")         },
    { LINE_GENERATE,                 TRUE,     TEXT("LINE_GENERATE")             },
    { LINE_LINEDEVSTATE,             TRUE,     TEXT("LINE_LINEDEVSTATE")         },
    { LINE_MONITORDIGITS,            TRUE,     TEXT("LINE_MONITORDIGITS")        },
    { LINE_MONITORMEDIA,             TRUE,     TEXT("LINE_MONITORMEDIA")         },
    { LINE_MONITORTONE,              TRUE,     TEXT("LINE_MONITORTONE")          },
    { LINE_PROXYREQUEST,             TRUE,     TEXT("LINE_PROXYREQUEST")         },
    { LINE_REMOVE,                   TRUE,     TEXT("LINE_REMOVE")               },
    { LINE_REPLY,                    TRUE,     TEXT("LINE_REPLY")                },
    { LINE_REQUEST,                  TRUE,     TEXT("LINE_REQUEST")              },
    { PHONE_BUTTON,                  FALSE,    TEXT("PHONE_BUTTON")              },
    { PHONE_CLOSE,                   FALSE,    TEXT("PHONE_CLOSE")               },
    { PHONE_CREATE,                  FALSE,    TEXT("PHONE_CREATE")              },
    { PHONE_DEVSPECIFIC,             FALSE,    TEXT("PHONE_DEVSPECIFIC")         },
    { PHONE_REMOVE,                  FALSE,    TEXT("PHONE_REMOVE")              },
    { PHONE_REPLY,                   FALSE,    TEXT("PHONE_REPLY")               },
    { PHONE_STATE,                   FALSE,    TEXT("PHONE_STATE")               },
    { 0xffffffff,                    FALSE,    NULL                              }
};

LOOKUP  aAddressStates[] =
{
    { LINEADDRESSSTATE_OTHER           ,TEXT("OTHER")              },
    { LINEADDRESSSTATE_DEVSPECIFIC     ,TEXT("DEVSPECIFIC")        },
    { LINEADDRESSSTATE_INUSEZERO       ,TEXT("INUSEZERO")          },
    { LINEADDRESSSTATE_INUSEONE        ,TEXT("INUSEONE")           },
    { LINEADDRESSSTATE_INUSEMANY       ,TEXT("INUSEMANY")          },
    { LINEADDRESSSTATE_NUMCALLS        ,TEXT("NUMCALLS")           },
    { LINEADDRESSSTATE_FORWARD         ,TEXT("FORWARD")            },
    { LINEADDRESSSTATE_TERMINALS       ,TEXT("TERMINALS")          },
    { LINEADDRESSSTATE_CAPSCHANGE      ,TEXT("CAPSCHANGE")         },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aBearerModes[] =
{
    { LINEBEARERMODE_VOICE             ,TEXT("VOICE")              },
    { LINEBEARERMODE_SPEECH            ,TEXT("SPEECH")             },
    { LINEBEARERMODE_MULTIUSE          ,TEXT("MULTIUSE")           },
    { LINEBEARERMODE_DATA              ,TEXT("DATA")               },
    { LINEBEARERMODE_ALTSPEECHDATA     ,TEXT("ALTSPEECHDATA")      },
    { LINEBEARERMODE_NONCALLSIGNALING  ,TEXT("NONCALLSIGNALING")   },
    { LINEBEARERMODE_PASSTHROUGH       ,TEXT("PASSTHROUGH")        },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aButtonModes[] =
{
    { PHONEBUTTONMODE_DUMMY            ,TEXT("DUMMY")              },
    { PHONEBUTTONMODE_CALL             ,TEXT("CALL")               },
    { PHONEBUTTONMODE_FEATURE          ,TEXT("FEATURE")            },
    { PHONEBUTTONMODE_KEYPAD           ,TEXT("KEYPAD")             },
    { PHONEBUTTONMODE_LOCAL            ,TEXT("LOCAL")              },
    { PHONEBUTTONMODE_DISPLAY          ,TEXT("DISPLAY")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aButtonStates[] =
{
    { PHONEBUTTONSTATE_UP              ,TEXT("UP")                 },
    { PHONEBUTTONSTATE_DOWN            ,TEXT("DOWN")               },
    { PHONEBUTTONSTATE_UNKNOWN         ,TEXT("UNKNOWN")            },
    { PHONEBUTTONSTATE_UNAVAIL         ,TEXT("UNAVAIL")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aCallInfoStates[] =
{
    { LINECALLINFOSTATE_OTHER          ,TEXT("OTHER")              },
    { LINECALLINFOSTATE_DEVSPECIFIC    ,TEXT("DEVSPECIFIC")        },
    { LINECALLINFOSTATE_BEARERMODE     ,TEXT("BEARERMODE")         },
    { LINECALLINFOSTATE_RATE           ,TEXT("RATE")               },
    { LINECALLINFOSTATE_MEDIAMODE      ,TEXT("MEDIAMODE")          },
    { LINECALLINFOSTATE_APPSPECIFIC    ,TEXT("APPSPECIFIC")        },
    { LINECALLINFOSTATE_CALLID         ,TEXT("CALLID")             },
    { LINECALLINFOSTATE_RELATEDCALLID  ,TEXT("RELATEDCALLID")      },
    { LINECALLINFOSTATE_ORIGIN         ,TEXT("ORIGIN")             },
    { LINECALLINFOSTATE_REASON         ,TEXT("REASON")             },
    { LINECALLINFOSTATE_COMPLETIONID   ,TEXT("COMPLETIONID")       },
    { LINECALLINFOSTATE_NUMOWNERINCR   ,TEXT("NUMOWNERINCR")       },
    { LINECALLINFOSTATE_NUMOWNERDECR   ,TEXT("NUMOWNERDECR")       },
    { LINECALLINFOSTATE_NUMMONITORS    ,TEXT("NUMMONITORS")        },
    { LINECALLINFOSTATE_TRUNK          ,TEXT("TRUNK")              },
    { LINECALLINFOSTATE_CALLERID       ,TEXT("CALLERID")           },
    { LINECALLINFOSTATE_CALLEDID       ,TEXT("CALLEDID")           },
    { LINECALLINFOSTATE_CONNECTEDID    ,TEXT("CONNECTEDID")        },
    { LINECALLINFOSTATE_REDIRECTIONID  ,TEXT("REDIRECTIONID")      },
    { LINECALLINFOSTATE_REDIRECTINGID  ,TEXT("REDIRECTINGID")      },
    { LINECALLINFOSTATE_DISPLAY        ,TEXT("DISPLAY")            },
    { LINECALLINFOSTATE_USERUSERINFO   ,TEXT("USERUSERINFO")       },
    { LINECALLINFOSTATE_HIGHLEVELCOMP  ,TEXT("HIGHLEVELCOMP")      },
    { LINECALLINFOSTATE_LOWLEVELCOMP   ,TEXT("LOWLEVELCOMP")       },
    { LINECALLINFOSTATE_CHARGINGINFO   ,TEXT("CHARGINGINFO")       },
    { LINECALLINFOSTATE_TERMINAL       ,TEXT("TERMINAL")           },
    { LINECALLINFOSTATE_DIALPARAMS     ,TEXT("DIALPARAMS")         },
    { LINECALLINFOSTATE_MONITORMODES   ,TEXT("MONITORMODES")       },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aCallSelects[] =
{
    { LINECALLSELECT_LINE              ,TEXT("LINE")               },
    { LINECALLSELECT_ADDRESS           ,TEXT("ADDRESS")            },
    { LINECALLSELECT_CALL              ,TEXT("CALL")               },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aCallStates[] =
{
    { LINECALLSTATE_IDLE               ,TEXT("IDLE")               },
    { LINECALLSTATE_OFFERING           ,TEXT("OFFERING")           },
    { LINECALLSTATE_ACCEPTED           ,TEXT("ACCEPTED")           },
    { LINECALLSTATE_DIALTONE           ,TEXT("DIALTONE")           },
    { LINECALLSTATE_DIALING            ,TEXT("DIALING")            },
    { LINECALLSTATE_RINGBACK           ,TEXT("RINGBACK")           },
    { LINECALLSTATE_BUSY               ,TEXT("BUSY")               },
    { LINECALLSTATE_SPECIALINFO        ,TEXT("SPECIALINFO")        },
    { LINECALLSTATE_CONNECTED          ,TEXT("CONNECTED")          },
    { LINECALLSTATE_PROCEEDING         ,TEXT("PROCEEDING")         },
    { LINECALLSTATE_ONHOLD             ,TEXT("ONHOLD")             },
    { LINECALLSTATE_CONFERENCED        ,TEXT("CONFERENCED")        },
    { LINECALLSTATE_ONHOLDPENDCONF     ,TEXT("ONHOLDPENDCONF")     },
    { LINECALLSTATE_ONHOLDPENDTRANSFER ,TEXT("ONHOLDPENDTRANSFER") },
    { LINECALLSTATE_DISCONNECTED       ,TEXT("DISCONNECTED")       },
    { LINECALLSTATE_UNKNOWN            ,TEXT("UNKNOWN")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aDigitModes[] =
{
    { LINEDIGITMODE_PULSE              ,TEXT("PULSE")              },
    { LINEDIGITMODE_DTMF               ,TEXT("DTMF")               },
    { LINEDIGITMODE_DTMFEND            ,TEXT("DTMFEND")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aHookSwitchDevs[] =
{
    { PHONEHOOKSWITCHDEV_HANDSET       ,TEXT("HANDSET")            },
    { PHONEHOOKSWITCHDEV_SPEAKER       ,TEXT("SPEAKER")            },
    { PHONEHOOKSWITCHDEV_HEADSET       ,TEXT("HEADSET")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aHookSwitchModes[] =
{
    { PHONEHOOKSWITCHMODE_ONHOOK       ,TEXT("ONHOOK")             },
    { PHONEHOOKSWITCHMODE_MIC          ,TEXT("MIC")                },
    { PHONEHOOKSWITCHMODE_SPEAKER      ,TEXT("SPEAKER")            },
    { PHONEHOOKSWITCHMODE_MICSPEAKER   ,TEXT("MICSPEAKER")         },
    { PHONEHOOKSWITCHMODE_UNKNOWN      ,TEXT("UNKNOWN")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aLampModes[] =
{
    { PHONELAMPMODE_DUMMY              ,TEXT("DUMMY")              },
    { PHONELAMPMODE_OFF                ,TEXT("OFF")                },
    { PHONELAMPMODE_STEADY             ,TEXT("STEADY")             },
    { PHONELAMPMODE_WINK               ,TEXT("WINK")               },
    { PHONELAMPMODE_FLASH              ,TEXT("FLASH")              },
    { PHONELAMPMODE_FLUTTER            ,TEXT("FLUTTER")            },
    { PHONELAMPMODE_BROKENFLUTTER      ,TEXT("BROKENFLUTTER")      },
    { PHONELAMPMODE_UNKNOWN            ,TEXT("UNKNOWN")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aLineStates[] =
{
    { LINEDEVSTATE_OTHER               ,TEXT("OTHER")              },
    { LINEDEVSTATE_RINGING             ,TEXT("RINGING")            },
    { LINEDEVSTATE_CONNECTED           ,TEXT("CONNECTED")          },
    { LINEDEVSTATE_DISCONNECTED        ,TEXT("DISCONNECTED")       },
    { LINEDEVSTATE_MSGWAITON           ,TEXT("MSGWAITON")          },
    { LINEDEVSTATE_MSGWAITOFF          ,TEXT("MSGWAITOFF")         },
    { LINEDEVSTATE_INSERVICE           ,TEXT("INSERVICE")          },
    { LINEDEVSTATE_OUTOFSERVICE        ,TEXT("OUTOFSERVICE")       },
    { LINEDEVSTATE_MAINTENANCE         ,TEXT("MAINTENANCE")        },
    { LINEDEVSTATE_OPEN                ,TEXT("OPEN")               },
    { LINEDEVSTATE_CLOSE               ,TEXT("CLOSE")              },
    { LINEDEVSTATE_NUMCALLS            ,TEXT("NUMCALLS")           },
    { LINEDEVSTATE_NUMCOMPLETIONS      ,TEXT("NUMCOMPLETIONS")     },
    { LINEDEVSTATE_TERMINALS           ,TEXT("TERMINALS")          },
    { LINEDEVSTATE_ROAMMODE            ,TEXT("ROAMMODE")           },
    { LINEDEVSTATE_BATTERY             ,TEXT("BATTERY")            },
    { LINEDEVSTATE_SIGNAL              ,TEXT("SIGNAL")             },
    { LINEDEVSTATE_DEVSPECIFIC         ,TEXT("DEVSPECIFIC")        },
    { LINEDEVSTATE_REINIT              ,TEXT("REINIT")             },
    { LINEDEVSTATE_LOCK                ,TEXT("LOCK")               },
    { LINEDEVSTATE_CAPSCHANGE          ,TEXT("CAPSCHANGE")         },
    { LINEDEVSTATE_CONFIGCHANGE        ,TEXT("CONFIGCHANGE")       },
    { LINEDEVSTATE_TRANSLATECHANGE     ,TEXT("TRANSLATECHANGE")    },
    { LINEDEVSTATE_COMPLCANCEL         ,TEXT("COMPLCANCEL")        },
    { LINEDEVSTATE_REMOVED             ,TEXT("REMOVED")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aMediaModes[] =
{
    { LINEMEDIAMODE_UNKNOWN            ,TEXT("UNKNOWN")            },
    { LINEMEDIAMODE_INTERACTIVEVOICE   ,TEXT("INTERACTIVEVOICE")   },
    { LINEMEDIAMODE_AUTOMATEDVOICE     ,TEXT("AUTOMATEDVOICE")     },
    { LINEMEDIAMODE_DATAMODEM          ,TEXT("DATAMODEM")          },
    { LINEMEDIAMODE_G3FAX              ,TEXT("G3FAX")              },
    { LINEMEDIAMODE_TDD                ,TEXT("TDD")                },
    { LINEMEDIAMODE_G4FAX              ,TEXT("G4FAX")              },
    { LINEMEDIAMODE_DIGITALDATA        ,TEXT("DIGITALDATA")        },
    { LINEMEDIAMODE_TELETEX            ,TEXT("TELETEX")            },
    { LINEMEDIAMODE_VIDEOTEX           ,TEXT("VIDEOTEX")           },
    { LINEMEDIAMODE_TELEX              ,TEXT("TELEX")              },
    { LINEMEDIAMODE_MIXED              ,TEXT("MIXED")              },
    { LINEMEDIAMODE_ADSI               ,TEXT("ADSI")               },
    { LINEMEDIAMODE_VOICEVIEW          ,TEXT("VOICEVIEW")          },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aPhoneStates[] =
{
    { PHONESTATE_OTHER                 ,TEXT("OTHER")              },
    { PHONESTATE_CONNECTED             ,TEXT("CONNECTED")          },
    { PHONESTATE_DISCONNECTED          ,TEXT("DISCONNECTED")       },
    { PHONESTATE_OWNER                 ,TEXT("OWNER")              },
    { PHONESTATE_MONITORS              ,TEXT("MONITORS")           },
    { PHONESTATE_DISPLAY               ,TEXT("DISPLAY")            },
    { PHONESTATE_LAMP                  ,TEXT("LAMP")               },
    { PHONESTATE_RINGMODE              ,TEXT("RINGMODE")           },
    { PHONESTATE_RINGVOLUME            ,TEXT("RINGVOLUME")         },
    { PHONESTATE_HANDSETHOOKSWITCH     ,TEXT("HANDSETHOOKSWITCH")  },
    { PHONESTATE_HANDSETVOLUME         ,TEXT("HANDSETVOLUME")      },
    { PHONESTATE_HANDSETGAIN           ,TEXT("HANDSETGAIN")        },
    { PHONESTATE_SPEAKERHOOKSWITCH     ,TEXT("SPEAKERHOOKSWITCH")  },
    { PHONESTATE_SPEAKERVOLUME         ,TEXT("SPEAKERVOLUME")      },
    { PHONESTATE_SPEAKERGAIN           ,TEXT("SPEAKERGAIN")        },
    { PHONESTATE_HEADSETHOOKSWITCH     ,TEXT("HEADSETHOOKSWITCH")  },
    { PHONESTATE_HEADSETVOLUME         ,TEXT("HEADSETVOLUME")      },
    { PHONESTATE_HEADSETGAIN           ,TEXT("HEADSETGAIN")        },
    { PHONESTATE_SUSPEND               ,TEXT("SUSPEND")            },
    { PHONESTATE_RESUME                ,TEXT("RESUME")             },
    { PHONESTATE_DEVSPECIFIC           ,TEXT("DEVSPECIFIC")        },
    { PHONESTATE_REINIT                ,TEXT("REINIT")             },
    { PHONESTATE_CAPSCHANGE            ,TEXT("CAPSCHANGE")         },
    { PHONESTATE_REMOVED               ,TEXT("REMOVED")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aTerminalModes[] =
{
    { LINETERMMODE_BUTTONS             ,TEXT("BUTTONS")            },
    { LINETERMMODE_LAMPS               ,TEXT("LAMPS")              },
    { LINETERMMODE_DISPLAY             ,TEXT("DISPLAY")            },
    { LINETERMMODE_RINGER              ,TEXT("RINGER")             },
    { LINETERMMODE_HOOKSWITCH          ,TEXT("HOOKSWITCH")         },
    { LINETERMMODE_MEDIATOLINE         ,TEXT("MEDIATOLINE")        },
    { LINETERMMODE_MEDIAFROMLINE       ,TEXT("MEDIAFROMLINE")      },
    { LINETERMMODE_MEDIABIDIRECT       ,TEXT("MEDIABIDIRECT")      },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aToneModes[] =
{
    { LINETONEMODE_CUSTOM              ,TEXT("CUSTOM")             },
    { LINETONEMODE_RINGBACK            ,TEXT("RINGBACK")           },
    { LINETONEMODE_BUSY                ,TEXT("BUSY")               },
    { LINETONEMODE_BEEP                ,TEXT("BEEP")               },
    { LINETONEMODE_BILLING             ,TEXT("BILLING")            },
    { 0xffffffff                       ,TEXT("")                   }
};

LOOKUP  aTransferModes[] =
{
    { LINETRANSFERMODE_TRANSFER        ,TEXT("TRANSFER")           },
    { LINETRANSFERMODE_CONFERENCE      ,TEXT("CONFERENCE")         },
    { 0xffffffff                       ,TEXT("")                   }
};


LPTSTR
GetFlags(
    DWORD_PTR dwFlags,
    PLOOKUP   pLookup
    )
{
    int i;
    TCHAR buf[256];
    LPTSTR p = NULL;


    buf[0] = 0;

    for (i = 0; (dwFlags && (pLookup[i].dwVal != 0xffffffff)); i++) {
        if (dwFlags & pLookup[i].dwVal) {
            _tcscat( buf, pLookup[i].lpszVal );
            dwFlags = dwFlags & (~(DWORD_PTR)pLookup[i].dwVal);
        }
    }

    if (buf[0]) {
        p = (LPTSTR) MemAlloc( (_tcslen(buf) + 1) * sizeof(buf[1]) );
        if (p) {
            _tcscpy( p, buf );
        }
    }

    return p;
}


void
ShowLineEvent(
    HLINE       htLine,
    HCALL       htCall,
    LPTSTR      MsgStr,
    DWORD_PTR   dwCallbackInstance,
    DWORD       dwMsg,
    DWORD_PTR   dwParam1,
    DWORD_PTR   dwParam2,
    DWORD_PTR   dwParam3
    )
{
    int       i;
    LPTSTR    lpszParam1 = NULL;
    LPTSTR    lpszParam2 = NULL;
    LPTSTR    lpszParam3 = NULL;
    TCHAR     MsgBuf[1024];



    MsgBuf[0] = 0;

    if (MsgStr) {
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("%s "), MsgStr );
    }

    _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("dwCallbackInstance=0x%08x "), dwCallbackInstance );

    for (i = 0; aMsgs[i].MsgId != 0xffffffff; i++) {
        if (dwMsg == aMsgs[i].MsgId) {
            break;
        }
    }

    if (aMsgs[i].MsgId == 0xffffffff) {
        _stprintf(
            &MsgBuf[_tcslen(MsgBuf)],
            TEXT("<unknown msg id = %d> : hLine=0x%08x, hCall=0x%08x "),
            dwMsg,
            htLine,
            htCall
            );
    } else {
        _stprintf(
            &MsgBuf[_tcslen(MsgBuf)],
            TEXT("%s : hLine=0x%08x, hCall=0x%08x "),
            aMsgs[i].Text,
            htLine,
            htCall
            );
    }

    if (aMsgs[i].LineMsg) {

        switch (dwMsg) {
            case LINE_ADDRESSSTATE:
                lpszParam2 = GetFlags( dwParam2, aAddressStates );
                break;

            case LINE_CALLINFO:
                lpszParam1 = GetFlags( dwParam1, aCallInfoStates );
                break;

            case LINE_CALLSTATE:
                lpszParam1 = GetFlags( dwParam1, aCallStates );
                break;

            case LINE_LINEDEVSTATE:
                lpszParam1 = GetFlags( dwParam1, aLineStates );
                break;
        }

    } else {

        switch (dwMsg) {
            case PHONE_BUTTON:
                lpszParam2 = GetFlags( dwParam2, aButtonModes );
                lpszParam3 = GetFlags( dwParam3, aButtonStates );
                break;

            case PHONE_STATE:
                lpszParam1 = GetFlags( dwParam1, aPhoneStates);
                break;
        }

    }

    _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("dwParam1=0x%08x"), dwParam1 );
    if (lpszParam1) {
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("(%s) "), lpszParam1 );
    } else {
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT(" ") );
    }

    _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("dwParam2=0x%08x"), dwParam2 );
    if (lpszParam2) {
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("(%s) "), lpszParam2 );
    } else {
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT(" ") );
    }

    _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("dwParam3=0x%08x"), dwParam3 );
    if (lpszParam3) {
        _stprintf( &MsgBuf[_tcslen(MsgBuf)], TEXT("(%s)"), lpszParam3 );
    }

    DebugPrint(( TEXT("%s"), MsgBuf ));

    if (lpszParam1) {
        MemFree( lpszParam1 );
    }

    if (lpszParam2) {
        MemFree( lpszParam2 );
    }

    if (lpszParam3) {
        MemFree( lpszParam3 );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\test\faxtest.c ===
#include <windows.h>
#include <shellapi.h>
#include <tchar.h>
#include <stdio.h>
#include "faxutil.h"
#include "winfax.h"
#include "tifflib.h"




BOOL
FaxRecipientCallback(
    IN HANDLE FaxHandle,
    IN DWORD RecipientNumber,
    IN LPVOID Context,
    IN PFAX_JOB_PARAM JobParams,
    IN PFAX_COVERPAGE_INFO CoverpageInfo
    )
{
    if (RecipientNumber > 3) {
        return FALSE;
    }

    JobParams->RecipientNumber = TEXT("22146");

    CoverpageInfo->CoverPageName = TEXT("fyi.cov");
    CoverpageInfo->RecFaxNumber = TEXT("22146");

    return TRUE;
}


BOOL
DoBroadcastDocument(
    HANDLE hFax,
    LPTSTR DocName
    )
{
    DWORD FaxJobId;


    return FaxSendDocumentForBroadcast( hFax, DocName, &FaxJobId, FaxRecipientCallback, NULL );
}


BOOL
DoSingleDocument(
    HANDLE hFax,
    LPTSTR DocName
    )
{
    DWORD FaxJobId;
    FAX_JOB_PARAM JobParams;
    FAX_COVERPAGE_INFO CoverpageInfo;


    ZeroMemory( &JobParams, sizeof(FAX_JOB_PARAM) );

    JobParams.SizeOfStruct = sizeof(FAX_JOB_PARAM);
    JobParams.RecipientNumber = TEXT("21464");

    ZeroMemory( &CoverpageInfo, sizeof(FAX_COVERPAGE_INFO) );

    CoverpageInfo.SizeOfStruct = sizeof(FAX_COVERPAGE_INFO);
    CoverpageInfo.CoverPageName = TEXT("fyi.cov");
    CoverpageInfo.RecFaxNumber = TEXT("21464");

    return FaxSendDocument( hFax, DocName, &JobParams, &CoverpageInfo, &FaxJobId );
}


int _cdecl
main(
    int argc,
    char *argvA[]
    )
{   
    LPTSTR                 *argv;
    int                    argcount   = 0;


#if 0
    TCHAR TempFile[MAX_PATH];
    GetTempFileName( TEXT("."), TEXT("fax"), 0, TempFile );
    _tprintf(TEXT("file=%s\n"),TempFile);
    CopyFile( argv[1], TempFile, FALSE );
    MergeTiffFiles( TempFile, argv[2] );
#endif


    HANDLE hFax;

    // do commandline stuff
#ifdef UNICODE
     argv = CommandLineToArgvW( GetCommandLine(), &argc );
#else
     argv = argvA;
#endif

    if (!FaxConnectFaxServer( argc <3? NULL: argv[2], &hFax )) {
        return -1;
    }

    DoBroadcastDocument( hFax, argv[1] );
    //DoSingleDocument( hFax, argv[1] );

    FaxClose( hFax );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\stress\resource.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    This file contains all resources defines for faxstres.exe

Author:

    Wesley Witt (wesw) 1-Nov-1996

Environment:

    User Mode

--*/

//
// dialogs
//

#define IDD_STRESS              501

//
// controls
//

#define IDC_STATIC              -1

#define IDC_ADD_DOCUMENTS       101
#define IDC_ADD_RECIPIENTS      102
#define IDC_COPIES              103
#define IDC_DOCUMENT_LIST       104
#define IDC_RECIPIENT_LIST      105
#define IDC_USE_EXCHANGE        106

#define APPICON                 601
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\service\testprov\testprov.c ===
#include <windows.h>
#include <tapi.h>
#include <faxdev.h>






VOID CALLBACK
TapiLineCallback(
    IN HANDLE FaxHandle,
    IN DWORD hDevice,
    IN DWORD dwMessage,
    IN DWORD dwInstance,
    IN DWORD dwParam1,
    IN DWORD dwParam2,
    IN DWORD dwParam3
    )
{
}


BOOL WINAPI
FaxDevInitialize(
    IN  HLINEAPP LineAppHandle,
    IN  HANDLE HeapHandle,
    OUT PFAX_LINECALLBACK *LineCallbackFunction
    )
{
    *LineCallbackFunction = TapiLineCallback;
    return TRUE;
}


BOOL WINAPI
FaxDevStartJob(
    IN  HLINE LineHandle,
    IN  DWORD DeviceId,
    OUT PHANDLE FaxHandle
    )
{
    return TRUE;
}


BOOL WINAPI
FaxDevEndJob(
    IN  HANDLE FaxHandle
    )
{
    return TRUE;
}


BOOL WINAPI
FaxDevSend(
    IN  HANDLE FaxHandle,
    IN  PFAX_SEND FaxSend,
    IN  PFAX_SEND_CALLBACK FaxSendCallback
    )
{
    return TRUE;
}


BOOL WINAPI
FaxDevReceive(
    IN  HANDLE FaxHandle,
    IN  HCALL CallHandle,
    IN OUT PFAX_RECEIVE FaxReceive
    )
{
    return TRUE;
}


BOOL WINAPI
FaxDevReportStatus(
    IN  HANDLE FaxHandle OPTIONAL,
    OUT PFAX_DEV_STATUS FaxStatus
    )
{
    return TRUE;
}


BOOL WINAPI
FaxDevAbortOperation(
    IN  HANDLE FaxHandle
    )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ocm\dlgcomon.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dialogs.c

Abstract:

    This file implements the common dialog proc and other
    common code used by other dialog procs.  All global
    data used by the dialog procs lives here too.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "faxocm.h"
#pragma hdrstop



INT_PTR
CommonDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PWIZPAGE WizPage;


    WizPage = (PWIZPAGE) GetWindowLongPtr( hwnd, DWLP_USER );

    switch( msg ) {
        case WM_INITDIALOG:

            SetWindowLongPtr( hwnd, DWLP_USER, ((LPPROPSHEETPAGE) lParam)->lParam );
            WizPage = (PWIZPAGE) ((LPPROPSHEETPAGE) lParam)->lParam;
            break;

        case WM_NOTIFY:

            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:

                    PropSheet_SetWizButtons(
                        GetParent(hwnd),
                        WizPage->ButtonState
                        );

                    SetWindowLongPtr( hwnd, DWLP_MSGRESULT, 0 );
                    break;

                case PSN_QUERYCANCEL:
                    {
                        if (!OkToCancel) {
                            DWORD Answer;
                            MessageBeep(0);
                            Answer = PopUpMsg( hwnd, IDS_QUERY_CANCEL, FALSE, MB_YESNO );
                            if (Answer == IDNO) {
                                SetWindowLongPtr( hwnd, DWLP_MSGRESULT, 1 );
                                return TRUE;
                            } else {
                                InstallThreadError = ERROR_CANCELLED;
                            }
                        }
                    }
                    break;
            }
            break;
    }

    if (WizPage && WizPage->DlgProc) {
        return WizPage->DlgProc( hwnd,  msg, wParam, lParam );
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\layout\layout.c ===
#include <windows.h>
#include <stdio.h>





int _cdecl
main(
    int argc,
    CHAR *argv[]
    )
{
    HANDLE hFileIn;
    HANDLE hMapIn;
    HANDLE hFileOut;
    HANDLE hMapOut;
    HANDLE hDataFile;
    LPSTR SrcData, DstData;
    LPSTR s,e,d;
    DWORD FileSize;
    CHAR FileName[MAX_PATH];
    DWORD DataSize;


    //
    // map the input file
    //

    hFileIn = CreateFile( argv[1], GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL );
    if (hFileIn == INVALID_HANDLE_VALUE) {
        return -1;
    }

    FileSize = GetFileSize( hFileIn, NULL );

    hMapIn = CreateFileMapping( hFileIn, NULL, PAGE_READONLY | SEC_COMMIT, 0, 0, NULL );
    if (!hMapIn) {
        return -1;
    }

    SrcData = s = MapViewOfFile( hMapIn, FILE_MAP_READ, 0, 0, 0 );

    //
    // map the output file
    //

    hFileOut = CreateFile( argv[2], GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL );
    if (hFileOut == INVALID_HANDLE_VALUE) {
        return -1;
    }

    hMapOut = CreateFileMapping( hFileOut, NULL, PAGE_READWRITE | SEC_COMMIT, 0, FileSize+64000, NULL );
    if (!hMapOut) {
        return -1;
    }

    DstData = d = MapViewOfFile( hMapOut, FILE_MAP_WRITE, 0, 0, 0 );

    //
    // look for the [SourceDisksFiles] section
    //

    while (TRUE) {
        s = strchr( s, '[' ) + 1;
        e = strchr( s, ']' );
        if (_strnicmp(s,"SourceDisksFiles",16)!=0) {
            s = e + 1;
            continue;
        }
        s = strchr(e,0xa) + 1;
        break;
    }

    CopyMemory(d,SrcData,s-SrcData);
    d += (s-SrcData);

    //
    // now loop thru all of the files in the [SourceDisksFiles] section
    //

    while (TRUE) {
        if (*s==0xd) {
            CopyMemory(d,s,2);
            d+=2;
            s+=2;
            continue;
        }
        if (*s=='[') break;
        e = strchr(s,'=');
        strcpy(FileName,argv[3]);
        if (FileName[strlen(FileName)-1]!='\\') {
            strcat(FileName,"\\");
        }
        strncat(FileName,s,e-s);

        hDataFile = CreateFile( FileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL );
        if (hDataFile != INVALID_HANDLE_VALUE) {
            DataSize = GetFileSize( hDataFile, NULL );
            CloseHandle(hDataFile);
        } else {
            DataSize = 0;
        }

        e = strchr(e,',')+1;
        e = strchr(e,',')+1;

        CopyMemory(d,s,e-s);
        d += (e-s);

        sprintf(d,"%01d",DataSize);
        d += strlen(d);

        s = strchr(e,',');
        e = strchr(e,0xa) + 1;

        CopyMemory(d,s,e-s);
        d += (e-s);
        s = e;
    }

    CopyMemory(d,s,FileSize-(s-SrcData));
    d += (FileSize-(s-SrcData));

    UnmapViewOfFile( DstData );
    CloseHandle( hMapOut );
    SetFilePointer( hFileOut, d-DstData, 0, FILE_BEGIN );
    SetEndOfFile( hFileOut );
    CloseHandle( hFileOut );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ocm\dlgeula.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dialogs.c

Abstract:

    This file implements the common dialog proc and other
    common code used by other dialog procs.  All global
    data used by the dialog procs lives here too.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "faxocm.h"
#pragma hdrstop


static WNDPROC OldEditProc;

LRESULT
CALLBACK
EulaEditSubProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Edit control subclass routine, to avoid highlighting text when user
    tabs to the edit control.

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/

{
    //
    // For setsel messages, make start and end the same.
    //
    if ((msg == EM_SETSEL) && ((LPARAM)wParam != lParam)) {
        lParam = wParam;
    }

    return CallWindowProc( OldEditProc, hwnd, msg, wParam, lParam );
}

BOOL
DisplayEula(
    HWND hwnd
    )
{
    HGLOBAL hResource;
    LPSTR   lpResource;
    LPSTR   p;
    BOOL    rVal = FALSE;
    DWORD   FileSize;
    PWSTR   EulaText = NULL;


    hResource = LoadResource(
        hInstance,
        FindResource( hInstance, MAKEINTRESOURCE(FAX_EULA), MAKEINTRESOURCE(BINARY) )
        );
    if (!hResource) {
        return FALSE;
    }

    lpResource = (LPSTR) LockResource(
        hResource
        );
    if (!lpResource) {
        FreeResource( hResource );
        return FALSE;
    }

    p = strchr( lpResource, '^' );
    if (!p) {
        //
        // the eula text file is corrupt
        //
        return FALSE;
    }

    FileSize = (DWORD)(p - lpResource);

    EulaText = (PWSTR) MemAlloc( (FileSize+1) * sizeof(WCHAR) );
    if (EulaText == NULL) {
        goto exit;
    }

    MultiByteToWideChar (
        CP_ACP,
        0,
        lpResource,
        FileSize,
        EulaText,
        (FileSize+1) * sizeof(WCHAR)
        );

    EulaText[FileSize] = 0;

    OldEditProc = (WNDPROC) GetWindowLongPtr( hwnd, GWLP_WNDPROC );
    SetWindowLongPtr( hwnd, GWLP_WNDPROC, (ULONG_PTR)EulaEditSubProc );

    SetWindowText( hwnd, EulaText );

    rVal = TRUE;

exit:

    MemFree (EulaText);

    if (lpResource) {
        FreeResource( lpResource );
    }

    return rVal;
}


INT_PTR
EulaDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch( msg ) {
        case WM_INITDIALOG:
            DisplayEula( GetDlgItem( hwnd, IDC_LICENSE_AGREEMENT ) );
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED) {
                switch (LOWORD(wParam)) {
                    case IDC_ACCEPT:
                        PropSheet_SetWizButtons( GetParent(hwnd), PSWIZB_NEXT );
                        break;

                    case IDC_DECLINE:
                        PropSheet_SetWizButtons( GetParent(hwnd), 0 );
                        break;
                }
            }
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    if (IsDlgButtonChecked( hwnd, IDC_ACCEPT ) == BST_CHECKED) {
                        PropSheet_SetWizButtons( GetParent(hwnd), PSWIZB_NEXT );
                    } else {
                        PropSheet_SetWizButtons( GetParent(hwnd), 0 );
                    }

                    if (Upgrade) {
                        PropSheet_SetWizButtons( GetParent(hwnd), PSWIZB_NEXT );
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT ,-1);
                        return TRUE;
                    }
                    
                    break;

                default:
                    break;
            }
            break;

        default:
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ocm\dlgfinal.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dialogs.c

Abstract:

    This file implements the common dialog proc and other
    common code used by other dialog procs.  All global
    data used by the dialog procs lives here too.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "faxocm.h"
#pragma hdrstop


INT_PTR
FinalDlgProc(
    HWND hDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static HFONT hfontTextBold = NULL;
    static HFONT hfontTextBigBold = NULL;

    switch( msg ) {
        case WM_INITDIALOG:
            {
                SetWindowText( GetParent(hDlg), GetProductName() );
                CenterWindow( GetParent(hDlg), GetDesktopWindow() );

                LOGFONT LogFont, LogFontOriginal;
                HFONT hfont = (HFONT)SendMessage(GetDlgItem(hDlg, IDC_FINAL_TITLE), WM_GETFONT, 0, 0);
                GetObject( hfont, sizeof(LogFont), &LogFont );
                LogFontOriginal = LogFont;

                LogFont = LogFontOriginal;
                LogFont.lfWeight = FW_BOLD;
                hfontTextBold = CreateFontIndirect( &LogFont );

                LogFont = LogFontOriginal;
                LogFont.lfWeight = FW_BOLD;
                int PtsPixels = GetDeviceCaps( GetDC(hDlg), LOGPIXELSY );
                int FontSize = (LogFont.lfHeight*72/PtsPixels) * 2;
                LogFont.lfHeight = PtsPixels*FontSize/72;
                hfontTextBigBold = CreateFontIndirect( &LogFont );

                SetWindowFont( GetDlgItem(hDlg, IDC_FINAL_TITLE), hfontTextBold, TRUE );
                SetWindowFont( GetDlgItem(hDlg, IDC_FINAL_SUBTITLE), hfontTextBigBold, TRUE );
            }
            break;

        case WM_DESTROY:
            DeleteObject( hfontTextBold );
            DeleteObject( hfontTextBigBold );
            break;

        default:
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ocm\dlgwelcm.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dialogs.c

Abstract:

    This file implements the common dialog proc and other
    common code used by other dialog procs.  All global
    data used by the dialog procs lives here too.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "faxocm.h"
#pragma hdrstop


INT_PTR
WelcomeDlgProc(
    HWND hDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static HFONT hfontTextBold = NULL;
    static HFONT hfontTextBigBold = NULL;

    switch( msg ) {
        case WM_INITDIALOG:
            {
                SetWindowText( GetParent(hDlg), GetProductName() );
                CenterWindow( GetParent(hDlg), GetDesktopWindow() );

                LOGFONT LogFont, LogFontOriginal;
                HFONT hfont = (HFONT)SendMessage(GetDlgItem(hDlg, IDC_WELCOME_TITLE), WM_GETFONT, 0, 0);
                GetObject( hfont, sizeof(LogFont), &LogFont );
                LogFontOriginal = LogFont;

                LogFont = LogFontOriginal;
                LogFont.lfWeight = FW_BOLD;
                hfontTextBold = CreateFontIndirect( &LogFont );

                LogFont = LogFontOriginal;
                LogFont.lfWeight = FW_BOLD;
                int PtsPixels = GetDeviceCaps( GetDC(hDlg), LOGPIXELSY );
                int FontSize = (LogFont.lfHeight*72/PtsPixels) * 2;
                LogFont.lfHeight = PtsPixels*FontSize/72;
                hfontTextBigBold = CreateFontIndirect( &LogFont );

                SetWindowFont( GetDlgItem(hDlg, IDC_WELCOME_TITLE), hfontTextBold, TRUE );
                SetWindowFont( GetDlgItem(hDlg, IDC_WELCOME_SUBTITLE), hfontTextBigBold, TRUE );
            }
            break;

        case WM_DESTROY:
            DeleteObject( hfontTextBold );
            DeleteObject( hfontTextBigBold );
            break;

        default:
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ocm\class.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    class.c

Abstract:

    This file implements the modem co-class
    installer for fax.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 31-Jul-1997

--*/

#include "faxocm.h"
#pragma hdrstop


#if DBG

typedef struct _DIF_DEBUG {
    DWORD DifValue;
    LPTSTR DifString;
} DIF_DEBUG, *PDIF_DEBUG;

DIF_DEBUG DifDebug[] =
{
    { 0,                           L""                           },  //  0x00000000
    { DIF_SELECTDEVICE,            L"DIF_SELECTDEVICE"           },  //  0x00000001
    { DIF_INSTALLDEVICE,           L"DIF_INSTALLDEVICE"          },  //  0x00000002
    { DIF_ASSIGNRESOURCES,         L"DIF_ASSIGNRESOURCES"        },  //  0x00000003
    { DIF_PROPERTIES,              L"DIF_PROPERTIES"             },  //  0x00000004
    { DIF_REMOVE,                  L"DIF_REMOVE"                 },  //  0x00000005
    { DIF_FIRSTTIMESETUP,          L"DIF_FIRSTTIMESETUP"         },  //  0x00000006
    { DIF_FOUNDDEVICE,             L"DIF_FOUNDDEVICE"            },  //  0x00000007
    { DIF_SELECTCLASSDRIVERS,      L"DIF_SELECTCLASSDRIVERS"     },  //  0x00000008
    { DIF_VALIDATECLASSDRIVERS,    L"DIF_VALIDATECLASSDRIVERS"   },  //  0x00000009
    { DIF_INSTALLCLASSDRIVERS,     L"DIF_INSTALLCLASSDRIVERS"    },  //  0x0000000A
    { DIF_CALCDISKSPACE,           L"DIF_CALCDISKSPACE"          },  //  0x0000000B
    { DIF_DESTROYPRIVATEDATA,      L"DIF_DESTROYPRIVATEDATA"     },  //  0x0000000C
    { DIF_VALIDATEDRIVER,          L"DIF_VALIDATEDRIVER"         },  //  0x0000000D
    { DIF_MOVEDEVICE,              L"DIF_MOVEDEVICE"             },  //  0x0000000E
    { DIF_DETECT,                  L"DIF_DETECT"                 },  //  0x0000000F
    { DIF_INSTALLWIZARD,           L"DIF_INSTALLWIZARD"          },  //  0x00000010
    { DIF_DESTROYWIZARDDATA,       L"DIF_DESTROYWIZARDDATA"      },  //  0x00000011
    { DIF_PROPERTYCHANGE,          L"DIF_PROPERTYCHANGE"         },  //  0x00000012
    { DIF_ENABLECLASS,             L"DIF_ENABLECLASS"            },  //  0x00000013
    { DIF_DETECTVERIFY,            L"DIF_DETECTVERIFY"           },  //  0x00000014
    { DIF_INSTALLDEVICEFILES,      L"DIF_INSTALLDEVICEFILES"     },  //  0x00000015
    { DIF_UNREMOVE,                L"DIF_UNREMOVE"               },  //  0x00000016
    { DIF_SELECTBESTCOMPATDRV,     L"DIF_SELECTBESTCOMPATDRV"    },  //  0x00000017
    { DIF_ALLOW_INSTALL,           L"DIF_ALLOW_INSTALL"          },  //  0x00000018
    { DIF_REGISTERDEVICE,          L"DIF_REGISTERDEVICE"         },  //  0x00000019
    { 0,                           L""                           },  //  0x0000001A
    { 0,                           L""                           },  //  0x0000001B
    { 0,                           L""                           },  //  0x0000001C
    { 0,                           L""                           },  //  0x0000001D
    { 0,                           L""                           },  //  0x0000001E
    { 0,                           L""                           },  //  0x0000001F
    { DIF_INSTALLINTERFACES,       L"DIF_INSTALLINTERFACES"      },  //  0x00000020
    { DIF_DETECTCANCEL,            L"DIF_DETECTCANCEL"           },  //  0x00000021
    { DIF_REGISTER_COINSTALLERS,   L"DIF_REGISTER_COINSTALLERS"  },  //  0x00000022
    { 0,                           L""                           }   //  0x00000023
};

#endif


VOID 
StartSystray(
    VOID
    )
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    LPWSTR szSystray = ExpandEnvironmentString( L"%systemroot%\\system32\\systray.exe" );

    GetStartupInfo(&si);

    if ( CreateProcess(NULL,szSystray,NULL,NULL,FALSE,DETACHED_PROCESS,NULL,NULL,&si,&pi) ) {
        CloseHandle( pi.hProcess );
        CloseHandle( pi.hThread );
    }

    MemFree( szSystray );
}


DWORD
CALLBACK
FaxModemCoClassInstaller(
    IN DI_FUNCTION InstallFunction,
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL,
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    )
{
    __try {

        DebugPrint(( L"FaxModemCoClassInstaller:  processing %s request", DifDebug[InstallFunction].DifString ));

        if (InstallFunction == DIF_FIRSTTIMESETUP) {
            NtGuiMode = TRUE;
            return Context->InstallResult;
        }

        if (InstallFunction == DIF_INSTALLDEVICE) {

            if (!Context->PostProcessing) {
                DebugPrint(( L"FaxModemCoClassInstaller:  pre-installation, waiting for post-installation call" ));
                return ERROR_DI_POSTPROCESSING_REQUIRED;
            }

            if (Context->InstallResult != NO_ERROR) {
                DebugPrint(( L"FaxModemCoClassInstaller:  previous error causing installation failure, 0x%08x", Context->InstallResult ));
                return Context->InstallResult;
            }

            if (!NtGuiMode) {

                //
                // check if we have a fax printer
                //
                PPRINTER_INFO_2 pPrinterInfo;
                DWORD dwPrinters, i;

                //
                // note: if this call returns NULL, assume this means that there are zero printers installed, 
                // not a spooler errror
                //
                pPrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters(NULL,2,&dwPrinters,PRINTER_ENUM_LOCAL);
                if (pPrinterInfo) {
                    for (i=0;i<dwPrinters;i++) {
                        if (wcscmp(pPrinterInfo[i].pDriverName,FAX_DRIVER_NAME) == 0) {
                            DebugPrint(( L"Fax printer %s already installed, exiting co-class installer", pPrinterInfo[i].pPrinterName ));
                            MemFree( pPrinterInfo );
                            return NO_ERROR;
                        }
                    }
                    MemFree( pPrinterInfo );
                }
               
                //
                // create a fax printer
                //

                WCHAR PrinterName[64];

                LoadString( hInstance, IDS_DEFAULT_PRINTER_NAME, PrinterName, sizeof(PrinterName)/sizeof(WCHAR) );

                if (!CreateLocalFaxPrinter( PrinterName )) {
                    DebugPrint(( L"CreateLocalFaxPrinter() failed" ));
                }
                //
                // start the fax service
                //

                StartFaxService();

                //
                // put the control panel back in place so the user sees it
                //
                LPTSTR dstFile = ExpandEnvironmentString( TEXT("%systemroot%\\system32\\fax.cpl") );
                LPTSTR srcFile = ExpandEnvironmentString( TEXT("%systemroot%\\system32\\fax.cpk") );

                if (!MoveFileEx(srcFile, dstFile, MOVEFILE_REPLACE_EXISTING)) {
                    MoveFileEx(srcFile, dstFile, MOVEFILE_REPLACE_EXISTING | MOVEFILE_DELAY_UNTIL_REBOOT);
                }

                //
                // create the program groups
                //

                CreateGroupItems( NULL );

                //
                // restart systray so that we get the fax icon
                //
                // StartSystray();
            }

            return NO_ERROR;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        DebugPrint(( TEXT("FaxModemCoClassInstaller crashed: 0x%08x"), GetExceptionCode() ));

    }

    return Context->InstallResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ocm\fileq.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fileq.c

Abstract:

    This file implements the file copy code.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "faxocm.h"
#pragma hdrstop

FILE_QUEUE_INFO MinimalServerFileQueue[] =
{
    { L"CoverPageFiles",         DIRID_COVERPAGE,    L"%s\\%s" , FILEQ_FLAG_SHELL, CSIDL_COMMON_DOCUMENTS }
};

#define CountMinimalServerFileQueue (sizeof(MinimalServerFileQueue)/sizeof(FILE_QUEUE_INFO))

FILE_QUEUE_INFO ServerFileQueue[] =
{
    { L"ClientFiles",            DIRID_CLIENTS,      L"%s\\" FAX_CLIENT_DIR, FILEQ_FLAG_SHELL, CSIDL_COMMON_APPDATA  },
    { L"CoverPageFiles",         DIRID_COVERPAGE,    L"%s\\%s" , FILEQ_FLAG_SHELL, CSIDL_COMMON_DOCUMENTS }
};

#define CountServerFileQueue (sizeof(ServerFileQueue)/sizeof(FILE_QUEUE_INFO))

FILE_QUEUE_INFO ClientFileQueue[] =
{
    { L"ClientSystemFiles",      DIRID_SYSTEM,       NULL,                            0,                0 },
    { L"HelpFilesClient",        DIRID_HELP,         NULL,                            0,                0 },
    { L"OutlookConfigFile",      DIRID_OUTLOOK_ECF,  L"%windir%\\addins",             FILEQ_FLAG_ENV,   0 },
    { L"CoverPageFiles",         DIRID_COVERPAGE,    L"%s\\Fax\\Personal Coverpages", FILEQ_FLAG_SHELL, CSIDL_PERSONAL}
};

#define CountClientFileQueue (sizeof(ClientFileQueue)/sizeof(FILE_QUEUE_INFO))



DWORD
SetupQueueXXXSection(
    HSPFILEQ QueueHandle,
    LPWSTR SourceRootPath,
    HINF InfHandle,
    HINF ListInfHandle,
    LPWSTR Section,
    DWORD CopyStyle,
    DWORD Action
    )
{
    if (Action == SETUP_ACTION_NONE) {
        return 0;
    }

    if (Action == SETUP_ACTION_COPY) {
        return SetupQueueCopySection(
            QueueHandle,
            SourceRootPath,
            InfHandle,
            ListInfHandle,
            Section,
            CopyStyle
            );
    }

    if (Action == SETUP_ACTION_DELETE) {
        return SetupQueueDeleteSection(
            QueueHandle,
            InfHandle,
            ListInfHandle,
            Section
            );
    }

    return 0;
}


BOOL
SetDestinationDir(
    HINF SetupInf,
    PFILE_QUEUE_INFO FileQueueInfo
    )
{
    WCHAR DestDir[MAX_PATH*2];
    BOOL Rval;


    if (FileQueueInfo->InfDirId < DIRID_USER) {
        return TRUE;
    }

    if (FileQueueInfo->Flags & FILEQ_FLAG_SHELL) {
        WCHAR ShellPath[MAX_PATH];
        if (!MyGetSpecialPath(FileQueueInfo->ShellId, ShellPath) ) {
            DebugPrint(( L"MyGetSpecialPath(%d) failed, ec = %d\n", FileQueueInfo->ShellId, GetLastError() ));
            return FALSE;
        }

        if (FileQueueInfo->InfDirId == DIRID_COVERPAGE) {
            wsprintf( DestDir, FileQueueInfo->DirName, ShellPath, GetString( IDS_COVERPAGE_DIR ) );
        } else {
            wsprintf( DestDir, FileQueueInfo->DirName, ShellPath );
        }
    } 

    if (FileQueueInfo->Flags &  FILEQ_FLAG_ENV) {
        ExpandEnvironmentStrings( FileQueueInfo->DirName, DestDir, sizeof(DestDir)/sizeof(WCHAR) );
    }

    DebugPrint(( L"Setting destination dir: [%d] [%s]", FileQueueInfo->InfDirId, DestDir ));

    MakeDirectory( DestDir );

    Rval = SetupSetDirectoryId(
        SetupInf,
        FileQueueInfo->InfDirId,
        DestDir
        );

    if (!Rval) {
        DebugPrint(( L"SetupSetDirectoryId() failed, ec=%d", GetLastError() ));
        return FALSE;
    }

    return TRUE;
}


BOOL
ProcessFileQueueEntry(
    HINF SetupInf,
    HSPFILEQ FileQueue,
    LPWSTR SourceRoot,
    PFILE_QUEUE_INFO FileQueueInfo,
    DWORD ActionId
    )
{
    BOOL Rval;


    //
    // set the destination directory
    //

    if (!SetDestinationDir( SetupInf, FileQueueInfo ) ) {
        return FALSE;
    }

    //
    // queue the operation
    //

    Rval = SetupQueueXXXSection(
        FileQueue,
        SourceRoot,
        SetupInf,
        SetupInf,
        FileQueueInfo->SectionName,
        SP_COPY_FORCE_NEWER,
        ActionId
        );
        
    return Rval;
}


BOOL
ProcessFileQueueEntryForDiskSpace(
    HINF SetupInf,
    HDSKSPC DiskSpace,
    LPWSTR SourceRoot,
    PFILE_QUEUE_INFO FileQueueInfo,
    DWORD Operation,
    BOOL AddToQueue
    )
{
    BOOL Rval;
    
    //
    // set the destination directory
    //

    if (!SetDestinationDir( SetupInf, FileQueueInfo )) {
        return FALSE;
    }

    //
    // add the files to the disk space queue
    //

    if (AddToQueue) {
        Rval = SetupAddSectionToDiskSpaceList(
                                                DiskSpace,
                                                SetupInf,
                                                NULL,
                                                FileQueueInfo->SectionName,
                                                Operation,
                                                NULL,
                                                0 
                                             );
            
        
    } else {
        Rval = SetupRemoveSectionFromDiskSpaceList(
                                                    DiskSpace,
                                                    SetupInf,
                                                    NULL,
                                                    FileQueueInfo->SectionName,
                                                    Operation,
                                                    NULL,
                                                    0
                                                  );
        
    }

    return Rval;
}


BOOL
AddServerFilesToQueue(
    HINF SetupInf,
    HSPFILEQ FileQueue,
    LPWSTR SourceRoot
    )
{
    PFILE_QUEUE_INFO pfqi = &MinimalServerFileQueue[0];
    DWORD CountMax = CountMinimalServerFileQueue;


//
// BugBug: might want to enable this block for product suites, so that client files are also copied over.
//
#if 0
if (IsProductSuite()) {
    pfqi = &ServerFileQueue[0];
    CountMax = CountServerFileQueue;
}
#endif
    
    for (DWORD i=0; i<CountMax; i++) {
        ProcessFileQueueEntry(
            SetupInf,
            FileQueue,
            SourceRoot,
            &pfqi[i],
            SETUP_ACTION_COPY
            );
    }

    return TRUE;
}


BOOL
CalcServerDiskSpace(
    HINF SetupInf,
    HDSKSPC DiskSpace,
    LPWSTR SourceRoot,
    BOOL AddToQueue
    )
{
    BOOL Rval = TRUE;
    DWORD ec;
    PFILE_QUEUE_INFO pfqi = &MinimalServerFileQueue[0];
    DWORD CountMax = CountMinimalServerFileQueue;


//
// BugBug: might want to enable this block for product suites, so that client files are also copied over.
//
#if 0
    if (IsProductSuite()) {
        pfqi = &ServerFileQueue[0];
        CountMax = CountServerFileQueue;
    }
#endif


    for (DWORD i=0; i<CountMax; i++) {
        if (!ProcessFileQueueEntryForDiskSpace(
            SetupInf,
            DiskSpace,
            SourceRoot,
            &pfqi[i],
            FILEOP_COPY,
            AddToQueue
            ))
        {
            ec = GetLastError();
            Rval = FALSE;
        }
    }

    return Rval;
}


BOOL
CopyClientFiles(
    LPWSTR SourceRoot
    )
{
    BOOL Rval = FALSE;
    HINF SetupInf = INVALID_HANDLE_VALUE;
    HSPFILEQ FileQueue = INVALID_HANDLE_VALUE;
    WCHAR Buffer[MAX_PATH];
    DWORD i;
    LPVOID Context = NULL;


    wcscpy( Buffer, SourceRoot );
    wcscat( Buffer, L"faxclnt.inf" );

    SetupInf = SetupOpenInfFile(
        Buffer,
        NULL,
        INF_STYLE_WIN4,
        NULL
        );
    if (SetupInf == INVALID_HANDLE_VALUE) {
        DebugPrint(( TEXT("SetupOpenInfFile() failed, [%s], ec=0x%08x"), Buffer, GetLastError() ));
        goto exit;
    }

    FileQueue = SetupOpenFileQueue();
    if (FileQueue == INVALID_HANDLE_VALUE) {
        DebugPrint(( TEXT("SetupOpenFileQueue() failed, ec=0x%08x"), GetLastError() ));
        goto exit;
    }

    for (i=0; i<CountClientFileQueue; i++) {
        ProcessFileQueueEntry(
            SetupInf,
            FileQueue,
            SourceRoot,
            &ClientFileQueue[i],
            SETUP_ACTION_COPY
            );
    }

    Context = SetupInitDefaultQueueCallbackEx( NULL, (HWND)INVALID_HANDLE_VALUE, 0, 0, 0 );
    if (!Context) {
        goto exit;
    }

    if (!SetupCommitFileQueue( NULL, FileQueue, SetupDefaultQueueCallback, Context )) {
        DebugPrint(( TEXT("SetupCommitFileQueue() failed, ec=0x%08x"), GetLastError() ));
        goto exit;
    }

    Rval = TRUE;

exit:

    if (Context) {
        SetupTermDefaultQueueCallback( Context );
    }
    if (FileQueue != INVALID_HANDLE_VALUE) {
        SetupCloseFileQueue( FileQueue );
    }
    if (SetupInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile( SetupInf );
    }

    return Rval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ocm\faxocm.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    faxocm.cpp

Abstract:

    This file implements the setup wizard code for the
    FAX server setup.

Environment:

        WIN32 User Mode

Author:

    Wesley Witt (wesw) 10-Sept-1997

--*/

#include "faxocm.h"
#pragma hdrstop


HINSTANCE hInstance;
SETUP_INIT_COMPONENT SetupInitComponent;

BOOL Unattended;
BOOL Upgrade;               // NT upgrade
BOOL Win9xUpgrade;          
BOOL NtGuiMode;
BOOL NtWorkstation;
BOOL UnInstall;
BOOL RemoteAdminSetup;
BOOL RebootRequired;
BOOL SuppressReboot;
WORD EnumPlatforms[4];
BOOL PointPrintSetup;
DWORD InstallThreadError;
BOOL OkToCancel;
DWORD CurrentCountryId;
LPWSTR CurrentAreaCode;
WCHAR ClientSetupServerName[MAX_PATH];
WCHAR ThisPlatformName[MAX_PATH];
DWORD InstalledPlatforms;
DWORD InstallType;
DWORD Installed;
BOOL ComponentInitialized;
WIZ_DATA WizData;
LPWSTR SourcePath;

PLATFORM_INFO Platforms[] =
{
    {  L"Windows NT x86",        L"i386",    0, FAX_INSTALLED_PLATFORM_X86,   NULL, FALSE },
    {  L"Windows NT Alpha_AXP",  L"alpha",   0, FAX_INSTALLED_PLATFORM_ALPHA, NULL, FALSE },
};

DWORD CountPlatforms = (sizeof(Platforms)/sizeof(PLATFORM_INFO));

UNATTEND_ANSWER UnattendAnswer[] =
{
   { L"FaxPrinterName",          DT_STRING,     0,          WizData.PrinterName         },
   { L"FaxNumber",               DT_STRING,     0,          WizData.PhoneNumber         },
   { L"RoutePrinterName",        DT_STRING,     0,          WizData.RoutePrinterName    },
   { L"RouteProfileName",        DT_STRING,     0,          WizData.RouteProfile        },
   { L"RouteFolderName",         DT_STRING,     0,          WizData.RouteDir            },
   { L"Csid",                    DT_STRING,     0,          WizData.Csid                },
   { L"Tsid",                    DT_STRING,     0,          WizData.Tsid                },
   { L"Rings",                   DT_LONGINT,    0,          &WizData.Rings              },
   { L"RouteToPrinter",          DT_BOOLEAN,    LR_PRINT,   &WizData.RoutingMask        },
   { L"RouteToInbox",            DT_BOOLEAN,    LR_INBOX,   &WizData.RoutingMask        },
   { L"RouteToFolder",           DT_BOOLEAN,    LR_STORE,   &WizData.RoutingMask        },
   { L"ArchiveOutgoing",         DT_BOOLEAN,    0,          &WizData.ArchiveOutgoing    },
   { L"ArchiveFolderName",       DT_STRING,     0,          WizData.ArchiveDir          }
};

#define CountUnattendAnswers  (sizeof(UnattendAnswer)/sizeof(UNATTEND_ANSWER))


extern "C" INT FaxDebugLevel;

extern "C"
DWORD
FaxOcmDllInit(
    HINSTANCE hInst,
    DWORD     Reason,
    LPVOID    Context
    )

/*++

Routine Description:

    DLL initialization function.

Arguments:

    hInstance   - Instance handle
    Reason      - Reason for the entrypoint being called
    Context     - Context record

Return Value:

    TRUE        - Initialization succeeded
    FALSE       - Initialization failed

--*/

{
    WCHAR DllName[MAX_PATH];


    if (Reason == DLL_PROCESS_ATTACH) {
        hInstance = hInst;
        DisableThreadLibraryCalls( hInstance );
        HeapInitialize( NULL, NULL, NULL, 0 );
        if (!GetModuleFileName(hInstance, DllName, MAX_PATH) || !LoadLibrary(DllName)) {
            return FALSE;
        }
        DebugPrint(( TEXT("faxocm loaded") ));
    }

    if (Reason == DLL_PROCESS_DETACH) {
        HeapCleanup();
    }

    return TRUE;
}


VOID
SetProgress(
    DWORD StatusString
    )
{
#ifdef NT5FAXINSTALL
    return;
#else
    SetupInitComponent.HelperRoutines.SetProgressText(
        SetupInitComponent.HelperRoutines.OcManagerContext,
        GetString( StatusString )
        );
    for (DWORD i=0; i<10; i++) {
        SetupInitComponent.HelperRoutines.TickGauge(
            SetupInitComponent.HelperRoutines.OcManagerContext
            );
    }
#endif
}


BOOL
SetWizData(
    VOID
    )
{
    HKEY hKey;
    LPWSTR RegisteredOwner = NULL;
    INFCONTEXT InfLine;
    WCHAR Id[128];
    WCHAR Value[128];
    DWORD i;
    HINF hInf;


    //
    // user name
    //

    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_WINDOWSNT_CURRVER, TRUE, KEY_ALL_ACCESS );
    RegisteredOwner = GetRegistryString( hKey, REGVAL_REGISTERED_OWNER, EMPTY_STRING );
    RegCloseKey( hKey );

    if (RegisteredOwner && RegisteredOwner[0]) {
        wcscpy( WizData.UserName, RegisteredOwner );
        MemFree( RegisteredOwner );
    }

    //
    // fax printer name
    //

    wcscpy( WizData.PrinterName, GetString( IDS_DEFAULT_PRINTER_NAME ) );

    //
    // csid
    //

    wcscpy( WizData.Csid, GetString( IDS_DEFAULT_CSID ) );

    //
    // tsid
    //

    wcscpy( WizData.Tsid, GetString( IDS_DEFAULT_TSID ) );

    //
    // ring count
    //

    WizData.Rings = 2;

    //
    // routing mask
    //

    WizData.RoutingMask = LR_STORE;

    WizData.ArchiveOutgoing = TRUE;
    
    //
    // routing dir name
    //

    if (MyGetSpecialPath( CSIDL_COMMON_DOCUMENTS, WizData.RouteDir)) {
       ConcatenatePaths( WizData.RouteDir, GetString(IDS_RECEIVE_DIR) );
    }

    //
    // archive dir name
    //
    if (MyGetSpecialPath( CSIDL_COMMON_DOCUMENTS, WizData.ArchiveDir)) {
       ConcatenatePaths( WizData.ArchiveDir, GetString(IDS_ARCHIVE_DIR) );
    }


    //
    // process any unattend data
    //

    if (Unattended) {       
        
        hInf = SetupInitComponent.HelperRoutines.GetInfHandle(
            INFINDEX_UNATTENDED,
            SetupInitComponent.HelperRoutines.OcManagerContext
            );
        
        if (hInf == INVALID_HANDLE_VALUE) {
            return FALSE;
        }

        if (SetupFindFirstLine( hInf, L"Fax", NULL, &InfLine )) {
            DebugPrint((L"Processing fax unattend data"));
            do {
                SetupGetStringField( &InfLine, 0, Id, sizeof(Id)/sizeof(WCHAR), NULL );
                for (i=0; i<CountUnattendAnswers; i++) {
                    if (_wcsicmp( Id, UnattendAnswer[i].KeyName ) == 0) {
                        if ((SetupGetStringField( 
                                    &InfLine, 
                                    1, 
                                    Value, 
                                    sizeof(Value)/sizeof(WCHAR), 
                                    NULL )) &&
                            *Value) {
                        
                            switch (UnattendAnswer[i].DataType) {
                                case DT_STRING:
                                    wcscpy( (LPWSTR)UnattendAnswer[i].DataPtr, Value );
                                    break;
    
                                case DT_LONGINT:
                                    *((LPDWORD)UnattendAnswer[i].DataPtr) = wcstoul( Value, NULL, 0 );
                                    break;
    
                                case DT_BOOLEAN:
                                    if (UnattendAnswer[i].UseMaskOnBool) {
                                        if (_wcsicmp( Value, L"yes" ) == 0 || _wcsicmp( Value, L"true" ) == 0) {
                                            *((LPDWORD)UnattendAnswer[i].DataPtr) |= UnattendAnswer[i].UseMaskOnBool;
                                        }
                                    } else {
                                        if (_wcsicmp( Value, L"yes" ) == 0 || _wcsicmp( Value, L"true" ) == 0) {
                                            *((LPDWORD)UnattendAnswer[i].DataPtr) = TRUE;
                                        } else {
                                            *((LPDWORD)UnattendAnswer[i].DataPtr) = FALSE;
                                        }
                                    }
                                    break;
    
                                default:
                                    break;
                            }                        
                        }
                    }
                }
            } while(SetupFindNextLine( &InfLine, &InfLine ));
        }
    }

    return TRUE;
}


BOOL
IsGoodComponent(
    IN LPWSTR ComponentId,
    IN LPWSTR SubcomponentId,
    IN LPWSTR TargetId
    )
{
    if (ComponentId == NULL || SubcomponentId == NULL) {
        return FALSE;
    }
    if (_wcsicmp( ComponentId, TargetId ) == 0 && _wcsicmp( SubcomponentId, TargetId ) == 0) {
        return TRUE;
    }
    return FALSE;
}


DWORD
FaxOcmSetupProc(
    IN LPWSTR ComponentId,
    IN LPWSTR SubcomponentId,
    IN UINT Function,
    IN UINT Param1,
    IN OUT PVOID Param2
    )
{
    
    DebugPrint(( TEXT("FaxOcmSetup proc called with function 0x%08x"), Function ));

    switch( Function ) {

        case OC_PREINITIALIZE:
            return OCFLAG_UNICODE;

        case OC_SET_LANGUAGE:
            return TRUE;

        case OC_INIT_COMPONENT:
            if (OCMANAGER_VERSION <= ((PSETUP_INIT_COMPONENT)Param2)->OCManagerVersion) {
                ((PSETUP_INIT_COMPONENT)Param2)->ComponentVersion = OCMANAGER_VERSION;
            } else {
                return ERROR_CALL_NOT_IMPLEMENTED;
            }

            if (SetupInitComponent.SetupData.OperationFlags & SETUPOP_STANDALONE) {
                return 0;
            }

            //
            // eventhough this call happens once for each component that this
            // dll installs, we really only need to do our thing once.  this is
            // because the data that ocm passes is really the same for all calls.
            //

            if (!ComponentInitialized) {
                CopyMemory( &SetupInitComponent, (LPVOID)Param2, sizeof(SETUP_INIT_COMPONENT) );

                Unattended = (SetupInitComponent.SetupData.OperationFlags & SETUPOP_BATCH) > 0;
                Upgrade = (SetupInitComponent.SetupData.OperationFlags & SETUPOP_NTUPGRADE) > 0;
                Win9xUpgrade = (SetupInitComponent.SetupData.OperationFlags & SETUPOP_WIN95UPGRADE) > 0;
                NtGuiMode = (SetupInitComponent.SetupData.OperationFlags & SETUPOP_STANDALONE) == 0;
                NtWorkstation = SetupInitComponent.SetupData.ProductType == PRODUCT_WORKSTATION;

                SourcePath = (LPWSTR) MemAlloc( StringSize(SetupInitComponent.SetupData.SourcePath) + MAX_PATH );
                if (!SourcePath) {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                wcscpy( SourcePath, SetupInitComponent.SetupData.SourcePath );
                if (SourcePath[wcslen(SourcePath)-1] != L'\\') {
                    wcscat( SourcePath, L"\\" );
                }

                if (NtGuiMode) {
#ifdef _X86_
                    wcscat( SourcePath, L"i386" );
#endif
#ifdef _ALPHA_
                    wcscat( SourcePath, L"alpha" );
#endif
                } else {
                    SourcePath = VerifyInstallPath(SourcePath);                    
                    DebugPrint(( TEXT("faxocm Sourcepath = %s\n"),SourcePath));
                }

                DebugPrint((L"faxocm - SourcePath = %s", SourcePath));
                if (NtGuiMode) {
                    Unattended = TRUE;
                }

                //
                // make sure our inf file is opened by sysoc correctly
                // if it isn't then try to open it ourself
                //
                if (SetupInitComponent.ComponentInfHandle == NULL) {
                    WCHAR InfPath[MAX_PATH];
                    LPWSTR p;

                    GetModuleFileName( hInstance, InfPath, sizeof(InfPath)/sizeof(WCHAR) );
                    p = wcsrchr( InfPath, L'\\' );
                    if (p) {
                        wcscpy( p+1, L"faxsetup.inf" );
                        SetupInitComponent.ComponentInfHandle = SetupOpenInfFile( InfPath, NULL, INF_STYLE_WIN4, NULL );
                        if (SetupInitComponent.ComponentInfHandle == INVALID_HANDLE_VALUE) {
                            return ERROR_FILE_NOT_FOUND;
                        }
                    } else {
                        return ERROR_FILE_NOT_FOUND;
                    }
                }

                SetupOpenAppendInfFile( NULL, SetupInitComponent.ComponentInfHandle, NULL );

                InitializeStringTable();

                //
                // do minimal mapi initialization for NtGuiMode setup
                //
                MyInitializeMapi(NtGuiMode);
                 

                GetInstallationInfo( &Installed, &InstallType, &InstalledPlatforms );

                if (NtGuiMode && (IsNt4or351Upgrade() || Win9xUpgrade)) {
                    //
                    // in this case, we should treat this as a fresh install of fax
                    //
                    Upgrade = FALSE;
                }

                if (!NtGuiMode) {
                    Upgrade = Installed;
                }

                EnumPlatforms[PROCESSOR_ARCHITECTURE_INTEL] =  0;
                EnumPlatforms[PROCESSOR_ARCHITECTURE_ALPHA] =  1;

                ComponentInitialized = TRUE;

                SYSTEM_INFO si;
                GetSystemInfo( &si );
                if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) {
                    SetEnvironmentVariable( L"platform", L"i386" );
                } else if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA) {
                    SetEnvironmentVariable( L"platform", L"alpha" );
                }

                SetWizData();
            }

            return 0;

        case OC_QUERY_CHANGE_SEL_STATE:
            if (NtGuiMode || (!Installed) || UnInstall) {
                return 0;
            }
            UnInstall = Param1 == 0;
            return 1;

        case OC_REQUEST_PAGES:
            {
                PSETUP_REQUEST_PAGES SetupRequestPages = (PSETUP_REQUEST_PAGES) Param2;

                if (NtGuiMode) {
                    //
                    // never return pages during gui-mode setup
                    //
                    return 0;
                }

                if (_wcsicmp( ComponentId, COMPONENT_FAX ) != 0) {
                    return 0;
                }

                if (Param1 == WizPagesWelcome) {
#ifdef NT5FAXINSTALL
                    return 0;
#else
                    SetupRequestPages->Pages[0] = GetWelcomeWizardPage();
                    return 1;
#endif
                }

                if (Param1 == WizPagesMode) {
#ifdef NT5FAXINSTALL
                    return 0;
#else
                    SetupRequestPages->Pages[0] = GetEulaWizardPage();
                    return 1;
#endif
                }

                if (Param1 == WizPagesFinal) {
#ifdef NT5FAXINSTALL
                    return 0;
#else
                    SetupRequestPages->Pages[0] = GetFinalWizardPage();
                    return 1;
#endif
                }
            }
            break;

        case OC_CALC_DISK_SPACE:
            if (NtGuiMode && !Upgrade) {
                CalcServerDiskSpace(
                    SetupInitComponent.ComponentInfHandle,
                    (HDSKSPC) Param2,
                    NULL,
                    Param1
                    );
            }
            break;

        case OC_QUEUE_FILE_OPS:
            if (!SubcomponentId || !*SubcomponentId) {
                return 0;
            }
            if (NtGuiMode && !Upgrade) {
                AddServerFilesToQueue(
                    SetupInitComponent.ComponentInfHandle,
                    (HSPFILEQ) Param2,
                    NULL
                    );
            }
            break;

        case OC_COMPLETE_INSTALLATION:
            if (!SubcomponentId || !*SubcomponentId) {
                return 0;
            }
            
            if (NtGuiMode) {
            
                ServerInstallation(
                    SetupInitComponent.HelperRoutines.QueryWizardDialogHandle(
                        SetupInitComponent.HelperRoutines.OcManagerContext
                        ),
                    SourcePath
                    );
            }
            break;

        case OC_QUERY_STEP_COUNT:
            if (!SubcomponentId || !*SubcomponentId) {
                return 0;
            }
            return ServerGetStepCount() * 10;

        case OC_CLEANUP:
            break;

        default:
            break;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ocm\pointprt.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    pointprt.cpp

Abstract:

    This file implements the code for point & print setup.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 10-Sept-1997

--*/

#include "faxocm.h"
#pragma hdrstop

BOOL
CopyClientFiles(
    LPWSTR SourceRoot
    );



BOOL
FaxPointPrintInstall(
    LPWSTR DirectoryName,
    LPWSTR PrinterName
    )
{
    WCHAR SourceDirectory[MAX_PATH];
    WCHAR FaxPrinterName[MAX_PATH];
    WCHAR ClientSetupServerName[MAX_PATH];
    LPWSTR p;
    DWORD len;
    HANDLE FaxHandle = INVALID_HANDLE_VALUE;

    ClientSetupServerName[0] = 0;

    len = wcslen(DirectoryName);
    wcscpy( SourceDirectory, DirectoryName );

    if (SourceDirectory[len-1] != L'\\') {
        SourceDirectory[len] = L'\\';
        SourceDirectory[len+1] = 0;
    }

    p = wcschr( &SourceDirectory[2], TEXT('\\') );
    if (p) {
        *p = 0;
        wcscpy( ClientSetupServerName, &SourceDirectory[2] );
        *p = TEXT('\\');
    }

    if (PrinterName[0] == L'\\' && PrinterName[1] == L'\\') {
        wcscpy( FaxPrinterName, PrinterName );
    } else {
        FaxPrinterName[0] = TEXT('\\');
        FaxPrinterName[1] = TEXT('\\');
        FaxPrinterName[2] = 0;
        wcscat( FaxPrinterName, PrinterName );
    }

    if (ClientSetupServerName[0]) {
        if (!FaxConnectFaxServer( ClientSetupServerName, &FaxHandle )) {
            return FALSE;
        } else {
            FaxClose( FaxHandle );
        }
    } 
    
    CopyClientFiles( SourceDirectory );
    SetClientRegistryData();
    DoExchangeInstall(NULL);
    CreateGroupItems( ClientSetupServerName );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ocm\faxocm.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <prsht.h>
#include <commctrl.h>
#include <setupapi.h>
#include <ocmanage.h>
#include <winspool.h>
#include <winsprlp.h>
#include <shellapi.h>
#include <lm.h>
#include <userenv.h>
#include <userenvp.h>
#include <tapi.h>
#include <shlobj.h>
#include <stdio.h>
#include <stdlib.h>
#include <aclapi.h>

#ifdef WX86
#include <wx86ofl.h>
#endif

#include "winfax.h"
#include "resource.h"

#define NO_FAX_LIST
#include "faxutil.h"

#include "faxreg.h"

//
// fax ocm component names
//
// WARNING:  if you change these strings, you must
//           also change the strings in the setup inf files
//

#define COMPONENT_FAX               L"Fax"
#define COMPONENT_FAX_CLIENT        L"Fax_Client"
#define COMPONENT_FAX_ADMIN         L"Fax_Remote_Admin"

#define DEFAULT_FAX_STORE_DIR       L"%systemroot%\\FaxStore"
#define FAX_SERVICE_NAME            L"Fax"
#define FAX_PRINTER_NAME            L"Fax"
#define OUTLOOKCONFIG_DIR           L"addins"
#define FAX_DRIVER_NAME             L"Windows NT Fax Driver"
#define FAX_MONITOR_NAME            L"Windows NT Fax Monitor"
#define FAX_MONITOR_FILE            L"msfaxmon.dll"
// #define FAX_SERVICE_DISPLAY_NAME    L"Fax Service"
#define FAX_SERVICE_IMAGE_NAME      L"%systemroot%\\system32\\faxsvc.exe"
#define FAX_SERVICE_DEPENDENCY      L"TapiSrv\0RpcSs\0PlugPlay\0Spooler\0"
#define WINNT_CURVER                L"Software\\Microsoft\\Windows NT\\CurrentVersion"
#define DIGID                       L"DigitalProductId"
#define REGKEY_PROFILES             L"\\ProfileList"
#define REGVAL_PROFILES             L"ProfilesDirectory"

#define FAXAB_SERVICE_NAME          L"MSFAX AB"
#define FAXXP_SERVICE_NAME          L"MSFAX XP"

#undef  StringSize
#define StringSize(_s)              (( _s ) ? (wcslen( _s ) + 1) * sizeof(WCHAR) : 0)

#define SecToNano(_sec)             (DWORDLONG)((_sec) * 1000 * 1000 * 10)
#define MinToNano(_min)             SecToNano((_min)*60)

#define COVERPAGE_EDITOR            L"%systemroot%\\system32\\faxcover.exe"
#define DEFAULT_FAX_PROFILE         L""

#define COVERPAGE_EXTENSION         L".cov"
#define COVERPAGE_ASSOC_NAME        L"Coverpage"
#define COVERPAGE_ASSOC_DESC        L"Fax Coverpage File"
#define COVERPAGE_OPEN_COMMAND      L"%SystemRoot%\\system32\\faxcover.exe \"%1\""
#define COVERPAGE_PRINT_COMMAND     L"%SystemRoot%\\system32\\faxcover.exe /p \"%1\""

#define EXCHANGE_CLIENT_EXT_NAME    "FaxExtension"
#define EXCHANGE_CLIENT_EXT_NAMEW   L"FaxExtension"
#define EXCHANGE_CLIENT_EXT_FILE    "%windir%\\system32\\faxext32.dll"
#define EXCHANGE_CONTEXT_MASK       "00000100000000"

#define DIRID_COVERPAGE             66001
#define DIRID_CLIENTS               66002
#define DIRID_OUTLOOK_ECF           66003

#define FILEQ_FLAG_ENV              1
#define FILEQ_FLAG_SHELL            2

#define SETUP_ACTION_NONE           0
#define SETUP_ACTION_COPY           1
#define SETUP_ACTION_DELETE         2

//
// BugBug...  If the CLSID global REGKEY_MYCLSID changes in fax\shellext, then this must also change
//
#define FAXSHELL_CLSID              L"{7f9609be-af9a-11d1-83e0-00c04fb6e984}"


#define EMPTY_STRING                L""



typedef struct _WIZ_DATA {
    DWORD       RoutingMask;
    DWORD       Rings;
    DWORD       ArchiveOutgoing;
    WCHAR       Csid[128];
    WCHAR       Tsid[128];
    WCHAR       RoutePrinterName[128];
    WCHAR       RouteDir[MAX_PATH];
    WCHAR       RouteProfile[128];
    WCHAR       UserName[128];
    WCHAR       PhoneNumber[128];
    WCHAR       PrinterName[128];
    WCHAR       ArchiveDir[MAX_PATH];
} WIZ_DATA, *PWIZ_DATA;

typedef struct _LINE_INFO {
    DWORD       PermanentLineID;
    BOOL        Selected;
    LPWSTR      DeviceName;
    LPWSTR      ProviderName;
    DWORD       Rings;
    DWORD       Flags;
} LINE_INFO, *PLINE_INFO;

typedef struct _SECURITY_INFO {
    WCHAR       AccountName[256];
    WCHAR       Password[256];
} SECURITY_INFO, *PSECURITY_INFO;

typedef struct _PLATFORM_INFO {
    LPWSTR      PrintPlatform;
    LPWSTR      OsPlatform;
    BOOL        Selected;
    DWORD       Mask;
    LPWSTR      DriverDir;
    BOOL        ThisPlatform;
} PLATFORM_INFO, *PPLATFORM_INFO;

typedef struct _WIZPAGE {
    DWORD           ButtonState;
    DWORD           PageId;
    DWORD           DlgId;
    DLGPROC         DlgProc;
    DWORD           Title;
    DWORD           SubTitle;
} WIZPAGE, *PWIZPAGE;

typedef struct _FILE_QUEUE_INFO {
    LPWSTR      SectionName;
    DWORD       InfDirId;
    LPWSTR      DirName;
    DWORD       Flags;
    DWORD       ShellId;
} FILE_QUEUE_INFO, *PFILE_QUEUE_INFO;

typedef struct _FILE_QUEUE_CONTEXT {
    HWND        hwnd;
    PVOID       QueueContext;
} FILE_QUEUE_CONTEXT, *PFILE_QUEUE_CONTEXT;

//
// group flags
//

#define USE_COMMON_GROUP        0x00000001    // do not use USE_USER_GROUP and USE_COMMON_GROUP
#define USE_USER_GROUP          0x00000002    //   together, they are mutually exclusive
#define USE_APP_PATH            0x00000004    // commandline must contain the subkey name
#define USE_SERVER_NAME         0x00000008    // if we're doing a client install the append the server name to the command line
#define USE_SHELL_PATH          0x00000010    // use CSIDL_COMMON_APPPATH in front of exe path
#define USE_SUBDIR              0x00000020    // create a subdir, don't set the working directory

typedef struct GROUP_ITEM {
    DWORD       ResourceID;
    TCHAR       Name[MAX_PATH];
} GROUP_ITEM, *PGROUPITEM;


typedef struct _GROUP_ITEMS {
    GROUP_ITEM  GroupName;
    GROUP_ITEM  Description;    
    GROUP_ITEM  CommandLine;
    GROUP_ITEM  IconPath;
    GROUP_ITEM  WorkingDirectory;
    DWORD       Flags;
    INT         IconIndex;
    INT         ShowCmd;
    WORD        HotKey;
    GROUP_ITEM  InfoTip;
} GROUP_ITEMS, *PGROUP_ITEMS;

typedef struct _MDM_DEVSPEC {
    DWORD Contents;                                 // Set to 1 (indicates containing key)
    DWORD KeyOffset;                                // Offset to key from start of this struct.
                                                    // (not from start of LINEDEVCAPS ).
                                                    //  8 in our case.
    CHAR String[1];                                 // place containing null-terminated registry key.
} MDM_DEVSPEC, *PMDM_DEVSPEC;

typedef struct {
    HANDLE  hComm;
    CHAR    szDeviceName[1];
} DEVICEID, *PDEVICEID;

typedef enum _DATAYPE {
   DT_STRING,
   DT_LONGINT,
   DT_BOOLEAN,
   DT_NONE,
} DATATYPE;

typedef struct _UNATTEND_ANSWER {
    LPWSTR      KeyName;
    DATATYPE    DataType;
    DWORD       UseMaskOnBool;
    LPVOID      DataPtr;
} UNATTEND_ANSWER, *PUNATTEND_ANSWER;


extern HINSTANCE hInstance;
extern SETUP_INIT_COMPONENT SetupInitComponent;
extern BOOL Unattended;
extern BOOL Upgrade;
extern BOOL NtGuiMode;
extern BOOL NtWorkstation;
extern DWORD FaxDevices;
extern BOOL UnInstall;
extern PLINE_INFO LineInfo;
extern "C" BOOL MapiAvail;
extern WORD EnumPlatforms[4];
extern DWORD InstalledPlatforms;
extern DWORD CountPlatforms;
extern PLATFORM_INFO Platforms[];
extern BOOL RemoteAdminSetup;
extern BOOL RebootRequired;
extern BOOL SuppressReboot;
extern BOOL PointPrintSetup;
extern DWORD InstallThreadError;
extern BOOL OkToCancel;
extern WCHAR ClientSetupServerName[MAX_PATH];
extern WCHAR ThisPlatformName[MAX_PATH];
extern DWORD CurrentCountryId;
extern LPWSTR CurrentAreaCode;
extern DWORD InstallType;
extern DWORD Installed;
extern WIZ_DATA WizData;


#define WM_MY_PROGRESS              (WM_USER+100)

LPWSTR
GetString(
    DWORD ResourceId
    );

BOOL
StopFaxService(
    VOID
    );

DWORD
DeviceInitialization(
    HWND hwnd
    );

BOOL
SetWizData(
    VOID
    );

INT_PTR
SecurityErrorDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
CommonDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
DeviceStatusDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
WelcomeDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
FinalDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
EulaDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
PlatformsDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
FileCopyDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
LastPageDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
LastPageUninstallDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
ServerNameDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
StationIdDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
RoutePrintDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
RouteStoreDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
RouteMailDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
RouteSecurityDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
ClientServerNameDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
ClientUserInfoDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
ClientFileCopyDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
PrinterNameDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
RemoteAdminFileCopyDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
DeviceSelectionDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
ExchangeDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
LastClientPageDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

PVOID
MyEnumPrinters(
    LPWSTR  pServerName,
    DWORD   level,
    PDWORD  pcPrinters,
    DWORD   Flags
    );

BOOL
IsPrinterFaxPrinter(
    LPWSTR PrinterName
    );

int
PopUpMsg(
    HWND hwnd,
    DWORD ResourceId,
    BOOL Error,
    DWORD Type
    );

BOOL
UnAttendGetAnswer(
    DWORD ControlId,
    LPBYTE AnswerBuf,
    DWORD AnswerBufSize
    );

extern"C"
BOOL
GetMapiProfiles(
    HWND hwnd,
    DWORD ResourceId
    );

extern"C"
BOOL
GetDefaultMapiProfile(
    LPWSTR ProfileName
    );

DWORD
DoUninstall(
    VOID
    );

DWORD
ServerInstallation(
    HWND hwnd,
    LPWSTR SourceRoot
    );

BOOL
DoBrowseDestDir(
    HWND    hDlg
    );

BOOL
GetUserInformation(
    LPWSTR *UserName,
    LPWSTR *FaxNumber,
    LPWSTR *AreaCode
    );

DWORD
ClientFileCopyThread(
    HWND hwnd
    );

DWORD
PointPrintFileCopyThread(
    HWND hwnd
    );

DWORD
RemoteAdminCopyThread(
    HWND hwnd
    );

VOID
SetWizPageTitle(
    HWND hWnd
    );

DWORD
GetModemClass(
    HANDLE hFile
    );

BOOL
CreateServerFaxPrinter(
    HWND hwnd,
    LPWSTR FaxPrinterName
    );

DWORD
StartFaxService(
    VOID
    );

VOID
CreateGroupItems(
    LPWSTR ServerName
    );

VOID
DeleteNt4Group(
    VOID
    );

//
// fileq.c
//

BOOL
InitializeFileQueue(
    HWND hwnd,
    HINF *SetupInf,
    HSPFILEQ **FileQueue,
    PVOID *QueueContext,
    LPWSTR SourceRoot
    );

BOOL
ProcessFileQueue(
    HINF SetupInf,
    HSPFILEQ *FileQueue,
    PVOID QueueContext,
    LPWSTR SourceRoot,
    PFILE_QUEUE_INFO FileQueueInfo,
    DWORD CountFileQueueInfo,
    PSP_FILE_CALLBACK MyQueueCallback,
    DWORD ActionId
    );

BOOL
CloseFileQueue(
    HSPFILEQ *FileQueue,
    PVOID QueueContext
    );

UINT
InstallQueueCallback(
    IN PVOID QueueContext,
    IN UINT  Notification,
    IN UINT  Param1,
    IN UINT  Param2
    );

VOID
SetProgress(
    DWORD StatusString
    );

BOOL
SetClientRegistryData(
    VOID
    );

BOOL
SetInstalledFlag(
    BOOL Installed
    );

BOOL
SetInstallType(
    DWORD InstallType
    );


DWORD
CreateClientFaxPrinter(
    HWND hwnd,
    LPWSTR FaxPrinterName
    );

BOOL
InstallHelpFiles(
    VOID
    );

VOID
DoExchangeInstall(
    HWND hwnd
    );

LPWSTR
RemoveLastNode(
    LPWSTR Path
    );

BOOL
PlatformOverride(
    LPWSTR   ThisPlatformName,
    LPWSTR   Override,
    LPWSTR   SourceRoot,
    LPWSTR   Result
    );

BOOL
StartSpoolerService(
    VOID
    );

BOOL
MyDeleteFile(
    LPWSTR FileName
    );

int
PopUpMsgFmt(
    HWND hwnd,
    DWORD ResourceId,
    BOOL Error,
    DWORD Type,
    ...
    );

LPWSTR
GetProductName(
    VOID
    );

DWORD
ExtraChars(
    HWND hwnd,
    LPWSTR TextBuffer
    );

LPWSTR
CompactFileName(
    LPCTSTR FileNameIn,
    DWORD CharsToRemove
    );

DWORD
MyStartService(
    LPWSTR ServiceName
    );

BOOL
SetServerRegistryData(
    LPWSTR SourceRoot
    );

BOOL
SetSoundRegistryData(
    VOID
    );

VOID
DeleteModemRegistryKey(
    VOID
    );

BOOL
SetInstalledPlatforms(
    DWORD PlatformsMask
    );

BOOL
InstallFaxService(
    BOOL UseLocalSystem,
    BOOL DemandStart,
    LPWSTR AccountName,
    LPWSTR Password
    );

BOOL
RenameFaxService(
    VOID
    );

BOOL
SetServiceAccount(
    LPWSTR ServiceName,
    PSECURITY_INFO SecurityInfo
    );

BOOL
DeleteFaxService(
    VOID
    );

BOOL
AddPrinterDrivers(
    VOID
    );

BOOL
CreateNetworkShare(
    LPWSTR Path,
    LPWSTR ShareName,
    LPWSTR Comment
    );

DWORD
SetServiceSecurity(
    LPWSTR AccountName
    );

BOOL
CallModemInstallWizard(
   HWND hwnd
   );

BOOL
DeleteFaxPrinters(
    HWND hwnd
    );

BOOL
DeleteDirectoryTree(
    LPWSTR Root
    );

BOOL
DeleteFaxRegistryData(
    VOID
    );

BOOL
DeleteRegistryTree(
    HKEY hKey,
    LPWSTR SubKey
    );

BOOL
MyDeleteService(
    LPWSTR ServiceName
    );

VOID
DeleteGroupItems(
    VOID
    );

extern "C"
BOOL
DeleteFaxMsgServices(
    VOID
    );

BOOL
DeleteNetworkShare(
    LPWSTR ShareName
    );

extern "C"
VOID
AddFaxAbToMapiSvcInf(
    LPWSTR SystemPath
    );

extern "C"
VOID
AddFaxXpToMapiSvcInf(
    LPWSTR SystemPath
    );

extern "C"
BOOL
InstallExchangeClientExtension(
    LPSTR ExtensionName,
    LPSTR ExtensionKey,
    LPSTR FileName,
    LPSTR  ContextMask
    );

extern "C"
BOOL
GetExchangeInstallCommand(
    LPWSTR InstallCommand
    );

extern "C"
BOOL
CreateDefaultMapiProfile(
    LPWSTR ProfileName
    );

extern "C"
BOOL
InstallFaxAddressBook(
    HWND hwnd,
    LPWSTR ProfileName
    );

extern "C"
BOOL
InstallFaxTransport(
    LPWSTR ProfileNameW
    );

extern "C"
BOOL
IsMapiServiceInstalled(
    LPWSTR ProfileNameW,
    LPWSTR ServiceNameW
    );

extern "C"
DWORD
IsExchangeRunning(
    VOID
    );

extern "C"
BOOL
InitializeMapi(
    BOOL MinimalInit
    );

BOOL
MyInitializeMapi(
    BOOL  MinimalInit
);


VOID
InitializeStringTable(
    VOID
    );

BOOL
GetInstallationInfo(
    LPDWORD Installed,
    LPDWORD InstallType,
    LPDWORD InstalledPlatforms
    );

HPROPSHEETPAGE
GetWelcomeWizardPage(
    VOID
    );

HPROPSHEETPAGE
GetEulaWizardPage(
    VOID
    );

HPROPSHEETPAGE
GetFinalWizardPage(
    VOID
    );

VOID
CenterWindow(
    HWND hwnd,
    HWND hwndToCenterOver
    );

BOOL
AddServerFilesToQueue(
    HINF SetupInf,
    HSPFILEQ FileQueue,
    LPWSTR SourceRoot
    );

BOOL
CalcServerDiskSpace(
    HINF SetupInf,
    HDSKSPC DiskSpace,
    LPWSTR SourceRoot,
    BOOL AddToQueue
    );

BOOL
CreateLocalFaxPrinter(
   LPWSTR FaxPrinterName
   );

BOOL
RecreateNt5Beta3FaxPrinters(
    VOID
    );

BOOL
RecreateNt4FaxPrinters(
   VOID
   );

DWORD
ServerGetStepCount(
    VOID
    );

BOOL
RegisterOleControlDlls(
    HINF hInf
    );

BOOL
SetServiceWorldAccessMask(
    SC_HANDLE hService,
    DWORD AccessMask
    );

BOOL 
SetKeySecurity(
    HKEY hKey
    );

LPWSTR
VerifyInstallPath(
    LPWSTR SourcePath
    );

BOOL
SetFaxShellExtension(
    LPCWSTR Path
    );

BOOL
IsNt4or351Upgrade(
    VOID
    );


BOOL
MyGetSpecialPath(
    INT Id,
    LPWSTR Buffer
    );

BOOL
SuperHideDirectory(
    PWSTR Directory
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ocm\help.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    help.c

Abstract:

    This file implements the code for the help file installation.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "faxocm.h"
#pragma hdrstop



#define HELP_INDEX_TAG          ":Index "
#define HELP_INDEX_SEP          '='
#define CRLF                    "\r\n"
#define FAX_HELP_STRING         ":Index Fax Help=fax.hlp"
#define FAX_HELP_TAG            "Fax Help"
#define HELP_INDEX_TAG_LEN      7
#define FAX_HELP_TAG_LEN        8
#define FAX_HELP_STRING_LEN     23
#define CRLF_LEN                2


BOOL
InstallHelpFiles(
    VOID
    )
{
    BOOL rVal = FALSE;
    TCHAR Buffer[MAX_PATH];
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hMap = NULL;
    LPSTR fPtr = NULL;
    LPSTR p,s;
    DWORD FileSize;
    INT cmp;


    ExpandEnvironmentStrings( L"%windir%\\system32\\windows.cnt", Buffer, sizeof(Buffer) );

    hFile = CreateFile(
        Buffer,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );
    if (hFile == INVALID_HANDLE_VALUE) {
        goto exit;
    }

    FileSize = GetFileSize( hFile, NULL );
    if (FileSize == 0xffffffff) {
        goto exit;
    }

    hMap = CreateFileMapping(
        hFile,
        NULL,
        PAGE_READWRITE,
        0,
        FileSize + 1024,
        NULL
        );
    if (!hMap) {
        goto exit;
    }

    fPtr = (LPSTR) MapViewOfFile(
        hMap,
        FILE_MAP_ALL_ACCESS,
        0,
        0,
        0
        );
    if (!fPtr) {
        goto exit;
    }

    p = fPtr;
    while (p<fPtr+FileSize) {
        if (_strnicmp( p, HELP_INDEX_TAG, HELP_INDEX_TAG_LEN ) == 0) {
            p += HELP_INDEX_TAG_LEN;
            s = strchr( p, HELP_INDEX_SEP );
            if (s) {
                cmp = (INT)strncmp( p, FAX_HELP_TAG, (ULONG)(s-p) );
                if (cmp == 0) {
                    //
                    // fax help is already installed
                    //
                    goto exit;
                } else if (cmp > 0) {
                    //
                    // this is where we insert it
                    //
                    p -= HELP_INDEX_TAG_LEN;
                    MoveMemory( p+FAX_HELP_STRING_LEN+CRLF_LEN, p, FileSize-(p-fPtr) );
                    CopyMemory( p, FAX_HELP_STRING, FAX_HELP_STRING_LEN );
                    p += FAX_HELP_STRING_LEN;
                    CopyMemory( p, CRLF, CRLF_LEN );
                    UnmapViewOfFile( fPtr );
                    CloseHandle( hMap );
                    fPtr = NULL;
                    hMap = NULL;
                    SetFilePointer( hFile, FileSize+FAX_HELP_STRING_LEN+CRLF_LEN, NULL, FILE_BEGIN );
                    SetEndOfFile( hFile );
                    break;
                }
            }
        }
        //
        // skip to the next line
        //
        while( *p != '\n' ) p++;
        p += 1;
    }

    ExpandEnvironmentStrings( L"%windir%\\system32\\windows.gid", Buffer, sizeof(Buffer) );
    MyDeleteFile( Buffer );

    ExpandEnvironmentStrings( L"%windir%\\system32\\windows.fts", Buffer, sizeof(Buffer) );
    MyDeleteFile( Buffer );

    ExpandEnvironmentStrings( L"%windir%\\system32\\windows.ftg", Buffer, sizeof(Buffer) );
    MyDeleteFile( Buffer );

    rVal = TRUE;

exit:
    if (fPtr) {
        UnmapViewOfFile( fPtr );
    }
    if (hMap) {
        CloseHandle( hMap );
    }
    if (hFile) {
        CloseHandle( hFile );
    }

    return rVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ocm\registry.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    This file provides access to the registry.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "faxocm.h"
#pragma hdrstop


BOOL
CreateDeviceProvider(
    HKEY hKey,
    LPWSTR ProviderKey,
    LPWSTR FriendlyName,
    LPWSTR ImageName,
    LPWSTR ProviderName
    )
{
    hKey = OpenRegistryKey( hKey, ProviderKey, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        DebugPrint(( L"could not create/open registry key (test)" ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, REGVAL_FRIENDLY_NAME, FriendlyName )) {
        DebugPrint(( L"could not add friendly name value" ));
        return FALSE;
    }

    if (!SetRegistryStringExpand( hKey, REGVAL_IMAGE_NAME, ImageName )) {
        DebugPrint(( L"could not add image name value" ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, REGVAL_PROVIDER_NAME, ProviderName )) {
        DebugPrint(( L"could not add provider name value" ));
        return FALSE;
    }

    RegCloseKey( hKey );

    return TRUE;
}


BOOL
CreateRoutingMethod(
    HKEY hKey,
    LPWSTR MethodName,
    LPWSTR FunctionName,
    LPWSTR FriendlyName,
    LPWSTR Guid,
    DWORD Priority
    )
{
    hKey = OpenRegistryKey( hKey, MethodName, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        DebugPrint(( L"could not create/open registry key for routing method" ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, REGVAL_FUNCTION_NAME, FunctionName )) {
        DebugPrint(( L"could not add function name value" ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, REGVAL_FRIENDLY_NAME, FriendlyName )) {
        DebugPrint(( L"could not add friendly name value" ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, REGVAL_GUID, Guid )) {
        DebugPrint(( L"could not add function name value" ));
        return FALSE;
    }

    if (!SetRegistryDword( hKey, REGVAL_ROUTING_PRIORITY, Priority )) {
        DebugPrint(( L"Could not set priority registry value" ));
    }

    RegCloseKey( hKey );

    return TRUE;
}


BOOL
CreateMicrosoftRoutingExtension(
    HKEY hKey,
    LPWSTR RoutingKey,
    LPWSTR FriendlyName,
    LPWSTR ImageName
    )
{
    HKEY hKeyMethods;


    hKey = OpenRegistryKey( hKey, RoutingKey, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        DebugPrint(( L"could not create/open registry key for routing extension" ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, REGVAL_FRIENDLY_NAME, FriendlyName )) {
        DebugPrint(( L"could not add friendly name value" ));
        return FALSE;
    }

    if (!SetRegistryStringExpand( hKey, REGVAL_IMAGE_NAME, ImageName )) {
        DebugPrint(( L"could not add image name value" ));
        return FALSE;
    }

    hKeyMethods = OpenRegistryKey( hKey, REGKEY_ROUTING_METHODS, TRUE, KEY_ALL_ACCESS );
    if (!hKeyMethods) {
        DebugPrint(( L"could not create/open registry key for routing methods" ));
        return FALSE;
    }

    CreateRoutingMethod( hKeyMethods, REGKEY_ROUTING_METHOD_EMAIL,    REGVAL_RM_EMAIL_FUNCTION,    GetString(IDS_RT_EMAIL_FRIENDLY),    REGVAL_RM_EMAIL_GUID,    4 );
    CreateRoutingMethod( hKeyMethods, REGKEY_ROUTING_METHOD_FOLDER,   REGVAL_RM_FOLDER_FUNCTION,   GetString(IDS_RT_FOLDER_FRIENDLY),   REGVAL_RM_FOLDER_GUID,   1 );
    CreateRoutingMethod( hKeyMethods, REGKEY_ROUTING_METHOD_INBOX,    REGVAL_RM_INBOX_FUNCTION,    GetString(IDS_RT_INBOX_FRIENDLY),    REGVAL_RM_INBOX_GUID,    3 );
    CreateRoutingMethod( hKeyMethods, REGKEY_ROUTING_METHOD_PRINTING, REGVAL_RM_PRINTING_FUNCTION, GetString(IDS_RT_PRINT_FRIENDLY),    REGVAL_RM_PRINTING_GUID, 2 );

    
    RegCloseKey( hKeyMethods );
    RegCloseKey( hKey );

    return TRUE;
}


VOID
RegCreateFaxDevice(
    HKEY hKeyDev,
    DWORD PermanentLineID,
    DWORD Rings,
    DWORD Priority,
    DWORD Flags,
    LPWSTR DeviceName,
    LPWSTR ProviderName,
    LPWSTR Csid,
    LPWSTR Tsid,
    DWORD RoutingMask,
    LPWSTR RoutePrinterName,
    LPWSTR RouteDir,
    LPWSTR RouteProfile
    )
{
    HKEY hKey;
    HKEY hKeyRouting;
    WCHAR PortName[32];


    swprintf( PortName, L"%08d", PermanentLineID );

    hKey = OpenRegistryKey( hKeyDev, PortName, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        DebugPrint(( L"Could not open device registry key" ));
        return;
    }

    if (!SetRegistryDword( hKey, REGVAL_PERMANENT_LINEID, PermanentLineID )) {
        DebugPrint(( L"Could not set device id registry value" ));
    }

    if (!SetRegistryDword( hKey, REGVAL_FLAGS, Flags )) {
        DebugPrint(( L"Could not set device flags registry value" ));
    }

    if (!SetRegistryDword( hKey, REGVAL_RINGS, Rings )) {
        DebugPrint(( L"Could not set device rings registry value" ));
    }

    if (!SetRegistryDword( hKey, REGVAL_PRIORITY, Priority )) {
        DebugPrint(( L"Could not set device rings registry value" ));
    }

    if (!SetRegistryString( hKey, REGVAL_DEVICE_NAME, DeviceName )) {
        DebugPrint(( L"Could not set device name registry value" ));
    }

    if (!SetRegistryString( hKey, REGVAL_PROVIDER, ProviderName )) {
        DebugPrint(( L"Could not set provider name registry value" ));
    }

    if (!SetRegistryString( hKey, REGVAL_ROUTING_CSID, Csid )) {
        DebugPrint(( L"Could not set csid registry value" ));
    }

    if (!SetRegistryString( hKey, REGVAL_ROUTING_TSID, Tsid )) {
        DebugPrint(( L"Could not set csid registry value" ));
    }

    hKeyRouting = OpenRegistryKey( hKey, REGKEY_ROUTING, TRUE, KEY_ALL_ACCESS );
    if (!hKeyRouting) {
        DebugPrint(( L"Could not open routing registry key" ));
        return;
    }

    if (!SetRegistryString( hKeyRouting, REGVAL_ROUTING_PRINTER, RoutePrinterName )) {
        DebugPrint(( L"Could not set printer name registry value" ));
    }

    if (!SetRegistryString( hKeyRouting, REGVAL_ROUTING_DIR, RouteDir )) {
        DebugPrint(( L"Could not set routing dir registry value" ));
    }

    if (!SetRegistryString( hKeyRouting, REGVAL_ROUTING_PROFILE, RouteProfile )) {
        DebugPrint(( L"Could not set routing profile name registry value" ));
    }

    if (!SetRegistryDword( hKeyRouting, REGVAL_ROUTING_MASK, RoutingMask )) {
        DebugPrint(( L"Could not set routing mask registry value" ));
    }

    RegCloseKey( hKeyRouting );
    RegCloseKey( hKey );
}


BOOL
CreateFileAssociation(
    LPWSTR FileExtension,
    LPWSTR FileAssociationName,
    LPWSTR FileAssociationDescription,
    LPWSTR OpenCommand,
    LPWSTR PrintCommand,
    LPWSTR PrintToCommand,
    LPWSTR FileName,
    DWORD  IconIndex
    )
{
    LONG rVal = 0;
    HKEY hKey = NULL;
    HKEY hKeyOpen = NULL;
    HKEY hKeyPrint = NULL;
    HKEY hKeyPrintTo = NULL;
    HKEY hKeyIcon = NULL;
    DWORD Disposition = 0;
    WCHAR Buffer[MAX_PATH*2];


    rVal = RegCreateKeyEx(
        HKEY_CLASSES_ROOT,
        FileExtension,
        0,
        NULL,
        0,
        KEY_ALL_ACCESS,
        NULL,
        &hKey,
        &Disposition
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    rVal = RegSetValueEx(
        hKey,
        NULL,
        0,
        REG_SZ,
        (LPBYTE) FileAssociationName,
        StringSize( FileAssociationName )
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    RegCloseKey( hKey );

    rVal = RegCreateKeyEx(
        HKEY_CLASSES_ROOT,
        FileAssociationName,
        0,
        NULL,
        0,
        KEY_ALL_ACCESS,
        NULL,
        &hKey,
        &Disposition
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    rVal = RegSetValueEx(
        hKey,
        NULL,
        0,
        REG_SZ,
        (LPBYTE) FileAssociationDescription,
        StringSize( FileAssociationDescription )
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    rVal = RegCreateKeyEx(
        hKey,
        L"Shell\\Open\\Command",
        0,
        NULL,
        0,
        KEY_ALL_ACCESS,
        NULL,
        &hKeyOpen,
        &Disposition
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    rVal = RegSetValueEx(
        hKeyOpen,
        NULL,
        0,
        REG_EXPAND_SZ,
        (LPBYTE) OpenCommand,
        StringSize( OpenCommand )
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    if (PrintCommand) {
        rVal = RegCreateKeyEx(
            hKey,
            L"Shell\\Print\\Command",
            0,
            NULL,
            0,
            KEY_ALL_ACCESS,
            NULL,
            &hKeyPrint,
            &Disposition
            );
        if (rVal != ERROR_SUCCESS) {
            goto exit;
        }

        rVal = RegSetValueEx(
            hKeyPrint,
            NULL,
            0,
            REG_EXPAND_SZ,
            (LPBYTE) PrintCommand,
            StringSize( PrintCommand )
            );
        if (rVal != ERROR_SUCCESS) {
            goto exit;
        }
    }

    if (PrintToCommand) {
        rVal = RegCreateKeyEx(
            hKey,
            L"Shell\\Printto\\Command",
            0,
            NULL,
            0,
            KEY_ALL_ACCESS,
            NULL,
            &hKeyPrintTo,
            &Disposition
            );
        if (rVal != ERROR_SUCCESS) {
            goto exit;
        }

        rVal = RegSetValueEx(
            hKeyPrintTo,
            NULL,
            0,
            REG_EXPAND_SZ,
            (LPBYTE) PrintToCommand,
            StringSize( PrintToCommand )
            );
        if (rVal != ERROR_SUCCESS) {
            goto exit;
        }
    }

    if (FileName) {
        rVal = RegCreateKeyEx(
            hKey,
            L"DefaultIcon",
            0,
            NULL,
            0,
            KEY_ALL_ACCESS,
            NULL,
            &hKeyIcon,
            &Disposition
            );
        if (rVal != ERROR_SUCCESS) {
            goto exit;
        }

        wsprintf( Buffer, L"%s,%d", FileName, IconIndex );

        rVal = RegSetValueEx(
            hKeyIcon,
            NULL,
            0,
            REG_EXPAND_SZ,
            (LPBYTE) Buffer,
            StringSize( Buffer )
            );
        if (rVal != ERROR_SUCCESS) {
            goto exit;
        }
    }

exit:
    RegCloseKey( hKey );
    RegCloseKey( hKeyOpen );
    RegCloseKey( hKeyPrint );
    RegCloseKey( hKeyPrintTo );
    RegCloseKey( hKeyIcon );

    return rVal == ERROR_SUCCESS;
}


BOOL
SetServerRegistryData(
    LPWSTR SourceRoot
    )
{
    HKEY hKey;
    LONG rVal;
    DWORD i;
    HKEY hKeyDev;
    HANDLE hNull;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    WCHAR CmdLine[128];
    LPWSTR LodCmdLine;    
    LPWSTR LodSrcPath;


    //
    // set top level defaults
    //

    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        DebugPrint(( L"Could not open software registry key" ));
        return FALSE;
    }

    if (!Upgrade) {
        if (!SetKeySecurity(hKey) ) {
            DebugPrint(( L"Couldn't set key security" ));
            return FALSE;
        }
    }

    if (!Upgrade) {
        if (!SetRegistryDword( hKey, REGVAL_RETRIES, DEFAULT_REGVAL_RETRIES )) {
            DebugPrint(( L"Could not set retries registry value" ));
        }

        if (!SetRegistryDword( hKey, REGVAL_RETRYDELAY, DEFAULT_REGVAL_RETRYDELAY )) {
            DebugPrint(( L"Could not set retry delay registry value" ));
        }

        if (!SetRegistryDword( hKey, REGVAL_DIRTYDAYS, DEFAULT_REGVAL_DIRTYDAYS )) {
            DebugPrint(( L"Could not set dirty days registry value" ));
        }

        if (!SetRegistryDword( hKey, REGVAL_QUEUE_PAUSED, DEFAULT_REGVAL_QUEUE_PAUSED )) {
            DebugPrint(( L"Could not set queue paused registry value" ));
        }

        if (!SetRegistryDword( hKey, REGVAL_JOB_NUMBER, DEFAULT_REGVAL_JOB_NUMBER )) {
            DebugPrint(( L"Could not net job number registry value" ));
        }

        if (!SetRegistryDword( hKey, REGVAL_BRANDING, DEFAULT_REGVAL_BRANDING )) {
            DebugPrint(( L"Could not set branding registry value" ));
        }

        if (!SetRegistryDword( hKey, REGVAL_USE_DEVICE_TSID, DEFAULT_REGVAL_USEDEVICETSID )) {
            DebugPrint(( L"Could not set usedevicetsid registry value" ));
        }

        if (!SetRegistryString( hKey, REGVAL_INBOUND_PROFILE, EMPTY_STRING )) {
            DebugPrint(( L"Could not set inbound profile registry value" ));
        }

        if (!SetRegistryDword( hKey, REGVAL_SERVERCP, DEFAULT_REGVAL_SERVERCP )) {
            DebugPrint(( L"Could not set servercp registry value" ));
        }

        if (!SetRegistryDword( hKey, REGVAL_STARTCHEAP, DEFAULT_REGVAL_STARTCHEAP )) {
            DebugPrint(( L"Could not set startcheap registry value" ));
        }

        if (!SetRegistryDword( hKey, REGVAL_STOPCHEAP, DEFAULT_REGVAL_STOPCHEAP )) {
            DebugPrint(( L"Could not set stopcheap registry value" ));
        }

        if (WizData.ArchiveOutgoing) {
            if (!SetRegistryDword( hKey, REGVAL_ARCHIVEFLAG, 1 )) {
                DebugPrint(( L"Could not set archiveflag registry value" ));
            }

            if (!SetRegistryString( hKey, REGVAL_ARCHIVEDIR, WizData.ArchiveDir )) {
                DebugPrint(( L"Could not set archive dir registry value" ));
            }
        }

        RegCloseKey( hKey );
    }

    if (!Upgrade) {
        hKeyDev = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_FAX_DEVICES, TRUE, KEY_ALL_ACCESS );
        if (!hKey) {
            DebugPrint(( L"Could not open devices registry key" ));
            return FALSE;
        }

        //
        // enumerate the devices and create the registry data
        //

        for (i=0; i<FaxDevices; i++) {

            RegCreateFaxDevice(
                hKeyDev,
                LineInfo[i].PermanentLineID,
                LineInfo[i].Rings,
                i+1,
                LineInfo[i].Flags,
                LineInfo[i].DeviceName,
                LineInfo[i].ProviderName,
                WizData.Csid,
                WizData.Tsid,
                WizData.RoutingMask,
                WizData.RoutePrinterName,
                WizData.RouteDir,
                WizData.RouteProfile
                );

        }

        RegCloseKey( hKeyDev );
    }

    //
    // create the device providers
    //

    hKeyDev = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_DEVICE_PROVIDER_KEY, TRUE, KEY_ALL_ACCESS );
    if (!hKeyDev) {
        DebugPrint(( L"Could not open device provider registry key" ));
        return FALSE;
    }

    CreateDeviceProvider(
        hKeyDev,
        REGKEY_MODEM_PROVIDER,
        REGVAL_MODEM_FRIENDLY_NAME_TEXT,
        REGVAL_MODEM_IMAGE_NAME_TEXT,
        GetString(IDS_MODEM_PROVIDER_NAME)
        );

    RegCloseKey( hKeyDev );

    //
    // create the routing extensions
    //

    hKeyDev = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_ROUTING_EXTENSION_KEY, TRUE, KEY_ALL_ACCESS );
    if (!hKeyDev) {
        DebugPrint(( L"Could not open routing extension registry key" ));
        return FALSE;
    }

    CreateMicrosoftRoutingExtension(
        hKeyDev,
        REGKEY_ROUTING_EXTENSION,
        REGVAL_ROUTE_FRIENDLY_NAME,
        REGVAL_ROUTE_IMAGE_NAME
        );

    RegCloseKey( hKeyDev );

    //
    // set the co-class installer
    //

    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_CODEVICEINSTALLERS, TRUE, KEY_ALL_ACCESS );
    if (hKey) {
        DWORD Size;
        LPWSTR Class = GetRegistryStringMultiSz( hKey, REGVAL_MODEM_CODEVICE, EMPTY_STRING, &Size );
        if (Class) {
            LPWSTR p = Class;
            BOOL Found = FALSE;
            while (p && *p) {
                if (_wcsicmp( p, FAX_COCLASS_STRING ) == 0) {
                    Found = TRUE;
                    break;
                }
                p += (wcslen(p) + 1);
            }
            if (!Found) {
                LPBYTE NewClass = (LPBYTE) MemAlloc( StringSize(Class) + StringSize(FAX_COCLASS_STRING) + 16 );
                if (NewClass) {
                    CopyMemory( NewClass, Class, Size );
                    wcscpy( (LPWSTR)(NewClass+Size-sizeof(WCHAR)), FAX_COCLASS_STRING );
                    Size += StringSize(FAX_COCLASS_STRING);
                    SetRegistryStringMultiSz( hKey, REGVAL_MODEM_CODEVICE, (LPWSTR) NewClass, Size );
                    MemFree( NewClass );
                }
            }
            MemFree( Class );
        }
        RegCloseKey( hKey );
    }

    //
    // set the user's preferences
    //

    if (!Upgrade) {
        hKey = OpenRegistryKey( HKEY_CURRENT_USER, REGKEY_FAX_SETUP, TRUE, KEY_ALL_ACCESS );
        if (!hKey) {
            DebugPrint(( L"Could not open fax setup registry key" ));
            return FALSE;
        }
        
        if (!SetRegistryStringExpand( hKey, REGVAL_CP_LOCATION, GetString(IDS_PERSONAL_COVERPAGE) )) {
            DebugPrint(( L"Could not set coverpage dir registry value" ));
        }

        if (!SetRegistryString( hKey, REGVAL_CP_EDITOR, COVERPAGE_EDITOR )) {
            DebugPrint(( L"Could not set coverpage editor registry value" ));
        }

        RegCloseKey( hKey );
    }

    //
    // create the perfmon registry data
    //

    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_FAXPERF, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        DebugPrint(( L"Could not open fax perfmon registry key" ));
        return FALSE;
    }

    if (!SetRegistryStringExpand( hKey, REGVAL_OPEN, REGVAL_OPEN_DATA )) {
        DebugPrint(( L"Could not set perfmon registry value" ));
    }

    if (!SetRegistryStringExpand( hKey, REGVAL_CLOSE, REGVAL_CLOSE_DATA )) {
        DebugPrint(( L"Could not set perfmon registry value" ));
    }

    if (!SetRegistryStringExpand( hKey, REGVAL_COLLECT, REGVAL_COLLECT_DATA )) {
        DebugPrint(( L"Could not set perfmon registry value" ));
    }

    if (!SetRegistryStringExpand( hKey, REGVAL_LIBRARY, REGVAL_LIBRARY_DATA )) {
        DebugPrint(( L"Could not set perfmon registry value" ));
    }

    RegCloseKey( hKey );

    //
    // load the performance counters
    //

    hNull = CreateFile(
        L"nul",
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );

    if (hNull == INVALID_HANDLE_VALUE) {
        rVal = GetLastError();
        return FALSE;
    }

    GetStartupInfo( &si );
    si.hStdInput  = hNull;
    si.hStdOutput = hNull;
    si.hStdError  = hNull;
    si.dwFlags     = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_HIDE;

    wcscpy( CmdLine, L"unlodctr fax" );

    rVal = CreateProcess(
        NULL,
        CmdLine,
        NULL,
        NULL,
        TRUE,
        DETACHED_PROCESS,
        NULL,
        NULL,
        &si,
        &pi
        );

    if (!rVal) {
        rVal = GetLastError();
        return FALSE;
    }

    WaitForSingleObject( pi.hProcess, INFINITE );

    CloseHandle( pi.hProcess );
    CloseHandle( pi.hThread  );

    if (NtGuiMode) {
        LodCmdLine = ExpandEnvironmentString( L"lodctr %systemroot%\\system32\\faxperf.ini" );
        if (!LodCmdLine) {
            return FALSE;
        }
    } else {
        LodCmdLine = L"lodctr faxperf.ini";
        LodSrcPath = ExpandEnvironmentString( L"%systemroot%\\system32\\" );
    }

    wcscpy( CmdLine, LodCmdLine );

    rVal = CreateProcess(
        NULL,
        CmdLine,
        NULL,
        NULL,
        TRUE,
        DETACHED_PROCESS,
        NULL,
        NtGuiMode ? NULL : LodSrcPath,
        &si,
        &pi
        );

    if (!rVal) {
        rVal = GetLastError();
        return FALSE;
    }

    WaitForSingleObject( pi.hProcess, INFINITE );

    CloseHandle( pi.hProcess );
    CloseHandle( pi.hThread  );

    CloseHandle( hNull );

    CreateFileAssociation(
        COVERPAGE_EXTENSION,
        GetString(IDS_COVERPAGE),
        GetString(IDS_COVERPAGEDESC),
        COVERPAGE_OPEN_COMMAND,
        COVERPAGE_PRINT_COMMAND,
        NULL,
        NULL,
        0
        );

    return TRUE;
}


BOOL
SetClientRegistryData(
    VOID
    )
{
    HKEY hKey;


    if (!Upgrade) {

        hKey = OpenRegistryKey( HKEY_CURRENT_USER, REGKEY_USERINFO, TRUE, KEY_ALL_ACCESS );
        if (!hKey) {
            DebugPrint(( L"Could not open fax user info registry key" ));
            return FALSE;
        }

        if (!SetRegistryString( hKey, REGVAL_FULLNAME, WizData.UserName )) {
            DebugPrint(( L"Could not set user name registry value" ));
        }

        if (!SetRegistryString( hKey, REGVAL_FAX_NUMBER, WizData.PhoneNumber )) {
            DebugPrint(( L"Could not set fax phone number registry value" ));
        }

        if (!SetRegistryDword( hKey, REGVAL_LAST_COUNTRYID, CurrentCountryId )) {
            DebugPrint(( L"Could not set last country id registry value" ));
        }

        if (!SetRegistryDword( hKey, REGVAL_USE_DIALING_RULES, 0 )) {
            DebugPrint(( L"Could not set use dialing rules registry value" ));
        }

        if (!SetRegistryDword( hKey, REGVAL_ALWAYS_ON_TOP, BST_UNCHECKED )) {
            DebugPrint(( L"Could not set always on top registry value" ));
        }

        if (!SetRegistryDword( hKey, REGVAL_SOUND_NOTIFICATION, BST_UNCHECKED )) {
            DebugPrint(( L"Could not set sound notification registry value" ));
        }

        if (!SetRegistryDword( hKey, REGVAL_ENABLE_MANUAL_ANSWER, BST_UNCHECKED )) {
            DebugPrint(( L"Could not set enable manual answer registry value" ));
        }

        if (!SetRegistryDword( hKey, REGVAL_TASKBAR, BST_CHECKED )) {
            DebugPrint(( L"Could not set enable manual answer registry value" ));
        }

        if (!SetRegistryDword( hKey, REGVAL_VISUAL_NOTIFICATION, BST_CHECKED )) {
            DebugPrint(( L"Could not set visual notification registry value" ));
        }

        if (!SetRegistryString( hKey, REGVAL_LAST_RECAREACODE, CurrentAreaCode )) {
            DebugPrint(( L"Could not set area code registry value" ));
        }

        RegCloseKey( hKey );

        hKey = OpenRegistryKey( HKEY_CURRENT_USER, REGKEY_FAX_SETUP, TRUE, KEY_ALL_ACCESS );
        if (!hKey) {
            DebugPrint(( L"Could not open fax setup registry key" ));
            return FALSE;
        }

        if (!SetRegistryDword( hKey, REGVAL_FAXINSTALLED, TRUE )) {
            DebugPrint(( L"Could not set installed registry value" ));
        }

        if (!SetRegistryDword( hKey, REGVAL_FAXINSTALL_TYPE, FAX_INSTALL_NETWORK_CLIENT )) {
            DebugPrint(( L"Could not set install type registry value" ));
        }

        if (!SetRegistryStringExpand( hKey, REGVAL_CP_LOCATION, GetString(IDS_PERSONAL_COVERPAGE) )) {
            DebugPrint(( L"Could not set coverpage dir registry value" ));
        }

        if (!SetRegistryStringExpand( hKey, REGVAL_CP_EDITOR, COVERPAGE_EDITOR )) {
            DebugPrint(( L"Could not set coverpage editor registry value" ));
        }

        RegCloseKey( hKey );
    }

    CreateFileAssociation(
        COVERPAGE_EXTENSION,
        GetString(IDS_COVERPAGE),
        GetString(IDS_COVERPAGEDESC),
        COVERPAGE_OPEN_COMMAND,
        NULL,
        NULL,
        NULL,
        0
        );

    return TRUE;
}

BOOL
SetSoundRegistryData()
{
    HKEY hKey;
    LPWSTR SoundName;
    //
    // incoming fax
    //
    hKey = OpenRegistryKey( HKEY_CURRENT_USER, REGKEY_EVENT_LABEL_IN, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        DebugPrint(( L"Could not open event label registry key" ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, NULL, GetString(IDS_INCOMING ))) {
        DebugPrint(( L"Could not set event label registry value" ));
    }

    RegCloseKey( hKey );

    //
    // outgoing fax
    //
    hKey = OpenRegistryKey( HKEY_CURRENT_USER, REGKEY_EVENT_LABEL_OUT, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        DebugPrint(( L"Could not open event label registry key" ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, NULL, GetString(IDS_OUTGOING ))) {
        DebugPrint(( L"Could not set event label registry value" ));
    }

    RegCloseKey( hKey );


    //
    // default incoming event sound
    //
    hKey = OpenRegistryKey( HKEY_CURRENT_USER, REGKEY_SCHEMES_DEFAULT_IN, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        DebugPrint(( L"Could not open default sound registry key" ));
        return FALSE;
    }

    SoundName = ExpandEnvironmentString( L"%systemroot%\\Media\\ringin.wav" );

    if (!SetRegistryString( hKey, NULL, SoundName ? SoundName : L"ringin.wav" )) {
        DebugPrint(( L"Could not set default sound registry value" ));
    }

    RegCloseKey( hKey );

    //
    // current incoming event sound
    //
    hKey = OpenRegistryKey( HKEY_CURRENT_USER, REGKEY_SCHEMES_CURRENT_IN, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        DebugPrint(( L"Could not open current sound registry key" ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, NULL, SoundName ? SoundName : L"ringin.wav" )) {
        DebugPrint(( L"Could not set current sound registry value" ));
    }
    
    if (SoundName) {
        MemFree( SoundName );
    }

    RegCloseKey( hKey );

    //
    // default outgoing event sound
    //
    hKey = OpenRegistryKey( HKEY_CURRENT_USER, REGKEY_SCHEMES_DEFAULT_OUT, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        DebugPrint(( L"Could not open default sound registry key" ));
        return FALSE;
    }

    SoundName = ExpandEnvironmentString( L"%systemroot%\\Media\\ringout.wav" );

    if (!SetRegistryString( hKey, NULL, SoundName ? SoundName : L"ringout.wav" )) {
        DebugPrint(( L"Could not set default sound registry value" ));
    }

    RegCloseKey( hKey );

    //
    // current outgoing event sound
    //
    hKey = OpenRegistryKey( HKEY_CURRENT_USER, REGKEY_SCHEMES_CURRENT_OUT, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        DebugPrint(( L"Could not open current sound registry key" ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, NULL, SoundName ? SoundName : L"ringin.wav" )) {
        DebugPrint(( L"Could not set current sound registry value" ));
    }
    
    if (SoundName) {
        MemFree( SoundName );
    }

    RegCloseKey( hKey );

    return TRUE;
}


BOOL
GetInstallationInfo(
    LPDWORD Installed,
    LPDWORD InstallType,
    LPDWORD InstalledPlatforms
    )
{
    HKEY hKey;
    LONG rVal;


    if (Installed) {
        *Installed = 0;
    }
    if (InstallType) {
        *InstallType = 0;
    }
    if (InstalledPlatforms) {
        *InstalledPlatforms = 0;
    }

    rVal = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        REGKEY_FAX_SETUP,
        &hKey
        );
    if (rVal != ERROR_SUCCESS) {
        return FALSE;
    }

    if (Installed) {
        *Installed = GetRegistryDword( hKey, REGVAL_FAXINSTALLED );
    }
    if (InstallType) {
        *InstallType = GetRegistryDword( hKey, REGVAL_FAXINSTALL_TYPE );
    }

    if (InstalledPlatforms) {
        *InstalledPlatforms = GetRegistryDword( hKey, REGVAL_FAXINSTALLED_PLATFORMS );
    }

    RegCloseKey( hKey );

    return TRUE;
}


BOOL
SetInstalledFlag(
    BOOL Installed
    )
{
    HKEY hKey;
    HKEY hKeySetup;


    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_FAX_SETUP, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        DebugPrint(( L"Could not open setup registry key" ));
        return FALSE;
    }

    if (!SetRegistryDword( hKey, REGVAL_FAXINSTALLED, Installed )) {
        DebugPrint(( L"Could not set installed registry value" ));
    }

    hKeySetup = OpenRegistryKey( hKey, REGKEY_FAX_SETUP_ORIG, TRUE, KEY_ALL_ACCESS );
    if (!hKeySetup) {
        DebugPrint(( L"Could not open fax setup registry key" ));
        return FALSE;
    }

    if (!SetRegistryString( hKeySetup, REGVAL_ROUTING_PRINTER, WizData.RoutePrinterName )) {
        DebugPrint(( L"Could not set printer name registry value" ));
    }

    if (!SetRegistryString( hKeySetup, REGVAL_ROUTING_DIR, WizData.RouteDir )) {
        DebugPrint(( L"Could not set routing dir registry value" ));
    }

    if (!SetRegistryString( hKeySetup, REGVAL_ROUTING_PROFILE, WizData.RouteProfile )) {
        DebugPrint(( L"Could not set routing profile name registry value" ));
    }

    if (!SetRegistryString( hKeySetup, REGVAL_ROUTING_CSID, WizData.Csid )) {
        DebugPrint(( L"Could not set routing csid registry value" ));
    }

    if (!SetRegistryString( hKeySetup, REGVAL_ROUTING_TSID, WizData.Tsid )) {
        DebugPrint(( L"Could not set routing tsid registry value" ));
    }

    if (!SetRegistryDword( hKeySetup, REGVAL_ROUTING_MASK, WizData.RoutingMask )) {
        DebugPrint(( L"Could not set routing mask registry value" ));
    }

    if (!SetRegistryDword( hKeySetup, REGVAL_RINGS, WizData.Rings )) {
        DebugPrint(( L"Could not set rings registry value" ));
    }

    RegCloseKey( hKeySetup );
    RegCloseKey( hKey );

    return TRUE;
}


BOOL
SetInstallType(
    DWORD InstallType
    )
{
    HKEY hKey;


    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_FAX_SETUP, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        DebugPrint(( L"Could not open setup registry key" ));
        return FALSE;
    }

    InstallType |= GetRegistryDword( hKey, REGVAL_FAXINSTALL_TYPE );

    if (!SetRegistryDword( hKey, REGVAL_FAXINSTALL_TYPE, InstallType )) {
        DebugPrint(( L"Could not set install type registry value" ));
    }

    RegCloseKey( hKey );

    return TRUE;
}


BOOL
SetInstalledPlatforms(
    DWORD PlatformsMask
    )
{
    HKEY hKey;


    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_FAX_SETUP, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        DebugPrint(( L"Could not open setup registry key" ));
        return FALSE;
    }

    PlatformsMask |= GetRegistryDword( hKey, REGVAL_FAXINSTALLED_PLATFORMS );

    if (!SetRegistryDword( hKey, REGVAL_FAXINSTALLED_PLATFORMS, PlatformsMask )) {
        DebugPrint(( L"Could not set install type registry value" ));
    }

    RegCloseKey( hKey );

    return TRUE;
}


BOOL
DeleteRegistryTree(
    HKEY hKey,
    LPWSTR SubKey
    )
{
    LONG Rval;
    HKEY hKeyCur;
    WCHAR KeyName[256];
    DWORD KeyNameSize;
    FILETIME FileTime;
    DWORD KeyCount;


    Rval = RegOpenKeyEx( hKey, SubKey, 0, KEY_ALL_ACCESS, &hKeyCur );
    if (Rval != ERROR_SUCCESS) {
        return FALSE;
    }

    KeyCount = GetSubKeyCount( hKeyCur );
    if (KeyCount == 0) {
        RegCloseKey( hKeyCur );
        RegDeleteKey( hKey, SubKey );
        return TRUE;
    }

    while( TRUE ) {
        KeyNameSize = sizeof(KeyName);
        Rval = RegEnumKeyEx( hKeyCur, 0, KeyName, &KeyNameSize, 0, NULL, NULL, &FileTime );
        if (Rval == ERROR_NO_MORE_ITEMS) {
            break;
        } else if (Rval != ERROR_SUCCESS) {
            RegCloseKey( hKeyCur );
            return FALSE;
        }

        if (!DeleteRegistryTree( hKeyCur, KeyName )) {
            RegCloseKey( hKeyCur );
            return FALSE;
        }
    }

    RegCloseKey( hKeyCur );
    RegDeleteKey( hKey, SubKey );

    return TRUE;
}


BOOL
DeleteFaxRegistryData(
    VOID
    )
{
    LONG  Rval;
    HKEY  hKeyCur;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    HANDLE hNull;
    WCHAR CmdLine[128];


    DeleteRegistryTree( HKEY_LOCAL_MACHINE, REGKEY_FAXSERVER       );
    DeleteRegistryTree( HKEY_CURRENT_USER,  REGKEY_FAXSERVER       );
    DeleteRegistryTree( HKEY_CURRENT_USER,  REGKEY_EVENT_LABEL_IN  );
    DeleteRegistryTree( HKEY_CURRENT_USER,  REGKEY_EVENT_LABEL_OUT );
    DeleteRegistryTree( HKEY_CURRENT_USER,  REGKEY_FAXSTAT         );

    Rval = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            L"Software\\Microsoft\\Exchange\\Client\\Extensions" ,
            0,
            KEY_ALL_ACCESS,
            &hKeyCur
            );
    if (Rval == ERROR_SUCCESS) {

        RegDeleteValue( hKeyCur, EXCHANGE_CLIENT_EXT_NAMEW );

        RegCloseKey( hKeyCur );
    }

    //
    // unload the performance counters
    //

    hNull = CreateFile(
        L"nul",
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );
    if (hNull != INVALID_HANDLE_VALUE) {

        GetStartupInfo( &si );
        si.hStdInput  = hNull;
        si.hStdOutput = hNull;
        si.hStdError  = hNull;
        si.dwFlags    = STARTF_USESTDHANDLES;

        wcscpy( CmdLine, L"unlodctr fax" );

        if (CreateProcess(
            NULL,
            CmdLine,
            NULL,
            NULL,
            TRUE,
            DETACHED_PROCESS,
            NULL,
            NULL,
            &si,
            &pi
            ))
        {
            WaitForSingleObject( pi.hProcess, INFINITE );
            CloseHandle( pi.hThread );
            CloseHandle( pi.hProcess );
        }

        CloseHandle( hNull );
    }

    return TRUE;
}


VOID
DeleteModemRegistryKey(
    VOID
    )
{
    HKEY hKeyDev;
    INT rVal;
    DWORD MaxSubKeyLen;
    LPWSTR KeyNameBuf;
    DWORD i;
    DWORD SubKeyLen;
    DWORD KeyNameLen;

    rVal = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        REGKEY_FAX_DEVICES,
        0,
        KEY_ALL_ACCESS,
        &hKeyDev
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( L"Could not open devices registry key, ec=0x%08x", rVal ));
        return;
    }

    MaxSubKeyLen = GetMaxSubKeyLen( hKeyDev );
    if (!MaxSubKeyLen) {
        return;
    }

    KeyNameLen =
        MaxSubKeyLen +
        sizeof(WCHAR) +
        wcslen( REGKEY_MODEM ) +
        sizeof(WCHAR) +
        32;

    KeyNameBuf = (LPWSTR) MemAlloc( KeyNameLen );

    if (KeyNameBuf == NULL) {
        DebugPrint(( L"DeleteModemRegistryKey: MemAlloc failed"  ));
        return;
    }

    rVal = ERROR_SUCCESS;
    i = 0;

    while (TRUE) {

        SubKeyLen = MaxSubKeyLen + sizeof(WCHAR);

        rVal = RegEnumKeyEx(
                    hKeyDev,
                    i++,
                    KeyNameBuf,
                    &SubKeyLen,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );
        if (rVal != ERROR_SUCCESS) {
            break;
        }

        swprintf( &KeyNameBuf[SubKeyLen], L"\\%s" , REGKEY_MODEM );

        DeleteRegistryTree( hKeyDev, KeyNameBuf );

    };

    RegCloseKey( hKeyDev );
}



BOOL
ResetFileAssociation(
    LPWSTR FileExtension,
    LPWSTR FileAssociationName
    )
{
    HKEY hKey;


    hKey = OpenRegistryKey( HKEY_CLASSES_ROOT, FileExtension, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        DebugPrint(( L"Could not open file extension registry key" ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, NULL, FileAssociationName )) {
        DebugPrint(( L"Could not set file association name registry value" ));
    }

    RegCloseKey( hKey );

    return TRUE;
}

BOOL SetKeySecurity(HKEY hKey) {
    long rslt;    
    
    PACL Dacl;
    
    PACCESS_ALLOWED_ACE CurrentAce;

    PSID EveryoneSid, CurrentSid;
    
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    
    DWORD i;
    
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;
    
    if (hKey == NULL) {
        DebugPrint(( TEXT("NULL hKey, can't set security\n")));
        return FALSE;
    }

    rslt =  GetSecurityInfo( hKey, 
                             SE_REGISTRY_KEY, // type of object 
                             DACL_SECURITY_INFORMATION,
                             NULL, 
                             NULL, 
                             &Dacl, 
                             NULL, 
                             &pSecurityDescriptor); 
 
    if (rslt != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Couldn't GetSecurityInfo, ec = %d\n"),rslt));
        return FALSE;
    }

    if (!IsValidSecurityDescriptor(pSecurityDescriptor)) {
        DebugPrint(( TEXT("Invalid SD\n")));
        return FALSE;
    }
        
    if (!AllocateAndInitializeSid(&WorldSidAuthority,
                                  1,
                                  SECURITY_WORLD_RID,
                                  0,0,0,0,0,0,0,
                                  &EveryoneSid) ) {
        DebugPrint(( TEXT("Couldn't AllocateAndInitializedSid, ec = %d\n") , GetLastError() ));
        LocalFree(pSecurityDescriptor);       
        return FALSE;
    }
   
    if (!IsValidSid(EveryoneSid)) {
        DebugPrint(( TEXT("Couldn't AllocateAndInitializedSid, ec = %d\n") , GetLastError() ));
        LocalFree(pSecurityDescriptor);
        return FALSE;
    }
    

    for (i=0;i<Dacl->AceCount;i++) {
        if (!GetAce(Dacl,i,(LPVOID *) &CurrentAce) ) {
            DebugPrint(( TEXT("Couldn't GetAce, ec = %d\n"), GetLastError() ));
            break;
        } 

        CurrentSid = (PSID) &CurrentAce->SidStart;

        if (EqualSid(EveryoneSid,CurrentSid)) {            

            CurrentAce->Mask &= ~(KEY_SET_VALUE | KEY_CREATE_SUB_KEY | KEY_CREATE_LINK | DELETE);                       

        }

    }

    rslt =  SetSecurityInfo( hKey, // handle to the object 
                             SE_REGISTRY_KEY, // type of object 
                             DACL_SECURITY_INFORMATION,// type of security information to set 
                             NULL,// pointer to the new owner SID 
                             NULL,// pointer to the new primary group SID 
                             Dacl,//NewDAcl // pointer to the new DACL 
                             NULL // pointer to the new SACL 
                            );

    if (rslt != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Couldn't SetSecurityInfo, ec = %d\n"), rslt ));
    } else {
        DebugPrint(( TEXT("SetSecurityInfo succeeded, ec = %d\n"), rslt ));
    }


    //
    // cleanup
    //
    FreeSid(EveryoneSid);
    LocalFree(pSecurityDescriptor);    
    
    return rslt==ERROR_SUCCESS ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ocm\groups.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    groups.c

Abstract:

    This file implements the file copy code.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "faxocm.h"
#pragma hdrstop


GROUP_ITEMS GroupItems[] =
{
    { {IDS_FAXGROUP,                     TEXT("") },
      {IDS_FAXQUEUE_ITEM,                TEXT("") },
      {IDS_FAXQUEUE_EXE,                 TEXT("") },
      {IDS_FAXQUEUE_ICON,                TEXT("") },
      {IDS_FAXQUEUE_WORKINGDIRECTORY,    TEXT("") },
      USE_COMMON_GROUP | USE_SERVER_NAME,
      0,
      SW_NORMAL,
      0,
      {IDS_FAXQUEUE_INFOTIP,             TEXT("") }
    },

    { {IDS_FAXGROUP,                     TEXT("") },
      {IDS_FAXFOLDER_ITEM,               TEXT("") },
      {IDS_FAXFOLDER_EXE,                TEXT("") },
      {IDS_FAXFOLDER_ICON,               TEXT("") },
      {IDS_FAXFOLDER_WORKINGDIRECTORY,   TEXT("") },
      USE_COMMON_GROUP | USE_SERVER_NAME |USE_SHELL_PATH | USE_SUBDIR,
      4,
      SW_NORMAL,
      0,
      {IDS_FAXFOLDER_INFOTIP,            TEXT("") }
    },

#if 0
    { {IDS_FAXGROUP,                     TEXT("") },
      {IDS_CPE_ITEM,                     TEXT("") },
      {IDS_CPE_EXE,                      TEXT("") },
      {IDS_CPE_ICON,                     TEXT("") },
      {IDS_CPE_WORKINGDIRECTORY,         TEXT("") },
      USE_COMMON_GROUP,
      0,
      SW_NORMAL,
      0,
      {IDS_CPE_INFOTIP,                  TEXT("") }
    },
#endif

    { {IDS_FAXGROUP,                     TEXT("") },
      {IDS_FAXSEND_ITEM,                 TEXT("") },
      {IDS_FAXSEND_EXE,                  TEXT("") },
      {IDS_FAXSEND_ICON,                 TEXT("") },
      {IDS_FAXSEND_WORKINGDIRECTORY,     TEXT("") },
      USE_COMMON_GROUP,
      0,
      SW_NORMAL,
      0,
      {IDS_FAXSEND_INFOTIP,              TEXT("") }
    },

    { {IDS_FAXGROUP,                     TEXT("") },
      {IDS_FAXADMIN_ITEM,                TEXT("") },
      {IDS_FAXADMIN_EXE,                 TEXT("") },
      {IDS_FAXADMIN_ICON,                TEXT("") },
      {IDS_FAXADMIN_WORKINGDIRECTORY,    TEXT("") },
      USE_COMMON_GROUP,
      5,
      SW_NORMAL,
      0,
      {IDS_FAXADMIN_INFOTIP,             TEXT("") }
    },

#if 0
    { {IDS_FAXGROUP,                     TEXT("") },
      {IDS_FAXVIEWER_ITEM,               TEXT("") },
      {IDS_FAXVIEWER_EXE,                TEXT("") },
      {IDS_FAXVIEWER_ICON,               TEXT("") },
      {IDS_FAXVIEWER_WORKINGDIRECTORY,   TEXT("") },
      USE_COMMON_GROUP,
      0,
      SW_NORMAL,
      0,
      {IDS_FAXVIEWER_INFOTIP,            TEXT("") }
    },
#endif

    { {IDS_FAXGROUP,                     TEXT("") },
      {IDS_FAXHELP_ITEM,                 TEXT("") },
      {IDS_FAXHELP_EXE,                  TEXT("") },
      {IDS_FAXHELP_ICON,                 TEXT("") },
      {IDS_FAXHELP_WORKINGDIRECTORY,     TEXT("") },
      USE_COMMON_GROUP,
      0,
      SW_NORMAL,
      0,
      {IDS_FAXHELP_INFOTIP,              TEXT("") }
    }

#if 0
    { {IDS_FAXGROUP,                     TEXT("") },
      {IDS_FAXPRINTER_ITEM,              TEXT("") },
      {IDS_FAXPRINTER_EXE,               TEXT("") },
      {IDS_FAXPRINTER_ICON,              TEXT("") },
      {IDS_FAXPRINTER_WORKINGDIRECTORY,  TEXT("") },
      USE_COMMON_GROUP,
      59,
      SW_NORMAL,
      0,
      {IDS_FAXPRINTER_INFOTIP,           TEXT("") }
    }
#endif
};

#define MAX_GROUP_ITEMS  (sizeof(GroupItems)/sizeof(GroupItems[0]))



VOID
DeleteNt4Group(
    VOID
    )
{
    WCHAR Name[100];
    
    MyLoadString(hInstance, IDS_NT4FAX_GROUP, Name, sizeof(Name) / sizeof(WCHAR), GetSystemDefaultUILanguage() );
    DeleteGroup( Name, USE_COMMON_GROUP );

}


VOID
DeleteGroupItems(
    VOID
    )
{
    DWORD i;

    for (i=0; i<MAX_GROUP_ITEMS; i++) {

        MyLoadString(hInstance,GroupItems[i].GroupName.ResourceID,GroupItems[i].GroupName.Name,64, GetSystemDefaultUILanguage());
        MyLoadString(hInstance,GroupItems[i].Description.ResourceID,GroupItems[i].Description.Name,64, GetSystemDefaultUILanguage());

        DeleteLinkFile(
            CSIDL_COMMON_PROGRAMS,
            GroupItems[i].GroupName.Name,
            GroupItems[i].Description.Name,
            FALSE
            );

    }

    DeleteGroup( GroupItems[0].GroupName.Name, GroupItems[0].Flags & USE_COMMON_GROUP );
}


VOID
CreateGroupItems(
    LPTSTR ServerName
    )
{
    DWORD i;
    WCHAR CommandLine[MAX_PATH*2];
    WCHAR IconPath[MAX_PATH*2];
    WCHAR WorkingDirectory[MAX_PATH*2];
    PGROUP_ITEMS Groups;
    DWORD GroupCount;
    WCHAR ShellPath[MAX_PATH];
    WCHAR FaxPrinterName[MAX_PATH];

    if (Upgrade) {
        DeleteGroupItems();
    }
    
    Groups = GroupItems;
    GroupCount = MAX_GROUP_ITEMS;

    for (i=0; i<GroupCount; i++) {
    
        MyLoadString(hInstance,Groups[i].GroupName.ResourceID,Groups[i].GroupName.Name,64, GetSystemDefaultUILanguage());
        MyLoadString(hInstance,Groups[i].Description.ResourceID,Groups[i].Description.Name,64, GetSystemDefaultUILanguage());

        if (Groups[i].CommandLine.ResourceID == IDS_FAXPRINTER_EXE) {
            MyLoadString(hInstance,IDS_DEFAULT_PRINTER_NAME,FaxPrinterName,MAX_PATH, GetSystemDefaultUILanguage());
            swprintf(
                Groups[i].CommandLine.Name,
                L"rundll32 printui.dll,PrintUIEntry %s /q /if /b \"%s\" /f \"%%SystemRoot%%\\inf\\ntprint.inf\" /r \"MSFAX:\" /m \"%s\" /l \"%%SystemRoot%%\\system32\"",
                IsProductSuite() ? L"/Z" : L"/z",
                FaxPrinterName,
                FAX_DRIVER_NAME
                );
        }
        else {
            MyLoadString(hInstance,Groups[i].CommandLine.ResourceID,Groups[i].CommandLine.Name,MAX_PATH, GetSystemDefaultUILanguage());
        }

        MyLoadString(hInstance,Groups[i].IconPath.ResourceID,Groups[i].IconPath.Name,MAX_PATH, GetSystemDefaultUILanguage());
        MyLoadString(hInstance,Groups[i].WorkingDirectory.ResourceID,Groups[i].WorkingDirectory.Name,MAX_PATH, GetSystemDefaultUILanguage());
        MyLoadString(hInstance,Groups[i].InfoTip.ResourceID,Groups[i].InfoTip.Name,MAX_PATH, GetSystemDefaultUILanguage());
                
        CreateGroup( Groups[i].GroupName.Name, Groups[i].Flags & USE_COMMON_GROUP );

        if ((Groups[i].Flags & USE_SHELL_PATH) && MyGetSpecialPath( CSIDL_COMMON_DOCUMENTS, ShellPath)) {
            wsprintf(CommandLine,Groups[i].CommandLine.Name,ShellPath);
            wsprintf(WorkingDirectory,Groups[i].WorkingDirectory.Name,ShellPath);
        } else {
            ExpandEnvironmentStrings( Groups[i].CommandLine.Name, CommandLine, sizeof(CommandLine)/sizeof(WCHAR) );
            ExpandEnvironmentStrings( Groups[i].WorkingDirectory.Name, WorkingDirectory, sizeof(WorkingDirectory)/sizeof(WCHAR) );            
        }
            
        ExpandEnvironmentStrings( Groups[i].IconPath.Name, IconPath, sizeof(IconPath)/sizeof(WCHAR) );       

        if ((Groups[i].Flags & USE_SERVER_NAME) && ServerName) {
            wcscat( CommandLine, L" " );
            wcscat( CommandLine, ServerName );
        }

        CreateLinkFile(
            CSIDL_COMMON_PROGRAMS,
            Groups[i].GroupName.Name,
            Groups[i].Description.Name,
            CommandLine,
            IconPath,
            Groups[i].IconIndex,
            (Groups[i].Flags & USE_SUBDIR) ? TEXT("") : WorkingDirectory,
            Groups[i].HotKey,
            Groups[i].ShowCmd,
            Groups[i].InfoTip.Name
            );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ocm\mapi.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mapi.c

Abstract:

    This file implements wrappers for all mapi apis.
    The wrappers are necessary because mapi does not
    implement unicode and this code must be non-unicode.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 7-Aug-1996

--*/

#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <mapiwin.h>
#include <mapix.h>
#include <stdio.h>

#define INTERNAL 1
#include "common.h"
#include "resource.h"


#define MAPISVC_INF                 "mapisvc.inf"
#define PAB_FILE_NAME               "%windir%\\msfax.pab"
#define PST_FILE_NAME               "%windir%\\msfax.pst"

#define FAXAB_SERVICE_NAME          "MSFAX AB"
#define FAXXP_SERVICE_NAME          "MSFAX XP"
#define MSAB_SERVICE_NAME           "MSPST AB"
#define MSPST_SERVICE_NAME          "MSPST MS"
#define CONTAB_SERVICE_NAME         "CONTAB"
#define MSAB_SERVICE_NAME_W        L"MSPST AB"
#define MSPST_SERVICE_NAME_W       L"MSPST MS"
#define FAXAB_SERVICE_NAME_W       L"MSFAX AB"
#define CONTAB_SERVICE_NAME_W      L"CONTAB"


//
// pab property tags
//

#define PR_PAB_PATH                             PROP_TAG( PT_TSTRING, 0x6600 )
#define PR_PAB_PATH_W                           PROP_TAG( PT_UNICODE, 0x6600 )
#define PR_PAB_PATH_A                           PROP_TAG( PT_STRING8, 0x6600 )
#define PR_PAB_DET_DIR_VIEW_BY                  PROP_TAG( PT_LONG,    0x6601 )

#define PAB_DIR_VIEW_FIRST_THEN_LAST            0
#define PAB_DIR_VIEW_LAST_THEN_FIRST            1

//
// pst property tags
//

#define PR_PST_PATH                             PROP_TAG( PT_STRING8, 0x6700 )
#define PR_PST_REMEMBER_PW                      PROP_TAG( PT_BOOLEAN, 0x6701 )
#define PR_PST_ENCRYPTION                       PROP_TAG( PT_LONG,    0x6702 )
#define PR_PST_PW_SZ_OLD                        PROP_TAG( PT_STRING8, 0x6703 )
#define PR_PST_PW_SZ_NEW                        PROP_TAG( PT_STRING8, 0x6704 )

#define PSTF_NO_ENCRYPTION                      ((DWORD)0x80000000)
#define PSTF_COMPRESSABLE_ENCRYPTION            ((DWORD)0x40000000)
#define PSTF_BEST_ENCRYPTION                    ((DWORD)0x20000000)


//
// externs & globals
//

extern BOOL MapiAvail;

static HMODULE MapiMod = NULL;
static LPMAPIADMINPROFILES MapiAdminProfiles = NULL;
static LPMAPIINITIALIZE MapiInitialize = NULL;
static LPMAPILOGONEX MapiLogonEx;
static LPMAPIUNINITIALIZE MapiUnInitialize = NULL;
static LPMAPIFREEBUFFER pMAPIFreeBuffer = NULL;
static LPPROFADMIN lpProfAdmin;

static CHAR MapiSvcInf[MAX_PATH*2];
static BOOL MapiStartedByLogon;

BOOL MapiAvail;


LPWSTR MyGetString(DWORD);



static
LPWSTR
AnsiStringToUnicodeString(
    LPSTR AnsiString,
    LPWSTR UnicodeString
    )
{
    DWORD Count;


    //
    // first see how big the buffer needs to be
    //
    Count = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        AnsiString,
        -1,
        NULL,
        0
        );

    //
    // i guess the input string is empty
    //
    if (!Count) {
        return NULL;
    }

    //
    // convert the string
    //
    Count = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        AnsiString,
        -1,
        UnicodeString,
        Count
        );

    //
    // the conversion failed
    //
    if (!Count) {
        return NULL;
    }

    return UnicodeString;
}


static
LPSTR
UnicodeStringToAnsiString(
    LPWSTR UnicodeString,
    LPSTR AnsiString
    )
{
    DWORD Count;


    //
    // first see how big the buffer needs to be
    //
    Count = WideCharToMultiByte(
        CP_ACP,
        0,
        UnicodeString,
        -1,
        NULL,
        0,
        NULL,
        NULL
        );

    //
    // i guess the input string is empty
    //
    if (!Count) {
        return NULL;
    }

    //
    // convert the string
    //
    Count = WideCharToMultiByte(
        CP_ACP,
        0,
        UnicodeString,
        -1,
        AnsiString,
        Count,
        NULL,
        NULL
        );

    //
    // the conversion failed
    //
    if (!Count) {
        return NULL;
    }

    return AnsiString;
}


VOID
MyWriteProfileString(
    LPTSTR SectionName,
    LPTSTR KeyName,
    LPTSTR Value,
    LPWSTR SystemPath
    )
{
    char IniPath[MAX_PATH];

    UnicodeStringToAnsiString(SystemPath, IniPath);

    strcat(IniPath, "\\");
    strcat(IniPath, MapiSvcInf);

    WritePrivateProfileString(
        SectionName,
        KeyName,
        Value,
        IniPath
        );
}

VOID
MyWriteProfileStringW(
    LPTSTR SectionName,
    LPTSTR KeyName,
    LPWSTR Value,
    LPWSTR SystemPath
    )
{
    WCHAR WSectionName[100];
    WCHAR WKeyName[100];
    WCHAR WMapiSvcInf[MAX_PATH];
    WCHAR IniPath[MAX_PATH];

    AnsiStringToUnicodeString (MapiSvcInf, WMapiSvcInf);
    AnsiStringToUnicodeString (KeyName, WKeyName) ;
    AnsiStringToUnicodeString (SectionName, WSectionName);

    swprintf(IniPath, L"%s\\%s", SystemPath, WMapiSvcInf);

    WritePrivateProfileStringW(
        WSectionName,
        WKeyName,
        Value,
        IniPath
        );
}


VOID
AddFaxAbToMapiSvcInf(
    LPWSTR SystemPath
    )
{

    MyWriteProfileStringW( "Default Services", "MSFAX AB",                 MyGetString(IDS_FAXAB_DISPLAY_NAME), SystemPath );
    MyWriteProfileStringW( "Services",         "MSFAX AB",                 MyGetString(IDS_FAXAB_DISPLAY_NAME), SystemPath );

    MyWriteProfileStringW( "MSFAX AB",         "PR_DISPLAY_NAME",          MyGetString(IDS_FAXAB_DISPLAY_NAME), SystemPath );
    MyWriteProfileString( "MSFAX AB",         "Providers",                "MSFAX ABP", SystemPath        );
    MyWriteProfileString( "MSFAX AB",         "PR_SERVICE_DLL_NAME",      "FAXAB.DLL", SystemPath        );
    MyWriteProfileString( "MSFAX AB",         "PR_SERVICE_SUPPORT_FILES", "FAXAB.DLL", SystemPath        );
    MyWriteProfileString( "MSFAX AB",         "PR_SERVICE_ENTRY_NAME",    "FABServiceEntry", SystemPath  );
    MyWriteProfileString( "MSFAX AB",         "PR_RESOURCE_FLAGS",        "SERVICE_SINGLE_COPY|SERVICE_NO_PRIMARY_IDENTITY", SystemPath );

    MyWriteProfileString( "MSFAX ABP",        "PR_PROVIDER_DLL_NAME",     "FAXAB.DLL", SystemPath        );
    MyWriteProfileString( "MSFAX ABP",        "PR_RESOURCE_TYPE",         "MAPI_AB_PROVIDER", SystemPath );
    MyWriteProfileStringW( "MSFAX ABP",        "PR_DISPLAY_NAME",          MyGetString(IDS_FAXAB_DISPLAY_NAME), SystemPath );
    MyWriteProfileStringW( "MSFAX ABP",        "PR_PROVIDER_DISPLAY",      MyGetString(IDS_FAXAB_DISPLAY_NAME), SystemPath );
}


VOID
AddFaxXpToMapiSvcInf(
    LPWSTR SystemPath
    )
{
    MyWriteProfileStringW( "Default Services", "MSFAX XP",                 MyGetString(IDS_FAXXP_DISPLAY_NAME), SystemPath );
    MyWriteProfileStringW( "Services",         "MSFAX XP",                 MyGetString(IDS_FAXXP_DISPLAY_NAME), SystemPath );

    MyWriteProfileStringW( "MSFAX XP",         "PR_DISPLAY_NAME",          MyGetString(IDS_FAXXP_DISPLAY_NAME), SystemPath );
    MyWriteProfileString( "MSFAX XP",         "Providers",                "MSFAX XPP", SystemPath                   );
    MyWriteProfileString( "MSFAX XP",         "PR_SERVICE_DLL_NAME",      "FAXXP.DLL", SystemPath                   );
    MyWriteProfileString( "MSFAX XP",         "PR_SERVICE_SUPPORT_FILES", "FAXXP.DLL", SystemPath                   );
    MyWriteProfileString( "MSFAX XP",         "PR_SERVICE_ENTRY_NAME",    "ServiceEntry", SystemPath                );
    MyWriteProfileString( "MSFAX XP",         "PR_RESOURCE_FLAGS",        "SERVICE_SINGLE_COPY|SERVICE_NO_PRIMARY_IDENTITY", SystemPath );

    MyWriteProfileString( "MSFAX XPP",        "PR_PROVIDER_DLL_NAME",     "FAXXP.DLL", SystemPath                   );
    MyWriteProfileString( "MSFAX XPP",        "PR_RESOURCE_TYPE",         "MAPI_TRANSPORT_PROVIDER", SystemPath     );
    MyWriteProfileString( "MSFAX XPP",        "PR_RESOURCE_FLAGS",        "STATUS_NO_DEFAULT_STORE", SystemPath     );
    MyWriteProfileStringW( "MSFAX XPP",        "PR_DISPLAY_NAME",          MyGetString(IDS_FAXXP_DISPLAY_NAME), SystemPath );
    MyWriteProfileStringW( "MSFAX XPP",        "PR_PROVIDER_DISPLAY",      MyGetString(IDS_FAXXP_DISPLAY_NAME), SystemPath );
}


VOID
FreeSRowSet(
    LPSRowSet prws
    )
{
    ULONG irw;

    if (!prws) {
        return;
    }

    for(irw = 0; irw < prws->cRows; irw++) {
        pMAPIFreeBuffer( prws->aRow[irw].lpProps );
    }

    pMAPIFreeBuffer( prws );
}


ULONG
MLCRelease(
    LPUNKNOWN punk
    )
{
    return (punk) ? punk->lpVtbl->Release(punk) : 0;
}


BOOL
ValidateProp(
    LPSPropValue pval,
    ULONG ulPropTag
    )
{
    if (pval->ulPropTag != ulPropTag) {
        pval->ulPropTag = ulPropTag;
        pval->Value.lpszA = "???";
        return TRUE;
    }

    return FALSE;
}


BOOL
IsMapiServiceInstalled(
    LPWSTR ProfileNameW,
    LPWSTR ServiceNameW
    )
{
    SPropTagArray taga = {2,{PR_DISPLAY_NAME,PR_SERVICE_NAME}};
    BOOL rVal = FALSE;
    LPSERVICEADMIN lpSvcAdmin;
    LPMAPITABLE pmt = NULL;
    LPSRowSet prws = NULL;
    DWORD i;
    LPSPropValue pval;
    CHAR ProfileName[128];
    CHAR ServiceName[64];


    if (!MapiAvail) {
        goto exit;
    }

    UnicodeStringToAnsiString( ProfileNameW, ProfileName );
    UnicodeStringToAnsiString( ServiceNameW, ServiceName );

    if (lpProfAdmin->lpVtbl->AdminServices( lpProfAdmin, ProfileName, NULL, 0, 0, &lpSvcAdmin )) {
        goto exit;
    }

    if (lpSvcAdmin->lpVtbl->GetMsgServiceTable( lpSvcAdmin, 0, &pmt )) {
        goto exit;
    }

    if (pmt->lpVtbl->SetColumns( pmt, &taga, 0 )) {
        goto exit;
    }

    if (pmt->lpVtbl->QueryRows( pmt, 4000, 0, &prws )) {
        goto exit;
    }

    for (i=0; i<prws->cRows; i++) {
        pval = prws->aRow[i].lpProps;
        ValidateProp( &pval[0], PR_DISPLAY_NAME );
        ValidateProp( &pval[1], PR_SERVICE_NAME );
        if (_stricmp( pval[1].Value.lpszA, ServiceName ) == 0) {
            rVal = TRUE;
            break;
        }
    }

exit:
    FreeSRowSet( prws );
    MLCRelease( (LPUNKNOWN)pmt );
    return rVal;
}


BOOL
InstallFaxAddressBook(
    HWND hwnd,
    LPWSTR ProfileNameW
    )
{
    SPropTagArray taga = {2,{PR_SERVICE_NAME,PR_SERVICE_UID}};
    SPropValue spvProps[2] = { 0 };
    BOOL rVal = FALSE;
    LPSERVICEADMIN lpSvcAdmin;
    CHAR ProfileName[128];
    CHAR Buffer[128];
    HRESULT hResult;
    LPMAPITABLE pmt = NULL;
    LPSRowSet prws = NULL;
    DWORD i;
    LPSPropValue pval;
    BOOL ConfigurePst = FALSE;
    BOOL ConfigurePab = FALSE;
    LPMAPISESSION Session = NULL;


    if (!MapiAvail) {
        goto exit;
    }

    UnicodeStringToAnsiString( ProfileNameW, ProfileName );

    if (IsMapiServiceInstalled( ProfileNameW, CONTAB_SERVICE_NAME_W )) {
        //
        // we don't need a pab/fab if we have the outlook contact address book
        //
        goto exit;
    }

    hResult = lpProfAdmin->lpVtbl->AdminServices( lpProfAdmin, ProfileName, NULL, 0, 0, &lpSvcAdmin );
    if (hResult) {
        goto exit;
    }

    if (!IsMapiServiceInstalled( ProfileNameW, MSAB_SERVICE_NAME_W )) {
        hResult = lpSvcAdmin->lpVtbl->CreateMsgService( lpSvcAdmin, MSAB_SERVICE_NAME, NULL, 0, 0 );
        if (hResult && hResult != MAPI_E_NO_ACCESS) {
            //
            // mapi will return MAPI_E_NO_ACCESS when the service is already installed
            //
            goto exit;
        }
        ConfigurePab = TRUE;
    }

    if (!IsMapiServiceInstalled( ProfileNameW, MSPST_SERVICE_NAME_W )) {
        hResult = lpSvcAdmin->lpVtbl->CreateMsgService( lpSvcAdmin, MSPST_SERVICE_NAME, NULL, 0, 0 );
        if (hResult && hResult != MAPI_E_NO_ACCESS) {
            //
            // mapi will return MAPI_E_NO_ACCESS when the service is already installed
            //
            goto exit;
        }
        ConfigurePst = TRUE;
    }

    if (!IsMapiServiceInstalled( ProfileNameW, FAXAB_SERVICE_NAME_W )) {
        hResult = lpSvcAdmin->lpVtbl->CreateMsgService( lpSvcAdmin, FAXAB_SERVICE_NAME, NULL, 0, 0 );
        if (hResult && hResult != MAPI_E_NO_ACCESS) {
            //
            // mapi will return MAPI_E_NO_ACCESS when the service is already installed
            //
            goto exit;
        }
    }

    //
    // now configure the address book and pst
    //

    if (lpSvcAdmin->lpVtbl->GetMsgServiceTable( lpSvcAdmin, 0, &pmt )) {
        goto exit;
    }

    if (pmt->lpVtbl->SetColumns( pmt, &taga, 0 )) {
        goto exit;
    }

    if (pmt->lpVtbl->QueryRows( pmt, 4000, 0, &prws )) {
        goto exit;
    }

    for (i=0; i<prws->cRows; i++) {
        pval = prws->aRow[i].lpProps;
        ValidateProp( &pval[0], PR_SERVICE_NAME );
        if (ConfigurePab && (_stricmp( pval[0].Value.lpszA, MSAB_SERVICE_NAME) == 0)) {
            //
            // configure the pab service
            //

            ExpandEnvironmentStrings( PAB_FILE_NAME, Buffer, sizeof(Buffer) );

            spvProps[0].ulPropTag  = PR_PAB_PATH;
            spvProps[0].Value.LPSZ = Buffer;
            spvProps[1].ulPropTag  = PR_PAB_DET_DIR_VIEW_BY;
            spvProps[1].Value.ul   = PAB_DIR_VIEW_FIRST_THEN_LAST;

            if (lpSvcAdmin->lpVtbl->ConfigureMsgService( lpSvcAdmin, (LPMAPIUID)pval[1].Value.bin.lpb, (ULONG_PTR)hwnd, 0, 2, spvProps )) {

            }
        }
        if (ConfigurePst && (_stricmp( pval[0].Value.lpszA, MSPST_SERVICE_NAME) == 0)) {
            //
            // configure the pst service
            //

            ExpandEnvironmentStrings( PST_FILE_NAME, Buffer, sizeof(Buffer) );

            spvProps[0].ulPropTag  = PR_PST_PATH;
            spvProps[0].Value.LPSZ = Buffer;
            spvProps[1].ulPropTag  = PR_PST_ENCRYPTION;
            spvProps[1].Value.ul   = PSTF_NO_ENCRYPTION;

            if (lpSvcAdmin->lpVtbl->ConfigureMsgService( lpSvcAdmin, (LPMAPIUID)pval[1].Value.bin.lpb, (ULONG_PTR)hwnd, 0, 2, spvProps )) {

            }

        }
    }

    if (ConfigurePab || ConfigurePst) {
        __try {
            if (MapiLogonEx(
                0,
                ProfileName,
                NULL,
                MAPI_NEW_SESSION | MAPI_EXTENDED,
                &Session
                ) == 0)
            {
                MapiStartedByLogon = TRUE;
                Session->lpVtbl->Logoff( Session, 0, 0, 0 );
            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {

        }
    }

    rVal = TRUE;

exit:
    FreeSRowSet( prws );
    MLCRelease( (LPUNKNOWN)pmt );
    return rVal;
}


BOOL
InstallFaxTransport(
    LPWSTR ProfileNameW
    )
{
    BOOL rVal = FALSE;
    LPSERVICEADMIN lpSvcAdmin;
    CHAR ProfileName[128];


    if (!MapiAvail) {
        goto exit;
    }

    UnicodeStringToAnsiString( ProfileNameW, ProfileName );

    if (lpProfAdmin->lpVtbl->AdminServices( lpProfAdmin, ProfileName, NULL, 0, 0, &lpSvcAdmin )) {
        goto exit;
    }

    if (lpSvcAdmin->lpVtbl->CreateMsgService( lpSvcAdmin, FAXXP_SERVICE_NAME, NULL, 0, 0 )) {
        goto exit;
    }

    rVal = TRUE;

exit:
    return rVal;
}


BOOL
CreateDefaultMapiProfile(
    LPWSTR ProfileNameW
    )
{
    BOOL rVal = FALSE;
    CHAR ProfileName[128];


    if (!MapiAvail) {
        goto exit;
    }

    UnicodeStringToAnsiString( ProfileNameW, ProfileName );

    //
    // create the new profile
    //

    if (lpProfAdmin->lpVtbl->CreateProfile( lpProfAdmin, ProfileName, NULL, 0, 0 )) {
        goto exit;
    }

    if (lpProfAdmin->lpVtbl->SetDefaultProfile( lpProfAdmin, ProfileName, 0 )) {
        goto exit;
    }

    rVal = TRUE;

exit:
    return rVal;
}


BOOL
GetDefaultMapiProfile(
    LPWSTR ProfileName
    )
{
    BOOL rVal = FALSE;
    LPMAPITABLE pmt = NULL;
    LPSRowSet prws = NULL;
    LPSPropValue pval;
    DWORD i;
    DWORD j;

    if (!MapiAvail) {
        goto exit;
    }

    //
    // get the mapi profile table object
    //

    if (lpProfAdmin->lpVtbl->GetProfileTable( lpProfAdmin, 0, &pmt )) {
        goto exit;
    }

    //
    // get the actual profile data, FINALLY
    //

    if (pmt->lpVtbl->QueryRows( pmt, 4000, 0, &prws )) {
        goto exit;
    }

    //
    // enumerate the profiles looking for the default profile
    //

    for (i=0; i<prws->cRows; i++) {
        pval = prws->aRow[i].lpProps;
        for (j = 0; j < 2; j++) {
            if (pval[j].ulPropTag == PR_DEFAULT_PROFILE && pval[j].Value.b) {
            //
            // this is the default profile
            //
            AnsiStringToUnicodeString( pval[0].Value.lpszA, ProfileName );
            rVal = TRUE;
            break;
            }
        }
    }

exit:
    FreeSRowSet( prws );
    MLCRelease( (LPUNKNOWN)pmt );

    return rVal;
}

BOOL
DeleteMessageService(
    LPSTR ProfileName
    )
{
    SPropTagArray taga = {2,{PR_SERVICE_NAME,PR_SERVICE_UID}};
    BOOL rVal = FALSE;
    LPSERVICEADMIN lpSvcAdmin;
    LPMAPITABLE pmt = NULL;
    LPSRowSet prws = NULL;
    DWORD i;
    LPSPropValue pval;


    if (!MapiAvail) {
        goto exit;
    }

    if (lpProfAdmin->lpVtbl->AdminServices( lpProfAdmin, ProfileName, NULL, 0, 0, &lpSvcAdmin )) {
        goto exit;
    }

    if (lpSvcAdmin->lpVtbl->GetMsgServiceTable( lpSvcAdmin, 0, &pmt )) {
        goto exit;
    }

    if (pmt->lpVtbl->SetColumns( pmt, &taga, 0 )) {
        goto exit;
    }

    if (pmt->lpVtbl->QueryRows( pmt, 4000, 0, &prws )) {
        goto exit;
    }

    for (i=0; i<prws->cRows; i++) {

        pval = prws->aRow[i].lpProps;

        ValidateProp( &pval[0], PR_SERVICE_NAME );

        if (_stricmp( pval[0].Value.lpszA, "MSFAX AB" ) == 0) {
            lpSvcAdmin->lpVtbl->DeleteMsgService( lpSvcAdmin, (LPMAPIUID) pval[1].Value.bin.lpb );
        }

        if (_stricmp( pval[0].Value.lpszA, "MSFAX XP" ) == 0) {
            lpSvcAdmin->lpVtbl->DeleteMsgService( lpSvcAdmin, (LPMAPIUID) pval[1].Value.bin.lpb );
        }
    }

exit:
    FreeSRowSet( prws );
    MLCRelease( (LPUNKNOWN)pmt );
    return rVal;
}

BOOL
DeleteFaxMsgServices(
    VOID
    )
{
    BOOL rVal = FALSE;
    LPMAPITABLE pmt = NULL;
    LPSRowSet prws = NULL;
    LPSPropValue pval;
    DWORD i;
    DWORD j;

    if (!MapiAvail) {
        goto exit;
    }

    //
    // get the mapi profile table object
    //

    if (lpProfAdmin->lpVtbl->GetProfileTable( lpProfAdmin, 0, &pmt )) {
        goto exit;
    }

    //
    // get the actual profile data, FINALLY
    //

    if (pmt->lpVtbl->QueryRows( pmt, 4000, 0, &prws )) {
        goto exit;
    }

    //
    // enumerate the profiles looking for the default profile
    //

    for (i=0; i<prws->cRows; i++) {
        pval = prws->aRow[i].lpProps;
        for (j = 0; j < 2; j++) {
            if (pval[j].ulPropTag == PR_DISPLAY_NAME) {
                DeleteMessageService( pval[j].Value.lpszA );
            break;
            }
        }
    }

exit:
    FreeSRowSet( prws );
    MLCRelease( (LPUNKNOWN)pmt );

    return rVal;
}

BOOL
IsExchangeInstalled(
    VOID
    )
{
    BOOL MapiAvail = FALSE;
    CHAR MapiOption[4];
    HKEY hKey;
    LONG rVal;
    DWORD Bytes;
    DWORD Type;

    rVal = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        "Software\\Microsoft\\Windows Messaging Subsystem",
        &hKey
        );
    if (rVal == ERROR_SUCCESS) {
        Bytes = sizeof(MapiOption);
        rVal = RegQueryValueEx(
            hKey,
            "MAPIX",
            NULL,
            &Type,
            (LPBYTE) MapiOption,
            &Bytes
            );
        if (rVal == ERROR_SUCCESS) {
            if (Bytes && MapiOption[0] == '1') {
                MapiAvail = TRUE;
            }
        }
        RegCloseKey( hKey );
    }

    return MapiAvail;
}


BOOL
InitializeMapi(
    BOOL MinimalInit // just init some global variables, don't load MAPI (TRUE for GUI-mode setup)
    )
{
    MAPIINIT_0 MapiInit;

    ExpandEnvironmentStrings( MAPISVC_INF, MapiSvcInf, sizeof(MapiSvcInf) );
    if (MinimalInit) {
        return TRUE;
    }


    MapiAvail = IsExchangeInstalled();
    if (!MapiAvail) {
        goto exit;
    }

    //
    // load the mapi dll
    //

    MapiMod = LoadLibrary( "mapi32.dll" );
    if (!MapiMod) {
        MapiAvail = FALSE;
        goto exit;
    }

    //
    // get the addresses of the mapi functions that we need
    //

    MapiAdminProfiles = (LPMAPIADMINPROFILES) GetProcAddress( MapiMod, "MAPIAdminProfiles" );
    MapiInitialize = (LPMAPIINITIALIZE) GetProcAddress( MapiMod, "MAPIInitialize" );
    MapiUnInitialize = (LPMAPIUNINITIALIZE) GetProcAddress( MapiMod, "MAPIUninitialize" );
    pMAPIFreeBuffer = (LPMAPIFREEBUFFER) GetProcAddress( MapiMod, "MAPIFreeBuffer" );
    MapiLogonEx = (LPMAPILOGONEX) GetProcAddress( MapiMod, "MAPILogonEx" );
    if ((!MapiAdminProfiles) || (!MapiInitialize) || (!MapiUnInitialize) || (!pMAPIFreeBuffer) || (!MapiLogonEx)) {
        MapiAvail = FALSE;
        goto exit;
    }

    //
    // initialize mapi for our calls
    //

    MapiInit.ulVersion = 0;
    MapiInit.ulFlags = 0;

    if (MapiInitialize( &MapiInit )) {
        MapiAvail = FALSE;
        goto exit;
    }

    //
    // get the admin profile object
    //

    if (MapiAdminProfiles( 0, &lpProfAdmin )) {
        MapiAvail = FALSE;
        goto exit;
    }

exit:
    return MapiAvail;
}


BOOL
GetMapiProfiles(
    HWND hwnd,
    DWORD ResourceId
    )
{
    BOOL rVal = FALSE;
    HMODULE MapiMod = NULL;
    LPMAPITABLE pmt = NULL;
    LPSRowSet prws = NULL;
    LPSPropValue pval;
    DWORD i;



    //
    // add the default profile
    //

    SendDlgItemMessageA(
        hwnd,
        ResourceId,
        CB_ADDSTRING,
        0,
        (LPARAM) "<Default Profile>"
        );

    SendDlgItemMessage(
        hwnd,
        ResourceId,
        CB_SETCURSEL,
        0,
        0
        );

    if (!MapiAvail) {
        goto exit;
    }

    //
    // get the mapi table object
    //

    if (lpProfAdmin->lpVtbl->GetProfileTable( lpProfAdmin, 0, &pmt )) {
        goto exit;
    }

    //
    // get the actual profile data, FINALLY
    //

    if (pmt->lpVtbl->QueryRows( pmt, 4000, 0, &prws )) {
        goto exit;
    }

    //
    // enumerate the profiles and put the name
    // of each profile in the combo box
    //

    for (i=0; i<prws->cRows; i++) {
        pval = prws->aRow[i].lpProps;

        SendDlgItemMessageA(
            hwnd,
            ResourceId,
            CB_ADDSTRING,
            0,
            (LPARAM) pval[0].Value.lpszA
            );

        if (pval[2].Value.b) {
           //
           // this is the default profile
           //
        }
    }

    //
    // set the first one to be the current one
    //

    SendDlgItemMessage(
        hwnd,
        ResourceId,
        CB_SETCURSEL,
        0,
        0
        );

    rVal = TRUE;

exit:
    FreeSRowSet( prws );
    MLCRelease( (LPUNKNOWN)pmt );

    return rVal;
}


BOOL
GetExchangeInstallCommand(
    LPWSTR InstallCommandW
    )
{
    HKEY hKey;
    LONG rVal;
    DWORD Bytes;
    DWORD Type;
    CHAR InstallCommand[512];


    rVal = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        "Software\\Microsoft\\Windows Messaging Subsystem",
        &hKey
        );
    if (rVal == ERROR_SUCCESS) {
        Bytes = sizeof(InstallCommand);
        rVal = RegQueryValueEx(
            hKey,
            "InstallCmd",
            NULL,
            &Type,
            (LPBYTE) InstallCommand,
            &Bytes
            );
        RegCloseKey( hKey );
        if (rVal == ERROR_SUCCESS) {
            AnsiStringToUnicodeString( InstallCommand, InstallCommandW );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
InstallExchangeClientExtension(
    LPSTR  ExtensionName,
    LPSTR  ExtensionKey,
    LPSTR  FileName,
    LPSTR  ContextMask
    )
{
    HKEY hKey;
    LONG rVal;
    CHAR Buffer[512];
    CHAR ExpandedFileName[MAX_PATH];
    CHAR KeyName[MAX_PATH];
    DWORD dontcare;

    sprintf( KeyName, "Software\\Microsoft\\Exchange\\Client\\%s", ExtensionKey );

    rVal = RegCreateKeyEx(
                          HKEY_LOCAL_MACHINE,
                          KeyName,
                          0,
                          NULL,
                          0,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hKey,
                          &dontcare );

    if (rVal == ERROR_SUCCESS) {

        ExpandEnvironmentStrings( FileName, ExpandedFileName, sizeof(ExpandedFileName) );

        sprintf( Buffer, "4.0;%s;1;%s", ExpandedFileName, ContextMask );

        rVal = RegSetValueEx(
            hKey,
            ExtensionName,
            0,
            REG_SZ,
            (LPBYTE) Buffer,
            strlen(Buffer) + 1
            );

        RegCloseKey( hKey );

        return rVal == ERROR_SUCCESS;
    }

    return FALSE;
}


DWORD
IsExchangeRunning(
    VOID
    )
{
    #define MAX_TASKS 256
    DWORD TaskCount;
    PTASK_LIST TaskList = NULL;
    DWORD ExchangePid = 0;
    DWORD i;


    if (MapiStartedByLogon) {
        return 0;
    }

    TaskList = (PTASK_LIST) malloc( MAX_TASKS * sizeof(TASK_LIST) );
    if (!TaskList) {
        goto exit;
    }

    TaskCount = GetTaskList( TaskList, MAX_TASKS );
    if (!TaskCount) {
        goto exit;
    }

    for (i=0; i<TaskCount; i++) {
        if (_stricmp( TaskList[i].ProcessName, "exchng32.exe" ) == 0) {
            ExchangePid = TaskList[i].dwProcessId;
            break;
        } else
        if (_stricmp( TaskList[i].ProcessName, "mapisp32.exe" ) == 0) {
            ExchangePid = TaskList[i].dwProcessId;
            break;
        }
    }

exit:
    free( TaskList );
    return ExchangePid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ocm\server.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    server.c

Abstract:

    This file implements the server file copy code.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "faxocm.h"
#pragma hdrstop



DWORD
ServerGetStepCount(
    VOID
    )
{
#ifdef NT5FAXINSTALL
    return 0;
#else
    return 5;
#endif
}


DWORD
ServerInstallation(
    HWND hwnd,
    LPWSTR SourceRoot
    )
{
    DWORD ErrorCode = 0;
    DWORD OldInstallType;
    WCHAR FileName[256];
    BOOL CompleteInstall = FALSE;
    WCHAR FaxCommonPath[MAX_PATH+1];
    LPTSTR pCommonPath;
    WCHAR CommonChar;
    DWORD attrib;
    HKEY hKey;  

#define MakeSpecialDirectory(_DIR,_HIDE) *pCommonPath = CommonChar;\
                                         *(pCommonPath+1) = (WCHAR) 0;\
                                         ConcatenatePaths( FaxCommonPath, _DIR ) ;\
                                         MakeDirectory( FaxCommonPath );\
                                         if (_HIDE) HideDirectory(FaxCommonPath);\

    DeviceInitialization( hwnd );

    if (NtGuiMode) {
        DebugPrint(( TEXT("faxocm - starting lanmanserver") ));
        MyStartService( L"LanmanServer" );
        if (FaxDevices > 0) {
            CompleteInstall = TRUE;
        }
    } else {
        CompleteInstall = TRUE;
    }

    //
    // delete the fax modem inf
    //

    ExpandEnvironmentStrings( L"%systemroot%\\awmodem.inf", FileName, sizeof(FileName)/sizeof(WCHAR) );
    MyDeleteFile( FileName );

    DebugPrint(( TEXT("faxocm - setting registry") ));

    //
    // set the registry data
    //

    //
    // hack: during NT GUI-mode setup, we need to retrieve the user's name twice because
    // the name is entered by the user after we've retreived the data (so we get a bogus name if we don't do this!)
    //
    if (NtGuiMode) {
       HKEY hKey;
       LPWSTR RegisteredOwner;

       hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_WINDOWSNT_CURRVER, TRUE, KEY_ALL_ACCESS );
       RegisteredOwner = GetRegistryString( hKey, REGVAL_REGISTERED_OWNER, EMPTY_STRING );
       RegCloseKey( hKey );       

       if (RegisteredOwner && RegisteredOwner[0]) {
          wcscpy( WizData.UserName, RegisteredOwner );
          MemFree( RegisteredOwner );
       }
    }
    SetProgress( IDS_SETTING_REGISTRY );

    if (!SetServerRegistryData( SourceRoot )) {
        DebugPrint(( L"SetServerRegistryData() failed" ));
        ErrorCode = IDS_COULD_SET_REG_DATA;
        goto error_exit;
    }

    if (!SetClientRegistryData()) {
        DebugPrint(( L"SetClientRegistryData() failed" ));
        ErrorCode = IDS_COULD_SET_REG_DATA;
        goto error_exit;
    }

    SetSoundRegistryData();

    DeleteModemRegistryKey();

    //
    // set all of the install flags in the registry
    // this must be done before the fax service is
    // started so it can query the values
    //

    OldInstallType = InstallType;

    SetInstalledFlag( TRUE );
    SetInstallType( NtWorkstation ? FAX_INSTALL_WORKSTATION : FAX_INSTALL_SERVER );
    SetInstalledPlatforms( 0 );

    //
    // install the fax service
    //

    SetProgress( IDS_INSTALLING_FAXSVC );

    if (!Upgrade) {
        if (!InstallFaxService( TRUE, TRUE, NULL, NULL )) {
            DebugPrint(( L"InstallFaxService() failed" ));
            ErrorCode = GetLastError();
            goto error_exit;
        }
    } else {
        RenameFaxService();
    }

    //
    // do the exchange stuff
    //
    SetProgress( IDS_INSTALLING_EXCHANGE );
    DoExchangeInstall( hwnd );

    //
    // create the printer
    //

    SetProgress( IDS_CREATING_FAXPRT );

    if (!Upgrade) {
        if (CompleteInstall) {
            DebugPrint(( TEXT("faxocm - creating fax printer") ));
            
            if (!CreateLocalFaxPrinter( WizData.PrinterName )) {
                DebugPrint(( L"CreateLocalFaxPrinter() failed" ));
                if (!NtGuiMode) {
                    StopFaxService();
                    DeleteFaxService();
                    SetInstalledFlag( FALSE );
                    ErrorCode = IDS_COULD_NOT_CREATE_PRINTER;
                    goto error_exit;
                }
            }
        }

    } else {
        if (NtGuiMode) {
            DeleteRegistryTree( HKEY_LOCAL_MACHINE, REGKEY_FAX_SECURITY );
            RecreateNt4FaxPrinters();
            RecreateNt5Beta3FaxPrinters();
        }
    }

    //
    // create the program group and it's items
    //

    DebugPrint(( TEXT("faxocm - creating program groups") ));
    
    SetProgress( IDS_CREATING_GROUPS );

    if (CompleteInstall) {
        //
        // safe to do this in an upgrade, since it's a noop if it's already there
        //
        CreateGroupItems( NULL );
        //
        // should be safe to do this in all cases since it will be a noop if it's not there
        //
        DeleteNt4Group();
    }

    if (NtGuiMode && (CompleteInstall == FALSE) ) {
        //
        // rename fax.cpl, so that it doesn't show up in the control panel
        //
        LPTSTR srcFile = ExpandEnvironmentString( TEXT("%systemroot%\\system32\\fax.cpl") );
        LPTSTR dstFile = ExpandEnvironmentString( TEXT("%systemroot%\\system32\\fax.cpk") );

        if (!MoveFileEx(srcFile, dstFile, MOVEFILE_REPLACE_EXISTING)) {
            MoveFileEx(srcFile, dstFile, MOVEFILE_REPLACE_EXISTING | MOVEFILE_DELAY_UNTIL_REBOOT);
        }

        MemFree( srcFile );
        MemFree( dstFile );
    }


    DebugPrint(( TEXT("faxocm - creating directories") ));

    //
    // share amd create the windows fax directory
    //

    if (!Upgrade) {

        if (WizData.ArchiveOutgoing) {
            if (*WizData.ArchiveDir) {
                //
                // specified in unattend
                //
                MakeDirectory( WizData.ArchiveDir );
            } else {
                
                if (!MyGetSpecialPath( CSIDL_COMMON_DOCUMENTS, FaxCommonPath ) ) {
                   DebugPrint(( TEXT("Couldn't MyGetSpecialPath, ec = %d\n"), GetLastError() ));
                   ErrorCode = IDS_COULD_NOT_SET_APP_PATH;
                   goto error_exit;
                }
                
                ConcatenatePaths( FaxCommonPath, GetString(IDS_ARCHIVE_DIR) ) ;
                MakeDirectory( FaxCommonPath );
                wcscpy( WizData.ArchiveDir, FaxCommonPath);                
            }           

            //SetFaxShellExtension( WizData.ArchiveDir );
        }

        if (WizData.RoutingMask & LR_STORE) {
            if (*WizData.RouteDir) {
                //
                // specified in unattend
                //
                MakeDirectory(WizData.RouteDir);
            } else {
                if (!MyGetSpecialPath( CSIDL_COMMON_DOCUMENTS, FaxCommonPath ) ) {
                   DebugPrint(( TEXT("Couldn't MyGetSpecialPath, ec = %d\n"), GetLastError() ));
                   ErrorCode = IDS_COULD_NOT_SET_APP_PATH;
                   goto error_exit;
                }
                
                ConcatenatePaths( FaxCommonPath, GetString(IDS_RECEIVE_DIR) ) ;
                MakeDirectory( FaxCommonPath );                
                wcscpy( WizData.RouteDir, FaxCommonPath);                
            }           

            //SetFaxShellExtension( WizData.RouteDir );
        }        

        if (!MyGetSpecialPath( CSIDL_COMMON_DOCUMENTS, FaxCommonPath ) ) {
           DebugPrint(( TEXT("Couldn't MyGetSpecialPath, ec = %d\n"), GetLastError() ));
           ErrorCode = IDS_COULD_NOT_SET_APP_PATH;
           goto error_exit;
        }

        ConcatenatePaths( FaxCommonPath, GetString(IDS_COVERPAGE_DIR) ) ;
        if (IsProductSuite()) {
            CreateNetworkShare( FaxCommonPath, TEXT("COVERPG$"), EMPTY_STRING );
        }
        pCommonPath = wcsrchr( FaxCommonPath, L'\\' );
        if (pCommonPath) {
            *pCommonPath = (WCHAR)0;
        }

        SuperHideDirectory(FaxCommonPath);

        if (!MyGetSpecialPath( CSIDL_COMMON_APPDATA, FaxCommonPath ) ) {
           DebugPrint(( TEXT("Couldn't MyGetSpecialPath, ec = %d\n"), GetLastError() ));
           ErrorCode = IDS_COULD_NOT_SET_APP_PATH;
           goto error_exit;
        }

        pCommonPath = &FaxCommonPath[wcslen(FaxCommonPath) -1];
        CommonChar = FaxCommonPath[wcslen(FaxCommonPath) -1];

        ConcatenatePaths( FaxCommonPath, FAX_DIR ) ;
        MakeDirectory( FaxCommonPath );

        MakeSpecialDirectory( FAX_RECEIVE_DIR, TRUE );
        MakeSpecialDirectory( FAX_QUEUE_DIR, TRUE );
        
        if (IsProductSuite()) {
            MakeSpecialDirectory( FAX_CLIENT_DIR, TRUE );
            MakeSpecialDirectory( FAX_CLIENT_DIR_I386, FALSE  );
            MakeSpecialDirectory( FAX_CLIENT_DIR_ALPHA, FALSE  );
            MakeSpecialDirectory( FAX_CLIENT_DIR_WIN95, FALSE );
            
            *pCommonPath = CommonChar;
            *(pCommonPath+1) = (WCHAR) 0;
            ConcatenatePaths( FaxCommonPath, FAX_DIR ) ;
            CreateNetworkShare( FaxCommonPath, FAX_SHARE, EMPTY_STRING );
        }
    } else {
        //
        // Remove the system attribute from the archive and receive folders
        // Delete desktop.ini from the archive and receive folders
        //
        if (MyGetSpecialPath( CSIDL_COMMON_DOCUMENTS, FaxCommonPath ) ) {
            ConcatenatePaths( FaxCommonPath, GetString(IDS_ARCHIVE_DIR) ) ;

            attrib = GetFileAttributes( FaxCommonPath );
            attrib &= ~FILE_ATTRIBUTE_SYSTEM;
            SetFileAttributes( FaxCommonPath, attrib );

            ConcatenatePaths( FaxCommonPath, TEXT("desktop.ini") );
            MoveFileEx( FaxCommonPath, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
        }

        if (MyGetSpecialPath( CSIDL_COMMON_DOCUMENTS, FaxCommonPath ) ) {
            ConcatenatePaths( FaxCommonPath, GetString(IDS_RECEIVE_DIR) ) ;

            attrib = GetFileAttributes( FaxCommonPath );
            attrib &= ~FILE_ATTRIBUTE_SYSTEM;
            SetFileAttributes( FaxCommonPath, attrib );

            ConcatenatePaths( FaxCommonPath, TEXT("desktop.ini") );
            MoveFileEx( FaxCommonPath, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
        }

        //
        // Unregister the old faxshell.dll
        //

        DeleteRegistryKey( HKEY_CLASSES_ROOT, TEXT("Clsid\\{7f9609be-af9a-11d1-83e0-00c04fb6e984}") );

        hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved"), TRUE, NULL );
        if (hKey) {
            RegDeleteValue( hKey, TEXT("{7f9609be-af9a-11d1-83e0-00c04fb6e984}") );
            RegCloseKey( hKey );
        }
    }

    return TRUE;

error_exit:

    //
    // reset the install registry data
    //

    SetInstalledFlag( Installed );
    SetInstallType( OldInstallType );
    SetInstalledPlatforms( InstalledPlatforms );

    //
    // display the error message
    //

    PopUpMsg( hwnd, ErrorCode, TRUE, 0 );

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ocm\resource.h ===
#define FAX_EULA                                904
#define IDI_FAX_ICON                            905
#define BINARY                                  1024

#define IDC_STATIC                              -1

#define IDD_WELCOME                             101
#define IDD_EULA                                102
#define IDD_FINAL                               103

#define IDS_COULD_NOT_CREATE_PRINTER            501
#define IDS_COULD_SET_REG_DATA                  502
#define IDS_CREATING_FAXPRT                     503
#define IDS_CREATING_GROUPS                     504
#define IDS_DEFAULT_CSID                        505
#define IDS_DEFAULT_DIR                         506
#define IDS_DEFAULT_PRINTER_NAME                507
#define IDS_DEFAULT_TSID                        508
#define IDS_DELETING_FAX_SERVICE                509
#define IDS_DELETING_GROUPS                     510
#define IDS_DELETING_REGISTRY                   511
#define IDS_INBOUND_DIR                         512
#define IDS_INSTALLING_EXCHANGE                 513
#define IDS_INSTALLING_FAXSVC                   514
#define IDS_QUERY_CANCEL                        515
#define IDS_SETTING_REGISTRY                    516
#define IDS_EULA_SUBTITLE                       517
#define IDS_EULA_TITLE                          518
#define IDS_TITLE_WKS                           519
#define IDS_TITLE_SRV                           520
#define IDS_TITLE_PP                            521
#define IDS_TITLE_RA                            522
#define IDS_ERR_TITLE                           523
#define IDS_WRN_TITLE                           524
#define IDS_FAXGROUP                            525
#define IDS_CPE_ITEM                            526
#define IDS_FAXSEND_ITEM                        527
#define IDS_FAXCFG_ITEM                         528
#define IDS_FAXVIEWER_ITEM                      529
#define IDS_FAXHELP_ITEM                        530
#define IDS_FAXQUEUE_ITEM                       531
#define IDS_FAX_DISPLAY_NAME                    532
#define IDS_FAXAB_DISPLAY_NAME                  533
#define IDS_FAXXP_DISPLAY_NAME                  534
#define IDS_MODEM_PROVIDER_NAME                 535
#define IDS_FAX_UNINSTALL_NAME                  536
#define IDS_FAXADMIN_ITEM                       537
#define IDS_FAXQUEUE_EXE                        538
#define IDS_FAXQUEUE_WORKINGDIRECTORY           539
#define IDS_FAXQUEUE_ICON                       540
#define IDS_CPE_EXE                             541
#define IDS_CPE_WORKINGDIRECTORY                542
#define IDS_CPE_ICON                            543
#define IDS_FAXSEND_EXE                         544
#define IDS_FAXSEND_WORKINGDIRECTORY            545
#define IDS_FAXSEND_ICON                        546
#define IDS_FAXCFG_EXE                          547
#define IDS_FAXCFG_WORKINGDIRECTORY             548
#define IDS_FAXCFG_ICON                         549
#define IDS_FAXVIEWER_EXE                       550
#define IDS_FAXVIEWER_WORKINGDIRECTORY          551
#define IDS_FAXVIEWER_ICON                      552
#define IDS_FAXHELP_EXE                         553
#define IDS_FAXHELP_WORKINGDIRECTORY            554
#define IDS_FAXHELP_ICON                        555
#define IDS_FAXADMIN_EXE                        556
#define IDS_FAXADMIN_WORKINGDIRECTORY           557
#define IDS_FAXADMIN_ICON                       558
#define IDS_PERSONAL_COVERPAGE                  559
#define IDC_LICENSE_AGREEMENT                   601
#define IDC_ACCEPT                              602
#define IDC_DECLINE                             603
#define IDC_WELCOME_TITLE                       604
#define IDC_WELCOME_SUBTITLE                    605
#define IDC_FINAL_TITLE                         606
#define IDC_FINAL_SUBTITLE                      607
#define IDS_FAXPRINTER_ITEM                     608
#define IDS_FAXPRINTER_EXE                      609
#define IDS_FAXPRINTER_ICON                     610
#define IDS_FAXPRINTER_WORKINGDIRECTORY         611
#define IDS_COULD_NOT_SET_APP_PATH              612
#define IDS_RECEIVE_DIR                         613
#define IDS_ARCHIVE_DIR                         614
#define IDS_FAXFOLDER_ITEM                      615
#define IDS_FAXFOLDER_EXE                       616
#define IDS_FAXFOLDER_ICON                      617
#define IDS_FAXFOLDER_WORKINGDIRECTORY          618
#define IDS_NT4FAX_GROUP                        619
#define IDS_COMMONAPPDIR                        620
#define IDS_COVERPAGE                           621
#define IDS_COVERPAGEDESC                       622
#define IDS_MONITOR                             623
#define IDS_INCOMING                            624
#define IDS_OUTGOING                            625
#define IDS_SERVICE_DESCRIPTION                 626
#define IDS_COVERPAGE_DIR                       627

#define IDS_FAXQUEUE_INFOTIP                    628
#define IDS_CPE_INFOTIP                         629
#define IDS_FAXSEND_INFOTIP                     630
#define IDS_FAXFOLDER_INFOTIP                   631
#define IDS_FAXCFG_INFOTIP                      632
#define IDS_FAXVIEWER_INFOTIP                   633
#define IDS_FAXHELP_INFOTIP                     634
#define IDS_FAXADMIN_INFOTIP                    635
#define IDS_FAXPRINTER_INFOTIP                  636
#define IDS_RT_EMAIL_FRIENDLY                   637 
#define IDS_RT_FOLDER_FRIENDLY                  638
#define IDS_RT_INBOX_FRIENDLY                   639
#define IDS_RT_PRINT_FRIENDLY                   640
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ocm\service.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    service.c

Abstract:

    This file provides access to the service control
    manager for starting, stopping, adding, and removing
    services.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "faxocm.h"
#pragma hdrstop



BOOL
InstallFaxService(
    BOOL UseLocalSystem,
    BOOL DemandStart,
    LPTSTR AccountName,
    LPTSTR Password
    )

/*++

Routine Description:

    Service installation function.  This function just
    calls the service controller to install the FAX service.
    It is required that the FAX service run in the context
    of a user so that the service can access MAPI, files on
    disk, the network, etc.

Arguments:

    UseLocalSystem  - Don't use the accountname/password, use LocalSystem
    Username        - User name where the service runs.
    Password        - Password for the user name.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/

{
    SC_HANDLE               hSvcMgr;
    SC_HANDLE               hService;
    DWORD                   ErrorCode;
    DWORD                   NumberOfTries = 0;

    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        DebugPrint(( L"could not open service manager: error code = %u", GetLastError() ));
        return FALSE;
    }

try_again:
    hService = OpenService(
        hSvcMgr,
        FAX_SERVICE_NAME,
        SERVICE_ALL_ACCESS
        );

    if (hService) {

        CloseServiceHandle( hService );
        

        if (MyDeleteService( FAX_SERVICE_NAME )) {
            goto AddService;
        }

        NumberOfTries += 1;

        if (NumberOfTries < 2) {
            goto try_again;
        } else {
            CloseServiceHandle( hSvcMgr );
            return FALSE;
        }
    }

AddService:

    if (!UseLocalSystem) {
        ErrorCode = SetServiceSecurity( AccountName );
        if (ErrorCode) {
            DebugPrint(( L"Could not grant access rights to [%s] : error code = 0x%08x", AccountName, ErrorCode ));
            SetLastError( ERROR_SERVICE_LOGON_FAILED );
            return FALSE;
        }
    }

    hService = CreateService(
        hSvcMgr,
        FAX_SERVICE_NAME,
        GetString(IDS_FAX_DISPLAY_NAME),
        SERVICE_ALL_ACCESS,
        UseLocalSystem ? SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS : SERVICE_WIN32_OWN_PROCESS,
        DemandStart ? SERVICE_DEMAND_START : SERVICE_AUTO_START,
        SERVICE_ERROR_NORMAL,
        FAX_SERVICE_IMAGE_NAME,
        NULL,
        NULL,
        FAX_SERVICE_DEPENDENCY,
        UseLocalSystem ? NULL : AccountName,
        UseLocalSystem ? NULL : Password
        );

    if (!hService) {
        DebugPrint(( L"Could not create fax service: error code = %u", GetLastError() ));
        return FALSE;
    }

    SERVICE_DESCRIPTION ServiceDescription;
    ServiceDescription.lpDescription = (LPTSTR) GetString( IDS_SERVICE_DESCRIPTION );
    
    ChangeServiceConfig2( hService, SERVICE_CONFIG_DESCRIPTION, (LPVOID)&ServiceDescription);

    ErrorCode = SetServiceWorldAccessMask( hService, SERVICE_START );

    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    if (ErrorCode == 0) {
        DebugPrint(( L"Could not set SERVICE_START access mask on service, ec=%u", GetLastError() ));
        MyDeleteService( FAX_SERVICE_NAME );
    }

    return ErrorCode;
}


BOOL
RenameFaxService(
    VOID
    )

/*++

Routine Description:

    Renames the FAX service from "Microsoft Fax Service" to "Fax Service".
    
    If the fax svc has any other name or is already named 
    "Microsoft Fax Service", the service is still renamed.

Arguments:

    None

Return Value:

    Return code.  Return zero for success, indicating the faxsvc was 
    successfully renamed, all other values indicate errors.

--*/

{
    SC_HANDLE               hSvcMgr = NULL;
    SC_HANDLE               hService = NULL;
    BOOL                    bResult;

    bResult = FALSE;

    //
    // get a handle to the fax service so we can look at it's display name
    //
    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        DebugPrint(( L"could not open service manager: error code = %u", GetLastError() ));
        goto e0;
    }

    hService = OpenService(
        hSvcMgr,
        FAX_SERVICE_NAME,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        DebugPrint(( L"could not open fax service: error code = %u", GetLastError() ));
        goto e1;
    }

    //
    // Change the service display name.  
    // SERVICE_NO_CHANGE and NULL indicate no change to that parameter
    //
    bResult = ChangeServiceConfig(
        hService,
        SERVICE_NO_CHANGE,
        SERVICE_NO_CHANGE,
        SERVICE_NO_CHANGE,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        GetString(IDS_FAX_DISPLAY_NAME));

    if (hService) CloseServiceHandle( hService );
e1:
    if (hSvcMgr) CloseServiceHandle( hSvcMgr );
e0:
    return(bResult);
}


DWORD
StartTheService(
    LPTSTR ServiceName
    )
{
    DWORD                   rVal = 0;
    SC_HANDLE               hSvcMgr = NULL;
    SC_HANDLE               hService = NULL;
    SERVICE_STATUS          Status;
    DWORD                   OldCheckPoint = 0;
    DWORD                   i = 0;



    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        rVal = GetLastError();
        DebugPrint(( L"could not open service manager: error code = %u", rVal ));
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        rVal = GetLastError();
        DebugPrint((
            L"could not open the %s service: error code = %u",
            ServiceName,
            rVal
            ));
        goto exit;
    }

    //
    // the service exists, lets start it
    //

    if (!StartService( hService, 0, NULL )) {
        rVal = GetLastError();
        if (rVal == ERROR_SERVICE_ALREADY_RUNNING) {
            rVal = ERROR_SUCCESS;
            goto exit;
        }
        
        DebugPrint((
            L"could not start the %s service: error code = %u",
            ServiceName,
            rVal
            ));
        goto exit;
    }

    do {
        if (!QueryServiceStatus( hService, &Status )) {
            DebugPrint((
                L"could not query status for the %s service: error code = %u",
                ServiceName,
                rVal
                ));
            break;
        }
        i += 1;
        if (i > 60) {
            break;
        }
        Sleep( 1000 );
    } while (Status.dwCurrentState != SERVICE_RUNNING);

    if (Status.dwCurrentState != SERVICE_RUNNING) {
        rVal = GetLastError();
        DebugPrint((
            L"could not start the %s service: error code = %u",
            ServiceName,
            rVal
            ));
        goto exit;
    }

    rVal = ERROR_SUCCESS;

exit:

    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}


DWORD
MyStartService(
    LPTSTR ServiceName
    )
{
    DWORD                   rVal = 0;
    SC_HANDLE               hSvcMgr = NULL;
    SC_HANDLE               hService = NULL;
    LPENUM_SERVICE_STATUS   EnumServiceStatus = NULL;



    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        rVal = GetLastError();
        DebugPrint(( L"could not open service manager: error code = %u", rVal ));
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        rVal = GetLastError();
        DebugPrint((
            L"could not open the %s service: error code = %u",
            ServiceName,
            rVal
            ));
        goto exit;
    }

    rVal = StartTheService( ServiceName );

exit:

    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}


BOOL
StopTheService(
    LPTSTR ServiceName
    )
{
    DWORD           rVal = 0;
    SC_HANDLE       hSvcMgr;
    SC_HANDLE       hService;
    SERVICE_STATUS  Status;
    DWORD           OldCheckPoint;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        DebugPrint(( L"could not open service manager: error code = %u", GetLastError() ));
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        DebugPrint((
            L"could not open the %s service: error code = %u",
            ServiceName,
            GetLastError()
            ));
        goto exit;
    }

    //
    // the service exists, lets stop it
    //

    ControlService(
        hService,
        SERVICE_CONTROL_STOP,
        &Status
        );

    if (!QueryServiceStatus( hService, &Status )) {
        DebugPrint((
            L"could not query status for the %s service: error code = %u",
            ServiceName,
            GetLastError()
            ));
        goto exit;
    }

    while (Status.dwCurrentState == SERVICE_RUNNING) {

        OldCheckPoint = Status.dwCheckPoint;

        Sleep( Status.dwWaitHint );

        if (!QueryServiceStatus( hService, &Status )) {
            break;
        }

        if (OldCheckPoint >= Status.dwCheckPoint) {
            break;
        }

    }

    if (Status.dwCurrentState == SERVICE_RUNNING) {
        DebugPrint((
            L"could not stop the %s service: error code = %u",
            ServiceName,
            GetLastError()
            ));
        goto exit;
    }

    rVal = TRUE;


exit:

    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}


BOOL
MyStopService(
    LPTSTR ServiceName
    )
{
    DWORD                   rVal = 0;
    SC_HANDLE               hSvcMgr;
    SC_HANDLE               hService;
    LPENUM_SERVICE_STATUS   EnumServiceStatus = NULL;
    DWORD                   BytesNeeded;
    DWORD                   ServiceCount;
    DWORD                   i;



    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        DebugPrint(( L"could not open service manager: error code = %u", GetLastError() ));
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        DebugPrint((
            L"could not open the %s service: error code = %u",
            ServiceName,
            GetLastError()
            ));
        goto exit;
    }

    if (!EnumDependentServices( hService, SERVICE_ACTIVE, NULL, 0, &BytesNeeded, &ServiceCount )) {
        if (GetLastError() != ERROR_MORE_DATA) {
            DebugPrint(( L"could not enumerate dependent services, ec=%d", GetLastError() ));
            goto exit;
        }
        EnumServiceStatus = (LPENUM_SERVICE_STATUS) MemAlloc( BytesNeeded );
        if (!EnumServiceStatus) {
            DebugPrint(( L"could not allocate memory for EnumDependentServices()" ));
            goto exit;
        }
    }

    if (!EnumDependentServices( hService, SERVICE_ACTIVE, EnumServiceStatus, BytesNeeded, &BytesNeeded, &ServiceCount )) {
        DebugPrint(( L"could not enumerate dependent services, ec=%d", GetLastError() ));
        goto exit;
    }

    if (ServiceCount) {
        for (i=0; i<ServiceCount; i++) {
            StopTheService( EnumServiceStatus[i].lpServiceName );
        }
    }

    StopTheService( ServiceName );

exit:

    if (EnumServiceStatus) {
        MemFree( EnumServiceStatus );
    }

    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}


DWORD
StartFaxService(
    VOID
    )
{
    return MyStartService( FAX_SERVICE_NAME );

}


BOOL
StopFaxService(
    VOID
    )
{
    return MyStopService( FAX_SERVICE_NAME );
}


BOOL
StartSpoolerService(
    VOID
    )
{
    DWORD Result;
    
    Result = MyStartService( L"Spooler");

    
    if (Result != ERROR_SUCCESS) {
        return FALSE;
    }

    //
    // the spooler lies about it's starting state, but
    // doesn't provide a way to synchronize the completion
    // of it starting.  so we just wait for some random time period.
    //

    Sleep( 1000 * 7 );

    return TRUE;
}


BOOL
StopSpoolerService(
    VOID
    )
{
    return MyStopService( L"Spooler" );
}


BOOL
SetServiceDependency(
    LPTSTR ServiceName,
    LPTSTR DependentServiceName
    )
{
    BOOL            rVal = FALSE;
    SC_HANDLE       hSvcMgr;
    SC_HANDLE       hService;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        DebugPrint(( L"could not open service manager: error code = %u", GetLastError() ));
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        DebugPrint((
            L"could not open the %s service: error code = %u",
            ServiceName,
            GetLastError()
            ));
        goto exit;
    }


    if (!ChangeServiceConfig(
        hService,               // handle to service
        SERVICE_NO_CHANGE,      // type of service
        SERVICE_NO_CHANGE,      // when to start service
        SERVICE_NO_CHANGE,      // severity if service fails to start
        NULL,                   // pointer to service binary file name
        NULL,                   // pointer to load ordering group name
        NULL,                   // pointer to variable to get tag identifier
        DependentServiceName,   // pointer to array of dependency names
        NULL,                   // pointer to account name of service
        NULL,                   // pointer to password for service account
        NULL                    // pointer to display name
        )) {
        DebugPrint(( L"could not open change service configuration, ec=%d", GetLastError() ));
        goto exit;
    }

    rVal = TRUE;

exit:
    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}


BOOL
SetServiceStart(
    LPTSTR ServiceName,
    DWORD StartType
    )
{
    BOOL            rVal = FALSE;
    SC_HANDLE       hSvcMgr;
    SC_HANDLE       hService;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        DebugPrint(( L"could not open service manager: error code = %u", GetLastError() ));
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        DebugPrint((
            L"could not open the %s service: error code = %u",
            ServiceName,
            GetLastError()
            ));
        goto exit;
    }


    if (!ChangeServiceConfig(
        hService,                        // handle to service
        SERVICE_NO_CHANGE,               // type of service
        StartType,                       // when to start service
        SERVICE_NO_CHANGE,               // severity if service fails to start
        NULL,                            // pointer to service binary file name
        NULL,                            // pointer to load ordering group name
        NULL,                            // pointer to variable to get tag identifier
        NULL,                            // pointer to array of dependency names
        NULL,                            // pointer to account name of service
        NULL,                            // pointer to password for service account
        NULL                             // pointer to display name
        ))
    {
        DebugPrint(( L"could not open change service configuration, ec=%d", GetLastError() ));
        goto exit;
    }

    rVal = TRUE;

exit:
    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}


BOOL
SetServiceAccount(
    LPTSTR ServiceName,
    PSECURITY_INFO SecurityInfo
    )
{
    BOOL            rVal = FALSE;
    SC_HANDLE       hSvcMgr;
    SC_HANDLE       hService;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        DebugPrint(( L"could not open service manager: error code = %u", GetLastError() ));
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        DebugPrint((
            L"could not open the %s service: error code = %u",
            ServiceName,
            GetLastError()
            ));
        goto exit;
    }


    if (!ChangeServiceConfig(
        hService,                        // handle to service
        SERVICE_NO_CHANGE,               // type of service
        SERVICE_NO_CHANGE,               // when to start service
        SERVICE_NO_CHANGE,               // severity if service fails to start
        NULL,                            // pointer to service binary file name
        NULL,                            // pointer to load ordering group name
        NULL,                            // pointer to variable to get tag identifier
        NULL,                            // pointer to array of dependency names
        SecurityInfo->AccountName,       // pointer to account name of service
        SecurityInfo->Password,          // pointer to password for service account
        NULL                             // pointer to display name
        )) {
        DebugPrint(( L"could not open change service configuration, ec=%d", GetLastError() ));
        goto exit;
    }

    rVal = TRUE;

exit:
    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}


BOOL
MyDeleteService(
    LPTSTR ServiceName
    )
{
    SC_HANDLE       hSvcMgr = NULL;
    SC_HANDLE       hService = NULL;
    SERVICE_STATUS  Status;
    DWORD           NumberOfTries = 0;
    BOOL            bSuccess = FALSE;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        return FALSE;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (hService) {

        //
        // the service exists, lets be sure that it is stopped
        //
Try_Again:
        if (!ControlService( hService, SERVICE_CONTROL_STOP, &Status )  && 
            GetLastError() == ERROR_INVALID_SERVICE_CONTROL ) {

            if (NumberOfTries < 3) {
                //
                // service is in the "START PENDING" state.  Let's wait a bit and try again.
                //
                NumberOfTries += 1;
                Sleep( 2 * 1000 );
                goto Try_Again;
            } else {
                goto Exit;
            }

        }
        
        //
        // now delete it
        //

        if (!DeleteService( hService )) {
            if (GetLastError() == ERROR_SERVICE_MARKED_FOR_DELETE) {
                bSuccess = TRUE;
            }
        } else {
            bSuccess = TRUE;
        }        

    } else {
        //
        // service doesn't exist, return TRUE even though we've done nothing
        //
        bSuccess = TRUE;
    }

Exit:
    if (hService) {
        CloseServiceHandle( hService );
    }

    if (hSvcMgr) {
        CloseServiceHandle( hSvcMgr );
    }

    return bSuccess;
}


BOOL
DeleteFaxService(
    VOID
    )
{
    return MyDeleteService( FAX_SERVICE_NAME );
}


BOOL
SetFaxServiceAutoStart(
    VOID
    )
{
    return SetServiceStart( FAX_SERVICE_NAME, SERVICE_AUTO_START );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ocm\security.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    service.c

Abstract:

    This file provides access to the service control
    manager for starting, stopping, adding, and removing
    services.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "faxocm.h"

#include <ntsecapi.h>
#include <lm.h>



NTSTATUS
OpenPolicy(
    LPWSTR ServerName,          // machine to open policy on (Unicode)
    DWORD DesiredAccess,        // desired access to policy
    PLSA_HANDLE PolicyHandle    // resultant policy handle
    );

BOOL
GetAccountSid(
    LPWSTR SystemName,          // where to lookup account
    LPWSTR AccountName,         // account of interest
    PSID *Sid                   // resultant buffer containing SID
    );

NTSTATUS
SetPrivilegeOnAccount(
    LSA_HANDLE PolicyHandle,    // open policy handle
    PSID AccountSid,            // SID to grant privilege to
    LPWSTR PrivilegeName,       // privilege to grant (Unicode)
    BOOL bEnable                // enable or disable
    );

void
InitLsaString(
    PLSA_UNICODE_STRING LsaString, // destination
    LPWSTR String                  // source (Unicode)
    );

void
DisplayNtStatus(
    LPSTR szAPI,                // pointer to function name (ANSI)
    NTSTATUS Status             // NTSTATUS error value
    );

void
DisplayWinError(
    LPSTR szAPI,                // pointer to function name (ANSI)
    DWORD WinError              // DWORD WinError
    );

#define RTN_OK 0
#define RTN_USAGE 1
#define RTN_ERROR 13

//
// If you have the ddk, include ntstatus.h.
//
#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS  ((NTSTATUS)0x00000000L)
#endif


BOOL
GetDefaultDomainName(
    LPWSTR DomainName
    )
{
    OBJECT_ATTRIBUTES           ObjectAttributes;
    NTSTATUS                    NtStatus;
    DWORD                       err             = 0;
    LSA_HANDLE                  LsaPolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo      = NULL;


    //
    //  Open a handle to the local machine's LSA policy object.
    //

    InitializeObjectAttributes( &ObjectAttributes,  // object attributes
                                NULL,               // name
                                0L,                 // attributes
                                NULL,               // root directory
                                NULL );             // security descriptor

    NtStatus = LsaOpenPolicy( NULL,                 // system name
                              &ObjectAttributes,    // object attributes
                              POLICY_EXECUTE,       // access mask
                              &LsaPolicyHandle );   // policy handle

    if( !NT_SUCCESS( NtStatus ) )
    {
        return FALSE;
    }

    //
    //  Query the domain information from the policy object.
    //
    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyAccountDomainInformation,
                                          (PVOID *) &DomainInfo );

    if (!NT_SUCCESS(NtStatus))
    {
        LsaClose(LsaPolicyHandle);
        return FALSE;
    }


    (void) LsaClose(LsaPolicyHandle);

    //
    // Copy the domain name into our cache, and
    //

    CopyMemory( DomainName,
                DomainInfo->DomainName.Buffer,
                DomainInfo->DomainName.Length );

    //
    // Null terminate it appropriately
    //

    DomainName[DomainInfo->DomainName.Length / sizeof(WCHAR)] = L'\0';

    //
    // Clean up
    //
    LsaFreeMemory( (PVOID)DomainInfo );

    return TRUE;
}


LPWSTR
GetMachineName(
    LPWSTR AccountName
    )
{
    LSA_HANDLE PolicyHandle = NULL;
    WCHAR DomainName[128];
    WCHAR LocalComputerName[128];
    LPWSTR MachineName = NULL;
    LPWSTR p;
    LPWSTR DCName = NULL;
    NET_API_STATUS NetStatus;
    UNICODE_STRING NameStrings;
    PLSA_REFERENCED_DOMAIN_LIST ReferencedDomains = NULL;
    PLSA_TRANSLATED_SID LsaSids = NULL;
    PUSER_MODALS_INFO_1 Modals = NULL;
    DWORD Size;
    NTSTATUS Status;


    //
    // get the domain name
    //

    p = wcschr( AccountName, L'\\' );
    if (p) {
        *p = 0;
        wcscpy( DomainName, AccountName );
        *p = L'\\';
    } else {
        wcscpy( DomainName, AccountName );
    }

    //
    // Open the policy on the target machine.
    //
    Status = OpenPolicy(
        NULL,
        POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
        &PolicyHandle
        );
    if (Status != STATUS_SUCCESS) {
        goto exit;
    }

    //
    // lookup the domain name for the account
    //

    InitLsaString( &NameStrings, AccountName );

    Status = LsaLookupNames(
        PolicyHandle,
        1,
        &NameStrings,
        &ReferencedDomains,
        &LsaSids
        );
    if (Status != STATUS_SUCCESS) {
        goto exit;
    }

    //
    // get the local computer name
    //

    Size = sizeof(LocalComputerName);
    if (!GetComputerName( LocalComputerName, &Size )) {
        goto exit;
    }

    //
    // see if we are tring to set a local account
    //

    if (wcscmp( LocalComputerName, ReferencedDomains->Domains->Name.Buffer ) != 0) {

        //
        // see what part of the domain we are attempting to set
        //

        NetStatus = NetUserModalsGet( NULL, 1, (LPBYTE*) &Modals );
        if (NetStatus != NERR_Success) {
            goto exit;
        }

        if (Modals->usrmod1_role != UAS_ROLE_PRIMARY) {

            //
            // we know we are remote, so get the real dc name
            //

            NetStatus = NetGetDCName( NULL, DomainName, (LPBYTE*) &DCName );
            if (NetStatus != NERR_Success) {
                goto exit;
            }

            MachineName = StringDup( DCName );

        }
    }


exit:
    if (Modals) {
        NetApiBufferFree( Modals );
    }
    if (DCName) {
        NetApiBufferFree( DCName );
    }
    if (ReferencedDomains) {
        LsaFreeMemory( ReferencedDomains );
    }
    if (LsaSids) {
        LsaFreeMemory( LsaSids );
    }
    if (PolicyHandle) {
        LsaClose( PolicyHandle );
    }

    return MachineName;
}



DWORD
SetServiceSecurity(
    LPWSTR AccountName
    )
{
    LSA_HANDLE PolicyHandle;
    PSID pSid;
    NTSTATUS Status;
    int iRetVal=RTN_ERROR;
    LPWSTR MachineName;
    WCHAR NewAccountName[512];


    if (AccountName[0] == L'.') {
        if (GetDefaultDomainName( NewAccountName )) {
            wcscat( NewAccountName, &AccountName[1] );
            AccountName = NewAccountName;
        }
    }

    //
    // try to get the correct machine name
    //
    MachineName = GetMachineName( AccountName );

    //
    // Open the policy on the target machine.
    //
    Status = OpenPolicy(
        MachineName,
        POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
        &PolicyHandle
        );
    if (Status != STATUS_SUCCESS) {
        return RTN_ERROR;
    }

    //
    // Obtain the SID of the user/group.
    // Note that we could target a specific machine, but we don't.
    // Specifying NULL for target machine searches for the SID in the
    // following order: well-known, Built-in and local, primary domain,
    // trusted domains.
    //
    if(GetAccountSid(
            MachineName, // target machine
            AccountName,// account to obtain SID
            &pSid       // buffer to allocate to contain resultant SID
            )) {
        //
        // We only grant the privilege if we succeeded in obtaining the
        // SID. We can actually add SIDs which cannot be looked up, but
        // looking up the SID is a good sanity check which is suitable for
        // most cases.

        //
        // Grant the SeServiceLogonRight to users represented by pSid.
        //
        if((Status=SetPrivilegeOnAccount(
                    PolicyHandle,           // policy handle
                    pSid,                   // SID to grant privilege
                    L"SeServiceLogonRight", // Unicode privilege
                    TRUE                    // enable the privilege
                    )) == STATUS_SUCCESS) {
            iRetVal=RTN_OK;
        }
    }

    //
    // Close the policy handle.
    //
    LsaClose(PolicyHandle);

    //
    // Free memory allocated for SID.
    //
    if(pSid != NULL) MemFree(pSid);

    return iRetVal;
}


void
InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPWSTR String
    )
{
    DWORD StringLength;

    if (String == NULL) {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = wcslen(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
}

NTSTATUS
OpenPolicy(
    LPWSTR ServerName,
    DWORD DesiredAccess,
    PLSA_HANDLE PolicyHandle
    )
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server = NULL;

    //
    // Always initialize the object attributes to all zeroes.
    //
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    if (ServerName != NULL) {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        InitLsaString(&ServerString, ServerName);
        Server = &ServerString;
    }

    //
    // Attempt to open the policy.
    //
    return LsaOpenPolicy(
                Server,
                &ObjectAttributes,
                DesiredAccess,
                PolicyHandle
                );
}

/*++
This function attempts to obtain a SID representing the supplied
account on the supplied system.

If the function succeeds, the return value is TRUE. A buffer is
allocated which contains the SID representing the supplied account.
This buffer should be freed when it is no longer needed by calling
HeapFree(GetProcessHeap(), 0, buffer)

If the function fails, the return value is FALSE. Call GetLastError()
to obtain extended error information.
--*/

BOOL
GetAccountSid(
    LPWSTR SystemName,
    LPWSTR AccountName,
    PSID *Sid
    )
{
    LPWSTR ReferencedDomain=NULL;
    DWORD cbSid=128;    // initial allocation attempt
    DWORD cbReferencedDomain=32; // initial allocation size
    SID_NAME_USE peUse;
    BOOL bSuccess=FALSE; // assume this function will fail

    __try {

    //
    // initial memory allocations
    //
    if((*Sid=MemAlloc(cbSid)) == NULL) __leave;
    if((ReferencedDomain=(LPWSTR)MemAlloc(cbReferencedDomain)) == NULL) __leave;

    //
    // Obtain the SID of the specified account on the specified system.
    //
    while(!LookupAccountName(
                    SystemName,         // machine to lookup account on
                    AccountName,        // account to lookup
                    *Sid,               // SID of interest
                    &cbSid,             // size of SID
                    ReferencedDomain,   // domain account was found on
                    &cbReferencedDomain,
                    &peUse
                    )) {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            //
            // reallocate memory
            //
            if((*Sid=HeapReAlloc(
                        GetProcessHeap(),
                        0,
                        *Sid,
                        cbSid
                        )) == NULL) __leave;

            if((ReferencedDomain=(LPWSTR)HeapReAlloc(
                        GetProcessHeap(),
                        0,
                        ReferencedDomain,
                        cbReferencedDomain
                        )) == NULL) __leave;
        }
        else __leave;
    }

    //
    // Indicate success.
    //
    bSuccess=TRUE;

    } // finally
    __finally {

    //
    // Cleanup and indicate failure, if appropriate.
    //

    MemFree(ReferencedDomain);

    if(!bSuccess) {
        if(*Sid != NULL) {
            MemFree(*Sid);
            *Sid = NULL;
        }
    }

    } // finally

    return bSuccess;
}

NTSTATUS
SetPrivilegeOnAccount(
    LSA_HANDLE PolicyHandle,    // open policy handle
    PSID AccountSid,            // SID to grant privilege to
    LPWSTR PrivilegeName,       // privilege to grant (Unicode)
    BOOL bEnable                // enable or disable
    )
{
    LSA_UNICODE_STRING PrivilegeString;

    //
    // Create a LSA_UNICODE_STRING for the privilege name.
    //
    InitLsaString(&PrivilegeString, PrivilegeName);

    //
    // grant or revoke the privilege, accordingly
    //
    if(bEnable) {
        return LsaAddAccountRights(
                PolicyHandle,       // open policy handle
                AccountSid,         // target SID
                &PrivilegeString,   // privileges
                1                   // privilege count
                );
    }
    else {
        return LsaRemoveAccountRights(
                PolicyHandle,       // open policy handle
                AccountSid,         // target SID
                FALSE,              // do not disable all rights
                &PrivilegeString,   // privileges
                1                   // privilege count
                );
    }
}

PSID WorldSid = NULL;
SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
PACL gDacl = NULL,gSacl = NULL;
PSID gGroup = NULL,gOwner = NULL;



BOOL
MakeAbsoluteCopyFromRelative(
    PSECURITY_DESCRIPTOR  psdOriginal,
    PSECURITY_DESCRIPTOR* ppsdNew
    )
{
    // we have to find out whether the original is already self-relative
    SECURITY_DESCRIPTOR_CONTROL         sdc = 0;
    PSECURITY_DESCRIPTOR                psdAbsoluteCopy = NULL;
    DWORD                               dwRevision = 0;
    DWORD                               cb = 0;
    PACL Dacl = NULL, Sacl = NULL;

    BOOL                                bDefaulted;
    PSID Owner = NULL, Group = NULL;

    DWORD                               dwDaclSize = 0;
    BOOL                                bDaclPresent = FALSE;
    DWORD                               dwSaclSize = 0;
    BOOL                                bSaclPresent = FALSE;

    DWORD                               dwOwnerSize = 0;
    DWORD                               dwPrimaryGroupSize = 0;

    if( !IsValidSecurityDescriptor( psdOriginal ) ) {
        return FALSE;
    }

    if( !GetSecurityDescriptorControl( psdOriginal, &sdc, &dwRevision ) ) {
        DWORD err = GetLastError();
        goto cleanup;
    }

    if( sdc & SE_SELF_RELATIVE ) {
        // the original is in self-relative format, build an absolute copy

        // get the dacl
        if( !GetSecurityDescriptorDacl(
                                      psdOriginal,      // address of security descriptor
                                      &bDaclPresent,    // address of flag for presence of disc. ACL
                                      &Dacl,           // address of pointer to ACL
                                      &bDefaulted       // address of flag for default disc. ACL
                                      )
          ) {
            goto cleanup;
        }

        // get the sacl
        if( !GetSecurityDescriptorSacl(
                                      psdOriginal,      // address of security descriptor
                                      &bSaclPresent,    // address of flag for presence of disc. ACL
                                      &Sacl,           // address of pointer to ACL
                                      &bDefaulted       // address of flag for default disc. ACL
                                      )
          ) {
            goto cleanup;
        }

        // get the owner
        if( !GetSecurityDescriptorOwner(
                                       psdOriginal,    // address of security descriptor
                                       &Owner,        // address of pointer to owner security
                                       // identifier (SID)
                                       &bDefaulted     // address of flag for default
                                       )
          ) {
            goto cleanup;
        }

        // get the group
        if( !GetSecurityDescriptorGroup(
                                       psdOriginal,    // address of security descriptor
                                       &Group, // address of pointer to owner security
                                       // identifier (SID)
                                       &bDefaulted     // address of flag for default
                                       )
          ) {
            goto cleanup;
        }

        // get required buffer size
        cb = 0;
        MakeAbsoluteSD(
                      psdOriginal,              // address of self-relative SD
                      psdAbsoluteCopy,          // address of absolute SD
                      &cb,                      // address of size of absolute SD
                      NULL,                     // address of discretionary ACL
                      &dwDaclSize,              // address of size of discretionary ACL
                      NULL,                     // address of system ACL
                      &dwSaclSize,              // address of size of system ACL
                      NULL,                     // address of owner SID
                      &dwOwnerSize,             // address of size of owner SID
                      NULL,                     // address of primary-group SID
                      &dwPrimaryGroupSize       // address of size of group SID
                      );

        // alloc the memory
        psdAbsoluteCopy = (PSECURITY_DESCRIPTOR) MemAlloc( cb );
        Dacl = (PACL) MemAlloc( dwDaclSize );
        Sacl = (PACL) MemAlloc( dwSaclSize );
        Owner = (PSID) MemAlloc( dwOwnerSize );
        Group = (PSID) MemAlloc( dwPrimaryGroupSize );

        if(NULL == psdAbsoluteCopy ||
           NULL == Dacl ||
           NULL == Sacl ||
           NULL == Owner ||
           NULL == Group
          ) {
            goto cleanup;
        }

        // make the copy
        if( !MakeAbsoluteSD(
                           psdOriginal,            // address of self-relative SD
                           psdAbsoluteCopy,        // address of absolute SD
                           &cb,                    // address of size of absolute SD
                           Dacl,                  // address of discretionary ACL
                           &dwDaclSize,            // address of size of discretionary ACL
                           Sacl,                  // address of system ACL
                           &dwSaclSize,            // address of size of system ACL
                           Owner,                 // address of owner SID
                           &dwOwnerSize,           // address of size of owner SID
                           Group,          // address of primary-group SID
                           &dwPrimaryGroupSize     // address of size of group SID
                           )
          ) {
            goto cleanup;
        }
    } else {
        // the original is in absolute format, fail
        goto cleanup;
    }

    *ppsdNew = psdAbsoluteCopy;

    // paranoia check
    if( !IsValidSecurityDescriptor( *ppsdNew ) ) {
        goto cleanup;
    }
    if( !IsValidSecurityDescriptor( psdOriginal ) ) {
        goto cleanup;
    }

    gDacl = Dacl;
    gSacl = Sacl;
    gOwner = Owner;
    gGroup = Group;

    return(TRUE);

    cleanup:
    if( Dacl != NULL && bDaclPresent == TRUE ) {
        MemFree((PVOID) Dacl );
        Dacl = NULL;
    }
    if( Sacl != NULL && bSaclPresent == TRUE ) {
        MemFree((PVOID) Sacl );
        Sacl = NULL;
    }
    if( Owner != NULL ) {
        MemFree((PVOID) Owner );
        Owner = NULL;
    }
    if( Group != NULL ) {
        MemFree((PVOID) Group );
        Group = NULL;
    }
    if( psdAbsoluteCopy != NULL ) {
        MemFree((PVOID) psdAbsoluteCopy );
        psdAbsoluteCopy = NULL;
    }

    return (FALSE);
}


BOOL
SetServiceWorldAccessMask(
    SC_HANDLE hService,
    DWORD AccessMask
    )
{
    BOOL Rval = FALSE;
    DWORD Size = 0;
    PSECURITY_DESCRIPTOR sd = NULL, sdnew = NULL;
    BOOL DaclPresent = FALSE;
    PACL Dacl = NULL;
    BOOL DaclDefaulted = FALSE;
    PACCESS_ALLOWED_ACE Ace = NULL;
    BOOL bEveryoneFound = FALSE;
    DWORD cbAcl, cbAce;
    PACL DaclNew = NULL;
    DWORD i;

    if (WorldSid == NULL) {
        if (!AllocateAndInitializeSid( &WorldAuthority, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &WorldSid )) {
            goto exit;
        }
    }

    if (!QueryServiceObjectSecurity( hService, DACL_SECURITY_INFORMATION, &sd, 0, &Size ) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (sd = (PSECURITY_DESCRIPTOR) MemAlloc( Size )) &&
        QueryServiceObjectSecurity( hService, DACL_SECURITY_INFORMATION, sd, Size, &Size ))
    {
        if (GetSecurityDescriptorDacl( sd, &DaclPresent, &Dacl, &DaclDefaulted )) {
            if (!IsValidSecurityDescriptor(sd)) {
                goto exit;
            }
            cbAcl = sizeof (ACL);
            for (i=0; i<Dacl->AceCount; i++) {
                if (GetAce( Dacl, i, (LPVOID*)&Ace )) {
                    if (EqualSid( WorldSid, &(Ace->SidStart))) {
                        Ace->Mask |= AccessMask;
                        bEveryoneFound = TRUE;
                    }
                    cbAce = sizeof (ACCESS_ALLOWED_ACE) - sizeof (DWORD);    // add this ACE's SID length
                    cbAce += GetLengthSid (Ace);
                    // add the length of each ACE to the total ACL length
                    cbAcl += cbAce;
                }
            }

            if (!MakeAbsoluteCopyFromRelative( sd, &sdnew )){
                    goto exit;
                }

            if (!bEveryoneFound) {

                // subtract ACE.SidStart from the size
                cbAce = sizeof (ACCESS_ALLOWED_ACE) - sizeof (DWORD);    // add this ACE's SID length
                cbAce += GetLengthSid (WorldSid);
                // add the length of each ACE to the total ACL length
                cbAcl += cbAce;

                DaclNew = (PACL) MemAlloc( cbAcl *4 );
                if (!DaclNew) {
                    goto exit;
                }

                if (!InitializeAcl(DaclNew, cbAcl*4, ACL_REVISION )) {
                    goto exit;
                }

                if (!IsValidAcl(DaclNew)) {
                    goto exit;
                }

                for (i = 0; i< Dacl->AceCount; i++) {
                    if (GetAce( Dacl, i, (LPVOID*)&Ace )) {
                        if (!AddAccessAllowedAce(
                                        DaclNew,
                                        ACL_REVISION,
                                        Ace->Mask,
                                        &(Ace->SidStart)
                                        )) {
                            goto exit;
                        }

                        if (!IsValidAcl(DaclNew)) {
                            goto exit;
                        }
                    } else {
                        goto exit;
                    }

                }
                if (!AddAccessAllowedAce(
                                        DaclNew,            // pointer to access-control list
                                        ACL_REVISION,    // ACL revision level
                                        SERVICE_QUERY_STATUS | AccessMask,     // access mask
                                        WorldSid        // pointer to security identifier);
                                        )) {
                    goto exit;
                }



                if (!IsValidAcl(DaclNew) ||
                    !IsValidSecurityDescriptor(sdnew) ||
                    !SetSecurityDescriptorDacl(
                                            sdnew,
                                            TRUE,
                                            DaclNew,
                                            FALSE )) {
                    goto exit;
                }

            }

            if (IsValidSecurityDescriptor( sdnew ) &&
                SetServiceObjectSecurity( hService, DACL_SECURITY_INFORMATION, sdnew )) {
                Rval = TRUE;
            }
        }
    }

exit:
    MemFree( sd );

    MemFree( sdnew );

    MemFree( DaclNew );

    MemFree( gDacl );
    MemFree( gSacl );
    MemFree( gGroup );
    MemFree( gOwner );

    return Rval;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ocm\uninstal.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    uninstal.c

Abstract:

    This file implements the un-install case.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "faxocm.h"
#pragma hdrstop





DWORD
DoUninstall(
    VOID
    )
{
    DWORD ErrorCode = 0;
    HKEY hKey;
    HKEY hKeyDevice;
    DWORD RegSize;
    DWORD RegType;
    LONG rVal;
    DWORD i = 0;
    WCHAR Buffer[MAX_PATH*2];


    //
    // kill the clients dir
    //

    wcscpy( Buffer,  Platforms[0].DriverDir );
    RemoveLastNode( Buffer );
    wcscat( Buffer, FAXCLIENTS_DIR );
    DeleteDirectoryTree( Buffer );

    //
    // kill the fax receieve dir(s)
    //

    rVal = RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_FAX_DEVICES, &hKey );
    if (rVal == ERROR_SUCCESS) {
        while (RegEnumKey( hKey, i++, Buffer, sizeof(Buffer)/sizeof(WCHAR) ) == ERROR_SUCCESS) {
            wcscat( Buffer, L"\\" );
            wcscat( Buffer, REGKEY_ROUTING );
            rVal = RegOpenKey( hKey, Buffer, &hKeyDevice );
            if (rVal == ERROR_SUCCESS) {
                RegSize = sizeof(Buffer);
                rVal = RegQueryValueEx(
                    hKeyDevice,
                    REGVAL_ROUTING_DIR,
                    0,
                    &RegType,
                    (LPBYTE) Buffer,
                    &RegSize
                    );
                if (rVal == ERROR_SUCCESS) {
                    DeleteDirectoryTree( Buffer );
                }
                RegCloseKey( hKeyDevice );
            }
        }
        RegCloseKey( hKey );
    }

    //
    // clean out the registry
    //

    SetProgress( IDS_DELETING_REGISTRY );
    DeleteFaxRegistryData();

    //
    // remove the fax service
    //

    SetProgress( IDS_DELETING_FAX_SERVICE );
    MyDeleteService( L"Fax" );

    //
    // remove the program groups
    //

    SetProgress( IDS_DELETING_GROUPS );
    DeleteGroupItems();

    DeleteFaxMsgServices();

    if (InstallType & FAX_INSTALL_SERVER) {
        DeleteNetworkShare( FAXCLIENTS_DIR );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ocm\tapi.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tapi.c

Abstract:

    This file provides all access to tapi.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "faxocm.h"
#pragma hdrstop

#include <initguid.h>
#include <devguid.h>

DWORD       TapiApiVersion;
HLINEAPP    hLineApp;
HANDLE      TapiEvent;
DWORD       TapiDevices;
DWORD       FaxDevices;
PLINE_INFO  LineInfo;
DWORD       CurrentLocationId;
LPVOID      AdaptiveModems;


#include "modem.c"


LONG
MyLineGetTransCaps(
    LPLINETRANSLATECAPS *LineTransCaps
    )
{
    DWORD LineTransCapsSize;
    LONG Rslt = ERROR_SUCCESS;


    //
    // allocate the initial linetranscaps structure
    //

    LineTransCapsSize = sizeof(LINETRANSLATECAPS) + 4096;
    *LineTransCaps = (LPLINETRANSLATECAPS) MemAlloc( LineTransCapsSize );
    if (!*LineTransCaps) {
        DebugPrint(( L"MemAlloc() failed, sz=0x%08x", LineTransCapsSize ));
        Rslt = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    (*LineTransCaps)->dwTotalSize = LineTransCapsSize;

    Rslt = lineGetTranslateCaps(
        hLineApp,
        TapiApiVersion,
        *LineTransCaps
        );

    if (Rslt != 0) {
        DebugPrint(( L"lineGetTranslateCaps() failed, ec=0x%08x", Rslt ));
        goto exit;
    }

    if ((*LineTransCaps)->dwNeededSize > (*LineTransCaps)->dwTotalSize) {

        //
        // re-allocate the LineTransCaps structure
        //

        LineTransCapsSize = (*LineTransCaps)->dwNeededSize;

        MemFree( *LineTransCaps );

        *LineTransCaps = (LPLINETRANSLATECAPS) MemAlloc( LineTransCapsSize );
        if (!*LineTransCaps) {
            DebugPrint(( L"MemAlloc() failed, sz=0x%08x", LineTransCapsSize ));
            Rslt = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        (*LineTransCaps)->dwTotalSize = LineTransCapsSize;

        Rslt = lineGetTranslateCaps(
            hLineApp,
            TapiApiVersion,
            *LineTransCaps
            );

        if (Rslt != 0) {
            DebugPrint(( L"lineGetTranslateCaps() failed, ec=0x%08x", Rslt ));
            goto exit;
        }

    }

exit:
    if (Rslt != ERROR_SUCCESS) {
        MemFree( *LineTransCaps );
        *LineTransCaps = NULL;
    }

    return Rslt;
}


BOOL
ValidateModem(
    PLINE_INFO LineInfo,
    LPLINEDEVCAPS LineDevCaps
    )
{
    PMDM_DEVSPEC MdmDevSpec;
    LPWSTR ModemKey;
    LPWSTR RespKeyName;
    HKEY hKey;


    if (LineDevCaps->dwDevSpecificSize == 0) {
        return FALSE;
    }

    MdmDevSpec = (PMDM_DEVSPEC) ((LPBYTE) LineDevCaps + LineDevCaps->dwDevSpecificOffset);
    if (MdmDevSpec->Contents != 1 || MdmDevSpec->KeyOffset != 8 && MdmDevSpec->String == NULL) {
        return FALSE;
    }

    ModemKey = AnsiStringToUnicodeString( (LPSTR) MdmDevSpec->String );
    if (!ModemKey) {
        return FALSE;
    }

    LineInfo->Flags = FPF_SEND;

    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, ModemKey, FALSE, KEY_READ );
    if (hKey) {
        RespKeyName = GetRegistryString( hKey, L"ResponsesKeyName", EMPTY_STRING );
        if (RespKeyName) {
            if (IsModemAdaptiveAnswer( AdaptiveModems, RespKeyName )) {
                LineInfo->Flags |= FPF_RECEIVE;
            }
            MemFree( RespKeyName );
        }
        RegCloseKey( hKey );
    }

    MemFree( ModemKey );

    return TRUE;
}


DWORD
DeviceInitialization(
    HWND hwnd
    )
{
    DWORD rVal = 0;
    LONG Rslt;
    LINEINITIALIZEEXPARAMS LineInitializeExParams;
    LINEEXTENSIONID lineExtensionID;
    DWORD LineDevCapsSize;
    LPLINEDEVCAPS LineDevCaps = NULL;
    LPWSTR DeviceClassList;
    BOOL UnimodemDevice;
    DWORD i;
    LPLINETRANSLATECAPS LineTransCaps = NULL;
    LPLINELOCATIONENTRY LineLocation = NULL;
    BOOL NoClass1 = FALSE;
    LPWSTR p;
    DWORD LocalTapiApiVersion;
    LPSTR ModemKey = NULL;


    DebugPrint(( TEXT("faxocm DeviceInitialization") ));
    //
    // initialize the adaptive answer data
    //

    AdaptiveModems = InitializeAdaptiveAnswerList( SetupInitComponent.ComponentInfHandle );

    //
    // initialize tapi
    //

    LineInitializeExParams.dwTotalSize      = sizeof(LINEINITIALIZEEXPARAMS);
    LineInitializeExParams.dwNeededSize     = 0;
    LineInitializeExParams.dwUsedSize       = 0;
    LineInitializeExParams.dwOptions        = LINEINITIALIZEEXOPTION_USEEVENT;
    LineInitializeExParams.Handles.hEvent   = NULL;
    LineInitializeExParams.dwCompletionKey  = 0;

    LocalTapiApiVersion = TapiApiVersion = 0x00020000;

    Rslt = lineInitializeEx(
        &hLineApp,
        hInstance,
        NULL,
        L"Fax Setup",
        &TapiDevices,
        &LocalTapiApiVersion,
        &LineInitializeExParams
        );

    if (Rslt != 0) {
        DebugPrint(( L"lineInitializeEx() failed, ec=0x%08x", Rslt ));
        hLineApp = NULL;
        goto exit;
    }

    if (TapiDevices == 0) {
        goto exit;
    }

    //
    // allocate the lineinfo structure
    //

    TapiEvent = LineInitializeExParams.Handles.hEvent;

    LineInfo = (PLINE_INFO) MemAlloc( TapiDevices * sizeof(LINE_INFO) );
    if (!LineInfo) {
        goto exit;
    }

    //
    // allocate the initial linedevcaps structure
    //

    LineDevCapsSize = sizeof(LINEDEVCAPS) + 4096;
    LineDevCaps = (LPLINEDEVCAPS) MemAlloc( LineDevCapsSize );
    if (!LineDevCaps) {
        goto exit;
    }

    //
    // enumerate all of the tapi devices
    //

    i = 0;

    do {

        Rslt = lineNegotiateAPIVersion(
            hLineApp,
            i,
            0x00010003,
            TapiApiVersion,
            &LocalTapiApiVersion,
            &lineExtensionID
            );
        if (Rslt != 0) {
            DebugPrint(( L"lineNegotiateAPIVersion() failed, ec=0x%08x", Rslt ));
            goto next_device;
        }

        ZeroMemory( LineDevCaps, LineDevCapsSize );
        LineDevCaps->dwTotalSize = LineDevCapsSize;

        Rslt = lineGetDevCaps(
            hLineApp,
            i,
            LocalTapiApiVersion,
            0,
            LineDevCaps
            );

        if (Rslt != 0) {
            DebugPrint(( L"lineGetDevCaps() failed, ec=0x%08x", Rslt ));
            goto next_device;
        }

        if (LineDevCaps->dwNeededSize > LineDevCaps->dwTotalSize) {

            //
            // re-allocate the linedevcaps structure
            //

            LineDevCapsSize = LineDevCaps->dwNeededSize;

            MemFree( LineDevCaps );

            LineDevCaps = (LPLINEDEVCAPS) MemAlloc( LineDevCapsSize );
            if (!LineDevCaps) {
                rVal = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }

            Rslt = lineGetDevCaps(
                hLineApp,
                i,
                TapiApiVersion,
                0,
                LineDevCaps
                );

            if (Rslt != 0) {
                DebugPrint(( L"lineGetDevCaps() failed, ec=0x%08x", Rslt ));
                goto next_device;
            }

        }

        if (TapiApiVersion != 0x00020000) {
            DebugPrint((
                L"TAPI device is incompatible with the FAX server: %s",
                (LPWSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwLineNameOffset)
                ));
            goto next_device;
        }

        //
        // save the line id
        //

        LineInfo[FaxDevices].PermanentLineID = LineDevCaps->dwPermanentLineID;
        LineInfo[FaxDevices].DeviceName = StringDup( (LPWSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwLineNameOffset) );
        LineInfo[FaxDevices].ProviderName = StringDup( (LPWSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwProviderInfoOffset) );
        LineInfo[FaxDevices].Rings = (LineDevCaps->dwLineStates & LINEDEVSTATE_RINGING) ? WizData.Rings : 0;
        LineInfo[FaxDevices].Flags = FPF_RECEIVE | FPF_SEND;

        //
        // filter out the commas because the spooler hates them
        //

        p = LineInfo[FaxDevices].DeviceName;
        while( p ) {
            p = wcschr( p, L',' );
            if (p) {
                *p = L'_';
            }
        }

        //
        // check for a modem device
        //

        UnimodemDevice = FALSE;

        if (LineDevCaps->dwDeviceClassesSize && LineDevCaps->dwDeviceClassesOffset) {
            DeviceClassList = (LPWSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwDeviceClassesOffset);
            while (*DeviceClassList) {
                if (wcscmp(DeviceClassList,L"comm/datamodem") == 0) {
                    UnimodemDevice = TRUE;
                    break;
                }
                DeviceClassList += (wcslen(DeviceClassList) + 1);
            }
        }

        if ((!(LineDevCaps->dwBearerModes & LINEBEARERMODE_VOICE)) ||
            (!(LineDevCaps->dwBearerModes & LINEBEARERMODE_PASSTHROUGH))) {
                //
                // unacceptable modem device type
                //
                UnimodemDevice = FALSE;
        }

        if (UnimodemDevice) {

            if (ValidateModem( &LineInfo[FaxDevices], LineDevCaps )) {
                FaxDevices += 1;
            }

        } else {

            if (LineDevCaps->dwMediaModes & LINEMEDIAMODE_G3FAX) {
                FaxDevices += 1;
            }
        }

next_device:
        i += 1;

    } while ( i < TapiDevices );

    if (FaxDevices == 0) {
        goto exit;
    }

    //
    // determine the current location information
    //

    Rslt = MyLineGetTransCaps( &LineTransCaps );
    if (Rslt != ERROR_SUCCESS) {
        if (Rslt == LINEERR_INIFILECORRUPT) {
            //
            // need to set the location information
            //
            if (!NtGuiMode) {
                Rslt = lineTranslateDialog( hLineApp, 0, LocalTapiApiVersion, hwnd, NULL );
                if (Rslt == ERROR_SUCCESS) {
                    Rslt = MyLineGetTransCaps( &LineTransCaps );
                }
            }
        }
        if (Rslt != ERROR_SUCCESS) {
            DebugPrint(( L"MyLineGetTransCaps() failed, ec=0x%08x", Rslt ));
            goto exit;
        }
    }

    LineLocation = (LPLINELOCATIONENTRY) ((LPBYTE)LineTransCaps + LineTransCaps->dwLocationListOffset);
    for (i=0; i<LineTransCaps->dwNumLocations; i++) {
        if (LineTransCaps->dwCurrentLocationID == LineLocation[i].dwPermanentLocationID) {
            break;
        }
    }

    if (i == LineTransCaps->dwNumLocations) {
        DebugPrint(( L"Could not determine the current location information" ));
        goto exit;
    }

    CurrentLocationId = LineTransCaps->dwCurrentLocationID;
    CurrentCountryId  = LineLocation->dwCountryID;
    CurrentAreaCode   = StringDup( (LPWSTR) ((LPBYTE)LineTransCaps + LineLocation->dwCityCodeOffset) );

exit:

    MemFree( LineDevCaps );
    MemFree( LineTransCaps );

    if (hLineApp) {
        lineShutdown( hLineApp );
        hLineApp = NULL;
    }

    DebugPrint(( TEXT("faxocm - found %d fax devices"), FaxDevices ));

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ocm\util.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This file implements utility functions.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "faxocm.h"
#include "tchar.h"
#pragma hdrstop

typedef struct _STRING_TABLE {
    DWORD   ResourceId;
    BOOL    UseTitle;
    LPWSTR  String;
} STRING_TABLE, *PSTRING_TABLE;


static STRING_TABLE StringTable[] =
{
    { IDS_TITLE_WKS,                         FALSE,      NULL },
    { IDS_TITLE_SRV,                         FALSE,      NULL },
    { IDS_TITLE_PP,                          FALSE,      NULL },
    { IDS_TITLE_RA,                          FALSE,      NULL },
    { IDS_WRN_TITLE,                          TRUE,      NULL },
    { IDS_ERR_TITLE,                          TRUE,      NULL },
    { IDS_COULD_NOT_CREATE_PRINTER,          FALSE,      NULL },
    { IDS_COULD_SET_REG_DATA,                FALSE,      NULL },
    { IDS_CREATING_FAXPRT,                   FALSE,      NULL },
    { IDS_CREATING_GROUPS,                   FALSE,      NULL },
    { IDS_DEFAULT_CSID,                      FALSE,      NULL },
    { IDS_DEFAULT_DIR,                       FALSE,      NULL },
    { IDS_DEFAULT_PRINTER_NAME,              FALSE,      NULL },
    { IDS_DEFAULT_TSID,                      FALSE,      NULL },
    { IDS_DELETING_FAX_SERVICE,              FALSE,      NULL },
    { IDS_DELETING_GROUPS,                   FALSE,      NULL },
    { IDS_DELETING_REGISTRY,                 FALSE,      NULL },
    { IDS_INBOUND_DIR,                       FALSE,      NULL },
    { IDS_INSTALLING_EXCHANGE,               FALSE,      NULL },
    { IDS_INSTALLING_FAXSVC,                 FALSE,      NULL },
    { IDS_QUERY_CANCEL,                      FALSE,      NULL },
    { IDS_SETTING_REGISTRY,                  FALSE,      NULL },
    { IDS_EULA_SUBTITLE,                     FALSE,      NULL },
    { IDS_EULA_TITLE,                        FALSE,      NULL },
    { IDS_FAX_DISPLAY_NAME,                  FALSE,      NULL },
    { IDS_FAXAB_DISPLAY_NAME,                FALSE,      NULL },
    { IDS_FAXXP_DISPLAY_NAME,                FALSE,      NULL },
    { IDS_MODEM_PROVIDER_NAME,               FALSE,      NULL },
    { IDS_FAX_UNINSTALL_NAME,                FALSE,      NULL },
    { IDS_PERSONAL_COVERPAGE,                FALSE,      NULL },
    { IDS_RECEIVE_DIR,                       FALSE,      NULL },
    { IDS_ARCHIVE_DIR,                       FALSE,      NULL },
    { IDS_COMMONAPPDIR,                      FALSE,      NULL },
    { IDS_COVERPAGE,                         FALSE,      NULL },
    { IDS_COVERPAGEDESC,                     FALSE,      NULL },
    { IDS_MONITOR,                           FALSE,      NULL },
    { IDS_INCOMING,                          FALSE,      NULL },
    { IDS_OUTGOING,                          FALSE,      NULL },
    { IDS_SERVICE_DESCRIPTION,               FALSE,      NULL },
    { IDS_COVERPAGE_DIR,                     FALSE,      NULL },
    { IDS_RT_EMAIL_FRIENDLY,                 FALSE,      NULL },
    { IDS_RT_FOLDER_FRIENDLY,                FALSE,      NULL },
    { IDS_RT_INBOX_FRIENDLY,                 FALSE,      NULL },
    { IDS_RT_PRINT_FRIENDLY,                 FALSE,      NULL }
};

#define CountStringTable (sizeof(StringTable)/sizeof(STRING_TABLE))


VOID
SetTitlesInStringTable(
    VOID
    )
{
    DWORD i;
    WCHAR Buffer[1024];
    DWORD Index = 0;


    for (i=0; i<CountStringTable; i++) {
        if (StringTable[i].UseTitle) {
            if (LoadString(
                hInstance,
                StringTable[i].ResourceId,
                Buffer,
                sizeof(Buffer)/sizeof(WCHAR)
                ))
            {
                if (StringTable[i].String) {
                    MemFree( StringTable[i].String );
                }
                StringTable[i].String = (LPWSTR) MemAlloc( StringSize( Buffer ) + 256 );
                if (StringTable[i].String) {
                    if (NtWorkstation) {
                        Index = 0;
                    } else {
                        Index = 1;
                    }
                    swprintf( StringTable[i].String, Buffer, StringTable[Index].String );
                }
            }
        }
    }
}


VOID
InitializeStringTable(
    VOID
    )
{
    DWORD i;
    WCHAR Buffer[512];
    SYSTEM_INFO SystemInfo;


    GetSystemInfo( &SystemInfo );

    switch (SystemInfo.wProcessorArchitecture) {

    case PROCESSOR_ARCHITECTURE_INTEL:
       swprintf(ThisPlatformName, L"i386" );
       break;

    case PROCESSOR_ARCHITECTURE_ALPHA:
       swprintf(ThisPlatformName, L"alpha" );
       break;

    case PROCESSOR_ARCHITECTURE_MIPS:
       swprintf(ThisPlatformName, L"mips" );
       break;

    case PROCESSOR_ARCHITECTURE_PPC:
       swprintf(ThisPlatformName, L"ppc" );
       break;

    default:
       DebugPrint(( L"Unsupported platform!" ));
       break;
    }


    for (i=0; i<CountStringTable; i++) {

        if (LoadString(
            hInstance,
            StringTable[i].ResourceId,
            Buffer,
            sizeof(Buffer)/sizeof(WCHAR)
            )) {

            StringTable[i].String = (LPWSTR) MemAlloc( StringSize( Buffer ) + 256 );
            if (!StringTable[i].String) {
                StringTable[i].String = L"";
            } else {
                wcscpy( StringTable[i].String, Buffer );
            }

        } else {

            StringTable[i].String = L"";

        }
    }

    SetTitlesInStringTable();
}


LPWSTR
GetString(
    DWORD ResourceId
    )
{
    DWORD i;

    for (i=0; i<CountStringTable; i++) {
        if (StringTable[i].ResourceId == ResourceId) {
            return StringTable[i].String;
        }
    }

    return NULL;
}

extern "C"
LPWSTR
MyGetString(
    DWORD ResourceId
    )
{
    DWORD i;

    for (i=0; i<CountStringTable; i++) {
        if (StringTable[i].ResourceId == ResourceId) {
            return StringTable[i].String;
        }
    }

    return NULL;
}


int
PopUpMsg(
    HWND hwnd,
    DWORD ResourceId,
    BOOL Error,
    DWORD Type
    )
{
   if (NtGuiMode) {
     WCHAR Buffer[256];
     wsprintf(Buffer, L"%s : %s\n", GetString( Error ? IDS_ERR_TITLE : IDS_WRN_TITLE ), GetString(ResourceId) );

     OutputDebugString(Buffer);
     return 0;
   }
    
   return MessageBox(
        hwnd,
        GetString( ResourceId ),
        GetString( Error ? IDS_ERR_TITLE : IDS_WRN_TITLE ),
        MB_SETFOREGROUND | (Error ? MB_ICONEXCLAMATION : MB_ICONINFORMATION) | (Type == 0 ? MB_OK : Type)
        );
}


int
PopUpMsgFmt(
    HWND hwnd,
    DWORD ResourceId,
    BOOL Error,
    DWORD Type,
    ...
    )
{
    WCHAR buf[1024];
    va_list arg_ptr;


    va_start(arg_ptr, Type);
    _vsnwprintf( buf, sizeof(buf), GetString( ResourceId ), arg_ptr );

   if (NtGuiMode) {
     WCHAR Buffer[1024];
     wsprintf(Buffer, L"%s : %s\n", GetString( Error ? IDS_ERR_TITLE : IDS_WRN_TITLE ), buf );

     OutputDebugString(Buffer);
     return 0;
   }

    return MessageBox(
        hwnd,
        buf,
        GetString( Error ? IDS_ERR_TITLE : IDS_WRN_TITLE ),
        MB_SETFOREGROUND | (Error ? MB_ICONEXCLAMATION : MB_ICONINFORMATION) | (Type == 0 ? MB_OK : Type)
        );
}


LPWSTR
GetProductName(
    VOID
    )
{
    DWORD Index;
    if (NtWorkstation) {
        Index = 0;
    } else {
        Index = 1;
    }
    return StringTable[Index].String;
}


VOID
DoExchangeInstall(
    HWND hwnd
    )
{
    TCHAR SystemPath[MAX_PATH];

    ExpandEnvironmentStrings(L"%systemroot%\\system32",SystemPath,sizeof(SystemPath));
    
    //
    // we don't install the fax address book anymore
    //
    //AddFaxAbToMapiSvcInf();

    AddFaxXpToMapiSvcInf(SystemPath);

    InstallExchangeClientExtension(
        EXCHANGE_CLIENT_EXT_NAME,
        "Extensions",
        EXCHANGE_CLIENT_EXT_FILE,
        EXCHANGE_CONTEXT_MASK
        );

#ifdef WX86
    TCHAR Wx86SystemPath[MAX_PATH];

    Wx86GetX86SystemDirectory(Wx86SystemPath, sizeof(Wx86SystemPath));

    //AddFaxAbToMapiSvcInf();
    AddFaxXpToMapiSvcInf(Wx86SystemPath);

    InstallExchangeClientExtension(
        EXCHANGE_CLIENT_EXT_NAME,
        "Extensions (x86)",
        EXCHANGE_CLIENT_EXT_FILE,
        EXCHANGE_CONTEXT_MASK
        );


#endif

    
}


BOOL
CreateNetworkShare(
    LPWSTR Path,
    LPWSTR ShareName,
    LPWSTR Comment
    )
{
    SHARE_INFO_2 ShareInfo;
    NET_API_STATUS rVal;
    WCHAR ExpandedPath[MAX_PATH*2];


    ExpandEnvironmentStrings( Path, ExpandedPath, sizeof(ExpandedPath) );

    ShareInfo.shi2_netname        = ShareName;
    ShareInfo.shi2_type           = STYPE_DISKTREE;
    ShareInfo.shi2_remark         = Comment;
    ShareInfo.shi2_permissions    = ACCESS_ALL;
    ShareInfo.shi2_max_uses       = (DWORD) -1,
    ShareInfo.shi2_current_uses   = (DWORD) -1;
    ShareInfo.shi2_path           = ExpandedPath;
    ShareInfo.shi2_passwd         = NULL;

    rVal = NetShareAdd(
        NULL,
        2,
        (LPBYTE) &ShareInfo,
        NULL
        );

    return rVal == 0;
}


BOOL
DeleteNetworkShare(
    LPWSTR ShareName
    )
{
    NET_API_STATUS rVal;


    rVal = NetShareDel(
        NULL,
        ShareName,
        0
        );

    return rVal == 0;
}


BOOL
DeleteDirectoryTree(
    LPWSTR Root
    )
{
    WCHAR FileName[MAX_PATH*2];
    WIN32_FIND_DATA FindData;
    HANDLE hFind;



    swprintf( FileName, L"%s\\*", Root );

    hFind = FindFirstFile( FileName, &FindData );
    if (hFind == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    do {

        if (FindData.cFileName[0] == L'.') {
            continue;
        }

        if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            DeleteDirectoryTree( FindData.cFileName );
        } else {
            MyDeleteFile( FindData.cFileName );
        }

    } while (FindNextFile( hFind, &FindData ));

    FindClose( hFind );

    RemoveDirectory( Root );

    return TRUE;
}


BOOL
MyDeleteFile(
    LPWSTR FileName
    )
{
    if (GetFileAttributes( FileName ) == 0xffffffff) {
        //
        // the file does not exists
        //
        return TRUE;
    }

    if (!DeleteFile( FileName )) {
        if (MoveFileEx( FileName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT )) {
            RebootRequired = TRUE;
            return TRUE;
        } else {
            return FALSE;
        }
    } else {
        return TRUE;
    }
}


VOID
FitRectToScreen(
    PRECT prc
    )
{
    INT cxScreen;
    INT cyScreen;
    INT delta;

    cxScreen = GetSystemMetrics(SM_CXSCREEN);
    cyScreen = GetSystemMetrics(SM_CYSCREEN);

    if (prc->right > cxScreen) {
        delta = prc->right - prc->left;
        prc->right = cxScreen;
        prc->left = prc->right - delta;
    }

    if (prc->left < 0) {
        delta = prc->right - prc->left;
        prc->left = 0;
        prc->right = prc->left + delta;
    }

    if (prc->bottom > cyScreen) {
        delta = prc->bottom - prc->top;
        prc->bottom = cyScreen;
        prc->top = prc->bottom - delta;
    }

    if (prc->top < 0) {
        delta = prc->bottom - prc->top;
        prc->top = 0;
        prc->bottom = prc->top + delta;
    }
}


VOID
CenterWindow(
    HWND hwnd,
    HWND hwndToCenterOver
    )
{
    RECT rc;
    RECT rcOwner;
    RECT rcCenter;
    HWND hwndOwner;

    GetWindowRect( hwnd, &rc );

    if (hwndToCenterOver) {
        hwndOwner = hwndToCenterOver;
        GetClientRect( hwndOwner, &rcOwner );
    } else {
        hwndOwner = GetWindow( hwnd, GW_OWNER );
        if (!hwndOwner) {
            hwndOwner = GetDesktopWindow();
        }
        GetWindowRect( hwndOwner, &rcOwner );
    }

    //
    //  Calculate the starting x,y for the new
    //  window so that it would be centered.
    //
    rcCenter.left = rcOwner.left +
            (((rcOwner.right - rcOwner.left) -
            (rc.right - rc.left))
            / 2);

    rcCenter.top = rcOwner.top +
            (((rcOwner.bottom - rcOwner.top) -
            (rc.bottom - rc.top))
            / 2);

    rcCenter.right = rcCenter.left + (rc.right - rc.left);
    rcCenter.bottom = rcCenter.top + (rc.bottom - rc.top);

    FitRectToScreen( &rcCenter );

    SetWindowPos(hwnd, NULL, rcCenter.left, rcCenter.top, 0, 0,
            SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
}


BOOL
CreateLocalFaxPrinter(
   LPWSTR FaxPrinterName
   )
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    WCHAR TmpCmdLine[512];
    WCHAR CmdLine[512];
    DWORD ExitCode;
    BOOL Rval = TRUE;
    MONITOR_INFO_2 MonitorInfo;
    PPRINTER_INFO_2 PrinterInfo;
    DWORD i;
    DWORD Count;
    WCHAR SourcePath[MAX_PATH];

    //
    // check to see if a fax printer already exists
    // if so, do nothing but return success
    //

    PrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters( NULL, 2, &Count, PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS );
    if (PrinterInfo) {
        for (i=0; i<Count; i++) {
            if (_wcsicmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0) {
                MemFree( PrinterInfo );
                return TRUE;
            }
        }
        MemFree( PrinterInfo );
    }

    //
    // create the print monitor
    //

    MonitorInfo.pName         = FAX_MONITOR_NAME;
    MonitorInfo.pEnvironment  = NULL;
    MonitorInfo.pDLLName      = FAX_MONITOR_FILE;

    if ((!AddMonitor( NULL, 2, (LPBYTE) &MonitorInfo )) &&
        (GetLastError() != ERROR_PRINT_MONITOR_ALREADY_INSTALLED))
    {
            DebugPrint(( L"AddMonitor() failed, ec=%d", GetLastError() ));
            return FALSE;
    }

    ExpandEnvironmentStrings( L"%windir%\\system32", &SourcePath[0], MAX_PATH );
    DebugPrint((L"faxocm - CreateLocalFaxPrinter SourcePath = %s", SourcePath));
    
    swprintf(
        TmpCmdLine,
        L"rundll32 printui.dll,PrintUIEntry %s /q /if /b \"%s\" /f \"%%windir%%\\inf\\ntprint.inf\" /r \"MSFAX:\" /m \"%s\" /l \"%s\"",
        IsProductSuite() ? L"/Z" : L"/z",
        FaxPrinterName,
        FAX_DRIVER_NAME,
        SourcePath
        );

    ExpandEnvironmentStrings( TmpCmdLine, CmdLine, sizeof(CmdLine)/sizeof(WCHAR) );

    GetStartupInfo( &si );

    if (!CreateProcess(
       NULL,
       CmdLine,
       NULL,
       NULL,
       FALSE,
       DETACHED_PROCESS,
       NULL,
       NULL,
       &si,
       &pi
       ))
    {
        return FALSE;
    }

    if (WaitForSingleObject( pi.hProcess, MinToNano(3) ) == WAIT_TIMEOUT) {
        TerminateProcess( pi.hProcess, 0 );
    }

    if (!GetExitCodeProcess( pi.hProcess, &ExitCode ) || ExitCode != 0) {
        Rval = FALSE;
    }

    CloseHandle( pi.hProcess );
    CloseHandle( pi.hThread );

    return Rval;
}

PVOID
MyEnumPortMonitors(
    LPTSTR  pServerName,
    DWORD   level,
    PDWORD  pcMonitors
    )
{
    PBYTE  pMonitorInfo = NULL;
    DWORD  cb = 0;
    DWORD  Error;

    if (!EnumMonitors(pServerName, level, NULL, 0, &cb, pcMonitors)){
        Error = GetLastError();
        if(Error == ERROR_INSUFFICIENT_BUFFER && (pMonitorInfo = (PBYTE) MemAlloc(cb)) != NULL){

            EnumMonitors(pServerName, level, pMonitorInfo, cb, &cb, pcMonitors);
            return pMonitorInfo;
        }
    }

    MemFree(pMonitorInfo);
    return NULL;
}

BOOL
RecreateNt5Beta3FaxPrinters(
    VOID
    )
{
    PMONITOR_INFO_2 MonitorInfo;
    MONITOR_INFO_2  MonitorStruct;
    PPRINTER_INFO_2 PrinterInfo;
    HANDLE hPrinter;
    DWORD Count, i, j = -1;
    PRINTER_DEFAULTS PrinterDefaults = {
        NULL,
        NULL,
        PRINTER_ALL_ACCESS
    };
    BOOL Result;
    WCHAR szDllPath[MAX_PATH];

    DebugPrint(( TEXT("faxocm inside RecreateNt5Beta3FaxPrinters") ));

    // Get the path for faxmon.dll
    ZeroMemory(szDllPath, sizeof(szDllPath));
    if (GetSystemDirectory(szDllPath, sizeof(szDllPath)) == 0) {
        DebugPrint(( TEXT("GetSystemDirectory() failed, ec = 0x%08x"), GetLastError() ));
        return FALSE;
    }
    wcscat(szDllPath, L"\\faxmon.dll");

    //
    // check to see if old port monitor exists
    // if so, delete all fax printers and recreate them
    //

    MonitorInfo = (PMONITOR_INFO_2) MyEnumPortMonitors( NULL, 2, &Count );
    if (!MonitorInfo) {
        return TRUE;
    }

    for (i=0; i<Count; i++) {
        if (_wcsicmp( MonitorInfo[i].pName, FAX_MONITOR_NAME ) == 0 &&
            _wcsicmp( MonitorInfo[i].pDLLName, L"faxmon.dll" ) == 0) {
            DebugPrint(( TEXT("faxocm found old port monitor") ));
            break;
        }
    }

    MemFree(MonitorInfo);

    if (i>=Count) {
        DebugPrint(( TEXT("faxocm did not find old port monitor") ));
        return TRUE;
    }

    PrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters( NULL, 2, &Count, PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS );
    if (!PrinterInfo) {
        goto e0;
    }

    for (i=0; i<Count; i++) {
        if (_wcsicmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0 &&
            _wcsicmp( PrinterInfo[i].pPortName, FAX_PORT_NAME ) == 0) {
            if (OpenPrinter( PrinterInfo[i].pPrinterName, &hPrinter, &PrinterDefaults)) {
                DebugPrint(( TEXT("faxocm deleting printer %s"), PrinterInfo[i].pPrinterName ));
                Result = DeletePrinter( hPrinter );
                j = i;
                ClosePrinter( hPrinter );
            }                
        }
    }

    MemFree( PrinterInfo );

e0:
    //
    // Delete the port monitor which will delete the port
    //
    DeleteMonitor( NULL, NULL, FAX_MONITOR_NAME);

    //
    // Mark faxmon.dll for deletion
    //
    MoveFileEx(szDllPath, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);

    //
    // create the print monitor
    //
    MonitorStruct.pName         = FAX_MONITOR_NAME;
    MonitorStruct.pEnvironment  = NULL;
    MonitorStruct.pDLLName      = FAX_MONITOR_FILE;

    if ((!AddMonitor( NULL, 2, (LPBYTE) &MonitorStruct )) &&
        (GetLastError() != ERROR_PRINT_MONITOR_ALREADY_INSTALLED))
    {
            DebugPrint(( L"AddMonitor() failed, ec=%d", GetLastError() ));
            return FALSE;
    }

    if ( j != -1 ) {
        //
        // create the fax printer which will create the port monitor
        //
        Result = CreateLocalFaxPrinter( GetString( IDS_DEFAULT_PRINTER_NAME ) );
        
        if (Result) {
            DebugPrint(( TEXT("faxocm created printer %s"), GetString( IDS_DEFAULT_PRINTER_NAME ) ));
        } else {
            DebugPrint(( TEXT("faxocm FAILED trying to create printer %s"), GetString( IDS_DEFAULT_PRINTER_NAME ) ));
        }
    }
        
    return TRUE;
}

BOOL
RecreateNt4FaxPrinters(
    VOID
    )
{
    PPRINTER_INFO_2 PrinterInfo;
    HANDLE hPrinter;
    DWORD Count, i, j = -1;
    PRINTER_DEFAULTS PrinterDefaults = {
        NULL,
        NULL,
        PRINTER_ALL_ACCESS
    };
    BOOL Result;

    DebugPrint(( TEXT("faxocm inside RecreateNt4FaxPrinters") ));
    //
    // check to see if a fax printer already exists
    // if so, delete it and create it
    //

    PrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters( NULL, 2, &Count, PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS );
    if (PrinterInfo) {
        for (i=0; i<Count; i++) {
            if (_wcsicmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0 &&
                _wcsicmp( PrinterInfo[i].pPortName, FAX_PORT_NAME ) != 0) {
                if (OpenPrinter( PrinterInfo[i].pPrinterName, &hPrinter, &PrinterDefaults)) {
                    DebugPrint(( TEXT("faxocm deleting printer %s"), PrinterInfo[i].pPrinterName ));
                    Result = DeletePrinter( hPrinter );
                    j = i;
                    ClosePrinter( hPrinter );
                }                
            }
        }
        if ( j != -1 ) {
            //
            // create the fax printer which will create the port monitor
            //
            Result = CreateLocalFaxPrinter( GetString( IDS_DEFAULT_PRINTER_NAME ) );
        
            if (Result) {
                DebugPrint(( TEXT("faxocm created printer %s"), GetString( IDS_DEFAULT_PRINTER_NAME ) ));
            } else {
                DebugPrint(( TEXT("faxocm FAILED trying to create printer %s"), GetString( IDS_DEFAULT_PRINTER_NAME ) ));
            }
        }        

        MemFree( PrinterInfo );
    }
    return TRUE;
}

BOOL
RegisterOleControlDlls(
    HINF InfHandle
    )
{
    typedef VOID (WINAPI *PREGISTERROUTINE)(VOID);
    INFCONTEXT InfLine;
    WCHAR Filename[MAX_PATH];
    WCHAR FullPath[MAX_PATH];
    BOOL b = TRUE;
    HMODULE ControlDll;
    DWORD d;
    LPCWSTR szOleControlDlls = L"OleControlDlls";
    WCHAR OldCD[MAX_PATH];
    PREGISTERROUTINE RegisterRoutine;


    //
    // Preserve current directory just in case
    //

    d = GetCurrentDirectory(MAX_PATH,OldCD);
    if(!d || (d >= MAX_PATH)) {
        OldCD[0] = 0;
    }

    OleInitialize(NULL);

    if (SetupFindFirstLine(InfHandle,szOleControlDlls,NULL,&InfLine)) {
        do {

            SetupGetStringField( &InfLine, 1, Filename, sizeof(Filename)/sizeof(WCHAR), &d );

            if (Filename[0]) {

                //
                // Form a full path to the dll
                //

                ExpandEnvironmentStrings( L"%windir%\\system32\\", FullPath, sizeof(FullPath)/sizeof(WCHAR) );
                SetCurrentDirectory( FullPath );
                wcscat( FullPath, Filename );

                if(ControlDll = LoadLibrary(FullPath)) {
                    if (RegisterRoutine = (PREGISTERROUTINE) GetProcAddress(ControlDll,"DllRegisterServer")) {
                        __try {
                            RegisterRoutine();
                        } __except (EXCEPTION_EXECUTE_HANDLER) {
                            b = FALSE;
                        }
                    } else {
                        b = FALSE;
                    }

                    FreeLibrary(ControlDll);
                } else {
                    b = FALSE;
                }
            } else {
                b = FALSE;
            }
        } while(SetupFindNextLine(&InfLine,&InfLine));
    }

    if(OldCD[0]) {
        SetCurrentDirectory(OldCD);
    }

    OleUninitialize();
    return b;
}

LPWSTR
VerifyInstallPath(
    LPWSTR SourcePath
    )
{
    HKEY hKey;
    WCHAR SourceFile[MAX_PATH];
    int len;

    //
    // make sure our source path contains necessary files.
    //

    wcscpy(SourceFile,SourcePath);
    len = wcslen(SourcePath);
    if (SourceFile[len-1] != '\\' ) {
        SourceFile[len] = '\\';
        SourceFile[len+1] = (WCHAR) 0;
    }

    wcscat(SourceFile,L"faxdrv.dll");

    if (GetFileAttributes(SourceFile) != (DWORD) -1 ) {
        return SourcePath;
    }

    //
    // our source path must be incorrect, use the registered NT source path
    //
    MemFree(SourcePath);

    hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,REGKEY_WINDOWSNT_CURRVER,FALSE,0);
    
    if (!hKey) {
        DebugPrint(( TEXT("Could'nt OpenRegistryKey, ec = %d\n"),GetLastError() ));
        return NULL;
    }

    SourcePath = GetRegistryString(hKey,REGVAL_SOURCE_PATH,NULL);
    
    RegCloseKey(hKey);

    return SourcePath;

}


BOOL
SetFaxShellExtension(
    LPCWSTR Path
    )
{
    WCHAR FileName[MAX_PATH];
    DWORD attrib;
    
    //
    // create the file
    //
    wsprintf(FileName, L"%s\\desktop.ini", Path);
    WritePrivateProfileString( L".ShellClassInfo",
                               L"UICLSID",
                               FAXSHELL_CLSID,
                               FileName
                             );                          

    //
    // hide it
    //
    attrib = GetFileAttributes( FileName );
    attrib |= FILE_ATTRIBUTE_HIDDEN;

    if (SetFileAttributes( FileName, attrib ) ) {
        //
        // better to use PathMakeSystemFolder, but don't want to get shlwapi involved,
        // so we just set the system flag for the folder.
        //
        attrib = GetFileAttributes( Path );
        attrib |= FILE_ATTRIBUTE_SYSTEM;
        return ( SetFileAttributes( Path, attrib ) );
    } else {
        return FALSE;
    }


}

BOOL
IsNt4or351Upgrade(
    VOID
    )
{
    //
    // we know that after installing NT5, the pid3.0 digital product id should be stored.  we can
    // determine if nt5 was installed by looking for this value
    //
    HKEY hKey;
    LONG rslt;
    BYTE data[1000];
    DWORD dwType;
    DWORD cbData = sizeof(data);
    

    rslt = RegOpenKey(HKEY_LOCAL_MACHINE,WINNT_CURVER,&hKey);
    if (rslt != ERROR_SUCCESS) {
        return FALSE;
    }

    rslt = RegQueryValueEx(hKey,DIGID,NULL,&dwType,data,&cbData);
    
    RegCloseKey(hKey);

    return (rslt != ERROR_SUCCESS);


}

BOOL
MyGetSpecialPath(
    INT Id,
    LPWSTR Buffer
    )
{
    WCHAR TempBuffer[MAX_PATH];
    HKEY hKey;
    LONG rslt;
    BYTE data[1000];
    DWORD dwType;
    DWORD cbData = sizeof(data);

    if (GetSpecialPath(Id,Buffer)) {
        return TRUE;
    }
    
    //
    // if it fails, then let's try to hack hack hack our way around this
    //    
    
    rslt = RegOpenKey(HKEY_LOCAL_MACHINE,WINNT_CURVER REGKEY_PROFILES ,&hKey);
    if (rslt != ERROR_SUCCESS) {
        return FALSE;
    }

    rslt = RegQueryValueEx(hKey,REGVAL_PROFILES,NULL,&dwType,data,&cbData);
    
    RegCloseKey(hKey);

    if (rslt != ERROR_SUCCESS) {
        //
        // 
        //
        return FALSE;
    }

    ExpandEnvironmentStrings((LPCTSTR) data,TempBuffer,sizeof(TempBuffer));

    if (Id == CSIDL_COMMON_APPDATA) {
        ConcatenatePaths( TempBuffer, GetString(IDS_COMMONAPPDIR) );
        lstrcpy( Buffer, TempBuffer);
        return TRUE;
    } 

    return FALSE;

}

BOOL
SuperHideDirectory(
    PWSTR Directory
    )
{
    //
    // super-hide means that even if the user says "show all files", the directory won't show up.
    //

    DWORD attrib;

    if (!Directory) {
        return FALSE;
    }

    //
    // hide it
    //
    attrib = GetFileAttributes( Directory );
    attrib |= (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);

    return ( SetFileAttributes( Directory, attrib ) );
    

}

BOOL
MyInitializeMapi(
    BOOL  MinimalInit
)
{
    HKEY    hKey = NULL;
    LPTSTR  szNoMailClient = NULL;
    LPTSTR  szPreFirstRun = NULL;
    BOOL    bRslt = FALSE;

    hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Clients\\Mail"), FALSE, KEY_ALL_ACCESS);
    if (hKey != NULL) {
        szNoMailClient = GetRegistryString(hKey, TEXT("NoMailClient"), TEXT(""));

        if (_tcscmp(szNoMailClient, TEXT("")) == 0) {
            MemFree(szNoMailClient);
            szNoMailClient = NULL;
        }
        else {
            RegDeleteValue(hKey, TEXT("NoMailClient"));
        }

        szPreFirstRun = GetRegistryString(hKey, TEXT("PreFirstRun"), TEXT(""));

        if (_tcscmp(szPreFirstRun, TEXT("")) == 0) {
            MemFree(szPreFirstRun);
            szPreFirstRun = NULL;
        }
        else {
            RegDeleteValue(hKey, TEXT("PreFirstRun"));
        }

    }

    bRslt = InitializeMapi(MinimalInit);

    if (szNoMailClient != NULL) {
        SetRegistryString(hKey, TEXT("NoMailClient"), szNoMailClient);

        MemFree(szNoMailClient);
    }

    if (szPreFirstRun != NULL) {
        SetRegistryString(hKey, TEXT("PreFirstRun"), szPreFirstRun);

        MemFree(szPreFirstRun);
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return bRslt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\setup\resource.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    This file contains all manafest contants for FAXSETUP's resources.

Author:

    Wesley Witt (wesw) 27-June-1995

Environment:

    User Mode

--*/


#define WIZARD_WIDTH                    276
#define WIZARD_HEIGTH                   140

#define IDC_STATIC                      -1
#define FAX_EULA                        901
#define BINARY                         1024

//
// icons
//

#define IDI_ACMEICON                    101

//
// bitmaps
//

#define IDB_FAXWIZ_BITMAP               201

//
// dialogs
//

#define IDD_SETUP_TYPE                  301
#define IDD_WELCOME                     302
#define IDD_INSTALL_MODE_PAGE           303

//
// controls
//

#define IDC_CLIENT_SETUP                401
#define IDC_REMOTE_ADMIN                402
#define IDC_SERVER_SETUP                403
#define IDC_WELCOME_LABEL01             404
#define IDC_WELCOME_LABEL02             405
#define IDC_WELCOME_LICENSE_AGREEMENT   406
#define IDC_WIZBMP                      407
#define IDC_WORKSTATION_SETUP           408
#define IDC_LICENSE_AGREEMENT           409
#define IDC_INSTALLMODE_LABEL01         410
#define IDC_UPGRADE                     411
#define IDC_UNINSTALL                   412
#define IDC_INSTALL_DRIVERS             413

//
// strings
//

#define IDS_TITLE_WKS                   501
#define IDS_TITLE_SRV                   502
#define IDS_BAD_OS                      503
#define IDS_ERR_TITLE                   504
#define IDS_MUST_BE_ADMIN               505
#define IDS_NOT_INSTALLED               506
#define IDS_NOT_SERVER                  507
#define IDS_QUERY_CANCEL                508
#define IDS_QUERY_UNINSTALL             509
#define IDS_WRN_TITLE                   510
#define IDS_AGREE                       511
#define IDS_DISAGREE                    512
#define IDS_SP2                         513
#define IDS_SMALLBIZ_ONLY               514
#define IDS_BAD_UNATTEND                515
#define IDS_INSTALLMODE_LABEL01         516
#define IDS_TITLE_PP                    517
#define IDS_TITLE_RA                    518
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\setup\faxsetup.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxsetup.c

Abstract:

    This file implements the Windows NT FAX Setup utility.

Environment:

        WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include <windows.h>
#include <commctrl.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "faxreg.h"
#include "faxutil.h"
#include "faxwiz.h"
#include "resource.h"


#define SERVICE_PACK_STRING         TEXT("Service Pack")

#define SETUP_TYPE_INVALID          0
#define SETUP_TYPE_WORKSTATION      1
#define SETUP_TYPE_SERVER           2
#define SETUP_TYPE_CLIENT           3
#define SETUP_TYPE_POINT_PRINT      4
#define SETUP_TYPE_REMOTE_ADMIN     5

LRESULT
WelcomeDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT
SetupModeDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT
InstallModeDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );


HINSTANCE  FaxWizModuleHandle;
DWORD      RequestedSetupType = SETUP_TYPE_INVALID;
DWORD      SetupType;
DWORD      InstallMode;
DWORD      ProductType;
DWORD      Installed;
DWORD      InstallType;
DWORD      InstalledPlatforms;
WNDPROC    OldEditProc;
LPWSTR     UnattendFileName;

typedef HPROPSHEETPAGE *LPHPROPSHEETPAGE;

typedef struct _WIZPAGE {
    UINT            ButtonState;
    UINT            HelpContextId;
    LPTSTR          Title;
    DWORD           PageId;
    DLGPROC         DlgProc;
    PROPSHEETPAGE   Page;
} WIZPAGE, *PWIZPAGE;


typedef struct _STRING_TABLE {
    DWORD   ResourceId;
    BOOL    UseTitle;
    LPTSTR  String;
} STRING_TABLE, *PSTRING_TABLE;


static STRING_TABLE StringTable[] =
{
    { IDS_TITLE_WKS,            FALSE,    NULL },
    { IDS_TITLE_SRV,            FALSE,    NULL },
    { IDS_TITLE_PP,             FALSE,    NULL },
    { IDS_TITLE_RA,             FALSE,    NULL },
    { IDS_BAD_OS,               TRUE,     NULL },
    { IDS_ERR_TITLE,            TRUE,     NULL },
    { IDS_MUST_BE_ADMIN,        TRUE,     NULL },
    { IDS_NOT_INSTALLED,        FALSE,    NULL },
    { IDS_NOT_SERVER,           TRUE,     NULL },
    { IDS_QUERY_CANCEL,         FALSE,    NULL },
    { IDS_QUERY_UNINSTALL,      TRUE,     NULL },
    { IDS_WRN_TITLE,            TRUE,     NULL },
    { IDS_AGREE,                TRUE,     NULL },
    { IDS_DISAGREE,             TRUE,     NULL },
    { IDS_SMALLBIZ_ONLY,        FALSE,    NULL },
    { IDS_BAD_UNATTEND,         FALSE,    NULL },
    { IDS_SP2,                  TRUE,     NULL },
    { IDS_INSTALLMODE_LABEL01,  TRUE,     NULL }
};

#define CountStringTable (sizeof(StringTable)/sizeof(STRING_TABLE))


typedef enum {
    WizPageWelcome,
    WizPageSetupMode,
    WizPageInstallMode,
    WizPageMaximum
} WizPage;


WIZPAGE SetupWizardPages[] = {

    //
    // Welcome page
    //
    {
       PSWIZB_NEXT,                                    // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageWelcome,                                 // page id
       WelcomeDlgProc,                                 // dlg proc
     { 0,                                              // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_WELCOME),                   // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       WelcomeDlgProc,                                 // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // Setup mode page
    //
    {
       PSWIZB_NEXT,                                    // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageSetupMode,                               // page id
       SetupModeDlgProc,                               // dlg proc
     { 0,                                              // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_SETUP_TYPE),                // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       SetupModeDlgProc,                               // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // Install Mode Page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,                      // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageInstallMode,                             // page id
       InstallModeDlgProc,                             // dlg proc
     { 0,                                              // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_INSTALL_MODE_PAGE),         // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       InstallModeDlgProc,                             // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }}

};


DWORD FaxSetupWizardPages[] =
{
    WizPageWelcome,
    WizPageSetupMode,
    WizPageInstallMode,
    (DWORD)-1
};



BOOL
IsUserAdmin(
    VOID
    );

VOID
CenterWindow(
    HWND hwnd,
    HWND hwndToCenterOver
    );


VOID
SetTitlesInStringTable(
    VOID
    )
{
    DWORD i;
    TCHAR Buffer[1024];
    DWORD Index = 0;


    for (i=0; i<CountStringTable; i++) {
        if (StringTable[i].UseTitle) {
            if (LoadString(
                FaxWizModuleHandle,
                StringTable[i].ResourceId,
                Buffer,
                sizeof(Buffer)
                ))
            {
                if (StringTable[i].String) {
                    MemFree( StringTable[i].String );
                }
                StringTable[i].String = (LPTSTR) MemAlloc( StringSize( Buffer ) + 256 );
                if (StringTable[i].String) {
                    switch (RequestedSetupType) {
                        case SETUP_TYPE_SERVER:
                            Index = 1;
                            break;

                        case SETUP_TYPE_WORKSTATION:
                            Index = 0;
                            break;

                        case SETUP_TYPE_CLIENT:
                            Index = 2;
                            break;

                        case SETUP_TYPE_POINT_PRINT:
                            Index = 2;
                            break;

                        case SETUP_TYPE_REMOTE_ADMIN:
                            Index = 3;
                            break;
                    }
                    _stprintf( StringTable[i].String, Buffer, StringTable[Index].String );
                }
            }
        }
    }
}


VOID
InitializeStringTable(
    VOID
    )
{
    DWORD i;
    HINSTANCE hInstance;
    TCHAR Buffer[256];


    hInstance = GetModuleHandle(NULL);

    for (i=0; i<CountStringTable; i++) {

        if (LoadString(
            hInstance,
            StringTable[i].ResourceId,
            Buffer,
            sizeof(Buffer)
            )) {

            StringTable[i].String = (LPTSTR) MemAlloc( StringSize( Buffer ) + 256 );
            if (!StringTable[i].String) {
                StringTable[i].String = TEXT("");
            } else {
                _tcscpy( StringTable[i].String, Buffer );
            }

        } else {

            StringTable[i].String = TEXT("");

        }
    }

    SetTitlesInStringTable();
}


LPTSTR
GetString(
    DWORD ResourceId
    )
{
    DWORD i;

    for (i=0; i<CountStringTable; i++) {
        if (StringTable[i].ResourceId == ResourceId) {
            return StringTable[i].String;
        }
    }

    return NULL;
}


VOID
SetWizPageTitle(
    HWND hWnd
    )
{
    DWORD Index = 0;
    switch (RequestedSetupType) {
        case SETUP_TYPE_SERVER:
            Index = 1;
            break;

        case SETUP_TYPE_WORKSTATION:
            Index = 0;
            break;

        case SETUP_TYPE_CLIENT:
            Index = 2;
            break;

        case SETUP_TYPE_POINT_PRINT:
            Index = 2;
            break;

        case SETUP_TYPE_REMOTE_ADMIN:
            Index = 3;
            break;
    }
    SetWindowText( GetParent( hWnd ), StringTable[Index].String );
}


int
PopUpMsg(
    HWND hwnd,
    DWORD ResourceId,
    BOOL Error,
    DWORD Type
    )
{
    return MessageBox(
        hwnd,
        GetString( ResourceId ),
        GetString( Error ? IDS_ERR_TITLE : IDS_WRN_TITLE ),
        MB_SETFOREGROUND | (Error ? MB_ICONEXCLAMATION : MB_ICONINFORMATION) | (Type == 0 ? MB_OK : Type)
        );
}


VOID
FitRectToScreen(
    PRECT prc
    )
{
    INT cxScreen;
    INT cyScreen;
    INT delta;

    cxScreen = GetSystemMetrics(SM_CXSCREEN);
    cyScreen = GetSystemMetrics(SM_CYSCREEN);

    if (prc->right > cxScreen) {
        delta = prc->right - prc->left;
        prc->right = cxScreen;
        prc->left = prc->right - delta;
    }

    if (prc->left < 0) {
        delta = prc->right - prc->left;
        prc->left = 0;
        prc->right = prc->left + delta;
    }

    if (prc->bottom > cyScreen) {
        delta = prc->bottom - prc->top;
        prc->bottom = cyScreen;
        prc->top = prc->bottom - delta;
    }

    if (prc->top < 0) {
        delta = prc->bottom - prc->top;
        prc->top = 0;
        prc->bottom = prc->top + delta;
    }
}


VOID
CenterWindow(
    HWND hwnd,
    HWND hwndToCenterOver
    )
{
    RECT rc;
    RECT rcOwner;
    RECT rcCenter;
    HWND hwndOwner;

    GetWindowRect( hwnd, &rc );

    if (hwndToCenterOver) {
        hwndOwner = hwndToCenterOver;
        GetClientRect( hwndOwner, &rcOwner );
    } else {
        hwndOwner = GetWindow( hwnd, GW_OWNER );
        if (!hwndOwner) {
            hwndOwner = GetDesktopWindow();
        }
        GetWindowRect( hwndOwner, &rcOwner );
    }

    //
    //  Calculate the starting x,y for the new
    //  window so that it would be centered.
    //
    rcCenter.left = rcOwner.left +
            (((rcOwner.right - rcOwner.left) -
            (rc.right - rc.left))
            / 2);

    rcCenter.top = rcOwner.top +
            (((rcOwner.bottom - rcOwner.top) -
            (rc.bottom - rc.top))
            / 2);

    rcCenter.right = rcCenter.left + (rc.right - rc.left);
    rcCenter.bottom = rcCenter.top + (rc.bottom - rc.top);

    FitRectToScreen( &rcCenter );

    SetWindowPos(hwnd, NULL, rcCenter.left, rcCenter.top, 0, 0,
            SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
}


LPHPROPSHEETPAGE
CreateWizardPages(
    HINSTANCE hInstance,
    PWIZPAGE SetupWizardPages,
    LPDWORD RequestedPages,
    LPDWORD PageCount
    )
{
    LPHPROPSHEETPAGE WizardPageHandles;
    LPDWORD PageList;
    DWORD PagesInSet;
    DWORD i;
    DWORD PageOrdinal;
    BOOL b;



    //
    // Determine which set of pages to use and how many there are in the set.
    //
    PageList = RequestedPages;

    PagesInSet = 0;
    while( PageList[PagesInSet] != (DWORD)-1) {
        PagesInSet += 1;
    }

    //
    // allocate the page handle array
    //

    WizardPageHandles = (HPROPSHEETPAGE*) MemAlloc(
        sizeof(HPROPSHEETPAGE) * PagesInSet
        );

    if (!WizardPageHandles) {
        return NULL;
    }

    //
    // Create each page.
    //

    b = TRUE;
    *PageCount = 0;
    for(i=0; b && (i<PagesInSet); i++) {

        PageOrdinal = PageList[i];

        SetupWizardPages[PageOrdinal].Page.hInstance = hInstance;
        SetupWizardPages[PageOrdinal].Page.dwFlags  |= PSP_USETITLE;
        SetupWizardPages[PageOrdinal].Page.lParam    = (LPARAM) &SetupWizardPages[PageOrdinal];

        SetupWizardPages[PageOrdinal].Page.dwSize = sizeof(PROPSHEETPAGE);

        WizardPageHandles[*PageCount] = CreatePropertySheetPage(
            &SetupWizardPages[PageOrdinal].Page
            );

        if(WizardPageHandles[*PageCount]) {
            (*PageCount)++;
        } else {
            b = FALSE;
        }

    }

    if (!b) {
        MemFree( WizardPageHandles );
        return NULL;
    }

    return WizardPageHandles;
}


BOOL
GetInstallationInfo(
    LPDWORD Installed,
    LPDWORD InstallType,
    LPDWORD InstalledPlatforms
    )
{
    HKEY hKey;
    LONG rVal;
    DWORD RegType;
    DWORD RegSize;


    if (Installed == NULL || InstallType == NULL) {
        return FALSE;
    }

    rVal = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        REGKEY_FAX_SETUP,
        &hKey
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not open setup registry key, ec=0x%08x"), rVal ));
        return FALSE;
    }

    RegSize = sizeof(DWORD);

    rVal = RegQueryValueEx(
        hKey,
        REGVAL_FAXINSTALLED,
        0,
        &RegType,
        (LPBYTE) Installed,
        &RegSize
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not query installed registry value, ec=0x%08x"), rVal ));
        *Installed = 0;
    }

    rVal = RegQueryValueEx(
        hKey,
        REGVAL_FAXINSTALL_TYPE,
        0,
        &RegType,
        (LPBYTE) InstallType,
        &RegSize
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not query install type registry value, ec=0x%08x"), rVal ));
        *InstallType = 0;
    }

    rVal = RegQueryValueEx(
        hKey,
        REGVAL_FAXINSTALLED_PLATFORMS,
        0,
        &RegType,
        (LPBYTE) InstalledPlatforms,
        &RegSize
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not query install platforms mask registry value, ec=0x%08x"), rVal ));
        *InstalledPlatforms = 0;
    }

    RegCloseKey( hKey );

    return TRUE;
}


VOID
ProcessCommandLineArgs(
    LPWSTR CommandLine
    )
{
    LPWSTR *argv;
    int argc;
    int i;
    WCHAR FileName[MAX_PATH*2];
    LPWSTR FnamePart;
    LPWSTR AnswerFile;



    argv = CommandLineToArgvW( CommandLine, &argc );

    for (i=0; i<argc; i++) {
        if (argv[i][0] == L'-' || argv[i][0] == L'/') {
            switch (_totlower(argv[i][1])) {
                case L't':
                    switch (_totlower(argv[i][2])) {
                        case L'w':
                            RequestedSetupType = SETUP_TYPE_WORKSTATION;
                            break;

                        case L's':
                            RequestedSetupType = SETUP_TYPE_SERVER;
                            break;

                        case L'c':
                            RequestedSetupType = SETUP_TYPE_CLIENT;
                            break;

                        case L'a':
                            RequestedSetupType = SETUP_TYPE_REMOTE_ADMIN;
                            break;

                    }
                    break;

                case L'u':

                        if (i+2 > argc) {
                            AnswerFile = L"unattend.txt";
                        } else {
                            AnswerFile = argv[i+1];
                        }

                        GetFullPathName( AnswerFile, sizeof(FileName)/sizeof(WCHAR), FileName, &FnamePart );
                        if (GetFileAttributes( FileName ) == 0xffffffff) {
                            PopUpMsg( NULL, IDS_BAD_UNATTEND, TRUE, 0 );
                            ExitProcess(0);
                        }

                        InstallMode = INSTALL_UNATTENDED;

                        UnattendFileName = StringDup( FileName );
                        break;

                case L'r':
                        InstallMode = INSTALL_REMOVE;
                        if (argv[i][2] == L'u') {
                            InstallMode |= INSTALL_UNATTENDED;
                        }
                        break;

                default:
                    break;
            }
        }
    }
}


LONG
CALLBACK
EulaEditSubProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Edit control subclass routine, to avoid highlighting text when user
    tabs to the edit control.

Arguments:

    Standard window proc arguments.

Returns:

    Message-dependent value.

--*/

{
    //
    // For setsel messages, make start and end the same.
    //
    if ((msg == EM_SETSEL) && ((LPARAM)wParam != lParam)) {
        lParam = wParam;
    }

    return CallWindowProc( OldEditProc, hwnd, msg, wParam, lParam );
}


BOOL
DisplayEula(
    HWND hwnd
    )
{
    HGLOBAL hResource;
    LPSTR   lpResource;
    LPSTR   p;
    BOOL    rVal = FALSE;
    DWORD   FileSize;
    PWSTR   EulaText = NULL;


    hResource = LoadResource(
        FaxWizModuleHandle,
        FindResource( FaxWizModuleHandle, MAKEINTRESOURCE(FAX_EULA), MAKEINTRESOURCE(BINARY) )
        );
    if (!hResource) {
        return FALSE;
    }

    lpResource = (LPSTR) LockResource(
        hResource
        );
    if (!lpResource) {
        FreeResource( hResource );
        return FALSE;
    }

    p = strchr( lpResource, '^' );
    if (!p) {
        //
        // the eula text file is corrupt
        //
        return FALSE;
    }

    FileSize = p - lpResource;

    EulaText = MemAlloc( (FileSize+1) * sizeof(WCHAR) );
    if (EulaText == NULL) {
        goto exit;
    }

    MultiByteToWideChar (
        CP_ACP,
        0,
        lpResource,
        FileSize,
        EulaText,
        (FileSize+1) * sizeof(WCHAR)
        );

    EulaText[FileSize] = 0;

    OldEditProc = (WNDPROC) GetWindowLong( hwnd, GWL_WNDPROC );
    SetWindowLong( hwnd, GWL_WNDPROC, (LONG)EulaEditSubProc );

    SetWindowText( hwnd, EulaText );

    rVal = TRUE;

exit:

    MemFree (EulaText);

    if (lpResource) {
        FreeResource( lpResource );
    }

    return rVal;
}


BOOL
AddWizardPages(
    HWND hwnd,
    DWORD SetupType
    )
{
    LPHPROPSHEETPAGE WizardPageHandles;
    DWORD PageCount;
    DWORD i;


    switch( SetupType ) {
        case SETUP_TYPE_WORKSTATION:
            WizardPageHandles = FaxWizGetWorkstationPages( &PageCount );
            break;

        case SETUP_TYPE_SERVER:
            WizardPageHandles = FaxWizGetServerPages( &PageCount );
            break;

        case SETUP_TYPE_CLIENT:
            WizardPageHandles = FaxWizGetClientPages( &PageCount );
            break;

        case SETUP_TYPE_REMOTE_ADMIN:
            WizardPageHandles = FaxWizRemoteAdminPages( &PageCount );
            break;
    }

    if (!WizardPageHandles) {
        return FALSE;
    }

    for (i=0; i<PageCount; i++) {
        PropSheet_AddPage( hwnd, WizardPageHandles[i] );
    }

    return TRUE;
}


LRESULT
WelcomeDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LPNMHDR NotifyParams;
    static TCHAR NextText[64];
    static TCHAR CancelText[64];


    switch( msg ) {
        case WM_INITDIALOG:
            CenterWindow( GetParent(hwnd), GetDesktopWindow() );
            SetWizPageTitle( hwnd );
            DisplayEula( GetDlgItem( hwnd, IDC_LICENSE_AGREEMENT ) );
            SetFocus( GetDlgItem( GetParent( hwnd ), IDCANCEL ));
            PostMessage( hwnd, WM_NEXTDLGCTL, 1, FALSE );
            GetWindowText( GetDlgItem(GetParent(hwnd), 0x3024), NextText, sizeof(NextText)/sizeof(TCHAR) );
            GetWindowText( GetDlgItem(GetParent(hwnd), IDCANCEL), CancelText, sizeof(NextText)/sizeof(TCHAR) );
            if (!(InstallMode & (INSTALL_REMOVE | INSTALL_UNATTENDED))) {
                SetWindowText( GetDlgItem(GetParent(hwnd), 0x3024), GetString(IDS_AGREE) );
                SetWindowText( GetDlgItem(GetParent(hwnd), IDCANCEL), GetString(IDS_DISAGREE) );
            }
            ShowWindow( GetDlgItem(GetParent(hwnd), 0x3023), SW_HIDE );
            break;

        case WM_NOTIFY:

            NotifyParams = (LPNMHDR) lParam;

            switch(NotifyParams->code) {

                case PSN_SETACTIVE:
                    if (InstallMode) {
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }

                    PropSheet_SetWizButtons( GetParent(hwnd), PSWIZB_NEXT );
                    SetWindowLong( hwnd, DWL_MSGRESULT, 0 );
                    break;

                case PSN_WIZNEXT:
                    SetWindowText( GetDlgItem(GetParent(hwnd), 0x3024), NextText );
                    SetWindowText( GetDlgItem(GetParent(hwnd), IDCANCEL), CancelText );
                    ShowWindow( GetDlgItem(GetParent(hwnd), 0x3023), SW_SHOW );
                    break;

                case PSN_QUERYCANCEL:
                    {
                        DWORD Answer;
                        MessageBeep( MB_ICONEXCLAMATION );
                        Answer = PopUpMsg( hwnd, IDS_QUERY_CANCEL, FALSE, MB_YESNO );
                        if (Answer == IDNO) {
                            SetWindowLong( hwnd, DWL_MSGRESULT, 1 );
                            return TRUE;
                        }
                    }
                    break;

            }
            break;

        default:
            break;
    }

    return FALSE;
}


LRESULT
SetupModeDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LPNMHDR NotifyParams;


    switch( msg ) {
        case WM_INITDIALOG:
            SetWizPageTitle( hwnd );
            break;

        case WM_NOTIFY:

            NotifyParams = (LPNMHDR) lParam;

            switch(NotifyParams->code) {

                case PSN_SETACTIVE:

                    if (RequestedSetupType != SETUP_TYPE_INVALID) {
                        //
                        // the user requested a specific setup type
                        // so this wizard page is not necessary
                        //
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }

                    CheckDlgButton( hwnd, IDC_SERVER_SETUP,      BST_UNCHECKED );
                    CheckDlgButton( hwnd, IDC_CLIENT_SETUP,      BST_UNCHECKED );
                    CheckDlgButton( hwnd, IDC_WORKSTATION_SETUP, BST_UNCHECKED );
                    CheckDlgButton( hwnd, IDC_REMOTE_ADMIN,      BST_UNCHECKED );

                    switch( SetupType ) {
                        case SETUP_TYPE_WORKSTATION:
                            CheckDlgButton( hwnd, IDC_WORKSTATION_SETUP, BST_CHECKED );
                            break;

                        case SETUP_TYPE_SERVER:
                            CheckDlgButton( hwnd, IDC_SERVER_SETUP, BST_CHECKED );
                            break;

                        case SETUP_TYPE_CLIENT:
                            CheckDlgButton( hwnd, IDC_CLIENT_SETUP, BST_CHECKED );
                            break;

                        case SETUP_TYPE_REMOTE_ADMIN:
                            CheckDlgButton( hwnd, IDC_REMOTE_ADMIN, BST_CHECKED );
                            break;
                    }

                    if (ProductType == PRODUCT_TYPE_WINNT) {
                        EnableWindow( GetDlgItem( hwnd, IDC_SERVER_SETUP ), FALSE );
                    }

                    PropSheet_SetWizButtons( GetParent(hwnd), PSWIZB_NEXT );
                    SetWindowLong( hwnd, DWL_MSGRESULT, 0 );
                    break;

                case PSN_WIZNEXT:
                    if (IsDlgButtonChecked( hwnd, IDC_WORKSTATION_SETUP )) {
                        SetupType = SETUP_TYPE_WORKSTATION;
                    } else if (IsDlgButtonChecked( hwnd, IDC_SERVER_SETUP )) {
                        SetupType = SETUP_TYPE_SERVER;
                    } else if (IsDlgButtonChecked( hwnd, IDC_CLIENT_SETUP )) {
                        SetupType = SETUP_TYPE_CLIENT;
                    } else if (IsDlgButtonChecked( hwnd, IDC_REMOTE_ADMIN )) {
                        SetupType = SETUP_TYPE_REMOTE_ADMIN;
                    } else {
                        SetupType = SETUP_TYPE_SERVER;
                    }
                    break;

                case PSN_QUERYCANCEL:
                    {
                        DWORD Answer;
                        MessageBeep(0);
                        Answer = PopUpMsg( hwnd, IDS_QUERY_CANCEL, FALSE, MB_YESNO );
                        if (Answer == IDNO) {
                            SetWindowLong( hwnd, DWL_MSGRESULT, 1 );
                            return TRUE;
                        }
                    }
                    break;
            }
            break;

        default:
            break;
    }

    return FALSE;
}


LRESULT
InstallModeDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch( msg ) {
        case WM_INITDIALOG:
            SetWindowText( GetDlgItem( hwnd, IDC_INSTALLMODE_LABEL01 ), GetString(IDS_INSTALLMODE_LABEL01) );
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    if (InstallMode) {
                        AddWizardPages( GetParent(hwnd), SetupType );
                        FaxWizSetInstallMode( InstallMode, InstallType, UnattendFileName );
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }

                    if (Installed) {

                        //
                        // the user has fax software installed, but we need
                        // to figure out if they have the type installed that
                        // is requested.
                        //

                        BOOL ReallyInstalled = FALSE;
                        switch( RequestedSetupType ) {
                            case SETUP_TYPE_WORKSTATION:
                                if (InstallType & FAX_INSTALL_WORKSTATION) {
                                    ReallyInstalled = TRUE;
                                }
                                break;

                            case SETUP_TYPE_SERVER:
                                if (InstallType & FAX_INSTALL_SERVER) {
                                    ReallyInstalled = TRUE;
                                }
                                break;

                            case SETUP_TYPE_CLIENT:
                            case SETUP_TYPE_POINT_PRINT:
                                if (InstallType & FAX_INSTALL_NETWORK_CLIENT) {
                                    ReallyInstalled = TRUE;
                                }
                                break;

                            case SETUP_TYPE_REMOTE_ADMIN:
                                if (InstallType & FAX_INSTALL_REMOTE_ADMIN) {
                                    ReallyInstalled = TRUE;
                                }
                                break;
                        }

                        if (!ReallyInstalled) {

                            //
                            // the user has requested an install type that
                            // is different from what is installed
                            //

                            InstallMode = INSTALL_NEW;
                            switch( RequestedSetupType ) {
                                case SETUP_TYPE_WORKSTATION:
                                    InstallType = FAX_INSTALL_WORKSTATION;
                                    break;

                                case SETUP_TYPE_SERVER:
                                    InstallType = FAX_INSTALL_SERVER;
                                    break;

                                case SETUP_TYPE_CLIENT:
                                case SETUP_TYPE_POINT_PRINT:
                                    InstallType = FAX_INSTALL_NETWORK_CLIENT;
                                    break;

                                case SETUP_TYPE_REMOTE_ADMIN:
                                    InstallType = FAX_INSTALL_REMOTE_ADMIN;
                                    break;
                            }
                            AddWizardPages( GetParent(hwnd), SetupType );
                            FaxWizSetInstallMode( InstallMode, InstallType, UnattendFileName );
                            SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                            return TRUE;
                        }

                        //
                        // looks like the fax software has already been installed
                        //
                        CheckDlgButton( hwnd, IDC_UPGRADE,         BST_CHECKED   );
                        CheckDlgButton( hwnd, IDC_UNINSTALL,       BST_UNCHECKED );
                        CheckDlgButton( hwnd, IDC_INSTALL_DRIVERS, BST_UNCHECKED );

                        if ((InstallType & FAX_INSTALL_SERVER) == 0) {

                            SetWindowPos( GetDlgItem( hwnd, IDC_INSTALL_DRIVERS ), 0, 0, 0, 0, 0, SWP_HIDEWINDOW );

                        }

                    } else {

                        //
                        // the fax sofware is not installed so there is
                        // no reason to ask the user if the want to upgrade, etc
                        //

                        InstallMode = INSTALL_NEW;
                        switch( RequestedSetupType ) {
                            case SETUP_TYPE_WORKSTATION:
                                InstallType = FAX_INSTALL_WORKSTATION;
                                break;

                            case SETUP_TYPE_SERVER:
                                InstallType = FAX_INSTALL_SERVER;
                                break;

                            case SETUP_TYPE_CLIENT:
                            case SETUP_TYPE_POINT_PRINT:
                                InstallType = FAX_INSTALL_NETWORK_CLIENT;
                                break;

                            case SETUP_TYPE_REMOTE_ADMIN:
                                InstallType = FAX_INSTALL_REMOTE_ADMIN;
                                break;
                        }
                        AddWizardPages( GetParent(hwnd), SetupType );
                        FaxWizSetInstallMode( InstallMode, InstallType, UnattendFileName );
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;

                    }
                    break;

                case PSN_WIZNEXT:
                    if (IsDlgButtonChecked( hwnd, IDC_UNINSTALL )) {
                        InstallMode = INSTALL_REMOVE;
                    } else if (IsDlgButtonChecked( hwnd, IDC_UPGRADE )) {
                        InstallMode = INSTALL_UPGRADE;
                    } else if (IsDlgButtonChecked( hwnd, IDC_INSTALL_DRIVERS )) {
                        InstallMode = INSTALL_DRIVERS;
                    } else {
                        InstallMode = INSTALL_UPGRADE;
                    }
                    AddWizardPages( GetParent(hwnd), SetupType );
                    FaxWizSetInstallMode( InstallMode, InstallType, UnattendFileName );
                    break;
            }
            break;
    }

    return FALSE;
}


int
WINAPI
#ifdef UNICODE
wWinMain(
#else
WinMain(
#endif
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPTSTR    lpCmdLine,
    int       nShowCmd
    )

/*++

Routine Description:

    Main entry point for the Windows NT Fax Setup utility.


Arguments:

    hInstance       - Instance handle
    hPrevInstance   - Not used
    lpCmdLine       - Command line arguments
    nShowCmd        - How to show the window

Return Value:

    Return code, zero for success.

--*/

{
    PROPSHEETHEADER psh;
    LPHPROPSHEETPAGE WizardPageHandles;
    DWORD PageCount;
    DWORD Answer;


    FaxWizModuleHandle = hInstance;

    HeapInitialize(NULL,NULL,NULL,0);

    ProductType = GetProductType();
    GetInstallationInfo( &Installed, &InstallType, &InstalledPlatforms );

    InitializeStringTable();

    ProcessCommandLineArgs( lpCmdLine );

    if (InstallMode & INSTALL_REMOVE) {

        if (InstallType & FAX_INSTALL_WORKSTATION) {
            RequestedSetupType = SETUP_TYPE_WORKSTATION;
        } else if (InstallType & FAX_INSTALL_SERVER) {
            RequestedSetupType = SETUP_TYPE_SERVER;
        } else if (InstallType & FAX_INSTALL_NETWORK_CLIENT) {
            RequestedSetupType = SETUP_TYPE_CLIENT;
        }

        SetTitlesInStringTable();

        if (!Installed) {
            //
            // how can we uninstall something that was never installed?
            //
            if (!(InstallMode & INSTALL_UNATTENDED)) {
                PopUpMsg( NULL, IDS_NOT_INSTALLED, TRUE, 0 );
            }
            ExitProcess(0);
        }

        if (InstallMode & INSTALL_UNATTENDED) {
            Answer = IDYES;
        } else {
            Answer = PopUpMsg( NULL, IDS_QUERY_UNINSTALL, FALSE, MB_YESNO );
        }

        if ( Answer == IDNO ){
            ExitProcess(0);
        }
    }

    if (!IsUserAdmin()) {
        PopUpMsg( NULL, IDS_MUST_BE_ADMIN, TRUE, 0 );
        return 0;
    }

    //
    // initialize the wizards
    //

    if (!FaxWizInit()) {
        return FALSE;
    }

    SetupType = SETUP_TYPE_WORKSTATION;
    RequestedSetupType = SETUP_TYPE_WORKSTATION;

    WizardPageHandles = CreateWizardPages( hInstance, SetupWizardPages, FaxSetupWizardPages, &PageCount );
    if (!WizardPageHandles) {
        return FALSE;
    }

    //
    // create the property sheet
    //

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_WIZARD | PSH_USECALLBACK;
    psh.hwndParent = NULL;
    psh.hInstance = hInstance;
    psh.pszIcon = NULL;
    psh.pszCaption = TEXT("FAX Installation Wizard");
    psh.nPages = PageCount;
    psh.nStartPage = 0;
    psh.phpage = WizardPageHandles;
    psh.pfnCallback = FaxWizGetPropertySheetCallback();

    PropertySheet( &psh );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\awdlib\awdlib.c ===
/*++
Copyright (c) 1997  Microsoft Corporation

awd library

Routines for reading from an AWD file.

Author:
  Brian Dewey (t-briand) 1997-7-2
--*/

#include <stdio.h>
#include <stdlib.h>
#include <ole2.h>		// AWD is an OLE compound document.
#include <assert.h>

#include "awdlib.h"		// Header file for this library.

// ------------------------------------------------------------
// Auxiliary routines

// OpenAWDFile
//
// Opens an AWD file and fills in the psStorages structure.
//
// Parameters:
//	pwcsFilename		name of file to open (UNICODE)
//	psStorages		Pointer to structure that will hold
//				the major storages used in an AWD file.
//
// Returns:
//	TRUE on success, FALSE on failure.  One or more storages may be
//	NULL even when the routine returns TRUE.  The client needs to
//	check for this.
//
// Author:
//	Brian Dewey (t-briand)  1997-6-30
BOOL
OpenAWDFile(const WCHAR *pwcsFilename, AWD_FILE *psStorages)
{
    HRESULT hStatus;		// Status indicator for reporting errors.
    IStorage *psStorage;	// Pointer to the storage.

    hStatus = StgOpenStorage(pwcsFilename,
			     NULL,
			     STGM_READ | STGM_SHARE_EXCLUSIVE,
			     NULL,
			     0,
			     &psStorages->psAWDFile);
    if(FAILED(hStatus)) {
	return FALSE;
    }
	// If we get here, we've succeeded.  Now open the related storages.
    psStorages->psDocuments = OpenAWDSubStorage(psStorages->psAWDFile,
						L"Documents");
    psStorages->psPersistInfo = OpenAWDSubStorage(psStorages->psAWDFile,
						  L"Persistent Information");
    psStorages->psDocInfo = OpenAWDSubStorage(psStorages->psPersistInfo,
					      L"Document Information");
    psStorages->psPageInfo = OpenAWDSubStorage(psStorages->psPersistInfo,
					       L"Page Information");
    psStorages->psGlobalInfo = OpenAWDSubStorage(psStorages->psPersistInfo,
						 L"Global Information");
    return TRUE;
}

// CloseAWDFile
//
// Closes an AWD file.
//
// Parameters:
//	psStorages		Pointer to the AWD file.
//	
// Returns:
// 	TRUE on success, FALSE otherwise.
//
// Author:
//	Brian Dewey (t-briand)  1997-6-27
BOOL
CloseAWDFile(AWD_FILE *psStorages)
{
	// This should probably use some exception mechanism.
    BOOL success = TRUE;
    if(FAILED(psStorages->psGlobalInfo->lpVtbl->Release(psStorages->psGlobalInfo))) {
	success = FALSE;
    }
    if(FAILED(psStorages->psPageInfo->lpVtbl->Release(psStorages->psPageInfo))) {
	success = FALSE;
    }
    if(FAILED(psStorages->psDocInfo->lpVtbl->Release(psStorages->psDocInfo))) {
	success = FALSE;
    }
    if(FAILED(psStorages->psPersistInfo->lpVtbl->Release(psStorages->psPersistInfo))) {
	success = FALSE;
    }
    if(FAILED(psStorages->psDocuments->lpVtbl->Release(psStorages->psDocuments))) {
	success = FALSE;
    }
    if(FAILED(psStorages->psAWDFile->lpVtbl->Release(psStorages->psAWDFile))) {
	success = FALSE;
    }
    return success;
}

// OpenAWDSubStorage
//
// Get a substorage from a parent storage.  Checks for errors
// and exits on error conditions.  Note that it's not an error if
// the substorage doesn't exist, so the caller should still check for NULL.
//
// Parameters:
//	psParent		Pointer to the parent storage.
//	pwcsStorageName		Name of the substorage (UNICODE).
//
// Returns:
//	A pointer to the substorage, or NULL if the substorage doesn't exist.
//
// Author:
//	Brian Dewey (t-briand)  1997-6-27
IStorage *
OpenAWDSubStorage(IStorage *psParent, const WCHAR *pwcsStorageName)
{
    IStorage *psSubStorage;	    // The substorage.
    HRESULT hStatus;		    // Status of the call.

    if(psParent == NULL) return NULL;
    hStatus = psParent->lpVtbl->OpenStorage(psParent,
					    pwcsStorageName,
					    NULL,
					    STGM_READ | STGM_SHARE_EXCLUSIVE,
					    NULL,
					    0,
					    &psSubStorage);
    if(FAILED(hStatus)) {
	if(hStatus == STG_E_FILENOTFOUND) {
	    fwprintf(stderr, L"OpenAWDSubStorage:No such substorage '%s'.\n",
		     pwcsStorageName);
	    return NULL;
	}
	    // use the wide-printf() to get the UNICODE filename.
	fwprintf(stderr, L"OpenAWDSubStorage:Unable to open substorage %s.\n",
		pwcsStorageName);
	exit(1);
    }
    return psSubStorage;
}

// OpenAWDStream
//
// This function opens an AWD stream for exclusive read access.  It
// checks for errors and exits on an error condition.  Not found is
// not considered a fatal error.
//
// Parameters:
// 	psStorage		Pointer to the storage holding the stream.
//	pwcsStreamName		Name of the stream (UNICODE).
//
// Returns:
// 	A pointer to the stream.  If no such stream exists, returns NULL.
// 	It will abort on any other error.
//
// Author:
// 	Brian Dewey (t-briand)	1997-6-27
IStream *
OpenAWDStream(IStorage *psStorage, const WCHAR *pwcsStreamName)
{
    HRESULT hStatus;
    IStream *psStream;

    assert(psStorage != NULL);		    // Sanity check.
    fwprintf(stderr, L"OpenAWDStream:Opening stream '%s'.\n", pwcsStreamName);
    hStatus = psStorage->lpVtbl->OpenStream(psStorage,
					    pwcsStreamName,
					    NULL,
					    STGM_READ | STGM_SHARE_EXCLUSIVE,
					    0,
					    &psStream);
    if(FAILED(hStatus)) {
	if(hStatus == STG_E_FILENOTFOUND) return NULL;
	fwprintf(stderr, L"OpenAWDStream:Error %x when opening stream %s.\n",
		 hStatus, pwcsStreamName);
	exit(1);
    }
    return psStream;
}

// AWDViewed
//
// This function tests if the AWD file has previously been viewed by
// a viewer.  It does this by checking for the presence of a stream
// called "BeenViewed."  See AWD specs.
//
// Parameters:
//	psStorage		Pointer to the "Persistent Information"
//				substorage.
//
// Returns:
//	TRUE if the file has been viewed, FALSE otherwise.
//
// Author:
//	Brian Dewey (t-briand)  1997-6-27
BOOL
AWDViewed(AWD_FILE *psStorages)
{
    IStream *psStream;		    // Pointer to the been-viewed stream.
    HRESULT hStatus;		    // Holds the status of the call.

	// Attempt to open the BeenViewed stream.
    hStatus = psStorages->psPersistInfo->lpVtbl->OpenStream(psStorages->psPersistInfo,
					    L"BeenViewed",
					    NULL,
					    STGM_READ | STGM_SHARE_EXCLUSIVE,
					    0,
					    &psStream);
	// If succeeded, then definately found.
    if(SUCCEEDED(hStatus)) return TRUE;
	// If not found, then definately hasn't been viewed.
    if(hStatus == STG_E_FILENOTFOUND) return FALSE;
    fprintf(stderr, "AWDViewed:Unexpected status %x.\n", hStatus);
	// Assume that we've been viewed.
    return TRUE;
}

// DumpAWDDocuments
//
// This function prints out the name of the fax documents contained in the
// file in their display order.  Output is to stdout.
//
// New AWD files have a "Display Order" stream in the psGlobalInfo that defines
// all of the documents.  Old AWD files need to enumerate through the
// "Documents" substorage.  
//
// Parameters:
//	psStorages		Pointer to the storages of an AWD file.
//
// Returns:
//	Nothing.
//
// Author:
//	Brian Dewey (t-briand)	1997-6-27
void
DumpAWDDocuments(AWD_FILE *psStorages)
{
    printf("Document list:\n");
    printf("-------- -----\n");
    EnumDocuments(psStorages, DisplayDocNames);

}

// EnumDocuments
//
// This function enumerates through all of the things in the "Documents"
// substorage and prints their names.  It's a helper routine to DumpAWDDocuments().
//
// Parameters:
//	psStorages			Pointer to the storages in the AWD file.
//	pfnDocProc			Pointer to function that should be called
//					with the names of the documents in the
//					AWD file.
//
// Returns:
//	TRUE if all iterations succeeded, FALSE otherwise.
//
// Author:
// 	Brian Dewey (t-briand)  1997-6-30
BOOL
EnumDocuments(AWD_FILE *psStorages, AWD_DOC_PROCESSOR pfnDocProc)
{
    IEnumSTATSTG *psEnum;
    STATSTG      sData;
    WCHAR        awcNameBuf[MAX_AWD_NAME]; // 32 == longest possible name.
    UINT         uiNameOffset;
    IStream      *psDisplayOrder;	   // Points to the display order stream.
    char         chData;		   // A single byte of data.
    ULONG        cbRead;		   // Count of bytes read.

    assert(psGlobalInfo != NULL);   // Sanity check.
    psDisplayOrder = OpenAWDStream(psStorages->psGlobalInfo, L"Display Order");
    if(psDisplayOrder == NULL) {
	fprintf(stderr, "There is no 'Display Order' stream.  This is an old AWD file.\n");
	if(FAILED(psStorages->psDocuments->lpVtbl->EnumElements(psStorages->psDocuments,
								0,
								NULL,
								0,
								&psEnum))) {
	    return FALSE;
	}
	sData.pwcsName = awcNameBuf;
	
	while(psEnum->lpVtbl->Next(psEnum, 1, &sData, NULL) == S_OK) {
		// We succeeded!
	    if(!(*pfnDocProc)(psStorages, sData.pwcsName))
		return FALSE;	// The enumeration has been aborted.
	}
	psEnum->lpVtbl->Release(psEnum);
	return TRUE;
    }

	// The display order list is a stream of document names.  Each
	// name is null-terminated, and a second null ends the stream.
	// The document names are ANSI characters.
	//
	// The easy way to read this, which is what I do, is to read
	// the stream a byte at a time.  For efficiency, this should be
	// changed to reading larger blocks.

	// Prime the loop by reading the first character.
    psDisplayOrder->lpVtbl->Read(psDisplayOrder, &chData, 1, &cbRead);
    while(chData) {		    // Until I've read a null...
	    // This inner loop prints out a single string.
	uiNameOffset = 0;
	while(chData) {
	    awcNameBuf[uiNameOffset++] = chData;
	    psDisplayOrder->lpVtbl->Read(psDisplayOrder, &chData, 1, &cbRead);
	};
	awcNameBuf[uiNameOffset] = 0;
	    // We've now read & printed a whole string.  Call the enumerator.
	if(!(*pfnDocProc)(psStorages, awcNameBuf)) {
	    psDisplayOrder->lpVtbl->Release(psDisplayOrder);
	    return FALSE;	// The enumeration has been aborted.
	}
	    // And re-prime the engine.
	psDisplayOrder->lpVtbl->Read(psDisplayOrder, &chData, 1, &cbRead);
    }

    psDisplayOrder->lpVtbl->Release(psDisplayOrder);
    return TRUE;
}

// DisplayDocNames
//
// This is a simple little routine that prints out the names of all of the
// documents in an AWD file.  Used in conjunction w/ EnumDocuments.
//
// Parameters:
//	psStorages			Pointer to the storages in the AWD file.
//	pwcsDocName			Name of a document (UNICODE).
//
// Returns:
//	TRUE.
//
// Author:
//	Brian Dewey (t-briand)	1997-6-30
BOOL
DisplayDocNames(AWD_FILE *psStorages, const WCHAR *pwcsDocName)
{
    wprintf(L"Document '%s'.\n", pwcsDocName);
    return TRUE;
}

// DetailedDocDump
//
// This function displays lots of information about a particular document.
//
// Parameters:
//	psStorages			Pointer to the storages in the AWD file.
//	pwcsDocName			Name of a document (UNICODE).
//
// Returns:
//	TRUE on success; FALSE on error.
//
// Author:
//	Brian Dewey (t-briand)	1997-6-30
BOOL
DetailedDocDump(AWD_FILE *psStorages, const WCHAR *pwcsDocName)
{
    IStream *psDocInfoStream;		    // Stream containing doc information.
    DOCUMENT_INFORMATION sDocInfo;	    // Document information.
    ULONG cbRead;			    // Count of bytes read.
    
    wprintf(L"Information for document '%s' --\n", pwcsDocName);
    psDocInfoStream = OpenAWDStream(psStorages->psDocInfo,
				    pwcsDocName);
    if(psDocInfoStream == NULL) {
	fprintf(stderr, "DetailedDocDump:No document info stream.\n");
	    // This is not a fatal error, so don't exit.
    } else {
	psDocInfoStream->lpVtbl->Read(psDocInfoStream,
				      &sDocInfo,
				      sizeof(sDocInfo),
				      &cbRead);
	if(sizeof(sDocInfo) != cbRead) {
	    fwprintf(stderr, L"DetailedDocDump:Error reading document information "
		     L"for %s.\n", pwcsDocName);
	} else {
	    printf("\tDocument signature = %x.\n", sDocInfo.Signature);
	    printf("\tDocument version = %x.\n", sDocInfo.Version);
	}
    }
    PrintPageInfo(&sDocInfo.PageInformation);
    return TRUE;
}

// PrintPageInfo
//
// This function displays the fields of a PAGE_INFORMATION structure to standard
// output.
//
// Parameters:
//	psPageInfo			The PAGE_INFORMATION structure to display.
//
// Returns:
//	nothing.
//
// Author:
//	Brian Dewey (t-briand)	1997-6-30

void
PrintPageInfo(PAGE_INFORMATION *psPageInfo)
{
    printf("\tStructure signature = %x\n", psPageInfo->Signature);
    printf("\tStructure version   = %x\n", psPageInfo->Version);

    if(psPageInfo->awdFlags & AWD_FIT_WIDTH)
	printf("\tAWD_FIT_WIDTH flag is set.\n");
    if(psPageInfo->awdFlags & AWD_FIT_HEIGHT)
	printf("\tAWD_FIT_HEIGHT flag is set.\n");
    if(psPageInfo->awdFlags & AWD_INVERT)
	printf("\tAWD_INVERT flag is set.\n");
    if(psPageInfo->awdFlags & AWD_IGNORE)
	printf("\tAWD_IGNORE flag is set.\n");

    printf("\tRotation = %d degrees counterclockwise.\n", psPageInfo->Rotation);
    printf("\tScaleX = %d.\n", psPageInfo->ScaleX);
    printf("\tScaleY = %d.\n", psPageInfo->ScaleY);
}

// DumpData
//
// A simple utility function that will write the specified data to a file
// for post-mortem examining.
//
// Parameters
//	pszFileName		Name of the output file.
//	pbData			Pointer to the data.
//	cbCount			Number of bytes to write.
//
// Returns:
//	nothing.
//
// Author:
//	Brian Dewey (t-briand)	1997-7-7
void
DumpData(LPTSTR pszFileName, LPBYTE pbData, DWORD cbCount)
{
    HANDLE hFile;
    DWORD  cbWritten;

    hFile = CreateFile(
	pszFileName,		// Open this file...
	GENERIC_WRITE,		// We want to write.
	0,			// Don't share.
	NULL,			// No need to inherit.
	CREATE_ALWAYS,		// Always create a new file.
	FILE_ATTRIBUTE_COMPRESSED, // Save disk space... might want to change this later.
	NULL);			// No template file.
    if(hFile != INVALID_HANDLE_VALUE) {
	WriteFile(hFile,
		  pbData,
		  cbCount,
		  &cbWritten,
		  NULL);
	CloseHandle(hFile);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ocm\wizard.cpp ===
#include "faxocm.h"
#pragma hdrstop



typedef enum {
    WizPageWelcome,
    WizPageEula,
    WizPageFinal,
    WizPageMaximum
} WizPage;


WIZPAGE SetupWizardPages[WizPageMaximum] =
{
    { PSWIZB_NEXT,             WizPageWelcome,  IDD_WELCOME,  WelcomeDlgProc,  0,               0                 },
    { PSWIZB_NEXT|PSWIZB_BACK, WizPageEula,     IDD_EULA,     EulaDlgProc,     IDS_EULA_TITLE,  IDS_EULA_SUBTITLE },
    { PSWIZB_FINISH,           WizPageFinal,    IDD_FINAL,    FinalDlgProc,    0,               0                 }
};





HPROPSHEETPAGE
CreateWizardPage(
    PWIZPAGE WizPage
    )
{
    WCHAR TitleBuffer[256];
    PROPSHEETPAGE WizardPage;


    WizardPage.dwSize             = sizeof(PROPSHEETPAGE);
    if (WizPage->Title == 0) {
        WizardPage.dwFlags        = PSP_DEFAULT | PSP_HIDEHEADER;
    } else {
        WizardPage.dwFlags        = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    }
    WizardPage.hInstance          = hInstance;
    WizardPage.pszTemplate        = MAKEINTRESOURCE(WizPage->DlgId);
    WizardPage.pszIcon            = NULL;
    WizardPage.pszTitle           = NULL;
    WizardPage.pfnDlgProc         = CommonDlgProc;
    WizardPage.lParam             = (LPARAM) WizPage;
    WizardPage.pfnCallback        = NULL;
    WizardPage.pcRefParent        = NULL;
    WizardPage.pszHeaderTitle     = NULL;
    WizardPage.pszHeaderSubTitle  = NULL;

    if (WizPage->Title) {
        if (LoadString(
                hInstance,
                WizPage->Title,
                TitleBuffer,
                sizeof(TitleBuffer)/sizeof(WCHAR)
                ))
        {
            WizardPage.pszHeaderTitle = _wcsdup( TitleBuffer );
        }
    }

    if (WizPage->SubTitle) {
        if (LoadString(
                hInstance,
                WizPage->SubTitle,
                TitleBuffer,
                sizeof(TitleBuffer)/sizeof(WCHAR)
                ))
        {
            WizardPage.pszHeaderSubTitle = _wcsdup( TitleBuffer );
        }
    }

    return CreatePropertySheetPage( &WizardPage );
}


HPROPSHEETPAGE
GetWelcomeWizardPage(
    VOID
    )
{
    return CreateWizardPage( &SetupWizardPages[0] );
}


HPROPSHEETPAGE
GetEulaWizardPage(
    VOID
    )
{
    return CreateWizardPage( &SetupWizardPages[1] );
}


HPROPSHEETPAGE
GetFinalWizardPage(
    VOID
    )
{
    return CreateWizardPage( &SetupWizardPages[2] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\ptrtest\ptrtest.c ===
#include <windows.h>
#include <winspool.h>
#include <stdio.h>
#include <tchar.h>

BYTE Buffer[4096*4];


int _cdecl
wmain(
    int argc,
    WCHAR *argv[]
    )
{
    DWORD cb;
    DWORD cnt;
    DWORD i;
    PPRINTER_INFO_1 PrinterInfo = (PPRINTER_INFO_1) Buffer;
    PDRIVER_INFO_2 DriverInfo = (PDRIVER_INFO_2) Buffer;
    PPRINTPROCESSOR_INFO_1 ProcessorInfo = (PPRINTPROCESSOR_INFO_1) Buffer;
    PMONITOR_INFO_2 MonitorInfo = (PMONITOR_INFO_2) Buffer;
    PPORT_INFO_2 PortInfo = (PPORT_INFO_2) Buffer;




    if (argc >= 3) {
        if (argv[1][0] == L'-' && argv[1][1] == L'd' && argv[1][2] == L'd') {
            if (!DeletePrinterDriver( NULL, NULL, argv[2] )) {
                _tprintf( TEXT("DeletePrinterDriver() failed, ec=%d\n"), GetLastError() );
            }
            return 0;
        }
        if (argv[1][0] == L'-' && argv[1][1] == L'd' && argv[1][2] == L'p') {
            HANDLE hPrinter;
            PRINTER_DEFAULTS PrinterDefaults;
            PrinterDefaults.pDatatype = NULL;
            PrinterDefaults.pDevMode = NULL;
            PrinterDefaults.DesiredAccess = PRINTER_ALL_ACCESS;
            OpenPrinter( argv[2], &hPrinter, &PrinterDefaults );
            DeletePrinter( hPrinter );
            ClosePrinter( hPrinter );
            return 0;
        }
        if (argv[1][0] == L'-' && argv[1][1] == L'd' && argv[1][2] == L'c') {
            DeletePrinterConnection( argv[2] );
            Sleep(3000);
            return 0;
        }
        if (argv[1][0] == L'-' && argv[1][1] == L'd' && argv[1][2] == L'm') {
            DeleteMonitor( NULL, NULL, argv[2] );
            return 0;
        }
        if (argv[1][0] == L'-' && argv[1][1] == L'a' && argv[1][2] == L'm') {
            MONITOR_INFO_2 MonitorInfo;
            MonitorInfo.pName = argv[2];
            MonitorInfo.pEnvironment = NULL;
            MonitorInfo.pDLLName = argv[3];
            AddMonitor( NULL, 2, (LPBYTE) &MonitorInfo );
            return 0;
        }
    }

    if (!EnumPrinters( PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS, NULL, 1, Buffer, sizeof(Buffer), &cb, &cnt )) {
        _tprintf( TEXT("EnumPrinters() failed, ec=0x%08x\n"), GetLastError() );
        return -1;
    }

    if (cnt) {
        _tprintf( TEXT("\nPrinters:\n") );
        for (i=0; i<cnt; i++) {
            _tprintf( TEXT("   %s\n"), PrinterInfo[i].pName );
        }
    }

    if (!EnumPrintProcessors( NULL, NULL, 1, Buffer, sizeof(Buffer), &cb, &cnt )) {
        _tprintf( TEXT("EnumPrintProcessors() failed, ec=0x%08x\n"), GetLastError() );
        return -1;
    }

    if (cnt) {
        _tprintf( TEXT("\nPrint Processors:\n") );
        for (i=0; i<cnt; i++) {
            _tprintf( TEXT("   %s\n"), ProcessorInfo[i].pName );
        }
    }

    if (!EnumPrinterDrivers( NULL, NULL, 2, Buffer, sizeof(Buffer), &cb, &cnt )) {
        _tprintf( TEXT("EnumPrinterDrivers() failed, ec=0x%08x\n"), GetLastError() );
        return -1;
    }

    if (cnt) {
        _tprintf( TEXT("\nDrivers:\n") );
        for (i=0; i<cnt; i++) {
            _tprintf( TEXT("   %s\n"), DriverInfo[i].pName );
            _tprintf( TEXT("     Files: %s\n            %s\n            %s\n"),
                DriverInfo[i].pDriverPath,
                DriverInfo[i].pDataFile,
                DriverInfo[i].pConfigFile
                );
        }
    }

    if (!EnumMonitors( NULL, 2, Buffer, sizeof(Buffer), &cb, &cnt )) {
        _tprintf( TEXT("EnumMonitors() failed, ec=0x%08x\n"), GetLastError() );
        return -1;
    }

    if (cnt) {
        _tprintf( TEXT("\nMonitors:\n") );
        for (i=0; i<cnt; i++) {
            _tprintf( TEXT("   %s\n"), MonitorInfo[i].pName );
            _tprintf( TEXT("     Files: %s\n"), MonitorInfo[i].pDLLName );
        }
    }


    if (!EnumPorts( NULL, 2, Buffer, sizeof(Buffer), &cb, &cnt )) {
        _tprintf( TEXT("EnumPorts() failed, ec=0x%08x\n"), GetLastError() );
        return -1;
    }

    if (cnt) {
        _tprintf( TEXT("\nPorts:\n") );
        for (i=0; i<cnt; i++) {
            _tprintf( TEXT("   %s\n"), PortInfo[i].pPortName );
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\awdlib\awd_tiff.c ===
/*++
  Copyright (c) 1997  Microsoft Corporation

  This file contains the parts of the AWD library that are also TIFF-aware
  (i.e., conversion routines).

  Author:
  Brian Dewey (t-briand)  1997-7-16
--*/

#include <stdio.h>
#include <stdlib.h>
#include <ole2.h>		// AWD is an OLE compound document.
#include <assert.h>

#include "awdlib.h"		// Header file for this library.
#include "viewrend.h"		// AWD rendering library.
#include "tifflibp.h"		// Need this for the stolen compression routines.

// ------------------------------------------------------------
// Defines
#define FAX_IMAGE_WIDTH		(1728)

// ------------------------------------------------------------
// Global variables
HANDLE hTiffDest;		// Used in the internal OutputPage()
				// and ConvertAWDToTiff().

// ------------------------------------------------------------
// Internal prototypes
BOOL
CompressBitmapStrip(
    PBYTE               pBrandBits,
    LPDWORD             pMmrBrandBits,
    INT                 BrandHeight,
    INT                 BrandWidth,
    DWORD              *DwordsOut,
    DWORD              *BitsOut
    );				// Routine stolen from tiff library.
				// Used to be EncodeMmrBranding().

void
ConvertWidth(const LPBYTE lpSrc, DWORD dwSrcWidth,
	     LPBYTE lpDest, DWORD dwDestWidth,
	     DWORD dwHeight);

BOOL OutputPage(AWD_FILE *psStorages, const WCHAR *pwcsDocName);

// ------------------------------------------------------------
// Routines

// ConvertAWDToTiff
//
// This function does exactly what it says.  Given the name of an AWD file, it
// attempts to convert it to a tiff file.
//
// Parameters:
//	pwcsAwdFile		name of the AWD file.
//	pwcsTiffFile		name of the TIFF file.
//
// Returns:
//	TRUE on successful conversion, FALSE otherwise.
//
// Author:
//	Brian Dewey (t-briand)	1997-7-14
BOOL
ConvertAWDToTiff(const WCHAR *pwcsAwdFile, WCHAR *pwcsTiffFile)
{
    BOOL bRetVal;		// Holds our return value.
    AWD_FILE sAWDStorages;	// Holds the main storages of the AWD file.
    
	// Initialization.
    HeapInitialize(NULL, NULL, NULL, 0);
    FaxTiffInitialize();

	// Open the source.
    if(!OpenAWDFile(pwcsAwdFile, &sAWDStorages)) {
	return FALSE;		
    }

	// Open the destination
    hTiffDest = TiffCreate(pwcsTiffFile,
			   TIFF_COMPRESSION_MMR,
			   FAX_IMAGE_WIDTH,
			   2,	// Fill order 2 == LSB2MSB (I think).
			   1);	// HIRES
    if(hTiffDest == NULL) {
	CloseAWDFile(&sAWDStorages);
	return FALSE;
    }
    bRetVal = EnumDocuments(&sAWDStorages, OutputPage);
    CloseAWDFile(&sAWDStorages);
    TiffClose(hTiffDest);
    return bRetVal;
}

// CompressBitmapStrip
//
// Stolen from Tiff library, where it's called EncodeMmrBranding().
//
// Author: ???
BOOL
CompressBitmapStrip(
    PBYTE               pBrandBits,
    LPDWORD             pMmrBrandBits,
    INT                 BrandHeight,
    INT                 BrandWidth,
    DWORD              *DwordsOut,
    DWORD              *BitsOut
    )

/*++

Routine Description:

   Encode an MMR branding from uncompressed branding bits.
   I don't have enough time to write an optimized
   Uncompressed -> MMR convertor, so the compromise is
   to use the existing Uncompressed Decoder (fast enough)
   and use the optimized MMR Encoder.
   Since we only convert few lines for Branding, it's OK.

--*/

{
    INT         a0, a1, a2, b1, b2, distance;
    LPBYTE      prefline;
    BYTE        pZeroline[1728/8];
    INT         delta = BrandWidth / BYTEBITS;
    INT         Lines = 0;
    LPDWORD     lpdwOut = pMmrBrandBits;
    BYTE        BitOut = 0;



#if TIFFDBG
    _tprintf( TEXT("encoding line #%d\n"), TiffInstance->Lines );
#endif


    // set first all white reference line

    prefline = pZeroline;

    ZeroMemory(pZeroline, BrandWidth/8);

    // loop til all lines done

    do {

        a0 = 0;
        a1 = GetBit( pBrandBits, 0) ? 0 : NextChangingElement(pBrandBits, 0, BrandWidth, 0 );
        b1 = GetBit( prefline, 0) ? 0 : NextChangingElement(prefline, 0, BrandWidth, 0 );

        while (TRUE) {

            b2 = (b1 >= BrandWidth) ? BrandWidth :
                    NextChangingElement( prefline, b1, BrandWidth, GetBit(prefline, b1 ));

            if (b2 < a1) {

                //
                // Pass mode
                //

                //OutputBits( TiffInstance, PASSCODE_LENGTH, PASSCODE );
                (*lpdwOut) += ( ((DWORD) (PASSCODE_REVERSED)) << BitOut);
                if ( (BitOut = BitOut + PASSCODE_LENGTH ) > 31 ) {
                    BitOut -= 32;
                    *(++lpdwOut) = ( (DWORD) (PASSCODE_REVERSED) ) >> (PASSCODE_LENGTH - BitOut);
                }


#if TIFFDBG
                PrintRunInfo( 1, 0, PASSCODE_LENGTH, PASSCODE );
                _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif
                a0 = b2;

            } else if ((distance = a1 - b1) <= 3 && distance >= -3) {

                //
                // Vertical mode
                //

                // OutputBits( TiffInstance, VertCodes[distance+3].length, VertCodes[distance+3].code );
                (*lpdwOut) += ( ( (DWORD) VertCodesReversed[distance+3].code) << BitOut);
                if ( (BitOut = BitOut + VertCodesReversed[distance+3].length ) > 31 ) {
                    BitOut -= 32;
                    *(++lpdwOut) = ( (DWORD) (VertCodesReversed[distance+3].code) ) >> (VertCodesReversed[distance+3].length - BitOut);
                }

#if TIFFDBG
                PrintRunInfo( 2, a1-a0, VertCodes[distance+3].length, VertCodes[distance+3].code );
                _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif
                a0 = a1;

            } else {

                //
                // Horizontal mode
                //

                a2 = (a1 >= BrandWidth) ? BrandWidth :
                        NextChangingElement( pBrandBits, a1, BrandWidth, GetBit( pBrandBits, a1 ) );

                // OutputBits( TiffInstance, HORZCODE_LENGTH, HORZCODE );
                (*lpdwOut) += ( ((DWORD) (HORZCODE_REVERSED)) << BitOut);
                if ( (BitOut = BitOut + HORZCODE_LENGTH ) > 31 ) {
                    BitOut -= 32;
                    *(++lpdwOut) = ( (DWORD) (HORZCODE_REVERSED) ) >> (HORZCODE_LENGTH - BitOut);
                }



#if TIFFDBG
                PrintRunInfo( 3, 0, HORZCODE_LENGTH, HORZCODE );
                _tprintf( TEXT("\t\ta0=%d, a1=%d, a2=%d, b1=%d, b2=%d\n"), a0, a1, a2, b1, b2 );
#endif

                if (a1 != 0 && GetBit( pBrandBits, a0 )) {

                    //OutputRun( TiffInstance, a1-a0, BlackRunCodes );
                    //OutputRun( TiffInstance, a2-a1, WhiteRunCodes );
                    OutputRunFastReversed(a1-a0, BLACK, &lpdwOut, &BitOut);
                    OutputRunFastReversed(a2-a1, WHITE, &lpdwOut, &BitOut);

                } else {

                    //OutputRun( TiffInstance, a1-a0, WhiteRunCodes );
                    //OutputRun( TiffInstance, a2-a1, BlackRunCodes );
                    OutputRunFastReversed(a1-a0, WHITE, &lpdwOut, &BitOut);
                    OutputRunFastReversed(a2-a1, BLACK, &lpdwOut, &BitOut);

                }

                a0 = a2;
            }

            if (a0 >= BrandWidth) {
                Lines++;
                break;
            }

            a1 = NextChangingElement( pBrandBits, a0, BrandWidth, GetBit( pBrandBits, a0 ) );
            b1 = NextChangingElement( prefline, a0, BrandWidth, !GetBit( pBrandBits, a0 ) );
            b1 = NextChangingElement( prefline, b1, BrandWidth, GetBit( pBrandBits, a0 ) );
        }

        prefline = pBrandBits;
        pBrandBits += (BrandWidth / 8);

    } while (Lines < BrandHeight);

    *DwordsOut = (DWORD)(lpdwOut - pMmrBrandBits);
    *BitsOut  = BitOut;

    return TRUE;
}

// ConvertWidth
//
// Changes the width of a bitmap.  If the desired width is smaller than the current
// width, this is accomplished by truncating lines.  If the desired width is greater
// than the current width, data will be copied up from the next line.
//
// Parameters:
//	lpSrc			Bitmap source.
//	dwSrcWidth		Its width.
//	lpDest			Pointer to destination.
//	dwDestWidth		Desired width of destination
//	dwHeight		Height of image (won't change).
//
// Returns:
//	nothing.
//
// Author:
//	Brian Dewey (t-briand)	1997-7-10
void
ConvertWidth(const LPBYTE lpSrc, DWORD dwSrcWidth,
	     LPBYTE lpDest, DWORD dwDestWidth,
	     DWORD dwHeight)
{
    LPBYTE lpSrcCur, lpDestCur;
    DWORD  dwCurLine;

    for(lpSrcCur = lpSrc, lpDestCur = lpDest, dwCurLine = 0;
	dwCurLine < dwHeight;
	lpSrcCur += dwSrcWidth, lpDestCur += dwDestWidth, dwCurLine++) {
	memcpy(lpDestCur, lpSrcCur, dwDestWidth);
    }
}

// OutputPage
//
// This is the core of the converter; it takes a single AWD page and writes it
// to the TIFF file.
//
// Parameters:
//	psStorages		Pointer to the AWD file from which we read.
//	pwcsDocName		Name of the page.
//
// Returns:
//	TRUE on success, FALSE on failure.
//
// Author:
//	Brian Dewey (t-briand)  1997-7-2
BOOL
OutputPage(AWD_FILE *psStorages, const WCHAR *pwcsDocName)
{
    BITMAP bmBand;		// A band of image data.
    LPBYTE lpOutBuf;		// Output bitmap (resized).
    LPBYTE lpOutCur;		// Used to write one line at a time.
    LPDWORD lpdwOutCompressed;	// Compressed output.
    LPDWORD lpdwSrc, lpdwSrcEnd; // Used during merge operation.
    DWORD dwDwordsOut,		// Number of DWORDS in compressed output...
	dwBitsOut = 0;		// Number of bits in compressed output.
    DWORD dwBitsOutOld = 0;	// BitsOut from the *previous* band compression.
    int    iCurLine;		// Current line index.
    LPVOID lpViewerContext;	// The viewer context; used by viewrend library.
    VIEWINFO sViewInfo;		// Information about the image.
    WORD awResolution[2],	// Holds X & Y resolutions
	wBandSize = 256;	// Desired band size; will be reset by ViewerOpen.
    int iImageWidth;		// Holds the image width.
    DWORD cbBytes;		// Actual count of bytes read.
    IStream *psDocument;	// Our document stream.
    BOOL bRet = FALSE;		// Return value; FALSE by default.
    UINT iCurPage;		// Current page.
    const DWORD dwMagicHeight = 3000; // FIXBKD

    if((psDocument = OpenAWDStream(psStorages->psDocuments, pwcsDocName)) == NULL) {
	fwprintf(stderr, L"OutputPage:Unable to open stream '%s'.\n",
		pwcsDocName);
	return FALSE;		// We failed.
    }
	// Now, open a viewer context and start reading bands of the image.
    if((lpViewerContext = ViewerOpen(psDocument,
				     HRAW_DATA,
				     awResolution,
				     &wBandSize,
				     &sViewInfo)) == NULL) {
	fprintf(stderr, "OutputPage:Unable to open viewer context.\n");
	return FALSE;
    }

    iCurPage = 0;		// Initialize our counter.

    bmBand.bmBits = malloc(wBandSize);	// Allocate memory to hold the band.
    if(!ViewerGetBand(lpViewerContext, &bmBand)) {
	fprintf(stderr, "OutputPage:Unable to obtain image band.\n");
	return FALSE;
    }
	// lpOutBuf = malloc(bmBand.bmHeight * (FAX_IMAGE_WIDTH / 8));
    lpOutBuf = malloc(dwMagicHeight * (FAX_IMAGE_WIDTH / 8));
    memset(lpOutBuf, '\0', dwMagicHeight * (FAX_IMAGE_WIDTH / 8));

	// Provided compression actually *compresses*, we should have more than
	// enough memory allocated.
    lpdwOutCompressed = malloc(dwMagicHeight * (FAX_IMAGE_WIDTH / 8));
    memset(lpdwOutCompressed, '\0', dwMagicHeight * (FAX_IMAGE_WIDTH / 8));
    if(!lpOutBuf || !lpdwOutCompressed) {
	TiffEndPage(hTiffDest);
	if(lpOutBuf) free(lpOutBuf);
	if(lpdwOutCompressed) free(lpdwOutCompressed);
	return FALSE;		// This will stop the conversion process.
    }

	// Main loop
    while(iCurPage < sViewInfo.cPage) {
	lpOutCur = lpOutBuf;
	while(bmBand.bmHeight) {
		// Make sure our bitmap has FAX_IMAGE_WIDTH as its width.
	    ConvertWidth(bmBand.bmBits, bmBand.bmWidth / 8,
			 lpOutCur, FAX_IMAGE_WIDTH / 8,
			 bmBand.bmHeight);
	    lpOutCur += (bmBand.bmHeight * (FAX_IMAGE_WIDTH / 8));
	    
	    if(!ViewerGetBand(lpViewerContext, &bmBand)) {
		fprintf(stderr, "OutputPage:Unable to obtain image band.\n");
		goto output_exit;	// Will return FALSE by default.
	    }
	} // while (wasn't that easy?)

	memset(lpdwOutCompressed, '\0', dwMagicHeight * (FAX_IMAGE_WIDTH / 8));
	CompressBitmapStrip(lpOutBuf,
			    lpdwOutCompressed,
			    (ULONG)((lpOutCur - lpOutBuf) / (FAX_IMAGE_WIDTH / 8)),
			    FAX_IMAGE_WIDTH,
			    &dwDwordsOut,
			    &dwBitsOut);
	memset(lpOutBuf, '\0', dwMagicHeight * (FAX_IMAGE_WIDTH / 8));
	fprintf(stderr, "OutputPage:Compressed image to %d dwords, %d bits.\n",
		dwDwordsOut, dwBitsOut);
			
	if(!TiffStartPage(hTiffDest)) {
	    fprintf(stderr, "OutputPage:Unable to open output page.\n");
	    return FALSE;	// We can't begin a page for some reason.
	    if(lpOutBuf) free(lpOutBuf);
	    if(lpdwOutCompressed) free(lpdwOutCompressed);
	}
	TiffWriteRaw(hTiffDest, (LPBYTE)lpdwOutCompressed,
		     (dwDwordsOut + 1) * sizeof(DWORD));
	((PTIFF_INSTANCE_DATA)hTiffDest)->Lines =
	    (ULONG)((lpOutCur - lpOutBuf) / (FAX_IMAGE_WIDTH / 8));
	if(sViewInfo.yRes <= 100)
	    ((PTIFF_INSTANCE_DATA)hTiffDest)->YResolution = 98;
	else
	    ((PTIFF_INSTANCE_DATA)hTiffDest)->YResolution = 196;
	TiffEndPage(hTiffDest);

	    // Now, move to a new page of the data.
	iCurPage++;
	if(iCurPage < sViewInfo.cPage) {
	    ViewerSetPage(lpViewerContext, iCurPage);
	    if(!ViewerGetBand(lpViewerContext, &bmBand)) {
		fprintf(stderr, "OutputPage:Unable to obtain image band.\n");
		goto output_exit;	// Will return FALSE by default.
	    }
	}
    }

	// Free memory.
    bRet = TRUE;
  output_exit:
    free(lpdwOutCompressed);
    free(lpOutBuf);
    free(bmBand.bmBits);
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\awdlib\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This file contains utilitarian functions for
    the FAX TIFF library.

Environment:

        WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "tifflibp.h"
#pragma hdrstop



INT
FindWhiteRun(
    PBYTE       pbuf,
    INT         startBit,
    INT         stopBit
    )

/*++

Routine Description:

    Find the next span of white pixels on the specified line

Arguments:

    pbuf        - Points to uncompressed pixel data for the current line
    startBit    - Starting bit index
    stopBit     - Last bit index

Return Value:

    Length of the next run of white pixels

--*/

{
    static const BYTE WhiteRuns[256] = {

        8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };

    INT run, bits, n;

    pbuf += (startBit >> 3);
    if ((bits = stopBit-startBit) <= 0)
        return 0;

    //
    // Take care of the case where starting bit index is not a multiple of 8
    //

    if (n = (startBit & 7)) {

        run = WhiteRuns[(*pbuf << n) & 0xff];
        if (run > BYTEBITS-n)
            run = BYTEBITS-n;
        if (n+run < BYTEBITS)
            return run;
        bits -= run;
        pbuf++;

    } else
        run = 0;

    //
    // Look for consecutive DWORD value = 0
    //

    if (bits >= DWORDBITS * 2) {

        PDWORD  pdw;

        //
        // Align to a DWORD boundary first
        //

        while ((DWORD_PTR) pbuf & 3) {

            if (*pbuf != 0)
                return run + WhiteRuns[*pbuf];

            run += BYTEBITS;
            bits -= BYTEBITS;
            pbuf++;
        }

        pdw = (PDWORD) pbuf;

        while (bits >= DWORDBITS && *pdw == 0) {

            pdw++;
            run += DWORDBITS;
            bits -= DWORDBITS;
        }

        pbuf = (PBYTE) pdw;
    }

    //
    // Look for consecutive BYTE value = 0
    //

    while (bits >= BYTEBITS) {

        if (*pbuf != 0)
            return run + WhiteRuns[*pbuf];

        pbuf++;
        run += BYTEBITS;
        bits -= BYTEBITS;
    }

    //
    // Count the number of white pixels in the last byte
    //

    if (bits > 0)
        run += WhiteRuns[*pbuf];

    return run;
}


INT
FindBlackRun(
    PBYTE       pbuf,
    INT         startBit,
    INT         stopBit
    )

/*++

Routine Description:

    Find the next span of black pixels on the specified line

Arguments:

    pbuf        - Points to uncompressed pixel data for the current line
    startBit    - Starting bit index
    stopBit     - Last bit index

Return Value:

    Length of the next run of black pixels

--*/

{
    static const BYTE BlackRuns[256] = {

        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 7, 8
    };

    INT run, bits, n;

    pbuf += (startBit >> 3);
    if ((bits = stopBit-startBit) <= 0)
        return 0;

    //
    // Take care of the case where starting bit index is not a multiple of 8
    //

    if (n = (startBit & 7)) {

        run = BlackRuns[(*pbuf << n) & 0xff];
        if (run > BYTEBITS-n)
            run = BYTEBITS-n;
        if (n+run < BYTEBITS)
            return run;
        bits -= run;
        pbuf++;

    } else
        run = 0;

    //
    // Look for consecutive DWORD value = 0xffffffff
    //

    if (bits >= DWORDBITS * 2) {

        PDWORD  pdw;

        //
        // Align to a DWORD boundary first
        //

        while ((DWORD_PTR) pbuf & 3) {

            if (*pbuf != 0xff)
                return run + BlackRuns[*pbuf];

            run += BYTEBITS;
            bits -= BYTEBITS;
            pbuf++;
        }

        pdw = (PDWORD) pbuf;

        while (bits >= DWORDBITS && *pdw == 0xffffffff) {

            pdw++;
            run += DWORDBITS;
            bits -= DWORDBITS;
        }

        pbuf = (PBYTE) pdw;
    }

    //
    // Look for consecutive BYTE value = 0xff
    //

    while (bits >= BYTEBITS) {

        if (*pbuf != 0xff)
            return run + BlackRuns[*pbuf];

        pbuf++;
        run += BYTEBITS;
        bits -= BYTEBITS;
    }

    //
    // Count the number of white pixels in the last byte
    //

    if (bits > 0)
        run += BlackRuns[*pbuf];

    return run;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\awdvstub\awdvstub.c ===
/*++
  awdvstub.c

  Copyright (c) 1997  Microsoft Corporation


  This program is a stub AWD viewer... it will first convert an awd file named
  on the command line to a tiff file in the temp directory, then it will launch
  the tiff viewer on that file.

  Also, when used with the '/c' switch, it's an AWD converter.  Two programs in one!

  Author:
  Brian Dewey (t-briand)	1997-7-15
--*/

#include <windows.h>
#include <commctrl.h>
#include <commdlg.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include "awdlib.h"		// Gives access to the AWD routines.
#include "tifflib.h"		// TIFF routines.
#include "tifflibp.h"		// I need access to the private TIFF definitions.
#include "faxutil.h"		// not sure why I need this...
#include "viewrend.h"		// win95 viewer library.
#include "debug.h"		// debug libarary.
#include "resource.h"		// resource constants

// ------------------------------------------------------------
// Prototypes
void Useage(HINSTANCE hInst);
void PopupError(UINT uID, HINSTANCE hModule);

// ------------------------------------------------------------
// WinMain

int
WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow
    )
{
    LPWSTR *argv;
    DWORD   argc;
    UINT    uiCurrentArg;	// Used for iterating through arguments.
    UINT    uiNumFiles=0;	// This is the number of files we've gotten
				// from the command line.
    WCHAR   szTempPath[MAX_PATH]; // Holds the temporary path.
    WCHAR   szTempFile[MAX_PATH]; // Holds the temporary file name.
    WCHAR   szAwdFile[MAX_PATH]; // Holds the name of the AWD file we're viewing or converting.
    TCHAR   szExeFile[MAX_PATH+3]; // Holds the name of the tiff viewer.
    TCHAR   szExeFileTemp[MAX_PATH+1]; // Pre-processed name of tiff viewer.
    TCHAR   szCmdLine[2 * MAX_PATH]; // This will be our command line.
    int     iStrLen;
    STARTUPINFO sStartupInfo = { 0 };
    PROCESS_INFORMATION sProcessInfo;
    BOOL    bConvert = FALSE;	// TRUE if we're to do a permanent conversion.
				// If FALSE, we do a conversion to a temporary file &
				// launch the viewer.
    BOOL    bTempProvided = FALSE;// If TRUE, then the user provided the destination file.
    UINT    uiHackPosition = 0;	// Oh, this is part of some awful code below...

    sStartupInfo.cb = sizeof(STARTUPINFO);

    argv = CommandLineToArgvW( GetCommandLine(), &argc );
    if(argc < 2) {
	Useage(hInstance);
	return 1;
    }
    for(uiCurrentArg = 1; uiCurrentArg < argc; uiCurrentArg++) {
	if((argv[uiCurrentArg][0] == L'-') ||
	   (argv[uiCurrentArg][0] == L'/')) {
	    switch(argv[uiCurrentArg][1]) {
		    // We're doing a switch based on the character after the
		    // command-argument specifier ('-' or '/').  Put additional
		    // arguments here as needed.
	      case L'c':
	      case L'C':
		bConvert = TRUE; // We're meant to do a permanent conversion.
		break;
	      default:
		    // Should an invalid parameter be an error?
		Useage(hInstance);
		return 1;
	    } // Switch
	} else {
	    switch(uiNumFiles) {
	      case 0:
		    // If we haven't encountered any files before, then
		    // this is the name of the AWD file.
		wcscpy(szAwdFile, argv[uiCurrentArg]);
		break;
	      case 1:
		    // Now, we're reading the name of the TIF file for permanent conversion.
		bTempProvided = TRUE;
		wcscpy(szTempFile, argv[uiCurrentArg]);
		break;
	      default:
		    // Too many parameters!
		Useage(hInstance);
		return 1;
	    }
	    uiNumFiles++;
	}
    } // For

    if(!bTempProvided) {
	if(!bConvert) {
		// If the user didn't give a temp file name, we provide one.
	    if(!GetTempPath(MAX_PATH, szTempPath)) {
		PopupError(IDS_NOTEMPPATH, hInstance);
		return 1;		// Failed to get the path. 
	    }
	    GetTempFileName(
		szTempPath,		// put the file in this directory.
		TEXT("avs"),		// prefix -- "awd viewer stub"
		0,			// Generate a unique name.
		szTempFile		// Will hold the new name
		);
	    DeleteFile(szTempFile);	// Get rid of that file name.
					// (created when obtained.)
	} else {
		// The user requested permanent conversion, but didn't
		// supply a name.  In this case, change the extention of
		// the file to TIF instead of generating a temp file name.
	    wcscpy(szTempFile, szAwdFile);
	}
	    // Make sure the file has the TIF extension.
	iStrLen = wcslen(szTempFile);
	szTempFile[iStrLen-3] = L't';
	szTempFile[iStrLen-2] = L'i';
	szTempFile[iStrLen-1] = L'f';
    } // if(bTempProvided)...
    
    if(ConvertAWDToTiff(szAwdFile, szTempFile)) {
	if(bConvert) return 0;		// We're done!
	if(FindExecutable(
	    szTempFile,		// This file
	    NULL,		// No default directory
	    szExeFileTemp	// Put the EXE name here.
	    ) <= (struct HINSTANCE__ *)32)
	    {
		    // If we get here, there's no associated executable.
		TRACE((TEXT("Unable to find executable.\r\n")));
		PopupError(IDS_NOVIEW, hInstance);
		DeleteFile(szTempFile);
		return 1;
	    }
	    // Now build a command line.
      _tryagain:		// We'll return here on some errors.
	memset(&sStartupInfo, '\0', sizeof(sStartupInfo));
	sStartupInfo.cb = sizeof(sStartupInfo);
	_stprintf(szExeFile, TEXT("\"%s\""), szExeFileTemp);
	TRACE((TEXT("Exe = '%s', strlen = %d.\r\n"),
	       szExeFile,
	       _tcslen(szExeFileTemp)));
	_stprintf(szCmdLine, TEXT("%s \"%s\""), szExeFile, szTempFile);
	TRACE((TEXT("Command line = %s"), szCmdLine));
	if(!CreateProcess(
	    NULL,
	    szCmdLine,		// make the temp. tiff file be the command line
	    NULL,		// Process attributes.
	    NULL,		// Thread attributes.
	    FALSE,		// Don't inherit handles.
	    0,			// No flags.
	    NULL,		// Use calling environment.
	    NULL,		// Use current directory.
	    &sStartupInfo,	// Default startup info.
	    &sProcessInfo	// Receive process information.
	    )) {
	    DebugSystemError(GetLastError());
	    if(uiHackPosition < sizeof(szExeFileTemp) - 1) {
		    // OK.  Here's the situation:  sometimes, the exe file name will be
		    // impropery truncated.  Changing the first NULL to a space fixes the
		    // problem.  If we haven't tried this fix, do it now and see if that
		    // gives us a proper command line.  If we have done this before,
		    // something else is wrong and I'll bail.
		if(uiHackPosition == 0) {
			// This is the first time we failed.  Replace the NULL at
			// the end of the string with a space and try again.
		    uiHackPosition = _tcslen(szExeFileTemp);
		}
		szExeFileTemp[uiHackPosition] = _T(' ');
		uiHackPosition++;
		while((uiHackPosition < sizeof(szExeFileTemp)) &&
		      (szExeFileTemp[uiHackPosition] != _T(' '))) {
		    uiHackPosition++;
		}
		if(uiHackPosition < sizeof(szExeFileTemp))
		    szExeFileTemp[uiHackPosition] = _T('\0');
		goto _tryagain;
	    }
	    
		    // If we get here, couldn't execute.
	    TRACE((TEXT("Unable to start process: '%s %s'\r\n"),
		   szExeFile,
		   szCmdLine
		   ));
	    PopupError(IDS_NOVIEW, hInstance);
	    DeleteFile(szTempFile);
	    return 1;
	}
	WaitForSingleObject(sProcessInfo.hProcess, INFINITE);
	    // When we get here, the viewer has terminated.
	DeleteFile(szTempFile);	// Erase our tracks.
    } else {
	PopupError(IDS_ERRCONV, hInstance);
    }
    return 0;
}

// Useage
//
// Displays command useage.
//
// Parameters:
//	hInst			Current module instance.
//
// Returns:
//	Nothing.
//
// Author:
//	Brian Dewey (t-briand)	1997-8-7
void
Useage(HINSTANCE hInst)
{
    PopupError(IDS_USEAGE, hInst);
}

// PopupError
//
// Displays a message box with an error message.
//
// Parameters:
//	uID		String resource ID
//	hModule		Module instance.
//
// Returns:
//	Nothing.
//
// Author:
//	Brian Dewey (t-briand)	1997-8-19
void
PopupError(UINT uID, HINSTANCE hModule)
{
    TCHAR szTitle[512], szMsg[512];

    if(!LoadString(hModule,
		   IDS_TITLE,
		   szTitle,
		   sizeof(szTitle)/sizeof(TCHAR))) {
	return;
    }
    if(!LoadString(hModule,
		   uID,
		   szMsg,
		   sizeof(szMsg)/sizeof(TCHAR))) {
	return;
    }
    MessageBox(NULL, szMsg, szTitle, MB_OK | MB_ICONSTOP);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\awdvstub\debug.h ===
#ifndef __DEBUG_H
#define __DEBUG_H
// debug.h
//
// Copyright (c) 1997  Microsoft Corporation
//
// This header contains definitions for debug trace macros that are used
// by the migration DLL.
//
// Author:
//	Brian Dewey (t-briand)  1997-8-4

void dprintf(LPCTSTR Format, ...);
void DebugSystemError(DWORD dwErrCode);

#ifdef NDEBUG
#define TRACE(_x_) dprintf _x_
#else
#define TRACE(_x_)
#endif // NDEBUG

#endif // __DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\awdvstub\resource.h ===
// resource.h
//
// Copyright (c) 1997  Microsoft Corporation
//
// This file contains the resource constants for the AWD viewer stub.
//
// Author:
//	Brian Dewey (t-briand)	1997-8-18

#define IDS_USEAGE	200
#define IDS_TITLE	201
#define IDS_NOVIEW	202
#define IDS_ERRCONV	203
#define IDS_NOTEMPPATH  204
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\awdvstub\debug.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This file implements the debug code for the
    fax project.  All components that require
    debug prints, asserts, etc.

Author:

    Wesley Witt (wesw) 22-Dec-1995

    Minor modifications by Brian Dewey (t-briand) 4-Aug-1997
      -- to work with the FAX migration DLL.

Environment:

    User Mode

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <setupapi.h>

BOOL ConsoleDebugOutput = FALSE;


VOID
ConsoleDebugPrint(
    LPTSTR buf
    )
{
}


void
dprintf(
    LPTSTR Format,
    ...
    )

/*++

Routine Description:

    Prints a debug string

Arguments:

    format      - printf() format string
    ...         - Variable data

Return Value:

    None.

--*/

{
    TCHAR buf[1024];
    DWORD len;
    static TCHAR AppName[16];
    va_list arg_ptr;
    SYSTEMTIME CurrentTime;


    if (AppName[0] == 0) {
        if (GetModuleFileName( NULL, buf, sizeof(buf) )) {
            _tsplitpath( buf, NULL, NULL, AppName, NULL );
        }
    }

    va_start(arg_ptr, Format);

    GetLocalTime( &CurrentTime );
    _stprintf( buf, TEXT("%x   %02d:%02d:%02d.%03d  %s: "),
        GetCurrentThreadId(),
        CurrentTime.wHour,
        CurrentTime.wMinute,
        CurrentTime.wSecond,
        CurrentTime.wMilliseconds,
        AppName[0] ? AppName : TEXT("")
        );
    len = _tcslen( buf );

    _vsntprintf(&buf[len], sizeof(buf)-len, Format, arg_ptr);

    len = _tcslen( buf );
    if (buf[len-1] != TEXT('\n')) {
        buf[len] = TEXT('\r');
        buf[len+1] = TEXT('\n');
        buf[len+2] = 0;
    }

    OutputDebugString( buf );

    _stprintf( buf, TEXT("%02d:%02d:%02d.%03d  "),
        CurrentTime.wHour,
        CurrentTime.wMinute,
        CurrentTime.wSecond,
        CurrentTime.wMilliseconds
        );
    len = _tcslen( buf );

    _vsntprintf(&buf[len], sizeof(buf)-len, Format, arg_ptr);

    ConsoleDebugPrint( buf );
}


VOID
AssertError(
    LPTSTR Expression,
    LPTSTR File,
    ULONG  LineNumber
    )

/*++

Routine Description:

    Thie function is use together with the Assert MACRO.
    It checks to see if an expression is FALSE.  if the
    expression is FALSE, then you end up here.

Arguments:

    Expression  - The text of the 'C' expression
    File        - The file that caused the assertion
    LineNumber  - The line number in the file.

Return Value:

    None.

--*/

{
    dprintf(
        TEXT("Assertion error: [%s]  %s @ %d\n"),
        Expression,
        File,
        LineNumber
        );

    __try {
        DebugBreak();
    } __except (UnhandledExceptionFilter(GetExceptionInformation())) {
        // Nothing to do in here.
    }
}

// DebugSystemError
//
// Displays a system error message on the debug console.
//
// Parameters:
//	dwSysErrorCode		The system error code returned by GetLastError().
//
// Returns:
//	Nothing.
//
// Side effects:
//	Does a dprintf() of the message associated with an error code.
//
// Author:
//	Brian Dewey (t-briand)	1997-7-25
void
DebugSystemError(DWORD dwSysErrorCode)
{
    TCHAR szErrorMsg[MAX_PATH];	// Holds our message.

    FormatMessage(
	FORMAT_MESSAGE_FROM_SYSTEM, // We're given a system error code.
	NULL,			// No string.
	dwSysErrorCode,		// The error code.
	0,			// Default language.
	szErrorMsg,		// The error message.
	sizeof(szErrorMsg),	// Size of our buffer.
	NULL			// No arguments.
	);
    dprintf(szErrorMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\common\template.c ===
/*
 *
 *	template.c
 *
 * 	This file defines the general format of all source files for the XXXX 
 * 	project. This section of the file defines a general propose of the 
 *	file or the functions within the file.
 *
 *	Created:	11/26/91
 *	Author:	Optional information
 * 	Contributor:
 */

#include <window.h>

#include "h/xxxx.h"
#include "h/template.h"


/* Global/Static Data -- If any --
 */	


/* Local Function Declaration -- if any --
 */
static dword localfunction( dword, dword );

/* Function_name
 *
 * Checks the blah blah blah index of the polar corrdinates of the greater
 * downtown sector of newly formed blah blah.
 *
 * Arg1 -- 	provides the blah blah for estimating the blah balh. Valid range  
 * 		of values if from 0-100 inclusive. Values outside this range will
 *		cause error return of EXECES_BLAH
 * 
 * Arg2 --	Blah Blah Blah
 *
 * Return Value:
 *		EXECESS_BLAH
 *		Success_BLAH
 *		
 */
DWORD
Function_name( DWORD Arg1, DWORD Arg2 )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\dcxcodec\dcxcodec.cpp ===
/*==============================================================================
This code module handles HRAW<==>DCX conversions.

DATE       NAME      COMMENTS
13-Apr-93  RajeevD   Adapted to C++ from WFW.
05-Oct-93  RajeevD   Moved out of faxcodec.dll
==============================================================================*/
#include <ifaxos.h>
#include <memory.h>
#include <dcxcodec.h>

#ifdef DEBUG
DBGPARAM dpCurSettings = {"DCXCODEC"};
#endif

// Context Object
typedef struct FAR DCX : public FC_PARAM
{
	LPBYTE lpbSave;
	UINT   cbSave;
	LPBYTE lpbIn, lpbOut;
	UINT   cbIn,  cbOut;
	UINT   ibLine;
	BYTE   bVal, bRun;
	
	void Init (LPFC_PARAM lpfcParam)
	{
			_fmemcpy (this, lpfcParam, sizeof(FC_PARAM));
			ibLine = 0;
			bRun = 0;
			cbSave = 0;
			lpbSave = (LPBYTE) (this + 1);
	}

	FC_STATUS Convert (LPBUFFER, LPBUFFER);
	void RawToDcx (void);
	void DcxToRaw (void);
}
	FAR *LPDCX;

//==============================================================================
FC_STATUS DCX::Convert
	(LPBUFFER lpbufIn, LPBUFFER lpbufOut)
{
	// Trap end of page.
	if (!lpbufIn || lpbufIn->dwMetaData == END_OF_PAGE)
		return FC_INPUT_EMPTY;

	// Get buffer parameters.
	lpbIn = lpbufIn->lpbBegData;		
	cbIn = lpbufIn->wLengthData;
	lpbOut = lpbufOut->EndData();

  // Restore raw overflow.
	if (cbSave)
	{
		DEBUGCHK (nTypeOut == HRAW_DATA);
		_fmemcpy (lpbOut, lpbSave, cbSave);
		lpbOut += cbSave;
	}

  // Calculate output buffer.
	cbOut = (UINT)(lpbufOut->EndBuf() - lpbOut);

	// Execute the conversion.
	nTypeOut == DCX_DATA ? RawToDcx() : DcxToRaw();

	// Adjust buffers.
	lpbufIn->lpbBegData = lpbIn;
	lpbufIn->wLengthData = (USHORT)cbIn;
	lpbufOut->wLengthData = (USHORT)(lpbOut - lpbufOut->lpbBegData);

	// Save raw overflow.
	if (nTypeOut == HRAW_DATA)
 	{
		cbSave = lpbufOut->wLengthData % cbLine;
		lpbufOut->wLengthData -= (USHORT)cbSave;
		_fmemcpy (lpbSave, lpbufOut->EndData(), cbSave);
	}

	// Return status.
	return cbIn? FC_OUTPUT_FULL : FC_INPUT_EMPTY;
}

/*==============================================================================
This procedure decodes HRAW bitmaps from DCX.  In a DCX encoding, if the two 
high bits of a byte are set, the remainder of the byte indicates the number of 
times the following byte is to be repeated.  The procedure returns when either 
the input is empty, or the output is full.  Unlike the consumers and producers 
in the t4core.asm, it does not automatically return at the first EOL.
==============================================================================*/
void DCX::DcxToRaw (void)
{
  // Loop until input is empty or output is full.
	while (1)
	{
		if (bRun >= 0xC0)		    // Has the run been decoded?
		{
			if (!cbIn) return;    // Check if input is empty.
			if (ibLine >= cbLine) // If at end of line,
				ibLine = 0;         //   wrap the position.
			bVal = ~(*lpbIn++);   // Fetch the value of the run.
			cbIn--;
			bRun -= 0xC0;         // Decode the run length.
		}

#if 0 // transparent version

    // Write out the run.
		while (bRun) 
		{	
			*lpbOut++ = bVal;
	 		cbOut--;
	 		ibLine++;
			bRun--;
		}

#else // optimized version

		if (bRun)
		{
			// Write out the run.
			BYTE bLen = min (bRun, cbOut);
			_fmemset (lpbOut, bVal, bLen);

			// Adjust the output parameters.
			bRun -= bLen;
			lpbOut += bLen;
			cbOut -= bLen;
			ibLine += bLen;
											
			// Check if output is full.
			if (!cbOut) return;
		}

#endif // optimize switch

		if (!cbIn) return;    // Fetch the next byte.
		if (ibLine >= cbLine)	// If at end of line,
			ibLine = 0;         //   wrap the position.
		if (*lpbIn >= 0xC0)		// If the byte is a run length, set up.
			bRun = *lpbIn++;

		else                  // Otherwise the byte is a single value.
			{ bRun = 1; bVal = ~(*lpbIn++);}
		cbIn--;

	} // while (1)
	
}
 
/*==============================================================================
This procedure encodes HRAW bitmaps for DCX.  In a DCX encoding, if the two 
high bits of a byte are set, the remainder of the byte indicates the number of 
times the following byte is to be repeated.  The procedure returns when either 
the input is empty or the output is full.  Unlike its brethren in T4, it does 
not return automatically at EOL.
==============================================================================*/
void DCX::RawToDcx (void)
{
	BYTE bVal, bRun;

	// Convert until input is empty or output is full.
	// The output is full if only one byte is available
	// because one input byte may produce two output bytes.
	while (cbIn && cbOut > 1)
	{
		if (ibLine >= cbLine) ibLine = 0;	// If EOL, wrap the position.
			
		// Get an input byte.
		bVal = *lpbIn++;
		cbIn--;
		bRun = 1;
		ibLine++;
		
		// Scan for a run until one of the following occurs:
		// (1) There are no more input bytes to be consumed.
		// (2) The end of the current line has been reached.
		// (3) The run length has reached the maximum of 63.
		// (4) The first byte does not match the current one.

#if 0 // Transparent Version.	

		while (/*1*/ cbIn	// Check first to avoid GP faults!
				&& /*4*/ bVal == *lpbIn
				&& /*2*/ ibLine < cbLine
				&& /*3*/ bRun < 63
					)
		{ lpbIn++; cbIn--; bRun++; ibLine++; }

#else // Optimized Version
	
	// If the next byte matches, scan for a run.
	// This test has been unrolled from the loop.
 	if (cbIn && bVal == *lpbIn)
	{
		BYTE ubMaxRest, ubRest;
		
		// Calculate the maximum number of bytes remaining.
		ubMaxRest = min (cbIn, 62);
		ubMaxRest = min (ubMaxRest, cbLine - ibLine);

		// Scan for a run.
		ubRest = 0;
		while (bVal == *lpbIn && ubRest < ubMaxRest)
			{lpbIn++; ubRest++;}

		// Adjust state.
		cbIn -= ubRest;
		ibLine += ubRest;
		bRun = ++ubRest;
	}

#endif // End of Compile Switch
 			
		bVal = ~bVal;		// Flip black and white.

		// Does the value need to be escaped,
		// or is there non-trival run of bytes?
		if (bVal >= 0xC0 || bRun>1)
		{ // Yes, encode the run length.
		  // (Possibly 1 for bVal>=0xC0).
			*lpbOut++ = bRun + 0xC0;
			cbOut--;
		}	

		*lpbOut++ = bVal;		// Encode the value.
		cbOut--;

	} // while (1)
}

//==============================================================================
// C Export Wrappers
//==============================================================================

#ifndef WIN32

BOOL WINAPI LibMain
	(HANDLE hInst, WORD wSeg, WORD wHeap, LPSTR lpszCmd)
{ return 1; }

extern "C" {int WINAPI WEP (int nParam);}
#pragma alloc_text(INIT_TEXT,WEP)
int WINAPI WEP (int nParam)
{ return 1; }

#endif

//==============================================================================
UINT WINAPI DcxCodecInit
	(LPVOID lpContext, LPFC_PARAM lpfcParam)
{
	UINT cbContext = sizeof(DCX);
	if (lpfcParam->nTypeOut == HRAW_DATA)
		cbContext += lpfcParam->cbLine;

	if (lpContext)
		((LPDCX) lpContext)->Init (lpfcParam);
	return cbContext;
}
 
//==============================================================================
FC_STATUS WINAPI DcxCodecConvert
	(LPVOID lpContext, LPBUFFER lpbufIn, LPBUFFER lpbufOut)
{
	return ((LPDCX) lpContext)->Convert (lpbufIn, lpbufOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\dcxcodec\raw2dcx.c ===
/*==============================================================================
This procedure converts HRAW to DCX in memory.

ASSUMES
1) Input buffer contains a single scan line.
2) Output buffer is twice as large as input.

29-Apr-94    RajeevD    Adapted from dcxcodec.dll
==============================================================================*/
#include <windows.h>

UINT              // output data size
DCXEncode
(
	LPBYTE lpbIn,   // raw input buffer
  LPBYTE lpbOut,  // dcx output buffer
	UINT cbIn       // input data size
)
{
	UINT cbOut = 0;
	BYTE bVal, bRun;

  while (cbIn)
  {
		// Get an input byte.
		bVal = *lpbIn++;
		cbIn--;
		bRun = 1;
	
		// Scan for a run until one of the following occurs:
		// (1) There are no more input bytes to be consumed.
		// (2) The run length has reached the maximum of 63.
		// (3) The first byte does not match the current one.

	 	if (cbIn && bVal == *lpbIn)
		{
			BYTE cbMax, cbRest;
			
			// Calculate the maximum number of bytes remaining.
			cbMax = min (cbIn, 62);

			// Scan for a run.
			cbRest = 0;
			while (bVal == *lpbIn && cbRest < cbMax)
				{lpbIn++; cbRest++;}

			// Adjust state.
			cbIn -= cbRest;
			bRun = ++cbRest;
		}	
		
	  // Flip black and white.
		bVal = ~bVal;	

		// Does the value need to be escaped,
		// or is there non-trival run of bytes?
		if (bVal >= 0xC0 || bRun>1)
		{
			// Yes, encode the run length.
		  // (possibly 1 for bVal>=0xC0).
			*lpbOut++ = bRun + 0xC0;
			cbOut++;
		}	

		// Encode the value.
		*lpbOut++ = bVal;		
		cbOut++;
	
	} // while (cbIn)

	return cbOut;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\faxcodec\faxcodec.cpp ===
/*=============================================================================
This code module dispatches external C calls to internal C++ calls.

DATE        NAME      COMMENTS
12-Apr-93   RajeevD   Adapted to C++ from WFW.
==============================================================================*/
#include <ifaxos.h>
#include <faxcodec.h>
#include <memory.h>
#include "context.hpp"

#ifdef DEBUG
#ifdef WIN32
DBGPARAM dpCurSettings = {"AWCODC32"};
#else
DBGPARAM dpCurSettings = {"FAXCODEC"};
#endif
#endif

#ifndef WIN32

BOOL WINAPI LibMain
	(HANDLE hInst, WORD wSeg, WORD wHeap, LPSTR lpszCmd)
{ return 1; }

extern "C" {int WINAPI WEP (int nParam);}
#pragma alloc_text(INIT_TEXT,WEP)
int WINAPI WEP (int nParam)
{ return 1; }

#endif

#define CONTEXT_SLACK (RAWBUF_SLACK + 2*CHANGE_SLACK)

//==============================================================================
UINT WINAPI FaxCodecInit (LPVOID lpContext, LPFC_PARAM lpParam)
{
	// Do we need double buffered change vector?
	BOOL f2DInit = 
		  lpParam->nTypeIn  ==  MR_DATA
   || lpParam->nTypeIn  == MMR_DATA
	 || lpParam->nTypeOut ==  MR_DATA 
	 || lpParam->nTypeOut == MMR_DATA;

	// Enforce 64K limit on size of context.
	DEBUGCHK (!(lpParam->cbLine > (f2DInit? 1875U : 3750U)));
	if (lpParam->cbLine > (f2DInit? 1875U : 3750U)) return 0;

	// Enforce nonzero K factor if encoding MR.
	DEBUGCHK (lpParam->nKFactor || lpParam->nTypeOut != MR_DATA);

	if (lpContext)
		((LPCODEC) lpContext)->Init (lpParam, f2DInit);
	return sizeof(CODEC) + CONTEXT_SLACK + (f2DInit ? 33:17) * lpParam->cbLine;
}

//==============================================================================
UINT WINAPI FaxCodecConvert
	(LPVOID lpContext, LPBUFFER lpbufIn, LPBUFFER lpbufOut)
{
	return ((LPCODEC) lpContext)->Convert (lpbufIn, lpbufOut);
}

//==============================================================================
void WINAPI FaxCodecCount (LPVOID lpContext, LPFC_COUNT lpCountOut)
{
	LPFC_COUNT lpCountIn = &((LPCODEC) lpContext)->fcCount;
	DEBUGMSG(1,("FaxCodecCount: good=%ld bad=%ld\n consec=%ld",
		lpCountIn->cTotalGood, lpCountIn->cTotalBad, lpCountIn->cMaxRunBad));
	_fmemcpy (lpCountOut, lpCountIn, sizeof(FC_COUNT));
	_fmemset (lpCountIn, 0, sizeof(FC_COUNT));
}	

//==============================================================================
void WINAPI InvertBuf (LPBUFFER lpbuf)
{
	LPBYTE lpb = lpbuf->lpbBegData;
	WORD    cb = lpbuf->wLengthData;
	DEBUGCHK (lpbuf && lpbuf->wLengthData % 4 == 0);
	while (cb--) *lpb++ = ~*lpb;
}

//==============================================================================
void WINAPI FaxCodecChange
(
	LPBYTE  lpbLine,      // input LRAW scan line
	UINT    cbLine,       // scan line byte width
  LPSHORT lpsChange     // output change vector
)
{
	T4STATE t4;

	t4.lpbIn   = lpbLine;
	t4.lpbOut  = (LPBYTE) lpsChange;
	t4.cbIn    = (WORD)cbLine;
	t4.cbOut   = cbLine * 16;
	t4.cbLine  = (WORD)cbLine;
	t4.wColumn = 0;
	t4.wColor  = 0;
	t4.wWord   = 0;
	t4.wBit    = 0;
	t4.cbSlack = CHANGE_SLACK;
	t4.wRet    = RET_BEG_OF_PAGE;

	RawToChange (&t4);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\faxcodec\client.c ===
/*==============================================================================
This source file is an example of a faxcodec.dll client.
          
DATE				NAME			COMMENT
13-Apr-93		rajeevd		Moved out of faxcodec.dll
18-Nov-93   rajeevd   Updated to new faxcodec API.
==============================================================================*/
#include <windows.h>
#include <buffers.h>
#include <faxcodec.h>

/*==============================================================================
This procedure performs any conversion indicated by a star in the table below:

                            Output

                 HRAW   LRAW   MH   MR    MMR

          HRAW                 *     *     *

          LRAW		             *     *     *

  Input   MH       *     *           *     *

          MR       *     *     *           *

          MMR      *     *     *     *      

The input and output are assumed to be in non-overlapping memory buffers.
==============================================================================*/

UINT MemConvert      // returns output data size (0 on failure)
	(
		LPBYTE lpbIn,    // input data pointer
		UINT   cbIn,     // input data size
		DWORD  nTypeIn,  // input data encoding
		
		LPBYTE lpbOut,   // output buffer pointer
		UINT   cbOut,    // output buffer size
		DWORD  nTypeOut, // output data encoding
		
		UINT   cbLine,   // scan line width
		UINT   nKFactor  // K factor (significant if nTypeOut==MR_DATA)
	)
{
	UINT cbRet = 0; 
	
	BUFFER bufIn, bufOut, bufEOP;
	BOOL fRevIn, fRevOut;

	HANDLE hContext;
	LPVOID lpContext;
	UINT cbContext;

	FC_PARAM  fcp;
	FC_STATUS fcs;
	
	// Set up input buffer.
	bufIn.lpbBegBuf = lpbIn;	
	bufIn.wLengthBuf  = cbIn;  
	bufIn.lpbBegData  = lpbIn;
	bufIn.wLengthData = cbIn;
	bufIn.dwMetaData   = nTypeIn;
	
	// Set up output buffer.
	bufOut.lpbBegBuf   = lpbOut;
	bufOut.lpbBegData  = lpbOut;
	bufOut.wLengthBuf  = cbOut;
	bufOut.wLengthData = 0;
	bufOut.dwMetaData   = nTypeOut;
	
	// Initialize EOP buffer
	bufEOP.dwMetaData = END_OF_PAGE;

	// Handle input bit reversal.
	if (nTypeIn == HRAW_DATA)
	{
		fRevIn = TRUE;
		BitReverseBuf (&bufIn);
	}	
	else fRevIn = FALSE;
	
	// Detect output bit reversal.
	if (nTypeOut == HRAW_DATA)
	{
		fRevOut = TRUE;
		nTypeOut = LRAW_DATA;
	}
	else fRevOut = FALSE;

	// Initialize parameters.
	fcp.nTypeIn  = nTypeIn;
	fcp.nTypeOut = nTypeOut;
	fcp.cbLine   = cbLine;
	fcp.nKFactor = nKFactor;

	// Query for size of context.
	cbContext = FaxCodecInit (NULL, &fcp);
	if (!cbContext)
		goto err;

	// Allocate context memory.
	hContext = GlobalAlloc (GMEM_FIXED, cbContext);
	if (!hContext)
		goto err;
	lpContext = GlobalLock (hContext);

	// Initialize context.
	FaxCodecInit (lpContext, &fcp); 

	// Convert data in single pass.
	fcs = FaxCodecConvert (lpContext, &bufIn,  &bufOut); 

	// Flush EOFB for nTypeOut == MMR_DATA
	FaxCodecConvert (lpContext, &bufEOP, &bufOut);

	// Free context memory.
	GlobalUnlock (hContext);
	GlobalFree (hContext);
	
	// Undo input bit reversal.
	if (fRevIn)
	{
		bufIn.lpbBegData = lpbIn;
		bufIn.wLengthData = cbIn;
		BitReverseBuf (&bufIn);
	}

	// Handle output bit reversal.
	if (fRevOut)
		BitReverseBuf (&bufOut);
	
	if (fcs == FC_INPUT_EMPTY)
		cbRet = bufOut.wLengthData;

err:
	return cbRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\faxcodec\bitrev.c ===
#include <ifaxos.h>
#include <faxcodec.h>

//==============================================================================
const BYTE BitRev[256] = // bit reversal of index
{
	0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
	0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
	0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
	0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
	0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
	0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
	0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
	0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
	0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
	0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
	0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
	0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
	0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
	0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
	0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
	0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
	0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
	0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
	0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
	0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
	0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
	0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
	0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
	0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
	0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
	0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
	0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
	0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
	0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
	0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
	0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
	0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
};

//==============================================================================
void WINAPI BitReverseBuf (LPBUFFER lpbuf)
{
	LPBYTE lpb; 
	USHORT cb; 

	DEBUGCHK (lpbuf && lpbuf->wLengthData % 4 == 0);

	switch (lpbuf->dwMetaData)
	{
		case LRAW_DATA:	lpbuf->dwMetaData = HRAW_DATA; break;
		case HRAW_DATA:	lpbuf->dwMetaData = LRAW_DATA; break;
		default:
			DEBUGMSG (1, ("FaxCodecRevBuf invalid metadata %d\r\n",lpbuf->dwMetaData));
	}

	lpb = lpbuf->lpbBegData;
	cb = lpbuf->wLengthData;
	while (cb--)
		*lpb++ =  BitRev[*lpb];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\faxcodec\context.hpp ===
/*==============================================================================
This include file defines C++ objects for each type of instance.
==============================================================================*/
#include <ifaxos.h>
#include <faxcodec.h>

#ifdef DEBUG
extern DBGPARAM dpCurSettings;
#endif

//==============================================================================
typedef struct T4STATE   // keep in sync with t4core.asm!
{
	LPBYTE lpbIn;          // read-only input buffer 
	LPBYTE lpbOut;         // output buffer
	WORD wOffset;					 // segment offset of change vector buffer (for consumers)
	WORD cbIn;             // input data size
	WORD cbOut;            // output buffer size
	WORD cbLine;           // width of line in bytes
	WORD wColumn;          // current position in bits
	WORD wColor;           // current color
	WORD wWord;            // current word
	WORD wBit;             // bit modulus
	WORD cbSlack;
	LPBYTE lpbRef;         // read-only reference change vector
	LPBYTE lpbBegRef;      // for client
	WORD wRet;             // return status
	WORD wToggle;
	WORD iKFactor;         // K counter
	WORD wMode;            // for MR
	short a0;	             // for MMR
	DWORD nType;           // type of data being produced/consumed
}
	FAR* LPT4STATE;

// Values for wRet
#define RET_INPUT_EMPTY1   1
#define RET_INPUT_EMPTY2   2
#define RET_OUTPUT_FULL    3
#define RET_END_OF_LINE    4
#define RET_SPURIOUS_EOL   5
#define RET_BEG_OF_PAGE    6
#define RET_END_OF_PAGE		10
#define RET_DECODE_ERR   253

#ifdef __cplusplus
extern "C" { 
#endif

	// ASM methods
	void ChangeToRaw (LPT4STATE);
	void RawToChange (LPT4STATE);
	void ChangeToMH  (LPT4STATE);
	void MHToChange  (LPT4STATE);
	void ChangeToMR  (LPT4STATE);
	void MRToChange  (LPT4STATE);
	void ChangeToMMR (LPT4STATE);
	void MMRToChange (LPT4STATE);

#ifdef __cplusplus
} // extern "C"
#endif

//==============================================================================

#ifdef __cplusplus

typedef class FAR CODEC : FC_PARAM
{
	LPBYTE lpbLine;
	UINT xExt;
	UINT cSpurious;
	LPBYTE lpbChange;
	LPBYTE lpbRef;
	BOOL f2D;
	T4STATE t4C, t4P;
	void (*Consumer)(LPT4STATE);
	void (*Producer)(LPT4STATE);
	WORD wBad;

public:
	FC_COUNT fcCount;

	void Init (LPFC_PARAM, BOOL f2DInit);
	FC_STATUS Convert (LPBUFFER, LPBUFFER);

private:
	void SwapChange (void);
	void ResetBad (void);
	void EndLine (void);
	void StartPage (void);
	void EndPage (LPBUFFER lpbufOut);
	FC_STATUS ConvertToT4  (LPBUFFER lpbufIn, LPBUFFER lpbufOut);
	FC_STATUS ConvertToRaw (LPBUFFER lpbufIn, LPBUFFER lpbufOut);

}
	FAR *LPCODEC;

#endif // C++
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\faxcodec\convert.cpp ===
/*==============================================================================
This code module handles T4 conversion instances.

DATE        NAME       COMMENTS
12-Apr-93   RajeevD    Adapted to C++ from WFW.
20-Apr-93   RajeevD    Overhauled buffer handling.
==============================================================================*/
#include <ifaxos.h>
#include <memory.h>
#include <faxcodec.h>
#include "context.hpp"

#define RTC_EOL 5

#define VALIDATE_CHANGE

typedef short FAR *LPSHORT;

//==============================================================================
#pragma warning(disable:4704)

#ifdef WIN32

UINT // size of change vector (0 if invalid)
ValidChangeVector
(
	LPSHORT lpsChange,   // change vector buffer
	SHORT   xExt         // pixel width of line
)
{
	SHORT sPrev = -1;

	SHORT cChange = xExt;

	while (cChange--)
	{
		// Check monotonicity.
		if (*lpsChange <= sPrev)
			return 0;
		sPrev = *lpsChange++;

		if (sPrev == xExt)
		{
			// Check EOL termination.
			if
			(   *lpsChange++ == xExt
			 && *lpsChange++ == xExt
			 && *lpsChange++ == xExt
			 && *lpsChange++ == -1
			 && *lpsChange++ == -1
		  )
			return sizeof(WORD) * (xExt - cChange) ;
		else
			return 0;
		}
		
	} // while (cChange--)

	return 0; // Hit end of change vector buffer.
}

#else // ifndef WIN32

UINT // size of change vector (0 if invalid)
ValidChangeVector
(
	LPSHORT lpsChange,   // change vector buffer
	SHORT   xExt         // pixel width of line
)
{
	UINT uRet;

	_asm
	{
		push	ds
		push	si

		lds		si, DWORD PTR [lpsChange]	; lpsChange
		mov		dx, -1						; sPrev
		mov		cx, xExt					; cChange
		mov		bx, cx						; xExt
		jmp		enterloop

	fooie:
		lodsw
		cmp		ax, dx
		jle		error		; need SIGNED compare
		mov		dx, ax
		cmp		dx, bx
		je		goteol
	enterloop:
		loop	fooie
	error:
		xor		ax, ax
		jmp		done

	goteol:
		lodsw
		cmp		ax, bx		; bx == xExt
		jne		error
		lodsw
		cmp		ax, bx
		jne		error
		lodsw
		cmp		ax, bx
		jne		error

		xor		bx, bx
		not		bx			; bx == -1
		lodsw
		cmp		ax, bx
		jne		error
		lodsw
		cmp		ax, bx
		jne		error

    // uRet = sizeof(WORD) * (xExt - cChange) ;
		mov   ax, xExt
		sub   ax, cx
		inc   ax
		shl   ax, 1
    
	done:
		pop		si
		pop		ds
		mov		uRet, ax
	}
	return uRet;
}

#endif // WIN32

//==============================================================================
void CODEC::ResetBad (void)
{
	DEBUGMSG (1,("FAXCODEC: decoded %d bad line(s)\r\n", wBad));
	if (fcCount.cMaxRunBad < wBad)
		fcCount.cMaxRunBad = wBad;
	wBad = 0;
}

//==============================================================================
void CODEC::SwapChange (void)
{
	LPBYTE lpbTemp;
	lpbTemp = lpbChange;
	lpbChange = lpbRef;
	lpbRef = lpbTemp;
}

//==============================================================================
void CODEC::EndLine (void)
{
	if (f2D)
	{
		// Reset consumer and producer.
		t4C.lpbRef =    lpbRef;
		t4C.lpbBegRef = lpbRef;
		t4P.lpbRef =    lpbRef;
		t4P.lpbBegRef = lpbRef;

		// Increment K Factor
		t4P.iKFactor++;
		if (t4P.iKFactor == nKFactor)
			t4P.iKFactor = 0;
	}

	// Clear change vector buffer (debug only).
	DEBUGSTMT (_fmemset (lpbChange, 0xCD, sizeof(WORD) * xExt + CHANGE_SLACK));

	// Reset consumer.
	t4C.wColumn = 0;
	t4C.wColor = 0;
	t4C.lpbOut = lpbChange;
	t4C.wOffset = LOWORD(lpbChange);
	t4C.wToggle = 0;

	// Reset producer.	
	t4P.wColumn = 0;
	t4P.wColor = 0;
	t4P.lpbIn = lpbChange;
}

//==============================================================================
void CODEC::StartPage (void)
{
	if (wBad) ResetBad();
	cSpurious = 0;
	EndLine ();

	// Reset consumer.
	t4C.wWord = 0;
	t4C.wBit = 0;
	t4C.wRet = RET_BEG_OF_PAGE;

	// Reset producer.
	t4P.wWord = 0;
	t4P.wBit = 0;
	t4P.wRet = RET_BEG_OF_PAGE;

	// Blank buffered output line.
	_fmemset (lpbLine, 0, cbLine);

	if (f2D)
	{
		// Blank reference vector.
		LPWORD lpwRef = (LPWORD) lpbRef;

		*lpwRef++ = (WORD)xExt;
		*lpwRef++ = (WORD)xExt;
		*lpwRef++ = (WORD)xExt;
		*lpwRef++ = (WORD)xExt;
		*lpwRef++ = 0xFFFF;
		*lpwRef++ = 0xFFFF;

		t4C.wMode = 0;
		t4P.wMode = 0;
		t4P.iKFactor = 0;
	}
}

//==============================================================================
void CODEC::EndPage (LPBUFFER lpbufOut)
{
	// Flush last byte and end-of-block code.
	switch (nTypeOut)
	{
		case LRAW_DATA:
		case NULL_DATA:
			return;
			
		case MH_DATA:
		case MR_DATA:
#ifndef WIN32
			return;
#endif		
		case MMR_DATA:
		{
			LPBYTE lpbBeg = lpbufOut->EndData();
    	t4P.lpbOut = lpbBeg;
    	t4P.cbOut = (WORD)(lpbufOut->EndBuf() - t4P.lpbOut);
    	t4P.wRet = RET_END_OF_PAGE;
    	Producer (&t4P);
    	lpbufOut->wLengthData += (WORD)(t4P.lpbOut - lpbBeg);
    	return;
		}
		
    default: DEBUGCHK (FALSE);
	}
}

/*==============================================================================
This method initializes a CODEC context.
==============================================================================*/
void CODEC::Init (LPFC_PARAM lpParam, BOOL f2DInit)
{
		DEBUGMSG (1, ("FAXCODEC: nTypeIn  = %lx\n\r", lpParam->nTypeIn));
		DEBUGMSG (1, ("FAXCODEC: nTypeOut = %lx\n\r", lpParam->nTypeOut));
		DEBUGMSG (1, ("FAXCODEC: cbLine   = %d\n\r", lpParam->cbLine));
		DEBUGMSG (1, ("FAXCODEC: nKFactor = %d\n\r", lpParam->nKFactor));
	
		// Initialize constants.
		_fmemcpy (this, lpParam, sizeof(FC_PARAM));
		xExt = 8 * cbLine;
		f2D = f2DInit;

		switch (nTypeIn)        // Determine the consumer.
		{
			case LRAW_DATA:   Consumer = RawToChange;	break;
			case MH_DATA:			Consumer = MHToChange;	break;
    	case MR_DATA:			Consumer = MRToChange;  break;
			case MMR_DATA:		Consumer = MMRToChange;	break;
			default:					DEBUGCHK (FALSE);
		}
		
		switch (nTypeOut)       // Determine the producer.
		{
			case NULL_DATA:   Producer = NULL;         break;		
			case LRAW_DATA:   Producer = ChangeToRaw;  break;
		  case MH_DATA:     Producer = ChangeToMH;   break;
		  case MR_DATA:     Producer = ChangeToMR;   break;
		  case MMR_DATA:    Producer = ChangeToMMR;  break;
			default:          DEBUGCHK (FALSE);
		}

	 	// Initialize memory buffers.
		lpbLine = (LPBYTE) (this + 1);
		lpbChange = lpbLine + cbLine + RAWBUF_SLACK;
		lpbRef = lpbChange;
		if (f2D)
			lpbRef += xExt * sizeof(USHORT) + CHANGE_SLACK;
 
		// Initialize consumer state.
		t4C.cbSlack = CHANGE_SLACK;
		t4C.cbLine  = (WORD)cbLine;
		t4C.nType   = nTypeIn;
		
		// Initialize producer state.
		t4P.cbSlack = OUTBUF_SLACK;
		t4P.cbLine  = (WORD)cbLine;
		t4P.nType   = nTypeOut;
		
		// Initialize error counts.
		_fmemset (&fcCount, 0, sizeof(fcCount));
		wBad = 0;
		
		// Reset for beginning of page.
		StartPage();
}

/*==============================================================================
This method executes a CODEC conversion.
==============================================================================*/
FC_STATUS CODEC::Convert (LPBUFFER lpbufIn, LPBUFFER lpbufOut)
{
	FC_STATUS ret;

	// A null input buffer is flag for end of page.
	if (!lpbufIn || lpbufIn->dwMetaData == END_OF_PAGE)
	{
	  DEBUGMSG (1,("FAXCODEC: got EOP\r\n"));
		EndPage (lpbufOut);
		StartPage ();
		return FC_INPUT_EMPTY;
	}

  // Ignore input after RTC but before end of page.
	if (cSpurious == RTC_EOL)
	{
	  DEBUGMSG (1,("FAXCODEC: ignoring input after RTC or EOFB\r\n"));
		return FC_INPUT_EMPTY;
  }
  
#ifndef WIN32

	if (t4C.wRet == RET_BEG_OF_PAGE)
	{
		if (nTypeOut == MH_DATA || nTypeOut == MR_DATA)
		{
		  // Start page with EOL.
			if (lpbufOut->EndBuf() - lpbufOut->EndData() < OUTBUF_SLACK)
				return FC_OUTPUT_FULL;
			*((LPWORD) lpbufOut->EndData()) = 0x8000;
			lpbufOut->wLengthData += 2;
		}
	}
	
#endif // WIN32
		
	// Initialize input buffer of consumer.
	t4C.lpbIn = lpbufIn->lpbBegData;
	t4C.cbIn = lpbufIn->wLengthData;

	// Dispatch to 2 or 3 phase conversion.
	if (nTypeOut == LRAW_DATA || nTypeOut == NULL_DATA)
		ret = ConvertToRaw (lpbufIn, lpbufOut);
	else
		ret = ConvertToT4 (lpbufIn, lpbufOut);

	// Adjust input buffer header.
	lpbufIn->lpbBegData = t4C.lpbIn;
	lpbufIn->wLengthData = t4C.cbIn;

	return ret;
}

//==============================================================================
FC_STATUS CODEC::ConvertToRaw (LPBUFFER lpbufIn, LPBUFFER lpbufOut)
{
	LPBYTE lpbOut = lpbufOut->EndData();
	UINT cbOut = (UINT)(lpbufOut->EndBuf() - lpbOut);

	if (t4P.wRet == RET_OUTPUT_FULL)
		goto copy_phase;

	while (1)
	{
		Consumer (&t4C); // generate change vector

		switch (t4C.wRet)
		{		
			case RET_INPUT_EMPTY1:
			case RET_INPUT_EMPTY2:
				return FC_INPUT_EMPTY;

			case RET_SPURIOUS_EOL:
				if (++cSpurious == RTC_EOL)
					return FC_INPUT_EMPTY;
				EndLine();
				continue;

		 	case RET_DECODE_ERR:
		 		break; // handle it later
	 		
			case RET_END_OF_PAGE:
				if (wBad) ResetBad();
				cSpurious = RTC_EOL;
				return FC_INPUT_EMPTY;
				
			case RET_END_OF_LINE:
			  t4P.cbIn = (USHORT)ValidChangeVector ((LPSHORT) lpbChange, (SHORT)xExt);
        if (!t4P.cbIn)
        	t4C.wRet = RET_DECODE_ERR; // consumer lied!
        else
        {
          // Adjust counters.
					fcCount.cTotalGood++;
					if (wBad) ResetBad();
					cSpurious = 0;
				}
				break;
				
			default: DEBUGCHK (FALSE);
		}

    // Handle decode errors.
		if (t4C.wRet == RET_DECODE_ERR)
		{
			if (nTypeIn == MMR_DATA)
	 			return FC_DECODE_ERR;
			wBad++;
			fcCount.cTotalBad++;

#ifdef DEBUG
      _fmemset (lpbLine, 0xFF, cbLine); // emit black line
#endif

			if (f2D)
			{
			  // Replicate change vector.
			  t4P.cbIn = (WORD)ValidChangeVector ((LPSHORT) lpbRef, (WORD)xExt);
			  DEBUGCHK (t4P.cbIn);
			  _fmemcpy (lpbChange, lpbRef, t4P.cbIn + CHANGE_SLACK);
			}
		
		  if (nTypeOut == NULL_DATA)
				goto EOL;

			if (!f2D)
				goto copy_phase;
    }

    // Optimize validation.
		if (nTypeOut == NULL_DATA)
			goto EOL;

	  // Run the producer.
		t4P.lpbOut = lpbLine;
		t4P.cbOut = (WORD)cbLine;
		ChangeToRaw (&t4P);

copy_phase:

		if (cbOut < cbLine)
		{
			t4P.wRet = RET_OUTPUT_FULL;
			return FC_OUTPUT_FULL;
		}

		// Append buffered line to output.
		t4P.wRet = RET_END_OF_LINE;
		_fmemcpy (lpbOut, lpbLine, cbLine);
		lpbufOut->wLengthData += (WORD)cbLine;
		lpbOut += cbLine;
		cbOut -= cbLine;

EOL:
		SwapChange ();
		EndLine ();

	} // while (1)

	// C8 thinks we can get here, but I know better.
	DEBUGCHK (FALSE);
	return FC_DECODE_ERR;
}

//==============================================================================
FC_STATUS CODEC::ConvertToT4 (LPBUFFER lpbufIn, LPBUFFER lpbufOut)
{
	LPBYTE lpbBegOut;
	
	t4P.lpbOut = lpbufOut->EndData();
	t4P.cbOut = (WORD)(lpbufOut->EndBuf() - t4P.lpbOut);

	if (t4P.wRet == RET_OUTPUT_FULL)
  	goto producer_phase;

	while (1)  // Loop until input is empty or output is full.
	{
		Consumer (&t4C);

		switch (t4C.wRet)
		{
			case RET_INPUT_EMPTY1:
			case RET_INPUT_EMPTY2:
				return FC_INPUT_EMPTY;

			case RET_SPURIOUS_EOL:
				if (++cSpurious == RTC_EOL)
					return FC_INPUT_EMPTY;
				EndLine();
				continue;

		 	case RET_DECODE_ERR:
		 		break; // handle it later
	 		
			case RET_END_OF_PAGE:
				if (wBad) ResetBad();
				cSpurious = RTC_EOL;
				return FC_INPUT_EMPTY;
				
			case RET_END_OF_LINE:
			  t4P.cbIn = (WORD)ValidChangeVector ((LPSHORT) lpbChange, (WORD)xExt);
        if (!t4P.cbIn)
        	t4C.wRet = RET_DECODE_ERR; // consumer lied!
        else
        {
          // Adjust counters.
					fcCount.cTotalGood++;
					if (wBad) ResetBad();
					cSpurious = 0;
				}
				break;
				
			default: DEBUGCHK (FALSE);
		}

		if (t4C.wRet == RET_DECODE_ERR)
		{
			DEBUGCHK (f2D && nTypeIn != LRAW_DATA);
			if (nTypeIn == MMR_DATA)
				return FC_DECODE_ERR;
			wBad++;
			fcCount.cTotalBad++;

#ifdef DEBUG
      {
      	// Substitute all black line.
	     	LPWORD lpwChange = (LPWORD) lpbChange;
			  *lpwChange++ = 0;
			  *lpwChange++ = xExt;
			  *lpwChange++ = xExt;
			  *lpwChange++ = xExt;
			  *lpwChange++ = xExt;
			  *lpwChange++ = 0xFFFF;
			  *lpwChange++ = 0xFFFF;
			  t4P.cbIn = 4;
			 }
#else
	    // Replicate previous line
	    t4P.cbIn = (WORD)ValidChangeVector ((LPSHORT) lpbRef, (WORD)xExt);   
	   	DEBUGCHK (t4P.cbIn);
	    _fmemcpy (lpbChange, lpbRef, t4P.cbIn + CHANGE_SLACK);
#endif

		}

producer_phase:

    lpbBegOut = t4P.lpbOut;
		Producer (&t4P);
		lpbufOut->wLengthData += (WORD)(t4P.lpbOut - lpbBegOut);

		// Check if output is full.
		if (t4P.wRet == RET_OUTPUT_FULL)
			return FC_OUTPUT_FULL;

// EOL:
		SwapChange();
		EndLine ();
		
	} // while (1)

	// C8 thinks we can get here, but I know better.
	DEBUGCHK (FALSE); 
	return FC_DECODE_ERR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\bmrotate.c ===
/*
**  Copyright (c) 1992 Microsoft Corporation
*/

/*============================================================================
// FILE                     RPBMVER.C
//
// MODULE                   Jumbo Cartridge Code
//
// PURPOSE                  This file contains Vertical Bitmap Code
//
// DESCRIBED IN             This module is described in jumbo .
//
// MNEMONICS                Standard Hungarian
//
// HISTORY
//
// 05/26/92  RodneyK        Original implimentation:
// 05/11/94  RajeevD        Adapted for unified.
//==========================================================================*/

#include <windows.h>
#include "jtypes.h"         /* Jumbo type definitions.                */

/*--------------------------------------------------------------------------*/

USHORT WINAPI RP_BITMAPV
(
   USHORT  usRow,             /* Row to start Bitmap             */
   USHORT  usCol,             /* Column to Start Bitmap          */
   UBYTE   ubTopPadBits,      /* Bits to skip in the data stream */
   USHORT  usHeight,          /* Number of bits to draw          */
   UBYTE FAR  *ubBitmapData,  /* Data to draw                    */
   LPBYTE  lpbOut,            // output band buffer
   UINT    cbLine             // bytes per scan line
)
/*
//
//  PURPOSE               This function draws vertical bitmaps in source
//                        copy mode.
//
//
// ASSUMPTIONS &          The code assumes nothing other than it gets valid
// ASSERTIONS             input data.
//
//
// INTERNAL STRUCTURES    No complex internal data structure are used
//
// UNRESOLVED ISSUES      None
//
//
//--------------------------------------------------------------------------*/
{
   UBYTE     *pubDest;
   SHORT     sIterations;
   USHORT    usReturnVal;
   USHORT    us1stByte;
   UBYTE     ubMask;
   UBYTE     ubNotMask;
   UBYTE     ubRotator;
   UBYTE     ubCurByte;


   usReturnVal = (ubTopPadBits + usHeight + 7) >> 3;

   pubDest = (UBYTE *) lpbOut + (usRow * cbLine) + (usCol >> 3);
   ubMask  = 0x80 >> (usCol & 7);
   ubNotMask = ~ubMask;

   ubCurByte = *ubBitmapData++;
   us1stByte = 8-ubTopPadBits;

   ubRotator = 0x80 >> ubTopPadBits;
   switch (us1stByte)
   {
      case 8 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               if ( !(--usHeight) ) break;  
      case 7 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               if ( !(--usHeight) ) break;  
      case 6 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               if ( !(--usHeight) ) break;
      case 5 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               if ( !(--usHeight) ) break;
      case 4 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               if ( !(--usHeight) ) break;
      case 3 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               if ( !(--usHeight) ) break;
      case 2 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               if ( !(--usHeight) ) break;
      case 1 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
               --usHeight;
      default:
               break;
   }

   ubCurByte = *ubBitmapData++;
   sIterations = usHeight >> 3;

   while (--sIterations >= 0)
   {
      /* 1 */
      *pubDest = (0x80 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;
      /* 2 */
      *pubDest = (0x40 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;
      /* 3 */
      *pubDest = (0x20 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;
      /* 4 */
      *pubDest = (0x10 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;
      /* 5 */
      *pubDest = (0x08 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;
      /* 6 */
      *pubDest = (0x04 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;
      /* 7 */
      *pubDest = (0x02 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;
      /* 8 */
      *pubDest = (0x01 & ubCurByte) ?
                 (*pubDest & ubNotMask) | ubMask :
                 (*pubDest & ubNotMask);
      pubDest -= cbLine;

      ubCurByte = *ubBitmapData++;
   }

   ubRotator = 0x80;
   switch (usHeight & 0x07)
   {
      case 7 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
      case 6 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
      case 5 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
      case 4 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
      case 3 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
      case 2 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
      case 1 :
               *pubDest = (ubRotator & ubCurByte) ?
                          (*pubDest & ubNotMask) | ubMask :
                          (*pubDest & ubNotMask);
               pubDest -= cbLine;
               ubRotator >>= 1;
      default:
               break;
   }

   return (usReturnVal); /* Return the number of byte in the list */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\brushpat.c ===
/*==============================================================================
This file defines 8x8 pixel monochrome patterns for standard GDI brushes.  
The patterns are for 6 hatched brushes and 65 gray levels of solid brushes.

05-30-93     RajeevD     Created.
02-15-94     RajeevD     Integrated into unified resource executor.
05-12-94     RajeevD     Ported to C for Win32.
==============================================================================*/

#define DB(b7,b6,b5,b4,b3,b2,b1,b0)\
  ((b7<<7)|(b6<<6)|(b5<<5)|(b4<<4)|(b3<<3)|(b2<<2)|(b1<<1)|b0)

const unsigned char BrushPat[71][8] = 
{
	// HS_HORIZONTAL
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),

	// HS_VERTICAL
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,1,1,0,0,0),

	// HS_FDIAGONAL
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,0,1,1,0,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,0,0,1,1),
	DB(1,0,0,0,0,0,0,1),
	DB(1,1,0,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,0,1,1,0,0,0,0),

	// HS_BDIAGONAL
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,1,1,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(1,1,0,0,0,0,0,0),
	DB(1,0,0,0,0,0,0,1),
	DB(0,0,0,0,0,0,1,1),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,1,1,0,0),

	// HS_CROSS
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,1,1,0,0,0),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,0,1,1,0,0,0),

	// HS_DIAGCROSS 
	DB(0,0,0,1,1,0,0,0),
	DB(0,0,1,1,1,1,0,0),
	DB(0,1,1,0,0,1,1,0),
	DB(1,1,0,0,0,0,1,1),
	DB(1,0,0,0,0,0,0,1),
	DB(1,1,0,0,0,0,1,1),
	DB(0,1,1,0,0,1,1,0),
	DB(0,0,1,1,1,1,0,0),

	// BS_SOLID[0,0h]
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[0,1,h]
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,1,0,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[02h]
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,1,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,1,0,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[03h]
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,1,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[04h]
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[05h]
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,1,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[06h]
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,1,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,1,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[07h]
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,1,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[08h]
	DB(0,0,0,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[09h]
	DB(0,0,0,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[0Ah]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[0Bh]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[0Ch]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,0,0,0,0),

	// BS_SOLID[0Dh]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,0,1,0,0),

	// BS_SOLID[0Eh]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,1,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,0,1,0,0),

	// BS_SOLID[0Fh]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,1,0,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,0,1,1,0),

	// BS_SOLID[1,0h]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,0,1,1,0),

	// BS_SOLID[1,1,h]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,2h]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,3h]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,4h]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,5h]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,6h]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,7h]
	DB(0,0,0,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,1,0,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,8h]
	DB(0,1,0,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,1,0,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,9h]
	DB(0,1,0,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,Ah]
	DB(0,1,1,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,0,1,1,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,Bh]
	DB(0,1,1,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,Ch]
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,0),

	// BS_SOLID[1,Dh]
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,0,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),

	// BS_SOLID[1,Eh]
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(0,0,0,0,1,1,1,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),

	// BS_SOLID[1,Fh]
	DB(1,1,1,0,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),

	// BS_SOLID[20h]
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),

	// BS_SOLID[21,h]
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),

	// BS_SOLID[22h]
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),

	// BS_SOLID[23h]
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[24h]
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[25h]
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,1),
	DB(1,0,0,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[26h]
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,1),
	DB(1,0,0,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[27h]
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,1),
	DB(1,0,1,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[28h]
	DB(1,1,1,1,1,0,1,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,1),
	DB(1,0,1,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[29h]
	DB(1,1,1,1,1,0,1,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[2Ah]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[2Bh]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[2Ch]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,0,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[2Dh]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,0),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[2Eh]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),

	// BS_SOLID[2Fh]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),

	// BS_SOLID[30h]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),

	// BS_SOLID[31,h]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(1,0,1,1,1,1,1,1),

	// BS_SOLID[32h]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,0,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(1,0,1,1,1,1,1,1),

	// BS_SOLID[33h]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,0,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[34h]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[35h]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[36h]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(0,0,0,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[37h]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,0,0,0,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[38h]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[39h]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,0,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[3Ah]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,0,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,0,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[3Bh]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,0,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[3Ch]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,0,0,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[3Dh]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,0,0,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,0,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[3Eh]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,0,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,0,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[3Fh]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,0,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),

	// BS_SOLID[40h]
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
	DB(1,1,1,1,1,1,1,1),
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\faxcodec\t4core.c ===
/* Copyright Microsoft Corp 1993, 1994
 *
 *      t4core.c
 *
 *      MH/MR/MMR/LRAW conversion utilities
 *
 *      Created:        12/06/93
 *      Author:         mikegins
 *      Reviewer:       rajeevd
 */

/* WARNING: This code may not be machine byte order independent, since it uses
   WORD manipulations
 */

/* On Change->X, need to return correct lpbOut */
/* On X->Change, need to return correct lpbOut, lpbIn, cbIn */

/*  Change->LRAW : Takes change vectors, outputs LRAW.
    LRAW->Change : Takes LRAW, outputs change vectors.
    Change->MMR  : Takes change vectors, generates MMR.  On END_OF_PAGE,
	flushes and appends EOFB.
    MMR->Change  : Takes MMR, generates change vectors.  On EOFB, returns
	END_OF_PAGE.
    MH->Change   : Takes change vectors, generates EOL/MH/EOL/MH/etc.  On
	END_OF_PAGE, flushes output.
    Change->MH   : Takes <optional garbage>/EOL/MH/EOL/MH/etc.  Returns EOL
	after MH line decoded.
    MR->Change   : Takes change vectors, generates EOL/MR/EOL/MR/etc.  On
	END_OF_PAGE, flushes output.
    Change->MR   : Takes <optional garbage>/EOL/MR/EOL/MR/etc.  Returns EOL
	after MR line decoded.
 */
#include <ifaxos.h>
#include "context.hpp"

#define  MH_OUTPUT_SLACK 32 // Enough bytes for anything to be output!
#define MMR_OUTPUT_SLACK 32 // Enough bytes for anything to be output!

#define SIZE_MKUP 0x8000
#define SIZE_SPEC 0x4000 /* size -> special instruction */
#define S_ZERO    0x4000
#define S_ERR     0x4001
#define S_EOL     0x4002
#define SIZE_MASK 0x3fff

static WORD dbg=0;

typedef struct
{
	WORD data;
  WORD bitsused;
}
	RUNINFO, FAR *LPRUNINFO;

RUNINFO EOFB = {0x0800,12}; /* Must repeat twice */
RUNINFO PASS = {0x0008,4};
RUNINFO HORIZ = {0x0004,3};

RUNINFO VERT[7] =
{
	{0x0060, 0x07}, {0x0030, 0x06}, {0x0006, 0x03}, {0x0001, 0x01},
  {0x0002, 0x03}, {0x0010, 0x06}, {0x0020, 0x07}
};

RUNINFO WhiteMkup[40] =
{
    {0x001B, 0x05}, {0x0009, 0x05}, {0x003A, 0x06}, {0x0076, 0x07},
    {0x006C, 0x08}, {0x00EC, 0x08}, {0x0026, 0x08}, {0x00A6, 0x08},
    {0x0016, 0x08}, {0x00E6, 0x08}, {0x0066, 0x09}, {0x0166, 0x09},
    {0x0096, 0x09}, {0x0196, 0x09}, {0x0056, 0x09}, {0x0156, 0x09},
    {0x00D6, 0x09}, {0x01D6, 0x09}, {0x0036, 0x09}, {0x0136, 0x09},
    {0x00B6, 0x09}, {0x01B6, 0x09}, {0x0032, 0x09}, {0x0132, 0x09},
    {0x00B2, 0x09}, {0x0006, 0x06}, {0x01B2, 0x09}, {0x0080, 0x0B},
    {0x0180, 0x0B}, {0x0580, 0x0B}, {0x0480, 0x0C}, {0x0C80, 0x0C},
    {0x0280, 0x0C}, {0x0A80, 0x0C}, {0x0680, 0x0C}, {0x0E80, 0x0C},
    {0x0380, 0x0C}, {0x0B80, 0x0C}, {0x0780, 0x0C}, {0x0F80, 0x0C}
};

RUNINFO WhiteTCode[64] =
{
    {0x00AC, 0x08}, {0x0038, 0x06}, {0x000E, 0x04}, {0x0001, 0x04},
    {0x000D, 0x04}, {0x0003, 0x04}, {0x0007, 0x04}, {0x000F, 0x04},
    {0x0019, 0x05}, {0x0005, 0x05}, {0x001C, 0x05}, {0x0002, 0x05},
    {0x0004, 0x06}, {0x0030, 0x06}, {0x000B, 0x06}, {0x002B, 0x06},
    {0x0015, 0x06}, {0x0035, 0x06}, {0x0072, 0x07}, {0x0018, 0x07},
    {0x0008, 0x07}, {0x0074, 0x07}, {0x0060, 0x07}, {0x0010, 0x07},
    {0x000A, 0x07}, {0x006A, 0x07}, {0x0064, 0x07}, {0x0012, 0x07},
    {0x000C, 0x07}, {0x0040, 0x08}, {0x00C0, 0x08}, {0x0058, 0x08},
    {0x00D8, 0x08}, {0x0048, 0x08}, {0x00C8, 0x08}, {0x0028, 0x08},
    {0x00A8, 0x08}, {0x0068, 0x08}, {0x00E8, 0x08}, {0x0014, 0x08},
    {0x0094, 0x08}, {0x0054, 0x08}, {0x00D4, 0x08}, {0x0034, 0x08},
    {0x00B4, 0x08}, {0x0020, 0x08}, {0x00A0, 0x08}, {0x0050, 0x08},
    {0x00D0, 0x08}, {0x004A, 0x08}, {0x00CA, 0x08}, {0x002A, 0x08},
    {0x00AA, 0x08}, {0x0024, 0x08}, {0x00A4, 0x08}, {0x001A, 0x08},
    {0x009A, 0x08}, {0x005A, 0x08}, {0x00DA, 0x08}, {0x0052, 0x08},
    {0x00D2, 0x08}, {0x004C, 0x08}, {0x00CC, 0x08}, {0x002C, 0x08}, 
};

RUNINFO BlackMkup[40] =
{
    {0x03C0, 0x0A}, {0x0130, 0x0C}, {0x0930, 0x0C}, {0x0DA0, 0x0C},
    {0x0CC0, 0x0C}, {0x02C0, 0x0C}, {0x0AC0, 0x0C}, {0x06C0, 0x0D},
    {0x16C0, 0x0D}, {0x0A40, 0x0D}, {0x1A40, 0x0D}, {0x0640, 0x0D},
    {0x1640, 0x0D}, {0x09C0, 0x0D}, {0x19C0, 0x0D}, {0x05C0, 0x0D},
    {0x15C0, 0x0D}, {0x0DC0, 0x0D}, {0x1DC0, 0x0D}, {0x0940, 0x0D},
    {0x1940, 0x0D}, {0x0540, 0x0D}, {0x1540, 0x0D}, {0x0B40, 0x0D},
    {0x1B40, 0x0D}, {0x04C0, 0x0D}, {0x14C0, 0x0D}, {0x0080, 0x0B},
    {0x0180, 0x0B}, {0x0580, 0x0B}, {0x0480, 0x0C}, {0x0C80, 0x0C},
    {0x0280, 0x0C}, {0x0A80, 0x0C}, {0x0680, 0x0C}, {0x0E80, 0x0C},
    {0x0380, 0x0C}, {0x0B80, 0x0C}, {0x0780, 0x0C}, {0x0F80, 0x0C}
};

RUNINFO BlackTCode[64] =
{
    {0x03B0, 0x0A}, {0x0002, 0x03}, {0x0003, 0x02}, {0x0001, 0x02},
    {0x0006, 0x03}, {0x000C, 0x04}, {0x0004, 0x04}, {0x0018, 0x05},
    {0x0028, 0x06}, {0x0008, 0x06}, {0x0010, 0x07}, {0x0050, 0x07},
    {0x0070, 0x07}, {0x0020, 0x08}, {0x00E0, 0x08}, {0x0030, 0x09},
    {0x03A0, 0x0A}, {0x0060, 0x0A}, {0x0040, 0x0A}, {0x0730, 0x0B},
    {0x00B0, 0x0B}, {0x01B0, 0x0B}, {0x0760, 0x0B}, {0x00A0, 0x0B},
    {0x0740, 0x0B}, {0x00C0, 0x0B}, {0x0530, 0x0C}, {0x0D30, 0x0C},
    {0x0330, 0x0C}, {0x0B30, 0x0C}, {0x0160, 0x0C}, {0x0960, 0x0C},
    {0x0560, 0x0C}, {0x0D60, 0x0C}, {0x04B0, 0x0C}, {0x0CB0, 0x0C},
    {0x02B0, 0x0C}, {0x0AB0, 0x0C}, {0x06B0, 0x0C}, {0x0EB0, 0x0C},
    {0x0360, 0x0C}, {0x0B60, 0x0C}, {0x05B0, 0x0C}, {0x0DB0, 0x0C},
    {0x02A0, 0x0C}, {0x0AA0, 0x0C}, {0x06A0, 0x0C}, {0x0EA0, 0x0C},
    {0x0260, 0x0C}, {0x0A60, 0x0C}, {0x04A0, 0x0C}, {0x0CA0, 0x0C},
    {0x0240, 0x0C}, {0x0EC0, 0x0C}, {0x01C0, 0x0C}, {0x0E40, 0x0C},
    {0x0140, 0x0C}, {0x01A0, 0x0C}, {0x09A0, 0x0C}, {0x0D40, 0x0C},
    {0x0340, 0x0C}, {0x05A0, 0x0C}, {0x0660, 0x0C}, {0x0E60, 0x0C}
};

// Common States
#define W    0
#define W0  50
#define W1  51
#define B  108
#define B0 109
#define B1 110

#define M SIZE_MKUP

typedef struct
{
	WORD nextstate;
  WORD size;
}
	nextinfo_t;

typedef struct
{
	nextinfo_t nextinf[4];
}
	State;

State MHStates[229] = {
/*   0 : W               */ {  1,     0,   2,     0,   3,     0,   4,     0}, 
/*   1 : W00             */ {  5,     0,   6,     0,   7,     0,   8,     0}, 
/*   2 : W10             */ {  B,     3,   9,     0,  10,     0,   B,     4}, 
/*   3 : W01             */ { 11,     0,  12,     0,  13,     0,   B,     2}, 
/*   4 : W11             */ {  B,     5,   B,     6,  14,     0,   B,     7}, 
/*   5 : W0000           */ { 15,     0,  16,     0,  17,     0,   B,    13}, 
/*   6 : W0010           */ {  B,    12,  18,     0,  19,     0,  20,     0}, 
/*   7 : W0001           */ { 21,     0,  22,     0,  23,     0,   B,     1}, 
/*   8 : W0011           */ { 24,     0,  B0,    10,  25,     0,  B1,    10}, 
/*   9 : W1010           */ { B0,     9,   B,    16,  B1,     9,   B,    17}, 
/*  10 : W1001           */ { W0, M|128,  B0,     8,  W1, M|128,  B1,     8}, 
/*  11 : W0100           */ { B0,    11,  26,     0,  B1,    11,  27,     0}, 
/*  12 : W0110           */ {  W,M|1664,  28,     0,  29,     0,  30,     0}, 
/*  13 : W0101           */ { 31,     W,  32,     0,  33,     0,   W, M|192}, 
/*  14 : W1101           */ {  B,    14,  W0,  M|64,   B,    15,  W1,  M|64}, 
/*  15 : W000000         */ { 34,     0,   B,    29,  35,     0,   B,    30}, 
/*  16 : W000010         */ { B0,    23,   B,    47,  B1,    23,   B,    48}, 
/*  17 : W000001         */ {  B,    45,  B0,    22,   B,    46,  B1,    22}, 
/*  18 : W001010         */ {  B,    39,   B,    41,   B,    40,   B,    42}, 
/*  19 : W001001         */ {  B,    53,  B0,    26,   B,    54,  B1,    26}, 
/*  20 : W001011         */ {  B,    43,  B0,    21,   B,    44,  B1,    21}, 
/*  21 : W000100         */ { B0,    20,   B,    33,  B1,    20,   B,    34}, 
/*  22 : W000110         */ { B0,    19,   B,    31,  B1,    19,   B,    32}, 
/*  23 : W000101         */ {  B,    35,   B,    37,   B,    36,   B,    38}, 
/*  24 : W001100         */ { B0,    28,   B,    61,  B1,    28,   B,    62}, 
/*  25 : W001101         */ {  B,    63,   W, M|320,   B,S_ZERO,   W, M|384}, 
/*  26 : W010010         */ { B0,    27,   B,    59,  B1,    27,   B,    60}, 
/*  27 : W010011         */ { 36,     0,  B0,    18,  37,     0,  B1,    18}, 
/*  28 : W011010         */ {  W, M|576,  38,     0,  39,     0,  40,     0}, 
/*  29 : W011001         */ {  W, M|448,  41,     0,   W, M|512,   W, M|640}, 
/*  30 : W011011         */ { 42,     0,  W0, M|256,  43,     0,  W1, M|256}, 
/*  31 : W010100         */ { B0,    24,   B,    49,  B1,    24,   B,    50}, 
/*  32 : W010110         */ {  B,    55,   B,    57,   B,    56,   B,    58}, 
/*  33 : W010101         */ {  B,    51,  B0,    25,   B,    52,  B1,    25}, 
/*  34 : W00000000       */ { 44,     0, 216, S_ERR, 216, S_ERR, 216, S_ERR}, 
/*  35 : W00000001       */ { 46,     0,  47,     0,  48,     0,  49,     0}, 
/*  36 : W01001100       */ { W0,M|1472,  W0,M|1536,  W1,M|1472,  W1,M|1536}, 
/*  37 : W01001101       */ { W0,M|1600,  W0,M|1728,  W1,M|1600,  W1,M|1728}, 
/*  38 : W01101010       */ { W0, M|960,  W0,M|1024,  W1, M|960,  W1,M|1024}, 
/*  39 : W01101001       */ { W0, M|832,  W0, M|896,  W1, M|832,  W1, M|896}, 
/*  40 : W01101011       */ { W0,M|1088,  W0,M|1152,  W1,M|1088,  W1,M|1152}, 
/*  41 : W01100110       */ { W0, M|704,  W0, M|768,  W1, M|704,  W1, M|768}, 
/*  42 : W01101100       */ { W0,M|1216,  W0,M|1280,  W1,M|1216,  W1,M|1280}, 
/*  43 : W01101101       */ { W0,M|1344,  W0,M|1408,  W1,M|1344,  W1,M|1408}, 
/*  44 : W0000000000     */ { 45,     0, 216, S_ERR, 216, S_ERR, 216, S_ERR}, 
/*  45 : W00000000000    */ { 45,     0,   W, S_EOL,   W, S_EOL,   W, S_EOL}, 
/*  46 : W0000000100     */ { W0,M|1792,   W,M|1984,  W1,M|1792,   W,M|2048}, 
/*  47 : W0000000110     */ { W0,M|1856,  W0,M|1920,  W1,M|1856,  W1,M|1920}, 
/*  48 : W0000000101     */ {  W,M|2112,   W,M|2240,   W,M|2176,   W,M|2304}, 
/*  49 : W0000000111     */ {  W,M|2368,   W,M|2496,   W,M|2432,   W,M|2560}, 
/*  50 : W0              */ { 52,     0,  53,     0,  54,     0,  55,     0}, 
/*  51 : W1              */ { 56,     0,  57,     0,  58,     0,  59,     0}, 
/*  52 : W000            */ { 60,     0,  61,     0,  62,     0,  63,     0}, 
/*  53 : W010            */ {  B,    11,  64,     0,  65,     0,  66,     0}, 
/*  54 : W001            */ { 67,     0,  68,     0,  69,     0,   B,    10}, 
/*  55 : W011            */ { 70,     0,  B0,     2,  71,     0,  B1,     2}, 
/*  56 : W100            */ { B0,     3,   W, M|128,  B1,     3,   B,     8}, 
/*  57 : W110            */ { B0,     5,  72,     0,  B1,     5,   W,  M|64}, 
/*  58 : W101            */ {  B,     9,  B0,     4,  73,     0,  B1,     4}, 
/*  59 : W111            */ { B0,     6,  B0,     7,  B1,     6,  B1,     7}, 
/*  60 : W00000          */ { 74,     0,  75,     0,  76,     0,   B,    22}, 
/*  61 : W00010          */ {  B,    20,  77,     0,  78,     0,  79,     0}, 
/*  62 : W00001          */ {  B,    23,  B0,    13,  80,     0,  B1,    13}, 
/*  63 : W00011          */ {  B,    19,  B0,     1,  81,     0,  B1,     1}, 
/*  64 : W01010          */ {  B,    24,  82,     0,  83,     0,   B,    25}, 
/*  65 : W01001          */ {  B,    27,  84,     0,  85,     0,   B,    18}, 
/*  66 : W01011          */ { 86,     0,  W0, M|192,  87,     0,  W1, M|192}, 
/*  67 : W00100          */ { B0,    12,  88,     0,  B1,    12,   B,    26}, 
/*  68 : W00110          */ {  B,    28,  89,     0,  90,     0,  91,     0}, 
/*  69 : W00101          */ { 92,     0,  93,     0,  94,     0,   B,    21}, 
/*  70 : W01100          */ { W0,M|1664,  95,     0,  W1,M|1664,  96,     0}, 
/*  71 : W01101          */ { 97,     0,  98,     0,  99,     0,   0, M|256}, 
/*  72 : W11010          */ { B0,    14,  B0,    15,  B1,    14,  B1,    15}, 
/*  73 : W10101          */ { B0,    16,  B0,    17,  B1,    16,  B1,    17}, 
/*  74 : W0000000        */ {100,     0, 101,     0, 216, S_ERR, 102,     0}, 
/*  75 : W0000010        */ { B0,    45,  B0,    46,  B1,    45,  B1,    46}, 
/*  76 : W0000001        */ { B0,    29,  B0,    30,  B1,    29,  B1,    30}, 
/*  77 : W0001010        */ { B0,    35,  B0,    36,  B1,    35,  B1,    36}, 
/*  78 : W0001001        */ { B0,    33,  B0,    34,  B1,    33,  B1,    34}, 
/*  79 : W0001011        */ { B0,    37,  B0,    38,  B1,    37,  B1,    38}, 
/*  80 : W0000101        */ { B0,    47,  B0,    48,  B1,    47,  B1,    48}, 
/*  81 : W0001101        */ { B0,    31,  B0,    32,  B1,    31,  B1,    32}, 
/*  82 : W0101010        */ { B0,    51,  B0,    52,  B1,    W1,  B1,    52}, 
/*  83 : W0101001        */ { B0,    49,  B0,    W0,  B1,    49,  B1,    W0}, 
/*  84 : W0100110        */ {  W,M|1472,   W,M|1600,   W,M|1536,   W,M|1728}, 
/*  85 : W0100101        */ { B0,    59,  B0,    60,  B1,    59,  B1,    60}, 
/*  86 : W0101100        */ { B0,    55,  B0,    56,  B1,    55,  B1,    56}, 
/*  87 : W0101101        */ { B0,    57,  B0,    58,  B1,    57,  B1,    58}, 
/*  88 : W0010010        */ { B0,    53,  B0,    54,  B1,    53,  B1,    54}, 
/*  89 : W0011010        */ { B0,    63,  B0,S_ZERO,  B1,    63,  B1,S_ZERO}, 
/*  90 : W0011001        */ { B0,    61,  B0,    62,  B1,    61,  B1,    62}, 
/*  91 : W0011011        */ { W0, M|320,  W0, M|384,  W1, M|320,  W1, M|384}, 
/*  92 : W0010100        */ { B0,    39,  B0,    40,  B1,    39,  B1,    40}, 
/*  93 : W0010110        */ { B0,    43,  B0,    44,  B1,    43,  B1,    44}, 
/*  94 : W0010101        */ { B0,    41,  B0,    42,  B1,    41,  B1,    42}, 
/*  95 : W0110010        */ { W0, M|448,  W0, M|512,  W1, M|448,  W1, M|512}, 
/*  96 : W0110011        */ {  W, M|704,  W0, M|640,   W, M|768,  W1, M|640}, 
/*  97 : W0110100        */ { W0, M|576,   W, M|832,  W1, M|576,   W, M|896}, 
/*  98 : W0110110        */ {  W,M|1216,   W,M|1344,   W,M|1280,   W,M|1408}, 
/*  99 : W0110101        */ {  W, M|960,   W,M|1088,   W,M|1024,   W,M|1152}, 
/* 100 : W000000000      */ { 45,     0, 216, S_ERR, 216, S_ERR, 216, S_ERR}, 
/* 101 : W000000010      */ {  W,M|1792, 103,     0, 104,     0, 105,     0}, 
/* 102 : W000000011      */ {  W,M|1856, 106,     0,   W,M|1920, 107,     0}, 
/* 103 : W00000001010    */ { W0,M|2112,  W0,M|2176,  W1,M|2112,  W1,M|2176}, 
/* 104 : W00000001001    */ { W0,M|1984,  W0,M|2048,  W1,M|1984,  W1,M|2048}, 
/* 105 : W00000001011    */ { W0,M|2240,  W0,M|2304,  W1,M|2240,  W1,M|2304}, 
/* 106 : W00000001110    */ { W0,M|2368,  W0,M|2432,  W1,M|2368,  W1,M|2432}, 
/* 107 : W00000001111    */ { W0,M|2496,  W0,M|2560,  W1,M|2496,  W1,M|2560}, 
/* 108 : B               */ {111,     0,   W,     3, 112,     0,   W,     2}, 
/* 109 : B0              */ {113,     0,   W,     1, 114,     0,   W,     4}, 
/* 110 : B1              */ { W0,     3,  W0,     2,  W1,     3,  W1,     2}, 
/* 111 : B00             */ {115,     0,   W,     6, 116,     0,   W,     5}, 
/* 112 : B01             */ { W0,     1,  W0,     4,  W1,     1,  W1,     4}, 
/* 113 : B000            */ {117,     0, 118,     0, 119,     0,   W,     7}, 
/* 114 : B001            */ { W0,     6,  W0,     5,  W1,     6,  W1,     5}, 
/* 115 : B0000           */ {120,     0, 121,     0, 122,     0, 123,     0}, 
/* 116 : B0001           */ {  W,     9,  W0,     7,   W,     8,  W1,     7}, 
/* 117 : B00000          */ {124,     0, 125,     0, 126,     0, 127,     0}, 
/* 118 : B00010          */ { W0,     9,  W0,     8,  W1,     9,  W1,     8}, 
/* 119 : B00001          */ {  W,    10, 128,     0,   W,    11,   W,    12}, 
/* 120 : B000000         */ {129,     0, 130,     0, 131,     0, 132,     0}, 
/* 121 : B000010         */ { W0,    10,  W0,    11,  W1,    10,  W1,    11}, 
/* 122 : B000001         */ {  W,    13, 133,     0, 134,     0,   W,    14}, 
/* 123 : B000011         */ {135,     0,  W0,    12, 136,     0,  W1,    12}, 
/* 124 : B0000000        */ {137,     0, 138,     0, 216, S_ERR, 139,     0}, 
/* 125 : B0000010        */ { W0,    13, 140,     0,  W1,    13, 141,     0}, 
/* 126 : B0000001        */ {142,     0, 143,     0, 144,     0, 145,     0}, 
/* 127 : B0000011        */ {146,     0,  W0,    14, 147,     0,  W1,    14}, 
/* 128 : B0000110        */ {  W,    15, 148,     0, 149,     0, 150,     0}, 
/* 129 : B00000000       */ {151,     0, 216, S_ERR, 216, S_ERR, 216, S_ERR}, 
/* 130 : B00000010       */ {  W,    18, 152,     0, 153,     0, 154,     0}, 
/* 131 : B00000001       */ {155,     0, 156,     0, 157,     0, 158,     0}, 
/* 132 : B00000011       */ {159,     0, 160,     0, 161,     0,   B,  M|64}, 
/* 133 : B00000110       */ {  W,    17, 162,     0, 163,     0, 164,     0}, 
/* 134 : B00000101       */ {165,     0, 166,     0, 167,     0,   W,    16}, 
/* 135 : B00001100       */ { W0,    15, 168,     0,  W1,    15, 169,     0},  
/* 136 : B00001101       */ {170,     0, 171,     0, 172,     0,   W,S_ZERO}, 
/* 137 : B000000000      */ {173,     0, 216, S_ERR, 216, S_ERR, 216, S_ERR}, 
/* 138 : B000000010      */ {  B,M|1792, 174,     0, 175,     0, 176,     0}, 
/* 139 : B000000011      */ {  B,M|1856, 177,     0,   B,M|1920, 178,     0}, 
/* 140 : B000001010      */ {  W,    23, 179,     0, 180,     0, 181,     0}, 
/* 141 : B000001011      */ {182,     0,  W0,    16, 183,     0,  W1,    16}, 
/* 142 : B000000100      */ { W0,    18, 184,     0,  W1,    18, 185,     0}, 
/* 143 : B000000110      */ {  W,    25, 186,     0, 187,     0, 188,     0}, 
/* 144 : B000000101      */ {189,     0, 190,     0, 191,     0,   W,    24}, 
/* 145 : B000000111      */ {192,     0,  B0,  M|64, 193,     0,  B1,  M|64}, 
/* 146 : B000001100      */ { W0,    17, 194,     0,  W1,    17, 195,     0}, 
/* 147 : B000001101      */ {196,     0, 197,     0, 198,     0,   W,    22}, 
/* 148 : B000011010      */ {  W,    20, 199,     0, 200,     0, 201,     0}, 
/* 149 : B000011001      */ {202,     0, 203,     0, 204,     0,   W,    19}, 
/* 150 : B000011011      */ {  W,    21,  W0,S_ZERO, 205,     0,  W1,S_ZERO}, 
/* 151 : B0000000000     */ {173,     0, 216, S_ERR,   W, S_EOL, 216, S_ERR}, 
/* 152 : B0000001010     */ {  W,    56, 206,     0, 207,     0,   W,    59}, 
/* 153 : B0000001001     */ {  W,    52, 208,     0, 209,     0,   W,    55}, 
/* 154 : B0000001011     */ {  W,    60,  W0,    24, 210,     0,  W1,    24}, 
/* 155 : B0000000100     */ { B0,M|1792,   B,M|1984,  B1,M|1792,   B,M|2048}, 
/* 156 : B0000000110     */ { B0,M|1856,  B0,M|1920,  B1,M|1856,  B1,M|1920}, 
/* 157 : B0000000101     */ {  B,M|2112,   B,M|2240,   B,M|2176,   B,M|2304}, 
/* 158 : B0000000111     */ {  B,M|2368,   B,M|2496,   B,M|2432,   B,M|2560}, 
/* 159 : B0000001100     */ { W0,    25, 211,     0,  W1,    25,   B, M|320}, 
/* 160 : B0000001110     */ {  W,    54, 212,     0, 213,     0, 214,     0}, 
/* 161 : B0000001101     */ {  B, M|384, 215,     0,   B, M|448,   W,    53}, 
/* 162 : B0000011010     */ {  W,    30,   W,    32,   W,    31,   W,    33}, 
/* 163 : B0000011001     */ {  W,    48,   W,    62,   W,    49,   W,    63}, 
/* 164 : B0000011011     */ {  W,    40,  W0,    22,   W,    41,  W1,    22}, 
/* 165 : B0000010100     */ { W0,    23,   W,    W0,  51,    23,   W,    51}, 
/* 166 : B0000010110     */ {  W,    57,   W,    61,   W,    58,   B, M|256}, 
/* 167 : B0000010101     */ {  W,    44,   W,    46,   W,    45,   W,    47}, 
/* 168 : B0000110010     */ {  B, M|128,   W,    26,   B, M|192,   W,    27}, 
/* 169 : B0000110011     */ {  W,    28,  W0,    19,   W,    29,  W1,    19}, 
/* 170 : B0000110100     */ { W0,    20,   W,    34,  W1,    20,   W,    35}, 
/* 171 : B0000110110     */ { W0,    21,   W,    42,  W1,    21,   W,    43}, 
/* 172 : B0000110101     */ {  W,    36,   W,    38,   W,    37,   W,    39}, 
/* 173 : B00000000000    */ {173,     0,   W, S_EOL,   W, S_EOL,   W, S_EOL}, 
/* 174 : B00000001010    */ { B0,M|2112,  B0,M|2176,  B1,M|2112,  B1,M|2176}, 
/* 175 : B00000001001    */ { B0,M|1984,  B0,M|2048,  B1,M|1984,  B1,M|2048}, 
/* 176 : B00000001011    */ { B0,M|2240,  B0,M|2304,  B1,M|2240,  B1,M|2304}, 
/* 177 : B00000001110    */ { B0,M|2368,  B0,M|2432,  B1,M|2368,  B1,M|2432}, 
/* 178 : B00000001111    */ { B0,M|2496,  B0,M|2560,  B1,M|2496,  B1,M|2560}, 
/* 179 : B00000101010    */ { W0,    44,  W0,    45,  W1,    44,  W1,    45}, 
/* 180 : B00000101001    */ { W0,    50,  W0,    51,  W1,    50,  W1,    51}, 
/* 181 : B00000101011    */ { W0,    46,  W0,    47,  W1,    46,  W1,    47}, 
/* 182 : B00000101100    */ { W0,    57,  W0,    58,  W1,    57,  W1,    58}, 
/* 183 : B00000101101    */ { W0,    61,  B0, M|256,  W1,    61,  B1, M|256}, 
/* 184 : B00000010010    */ { W0,    52,   B, M|640,  W1,    52,   B, M|704}, 
/* 185 : B00000010011    */ {  B, M|768,  W0,    55,   B, M|832,  W1,    55}, 
/* 186 : B00000011010    */ { B0, M|384,  B0, M|448,  B1, M|384,  B1, M|448}, 
/* 187 : B00000011001    */ {  B,M|1664,  B0, M|320,   B,M|1728,  B1, M|320}, 
/* 188 : B00000011011    */ {  B, M|512,  W0,    53,   B, M|576,  W1,    53}, 
/* 189 : B00000010100    */ { W0,    56,   B,M|1280,  W1,    56,   B,M|1344}, 
/* 190 : B00000010110    */ { W0,    60,   B,M|1536,  W1,    60,   B,M|1600}, 
/* 191 : B00000010101    */ {  B,M|1408,  W0,    59,   B,M|1472,  W1,    59}, 
/* 192 : B00000011100    */ { W0,    54,   B, M|896,  W1,    54,   B, M|960}, 
/* 193 : B00000011101    */ {  B,M|1024,   B,M|1152,   B,M|1088,   B,M|1216}, 
/* 194 : B00000110010    */ { W0,    48,  W0,    49,  W1,    48,  W1,    49}, 
/* 195 : B00000110011    */ { W0,    62,  W0,    63,  W1,    62,  W1,    63}, 
/* 196 : B00000110100    */ { W0,    30,  W0,    31,  W1,    30,  W1,    31}, 
/* 197 : B00000110110    */ { W0,    40,  W0,    41,  W1,    40,  W1,    41}, 
/* 198 : B00000110101    */ { W0,    32,  W0,    33,  W1,    32,  W1,    33}, 
/* 199 : B00001101010    */ { W0,    36,  W0,    37,  W1,    36,  W1,    37}, 
/* 200 : B00001101001    */ { W0,    34,  W0,    35,  W1,    34,  W1,    35}, 
/* 201 : B00001101011    */ { W0,    38,  W0,    39,  W1,    38,  W1,    39}, 
/* 202 : B00001100100    */ { B0, M|128,  B0, M|192,  B1, M|128,  B1, M|192}, 
/* 203 : B00001100110    */ { W0,    28,  W0,    29,  W1,    28,  W1,    29}, 
/* 204 : B00001100101    */ { W0,    26,  W0,    27,  W1,    26,  W1,    27}, 
/* 205 : B00001101101    */ { W0,    42,  W0,    43,  W1,    42,  W1,    43}, 
/* 206 : B000000101010   */ { B0,M|1408,  B0,M|1472,  B1,M|1408,  B1,M|1472}, 
/* 207 : B000000101001   */ { B0,M|1280,  B0,M|1344,  B1,M|1280,  B1,M|1344}, 
/* 208 : B000000100110   */ { B0, M|768,  B0, M|832,  B1, M|768,  B1, M|832}, 
/* 209 : B000000100101   */ { B0, M|640,  B0, M|704,  B1, M|640,  B1, M|704}, 
/* 210 : B000000101101   */ { B0,M|1536,  B0,M|1600,  B1,M|1536,  B1,M|1600}, 
/* 211 : B000000110010   */ { B0,M|1664,  B0,M|1728,  B1,M|1664,  B1,M|1728}, 
/* 212 : B000000111010   */ { B0,M|1024,  B0,M|1088,  B1,M|1024,  B1,M|1088}, 
/* 213 : B000000111001   */ { B0, M|896,  B0, M|960,  B1, M|896,  B1, M|960}, 
/* 214 : B000000111011   */ { B0,M|1152,  B0,M|1216,  B1,M|1152,  B1,M|1216}, 
/* 215 : B000000110110   */ { B0, M|512,  B0, M|576,  B1, M|512,  B1, M|576}, 
/* 216 : error state     */ {216,     0, 216,     0, 216,     0, 216,     0}, 
/* 217 : KillEol (0)     */ {219,     0, 218,     0, 217,     0, 217,     0}, 
/* 218 : KillEol (1)     */ {220,     0, 218,     0, 217,     0, 217,     0}, 
/* 219 : KillEol (2)     */ {221,     0, 218,     0, 217,     0, 217,     0}, 
/* 220 : KillEol (3)     */ {222,     0, 218,     0, 217,     0, 217,     0}, 
/* 221 : KillEol (4)     */ {223,     0, 218,     0, 217,     0, 217,     0}, 
/* 222 : KillEol (5)     */ {224,     0, 218,     0, 217,     0, 217,     0}, 
/* 223 : KillEol (6)     */ {225,     0, 218,     0, 217,     0, 217,     0}, 
/* 224 : KillEol (7)     */ {226,     0, 218,     0, 217,     0, 217,     0}, 
/* 225 : KillEol (8)     */ {227,     0, 218,     0, 217,     0, 217,     0}, 
/* 226 : KillEol (9)     */ {228,     0, 218,     0, 217,     0, 217,     0}, 
/* 227 : KillEol (10)    */ {228,     0, 218,     0,   0,     0, 217,     0}, 
/* 228 : KillEol (11)    */ {228,     0,  W0,     0,   0,     0,  W1,     0}
};

#define HIGHSET 0xff00
#define LOWSET  0x00ff
#define HIGHSHIFT 8
#define P       0x0100
#define VL3     0x0200
#define VL2     0x0300
#define VL1     0x0400
#define V0      0x0500
#define VR1     0x0600
#define VR2     0x0700
#define VR3     0x0800
#define H       0x0900
#define H0      0x0a00
#define H1      0x0b00
#define EOFB6   0x0c00
#define EOFB7   0x0d00
    
#define ERR     0x0f00

#define VL3V0   (VL3|(V0>>HIGHSHIFT))
#define VL2V0   (VL2|(V0>>HIGHSHIFT))
#define VL1V0   (VL1|(V0>>HIGHSHIFT))
#define V0V0    (V0|(V0>>HIGHSHIFT))
#define VR1V0   (VR1|(V0>>HIGHSHIFT))
#define VR2V0   (VR2|(V0>>HIGHSHIFT))
#define VR3V0   (VR3|(V0>>HIGHSHIFT))
#define PV0     (P|(V0>>HIGHSHIFT))

State MMRStates[9] = {
/*    0 : no bits       */ {  1,     0,  2,   V0,  3,    0,  0, V0V0},
/*    1 : 00            */ {  4,     0,  0,   H0,  0,    P,  0,   H1},
/*    2 : 0             */ {  5,     0,  0,  VL1,  0,    H,  0,  VR1},
/*    3 : 01            */ {  2,   VL1,  2,  VR1,  0,VL1V0,  0,VR1V0},
/*    4 : 0000          */ {  0, EOFB6,  0,  VL2,  6,    0,  0,  VR2},
/*    5 : 000           */ {  7,     0,  2,    P,  8,    0,  0,  PV0},
/*    6 : 000001        */ {  2,   VL3,  2,  VR3,  0,VL3V0,  0,VR3V0},
/*    7 : 00000         */ {  0, EOFB7,  0,  VL3,  0,  ERR,  0,  VR3},
/*    8 : 00001         */ {  2,   VL2,  2,  VR2,  0,VL2V0,  0,VR2V0}
};

//==============================================================================
const BYTE whitespace[256] =
{
    8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0
};

void RawToChange(LPT4STATE lpt4s)
{
	LPWORD outptr = (LPWORD)lpt4s->lpbOut;
	LPBYTE inptr = lpt4s->lpbIn;
	LPBYTE inend = inptr + lpt4s->cbIn;
	WORD bitwidth = lpt4s->cbLine * 8;
	WORD currcolumn = lpt4s->wColumn;
	WORD currcolor = lpt4s->wColor;
	WORD currbit = lpt4s->wBit;
	BYTE currbyte;
	WORD space;
	
  if (inptr >= inend)
		goto inempty;
	if (currcolor)
		goto black;

white:
	if (currbyte = *inptr >> currbit)
	{
		space = whitespace[currbyte];
		currbit += space;
		currcolumn += space;
		if (currcolumn >= bitwidth)
		{
	    currbit -= (currcolumn-bitwidth);
	    goto eol;
		}

		*outptr++ = currcolumn;
	}

  else if ((currcolumn += (8-currbit)) >= bitwidth)
  {
  	currbit = 8 - (currcolumn - bitwidth);
		goto eol;
  }

  else
  {
		currbit = 0;
		while ((++inptr < inend) && (!*inptr))
		{
	    currcolumn += 8;
	    if (currcolumn >= bitwidth)
	    {
				currbit = 8-(currcolumn-bitwidth);
				goto eol;
	    }
		}
		if (inptr >= inend)
	    goto inempty;
		space = whitespace[*inptr];
		currbit += space;
		currcolumn += space;
		if (currcolumn >= bitwidth)
		{
	    currbit -= (currcolumn-bitwidth);
	    goto eol;
		}
		*outptr++ = currcolumn;
	}
  currcolor = 1;

black:

	if ((currbyte = ((signed char)*inptr) >> currbit) != 0xff)
	{
		space = whitespace[255-currbyte];
		currbit += space;
		currcolumn += space;
		if (currcolumn >= bitwidth)
		{
	  	currbit -= (currcolumn-bitwidth);
	    goto eol;
		}
		*outptr++ = currcolumn;
  }

  else if ((currcolumn += (8-currbit)) >= bitwidth)
  {
		currbit = 8 - (currcolumn - bitwidth);
		goto eol;
  }

  else
  {
		currbit = 0;
		while ((++inptr < inend) && (*inptr==0xff))
		{
			currcolumn += 8;
			if (currcolumn >= bitwidth)
			{
				currbit = 8-(currcolumn-bitwidth);
				goto eol;
			}
		}

		if (inptr >= inend)
			goto inempty;
		space = whitespace[255 - *inptr];
		currbit += space;
		currcolumn += space;
		if (currcolumn >= bitwidth)
		{
			currbit -= (currcolumn-bitwidth);
			goto eol;
		}
		*outptr++ = currcolumn;
	}

	currcolor = 0;
	goto white;

eol:
	*outptr++ = bitwidth;
	*outptr++ = bitwidth;
	*outptr++ = bitwidth;
	*outptr++ = bitwidth;
	*outptr++ = (WORD)-1;
	*outptr++ = (WORD)-1;
	
	lpt4s->wBit = currbit;
	lpt4s->cbIn = (WORD)(((LPBYTE)inend) - ((LPBYTE)inptr));
	lpt4s->lpbIn = inptr;
	lpt4s->lpbOut = (LPBYTE)outptr;
	lpt4s->wColor = 0;
	lpt4s->wColumn = 0;
	lpt4s->wRet = RET_END_OF_LINE;
	return;

inempty:

	lpt4s->wBit = 0;
	lpt4s->cbIn = 0;
	lpt4s->lpbIn = inend;
	lpt4s->lpbOut = (LPBYTE)outptr;
	lpt4s->wColor = currcolor;
	lpt4s->wColumn = currcolumn;
	lpt4s->wRet = RET_INPUT_EMPTY1;
	return;
}

//==============================================================================
__inline void EncodeRun(LPRUNINFO ptr, LPWORD FAR *outptr, LPWORD currbit)
{
	WORD bits = ptr->bitsused;
  WORD data = ptr->data;

  if (!*currbit)
  {
		**outptr = data;
		*currbit = bits;
  }

  else
  {
		**outptr |= (data << *currbit);
		*currbit += bits;
		if (*currbit > 15)
		{
	    *++*outptr = data >> ((16 - (*currbit - bits)));
	    *currbit &= 15;
		}
	}
}

//==============================================================================
void MMRToChange(LPT4STATE lpt4s)
{
	nextinfo_t FAR *nextptr;
	BYTE currbyte;
	WORD size;
	short b1,b2;
	LPWORD x;

	// Load context
	LPBYTE inptr    =          lpt4s->lpbIn;
	LPWORD outptr   = (LPWORD) lpt4s->lpbOut;
	LPWORD refline  = (LPWORD) lpt4s->lpbRef;
	LPBYTE inend    =          lpt4s->lpbIn + lpt4s->cbIn;
	WORD state      =          lpt4s->wToggle;
	WORD bitwidth   =          lpt4s->cbLine * 8;
	WORD currbit    =          lpt4s->wBit;
	WORD currstate  =          lpt4s->wWord;
	WORD currcolumn =          lpt4s->wColumn;
	WORD currcolor  =          lpt4s->wColor;

	DEBUGMSG(dbg && lpt4s->wRet == RET_INPUT_EMPTY1,
		("IN:  Column %d, color %d, state %d, currstate %d, *ref = %d\n\r",
			currcolumn,currcolor,state,currstate,*refline));
			
	if (inptr >= inend)
	{
		switch (lpt4s->wRet)
		{
			case RET_END_OF_LINE:
			case RET_BEG_OF_PAGE:
				lpt4s->wRet = RET_INPUT_EMPTY2;
				break;
				
			default:
				lpt4s->wRet = RET_INPUT_EMPTY1;
				break;
		}
		DEBUGMSG(dbg,("Bailing 1 %d\n\r",lpt4s->wRet));
		return;
	}

	switch (lpt4s->wRet)
	{
		case RET_END_OF_LINE:
		case RET_BEG_OF_PAGE:
			state = 0; // yes, fall through
		case RET_INPUT_EMPTY2:
			b1 = *refline;
			b2 = *(refline + 1);
			break;

		default:
			x = refline + currcolor;
			if ((b1 = *x++) <= (short)currcolumn)
			{
	    	x++;
	    	while ((b1 = *x++) <= (short)currcolumn)
	    	{
					x++;
					refline += 2;
				}
			}
			b2 = *x++;
			break;
	}
		
	if (currbit & 1)
	{
		currbit++;
		state = 0;
		currstate = 0;
		currcolor ^= 1;
		currcolumn = *outptr++ = b1;

		if (currcolumn < bitwidth)
		{
	  	x = refline+currcolor;
	  	if ((b1 = *x++) <= (short)currcolumn)
	  	{
				x++;
				while ((b1 = *x++) <= (short)currcolumn)
					{ x++; refline += 2; }
	    }
	    b2 = *x++;
		}

		else
		{
	  	currbit-=2;
	    goto eol;
		}
	} // end if (currbit & 1)
	
  if (currbit == 8)
  {
		currbit = 0;
		if (++inptr == inend)
		{
	    DEBUGMSG(dbg,("Bailing 2\n\r"));
	    currbit = (WORD)(-2); //adjusted +2 below
	    lpt4s->wRet = RET_INPUT_EMPTY1;
	    goto out;
		}
	}

	do // fetch bytes
	{
		currbyte = *inptr >> currbit;

		do // fetch bits
		{
	    if (!state)
	    {
				DEBUGMSG(dbg,("Currstate = %d\n\r",currstate));
				nextptr = &MMRStates[currstate].nextinf[currbyte & 3];
				currstate = nextptr->nextstate;
				DEBUGMSG(dbg,("Currstate set to %d\n\r",currstate));

				if (size = nextptr->size)
				{
		    	if (size & HIGHSET)
		    	{
						DEBUGMSG(dbg,("Taking high: %4.4x\n\r",size & HIGHSET));

						switch (size & HIGHSET)
						{
							case VL3:
							case VL2:
							case VL1:
							case V0:
							case VR1:
							case VR2:
							case VR3:
                                                                currcolumn = b1+ (size>>HIGHSHIFT)- (WORD)(V0>>HIGHSHIFT);
								*outptr++ = currcolumn;
								currcolor^=1;
								break;
								
							case P:
								currcolumn = b2;
								break;
								
							case H:
								state = 1;
								currstate = (currcolor? B:W);
								break;
								
							case H0:
								state = 1;
								currstate = (currcolor? B0:W0);
								break;
								
							case H1:
								state = 1;
								currstate = (currcolor?B1:W1);
								break;
								
							case ERR:
								DEBUGMSG(dbg,("Bailing 3\n\r"));
								lpt4s->wRet = RET_DECODE_ERR;
								goto out;
								
							case EOFB6:
								state = 3;
								currstate = 6;
								break;
								
							case EOFB7:
								state = 3;
								currstate = 7;
								break;
								
						} // end switch (size & HIGHSET)
						
						size &= ~HIGHSET;

						if (currcolumn < bitwidth)
						{
			    		x = refline + currcolor;
			    		if ((b1 = *x++) <= (short)currcolumn)
			    		{
								x++;
								while ((b1 = *x++) <= (short)currcolumn)
								{
				    			x++;
				    			refline += 2;
								}
			    		}
			    		b2 = *x++;
						}

						else if (size & LOWSET)
						{
							currbit--;
							DEBUGMSG(dbg,("Bailing 4\n\r"));
							goto eol;
						}
		    	} // end if (size & HIGHSET)
		    	
		    	if (size & LOWSET)
		    	{
		    		DEBUGMSG(dbg,("Taking low : %4.4x\n\r", (size & LOWSET)<<HIGHSHIFT));

		    		switch ((size & LOWSET) << HIGHSHIFT)
		    		{
							case V0:
								currcolumn = *outptr++ = b1;
								currcolor^=1;
								break;
						}

						if (currcolumn >= bitwidth)
						{
							DEBUGMSG(dbg,("Taking new escape!\n\r"));
							goto eol;
						}
						
						size &= ~HIGHSET;
						x = refline + currcolor;
						DEBUGMSG(dbg,("Current column = %d, bitwidth = %d\n\r",
							currcolumn,bitwidth));

						if ((b1 = *x++) <= (short)currcolumn)
						{
			    		DEBUGMSG(dbg,("Looping, b1 = %d, *x = %d\n\r", b1,*x));
			   			x++;
			    		while ((b1 = *x++) <= (short)currcolumn)
			    		{
			    			DEBUGMSG(dbg,("Looping, b1 = %d, *x = %d\n\r", b1,*x));
								x++;
								refline += 2;
			    		}
						}
						b2 = *x++;
						
		    	} // end if (size & LOWSET)

				}
			}

			else if (state < 3)
			{
				DEBUGMSG(dbg,("MHCurrstate = %d (%d)\n\r",currstate,state));
				nextptr = &MHStates[currstate].nextinf[currbyte & 3];
				currstate = nextptr->nextstate;

				DEBUGMSG(dbg,("MHCurrstate set to %d\n\r",currstate));

				if (size = nextptr->size)
				{
					switch (size & ~SIZE_MASK)
		  		{
						case 0:
							currcolumn += size;
							if ((state == 2) || (currcolumn != bitwidth))
								*outptr++ = currcolumn;
							currcolor ^= 1;
							state = (state+1)%3;
							break;
					
						case SIZE_SPEC:
						  if (size == SIZE_SPEC)
						  {
								if ((state == 2) || (currcolumn != bitwidth))
							  	*outptr++ = currcolumn;
								currcolor ^= 1;
								state = (state+1)%3;
								break;
							}
							else
							{
								lpt4s->wRet = RET_SPURIOUS_EOL;
								goto out;
							}

						default:
					    currcolumn += size & SIZE_MASK;
					    break;
					    
		    	} 
				} // end if (size = nextptr->size)
		
				if (!state)
				{
		    	if (currcolumn < bitwidth)
		    	{
						x = refline + currcolor;
						b1 = *x++;
						while (b1 <= (short)currcolumn)
							{ x++; b1 = *x++; }
						b2 = *x++;
		   		}

		    	switch (currstate)
		    	{
						case W:
						case B:
					    currstate = W;
					    break;
					    
						case W0:
						case B0:
					    currstate = 2;
					    break;
					    
						case W1:
						case B1:
			    		currstate = 0;
					    if (currcolumn < bitwidth)
					    {
								currcolumn = *outptr++ = b1;
								currcolor^=1;
								if (currcolumn < bitwidth)
								{
							    x = refline + currcolor;
							    b1 = *x++;
							    while (b1 <= (short)currcolumn)
							    	{ x++; b1 = *x++; }
				    			b2 = *x++;
								}
			    		}

			    		else
			    		{
								currbit--;
								goto eol;
							}
		    		} // end switch (currstate)

					}
	    }

	    else 
	    {
				switch (currbyte & 3)
				{
		    	case 0:
		    		break;
		    		
		    	case 1:
						if ((currstate != 11) && (currstate != 23))
						{
			    		lpt4s->wRet = RET_DECODE_ERR;
			    		DEBUGMSG(dbg,("Bailing 7\n\r"));
			   			goto out;
						}
						break;

		    	case 2:
						if ((currstate != 10) && (currstate != 22))
						{
			    		lpt4s->wRet = RET_DECODE_ERR;
			    		DEBUGMSG(dbg,("Bailing 8\n\r"));
			    		goto out;
						}
						break;

		    	case 3:
						if (currstate != 23)
						{
			    		lpt4s->wRet = RET_DECODE_ERR;
			    		DEBUGMSG(dbg,("Bailing 9\n\r"));
			    		goto out;
						}
						break;
				}

				currstate += 2;

				if (currstate >= 24)
				{
		    	DEBUGMSG(dbg,("Bailing 10\n\r"));
		    	inptr++; // consume last byte
		    	lpt4s->wRet = RET_END_OF_PAGE;
		    	goto out;
				}
	    }
eol:
		if (!state && (currcolumn == bitwidth))
		{
			DEBUGMSG(dbg,("Bailing 11\n\r"));
			lpt4s->wRet = RET_END_OF_LINE;
			*outptr++ = bitwidth;
			*outptr++ = bitwidth;
			*outptr++ = bitwidth;
			*outptr++ = (WORD)-1;
			*outptr++ = (WORD)-1;
			goto out;
    }

    else if (currcolumn > bitwidth)
    {
			DEBUGMSG(dbg,("Bailing 12\n\r"));
			lpt4s->wRet = RET_DECODE_ERR;
			goto out;
 	  }
	  currbyte >>= 2;

	} while ((currbit += 2) < 8); // fetch bits

	currbit = 0;

	} while (++inptr < inend); // fetch bytes
		
  currbit = (WORD) -2;
  lpt4s->wRet = RET_INPUT_EMPTY1;
  DEBUGMSG(dbg,("Bailing 13\n\r"));

out:

  if (currcolumn==bitwidth && lpt4s->wRet != RET_END_OF_LINE)
  	lpt4s->wRet = RET_INPUT_EMPTY2;

	if ((currcolumn == 0) && (currcolor == 0) && (lpt4s->wRet == RET_INPUT_EMPTY1))
		lpt4s->wRet = RET_INPUT_EMPTY2;

	lpt4s->cbIn -= (WORD)(inptr - lpt4s->lpbIn);
	lpt4s->lpbIn = inptr;
	lpt4s->lpbOut = (LPBYTE)outptr;
	lpt4s->lpbRef = (LPBYTE)refline;
	lpt4s->wBit = currbit+2;
	lpt4s->wWord = currstate;
	lpt4s->wColumn = currcolumn;
	lpt4s->wToggle = state;
	lpt4s->wColor = currcolor;
}

//==============================================================================
void MHToChange(LPT4STATE lpt4s)
{
	WORD size;
	BYTE currbyte;
	nextinfo_t FAR *nextptr;

  // Load context.
	LPBYTE inptr    =          lpt4s->lpbIn;
	LPWORD outptr   = (LPWORD) lpt4s->lpbOut;
	LPBYTE inend    =          lpt4s->lpbIn + lpt4s->cbIn;
	WORD bitwidth   =          lpt4s->cbLine * 8;
	WORD currbit    =          lpt4s->wBit;
	WORD currstate  =          lpt4s->wWord;
	WORD currcolumn =          lpt4s->wColumn;
	WORD ismkup     =          lpt4s->wColor;
	
  if (inptr >= inend)
  {
  	switch (lpt4s->wRet)
  	{
  		case RET_END_OF_LINE:
  		case RET_BEG_OF_PAGE:
  			lpt4s->wRet = RET_INPUT_EMPTY2;
  			break;
  			
  		default:
  			lpt4s->wRet = RET_INPUT_EMPTY1;
  			break;
  	}
  	return;
  }

  switch (lpt4s->wRet)
  {
  	case RET_END_OF_LINE:
  	case RET_BEG_OF_PAGE:
  	case RET_INPUT_EMPTY2:
  		switch (currstate)
  		{
  			case B0:
  			case W0:
  				currstate = 218;
  				break;
  				
  			default:
  				currstate = 217;
  				break;
  		}
  }
  
  if (currstate == 216)
		currstate = 217;

  if (currbit == 8)
  {
		currbit = 0;
		if (++inptr == inend)
		{
	    lpt4s->wRet = RET_INPUT_EMPTY1;
	    goto out;
		}
  }

  
  do // fetch bytes
  {
		currbyte = *inptr >> currbit;
		DEBUGMSG(dbg,("MH currbyte = %4.4x, currbit %d, cc %d\n\r",*inptr,currbit,currcolumn));

		do // fetch bits
		{
	    nextptr = &MHStates[currstate].nextinf[currbyte & 3];
	    currstate = nextptr->nextstate;
	    if (size = nextptr->size)
	    {
				switch (size & ~SIZE_MASK)
				{
					case 0:
						ismkup = 0;
						currcolumn += size;
						*outptr++ = currcolumn;
						break;

					case SIZE_MKUP:
						ismkup = 1;
						currcolumn += size & SIZE_MASK;
						break;

				  case SIZE_SPEC:
						switch (size)
						{
							case S_ZERO:
								if (*(outptr-1) != currcolumn || LOWORD(outptr) == lpt4s->wOffset)
									*outptr++ = currcolumn;
                else outptr--; // Back up one change on bogus zero runs. -RajeevD
								ismkup = 0;
								break;
									
							case S_ERR:
								lpt4s->wRet = RET_DECODE_ERR;
								goto out;
								
							case S_EOL:
								if (!currcolumn)
								{
									DEBUGMSG(dbg,("SPURIOUS EOL!\n\r"));
									lpt4s->wRet = RET_SPURIOUS_EOL;
								}
								else
								{
									currstate = 216;
									lpt4s->wRet = RET_DECODE_ERR;
								}
								goto out;

							default: DEBUGCHK (FALSE);
						}
						break;

					default: DEBUGCHK (FALSE);
					
				} // switch (size & ~SIZE_MASK)
	    }

			if ((currcolumn == bitwidth) && (*(outptr-1) == bitwidth))
			{
				*outptr++ = bitwidth;
				*outptr++ = bitwidth;
				*outptr++ = bitwidth;
				*outptr++ = (WORD)-1;
				*outptr++ = (WORD)-1;
			  lpt4s->wRet = RET_END_OF_LINE;
				goto out;
			}
			
	    currbyte >>= 2;

		} while ((currbit += 2) < 8); // fetch bits

		currbit = 0;

	} while (++inptr < inend); // fetch bytes


	 currbit = (WORD)-2; /* Since already done above */
	 lpt4s->wRet = RET_INPUT_EMPTY1;

out: // Save context.
	lpt4s->wBit    = currbit+2;
	lpt4s->cbIn   -= (WORD)(inptr - lpt4s->lpbIn);
	lpt4s->lpbIn   = inptr;
	lpt4s->lpbOut  = (LPBYTE)outptr;
	lpt4s->wWord   = currstate;
	lpt4s->wColumn = currcolumn;
	lpt4s->wColor  = ismkup;
}

//==============================================================================
#define MRMODE_INIT    0
#define MRMODE_GETEOL  1
#define MRMODE_1D      2
#define MRMODE_2D      3
#define MRMODE_GOTEOL  4
#define MRMODE_PENDERR 5

void MRToChange(LPT4STATE lpt4s)
{
	WORD mode = lpt4s->wMode;
	LPBYTE inptr, inend;
	WORD currbit, currbyte, count;
	
  if (!lpt4s->cbIn)
  {
		lpt4s->wRet = RET_INPUT_EMPTY1;
		return;
  }

	if (mode == MRMODE_PENDERR)
	{
    lpt4s->wMode = MRMODE_INIT;
    lpt4s->wRet = RET_DECODE_ERR;
    return;
	}
	
  if (mode == MRMODE_INIT || mode == MRMODE_GETEOL)
  {
	  inptr = lpt4s->lpbIn;
		inend = inptr + lpt4s->cbIn;
		currbit = lpt4s->wBit;
		count = lpt4s->wWord;

		do // fetch bytes
		{
	  	currbyte = *inptr >> currbit;

	    do // fetch bits
	    {    
				switch (currbyte & 3)
				{
		    	case 0:
						count+=2;
						break;
						
			    case 1:
						if (count >= 11)
						{
							mode = MRMODE_2D;
							lpt4s->wWord = 0;
							lpt4s->wRet = RET_END_OF_LINE;
							goto processmr;
						}
						else if (mode == MRMODE_GETEOL)
						{
							lpt4s->wMode = MRMODE_INIT;
							lpt4s->wWord = 1;
							goto eolseekerr;
						}
						else count = 1;
						break;
						
		    	case 2:
						if (count >= 10)
						{
			    		mode = MRMODE_GOTEOL;
			    		goto processmr;
						}
						else if (mode == MRMODE_GETEOL)
						{
					    lpt4s->wMode = MRMODE_INIT;
					    lpt4s->wWord = 0;
			    		goto eolseekerr;
						}
						else count = 0;
						break;
						
		    	case 3:
						if (count >= 11)
						{
					    mode = MRMODE_1D;
					    lpt4s->wRet = RET_INPUT_EMPTY1;
					    lpt4s->wWord = 0;
					    goto processmr;
						}
						else if (mode == MRMODE_GETEOL)
						{
					    lpt4s->wMode = MRMODE_INIT;
					    lpt4s->wWord = 0;
					    goto eolseekerr;
						}
						else count = 0;
						break;
						
					} // switch (currbyte & 3)
					
					currbyte >>= 2;

	    } while ((currbit += 2) < 8); // fetch bits

	    currbit = 0;

		} while (++inptr < inend); // fetch bytes

		lpt4s->wBit = 0;
		lpt4s->wMode = mode;
		lpt4s->wWord = count;
		lpt4s->cbIn -= (WORD)(inptr - lpt4s->lpbIn);
		lpt4s->lpbIn = inptr;
		lpt4s->wRet = RET_INPUT_EMPTY1;
		return;

eolseekerr:

		if ((lpt4s->wBit = currbit+2)==8)
		{
		    lpt4s->wBit = 0;
		    inptr++;
		}
		lpt4s->cbIn -= (WORD)(inptr - lpt4s->lpbIn);
		lpt4s->lpbIn = inptr;
		lpt4s->wRet = RET_DECODE_ERR;
		return;
	
processmr:

		if ((lpt4s->wBit = currbit+2)==8)
		{
	    lpt4s->wBit = 0;
	    inptr++;
		}
		lpt4s->cbIn -= (WORD)(inptr - lpt4s->lpbIn);
		lpt4s->lpbIn = inptr;
  }

  if (mode == MRMODE_GOTEOL)
  {
		BYTE bits = *lpt4s->lpbIn >> lpt4s->wBit;

		if (bits & 1)
		{
	    mode = MRMODE_1D;
	    lpt4s->wWord = (bits & 2 ? W1 : W0);
	    lpt4s->wRet = RET_INPUT_EMPTY1;
		} 
		else
		{
	    mode = MRMODE_2D;
	    if (bits & 2)
				lpt4s->wBit--;
	    else
				lpt4s->wWord = 2;
	    lpt4s->wRet = RET_END_OF_LINE;
		}
		
		if ((lpt4s->wBit += 2) == 8)
		{
	    lpt4s->wBit = 0;
	    lpt4s->lpbIn++;
	    lpt4s->cbIn--;
		}
  } // if (mode == 4)

  if (mode == MRMODE_1D)
  {
		MHToChange(lpt4s);
		if ((lpt4s->wRet == RET_END_OF_LINE)
		 || (lpt4s->wRet == RET_SPURIOUS_EOL))
    {
    	switch (lpt4s->wWord)
    	{
    		case W:
    		case B:
    			mode = MRMODE_GETEOL;
    			lpt4s->wWord = 0;
    			break;
    			
    		case W0:
    		case B0:
					mode = MRMODE_GETEOL;
					lpt4s->wWord = 1;
					break;
					
    		case W1:
    		case B1:
    		  mode = MRMODE_PENDERR;
    		  lpt4s->wWord = 0;
  				break;

  			default: DEBUGCHK (FALSE);
  		}		
		}
  }
  
	else if (mode == MRMODE_2D)
	{
		MMRToChange(lpt4s);
		if (lpt4s->wRet == RET_END_OF_LINE)
		{
	    if (lpt4s->wBit & 1)
	    {
	      // Found extra 1 bit.
				lpt4s->wBit++;
				lpt4s->wWord = 0;
				mode = MRMODE_PENDERR;
	    }
	    else 
	    {
    		switch (lpt4s->wWord)
    		{
    			case 0: lpt4s->wWord = 0; break;
    			case 2: lpt4s->wWord = 1; break;
    			default: DEBUGCHK (FALSE);
    		}
    		mode = MRMODE_GETEOL;
    	}
		}
  }
  
	if (lpt4s->wRet == RET_DECODE_ERR)
		mode = MRMODE_INIT;
	lpt4s->wMode = mode;
}

//==============================================================================
const BYTE blackstart[8] = {0x00,0xfe,0xfc,0xf8,0xf0,0xe0,0xc0,0x80};
const BYTE blackend[8]   = {0x00,0x01,0x03,0x07,0x0f,0x1f,0x3f,0x7f};

void ChangeToRaw(LPT4STATE lpt4s)
{
	WORD sbyte,ebyte,start,end;

	WORD    width =          lpt4s->cbLine;
	LPBYTE outptr =          lpt4s->lpbOut;
	LPWORD  inptr = (LPWORD) lpt4s->lpbIn;

	if (width>lpt4s->cbOut)
	{
		lpt4s->wRet = RET_OUTPUT_FULL;
		return;
	}

  lpt4s->wRet = RET_END_OF_LINE;
  lpt4s->cbOut -= width;
  _fmemset(outptr,0,width);
  width *= 8;

  while (*inptr != width)
  {
		start = *inptr & 7;
		sbyte = *inptr++ >>3;
		end   = *inptr & 7;
		ebyte = *inptr++ >>3;

		if (start)
		{
	    if (sbyte == ebyte)
	    {
				outptr[sbyte] |= blackstart[start] & blackend[end];
				continue;
	    }
	    else
				outptr[sbyte++] |= blackstart[start];
		}
		if (ebyte!=sbyte)
	    _fmemset(outptr + sbyte, 0xff, ebyte - sbyte);
		outptr[ebyte] |= blackend[end];
   }
}

//==============================================================================
void ChangeToMMR(LPT4STATE lpt4s)
{
	LPWORD refline, inptr, outptr, eoout;
	WORD bitwidth, currbit, currcolor, runsize;
	short a0,a1,a2,b1,b2;
	LPWORD x;
	refline = (LPWORD)lpt4s->lpbRef;
	inptr = (LPWORD)lpt4s->lpbIn;
	outptr = (LPWORD)lpt4s->lpbOut;
	bitwidth = lpt4s->cbLine * 8;
	currbit = lpt4s->wBit;
	currcolor = lpt4s->wColor;
	*outptr = lpt4s->wWord;
	eoout = outptr + (lpt4s->cbOut/2)-(MMR_OUTPUT_SLACK/2);

	if (lpt4s->wRet == RET_END_OF_PAGE)
	{
		EncodeRun(&EOFB,&outptr,&currbit);
		EncodeRun(&EOFB,&outptr,&currbit);
		
		if (currbit)
		{
	    currbit = 0;
	    outptr++;
		}
		goto end;
	}

  a1 = *inptr;
  a2 = *(inptr+1);

	switch (lpt4s->wRet)
	{
		case RET_END_OF_LINE:
		case RET_BEG_OF_PAGE:
			a0 = 0;
			b1 = *refline;
			b2 = *(refline+1);
			goto top2;

		default:
	 		a0 = lpt4s->a0;
		  if (a0 == (short)bitwidth)
		  {
				lpt4s->wRet = RET_END_OF_LINE;
				goto end;
		  }
			break;
	}

top:

  x = refline + currcolor;
  if ((b1 = *x++) <= a0)
  {
		x++;
		while ((b1 = *x++) <= a0)
		{
	    x++;
	    refline += 2;
		}
  }

  b2 = *x++;

top2:

  if (b2 < a1) // pass mode
  {
		EncodeRun (&PASS,&outptr,&currbit);
		a0 = b2;
  }

  else if ((a1+3>=b1) && (a1-3)<=b1) // vertical mode
  {
		EncodeRun (&VERT[b1-a1+3],&outptr,&currbit);
		currcolor ^= 1;
		a0 = a1;
		a1 = *++inptr;
		a2 = *(inptr+1);
  }

  else // horizontal mode
  {
		EncodeRun(&HORIZ, &outptr, &currbit);

		if (!currcolor)
		{
		  // Encode white run.
	    runsize = a1 - a0;
	    while (runsize >= 2560)
	    {
				EncodeRun(&WhiteMkup[39],&outptr,&currbit);
				runsize -= 2560;
	    }
	    if (runsize >= 64)
	    {
				EncodeRun(&WhiteMkup[runsize/64-1],&outptr,&currbit);
				runsize &= 63;
	    }
	    EncodeRun(&WhiteTCode[runsize],&outptr,&currbit);

      // Encode black run.
	    runsize = a2 - a1;
	    while (runsize >= 2560)
	    {
				EncodeRun(&BlackMkup[39],&outptr,&currbit);
				runsize -= 2560;
	    }
	    if (runsize >= 64)
	    {
				EncodeRun(&BlackMkup[runsize/64-1],&outptr,&currbit);
				runsize &= 63;
	    }
			EncodeRun(&BlackTCode[runsize],&outptr,&currbit);
		}

		else
		{
			// Encode black run.
			runsize = a1 - a0;

	    while (runsize >= 2560)
	    {
				EncodeRun(&BlackMkup[39],&outptr,&currbit);
				runsize -= 2560;
			}
	    if (runsize >= 64)
	    {
				EncodeRun(&BlackMkup[runsize/64-1],&outptr,&currbit);
				runsize &= 63;
	    }
	    EncodeRun(&BlackTCode[runsize],&outptr,&currbit);

      // Encode white run.
	    runsize = a2 - a1;
	    while (runsize >= 2560)
	    {
				EncodeRun(&WhiteMkup[39],&outptr,&currbit);
				runsize -= 2560;
	    }
	    if (runsize >= 64)
	    {
				EncodeRun(&WhiteMkup[runsize/64-1],&outptr,&currbit);
				runsize &= 63;
	    }
	    EncodeRun(&WhiteTCode[runsize],&outptr,&currbit);
		}

		a0 = a2;
		inptr += 2;
		a1 = *inptr;
		a2 = *(inptr+1);
  }

  if (outptr >= eoout)
  {
		lpt4s->wRet = RET_OUTPUT_FULL;
		goto end;
  }
  
  if (a0 < (short)bitwidth)
		goto top;
  lpt4s->wRet = RET_END_OF_LINE;

end:
	lpt4s->a0 = a0;
	lpt4s->wColor = currcolor;
	lpt4s->wWord = currbit ? *outptr : 0;
	lpt4s->wBit = currbit;
	lpt4s->lpbIn = (LPBYTE)inptr;
	lpt4s->cbOut -= (WORD)((LPBYTE)outptr - lpt4s->lpbOut);
	lpt4s->lpbOut = (LPBYTE)outptr;
	lpt4s->lpbRef = (LPBYTE)refline;
	return;
}

//==============================================================================
void ChangeToMH (LPT4STATE lpt4s)
{
	LPWORD inptr = (LPWORD)lpt4s->lpbIn;
	LPWORD outptr = (LPWORD)lpt4s->lpbOut;
	LPWORD eoout;
	WORD bitwidth = lpt4s->cbLine * 8;
	WORD currbit, currcolor, currcolumn, runsize;
	currbit = lpt4s->wBit;
	currcolumn = lpt4s->wColumn;
	currcolor = lpt4s->wColor;
	eoout = outptr + (lpt4s->cbOut/2)-(MH_OUTPUT_SLACK/2);
	*outptr = lpt4s->wWord;

	switch (lpt4s->wRet)
	{
		case RET_END_OF_PAGE:
	    if (currbit)
		    lpt4s->lpbOut+=2;
			*((LPWORD)lpt4s->lpbOut) = 0x8000;
			lpt4s->lpbOut += 2;
	    return;

		case RET_END_OF_LINE:
		case RET_BEG_OF_PAGE:

	    if (lpt4s->nType == MH_DATA)
	    {
				if (currbit)
				{
		    	currbit = 0;
		    	outptr++;
				}
				*outptr++ = 0x8000;
	    }
	    break;
  }

  if (outptr > eoout)
		goto eooutput;

  if (currcolor)
		goto black;

white:

	currcolor = 1;
	runsize = *inptr - currcolumn;
	currcolumn = *inptr;
  while (runsize >= 2560)
  {
		EncodeRun(&WhiteMkup[39],&outptr,&currbit);
		runsize -= 2560;
  }
  if (runsize >= 64)
  {
		EncodeRun(&WhiteMkup[runsize/64-1],&outptr,&currbit);
		runsize &= 63;
  }
  EncodeRun(&WhiteTCode[runsize],&outptr,&currbit);

  if (*inptr++ == bitwidth)
		goto eoln;
  if (outptr > eoout)
		goto eooutput;

black:

	currcolor = 0;
	runsize = *inptr - currcolumn;
	currcolumn = *inptr;

	while (runsize >= 2560)
	{
		EncodeRun(&BlackMkup[39],&outptr,&currbit);
		runsize -= 2560;
	}
	if (runsize >= 64)
	{
		EncodeRun(&BlackMkup[runsize/64-1],&outptr,&currbit);
		runsize &= 63;
  }
  EncodeRun(&BlackTCode[runsize],&outptr,&currbit);

  if (*inptr++ == bitwidth)
		goto eoln;
  if (outptr > eoout)
		goto eooutput;
  goto white;

eoln:
    lpt4s->wColumn = 0;
    lpt4s->wColor = 0;
    lpt4s->wWord = currbit ? *outptr : 0;
    lpt4s->wBit = currbit;
    lpt4s->lpbIn = (LPBYTE)inptr;
    lpt4s->cbOut -= (WORD)((LPBYTE)outptr - lpt4s->lpbOut);
    lpt4s->lpbOut = (LPBYTE)outptr;
    lpt4s->wRet = RET_END_OF_LINE;
    return;

eooutput:

    lpt4s->wColumn = currcolumn;
    lpt4s->wColor = currcolor;
    lpt4s->wWord = currbit ? *outptr : 0;
    lpt4s->wBit = currbit;
    lpt4s->lpbIn = (LPBYTE)inptr;
    lpt4s->cbOut -= (WORD)((LPBYTE)outptr - lpt4s->lpbOut);
    lpt4s->lpbOut = (LPBYTE)outptr;
    lpt4s->wRet = RET_OUTPUT_FULL;
    return;
}

//==============================================================================
void ChangeToMR(LPT4STATE lpt4s)
{
	switch (lpt4s->wRet)
	{
		case RET_END_OF_PAGE:
		
	  	if (lpt4s->wBit)
	    {
				*((LPWORD)lpt4s->lpbOut) = lpt4s->wWord;
        lpt4s->lpbOut += 2;
			}
			*((LPWORD)lpt4s->lpbOut) = 0x8000;
			lpt4s->lpbOut += 2;
	    return;

		case RET_BEG_OF_PAGE:
		case RET_END_OF_LINE:
	    if (lpt4s->wBit)
	    {
				lpt4s->wBit = 0;
				*((LPWORD)lpt4s->lpbOut)++ = lpt4s->wWord;
				lpt4s->cbOut-=2;
	    }
	    *((LPWORD)lpt4s->lpbOut)++ = lpt4s->iKFactor ? 0x4000 : 0xc000;
	    lpt4s->cbOut -= 2;
	    lpt4s->wWord = 0;
	    break;
	}

  if (lpt4s->iKFactor)
		ChangeToMMR(lpt4s);
  else
		ChangeToMH(lpt4s);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\constant.h ===
// constants defined
// History: 9/28/93 mslin
//             RES_DIR_SIZE changed to 2048 for Acorn printer
//          10/22/93  mslin         
//             change expand brush to only 16 lines instead 
//             of 32 for saving memory because currently the 
//             repeat pattern is 16x16
//             BYTESPERSACNLINE enlarge to 616 for 600 dpi.
//
#define SUCCESS   1
#define FAILURE   0
#define EXTERN
#define PRIVATE

#ifdef DEBUG
#define  MAXBAND  24   
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\ddbitblt.h ===
/*==============================================================================
Structures and prototypes for display driver interface.

09-Jun-93     RajeevD     Created.
==============================================================================*/
#ifndef _INC_DDBITBLT
#define _INC_DDBITBLT

// Logical Brush 
typedef struct
{
	WORD lbStyle;
  WORD lbColor; 
  WORD lbHatch;
  WORD lbBkColor;
}
	DD_BRUSH;

// Physical Bitmap
typedef struct
{ 
	WORD   bmType;
  WORD   bmWidth;
  WORD   bmHeight;
  WORD   bmWidthBytes;
  BYTE   bmPlanes;
  BYTE   bmBitsPixel;
  LPVOID bmBits;
  DWORD  bmWidthPlanes;
  LPVOID bmlpPDevice;
  WORD   bmSegmentIndex;
  WORD   bmScanSegment;
	WORD bmFillBytes;
}
	DD_BITMAP, FAR* LPDD_BITMAP;

// Draw Mode
typedef struct
{
	short Rop2;
	short bkMode;
	DWORD dwbgColor;
	DWORD dwfgColor;
}
	DD_DRAWMODE;

// API Prototypes
BOOL FAR PASCAL ddBitBlt
	(LPVOID, WORD, WORD, LPVOID, WORD, WORD,
	WORD, WORD, DWORD, LPVOID, LPVOID);

BOOL FAR PASCAL ddRealize
	(LPVOID, short, LPVOID, LPVOID, LPVOID);

DWORD FAR PASCAL ddColorInfo
  (LPVOID, DWORD, LPDWORD);

#endif // _INC_DDBITBLT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\dorpl.c ===
/*
**  Copyright (c) 1991 Microsoft Corporation
*/
//===========================================================================
// FILE                         DORPL.C
//
// MODULE                       Host Resource Executor
//
// PURPOSE                      Convert A-form to B-form for jumbo driver
//
// DESCRIBED IN                 Resource Executor design spec.
//
// MNEMONICS                    n/a
//
// HISTORY  1/17/92 mslin       extracted functions from cartrige JUMBO.C
//                              and then modified.
//				03/09/92 dstseng	  RP_FillScanRow -> RP_FILLSCANROW (.asm)
//				03/10/92 dssteng	  add one parameter SrcxOrg to RP_BITMAP1TO1()
//										  to handle the case xOffset <> 0
//				03/11/92 dstseng	  <3> optimize fill rect. by calling RP_FILLSCANROW()	
//              05/21/92 mslin  Add DUMBO compiled switch for Fixed memory
//                              because real time interrupt routine will call
//                              hre when printing in real-time rendering mode
//          08/18/92 dstseng    @1 fix bug that trashed the value of usPosOff
//          08/21/92 dstseng    @2 fix a inadvertent bug in BitMapHI
//          10/12/92 dstseng    @3 fix "Glyph range checking" bug
//          11/12/92 dstseng    @4 special treatment for hollow brush
//          11/12/92 dstseng    @5 fix bug in command ShowText & ShowField
//          09/27/93 mslin      add BuildPcrDirectory600() for Spicewood 6.
//
//
//===========================================================================

// Include files
//
#include <ifaxos.h>
#include <resexec.h>

#include "constant.h"
#include "jtypes.h"     // type definition used in cartridge
#include "jres.h"       // cartridge resource data type definition
#include "hretype.h"    // define data structure used by hre.c and rpgen.c
#include "hreext.h"     // declaration extern global var. and extern func.
#include "multbyte.h"   // define macros to take care of byte ordering
#include "stllnent.h"   // declare style line functions.

#ifdef DEBUG
DBGPARAM dpCurSettings = {"RESEXEC"};
#endif

#define Brush40Gray (ULONG)0x8140     /* all black */

extern const WORD wRopTable[256];
extern BYTE BrushPat[72][8];

#define ASSERT(cond,mesg) if (cond) {DEBUGMSG (1, mesg); goto EndRPL;}

// functions prototypes
static   void  RP_NewRop (LPRESTATE lpRE, UBYTE ubRop);
static   int   SelectResource(LPHRESTATE lpHREState, UINT uid);
extern   void  GetTotalPixels (RP_SLICE_DESC FAR* psdSlice);
extern   BOOL  OpenBlt     (LPRESTATE, UINT);
extern   BOOL  SetBrush    (LPRESTATE);
extern   void  CloseBlt    (LPRESTATE);

//---------------------------------------------------------------------------
void

DoRPL
(
   LPHRESTATE lpHREState,       // far pointer to current job context
                                // corresponding to the job HANDLE
   LPRPLLIST lpRPLList          // pointer to RPL list
)
// PURPOSE                      Execute a Render Primitive List (RPL)
//                              which is a list of RPL block.
//                              
//
// ASSUMPTIONS & ASSERTIONS     None.
//
// INTERNAL STRUCTURES          None visible outside of HRE.
//
// UNRESOLVED ISSUES            programmer development notes
//
//---------------------------------------------------------------------------       
{
   LPBITMAP          lpbmBand;
   LPRESTATE         lpRE;
   UBYTE      FAR*   lpub;
   USHORT     FAR*   lpus;
   ULONG      FAR*   lpul;
   UBYTE      FAR*   lpubLimit;
   LPJG_RPL_HDR      lpRPL;
   USHORT            usTop;
   USHORT            yBrush;
   USHORT            iGlyph;
   LPFRAME           lpFrame;
   LPRESDIR          lpResDir;
   SHORT             sLoopCount;
   RP_SLICE_DESC     slice;

   lpRPL = (LPJG_RPL_HDR)lpRPLList->lpFrame->lpData;
   usTop = GETUSHORT(&lpRPL->usTopRow);
   yBrush = usTop & 0x001F;
   // 08/06/92 dstseng, Because band is not always 32x, 
   // We have difficulty to paint our brush with correct offset
   // Unless We have a variable to keep the offset of usTop.
   
   lpRE = lpHREState->lpREState;
   lpbmBand = lpRE->lpBandBuffer;

   if (!OpenBlt (lpRE, yBrush))
   	return;

#ifdef MARSHAL

      lpFrame = lpRPLList->lpFrame;

      /* interpret the RPL, get parm list ptrs */
      lpul = (ULONG FAR*)((++lpFrame)->lpData);
      lpus = (USHORT FAR*)((++lpFrame)->lpData);
      lpub = (UBYTE FAR*)((++lpFrame)->lpData); 
      /* get resource limit address */
      lpubLimit = (UBYTE FAR*)(lpub + lpFrame->wSize);

#else
 
      /* interpret the RPL, get parm list ptrs */
      lpul = (ULONG FAR*)(lpRPL->ulParm);
      lpus = (USHORT FAR*) (GETUSHORT(&lpRPL->usLongs) * 4 +
                      (UBYTE FAR*)(lpul));
      lpub = (UBYTE FAR*) (GETUSHORT(&lpRPL->usShorts) * 2 +
                      (UBYTE FAR*)(lpus));
      /* get resource limit address */
      lpubLimit = (UBYTE FAR*)lpRPL + lpRPLList->lpFrame->wSize + 1;

#endif

      // if first time call then initialize state variables ???
      /* state variables */
      /* Set to default value at beginning of each RPL. */
      /* The order of RPL execution is not specified and there must not be */
      /* any dependency on the previous RPL. */
      lpRE->sRow = 0 - usTop;    //mslin 3/14/92 ccteng
      lpRE->sCol = lpRE->sCol2 = 0;
      lpRE->ubPenStyle = 0;  /* set solid line */
      lpRE->usPenPhase = 0;  /* restart the pattern */

      /* no current glyph set */
      lpRE->lpCurGS = NULL;
      SelectResource(lpHREState, Brush40Gray);
      lpRE->lpCurBitmap = NULL;

      /* set default ROP */
      RP_NewRop(lpRE, 0x88);

      while (1)
      {
      	if (lpub > lpubLimit)
      	{
         	DEBUGMSG (1, ("HRE: Execution past end of RPL."));
					goto EndRPL;
				}
				
         switch ( *lpub++ )
         {
         /* 0x00 - 0x05 */
         case JG_RP_SetRowAbsS:
            /* long row setting */
            lpRE->sRow = GETUSHORTINC(lpus);
            lpRE->sRow -= usTop;
            break;

         case JG_RP_SetRowRelB:
            lpRE->sRow += (SBYTE)*lpub++;
            break;

         case JG_RP_SetColAbsS:
            /* short column setting */
            lpRE->sCol = GETUSHORTINC(lpus);
            break;

         case JG_RP_SetColRelB:
            lpRE->sCol += (SBYTE)*lpub++;
            break;

         case JG_RP_SetExtAbsS:
            lpRE->sCol2 = GETUSHORTINC(lpus);
               break;

         case JG_RP_SetExtRelB:
            lpRE->sCol2 += (SBYTE)*lpub++;
               break;

         /* 0x10 - 0x1A */

         case JG_RP_SelectS:
            /* make resource current */
            if (!SelectResource(lpHREState, GETUSHORT(lpus)))
               goto EndRPL;   // select resource failure
            lpus++;
            break;

         case JG_RP_SelectB:
            /* make resource current */
            if (!SelectResource(lpHREState, *lpub))
               goto EndRPL;   // select resource failure
            lpub += 1;
            break;

         case JG_RP_Null:
         case JG_RP_End:
            goto EndRPL;

         case JG_RP_SetRop:
            /* raster op setting */
            RP_NewRop(lpRE, *lpub++);
            break;

         case JG_RP_SetPenStyle:
            // if (lpREState->ubPenStyle != *lpub)
            //   lpREState->usPenPhase = 0;  /* restart the pattern */
            lpRE->ubPenStyle = *lpub++;
            break;

#if 0
         case JG_RP_ShowText:   
            {
            UBYTE ubCount;
            lpub++;             // ubFontCode  @5
            ubCount = *lpub++;   // ubNChars
            lpub += ubCount;    // ubCharCode ...  @5
            break;
            }

         case JG_RP_ShowField:
            lpub++;             // ubFontCode  @5
            lpus++;             // usFieldCode @5
            break;
#endif

         case JG_RP_SetRopAndBrush :
            RP_NewRop (lpRE, *lpub++);
            /* make resource current */
            if (!SelectResource(lpHREState, GETUSHORT(lpus)))
               goto EndRPL;   // select resource failure
            lpus++;
            break;

         case JG_RP_SetPatternPhase :
            lpRE->usPenPhase = GETUSHORTINC(lpus);
            break;

         /* 0x20 - 0x23 */
         case JG_RP_LineAbsS1:
         {
            USHORT   usX, usY;

            /* draw line */
            usY = GETUSHORTINC(lpus);     // absolute row
            usY -= usTop;
            usX = GETUSHORTINC(lpus);     // absolute col
            
            ASSERT ((lpRE->sRow < 0) || (lpRE->sRow >= (SHORT)lpbmBand->bmHeight),
              ("HRE: LineAbsS1 y1 = %d\r\n", lpRE->sRow));
            ASSERT ((usY >= (WORD) lpbmBand->bmHeight),
              ("HRE: LineAbsS1 y2 = %d\r\n", usY));

            RP_SliceLine (lpRE->sCol, lpRE->sRow, usX , usY, &slice, lpRE->ubPenStyle);
            if (!StyleLineDraw(lpRE, &slice, lpRE->ubPenStyle,(SHORT)lpRE->ubRop, lpRE->wColor))
                RP_LineEE_Draw(&slice, lpbmBand);
            /* update current position */
            lpRE->sRow = usY;
            lpRE->sCol = usX;
            break;
         }
         
         case JG_RP_LineRelB1:
         {
            SHORT sX, sY;

            /* draw line */
            sY = lpRE->sRow + (SBYTE)*lpub++;    // delta row
            sX = lpRE->sCol + (SBYTE)*lpub++;    // delta col
            
            ASSERT ((lpRE->sRow < 0 || lpRE->sRow >= (SHORT)lpbmBand->bmHeight),
            	("HRE: LineRelB1 y1 = %d\r\n", lpRE->sRow));
            ASSERT ((sY < 0 || sY >= (SHORT)lpbmBand->bmHeight),
            	("HRE: LineRelB1 y2 = %d\r\n", sY));
            
            RP_SliceLine (lpRE->sCol, lpRE->sRow, sX , sY, &slice, lpRE->ubPenStyle);
            if (!StyleLineDraw(lpRE, &slice, lpRE->ubPenStyle,(SHORT)lpRE->ubRop, lpRE->wColor))
                RP_LineEE_Draw(&slice, lpbmBand);
            /* update current position */
            lpRE->sRow = sY;
            lpRE->sCol = sX;
            break;
         }
     
         case JG_RP_LineSlice:
            {
            USHORT us_trow, us_tcol;
            us_trow = *lpub++;
            slice.us_n_slices = *lpub++;
            us_tcol = us_trow; us_trow >>= 2; us_tcol &= 3; us_tcol -= 1;
            slice.s_dy_skip = us_tcol;
            us_tcol = us_trow; us_trow >>= 2; us_tcol &= 3; us_tcol -= 1;
            slice.s_dx_skip = us_tcol;
            us_tcol = us_trow; us_trow >>= 2; us_tcol &= 3; us_tcol -= 1;
            slice.s_dy_draw = us_tcol;
            us_tcol = us_trow;                us_tcol &= 3; us_tcol -= 1;
            slice.s_dx_draw = us_tcol;
            slice.s_dis    = GETUSHORTINC(lpus);
            slice.s_dis_lg = GETUSHORTINC(lpus);
            slice.s_dis_sm = GETUSHORTINC(lpus);
            slice.us_first = GETUSHORTINC(lpus);
            slice.us_last  = GETUSHORTINC(lpus);
            slice.us_small = GETUSHORTINC(lpus);
            slice.us_x1 = lpRE->sCol;
            slice.us_y1 = lpRE->sRow;
            slice.us_x2 = lpRE->sCol;
            slice.us_y2 = lpRE->sRow;
            GetTotalPixels(&slice);
            if (!StyleLineDraw(lpRE, &slice, lpRE->ubPenStyle,(SHORT)lpRE->ubRop, lpRE->wColor))
               RP_LineEE_Draw(&slice, lpbmBand);
            break;
            }

         case JG_RP_FillRowD:

            lpRE->sCol  += (SBYTE)*lpub++; 
            lpRE->sCol2 += (SBYTE)*lpub++;
           
            // Yes, this should fall through!

         case JG_RP_FillRow1:

            ASSERT ((lpRE->sRow < 0 || lpRE->sRow >= (SHORT)lpbmBand->bmHeight),
          		("HRE: FillRow1 y1 = %d\r\n", lpRE->sRow));
          	ASSERT ((lpRE->sCol2 - lpRE->sCol <= 0),
            	("HRE: FillRow1 Width <= 0"));

            RP_FILLSCANROW
            (
            	lpRE, lpRE->sCol, lpRE->sRow, (USHORT)(lpRE->sCol2 - lpRE->sCol), 1,
              (LPBYTE) lpRE->lpCurBrush, lpRE->ulRop,
              lpbmBand->bmBits, lpbmBand->bmWidthBytes, yBrush
            );
            lpRE->sRow++;
            break;

         /* 0x40 - 0x41 */
         case JG_RP_RectB:
         {
            UBYTE ubHeight = *lpub++;
            UBYTE ubWidth  = *lpub++;

            ASSERT ((lpRE->sRow < 0 || lpRE->sRow >= (SHORT)lpbmBand->bmHeight),
            	("HRE: RectB y1 = %d\r\n", lpRE->sRow));
            ASSERT ((lpRE->sRow + ubHeight > (SHORT)lpbmBand->bmHeight),
                ("HRE: RectB y2 = %d\r\n", lpRE->sRow + ubHeight));

            RP_FILLSCANROW
            (
            	lpRE, lpRE->sCol, lpRE->sRow, ubWidth, ubHeight,
            	(LPBYTE) lpRE->lpCurBrush, lpRE->ulRop,
              lpbmBand->bmBits, lpbmBand->bmWidthBytes, yBrush
            );
            break;
         }

         case JG_RP_RectS:
         {
            USHORT   usHeight = *lpus++;
            USHORT   usWidth  = *lpus++;            

            ASSERT ((lpRE->sCol < 0 || lpRE->sCol >= (SHORT) lpbmBand->bmWidth),
                ("HRE: RectS xLeft = %d\r\n", lpRE->sCol));
            ASSERT ((lpRE->sCol + (SHORT)usWidth> (SHORT) lpbmBand->bmWidth),
                ("HRE: RectS xRight = %d\r\n", lpRE->sCol + usWidth));
            ASSERT ((lpRE->sRow < 0 || lpRE->sRow >= (SHORT)lpbmBand->bmHeight),
                ("HRE: RectS yTop = %d\r\n", lpRE->sRow));
            ASSERT ((lpRE->sRow + (SHORT)usHeight > (SHORT)lpbmBand->bmHeight),
                ("HRE: RectS yBottom = %d\r\n", lpRE->sRow + usHeight));

            RP_FILLSCANROW
						(
							lpRE, lpRE->sCol,	lpRE->sRow, usWidth, usHeight,
							(LPBYTE) lpRE->lpCurBrush, lpRE->ulRop,
              lpbmBand->bmBits, lpbmBand->bmWidthBytes, yBrush
            );
            break;
         }

         case JG_RP_BitMapHI:
         {
            UBYTE    ubCompress;
            UBYTE    ubLeft;
            USHORT   usHeight;
            USHORT   usWidth;
            ULONG FAR *ulBitMap;

            ubCompress = *lpub++;
            ubLeft = *lpub++;
            usHeight = GETUSHORTINC(lpus);
            usWidth = GETUSHORTINC(lpus);
            // ulBitMap = (ULONG FAR *)GETULONGINC(lpul);
            ulBitMap = lpul;

            RP_BITMAP1TO1
            ( 
              lpRE,
              (USHORT) ubLeft,
              (USHORT) lpRE->sRow,
              (USHORT) (lpRE->sCol + ubLeft),
              (USHORT) ((usWidth+ubLeft+0x1f) >>5),
              (USHORT) usHeight,
              (USHORT) usWidth,
              (ULONG FAR *) ulBitMap,
              (ULONG FAR *) lpRE->lpCurBrush,
              lpRE->ulRop
            );
            lpul += usHeight * ((usWidth + ubLeft + 0x1F) >> 5);  // @2
            break;

         }

         case JG_RP_BitMapHR:
         {
            LPJG_BM_HDR lpBmp;
            UBYTE    ubCompress;
            UBYTE    ubLeft;
            USHORT   usHeight;
            USHORT   usWidth;
            ULONG FAR *ulBitMap;

            lpBmp = lpRE->lpCurBitmap;
            ubCompress = lpBmp->ubCompress;
            ubLeft = lpBmp->ubLeft;
            usHeight = GETUSHORT(&lpBmp->usHeight);
            usWidth = GETUSHORT(&lpBmp->usWidth);
            ulBitMap = lpRE->lpCurBitmapPtr;

            // Special case band bitmap.
            if (ulBitMap == (ULONG FAR*) lpbmBand->bmBits)
            	break;

            // Call bitblt.
            RP_BITMAP1TO1
            (
              lpRE,
              (USHORT) ubLeft,
              (USHORT) lpRE->sRow,
              (USHORT) (lpRE->sCol + ubLeft),
              (USHORT) ((usWidth+ubLeft+0x1f) >>5),
              (USHORT) usHeight,
              (USHORT) usWidth,
              (ULONG FAR *) ulBitMap,
              (ULONG FAR *) lpRE->lpCurBrush,
              lpRE->ulRop
            );
            break;

         }
         case JG_RP_BitMapV:
         {
            UBYTE      ubTopPad;
            USHORT     usHeight;

            ubTopPad = *lpub++;
            usHeight = GETUSHORTINC(lpus);

            ASSERT ((lpRE->sRow - (SHORT)usHeight + 1 < 0 ||
                lpRE->sRow - (SHORT)usHeight + 1 >= (SHORT)lpbmBand->bmHeight),
                ("HRE: BitmapV y1 = %d\r\n", lpRE->sRow + usHeight));
            ASSERT ((lpRE->sRow < 0 || lpRE->sRow >= (SHORT)lpbmBand->bmHeight),
              ("HRE: BitmapV y2 = %d\r\n", lpRE->sRow));

            lpub += RP_BITMAPV (lpRE->sRow, lpRE->sCol, ubTopPad, 
              usHeight, lpub, lpbmBand->bmBits, lpbmBand->bmWidthBytes);
            lpRE->sCol--;
            break;
         }

         /* 0x60 - 0x63 */
         case JG_RP_GlyphB1:
            iGlyph = (USHORT)*lpub++;
            sLoopCount = 1;
            goto  PlaceGlyph;

         case JG_RP_GlyphBD:
            lpRE->sRow += (SBYTE)*lpub++;
            lpRE->sCol += (SBYTE)*lpub++;
            iGlyph = (USHORT)*lpub++;
            sLoopCount = 1;
            goto PlaceGlyph;

         case JG_RP_GlyphBDN:
            sLoopCount = *lpub++;
            lpRE->sRow += (SBYTE)*lpub++;
            lpRE->sCol += (SBYTE)*lpub++;
            iGlyph = (USHORT)*lpub++;
            goto PlaceGlyph;

      PlaceGlyph:
      {
         SHORT       i;

         /* render the glyph */
         lpResDir = (LPRESDIR)(lpRE->lpCurGS);
         ASSERT ((!lpResDir), ("No selected glyph set!"));
         lpFrame = (LPFRAME)(lpResDir->lpFrameArray);

         for (i = 1; i <= sLoopCount; i++)
         {
            LPJG_GLYPH lpGlyph;
            ULONG FAR *lpSrc;

						
#ifndef MARSHAL
                LPJG_GS_HDR lpGh  = (LPJG_GS_HDR) (lpFrame->lpData);

                // Check that glyph index is within bounds.
                if (iGlyph >= lpGh->usGlyphs)
                {
                	RETAILMSG(("WPSFAXRE DoRpl glyph index out of range!\n"));
                	iGlyph = 0;
                }
             
                lpGlyph = (LPJG_GLYPH) (((UBYTE FAR*) &lpGh->ResHdr.ulUid)
                      + GETUSHORT(&(lpGh->ausOffset[iGlyph])));
                lpSrc = (ULONG FAR *)&lpGlyph->aulPels[0];
#else
                lpGlyph = (LPJG_GLYPH)(lpFrame[(iGlyph+1) << 1].lpData);
                lpSrc = (ULONG FAR*)(lpFrame[((iGlyph+1) << 1) + 1].lpData);
#endif

             RP_BITMAP1TO1
             (
               lpRE,
               (USHORT)0,
               (USHORT)lpRE->sRow,
               (USHORT)lpRE->sCol,
               (USHORT) ((lpGlyph->usWidth + 31) / 32),
               (USHORT) lpGlyph->usHeight,
               (USHORT) lpGlyph->usWidth,
               (ULONG FAR *) lpSrc,
               (ULONG FAR *)lpRE->lpCurBrush,
               (ULONG)lpRE->ulRop
             );

             if (i != sLoopCount)
             {
                // only GlyphBDN comes here 
                lpRE->sRow += (SBYTE)*lpub++;
                lpRE->sCol += (SBYTE)*lpub++;
                iGlyph = (USHORT)*lpub++;
             }
         }
         break;
      }

      default:

      	ASSERT ((TRUE), ("Unsupported RPL command."));
      }
   }

EndRPL:

	CloseBlt (lpRE);
}

// PRIVATE FUNCTIONS
//---------------------------------------------------------------------------
static
void                        
RP_NewRop
(
	LPRESTATE lpRE,  
	UBYTE ubRop                  // one byte ROP code from driver, this
                               // ROP should be convert to printer ROP code
                               // in this routine
)
// PURPOSE                      set new ROP value, also do conversion
//                              since value 1 is black in printer
//                              while value 0 is black in display
//                              
//---------------------------------------------------------------------------       
{
   lpRE->usBrushWidth = 0; // reset pattern width

   lpRE->ubRop = ubRop;         // save old Rop code

   ubRop = (UBYTE) (
           (ubRop>>7&0x01) | (ubRop<<7&0x80) |
           (ubRop>>5&0x02) | (ubRop<<5&0x40) |
           (ubRop>>3&0x04) | (ubRop<<3&0x20) |
           (ubRop>>1&0x08) | (ubRop<<1&0x10)
           );
   ubRop = (UBYTE)~ubRop;

   lpRE->ulRop = ((ULONG) ubRop) << 16;
   
#ifdef WIN32
   lpRE->dwRop = lpRE->ulRop | wRopTable[lpRE->ubRop];
#endif

}
	 
//==============================================================================
void TileBrush (LPBYTE lpbPat8, LPDWORD lpdwPat32)
{
	UINT iRow;
	
	for (iRow = 0; iRow < 8; iRow++)
	{
		DWORD dwRow = *lpbPat8++;
		dwRow |= dwRow << 8;
		dwRow |= dwRow << 16;

		lpdwPat32[iRow]      = dwRow;
		lpdwPat32[iRow + 8]  = dwRow;
		lpdwPat32[iRow + 16] = dwRow;
		lpdwPat32[iRow + 24] = dwRow;
	}
}

//---------------------------------------------------------------------------
static
int
SelectResource
(
   LPHRESTATE lpHREState,      // far pointer to current job context
                               // corresponding to the job HANDLE
   UINT uid                     // specified resource uid.
)
// PURPOSE                      given a resource block pointer
//                              set this resource as current resource
//                              only glyph, brush and bitmap can be
//                              selected.
//---------------------------------------------------------------------------       
{
   LPRESDIR          lprh;
   LPRESDIR          lpResDir;
   LPJG_RES_HDR      lprh1;
   ULONG FAR         *lpBrSrc;
   LPFRAME           lpFrame;
   USHORT            usClass;
   LPRESTATE         lpRE = lpHREState->lpREState;
   
   lpRE->wColor = (uid == 0x8100)? 0x0000 : 0xFFFF;
   
   // Trap stock brushes.
   if ( uid & 0x8000 )
   {
     UINT iBrush = (uid < 0x8100)? uid - 0x8000 : uid - 0x8100 + 6;
		 if (lpRE->lpBrushPat)
       lpRE->lpCurBrush = (LPDWORD) (lpRE->lpBrushPat + 128*iBrush);
		 else
		 {
       lpRE->lpCurBrush = (LPDWORD) lpRE->TiledPat;
       TileBrush (BrushPat[iBrush], lpRE->lpCurBrush);
     }

     SetBrush (lpRE);
	   return SUCCESS;
   }
   
   /* must be downloaded resource */
   lprh = (&lpHREState->lpDlResDir[uid]);

   if ((lpResDir = (LPRESDIR)lprh) == NULL)
      return(FAILURE);

   lprh1 = (LPJG_RES_HDR)lpResDir->lpFrameArray->lpData;

   usClass = GETUSHORT(&lprh1->usClass);
   switch (usClass)
   {

   case JG_RS_GLYPH:
      lpRE->lpCurGS = (LPJG_GS_HDR)lprh;
      break;

   case JG_RS_BRUSH:
      lpFrame = (LPFRAME)(lpResDir->lpFrameArray);

#ifdef MARSHAL
      lpBrSrc = (ULONG FAR *)((++lpFrame)->lpData);
#else
      {
         LPJG_BRUSH  lpBr = (LPJG_BRUSH)(lpFrame->lpData);
         lpBrSrc = (ULONG FAR *)(lpBr->aulPels);
      }
#endif
     
      lpRE->lpCurBrush = (ULONG FAR *)lpBrSrc;
      SetBrush (lpRE);
      break;

   case JG_RS_BITMAP:
      lpFrame = (LPFRAME)(lpResDir->lpFrameArray);
      lpRE->lpCurBitmap = (LPJG_BM_HDR)(lpFrame->lpData);
      lpFrame++;

#ifdef MARSHAL      
         lpRE->lpCurBitmapPtr = (ULONG FAR *)(lpFrame->lpData);
#else
         lpRE->lpCurBitmapPtr = (ULONG FAR *)lpRE->lpCurBitmap->aulPels;
#endif

   default:
      break;
    }
    return(SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\ddbitblt.c ===
/*==============================================================================
These routines are wrappers for the display driver BitBlt interface.

05-30-93     RajeevD     Created.
02-15-94     RajeevD     Integrated into unified resource executor.
==============================================================================*/

#include <windows.h>
#include <windowsx.h>
#include "constant.h"
#include "frame.h"      // driver header file, resource block format
#include "jtypes.h"     // type definition used in cartridge
#include "jres.h"       // cartridge resource data type definition
#include "hretype.h"
#include "hreext.h"

#include "ddbitblt.h"

USHORT usBrushWidth; // just a dummy

//==============================================================================
BOOL OpenBlt (LPRESTATE lpRE, UINT yBrush)
{ 
	LPDD_BITMAP lpbmPat;
	LPBITMAP lpbmBand;
 
	// Initialize source.
	lpRE->bmSrc.bmPlanes = 1;
	lpRE->bmSrc.bmBitsPixel = 1;
	
	// Initialize destination.
	lpbmBand = lpRE->lpBandBuffer;
	lpRE->bmDst.bmPlanes = 1;
	lpRE->bmDst.bmBitsPixel = 1;
	lpRE->bmDst.bmWidth = lpbmBand->bmWidth;
	lpRE->bmDst.bmHeight = lpbmBand->bmHeight;
	lpRE->bmDst.bmWidthBytes = lpbmBand->bmWidthBytes;
	lpRE->bmDst.bmWidthPlanes = lpRE->bmDst.bmWidthBytes * lpRE->bmDst.bmHeight;
	lpRE->bmDst.bmBits = lpbmBand->bmBits;

	// Initialize DRAWMODE.
	ddColorInfo (&lpRE->bmDst, 0xFFFFFF, &lpRE->DrawMode.dwbgColor);
	ddColorInfo (&lpRE->bmDst, 0x000000, &lpRE->DrawMode.dwfgColor);
	lpRE->DrawMode.bkMode = 1; // transparent
	
	// Initialize LOGBRUSH.
	lpRE->lb.lbStyle = BS_PATTERN;
	lpRE->lb.lbHatch = GlobalAlloc (GMEM_ZEROINIT, sizeof(DD_BITMAP));
	if (!lpRE->lb.lbHatch)
		return FALSE;
	lpbmPat = (LPDD_BITMAP) GlobalLock (lpRE->lb.lbHatch);

  // Set brush origin.
  lpRE->wPoint[0] = 0;
  lpRE->wPoint[1] = yBrush;
  
	// Initialize pattern bitmap.
	lpbmPat->bmPlanes = 1;
	lpbmPat->bmBitsPixel = 1;
	lpbmPat->bmWidth = 32;
	lpbmPat->bmHeight = 32;
	lpbmPat->bmWidthBytes = 4;
	lpbmPat->bmWidthPlanes = 128;
	lpbmPat->bmBits = lpRE->TiledPat;
	GlobalUnlock (lpRE->lb.lbHatch);

  // Set physical brush.
	lpRE->lpBrush = NULL;

	return TRUE;
}

//==============================================================================
void CloseBlt (LPRESTATE lpRE)
{
	GlobalFree (lpRE->lb.lbHatch);
	if (lpRE->lpBrush)
		GlobalFreePtr (lpRE->lpBrush);
}

//==============================================================================
BOOL SetBrush (LPRESTATE lpRE)
{
 	LPDD_BITMAP lpbmPat = (LPDD_BITMAP) GlobalLock (lpRE->lb.lbHatch);
	UINT cbBrush;
	
  // Delete previous brush, if any.
	if (lpRE->lpBrush)
	{
		ddRealize (&lpRE->bmDst, -OBJ_BRUSH, &lpRE->lb, lpRE->lpBrush, lpRE->wPoint);
		GlobalFreePtr (lpRE->lpBrush);
	}

	// Realize new physical brush.
	lpbmPat->bmBits = lpRE->lpCurBrush;
	cbBrush = ddRealize (&lpRE->bmDst, OBJ_BRUSH, &lpRE->lb, NULL, lpRE->wPoint);
	lpRE->lpBrush = GlobalAllocPtr (GMEM_FIXED, cbBrush);
	ddRealize (&lpRE->bmDst, OBJ_BRUSH, &lpRE->lb, lpRE->lpBrush, lpRE->wPoint);

	GlobalUnlock (lpRE->lb.lbHatch);
	return TRUE;
}

//==============================================================================
// Clipping to top and bottom of band is performed, but
// ideally should be handled by caller as needed.

DWORD FAR PASCAL RP_BITMAP1TO1
(
	LPRESTATE lpRE,
	WORD    xSrc,   // Left padding
	short   yDst,	  // Top row of destination.
	short   xDst,	  // Left column of destination.
	WORD    clLine, // Longs per scan line
	WORD    yExt,   // Height in pixels
	WORD    xExt,   // Width in pixels 
	LPDWORD lpSrc,  // Far pointer to source
	LPDWORD lpPat,  // Far pointer to pattern
	DWORD   dwRop		// Raster operation
)
{
	LPBITMAP lpbmBand;
	WORD ySrc;
			
	// Record parameters.
	lpRE->bmSrc.bmWidth = xExt + xSrc;
	lpRE->bmSrc.bmHeight = yExt;
	lpRE->bmSrc.bmWidthBytes = 4 * clLine;
	lpRE->bmSrc.bmWidthPlanes = lpRE->bmSrc.bmWidthBytes * lpRE->bmSrc.bmHeight;
	lpRE->bmSrc.bmBits = lpSrc;
	
	// Clip to top of band.
	if (yDst >= 0)
		ySrc = 0;
	else
	{
		ySrc = -yDst;
		yExt -= ySrc;
		yDst = 0;
	}

	// Clip to bottom of band.
	lpbmBand = lpRE->lpBandBuffer;
	if (yExt > (WORD) lpbmBand->bmHeight - yDst)
		yExt = lpbmBand->bmHeight - yDst;

	ddBitBlt
	(
		&lpRE->bmDst, xDst, yDst, &lpRE->bmSrc, xSrc, ySrc,
		xExt, yExt, lpRE->dwRop, lpRE->lpBrush, &lpRE->DrawMode
	);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\genconst.inc ===
;----------------------------Module-Header------------------------------;
; Module Name: GENCONST.BLT
;
; Constants for general use in BitBLT.
;
; Created: In Windows' distant past (c. 1983)
;
; Copyright (c) 1983 - 1987  Microsoft Corporation
;
; This file is a catchall for constants for use in BitBLT.
;
; This file is part of a set that makes up the Windows BitBLT function
; at driver-level.
;-----------------------------------------------------------------------;

;	The following equates are for stuffing into the generated BLT.
;	For full 16-bit values, the two bytes are reversed so that they
;	come out correctly when stored in memory (i.e. the 8088 stores
;	the LSB first).


I_ADD_AL_BYTE_I		equ	004h	;ADD	al,byte immediate
I_ADD_AX_WORD_I		equ	005h	;ADD	ax,word immediate
I_ADD_DI_WORD_I		equ	0C781h	;ADD	di,immediate
I_ADD_SI_WORD_I		equ	0C681h	;ADD	si,immediate
I_AND_AL_MEM		equ	00622h	;AND	al,[addr]
I_AND_AL_BYTE_I		equ	024h	;AND	al,byte immediate

I_CMP_AL_BYTE_I		equ	03Ch	;CMP	al,byte immediate
I_CMP_AX_WORD_I		equ	03Dh	;CMP	ax,word immediate
I_CMP_CX_2		equ	0F983h	;CMP	cx,2
I_CS_OVERRIDE		equ	02Eh	;CS:

I_DEC_SI_DEC_DI		equ	04F4Eh	;DEC	si
					;DEC	di
I_ES_OVERRIDE		equ	026h	;ES:
I_FS_OVERRIDE		equ	064h	;FS:
I_GS_OVERRIDE		equ	065h	;GS:

I_INC_SI_INC_DI		equ	04746h	;INC	si
					;INC	di
I_JC_P5H		equ	00372h	;JC	$+5
I_JC_P0DH		equ	00B72h	;JC	$+0Dh
I_JC_P12H		equ	01072h	;JC	$+12h
I_JMP_NEAR		equ	0E9h	;JMP	near
I_JNC			equ	073h	;JNC	short
I_JNC_P12H		equ	01073h	;JNC	$+12h
I_JNS_P6		equ	00479H	;JNS	$+6
I_JLE_P2                equ     0007EH  ;JLE    $+2     mslin

I_LEA_AX_SI_DISP16	equ	0848Dh	;lea	ax,WordDisp[si]
I_LEA_AX_DI_DISP16	equ	0858Dh	;lea	ax,WordDisp[di]
I_LODSB			equ	0ACh	;LODSB
I_LOOP			equ	0E2h	;LOOP

I_MOV_AH_AL		equ	0E08Ah	;MOV	ah,al
I_MOV_AH_DEST		equ	0258Ah	;MOV	ah,[di]
I_MOV_AH_SI_DISP16	equ	0A48Ah	;MOV	ah,WordDisp[si]
I_MOV_AL_0FFH		equ	0FFB0h	;MOV	al,0FFH
I_MOV_AL_AH		equ	0C48Ah	;MOV	al,ah
I_MOV_AL_DL		equ	0C28Ah	;MOV	al,dl
I_MOV_AL_DH		equ	0C68Ah	;MOV	al,dh
I_MOV_AL_DEST		equ	0058Ah	;MOV	al,[di]
I_MOV_AL_MEM		equ	0A0h	;MOV	al,[addr]
I_MOV_AL_SI_DISP16	equ	0848Ah	;MOV	al,WordDisp[si]
I_MOV_AX_DS		equ	0D88Ch	;MOV	ax,ds
I_MOV_AX_DI		equ	0C78Bh	;MOV	ax,di
I_MOV_AX_ES		equ	0C08Ch	;MOV	ax,es
I_MOV_AX_SI		equ	0C68Bh	;MOV	ax,si
I_MOV_AX_WORD_I		equ	0B8h	;MOV	ax,immediate
I_MOV_BL_AL		equ	0D88Ah	;MOV	bl,al
I_MOV_AL_BYTE_I		equ	0B0h	;MOV	al,immediate    mslin
I_MOV_BL_BYTE_I		equ	0B3h	;MOV	bl,immediate
I_MOV_BP_WORD_I		equ	0BDh	;MOV	bp,immediate
I_MOV_BX_WORD_I		equ	0BBh	;MOV	bx,word immediate
I_MOV_CX_DS		equ	0D98Ch	;MOV	cx,ds
I_MOV_CX_WORD_I		equ	0B9h	;MOV	cx,immediate
I_MOV_DH_BX_DISP8	equ	0778Ah	;MOV	dh,ByteDisp[si]
I_MOV_DI_AX		equ	0F88Bh	;MOV	di,ax
I_MOV_DL_AL		equ	0D08Ah	;MOV	dl,al
I_MOV_DS_AX		equ	0D88Eh	;MOV	ds,ax
I_MOV_DS_CX		equ	0D98Eh	;MOV	ds,cx
I_MOV_ES_AX		equ	0C08Eh	;MOV	es,ax
I_MOV_MEM_AL		equ	0A2h	;MOV	[addr],al
I_MOV_SI_AX		equ	0F08Bh	;MOV	si,ax
I_MOVSB			equ	0A4h	;MOVSB
I_MOVSW			equ	0A5h	;MOVSW
I_MOV_MEM_AX		equ	0A2h	;MOV	[addr],ax       ;mslin

I_MOV_BL_BYTE_I         equ     0B3h    ;MOV    bl, byte immediate

I_NOT_AL		equ	0D0F6h	;NOT	al
I_NOT_AX		equ	0D0F7h	;NOT	ax

I_OR_AL_AH		equ	0C40Ah	;OR	al,ah
I_OR_AH_AL		equ	0E00Ah	;OR	ah,al

I_POP_BX		equ	05Bh	;POP	bx
I_POP_SI		equ	05Eh	;POP	si
I_POP_DI_POP_CX		equ	0595Fh	;POP	di
					;POP	cx
I_PUSH_BX		equ	053h	;PUSH	bx
I_PUSH_SI		equ	056h	;PUSH	si
I_PUSH_CX_PUSH_DI	equ	05751h	;PUSH	cx
					;PUSH	di
I_REP			equ	0F3h	;REP
I_RET_NEAR		equ	0C3h	;RET	near
I_RET_FAR		equ	0CBh	;RET	far
I_ROL_AL_1		equ	0C0D0h	;ROL	al,1
I_ROR_AL_1		equ	0C8D0h	;ROR	al,1
I_ROL_AL_N		equ	0C0C0h	;ROL	al,N  -- next byte is N
I_ROR_AL_N		equ	0C8C0h	;ROR	al,N  -- next byte is N

I_SHL_BL_1		equ	0E3D0h	;SHL	bl,1
I_SS_OVERRIDE		equ	036h	;SS:
I_STOSB			equ	0AAh	;STOSB
I_STOSW			equ	0ABh	;STOSW

I_XOR_AL_MEM		equ	00632h	;XOR	al,[addr]
I_XOR_AL_BYTE_I		equ	034h	;XOR	al,byte immediate
I_XOR_AX_WORD_I		equ	035h	;XOR	ax,word immediate
I_XOR_BH_BH		equ	0FF32h	;XOR	BH,BH
I_XOR_MEM_WORD_I	equ	03681H	;XOR	[addr],word immediate

;mslin added
I_MOV_DX_WORD_I		equ	0BAh	;MOV	dx,immediate
I_POP_DX		equ	05Ah	;POP	dx
I_MOV_DX_DS		equ	0DA8Ch	;MOV	dx,ds
I_MOV_AL_000H		equ	000B0h	;MOV	al,000H


	page

;	INCREASE is the flag used to show that the BLT operation will be
;	increasing in Y (Y+).
;
;	DECREASE is the flag used to show that the BLT operation will be
;	decreasing in Y (Y-).
;
;	STEPLEFT is the flag used to show that the BLT will be stepping
;	left (i.e. start at the right hand corner of the source, stepping
;	left, or X-).
;
;	STEPRIGHT is the flag used to show that the BLT will be stepping
;	right (i.e. start at the left hand corner of the source, stepping
;	right, or X+).


INCREASE	equ	1		;Incrementing
DECREASE	equ	-1		;Decrementing
STEPLEFT	equ	0		;Stepping to the left
STEPRIGHT	equ	1		;Stepping to the right

	page

;	gl_the_flags
;
;	F0_GAG_CHOKE	Set if the source and destination are of different
;			color formats.	When set, some form of color
;			conversion will be required.
;
;			Once you see what all is involved with color
;			conversion, you'll understand why this flag is
;			called this.
;
;	F0_COLOR_PAT	Set if color pattern fetch code will be used.  If
;			clear, then mono pattern fetch code will be used.
;			Mono/color pattern fetch is always based on the
;			destination being mono/color (it is the same).
;
;	F0_PAT_PRESENT	Set if a pattern is involved in the BLT.
;
;	F0_SRC_PRESENT	Set if a source  is involved in the BLT.
;
;	F0_SRC_IS_DEV	Set if the source is the physical device.  Clear if
;			the source is a memory bitmap.
;
;	F0_SRC_IS_COLOR	Set if the source is color, clear if monochrome.
;
;	F0_DEST_IS_DEV	Set if the destination is the physical device.
;			Clear if the destination is a memory bitmap.
;
;	F0_DEST_IS_COLOR
;			Set if the destination is color, clear if
;			monochrome.


F0_GAG_CHOKE		equ	10000000b	;Going mono <==> color
F0_COLOR_PAT		equ	01000000b	;Use color pattern fetch code
F0_PAT_PRESENT		equ	00100000b	;Pattern is involved in blt
F0_SRC_PRESENT		equ	00010000b	;Source is involved in blt
F0_SRC_IS_DEV		equ	00001000b	;Source is the device
F0_SRC_IS_COLOR		equ	00000100b	;Source is color
F0_DEST_IS_DEV		equ	00000010b	;Destination is the device
F0_DEST_IS_COLOR	equ	00000001b	;Destination is color

;-----------------------------------------------------------------------;
; Definitions for fbFetch
;-----------------------------------------------------------------------;

FF_NO_LAST_FETCH	equ	00000010b	;Final fetch might GP
FF_TWO_INIT_FETCHES	equ	00000001b	;Two initial fetches needed
FF_ONE_INIT_FETCH	equ	       0	;One initial fetche  needed
FF_ONLY_1_DEST_BYTE	equ	00000100b	;Only one destination byte
FF_ONLY_1_SRC_BYTE	equ	00001000b	;Only one source byte


;-----------------------------------------------------------------------;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\frame.h ===
/*
**  Copyright (c) 1991 Microsoft Corporation
*/
//==============================================================================
// FILE                         FRAME.H
//
// MODULE                       JUMBO Printer Driver, Queue Processor,
//                              Resource Executor, & Comm Module
//
// PURPOSE                      FRAME structure format
//
// DESCRIBED IN                 Jumbo Device Driver Design Description
//
// EXTERNAL INTERFACES
//
// INTERNAL INTERFACES
//
// MNEMONICS
//
// HISTORY  07/12/91 o-rflagg   Created
//          01/15/92 steveflu   bring up to coding conventions,
//                              change for QP interface
//
//==============================================================================


#ifndef _FRAME_
#define _FRAME_

// Don't change FRAME unless you also change the COMM driver and
// the Queue Processor, and the Resource Executor, and ....
typedef struct FRAMEtag
{
    WORD wReserved;
    WORD wSize;             // size of this block
    LPBYTE lpData;          // pointer to frame data
} FRAME;
typedef FRAME FAR *LPFRAME;
typedef FRAME NEAR *PFRAME;

#endif // _FRAME_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\devconst.inc ===
;----------------------------Module-Header------------------------------;
; Module Name: DEVCONST.BLT
;
; Device-specific constants.
;
; Created: In Windows' distant past (c. 1983)
;
; Copyright (c) 1983 - 1987  Microsoft Corporation
;
; This file is part of a set that makes up the Windows BitBLT function
; at driver-level.
;-----------------------------------------------------------------------;

;	MAX_BLT_SIZE is the maximum stack space required for the BITBLT
;	code.  This is a hard number to compute.  It must be based on
;	the worst case situation:
;
;		worst phase alignment
;		worst color conversions
;		first byte present
;		last byte present
;		full inner loop
;		jump into the inner loop
;
;	and any other factor which could increase the size of the code.


MAX_BLT_SIZE	=	452		;Max stack space a BLT will require


ifdef	GEN_COLOR_BLT
;	The following flags are used in the inner loops to both control
;	the EGA read/write enable registers, and the plane loop count.
;
;	They are based on a simple relationship of the EGA's Map Mask
;	register and Read Map Select Register when used as a three plane
;	system:
;
;	Map Mask:     D3 D2 D1 D0	   Read Map: D2 D1 D0
;
;	  C0 plane     0  0  0	1		      0  0  0
;	  C1 plane     0  0  1	0		      0  0  1
;	  C2 plane     0  1  0	0		      0  1  0
;
;
;	Note that to convert the map mask into a read mask for the
;	same plane only requires a "SHR x,1" instruction.  This trick
;	would not work if all four planes were used.
;
;	In four plane mode, when the above mapping occurs becomes:
;
;	  C3 plane     1  0  0	0		      1  0  0
;
;	  To map this into the correct read map register of 11b:
;
;		cmp	mask,100b	;Set 'C' if not C3
;		adc	mask,-1 	;sub -1 only if C3
;
;
;
;	The "loop counter" will consist of a bit shifted left every
;	interation of the loop, which will be used as stated above.
;	When this bit mask reaches a predetermined value, the loop
;	will terminate.


COLOR_OP	equ	C0_BIT		;Color operations start with C0
MONO_OP		equ	MONO_BIT 	;Mono operations start with mono bit

ifdef	FOUR_PLANE
END_OP		equ	(C3_BIT+MONO_BIT) SHL 1	;Loop terminating bits
else
END_OP		equ	(C2_BIT+MONO_BIT) SHL 1	;Loop terminating bits
endif





;	dl_moore_flags
;
;	dl_moore_flags pertain to color conversion only.  If color
;	conversion doesn't apply to the BLT, these flags will not
;	be defined.
;
;
;	F1_REP_OK		When F1_REP_OK is set, then the innerloop code can
;			use a REP MOVSx instruction.  This will be the
;			case if:
;
;			a)  The source is the EGA and the color compare
;			    register can be used to do the conversion
;			    from color to monochrome.
;
;			b)  The source is monochrome, the background
;			    color white, and the foreground color black,
;			    in which case color converison of the source
;			    would just give the source.
;
;	F1_NO_MUNGE 	Set under the same conditions as "b" above.


F1_REP_OK	equ	10000000b	;Using REP is ok (when F0_GAG_CHOKE)
F1_NO_MUNGE 	equ	01000000b	;No mono ==> color conversion table
;		equ	00100000b
;		equ	00010000b
;		equ	00001000b
;		equ	00000100b
;		equ	00000010b
;		equ	00000001b

endif	;GEN_COLOR_BLT


	page

;	The DEV structure contains all the information taken from the
;	PDevices passed in.  PDevices are copied to the frame to reduce
;	the number of long pointer loads required.  Having the data
;	contained in the structure allows MOVSW to be used when copying
;	the data.
;
;	width_bits	The number of pixels wide the device is.
;
;	height		The number of scans high the device is.
;
;	width_b		The width of a scan in bytes.
;
;	lp_bits		The pointer to the actual bits of the device.
;			It will be adjusted as necessary to point to the
;			first byte to be modified by the BLT operation.
;
;	plane_w		Width of one plane of data.  Only used if the
;			device is a small color bitmap.
;
;	seg_index	Index to get to the next segment of the bitmap.
;			Only defined if the bitmap is a huge bitmap.
;
;	scans_seg	Number of scan lines per 64K segment.  Only
;			defined if the bitmap is a huge bitmap.
;
;	fill_bytes	Number of unused bytes per 64K segment.  Only
;			defined if the bitmap is a huge bitmap.
;
;	dev_flags	Device Specific Flags
;			SPANS_SEG   - BLT will span 64K segment of the device
;			IS_DEVICE   - This is the physical device
;			COLOR_UP    - Generate color scan line update
;			IS_COLOR    - Device is a color device
;
;	comp_test	JC or JNC opcode, used in the huge bitmap scan line
;			update code.  This opcode is based on whether the
;			BLT is Y+, or Y-.
;
;	comp_value	Range of addresses to compare the offset against
;			to determine if overflow occured.  comp_test is the
;			conditional jump to use for no overflow after doing
;			a compare with the offset register and this value.
;
;	next_scan	Bias to get to the next (previous) scan line.


DEV		struc

  width_bits	dw	?		;Width in bits
  height	dw	?		;Height in scans
  width_b	dw	?		;Width in bytes
  lp_bits	dd	?		;Pointer to the bits
  plane_w	dw	?		;Increment to next plane
  seg_index	dw	?		;Index to next segment if huge bitmap
  scans_seg	dw	?		;Scans per segment if huge
  fill_bytes	dw	?		;Filler bytes per segment if huge
  dev_flags	db	?		;Device flags as given above
  comp_test	db	?		;JC or JNC opcode
  comp_value	dw	?		;Huge bitmap overflow range
  next_scan	dw	?		;Index to next scan

DEV		ends


;	Constants for use in dev_flags field of DEV structure:

IS_COLOR 	equ	00000001b	;Device is color
IS_DEVICE	equ	00000010b	;Physical Device
COLOR_UP 	equ	00000100b	;Color scan line update
SPANS_SEG	equ	10000000b	;BLT spans a segment boundary

OFF_LP_BITS	equ	wptr lp_bits	;Offset  portion of lp_bits
SEG_LP_BITS	equ	wptr lp_bits+2	;Segment portion of lp_bits
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\gdi32blt.c ===
#include <windows.h>
#include "constant.h"
#include "frame.h"      // driver header file, resource block format
#include "jtypes.h"         /* Jumbo type definitions.                */
#include "jres.h"       // cartridge resource data type definition
#include "hretype.h"          /* Slice Descriptor defs.                 */
#include "hreext.h"

//==============================================================================
BOOL OpenBlt (LPRESTATE lpRE, UINT yBrush)
{
	HDC hdcScreen;
	HBITMAP hbmDst;
  LPBITMAP lpbmBand = lpRE->lpBandBuffer;
 	UINT cbBand = lpbmBand->bmHeight * lpbmBand->bmWidthBytes;
 	LPVOID lpBits;
 	
	struct
	{
		BITMAPINFOHEADER bmih;
    DWORD dwPal[2];
	}
		bmiDst;

  // Create memory device contexts.
  hdcScreen = CreateIC ("DISPLAY", NULL, NULL, NULL);
  lpRE->hdcDst = CreateCompatibleDC (hdcScreen);
  lpRE->hdcSrc = CreateCompatibleDC (hdcScreen);
  DeleteDC (hdcScreen);

 	// Initialize destination bitmap.
  bmiDst.bmih.biSize = sizeof(BITMAPINFOHEADER);
  bmiDst.bmih.biWidth = lpbmBand->bmWidth;
  bmiDst.bmih.biHeight = -lpbmBand->bmHeight; // top-down
  bmiDst.bmih.biPlanes = 1;
  bmiDst.bmih.biBitCount = 1;
  bmiDst.bmih.biCompression = BI_RGB;
  bmiDst.bmih.biSizeImage = 0;
  bmiDst.bmih.biClrUsed = 0;
  bmiDst.bmih.biClrImportant = 0;
  bmiDst.dwPal[0] = RGB (  0,   0,   0);
  bmiDst.dwPal[1] = RGB (255, 255, 255);

  // Create DIB section.
	hbmDst = CreateDIBSection
	 	(lpRE->hdcDst, (LPBITMAPINFO) &bmiDst, DIB_RGB_COLORS, &lpBits, NULL, 0);
	if (!hbmDst)
		return FALSE;
	lpRE->hbmDef = SelectObject (lpRE->hdcDst, hbmDst);
  lpRE->hbrDef = NULL;
  		
  // Swap frame buffers.
  lpRE->lpBandSave = lpbmBand->bmBits;
  lpbmBand->bmBits = lpBits;

  // Disable GDI batching.
  GdiSetBatchLimit (1);

	return TRUE;
}

//==============================================================================
void CloseBlt (LPRESTATE lpRE)
{
	// Restore frame buffer.
	LPBITMAP lpbmBand = lpRE->lpBandBuffer;
 	UINT cbBand = lpbmBand->bmHeight * lpbmBand->bmWidthBytes;
  memcpy (lpRE->lpBandSave, lpbmBand->bmBits, cbBand);
	lpbmBand->bmBits = lpRE->lpBandSave;

  // Restore default objects.
  DeleteObject (SelectObject (lpRE->hdcDst, lpRE->hbmDef));
  DeleteObject (SelectObject (lpRE->hdcDst, lpRE->hbrDef));

  // Destroy memory device contexts.
 	DeleteDC (lpRE->hdcDst);
 	DeleteDC (lpRE->hdcSrc);

 	// Restore GDI batching.
  GdiSetBatchLimit (0);
}

//==============================================================================
DWORD FAR PASCAL RP_BITMAP1TO1
(
	LPRESTATE lpRE,
	WORD    xSrc,    // Left padding
	short   yDst,	   // Top row of destination.
	short   xDst,	   // Left column of destination.
	WORD    clLine,  // Longs per scan line
	WORD    yExt,    // Height in pixels
	WORD    xExt,    // Width in pixels 
	LPDWORD lpSrc,   // Far pointer to source
	LPDWORD lpPat,   // Far pointer to pattern
	DWORD   dwRop		 // Raster operation
)
{
	HBITMAP hbmSrc, hbmOld;
	
  // Create source bitmap.
	hbmSrc = CreateCompatibleBitmap (lpRE->hdcSrc, 32*clLine, yExt);
	SetBitmapBits (hbmSrc, 4*clLine*yExt, lpSrc);
	hbmOld = SelectObject (lpRE->hdcSrc, hbmSrc);

  // Call GDI BitBlt.
	BitBlt (lpRE->hdcDst, xDst, yDst, xExt, yExt, lpRE->hdcSrc, xSrc, 0, lpRE->dwRop);

  // Destroy source bitmap.
  SelectObject (lpRE->hdcSrc, hbmOld);
  DeleteObject (hbmSrc);
	return 0;	
}

//==============================================================================
BOOL SetBrush (LPRESTATE lpRE)
{
	HBITMAP hbmPat;
	HBRUSH hbrPat, hbrOld;

  // Create pattern brush.
  hbmPat = CreateBitmap (32, 32, 1, 1, lpRE->lpCurBrush);
	hbrPat = CreatePatternBrush (hbmPat);
	DeleteObject (hbmPat);

	// Replace previous brush.
	hbrOld = SelectObject (lpRE->hdcDst, hbrPat);
	if (lpRE->hbrDef)
		DeleteObject (hbrOld);  // delete old brush
	else
		lpRE->hbrDef = hbrOld;  // save default brush

	return TRUE;
}

//==============================================================================
ULONG FAR PASCAL RP_FILLSCANROW
(
	LPRESTATE  lpRE,       // resource executor context
	USHORT     xDst,       // rectangle left
	USHORT     yDst,       // rectangle right
	USHORT     xExt,       // rectangle width
	USHORT     yExt,       // rectangle height
	UBYTE FAR* lpPat,      // 32x32 pattern bitmap
	DWORD      dwRop,      // raster operation
	LPVOID     lpBand,     // output band buffer
	UINT       cbLine,     // band width in bytes
	WORD       yBrush      // brush position offset
)
{
	return PatBlt (lpRE->hdcDst, xDst, yDst, xExt, yExt, lpRE->dwRop);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\genlocal.inc ===
;----------------------------Module-Header------------------------------;
; Module Name: GENLOCAL.BLT
;
; Parameters and generic local variables for BitBLT.
;
; Created: In Windows' distant past (c. 1983)
;
; Copyright (c) 1983 - 1987  Microsoft Corporation
;
; This file contains the parameters passed to BitBLT, as well as local
; variables that all of its code expects.
;
; The prefix "gl_" stands for "generic local". Other prefixes are "cl_"
; for "color-related local" and "dl_" for "device-related local".
;
; This file is part of a set that makes up the Windows BitBLT function
; at driver-level.
;-----------------------------------------------------------------------;

        parmD   _PRT_FrameStart      ;Get pointer to destination
        parmD   _lpgBrush
        parmW   _PRT_BytesPerScanline
        parmW   _usBrushWidth
        parmW   _PRT_Max_X
        parmW   _PRT_Max_Y
        parmW   _usgPosOff      ; dstseng 08/06/92 To get correct Brush Offset
        parmW   SrcxOrg                 ;Source      origin - x coordinate
        parmW   DestyOrg                ;Destination origin - y coordinate
        parmW   DestxOrg                ;Destination origin - x coordinate
        parmW   DestWarp                ;Destination # of DWord per scanline
        parmW   yExt                    ;y extent of the BLT
        parmW   xExt                    ;x extent of the BLT
        parmD   lpSrcDev                ;--> to source bitmap descriptor
        parmD   lpPBrush                ;--> to a physical brush (pattern)
        parmD   Rop                     ;Raster operation descriptor

;       Generic locals (i.e. used by all BitBLT code)

ifdef   THIS_IS_DOS_3_STUFF
else
;        localW  ScreenSelector
endif
        localB  gl_phase_h              ;Horizontal phase (rotate count)
        localW  gl_pat_row              ;Current row for patterns [0..31]
;mslin        localB  gl_direction            ;Increment/decrement flag

        localB  local_enable_flag       ;Local copy of the enable flag
;       localB  mask_flags              ;Number of first fetches needed
;
;MF_PHASE               equ     00000111b
;MF_PHASE_POSITIVE      equ     00001000b
;MF_STEP_RIGHT          equ     00010000b
;MF_WORD_FETCH          equ     00100000b
;MF_BIG_PHASE           equ     01000000b ; phase > 4
;MF_UN_USED             equ     10000000b

        localB  gl_the_flags
        localB  gl_first_fetch          ;Number of first fetches needed
        localB  gl_step_direction       ;Direction of move (left right)
        localW  gl_start_mask           ;Mask for first dest byte
        localW  gl_last_mask            ;Mask for last  dest byte
        localW  gl_mask_p               ;Horizontal phase mask
        localW  gl_inner_loop_count     ;# of entire bytes to BLT in innerloop
        localW  gl_operands             ;Operand string
        localW  gl_start_fl             ;Start of fetch/logic operation
        localW  gl_end_fl               ;End   of fetch/logic operation
        localW  gl_end_fls              ;End   of fetch/logic/store operation
        localD  gl_blt_addr             ;BLT offset address
        localW  WorkSelector            ; selector to use
        localW  cFetchCode              ;size of the fetch code alone


        localW  SrcxOrg                 ;Source origin - x coordinate
        localW  SrcyOrg                 ;Source origin - y coordinate
        localW  gl_pattern_ptr          ;next fetch byte pattern address
        localW  destOffset
        localW  gl_pat_col              ;Current row for patterns [0..3]
        localW  gl_brush_width          ;Current brush width in byte
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\gendata.inc ===
;----------------------------Module-Header------------------------------;
; Module Name: GENDATA.BLT
;
; Data definitions for BitBLT.
;
; Created: In Windows' distant past (c. 1983)
;
; Copyright (c) 1983 - 1987  Microsoft Corporation
;
; This file is a catchall for data definitions other that code templates
; for BitBLT.
;
; This file is part of a set that makes up the Windows BitBLT function
; at driver-level.
; 03/06/92  dstseng change bitmask_tbl1/bitmask_tbl2 to private
;-----------------------------------------------------------------------;

;	The following two bitmask tables are used for fetching
;	the first and last byte used-bits bitmask.


;	public bitmask_tbl1
;	public _bitmask_tbl1
bitmask_tbl1	label	byte
_bitmask_tbl1	label	byte
	db	11111111b		;Masks for leftmost byte
	db	01111111b
	db	00111111b
	db	00011111b
	db	00001111b
	db	00000111b
	db	00000011b
	db	00000001b


;	public bitmask_tbl2
;	public _bitmask_tbl2
bitmask_tbl2	label	byte
_bitmask_tbl2	label	byte
	db	10000000b		;Masks for rightmost byte
	db	11000000b
	db	11100000b
	db	11110000b
	db	11111000b
	db	11111100b
	db	11111110b
	db	11111111b



;	phase_tbl1 is used for loading the "used" bits and "saved" bits
;	bitmasks for cases 1,2,3 where the step direction is left to
;	right.	If it weren't for the case of zero, this could be done
;	with a simple rotate of 00FF.	For cases 4,5,6, a simple rotate
;	can create the mask needed.


;	public	phase_tbl1
phase_tbl1	label	word
	db	11111111b,00000000b		;Used bits, saved bits
	db	00000001b,11111110b
	db	00000011b,11111100b
	db	00000111b,11111000b
	db	00001111b,11110000b
	db	00011111b,11100000b
	db	00111111b,11000000b
	db	01111111b,10000000b
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\hreext.h ===
// Extern functions declaration

#ifndef _HREEXT_
#define _HREEXT_

// Execute an RPL
void DoRPL (LPHRESTATE lpHREState, LPRPLLIST lpRPL);

BOOL InitDisplay (LPRESTATE, UINT);

// BitBlt: source is aligned, destination is not aligned
ULONG FAR PASCAL RP_BITMAP1TO1
(
	 LPVOID   lpContext,          // resource executor context
   USHORT   us_xoffset,         /* left offset of source bitmap */
   short    ul_row,             /* top row position */
   short    ul_col,             /* left column position */
   USHORT   ul_warp,            /* longs per scan line */
   USHORT   ul_height,          /* num of dot rows */
   USHORT   ul_width,           /* num of significant dot columns */
   ULONG FAR *pul_src,          /* bit map data to be copied */
   ULONG FAR *pul_pat,          /* pattern pointer */
   ULONG    ul_rop
);

// PatBlt
ULONG FAR PASCAL RP_FILLSCANROW
(
	LPRESTATE  lpRE,       // resource executor context
	USHORT     xDst,       // rectangle left
	USHORT     yDst,       // rectangle right
	USHORT     xExt,       // rectangle width
	USHORT     yExt,       // rectangle height
	UBYTE FAR* lpPat,      // 32x32 pattern bitmap
	DWORD      dwRop,      // raster operation
	LPVOID     lpBand,     // output band buffer
	UINT       cbLine,     // band width in bytes
	WORD       yBrush      // brush position offset
);

// Vertical Bitmaps
USHORT FAR PASCAL RP_BITMAPV
(
   USHORT  usRow,             /* Row to start Bitmap             */
   USHORT  usCol,             /* Column to Start Bitmap          */
   UBYTE   ubTopPadBits,      /* Bits to skip in the data stream */
   USHORT  usHeight,          /* Number of bits to draw          */
   UBYTE FAR  *ubBitmapData,  /* Data to draw                    */
   LPVOID  lpBits,            // output band buffer
   UINT    cbLine             // bytes per scan line
);

UINT RP_LineEE_Draw
(
	RP_SLICE_DESC FAR *slice,
	LPBITMAP lpbmBand
);
 
// Convert a line from endpoint form to slice form
void RP_SliceLine
(
   SHORT s_x1, SHORT s_y1,  // endpoint 1
   SHORT s_x2, SHORT s_y2,  // endpoint 2
   RP_SLICE_DESC FAR* lpsd, // output slice form of line
   UBYTE fb_keep_order      // keep drawing order on styled lines/
);

#endif // _HREEXT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\glyph.cpp ===
/*==============================================================================
This source file contains routines for chaingon decompression of glyphs.

29-Dec-93    RajeevD    Integrated into unified resource executor.
==============================================================================*/
#include <ifaxos.h>
#include <memory.h>
#include "resexec.h"

#include "constant.h"
#include "jtypes.h"     // type definition used in cartridge
#include "jres.h"       // cartridge resource data type definition
#include "hretype.h"    // define data structure used by hre.c and rpgen.c

#define CEIL32(val) (((val) + 31) & ~31)

#define RUN_FLAG ((short) 0x8000)

// Bit Stream Object
typedef class FAR BITIO
{
private:
	UINT uBit;
public:
	LPBYTE lpb;

	BITIO (LPBYTE lpbInit) {lpb = lpbInit, uBit = 0;}
	BITIO () {uBit = 0;}

	short Read2  (void);
	short Read4  (void);
	short Read6  (void);
	short Read8  (void);
	WORD  Read8U (void);
	short Read16 (void);
	WORD  ReadU  (void);

	short DecodeDelta (void);
}
	FAR *LPBITIO;

//==============================================================================
short BITIO::Read2 (void)
{
	short s;

	// Mask and shift 2-bit field.
	s = (*lpb >> (6 - uBit)) & 0x03;

	// Advance stream pointer.
	uBit += 2;
	if (uBit == 8)
		{lpb++; uBit = 0;}

#ifndef BITIO_NOSIGNEXT
	if (s >= 2)
		s -= 4;	// Sign extend into short.
#endif
	return s;
}

//========================================================================
short BITIO::Read4 (void)
{
	LPBYTE lpbVal;
	short s;
	
	if (uBit == 6)
	{
		lpbVal = (LPBYTE) &s;
		lpbVal[1] = *lpb++;
		lpbVal[0] = *lpb;
		s >>= 6;
		s &= 0x000F;
		uBit = 2;
	}

	else
	{
		s = (*lpb >> (4 - uBit)) & 0x0F;
		uBit += 4;
		if (uBit == 8)
			{ lpb++; uBit = 0; }
	}

#ifndef BITIO_NOSIGNEXT
	if (s >= 8)
		s -= 16; // Sign extend into short.
#endif

	return s;
}

//========================================================================
short BITIO::Read6 (void)
{
	LPBYTE lpbVal;
	short s;
	
	switch (uBit/2)
	{
		case 0:
			s = (short) (*lpb >> 2);
			uBit = 6;
			break;
				
		case 1:
			s = (short) *lpb++;
			uBit = 0;
			break;
			
		case 2:
			lpbVal = (LPBYTE) &s;
			lpbVal[1] = *lpb++;
			lpbVal[0] = *lpb;
			s >>= 6;
			uBit = 2;
			break;
			
		case 3:
			lpbVal = (BYTE *) &s;
			lpbVal[1] = *lpb++;
			lpbVal[0] = *lpb;
			s >>= 4;
			uBit = 4;
			break;
	}

	s &= 0x003F;
	
#ifndef BITIO_NOSIGNEXT
	if (s >= 32)
		s -= 64; // Sign extend into short.
#endif
	return s;
}

//========================================================================
short BITIO::Read8 (void)
{
	short s;
	LPBYTE lpbVal;

	if (uBit == 0)
		s = (short) *lpb++;

	else
	{
		lpbVal = (LPBYTE) &s;
		lpbVal[1] = *lpb++;
		lpbVal[0] = *lpb;
		s >>= (8 - uBit);
		s &= 0x00FF;
	}

#ifndef BITIO_NOSIGNEXT
	if (s >= 128)
		s -= 256;	// Sign extend into short.
#endif

	return s;
}

//========================================================================
WORD BITIO::Read8U (void)
{
	short s;
	LPBYTE lpbVal;

	if (uBit == 0)
		s = (short) *lpb++;

	else
	{
		lpbVal = (LPBYTE) &s;
		lpbVal[1] = *lpb++;
		lpbVal[0] = *lpb;
		s >>= (8 - uBit);
		s &= 0x00FF;
	}

	return s;
}

//========================================================================
short BITIO::Read16 (void)
{
	short s;
	LPBYTE lpbVal = (LPBYTE) &s;

	lpbVal[1] = *lpb++;
	lpbVal[0] = *lpb++;

	switch (uBit/2)
	{
		case 0:
			break;
			
		case 1:
			s <<= 2;
			s |= (*lpb >> 6) & 0x03;
			break;
			
		case 2:
			s <<= 4;
			s |= (*lpb >> 4) & 0x0F;
			break;
			
		case 3:
			s <<= 6;
			s |= (*lpb >> 2) & 0x3F;
			break;
	}

	return s;
}

//==============================================================================
WORD BITIO::ReadU (void)
{
	WORD w = Read8U();
	if (w == 0xFF)
		w = Read16();
	return w;
}


/*==============================================================================
This utility procedure uses an OR operation to fill runs in a scan buffer.
==============================================================================*/
LPBYTE FillRun     // Returns next scan line
(
	LPBYTE lpbLine,   // first output scan line
	UINT   cbLine,    // width of a scan line
 	UINT   xLeft,     // left column, inclusive
	UINT   xRight,    // right column, exclusive
	UINT   cLines = 1 // number of scan lines
)
{
	const static WORD wFill[16] =
	{
		0xFFFF, 0xFF7F, 0xFF3F, 0xFF1F,
		0xFF0F, 0xFF07, 0xFF03, 0xFF01,
		0xFF00, 0x7F00, 0x3F00, 0x1F00,
		0x0F00, 0x0700, 0x0300, 0x0100,
	};

	UINT iwLeft, iwRight;
	WORD wLeft,  wRight; // masks
	LPWORD lpwLine = (LPWORD) lpbLine;
	UINT cwLine = cbLine / 2;

	iwLeft  = xLeft  / 16;
	iwRight = xRight / 16;
	wLeft  =  wFill [xLeft  & 15];
	wRight = ~wFill [xRight & 15];
	
	if (iwLeft == iwRight)
	{
		while (cLines--)
		{
			// Run is within a single WORD.
			lpwLine[iwLeft] |= wLeft & wRight;
			lpwLine += cwLine;
		}
	}
	
	else
	{
		UINT cbMiddle = 2 * (iwRight - iwLeft - 1);

		while (cLines--)
		{
			// Run spans more than one WORD.
			lpwLine[iwLeft] |= wLeft;
			_fmemset (lpwLine + iwLeft + 1, 0xFF, cbMiddle);
			if (wRight) // Don't access beyond output!
				lpwLine[iwRight] |= wRight;
			lpwLine += cwLine;
		}	
	}

	return (LPBYTE) lpwLine;
}

//==============================================================================
UINT              // unpacked size
UnpackGlyph  
(	
	LPBYTE lpbIn,   // packed glyph
	LPBYTE lpbOut   // output buffer
)
{
	BITIO bitio (lpbIn); // input bit stream
	LPWORD lpwOut;       // alias for lpbOut
	WORD xExt, yExt;     // glyph dimensions
	UINT cbLine;         // scan line width

	// Decode glyph header.
	xExt = bitio.ReadU();
	yExt = bitio.ReadU();
	cbLine = CEIL32(xExt) / 8;
	
	// Write glyph dimensions.
	lpwOut = (LPWORD) lpbOut;
	*lpwOut++ = yExt;
	*lpwOut++ = xExt;
	lpbOut = (LPBYTE) lpwOut;

	// Clear output buffer.
	_fmemset (lpbOut, 0x00, cbLine * yExt);

	// Unpack each chain.
	while (1)	
	{
		LPBYTE lpbScan;         // output buffer
		UINT yTop;              // top of chaingon
		UINT xLeft, xRight;     // left and right bound
		short dxLeft, dxRight;  // left and right delta
		UINT cLine, cRun;       // line counters

		// Decode chain header.
		xRight = bitio.ReadU();
		if (!xRight) // termination
			goto done;
		cLine  = bitio.ReadU();
		xLeft  = bitio.ReadU();
    yTop   = bitio.ReadU();
		lpbScan = lpbOut + yTop * cbLine;
		xRight += xLeft;
	
		// Fill first row.
		lpbScan = FillRun (lpbScan, cbLine, xLeft, xRight);
		cLine--;

		// Fill remaining rows.
		while (cLine)
		{
			dxLeft = bitio.DecodeDelta ();

			if (dxLeft == RUN_FLAG) 
			{
				// Decode run of repeated lines.
 				cRun = (bitio.Read4() & 0xF) + 3;
				lpbScan = FillRun (lpbScan, cbLine, xLeft, xRight, cRun);
				cLine -= cRun;
			}
			
			else 
			{
				// Adjust by deltas.
				dxRight = bitio.DecodeDelta();
				xLeft  += dxLeft;
				xRight += dxRight;
				lpbScan = FillRun (lpbScan, cbLine, xLeft, xRight);
				cLine--;
   		}

	 	} // while (cLine--)

	} // while (1)

done:
	return 2 * sizeof(WORD) + yExt * cbLine;
}
	
//==============================================================================
void WINAPI UnpackGlyphSet (LPVOID lpIn, LPVOID lpOut)
{
	LPJG_GS_HDR lpSetIn  = (LPJG_GS_HDR) lpIn;
	LPJG_GS_HDR lpSetOut = (LPJG_GS_HDR) lpOut;
	LPBYTE lpbOut;
	WORD iGlyph;

	// Copy header.
	_fmemcpy (lpSetOut, lpSetIn, sizeof(JG_RES_HDR) + sizeof(WORD));

	// Create pointer to end of offset tables.
	lpbOut = ((LPBYTE) lpSetOut) + lpSetIn->ausOffset[0];

	// Unpack the glyphs.	
	for (iGlyph=0; iGlyph<lpSetIn->usGlyphs; iGlyph++)
 	{
		lpSetOut->ausOffset[iGlyph] = (USHORT)(lpbOut - (LPBYTE) lpSetOut);
		lpbOut += UnpackGlyph
			((LPBYTE) lpSetIn + lpSetIn->ausOffset[iGlyph], lpbOut);
 	}
}

//==============================================================================
short  // Returns delta (or RUN_FLAG)
BITIO::DecodeDelta (void)
{
	short s;

	s = Read2();	     
	if (s != -2)       // Trap -1, 0, +1.
		return s;

	s = Read4();	     // Get 4-bit prefix.
	switch (s)
	{
		case 0: // run of zeros
			return RUN_FLAG;

		case 1: // 6-bit literal
			s = Read6();
			return (s >= 0? s + 8  : s - 7);

		case -1: // 8-bit literal
			s = Read8();
			return (s >= 0? s + 40 : s - 39);

		case -8: // 16-bit literal
			return Read16();

		default: // 4-bit literal
			return s;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\hre.c ===
/*
**  Copyright (c) 1991 Microsoft Corporation
*/
//===========================================================================
// FILE                         HRE.C
//
// MODULE                       Host Resource Executor
//
// PURPOSE                      Convert A-form to B-form for jumbo driver
//
// DESCRIBED IN                 Resource Executor design spec.
//
// MNEMONICS                    n/a
// 
// HISTORY  1/17/92 mslin       created
//          3/30/92 mslin       Pre-compiled brush generated for each job.
//                              ideal case would be initialize PcrBrush in
//                              HRE.DLL loading, and free up when HRE 
//                              terminate. but we had problem in Dumbo, ???
//                              Expanded Brush Buffer allocated for each job.
//                              lpgBrush will be set to lpREState->lpBrushBuf
//                              in DoRpl().
//          4/15/92 mslin       added uiHREExecuteRPL() for dumbo.
//          9/27/93 mslin       added a new bit of wFlags in hHREOpen() for
//                              300/600 dpi:
//                                  bit2: 0 -- 300 dpi
//                                  bit2: 1 -- 600 dpi
//                              also remove DUMBO compiler switch. 
//          2/09/94 rajeevd     Undid all of the above changes.
//===========================================================================

// include file
#include <windows.h>
#include <windowsx.h>
#include <resexec.h>

#include "constant.h"
#include "jtypes.h"     // type definition used in cartridge
#include "jres.h"       // cartridge resource data type definition
#include "hretype.h"    // define data structure used by hre.c and rpgen.c

#include "hreext.h"
#include "multbyte.h"   // define macros to take care of byte ordering

#define HRE_SUCCESS             0x0     // successful return from HRE
#define HRE_EXECUTED_RPL        0x01    // Executed the final RP in an RPL
#define HRE_EXECUTED_ONE        0x02    // Executed only one RP from an RPL
                                        // (not the last one)
#define HRE_ERROR               0x03    // General HRE failure

// PRIVATE functions
static   UINT        PutRPL(LPHRESTATE lpHREState, LPFRAME lpFrameArray,
                     UINT uiCount);
static   UINT        FreeRPL(LPRPLLIST lpRPL);

#ifdef DEBUG
DWORD    dwrgTime[MAXBAND];
SHORT    sCurrentLine;
ULONG    ulgPageId = 0;
ULONG    ulgTimes[1000] = {0};
#endif

#include "windows.h"

//==============================================================================

#ifndef WIN32

BOOL WINAPI LibMain
	(HANDLE hInst, WORD wSeg, WORD wHeap, LPSTR lpszCmd)
{ return 1; }

int WINAPI WEP (int nParam);
#pragma alloc_text(INIT_TEXT,WEP)
int WINAPI WEP (int nParam)
{ return 1; }

#endif

//==============================================================================
HANDLE                 // context handle (NULL on failure)
WINAPI hHREOpen
(
	LPVOID lpBrushPat,   // array of 32x32 brush patterns
	UINT   cbLine,       // maximum page width in bytes
	UINT   cResDir       // entries in resource directory
)
{
   HANDLE      hHREState;
   LPHRESTATE  lpHREState;
   LPRESTATE   lpREState;
   LPRESDIR    lpDlResDir;

   // create a handle for the new session 
   if (!(hHREState = GlobalAlloc(GMEM_MOVEABLE, sizeof(HRESTATE))))
      return (NULL);
   lpHREState = (LPHRESTATE) GlobalLock (hHREState);

   // allocate Download ResDir Table
   if (!(lpDlResDir = (LPRESDIR) GlobalAllocPtr (GMEM_ZEROINIT, sizeof(RESDIR) * cResDir)))
   {
      // unlock and free HRESTATE
      GlobalUnlock(hHREState);
      GlobalFree(hHREState);
      return(NULL);
   }
   
   // allocate RESTATE data structure and Initialize it
   // this is graphic state of rendering 
   if (!(lpREState = (LPRESTATE) GlobalAllocPtr (GMEM_ZEROINIT, sizeof(RESTATE))))
   {
      GlobalUnlock(hHREState);
      GlobalFree(hHREState);
      GlobalFreePtr (lpDlResDir);
      return (NULL);
   }

#ifdef WIN32

  lpREState->lpBrushBuf = NULL;

#else

   if (!(lpREState->lpBrushBuf = (LPSTR) GlobalAllocPtr(GMEM_MOVEABLE, (cbLine + 4) * 16)))
   {
      GlobalUnlock(hHREState);
      GlobalFree(hHREState);
      GlobalFreePtr (lpDlResDir);
      GlobalFreePtr (lpREState);
      return (NULL);
   }

#endif
      
   // Initialize RESTATE
   lpREState->lpBrushPat = lpBrushPat;
                                            
   // Initialize HRESTATE
   lpHREState->hHREState = hHREState;
   lpHREState->scDlResDir = (USHORT)cResDir;
   lpHREState->lpDlResDir = lpDlResDir;
   lpHREState->lpRPLHead= NULL;
   lpHREState->lpRPLTail= NULL;
   lpHREState->lpREState = lpREState;

   GlobalUnlock(hHREState);
   return(hHREState);
}

//---------------------------------------------------------------------------
UINT                            // will be zero (0) if resource is processed
                                // succesfully, otherwise it will be an error
                                // code as defined above.
WINAPI uiHREWrite
(
    HANDLE      hHREState,      // handle returned previously by hREOpen
    LPFRAME     lpFrameArray,   // FAR pointer to an array of FRAME structs
    UINT        uiCount         // Number of FRAME structs pointed to by 
                                // lpFrameArray
)

// PURPOSE                      To add a resource block (RPLK) to the
//                              HRE state hash table for the context
//                              identified by hHREState.
//
// ASSUMPTIONS & ASSERTIONS     The memory for the RBLK has allready been
//                              Allocated and locked.  HRE will not copy the
//                              data, just the pointers.
//                              The lpFrameArray does not point to an SPL.
//                              All SPL's will be handled externally to HRE.
//
// INTERNAL STRUCTURES          
//
// UNRESOLVED ISSUES            
//
//---------------------------------------------------------------------------       
{
   LPHRESTATE     lpHREState;
   LPJG_RES_HDR   lpResHdr;
   LPRESDIR       lpResDir;
   ULONG          ulUID;
   USHORT         usClass;
   HANDLE         hFrame;
   LPFRAME        lpFrameArrayDup, lpFrame;
   UINT           uiLoopCount;

   lpHREState = (LPHRESTATE) GlobalLock (hHREState);

   // get resource class                                            
   lpResHdr = (LPJG_RES_HDR )lpFrameArray->lpData;
   usClass = GETUSHORT(&lpResHdr->usClass);
   switch(usClass)
   {
      case JG_RS_RPL: /*0x4*/
         // store into RPL list
         if( PutRPL(lpHREState, lpFrameArray, uiCount) != HRE_SUCCESS )
         {
            GlobalUnlock(hHREState);
            return(HRE_ERROR);   // out of memory
         }
         break;

      case JG_RS_GLYPH: /*0x1*/
      case JG_RS_BRUSH: /*0x2*/
      case JG_RS_BITMAP: /*0x3*/
         // check to see if uid >= size of hash table then reallocate
         ulUID = GETULONG(&lpResHdr->ulUid);
         lpResDir = lpHREState->lpDlResDir;
         if (ulUID >= lpHREState->scDlResDir)
         {
               return(HRE_ERROR);
         }

         // Free frame array of previous resource block
         lpFrameArrayDup = lpResDir[ulUID].lpFrameArray;
         if(lpFrameArrayDup)
           GlobalFreePtr (lpFrameArrayDup);
          
         // copy frame array
         if (!(hFrame = GlobalAlloc(GMEM_MOVEABLE, uiCount * sizeof(FRAME))))
            return (HRE_ERROR);
         if (!(lpFrameArrayDup = (LPFRAME)GlobalLock(hFrame)))
         {
            GlobalFree(hFrame);
            return (HRE_ERROR);
         }
         lpFrame = lpFrameArrayDup;
         for(uiLoopCount=0; uiLoopCount<uiCount; uiLoopCount++)
         {
            *lpFrame++ = *lpFrameArray++;
         }

         // put into hash table
         lpResDir[ulUID].lpFrameArray = lpFrameArrayDup;
         lpResDir[ulUID].uiCount = uiCount;
         break;
         
      default:
         // error return 
         break;

   }

   GlobalUnlock(hHREState);
   return(HRE_SUCCESS);

}


//---------------------------------------------------------------------------
UINT   WINAPI uiHREExecute
(
	HANDLE   hHREState,  // resource executor context
  LPBITMAP lpbmBand,   // output band buffer
  LPVOID   lpBrushPat  // array of 32x32 brush patterns
)
{
   LPHRESTATE  lpHREState;
   LPRESTATE   lpRE;
   LPRPLLIST   lpRPL, lpRPLSave;

   lpHREState = (LPHRESTATE) GlobalLock (hHREState);
   
   // Record parameters in RESTATE.
   lpRE = lpHREState->lpREState;
   lpRE->lpBandBuffer = lpbmBand;
   lpRE->lpBrushPat   = lpBrushPat;

   lpRPL = lpHREState->lpRPLHead;
   do
   {
     DoRPL(lpHREState, lpRPL);
      lpRPLSave = lpRPL;
      lpRPL=lpRPL->lpNextRPL;
      FreeRPL(lpRPLSave);
   }
   while(lpRPL);
   // if last RP executed then update lpRPLHead
   lpHREState->lpRPLHead = lpRPL;
   
   GlobalUnlock(hHREState);
   return(HRE_EXECUTED_RPL);

}

//---------------------------------------------------------------------------
UINT                            // will be zero (0) if HRE context is closed
                                // succesfully, otherwise it will be an error
                                // code as defined above.
WINAPI uiHREClose
(
    HANDLE      hHREState       // handle returned previously by hREOpen
)

// PURPOSE                      To close a previously opened context in the
//                              HRE.  All memory and state information 
//                              associated with the context will be freed.
//
// ASSUMPTIONS & ASSERTIONS     None.
//
// INTERNAL STRUCTURES          None.
//
// UNRESOLVED ISSUES            programmer development notes
//
// --------------------------------------------------------------------------
{
   LPHRESTATE  lpHREState;
   LPRESTATE   lpRE;
   LPRESDIR    lpDlResDir;
   SCOUNT      scDlResDir;
   SCOUNT      sc;
   LPFRAME     lpFrameArray;
   	
   if (!(lpHREState = (LPHRESTATE) GlobalLock (hHREState)))
     return HRE_ERROR;

   lpDlResDir = lpHREState->lpDlResDir;
   if(lpDlResDir != NULL)                 // mslin, 4/15/92 for dumbo
   {
      scDlResDir = lpHREState->scDlResDir;
      // free frame array of DlResDir
      for(sc = 0; sc < scDlResDir; sc++)
      {
         if( (lpFrameArray = lpDlResDir[sc].lpFrameArray) != NULL)
           GlobalFreePtr (lpFrameArray);
      }

      // unlock and free DlResDir
      GlobalFreePtr(lpDlResDir);
   }

	 lpRE = lpHREState->lpREState;

#ifndef WIN32
   GlobalFreePtr (lpRE->lpBrushBuf);
#endif   
   GlobalFreePtr (lpRE);
   
   GlobalUnlock(hHREState);
   GlobalFree(hHREState);
   
   return(HRE_SUCCESS);
}
 
// ------------------------------------------------------------------------
static
UINT                         // HRE_SUCCESS if allocate memory OK
                             // HRE_ERROR if allocate memory failure
PutRPL
(
   LPHRESTATE lpHREState,
   LPFRAME lpFrameArray,
   UINT uiCount
)
// PURPOSE
//                            Allocate a RPL entry and then put RPL into 
//                            tail of RPL list.
//
//           
// ------------------------------------------------------------------------
{
   HANDLE      hRPL;
   LPRPLLIST   lpRPL;
   HANDLE      hFrame;
   LPFRAME     lpFrameArrayDup, lpFrame;
   UINT        uiLoopCount;

   if (!(hRPL = GlobalAlloc(GMEM_MOVEABLE, sizeof(RPLLIST))))
      return (HRE_ERROR);
   if (!(lpRPL = (LPRPLLIST)GlobalLock(hRPL)))
   {
      GlobalFree(hRPL);
      return (HRE_ERROR);
   }

   // copy frame array
   if (!(hFrame = GlobalAlloc(GMEM_MOVEABLE, uiCount * sizeof(FRAME))))
      return (HRE_ERROR);
   if (!(lpFrameArrayDup = (LPFRAME)GlobalLock(hFrame)))
   {
      GlobalFree(hFrame);
      return (HRE_ERROR);
   }
   lpFrame = lpFrameArrayDup;
   for(uiLoopCount=0; uiLoopCount<uiCount; uiLoopCount++)
   {
      *lpFrame++ = *lpFrameArray++;
   }

   lpRPL->uiCount = uiCount;
   lpRPL->lpFrame = lpFrameArrayDup;
   lpRPL->lpNextRPL = NULL;
   if(lpHREState->lpRPLHead == NULL)
   {
      // first RPL
      lpHREState->lpRPLHead = lpHREState->lpRPLTail = lpRPL;
   }
   else
   {
      lpHREState->lpRPLTail->lpNextRPL = lpRPL;
      lpHREState->lpRPLTail = lpRPL;
   }
   return(HRE_SUCCESS);
}

// ------------------------------------------------------------------------
static
UINT                            // HRE_SUCCESS if allocate memory OK
                                // HRE_ERROR if allocate memory failure
FreeRPL
(
   LPRPLLIST lpRPL
)
// PURPOSE
//                               Free a RPL entry and its frame array
//
// ------------------------------------------------------------------------
{
	GlobalFreePtr (lpRPL->lpFrame);
	GlobalFreePtr (lpRPL);
	return HRE_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\hretype.h ===
/*
**  Copyright (c) 1992 Microsoft Corporation
*/
//===========================================================================
// FILE                         HRETYPE.h
//
// MODULE                       HRE (Host Resource Executor Interface)
//
// PURPOSE                      provide specification of HRE interface
//
// DESCRIBED IN                 Resource Executor design spec
//                              Host resource executor interface design spec
//
// EXTERNAL INTERFACES          This file defines the interface exported by
//                              the HPRS for use by the D'Jumbo Driver and
//                              sleek product queue processors.
//
// INTERNAL INTERFACES          
//
// MNEMONICS                    
//
// HISTORY  01/18/92 mslin     created it.
//          04/15/92 mslin     added uiStatus in _RESDIR structure for dumbo
//
//===========================================================================

// --------------------------------------------------------------------------
// Data Type definition
// --------------------------------------------------------------------------

// Host Resource Store hash table
typedef struct _RESDIR
{
  UINT      uiStatus;           // Resource status, RS_RELEASE/RS_AVAILABLE
                                 //mslin, 4/15/92 for dumbo
  UINT      uiCount;
  LPFRAME   lpFrameArray;
}
	RESDIR, *PRESDIR, FAR *LPRESDIR;

// RPL link list, it will be executed in the sequence of store
typedef struct _RPLLIST
{
   struct _RPLLIST   FAR *lpNextRPL;
   LPFRAME           lpFrame;
   UINT              uiCount;
}
	RPLLIST, FAR *LPRPLLIST;

// state of Resource Executor
typedef struct
{
   LPSTR          lpBrushBuf;   // expanded brush buffer, 3/30/92 mslin
   LPBYTE         lpBrushPat;   // pointer to custom stock brush patterns
   BYTE           TiledPat[128];// buffer for 8x8 pattern tiled into 32x32
   LPJG_BM_HDR    lpCurBitmap;  // current bitmap resource
   ULONG FAR*     lpCurBitmapPtr;   // current bitmap resource
   ULONG FAR*     lpCurBrush;   // current brush resource
   LPJG_GS_HDR    lpCurGS;      // current glyph set
   LPJG_RES_HDR   lpCurRPL;     // current RPL
   SHORT          sCol;         // current column position
   SHORT          sRow;         // current row position
   LPBITMAP       lpBandBuffer; // band buffer ??? should we save ???
   SHORT          sCol2;        // 2nd current column position
   UBYTE          ubPenStyle;   // current pen style
   USHORT         usPenPhase;   // current pen phase
   WORD           wColor;       // pen color

   // BitBlt
   ULONG          ulRop;        // shifted ropcode
   UBYTE          ubRop;        // original ropcode
	 USHORT         usBrushWidth; // brush buffer
   UINT           yPat;         // brush offset
   
#ifdef WIN32
	 // GDI32 BitBlt
   LPVOID  lpBandSave;
   HDC     hdcDst, hdcSrc;
   HBITMAP hbmDef;
   HBRUSH  hbrDef;
   DWORD   dwRop;
#endif
   
}
	RESTATE, FAR *LPRESTATE;

typedef struct
{
   HANDLE      hHREState;     // handle
   SCOUNT      scDlResDir;    // size of download resource directory
   LPRESDIR    lpDlResDir;    // download resource directory
   LPRPLLIST   lpRPLHead;     // RPL list head
   LPRPLLIST   lpRPLTail;     // RPL list tail
   LPRESTATE   lpREState;     // RE rendering state

} HRESTATE, FAR *LPHRESTATE;

// Slice descriptor, line in slice form
typedef struct
{
   USHORT us_x1,us_y1;          /* location of first dot drawn in line */
   USHORT us_x2,us_y2;          /* location of last dot drawn in line */
   SHORT  s_dx_draw,s_dy_draw;  /* direction of slice drawing */
   SHORT  s_dx_skip,s_dy_skip;  /* direction of skip between slices */
   SHORT  s_dis;                /* slice discriminant, >=0 large, <0 small */
   SHORT  s_dis_lg,s_dis_sm;    /* large/small slice discriminant adjust */
   USHORT us_first,us_last;     /* length of first and last slice in pels */
   USHORT us_n_slices;          /* number of intermediate slices */
   USHORT us_small;             /* length small slice (large is implicit) */
}
   RP_SLICE_DESC;               /* prefix "sd" */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\jres.h ===
/*---------------------------------------------------------------------------
 JRES.H -- Jumbo Resource definitions

 Bert Douglas  6/10/91    Adapted for use in printer
 mslin         2/15/92    Adapted for use in Host Resource Executor
                          Baseline 3.0
*/

/*---------------------------------------------------------------------------
 Resource Section
/*---------------------------------------------------------------------------
*/

#include <pshpack2.h>		// BKD 1997-7-9: added

/* Resource Header */
typedef struct 
{
      UID         ulUid;        /* shortened version of uid */
      USHORT      usClass;      /* shortened version of class */
} 
   JG_RES_HDR, *PJG_RES_HDR, FAR *LPJG_RES_HDR;

/* resource state codes */

#define JG_RES_STATE_DEFAULT ((UBYTE) 0x00)
#define JG_RES_STATE_RELEASE ((UBYTE) 0x01)
#define JG_RES_STATE_RETAIN  ((UBYTE) 0x02)
#define JG_RES_STATE_MAX     ((UBYTE) 0x03)


/* usClass Resource Description */

#define JG_RS_NULL   ( (UBYTE) 0x00 )   /* Null                       */
#define JG_RS_GLYPH  ( (UBYTE) 0x01 )   /* Glyph Set                  */
#define JG_RS_BRUSH  ( (UBYTE) 0x02 )   /* Brush                      */
#define JG_RS_BITMAP ( (UBYTE) 0x03 )   /* Horizontal Bitmap          */
#define JG_RS_RPL    ( (UBYTE) 0x04 )   /* Redner Primitive List      */
#define JG_RS_SPL    ( (UBYTE) 0x05 )   /* Supervisory Primitive List */
#define JG_RS_MAX    ( (UBYTE) 0x06 )   /* Non-inclusive limit        */

/*---------------------------------------------------------------------------
 JG_RS_GS (Glyph Set) Resource Definitions
*/

typedef struct 
{
   JG_RES_HDR  ResHdr;              /* resource header             */
   USHORT      usGlyphs;         /* count of glyphs in resource */
   USHORT      ausOffset[1];     /* table of offsets to the glyphs */
} *PJG_GS_HDR, FAR *LPJG_GS_HDR, JG_GS_HDR;

   
typedef struct 
{
   USHORT      usHeight;
   USHORT      usWidth;
   ULONG       aulPels[1];       /* start of pixel array */
} *PJG_GLYPH, FAR *LPJG_GLYPH, G_GLYPH;


/*---------------------------------------------------------------------------
 Brush Resource Definitions
*/

typedef struct 
{
   JG_RES_HDR  ResHdr;              /* resource header */
   ULONG       aulPels[32];      /* bitmap array */
} *PJG_BRUSH, FAR *LPJG_BRUSH, JG_BRUSH;

typedef struct
{
   JG_RES_HDR  ResHdr;
   UBYTE       ubCompress;
   UBYTE       ubLeft;
   USHORT      usHeight;
   USHORT      usWidth;
   ULONG       aulPels[1];
} *PJG_BM_HDR, FAR *LPJG_BM_HDR, JG_BM_HDR;


/*---------------------------------------------------------------------------
 Render Primitives Section
/*---------------------------------------------------------------------------
*/

/* RPL (Render Primitive List) Header */
typedef struct 
{
   JG_RES_HDR  ResHdr;           //resource header
   USHORT      usTopRow;         //top row, banding
   USHORT      usBotomRow;       //bottom row, banding
   USHORT      usLongs;          //number of long parm
   USHORT      usShorts;         //number of short parm
   USHORT      usBytes;          //number of byte parm
   ULONG       ulParm[1];      //start of long parm
} *PJG_RPL_HDR, FAR *LPJG_RPL_HDR, JG_RPL_HDR;


/* RP Opcode Definition */

#define JG_RP_SetRowAbsS       ( (UBYTE) 0x00 )
#define JG_RP_SetRowRelB       ( (UBYTE) 0x01 )
#define JG_RP_SetColAbsS       ( (UBYTE) 0x02 )
#define JG_RP_SetColRelB       ( (UBYTE) 0x03 )
#define JG_RP_SetExtAbsS       ( (UBYTE) 0x04 )
#define JG_RP_SetExtRelB       ( (UBYTE) 0x05 )

#define JG_RP_SelectL          ( (UBYTE) 0x10 )
#define JG_RP_SelectS          ( (UBYTE) 0x11 )
#define JG_RP_SelectB          ( (UBYTE) 0x12 )
#define JG_RP_Null             ( (UBYTE) 0x13 )
#define JG_RP_End              ( (UBYTE) 0x14 )
#define JG_RP_SetRop           ( (UBYTE) 0x15 )
#define JG_RP_SetPenStyle      ( (UBYTE) 0x16 )
#define JG_RP_ShowText         ( (UBYTE) 0x17 )
#define JG_RP_ShowField        ( (UBYTE) 0x18 )
#define JG_RP_SetRopAndBrush   ( (UBYTE) 0x19 )
#define JG_RP_SetPatternPhase  ( (UBYTE) 0x1A )

#define JG_RP_LineAbsS1        ( (UBYTE) 0x20 )
#define JG_RP_LineAbsSN        ( (UBYTE) 0x21 )
#define JG_RP_LineRelB1        ( (UBYTE) 0x22 )
#define JG_RP_LineRelBN        ( (UBYTE) 0x23 )
#define JG_RP_LineSlice        ( (UBYTE) 0x24 )
#define JG_RP_StylePos         ( (UBYTE) 0x25 )


#define JG_RP_FillRow1         ( (UBYTE) 0x30 )
#define JG_RP_FillRowD         ( (UBYTE) 0x31 )

#define JG_RP_RectB            ( (UBYTE) 0x40 )
#define JG_RP_RectS            ( (UBYTE) 0x41 )

#define JG_RP_BitMapHI         ( (UBYTE) 0x50 )
#define JG_RP_BitMapHR         ( (UBYTE) 0x51 )
#define JG_RP_BitMapV          ( (UBYTE) 0x52 )

#define JG_RP_GlyphB1          ( (UBYTE) 0x60 )
#define JG_RP_GlyphS1          ( (UBYTE) 0x61 )
#define JG_RP_GlyphBD          ( (UBYTE) 0x62 )
#define JG_RP_GlyphSD          ( (UBYTE) 0x63 )
#define JG_RP_GlyphBDN         ( (UBYTE) 0x64 )

#define JG_RP_WedgeB           ( (UBYTE) 0x70 )
#define JG_RP_WedgeS           ( (UBYTE) 0x71 )

/* fbEnds */
#define JG_NO_FIRST_PEL  ( (UBYTE) (1<<0) )   /* first pel excluded      */
#define JG_NO_LAST_PEL   ( (UBYTE) (1<<1) )   /* last pel excluded       */

#include <poppack.h>		// BKD 1997-7-9: added
/* End --------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\hreblt.c ===
#include <ifaxos.h>
#include <resexec.h>
#include "constant.h"
#include "jtypes.h"     // type definition used in cartridge
#include "jres.h"       // cartridge resource data type definition
#include "hretype.h"    // define data structure used by hre.c and rpgen.c

//==============================================================================
BOOL OpenBlt (LPRESTATE lpRE, UINT yBrush)
{
	lpRE->usBrushWidth = 0;
	return TRUE;
}

//==============================================================================
void CloseBlt (LPRESTATE lpRE)
{

}

//==============================================================================
BOOL SetBrush (LPRESTATE lpRE)
{
	lpRE->usBrushWidth = 0;
	return TRUE;
}

//==============================================================================
DWORD FAR PASCAL HREBitBlt
(
	LPVOID  PRT_FrameStart,
	LPVOID  lpgBrush,
	WORD    PRT_BytesPerScanLine,
	WORD    usBrushWidth,
	WORD    PRT_Max_X,
	WORD    PRT_Max_Y,
	WORD    usgPosOff,
	WORD    xSrc,    // Left padding
	short   yDst,	   // Top row of destination.
	short   xDst,	   // Left column of destination.
	WORD    clLine,  // Longs per scan line
	WORD    yExt,    // Height in pixels
	WORD    xExt,    // Width in pixels 
	LPDWORD lpSrc,   // Far pointer to source
	LPDWORD lpPat,   // Far pointer to pattern
	DWORD   dwRop	 // Raster operation
);

DWORD FAR PASCAL RP_BITMAP1TO1
(
	LPRESTATE lpRE,
	WORD    xSrc,    // Left padding
	short   yDst,	   // Top row of destination.
	short   xDst,	   // Left column of destination.
	WORD    clLine,  // Longs per scan line
	WORD    yExt,    // Height in pixels
	WORD    xExt,    // Width in pixels 
	LPDWORD lpSrc,   // Far pointer to source
	LPDWORD lpPat,   // Far pointer to pattern
	DWORD   dwRop		 // Raster operation
)
{
	LPBITMAP lpbmBand = lpRE->lpBandBuffer;

	return HREBitBlt
		(
			lpbmBand->bmBits, lpRE->lpBrushBuf, lpbmBand->bmWidthBytes,
			lpRE->usBrushWidth, lpbmBand->bmWidth, lpbmBand->bmHeight, lpRE->yPat,
			xSrc, yDst, xDst, clLine, yExt, xExt, lpSrc, lpPat, dwRop
		);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\mflags.inc ===
;--------------------------------------------------
;MASMFLAGS definitions
;--------------------------------------------------
   EGA    =  0001h		;Build the EGA driver.
   VGA    =  0002h		;Build the VGA driver.
   SVGA   =  0004h		;Build the SuperVGA driver.
   ROM    =  0008h		;Build A ROMable driver.
   PENWIN =  0010h		;Build A PenWin compliant driver.
   PUBDEFS=  4000h		;Make symbols public.
   DEBUG  =  8000h		;Build a debug driver.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\multbyte.h ===
/*
**  Copyright (c) 1991 Microsoft Corporation
*/
//===========================================================================
// FILE                         multbyte.h
//
// MODULE                       Host Resource Executor
//
// PURPOSE                      
//    This file defines macros to allow processor independent 
//    manipulation of (possibly "foreign") multibyte records.
//
//
// DESCRIBED IN                 Resource Executor design spec.
//
// MNEMONICS                    n/a
// 
// HISTORY  1/17/92 mslin       created
//
//===========================================================================
    
#define GETUSHORT(p) (*p)
#define GETULONG(p) (*p)
#define GETUSHORTINC(a)   GETUSHORT((a)); a++  /* Do NOT parenthesize! */
#define GETULONGINC(a)    GETULONG((a)); a++  /* Do NOT parenthesize! */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\jtypes.h ===
/*---------------------------------------------------------------------------
 JTYPES.H -- Jumbo basic type definitions

 Chia-Chi Teng 5/23/91    Created (for use in Jasm assembler)
 Bert Douglas  6/10/91    Adapted for use in printer
*/

#ifndef jtypes_h
#define jtypes_h

#ifndef FAR
#define FAR far
#endif
#ifndef NEAR
#define NEAR near
#endif
#ifndef WINAPI
#define WINAPI 
#endif

/*---------------------------------------------------------------------------
 Variable naming conventions

   -------   ------   ----------------------------------------------------
   Typedef   Prefix   Description
   -------   ------   ----------------------------------------------------
   SBYTE     b        8 bit signed integer
   SHORT     s        16 bit signed integer
   SLONG     l        32 bit signed integer

   UBYTE     ub       8 bit unsigned integer
   USHORT    us       16 bit unsigned integer
   ULONG     ul       32 bit unsigned integer

   BFIX      bfx      8 bit (4.4) signed fixed point number
   SFIX      sfx      16 bit (12.4) signed fixed point number
   LFIX      lfx      32 bit (28.4) signed fixed point number

   UBFIX     ubfx     8 bit (4.4) unsigned fixed point number
   USFIX     usfx     16 bit (12.4) unsigned fixed point number
   ULFIX     ulfx     32 bit (28.4) unsigned fixed point number

   FBYTE     fb       set of 8 bit flags
   FSHORT    fs       set of 16 bit flags

   BPOINT    bpt      byte index into the point table (UBYTE)
   SPOINT    spt      short index into the point table (USHORT)

   BCOUNT    bc       8 bit "count" of objects
   SCOUNT    sc       16 bit "count" of objects
   LCOUNT    lc       32 bit "count" of objects
                      The number of objects is one more than the "count".
                      There must be at least one object.

   UID       uid      32 bit unique identifier
   -------   ------   ----------------------------------------------------
*/

typedef char                SBYTE, BFIX;
typedef unsigned char       FBYTE, UBYTE, BPOINT, BCOUNT, UBFIX;
typedef short               SFIX, SHORT;
typedef unsigned short      USHORT, FSHORT, SPOINT, SCOUNT, USFIX;
typedef long                LFIX, SLONG;
typedef unsigned long       ULONG, LCOUNT, ULFIX, UID;

#endif /* jtypes_h */

/* End --------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\roptable.c ===
/*==============================================================================
This table generates the low word of a 32-bit ROP from an 8-bit ROP.

11-Jun-93    RajeevD    Created
==============================================================================*/

const unsigned short wRopTable[256] = 
{
	0x0042, // 0 (BLACKNESS)
	0x0289, // DPSoon
	0x0C89, // DPSona
	0x00AA, // PSon
	0x0C88, // SDPona
	0x00A9, // DPon
	0x0865, // PDSxnon
	0x02C5, // PDSaon
	0x0F08, // SDPnaa
	0x0245, // PDSxon
	0x0329, // DPna
	0x0B2A, // PSDnaon
	0x0324, // SPna
	0x0B25, // PDSnaon
	0x08A5, // PDSonon
	0x0001, // Pn
	0x0C85, // PDSona
	0x00A6, // DSon (NOTSRCERASE)
	0x0868, // SDPxnon
	0x02C8, // SDPaon
	0x0869, // DPSxnon
	0x02C9, // DPSaon
	0x5CCA, // PSDPSanaxx
	0x1D54, // SSPxDSxaxn
	0x0D59, // SPxPDxa
	0x1CC8, // SDPSanaxn
	0x06C5, // PDSPaox
	0x0768, // SDPSxaxn
	0x06CA, // PSDPaox
	0x0766, // DSPDxaxn
	0x01A5, // PDSox
	0x0385, // PDSoan
	0x0F09, // DPSnaa
	0x0248, // SDPxon
	0x0326, // DSna
	0x0B24, // SPDnaon
	0x0D55, // SPxDSxa
	0x1CC5, // PDSPanaxn
	0x06C8, // SDPSaox
	0x1868, // SDPSxnox
	0x0369, // DPSxa
	0x16CA, // PSDPSaoxxn
	0x0CC9, // DPSana
	0x1D58, // SSPxPDxaxn
	0x0784, // SPDSoax
	0x060A, // PSDnox
	0x064A, // PSDPxox
	0x0E2A, // PSDnoan
	0x032A, // PSna
	0x0B28, // SDPnaon
	0x0688, // SDPSoox
	0x0008, // Sn (NOTSRCCOPY)
	0x06C4, // SPDSaox
	0x1864, // SPDSxnox
	0x01A8, // SDPox
	0x0388, // SDPoan
	0x078A, // PSDPoax
	0x0604, // SPDnox
	0x0644, // SPDSxox
	0x0E24, // SPDnoan
	0x004A, // PSx
	0x18A4, // SPDSonox
	0x1B24, // SPDSnaox
	0x00EA, // PSan
	0x0F0A, // PSDnaa
	0x0249, // DPSxon
	0x0D5D, // SDxPDxa
	0x1CC4, // SPDSanaxn
	0x0328, // SDna (SRCERASE)
	0x0B29, // DPSnaon
	0x06C6, // DSPDaox
	0x076A, // PSDPxaxn
	0x0368, // SDPxa
	0x16C5, // PDSPDaoxxn
	0x0789, // DPSDoax
	0x0605, // PDSnox
	0x0CC8, // SDPana
	0x1954, // SSPxDSxoxn
	0x0645, // PDSPxox
	0x0E25, // PDSnoan
	0x0325, // PDna
	0x0B26, // DSPnaon
	0x06C9, // DPSDaox
	0x0764, // SPDSxaxn
	0x08A9, // DPSonon
	0x0009, // Dn, // DSTINVERT
	0x01A9, // DPSox
	0x0389, // DPSoan
	0x0785, // PDSPoax
	0x0609, // DPSnox
	0x0049, // DPx (PATINVERT)
	0x18A9, // DPSDonox
	0x0649, // DPSDxox
	0x0E29, // DPSnoan
	0x1B29, // DPSDnaox
	0x00E9, // DPan
	0x0365, // PDSxa
	0x16C6, // DSPDSaoxxn
	0x0786, // DSPDoax
	0x0608, // SDPnox
	0x0788, // SDPSoax
	0x0606, // DSPnox
	0x0046, // DSx (SRCINVERT)
	0x18A8, // SDPSonox
	0x58A6, // DSPDSonoxxn
	0x0145, // PDSxxn
	0x01E9, // DPSax
	0x178A, // PSDPSoaxxn
	0x01E8, // SDPax
	0x1785, // PDSPDoaxxn
	0x1E28, // SDPSnoax
	0x0C65, // PDSxnan
	0x0CC5, // PDSana
	0x1D5C, // SSDxPDxaxn
	0x0648, // SDPSxox
	0x0E28, // SDPnoan
	0x0646, // DSPDxox
	0x0E26, // DSPnoan
	0x1B28, // SDPSnaox
	0x00E6, // DSan
	0x01E5, // PDSax
	0x1786, // DSPDSoaxxn
	0x1E29, // DPSDnoax
	0x0C68, // SDPxnan
	0x1E24, // SPDSnoax
	0x0C69, // DPSxnan
	0x0955, // SPxDSxo
	0x03C9, // DPSaan
	0x03E9, // DPSaa
	0x0975, // SPxDSxon
	0x0C49, // DPSxna
	0x1E04, // SPDSnoaxn
	0x0C48, // SDPxna
	0x1E05, // PDSPnoaxn
	0x17A6, // DSPDSoaxx
	0x01C5, // PDSaxn
	0x00C6, // DSa (SRCAND)
	0x1B08, // SDPSnaoxn
	0x0E06, // DSPnoa
	0x0666, // DSPDxoxn
	0x0E08, // SDPnoa
	0x0668, // SDPSxoxn
	0x1D7C, // SSDxPDxax
	0x0CE5, // PDSanan
	0x0C45, // PDSxna
	0x1E08, // SDPSnoaxn
	0x17A9, // DPSDPoaxx
	0x01C4, // SPDaxn
	0x17AA, // PSDPSoaxx
	0x01C9, // DPSaxn
	0x0169, // DPSxx
	0x588A, // PSDPSonoxx
	0x1888, // SDPSonoxn
	0x0066, // DSxn
	0x0709, // DPSnax
	0x07A8, // SDPSoaxn
	0x0704, // SPDnax
	0x07A6, // DSPDoaxn
	0x16E6, // DSPDSaoxx
	0x0345, // PDSxan
	0x00C9, // DPa
	0x1B05, // PDSPnaoxn
	0x0E09, // DPSnoa
	0x0669, // DPSDxoxn
	0x1885, // PDSPonoxn
	0x0065, // PDxn
	0x0706, // DSPnax
	0x07A5, // PDSPoaxn
	0x03A9, // DPSoa
	0x0189, // DPSoxn
	0x0029, // D
	0x0889, // DPSono
	0x0744, // SPDSxax
	0x06E9, // DPSDaoxn
	0x0B06, // DSPnao
	0x0229, // DPno
	0x0E05, // PDSnoa
	0x0665, // PDSPxoxn
	0x1974, // SSPxDSxox
	0x0CE8, // SDPanan
	0x070A, // PSDnax
	0x07A9, // DPSDoaxn
	0x16E9, // DPSDPaoxx
	0x0348, // SDPxan
	0x074A, // PSDPxax
	0x06E6, // DSPDaoxn
	0x0B09, // DPSnao
	0x0226, // DSno (MERGEPAINT)
	0x1CE4, // SPDSanax
	0x0D7D, // SDxPDxan
	0x0269, // DPSxo
	0x08C9, // DPSano
	0x00CA, // PSa (MERGECOPY)
	0x1B04, // SPDSnaoxn
	0x1884, // SPDSonoxn
	0x006A, // PSxn
	0x0E04, // SPDnoa
	0x0664, // SPDSxoxn
	0x0708, // SDPnax
	0x07AA, // PSDPoaxn
	0x03A8, // SDPoa
	0x0184, // SPDoxn
	0x0749, // DPSDxax
	0x06E4, // SPDSaoxn
	0x0020, // S (SRCCOPY)
	0x0888, // SDPono
	0x0B08, // SDPnao
	0x0224, // SPno
	0x0E0A, // PSDnoa
	0x066A, // PSDPxoxn
	0x0705, // PDSnax
	0x07A4, // SPDSoaxn
	0x1D78, // SSPxPDxax
	0x0CE9, // DPSanan
	0x16EA, // PSDPSaoxx
	0x0349, // DPSxan
	0x0745, // PDSPxax
	0x06E8, // SDPSaoxn
	0x1CE9, // DPSDanax
	0x0D75, // SPxDSxan
	0x0B04, // SPDnao
	0x0228, // SDno
	0x0268, // SDPxo
	0x08C8, // SDPano
	0x03A5, // PDSoa
	0x0185, // PDSoxn
	0x0746, // DSPDxax
	0x06EA, // PSDPaoxn
	0x0748, // SDPSxax
	0x06E5, // PDSPaoxn
	0x1CE8, // SDPSanax
	0x0D79, // SPxPDxan
	0x1D74, // SSPxDSxax
	0x5CE6, // DSPDSanaxxn
	0x02E9, // DPSao
	0x0849, // DPSxno
	0x02E8, // SDPao
	0x0848, // SDPxno
	0x0086, // DSo (SRCPAINT)
	0x0A08, // SDPnoo
	0x0021, // P (PATCOPY)
	0x0885, // PDSono
	0x0B05, // PDSnao
	0x022A, // PSno
	0x0B0A, // PSDnao
	0x0225, // PDno
	0x0265, // PDSxo
	0x08C5, // PDSano
	0x02E5, // PDSao
	0x0845, // PDSxno
	0x0089, // DPo
	0x0A09, // DPSnoo (PATPAINT)
	0x008A, // PSo
	0x0A0A, // PSDnoo
	0x02A9, // DPSoo
	0x0062, // 1 (WHITENESS)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\macros.inc ===
page	,132
;-----------------------------Module-Header-----------------------------;
; Module Name:	MACROS.MAC
;
; This file contains macros definitions for all display drivers to use.
;
; Created: 06-Jan-1987
; Author:  Walt Moore [waltm]
;
; Copyright (c) 1987 Microsoft Corporation
;
; Exported Functions:	none
;
; Public Functions:	none
;
; Public Data:		none
;
; General Description:
;
;	Two text equates are given as short hand for WORD PTR
;	and BYTE PTR.
;
;	A Macro is defined for performing 16-bit output on machines
;	which cannot correctly do so.
;
;	The macro which is invoked by CMACROS for private stack
;	checking is defined.
;
; Restrictions:
;	The use of the ?CHKSTKPROC macro requires it to be defined
;	before CMACROS is included.  If CMACROS is included before
;	the include file, a ?CHKSTKPROC macro should be defined
;	with a null macro body.  This macro will then redefine the
;	earlier macro.
;
;	The out16 macro is intended as documentation for anyone
;	converting a driver to a machine which cannot do 16-bit
;	outputs correctly.  There is no guarantee that any code
;	will have been tested (only one machine is known to have
;	the problem).
;
;-----------------------------------------------------------------------;




;	The following two equates are just used as shorthand
;	for the "word ptr" and "byte ptr" overrides.

wptr	equ	word ptr
bptr	equ	byte ptr
		
		.286

;---------------------------------Macro---------------------------------;
; out16
;
; out16 is a macro used wherever any 16-bit output is performed.
; The macro is intended to serve as documentation for those machines
; which do not perform 16-bit outputs correctly (where correctly is
; defined as the way the IBM AT does it).
;
; usage
;
;     out16   d,a
;
; where
;
;     d   -   I/O address register. Included as documentation
;	      only.  Must always be DX (lower case).
;
;     a   -   Register to output.  Included as documentation
;	      only.  Must always be AX (lower case).
;
; Entry:
;	AX	= data to output
;	DX	= I/O port address
; Returns:
;	none
; Error Returns:
;	none
; Registers Destroyed:
;	FLAGS
; Registers Preserved:
;	AX,BX,CX,DX,SI,DI,BP,DS,ES
; Calls:
;       none
; History:
;	Fri 16-Jan-1987 16:49:03 -by-  Walt Moore [waltm]
;	Initial version
;-----------------------------------------------------------------------;


ifndef	IO8				;;If normal 16 bit outputs
  out16   equ	  out
else					;;If 8-bit outputs
  out16 macro d,a
	ifdif <a>,<ax>
	%out out16 - invalid register, must be ax
	.err
	endif
	ifdif	<d>,<dx>
	%out	out16 - invalid register, must be dx
	.err
	endif
	ifdif <is>,<cli>		;;  If interrupts not off
	cli				;;    then turn them off
	endif				;;
	out	dx,al			;;  Output LSB portion
	inc	dx			;;  --> next address
	xchg	al,ah			;;  Get MSB of output value
	out	dx,al			;;  Output MSB portion
	ifdif <ie>,<cli>		;;  If not explicitly told to leave
	sti				;;    interrupts off, turn them on
	endif				;;
	ifdif <rd>,<dont_save_DL>	;;  If not explicitly told to trash DX,
	dec	dx			;;    restore it.
	xchg	al,ah
	endif
	endm
endif



;---------------------------------Macro---------------------------------;
; ?CHKSTKPROC
;
; Private Stack Checking Macro
;
; ?CHKSTKPROC will be invoked by the CMACROS for any procedure
; with local variables if both ?CHKSTK and ?CHKSTKPROC were
; defined prior to including the CMACROS.
;
; The macro has one parameter, which is the number of bytes
; to allocate, which is supplied by the CMACROS.
;
; The usage of this macro is defined by the CMACROS.  There is no
; user control over the macro.	Register usage will be as defined
; by the routine my_check_stack.
;
; Calls:
;	my_check_stack
; History:
;	Fri 16-Jan-1987 16:49:03 -by-  Walt Moore [waltm]
;	Initial version
;-----------------------------------------------------------------------;


ifdef	?CHKSTK 			;;Only define macro if
ifdef	?CHKSTKPROC			;;  private stack checking
ifndef	?CHKSTKNAME			;;If user name differs from default
extrn	my_check_stack:near		;;Procedure to do the checking
endif
?CHKSTKPROC macro s			;;Actual macro text
	mov	ax,s			;;my_check_stack takes requested space
ifdef	?CHKSTKNAME
	?CHKSTKNAME
else
	call	my_check_stack		;;  in AX
endif
endm
endif
endif



;-----------------------------------------------------------------------;
; odd	--- macro for odd alignment, counterpart for masm's "even".
;
; Arguments:
;	none
; Returns:
;	nothing
; Alters:
;	nothing
; Calls:
;	nothing
; History:
;
;  Sun Mar 01, 1987 07:48:01p	-by-	Wesley O. Rupel   [wesleyr]
; Wrote it!
;-----------------------------------------------------------------------;


odd	macro
	ife (offset $) AND 1
	nop
	endif
	endm



;-----------------------------------------------------------------------;
; pushem
; popem
;
; Allows giving a list of registers to push/pop on a single line.
; Also allows easy verificaton that pushes and pops are balanced
; because arguements are given in the same order:
;
;	pushem	ax,bx,cx   goes with
;	popem	ax,bx,cx
;
; Arguments:
;	registers to push/pop
; Returns:
;	nothing
; Alters:
;	nothing
; Calls:
;	nothing
; History:
;
;  Mon Mar 09, 1987 06:12:32p	-by-	Wesley O. Rupel   [wesleyr]
; Wrote it!
;-----------------------------------------------------------------------;


pushem	macro	r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF,r10,r11,r12
	irp	x,<r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF,r10,r11,r12>
	ifnb	<x>
	push	x
	endif
	endm
	endm

popem	macro	r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF,r10,r11,r12
	irp	x,<r12,r11,r10,rF,rE,rD,rC,rB,rA,r9,r8,r7,r6,r5,r4,r3,r2,r1>
	ifnb	<x>
	pop	x
	endif
	endm
	endm



;-----------------------------------------------------------------------;
; smov
;
; smove moves the contents of one segment register into another
; segment register.
;
; usage
;
;	smov	x,y
;
; where
;
;	x is the destination register
;	y is the source register
;
; Arguments:
;	y is source segment register
; Returns:
;	x segment register = y segment register
; Alters:
;	x segment register
; Calls:
;	nothing
; History:
;
;  Mon Mar 09, 1987 06:12:32p	-by-	Wesley O. Rupel   [wesleyr]
; Wrote it!
;-----------------------------------------------------------------------;


smov	macro	x,y
	push	y
	pop	x
	endm



;--------------------------------------------------------------------------;
; abs_ax
;	takes absolute value of AX
; Entry:
;	AX	= integer
; Returns:
;	AX	= abs(AX)
; Error Returns:
;	none
; Registers Destroyed:
;	DX,FLAGS
; Registers Preserved:
;	BX,CX,SI,DI,DS,ES,BP
; Calls:
;	none
; History:
;  Thu Mar 05, 1987 06:15:46p	-by-  Tony Pisculli	[tonyp]
; wrote it
;--------------------------------------------------------------------------;


abs_ax	macro
	cwd
	xor	ax,dx
	sub	ax,dx
	endm



;--------------------------------------------------------------------------;
; min_ax
;	returns min of AX and REG
; Entry:
;	AX	= integer
;	REG	= general purpose register containing an integer
; Returns:
;	AX	= min(AX,REG)
; Error Returns:
;	none
; Registers Destroyed:
;	DX,FLAGS
; Registers Preserved:
;	BX,CX,SI,DI,DS,ES,BP
; Calls:
;	none
; History:
;  Sat Mar 07, 1987 08:39:04p	-by-  Tony Pisculli	[tonyp]
; wrote it
;--------------------------------------------------------------------------;


min_ax	macro	REG
	sub	ax,REG
	cwd
	and	ax,dx
	add	ax,REG
	endm



;--------------------------------------------------------------------------;
; max_ax
;	returns max of AX and REG
; Entry:
;	AX	= integer
;	REG	= general purpose register containing an integer
; Returns:
;	AX	= max(AX, REG)
; Error Returns:
;	none
; Registers Destroyed:
;	DX,FLAGS
; Registers Preserved:
;	BX,CX,SI,DI,DS,ES,BP
; Calls:
;	none
; History:
;  Sat Mar 07, 1987 08:41:38p	-by-  Tony Pisculli	[tonyp]
; wrote it
;--------------------------------------------------------------------------;


max_ax	macro	REG
	sub	ax,REG
	cwd
	not	dx
	and	ax,dx
	add	ax,REG
	endm



;	The following equates are used for defining the target
;	processor to the shift macros.


GENERIC	equ	0

CPU	equ	GENERIC
;CPU	equ	88
;CPU	equ	86
;CPU	equ	186
;CPU	equ	286
;CPU	equ	386



;--------------------------------------------------------------------------;
; shiftl
;
; shiftl is used to implement the advanced shift left immediate
; (SHL dest,count) functionality of the 286 and 386.
;
; Entry:
;	DEST	= var to shift
;	COUNT	= number to shift by
; Returns:
;	DEST	= DEST shl COUNT
; Error Returns:
;	none
; Registers Destroyed:
;	none
; Registers Preserved:
;	all
; Calls:
;	none
; History:
;  Sat Mar 07, 1987 08:44:30p	-by-  Tony Pisculli	[tonyp]
; wrote it
;--------------------------------------------------------------------------;


shiftl	macro	DEST,COUNT
if (CPU eq 286) or (CPU eq 386)
	shl	DEST,COUNT
else
	REPT	COUNT
	shl	DEST,1
	ENDM
endif
	endm



;--------------------------------------------------------------------------;
; shiftr
;
; shiftr is used to implement the advanced shift right immediate
; (SHR dest,count) functionality of the 286 and 386.
;
; Entry:
;	DEST	= var to shift
;	COUNT	= number to shift by
; Returns:
;	DEST	= DEST shr COUNT
; Error Returns:
;	none
; Registers Destroyed:
;	none
; Registers Preserved:
;	all
; Calls:
;	none
; History:
;  Sat Mar 07, 1987 08:44:52p	-by-  Tony Pisculli	[tonyp]
; wrote it
;--------------------------------------------------------------------------;


shiftr	macro	DEST,COUNT
if (CPU eq 286) or (CPU eq 386)
	shr	DEST,COUNT
else
	REPT	COUNT
	shr	DEST,1
	ENDM
endif
	endm


;--------------------------------------------------------------------------;
; rotcr, rotcl
; rotr, rotl
;
; Use just like you would rcr (or rcl, rol, ror) immediate in 286 specific
; code.  If the processor does not support the immediate count (>1 on 808[68])
; then the macro generates multiple rcr (...) by one statements.
;
; Entry:
;	DEST	= var to rotate
;	COUNT	= number to rotate by
; Returns:
;	DEST	= DEST shr COUNT
; Error Returns:
;	none
; Registers Destroyed:
;	none
; Registers Preserved:
;	all
; Calls:
;	none
; History:
; 
;  Fri Apr 17, 1987 08:39:39p	-by-	Wesley O. Rupel	  [wesleyr]
; added rotl and rotr
;
;  Sun Apr 12, 1987 07:34:37p	-by-	Wesley O. Rupel	  [wesleyr]
; wrote it
;--------------------------------------------------------------------------;


rotcr	macro	DEST,COUNT
if (CPU eq 286) or (CPU eq 386)
	rcr	DEST,COUNT
else
	REPT	COUNT
	rcr	DEST,1
	ENDM
endif
	endm

rotcl	macro	DEST,COUNT
if (CPU eq 286) or (CPU eq 386)
	rcl	DEST,COUNT
else
	REPT	COUNT
	rcl	DEST,1
	ENDM
endif
	endm



rotl	macro	DEST,COUNT
if (CPU eq 286) or (CPU eq 386)
	rol	DEST,COUNT
else
	REPT	COUNT
	rol	DEST,1
	ENDM
endif
	endm


rotr	macro	DEST,COUNT
if (CPU eq 286) or (CPU eq 386)
	ror	DEST,COUNT
else
	REPT	COUNT
	ror	DEST,1
	ENDM
endif
	endm


;--------------------------------------------------------------------------;
; ashiftr
;
; ashiftr is used to implement the advanced shift arithmetic right immediate
; (SAR dest,count) functionality of the 286 and 386.
;
; Entry:
;	DEST	= var to shift
;	COUNT	= number to shift by
; Returns:
;	DEST	= DEST sar COUNT
; Error Returns:
;	none
; Registers Destroyed:
;	none
; Registers Preserved:
;	all
; Calls:
;	none
; History:
;  Sat Mar 07, 1987 08:45:06p	-by-  Tony Pisculli	[tonyp]
; wrote it
;--------------------------------------------------------------------------;


ashiftr	macro	DEST,COUNT
if (CPU eq 286) or (CPU eq 386)
	sar	DEST,COUNT
else
	REPT	COUNT
	sar	DEST,1
	ENDM
endif
	endm



;---------------------------------Macro---------------------------------;
; jmpnext
; jmpnext stop
;
; jmpnext is used in the generation of fall through chains.  It
; generates the opcode used to swallow the next two bytes of object
; code (cmp ax,immediate word), and performs error checking to
; ensure that only two bytes of object code exist between any
; use of jmpnext.
;
; The chain is terminated by use of an optional parameter to jmpnext.
; If this optional field is non-blank, the chain is terminated.
;
; usage
;
;	dog:
;	      mov    al,34
;	     jmpnext
;
;	foo:
;	     mov     al,0
;	     jmpnext
;
;	bar:
;	     mov     al,1
;	     jmpnext stop			;End of the chain
;
; Entry:
;	none
; Returns:
;	none
; Error Returns:
;	none
; Registers Destroyed:
;	FLAGS
; Registers Preserved:
;	AX,BX,CX,DX,SI,DI,BP,DS,ES
; Calls:
;       none
; History:
;	Fri 13-Mar-1987 12:03:16 -by-  Walt Moore [waltm]
;	Initial version
;-----------------------------------------------------------------------;


??ji	=	0			;;Initial index value

jmpnext macro e
jn %??ji,%(??ji+1),e			;;Set next label
endm

jn macro i,j,e
.sall
??ji&i:
.xall
ifb <e> 				;;If not the end of the chain
	db	03Dh			;;cmp ax, next two bytes
errn$	??ji&j,+2			;;next lable must be two bytes away
endif
??ji=j					;;increment counter
endm



;---------------------------------Macro---------------------------------;
; missing_code
;
; missing_code is a macro which will display a message on the screen
; at assembly time.  It is used to flag code sequences which have not
; been completed.
;
; usage
;
;	missing_code	<text>
;
; Entry:
;	none
; Returns:
;	none
; Error Returns:
;	none
; Registers Destroyed:
;	none
; Registers Preserved:
;	ALL
; Calls:
;       none
; History:
;	Sun 22-Mar-1987 18:21:34 -by-  Walt Moore [waltm]
;	Initial version
;-----------------------------------------------------------------------;

missing_code	macro	x
	if1
	??_out	<&! Missing Code &!  x>
	endif
	endm

;---------------------------Macro---------------------------------------;
; LMHtoP
;
; Converts a Local Memory Handle to a local pointer.
;
; Entry:
; 	reg1[,reg2]
; Returns:
; 	reg1 = pointer
; Error Returns:
; 	
; Registers Destroyed:
; 	none
; History:
;  Mon Mar 23, 1987 06:54:26a  -by-  Charles Whitmer [chuckwh]
; Imported from GDI.
;-----------------------------------------------------------------------;

LMHtoP macro r1,r2		;; Local Movable Handle to pointer
ifnb <r2>
	mov	r1,[r2]
else
	mov	r1,[r1]
endif
endm


;-------------------------Macro-----------------------------------------;
; REPSTOSB Dst
;
; store <cx> copies of al at Dst, aliging destination on WORD writes
;
;   Dst 	destination, must be of the form SEL:[di] (default is es:[di])
;
; Entry:
;   Dst 	-> points to dest buffer
;   al		byte to write
;   cx		count bytes
;
; NOTE a dest segment other than ES is handled by generating a loop
; all other cases generate a rep mov
;
; NOTE this code assumes the direction flag is set to FORWARD
;
; NOTE cx must be non-zero
;
; Returns:
;
; History:
;	Sun 31-Jul-1989  -by-  ToddLa
;	Wrote it.
;
;-----------------------------------------------------------------------;

?REPSTOSB macro Dst
	local	l1
	local	l2
	local	l3
	local	localdest

IFIDNI <Dst>, <NOAHLOAD>
	localdest EQU es:[di]
ELSE
	localdest EQU Dst
	mov	ah,al		    ; make sure ah == al
ENDIF

	test	di,1
	jz	l1
	stos	byte ptr localdest
	dec	cx
l1:
	shr	cx,1
	rep	stos word ptr localdest
	adc	cl,cl
	rep	stos byte ptr localdest

	endm

REPSTOSB macro Dst
ifb <Dst>
	?REPSTOSB es:[di]
else
	?REPSTOSB Dst
endif
	endm

;-------------------------Macro-----------------------------------------;
; REPMOVSB Dst, Src, alignR
;
; copy <cx> bytes from Src to Dst, aliging destination or source
; on WORD writes
;
;   Dst 	destination, must be of the form SEL:[di] (default is es:[di])
;   Src 	source,      must be of the form SEL:[si] (default is ds:[si])
;   alignR	register to align   si or di (default is di)
;
; Entry:
;   Src 	-> points to source buffer
;   Dst 	-> points to dest buffer
;   cx		count bytes
;
; NOTE this code assumes the direction flag is set to FORWARD
;
; NOTE cx must be non-zero
;
; Returns:
;
; History:
;	Sun 31-Jul-1989  -by-  ToddLa
;	Wrote it.
;-----------------------------------------------------------------------;

?REPMOVSB  macro Dst, Src, alignR
	local	l1
	local	l2
	local	l3

	test	alignR,1
	jz	l1
	movs	byte ptr Dst, byte ptr Src
	dec	cx
l1:	shr	cx,1
	rep	movs	word ptr Dst, word ptr Src
	adc	cl,cl
	rep	movs	byte ptr Dst, byte ptr Src

	endm

REPMOVSB  macro Dst, Src, alignR

ifb <Dst>
	?REPMOVSB es:[di],ds:[si],di
	exitm
endif

ifb <Src>
	?REPMOVSB Dst,ds:[si],di
	exitm
endif

ifb <alignR>
	?REPMOVSB Dst,Src,di
	exitm
endif
	?REPMOVSB Dst,Src,alignR

	endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\roptable.inc ===
;----------------------------Module-Header------------------------------;
; Module Name: ROPTABLE.BLT
;
; Raster operation code templates for BitBLT.
;
; Created: In Windows' distant past (c. 1983)
;
; Copyright (c) 1983 - 1987  Microsoft Corporation
;
; This file defines the code templates for all raster operations which
; BitBLT supports.
;
; This file is part of a set that makes up the Windows BitBLT function
; at driver-level.
;-----------------------------------------------------------------------;

if	MASMFLAGS and PUBDEFS
	public	Sn
	public	DDx
	public	DPna
	public	Pn
	public	PDSanon
	public	PSnon
	public	DPSona
	public	PSon
	public	PDSnaon
	public	PDSaon
	public	DPon
	public	PDSonon
	public	DPSnoon
	public	DPSoon
	public	DSon
	public	PDSona
	public	SDPxnon
	public	SSPxDSxaxn
	public	SPxDSxa
	public	PSDPSanaxx
	public	SDPSanaxn
	public	DSna
	public	PDSPanaxn
	public	DPSana
	public	PDSnaxn
	public	DPSaon
	public	PDSPaox
	public	PDSox
	public	SDPSxaxn
	public	DPSxa
	public	DSPDxaxn
	public	DPSnaa
	public	PSna
	public	DPSaan
	public	PSDnaon
	public	SPDnaon
	public	PDSPxaxn
	public	SDPSaox
	public	PSDPSaoxxn
	public	SSPxPDxaxn
	public	SPxPDxa
	public	DSPDSoaxxn
	public	SPDSoax
	public	PDSoan
	public	PSDPxox
	public	SDPxon
	public	PSDnoan
	public	PSan
	public	SDPnaon
	public	SDPaon
	public	PSDPaox
	public	SDPSoox
	public	SPDSaox
	public	DPSDxaxn
	public	SDPox
	public	PSDPoax
	public	SDPoan
	public	PSx
	public	SPDnox
	public	SPDSxox
	public	PDSxon
	public	SPDnoan
	public	SPDSonox
	public	DPSxnan
	public	SPDSnaox
	public	SPDSanaxn
	public	PDSana
	public	DSan
	public	PSDPxaxn
	public	SDPxa
	public	DSPDaox
	public	PDSPDaoxxn
	public	DPSDoax
	public	DPSanon
	public	PDSnox
	public	DSnon
	public	SDPana
	public	SSPxDSxoxn
	public	SPxDSxo
	public	PDSPxox
	public	DPSxon
	public	PDna
	public	Dn
	public	DPSDaox
	public	SPDSxaxn
	public	PDSxa
	public	DPx
	public	PDSxnon
	public	DPSnoan
	public	PDSPoax
	public	DPSoan
	public	PDSax
	public	DPSnox
	public	DPSox
	public	PDSxnan
	public	DPSDonox
	public	DPSDxox
	public	DSPnaon
	public	PDSPnaox
	public	DPan
	public	DSPDSaoxxn
	public	SDPnox
	public	DPSnaxn
	public	DPSax
	public	DSx
	public	PDSxxn
	public	SDPSonox
	public	PSDPSonoxxn
	public	DPSonon
	public	SDPSoax
	public	PSDPSoaxxn
	public	SDPax
	public	DSPDoax
	public	PDSPDoaxxn
	public	SDPSnoax
	public	SSDxPDxaxn
	public	SDxPDxa
	public	SDPSxox
	public	SDPnoan
	public	DSPDxox
	public	SDPSnaox
	public	DPSnaon
	public	DSPnoan
	public	PDSPnoax
	public	DPSxnon
	public	PDSnoan
	public	SPDSnoax
	public	SDPxnan
endif

ROPDEF macro lbl,ne,whocares
if1
if MASMFLAGS and DEBUG
public lbl
endif
ROP&ne=(offset lbl)-(offset roptable)	;;Start with offset
irpc x,lbl
ROP&ne = ROP&ne AND (NOT NEGATE_NEEDED)
ifidn <n>,<&&x>
ROP&ne = ROP&ne OR NEGATE_NEEDED 	;;Show negate needed
endif
ifidn <P>,<&&x>
ROP&ne = ROP&ne OR PATTERN_PRESENT	;;Show pattern present
endif
ifidn <S>,<&&x>
ROP&ne = ROP&ne OR SOURCE_PRESENT	;;Show source needed
endif
endm
ROPDEF1 ROP&ne,%((offset $)-(offset lbl))
endif
endm


ROPDEF1 macro lbl,len
if len					;;Skip 0
lbl = lbl OR (ROPLen&len SHL 10)	;;Set size index
endif
endm



	public	roptable
roptable	label	word

	errn$	roptable			;Must be at offset 0
Sn:
	ROPDEF	Sn,0033,0008


	errn$	roptable			;Must be at offset 0

	dw	ROP0000,ROP0001,ROP0002,ROP0003
	dw	ROP0004,ROP0005,ROP0006,ROP0007
	dw	ROP0008,ROP0009,ROP000A,ROP000B
	dw	ROP000C,ROP000D,ROP000E,ROP000F
	dw	ROP0010,ROP0011,ROP0012,ROP0013
	dw	ROP0014,ROP0015,ROP0016,ROP0017
	dw	ROP0018,ROP0019,ROP001A,ROP001B
	dw	ROP001C,ROP001D,ROP001E,ROP001F
	dw	ROP0020,ROP0021,ROP0022,ROP0023
	dw	ROP0024,ROP0025,ROP0026,ROP0027
	dw	ROP0028,ROP0029,ROP002A,ROP002B
	dw	ROP002C,ROP002D,ROP002E,ROP002F
	dw	ROP0030,ROP0031,ROP0032,ROP0033
	dw	ROP0034,ROP0035,ROP0036,ROP0037
	dw	ROP0038,ROP0039,ROP003A,ROP003B
	dw	ROP003C,ROP003D,ROP003E,ROP003F
	dw	ROP0040,ROP0041,ROP0042,ROP0043
	dw	ROP0044,ROP0045,ROP0046,ROP0047
	dw	ROP0048,ROP0049,ROP004A,ROP004B
	dw	ROP004C,ROP004D,ROP004E,ROP004F
	dw	ROP0050,ROP0051,ROP0052,ROP0053
	dw	ROP0054,ROP0055,ROP0056,ROP0057
	dw	ROP0058,ROP0059,ROP005A,ROP005B
	dw	ROP005C,ROP005D,ROP005E,ROP005F
	dw	ROP0060,ROP0061,ROP0062,ROP0063
	dw	ROP0064,ROP0065,ROP0066,ROP0067
	dw	ROP0068,ROP0069,ROP006A,ROP006B
	dw	ROP006C,ROP006D,ROP006E,ROP006F
	dw	ROP0070,ROP0071,ROP0072,ROP0073
	dw	ROP0074,ROP0075,ROP0076,ROP0077
	dw	ROP0078,ROP0079,ROP007A,ROP007B
	dw	ROP007C,ROP007D,ROP007E,ROP007F



	errn$	roptable,-256			;Must be 256 bytes afterwards
	db	2,3,4,5,7,9,11,13





;	The actual raster operation templates follow.
;
;	Entry:	AL     =  Source byte
;		DH     =  Pattern Bytes
;		ES:DI --> Destination byte
;
;	Exit:	AL     =  Result
;		DH     =  Pattern Bytes
;		ES:DI --> Destination byte
;		AH	  IS possibly the destination byte
;
;	Uses:	AL,AH,DH,DL


;-----------------------------------------------------------------
; In Wes' World:
;	The actual raster operation templates follow.
;
;	Entry:	AX     =  Source word
;		DX     =  Pattern Word
;		ES:DI --> Destination word
;
;	Exit:	AX     =  Result
;		DX     =  Pattern Word
;		ES:DI --> Destination word
;		BP,BX??	  IS possibly the destination word
;
;	Uses:	AL,AH,DH,DL
;-----------------------------------------------------------------


DDx:
	xor	al,al
	ROPDEF	DDx,0000,0042


DPna:
Pn:
	mov	al,dh
	ROPDEF	Pn,000F,0001
	not	al
PDSanon:
	and	al,es:[di]
	ROPDEF	DPna,000A,0329
PSnon:
	not	al
DPSona:
PSon:
	or	al,dh
	ROPDEF	PDSanon,0008,0F08
	ROPDEF	PSon,0003,00AA
	ROPDEF	PSnon,000C,0324
PDSnaon:
	not	al
PDSaon:
	and	al,es:[di]
	ROPDEF	DPSona,0002,0C89
	or	al,dh
	ROPDEF	PDSnaon,000D,0B25
	ROPDEF	PDSaon,0007,02C5


DPon:
	mov	al,dh
PDSonon:
	or	al,es:[di]
	ROPDEF	DPon,0005,00A9
DPSnoon:
	not	al
DPSoon:
	or	al,dh
	ROPDEF	PDSonon,000E,08A5
DSon:
PDSona:
	or	al,es:[di]
	ROPDEF	DPSnoon,0004,0C88
	ROPDEF	DPSoon,0001,0289
	ROPDEF	DSon,0011,00A6
	not	al
	and	al,dh
	ROPDEF	PDSona,0010,0C85


SDPxnon:
	mov	ah,es:[di]
	xor	ah,dh
	not	ah
	or	al,ah
	ROPDEF	SDPxnon,0012,0868


SSPxDSxaxn:
	mov	dl,al
SPxDSxa:
	mov	ah,dh
	xor	ah,al
	xor	al,es:[di]
	and	al,ah
	ROPDEF	SPxDSxa,0024,0D55
	xor	al,dl
	ROPDEF	SSPxDSxaxn,0017,1D54


PSDPSanaxx:
SDPSanaxn:
	mov	dl,al
	and	al,dh
DSna:
	not	al
	and	al,es:[di]
	ROPDEF	DSna,0022,0326
	xor	al,dl
	ROPDEF	SDPSanaxn,0019,1CC8
	xor	al,dh
	ROPDEF	PSDPSanaxx,0016,5CCA


PDSPanaxn:
DPSana:
	and	al,dh
PDSnaxn:
	not	al
	and	al,es:[di]
	ROPDEF	DPSana,002A,0CC9
	xor	al,dh
	ROPDEF	PDSnaxn,002D,060A
	ROPDEF	PDSPanaxn,0025,1CC5




DPSaon:
PDSPaox:
	and	al,dh
PDSox:
	or	al,es:[di]
	ROPDEF	DPSaon,0015,02C9
	xor	al,dh
	ROPDEF	PDSox,001E,01A5
	ROPDEF	PDSPaox,001A,06C5


SDPSxaxn:
	mov	dl,al
DPSxa:
	xor	al,dh
	and	al,es:[di]
	ROPDEF	DPSxa,0028,0369
	xor	al,dl
	ROPDEF	SDPSxaxn,001B,0768


DSPDxaxn:
	mov	ah,es:[di]
	mov	dl,ah
	xor	dl,dh
	and	al,dl
	xor	al,ah
	ROPDEF	DSPDxaxn,001D,0766


DPSnaa:
PSna:
	not	al
DPSaan:
	and	al,dh
	ROPDEF	PSna,0030,032A
	and	al,es:[di]
	ROPDEF	DPSnaa,0020,0F09
	ROPDEF	DPSaan,007F,03C9


PSDnaon:
	mov	ah,es:[di]
	not	ah
	and	al,ah
	or	al,dh
	ROPDEF	PSDnaon,000B,0B2A


SPDnaon:
	mov	ah,es:[di]
	not	ah
	and	ah,dh
	or	al,ah
	ROPDEF	SPDnaon,0023,0B24


PDSPxaxn:
	xor	al,dh
	and	al,es:[di]
	xor	al,dh
	ROPDEF	PDSPxaxn,0027,1868


SDPSaox:
PSDPSaoxxn:
	mov	dl,al
	and	al,dh
	or	al,es:[di]
	xor	al,dl
	ROPDEF	SDPSaox,0026,06C8
	xor	al,dh
	ROPDEF	PSDPSaoxxn,0029,16CA


SSPxPDxaxn:
	mov	dl,al
SPxPDxa:
	mov	ah,es:[di]
	xor	ah,dh
	xor	al,dh
	and	al,ah
	ROPDEF	SPxPDxa,0018,0D59
	xor	al,dl
	ROPDEF	SSPxPDxaxn,002B,1D58


DSPDSoaxxn:
SPDSoax:
	mov	dl,al
PDSoan:
	mov	ah,es:[di]
	or	al,ah
	and	al,dh
	ROPDEF	PDSoan,001F,0385
	xor	al,dl
	ROPDEF	SPDSoax,002C,0784
	xor	al,ah
	ROPDEF	DSPDSoaxxn,0079,1786




PSDPxox:
SDPxon:
	mov	ah,es:[di]
	xor	ah,dh
	or	al,ah
	ROPDEF	SDPxon,0021,0248
	xor	al,dh
	ROPDEF	PSDPxox,002E,064A


PSDnoan:
	mov	ah,es:[di]
	not	ah
	or	al,ah
PSan:
	and	al,dh
	ROPDEF	PSan,003F,00EA
	ROPDEF	PSDnoan,002F,0E2A


SDPnaon:
	mov	ah,dh
	not	ah
	and	ah,es:[di]
	or	al,ah
	ROPDEF	SDPnaon,0031,0B28


SDPaon:
PSDPaox:
	mov	ah,es:[di]
	and	ah,dh
	or	al,ah
	ROPDEF	SDPaon,0013,02C8
	xor	al,dh
	ROPDEF	PSDPaox,001C,06CA



SDPSoox:
	mov	dl,al
	or	al,dh
	or	al,es:[di]
	xor	al,dl
	ROPDEF	SDPSoox,0032,0688


SPDSaox:
	mov	dl,al
	and	al,es:[di]
	or	al,dh
	xor	al,dl
	ROPDEF	SPDSaox,0034,06C4


DPSDxaxn:
	mov	ah,es:[di]
	xor	al,ah
	and	al,dh
	xor	al,ah
	ROPDEF	DPSDxaxn,0035,1864


SDPox:
	mov	ah,es:[di]
	or	ah,dh
	xor	al,ah
	ROPDEF	SDPox,0036,01A8


PSDPoax:
SDPoan:
	mov	ah,es:[di]
	or	ah,dh
	and	al,ah
	ROPDEF	SDPoan,0037,0388
PSx:
	xor	al,dh
	ROPDEF	PSx,003C,004A
	ROPDEF	PSDPoax,0038,078A


SPDnox:
	mov	ah,es:[di]
	not	ah
	or	ah,dh
	xor	al,ah
	ROPDEF	SPDnox,0039,0604


SPDSxox:
	mov	dl,al
PDSxon:
	xor	al,es:[di]
	or	al,dh
	ROPDEF	PDSxon,0009,0245
	xor	al,dl
	ROPDEF	SPDSxox,003A,0644


SPDnoan:
	mov	ah,es:[di]
	not	ah
	or	ah,dh
	and	al,ah
	ROPDEF	SPDnoan,003B,0E24


SPDSonox:
	mov	dl,al
	or	al,es:[di]
	not	al
	or	al,dh
	xor	al,dl
	ROPDEF	SPDSonox,003D,18A4


DPSxnan:
	xor	al,dh
SPDSnaox:
	mov	dl,al			;(wasted for DPSxnan)
	not	al
	and	al,es:[di]
	ROPDEF	DPSxnan,007D,0C69
	or	al,dh
	xor	al,dl
	ROPDEF	SPDSnaox,003E,1B24


SPDSanaxn:
	mov	dl,al
PDSana:
DSan:
	and	al,es:[di]
	ROPDEF	DSan,0077,00E6
	not	al
	and	al,dh
	ROPDEF	PDSana,0070,0CC5
	xor	al,dl
	ROPDEF	SPDSanaxn,0043,1CC4


PSDPxaxn:
SDPxa:
	mov	ah,es:[di]
	xor	ah,dh
	and	al,ah
	ROPDEF	SDPxa,0048,0368
	xor	al,dh
	ROPDEF	PSDPxaxn,0047,076A


DSPDaox:
PDSPDaoxxn:
	mov	ah,es:[di]
	mov	dl,ah
	and	dl,dh
	or	al,dl
	xor	al,ah
	ROPDEF	DSPDaox,0046,06C6
	xor	al,dh
	ROPDEF	PDSPDaoxxn,0049,16C5

DPSDoax:
	mov	ah,es:[di]
	or	al,ah
	and	al,dh
	xor	al,ah
	ROPDEF	DPSDoax,004A,0789


DPSanon:
	and	al,dh
PDSnox:
DSnon:
	not	al
	or	al,es:[di]
	ROPDEF	DPSanon,0040,0F0A
	ROPDEF	DSnon,0044,0328
	xor	al,dh
	ROPDEF	PDSnox,004B,0605


SDPana:
	mov	ah,es:[di]
	and	ah,dh
	not	ah
	and	al,ah
	ROPDEF	SDPana,004C,0CC8


SSPxDSxoxn:
	mov	dl,al
SPxDSxo:
	mov	ah,al
	xor	ah,dh
	xor	al,es:[di]
	or	al,ah
	ROPDEF	SPxDSxo,007E,0955
	xor	al,dl
	ROPDEF	SSPxDSxoxn,004D,1954


PDSPxox:
DPSxon:
	xor	al,dh
	or	al,es:[di]
	ROPDEF	DPSxon,0041,0249
	xor	al,dh
	ROPDEF	PDSPxox,004E,0645


PDna:
Dn:
	mov	al,es:[di]
	ROPDEF	Dn,0055,0009
	not	al
	and	al,dh
	ROPDEF	PDna,0050,0325


DPSDaox:
	mov	ah,es:[di]
	and	al,ah
	or	al,dh
	xor	al,ah
	ROPDEF	DPSDaox,0052,06C9


SPDSxaxn:
	mov	dl,al
PDSxa:
	xor	al,es:[di]
	and	al,dh
	ROPDEF	PDSxa,0060,0365
	xor	al,dl
	ROPDEF	SPDSxaxn,0053,0764


DPx:
	mov	al,dh
PDSxnon:
	xor	al,es:[di]
	ROPDEF	DPx,005A,0049
DPSnoan:
	not	al
PDSPoax:
DPSoan:
	or	al,dh
	ROPDEF	PDSxnon,0006,0865
PDSax:
	and	al,es:[di]
	ROPDEF	DPSnoan,005D,0E29
	ROPDEF	DPSoan,0057,0389
	xor	al,dh
	ROPDEF	PDSPoax,0058,0785
	ROPDEF	PDSax,0078,01E5


DPSnox:
	not	al
DPSox:
	or	al,dh
PDSxnan:
	xor	al,es:[di]
	ROPDEF	DPSox,0056,01A9
	ROPDEF	DPSnox,0059,0609
	not	al
	and	al,dh
	ROPDEF	PDSxnan,006F,0C65


DPSDonox:
	mov	ah,es:[di]
	or	al,ah
	not	al
	or	al,dh
	xor	al,ah
	ROPDEF	DPSDonox,005B,18A9


DPSDxox:
	mov	ah,es:[di]
	xor	al,ah
	or	al,dh
	xor	al,ah
	ROPDEF	DPSDxox,005C,0649


DSPnaon:
PDSPnaox:
	mov	ah,dh
	not	ah
	and	al,ah
	or	al,es:[di]
	ROPDEF	DSPnaon,0051,0B26
	xor	al,dh
	ROPDEF	PDSPnaox,005E,1B29


DPan:
	mov	al,dh
	and	al,es:[di]
	ROPDEF	DPan,005F,00E9


DSPDSaoxxn:
	mov	dl,al
	mov	ah,es:[di]
	and	al,ah
	or	al,dh
	xor	al,dl
	xor	al,ah
	ROPDEF	DSPDSaoxxn,0061,16C6


SDPnox:
	mov	ah,dh
	not	ah
	or	ah,es:[di]
	xor	al,ah
	ROPDEF	SDPnox,0063,0608


DPSnaxn:
	not	al
DPSax:
	and	al,dh
DSx:
PDSxxn:
	xor	al,es:[di]
	ROPDEF	DSx,0066,0046
	ROPDEF	DPSax,006A,01E9
	ROPDEF	DPSnaxn,0065,0606
	xor	al,dh
	ROPDEF	PDSxxn,0069,0145


SDPSonox:
PSDPSonoxxn:
	mov	dl,al
DPSonon:
	or	al,dh
	not	al
	or	al,es:[di]
	ROPDEF	DPSonon,0054,08A9
	xor	al,dl
	ROPDEF	SDPSonox,0067,18A8
	xor	al,dh
	ROPDEF	PSDPSonoxxn,0068,58A6


SDPSoax:
PSDPSoaxxn:
	mov	dl,al
	or	al,dh
	and	al,es:[di]
	xor	al,dl
	ROPDEF	SDPSoax,0064,0788
	xor	al,dh
	ROPDEF	PSDPSoaxxn,006B,178A


SDPax:
	mov	ah,es:[di]
	and	ah,dh
	xor	al,ah
	ROPDEF	SDPax,006C,01E8


DSPDoax:
PDSPDoaxxn:
	mov	ah,es:[di]
	mov	dl,ah
	or	ah,dh
	and	al,ah
	xor	al,dl
	ROPDEF	DSPDoax,0062,0786
	xor	al,dh
	ROPDEF	PDSPDoaxxn,006D,1785


SDPSnoax:
	mov	dl,al
	not	al
	or	al,dh
	and	al,es:[di]
	xor	al,dl
	ROPDEF	SDPSnoax,006E,1E28


SSDxPDxaxn:
	mov	dl,al
SDxPDxa:
	mov	ah,es:[di]
	xor	al,ah
	xor	ah,dh
	and	al,ah
	ROPDEF	SDxPDxa,0042,0D5D
	xor	al,dl
	ROPDEF	SSDxPDxaxn,0071,1D5C


SDPSxox:
	mov	dl,al
	xor	al,dh
	or	al,es:[di]
	xor	al,dl
	ROPDEF	SDPSxox,0072,0648


SDPnoan:
	mov	ah,dh
	not	ah
	or	ah,es:[di]
	and	al,ah
	ROPDEF	SDPnoan,0073,0E28


DSPDxox:
	mov	ah,es:[di]
	mov	dl,ah
	xor	ah,dh
	or	al,ah
	xor	al,dl
	ROPDEF	DSPDxox,0074,0646


SDPSnaox:
	mov	dl,al
DPSnaon:
	not	al
	and	al,dh
	or	al,es:[di]
	ROPDEF	DPSnaon,0045,0B29
	xor	al,dl
	ROPDEF	SDPSnaox,0076,1B28


DSPnoan:
PDSPnoax:
	mov	ah,dh
	not	ah
	or	al,ah
	and	al,es:[di]
	ROPDEF	DSPnoan,0075,0E26
DPSxnon:
	xor	al,dh
	ROPDEF	PDSPnoax,007A,1E29
PDSnoan:
SPDSnoax:
	mov	dl,al			;(wasted for DPSxnon)
	not	al
	or	al,es:[di]
	ROPDEF	DPSxnon,0014,0869
	and	al,dh
	ROPDEF	PDSnoan,004F,0E25
	xor	al,dl
	ROPDEF	SPDSnoax,007C,1E24

SDPxnan:
	mov	ah,es:[di]
	xor	ah,dh
	not	ah
	and	al,ah
	ROPDEF	SDPxnan,007B,0C68



foobar	macro	y
if @Version LT 600
if2
  %out	Size of the table is y.
endif
else
  %out	Size of the table is y.
endif
endm

foobar	%(offset $)-(offset roptable)-256-8
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\rpgen.c ===
/*
**  Copyright (c) 1991 Microsoft Corporation
*/
//===========================================================================
// FILE                         RPGEN.C
//
// MODULE                       Host Resource Executor
//
// PURPOSE                      Rendering primitives, generic,
//
// DESCRIBED IN                 Resource Executor design spec.
//
//
// MNEMONICS                    n/a
//
// HISTORY                      Bert Douglas  5/1/91 Initial coding started
//                              mslin/dstseng 01/17/92 revise for HRE
//                              dstseng       03/06/92 <1> RP_FillScanRow 
//															 ->RP_FILLSCANROW for asm. version.
//										  dstseng		 03/19/92 <2> comment out unnecessary code.
//															 which was implemented for frac. version of
//															 slicing algorithm.
//
//===========================================================================
#include <windows.h>
#include "constant.h"
#include "jtypes.h"
#include "jres.h"
#include "frame.h"      // driver header file, resource block format
#include "hretype.h"    // define data structure used by hre.c and rpgen.c

//---------------------------------------------------------------------------
void RP_SliceLine
(
   SHORT s_x1, SHORT s_y1,  // endpoint 1
   SHORT s_x2, SHORT s_y2,  // endpoint 2
   RP_SLICE_DESC FAR* psd, // output slice form of line
   UBYTE fb_keep_order      // keep drawing order on styled lines/
)

// PURPOSE
//    Convert a line from endpoint form to slice form
//
//    Slices will run from left to right
//
//    The generated slices are of maximal length and are in a horizontal,
//    vertical or diagonal direction.  Most frame buffer hardware can be
//    accessed with particular efficiency in these directions.  All slices
//    of a line are in the same direction.
//
//    Clipping must be performed by caller.  All coordinates will be non-negative.
//
//    Basic algorithm is taken from :
//      Bresenham, J. E. Run length slice algorithms for incremental lines.
//      In "Fundamental Algorithms for Computer Graphics", R. A. Earnshaw, Ed.
//      NATO ASI Series, Springer Verlag, New York, 1985, 59-104.
//
//    Modifications have been made to the above algorithm for:
//      - sub-pixel endpoint coordinates
//      - equal error rounding rules
//      - GIQ (grid intersect quantization) rules
//      - first/last pixel exclusion
//
//    The line is sliced in four steps:
//
//    STEP 1:  Find the pixel center cooridnates of the first and
//    last pixels in the line.  This is done according to the GIQ conventions.
//
//    STEP 2:  Use these integer pixel center endpoint coordinates
//    to produce the Bresenham slices for the line.  The equal error rounding
//    rule is used, when the first and last slices are not of equal length, to
//    decide which end gets the short slice.
//
//    STEP 3:  Adjust the length of the first and last slices for the
//    effect of the sub-pixel endpoint coordinates.  Note that the sub-pixel
//    part of the coordinates can only effect the first and last slices and
//    has no effect on the intermediate slices.
//
//    STEP 4:  Perform the conditional exclusion of the first and
//    last pixels from the line.
//
//
// ASSUMPTIONS & ASSERTIONS     none.
//
// INTERNAL STRUCTURES          none.
//
// UNRESOLVED ISSUES            programmer development notes
//---------------------------------------------------------------------------
{
   SHORT  s_q,s_r;               /* defined in Bresenhams paper            */
   SHORT  s_m,s_n;               /* "                                      */
   SHORT  s_dx,s_dy;             /* "                                      */
   SHORT  s_da,s_db;             /* "                                      */
   SHORT  s_del_b;               /* "                                      */
   SHORT  s_abs_dy;              /* absolute value of s_dy                 */

   SHORT  s_sy;                  /* 1 or -1 , sign of s_dy                 */
   SHORT  s_dx_oct,s_dy_oct;     /* octant dir  xy= 0/1 1/1 1/0 1/-1 0/-1  */
   SHORT  s_dx_axial,s_dy_axial; /* 1/2 octant axial dir xy= 0/1 1/0 -1/0  */
   SHORT  s_dx_diag, s_dy_diag;  /* 1/2 octant diagonal dir xy= 1/1 1/-1   */
   SHORT  s_t;                   /* temporary                              */
   FBYTE  fb_short_end_last;     /* 0=first end short, 1=last end short    */
   UBYTE  fb_unswap;             /* need to un-swap endpoints at return    */

   fb_unswap = FALSE;


   /*------------------------------------------------------------*/
   /* STEP 1: Find pixel center coordinates of first/last pixels */
   /*------------------------------------------------------------*/

   /* always draw left to right, normalize to semicircle with x >= 0 */
   s_dx = s_x2 - s_x1;
   if ( s_dx < 0 )
   {
      fb_unswap = fb_keep_order;
      s_dx  = -s_dx;
      s_t     = s_x2;
      s_x2 = s_x1;
      s_x1 = s_t;
      s_t     = s_y2;
      s_y2 = s_y1;
      s_y1 = s_t;
   }
   s_dy = s_y2 - s_y1;


   /*------------------------------------------------------------*/
   /* STEP 2: Produce slices using the Bresenham algorithm       */
   /*------------------------------------------------------------*/

   if ( s_dy < 0 )
   {
      s_abs_dy = -s_dy;
      s_sy = -1;
      fb_short_end_last = 1;
    }
   else
   {
      s_abs_dy = s_dy;
      s_sy = 1;
      fb_short_end_last = 0;
   }

   /* normalize to octant */
   if ( s_dx >= s_abs_dy )
   {
      s_da = s_dx;
      s_db = s_abs_dy;
      s_dx_oct = 1;
      s_dy_oct = 0;
   }
   else
   {
      s_da = s_abs_dy;
      s_db = s_dx;
      s_dx_oct = 0;
      s_dy_oct = s_sy;
      fb_short_end_last = 1;
   }

   /* normalize to half octant */
   s_del_b = s_db;
   s_t = s_da - s_db;
   if ( s_del_b > s_t )
   {
      s_del_b = s_t;
      fb_short_end_last ^= 1;
   }

   /* handle special case of slope of 2 */
   s_dx_axial = s_dx_oct;
   s_dy_axial = s_dy_oct;
   s_dx_diag = 1;
   s_dy_diag = s_sy;
   if (  ( s_da == (2 * s_del_b) )
      && ( s_dy < 0 )
      )
   {  s_dx_axial = 1;
      s_dy_axial = s_sy;
      s_dx_diag = s_dx_oct;
      s_dy_diag = s_dy_oct;
      fb_short_end_last ^= 1;
   }

   /* determine slice movement and skip directions */
   if ( s_db == s_del_b )
   {
      /* slice direction is axial, skip direction is diagonal */
      psd->s_dx_draw = s_dx_axial;
      psd->s_dy_draw = s_dy_axial;
      psd->s_dx_skip = s_dx_diag - s_dx_axial;
      psd->s_dy_skip = s_dy_diag - s_dy_axial;
   }
   else
   {
      /* slice direction is diagonal, skip direction is axial */
      psd->s_dx_draw = s_dx_diag;
      psd->s_dy_draw = s_dy_diag;
      psd->s_dx_skip = s_dx_axial - s_dx_diag;
      psd->s_dy_skip = s_dy_axial - s_dy_diag;
   }

   /* handle zero slope lines with special case */
   if ( s_del_b == 0 )
   {
      psd->us_first = s_da + 1;
      psd->us_n_slices = 0;
      psd->us_last = 0;
   }
   else
   /* general case, non-zero slope lines */
   {
      /* basic Bresenham parameters */
      s_q = s_da / s_del_b;
      s_r = s_da % s_del_b;
      s_m = s_q / 2;
      s_n = s_r;
      if ( s_q & 1 ) s_n += s_del_b;

      /* first and last slice length */
      psd->us_first = psd->us_last = s_m + 1;
      if ( s_n == 0 )
      {
         if ( fb_short_end_last )
            psd->us_last -= 1;
         else
            psd->us_first -= 1;
      }

      /* remaining line slice parameters */
      psd->us_small = s_q;
      psd->s_dis_sm = 2*s_r;
      psd->s_dis_lg = psd->s_dis_sm - (2*s_del_b);
      psd->s_dis = s_n + psd->s_dis_lg;
      if ( s_dy < 0 ) psd->s_dis -= 1;
      psd->us_n_slices = s_del_b - 1;

   }

   /* output endpoints */
   psd->us_x1 = s_x1;
   psd->us_y1 = s_y1;
   psd->us_x2 = s_x2;
   psd->us_y2 = s_y2;

   if ( fb_unswap )
   {
      psd->us_x1 = s_x2;
      psd->us_y1 = s_y2;
      psd->us_x2 = s_x1;
      psd->us_y2 = s_y1;
      psd->s_dx_draw = -psd->s_dx_draw;
      psd->s_dy_draw = -psd->s_dy_draw;
      psd->s_dx_skip = -psd->s_dx_skip;
      psd->s_dy_skip = -psd->s_dy_skip;
      s_t = psd->us_first;
      psd->us_first = psd->us_last;
      psd->us_last = s_t;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\ropdefs.inc ===
;----------------------------Module-Header------------------------------;
; Module Name: ROPDEFS.BLT
;
; Constants relating to raster operation definitions.
;
; Created: In Windows' distant past (c. 1983)
;
; Copyright (c) 1983 - 1987  Microsoft Corporation
;
; These constants are used mainly in the file ROPTABLE.BLT, in which
; the raster operation code templates are defined.
;
; This file is part of a set that makes up the Windows BitBLT function
; at driver-level.
;-----------------------------------------------------------------------;

	subttl	Raster Operation Definitions
	page


;	Raster Op Definitions
;
;
;	The include file COMMENT.BLT contains a good description
;	of the encoding of the raster operations.  It should be
;	read before examining the definitions that follow.
;
;	The sixteen-bit number indicating which raster Op is to be
;	performed is encoded in the following manner:


EPS_OFF	=	0000000000000011b	;Offset within parse string
EPS_INDEX =	0000000000011100b	;Parse string index
LogPar	=	0000000000100000b	;(1 indicates implied NOT as Logop6)
LogOp1	=	0000000011000000b	;Logical Operation #1
LogOp2	=	0000001100000000b	;Logical Operation #2
LogOp3	=	0000110000000000b	;Logical Operation #3
LogOp4	=	0011000000000000b	;Logical Operation #4
LogOp5	=	1100000000000000b	;Logical Operation #5


;	The parity bit is used to encode an optional sixth logical operation
;	which will always be a "NOT".  In most cases this is used to get an
;	even number of "NOT"s so that reduction can take place (two sequential
;	trailing "NOT"s cancel each other out and thus are eliminated).



;	Each LogOp (Logical Operation) is encoded as follows:

LogNOT	=	00b			;NOT result
LogXOR	=	01b			;XOR result with next operand
LogOR	=	10b			;OR  result with next operand
LogAND	=	11b			;AND result with next operand



;	The parse string is a string which contains the operands for
;	the logical operation sequences (source, destination, pattern).
;	The logic opcodes are applied to the current result and the next
;	element of the given string (unless the LogOp is a NOT which only
;	affects the result).
;
;	The string is encoded as eight two-bit numbers indicating which
;	operand is to be used

opDefs		struc
  OpSpec	db	?		  ;Special Operand as noted below
  OpSrc 	db	?		  ;Operand is source field
  OpDest	db	?		  ;Operand is destination field
  OpPat 	db	?		  ;Operand is pattern field
opDefs		ends



;	The special operand is used for a few rops that would not fit into
;	an RPN format.	On the first occurance of an OpSpec, the current result
;	is "PUSHED", and the next operand is loaded.  On the second occurance
;	of the OpSpec, the given logic operation is performed between the
;	current result and the "PUSHED" value.
;
;	**NOTE**  Since there can be no guarantee that the client will call
;	the BLT routine with one of the 256 published raster ops, it is
;	possible that a value might be "PUSHED" and then never "POPPED".
;	If these "PUSHES" are made to the stack, then care must be made to
;	remove the "PUSHED" value.
;
;	In any case, since the raster op was not one of the published
;	"magic numbers", the BLT can be aborted or the result can be
;	computed to the extent possible.  The only restriction is that it
;	must not crash the system (i.e. don't leave extra stuff on the stack).
;
;		Simply: Compute garbage, but don't crash!




;	Define the parse strings to be allocated later.
;
;	An example parse string for the pattern "SDPSDPSD" would be
;	"0110110110110110b"


parseStr0	=	07AAAh		;src,pat,dest,dest,dest,dest,dest,dest
parseStr1	=	079E7h		;src,pat,dest,src,pat,dest,src,pat
parseStr2	=	06DB6h		;src,dest,pat,src,dest,pat,src,dest
parseStr3	=	0AAAAh		;dest,dest,dest,dest,dest,dest,dest,dest
parseStr4	=	0AAAAh		;dest,dest,dest,dest,dest,dest,dest,dest
parseStr5	=	04725h		;src,spec,src,pat,spec,dest,src,src
parseStr6	=	04739h		;src,spec,src,pat,spec,pat,dest,src
parseStr7	=	04639h		;src,spec,src,dest,spec,pat,dest,src



;	The following equates are for certain special functions that are
;	derived from the very first string (index of SpecParseStrIndex).
;
;	These strings will have their innerloops special cased for
;	speed enhancements (i.e MOVSx and STOSx for pattern copys and
;	white/black fill, and MOVSx for source copy if possible)

PAT_COPY 	equ	0021h		;P    - dest = Pattern
NOTPAT_COPY	equ	0001h		;Pn   - dest = NOT Pattern
FILL_BLACK	equ	0042h		;DDx  - dest = 0 (black)
FILL_WHITE	equ	0062h		;DDxn - dest = 1
SOURCE_COPY	equ	0020h		;S    - dest = source


	errnz	LogXOR-01b		;These must hold true for above equates
	errnz	LogOp1-0000000011000000b
	errnz	LogPar-0000000000100000b
	errnz	parseStr0-7AAAh 	;  plus the string must be SPDD


SPEC_PARSE_STR_INDEX equ	0	;Special cased strings index


if @Version LT 600
if2
  %out	Static Raster Operations
endif
else
  %out	Static Raster Operations
endif



;	The raster operation table consists of a word for each of
;	the first 128 raster operations (00 through 7F).  The second
;	half of the raster operations (FF through 80) are the inverse
;	of the first half.
;
;	The table is encoded as follows:
;
;	    N S P LLL OOOOOOOOOO
;	    | | |  |	  |
;	    | | |  |	  |_____  Offset of code from roptable.
;	    | | |  |
;	    | | |  |____________  Length index
;	    | | |
;	    | | |_______________  Pattern is present
;	    | |
;	    | |_________________  Source is present
;	    |
;	    |___________________  Generate trailing NOT
;
;
;	To map the ROPS 80h through FFh to 00h through 7Fh, take the
;	1's complement of the ROP, and invert 'N' above.
;
;
;	Notes:
;
;	    1)	An offset of 0 is reserved for source copy.  This
;		was done to reduce the number of LLLs to 8, so that
;		the above encoding could fit into a 16-bit integer.
;
;
;	    2)	LLL only allows a maximum of 8 different template sizes!
;		Actual length is at roptable+256+LLL.
;
;
;
;
;	ROP is the macro that generates the equates which will be
;	stored into the roptable as specified above.
;
;	Usage:
;
;	    ROPDEF	Pattern,Number
;
;	Where
;
;	    Pattern	Is the RPN definition of the raster operation.
;			It is used as the label of the first byte of
;			the template.  It also is used to determine
;			is there is a (S)ource, (P)attern, and if the
;			final result is to be (n)egated.
;
;	    Number	is the boolean result of the raster operation
;			based on a P=F0, S=CC, and D=AA.  These labels
;			and indexes can be found in the file COMMENT.BLT
;
;			Since there are many equivelent boolean expresions,
;			some of the rops will not match the label given.
;			The label is for reference only.  The final result
;			is what counts.



ROPOffset	equ	0000001111111111b
ROPLength	equ	0001110000000000b
SOURCE_PRESENT	equ	0010000000000000b
PATTERN_PRESENT	equ	0100000000000000b
NEGATE_NEEDED	equ	1000000000000000b


;	Define the eight template length indices.

ROPLen2  	equ	0
ROPLen3  	equ	1
ROPLen4  	equ	2
ROPLen5  	equ	3
ROPLen7  	equ	4
ROPLen9  	equ	5
ROPLen11 	equ	6
ROPLen13 	equ	7
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\rplnee.h ===
typedef char             int8;           /* signed byte: -128..127          */
typedef unsigned char    uint8;          /* unsigned byte: 0..255           */
typedef unsigned short   uint16;         /* unsigned integer: 0..65535      */
typedef short            int16;          /* signed integer: -32768..32767   */
typedef unsigned long    uint32;         /* unsigned long integer: 0..2^32-1*/
typedef long             int32;          /* signed long integer: -2^31..2^31*/

#define FIRST    (uint16)1
#define LAST     (uint16)2
#define ALLONE   (uint16)0xFFFF
#define SECTOR0  0
#define SECTOR1  4
#define SECTOR2  7
#define SECTOR3  9
#define SECTOR4  11
#define SECTOR5  13
#define SECTOR6  12
#define SECTOR7  8

struct DRAWINFO
{
    uint16 FAR *bytePosition;
    int    nextY;
    uint16 bitPosition;
};

typedef struct DRAWINFO drawInfoStructType;

static void Sector07(RP_SLICE_DESC FAR* line, LPBITMAP lpbm);
static void Sector16(RP_SLICE_DESC FAR* line, LPBITMAP lpbm);
static void Sector25(RP_SLICE_DESC FAR* line, LPBITMAP lpbm);
static void Sector34(RP_SLICE_DESC FAR* line, LPBITMAP lpbm);

void (*sector_function[14])(RP_SLICE_DESC FAR*, LPBITMAP lpbm) =
{
	Sector07,
	     0,
	     0,
	     0,
	Sector16,
	     0,
	     0,
	Sector25,
	Sector07,
	Sector34,
	     0,
	Sector34,
	Sector16,
	Sector25
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\viewrend\genfile.hpp ===
/*==============================================================================
This C++ object provides a generic layer over various stream types.

	#define		Stream
	WINFILE   Windows file 
	SECFILE   IFAX secure file
  OLEFILE   OLE2 IStream

01-Nov-93   RajeevD    Created.
03-Mar-94   RajeevD    Added IStream support.
==============================================================================*/
#ifndef _INC_GENFILE
#define _INC_GENFILE

#include <ifaxos.h>

#ifdef SECFILE
#include <awfile.h>
#endif

#ifdef OLEFILE
#ifdef WIN32
#include <objerror.h>
#endif
#include <memory.h>
#include <objbase.h>
#endif

// seek origins
#define SEEK_BEG 0
#define SEEK_CUR 1 
#define SEEK_END 2

typedef struct FAR GENFILE
{
	GENFILE (void) {fOpen = FALSE;}

#ifdef WINFILE

	HFILE hf;
	
	BOOL Open  (LPVOID lpFilePath, WORD wMode)
		{ return (fOpen = (hf = _lopen ((LPSTR) lpFilePath, wMode)) != HFILE_ERROR); }
	
 	BOOL Read  (LPVOID lpRead, UINT cbRead)
		{ return _lread  (hf, (char FAR*) lpRead,  cbRead) == cbRead; }

	BOOL Write (LPVOID lpWrite, UINT cbWrite)
		{ return _lwrite (hf, (char FAR*) lpWrite, cbWrite) == cbWrite; }
		
	BOOL Seek  (long lOffset, WORD wOrigin = 0)
		{ return _llseek (hf, lOffset, wOrigin) != -1L; }

	DWORD Tell (void)
		{ return _llseek (hf, 0, SEEK_CUR); }

	~GENFILE ()
		{ if (fOpen) _lclose (hf); }

#endif // WINFILE

#ifdef SECFILE

	hOpenSecureFile hosf;

	BOOL Open  (LPVOID lpFilePath, WORD wMode)
		{ return (fOpen = !SecOpenFile ((LPhSecureFile) lpFilePath, &hosf, wMode)); }

 	BOOL Read  (LPVOID lpRead, UINT cbRead)
		{ return SecReadFile  (&hosf, lpRead, cbRead) == cbRead; }

	BOOL Write (LPVOID lpWrite, UINT cbWrite)
		{ return SecWriteFile (&hosf, lpWrite, cbWrite) == cbWrite; }
		
	BOOL Seek  (long lOffset, WORD wOrigin = 0)
		{ return SecSeekFile  (&hosf, lOffset, wOrigin) != -1L; }

	DWORD Tell (void)
		{ return SecSeekFile (&hosf, 0, SEEK_CUR);}

	~GENFILE ()
		{ if (fOpen) SecCloseFile (&hosf); }

#endif // SECFILE

#ifdef OLEFILE

	LPSTREAM lpStream;
	
	BOOL Open  (LPVOID lpFilePath, WORD wMode)
	{
		lpStream = (LPSTREAM) lpFilePath;
		Seek (0, STREAM_SEEK_SET); // BKD: changed to STREAM_SEEK_SET
		return TRUE;
	}
	
 	BOOL Read  (LPVOID lpRead, UINT cbRead)
	{ 
		DWORD cbActual;
		lpStream->Read (lpRead, cbRead, &cbActual);
		return (cbRead == cbActual);
	}

	BOOL Write (LPVOID lpWrite, UINT cbWrite)
	  { return (lpStream->Write (lpWrite, cbWrite, NULL) == S_OK); }
		
	BOOL Seek  (long lOffset, WORD wOrigin = 0)
	{
		LARGE_INTEGER dlOffset;		
		ULARGE_INTEGER dlNewOffset;

		LISet32 (dlOffset, lOffset);
		return (lpStream->Seek (dlOffset, wOrigin, &dlNewOffset) == S_OK);
	}

	DWORD Tell (void)
	{
		LARGE_INTEGER dlOffset;
		ULARGE_INTEGER dlNewOffset;

		LISet32 (dlOffset, 0);
		lpStream->Seek (dlOffset, SEEK_CUR, &dlNewOffset);
		return dlNewOffset.LowPart;
	}
		
	~GENFILE () { }
  
#endif // OLEFILE

	BOOL fOpen;
}
	FAR *LPGENFILE;

#endif // _INC_GENFILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\viewrend\dcxview.cpp ===
/*==============================================================================
This module provides DCX rendering support for viewing faxes.

19-Jan-94   RajeevD    Integrated into IFAX viewer.
==============================================================================*/
#ifdef VIEWDCX

#include <memory.h>
#include "viewrend.hpp"
#include "dcxcodec.h"

//==============================================================================
DCXVIEW::DCXVIEW (DWORD nType)
{
	nTypeOut = nType;
	lpCodec = NULL;
	bufIn.wLengthBuf = 8000;
	bufIn.lpbBegBuf = (LPBYTE) GlobalAllocPtr (0, bufIn.wLengthBuf);
}

//==============================================================================
DCXVIEW::~DCXVIEW ()
{
	if (lpCodec)
		GlobalFreePtr (lpCodec);
	if (bufIn.lpbBegBuf)
		GlobalFreePtr (bufIn.lpbBegBuf);
}
		
//==============================================================================
BOOL DCXVIEW::Init (LPVOID lpFilePath, LPVIEWINFO lpvi, LPWORD lpwBandSize)
{
	DWORD dwOffset;
	PCX_HDR pcx;
	UINT cbCodec;

	if (!this || !bufIn.lpbBegBuf)
		return_error (("VIEWREND could not allocate context!\r\n"));

	if (!Open (lpFilePath, 0))
		return_error (("VIEWREND could not open spool file!\r\n"));

	if (!Seek (sizeof(DWORD), SEEK_BEG))
		return_error (("VIEWREND could not seek to first page offset!\r\n"));

	if (!Read (&dwOffset, sizeof(dwOffset)))
		return_error (("VIEWREND could not read first page offset\r\n"));
		
	if (!Seek (dwOffset, SEEK_BEG))
		return_error (("VIEWREND could not seek to first page!\r\n"));

	if (!Read (&pcx, sizeof(pcx)))
		return_error (("VIEWREND could read header of first page!\r\n"));


	// Fill VIEWINFO.
	lpvi->cPage = 0;
	while (SetPage(lpvi->cPage))
		lpvi->cPage++;
	switch (pcx.xRes)
	{
		case 640:
			// Assume square aspect ratio for apps.
			lpvi->xRes = 200;
			lpvi->yRes = 200;
			break;

		default:
			lpvi->xRes = pcx.xRes;
			lpvi->yRes = pcx.yRes;
			break;
	}		
	lpvi->yMax = pcx.yMax - pcx.yMin;
	
	// Set up codec.
	fcp.nTypeIn  = DCX_DATA;
	fcp.nTypeOut = HRAW_DATA;
	fcp.cbLine = (pcx.xMax - pcx.xMin + 1) / 8;
	
	// Query codec.
	cbCodec = DcxCodecInit (NULL, &fcp);
	if (!cbCodec)
		return_error (("VIEWREND could not init codec!\r\n"));

	// Initialize codec.
	lpCodec = GlobalAllocPtr (0, cbCodec);
	if (!lpCodec)
		return_error (("VIEWREND could not allocate codec!\r\n"));

	cbBand = *lpwBandSize;
	return SetPage (0);
}

//==============================================================================
BOOL DCXVIEW::SetPage (UINT iPage)
{
	DWORD dwOffset[2];
	DEBUGCHK (iPage < 1024);

  // Get offset of current and next page.
	Seek (sizeof(DWORD) * (iPage + 1), SEEK_BEG);
	Read (dwOffset, sizeof(dwOffset));
	if (!dwOffset[0])
		return FALSE;
	if (!dwOffset[1])
	{	
		Seek (0, SEEK_END);
		dwOffset[1] = Tell();
	}

  // Seek to page.
	dwOffset[0] += sizeof(PCX_HDR);
	if (!Seek (dwOffset[0], SEEK_BEG))
		return_error (("VIEWREND could not seek to page %d!",iPage));
	cbPage = dwOffset[1] - dwOffset[0];

  // Initialize codec.
	DcxCodecInit (lpCodec, &fcp);
	bufIn.Reset();

	fEndPage = FALSE;
	return TRUE;
}
	
//==============================================================================
BOOL DCXVIEW::GetBand (LPBITMAP lpbmBand)
{
	FC_STATUS fcs;
	BUFFER bufOut;
	
	DEBUGCHK (lpbmBand && lpbmBand->bmBits);

	// Fill descriptor.
	lpbmBand->bmType = 0;
	lpbmBand->bmWidth = 8 * fcp.cbLine;
	lpbmBand->bmWidthBytes = fcp.cbLine;
	lpbmBand->bmPlanes = 1;
	lpbmBand->bmBitsPixel = 1;

	// Trap end of page.
	if (fEndPage)
	{
		lpbmBand->bmHeight = 0;
		return TRUE;
	}
	
	// Set up output buffer.
	bufOut.lpbBegBuf  = (LPBYTE) lpbmBand->bmBits;
	bufOut.wLengthBuf = cbBand;
	bufOut.Reset();
	bufOut.dwMetaData = LRAW_DATA;
	
	do
	{
	  // Fetch input buffer?
		if (!bufIn.wLengthData)
		{
			// Reset buffer.
			bufIn.lpbBegData = bufIn.lpbBegBuf;
			if ((DWORD) bufIn.wLengthBuf < cbPage)
				bufIn.wLengthData = bufIn.wLengthBuf;
			else
				bufIn.wLengthData = (WORD) cbPage;
				
      // Read DCX data.
			if (!Read (bufIn.lpbBegData, bufIn.wLengthData))
				return_error (("VIEWREND could not read DCX buffer!\r\n"));
			cbPage -= bufIn.wLengthData;
		}

	  // Decode the DCX data.
		fcs = DcxCodecConvert (lpCodec, &bufIn, &bufOut);

		// Check for end of page.
		if (!cbPage)
		{
			fEndPage = TRUE;
			break;
		}
	}
		while (fcs == FC_INPUT_EMPTY);

  // Bit reverse if needed.
	if (nTypeOut == LRAW_DATA)
		BitReverseBuf (&bufOut);

  // Calculate output height.
	lpbmBand->bmHeight = bufOut.wLengthData / fcp.cbLine;
	return TRUE;
}

#endif // VIEWDCX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\rplnee.c ===
/*
**  Copyright (c) 1991 Microsoft Corporation
*/
//===========================================================================
// FILE                         RPLNEE.C
//
// MODULE                       Host Resource Executor
//
// PURPOSE                      Using Bresenham run slice algorithm to
//                              draw single pixel line.
//
// DESCRIBED IN                 Resource Executor design spec.
//
// The drawing sectors are also described in the following diagram.
// Y is shown increasing down the page as do the printer physical
// coordinates.  The program code handles separately sectors 0/7, 6/1, 5/2
// and 4/3.
//
//
//             |        x         x
//             |                 x
//             |       x        x
//             |               x
//             |  0   x   1   x
//             |             x
//             |     x      x
//             |           x
//             |    x     x
//             |         x   2
//             |   x    x         x
//             |       x        x
//             |  x   x       x
//             |     x      x
//             | x  x     x
//             |   x    x
//             |x x   x      3
//             | x  x
//             |x x
//             |-------------------            --> X
//             |x x
//             | x  x
//             |x x   x      4
//             |   x    x
//             | x  x     x
//             |     x      x
//             |  x   x       x
//             |       x        x
//             |   x    x         x
//             |         x   5
//             |    x     x
//             |           x
//             |     x      x
//             |             x
//             |  7   x   6   x
//             |               x
//             |       x        x
//             |                 x
//             |        x         x
//
//
//             |
//             |
//            \|/
//
//             Y
//
//
// MNEMONICS                    n/a
//
// HISTORY  1/17/92 dstseng     created
//
//===========================================================================

// include file
#include <windows.h>

#include "constant.h"
#include "frame.h"      // driver header file, resource block format
#include "jtypes.h"     // type definition used in cartridge
#include "jres.h"       // cartridge resource data type definition
#include "hretype.h"    // define data structure used by hre.c and rpgen.c
#include "rplnee.h"

static
void ShortSlice07(RP_SLICE_DESC FAR* line,
                  drawInfoStructType FAR *drawInfo,
                  uint16  firstOrLast);
static
void ShortSlice16(RP_SLICE_DESC FAR* line,
                  drawInfoStructType FAR *drawInfo,
                  uint16  firstOrLast);
static
void ShortSlice25(RP_SLICE_DESC FAR* line,
                  drawInfoStructType FAR *drawInfo,
                  uint16  firstOrLast);
static
void DisplaySlice34(RP_SLICE_DESC FAR* line,
                  drawInfoStructType FAR *drawInfo,
                  uint16  firstOrLast);

//---------------------------------------------------------------------------
UINT                            //always return 0 to upper level
RP_LineEE_Draw
(
    RP_SLICE_DESC FAR FAR* line,        /* output slice form of line */
    LPBITMAP      lpbm
)

// PURPOSE                      input RP_SLICE_DESC is prepared by RP_SliceLine
//                              according to different sector (0-7),
//                              this routine will call different functions
//                              to draw the slices with the length recorded
//                              in FAR* line.
//
//
// ASSUMPTIONS & ASSERTIONS     None.
//
// INTERNAL STRUCTURES          RP_SLICE_DESC is defined in hretype.h
//
// UNRESOLVED ISSUES            programmer development notes
//---------------------------------------------------------------------------
{
uint16 func;

    /* Get function address according to drawing & skipping direction */
    func = (line->s_dx_draw << 3) + (line->s_dy_draw << 2) +
           (line->s_dx_skip << 1) + line->s_dy_skip + 2;

    /* Call corresponding function to render line */
    (*sector_function[func])(line, lpbm);
    return(0);
}

//---------------------------------------------------------------------------
static void
Sector07
(
    RP_SLICE_DESC FAR* line,        /* output slice form of line */
    LPBITMAP lpbm
)

// PURPOSE                      input RP_SLICE_DESC is prepared by RP_SliceLine
//                              prepare drawinfo and call ShortSlice07()
//                              to draw the line located in sector 0/7
//                              dy/dx > 2
//
//
// ASSUMPTIONS & ASSERTIONS     None.
//
// INTERNAL STRUCTURES          RP_SLICE_DESC is defined in hretype.h
//                              drawInfoStructType is defined in rplnee.h
//
// UNRESOLVED ISSUES            programmer development notes
//---------------------------------------------------------------------------
{
uint16 func;
uint16 bitShift;
drawInfoStructType drawInfo;

    drawInfo.bytePosition = (uint16 FAR *)((UINT_PTR)lpbm->bmBits +
                             line->us_y1 * lpbm->bmWidthBytes);
    drawInfo.bytePosition += line->us_x1 >> 4;
    func = (line->s_dx_draw << 3) + (line->s_dy_draw << 2) +
           (line->s_dx_skip << 1) + line->s_dy_skip + 2;
    if (func == SECTOR0)
        drawInfo.nextY = -1 * lpbm->bmWidthBytes; /* sector 0 */
    else
        drawInfo.nextY = lpbm->bmWidthBytes;  /* sector 7 */
    bitShift = line->us_x1 & 0x000F;
    drawInfo.bitPosition = 0x8000 >> bitShift;
    /* Now rendering the first slice */
    if (line->us_first > 0) {
            ShortSlice07(line, &drawInfo, FIRST);
    }
    /* Rendering intermediate slices */
    if (line->us_n_slices > 0) {
            ShortSlice07(line, &drawInfo, (uint16)0);
    }
    /* Now rendering the last slice */
    if (line->us_last > 0) {
            ShortSlice07(line, &drawInfo, LAST);
    }
    return;
}

//---------------------------------------------------------------------------
static void
Sector16
(
    RP_SLICE_DESC FAR* line,         /* output slice form of line */
    LPBITMAP lpbm
)

// PURPOSE                      input RP_SLICE_DESC is prepared by RP_SliceLine
//                              prepare drawinfo and call ShortSlice16()
//                              to draw the line located in sector 1/6
//                              2 > dy/dx > 1
//
//
// ASSUMPTIONS & ASSERTIONS     None.
//
// INTERNAL STRUCTURES          RP_SLICE_DESC is defined in hretype.h
//                              drawInfoStructType is defined in rplnee.h
//
// UNRESOLVED ISSUES            programmer development notes
//---------------------------------------------------------------------------
{
uint16 func;
uint16 bitShift;
drawInfoStructType drawInfo;

    drawInfo.bytePosition = (uint16 FAR *)((UINT_PTR)lpbm->bmBits +
                             line->us_y1 * lpbm->bmWidthBytes);
    drawInfo.bytePosition += line->us_x1 >> 4;
    func = (line->s_dx_draw << 3) + (line->s_dy_draw << 2) +
           (line->s_dx_skip << 1) + line->s_dy_skip + 2;
    if (func == SECTOR1)
        drawInfo.nextY = -1 * lpbm->bmWidthBytes; /* sector 1 */
    else
        drawInfo.nextY = lpbm->bmWidthBytes;  /* sector 6 */
    bitShift = line->us_x1 & 0x000F;
    drawInfo.bitPosition = 0x8000 >> bitShift;
    /* Now rendering the first slice */
    if (line->us_first > 0) {
            ShortSlice16(line, &drawInfo, FIRST);
    }
    /* Rendering intermediate slices */
    if (line->us_n_slices > 0) {
            ShortSlice16(line, &drawInfo, (uint16)0);
    }
    /* Now rendering the last slice */
    if (line->us_last > 0) {
            ShortSlice16(line, &drawInfo, LAST);
    }
    return;
}

//---------------------------------------------------------------------------
static void
Sector25
(
    RP_SLICE_DESC FAR* line,         /* output slice form of line */
    LPBITMAP lpbm
)

// PURPOSE                      input RP_SLICE_DESC is prepared by RP_SliceLine
//                              prepare drawinfo and call ShortSlice25()
//                              to draw the line located in sector 2/5
//                              1 < dx/dy < 2
//
//
// ASSUMPTIONS & ASSERTIONS     None.
//
// INTERNAL STRUCTURES          RP_SLICE_DESC is defined in hretype.h
//                              drawInfoStructType is defined in rplnee.h
//
// UNRESOLVED ISSUES            programmer development notes
//---------------------------------------------------------------------------
{
uint16 func;
uint16 bitShift;
drawInfoStructType drawInfo;

    drawInfo.bytePosition = (uint16 FAR *)((UINT_PTR)lpbm->bmBits +
                             line->us_y1 * lpbm->bmWidthBytes);
    drawInfo.bytePosition += line->us_x1 >> 4;
    func = (line->s_dx_draw << 3) + (line->s_dy_draw << 2) +
           (line->s_dx_skip << 1) + line->s_dy_skip + 2;
    if (func == SECTOR2)
        drawInfo.nextY = -1 * lpbm->bmWidthBytes; /* sector 2 */
    else
        drawInfo.nextY = lpbm->bmWidthBytes;  /* sector 5 */
    bitShift = line->us_x1 & 0x000F;
    drawInfo.bitPosition = 0x8000 >> bitShift;
    /* Now rendering the first slice */
    if (line->us_first > 0) {
            ShortSlice25(line, &drawInfo, FIRST);
    }
    /* Rendering intermediate slices */
    if (line->us_n_slices > 0) {
            ShortSlice25(line, &drawInfo, (uint16)0);
    }
    /* Now rendering the last slice */
    if (line->us_last > 0) {
            ShortSlice25(line, &drawInfo, LAST);
    }
    return;
}

//---------------------------------------------------------------------------
static void
Sector34
(
    RP_SLICE_DESC FAR* line,         /* output slice form of line */
    LPBITMAP lpbm
)

// PURPOSE                      input RP_SLICE_DESC is prepared by RP_SliceLine
//                              prepare drawinfo and call DisplaySlice34()
//                              to draw the line located in sector 3/4
//                              dx/dy > 2
//
//
// ASSUMPTIONS & ASSERTIONS     None.
//
// INTERNAL STRUCTURES          RP_SLICE_DESC is defined in hretype.h
//                              drawInfoStructType is defined in rplnee.h
//
// UNRESOLVED ISSUES            programmer development notes
//---------------------------------------------------------------------------
{
uint16 func;
uint16 bitShift;
drawInfoStructType drawInfo;

    drawInfo.bytePosition = (uint16 FAR *)((UINT_PTR)lpbm->bmBits +
                             line->us_y1 * lpbm->bmWidthBytes);
    drawInfo.bytePosition += line->us_x1 >> 4;
    func = (line->s_dx_draw << 3) + (line->s_dy_draw << 2) +
           (line->s_dx_skip << 1) + line->s_dy_skip + 2;
    if (func == SECTOR3)
        drawInfo.nextY = -1 * lpbm->bmWidthBytes; /* sector 3 */
    else
        drawInfo.nextY = lpbm->bmWidthBytes;  /* sector 4 */
    bitShift = line->us_x1 & 0x000F;
    drawInfo.bitPosition = bitShift;
    /* Now rendering the first slice */
    if (line->us_first > 0) {
        DisplaySlice34(line, &drawInfo, FIRST);
    }
    /* Rendering intermediate slices */
    if (line->us_n_slices > 0) {
        DisplaySlice34(line, &drawInfo, 0);
    }
    /* Now rendering the last slice */
    if (line->us_last > 0) {
        DisplaySlice34(line, &drawInfo, LAST);
    }
    return;
}

//---------------------------------------------------------------------------
static void
ShortSlice07
(
    RP_SLICE_DESC          FAR* line,           /* output slice form of line */
    drawInfoStructType FAR *drawInfo,       // position to put pixel on it
    uint16                 firstOrLast      // is this first/last slice?
)
// PURPOSE                      drawing the line located in sector 0/7
//                              dy/dx > 2
//
//
// ASSUMPTIONS & ASSERTIONS     None.
//
// INTERNAL STRUCTURES          RP_SLICE_DESC is defined in hretype.h
//                              drawInfoStructType is defined in rplnee.h
//
// UNRESOLVED ISSUES            programmer development notes
//---------------------------------------------------------------------------
{
uint16 loop1st, loop2nd, loop3rd;
int32  ddaValue, ddaDiff;
uint16 i, j;

    if (firstOrLast) {
        if (firstOrLast == FIRST)
            loop1st = line->us_first;
        else
            loop1st = line->us_last;
        loop2nd = 1;
        loop3rd = 0;
        ddaValue = -1;
        ddaDiff = 0;
    } else {
        loop1st = line->us_small;
        loop2nd = line->us_n_slices & 0x03;
        loop3rd = line->us_n_slices >> 2;
        ddaValue = line->s_dis - line->s_dis_sm;
        ddaDiff = line->s_dis_lg - line->s_dis_sm;
    }
    for (i = 0; i <= loop3rd; i++) {
        while(loop2nd--) {
            if (firstOrLast)
                ddaValue += 0;
            else
                ddaValue += line->s_dis_sm;
            if (ddaValue >= 0) {
                ddaValue  += ddaDiff;
                *drawInfo->bytePosition |=
                (drawInfo->bitPosition >> 8) | (drawInfo->bitPosition << 8);
                drawInfo->bytePosition +=  drawInfo->nextY >> 1;
            }
            for (j = 0; j < loop1st; j++) {
                *drawInfo->bytePosition |=
                (drawInfo->bitPosition >> 8) | (drawInfo->bitPosition << 8);
                drawInfo->bytePosition +=  drawInfo->nextY >> 1;
            }
            if ((drawInfo->bitPosition >>= 1) == 0) {
                drawInfo->bytePosition++;
                drawInfo->bitPosition = 0x8000;
            }
        }
        loop2nd = 4;
    }
    return;
}


//---------------------------------------------------------------------------
static void
ShortSlice16
(
    RP_SLICE_DESC          FAR* line,           /* output slice form of line */
    drawInfoStructType FAR *drawInfo,       // position to put pixel on it
    uint16                 firstOrLast      // is this first/last slice?
)
// PURPOSE                      drawing the line located in sector 1/6
//                              2> dy/dx > 1
//
//
// ASSUMPTIONS & ASSERTIONS     None.
//
// INTERNAL STRUCTURES          RP_SLICE_DESC is defined in hretype.h
//                              drawInfoStructType is defined in rplnee.h
//
// UNRESOLVED ISSUES            programmer development notes
//---------------------------------------------------------------------------
{
uint16 loop1st, loop2nd, loop3rd;
int32  ddaValue, ddaDiff;
uint16  i, j;

    if (firstOrLast) {
        if (firstOrLast == FIRST)
            loop1st = line->us_first;
        else
            loop1st = line->us_last;
        loop2nd = 1;
        loop3rd = 0;
        ddaValue = -1;
        ddaDiff = 0;
    } else {
        loop1st = line->us_small;
        loop2nd = line->us_n_slices & 0x03;
        loop3rd = line->us_n_slices >> 2;
        ddaValue = line->s_dis - line->s_dis_sm;
        ddaDiff = line->s_dis_lg - line->s_dis_sm;
    }
    for (i = 0; i <= loop3rd; i++) {
        while(loop2nd--) {
            if (firstOrLast)
                ddaValue += 0;
            else
                ddaValue += line->s_dis_sm;
            if (ddaValue >= 0) {
                ddaValue  += ddaDiff;
                *drawInfo->bytePosition |=
                (drawInfo->bitPosition >> 8) | (drawInfo->bitPosition << 8);
                drawInfo->bytePosition += drawInfo->nextY >> 1;
                if ((drawInfo->bitPosition >>= 1) == 0) {
                    drawInfo->bytePosition++;
                    drawInfo->bitPosition = 0x8000;
                }
            }
            for (j = 0; j < loop1st; j++) {
                *drawInfo->bytePosition |=
                (drawInfo->bitPosition >> 8) | (drawInfo->bitPosition << 8);
                drawInfo->bytePosition += drawInfo->nextY >> 1;
                if ((drawInfo->bitPosition >>= 1) == 0) {
                    drawInfo->bytePosition++;
                    drawInfo->bitPosition = 0x8000;
                }
            }
            /* Adjust skip direction by backword 1 bit */
            if ((drawInfo->bitPosition <<= 1) == 0) {
                drawInfo->bytePosition--;
                drawInfo->bitPosition = 0x0001;
            }
        }
        loop2nd = 4;
    }
    return;
}


//---------------------------------------------------------------------------
static void
ShortSlice25
(
    RP_SLICE_DESC          FAR* line,           /* output slice form of line */
    drawInfoStructType FAR *drawInfo,       // position to put pixel on it
    uint16                 firstOrLast      // is this first/last slice?
)
// PURPOSE                      drawing the line located in sector 2/5
//                              2> dx/dy > 1
//
//
// ASSUMPTIONS & ASSERTIONS     None.
//
// INTERNAL STRUCTURES          RP_SLICE_DESC is defined in hretype.h
//                              drawInfoStructType is defined in rplnee.h
//
// UNRESOLVED ISSUES            programmer development notes
//---------------------------------------------------------------------------
{
uint16 loop1st, loop2nd, loop3rd;
int32  ddaValue, ddaDiff;
uint16 i, j;

    if (firstOrLast) {
        if (firstOrLast == FIRST)
            loop1st = line->us_first;
        else
            loop1st = line->us_last;
        loop2nd = 1;
        loop3rd = 0;
        ddaValue = -1;
        ddaDiff = 0;
    } else {
        loop1st = line->us_small;
        loop2nd = line->us_n_slices & 0x03;
        loop3rd = line->us_n_slices >> 2;
        ddaValue = line->s_dis - line->s_dis_sm;
        ddaDiff = line->s_dis_lg - line->s_dis_sm;
    }
    for (i = 0; i <= loop3rd; i++) {
        while(loop2nd--) {
            if (firstOrLast)
                ddaValue += 0;
            else
                ddaValue += line->s_dis_sm;
            if (ddaValue >= 0) {
                ddaValue  += ddaDiff;
                *drawInfo->bytePosition |=
                (drawInfo->bitPosition >> 8) | (drawInfo->bitPosition << 8);
                drawInfo->bytePosition += drawInfo->nextY >> 1;
                if ((drawInfo->bitPosition >>= 1) == 0) {
                    drawInfo->bytePosition++;
                    drawInfo->bitPosition = 0x8000;
                }
            }
            for (j = 0; j < loop1st; j++) {
                *drawInfo->bytePosition |=
                (drawInfo->bitPosition >> 8) | (drawInfo->bitPosition << 8);
                drawInfo->bytePosition += drawInfo->nextY >> 1;
                if ((drawInfo->bitPosition >>= 1) == 0) {
                    drawInfo->bytePosition++;
                    drawInfo->bitPosition = 0x8000;
                }
            }
            /* Adjust skip direction by backword 1 column */
            drawInfo->bytePosition -= drawInfo->nextY >> 1;
        }
        loop2nd = 4;
    }
    return;
}

//---------------------------------------------------------------------------
static void
DisplaySlice34
(
    RP_SLICE_DESC          FAR* line,           /* output slice form of line */
    drawInfoStructType FAR *drawInfo,       // position to put pixel on it
    uint16                 firstOrLast      // is this first/last slice?
)
// PURPOSE                      drawing the line located in sector 3/4
//                              dx/dy > 2
//
//
// ASSUMPTIONS & ASSERTIONS     None.
//
// INTERNAL STRUCTURES          RP_SLICE_DESC is defined in hretype.h
//                              drawInfoStructType is defined in rplnee.h
//
// UNRESOLVED ISSUES            programmer development notes
//---------------------------------------------------------------------------
{
uint16 nSlice, sliceLength;
uint16 wordNumber, lShiftInLastWord;
int32  ddaValue, ddaDiff;
uint16  i;
uint16 tmp;

    if (firstOrLast) {
        nSlice = 1;
        ddaValue = -1;
        ddaDiff = 0;
    } else {
        nSlice = line->us_n_slices;
        ddaValue = line->s_dis - line->s_dis_sm;
        ddaDiff = (line->s_dis_lg - line->s_dis_sm);
    }
    while (nSlice--) {
        if (!firstOrLast) {
            sliceLength = line->us_small;
            ddaValue += line->s_dis_sm;
        } else if (firstOrLast == FIRST) {
            sliceLength = line->us_first;
            ddaValue += 0;
        } else {
            sliceLength = line->us_last;
            ddaValue += 0;
        }
        if (ddaValue >= 0) {
            ddaValue  += ddaDiff;
            sliceLength += 1;
        }
        wordNumber = (drawInfo->bitPosition + sliceLength) >> 4;
        lShiftInLastWord = 16 -
                         ((drawInfo->bitPosition + sliceLength) & 0x0F);
        if (!wordNumber) { /* slice < 16 bits */
            /*
            *drawInfo->bytePosition |=
                ((uint16)ALLONE >> drawInfo->bitPosition) << lShiftInLastWord;
             */
            tmp = (uint16)ALLONE >> (16 - sliceLength);
            tmp <<= lShiftInLastWord;
            *drawInfo->bytePosition |= (tmp >> 8) | (tmp << 8);
        } else {
            tmp = (uint16)ALLONE >> drawInfo->bitPosition;
            *drawInfo->bytePosition++ |= (tmp >> 8) | (tmp << 8);
            for (i = 1; i < wordNumber; i++) {
                *drawInfo->bytePosition++ = (uint16)ALLONE;
            }
            if (lShiftInLastWord != 16) {
                tmp =  (uint16)ALLONE << lShiftInLastWord;
                *drawInfo->bytePosition |= (tmp >> 8) | (tmp << 8);
            }

        }
        /* Adjust skip direction by backword 1 column */
        drawInfo->bytePosition += drawInfo->nextY >> 1;
        drawInfo->bitPosition += sliceLength;
        wordNumber = drawInfo->bitPosition >> 4;
        if (wordNumber) {
            drawInfo->bitPosition &= 0x0F;
        }
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\viewrend\rbaview.cpp ===
/*==============================================================================
This module provides RBA rendering support for viewing faxes.

03-Mar-94   RajeevD    Created.
==============================================================================*/
#ifdef VIEWRBA

#include <memory.h>
#include "viewrend.hpp"
#include "resexec.h"


#define COMMON_SIZE 6

//==============================================================================
RBAVIEW::RBAVIEW (DWORD nType)
{
	_fmemset ((LPBYTE) this + sizeof(LPVOID), 0, sizeof(RBAVIEW) - sizeof(LPVOID));
	nTypeOut = nType;
}

//==============================================================================
RBAVIEW::~RBAVIEW ()
{
	if (hHRE)
		uiHREClose (hHRE);
		
	for (UINT iRes = 0; iRes < 256; iRes++)
		if (ResDir[iRes])
			GlobalFreePtr (ResDir[iRes]);

	if (lpCodec)
		GlobalFreePtr (lpCodec);

	if (bufIn.lpbBegBuf)
		GlobalFreePtr (bufIn.lpbBegBuf);
}
		
//==============================================================================
BOOL RBAVIEW::Init (LPVOID lpFilePath, LPVIEWINFO lpvi, LPWORD lpwBandSize)
{
	ENDJOB EndJob;
	
	if (!Open (lpFilePath, 0))
		return_error (("VIEWREND could not reopen spool file!\r\n"));

	if (!Read((LPBYTE) &BegJob, sizeof(BegJob)))
		return_error (("VIEWREND could not read spool header!\r\n"));

	dwOffset[0] = Tell();

	DEBUGCHK (lpwBandSize);
	*lpwBandSize = (WORD) BegJob.xBand/8 * (WORD) BegJob.yBand + OUTBUF_SLACK;

  if (BegJob.cResDir)
  {
		hHRE = hHREOpen (NULL, (UINT) BegJob.xBand/8, (UINT) BegJob.cResDir);
		if (!hHRE)
			return_error (("VIEWREND could not initialize resource executor!\r\n"));
	}
	
	if (1)
	{
		FC_PARAM fcp;
		UINT cbCodec;
		
		// Query for codec size.
		fcp.nTypeIn  = MMR_DATA;
		fcp.nTypeOut = LRAW_DATA;
		fcp.cbLine   = (UINT) BegJob.xBand / 8;
		cbCodec = FaxCodecInit (NULL, &fcp);
		DEBUGCHK (cbCodec);

    // Allocate codec context.
		lpCodec = GlobalAllocPtr (0, cbCodec);
		if (!lpCodec)
			return_error (("VIEWREND could allocate codec context!\r\n"));
		FaxCodecInit (lpCodec, &fcp);

		bufIn.wLengthBuf = 2000;
		bufIn.lpbBegBuf  = (LPBYTE) GlobalAllocPtr (0, bufIn.wLengthBuf);
		if (!bufIn.lpbBegBuf)
			return_error (("VIEWREND could not allocate input buffer!\r\n"));
	}

	// Fill VIEWINFO.
	lpvi->xRes = BegJob.xRes;
	lpvi->yRes = BegJob.yRes;

	if
	(    Seek (- (long) sizeof(ENDJOB), SEEK_END)
		&& Read (&EndJob, sizeof(ENDJOB))
		&& EndJob.dwID == ID_ENDJOB
	)
	{
		lpvi->cPage = EndJob.cPage;
		lpvi->yMax  = EndJob.yMax;
	}
	else
	{
		lpvi->cPage = 0;
		while (SetPage (lpvi->cPage))
			lpvi->cPage++;
		lpvi->yMax = 0;
	}
			 
	return SetPage (0);
}

//==============================================================================
BOOL RBAVIEW::SetPage (UINT iPage)
{
	if (iPage < iMaxPage)
	{
		Seek (dwOffset[iPage], STREAM_SEEK_SET); // BKD: changed to STREAM_SEEK_SET
		return TRUE;
	}

  Seek (dwOffset[iMaxPage], STREAM_SEEK_SET); // BKD: changed to STREAM_SEEK_SET

	while (1)
	{
		RESHDR Header;
		FRAME Frame;
		
		if (!Read ((LPBYTE) &Header, sizeof(Header)))
			return_error (("VIEWREND could not read RBA resource header!"));

		switch (Header.wClass)
		{
			case ID_GLYPH:			
			case ID_BRUSH:
			{
				UINT cbRaw;

				// Allocate mmeory from cache.
				Frame.lpData = (LPBYTE) GlobalAllocPtr (0, Header.cbRest);
				if (!Frame.lpData)
					return_error (("VIEWREND could not allocate memory!\r\n"));

				// Read resource from stream.
				if (!Read (Frame.lpData + COMMON_SIZE, Header.cbRest - COMMON_SIZE))
					return_error (("VIEWREND could not read resource!\r\n"));

				// Trap chaingon compressed glyph sets.
				cbRaw = HIWORD (Header.dwID);
				if (cbRaw)
				{
					LPVOID lpRaw;
					
					DEBUGCHK (Header.wClass == ID_GLYPH);
					if (!(lpRaw = GlobalAllocPtr (0, cbRaw)))
						return_error (("VIEWREND could not allocate decompression buffer!\r\n"));
					UnpackGlyphSet (Frame.lpData, lpRaw);
					GlobalFreePtr (Frame.lpData);

					Header.cbRest = (USHORT)cbRaw;
					Header.dwID   = LOWORD (Header.dwID);

					Frame.lpData = (LPBYTE) lpRaw;
				}

				// Past common header.
				_fmemcpy (Frame.lpData, &Header.dwID, COMMON_SIZE);
				Frame.wSize = Header.cbRest;

        // Add resource to directory.
				uiHREWrite (hHRE, &Frame, 1);
			  ResDir[Header.dwID] = Frame.lpData;
			  break;
			}
			  
			case ID_CONTROL:
			
				if (Header.dwID == ID_ENDPAGE)
				{
					iMaxPage++;
					dwOffset [iMaxPage] = Tell ();
					if (iPage < iMaxPage)
					{
					    // BKD: changed to STREAM_SEEK_SET
						Seek (dwOffset[iPage], STREAM_SEEK_SET); 
						return TRUE;
					}
				}

      // Yes, fall through to default case!
      
			default:

				// Skip everything else.
				if (!Seek (Header.cbRest - COMMON_SIZE, SEEK_CUR))
					return_error (("VIEWREND could not skip unknown RBA resource"));

		} // switch (Header.wClass)

	} // while (1)

}
	
//==============================================================================
BOOL RBAVIEW::GetBand (LPBITMAP lpbmBand)
{
	DEBUGCHK (lpbmBand && lpbmBand->bmBits);
	
	lpbmBand->bmType = 0;
	lpbmBand->bmWidth = (WORD) BegJob.xBand;
	lpbmBand->bmWidthBytes = lpbmBand->bmWidth / 8;
	lpbmBand->bmPlanes = 1;
	lpbmBand->bmBitsPixel = 1;

	while (1)
	{
		RESHDR Header;

		if (!Read ((LPBYTE) &Header, sizeof(Header)))
			return FALSE;

  	switch (Header.wClass)
  	{
  		case ID_RPL:
  			return ExecuteRPL  (lpbmBand, &Header);

  		case ID_BAND:
  		  return ExecuteBand (lpbmBand, &Header);
	  
  		case ID_CONTROL:

				// Trap page breaks.
  			if (Header.dwID == ID_ENDPAGE)
  			{
					Seek (-8, SEEK_CUR);
					lpbmBand->bmHeight = 0;
					return TRUE;
  			}

  			// Yes, fall through to default case!

  		default:

  			// Skip everything else.
				if (!Seek (Header.cbRest - COMMON_SIZE, SEEK_CUR))
					return FALSE;
  	} // switch (Header.wClass)
		
	} // while (1)
	
}

//==============================================================================
BOOL RBAVIEW::ExecuteRPL (LPBITMAP lpbmBand, LPRESHDR lpHeader)
{
 	FRAME Frame;

  // Clear band.
	lpbmBand->bmHeight = (WORD) BegJob.yBand;
	_fmemset (lpbmBand->bmBits, 0, lpbmBand->bmHeight * lpbmBand->bmWidthBytes);

  // Trap blank bands.
	if (lpHeader->cbRest == COMMON_SIZE)
		return TRUE;

  // Allocate RPL.
	Frame.lpData = (LPBYTE) GlobalAllocPtr (0, lpHeader->cbRest);
	if (!Frame.lpData)
		return_error (("VIEWREND could not allocate RPL!\r\n"));

  // Load RPL.
	Frame.wSize = lpHeader->cbRest;
	_fmemcpy (Frame.lpData, &lpHeader->dwID, COMMON_SIZE);
	Read (Frame.lpData + COMMON_SIZE, Frame.wSize - COMMON_SIZE);

  // Execute RPL.
	uiHREWrite (hHRE, &Frame, 1);
	uiHREExecute (hHRE, lpbmBand, NULL);

	// Free RPL.
	GlobalFreePtr (Frame.lpData);
	return TRUE;
}

//==============================================================================
BOOL RBAVIEW::ExecuteBand (LPBITMAP lpbmBand, LPRESHDR lpHeader)
{
	BMPHDR bmh;
	UINT cbIn;
	FC_PARAM fcp;
	BUFFER bufOut;

	// Read bitmap header.
	if (!Read ((LPBYTE) &bmh, sizeof(bmh)))
		return FALSE;
	lpbmBand->bmHeight = bmh.wHeight;
	cbIn = lpHeader->cbRest - COMMON_SIZE - sizeof(bmh);
	
  // Trap uncompressed bands.
	if (!bmh.bComp)
	{
		if (!Read (lpbmBand->bmBits, cbIn))
			return FALSE;
		if (nTypeOut == LRAW_DATA)
		{
			BUFFER bufOut;
			bufOut.lpbBegData  = (LPBYTE) lpbmBand->bmBits;
			bufOut.wLengthData = (USHORT)cbIn;
			bufOut.dwMetaData  = HRAW_DATA;
			BitReverseBuf (&bufOut);
		}

		return TRUE;
	}
		
	// Initialize codec.
	fcp.nTypeIn  = bmh.bComp >> 2;
	fcp.nTypeOut = LRAW_DATA;
	fcp.cbLine   = (WORD) BegJob.xBand / 8;
	FaxCodecInit (lpCodec, &fcp);

	// Initialize input.
	bufIn.dwMetaData = fcp.nTypeIn;

	// Initialize output.
	bufOut.lpbBegBuf   = (LPBYTE) lpbmBand->bmBits;
	bufOut.wLengthBuf  = fcp.cbLine * bmh.wHeight;
	bufOut.lpbBegData  = bufOut.lpbBegBuf;
	bufOut.wLengthData = 0;
	bufOut.dwMetaData  = fcp.nTypeOut;

  // Convert.
	while (cbIn)
	{
		bufIn.lpbBegData = bufIn.lpbBegBuf;
		bufIn.wLengthData = min (cbIn, bufIn.wLengthBuf);
				
		if (!Read (bufIn.lpbBegData, bufIn.wLengthData))
			return FALSE;
		cbIn -= bufIn.wLengthData;

	 	if (FaxCodecConvert (lpCodec, &bufIn, &bufOut) == FC_DECODE_ERR)
	 		return_error (("VIEWREND MMR decode error!\r\n"));
	
	} // while (cbIn)

	if (nTypeOut == HRAW_DATA)
		BitReverseBuf (&bufOut);

	return TRUE;
}

#endif // VIEWRBA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\stllnent.c ===
// Copyright (c) 1992-1993 Microsoft Corporation

/*============================================================================
This code module implements styled lines in the NT format.

05/29/81  v-BertD    Initial code (used in RP_LineEE_Draw)
02/20/92  RodneyK    Converted to Styled line code.
02/21/92  RodneyK    Each bit in the Mask is used for two pixels.
03/20/92  RodneyK    Converted to NT style format.
06/01/93  RajeevD    Collapsed ROP handling from StyleLine* to Draw*.
                     (Reduces code size by 8K with no loss in speed.)
============================================================================*/
#include <windows.h>
#include "constant.h"
#include "frame.h"      // driver header file, resource block format
#include "jtypes.h"         /* Jumbo type definitions.                */
#include "jres.h"       // cartridge resource data type definition
#include "hretype.h"          /* Slice Descriptor defs.                 */

// Table data for the predefined pen styles
ULONG ulWinStyles[] =
{
   0x00000002, 0x00ffffff, 0x00000000, /* solid */
   0x00000002, 0x00000028, 0x00000010, /* dash  */ /* 28 */
   0x00000002, 0x00000008, 0x00000008, /* dot   */
   0x00000004, 0x0000001c, 0x0000000f, 0x00000008, 0x0000000f, /* dash dot */
   0x00000006, 0x0000001c, 0x0000000f, 0x00000008, 0x00000008,0x00000008, 0x0000000f,
   0x00000002, 0x00000000, 0x00ffffff, /* NULL  */
   0x00000002, 0x00ffffff, 0x00000000  /* Inside border */
};

const BYTE ulStyleLookUp[7] =
	{ 0x00, 0x03, 0x06, 0x09, 0x0e, 0x15, 0x18};

const USHORT usStyleSize[7] =
	{0x0000, 0x0038, 0x0010, 0x0042, 0x0052, 0x0000, 0x0000 };

typedef void (*ROPPROC)(LPBYTE, WORD, BYTE);

//==============================================================================
void DrawANDDNR (LPBYTE lpbFrame, WORD wColor, BYTE bPos)
{
	if (~(*lpbFrame & wColor) & bPos)
		*lpbFrame |=  bPos;
	else
		*lpbFrame &= ~bPos;
}

//==============================================================================
void DrawANDDR (LPBYTE lpbFrame, WORD wColor, BYTE bPos)
{
	*lpbFrame &= ~bPos;
}

//==============================================================================
void DrawANDNDR (LPBYTE lpbFrame, WORD wColor, BYTE bPos)
{
	if (((~*lpbFrame) & wColor) & bPos)
		*lpbFrame |=  bPos;
	else
		*lpbFrame &= ~bPos;
}

//==============================================================================
void DrawCOPY0 (LPBYTE lpbFrame, WORD wColor, BYTE bPos)
{
	*lpbFrame &= ~bPos;
}

//==============================================================================
void DrawCOPY1 (LPBYTE lpbFrame, WORD wColor, BYTE bPos)
{
  *lpbFrame |= bPos;
}

//==============================================================================
void DrawORDNR (LPBYTE lpbFrame, WORD wColor, BYTE bPos)
{
	if ((~(*lpbFrame | wColor)) & bPos)
  	*lpbFrame |=  bPos;
	else 
  	*lpbFrame &= ~bPos;
}

//==============================================================================
void DrawORDR (LPBYTE lpbFrame, WORD wColor, BYTE bPos)
{
	*lpbFrame |= bPos;
}

//==============================================================================
void DrawORNDR (LPBYTE lpbFrame, WORD wColor, BYTE bPos)
{
	if (((~*lpbFrame) | wColor) & bPos)
  	*lpbFrame |=  bPos;
  else
  	*lpbFrame &= ~bPos;
}

//==============================================================================
void DrawXOR (LPBYTE lpbFrame, WORD wColor, BYTE bPos)
{
	if ((~*lpbFrame) & bPos)
		*lpbFrame |=  bPos;
	else
  	*lpbFrame &= ~bPos;
}

//==============================================================================
void StyleLine
(
	LPRESTATE lpREState,         // resource executor context
	RP_SLICE_DESC FAR*psdSlice,     /* Line Slice descriptor */
	ULONG *pulStyle,             /* Line style pointer    */
	WORD wColor,
	ROPPROC RopProc
)
/*==============================================================================
 PURPOSE               This function handle the OR Raster operations for
                       the styled line code.  It draws a line based on the
                       Slice descriptor, current color, current ROP, and
                       the current linestyle.

                       The function runs through the slice and determine
                       whether a point is to drawn or not.  The raster
                       operation is applied only the points which need to
                       be drawn.

ASSUMPTIONS &          This code assumes that the slice descriptor and the
ASSERTIONS             pointer to the style table are valid and correct.
                       No checks are performed to validate this data.
==============================================================================*/
{
   LPBITMAP lpbm;
   register UBYTE FAR *pbFrame;                       /* frame pointer               */
   SLONG lSlice_x, lSlice_y;            /* Slice Run variables         */
   SLONG lSkip_x, lSkip_y;              /* Slice skip variables        */
   register UBYTE usfPos;                        /* Bit in frame to modify      */
   register SHORT i;                             /* Slice variable              */
   ULONG *pulStyleTmp;                  /* Pointer to style data       */
   register ULONG ulDrawCount;                   /* Number of pixels to draw on */
   ULONG ulStyleCount;                  /* Count of data in line style */
   register BYTE bDraw;                         /* To draw or Not to draw      */

   pulStyleTmp = pulStyle + 1;          /* Point to style data         */
   ulDrawCount = *pulStyleTmp++;        /* Get the first count         */
   ulStyleCount = *(pulStyle) - 1;      /* Pattern longs remaining     */
   bDraw = 0xFF;                        /* Start by drawing            */

   for ( i = 0 ; i < (SHORT)lpREState->usPenPhase; i++)
   {
      if(!ulDrawCount)                  /* Flip draw mask */
      {
         bDraw = (BYTE)~bDraw;
         if (!ulStyleCount--)           /* recycle the pattern? */
         {
            ulStyleCount = *(pulStyle) - 1;
            pulStyleTmp = pulStyle + 1;
         }
         ulDrawCount = *pulStyleTmp++;  /* Get next style count */
      }
      ulDrawCount--;
   }

   lpbm = lpREState->lpBandBuffer;
   pbFrame = (UBYTE FAR*) lpbm->bmBits;
   pbFrame += psdSlice->us_y1 * lpbm->bmWidthBytes;
   pbFrame += psdSlice->us_x1 >> 3;
   usfPos = (UBYTE)(0x80 >> (psdSlice->us_x1 & 0x7));     /* Calculate the bit mask */

   lSlice_x = psdSlice->s_dx_draw;
   lSlice_y = psdSlice->s_dy_draw * lpbm->bmWidthBytes;
   lSkip_x = psdSlice->s_dx_skip;
   lSkip_y = psdSlice->s_dy_skip * lpbm->bmWidthBytes;

   // Do the first slice...

   if (psdSlice->us_first)
   {
      for ( i = psdSlice->us_first ; i > 0 ; --i )
      {
         if(!ulDrawCount)                  /* Flip draw mask */
         {
            bDraw = (BYTE)~bDraw;
            if (!ulStyleCount--)           /* recycle the pattern? */
            {
               ulStyleCount = *(pulStyle) - 1;
               pulStyleTmp = pulStyle + 1;
            }
            ulDrawCount = *pulStyleTmp++;  /* Get next style count */
         }
         ulDrawCount--;

         if (bDraw)
					(*RopProc)(pbFrame, wColor, usfPos);

         if (lSlice_x < 0)
         {
            usfPos <<= 1;
            if ( usfPos == 0 )                 /* Check mask underflow and adjust */
            {
               usfPos = 0x01;                /* Reset the bit mask */
               pbFrame -= 1;                  /* move to next UBYTE */
            }
         }
         else
         {
            usfPos >>= lSlice_x;
            if ( usfPos == 0 )                 /* Check mask underflow and adjust */
            {
               usfPos = 0x80;                /* Reset the bit mask */
               pbFrame += 1;                  /* move to next UBYTE */
            }
         }
         pbFrame += lSlice_y;              /* advance to next row */
      }

      if ( lSkip_x < 0 )                   /* going to the left? */
      {
         usfPos <<= 1;                      /* shift the mask */
         if ( usfPos == 0 )                 /* Check for over/under flow */
         {
            usfPos = 0x01;                /* Reset Mask */
            pbFrame -= 1;                  /* point to the next UBYTE */
         }
      }
      else                                 /* moving to the right */
      {
         usfPos >>= lSkip_x;
         if ( usfPos == 0 )
         {
            usfPos = 0x80;
            pbFrame += 1;
         }
      }
      pbFrame += lSkip_y;
   }

   // Do the intermediate slices...
   
   for ( ; psdSlice->us_n_slices > 0 ; --psdSlice->us_n_slices )
   {
      if ( psdSlice->s_dis < 0 )
      {
         i = psdSlice->us_small;
         psdSlice->s_dis += psdSlice->s_dis_sm;
      }
      else
      {
         i = psdSlice->us_small + 1;
         psdSlice->s_dis += psdSlice->s_dis_lg;
      }

      for ( ; i > 0 ; --i )
      {
         if(!ulDrawCount)               /* Is it time to flip the draw state */
         {
            bDraw = (BYTE)~bDraw;             /* Yes, Change it   */
            if (!ulStyleCount--)        /* Recycle pattern? */
            {
               ulStyleCount = *(pulStyle) - 1;
               pulStyleTmp = pulStyle + 1;
            }
            ulDrawCount = *pulStyleTmp++;   /* Advance the pattern */
         }
         ulDrawCount--;

         if (bDraw)
					(*RopProc)(pbFrame, wColor, usfPos);
         	
         if (lSlice_x < 0)
         {
            usfPos <<= 1;
            if ( usfPos == 0 )                 /* Check mask underflow and adjust */
            {
               usfPos = 0x01;                /* Reset the bit mask */
               pbFrame -= 1;                  /* move to next UBYTE */
            }
         }
         else
         {
            usfPos >>= lSlice_x;
            if ( usfPos == 0 )                 /* Check mask underflow and adjust */
            {
               usfPos = 0x80;                /* Reset the bit mask */
               pbFrame += 1;                  /* move to next UBYTE */
            }
         }
         pbFrame += lSlice_y;
      }

      if ( lSkip_x < 0 )                /* Check for negative movement */
      {
         usfPos <<= 1;
         if ( usfPos == 0 )
         {
            usfPos = 0x01;
            pbFrame -= 1;
         }
      }
      else
      {
         usfPos >>= lSkip_x;             /* Do positive case */
         if ( usfPos == 0 )
         {
            usfPos = 0x80;
            pbFrame += 1;
         }
      }
      pbFrame += lSkip_y;
   }

   // Do the last slice...

   for ( i = psdSlice->us_last ; i > 0 ; --i )
   {
      if(!ulDrawCount)                  /* Check to see if draw status needs */
      {                                 /* to be changed                     */
         bDraw = (BYTE)~bDraw;
         if (!ulStyleCount--)
         {                              /* update the style pointer */
            ulStyleCount = *(pulStyle) - 1;
            pulStyleTmp = pulStyle + 1;
         }
         ulDrawCount = *pulStyleTmp++;
      }
      ulDrawCount--;                    /* count down the style count */

      if (bDraw)
      	(*RopProc)(pbFrame, wColor, usfPos);

      if (lSlice_x < 0)
      {
         usfPos <<= 1;
         if ( usfPos == 0 )                 /* Check mask underflow and adjust */
         {
            usfPos = 0x01;                /* Reset the bit mask */
            pbFrame -= 1;                  /* move to next UBYTE */
         }
      }
      else
      {
         usfPos >>= lSlice_x;
         if ( usfPos == 0 )                 /* Check mask underflow and adjust */
         {
            usfPos = 0x80;                /* Reset the bit mask */
            pbFrame += 1;                  /* move to next UBYTE */
         }
      }
      pbFrame += lSlice_y;
   }

  // AdjustPhase(psdSlice);
	{
		SHORT    sDx, sDy;
		USHORT   usLength;

		sDx = psdSlice->us_x2 - psdSlice->us_x1;
		sDy = psdSlice->us_y2 - psdSlice->us_y1;
		if (sDx < 0) sDx = -sDx;
		if (sDy < 0) sDy = -sDy;

		usLength = usStyleSize[lpREState->ubPenStyle];
		if (usLength != 0)
		{
		  if (sDx < sDy)
		     lpREState->usPenPhase += (USHORT)sDy + 1;
		  else
		     lpREState->usPenPhase += (USHORT)sDx + 1;
		  lpREState->usPenPhase %= usLength;
		}
  }
}

//==============================================================================
void GetTotalPixels
(
   RP_SLICE_DESC FAR *psdSlice    /* Line Slice descriptor */
)
//
//  PURPOSE               Caculate how many pixel are going to be drawn.
//                        Put the result in us_y2 = us_y1 + Total Pixels
//                        This function is called only in JG_RP_LineSlice
//
// ASSUMPTIONS &          This code assumes that the slice descriptor and the
// ASSERTIONS             pointer to the style table are valid and correct.
//                        No checks are performed to validate this data.
//                        If an unsupported ROP is sent ROP(0) BLACKNESS is
//                        used.
//
// INTERNAL STRUCTURES    No complex internal data structure are used
//
//--------------------------------------------------------------------------*/
{
   USHORT usTotalPixels;
   SHORT  sDis;
   SHORT  i;

   usTotalPixels = psdSlice->us_first + psdSlice->us_last;
   sDis = psdSlice->s_dis;
   for (i = 0; i <  (SHORT)psdSlice->us_n_slices; i++) {
      if ( sDis < 0 )
      {
         usTotalPixels += psdSlice->us_small;
         sDis += psdSlice->s_dis_sm;
      }
      else
      {
         usTotalPixels += psdSlice->us_small + 1;
         sDis += psdSlice->s_dis_lg;
      }
   }
   psdSlice->us_y2 = psdSlice->us_y1 + usTotalPixels - 1;
   return;
}

//==============================================================================
BYTE StyleLineDraw
(
	 LPRESTATE lpREState,        // resource executor context
   RP_SLICE_DESC FAR *psdSlice,    /* Line Slice descriptor */
   UBYTE ubLineStyle, /* Line style pointer    */
   SHORT sRop,
   SHORT usColor
)

/*
//
//  PURPOSE               This function calls the correct function to draw
//                        a single pixel styled line using the correct
//                        ROP, Linestyle, and color (pen).
//
// ASSUMPTIONS &          This code assumes that the slice descriptor and the
// ASSERTIONS             pointer to the style table are valid and correct.
//                        No checks are performed to validate this data.
//                        If an unsupported ROP is sent ROP(0) BLACKNESS is
//                        used.
//
// INTERNAL STRUCTURES    No complex internal data structure are used
//
// UNRESOLVED ISSUES      Banding problems???
//
// RETURNS                0 - use fast line, 1 - don't draw, 2 - style drawn
//
//--------------------------------------------------------------------------*/
{
   BYTE bRetVal;    /* Return value for optimizing certain cases             */
   ULONG *pulStyle; /* Line style pointer    */
   BYTE bSolid;

   if (!ubLineStyle && ((psdSlice->s_dx_draw < 0) || (psdSlice->s_dx_skip <0)))
      {
        // JG_WARNING("Neg X with Solid Line");
        ubLineStyle = 6; /* for style line code to do it */
      }
   if (ubLineStyle == 5)
      bRetVal = 1;
   else
   {
      /* Note style 6 will not be considered solid to simplify things */
      bSolid = (BYTE)(ubLineStyle == 0);
      pulStyle = &ulWinStyles[ulStyleLookUp[ubLineStyle]];
      bRetVal = 2;

      if (usStyleSize[ubLineStyle])
         lpREState->usPenPhase %= usStyleSize[ubLineStyle];

      switch (sRop)
      {
         case  0x00 :                                        /* ROP BLACK */
            if(bSolid) bRetVal = 0;
            else StyleLine (lpREState, psdSlice, pulStyle, 0, DrawCOPY1);
            break;
         case  0x05 :                                             /* DPon */
            StyleLine (lpREState, psdSlice, pulStyle, usColor, DrawORDNR);
            break;
         case  0x0a :                                             /* DPna */
            if(!usColor) bRetVal = 1;
            else StyleLine (lpREState, psdSlice, pulStyle, 0, DrawANDDR);
            break;
         case  0x0f :                                             /* Pn */
            if(bSolid && !usColor)
               bRetVal = 0;
            else
               if (usColor)
               	StyleLine (lpREState, psdSlice, pulStyle, 0, DrawCOPY0);
               else
               	StyleLine (lpREState, psdSlice, pulStyle, 0, DrawCOPY1);
            break;
         case  0x50 :                                             /* PDna */
            StyleLine (lpREState, psdSlice, pulStyle, usColor, DrawANDNDR);
            break;
         case  0x55 :                                            /* Dn */
            usColor   = 0x0000;
            StyleLine (lpREState, psdSlice, pulStyle, usColor, DrawORNDR);
            break;
         case  0x5a :                                           /* DPx */
            if(!usColor) bRetVal = 1;
            else StyleLine (lpREState, psdSlice, pulStyle, 0, DrawXOR);
            break;
         case  0x5f :                                           /* DPan */
            if(bSolid && !usColor) bRetVal = 0;
            else StyleLine (lpREState, psdSlice, pulStyle, usColor, DrawANDDNR);
            break;
         case  0xa0 :                                           /* DPa */
            if(usColor) bRetVal = 1;
            else StyleLine (lpREState, psdSlice, pulStyle, 0, DrawANDDR);
            break;
         case  0xa5 :                                           /* PDxn */
            if(usColor) bRetVal = 1;
            else StyleLine (lpREState, psdSlice, pulStyle, 0, DrawXOR);
            break;
         case  0xaa :                                           /* D */
            bRetVal = 1;
            break;
         case  0xaf :                                           /* DPno */
            if (usColor) bRetVal = 1;
            else if(bSolid) bRetVal = 0;
            else StyleLine (lpREState, psdSlice, pulStyle, 0, DrawORDR);
            break;
         case  0xf0 :                                           /* P */
            if(bSolid && usColor) bRetVal = 0;
            else if (usColor)
            	StyleLine (lpREState, psdSlice, pulStyle, 0, DrawCOPY1);
            else
            	StyleLine (lpREState, psdSlice, pulStyle, 0, DrawCOPY0);
            break;
         case  0xf5 :                                           /* PDno */
            if(bSolid && usColor) bRetVal = 0;
            else StyleLine (lpREState, psdSlice, pulStyle, usColor, DrawORNDR);
            break;
         case  0xfa :                                           /* PDo */
            if (!usColor) bRetVal = 1;
            else if(bSolid) bRetVal = 0;
            else StyleLine (lpREState, psdSlice, pulStyle, 0, DrawORDR);
            break;
         case  0xFF :                                           /* WHITENESS */
            StyleLine (lpREState, psdSlice, pulStyle, 0, DrawCOPY0);
            break;
         default:                                               /* BLACKNESS */
            if(bSolid) bRetVal = 0;
            else StyleLine (lpREState, psdSlice, pulStyle, 0, DrawCOPY1);
      }
   }
   return (bRetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\viewrend\mmrview.cpp ===
/*==============================================================================
This module provides MMR rendering support for viewing faxes.

19-Jan-94   RajeevD    Integrated into IFAX viewer.
==============================================================================*/
#ifdef VIEWMMR

#include <memory.h>
#include "viewrend.hpp"

//==============================================================================
MMRVIEW::MMRVIEW (DWORD nType)
{
	_fmemset ((LPBYTE) this + sizeof(LPVOID), 0, sizeof(MMRVIEW) - sizeof(LPVOID));

	DEBUGCHK (lpSpool == NULL);
	DEBUGCHK (lpCodec == NULL);
	DEBUGCHK (lpbufIn == NULL);
	nTypeOut = nType;
}

//==============================================================================
MMRVIEW::~MMRVIEW ()
{
	if (lpSpool) SpoolReadClose (lpSpool);
	if (lpCodec) GlobalFreePtr (lpCodec);
	if (lpbufIn) SpoolFreeBuf (lpbufIn);
}
		
//==============================================================================
BOOL MMRVIEW::Init (LPVOID lpFilePath, LPVIEWINFO lpvi, LPWORD lpwBandSize)
{
	UINT cbCodec;
	
	if (!this)
		return_error (("VIEWREND could not allocate context!\r\n"));

	// Open spool file.
	lpSpool = SpoolReadOpen (lpFilePath, &sh);
	if (!lpSpool)
		return_error (("VIEWREND could not open spool file!\r\n"));

	// Fill VIEWINFO.
	lpvi->cPage = SpoolReadCountPages (lpSpool);
	lpvi->xRes = sh.xRes;
	lpvi->yRes = sh.yRes;
	lpvi->yMax = 0;

	// Set band size.
	DEBUGCHK (lpwBandSize);
	cbBand = *lpwBandSize;
  if (cbBand < 2 * sh.cbLine)
 	{
		cbBand = 2 * sh.cbLine;
		*lpwBandSize = cbBand;
	}
	
	// Set up codec.
	fcp.nTypeIn  = MMR_DATA;
	fcp.nTypeOut = LRAW_DATA;
	fcp.cbLine = sh.cbLine;
	DEBUGCHK (fcp.nKFactor == 0);

	// Query codec.
	cbCodec = FaxCodecInit (NULL, &fcp);
	if (!cbCodec)
		return_error (("VIEWREND could not init codec!\r\n"));

	// Initialize codec.
	lpCodec = GlobalAllocPtr (0, cbCodec);
	if (!lpCodec)
		return_error (("VIEWREND could not allocate codec!\r\n"));

	return SetPage (0);
}

//==============================================================================
BOOL MMRVIEW::SetPage (UINT iPage)
{
	if (!SpoolReadSetPage (lpSpool, iPage))
		return FALSE;
	fEOP = FALSE;
	if (lpbufIn)
	{
		SpoolFreeBuf (lpbufIn);
		lpbufIn = NULL;
	}
	FaxCodecInit (lpCodec, &fcp);
	return TRUE;
}
	
//==============================================================================
BOOL MMRVIEW::GetBand (LPBITMAP lpbmBand)
{
	DEBUGCHK (lpbmBand && lpbmBand->bmBits);

	// Fill descriptor.
	lpbmBand->bmType = 0;
	lpbmBand->bmWidth = 8 * fcp.cbLine;
	lpbmBand->bmWidthBytes = fcp.cbLine;
	lpbmBand->bmPlanes = 1;
	lpbmBand->bmBitsPixel = 1;

	// Trap end of page.
	if (fEOP)
	{
		lpbmBand->bmHeight = 0;
		return TRUE;
	}
	
	// Set up output buffer.
	bufOut.lpbBegBuf  = (LPBYTE) lpbmBand->bmBits;
	bufOut.wLengthBuf = cbBand;
	bufOut.Reset();
	bufOut.dwMetaData = LRAW_DATA;
	
	while (1)
	{
		// Fetch input buffer?
		if (!lpbufIn)
		{
			if (!(lpbufIn = SpoolReadGetBuf (lpSpool)))
				return_error (("VIEWREND could not fetch input buffer.\r\n"));

			switch (lpbufIn->dwMetaData)
			{
				case END_OF_PAGE:
				case END_OF_JOB:
				  // metabuffers will be freed in SetPage or destructor.
					fEOP = TRUE;
					goto done;
			
				case MMR_DATA:
					break;

				default:
					continue;
			}
		}

		switch (FaxCodecConvert (lpCodec, lpbufIn, &bufOut))
		{
			case FC_DECODE_ERR:	
				return_error (("VIEWREND fatal MMR decode error!\r\n"));

			case FC_INPUT_EMPTY:
				SpoolFreeBuf (lpbufIn);
				lpbufIn = NULL;
				continue;			

			case FC_OUTPUT_FULL:
				goto done;
		}

	} // while (1)

done:

	if (nTypeOut == HRAW_DATA)	
		BitReverseBuf (&bufOut);
	lpbmBand->bmHeight = bufOut.wLengthData / fcp.cbLine;
	return TRUE;
}

#endif // VIEWMMR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\resexec\stllnent.h ===
/*
**  Copyright (c) 1992 Microsoft Corporation
*/

/*============================================================================
// FILE                     STLLNENT.H
//
// MODULE                   Jumbo Cartridge Public Information
//
// PURPOSE                  This file contains the function to draw styled
//
// DESCRIBED IN             This module has not been documented at this time.
//
// EXTERNAL INTERFACES      StyleLineDraw
//
// MNEMONICS                Standard Hungarian
//
// HISTORY
//
// 04/02/92  Rodneyk     WPG Coding Conventions.
//
//==========================================================================*/



BYTE StyleLineDraw
(
	 LPRESTATE lpREState,    // resource executor context
   RP_SLICE_DESC FAR *s,       /* Line Slice descriptor */
   UBYTE ubLineStyle,         /* Line style pointer    */
   SHORT sRop,             /* Current Raster operation number */
   SHORT wColor             /* Pen color to use White = 0, Black = 0xffff */
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\viewrend\viewrend.cpp ===
/*==============================================================================
This module provides MMR rendering support for viewing faxes.

19-Jan-94   RajeevD    Integrated into IFAX viewer.
==============================================================================*/
#include <ifaxos.h>
#include <viewrend.h>
#include <dcxcodec.h>
#include "viewrend.hpp"

#ifdef DEBUG
DBGPARAM dpCurSettings = {"VIEWREND"};
#endif

// file signatures
#define MMR_SIG 0x53465542 // "BUFS"
#define RBA_SIG 0x53505741 // "AWPS"

//==============================================================================
// C Export Wrappers
//==============================================================================

#ifndef WIN32

EXPORT_DLL BOOL WINAPI LibMain
	(HANDLE hInst, WORD wSeg, WORD wHeap, LPSTR lpszCmd)
{ return 1; }

extern "C" {int WINAPI WEP (int nParam);}
#pragma alloc_text(INIT_TEXT,WEP)
int WINAPI WEP (int nParam)
{ return 1; }

#endif

//==============================================================================
LPVOID
WINAPI
ViewerOpen
(
	LPVOID     lpFile,      // IFAX key or Win3.1 path or OLE2 IStream
	DWORD      nType,       // data type: HRAW_DATA or LRAW_DATA
	LPWORD     lpwResoln,   // output pointer to x, y dpi array
	LPWORD     lpwBandSize, // input/output pointer to output band size
	LPVIEWINFO lpViewInfo   // output pointer to VIEWINFO struct
)
{
	GENFILE gf;
	DWORD dwSig;
	LPVIEWREND lpvr;
	VIEWINFO ViewInfo;
	
 	DEBUGMSG (1, ("VIEWREND ViewerOpen entry\r\n"));
 	 
  // Read DWORD signature.
  if (!(gf.Open (lpFile, 0)))
  	return_error (("VIEWREND could not open spool file!\r\n"));

#ifdef VIEWDCX
	if (!gf.Read (&dwSig, sizeof(dwSig)))
  	return_error (("VIEWREND could not read signature!\r\n"));
#else
	dwSig = 0;  	
#endif

	if (dwSig != DCX_SIG)
	{
   	if (!gf.Seek (2, 0) || !gf.Read (&dwSig, sizeof(dwSig)))
  		return_error (("VIEWREND could not read signature!\r\n"));
  }
	
	// Determine file type.
  switch (dwSig)
  {

#ifdef VIEWMMR
  	case MMR_SIG:
  	  lpvr = new MMRVIEW (nType);
 		  break;
#endif

#ifdef VIEWDCX
		case DCX_SIG:
			lpvr = new DCXVIEW (nType);
			break;
#endif		

#ifdef VIEWRBA
 		case RBA_SIG:
	 	case ID_BEGJOB:
			lpvr = new RBAVIEW (nType);
			break;
#endif
			
  	default:
  		return_error (("VIEWREND could not recognize signature!\r\n"));
  }

	if (!lpViewInfo)
		lpViewInfo = &ViewInfo;
	
	// Initialize context.
	if (!lpvr->Init (lpFile, lpViewInfo, lpwBandSize))
		{ delete lpvr; lpvr = NULL;}

	if (lpwResoln)
	{
		lpwResoln[0] = lpViewInfo->xRes;
		lpwResoln[1] = lpViewInfo->yRes;
	}
	
	return lpvr;
}

//==============================================================================
BOOL WINAPI ViewerSetPage (LPVOID lpContext, UINT iPage)
{
	return ((LPVIEWREND) lpContext)->SetPage (iPage);
}

//==============================================================================
BOOL WINAPI ViewerGetBand (LPVOID lpContext, LPBITMAP lpbmBand)
{
	return ((LPVIEWREND) lpContext)->GetBand (lpbmBand);
}

//==============================================================================
BOOL WINAPI ViewerClose (LPVOID lpContext)
{
	delete (LPVIEWREND) lpContext;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\awd\viewrend\viewrend.hpp ===
#ifndef _VIEWHPP_
#define _VIEWHPP_

#include <ifaxos.h>
#include <viewrend.h>
#include <rambo.h>
#include <faxspool.h>
#include <faxcodec.h>
#include "genfile.hpp"

#define return_error(mesg) do {DEBUGMSG (1, mesg); return FALSE;} while(0)

// global memory
#ifdef IFBGPROC
#define GlobalAllocPtr(f,cb) IFMemAlloc(f,cb,NULL)
#define GlobalFreePtr(lp) IFMemFree(lp)
#else
#include <windowsx.h>
#endif

// base viewer context
typedef struct FAR VIEWREND : public GENFILE
{
	virtual BOOL Init (LPVOID, LPVIEWINFO, LPWORD) = 0;
  virtual BOOL SetPage (UINT iPage) = 0;
  virtual BOOL GetBand (LPBITMAP) = 0;
  virtual ~VIEWREND() {}
}
	FAR* LPVIEWREND;

// MMR viewer context
typedef struct FAR MMRVIEW : public VIEWREND
{
	LPVOID lpSpool;
	SPOOL_HEADER sh;
	BOOL fEOP;
	
	LPVOID lpCodec;
	FC_PARAM fcp;
		
	LPBUFFER lpbufIn;
	BUFFER bufOut;
	DWORD nTypeOut;
	WORD  cbBand;

  MMRVIEW (DWORD nTypeOut);
	virtual BOOL Init (LPVOID, LPVIEWINFO, LPWORD);
  virtual BOOL SetPage (UINT iPage);
  virtual BOOL GetBand (LPBITMAP);
  virtual ~MMRVIEW();
}
	FAR *LPMMRVIEW;

#define MAX_PAGE 1024

// RBA viewer context
typedef struct FAR RBAVIEW : public VIEWREND
{
	DWORD    dwOffset[MAX_PAGE];
	BEGJOB   BegJob;
	LPVOID   ResDir[256];
	LPVOID   lpCodec;
	BUFFER   bufIn;
	DWORD    nTypeOut;
	UINT     iMaxPage;
	HANDLE   hHRE;
	
  RBAVIEW (DWORD nTypeOut);
	virtual BOOL Init (LPVOID, LPVIEWINFO, LPWORD);
  virtual BOOL SetPage (UINT iPage);
  virtual BOOL GetBand (LPBITMAP);
  virtual ~RBAVIEW();

  BOOL ExecuteRPL  (LPBITMAP, LPRESHDR);
  BOOL ExecuteBand (LPBITMAP, LPRESHDR);
}
	FAR *LPRBAVIEW;

// DCX viewer context
typedef struct FAR DCXVIEW : public VIEWREND
{
	LPVOID   lpCodec;
	FC_PARAM fcp;
	DWORD    nTypeOut;
	BUFFER   bufIn;
	DWORD    cbPage;
	BOOL     fEndPage;
	WORD     cbBand;
			
  DCXVIEW (DWORD nTypeOut);
	virtual BOOL Init (LPVOID, LPVIEWINFO, LPWORD);
  virtual BOOL SetPage (UINT iPage);
  virtual BOOL GetBand (LPBITMAP);
  virtual ~DCXVIEW();
}
	FAR *LPDCXVIEW;
		
#endif // _VIEWHPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\inc\buffers.h ===
/*==============================================================================
This file includes the BUFFER typedef and standard meta-data values.

23-Feb-93    RajeevD    Moved from ifaxos.h
17-Jul-93    KGallo     Added STORED_BUF_DATA metadata type for buffers containing 
                        the stored info for another buffer.
28-Sep-93    ArulM      Added RES_ ENCODE_ WIDTH_ and LENGTH_ typedefs
==============================================================================*/
#ifndef _INC_BUFFERS
#define _INC_BUFFERS

//----------------------------- BUFFERS -------------------------
/****
	@doc    EXTERNAL        IFAXOS    DATATYPES

	@types  BUFFER  |   The Buffer structure defines the buffer header
			structures which processes manipulate.

	@field  WORD	|   fReadOnly   | Specifies whether the buffer
			is readonly or not. It is the applications responsibility to
			check this flag and not violate it. <f IFBufMakeWritable> should
			be used if a process needs to write on a buffer which is
			marked readonly. This field should not be modified by the
			process itself.

	@field  LPBYTE  |   lpbBegBuf   | A far ptr pointing to the physical
			start of the buffer. This ptr has meaning only in the calling
			process's address space and should not be stored for any
			reason. It should not be modified either.

	@field  WORD    |   wLengthBuf  | Physical length of the buffer. Should
			not be modified by the process. Should be used in conjunction
			with <e BUFFER.lpbBegBuf> to know the physical boundaries of the buffer.

	@field  DWORD    |   dwMetaData   | Indicates the kind of data stored in
			the buffer. See <t STD_DATA_TYPES> for all the possible values
	    of this field.

	@field  LPBYTE  |   lpbBegData  | Far ptr to the start of valid data in the
			buffer. The process is responsible for maintaining the integrity
			of this as it consumes or produces data in the buffer. The ptr should
			not be passed to any other process as it will not be valid. At buffer
			allocation time this field is initialized to point to the physical
			beginning of the buffer.

	@field  LPBYTE  |   lpbCurPtr   | One of the fields of a union containing
	    lpbfNext and dwTemp as its other members.
	    A general purpose far ptr which can be
			used to mark an interesting place in the buffer. Should be used as
			a temporary variable while processing the buffer. Should not be directly
	    passed to any other process. Initialized
			to point to the beginning of the buffer at allocation time.
	    Remember that this is a UNION !!

	@field  LPBUFFER  |   lpbfNext | One of the fields of a union containing
	    lpbCurPtr and dwTemp as its other members. This should be used
	    when a module wants to internally link a list of buffers together.
	    Remember that this is a UNION !!

	@field  DWORD |   dwTemp | One of the fields of a union containing
	    lpbfNext and lpbCurPtr as its other members. This should be used when
	    the module wants to store some random information in the header.
	    Remember that this is a UNION !!

	@field  WORD    |   wLengthData | Gives the length of valid contiguous data
			present in the buffer starting at <e BUFFER.lpbBegData>. The process is
			responsible for maintaining the integrity of this. Initialized to
			zero at allocation time.

	@comm   There are other reserved fields in the structure which have not been
			mentioned here.

	@tagname _BUFFER

	@xref   <f IFBufAlloc>
****/

typedef struct _BUFFER
{       
	// Private portion
	struct _BUFFERDATA  FAR *lpbdBufData;
	struct _BUFFER FAR *lpbfNextBuf;
    WORD    wResFlags;

	// Read Only portion
	WORD	fReadOnly;      // Is the buffer readonly ??
	LPBYTE  lpbBegBuf;      // Physical start of buffer
	WORD    wLengthBuf;     // Length of buffer

	// Read write public portion
	WORD    wLengthData;    // length of valid data
	DWORD   dwMetaData;      // Used to store metadata information
	LPBYTE  lpbBegData;     // Ptr to start of data
	union
	{
		struct _BUFFER FAR*     lpbfNext;       // for linking buffers
		LPBYTE  lpbCurPtr;      // for local current position use
		DWORD   dwTemp;    // for general use
	};

#ifdef VALIDATE
	// Dont touch this !!
	WORD    sentinel;       // debug sentinel
#endif

// C++ Extensions
#ifdef __cplusplus

	LPBYTE EndBuf  (void) FAR {return lpbBegBuf  + wLengthBuf; }
	LPBYTE EndData (void) FAR {return lpbBegData + wLengthData;}
	void   Reset   (void) FAR {lpbBegData = lpbBegBuf; wLengthData = 0;}
  
#endif // __cplusplus

} BUFFER, FAR *LPBUFFER , FAR * FAR * LPLPBUFFER ;

/********
    @doc    EXTERNAL IFAXOS DATATYPES SRVRDLL OEMNSF

    @type   DWORD | STD_DATA_TYPES | Standard data types used for
	    specifying the format of data in the system.

    @emem   MH_DATA     | Modified Huffman (T.4 1-dimensional).
    @emem   MR_DATA     | Modified READ (T.4 2-dimensional).
    @emem   MMR_DATA| Modified Modified READ (T.6).
    @emem   LRAW_DATA | Raw bitmap data, Least Significant Bit to the left.
    @emem   HRAW_DATA | Raw Bitmap data, Most Significant Bit to the left.
    @emem   DCX_DATA | Industry standard DCX specification (collection of PCX pages).
    @emem   ENCRYPTED_DATA | Data encrypted - original format unspecified.
    @emem   SIGNED_DATA | Data along with a digital signature. 
    @emem   BINFILE_DATA | Arbitrary binary data.
    @emem   STORED_BUF_DATA | Contains a BUFFER header & data.
    @emem   DCP_TEMPLATE_DATA | Digital Cover Page template data.
    @emem   DCP_DATA | Digital Cover Page processed template data.
    @emem   SPOOL_DATA | Spool data type - same as MMR for now.
    @emem   PRINTMODE_DATA | Printer Mode structure.
    @emem   ASCII_DATA | Ascii text.
    @emem   OLE_DATA   | Ole object.
    @emem   OLE_PICTURE | Ole Rendering Data.
    @emem   END_OF_PAGE | End of page marker.
    @emem   END_OF_JOB  | End of job marker.
    @emem   CUSTOM_METADATA_TYPE  | Beyond this value custom data types can be
	    defined.

    @comm   This should be used to specify data type of any data stream in the
	    system - from BUFFERS to Linearized Messages.  All data types which 
	    need to be used in bit fields (i.e. the Format Resolution) must have
	    a value which is a power of 2.  Other data types which do not need to used
	    in a bit field context may be assigned the other values.
********/

#define MH_DATA           0x00000001L
#define MR_DATA           0x00000002L
#define MMR_DATA          0x00000004L
#define LRAW_DATA         0x00000008L
#define HRAW_DATA         0x00000010L
#define DCX_DATA          0x00000020L
#define ENCRYPTED_DATA    0x00000040L
#define BINFILE_DATA      0x00000080L
#define DCP_TEMPLATE_DATA 0x00000100L
#define ASCII_DATA        0x00000200L
#define RAMBO_DATA        0x00000400L
#define LINEARIZED_DATA   0x00000800L
#define DCP_DATA          0x00001000L
#define PCL_DATA          0x00002000L
#define ADDR_BOOK_DATA    0x00004000L
#define OLE_BIT_DATA      0x00008000L    // So we can use fmtres on OLE_DATA
#define OLE_BIT_PICTURE   0x00010000L    // So we can use fntres on OLE_BIT_PICTURE

// Make spool data be MMR
#define SPOOL_DATA        MMR_DATA

// Standard Non-Bit Valued MetaData values
#define NULL_DATA         0x00000000L
#define SIGNED_DATA       0x00000003L
#define STORED_BUF_DATA   0x00000005L
#define PRINTMODE_DATA    0x00000006L
#define OLE_DATA          0x0000001EL    // DONT CHANGE THIS VALUE - Needs to be Snowball Compatible
#define OLE_PICTURE       0x0000001FL    // DONT CHANGE THIS VALUE - Needs to be Snowball Compatible
#define END_OF_PAGE       0x00000021L
#define END_OF_JOB        0x00000022L
#define PARADEV_DATA      0x00000031L    // parallel device data
#define PARADEV_EOF       0x00000032L    // parallel device end of file


#define ISVIEWATT(e)  (((e) == MMR_DATA) || ((e) == RAMBO_DATA))
#define ISOLEATT(e)   (((e) == OLE_DATA) || ((e) == OLE_PICTURE))
#define ISPAGEDATT(e) (((e)==MMR_DATA) || ((e)==MR_DATA) || \
                        ((e)==MH_DATA)|| ((e)==LRAW_DATA)|| ((e)==HRAW_DATA))


// Allow for 24 standard bit valued MetaData values
#define CUSTOM_METADATA_TYPE  0x00800001L

/********
    @doc    EXTERNAL IFAXOS DATATYPES SRVRDLL OEMNSF

    @type   DWORD | STD_RESOLUTIONS | Standard Page Resolutions

    @emem   AWRES_UNUSED      | Resolution is unused or irrelevant
    @emem   AWRES_UNKNOWN     | Resolution is unknown
    @emem   AWRES_CUSTOM      | Custom resolution
    @emem   AWRES_mm080_038   | 8 lines/mm x 3.85 lines/mm
    @emem   AWRES_mm080_077   | 8 lines/mm x 7.7 lines/mm
    @emem   AWRES_mm080_154   | 8 lines/mm x 15.4 lines/mm
    @emem   AWRES_mm160_154   | 16 lines/mm x 15.4 lines/mm
    @emem   AWRES_200_100     | 200 dpi x 100 dpi
    @emem   AWRES_200_200     | 200 dpi x 200 dpi
    @emem   AWRES_200_400     | 200 dpi x 400 dpi
    @emem   AWRES_300_300     | 300 dpi x 300 dpi
    @emem   AWRES_400_400     | 400 dpi x 400 dpi
********/   

#define AWRES_UNUSED            0xFFFFFFFFL
#define	AWRES_UNKNOWN		0x00000000L
#define AWRES_CUSTOM            0x00000001L
#define AWRES_mm080_038         0x00000002L
#define AWRES_mm080_077         0x00000004L
#define AWRES_mm080_154         0x00000008L
#define AWRES_mm160_154         0x00000010L
#define AWRES_200_100           0x00000020L
#define AWRES_200_200           0x00000040L
#define AWRES_200_400           0x00000080L
#define AWRES_300_300           0x00000100L
#define AWRES_400_400           0x00000200L
#define AWRES_600_600           0x00000400L
#define AWRES_600_300           0x00000800L

// Keep old names for a while
#define AWRES_NORMAL            AWRES_mm080_038
#define AWRES_FINE              AWRES_mm080_077
#define AWRES_SUPER             AWRES_mm080_154
#define AWRES_SUPER_SUPER       AWRES_mm160_154
#define AWRES_SUPER_FINE        AWRES_SUPER_SUPER

/********
    @doc    EXTERNAL    IFAXOS  DATATYPES  SRVRDLL

    @type   DWORD |  STD_PAGE_LENLIMITS | Standard Page Length Limits

    @emem   AWLENLIMIT_UNUSED    | Page Length Limit unused
    @emem   AWLENLIMIT_STD       | Page Length Limit defined by Standard Paper Size
    @emem   AWLENLIMIT_UNLIMITED | unlimited page length
********/

#define AWLENLIMIT_UNUSED    0xFFFFFFFFL
#define AWLENLIMIT_STD       0x00000001L
#define AWLENLIMIT_UNLIMITED 0x00000002L


/********
    @doc    EXTERNAL IFAXOS DATATYPES SRVRDLL 

    @typee  STD_PAGE_SIZES | Standard Page Sizes

    @emem   AWPAPER_UNUSED         |  Paper size is unused
    @emem   AWPAPER_UNKNOWN         |  Unknown size
    @emem   AWPAPER_CUSTOM          |  Custom Paper size
    @emem   AWPAPER_A3_PORTRAIT     |  A3 Portrait
    @emem   AWPAPER_A3_LANDSCAPE    | A3 landscape
    @emem	AWPAPER_B4_PORTRAIT     | B4 portrait
	@emem	AWPAPER_B4_LANDSCAPE    | B4 landscape
	@emem	AWPAPER_A4_PORTRAIT     | A4 portrait
	@emem	AWPAPER_A4_LANDSCAPE    | A4 landscape
	@emem	AWPAPER_B5_PORTRAIT     | B5 portrait
	@emem	AWPAPER_B5_LANDSCAPE    | B5 landscape
	@emem	AWPAPER_A5_PORTRAIT     | A5 portrait
	@emem	AWPAPER_A5_LANDSCAPE    | A5 landscape
	@emem	AWPAPER_A6_PORTRAIT     | A6 portrait
	@emem	AWPAPER_A6_LANDSCAPE    | A6 landscape
	@emem	AWPAPER_LETTER_PORTRAIT | Letter portrait
	@emem	AWPAPER_LETTER_LANDSCAPE | Letter landscape
	@emem	AWPAPER_LEGAL_PORTRAIT   | Legal portrait
	@emem	AWPAPER_LEGAL_LANDSCAPE  | Legal landscape
	@emem	AWPAPER_WIN31_DEFAULT   | ????


	@comm   Page width in pixels must be exactly correct for MH/MR/MMR
			decoding and to interoperate with Group-3 fax machines.
			The table in the example below gives the bits/bytes required at each width
			and resolution combination

    @ex     Table for Page Width vs Resolution  |

                         A4        B4        A3        A5        A6
    200dpi / 8li/mm   1728/216  2048/256  2432/304  1216/152   864/108
    300               2592/324  3072/384  3648/456  1824/228  1296/162
    400dpi / 16li/mm  3456/432  4096/512  4864/608  2432/304  1728/216

********/

#define         AWPAPER_UNUSED                  0xFFFFFFFFL
#define         AWPAPER_UNKNOWN                 0x00000000L
#define         AWPAPER_CUSTOM                  0x00000001L
#define         AWPAPER_A3_PORTRAIT             0x00000002L
#define         AWPAPER_A3_LANDSCAPE            0x00000004L
#define         AWPAPER_B4_PORTRAIT             0x00000008L
#define         AWPAPER_B4_LANDSCAPE            0x00000010L
#define         AWPAPER_A4_PORTRAIT             0x00000020L
#define         AWPAPER_A4_LANDSCAPE            0x00000040L
#define         AWPAPER_B5_PORTRAIT             0x00000080L
#define         AWPAPER_B5_LANDSCAPE            0x00000100L
#define         AWPAPER_A5_PORTRAIT             0x00000200L
#define         AWPAPER_A5_LANDSCAPE            0x00000400L
#define         AWPAPER_A6_PORTRAIT             0x00000800L
#define         AWPAPER_A6_LANDSCAPE            0x00001000L
#define         AWPAPER_LETTER_PORTRAIT         0x00002000L
#define         AWPAPER_LETTER_LANDSCAPE        0x00004000L
#define         AWPAPER_LEGAL_PORTRAIT          0x00008000L
#define         AWPAPER_LEGAL_LANDSCAPE         0x00010000L
#define         AWPAPER_WIN31_DEFAULT           0x00020000L





#endif // _INC_BUFFERS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\inc\faxcodec.h ===
// Copyright (c) Microsoft Corp. 1992-94
/*==============================================================================
The prototypes in this header file define an API for the Fax Codec DLL.

DATE				NAME			COMMENTS
25-Nov-92		RajeevD   Created.
13-Apr-93		RajeevD		Changed to Bring Your Own Memory (BYOM :=) API.
01-Nov-93   RajeevD   Defined structure for initialization parameters.
21-Jan-94   RajeevD   Split FaxCodecRevBuf into BitReverseBuf and InvertBuf.
19-Jul-94   RajeevD   Added nTypeOut=NULL_DATA and FaxCodecCount.
==============================================================================*/
#ifndef _FAXCODEC_
#define _FAXCODEC_

#include <windows.h>
#include <buffers.h>

/*==============================================================================
The FC_PARAM structure specifies the conversion to be initialized.
This matrix indicates the valid combinations of nTypeIn and nTypeOut.

                             nTypeOut
                             
                 MH     MR     MMR    LRAW    NULL
                 
        MH               *      *       *      *

        MR       *              *       *      *
nTypeIn
        MMR      *       *              *

        LRAW     *       *      * 
        
==============================================================================*/
typedef struct
#ifdef __cplusplus
  FAR FC_PARAM
#endif
{
	DWORD nTypeIn;      // input data type:  {MH|MR|MMR|LRAW}_DATA
	DWORD nTypeOut;     // output type type: {MH|MR|MMR|LRAW|NULL}_DATA
	UINT  cbLine;       // scan line byte width (must be multiple of 4)
	UINT  nKFactor;     // K factor (significant for nTypeOut==MR_DATA)
}
	FC_PARAM, FAR *LPFC_PARAM;

#ifdef __cplusplus
extern "C" {
#endif

/*==============================================================================
FaxCodecInit() initializes a context for a conversion.  The client may pass a 
NULL context pointer to query for the exact size of the context, allocate the
context memory, and call a second time to initialize.
==============================================================================*/
UINT                     // size of context (0 on failure)
WINAPI FaxCodecInit
(
	LPVOID     lpContext,  // context pointer (or NULL on query)
	LPFC_PARAM lpParam	   // initialization parameters
);

typedef UINT (WINAPI *LPFN_FAXCODECINIT)
	(LPVOID, LPFC_PARAM);

// Return codes for FaxCodecConvert
typedef UINT FC_STATUS;
#define FC_INPUT_EMPTY 0
#define FC_OUTPUT_FULL 1
#define FC_DECODE_ERR  4 // only for nTypeIn==MMR_DATA

/*==============================================================================
FaxCodecConvert() executes the conversion specified in FaxCodecInit().

In the input buffer, lpbBegData is advanced and wLengthData is decremented as 
data is consumed.  If the caller wants to retain the input data, both must be 
saved and restored.  If the input type is LRAW_DATA, wLengthData must be a
multiple of 4.

In the output buffer, wLengthData is incremented as data is appended.  If the
output type is LRAW_DATA, an whole number of scan lines are produced.

To flush any output data at the end of a page, pass a NULL input buffer or a
zero length buffer with dwMetaData set to END_OF_PAGE.

Returns when the input buffer is empty or the output buffer full.
==============================================================================*/
FC_STATUS             // status
WINAPI FaxCodecConvert
(
	LPVOID   lpContext, // context pointer
	LPBUFFER lpbufIn,   // input buffer (NULL at end of page)
	LPBUFFER lpbufOut   // output buffer
);

typedef UINT (WINAPI *LPFN_FAXCODECCONVERT)
	(LPVOID, LPBUFFER, LPBUFFER);

/*==============================================================================
The FC_COUNT structure accumulates various counters during FaxCodecConvert.
==============================================================================*/
typedef struct
{
	DWORD cTotalGood;    // total good scan lines
	DWORD cTotalBad;     // total bad scan lines
	DWORD cMaxRunBad;    // maximum consecutive bad
}
	FC_COUNT, FAR *LPFC_COUNT;

/*==============================================================================
FaxCodecCount() reports and resets the internal counters.
==============================================================================*/
void WINAPI FaxCodecCount
(
	LPVOID     lpContext,
	LPFC_COUNT lpCount
);

typedef void (WINAPI *LPFN_FAXCODECCOUNT)
	(LPVOID, LPFC_COUNT);

/*==============================================================================
BitReverseBuf() performs a bit reversal of buffer data.  The dwMetaData field is
toggled between LRAW_DATA and HRAW_DATA.  As with all scan lines, the length 
of data (wLengthData) must be a 32-bit multiple.  For best performance the start
of the data (lpbBegData) should be 32-bit aligned and the data predominantly 0.
==============================================================================*/
void WINAPI BitReverseBuf (LPBUFFER lpbuf);

/*==============================================================================
InvertBuf() inverts buffer data.  As with all scan lines, the length of data 
(wLengthData) must be a 32-bit multiple.  For best performance, the start of 
data (lpbBegData) should be 32-bit aligned.
==============================================================================*/
void WINAPI InvertBuf (LPBUFFER lpbuf);

/*==============================================================================
FaxCodecChange() produces a change vector for an LRAW scan line.
==============================================================================*/
typedef short FAR* LPSHORT;

// Slack Parameters.
#define RAWBUF_SLACK 2
#define CHANGE_SLACK 12
#define OUTBUF_SLACK 16

extern void WINAPI FaxCodecChange
(
	LPBYTE  lpbLine,  // LRAW scan line
	UINT    cbLine,   // scan line width
  LPSHORT lpsChange // change vector
);

#ifdef __cplusplus
} // extern "C" {
#endif

#endif // _FAXCODEC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\inc\dcxcodec.h ===
// Copyright (C) Microsoft Corp. 1994
/*==============================================================================
The prototypes in this header file define an API for the Dcx Codec DLL.

DATE				NAME			COMMENTS
13-Jan-94   RajeevD   Parallel to faxcodec.h
==============================================================================*/
#ifndef _INC_DCXCODEC
#define _INC_DCXCODEC

#include <faxcodec.h>

#ifdef __cplusplus
extern "C" {
#endif

/*==============================================================================
DcxCodecInit() initializes a context for a conversion.  The client may pass a 
NULL context pointer to query for the exact size of the context, allocate the
context memory, and call a second time to initialize.
==============================================================================*/
UINT                     // returns size of context (0 on failure)
WINAPI DcxCodecInit
(
	LPVOID     lpContext,  // context pointer (or NULL on query)
	LPFC_PARAM lpParam	   // initialization parameters
);

/*==============================================================================
DcxCodecConvert() executes the conversion specified in DcxCodecInit().

In the input buffer, lpbBegData is advanced and uLengthData is decremented as 
data is consumed.  If the caller wants to retain the input data, both must be 
saved and restored.

In the output buffer, uLengthData is incremented as data is appended.  If the
output type is HRAW_DATA, an integral number of scan lines are produced.

To flush any output data at the end of apage, pass a NULL input buffer.

Returns when the input buffer is empty or the output buffer full.
==============================================================================*/
FC_STATUS             // returns status
WINAPI DcxCodecConvert
(
	LPVOID   lpContext, // context pointer
	LPBUFFER lpbufIn,   // input buffer (NULL at end of page)
	LPBUFFER lpbufOut   // output buffer
);


#ifdef __cplusplus
} // extern "C" {
#endif

// DCX file header
typedef struct
{
	DWORD   dwSignature;    // always set to DCX_SIG
	DWORD   dwOffset[1024]; // array of page offsets
}
	DCX_HDR;

#define DCX_SIG 987654321L

// PCX file header
typedef struct
{
	BYTE    bSig;          // signature: always  0Ah
	BYTE    bVer;          // version: at least 2 
	BYTE    bEnc;          // encoding: always 1
	BYTE    bBPP;          // color depth [bpp]
	short   xMin;          // x minimum, inclusive
	short   yMin;          // y minimum, inclusive
	short   xMax;          // x maximum, inclusive
	short   yMax;          // y maximum, inclusive
	WORD    xRes;          // x resolution [dpi]
	WORD    yRes;          // y resolution [dpi]
	BYTE    bPalette[48];  // color palette
	BYTE    bReserved;
	BYTE    bPlanes;       // number of color planes
	WORD    wHoriz; 
  WORD    wPalInfo;      // palette info: always 1
	char    bFill[58];
}
	PCX_HDR;

#endif // _INC_DCXCODEC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\inc\faxspool.h ===
// Copyright (c) Microsoft Corp. 1993-94
/*==============================================================================
The Spool API is a file layer for buffers which supports random access to pages.
This module is compiled to use secure files on IFAX and plain files on Windows.

27-Oct-93    RajeevD    Created.
06-Dec-93    RajeevD    Integrated with render server.
22-Dec-93    RajeevD    Added SpoolReadSetPage.
06-Sep-94    RajeevD    Added SpoolRepairFile.
09-Sep-94    RajeevD    Added SpoolReadCountPages
==============================================================================*/
#ifndef _FAXSPOOL_
#define _FAXSPOOL_

#include <ifaxos.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct      // spool file header
{
	WORD  xRes;       // X resolution [dpi]
	WORD  yRes;       // Y resolution [dpi]
	WORD  cbLine;     // X extent [bytes]
}
	SPOOL_HEADER, FAR *LPSPOOL_HEADER;

/*==============================================================================
SpoolWriteOpen creates a context for writing buffers to a spool file.
==============================================================================*/
LPVOID                       // context pointer (NULL on failure)
WINAPI
SpoolWriteOpen
(
	LPVOID lpFilePath,         // IFAX file key or Windows file name
	LPSPOOL_HEADER lpHeader    // image attributes to record in file
);

/*==============================================================================
SpoolWriteBuf dumps buffers to the spool file.  The buffers are not freed or
modified.  Each page is terminated by passing a buffer with dwMetaData set to
END_OF_PAGE, except the last page, which is terminated by END_OF_JOB.  IFAX
files are flushed at the end of each page.  This call may fail if the disk
becomes full, in which case the caller is responsible for deleting the file and
destroying the context.
==============================================================================*/
BOOL                         // TRUE (success) or FALSE (failure)
WINAPI
SpoolWritePutBuf
(
	LPVOID lpContext,          // context returned from SpoolWriteOpen
	LPBUFFER lpbuf             // buffer to be written to spool file
);

/*==============================================================================
SpoolWriteClose destroys a context returned from SpoolWriteOpen.
==============================================================================*/
void
WINAPI
SpoolWriteClose
(
	LPVOID lpContext           // context returned from SpoolWriteOpen
);

/*==============================================================================
SpoolRepairFile repairs a truncated file created by SpoolWriteOpen but not
flushed by SpoolWriteClose due to a system failure.
==============================================================================*/
WORD                         // number of complete pages recovered
WINAPI
SpoolRepairFile
(
	LPVOID lpFileIn,           // damaged file 
	LPVOID lpFileOut           // repaired file
);

/*==============================================================================
SpoolReadOpen creates a context for reading buffers from a completed spool file.
==============================================================================*/
LPVOID                       // context pointer (NULL on failure)
WINAPI
SpoolReadOpen
(
	LPVOID lpFilePath,         // IFAX file key or Windows file name
	LPSPOOL_HEADER lpHeader    // image attributes to fill (or NULL)
);

/*==============================================================================
SpoolReadCountPage returns the number of pages in a spool file.
==============================================================================*/
WORD                         // number of pages
WINAPI
SpoolReadCountPages
(
	LPVOID lpContext           // context returned from SpoolReadOpen
);

/*==============================================================================
SpoolReadSetPage sets the spool file to the start of the specified page.
==============================================================================*/
BOOL                         // TRUE (success) or FALSE (failure)
WINAPI
SpoolReadSetPage
(
	LPVOID lpContext,          // context returned from SpoolReadOpen
	WORD   iPage               // page index (first page has index 0)
);

/*==============================================================================
SpoolReadGetBuf to retrieves the next buffer from the spool file.  Each page is
terminated by an END_OF_PAGE buffer, except the last page, which is terminated
by END_OF_JOB.  The call may fail if a buffer cannot be allocated.
==============================================================================*/
LPBUFFER                     // returns filled buffer (NULL on failure)
WINAPI
SpoolReadGetBuf
(
	LPVOID lpContext           // context returned from SpoolReadOpen
);

/*==============================================================================
SpoolFreeBuf can free buffers returned from SpoolReadGetBuf.
==============================================================================*/
BOOL                         // TRUE  (success) or FALSE (failure)
WINAPI
SpoolFreeBuf
(
	LPBUFFER lpbuf             // buffer returned from SpoolReadGetBuf
);

/*==============================================================================
SpoolReadClose destroys a context returned from SpoolReadOpen.
==============================================================================*/
void
WINAPI
SpoolReadClose 
(
	LPVOID lpContext           // context returned from SpoolReadOpen
);


#ifdef __cplusplus
} // extern "C"
#endif

#endif // _FAXSPOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\inc\awdlib.h ===
#ifndef _AWDLIB_H
#define _AWDLIB_H
/*++
  awdlib.h

  header file for the AWD library.

  Copyright (c) 1997  Microsoft Corporation

  Author:
       Brian Dewey (t-briand)  1997-7-2

--*/

// needed includes for the AWD file format
#include <ole2.h>		// AWD is an OLE compound document.

// ------------------------------------------------------------
// Defines
#define MAX_AWD_NAME	(32)

// ------------------------------------------------------------
// Data types

// This structure holds the primary storages used in an AWD file.
typedef struct awd_file {
    IStorage *psAWDFile;	// The root storage of the file.
    IStorage *psDocuments;	// Storage holding the document data.
    IStorage *psPersistInfo;	// Persistent information storage.
    IStorage *psDocInfo;	// Document information stream.
    IStorage *psPageInfo;	// Page information storage.
    IStorage *psGlobalInfo;	// Global information storage.
} AWD_FILE;

// An AWD_DOC_PROCESSOR is a function that does something with an document
// contained in an AWD file.  Used in the EnumDocuments() function.  The
// function should return TRUE on success and FALSE on an error that requires
// the enumeration process to abort.
typedef BOOL (*AWD_DOC_PROCESSOR)(AWD_FILE *psStorages, const WCHAR *pwcsDocName);

#include "oleutils.h"		// Use the elliott fax viewer definitions.


// ------------------------------------------------------------
// Prototypes
BOOL      ConvertAWDToTiff(const WCHAR *pwcsAwdFile, WCHAR *pwcsTiffFile);
BOOL      OpenAWDFile(const WCHAR *pwcsFilename, AWD_FILE *psStorages);
BOOL      CloseAWDFile(AWD_FILE *psStorages);
IStorage *OpenAWDSubStorage(IStorage *psParent, const WCHAR *pwcsStorageName);
IStream  *OpenAWDStream(IStorage *psStorage, const WCHAR *pwcsStreamName);
BOOL      AWDViewed(AWD_FILE *psStorages);
void      DumpAWDDocuments(AWD_FILE *psStorages);
BOOL      EnumDocuments(AWD_FILE *psStorages, AWD_DOC_PROCESSOR pfnDocProc);
BOOL      DisplayDocNames(AWD_FILE *psStorages, const WCHAR *pwcsDocName);
BOOL      DetailedDocDump(AWD_FILE *psStorages, const WCHAR *pwcsDocName);
void      PrintPageInfo(PAGE_INFORMATION *psPageInfo);
void      DumpData(LPTSTR pszFileName, LPBYTE pbData, DWORD cbCount);




#endif // _AWDLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\inc\errormod.h ===
#ifndef _ERRORMOD_H
#define _ERRORMOD_H


// IFKERNEL API's
#define API_IFK_ALLOCBUF	         0x0040
#define API_IFK_FREEBUF	            0x0080
#define API_IFK_MAKEBUFWRITABLE	   0x00c0
#define API_IFK_SHAREBUF	         0x0100
#define API_IFK_SPLITBUF	         0x0140

#define API_IFK_IFGLOBALALLOC       0x1000
#define API_IFK_IFGLOBALFREE        0x1040

#define API_IFK_CREATEIFPIPE	      0x2000
#define API_IFK_DELETEIFPIPE	      0x2040
#define API_IFK_OPENIFPIPE	         0x2080
#define API_IFK_CLOSEIFPIPE	      0x20c0
#define API_IFK_REQREADFROMIFPIPE	0x2100
#define API_IFK_REQWRITETOIFPIPE	   0x2140

#define API_IFK_NEWMEMUNIT	         0x3040

#define API_IFK_POSTMESSAGE	      0x4000
#define API_IFK_GETMESSAGE		      0x4040
#define API_IFK_PEEKMESSAGE	      0x4080
#define API_IFK_BROADCASTMESSAGE	   0x40c0

#define API_IFK_CREATEPROCESS       0x5000
#define API_IFK_TERMINATEAPP            0x5040
#define API_IFK_GETIFPROCWINDOW         0x5080
#define API_IFK_SETIFPROCPRIORITY       0x50C0
#define API_IFK_GETIFPROCPRIORITY       0x5100

#define API_IFK_CREATEMUTEX	            0x6000
#define API_IFK_RELEASEMUTEX	        0x6040
#define API_IFK_CREATEEVENT	            0x6080
#define API_IFK_SETEVENT		        0x60c0   
#define API_IFK_WAITFORSINGLEOBJECT	    0x6100
#define API_IFK_FREESYNCOBJECT	        0x6140
#define API_IFK_GETSETEVENTPARAM        0x6180

#define API_IFK_IFSETTIMER             0x7000


//IFSCAN APIs (High level scanner driver: error codes in prnscn.h)
#define	API_OPENSCANNER				0x0040
#define	API_CLOSESCANNER			0x0080
#define	API_STARTSCANJOB			0x00c0
#define	API_ENDSCANJOB				0x0100
#define	API_CONTINUESCANJOB			0x0200
#define	API_ABORTSCANJOB			0x0300
#define	API_GETSCANNERSTATUS		0x0400
#define API_GETSCANNERPAPERINFO	  	0x0500
#define	API_GETSCANIMAGEINFO		0x0600
#define	API_GETSCANNERCAPS			0x0700
#define	API_GETSCANNERCUSTOMCAPS	0x0800
#define	API_COMPLETESCANPAGE		0x0900
#define	API_GETSCANDEVICEINFO		0x0a00
#define	API_SELECTSCANDEVICE		0x0b00
#define	API_SCANDEVICEMODE			0x0c00
#define	API_INITIFSCAN				0x0d00
#define	API_SCANDIAGNOSTICJOB		0x0e00
#define	API_GETDEVINFOFROMID		0x0f00
#define	API_GETDEVINFOFROMSTR		0x1000
#define	API_GETDEVDEFAULTMODE		0x1100
#define API_SCANNERPREFEED			0x1200
#define API_STARTCOPYJOB			0x1300
#define API_ENDCOPYJOB				0x1400

//IFPRINT (high level printer drivers api: error codes in prnscn.h)
#define	API_SELECTPRINTDEVICE		0x0a00
#define	API_GETPRINTDEVICEINFO		0x0900
#define	API_PRINTDEVICEMODE			0x0b00
#define	API_PRINTDIAGNOSTICJOB		0x0c00
#define API_CHECKPRINTERSTATUS		0x0d00

//Awreport(the report engine)
#define	API_AWREPORTMESSAGE			0x0a00


//Remote Access APIs (Remote Access Apis)
//IPX
#define	API_PSINIT				0x0040
#define	API_INITIATEBIND		0x0080

//MAC
#define	API_MACINIT				0x0040


//Renderer APIs

#define	API_RENDEROPEN				0x0040
#define	API_RENDEREXECUTE			0x0080
#define	API_RENDERCLOSE				0x00c0


//  Message pump events disguised as APIs

                                       // APICODE BITS | ERRCODE BITS
#define API_JOBMESSAGE        0x0040   // 0000 0000 01 | 00 0000
#define API_JOBCOMPLETE       0x0080   // 0000 0000 10 | 00 0000
#define API_JOBERRCOMPLETE    0x00C0   // 0000 0000 11 | 00 0000

#define API_MPJOBCANCEL       0x0100   
#define API_MPREJECTMSG       0x0140   
#define API_MPANSWER          0x0180   
#define API_MPTRANSPORT       0x01C0   
#define API_MPPOLLRETRIEVE    0x0200   
#define API_MPDEST            0x0240   




// WINDOWS MODULE API's 
#define WERR_OK  0x0
#define WERR_GETVERSION 0x40
#define WERR_GETFREESPACE 0x80
#define WERR_GETCURRENTPDB 0xC0
#define WERR_GETWINDOWSDIRECTORY 0x100
#define WERR_GETSYSTEMDIRECTORY 0x140
#define WERR_GETFREESYSTEMRESOURCES 0x180
#define WERR_GETWINFLAGS 0x1C0
#define WERR_GETDOSENVIRONMENT 0x200
#define WERR_GETCURRENTTIME 0x240
#define WERR_GETTICKCOUNT 0x280
#define WERR_GETTIMERRESOLUTION 0x2C0
#define WERR_LOGERROR 0x300
#define WERR_LOGPARAMERROR 0x340
#define WERR_GETWINDEBUGINFO 0x380
#define WERR_SETWINDEBUGINFO 0x3C0
#define WERR_FATALEXIT 0x400
#define WERR_FATALAPPEXIT 0x440
#define WERR_EXITWINDOWS 0x480
#define WERR_EXITWINDOWSEXEC 0x4C0
#define WERR_DEBUGBREAK 0x500
#define WERR_OUTPUTDEBUGSTRING 0x540
#define WERR_SETERRORMODE 0x580
#define WERR_ISBADREADPTR 0x5C0
#define WERR_ISBADWRITEPTR 0x600
#define WERR_ISBADHUGEREADPTR 0x640
#define WERR_ISBADHUGEWRITEPTR 0x680
#define WERR_ISBADCODEPTR 0x6C0
#define WERR_ISBADSTRINGPTR 0x700
#define WERR_PROFINSCHK 0x740
#define WERR_PROFSETUP 0x780
#define WERR_PROFSAMPRATE 0x7C0
#define WERR_PROFSTART 0x800
#define WERR_PROFSTOP 0x840
#define WERR_PROFCLEAR 0x880
#define WERR_PROFFLUSH 0x8C0
#define WERR_PROFFINISH 0x900
#define WERR_CATCH 0x940
#define WERR_THROW 0x980
#define WERR_SWITCHSTACKBACK 0x9C0
#define WERR_SWITCHSTACKTO 0xA00
#define WERR_LOADMODULE 0xA40
#define WERR_FREEMODULE 0xA80
#define WERR_LOADLIBRARY 0xAC0
#define WERR_FREELIBRARY 0xB00
#define WERR_WINEXEC 0xB40
#define WERR_GETMODULEHANDLE 0xB80
#define WERR_GETMODULEUSAGE 0xBC0
#define WERR_GETMODULEFILENAME 0xC00
#define WERR_GETPROCADDRESS 0xC40
#define WERR_GETINSTANCEDATA 0xC80
#define WERR_GETCODEHANDLE 0xCC0
#define WERR_GETCODEINFO 0xD00
#define WERR_MAKEPROCINSTANCE 0xD40
#define WERR_FREEPROCINSTANCE 0xD80
#define WERR_SETSWAPAREASIZE 0xDC0
#define WERR_SWAPRECORDING 0xE00
#define WERR_VALIDATECODESEGMENTS 0xE40
#define WERR_GETNUMTASKS 0xE80
#define WERR_ISTASK 0xEC0
#define WERR_GETCURRENTTASK 0xF00
#define WERR_YIELD 0xF40
#define WERR_DIRECTEDYIELD 0xF80
#define WERR_GLOBALALLOC 0xFC0
#define WERR_GLOBALREALLOC 0x1000
#define WERR_GLOBALFREE 0x1040
#define WERR_GLOBALDOSALLOC 0x1080
#define WERR_GLOBALDOSFREE 0x10C0
#define WERR_GLOBALLOCK 0x1100
//#define WERR_GLOBALLOCK 0x1140
#define WERR_GLOBALUNLOCK 0x1180
#define WERR_GLOBALSIZE 0x11C0
#define WERR_GLOBALHANDLE 0x1200
#define WERR_GLOBALFLAGS 0x1240
#define WERR_GLOBALWIRE 0x1280
//#define WERR_GLOBALWIRE 0x12C0
#define WERR_GLOBALUNWIRE 0x1300
#define WERR_GLOBALPAGELOCK 0x1340
#define WERR_GLOBALPAGEUNLOCK 0x1380
#define WERR_GLOBALFIX 0x13C0
#define WERR_GLOBALUNFIX 0x1400
#define WERR_GLOBALLRUNEWEST 0x1440
#define WERR_GLOBALLRUOLDEST 0x1480
#define WERR_GLOBALCOMPACT 0x14C0
#define WERR_GLOBALNOTIFY 0x1500
#define WERR_LOCKSEGMENT 0x1540
#define WERR_UNLOCKSEGMENT 0x1580
#define WERR_ALLOCSELECTOR 0x15C0
#define WERR_FREESELECTOR 0x1600
#define WERR_ALLOCDSTOCSALIAS 0x1640
#define WERR_PRESTOCHANGOSELECTOR 0x1680
#define WERR_GETSELECTORBASE 0x16C0
#define WERR_SETSELECTORBASE 0x1700
#define WERR_GETSELECTORLIMIT 0x1740
#define WERR_SETSELECTORLIMIT 0x1780
#define WERR_LIMITEMSPAGES 0x17C0
#define WERR_VALIDATEFREESPACES 0x1800
#define WERR_LOCALALLOC 0x1840
#define WERR_LOCALREALLOC 0x1880
#define WERR_LOCALFREE 0x18C0
#define WERR_LOCALLOCK 0x1900
//#define WERR_LOCALLOCK 0x1940
#define WERR_LOCALUNLOCK 0x1980
#define WERR_LOCALSIZE 0x19C0
#define WERR_LOCALHANDLE 0x1A00
//#define WERR_LOCALHANDLE 0x1A40
#define WERR_LOCALFLAGS 0x1A80
#define WERR_LOCALINIT 0x1AC0
#define WERR_LOCALCOMPACT 0x1B00
#define WERR_LOCALSHRINK 0x1B40
#define WERR_OPENFILE 0x1B80
#define WERR__LOPEN 0x1BC0
#define WERR__LCREAT 0x1C00
#define WERR__LCLOSE 0x1C40
#define WERR__LLSEEK 0x1C80
#define WERR__LREAD 0x1CC0
#define WERR__LWRITE 0x1D00
#define WERR__HREAD 0x1D40
#define WERR__HWRITE 0x1D80
#define WERR_GETTEMPFILENAME 0x1DC0
#define WERR_GETTEMPDRIVE 0x1E00
#define WERR_GETDRIVETYPE 0x1E40
#define WERR_SETHANDLECOUNT 0x1E80
#define WERR_WNETADDCONNECTION 0x1EC0
#define WERR_WNETGETCONNECTION 0x1F00
#define WERR_WNETCANCELCONNECTION 0x1F40
#define WERR_FINDRESOURCE 0x1F80
#define WERR_LOADRESOURCE 0x1FC0
#define WERR_FREERESOURCE 0x2000
#define WERR_LOCKRESOURCE 0x2040
//#define WERR_LOCKRESOURCE 0x2080
#define WERR_SIZEOFRESOURCE 0x20C0
#define WERR_ACCESSRESOURCE 0x2100
#define WERR_ALLOCRESOURCE 0x2140
#define WERR_SETRESOURCEHANDLER 0x2180
#define WERR_INITATOMTABLE 0x21C0
#define WERR_ADDATOM 0x2200
#define WERR_DELETEATOM 0x2240
#define WERR_FINDATOM 0x2280
#define WERR_GETATOMNAME 0x22C0
#define WERR_GLOBALADDATOM 0x2300
#define WERR_GLOBALDELETEATOM 0x2340
#define WERR_GLOBALFINDATOM 0x2380
#define WERR_GLOBALGETATOMNAME 0x23C0
#define WERR_GETATOMHANDLE 0x2400
#define WERR_GETPROFILEINT 0x2440
#define WERR_GETPROFILESTRING 0x2480
#define WERR_WRITEPROFILESTRING 0x24C0
#define WERR_GETPRIVATEPROFILEINT 0x2500
#define WERR_GETPRIVATEPROFILESTRING 0x2540
#define WERR_WRITEPRIVATEPROFILESTRING 0x2580
#define WERR_ANSITOOEM 0x25C0
#define WERR_OEMTOANSI 0x2600
#define WERR_ANSITOOEMBUFF 0x2640
#define WERR_OEMTOANSIBUFF 0x2680
#define WERR_ANSINEXT 0x26C0
#define WERR_ANSIPREV 0x2700
#define WERR_ANSIUPPER 0x2740
#define WERR_ANSILOWER 0x2780
#define WERR_ANSIUPPERBUFF 0x27C0
#define WERR_ANSILOWERBUFF 0x2800
#define WERR_ISCHARALPHA 0x2840
#define WERR_ISCHARALPHANUMERIC 0x2880
#define WERR_ISCHARUPPER 0x28C0
#define WERR_ISCHARLOWER 0x2900
#define WERR_LSTRCMP 0x2940
#define WERR_LSTRCMPI 0x2980
#define WERR_LSTRCPY 0x29C0
#define WERR_LSTRCAT 0x2A00
#define WERR_LSTRLEN 0x2A40
#define WERR_LSTRCPYN 0x2A80
#define WERR_HMEMCPY 0x2AC0
#define WERR_ISDBCSLEADBYTE 0x2B00
#define WERR_LOADSTRING 0x2B40
#define WERR_OEMKEYSCAN 0x2B80
#define WERR_VKKEYSCAN 0x2BC0
#define WERR_GETKEYBOARDTYPE 0x2C00
#define WERR_MAPVIRTUALKEY 0x2C40
#define WERR_GETKBCODEPAGE 0x2C80
#define WERR_GETKEYNAMETEXT 0x2CC0
#define WERR_TOASCII 0x2D00
#define WERR_CREATEDC 0x2D40
#define WERR_CREATEIC 0x2D80
#define WERR_CREATECOMPATIBLEDC 0x2DC0
#define WERR_DELETEDC 0x2E00
#define WERR_GETDCORG 0x2E40
#define WERR_SAVEDC 0x2E80
#define WERR_RESTOREDC 0x2EC0
#define WERR_SETENVIRONMENT 0x2F00
#define WERR_GETENVIRONMENT 0x2F40
#define WERR_MULDIV 0x2F80
#define WERR_SETBOUNDSRECT 0x2FC0
#define WERR_GETBOUNDSRECT 0x3000
#define WERR_GETDEVICECAPS 0x3040
#define WERR_SETMAPMODE 0x3080
#define WERR_GETMAPMODE 0x30C0
#define WERR_SETWINDOWORG 0x3100
#define WERR_GETWINDOWORG 0x3140
#define WERR_SETWINDOWEXT 0x3180
#define WERR_GETWINDOWEXT 0x31C0
#define WERR_OFFSETWINDOWORG 0x3200
#define WERR_SCALEWINDOWEXT 0x3240
#define WERR_SETVIEWPORTORG 0x3280
#define WERR_GETVIEWPORTORG 0x32C0
#define WERR_SETVIEWPORTEXT 0x3300
#define WERR_GETVIEWPORTEXT 0x3340
#define WERR_OFFSETVIEWPORTORG 0x3380
#define WERR_SCALEVIEWPORTEXT 0x33C0
#define WERR_SETWINDOWORGEX 0x3400
#define WERR_GETWINDOWORGEX 0x3440
#define WERR_SETWINDOWEXTEX 0x3480
#define WERR_GETWINDOWEXTEX 0x34C0
#define WERR_OFFSETWINDOWORGEX 0x3500
#define WERR_SCALEWINDOWEXTEX 0x3540
#define WERR_SETVIEWPORTEXTEX 0x3580
#define WERR_GETVIEWPORTEXTEX 0x35C0
#define WERR_SETVIEWPORTORGEX 0x3600
#define WERR_GETVIEWPORTORGEX 0x3640
#define WERR_OFFSETVIEWPORTORGEX 0x3680
#define WERR_SCALEVIEWPORTEXTEX 0x36C0
#define WERR_DPTOLP 0x3700
#define WERR_LPTODP 0x3740
#define WERR_GETNEARESTCOLOR 0x3780
#define WERR_GETSYSCOLOR 0x37C0
#define WERR_SETSYSCOLORS 0x3800
#define WERR_GETSTOCKOBJECT 0x3840
#define WERR_ISGDIOBJECT 0x3880
#define WERR_DELETEOBJECT 0x38C0
#define WERR_SELECTOBJECT 0x3900
#define WERR_GETOBJECT 0x3940
#define WERR_UNREALIZEOBJECT 0x3980
#define WERR_ENUMOBJECTS 0x39C0
//#define WERR_ENUMOBJECTS 0x3A00
#define WERR_CREATEPEN 0x3A40
#define WERR_CREATEPENINDIRECT 0x3A80
#define WERR_CREATESOLIDBRUSH 0x3AC0
#define WERR_CREATEHATCHBRUSH 0x3B00
#define WERR_CREATEPATTERNBRUSH 0x3B40
#define WERR_CREATEDIBPATTERNBRUSH 0x3B80
#define WERR_CREATEBRUSHINDIRECT 0x3BC0
#define WERR_SETBRUSHORG 0x3C00
#define WERR_GETBRUSHORG 0x3C40
#define WERR_GETBRUSHORGEX 0x3C80
#define WERR_CREATERECTRGN 0x3CC0
#define WERR_CREATERECTRGNINDIRECT 0x3D00
#define WERR_CREATEELLIPTICRGNINDIRECT 0x3D40
#define WERR_CREATEELLIPTICRGN 0x3D80
#define WERR_CREATEPOLYGONRGN 0x3DC0
#define WERR_CREATEPOLYPOLYGONRGN 0x3E00
#define WERR_CREATEROUNDRECTRGN 0x3E40
#define WERR_SETRECTRGN 0x3E80
#define WERR_COMBINERGN 0x3EC0
#define WERR_EQUALRGN 0x3F00
#define WERR_OFFSETRGN 0x3F40
#define WERR_GETRGNBOX 0x3F80
#define WERR_RECTINREGION 0x3FC0
#define WERR_PTINREGION 0x4000
#define WERR_CREATEPALETTE 0x4040
#define WERR_SELECTPALETTE 0x4080
#define WERR_REALIZEPALETTE 0x40C0
#define WERR_UPDATECOLORS 0x4100
#define WERR_ANIMATEPALETTE 0x4140
#define WERR_SETPALETTEENTRIES 0x4180
#define WERR_GETPALETTEENTRIES 0x41C0
#define WERR_GETNEARESTPALETTEINDEX 0x4200
#define WERR_RESIZEPALETTE 0x4240
#define WERR_GETSYSTEMPALETTEENTRIES 0x4280
#define WERR_GETSYSTEMPALETTEUSE 0x42C0
#define WERR_SETSYSTEMPALETTEUSE 0x4300
#define WERR_SELECTCLIPRGN 0x4340
#define WERR_GETCLIPBOX 0x4380
#define WERR_INTERSECTCLIPRECT 0x43C0
#define WERR_OFFSETCLIPRGN 0x4400
#define WERR_EXCLUDECLIPRECT 0x4440
#define WERR_PTVISIBLE 0x4480
#define WERR_RECTVISIBLE 0x44C0
#define WERR_MOVETO 0x4500
#define WERR_GETCURRENTPOSITION 0x4540
#define WERR_MOVETOEX 0x4580
#define WERR_GETCURRENTPOSITIONEX 0x45C0
#define WERR_LINETO 0x4600
#define WERR_POLYLINE 0x4640
#define WERR_LINEDDA 0x4680
#define WERR_RECTANGLE 0x46C0
#define WERR_ROUNDRECT 0x4700
#define WERR_ELLIPSE 0x4740
#define WERR_ARC 0x4780
#define WERR_CHORD 0x47C0
#define WERR_PIE 0x4800
#define WERR_POLYGON 0x4840
#define WERR_POLYPOLYGON 0x4880
#define WERR_SETPOLYFILLMODE 0x48C0
#define WERR_GETPOLYFILLMODE 0x4900
#define WERR_FLOODFILL 0x4940
#define WERR_EXTFLOODFILL 0x4980
#define WERR_FILLRGN 0x49C0
#define WERR_FRAMERGN 0x4A00
#define WERR_INVERTRGN 0x4A40
#define WERR_PAINTRGN 0x4A80
#define WERR_FILLRECT 0x4AC0
#define WERR_FRAMERECT 0x4B00
#define WERR_INVERTRECT 0x4B40
#define WERR_DRAWFOCUSRECT 0x4B80
#define WERR_TEXTOUT 0x4BC0
#define WERR_TABBEDTEXTOUT 0x4C00
#define WERR_EXTTEXTOUT 0x4C40
#define WERR_GETTEXTEXTENT 0x4C80
#define WERR_GETTABBEDTEXTEXTENT 0x4CC0
#define WERR_GETTEXTEXTENTPOINT 0x4D00
#define WERR_DRAWTEXT 0x4D40
#define WERR_GRAYSTRING 0x4D80
#define WERR_GETCHARWIDTH 0x4DC0
#define WERR_SETTEXTCOLOR 0x4E00
#define WERR_GETTEXTCOLOR 0x4E40
#define WERR_SETBKCOLOR 0x4E80
#define WERR_GETBKCOLOR 0x4EC0
#define WERR_SETBKMODE 0x4F00
#define WERR_GETBKMODE 0x4F40
#define WERR_SETTEXTALIGN 0x4F80
#define WERR_GETTEXTALIGN 0x4FC0
#define WERR_SETTEXTCHARACTEREXTRA 0x5000
#define WERR_GETTEXTCHARACTEREXTRA 0x5040
#define WERR_SETTEXTJUSTIFICATION 0x5080
#define WERR_CREATEFONT 0x50C0
#define WERR_CREATEFONTINDIRECT 0x5100
#define WERR_SETMAPPERFLAGS 0x5140
#define WERR_ADDFONTRESOURCE 0x5180
#define WERR_REMOVEFONTRESOURCE 0x51C0
#define WERR_GETTEXTFACE 0x5200
#define WERR_GETASPECTRATIOFILTER 0x5240
#define WERR_GETASPECTRATIOFILTEREX 0x5280
#define WERR_GETTEXTMETRICS 0x52C0
#define WERR_GETOUTLINETEXTMETRICS 0x5300
#define WERR_ENUMFONTFAMILIES 0x5340
#define WERR_ENUMFONTS 0x5380
//#define WERR_ENUMFONTS 0x53C0
//#define WERR_ENUMFONTFAMILIES 0x5400
#define WERR_GETFONTDATA 0x5440
#define WERR_CREATESCALABLEFONTRESOURCE 0x5480
#define WERR_GETGLYPHOUTLINE 0x54C0
#define WERR_GETCHARABCWIDTHS 0x5500
#define WERR_GETKERNINGPAIRS 0x5540
#define WERR_GETRASTERIZERCAPS 0x5580
#define WERR_CREATEBITMAP 0x55C0
#define WERR_CREATEBITMAPINDIRECT 0x5600
#define WERR_CREATECOMPATIBLEBITMAP 0x5640
#define WERR_CREATEDISCARDABLEBITMAP 0x5680
#define WERR_CREATEDIBITMAP 0x56C0
#define WERR_LOADBITMAP 0x5700
#define WERR_BITBLT 0x5740
#define WERR_PATBLT 0x5780
#define WERR_STRETCHBLT 0x57C0
#define WERR_STRETCHDIBITS 0x5800
#define WERR_SETPIXEL 0x5840
#define WERR_GETPIXEL 0x5880
#define WERR_SETSTRETCHBLTMODE 0x58C0
#define WERR_GETSTRETCHBLTMODE 0x5900
#define WERR_SETBITMAPDIMENSION 0x5940
#define WERR_GETBITMAPDIMENSION 0x5980
#define WERR_SETBITMAPDIMENSIONEX 0x59C0
#define WERR_GETBITMAPDIMENSIONEX 0x5A00
#define WERR_SETROP2 0x5A40
#define WERR_GETROP2 0x5A80
#define WERR_SETBITMAPBITS 0x5AC0
#define WERR_GETBITMAPBITS 0x5B00
#define WERR_SETDIBITS 0x5B40
#define WERR_GETDIBITS 0x5B80
#define WERR_SETDIBITSTODEVICE 0x5BC0
#define WERR_CREATEMETAFILE 0x5C00
#define WERR_CLOSEMETAFILE 0x5C40
#define WERR_GETMETAFILE 0x5C80
#define WERR_DELETEMETAFILE 0x5CC0
#define WERR_COPYMETAFILE 0x5D00
#define WERR_PLAYMETAFILE 0x5D40
#define WERR_GETMETAFILEBITS 0x5D80
#define WERR_SETMETAFILEBITS 0x5DC0
#define WERR_SETMETAFILEBITSBETTER 0x5E00
#define WERR_PLAYMETAFILERECORD 0x5E40
#define WERR_ENUMMETAFILE 0x5E80
#define WERR_STARTDOC 0x5EC0
#define WERR_STARTPAGE 0x5F00
#define WERR_ENDPAGE 0x5F40
#define WERR_ENDDOC 0x5F80
#define WERR_ABORTDOC 0x5FC0
#define WERR_SETABORTPROC 0x6000
#define WERR_SPOOLFILE 0x6040
#define WERR_QUERYABORT 0x6080
#define WERR_ESCAPE 0x60C0
#define WERR_GETSYSTEMMETRICS 0x6100
#define WERR_GETDOUBLECLICKTIME 0x6140
#define WERR_SETDOUBLECLICKTIME 0x6180
#define WERR_SYSTEMPARAMETERSINFO 0x61C0
#define WERR_SETRECT 0x6200
#define WERR_SETRECTEMPTY 0x6240
#define WERR_COPYRECT 0x6280
#define WERR_ISRECTEMPTY 0x62C0
#define WERR_EQUALRECT 0x6300
#define WERR_INTERSECTRECT 0x6340
#define WERR_UNIONRECT 0x6380
#define WERR_SUBTRACTRECT 0x63C0
#define WERR_OFFSETRECT 0x6400
#define WERR_INFLATERECT 0x6440
#define WERR_PTINRECT 0x6480
#define WERR_REGISTERWINDOWMESSAGE 0x64C0
#define WERR_GETMESSAGE 0x6500
#define WERR_PEEKMESSAGE 0x6540
#define WERR_WAITMESSAGE 0x6580
#define WERR_GETMESSAGEPOS 0x65C0
#define WERR_GETMESSAGETIME 0x6600
#define WERR_GETMESSAGEEXTRAINFO 0x6640
#define WERR_TRANSLATEMESSAGE 0x6680
#define WERR_DISPATCHMESSAGE 0x66C0
#define WERR_SETMESSAGEQUEUE 0x6700
#define WERR_GETINPUTSTATE 0x6740
#define WERR_GETQUEUESTATUS 0x6780
#define WERR_POSTMESSAGE 0x67C0
#define WERR_SENDMESSAGE 0x6800
#define WERR_POSTAPPMESSAGE 0x6840
#define WERR_REPLYMESSAGE 0x6880
#define WERR_INSENDMESSAGE 0x68C0
#define WERR_CALLMSGFILTER 0x6900
#define WERR_POSTQUITMESSAGE 0x6940
#define WERR_REGISTERCLASS 0x6980
#define WERR_UNREGISTERCLASS 0x69C0
#define WERR_GETCLASSINFO 0x6A00
#define WERR_GETCLASSNAME 0x6A40
#define WERR_GETCLASSWORD 0x6A80
#define WERR_SETCLASSWORD 0x6AC0
#define WERR_GETCLASSLONG 0x6B00
#define WERR_SETCLASSLONG 0x6B40
#define WERR_ISWINDOW 0x6B80
#define WERR_CREATEWINDOWEX 0x6BC0
#define WERR_CREATEWINDOW 0x6C00
#define WERR_DESTROYWINDOW 0x6C40
#define WERR_GETWINDOWTASK 0x6C80
#define WERR_ISCHILD 0x6CC0
#define WERR_GETPARENT 0x6D00
#define WERR_SETPARENT 0x6D40
#define WERR_ISWINDOWVISIBLE 0x6D80
#define WERR_SHOWWINDOW 0x6DC0
#define WERR_ENABLEWINDOW 0x6E00
#define WERR_ISWINDOWENABLED 0x6E40
#define WERR_SETWINDOWTEXT 0x6E80
#define WERR_GETWINDOWTEXT 0x6EC0
#define WERR_GETWINDOWTEXTLENGTH 0x6F00
#define WERR_GETWINDOWWORD 0x6F40
#define WERR_SETWINDOWWORD 0x6F80
#define WERR_GETWINDOWLONG 0x6FC0
#define WERR_SETWINDOWLONG 0x7000
#define WERR_GETCLIENTRECT 0x7040
#define WERR_GETWINDOWRECT 0x7080
#define WERR_GETWINDOWPLACEMENT 0x70C0
#define WERR_SETWINDOWPLACEMENT 0x7100
#define WERR_SETWINDOWPOS 0x7140
#define WERR_BEGINDEFERWINDOWPOS 0x7180
#define WERR_DEFERWINDOWPOS 0x71C0
#define WERR_ENDDEFERWINDOWPOS 0x7200
#define WERR_MOVEWINDOW 0x7240
#define WERR_BRINGWINDOWTOTOP 0x7280
#define WERR_DEFWINDOWPROC 0x72C0
#define WERR_CALLWINDOWPROC 0x7300
//#define WERR_CALLWINDOWPROC 0x7340
#define WERR_ADJUSTWINDOWRECT 0x7380
#define WERR_ADJUSTWINDOWRECTEX 0x73C0
#define WERR_FLASHWINDOW 0x7400
#define WERR_SHOWOWNEDPOPUPS 0x7440
#define WERR_OPENICON 0x7480
#define WERR_CLOSEWINDOW 0x74C0
#define WERR_ANYPOPUP 0x7500
#define WERR_ISICONIC 0x7540
#define WERR_ISZOOMED 0x7580
#define WERR_CLIENTTOSCREEN 0x75C0
#define WERR_SCREENTOCLIENT 0x7600
#define WERR_MAPWINDOWPOINTS 0x7640
#define WERR_WINDOWFROMPOINT 0x7680
#define WERR_CHILDWINDOWFROMPOINT 0x76C0
#define WERR_GETDESKTOPWINDOW 0x7700
#define WERR_FINDWINDOW 0x7740
#define WERR_ENUMWINDOWS 0x7780
#define WERR_ENUMCHILDWINDOWS 0x77C0
#define WERR_ENUMTASKWINDOWS 0x7800
#define WERR_GETTOPWINDOW 0x7840
#define WERR_GETWINDOW 0x7880
#define WERR_GETNEXTWINDOW 0x78C0
#define WERR_SETPROP 0x7900
#define WERR_GETPROP 0x7940
#define WERR_REMOVEPROP 0x7980
#define WERR_ENUMPROPS 0x79C0
#define WERR_GETDC 0x7A00
#define WERR_RELEASEDC 0x7A40
#define WERR_GETWINDOWDC 0x7A80
#define WERR_GETDCEX 0x7AC0
#define WERR_BEGINPAINT 0x7B00
#define WERR_ENDPAINT 0x7B40
#define WERR_UPDATEWINDOW 0x7B80
#define WERR_EXCLUDEUPDATERGN 0x7BC0
#define WERR_LOCKWINDOWUPDATE 0x7C00
#define WERR_GETUPDATERECT 0x7C40
#define WERR_GETUPDATERGN 0x7C80
#define WERR_INVALIDATERECT 0x7CC0
#define WERR_VALIDATERECT 0x7D00
#define WERR_INVALIDATERGN 0x7D40
#define WERR_VALIDATERGN 0x7D80
#define WERR_REDRAWWINDOW 0x7DC0
#define WERR_SCROLLWINDOW 0x7E00
#define WERR_SCROLLDC 0x7E40
#define WERR_SCROLLWINDOWEX 0x7E80
#define WERR_SETACTIVEWINDOW 0x7EC0
#define WERR_GETACTIVEWINDOW 0x7F00
#define WERR_GETLASTACTIVEPOPUP 0x7F40
#define WERR_SETFOCUS 0x7F80
#define WERR_GETFOCUS 0x7FC0
#define WERR_GETKEYSTATE 0x8000
#define WERR_GETASYNCKEYSTATE 0x8040
#define WERR_GETKEYBOARDSTATE 0x8080
#define WERR_SETKEYBOARDSTATE 0x80C0
#define WERR_SETCAPTURE 0x8100
#define WERR_RELEASECAPTURE 0x8140
#define WERR_GETCAPTURE 0x8180
#define WERR_SWAPMOUSEBUTTON 0x81C0
#define WERR_GETSYSMODALWINDOW 0x8200
#define WERR_SETSYSMODALWINDOW 0x8240
#define WERR_SETTIMER 0x8280
#define WERR_KILLTIMER 0x82C0
#define WERR_LOADACCELERATORS 0x8300
#define WERR_TRANSLATEACCELERATOR 0x8340
#define WERR_ISMENU 0x8380
#define WERR_CREATEMENU 0x83C0
#define WERR_CREATEPOPUPMENU 0x8400
#define WERR_LOADMENU 0x8440
#define WERR_LOADMENUINDIRECT 0x8480
#define WERR_DESTROYMENU 0x84C0
#define WERR_GETMENU 0x8500
#define WERR_SETMENU 0x8540
#define WERR_GETSYSTEMMENU 0x8580
#define WERR_DRAWMENUBAR 0x85C0
#define WERR_HILITEMENUITEM 0x8600
#define WERR_INSERTMENU 0x8640
#define WERR_APPENDMENU 0x8680
#define WERR_MODIFYMENU 0x86C0
#define WERR_REMOVEMENU 0x8700
#define WERR_DELETEMENU 0x8740
#define WERR_CHANGEMENU 0x8780
#define WERR_ENABLEMENUITEM 0x87C0
#define WERR_CHECKMENUITEM 0x8800
#define WERR_GETSUBMENU 0x8840
#define WERR_GETMENUITEMCOUNT 0x8880
#define WERR_GETMENUITEMID 0x88C0
#define WERR_GETMENUSTRING 0x8900
#define WERR_GETMENUSTATE 0x8940
#define WERR_SETMENUITEMBITMAPS 0x8980
#define WERR_GETMENUCHECKMARKDIMENSIONS 0x89C0
#define WERR_TRACKPOPUPMENU 0x8A00
#define WERR_SETSCROLLPOS 0x8A40
#define WERR_GETSCROLLPOS 0x8A80
#define WERR_SETSCROLLRANGE 0x8AC0
#define WERR_GETSCROLLRANGE 0x8B00
#define WERR_SHOWSCROLLBAR 0x8B40
#define WERR_ENABLESCROLLBAR 0x8B80
#define WERR_OPENCLIPBOARD 0x8BC0
#define WERR_CLOSECLIPBOARD 0x8C00
#define WERR_EMPTYCLIPBOARD 0x8C40
#define WERR_GETOPENCLIPBOARDWINDOW 0x8C80
#define WERR_GETCLIPBOARDOWNER 0x8CC0
#define WERR_SETCLIPBOARDVIEWER 0x8D00
#define WERR_GETCLIPBOARDVIEWER 0x8D40
#define WERR_SETCLIPBOARDDATA 0x8D80
#define WERR_GETCLIPBOARDDATA 0x8DC0
#define WERR_ISCLIPBOARDFORMATAVAILABLE 0x8E00
#define WERR_GETPRIORITYCLIPBOARDFORMAT 0x8E40
#define WERR_REGISTERCLIPBOARDFORMAT 0x8E80
#define WERR_COUNTCLIPBOARDFORMATS 0x8EC0
#define WERR_ENUMCLIPBOARDFORMATS 0x8F00
#define WERR_GETCLIPBOARDFORMATNAME 0x8F40
#define WERR_CHANGECLIPBOARDCHAIN 0x8F80
#define WERR_LOADCURSOR 0x8FC0
#define WERR_CREATECURSOR 0x9000
#define WERR_DESTROYCURSOR 0x9040
#define WERR_COPYCURSOR 0x9080
#define WERR_SHOWCURSOR 0x90C0
#define WERR_SETCURSORPOS 0x9100
#define WERR_GETCURSORPOS 0x9140
#define WERR_SETCURSOR 0x9180
#define WERR_GETCURSOR 0x91C0
#define WERR_CLIPCURSOR 0x9200
#define WERR_GETCLIPCURSOR 0x9240
#define WERR_LOADICON 0x9280
#define WERR_CREATEICON 0x92C0
#define WERR_DESTROYICON 0x9300
#define WERR_COPYICON 0x9340
#define WERR_DRAWICON 0x9380
#define WERR_MESSAGEBOX 0x93C0
#define WERR_MESSAGEBEEP 0x9400
#define WERR_CREATECARET 0x9440
#define WERR_DESTROYCARET 0x9480
#define WERR_SETCARETPOS 0x94C0
#define WERR_GETCARETPOS 0x9500
#define WERR_HIDECARET 0x9540
#define WERR_SHOWCARET 0x9580
#define WERR_GETCARETBLINKTIME 0x95C0
#define WERR_SETCARETBLINKTIME 0x9600
#define WERR_DEFFRAMEPROC 0x9640
#define WERR_DEFMDICHILDPROC 0x9680
#define WERR_TRANSLATEMDISYSACCEL 0x96C0
#define WERR_ARRANGEICONICWINDOWS 0x9700
#define WERR_ISDIALOGMESSAGE 0x9740
#define WERR_DEFDLGPROC 0x9780
#define WERR_CREATEDIALOG 0x97C0
#define WERR_CREATEDIALOGINDIRECT 0x9800
#define WERR_CREATEDIALOGPARAM 0x9840
#define WERR_CREATEDIALOGINDIRECTPARAM 0x9880
#define WERR_DIALOGBOX 0x98C0
#define WERR_DIALOGBOXINDIRECT 0x9900
#define WERR_DIALOGBOXPARAM 0x9940
#define WERR_DIALOGBOXINDIRECTPARAM 0x9980
#define WERR_ENDDIALOG 0x99C0
#define WERR_GETDLGCTRLID 0x9A00
#define WERR_GETDLGITEM 0x9A40
#define WERR_SENDDLGITEMMESSAGE 0x9A80
#define WERR_SETDLGITEMINT 0x9AC0
#define WERR_GETDLGITEMINT 0x9B00
#define WERR_SETDLGITEMTEXT 0x9B40
#define WERR_GETDLGITEMTEXT 0x9B80
#define WERR_CHECKDLGBUTTON 0x9BC0
#define WERR_CHECKRADIOBUTTON 0x9C00
#define WERR_ISDLGBUTTONCHECKED 0x9C40
#define WERR_GETNEXTDLGGROUPITEM 0x9C80
#define WERR_GETNEXTDLGTABITEM 0x9CC0
#define WERR_MAPDIALOGRECT 0x9D00
#define WERR_GETDIALOGBASEUNITS 0x9D40
#define WERR_DLGDIRLIST 0x9D80
#define WERR_DLGDIRSELECT 0x9DC0
#define WERR_DLGDIRLISTCOMBOBOX 0x9E00
#define WERR_DLGDIRSELECTCOMBOBOX 0x9E40
#define WERR_DLGDIRSELECTEX 0x9E80
#define WERR_DLGDIRSELECTCOMBOBOXEX 0x9EC0
#define WERR_SETWINDOWSHOOK 0x9F00
#define WERR_DEFHOOKPROC 0x9F40
//#define WERR_SETWINDOWSHOOK 0x9F80
//#define WERR_DEFHOOKPROC 0x9FC0
#define WERR_UNHOOKWINDOWSHOOK 0xA000
#define WERR_SETWINDOWSHOOKEX 0xA040
#define WERR_UNHOOKWINDOWSHOOKEX 0xA080
#define WERR_CALLNEXTHOOKEX 0xA0C0
#define WERR_ENABLEHARDWAREINPUT 0xA100
#define WERR_QUERYSENDMESSAGE 0xA140
#define WERR_LOCKINPUT 0xA180
#define WERR_GETSYSTEMDEBUGSTATE 0xA1C0
#define WERR_WINHELP 0xA200
#define WERR_OPENSOUND 0xA240
#define WERR_CLOSESOUND 0xA280
#define WERR_STARTSOUND 0xA2C0
#define WERR_STOPSOUND 0xA300
#define WERR_SETVOICEQUEUESIZE 0xA340
#define WERR_SETVOICENOTE 0xA380
#define WERR_SETVOICEACCENT 0xA3C0
#define WERR_SETVOICEENVELOPE 0xA400
#define WERR_SETVOICESOUND 0xA440
#define WERR_SETVOICETHRESHOLD 0xA480
#define WERR_GETTHRESHOLDEVENT 0xA4C0
#define WERR_GETTHRESHOLDSTATUS 0xA500
#define WERR_SETSOUNDNOISE 0xA540
#define WERR_WAITSOUNDSTATE 0xA580
#define WERR_SYNCALLVOICES 0xA5C0
#define WERR_COUNTVOICENOTES 0xA600
#define WERR_BUILDCOMMDCB 0xA640
#define WERR_OPENCOMM 0xA680
#define WERR_CLOSECOMM 0xA6C0
#define WERR_READCOMM 0xA700
#define WERR_WRITECOMM 0xA740
#define WERR_UNGETCOMMCHAR 0xA780
#define WERR_FLUSHCOMM 0xA7C0
#define WERR_TRANSMITCOMMCHAR 0xA800
#define WERR_SETCOMMSTATE 0xA840
#define WERR_GETCOMMSTATE 0xA880
#define WERR_GETCOMMERROR 0xA8C0
#define WERR_SETCOMMBREAK 0xA900
#define WERR_CLEARCOMMBREAK 0xA940
#define WERR_SETCOMMEVENTMASK 0xA980
#define WERR_GETCOMMEVENTMASK 0xA9C0
#define WERR_ESCAPECOMMFUNCTION 0xAA00
#define WERR_ENABLECOMMNOTIFICATION 0xAA40
#define WERR_WVSPRINTF 0xAA80
#define WERR_DEFDRIVERPROC 0xAAC0
#define WERR_OPENDRIVER 0xAB00
#define WERR_CLOSEDRIVER 0xAB40
#define WERR_SENDDRIVERMESSAGE 0xAB80
#define WERR_GETDRIVERMODULEHANDLE 0xABC0
#define WERR_GETNEXTDRIVER 0xAC00
#define WERR_GETDRIVERINFO 0xAC40

#endif // _ERRORMOD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\inc\resexec.h ===
// Copyright (c) Microsoft Corp. 1994

// Resource Executor API

#ifndef _RESEXEC_
#define _RESEXEC_

#ifdef __cplusplus
extern "C" {
#endif

#ifdef IFBGPROC
#ifndef _BITMAP_
#define _BITMAP_

// Win 3.1 Bitmap
typedef struct
{
	int     bmType;
	int     bmWidth;
	int     bmHeight;
	int     bmWidthBytes;
	BYTE    bmPlanes;
	BYTE    bmBitsPixel;
	void FAR* bmBits;
}
	BITMAP, FAR *LPBITMAP;

#endif // _BITMAP_	
#endif // IFBGPROC

typedef struct
{
	WORD wReserved;
	WORD wSize;             // size of this block
	LPBYTE lpData;          // pointer to frame data
}
	FRAME, FAR *LPFRAME;

HANDLE                 // context handle (NULL on failure)
WINAPI hHREOpen
(
	LPVOID lpReserved,   // reserved: set to NULL
	UINT   cbLine,       // maximum page width in bytes
	UINT   cResDir       // entries in resource directory
);

UINT   WINAPI uiHREWrite (HANDLE, LPFRAME, UINT);

UINT   WINAPI uiHREExecute
(
	HANDLE   hRE,        // resource executor context
  LPBITMAP lpbmBand,   // output band buffer
  LPVOID   lpBrushPat  // array of 32x32 brush patterns
);

UINT   WINAPI uiHREClose (HANDLE);

void   WINAPI UnpackGlyphSet (LPVOID, LPVOID);

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _RESEXEC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\inc\version.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 ****************************************************************************/

#ifndef VS_FF_DEBUG
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#ifdef WIN32
#include <winver.h>
#else
#include <ver.h>
#endif
#endif

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/

#define VERSION                     "0.0.0"
#define VER_FILEVERSION_STR         "0.0.0\0"
#define VER_FILEVERSION             0,0,0,0
#define VER_PRODUCTVERSION_STR      "0.0.0\0"
#define VER_PRODUCTVERSION          0,0,0,0

// #define OFFICIAL
// #define FINAL

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\inc\ifaxos.h ===
#ifndef _INC_IFAXOS
#define _INC_IFAXOS

#ifdef __cplusplus
extern "C" {
#endif

// add SHIP_BUILD from Win95fax retail builds
#ifndef DEBUG
#ifdef WIN32
#define SHIP_BUILD
#endif
#endif

// -------------------------- Include Files ------------------------------------

#ifdef IFBGPROC
// Remove appropriate parts of windows.h
// #define NOKERNEL
#ifndef WANTGDI
#define NOGDI
#endif
// #define  NOUSER
#define NOSOUND
// #define  NOCOMM
// #define  NODRIVERS
// #define  NOMINMAX
// #define  NOLOGERROR
// #define  NOPROFILER
// #define  NOMEMMGR
// #define  NOLFILEIO
// #define  NOOPENFILE
// #define  NORESOURCE
// #define  NOATOM
// #define  NOLANGUAGE
// #define  NOLSTRING
// #define  NODBCS
#define NOKEYBOARDINFO
#define NOGDICAPMASKS
#define NOCOLOR
#ifndef WANTGDI
#define NOGDIOBJ
#define NOBITMAP
#endif
#define NODRAWTEXT
#define NOTEXTMETRIC
#define NOSCALABLEFONT
#define NORASTEROPS
#define NOMETAFILE
#define NOSYSMETRICS
#define NOSYSTEMPARAMSINFO
// #define NOMSG
#define NOWINSTYLES
#define NOWINOFFSETS
// #define  NOSHOWWINDOW
#define NODEFERWINDOWPOS
#define NOVIRTUALKEYCODES
#define NOKEYSTATES
#define NOWH
#define NOMENUS
#define NOSCROLL
#define NOCLIPBOARD
#define NOICONS
#define NOMB
#define NOSYSCOMMANDS
#define NOMDI
#define NOCTLMGR
#define NOWINMESSAGES
#define NOHELP
#endif

// put strict type checking on ... and get rid of multiple define warnings
#ifndef STRICT
#define STRICT
#endif

#ifndef WINDRV
#   ifdef WIN32
#       define _INC_OLE
#   endif
#   include <windows.h>
#  ifdef   WIN32
#      include <windowsx.h>
#  endif
#endif

#ifdef WIN32
#define DECLSPEC_IMPORT __declspec(dllimport)
#endif

#ifndef WIN32
// Define WINBASE to avoid mapi including some duplicate definitions
#define _WINBASE_
#endif

//-------------------------- General Defines ---------------------

#ifndef WIN32
#define STATIC  static
#define CONST   const
#define CHAR    char
#define UCHAR   BYTE
#define INT     int

typedef short    SHORT;
typedef unsigned long ULONG;
typedef unsigned short USHORT;
typedef CHAR    *PCHAR;
typedef VOID    *PVOID;
#endif

typedef CHAR    FAR *LPCHAR;
typedef CHAR    NEAR *NPCHAR;

#define CARRAIGE_RETURN 0x0D
#define LINEFEED 0x0A
#define BACKSPACE 0x08
#define CNULL   0x00

#ifndef WIN32
#ifndef MAKEWORD
#  define MAKEWORD(low, high) ((WORD)(((BYTE)(low)) | (((WORD)((BYTE)(high))) << 8)))
#endif
#  define EXPORT_DLL
#  define IMPORT_DLL
#else
#  ifndef HTASK
#     define HTASK HANDLE
#  endif
#  define __export __declspec( dllexport )
#  define _export  __declspec( dllexport )
#  define IMPORT_DLL __declspec( dllimport )
#  define EXPORT_DLL __declspec( dllexport )
#endif

// --------------- RESOURCE management -------------------------------

// Always define this for now ...
#ifndef SHIP_BUILD
// #if defined(VALIDATE) || defined(DEBUGAPI) || defined(DEBUG)

/********
    @doc    EXTERNAL    RESOURCE IFAXOS

    @type   VOID |  RESOURCE_ALLOC_FLAGS | Lists the resource management options
            for OS resource accounting.

    @emem   RES_ALLOC_TASK  |  This flag indicates that the resource in question
            is being allocated on behalf of the current process. The resource
            should not be directly passed on to any other process context. It
            should be freed by this process before termination - else the kernel
            will free it when the process dies (if running in debug).
            Ownership automatically gets transferred between tasks when standard
            IPC methods like pipes are used to transfer resources like Buffers.

    @emem   RES_ALLOC_NONE  | This flag is used to allocate resources which should
            not be accounted to any system module. The calling party essentially
            undertakes full responsibility for freeing this object. This is mainly
            to be used for resource allocated on behalf of messages in the store
            since their ownership is transferred to the current process which has
            the message open.

    @emem   HINSTANCE_DLL   | If the allocated resource is to be assigned to the
            calling DLL, the hinstance of the DLL should be passed in as the value
            of the ResourceFlags Word. These resources will be freed (in the debug
            version) when the DLL terminates. They will not be assigned to any
            particular process context.

    @xref   <f IFBufAlloc> <f IFMemAlloc> <f CreateMutex> <f CreateEvent>
            <f IFPipeCreate> <f IFProcSetResFlags>
********/

#define RES_ALLOC_TASK  0x0000
#define RES_ALLOC_NONE  0x0001
#define RES_ALLOC_INTERNAL  0x0002
#define RES_ALLOC_CRITSEC  0x0003

#if defined(WFW) || defined(WIN32)

#define IFProcSetResFlags(wResFlags)  (0)

#else

extern EXPORT_DLL VOID WINAPI IFProcSetResFlags(WORD wResFlags);

#endif

#else

#define IFProcSetResFlags(p1) (0)

#endif

// --------------- ERROR Handling ------------------------------------

#include <errormod.h>

/********
    @doc    EXTERNAL    ERROR   IFAXOS

    @api    DWORD    | IFErrAssemble   | Forms an IFAX Error dword out of its components.

    @parm   BYTE    | bProcessID    | Identifies the process in whose context the error
            occured. Must be one of the predefined system process ID's - see <t SYSTEM_PROCESSES>
            for the list. This field does not need to be filled in until an error is
            propagated across a process boundary. If not being set to a valid PROCID, this
            should be initilialized to one of the following values:
            @flag  PROCID_WIN32 | if <p bModuleID> is set to MODID_WIN32.
            @flag  PROCID_NONE | for all other cases.

    @parm   BYTE    | bModuleID | Identifies the module reporting the error. MUST be
            one of the predefined system module ID's - see <t SYSTEM_MODULES> for the
            list.

    @parm   WORD    | wApiCode  | Identifies the API code for the error in the module indicated
            by <p bModuleID>. All Api codes should be defined in the file errormod.h. Api codes should
            be defined so that the low 6 bits are zero. This allows both the <p wApiCode> and the
            <p wErrorCode> to be logical OR'ed together and stored as a single word.

    @parm   WORD    | wErrorCode    | Identifies the error code. The format
            of this is module dependent. For uniformity however, it is highly
            encouraged that all IFAX modules use a standard format for this error word.
            This standard format reserves the first 6 bits for an error code,
            and the high 10 bits for an API identifier.

            If the IFAX format is being used, the <p wApiCode>
            parameter should be used to pass in the high 10 bits, and the <p wErrorCode> (This
            parameter!) should be used to pass in the 6 bit error code. Values upto ERR_FUNCTION_START
            are reserved for standard system errors - see <t SYSTEM_ERROR_VALUES> for the list.
            Error values should be positive and less than 64.

            Other modules like the filesystem conform completely to the Win32 Error space. These
            should set <p wErrorCode> to standard Win32 errors (use all 16 bits) and leave
            the <p wApiCode> as API_WIN32.

            Still others need to use all 16 bits in a custom manner - like the Printer Drivers.
            These *must* set the <p bModuleID> correctly so that the error can be interpreted
            appropriately. Standard processes like the UI have to understand these error codes,
            so only inbuilt system modules which they have knowledge about can use custom codes.
            These should set the wApiCode to API_NONE.

    @rdesc  Returns the DWORD representation for this error. This allows this to be directly
            passed in as input to <f SetLastError>.

    @ex     Example usage |

            SetLastError(IFErrAssemble(PROCID_NONE,MODID_IFKERNEL,API_IFK_POSTMESSAGE,ERR_INVALID_PARAM));

    @xref   <f IFErrGetModule> <f IFErrGetProcess> <f GetIFErrorErrcode> <f SetLastError>
            <f GetIFErrorApicode> <t SYSTEM_MODULES> <t SYSTEM_PROCESSES> <t SYSTEM_ERROR_VALUES>
            <f GetLastError> <f IFNVRamSetError> <f GetIFErrorCustomErrcode>
********/

#define IFErrAssemble(process,module,call,error) \
    MAKELONG((WORD)call|(WORD)error, MAKEWORD((BYTE)module, (BYTE)process))

/*********
    @doc    EXTERNAL ERROR  IFAXOS

    @api    BYTE    | IFErrGetModule  | Retrieves the module ID from an IFAX Error.

    @parm   DWORD   | errvar    | The error value.

    @rdesc  Returns the module ID. This will be from the list specified in <t SYSTEM_MODULES>.

    @xref   <f IFErrAssemble> <t SYSTEM_MODULES> <f IFErrSetModule>

    @api    BYTE    | IFErrGetProcess  | Retrieves the process ID from an IFAX Error.

    @parm   DWORD   | errvar    | The error value.

    @rdesc  Returns the process ID. This will be from the list specified in <t SYSTEM_PROCESSES>.

    @xref   <f IFErrAssemble> <t SYSTEM_PROCESSES> <f IFErrSetProcess>

    @api    WORD    | GetIFErrorErrcode  | Retrieves the error code from an IFAX Error.

    @parm   DWORD   | errvar    | The error value.

    @rdesc  Returns the error code. If less than ERR_FUNCTION_START, this is from the list
            in <t SYSTEM_ERROR_VALUES>.

    @xref   <f IFErrAssemble> <t SYSTEM_ERROR_VALUES>

    @api    WORD    | GetIFErrorCustomErrcode  | Retrieves a custom 16 bit error code from an IFAX Error.

    @parm   DWORD   | errvar    | The error value.

    @rdesc  Returns the error code. This might be a Win32 error code if the module ID was
            MODID_WIN32, or a custom error code.

    @xref   <f IFErrAssemble> <t SYSTEM_ERROR_VALUES>

    @api    WORD    | GetIFErrorApicode  | Retrieves the API code from an IFAX Error.

    @parm   DWORD   | errvar    | The error value.

    @rdesc  Returns the API code. API codes for all the system modules are documented in
            the file errormod.h

    @xref   <f IFErrAssemble> <t SYSTEM_MODULES>

    @api    DWORD    | IFErrSetModule  | Sets the module ID in an IFAX Error.

    @parm   DWORD   | errvar    | The error value. It's value is not changed by the call.

    @parm   BYTE    | bModule   | The module ID to be set from the list in <t SYSTEM_MODULES>.

    @rdesc  Returns the DWORD representation of the new error code.

    @xref   <f IFErrAssemble> <t SYSTEM_MODULES> <f IFErrGetModule>

    @api    DWORD    | IFErrSetProcess  | Sets the Process ID in an IFAX Error.

    @parm   DWORD   | errvar    | The error value. Its value is not changed by the call.

    @parm   BYTE    | bProcess   | The Process ID to be set from the list in <t SYSTEM_PROCESSES>.

    @rdesc  Returns the DWORD representation of the new error code.

    @xref   <f IFErrAssemble> <t SYSTEM_PROCESSES> <f IFErrGetProcess>

********/
#define IFErrSetModule(errvar,module)  \
    MAKELONG(LOWORD((DWORD)errvar),MAKEWORD((BYTE)module, HIBYTE(HIWORD((DWORD)errvar))))
#define IFErrSetProcess(errvar,process)    \
    MAKELONG(LOWORD((DWORD)errvar),MAKEWORD(LOBYTE(HIWORD((DWORD)errvar)), (BYTE)process))
#define IFErrGetModule(errvar)    LOBYTE(HIWORD((DWORD)errvar))
#define IFErrGetProcess(errvar)   HIBYTE(HIWORD((DWORD)errvar))
#define GetIFErrorErrcode(errvar)   (LOWORD((DWORD)errvar) & 0x003F)
#define GetIFErrorApicode(errvar)   (LOWORD((DWORD)errvar) & 0xFFC0)
#define GetIFErrorCustomErrcode(errvar) LOWORD((DWORD)errvar)

/********
   @doc    EXTERNAL    DEFINES     ERROR   IFAXOS

    @type   VOID | SYSTEM_MODULES  | Identifiers for all the standard system modules.

    @emem   MODID_NONE          | Use this if you are not setting the module ID. DONT USE ZERO !!
    @emem   MODID_WIN32         | Set for modules returning standard Win32 system error codes
    @emem   MODID_BOSS          | ID = 1    Error in BOSS
    @emem   MODID_WINMODULE     | ID = 2    All windows modules including UER/GDI/KERNEL
    @emem   MODID_IFKERNEL      | ID = 3
    @emem   MODID_IFFILESYS     | ID = 4
    @emem   MODID_MSGSTORE      | ID = 5
    @emem   MODID_LINEARIZER    | ID = 6
    @emem   MODID_SECURITY      | ID = 7
    @emem   MODID_IFPRINT       | ID = 8    High level Printer Driver
    @emem   MODID_IFSCAN        | ID = 9    High level Scanner Driver
    @emem   MODID_IFSIPX        | ID = 10   SPX/IPX Stack
    @emem   MODID_REND_SERVER   | ID = 11   Rendering Server
    @emem   MODID_FORMAT_RES    | ID = 12   Format Resolution
    @emem   MODID_IFFILE        | ID = 13   IFFiles
    @emem   MODID_TEXTRENDERER  | ID = 14   Ascii Renderer
    @emem   MODID_DIGCOVPAGE    | ID = 15   Digital Coverpage
    @emem   MODID_AWBRANDER     | ID = 16   Fax Brander
    @emem   MODID_MSGSVR        | ID = 17   Message Server
    @emem   MODID_MSGHNDLR      | ID = 18  Per-Connection message handler
    @emem   MODID_MODEMDRV      | ID = 19  Modem driver
    @emem   MODID_PSIFAX       | ID = 20   PSI Fax protocol
    @emem   MODID_AWT30            | ID = 21   
    @emem   MODID_PSIFAXBG     | ID = 22
    @emem   MODID_AWNSF            | ID = 23
    @emem   MODID_FAXCODEC      | ID = 24
    @emem   MODID_MSGPUMP       | ID = 25
    @emem   MODID_AWREPORT      | ID = 26
    @emem   MODID_MSGSVRD		| ID = 27


    @emem   MODID_CUSTOM        | ID = 160  Beyond this are custom/installable modules

    @xref   <f IFErrAssemble> <f IFErrGetModule>
********/
// System Module IDs
#define MODID_WIN32         0
#define MODID_BOSS          1
#define MODID_WINMODULE     2
#define MODID_IFKERNEL      3
#define MODID_IFFILESYS     4
#define MODID_MSGSTORE      5
#define MODID_LINEARIZER    6
#define MODID_SECURITY      7
#define MODID_IFPRINT       8
#define MODID_IFSCAN        9
#define MODID_IFSIPX        10
#define MODID_REND_SERVER   11
#define MODID_FORMAT_RES    12
#define MODID_IFFILE        13
#define MODID_TEXTRENDERER  14
#define MODID_DIGCOVPAGE    15
#define MODID_AWBRANDER     16
#define MODID_MSGSVR        17
#define MODID_MSGHNDLR      18
#define MODID_MODEMDRV     19
#define MODID_PSIFAX       20
#define MODID_AWT30            21  
#define MODID_PSIFAXBG     22
#define MODID_AWNSF            23
#define MODID_FAXCODEC      24
#define MODID_MSGPUMP       25
#define MODID_AWREPORT      26
#define MODID_MSGSVRD		27

#define MAXMODID              26

#define MODID_NONE          159

// Special module ID's
#define MODID_CUSTOM        160

// Strings used in debug version for friendly display
#define SYSMODULESTRINGS   \
    { "Win32", "Boss", "Windows", "IFKernel", "FileSystem", "Msg Store", "Linearizer",    \
      "Security", "HLPrintDriver", "HLScanDriver", "IPX/SPX", "RendServer", \
      "Format Res", "IFFile", "AsciiRenderer","DigCovPage","AWBrander", \
      "Msg Server", "Msg Handler", "Modem Driver", "PSIFAX", "AWT30",  \
     "PSIFAXBG", "AWNSF", "Fax Codec", "Msg Pump" , "Awreport" \
    }

/********
   @doc    EXTERNAL    DEFINES     ERROR   IFAXOS

    @type   VOID | SYSTEM_PROCESSES  | Identifiers for all the standard system processes.

    @emem   PROCID_WIN32        | Used to initialize for Win32 modules.
    @emem   PROCID_NONE         | Used when process context does not need to be set.
    @emem   PROCID_MSGSCHED     | ID = 0x21
    @emem   PROCID_JOBPROCESS   | ID = 0x22
    @emem   PROCID_UI           | ID = 0x23
    @emem   PROCID_PRINTER      | ID = 0x24
    @emem   PROCID_SCANNER      | ID = 0x25
    @emem   PROCID_MSGSVR       | ID = 0x26
    @emem   PROCID_GRRENDER     | ID = 0x27
    @emem   PROCID_MSGHNDLR     | ID = 0x28
    @emem   PROCID_PARADEV 		| ID = 0x29
    @emem   PROCID_UIBGPROC 	| ID = 0x30

    @comm   All Process ID's need to have the 6th bit set to be compatible with the
            standard Win32 error definitions.

    @xref   <f IFErrAssemble> <f IFErrGetProcess>
********/
// System Process IDs
#define PROCID_WIN32           0x00
#define PROCID_NONE            0x20
#define PROCID_MSGSCHED        0x21
#define PROCID_JOBPROCESS      0x22
#define PROCID_UI              0x23
#define PROCID_PRINTER         0x24
#define PROCID_SCANNER         0x25
#define PROCID_MSGSVR          0x26
#define PROCID_GRRENDER        0x27
#define PROCID_MSGHNDLR        0x28
#define PROCID_PARADEV         0x29
#define PROCID_UIBGPROC		   0x30	

// Strings used in debug version for friendly display
#define MAXPROCID  11
#define SYSPROCESSSTRINGS       \
    {"None", "Msg Scheduler", "Job Process", "UI Process", "Printer", "Scanner", \
     "Msg Transport", "GR Renderer", "Msg Handler", "Para Dev", "UIBGProc"  }

/********
   @doc    EXTERNAL    DEFINES     ERROR   IFAXOS

   @type   VOID | SYSTEM_ERROR_VALUES | This defines all the standard
           system error values.

   @emem   ERR_NOT_ENOUGH_MEM | Value = 0x0001 : Indicates an out of memory
           condition.

   @emem   ERR_INVALID_PARAM | Value = 0x0002 : Indicates that any one of
           the parameters passed to the function was invalid.

   @emem   ERR_FUNCTION_START | Value = 0x0010 : Any error value above this
           had been custom defined by the called function. If you need
           a custom error value, you can define it starting from this
           value.

   @xref   <f IFErrAssemble>
********/

// System Error values
#define ERR_NOT_ENOUGH_MEM  0x0001
#define ERR_INVALID_PARAM   0x0002
#define ERR_FUNCTION_START  0x0010

// Strings used in debug version for friendly display
#define SYSERRORSTRINGS \
    {"None", "Out Of Memory", "Invalid Param", "Unused", "Unused", "Unused",  \
    "Unused", "Unused", "Unused", "Unused", "Unused", "Unused", \
    "Unused", "Unused", "Unused", "Unused" }

// Functions

#if !defined(SHIP_BUILD) && !defined(WIN32)
VOID WINAPI RestoreLastError (DWORD dwErrVal);
#else
#define RestoreLastError(dw) SetLastError(dw)
#endif

#ifndef WIN32
VOID WINAPI SetLastError (DWORD dwErrVal);
DWORD WINAPI GetLastError (VOID);
#endif


//----------------------------- MESSAGING -------------------------

// Message type definitions  - below 0x0400 is reserved by windows,
// between 0x0400 and 0x0800 is reserved by the IFAX OS

#define IF_START        WM_USER+0x0300

#define IF_TASK_START   IF_START+0x0001
#define IF_TASK_END     IF_START+0x0020
#define IF_DEBUG_START  IF_START+0x0021
#define IF_DEBUG_END    IF_START+0x0040
#define IF_PIPES_START  IF_START+0x0041
#define IF_PIPES_END    IF_START+0x0060
#define IF_TIMER_START  IF_START+0x0081
#define IF_TIMER_END    IF_START+0x0090
#define IF_USER         IF_START+0x0400
//messages for printer and scanner
#define IF_SCANNER_START IF_START+0x0200
#define IF_SCANNER_END   IF_START+0x0220
//messages for the graphics renderer
#define    IF_GRRENDER_START   IF_START+0x0221
#define    IF_GRRENDER_END     IF_START+0x0230
//messages for the faxcodec renderer
#define    IF_FAXREND_START    IF_START+0x0231
#define    IF_FAXREND_END      IF_START+0x0235
//messages for the message pump
#define IF_MSGPUMP_START (IF_START+0x0250)
#define IF_MSGPUMP_END   (IF_START+0x029F)
//messages for devices
#define IF_DEVICE_START (IF_START+0x02B0)
#define IF_DEVICE_END   (IF_START+0x02CF)
// Message for UI Init
#define IF_UI_START        (IF_START+0x2F0)
#define IF_UI_END      (IF_START+0x300)
// Status
#define IF_STATUS_START    (IF_START+0x301)
#define IF_STATUS_END   (IF_START+0x310)
// Config
#define IF_CONFIG_START    (IF_START+0x311)
#define IF_CONFIG_END   (IF_START+0x320)
// Modem
#define IF_MODEM_START (IF_START+0x321)
#define IF_MODEM_END   (IF_START+0x325)
// PSIBG
#define IF_PSIBG_START (IF_START+0x330)
#define IF_PSIBG_END   (IF_START+0x339)
// PSIFAX
#define IF_PSIFAX_START    (IF_START+0x340)
#define IF_PSIFAX_END      (IF_START+0x349)
// MSGSVR
#define IF_MSGSVR_START  (IF_START+0x350)
#define IF_MSGSVR_END    (IF_START+0x369)
// OEM
#define IF_OEM_START    (IF_START+0x370)
#define IF_OEM_END      (IF_START+0x379)
// SOS
#define IF_SOS_START    (IF_START+0x380)
#define IF_SOS_END      (IF_START+0x38F)
// uiutil
#define IF_UU_START     (IF_START+0x390)
#define IF_UU_END       (IF_START+0x39F)
// parallel device
#define IF_PD_START     (IF_START+0x3A0)
#define IF_PD_END       (IF_START+0x3BF)
// RPC layer
#define IF_RPC_START     (IF_START+0x3C0)
#define IF_RPC_END       (IF_START+0x3CF)
//UIBGProc
#define IF_UIBGPROC_START (IF_START+0x3D0)
#define IF_UIBGPROC_END	  (IF_START+0x3DF)	
// services
#define IF_SERVICE_START  (IF_START+0x3E0)
#define IF_SERVICE_END    (IF_START+0x3EF)


/********
   @doc    EXTERNAL    MESSAGES    PROCESS IFAXOS

   @msg    IF_INIT_STATUS |   This message should be posted by all devices
           after initialization is complete to indicate success/failure.
           Typically, the device process will send an IF_INIT_STATUS
          message for every device it initializes and one for its own
          initilization. This message should be posted to the UISHELL
          process. Use <f IFProcGetInfo> to obtain the appropriate window handle.

   @parm   WPARAM  | wParam    | 16 bit device error.
   @parm   LPARAM  | lParam    | Is formed as MAKELPARAM(MAKEWORD
       (ucInitStatus,ucMinorDevId),MAKEWORD(ucMajorDevId,ucProcId))    
   @flag   INIT_NO_ERROR   |   There was no error.
   @flag   INIT_FATAL_ERROR|   There was a fatal error. System should reboot.
   @flag   INIT_WARNING_ERROR  | There were some errors, but the system doesnt need
           to reboot.

   @parm   LPARAM  | lParam    | Contains a standard IFAX Error code. See
           <f IFErrAssemble> for details.

   @xref   <f IFProcGetInfo> <f IFErrAssemble>
********/
#define INIT_NO_ERROR      0x00
#define INIT_FATAL_ERROR   0x01
#define INIT_WARNING_ERROR 0x02

#define IF_INIT_STATUS     IF_UI_START
/********
   @doc    EXTERNAL    MESSAGES    PROCESS IFAXOS
   @msg    IF_DEVREINIT |   This message will be posted by the uishell to
           device process that handle user errors if the initialization
           fails due to user errors.

   @parm   WPARAM  | wParam    | MAKEWORD(ucMinorDevId,ucMajorDevId)

   @xref   <f IFProcGetInfo> <f IFErrAssemble>
********/

#define    IF_DEVREINIT    IF_UI_START+1

// Functions --------
BOOL WINAPI BroadcastMessage (UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL WINAPI BroadcastMessageEx (UINT uMsg, WPARAM wParam, LPARAM lParam);

// Dispatch message for BG Procs
/********
   @doc    EXTERNAL    MESSAGE     MACROS  IFAXOS

   @api    VOID    |   DispatchMessage | Dispatches a message to your
           windows procedure.

   @parm   LPMSG   | lpMsg |   Ptr to a message struct which is to be
           dispatched. This parameter *must* be &msg for all IFAX
           background processes - i.e you must have a declared variable
           called "msg" into which you have previsouly retrieved the
           message using <f GetMessage>.

   @comm   This function dispatches a message to your windows procedure.
           For foreground processes this works exactly the way the standard
           Windows DispatchMessage works. For background processes
           (which dont have any explicit windows) the message is sent to
           a procedure called BGWindowProc. You *must* have a callback
           defined as this - see BGWindowProc for details.

   @cb     LRESULT  BGCALLBACK |   BGWindowProc    | This is the window procedure
           for all IFAX background processes. The functions *must* be called
           by this exact name. This callback is not relevant for foreground
           processes.

   @parm   HWND    | hwnd  | contains the handle of the window to which the
           message is being dispatched. For Background processes this will always
           be the same as that returned from <f IFProcGetInfo>.

   @parm   UINT    | message | the message id

   @parm   WPARAM  | wParam | the first parameter associated with the message

   @parm   LPARAM  | lParam    | The second parameter associated with the message

   @rdesc  The return value depends on the message being processed.

   @comm   A protoype for this is already declared in ifaxos.h. You should
           process all your messages inside this window procedure. Your
           main application loop should thus look like

           while (GetMessage(&msg,NULL,0,0))
           {
               DispatchMessage(&msg);
           }
           return;

           You should *not* export this procedure in your .def file.

   @xref   <f GetMessage>
********/

#ifdef IFBGPROC
#define DispatchMessage(pmsg)   BGWindowProc((pmsg)->hwnd,(pmsg)->message,(pmsg)->wParam,(pmsg)->lParam)
#define BGCALLBACK PASCAL
LRESULT BGCALLBACK BGWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
#endif

//----------------------------- TASK MANAGEMENT--------------------
/********
   @doc    EXTERNAL    PROCESS     MACROS  IFAXOS

   @api    VOID    |   ENTER_INT_CRIT_SECTION  | Macro to enter
           an interrupt critical section.

   @comm   This is an inline assembly macro which turns interrupts
           off. Needless to say, this must be used with extreme
           caution. There must be a matching call to
           <f EXIT_INT_CRIT_SECTION>. Nested pairs of calls
           to these are permitted as long as they are not within the
          same invocation of the function. The function relies on
          being able to save the previous state of the flags in a
          unique local variable called __wIntFlags.
           This might affect some optimization options in your
           function due to being inline assembly. You might want to
           declare a local function which calls this macro internally.
           This way you can get global optimzations in the calling
           functions.

   @xref   <f EXIT_INT_CRIT_SECTION>  <f IFProcEnterCritSec>
           <f IFProcExitCritSec>
********/


// Macros --------
#define ENTER_INT_CRIT_SECTION  \
   {   \
   _asm pushf  \
   _asm cli    \
   _asm pop __wIntFlags    \
   }

/********
   @doc    EXTERNAL    PROCESS     MACROS  IFAXOS

   @api    VOID    |   EXIT_INT_CRIT_SECTION   | Macro to exit
           an interrupt critical section.

   @comm   This is an inline assembly macro which sets the interrupt
           flag state back to its state before the last call to
           <f ENTER_INT_CRIT_SECTION>. This function relies    on the
          appropriate flags to have been saved in a local variable
          with the name __wIntFlags.

   @xref   <f ENTER_INT_CRIT_SECTION> <f IFProcEnterCritSec>
           <f IFProcExitCritSec>
********/

// defined this way so that it works with windows enhanced mode
// refer guide to programming pg 14-15
#define EXIT_INT_CRIT_SECTION   \
   {   \
   _asm mov ax, __wIntFlags    \
   _asm test ah,2      \
   _asm jz $+3     \
   _asm sti            \
   _asm NOP            \
   }

/********
    @doc    EXTERNAL    DEFINES     ERROR   IFAXOS

    @type   VOID | PRIORITY DEFINES  | System defined priority levels
    @emem   PROC_PRIORITY_CRITICALRT | This should be used very sparingly
            for tasks which have very critical real time constraints (less
            than 200ms). These processes should typically be very low bandwidth
            since they can easily starve other processes. 
    @emem   PROC_PRIORITY_HIGHRT | Tasks with latency requirements of less than
            a second. Should not be high bandwidth to avoid starvation of processes.
    @emem   PROC_PRIORITY_MEDRT | Tasks with latency requirements of 1-3 secs.
            Should not be high bandwidth to avoid starvation of processes.
    @emem   PROC_PRIORITY_LOWRT | Tasks with latencies of 3-30secs. Should not
            be high bandwidth. 
    @emem   PROC_PRIORITY_DEFAULT | The default priority tasks start out at. These
            processes have none or very low real time requirements. They should
            in general not have high bandwidth. 
    @emem   PROC_PRIORITY_NONRT_USERVISIBLE | Non real time tasks which have visibility
            at the user level. Can be high bandwidth. An example on a fax machine is
            a copy job.
    @emem   PROC_PRIORITY_NONRT_USERHIDDEN | Non real time tasks which have very little
            visibility at the user level. Examples on a fax machine are local jobs 
            not involving devices. Can be high bandwidth.
    @comm   Processes should be VERY careful in setting their priorities. The way the 
            current scheduling works it is very easy to cause starvation of low 
            priority processes. In particular, processes which are "high bandwidth" - ie
            those which can consume huge amounts of CPU time if given, should be very
            careful - and should in general be at a priority level lower than the default.
            Processes higher than the default should have some sontrols on how much cpu
            time they can use up. On the fax machine, such controls are mostly in the form
            of device througputs - like the phone line.
    @xref   <f IFProcSetPriority> <f IFProcGetPriority>
********/
#define PROC_PRIORITY_MIN               31
#define PROC_PRIORITY_MAX               1
#define PROC_PRIORITY_CRITICALRT        3
#define PROC_PRIORITY_HIGHRT            6
#define PROC_PRIORITY_MEDRT             9
#define PROC_PRIORITY_LOWRT             12
#define PROC_PRIORITY_DEFAULT           15
#define PROC_PRIORITY_NONRT_USERVISIBLE   18
#define PROC_PRIORITY_NONRT_USERHIDDEN    21

#define UAE_BOX                 0
#define NO_UAE_BOX              1

///// Specific priorities used by standard processes 	   ////
//
// We want the following relations to hold
// 	PSIFAXBG > everything else, cause it's low-latency, low-bandwidth
//	ModemJob related (med bandwidth) > all other high/med bandwith jobs
//  DeviceJob related (high bandwidth, NO latency reqs) < all other jobs except Spool jobs
//  SpoolJobs (high bandwidth NO latency reqs, not user-visible) < everything
//  MSCHED is as high as ModemJob prio when it is on critical path, otherwise
//		it stays at default. Higher than Dev & Spool jobs, lower than all else
//  COMMSRV (pretty low latency reqs, high bandwidth) is slightly higher than
//		default (Higher than MSCHED & Dev/Spool jobs, lower than modem jobs)
//  RPCHNDLR (pretty lax latency reqs, high bandwidth) dynamic
//		Same prio as MSCHED while working, same as COMMSRV during accept
//  MSGSVR & RPCSRV (lowish latency reqs, very low bandwidth) roundrobin
//		with ModemJob, higher than all else
//  REPORT bg proc slightly lower than default.

// PSIFAXBG prio is highest
#define PRIO_PSIFAXBG_ACTIVE    PROC_PRIORITY_CRITICALRT
#define PRIO_PSIFAXBG_IDLE      PROC_PRIORITY_DEFAULT
// ModemJob is 2nd highest
#define PRIO_MODEMJOB           PROC_PRIORITY_MEDRT
// Spooljob is LOWEST, Device jobs are second lowest 
#define PRIO_SPOOLJOB           PROC_PRIORITY_NONRT_USERHIDDEN
#define PRIO_DEVICEJOB          PROC_PRIORITY_NONRT_USERVISIBLE
// PSINET jobs are same prio as SPOOL jobs
#define PRIO_PSINETJOB          PRIO_SPOOLJOB
// MSCHED's prio when it is NOT on a MODEMJOB critical path
#define PRIO_MSCHED         	PROC_PRIORITY_DEFAULT
// COMMSRV is between MODEMJOB & MSCHED
#define PRIO_COMMSRV            PROC_PRIORITY_LOWRT
// RPCHNDLR is same as MSCHED while working
#define PRIO_RPCHNDLR_ACCEPT    PROC_PRIORITY_LOWRT
#define PRIO_RPCHNDLR_WORKING   PROC_PRIORITY_DEFAULT
// RPCSRV is same as MODEMJOB. It should NOT consume much CPU at this level!
#define PRIO_RPCSRV             PROC_PRIORITY_MEDRT
// MSGSVR is same as MODEMJOB, except when processing recovery msgs
#define PRIO_MSGSVR_WAITMSG     PROC_PRIORITY_MEDRT
#define PRIO_MSGSVR_RECOVERY    PROC_PRIORITY_NONRT_USERVISIBLE
// Report process is real low prio when doing background info assimilation
// slightly higher when doing work on user request.
#define PRIO_UIBGPROC			PROC_PRIORITY_NONRT_USERHIDDEN
#define PRIO_UIBGPROC_USERREQUEST PROC_PRIORITY_NONRT_USERVISIBLE

/********
   @doc    EXTERNAL    MESSAGES    PROCESS IFAXOS

   @msg    IF_QUIT |   This is the message which forces <f GetMessage>
           to return FALSE causing the process to exit its main message
           processing loop and terminate. Typically a process should
           post itself this message in response to a <m IF_EXIT> message.

   @parm   WPARAM  | wParam    | NULL

   @parm   LPARAM  | lParam    | NULL

   @rdesc  none

   @xref   <m IF_EXIT>

   @msg    IF_EXIT | This message is sent to a process to request it
           to terminate. An application should clean up any resources
           it has allocated and then post itself a <m IF_QUIT> message
           directly.

   @parm   WPARAM  | wParam    | NULL

   @parm   LPARAM  | lParam    | NULL

   @rdesc  none

   @xref   <m IF_QUIT>
********/

// Messages
#define IF_QUIT     IF_TASK_START
#define IF_EXIT     IF_TASK_START+1

// Functions -----------
#ifndef WIN32
HTASK   WINAPI GetWindowTask(HWND hwnd);
#ifndef SHIP_BUILD
DWORD   WINAPI IFProcProfile(HTASK hTask, BOOL fStart);
#else
#define IFProcProfile(HTASK,FSTART) (0)
#endif
#else
// Remove calls to Profile ..
#define IFProcProfile(x,y)    (DWORD)(0)
#endif

HTASK WINAPI IFProcCreate (LPSTR lpszAppName, UINT fuCmdShow);
VOID WINAPI IFProcTerminate (HTASK hTask, WORD wFlags);
VOID WINAPI IFProcEnterCritSec(VOID);
VOID WINAPI IFProcExitCritSec(VOID);
BOOL WINAPI IFProcChangeToFG(VOID);
BOOL WINAPI IFProcChangeToBG(VOID);
HWND    WINAPI IFProcGetInfo (HTASK FAR *lphTask, LPSTR lpszModule, HINSTANCE FAR *lphInst);
BOOL    WINAPI IFProcRegisterWindow (HWND hwnd);
WORD    WINAPI IFProcGetPriority (HTASK hTask);
BOOL    WINAPI IFProcSetPriority (HTASK hTask, WORD wPriority);

#ifndef NOBUFFERS
//----------------------------- BUFFERS -------------------------

// Moved BUFFER typedef and standard meta-data values to buffers.h! -RajeevD
#include <buffers.h>

#ifdef VALIDATE
#define BUF_SENTINELPOS 30
#endif

// Error values
#define ERR_DATA_SMALL      ERR_FUNCTION_START

// Functions
extern EXPORT_DLL LPBUFFER WINAPI IFBufAlloc (LONG lBufSize);
extern EXPORT_DLL BOOL WINAPI IFBufFree (LPBUFFER lpbf);
extern EXPORT_DLL LPBUFFER WINAPI IFBufMakeWritable (LPBUFFER lpbf);
extern EXPORT_DLL LPBUFFER WINAPI IFBufShare (LPBUFFER lpbf);
extern EXPORT_DLL LPBUFFER WINAPI IFBufSplit (LPBUFFER lpbf, LPBYTE lpb);


//----------------------------- PIPES ----------------------------

#ifndef WIN32

// types
typedef  struct _PIPE NEAR *HPIPE;

// Parameter
#define IFPIPE_READ_MODE    0x0001
#define IFPIPE_WRITE_MODE   0x0002
#define REQREAD_REMOVE_DATA 0x0003
#define REQREAD_NOREMOVE_DATA   0x0004

// Error values
#define ERR_TOO_MANY_OPENS          ERR_FUNCTION_START
#define ERR_TOO_MANY_PENDING_WRITES ERR_FUNCTION_START+1
#define ERR_PIPE_STILL_OPEN         ERR_FUNCTION_START+2

/********
   @doc    EXTERNAL    MESSAGES    IFPIPES IFAXOS

   @msg    IF_PIPE_DATA_WRITTEN | This message is sent to notify a process
           that a previous write request using <f IFPipeReqWrite> has
           been successfully concluded. On reciept of this message the
           process can issue another write request on the same pipe.

   @parm   WPARAM  | wParam    | The <p wContext> parameter passed to the
            <f IFPipeOpen> call.

   @parm   LPARAM  | lParam    | NULL

   @rdesc  none

   @xref   <f IFPipeReqWrite>

   @msg    IF_PIPE_DATA_ARRIVED | This message is sent to a process which
           previsouly issued a read request to a pipe, intimating it that
           the buffer it requested is now available.

   @parm   WPARAM  | wParam    | The <p wContext> parameter passed to the
            <f IFPipeOpen> call.

   @parm   LPARAM  | lParam    | Contains a far ptr to a <t BUFFER> structure
           which has the requested data. On receipt of this message the process
           can issue another read request on the same pipe.

   @rdesc  none

   @xref   <f IFPipeReqRead>
********/

// Messages
#define IF_PIPE_DATA_WRITTEN    IF_PIPES_START
#define IF_PIPE_DATA_ARRIVED    IF_PIPES_START+1

// Functions
HPIPE WINAPI IFPipeCreate (WORD wSize);
BOOL WINAPI IFPipeDelete (HPIPE hpipe);
BOOL WINAPI IFPipeOpen (HPIPE hPipe, HWND hwnd, WORD wMode, WPARAM wContext);
BOOL WINAPI IFPipeClose (HPIPE hPipe, WORD wMode);
BOOL WINAPI IFPipeReqRead (HPIPE hPipe, WORD fwRemove);
BOOL WINAPI IFPipeReqWrite (HPIPE hPipe, LPBUFFER lpbf);
BOOL WINAPI IFPipeGetInfo (HPIPE hPipe, LPWORD lpwSize, LPWORD lpwcBufs);

#else // !WIN32

DECLARE_HANDLE32(HPIPE);

#endif // !WIN32

#endif // NOBUFFERS

//----------------------------- DEBUG SERVICES -------------------------

// Debug typedefs. These dont do any harm to anyone. Define them if there is
// anyone who might need them.

#if defined(DEBUG) || defined(IFKINTERNAL)

/********
   @doc    EXTERNAL    DATATYPES   DEBUG   IFAXOS

   @types  DBGPARAM    |   Structure containing the debug
           settings for any module in the system.

   @field  CHAR[32]    |   lpszName    | Specifies the name of the module.
           This is how your module will appear in the IFAX controller. Must
           be less than 32 characters long, and NULL terminated.

   @field  HWND    |   hwnd    | Specifies the primary window handle associated with
           this module IF the module is a process. For DLL's this value should
           always be NULL. Background processes should set it to their own ID using
           <f IFProcGetInfo> and <f GetCurrentTask> at initialization time.
           Foreground processes should set it to the window handle of their client
           window.

   @field  CHAR[16][32]    | rglpszZones   |   Stores a list of 16 strings
           which describe the zones associated with the lower 16 bits of
           zone mask. The module must decide and define its own zones for these
           bits - any bits not used should be left as "Not Used". These strings
           will be displayed by the IFAX controller to assist users in choosing
           the zones to be set for your module. Each string should not be more
           than 32 characters long, and should be NULL terminated.

   @field  ULONG   |   ulZoneMask  |   This is the mask which stores the
           current zone settings for the module. The IFAX controller will
           set this field according to what the user specifies. This field
           should be initialized to something which makes sense for your module
           - as that will be the default till the user changes it.

   @comm   This structure should be passed to <f IFDbgSetParams> at
           intialization time to enable the user to control the trace options.

           **VERY IMPORTANT NOTE** This structure MUST be declared with a
           variable  name of dpCurSettings to allow the system zones to
           function correctly.

   @tagname _DBGPARAM

   @xref   <f IFDbgSetParams>

********/

typedef struct _DBGPARAM {
   CHAR    lpszName[32];           // name of module
   HWND    hwnd;                   // Primary window Handle if task, NULL otherwise
   CHAR    rglpszZones[16][32];    // names of zones for first 16 bits
   ULONG   ulZoneMask;             // Zone Mask
}   DBGPARAM, FAR *LPDBGPARAM;

// Debug functions
BOOL WINAPI IFDbgOut (LPSTR lpszStatus);
WORD WINAPI IFDbgIn (LPSTR lpszPrompt, LPSTR lpszReply, WORD wBufSize);
extern EXPORT_DLL VOID WINAPI IFDbgSetParams (LPDBGPARAM lpdpParam, BOOL fEntry);
extern EXPORT_DLL VOID FAR CDECL  IFDbgPrintf(LPSTR lpszFmt, ...);
extern EXPORT_DLL BOOL WINAPI IFDbgCheck(VOID);

// Encourage people to use the correct variable
extern EXPORT_DLL DBGPARAM dpCurSettings;


// Special UI communication stuff

// Functions
DWORD WINAPI DebugUIMessage (UINT wMsg, WPARAM wParam, DWORD lParam);

// Messages to the UI proc
#define IF_DISP_STRING  IF_DEBUG_START
#define IF_INP_REQUEST  IF_DEBUG_START+1
#define IF_NEW_SETTING  IF_DEBUG_START+2
#define IF_DEL_SETTING  IF_DEBUG_START+3
#define IF_NEW_TASK     IF_DEBUG_START+4
#define IF_DEL_TASK     IF_DEBUG_START+5
#define IF_FILELOG_POLL IF_DEBUG_START+6

// Messages from the UI proc
#define REGISTER_UI_TASK    1
#define SET_LOG_MODE       2
#define DEBUG_OUT_DONE      3
#define DEBUG_IN_DONE       4
#define DEREGISTER_UI_TASK  5


#endif

// Debug Macros. These should be defined only if the module is being compiled
// in debug

#ifdef DEBUG

/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   DEBUGMSG    |   Prints a trace message on the debug
           console depending on enable flags set by the user.

   @parm   <lt>c_expression<gt>    |   cond    |   Boolean condition which is
           evaluated to decide whether or not to print the message.

   @parm   <lt>printfexp<gt>   | printf_exp    |  Printf parameters for the
           message to be displayed. Must be enclosed in a single pair of
           parentheses.

   @rdesc  TRUE if the message is printed, and FALSE if it is not.

   @comm   The condition should consist of a boolean expression testing whether
           the relevant zones are on or off.  Each module has a current zone
           mask which identifies which of the possible 32 zones is currently on.
           The top 16 bits of these are reserved for use for system defined
           zones - like ZONE_FUNC_ENTRY which is defined as

           #define ZONE_FUNC_ENTRY (0x00010000&dpCurSettings.ulZoneMask)

            Modules should take care to see
           that they print out trace messages which are meaningful and conform
           to some pattern - remember that other people than you have to see
           and make sense of your messages. The general format I have been
           following is :

           <lt>Task ID<gt> :
           <lt>ModuleName<gt>:<lt>SubModule<gt>:<lt>Function<gt>:<lt>msg<gt>

           The task ID is useful to sort out the output of multiple tasks
           running in the system.  The example call above yields this kind of
           output.

           The various predefined system zones are:
               ZONE_FUNC_ENTRY : To be used for all function entry and exit
                   messages. By convention, the parameters should be printed
                   on entry, and the return value should be printed on exit.
                   Any values printed in hexadecimal should be preceded by a 0x
               ZONE_INT_FUNC : To be used for any other traces at interesting
                   points within a function.

           All trace messages are disabled in a non debug build.

   @ex     Example Definition & Use |

           #define ZONE_CUSTOM (0x00000001&dpCurSettings.ulZoneMask)

           DEBUGMSG (ZONE_FUNC_ENTRY && ZONE_CUSTOM,
                       ("0x%04X:IFK:Buffers:GenericFunction:Entry\r\n",
                       GetCurrentTask()));

           This will print a trace message only if the user has turned the
           function entry zone and the custom zone on.

   @xref   <f IFDbgPrintf>
********/

#define DEBUGMSG(cond,printf_exp)   \
   ((cond)?(IFDbgPrintf printf_exp),1:0)

// Standard Debug zones
#define ZONE_FUNC_ENTRY (0x00010000&dpCurSettings.ulZoneMask)
#define ZONE_INT_FUNC   (0x00020000&dpCurSettings.ulZoneMask)

/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   ERRORMSG    |   Prints an error message on the debug
           console.

   @parm   <lt>printfexp<gt>   | printf_exp    |  Printf parameters for the
           message to be displayed. Must be enclosed in a single pair of
           parentheses.

   @comm   Should be used to display Error messages.

   @ex     Example Definition & Use |

           ERRORMSG (("0x%04X:JOB Failed !!\r\n", GetCurrentTask()));

           This will print a trace message like:

           ERROR: Job Process: 0x2346: JOB Failed !!

   @xref   <f IFDbgPrintf>
********/
#ifndef WIN32
#define ERRORMSG(printf_exp)   \
   (IFProcEnterCritSec(), \
    IFDbgPrintf("ERROR:(0x%04X):%s:",GetCurrentTask(),(LPSTR)(dpCurSettings.lpszName)), \
    IFDbgPrintf printf_exp ,\
    IFProcExitCritSec(), \
    1)
#else
#define ERRORMSG(printf_exp)   \
   (IFDbgPrintf("ERROR:(0x%08lX):%s:",GetCurrentProcessId(),(LPSTR)(dpCurSettings.lpszName)), \
    IFDbgPrintf printf_exp ,\
    1)
#endif

/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   RETAILMSG    |   Prints a message on the debug
           console even for retail builds.

   @parm   <lt>printfexp<gt>   | printf_exp    |  Printf parameters for the
           message to be displayed. Must be enclosed in a single pair of
           parentheses.

   @comm   Should be used to display debugging messages which are desired
           in the retail build. For obvious reasons this should be used
          sparingly. The benefit is that all such messages can be turned off
           for the shipping build by simply changing the macro in ifaxos.h

   @ex     Example Definition & Use |

           RETAILMSG (("0x%04X:Scanner Opened !!\r\n", GetCurrentTask()));

           This will print a trace message like:

           0x4567:Scanner Opened !!

   @xref   <f IFDbgPrintf>
********/
#define RETAILMSG(printf_exp)   (IFDbgPrintf printf_exp)

/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   WARNINGMSG    |   Prints a warning message on the debug
           console even for retail builds.

   @parm   <lt>printfexp<gt>   | printf_exp    |  Printf parameters for the
           message to be displayed. Must be enclosed in a single pair of
           parentheses.

   @comm   Should be used to display debugging messages which are desired
           in the retail build. For obvious reasons this should be used
          sparingly. The benefit is that all such messages can be turned off
           for the shipping build by simply changing the macro in ifaxos.h

   @ex     Example Definition & Use |

           WARNINGMSG (("0x%04X:Scanner Opened !!\r\n", GetCurrentTask()));

           This will print a trace message like:

           WARNING: 0x4567:Scanner Opened !!

   @xref   <f IFDbgPrintf> <f ERRORMSG>
********/
#ifndef WIN32
#define WARNINGMSG(printf_exp)   \
   (IFProcEnterCritSec(), \
    IFDbgPrintf("WARNING:(0x%04X):%s:",GetCurrentTask(),(LPSTR)(dpCurSettings.lpszName)), \
    IFDbgPrintf printf_exp ,\
    IFProcExitCritSec(), \
    1)
#else
#define WARNINGMSG(printf_exp)   \
   (IFDbgPrintf("WARNING:(0x%08lX):%s:",GetCurrentProcessId(),(LPSTR)(dpCurSettings.lpszName)), \
    IFDbgPrintf printf_exp ,\
    1)
#endif


/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   DEBUGCHK    |   Macro implementing an assert.

   @parm   <lt>c_exp<gt>   | exp   |  Expression to be checked.

   @rdesc  Returns TRUE if the expression was non zero, and FALSE if not.

   @comm   This is a macro which implements functionality similar to the assert
           statement in C.  The expression argument is evaluated, and no action
           is taken if it evaluates to true. If false, a debug message is
           printed out  giving the  File name and line number where the check
           failed, along with the module name which was registered
           in the <t DBGPARAM> structure. Because of this, you *must* register
           your debug settings using <f IFDbgSetParams> before you can use the 
           DEBUGCHK macro.  After this the function <f IFDbgCheck> is called
           to generate an assert.

           This statement disappears when the DEBUG option is turned off.

    @xref   <f IFDbgCheck>           
********/

#define BG_CHK(exp)    \
   ((exp)?1:(              \
       IFDbgPrintf ("DEBUGCHK failed in file %s at line %d \r\n",  \
                 (LPSTR) __FILE__ , __LINE__ ), 1  \
            ))

#ifndef DEBUGCHK_UNSAFE_IN_WFWBG


#define DBGCHK(module,exp) \
   ((exp)?1:(          \
       IFDbgPrintf ("%s: DEBUGCHK failed in file %s at line %d \r\n", \
                 (LPSTR) module, (LPSTR) __FILE__ , __LINE__ ),    \
       IFDbgCheck() \
            ))

#define DEBUGCHK(exp) DBGCHK(dpCurSettings.lpszName, exp)

#endif

/********
   @doc    EXTERNAL    IFAXOS    DEBUG   MACROS

   @api    BOOL    |   DEBUGSTMT   |   Evaluates the expression in debug mode.

   @parm   <lt>c_exp<gt>   | exp   |  Expression to be evaluated.

   @rdesc  Returns the value returned by the expression.

   @comm   This macro is provided for convenience and code readability purposes
           to replace a construct of the form

               #ifdef DEBUG
               exp;
               #endif

           It evaluates to zero in a non debug build.

********/

#define DEBUGSTMT(exp) exp

#else // NOT DEBUG

// Let debugmsg's through currently
#ifndef SHIP_BUILD
//#ifndef FOOBAR

// Non DEBUG MODE
extern EXPORT_DLL VOID FAR CDECL  IFDbgPrintf(LPSTR lpszFmt, ...);
extern EXPORT_DLL BOOL WINAPI IFDbgCheck(VOID);

#ifndef WIN32
#define ERRORMSG(printf_exp)   \
   (IFProcEnterCritSec(), \
    IFDbgPrintf("ERROR:(0x%04X):",GetCurrentTask()), \
    IFDbgPrintf printf_exp ,\
    IFProcExitCritSec(), \
    1)
#define WARNINGMSG(printf_exp)   \
   (IFProcEnterCritSec(), \
    IFDbgPrintf("WARNING:(0x%04X):",GetCurrentTask()), \
    IFDbgPrintf printf_exp ,\
    IFProcExitCritSec(), \
    1)
#define RETAILMSG(printf_exp)   (IFDbgPrintf printf_exp)
#else  //Win32 -- NO MESSAGES OF ANY SORT IN NON-DEBUG WIN32

#define RETAILMSG(printf_exp) (0)
#define ERRORMSG(printf_exp) (0)
#define WARNINGMSG(printf_exp) (0)
 
#endif


#else

#define RETAILMSG(printf_exp) (0)
#define ERRORMSG(printf_exp) (0)
#define WARNINGMSG(printf_exp) (0)

#endif

// These are to macro out all debug stuff in retail/ship builds
#define DEBUGMSG(cond,expr)  (0)
#define DBGCHK(module,exp) (0)
#define DEBUGCHK(exp) (0)
#define BG_CHK(exp) (0)
#define DEBUGSTMT(exp) (0)

// Macros for direct function calls made ..
#ifndef IFKINTERNAL
#define IFDbgOut(lpszStatus) (0)
#define IFDbgIn(lpszPrompt,lpszReply,wBufSize) (0)
#define IFDbgSetParams(lpdpParam,fEntry) (0)
#define DebugUIMessage(wMsg,wParam,lParam) (0)
#endif

#endif

/********
   @doc    EXTERNAL    IFAXOS    MACROS

   @api    BOOL    |   UIEVENT |   Prints a status string in the UI

   @parm   LPSTR | string |  String to be printed.

   @comm   This macro is provided in both the retail & debug builds to
            allow some limited set of status strings to be printed in
            the UI. You must format a string yourself - you can
            use wsprintf() to create a complex one if desired. The
            maximum string length allowed is 64 bytes.
********/
#define IF_SYS_EVENT     IF_UI_START+1
// UI Event messages
#define UIEVENT(string)   \
{       \
    CHAR    szUIShell[] = "UISHELL";  \
    DEBUGCHK(lstrlen(string) < 64); \
    PostMessage (IFProcGetInfo(NULL, szUIShell, NULL), IF_SYS_EVENT,   \
                 NULL, MAKELPARAM(GlobalAddAtom(string),0));    \
}

// --------------- Synchronization services --------------------------------------
// Dont provide any for win32.
#ifndef WIN32

typedef  struct _SYNC NEAR *HSYNC;

// Error returns
#define ERR_MUTEX_NOT_FREE  ERR_FUNCTION_START
#define ERR_EVENT_NOT_FREE  ERR_FUNCTION_START+1
#define ERR_TOO_MANY_EVENTWAITS ERR_FUNCTION_START+2

// generic functions
DWORD WINAPI WaitForSingleObject (HSYNC hsc, DWORD dwTime);

// Mutex functions
HSYNC WINAPI CreateMutex (LPVOID lpvAttribs, BOOL fInitial,LPSTR lpszName);
BOOL WINAPI ReleaseMutex (HSYNC hsc);

// Event Functions
HSYNC   WINAPI  CreateEvent (LPVOID lpvAttribs, BOOL bManualReset,
                            BOOL bInitialState, LPSTR lpszName);

BOOL    WINAPI  SetEvent (HSYNC hsc);
BOOL    WINAPI  ResetEvent (HSYNC hsc);
BOOL WINAPI FreeSyncObject (HSYNC hsc);
BOOL WINAPI  GetSetEventParam (HSYNC hsc, BOOL fSetParam, LPDWORD lpdwParam);

#else // !WIN32

DECLARE_HANDLE32(HSYNC);

#endif // !WIN32

/********
   @doc    EXTERNAL    DEFINES     ERROR   IFAXOS

    @type   VOID | SYSTEM_MODULE_NAMES  | Strings to be passed to IFProcGetInfo to get handles to standard IFAX modules

    @emem   MODNAME_UISHELL  | UI Shell
    @emem   MODNAME_MSCHED   | Message Scheduler
    @emem   MODNAME_MSGSVR   | Message Server a.k.a. Message Transport

    @xref   <f IFProcGetInfo>
********/

// IFAX Module names
#define MODNAME_UISHELL        "UISHELL"
#define MODNAME_MSCHED     "MSCHED"
#define MODNAME_MSGSVR     "MSGSVR"


// --------------- Timer Services -----------------------------------------

#ifndef WIN32

/********
   @doc    EXTERNAL    IFAXOS    MESSAGES    TIMER

   @msg    IF_TIMER | This message is sent to notify a process
           of the expiration of a timer set using <f IFTimerSet>.

   @parm   WPARAM  | wParam    | Contains the timer id set int he
           <f IFTimerSet> call.

   @parm   LPARAM  | lParam    | Contains the lParam passed into
           the IFTimerSet call.

   @rdesc  none

   @xref   <f IFTimerSet>
********/

// messages
#define IF_TIMER    IF_TIMER_START

// flags
#define TIME_ONESHOT    0
#define TIME_PERIODIC   1

// functions
VOID WINAPI IFProcSleep (WORD wSleepPeriod);
WORD WINAPI IFTimerSet (HWND hwnd, WORD idTimer, WORD wTimeout,
                         TIMERPROC tmprc, WORD wFlags, LPARAM lContext);
BOOL WINAPI    IFTimerKill (HWND hwnd, UINT idTimer);

#endif

// --------------- Global Pool Management ----------------------------------


/********
   @doc    EXTERNAL    IFAXOS    DEFINES     GLOBMEM

   @type   VOID | STANDARD_BLOCK_SIZES | This defines all the standard global
           memory block sizes. As far as possible all memory allocations
           should be for one of these sizes. Any other size will be much
           more inefficient and couls cause fragmentation of system
           memory.

   @emem   ONLY_HEADER_SIZE| This will allocate a buffer with no data
           associated with it. This can be used to pass metadata between
           processes - eg an END_OF_JOB buffer marker.

   @emem   SMALL_HEADER_SIZE| This currently defines a 32 byte memory
           block. It is used for all buffer headers, and can be used
           for things like protocol headers, structure headers etc.

   @emem   COMPRESS_DATA_SIZE | This defines a 1Kb memory block which
           should be used to store any compressed data form. This is
           the general purpose data storage size. Any buffer which
           could be around for a long time should contain compressed
           data in this size of buffer.

   @emem   RAW_DATA_SIZE | This defines a large buffer size (currently
           8Kb) for use by renderers as frame buffers. They should be
           used only to store raw bitmap data which is being sent
           directly to a consumer device like the printer. There are
           very few of these - so they should be used only for this
           short lived purpose.

   @emem   BAND_BUFFER_SIZE| This defines a jumbo buffer of 64K for use
           by the resource-based renderer.  There may be only one such
           buffer in the global pool. (NOT IMPLEMENTED YET)

   @xref   <f IFMemAlloc> <f IFBufAlloc>
********/

// Std block sizes
#define ONLY_HEADER_SIZE   0       // No data
#define SMALL_HEADER_SIZE  -1       // 32b
#define COMPRESS_DATA_SIZE  -2      // 1Kb

//
#define RAW_DATA_SIZE       -3      // 8Kb

// Special size for modem ECM frame
#define BYTE_265_SIZE       -4      // 265 bytes
#define BYTE_265_ACTUALSIZE 265

// Number of sizes
#define MAX_POOL_INDEX  -4          // For parameter validation

// Not available yet!
#define BAND_BUFFER_SIZE    30720      // 64Kb

// Flag to force global alloc. Uses a windows flag which is ignored/defunct in
// the 3.1 kernel (and the boss kernel)
#define IFMEM_USEGLOBALALLOC GMEM_NOT_BANKED

// Functions
extern EXPORT_DLL LPVOID  WINAPI  IFMemAlloc (UINT fuAlloc, LONG lAllocSize,
                                  LPWORD lpwActualSize);
extern EXPORT_DLL BOOL WINAPI IFMemFree (LPVOID lpvMem);


/********
    @doc    EXTERNAL   IFAXOS

    @api    HIPCMEM | IFMemGetIPCHandle | Returns an opaque 32 bit handle
            which is portable across process contexts.

    @parm   LPVOID  | lpvMem    | A ptr to global memory allocated using
            <f IFMemAlloc>.

    @rdesc  Opaque 32 bit none zero handle if succesfull. 0 if the memory
            ptr passed in is invalid.

    @comm   This function should be used by any DLL or process before trying
            to pass this memory to another process context. Only handles
            returned by this API should cross context boundaries, and the
            receiving context should call <f IFMemMapIPCHandle> to get back
            a valid memory ptr in its new context.

            This applies even for DLL's which might allocate a piece of
            global memory and access it in different process contexts. They
            should use these functions to map them so that they are portable.

            For Win16/IFAX implementations, this is essentially a NOP.

    @xref   <f IFMemAlloc> <f IFMemMapIPCHandle>

    @type   DWORD | HIPCMEM | Opaque 32 bit handle to global memory block.

    @xref   <f IFMemMapIPCHandle> <f IFMemGetIPCHandle>
*********/
typedef DWORD HIPCMEM;
#define IFMemGetIPCHandle(par1) ((HIPCMEM)par1)

/********
    @doc    EXTERNAL   IFAXOS

    @api    DWORD | IFMemMapIPCHandle | Maps a piece of memory into the
            current tasks address space.

    @parm   HIPCMEM | hMemHandle    | A memory handle returned from a call
            to <f IFMemGetIPCHandle> previously.

    @rdesc  Valid ptr to memory in the context of the calling process if
            succesful. NULL if it fails.

    @comm   See comments in <f IFMemMapIPCHandle>.

    @xref   <f IFMemAlloc> <f IFMemMapIPCHandle>
*********/
#define IFMemMapIPCHandle(par1) ((LPVOID)par1)


// --------------- Time API's ----------------------------------------------

/********
    @doc    EXTERNAL IFAXOS SRVRDLL

    @types  SYSTEMTIME  | Structure describing the time in terms of roman
            calendar.

    @field  WORD    | wYear | The year
    @field  WORD    | wMonth | The month from 1-12
    @field  WORD    | wDayOfWeek | Day of week with Sunday = 0
    @field  WORD    | wDay | The day of the month, from 1-31
    @field  WORD    | wHour | The hour from 0-23
    @field  WORD    | wMinute | Minutes from 0-59
    @field  WORD    | wSecond | Seconds from 0-50
    @field  WORD    | wMilliseconds | Milliseconds from 0-99

    @comm   This is the format used for dislaying time to the user etc.

    @xref   <f SystemTimeToFileTime> <t FILETIME> <f FileTimeToSystemTime>
********/
#ifndef WIN32

typedef struct _SYSTEMTIME {
   WORD wYear;
   WORD wMonth;
   WORD wDayOfWeek;
   WORD wDay;
   WORD wHour;
   WORD wMinute;
   WORD wSecond;
   WORD wMilliseconds;
} SYSTEMTIME, FAR *LPSYSTEMTIME;

#endif

/********
    @doc    EXTERNAL  IFAXOS

    @types  FILETIME    | Structure used to store time internally and for
            mathematical operations.

    @field  DWORD   | dwLowDateTime | Low 32 bits of the time.

    @field  DWORD   | dwHighDateTime | High 32 bits of the time.

    @comm   Absolute time in IFAX is represented by a 64-bit large integer accurate
            to 100ns resolution.  The smallest time resolution used by this package
            is One millisecond.  The basis for this time is the start of 1601 which
            was chosen because it is the start of a new quadricentury.  Some facts
            to note are:

            o At 100ns resolution 32 bits is good for about 429 seconds (or 7 minutes)

            o At 100ns resolution a large integer (i.e., 63 bits) is good for
            about 29,247 years, or around 10,682,247 days.

            o At 1 second resolution 31 bits is good for about 68 years

            o At 1 second resolution 32 bits is good for about 136 years

            o 100ns Time (ignoring time less than a millisecond) can be expressed
            as two values, Days and Milliseconds.  Where Days is the number of
            whole days and Milliseconds is the number of milliseconds for the
            partial day.  Both of these values are ULONG.

    @xref   <f SystemTimeToFileTime> <t SYSTEMTIME> <f FileTimeToSystemTime>
********/
#ifndef WIN32
// If sos property.h has been included this will cause a redefinition
#ifndef PROPERTY_H

#ifndef _FILETIME_
#define _FILETIME_

typedef struct _FILETIME {
   DWORD dwLowDateTime;
   DWORD dwHighDateTime;
} FILETIME, FAR *LPFILETIME;

#endif // _FILETIME_

#endif // Property_H

BOOL WINAPI FileTimeToSystemTime(LPFILETIME lpTime,LPSYSTEMTIME lpTimeFields);

BOOL WINAPI SystemTimeToFileTime(LPSYSTEMTIME lpTimeFields,LPFILETIME lpTime);

BOOL WINAPI FileTimeToLocalFileTime(LPFILETIME lpft, LPFILETIME lpftLocal);

BOOL WINAPI LocalFileTimeToFileTime(LPFILETIME lpftLocal, LPFILETIME lpft);

BOOL WINAPI SetLocalTime(LPSYSTEMTIME lpstLocal);

VOID WINAPI GetLocalTime(LPSYSTEMTIME lpstLocal);
#endif // Win32

// --------------- NVRAM  API's ----------------------------------------------

typedef struct ERRORLOGPOINTER {
    WORD wNextEntryPtr ;
    WORD wNumEntries ;
} ERRORLOGPOINTER , FAR * LPERRORLOGPOINTER ;

#define MAX_ERRORLOG_ENTRIES       30
#define MAX_OEMERRBUF_SIZE         16

/********
    @doc    EXTERNAL  IFAXOS

    @types  ERRORLOGENTRY    | Used to store Log Entries.

    @field  DWORD   | dwErrorCode | This is the IFAX error code
           corresponding to the error being retrieved. See <f IFErrAssemble>
           for details of the format of this dword.

    @field  DWORD   | dwTimeStamp | The time at which this error was
           logged into NVRam. The various fields are:
           @flag  Bits 0-4 | Second divided by 2
           @flag  Bits 5-10|   Minute (0-59)
           @flag  Bits 11-15 | Hour (0-23 on a 24 hour clock)
           @flag  Bits 16-20 | Day of the month (1-31)
           @flag  Bits 21-24 | Month (1 = January, 2 = February, etc.)
           @flag  Bits 25-31 | Year offset from COUNTER_YEAR_OFFSET (add COUNTER_YEAR_OFFSET to get actual year)

    @field CHAR    | oemErrBuf  | The buffer in which the application
           specific custom data/extended error corresponding to this
           error is retrieved.

    @comm   Used as a parameter to IFNvramGetError. This will typically be
           used for diagnostic functions.

    @xref   <f IFNvramGetError>
********/

#define COUNTER_YEAR_OFFSET  (1970)

typedef struct tagERRORLOGENTRY {
   DWORD dwErrorCode;
   DWORD dwTimeStamp;
   char oemErrBuf[MAX_OEMERRBUF_SIZE];
} ERRORLOGENTRY, FAR *LPERRORLOGENTRY;

typedef DWORD ERRORLOGSENTINEL , FAR * LPERRORLOGSENTINEL ;

// Set to the current version number (12.19)
#define SENTINEL_SET              0x00000C13UL

#define MAX_COUNTERS 30
#define OEM_NVRAM_COUNTER_START 12

// Special system counter which indicates the # of times the machine has rebooted
// It is a 4 byte counter with a timestamp
// If this value is 1 then this is the first time the machine has ever been rebooted.
// - This value cannot be set by any user application!

#define BOOT_COUNTER           0

// specific counter numbers assigned for various logical counters

#define TXCALL_COUNTER         1
#define RXCALL_COUNTER         2

// ****************************************************************************
//
// An HHSOS owned counter.
// This is the number of bad boots we have suffered (meaning the HHSOS could not
// successfully init).  When this number gets too big, we stop trying to init.  
// This will cause AWCHKSOS to alert the user of the problem.
//

#define BAD_BOOTS_COUNTER      3

//
// ****************************************************************************


// These values for wFlags (in IFSetCounterValue) - some are mutually exclusive

// If CLEARSET is set the value is cleared before being added - otherwise it is just added
// Currently you cannot request a double long and a timestamp

// For now the interrupt has no context but in the future it might be useful

#define COUNTER_CLEARSET          0x0001
#define COUNTER_DOUBLE_LONG       0x0002
#define COUNTER_UPDATE_TIMESTAMP  0x0004
#define COUNTER_INTERRUPT_CONTEXT 0x1000

// Only here temporarily until everything gets moved to new values

#define COUNTER_VALUESET     (COUNTER_CLEARSET | COUNTER_UPDATE_TIMESTAMP)
#define COUNTER_ADDVALUE     0x0100
#define COUNTER_TIMESTAMP    0x0200
#define COUNTER_NOTIMESTAMP  COUNTER_DOUBLE_LONG
#define PROCESS_CONTEXT      0x0300
#define INTERRUPT_CONTEXT    COUNTER_INTERRUPT_CONTEXT

/********
    @doc    EXTERNAL  IFAXOS

    @types  COUNTERENTRY    | Used to store 4 and 8 byte Counters.

    @field  DWORD   | dwCounterVal1 | For a 4 byte counter, the value of the
           counter. For an 8 byte counter, the low order
           4 bytes of the value of the counter.

    @field  DWORD   | dwTimeStamp | For a 4 byte counter, the time at
           which the counter was last reset. The fields in the timestamp are:
           @flag  Bits 0-4 | Second divided by 2
           @flag  Bits 5-10|   Minute (0-59)
           @flag  Bits 11-15 | Hour (0-23 on a 24 hour clock)
           @flag  Bits 16-20 | Day of the month (1-31)
           @flag  Bits 21-24 | Month (1 = January, 2 = February, etc.)
           @flag  Bits 25-31 | Year offset from 1980 (add 1980 to get actual year)

           For an 8 byte counter, dwTimeStamp is the high order 4 bytes of the
           counter value.

    @comm   Used by the IFNvramGetCounterValue function.

    @xref   <f IFNvramGetCounterValue>
********/
typedef struct tagCOUNTERENTRY {
   DWORD dwCounterVal1;
   DWORD dwTimeStamp;
} COUNTERENTRY, FAR *LPCOUNTERENTRY;

//-------------------------- Prototypes ----------------------------------

#if defined(WFW) || defined(WIN32)

#define IFNvramSetError(dw,lpb,w)              (0)
#define IFNvramSetErrorInterrupt(dw,lpb,w)         (0)
#define IFNvramGetError(lperrlog,lpwMaxEntries) (0)
#define IFNvramSetCounterValue(p1,p2,p3,p4)    (0)
#define IFNvramGetCounterValue(w1,lpentry)         (0)
#define IFNvramAllocScratchBuf(wSize)          (NULL)

#else

BOOL WINAPI     IFNvramSetError(DWORD, LPBYTE, WORD);
BOOL WINAPI     IFNvramSetErrorInterrupt(DWORD, LPBYTE, WORD);
BOOL FAR CDECL  IFNvramvSetError(DWORD dwError,WORD nErrs,...) ;
BOOL WINAPI     IFNvramGetError(LPERRORLOGENTRY lperrlog,LPWORD lpwMaxEntries) ;
BOOL WINAPI     IFNvramSetCounterValue(WORD, DWORD, DWORD, WORD);
BOOL WINAPI     IFNvramGetCounterValue(WORD, LPCOUNTERENTRY);
BOOL WINAPI     IFNvramFlushToFileLog(VOID) ;
BOOL WINAPI     IFNvramInitFileLog(VOID) ;
LPBYTE WINAPI   IFNvramAllocScratchBuf(WORD wSize);

#endif

/********
    @doc    EXTERNAL   IFAXOS

    @api    BOOL | _lflush | Flushes all pending writes to a file handle.

    @parm   HFILE  | hf    | A file handle obtained from _lopen or OpenFile

    @rdesc  Returns TRUE for success, FALSE for failure.

    @comm   This function will flush all pending writes to disk.

            For Win16 implementations, this currently always fails.
*********/

BOOL WINAPI _lflush(HFILE hf);


// the following is for service messages
#define IF_ST_END_SOSBK        (IF_SERVICE_START+0)
#define IF_ST_END_SOSRST       (IF_SERVICE_START+1)


#ifdef __cplusplus
} // extern "C" {
#endif

#endif  // _INC_IFAXOS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\inc\migrate.h ===
#ifndef __MIGRATE_H
#define __MIGRATE_H
/*++
  migrate.h

  Copyright (c) 1997  Microsoft Corporation


  This file contains prototypes & definitions for the Win95->NT Fax
  migration DLL.

  Author:

  Brian Dewey (t-briand) 1997-7-14

--*/

// ------------------------------------------------------------
// Prototypes

// All of these functions are required in a migration DLL.

LONG
CALLBACK 
QueryVersion (
	OUT LPCSTR  *ProductID,	  // Unique identifier string.
	OUT LPUINT DllVersion,	  // Version number.  Cannot be zero.
	OUT LPINT *CodePageArray, // OPTIONAL.  Language dependencies.
	OUT LPCSTR  *ExeNamesBuf, // OPTIONAL.  Executables to look for.
	LPVOID Reserved
	);

LONG
CALLBACK
Initialize9x(
    IN  LPCSTR WorkingDirectory,  // Place to store files.
    IN  LPCSTR SourceDirectories, // Location of the Windows NT source. MULTI-SZ.
    LPVOID     Reserved		  // Exactly what it says.
    );

LONG
CALLBACK
MigrateUser9x(
    IN  HWND ParentWnd,		  // Parent (if need a UI)
    IN  LPCSTR UnattendFile,	  // Name of unattend file
    IN  HKEY UserRegKey,	  // Key to this user's registry settings.
    IN  LPCSTR UserName,	  // Account name of user.
    LPVOID Reserved
    );

LONG
CALLBACK
MigrateSystem9x(
    IN  HWND ParentWnd,		  // Parent for UI.
    IN  LPCSTR UnattendFile,	  // Name of unattend file
    LPVOID Reserved
    );

LONG
CALLBACK
InitializeNT(
    IN  LPCWSTR WorkingDirectory, // Working directory for temporary files.
    IN  LPCWSTR SourceDirectory,  // Directory of winNT source.
    LPVOID Reserved		  // It's reserved.
    );

LONG
CALLBACK
MigrateUserNT(
    IN  HINF UnattendInfHandle,	  // Access to the unattend.txt file.
    IN  HKEY UserRegHandle,	  // Handle to registry settings for user.
    IN  LPCWSTR UserName,	  // Name of the user.
    LPVOID Reserved
    );

LONG
CALLBACK
MigrateSystemNT(
    IN  HINF UnattendInfHandle,	  // Access to the unattend.txt file.
    LPVOID Reserved
    );

// ------------------------------------------------------------
// defines
#define FAX_MIGRATION_VERSION	(1)

// ------------------------------------------------------------
// global data
extern LPCTSTR lpLogonUser;	  // Holds the logon user name for faxuser.ini
extern TCHAR   szInfFileName[];	  // Name of the generated INF file.
extern HINSTANCE hinstMigDll;	  // Handle to the migration DLL instance.

#endif // __MIGRATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\inc\property.h ===
//
// MAPI Properties
//
//
// Mail user generic properties =                       0x3a00 - 0x3aff

//  4000    57FF    Transport-defined envelope property
//  5800    5FFF    Transport-defined per-recipient property
//  6000    65FF    User-defined non-transmittable property
//  6600    67FF    Provider-defined internal non-transmittable property
//  6800    7BFF    Message class-defined content property
//  7C00    7FFF    Message class-defined non-transmittable
//                  property


// Transport-defined message envelope properties =      0x4000 - 0x57ff
// Transport-defined recipient properties =             0x5800 - 0x5fff
// User-defined non-transmittable message props =       0x6000 - 0x65ff
// Provider-defined internal non-transmittable props =  0x6600 - 0x67ff
// Message class-defined message content properties =   0x6800 - 0x7bff
// Message class-defined non-transmittable message
//  props =                                             0x7c00 - 0x7fff
// User-defined properties identified only by name,
//  through the property name to ID mapping facility
//  of the IMAPIProp interface =                        0x8000 - 0xfffe
//

#define TRANSPORT_ENVELOPE_BASE             0x4000
#define TRANSPORT_RECIP_BASE                0x5800
#define USER_NON_TRANSMIT_BASE              0x6000
#define PROVIDER_INTERNAL_NON_TRANSMIT_BASE 0x6600
#define MESSAGE_CLASS_CONTENT_BASE          0x6800
#define MESSAGE_CLASS_NON_TRANSMIT_BASE     0x7C00

#define EFAX_MESSAGE_BASE                   TRANSPORT_ENVELOPE_BASE + 0x500
#define EFAX_RECIPIENT_BASE                 TRANSPORT_RECIP_BASE + 0x100
#define EFAX_PR_OPTIONS_BASE                PROVIDER_INTERNAL_NON_TRANSMIT_BASE + 0x100

#define EFAX_ADDR_TYPE                      "FAX"

//
// LOGON Properties
//
// Properties we store in the Profile.
//
// The following is used to access the properties in the logon array.
// If you add a property to the profile, you should increment this number!
#define MAX_LOGON_PROPERTIES                10

// Other logon properties:
//  PR_SENDER_NAME                          - in mapitags.h
//  PR_SENDER_EMAIL_ADDRESS                 - in mapitags.h (this file)
// Fax Product name
#define PR_FAX_PRODUCT_NAME                 PROP_TAG(PT_TSTRING, (EFAX_PR_OPTIONS_BASE + 0x0))

// Active fax device name
#define PR_FAX_ACTIVE_MODEM_NAME            PROP_TAG(PT_TSTRING, (EFAX_PR_OPTIONS_BASE + 0x1))

// If value is TRUE, work offline
#define PR_FAX_WORK_OFF_LINE                PROP_TAG(PT_BOOLEAN, (EFAX_PR_OPTIONS_BASE + 0x2))

// If true, you want to share the active fax device
#define PR_FAX_SHARE_DEVICE                 PROP_TAG(PT_BOOLEAN, (EFAX_PR_OPTIONS_BASE + 0x3))

// The share name
#define PR_FAX_SHARE_NAME                   PROP_TAG(PT_TSTRING, (EFAX_PR_OPTIONS_BASE + 0x4))

// Sender Country code ID - used internally by fax config
#define PR_FAX_SENDER_COUNTRY_ID            PROP_TAG(PT_LONG,    (EFAX_PR_OPTIONS_BASE + 0x5))

// multi-value proerty to hold the names of the netfax devices the user added
#define PR_FAX_NETFAX_DEVICES               PROP_TAG(PT_MV_STRING8, (EFAX_PR_OPTIONS_BASE + 0x6))

// The share pathname on the sharing machine
#define PR_FAX_SHARE_PATHNAME               PROP_TAG(PT_TSTRING, (EFAX_PR_OPTIONS_BASE + 0x7))

// Profile section version
#define PR_FAX_PROFILE_VERSION              PROP_TAG(PT_LONG, (EFAX_PR_OPTIONS_BASE + 0x8))

//
// Non-Transmittable message properties
//

#define PR_FAX_CHEAP_BEGIN_HOUR             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x1))
#define PR_FAX_CHEAP_BEGIN_MINUTE           PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x2))
#define PR_FAX_CHEAP_END_HOUR               PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x3))
#define PR_FAX_CHEAP_END_MINUTE             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x4))
#define PR_FAX_NOT_EARLIER_HOUR             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x5))
#define PR_FAX_NOT_EARLIER_MINUTE           PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x6))
#define PR_FAX_NOT_EARLIER_DATE             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x7))
#define PR_FAX_NUMBER_RETRIES               PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x8))
#define PR_FAX_MINUTES_BETWEEN_RETRIES      PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x9))
// Should a cover page be sent with this message
#define PR_FAX_INCLUDE_COVER_PAGE           PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0xA))
#define PR_FAX_COVER_PAGE_BODY              PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0xB))
#define PR_FAX_LOGO_STRING                  PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0xC))
// Should this message be send as text, in printed format, or best available
#define PR_FAX_DELIVERY_FORMAT              PROP_TAG(PT_LONG,    (EFAX_MESSAGE_BASE + 0xD))
#define PR_FAX_PRINT_ORIENTATION            PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0xE))
#define PR_FAX_PAPER_SIZE                   PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0xF))
#define PR_FAX_IMAGE_QUALITY                PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x10))
// These should be set by transport so Linearizer can see them.
#define PR_FAX_SENDER_NAME                  PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x11))
#define PR_FAX_SENDER_EMAIL_ADDRESS         PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x12))
#define PR_FAX_LMI_CUSTOM_OPTION            PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x13))
#define PR_FAX_PREVIOUS_STATE               PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x14))
#define PR_FAX_FAXJOB                       PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x15))
// The billing code to bill for the transmission of this message
#define PR_FAX_BILLING_CODE                 PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x16))
// Previous billing codes used
#define PR_FAX_PREV_BILLING_CODES           PROP_TAG(PT_MV_STRING8, (EFAX_MESSAGE_BASE + 0x17))
// Is Fax message to begin (or fully included, if short) on the cover page
#define PR_FAX_BGN_MSG_ON_COVER             PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x18))
// Should the message be sent immediately, at cheap rates or at a specific time
#define PR_FAX_SEND_WHEN_TYPE               PROP_TAG(PT_LONG,    (EFAX_MESSAGE_BASE + 0x19))
// Absolute pathname of default coverpage file
#define PR_FAX_DEFAULT_COVER_PAGE           PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x1A))
// Maximum Time to wait for connection (seconds)
#define PR_FAX_MAX_TIME_TO_WAIT             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x1B))
// Enable/Disable logging calls
#define PR_FAX_LOG_ENABLE                   PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x1C))
// Number of calls to keep log of
#define PR_FAX_LOG_NUM_OF_CALLS             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x1D))
// Display call progress
#define PR_FAX_DISPLAY_PROGRESS             PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x1E))
// Embed Linked objects before sending
#define PR_FAX_EMBED_LINKED_OBJECTS         PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x1F))
// TAPI Location ID
#define PR_FAX_TAPI_LOC_ID                  PROP_TAG(PT_LONG,    (EFAX_MESSAGE_BASE + 0x20))
// Must render ALL attachments before sending
#define PR_FAX_MUST_RENDER_ALL_ATTACH       PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x21))
// Enable per-recipient options
#define PR_FAX_ENABLE_RECIPIENT_OPTIONS     PROP_TAG(PT_BOOLEAN, (EFAX_MESSAGE_BASE + 0x22))
// Calling Card Name
#define PR_FAX_CALL_CARD_NAME               PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x24))
// Print to fax rba stream filename
#define PR_FAX_PRINT_TO_NAME                PROP_TAG(PT_STRING8, (EFAX_MESSAGE_BASE + 0x25))
#define PR_FAX_SECURITY_SEND                PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x26))
#define PR_FAX_SECURITY_RECEIVED            PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x27))
// RBA data property (print-to-fax)
#define PR_FAX_RBA_DATA                     PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x28))

// Poll retrieval
#define PR_POLL_RETRIEVE_SENDME             PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x29))
#define PR_POLL_RETRIEVE_TITLE              PROP_TAG(PT_TSTRING, (EFAX_MESSAGE_BASE + 0x30))
#define PR_POLL_RETRIEVE_PASSWORD           PROP_TAG(PT_TSTRING, (EFAX_MESSAGE_BASE + 0x31))
#define PR_POLLTYPE                         PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x32))

// Poll server
#define PR_MESSAGE_TYPE                     PROP_TAG(PT_I2,      (EFAX_MESSAGE_BASE + 0x33))

// Digital signature for an attachment
#define PR_ATTACH_SIGNATURE                 PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x34))

// (print-to-fax # of pages)
#define PR_FAX_PRINT_TO_PAGES               PROP_TAG(PT_LONG,    (EFAX_MESSAGE_BASE + 0x35))

// On incoming message attachment, this contains image data requiring render conversion.
#define PR_FAX_IMAGE                        PROP_TAG(PT_BINARY,  (EFAX_MESSAGE_BASE + 0x36))

// Print a header line on the top of every G3 fax page (branding)
#define PR_FAX_PRINT_HEADER                 PROP_TAG(PT_BOOLEAN,  (EFAX_MESSAGE_BASE + 0x37))

// Billing code DWORD representation
#define PR_FAX_BILLING_CODE_DWORD           PROP_TAG(PT_LONG, (EFAX_MESSAGE_BASE + 0x38))


//
// Non-Transmittable mail-user properties
//
#define PR_FAX_RECIP_CAPABILITIES           PROP_TAG(PT_I2,      (EFAX_RECIPIENT_BASE + 0x0))
// Name of the recipient to put on the cover page
#define PR_FAX_CP_NAME                      PROP_TAG(PT_TSTRING, (EFAX_RECIPIENT_BASE + 0x1))
#define PR_FAX_CP_NAME_W                    PROP_TAG(PT_UNICODE, (EFAX_RECIPIENT_BASE + 0x1))
#define PR_FAX_CP_NAME_A                    PROP_TAG(PT_STRING8, (EFAX_RECIPIENT_BASE + 0x1))
#define PR_RECIP_INDEX                      PROP_TAG(PT_I2,      (EFAX_RECIPIENT_BASE + 0x2))
#define PR_HOP_INDEX                        PROP_TAG(PT_I2,      (EFAX_RECIPIENT_BASE + 0x3))
// BUGBUG: This should go away
#define PR_RECIP_VOICENUM                   PROP_TAG(PT_TSTRING, (EFAX_RECIPIENT_BASE + 0x4))
#define PR_FAX_ENCRYPTION_KEY               PROP_TAG(PT_BINARY,  (EFAX_RECIPIENT_BASE + 0x5))

// Moved here from chicago\ui\faxab\faxab.h
#define PR_COUNTRY_ID                       PROP_TAG(PT_LONG,0x6607)
#define PR_AREA_CODE                        PROP_TAG(PT_STRING8,0x6608)
#define PR_TEL_NUMBER                       PROP_TAG(PT_STRING8,0x6609)
#define PR_MAILBOX                          PROP_TAG(PT_STRING8,0x660a)


#define ArrayIndex(PROP, ARRAY)(ARRAY)[(PROP_ID(PROP) - EFAX_XP_MESSAGE_BASE - 1)]


/**********************************************************************************

   Property Values Section

***********************************************************************************/

#define NUM_SENDER_PROPS            3       // How many sender ID properties?

// Send As
// PR_FAX_DELIVERY_FORMAT
#define SEND_BEST                  0
#define SEND_EDITABLE              1
#define SEND_PRINTED               2
#define DEFAULT_SEND_AS                SEND_BEST

// Send At
// PR_FAX_SEND_WHEN_TYPE
#define SEND_ASAP                  0
#define SEND_CHEAP                 1
#define SEND_AT_TIME               2
#define DEFAULT_SEND_AT            SEND_ASAP

// Paper Size
// PR_FAX_PAPER_SIZE
#define PAPER_US_LETTER            0       // US Letter page size
#define PAPER_US_LEGAL             1
#define PAPER_A4                   2
#define PAPER_B4                   3
#define PAPER_A3                   4
// "real" default page size is in a resource string depending on U.S. vs metric
#define DEFAULT_PAPER_SIZE      PAPER_US_LETTER     // Default page size

// Print Orientation
// PR_FAX_PRINT_ORIENTATION
#define PRINT_PORTRAIT             0       // Protrait printing
#define PRINT_LANDSCAPE            1
#define DEFAULT_PRINT_ORIENTATION  PRINT_PORTRAIT

// Image Quality
// PR_FAX_IMAGE_QUALITY
#define IMAGE_QUALITY_BEST         0
#define IMAGE_QUALITY_STANDARD     1
#define IMAGE_QUALITY_FINE         2
#define IMAGE_QUALITY_300DPI       3
#define IMAGE_QUALITY_400DPI       4
#define DEFAULT_IMAGE_QUALITY      IMAGE_QUALITY_BEST

// Speaker
// PR_FAX_SPEAKER_VOLUME
#define NUM_OF_SPEAKER_VOL_LEVELS  4   // Number of speaker volume levels
#define DEFAULT_SPEAKER_VOLUME     2   // Default speaker volume level
#define SPEAKER_ALWAYS_ON          2   // Speaker mode: always on
#define SPEAKER_ON_UNTIL_CONNECT   1   // speaker on unitl connected
#define SPEAKER_ALWAYS_OFF         0   // Speaker off
#define DEFAULT_SPEAKER_MODE       SPEAKER_ON_UNTIL_CONNECT   // Default speaker mode

// Answer
// PR_FAX_ANSWER_MODE
#define NUM_OF_RINGS                3
#define ANSWER_NO                  0
#define ANSWER_MANUAL               1
#define ANSWER_AUTO                 2
#define DEFAULT_ANSWER_MODE         ANSWER_NO

// Blind Dial
#define DEFAULT_BLIND_DIAL         3
// Comma Delay
#define DEFAULT_COMMA_DELAY            2
// Dial Tone Wait
#define DEFAULT_DIAL_TONE_WAIT     30
// Hangup Delay
#define DEFAULT_HANGUP_DELAY       60

// Poll retrieval
// PR_POLL_RETRIEVE_SENDME
#define SENDME_DEFAULT              0
#define SENDME_DOCUMENT             1

// PR_POLLTYPE
#define POLLTYPE_REQUEST            1
#define POLLTYPE_STORE              2

// Type of fax devices (line IDs)
// PR_FAX_ACTIVE_MODEM_TYPE
/*
   defined in ifaxdev\h\filet30.h

#define LINEID_NONE        (0x0)
#define LINEID_COMM_PORTNUM        (0x1)
#define LINEID_COMM_HANDLE     (0x2)
#define LINEID_TAPI_DEVICEID       (0x3)
#define LINEID_TAPI_PERMANENT_DEVICEID (0x4)
#define LINEID_NETFAX_DEVICE   (0x10)

*/

// Line ID (depends on the value in PR_FAX_ACTIVE_MODEM_TYPE)
// PR_FAX_ACTIVE_MODEM
#define    NO_MODEM                    0xffffffff  // To show no modem is selected

// PR_FAX_TAPI_LOC_ID
#define    NO_LOCATION                 0xffffffff  // No TAPI location

// Values for PR_FAX_FLAGS
// #define EFAX_FLAG_PEER_TO_PEER              ((ULONG)0x00000001)
#define EFAX_FLAG_UI_ALWAYS                 ((ULONG)0x00000002)
// #define EFAX_FLAG_LOG_EVENTS                ((ULONG)0x00000004)
#define EFAX_FLAG_SAVE_DATA                 ((ULONG)0x00000008)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\inc\rambo.h ===
// Copyright (c) Microsoft Corp. 1994-95

#ifndef _RAMBO_
#define _RAMBO_

#include <windows.h>
#include <pshpack2.h>		// The structures in this file need to be word-aligned.

// common header
typedef struct
{
	WORD  cbRest;
	DWORD dwID;
	WORD  wClass;
}
	RESHDR, FAR *LPRESHDR;

// resource classes
#define ID_GLYPH   1
#define ID_BRUSH   2
#define ID_BITMAP  3
#define ID_RPL     4
#define ID_CONTROL 8
#define ID_BAND   10

// control IDs
#define ID_BEGJOB  0x49505741 // "AWPI"
#define ID_ENDPAGE 0x45474150 // "PAGE"
#define ID_ENDJOB  0x4a444e45 // "ENDJ"

// job header
typedef struct BEGJOB
{ 
	// common header
	WORD  cbRest;     // sizeof(BEGJOB) - sizeof(WORD)
	DWORD dwID;       // ID_BEGJOB
	WORD  wClass;     // ID_CONTROL

	// image attributes
	DWORD xBand;      // page width  [pixels]
	DWORD yBand;      // band height [pixels]
	WORD  xRes;       // horizontal resolution [dpi]
	WORD  yRes;       // vertical resolution [dpi]

	// memory attributes
	DWORD cbCache;    // cache size [KB]
	WORD  cResDir;    // directory size
	BYTE  bBitmap;    // bitmap compression
	BYTE  bGlyph;     // glyph compression
	BYTE  bBrush;     // stock brush set
	BYTE  bPad[3];    // reserved, must be 0
}
	BEGJOB, FAR *LPBEGJOB;

// job tailer
typedef struct ENDJOB
{
	// common header
	WORD  cbRest;      // sizeof(ENDJOB) - sizeof(WORD)
	DWORD dwID;        // ID_ENDJOB
	WORD  wClass;      // ID_CONTROL

	// job attributes
	WORD  cPage;       // number of pages
	WORD  yMax;        // maximum height
}
	ENDJOB, FAR *LPENDJOB;

// bitmap header
typedef	struct
{
	BYTE  bComp;
	BYTE  bLeftPad;
	WORD  wHeight;
	WORD  wWidth;
}
	BMPHDR, FAR* LPBMPHDR;

#include <poppack.h>

#endif // _RAMBO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\inc\oleutils.h ===
/*
   Microsoft Corp. (C) Copyright 1994
   Developed under contract by Numbers & Co.
----------------------------------------------------------------------------

        name:   Elliot Viewer - Chicago Viewer Utility
        						Cloned from the IFAX Message Viewing Utility

        file:   oleutils.h

    comments:   Functions to support OLE2 interactions
            
        
		NOTE: This header must be used with the LARGE memory model
		
----------------------------------------------------------------------------
   Microsoft Corp. (C) Copyright 1994
   Developed under contract by Numbers & Co.
*/
       
#ifndef OLEUTILS_H
#define OLEUTILS_H
    
    
#include <ole2.h>


/*
	Version constants
 */
#define AWD_SIGNATURE		0
#define AWD_SIGNATURE_STR  "0"

/*
	This has the "current" version. As new ones come along shift this
	down to a new AWD_VERxx... set and add a check to 
	CViewer::get_awd_version. Add a new version check and any code
	needed to handle whatever is different with the new version to 
	appropriate places in oleutils.cpp, etc...
 */
#define AWD_VERSION			1
#define AWD_VERSION_STR	   "1"

// this is same as AWD_VERSION, used by the transport
#define AWD_VER1A			1
#define AWD_VER1A_STR	   "1.0 (pages = docs)"


/*
	Recognized extensions
 */
#define BMP_EXT			_T("bmp")
#define DIB_EXT			_T("dib")
#define DCX_EXT			_T("dcx")
#define RBA_EXT			_T("rba")
#define RMF_EXT			_T("rmf")
#define AWD_EXT			_T("awd")


/*
	AWD flags
 */
#define AWD_FIT_WIDTH	0x00000001
#define AWD_FIT_HEIGHT	0x00000002
#define AWD_INVERT		0x00000010
#define AWD_WASINVERTED	0x40000000
#define AWD_IGNORE		0x80000000

       
/*
	AWD file structures
 */
#pragma pack( 1 ) // THESE STRUCTS MUST BE BYTE ALIGNED
typedef struct
	{
	WORD  Signature;
	WORD  Version;
	DATE  dtLastChange;
	DWORD awdFlags;
	WORD  Rotation;
	WORD  ScaleX;
	WORD  ScaleY;
	}
	PAGE_INFORMATION;
	
	
typedef struct
	{
	WORD  Signature;
	WORD  Version;
	PAGE_INFORMATION PageInformation;
	}
	DOCUMENT_INFORMATION;
		
	
	
typedef struct
	{
	WORD  Signature;
	WORD  Version;
	DATE  dtLastChange;
	DWORD awdFlags;
	WORD  Author_bufferlen; // includes the UNICODE '\0' terminator
	WCHAR Author[1];		// UNICODE !!!
	}
	OVERLAY_INFORMATION;



// defs for summary stream- must be 32bit aligned
#pragma pack( 4 )


#define SUMMARY_FMTID( fmtid )                                          \
	CLSID fmtid =														\
	{0xF29F85E0, 0x4FF9, 0x1068, {0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9}}
				 
				 

#define PID_TITLE	        0x00000002
#define PID_SUBJECT         0x00000003
#define PID_AUTHOR          0x00000004
#define PID_KEYWORDS        0x00000005
#define PID_COMMENTS        0x00000006
#define PID_TEMPLATE        0x00000007
#define PID_LASTAUTHOR      0x00000008
#define PID_REVNUMBER       0x00000009
#define PID_EDITTIME        0x0000000a
#define PID_LASTPRINTED     0x0000000b
#define PID_CREATE_DTM      0x0000000c
#define PID_LASTSAVE_DTM	0x0000000d
#define PID_PAGECOUNT       0x0000000e
#define PID_WORDCOUNT       0x0000000f
#define PID_CHARCOUNT       0x00000010
#define PID_THUMBNAIL       0x00000011
#define PID_APPNAME         0x00000012

// BKD 1997-7-9: done to disable warning message.  This is probably bad that the oleutils
// uses a macro that's now been reserved and probably should be changed.
// FIXBKD
#ifdef PID_SECURITY
#undef PID_SECURITY
#endif // PID_SECURITY

#define PID_SECURITY        0x00000013


typedef struct
	{
	DWORD dwType;
	DATE  date;
	}
	date_prop_t;
	

typedef struct
	{
	DWORD dwType;
	DWORD wval;
	}
	wval_prop_t;


typedef struct
	{
	DWORD dwType;
	DWORD numbytes;
	char  string[80]; 
	}
	string_prop_t;
	

typedef struct
	{
	DWORD PropertyID;
	DWORD dwOffset;
	}
	PROPERTYIDOFFSET;


typedef struct
	{
	DWORD cbSection;
	DWORD cProperties;
	
	PROPERTYIDOFFSET revnum_pair;
	PROPERTYIDOFFSET lastprt_pair;
	PROPERTYIDOFFSET create_dtm_pair;
	PROPERTYIDOFFSET lastsaved_dtm_pair;
	PROPERTYIDOFFSET numpages_pair;
	PROPERTYIDOFFSET appname_pair;
	PROPERTYIDOFFSET security_pair;
	PROPERTYIDOFFSET author_pair;

	string_prop_t 	 revnum;
	date_prop_t 	 lastprt;
	date_prop_t 	 create_dtm;
	date_prop_t 	 lastsaved_dtm;
	wval_prop_t 	 numpages;
	string_prop_t 	 appname;
	wval_prop_t 	 security;
	string_prop_t 	 author;
	}
	summaryPROPERTYSECTION;	
	

typedef struct
	{
	GUID FormatID;
	DWORD dwOffset;
	}
	FORMATIDOFFSET;
	
           
// quick and dirty summary stream. Not all properties are used           
typedef struct
	{
	WORD  wByteOrder;
	WORD  wFormat;
	DWORD dwOSVer;
	CLSID clsID;
	DWORD cSections;
	FORMATIDOFFSET section1_pair;
	summaryPROPERTYSECTION section1;
	}
	summaryPROPERTYSET;



#define NUM_USED_PROPS  8

/*
	The def for summary_info_t was moved to viewerob.h so that 
	every module doesn't have to pull in oleutils.h because of the
	summary_info_t variable that is in CViewer.
 */
//typedef struct
//	{
//	:
//	:
//	}
//	summary_info_t;


// structs for reading summary stream
typedef struct
	{
	WORD  wByteOrder;
	WORD  wFormat;
	DWORD dwOSVer;
	CLSID clsID;
	DWORD cSections;
	}
	summary_header_t;


typedef struct
	{
	DWORD cbSection;
	DWORD cProperties;
	}
	summary_section_t;
	

#pragma pack() // go back to default packing
	
// BKD:  I snipped the prototypes, since they're not used
// in the awd converter.


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\inc\viewrend.h ===
// Copyright (c) Microsoft Corp. 1993-94
/*==============================================================================
This header file defines the viewer rendering support API.

17-Oct-93    RajeevD    Created.
25-Oct-93    RajeevD    Updated to support random access to bands.
==============================================================================*/
#ifndef _INC_VIEWREND
#define _INC_VIEWREND

#include <ifaxos.h>

#ifdef IFBGPROC
#ifndef _BITMAP_
#define _BITMAP_

// Win 3.1 Bitmap
typedef struct
{
	int     bmType;
	int     bmWidth;
	int     bmHeight;
	int     bmWidthBytes;
	BYTE    bmPlanes;
	BYTE    bmBitsPixel;
	void FAR* bmBits;
}
	BITMAP, FAR *LPBITMAP;

#endif // _BITMAP_	
#endif // IFBGPROC
	
#ifdef __cplusplus
extern "C" {
#endif

typedef struct
{
	WORD cPage;  // number of pages
	WORD xRes;   // horizontal resolution [dpi]
	WORD yRes;   // vertical resolution [dpi]
	WORD yMax;   // maximum page height [pixels]
}
	VIEWINFO, FAR* LPVIEWINFO;
	
/*==============================================================================
This initialization procedure creates a context for use in all subsequent calls.
Upon call, the lpwBandSize parameter point to the preferred output band buffer 
size.  Upon return, it may be filled with a larger value if required.
==============================================================================*/
LPVOID                // returns context (NULL on failure)
WINAPI
ViewerOpen
(
	LPVOID     lpFile,      // IFAX key or Win3.1 path or OLE2 IStream
	DWORD      nType,       // data type: HRAW_DATA or LRAW_DATA
	LPWORD     lpwResoln,   // output pointer to x, y dpi array
	LPWORD     lpwBandSize, // input/output pointer to output band size
	LPVIEWINFO lpViewInfo   // output pointer to VIEWINFO struct
);

/*==============================================================================
This procedure sets the current page.  The first page has index 0.
==============================================================================*/
BOOL                   // returns success/failure
WINAPI      
ViewerSetPage
(
	LPVOID lpContext,    // context pointer
	UINT   iPage         // page index
);

/*==============================================================================
This procedure may be called repeatedly to fetch successive bands of a page.  
Upon call, lpbmBand->bmBits must point to an output band buffer.  Upon return, 
the remaining fields of lpbmBand will be filled.  The lpbmBand->bmHeight will 
be set to 0 to indicate end of page.
==============================================================================*/
BOOL                  // returns success/failure
WINAPI
ViewerGetBand
(
	LPVOID   lpContext, // context pointer
	LPBITMAP lpbmBand 
);

/*==============================================================================
This termination call releases the context.
==============================================================================*/
BOOL WINAPI ViewerClose
(
	LPVOID lpContext
);

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _INC_VIEWREND
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\inc\viewerob.h ===
/*
   Microsoft Corp. (C) Copyright 1994
   Developed under contract by Numbers & Co.
----------------------------------------------------------------------------

        name:   Elliot Viewer - Chicago Viewer Utility
        						Cloned from the IFAX Message Viewing Utility

	 	file:	viewerob.h

    comments:	Class definitions for Viewer and ViewPage Objects.
    
	These objects are interface wrappers for the original IFAX viewer
	C code. All of the viewer's static variables and whatnot are collected
	here so that multiple independant viewers can be created to support 
	multiple open documents/pages. The innards of the viewer objects are 
	essentially the same as the original except for necessary fiddles to 
	allow functions to get at things that used to be static but are now
	private object data. The original innards just scream to be converted
	to C++ but time constraints didn't allow that...
 			
 	If a struct or occasional whatnot seems a bit clumsy it is probably
 	a relic leftover from the above original clone code. It works...
     	
		NOTE: This header must be used with the LARGE memory model
		
----------------------------------------------------------------------------
   Microsoft Corp. (C) Copyright 1994
   Developed under contract by Numbers & Co.
*/



#ifndef VIEWEROB_H
#define VIEWEROB_H


//#include <ole2.h>

/*
	Specials for WIN32 and WIN16 coexistance
 */
#ifdef WIN32
#define huge
#endif
   

/*
	Unicode spasms
 */
#ifndef WIN32
#ifndef TCHAR
typedef char TCHAR;
#endif
 
#ifndef _T
#define _T(x)	x
#endif

#ifndef LPTSTR
typedef TCHAR FAR *LPTSTR;
#endif

#ifndef LPTCH
typedef TCHAR FAR *LPTCH;
#endif
#endif   
   
   

/*
	Constants and defs
 */

#define OK		0
#define FAIL   -1

#define TRUE	1
#define FALSE	0

#define RESET   2
#define RESET2  3

                

#define MAX_INI_STR			256
#define MAX_STR_LEN			80
#define MAX_MEDIUMSTR_LEN	40
#define MAX_SHORTSTR_LEN	20
#define MAX_EXTSTR_LEN		3
#define MAX_COORD			32767
#define MIN_COORD  		   -32768


#define BORDER_SCROLL_SCALE	2
#define MAX_FILENAME_LEN 	13      

#ifdef WIN32
#define MAX_PATHNAME_LEN	MAX_PATH
#else
#define MAX_PATHNAME_LEN	256
#endif

#define MAX_BANDBUFFER		65536
#define MAX_VOPENBUF		65000
#define MAX_STREAM_BUF		32000
#define PAGESIZE_GUESS		(4*MAX_BANDBUFFER)


#define TEXT_FOREGROUND		RGB( 255,255,255 )
#define TEXT_BACKGROUND		RGB( 128,128,128 )



/*
	Zoom factors
 */
#define MAX_ZOOM					  100
#define INITIAL_ZOOM				  100
#define THUMBNAIL_ZOOM					5										  
#define DEFAULT_DPI					   80 // 800 pixels, 10 inch screen, used 
										  //  for demo bitmaps.


/*
	Rotation "angles"
 */
#define RA_0				0
#define RA_90               90
#define RA_180              180
#define RA_270              270
#define RA_360              360




// BKD 1997-7-9: commented out.  Already defined in buffers.h
// Standard Bit Valued MetaData values
//#define LRAW_DATA         0x00000008
//#define HRAW_DATA         0x00000010
#ifndef LRAW_DATA
#include "buffers.h"
#endif

          
          
/*
	BitBlt display defaults
 */
#define PRIMARY_BLTOP	  SRCCOPY
#define ALTERNATE_BLTOP	  NOTSRCCOPY


/*
	Timer ids
 */
#define DELAYED_OPEN_TIMER 1          
#define DRAG_TIMER		   2          
#define THUMB_FLAME_TIMER  3
          


/*
	Misc types
 */ 
typedef unsigned char 	uchar;
typedef unsigned int 	uint;
typedef unsigned short 	ushort;
typedef unsigned long 	ulong;

   
/*  
	My version of RECT
 */
typedef struct
	{
	int x_ul, y_ul;		// Upper left xy loc
	int x_lr, y_lr;		// Lower left xy loc
	int width, height;
	}
	winrect_type;
	

/*
	The "attachment" table. This is used to save the header info in a
	Chicago style viewer-message file, slightly processed.
 */	
typedef struct 
	{
	char	 *atchname;	// stream name for attachment (document)
	LONG	  numpages; // number of pages in atchname
	short     binfile;  // TRUE -> something we can't look at.
	short	  isademo;	// TRUE -> use demo version of viewrend (vrdemo)
	
	// document state (this section is 32bit aligned at this point)
	DATE  dtLastChange;
	DWORD awdFlags;
	WORD  Rotation;
	WORD  ScaleX;
	WORD  ScaleY;
	} 
	attachment_table_type;


/*
	Struct for keeping track of whats in the attachment table,
	whats viewable and what isn't, etc.
 */
typedef struct
	{              
	short				  is_displayable;   // TRUE -> viewable
	HBITMAP				  hbmp;				// "icon" for non viewable attachments
	uint    			  page_offset; 		// From first displayable attachment.
	attachment_table_type *at;				// ptr to attachment table.
	}
	attachment_type;
	


/*
	Struct for keeping track of viewrend bands
 */	
typedef struct
	{
	long height_bytes;
	long first_scanline;
	}
	band_height_type;	


/*	
	Struct defining a "viewdata" object. This should be a converted to be
	a real c++ object but time constaints dictated I use it as is.
 */
typedef struct
	{
	BITMAP		 bmp;			// Raw bitmap data (NOT a GDI bitmap)
								//	NOTE: This data is NEVER rotated
								//		  (always RA_0) but can be
								//		  scaled.
								
	HBITMAP 	 hbmp;			// Handle for in memory bitmap
	HDC			 mem_hdc;		// DC for blting it to a window
	RECT 		 isa_edge;		// Flags for bitmap/file edge correspondance
	winrect_type bmp_wrc;		// Loc and size of bitmap rel to file bitmap
	
	short		 dragging;		// Bitmap is being dragged if TRUE
	
	short		 copying;		// Bitmap is being select/copied to clipboard
	RECT 		 copy_rect;		// Area to copy
	short		 copy_rect_valid; // copy_rect has valid data
	short        first_copy_rect; // flag to init focus rect
	POINT		 copyanchor_pt;
	POINT		 viewanchor_pt;
	
	winrect_type viewwin_wrc;	// Loc and size of window to drag in	                 
	winrect_type view_wrc;		// Loc and size of view window rel to bitmap
	POINT		 last_file_wrc_offset; // used for adjusting view_wrc before
									   //  rotations 
	POINT		 last_cursor;	// Last cursor loc during a drag
	int			 bdrscrl_scale;	// Scale factor for border scroll increments
	
	RECT		 left_erase;	// Rects for erasing the bitmap's
	RECT		 top_erase;		//   previous position during a drag.
	RECT		 right_erase;	
	RECT		 bottom_erase;	
	
	short		 left_iserased; // Draw corespnding erase rect if TRUE
	short		 top_iserased;	//	 during a drag.
	short		 right_iserased;
	short		 bottom_iserased;
	

	/*
		If hfile != HFILE_ERROR then the band parameters are undefined. Otherwise
		they are defined only if hbmp does not contain the entire page bmp
	 */	                                                              
	HFILE 		 hfile;			// Handle for file bitmap   
	band_height_type *band_heights;  // Array of Rajeev band heights
	short		 num_bands;		// Number of bands
	short		 current_band;	// Currently selected band
	TCHAR		 filename[MAX_FILENAME_LEN+1];
	winrect_type file_wrc;		// Loc (always=0) and size of file bitmap;
	winrect_type prescale_file_wrc;	// file_wrc / x,y_prescale
	int		 	 x_dpi;			// x dots per inch
	int		 	 y_dpi;			// y dots per inch
    uint		 linebytes;  	// Total bytes per scanline
    uint		 num_planes;	// Number of planes
    uint		 bits_per_pix;  // Bits per pixel in a plane
    
    short		 has_data;		// Bitmap and/or bmBits contains data.
    short		 in_mem; 		// All data fits in memory.
	}
	viewdata_type;



typedef int
	(WINAPI *IFMESSPROC)( char *, int );
 
 

	
/*
	This struct is for reading/writing SummaryStreams. It was
	in oleutils.h but I moved it here so every module in the 
	Viewer doesn't have to pull in oleutils.h because of the 
	summary_info_t variable in CViewer.
 */
typedef struct
	{
	LPSTR revnum;
	DATE  last_printed;
	DATE  when_created;
	DATE  last_saved;
	DWORD num_pages;
	LPSTR appname;
	DWORD security;
	LPSTR author;
	}
	summary_info_t;






/*
	Macros
 */		
#define WIDTHSHORTS( width, bits_per_pix )									\
		((((long)width)*bits_per_pix + 15)/16)



#define V_WIDTHBYTES( width, bits_per_pix )									\
		(WIDTHSHORTS( width, bits_per_pix )*2)


#define BITMAPSTRIDE( widthbytes, height )									\
		(((long)widthbytes) * height)



#define BITMAPWIDTHBYTES( widthbytes, height, planes )						\
		(BITMAPSTRIDE( widthbytes, height )*planes)


#define BITMAPBYTES( width, bits_per_pix, height, planes )					\
		(BITMAPWIDTHBYTES( V_WIDTHBYTES( width, bits_per_pix ), 				\
						   height, 											\
						   planes ))



#define SWAP_SHORT_BYTES( short_to_swap )									\
		__asm                                                               \
		{                                                                   \
		__asm mov	ax, short_to_swap                                       \
		__asm xchg	ah, al                                                  \
		__asm mov	short_to_swap, ax                                       \
		}



#define SWAP_LONG_BYTES( long_to_swap )										\
		__asm																\
		{                                                                   \
		__asm mov	ax, word ptr long_to_swap[2]                            \
		__asm xchg	ah, al                                                  \
		__asm xchg	word ptr long_to_swap[0], ax                            \
		__asm xchg	ah, al                                                  \
		__asm mov	word ptr long_to_swap[2], ax                            \
		}





















/*
	Global data
 */
extern /*IFMSGBOXPROC*/IFMESSPROC IfMessageBox_lpfn;
extern TCHAR    viewer_homedir[MAX_PATHNAME_LEN+1];
extern short    ra360_bugfix;
extern DWORD	cshelp_map[];


/*
	Non object viewer functions
 */
extern short
	InitializeViewer( void );


/* WARNING * WARNING * WARNING * HACKHACKHACKHACKHACKHACKHACKHACK */
/*   hack so CViewerPage::print_viewdata can call AbortProc       */
typedef BOOL (CALLBACK *utils_prtabortproc_type)(HDC, int);
extern utils_prtabortproc_type utils_prtabortproc;
/******************************************************************/


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\migrate\debug.h ===
#ifndef __DEBUG_H
#define __DEBUG_H
// debug.h
//
// Copyright (c) 1997  Microsoft Corporation
//
// This header contains definitions for debug trace macros that are used
// by the migration DLL.
//
// Author:
//	Brian Dewey (t-briand)  1997-8-4

void dprintf(LPTSTR Format, ...);
void DebugSystemError(DWORD dwErrCode);

#ifdef NDEBUG
#define TRACE(_x_) dprintf _x_
#else
#define TRACE(_x_)
#endif // NDEBUG

#endif // __DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\migrate\debug.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This file implements the debug code for the
    fax project.  All components that require
    debug prints, asserts, etc.

Author:

    Wesley Witt (wesw) 22-Dec-1995

    Minor modifications by Brian Dewey (t-briand) 4-Aug-1997
      -- to work with the FAX migration DLL.

Environment:

    User Mode

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <setupapi.h>

BOOL ConsoleDebugOutput = FALSE;


VOID
ConsoleDebugPrint(
    LPTSTR buf
    )
{
}


void
dprintf(
    LPTSTR Format,
    ...
    )

/*++

Routine Description:

    Prints a debug string

Arguments:

    format      - printf() format string
    ...         - Variable data

Return Value:

    None.

--*/

{
    TCHAR buf[1024];
    DWORD len;
    static TCHAR AppName[16];
    va_list arg_ptr;
    SYSTEMTIME CurrentTime;


    if (AppName[0] == 0) {
        if (GetModuleFileName( NULL, buf, sizeof(buf) )) {
            _tsplitpath( buf, NULL, NULL, AppName, NULL );
        }
    }

    va_start(arg_ptr, Format);

    GetLocalTime( &CurrentTime );
    _stprintf( buf, TEXT("%x   %02d:%02d:%02d.%03d  %s: "),
        GetCurrentThreadId(),
        CurrentTime.wHour,
        CurrentTime.wMinute,
        CurrentTime.wSecond,
        CurrentTime.wMilliseconds,
        AppName[0] ? AppName : TEXT("")
        );
    len = _tcslen( buf );

    _vsntprintf(&buf[len], sizeof(buf)-len, Format, arg_ptr);

    len = _tcslen( buf );
    if (buf[len-1] != TEXT('\n')) {
        buf[len] = TEXT('\r');
        buf[len+1] = TEXT('\n');
        buf[len+2] = 0;
    }

    OutputDebugString( buf );
#ifndef TEST_WIN95	
    SetupLogError(buf, LogSevInformation);
#else
	// When testing win95, we write to the console instead of the
	// setup log.
    _ftprintf(stderr, buf);
#endif

    _stprintf( buf, TEXT("%02d:%02d:%02d.%03d  "),
        CurrentTime.wHour,
        CurrentTime.wMinute,
        CurrentTime.wSecond,
        CurrentTime.wMilliseconds
        );
    len = _tcslen( buf );

    _vsntprintf(&buf[len], sizeof(buf)-len, Format, arg_ptr);

    ConsoleDebugPrint( buf );
}


VOID
AssertError(
    LPTSTR Expression,
    LPTSTR File,
    ULONG  LineNumber
    )

/*++

Routine Description:

    Thie function is use together with the Assert MACRO.
    It checks to see if an expression is FALSE.  if the
    expression is FALSE, then you end up here.

Arguments:

    Expression  - The text of the 'C' expression
    File        - The file that caused the assertion
    LineNumber  - The line number in the file.

Return Value:

    None.

--*/

{
    dprintf(
        TEXT("Assertion error: [%s]  %s @ %d\n"),
        Expression,
        File,
        LineNumber
        );

    __try {
        DebugBreak();
    } __except (UnhandledExceptionFilter(GetExceptionInformation())) {
        // Nothing to do in here.
    }
}

// DebugSystemError
//
// Displays a system error message on the debug console.
//
// Parameters:
//	dwSysErrorCode		The system error code returned by GetLastError().
//
// Returns:
//	Nothing.
//
// Side effects:
//	Does a dprintf() of the message associated with an error code.
//
// Author:
//	Brian Dewey (t-briand)	1997-7-25
void
DebugSystemError(DWORD dwSysErrorCode)
{
    TCHAR szErrorMsg[MAX_PATH];	// Holds our message.

    FormatMessage(
	FORMAT_MESSAGE_FROM_SYSTEM, // We're given a system error code.
	NULL,			// No string.
	dwSysErrorCode,		// The error code.
	0,			// Default language.
	szErrorMsg,		// The error message.
	sizeof(szErrorMsg),	// Size of our buffer.
	NULL			// No arguments.
	);
    dprintf(szErrorMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\migrate\resource.h ===
// resource.h
//
// Copyright (c) 1997  Microsoft Corporation
//
// Resource IDs for the fax migration DLL.
//
// Author:
// 	Brian Dewey (t-briand)	1997-8-19

#define IDS_ID		200
#define IDS_NTINFNAME	201
#define IDS_FAXSTORE	202
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\migrate\makefile.inc ===
msg.mc: $(BASE_INC_PATH)\vendinfo.mc
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\migrate\migrate.c ===
/*++
  migrate.c

  Copyright (c) 1997  Microsoft Corporation


  This module performs Windows 95 to Windows NT fax migration.
  Specifically, this file contains the Windows NT side of migration...

  Author:

  Brian Dewey (t-briand) 1997-7-14

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <setupapi.h>
#include <wchar.h>
#include <tchar.h>
#include "migrate.h"              // Contains prototypes & version information.
#include "debug.h"                // Includes TRACE definition
#include "resource.h"             // Resources.

// ------------------------------------------------------------
// Global data

// Wide names of the working & source directories.
static WCHAR lpWorkingDir[MAX_PATH],
    lpSourceDir[MAX_PATH];
HINSTANCE hinstMigDll;

// ------------------------------------------------------------
// Prototypes
static BOOL CreateKeyAndValue(HKEY hRoot, LPWSTR szSubKey, LPWSTR szName, LPWSTR szDefaultValue);

BOOL WINAPI
DllEntryPoint(HINSTANCE hinstDll, DWORD dwReason, LPVOID lpReserved)
{
    if(dwReason == DLL_PROCESS_ATTACH) {
        TRACE((TEXT("Migration DLL attached.\r\n")));
        hinstMigDll = hinstDll;
    }
    return TRUE;
}

// InitializeNT
//
// This routine performs NT-side initialization.
//
// Parameters:
//      Documented below.
//
// Returns:
//      ERROR_SUCCESS.
//
// Author:
//      Brian Dewey (t-briand)  1997-7-14
LONG
CALLBACK
InitializeNT(
    IN  LPCWSTR WorkingDirectory, // Working directory for temporary files.
    IN  LPCWSTR SourceDirectory,  // Directory of winNT source.
    LPVOID Reserved               // It's reserved.
    )
{
    TRACE((TEXT("Fax Migration:NT Side Initialized.\r\n")));
    wcscpy(lpWorkingDir, WorkingDirectory);
    wcscpy(lpSourceDir, SourceDirectory);
    return ERROR_SUCCESS;         // A very confused return value.
}


// MigrateUserNT
//
// Sets up user information.
//
// Parameters:
//      Documented below.
//
// Returns:
//      ERROR_SUCCESS.
//
// Author:
//      Brian Dewey (t-briand)  1997-7-14
LONG
CALLBACK
MigrateUserNT(
    IN  HINF UnattendInfHandle,   // Access to the unattend.txt file.
    IN  HKEY UserRegHandle,       // Handle to registry settings for user.
    IN  LPCWSTR UserName,         // Name of the user.
    LPVOID Reserved
    )
{
        // our task:  copy entries from szInfFileName to the registry.
    LPTSTR lpNTOptions = TEXT("Software\\Microsoft\\Fax\\UserInfo");
    HKEY   hReg;                  // Registry key for user.
    LPCTSTR alpKeys[] = {         // This array defines what keys will be
        TEXT("Address"),          // copied from faxuser.ini into the registry.
        TEXT("Company"),
        TEXT("Department"),
        TEXT("FaxNumber"),
        TEXT("FullName"),
        TEXT("HomePhone"),
        TEXT("Mailbox"),
        TEXT("Office"),
        TEXT("OfficePhone"),
        TEXT("Title")
    };
    UINT iCount, iMax;            // used for looping through all the sections.
    UINT i;                       // Used for converting doubled ';' to CR/LF pairs.
    TCHAR szValue[MAX_PATH];
    TCHAR szInfFileNameRes[MAX_PATH];
    TCHAR szUser[MAX_PATH];       // TCHAR representation of the user name.
    LONG  lError;                 // Holds a returned error code.

    if(UserName == NULL) {
            // NULL means the logon user.
        _tcscpy(szUser, lpLogonUser);// Get the logon user name for faxuser.ini
    } else {
#ifdef _UNICODE
        // If this is a unicode compile, UserName and szUser are the same.  Just
        // copy one to the other.
    wcscpy(szUser, UserName);
#else
        // We need to convert the wide UserName to the narrow szUser.
    WideCharToMultiByte(
        CP_ACP,                   // Convert to ANSI.
        0,                        // No flags.
        UserName,                 // The wide char set.
        -1,                       // Null-terminated string.
        szUser,                   // Holds the converted string.
        sizeof(szUser),           // Size of this buffer...
        NULL,                     // Use default unmappable character.
        NULL                      // I don't need to know if I used the default.
        );
#endif // _UNICODE
    }

    TRACE((TEXT("(MigrateUserNT):Migrating user '%s'.\r\n"), szUser));

    if(RegOpenKeyEx(UserRegHandle,
                    lpNTOptions,  // Open this subkey.
                    0,            // Reserved.
                    KEY_WRITE,    // We want write permission.
                    &hReg) != ERROR_SUCCESS) {
            // All I'm allowed to do is return obscure error codes...
            // However, unless there's a hardware failure, I'm supposed to say
            // everything's OK.
        return ERROR_SUCCESS;
    }

    iMax = sizeof(alpKeys) / sizeof(LPCTSTR);

    _stprintf(szInfFileNameRes, TEXT("%s\\migrate.inf"), lpWorkingDir);
    
    ExpandEnvironmentStrings(szInfFileNameRes, szInfFileName, MAX_PATH);

    TRACE((TEXT("Reading from file %s.\r\n"), szInfFileName));
    for(iCount = 0; iCount < iMax; iCount++) {
        GetPrivateProfileString(
            szUser,
            alpKeys[iCount],
            TEXT(""),
            szValue,
            sizeof(szValue),
            szInfFileName
            );
            // If there was a CR/LF pair, the w95 side of things converted it
            // to a doubled semicolon.  So I'm going to look for doubled semicolons
            // and convert them to CR/LF pairs.
        i = 0;
        while(szValue[i] != _T('\0')) {
            if((szValue[i] == _T(';')) && (szValue[i+1] == _T(';'))) {
                    // Found a doubled semicolon.
                szValue[i] = '\r';
                szValue[i+1] = '\n';
                TRACE((TEXT("Doing newline translation.\r\n")));
            }
            i++;
        }
        lError = RegSetValueEx(hReg,
                               alpKeys[iCount],
                               0,
                               REG_SZ,
                               szValue,
                               _tcslen(szValue)+1);
        if(lError != ERROR_SUCCESS) {
            TRACE((TEXT("Error in RegSetValueEx():%x\r\n"), lError));
            return lError;
        }
        TRACE((TEXT("%s = %s\r\n"), alpKeys[iCount], szValue));
    }
    RegCloseKey(hReg);
    return ERROR_SUCCESS;         // A very confused return value.
}


// MigrateSystemNT
//
// Updates the system registry to associate 'awdvstub.exe' with the
// AWD extension.
//
// Parameters:
//      Documented below.
//
// Returns:
//      ERROR_SUCCESS.
//
// Author:
//      Brian Dewey (t-briand)  1997-7-14
LONG
CALLBACK
MigrateSystemNT(
    IN  HINF UnattendInfHandle,   // Access to the unattend.txt file.
    LPVOID Reserved
    )
{
    WCHAR szExeFileName[MAX_PATH];
    WCHAR szWindowsDir[MAX_PATH];
    WCHAR szDestFile[MAX_PATH];
    WCHAR szOpenCommand[MAX_PATH + 16];
    WCHAR szConvertCommand[MAX_PATH + 16]; // "*" /c "%1"


    // first, copy 'awdvstub.exe' to %SystemRoot%\system32.
    GetWindowsDirectoryW(szWindowsDir, MAX_PATH);
    swprintf(szExeFileName, L"%s\\%s", lpWorkingDir, L"awdvstub.exe");
    swprintf(szDestFile, L"%s\\system32\\%s", szWindowsDir, L"awdvstub.exe");
    if(!CopyFileW(szExeFileName,
                 szDestFile,
                 FALSE)) {
        TRACE((TEXT("Fax:MigrateSystemNT:Copy file failed.\r\n")));
    } else {
        TRACE((TEXT("Fax:MigrateSystemNT:Copy file succeeded.\r\n")));
    }

        // Generate the command lines.
    swprintf(szOpenCommand, L"\"%s\" \"%%1\"", szDestFile);
    swprintf(szConvertCommand, L"\"%s\" /c \"%%1\"", szDestFile);
    
        // Now, update the registry.
    CreateKeyAndValue(HKEY_CLASSES_ROOT, NULL, L".awd", L"awdfile");
    CreateKeyAndValue(HKEY_CLASSES_ROOT, NULL, L"awdfile", L"Windows 95 Fax File (obsolete)");
    CreateKeyAndValue(HKEY_CLASSES_ROOT, L"awdfile", L"shell", NULL);
    CreateKeyAndValue(HKEY_CLASSES_ROOT, L"awdfile\\shell", L"open", NULL);
    CreateKeyAndValue(HKEY_CLASSES_ROOT, L"awdfile\\shell\\open", L"command", szOpenCommand);
    CreateKeyAndValue(HKEY_CLASSES_ROOT, L"awdfile\\shell", L"convert", L"Convert to TIFF");
    CreateKeyAndValue(HKEY_CLASSES_ROOT, L"awdfile\\shell\\convert",
                      L"command", szConvertCommand);
    return ERROR_SUCCESS;         // A very confused return value.
}

// CreateKeyAndValue
//
// This routine will create a registry key and assign it a default value.
//
// Parameters:
//      hRoot                   An open registry key.
//      szSubKey                A subkey in which the new key will be created.  May be NULL.
//      szName                  Name of the new key.  May not be NULL.
//      szDefaultValue          Default value for the key.  May be NULL.
//
// Returns:
//      TRUE on success, FALSE on failure.
//
// Author:
//      Brian Dewey (t-briand)  1997-8-7
static BOOL
CreateKeyAndValue(HKEY hRoot, LPWSTR szSubKey, LPWSTR szName, LPWSTR szDefaultValue)
{
    HKEY  hSubKey;                // Subkey registry key.
    HKEY  hKey;                   // Registry key.
    DWORD dwDisposition;          // used in api calls.
    UINT  uiStrLen;
    BOOL  bCloseSubKey = FALSE;   // Do we need to close hSubKey?

    if(szSubKey != NULL) {
        if(RegOpenKeyExW(
            hRoot,
            szSubKey,
            0,
            KEY_CREATE_SUB_KEY,
            &hSubKey
            ) != ERROR_SUCCESS) {
            TRACE((TEXT("CreateKeyAndValue:Unable to open subkey.\r\n")));
            return FALSE;
        } // if(RegOpenKeyExW())
        bCloseSubKey = TRUE;
    } else {
        hSubKey = hRoot;          // The subkey is the root...
    }
    
        // Now, set up the registry.  There are WAY TOO MANY PARAMETERS in this
        // darn API.  Some designer needs to chill out!
    if(RegCreateKeyExW(
        hSubKey,
        szName,                   // We're worried about this extension.
        0,                        // Reserved.
        NULL,                     // I have no idea what to put here.  Hope this works!
        REG_OPTION_NON_VOLATILE,  // This is the default, but I decided to be explicit.
        KEY_ALL_ACCESS,           // Be generous with security.
        NULL,                     // No child process inheritance.
        &hKey,                    // Store the key here.
        &dwDisposition            // The disposition of the call...
        ) != ERROR_SUCCESS) {
        TRACE((TEXT("Fax:MigrateSystemNT:Unable to create registry entry.\r\n")));
    } else {
        TRACE((TEXT("Fax:MigrateSystemNT:Created key; disposition = %s.\r\n"),
               (dwDisposition == REG_CREATED_NEW_KEY) ?
               TEXT("REG_CREATED_NEW_KEY") :
               TEXT("REG_OPENED_EXISTING_KEY")));
    }

        // Only set the value if they passed in a value.
    if(szDefaultValue != NULL) {
        uiStrLen = wcslen(szDefaultValue);
        if(RegSetValueExW(
            hKey,
            NULL,                 // Trying to set the default value.
            0,                    // Reserved.
            REG_SZ,               // Setting a string value.
            (LPBYTE)szDefaultValue,
            (uiStrLen+1) * sizeof(WCHAR)
            ) != ERROR_SUCCESS) {
            TRACE((TEXT("Fax:MigrateSystemNT:Unable to set default value.\r\n")));
        } else {
            TRACE((TEXT("Fax:MigrateSystemNT:Default value set.\r\n")));
        } // if(RegSetValueExW())...
    } // if(szDefaultValue != NULL)...
    RegCloseKey(hKey);
    if(bCloseSubKey) RegCloseKey(hSubKey);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\w95fdump\w95fdump.c ===
/*++
  w95fdump.c

  Copyright (c) 1997  Microsoft Corporation

  This utility dumps configuration information about the win95 fax.
  It pulls this information from the registry...
  This is primarily a warm-up application for win95->NT migration; the migration
  DLL will need to get all of this information to configure the NT setup.

  Author:
  Brian Dewey (t-briand)  1997-7-18
--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <setupapi.h>
#include "migrate.h"            // Includes my migration prototypes.

// ------------------------------------------------------------
// Prototypes
BOOL EnumUsers();

// ------------------------------------------------------------
// main

int _cdecl
main(int argc, char *argv[])
{
    LPCSTR ProductID;           // Will hold the ID string from my DLL.
    UINT   DllVersion;          // Holds the version of the DLL.
    LPINT  CodePageArray;       // Locale info.
    LPCSTR ExeNamesBuf;         // Executables to look for.
    LPVOID Reserved = NULL;     // Placeholder.
    
        // Print banner.
    fprintf(stderr, "Win32 Fax Configuration Dump Utility\n");
    fprintf(stderr, "Copyright (c) 1997  Microsoft Corporation\n");
    QueryVersion(&ProductID, &DllVersion, &CodePageArray, &ExeNamesBuf, Reserved);
    fprintf(stderr, "Library '%s' version %d.\n", ProductID, DllVersion);

        // Simulate the initialization.
    Initialize9x(".", ".", Reserved);

        // This will try to gather all user information.
    if(EnumUsers())
        fprintf(stderr, "User migration succeeded.\n");
    else {
        fprintf(stderr, "User migration failed, exiting...\n");
        return 1;
    }

        // Finally, try to migrate the system.
    if(MigrateSystem9x(NULL, ".\\unattend.txt", Reserved) != ERROR_SUCCESS) {
        fprintf(stderr, "System migration failed.\n");
        return 1;
    } else {
        fprintf(stderr, "System migration succeeded.\n");
    }
    
    return 0;
}

// ------------------------------------------------------------
// Auxiliary functions
BOOL
EnumUsers()
{
    DWORD  dwIndex;             // Index of the HKEY_USERS subkey.
    TCHAR  szKeyName[MAX_PATH]; // Name of the subkey.
    DWORD  cbBufSize;           // Size of the name buffer.
    FILETIME ftTime;            // Will hold the time the key was last modified.
    HKEY   hUserKey;            // Registry key for a user.
    LONG   lResult;             // Result codes from API calls.
    LONGLONG llDiskSpace,       // Total disk space used.
        llComponentSpace;       // Component space required.

    dwIndex = 0;
    cbBufSize = sizeof(szKeyName);
    while(RegEnumKeyEx(HKEY_USERS, // We're enumerating through the users.
                       dwIndex++, // Keep incrementing the index!
                       szKeyName, // Will hold the name of the subkey.
                       &cbBufSize, // Will hold the # of characters in the key name.
                       NULL,    // Reserved; must be NULL.
                       NULL,    // Class info (I don't need this).
                       NULL,    // size of class info -- not needed.
                       &ftTime) == ERROR_SUCCESS) {
        _tprintf(TEXT("User %s.\n"), szKeyName);
            // Open the key.
        if((lResult = RegOpenKeyEx(HKEY_USERS,
                                   szKeyName,
                                   0,           // Zero options.
                                   KEY_READ,    // Read-only permission.
                                   &hUserKey)) != ERROR_SUCCESS) {
                // FIXBKD: Use FormatMessage
            _ftprintf(stderr, TEXT("EnumUsers:Unable to open key for user %s.\n"),
                      szKeyName);
            return FALSE;
        }

            // Call the migration DLL MigrateUser9x routine.
        MigrateUser9x(
            NULL,               // No window for UI.
            "unattend.txt",     // Sample unattend file.
            hUserKey,           // Key to the user's part of the registry.
            szKeyName,          // Pass in the user's name.
            &llComponentSpace   // Receive the amount of space needed.
            );

        RegCloseKey(hUserKey);  // Close the key.
        cbBufSize = sizeof(szKeyName); // Reset size indicator.
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\wntmig\ntmigrate.c ===
/*++
  Copyright (c) 1997  Microsoft Corporation

  This module tests the NT side of my migration DLL.

  Assumptions:

     * There's no work to do migrating users.  That's all done by fax setup.
     * The migration DLL doesn't need the unattend file.
     * awdvstub.exe is in the same directory.

  Author:
  Brian Dewey (t-briand)	1997-7-25
--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <setupapi.h>
#include "migrate.h"

// ------------------------------------------------------------
// Prototypes
void SystemError(DWORD dwSysErrorCode);

// ------------------------------------------------------------
// main
int _cdecl
main()
{
    LPVOID Reserved = NULL;
    HINF   hUnattend;		// Handle to the unattend file.
    UINT   iLineNo;		// Will hold the number of an offending line.
    DWORD  dwSysError;		// Error code...
    LONG   lError;		// Returned error code.
    TCHAR  szFileName[] = TEXT("f:\\nt\\private\\awd2tiff\\bin\\i386\\unattend.txt");

    fprintf(stderr, "Windows NT Sample Migration Tool.\n");
    fprintf(stderr, "Copyright (c) 1997  Microsoft Corporation.\n\n");

    if(InitializeNT(L"dump", L"dump", Reserved) != ERROR_SUCCESS) {
	fprintf(stderr, "NTMigrate:Migration DLL initialization failed, exiting...\n");
	exit(1);
    } else {
	fprintf(stderr, "NT side of migration DLL successfully initialized.\n");
    }

	// TODO:  migrate the system.
    MigrateSystemNT(NULL, NULL);
    return 0;
}

// ------------------------------------------------------------
// Auxiliary functions

// SystemError
//
// Displays a system error message on stderr.
//
// Parameters:
//	dwSysErrorCode		The system error code returned by GetLastError().
//
// Returns:
//	Nothing.
//
// Side effects:
//	Prints the error message on stderr.
//
// Author:
//	Brian Dewey (t-briand)	1997-7-25
void
SystemError(DWORD dwSysErrorCode)
{
    TCHAR szErrorMsg[MAX_PATH];	// Holds our message.

    fprintf(stderr, "In SystemError(): Error code = %x.\n", dwSysErrorCode);
    FormatMessage(
	FORMAT_MESSAGE_FROM_SYSTEM, // We're given a system error code.
	NULL,			// No string.
	dwSysErrorCode,		// The error code.
	0,			// Default language.
	szErrorMsg,		// The error message.
	sizeof(szErrorMsg),	// Size of our buffer.
	NULL			// No arguments.
	);
    _ftprintf(stderr, szErrorMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\win9xupg\migrate\w95mig.c ===
/*++
  w95mig.c

  Copyright (c) 1997  Microsoft Corporation


  This module contains the win95 side of the migration code.

  Author:

  Brian Dewey (t-briand) 1997-7-18

--*/

#include <windows.h>
#include <setupapi.h>
#include <mapidefs.h>
#include <mapitags.h>           // To get the property definitions.
#include <stdio.h>
#include <tchar.h>
#include "migrate.h"            // Contains prototypes & version information.
#include "property.h"           // Stolen from Elliott -- contains their fax properties
#include "debug.h"              // for tracing.
#include "resource.h"           // Migration resources.
#include "msg.h"

// ------------------------------------------------------------
// Defines & macros
#define SWAPWORD(x) (((x) << 16) | ((x) >> 16))

// ------------------------------------------------------------
// Internal data

// First, this is the name of the INF file that we generate.
static TCHAR szInfFileBase[]    = TEXT("migrate.inf");
TCHAR szInfFileName[MAX_PATH];  // This will be the fully qualified path of the above.

static char  lpWorkingDir[MAX_PATH];     // This is our working directory.
static TCHAR szDoInstall[4];             // Will be either "No" or "Yes".
static TCHAR szFaxPrinterName[MAX_PATH]; // Name of the fax printer.
static TCHAR szFaxAreaCode[16];          // Contains the fax modem area code.
static TCHAR szFaxNumber[9];             // Fax # w/o area or country code.
static TCHAR szNTProfileName[MAX_PATH];  // Profile to use for routing.
static TCHAR szFaxStoreDir[MAX_PATH];    // Folder to use for routing.
static TCHAR szUserName[MAX_PATH];       // This will be the user's name who owns the fax service.
static TCHAR szUserID[MAX_PATH];         // This is the login name of the user who owns the fax.
static TCHAR szPerformInstall[16];       // Will be szPerformYes or szPerformNo.
static TCHAR szPerformYes[]     = TEXT("New"); 
static TCHAR szPerformNo[]      = TEXT("Skip");

// The following are section names from the Microsoft registry.
// They're used to find the fax profile for a user.
static const LPTSTR LPUSERPROF  = TEXT("Software\\Microsoft\\Windows Messaging Subsystem\\Profiles");
static const LPTSTR LPPROFNAME  = TEXT("DefaultProfile");

// The following's part of the path to the Exchange profile in question.
static const LPTSTR LPPROFILES  = TEXT("Software\\Microsoft\\Windows Messaging Subsystem\\Profiles");

// This is how we find the fax printer.
static const LPTSTR LPPRINTER   = TEXT("System\\CurrentControlSet\\control\\Print\\Printers");

// This is how we get the root UID.
static const LPTSTR LPPROFUID   = TEXT("Profile UID");

// This is the name we use for the logon user section of 'faxuser.ini'
LPCTSTR lpLogonUser             = TEXT("Logon User");

// This keeps track of the number of users migrated.  Used to make annotations
// in the INF file.
static DWORD dwUserCount = 0;

// ------------------------------------------------------------
// Internal function prototypes
static BOOL GetUserProfileName(HKEY hUser, LPTSTR lpProfName, DWORD cbSize);
static BOOL GetFaxPrinterName(LPTSTR lpPrinterName, DWORD cbSize);
static BOOL GetRegProfileKey(HKEY hUser, LPTSTR lpProfName, PHKEY phRegProfileKey);
static void DumpUserInfo(HKEY hUserInfo, LPCSTR UserName, LPTSTR szProfileName);
static void SetGlobalFaxNumberInfo(LPCTSTR szPhone);
static void GenerateIncompatableMessages();
static BOOL InitializeInfFile(LPCTSTR WorkingDirectory);

typedef struct {
    CHAR    CompanyName[256];
    CHAR    SupportNumber[256];
    CHAR    SupportUrl[256];
    CHAR    InstructionsToUser[1024];
} VENDORINFO, *PVENDORINFO;

VENDORINFO VendorInfo;

// QueryVersion
//
// This routine returns version information about the migration DLL.
//
// Parameters:
//      Commented below.
//
// Returns:
//      ERROR_SUCCESS.
//
// Author:
//      Brian Dewey (t-briand)  1997-7-23
LONG
CALLBACK 
QueryVersion (
        OUT LPCSTR  *ProductID,   // Unique identifier string.
        OUT LPUINT DllVersion,    // Version number.  Cannot be zero.
        OUT LPINT *CodePageArray, // OPTIONAL.  Language dependencies.
        OUT LPCSTR  *ExeNamesBuf, // OPTIONAL.  Executables to look for.
        OUT PVENDORINFO *ppVendorInfo
        )
{
    *ProductID = "Microsoft Fax";
    *DllVersion = FAX_MIGRATION_VERSION;
    *CodePageArray = NULL;        // No language dependencies
    *ExeNamesBuf = NULL;
    *ppVendorInfo = &VendorInfo;

    FormatMessage( 
        FORMAT_MESSAGE_FROM_HMODULE,
        hinstMigDll,
        MSG_VI_COMPANY_NAME,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        &VendorInfo.CompanyName[0],
        sizeof(VendorInfo.CompanyName),
        NULL
        );
    
    FormatMessage( 
        FORMAT_MESSAGE_FROM_HMODULE,
        hinstMigDll,
        MSG_VI_SUPPORT_NUMBER,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        &VendorInfo.SupportNumber[0],
        sizeof(VendorInfo.SupportNumber),
        NULL
        );
    
    FormatMessage( 
        FORMAT_MESSAGE_FROM_HMODULE,
        hinstMigDll,
        MSG_VI_SUPPORT_URL,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        &VendorInfo.SupportUrl[0],
        sizeof(VendorInfo.SupportUrl),
        NULL
        );
    
    FormatMessage( 
        FORMAT_MESSAGE_FROM_HMODULE,
        hinstMigDll,
        MSG_VI_INSTRUCTIONS,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        &VendorInfo.InstructionsToUser[0],
        sizeof(VendorInfo.InstructionsToUser),
        NULL
        );
    
    
    return ERROR_SUCCESS;
}

// Initialize9x
//
// This is called to initialize the migration process.  See the migration dll
// spec for more details.
//
// Parameters:
//      Commented below.
//
// Author:
//      Brian Dewey (t-briand)  1997-7-14
LONG
CALLBACK
Initialize9x(
    IN  LPCSTR WorkingDirectory,  // Place to store files.
    IN  LPCSTR SourceDirectory,   // Location of the Windows NT source.
    LPVOID     Reserved           // Exactly what it says.
    )
{
    TRACE((TEXT("Fax migration DLL initialized.\r\n")));
    InitializeInfFile(WorkingDirectory);
    strncpy(lpWorkingDir, WorkingDirectory, MAX_PATH);
    _tcscpy(szPerformInstall, szPerformNo); // First assume we don't need to install.
    return ERROR_SUCCESS;         // A very confused return value.
}


// MigrateUser9x
//
// This routine records the fax information specific to a user.
//
// Parameters:
//      Documented below.
//
// Returns:
//      ERROR_SUCCESS.
//
// Author:
//      Brian Dewey (t-briand)  1997-7-14
LONG
CALLBACK
MigrateUser9x(
    IN  HWND ParentWnd,           // Parent (if need a UI)
    IN  LPCSTR UnattendFile,      // Name of unattend file
    IN  HKEY UserRegKey,          // Key to this user's registry settings.
    IN  LPCSTR UserName,          // Account name of user.
    LPVOID Reserved
    )
{
    TCHAR szProfileName[MAX_PATH]; // Holds the name of this user's profile.
    HKEY  hRegProfileKey;       // The fax profile key in the registry.
    DWORD dwExceptCode;         // Exception error code
    
    __try {
        TRACE((TEXT("Fax migration dll migrating user.\r\n")));
        if(GetUserProfileName(UserRegKey, szProfileName, sizeof(szProfileName))) {
            TRACE((TEXT("\tProfile name = %s.\r\n"), szProfileName));
            if(GetRegProfileKey(UserRegKey, szProfileName, &hRegProfileKey)) {
                    // We now know we want to do an installation.
                _tcscpy(szPerformInstall, szPerformYes);
                TRACE((TEXT("Successfully got profile information.\r\n")));
                _tcscpy(szNTProfileName, szProfileName); // Remember this name for NT.
                
                    // NULL means the logon user...
                if(UserName != NULL)
                    _tcscpy(szUserID, UserName); // Remember the ID for the unattend.txt file.
                else
                    _tcscpy(szUserID, lpLogonUser); // Use the logon user name.
                
                DumpUserInfo(hRegProfileKey, szUserID, szProfileName);
                RegCloseKey(hRegProfileKey);
            } else {
                TRACE(TEXT(("Could not get profile information.\r\n")));
                return ERROR_NOT_INSTALLED;
            }
        } else {
            TRACE((TEXT("\tCould not find profile name.\r\n")));
            return ERROR_NOT_INSTALLED;
        }
        return ERROR_SUCCESS;     // A very confused return value.
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        dwExceptCode = GetExceptionCode();
        switch(dwExceptCode) {
          case EXCEPTION_ACCESS_VIOLATION:
            TRACE((TEXT("Fax:MigrateUser9x:Access violation.\r\n")));
            break;
          case EXCEPTION_INT_DIVIDE_BY_ZERO:
          case EXCEPTION_FLT_DIVIDE_BY_ZERO:
            TRACE((TEXT("Fax:MigrateUser9x:Divide by zero.\r\n")));
            break;
          default:
            TRACE((TEXT("Fax:MigrateUser9x:Unhandled exception.\r\n")));
            break;
        }
        return ERROR_SUCCESS;
    }
}


// MigrateSystem9x
//
// This routine copies system-wide settings.
// It also takes care of writing the [Fax] section of the unattend file.
//
// Parameters:
//      Documented below.
//
// Returns:
//      ERROR_SUCCESS.
//
// Author:
//      Brian Dewey (t-briand)  1997-7-14
LONG
CALLBACK
MigrateSystem9x(
    IN  HWND ParentWnd,           // Parent for UI.
    IN  LPCSTR UnattendFile,      // Name of unattend file
    LPVOID Reserved
    )
{
    typedef struct tagANSWER {
        LPTSTR szKey;
        LPTSTR szValue;
    } ANSWER;
        // This array defines the information we need to add to the unattend.txt
        // file.
    ANSWER aAnswers[] = {
        { TEXT("Mode"), szPerformInstall },              // Must be "New" or "Skip".
        { TEXT("SetupType"), TEXT("Workstation") },      // Must be "Workstation".
        { TEXT("FaxPrinterName"), szFaxPrinterName },    // I'm guessing here.
        { TEXT("FaxNumber"), szFaxNumber },              // Must get this from a profile...
//      { TEXT("UseExchange"), TEXT("No") },             // Assume "No" Exchange Server.
//      { TEXT("ProfileName"), TEXT("") },               // And therefore no exchange profile.
//      { TEXT("RouteMail"), TEXT("No") },               // Don't deliver to an inbox.
//      { TEXT("RouteProfileName"), TEXT("") },          // Therefore, profile not needed.
//      { TEXT("Platforms"), TEXT("i386") },             // win95 => i386 (only platform!)
//      { TEXT("RoutePrint"), TEXT("No") },              // Default to "No" printing
//      { TEXT("RoutePrintername"), TEXT("") },          // And therefore no printer name.
//      { TEXT("AccountName"), TEXT("Administrator") },  // Run as local administrator.
//      { TEXT("Password"), TEXT("") },                  // Password for that darn account.
        { TEXT("FaxPhone"), szFaxNumber },               // Again, pull this from a user.
//      { TEXT("RouteFolder"), TEXT("Yes") },            // Default "Yes".
//      { TEXT("FolderName"), szFaxStoreDir },           // Where we stick the stuff.
//      { TEXT("ServerName"), TEXT("") },                // Server irrelivant in NTW stand-alone.
//      { TEXT("SenderName"), szUserName },              // Pull from a user
//      { TEXT("SenderFaxAreaCode"), szFaxAreaCode },    // Pull from a user
//      { TEXT("SenderFaxNumber"), szFaxNumber }         // Pull from a user
    };
    UINT i,                     // Loop index
        iMax;                   // Largest index.
    LPCTSTR szFaxSection = TEXT("Fax");
    TCHAR szFaxStoreDirRes[MAX_PATH];

        // Get the fax printer.
    GetFaxPrinterName(szFaxPrinterName, sizeof(szFaxPrinterName));
        // Figure out where to put the fax.
        // FIXBKD. This will need an incompatability message.
    _tcscpy(szFaxStoreDirRes, TEXT("uninitialized"));
    if(!LoadString(hinstMigDll,
                   IDS_FAXSTORE,
                   szFaxStoreDirRes,
                   sizeof(szFaxStoreDirRes)
        )) {
        TRACE((TEXT("Unable to get fax storage directory; using default.\r\n")));
        DebugSystemError(GetLastError());
        TRACE((TEXT("I currently think the store dir is '%s'.\r\n"),
               szFaxStoreDirRes));
        _tcscpy(szFaxStoreDirRes, TEXT("%windir%\\FaxStore"));
    }
    ExpandEnvironmentStrings(szFaxStoreDirRes, szFaxStoreDir, sizeof(szFaxStoreDir));

    iMax = sizeof(aAnswers)/sizeof(ANSWER); // Compute size of array.
    for(i = 0; i < iMax; i++) {
        WritePrivateProfileString(
            szFaxSection,
            aAnswers[i].szKey,
            aAnswers[i].szValue,
            UnattendFile
            );
    }

    return ERROR_SUCCESS;         // A very confused return value.
}


// ------------------------------------------------------------
// Auxiliary functions

// GetUserProfileName
//
// This function gets the name of the default MAPI profile for a user.
//
// Parameters:
//      hUser                   Pointer to the HKCU equivalent in setup.
//      lpProfName              Pointer to buffer that will hold the profile name.
//      cbSize                  Size of said buffer.
//
// Returns:
//      TRUE on success, FALSE on failure.
//
// Author:
//      Brian Dewey (t-briand)  1997-8-6
static
BOOL
GetUserProfileName(HKEY hUser, LPTSTR lpProfName, DWORD cbSize)
{
    LONG lResult;               // Result of API calls.
    HKEY hUserProf;             // Key to the user profile section.
    DWORD dwType;               // Holds the type of the data.

    TRACE((TEXT("In GetUserProfileName.\r\n")));
    lResult = RegOpenKeyEx(
        hUser,                  // Opening a user key...
        LPUSERPROF,             // This section of the registry...
        0,                      // Reserved; must be 0.
        KEY_READ,               // Read permission,
        &hUserProf              // Store the key here.
        );
    if(lResult != ERROR_SUCCESS) return FALSE; // We failed.
    lResult = RegQueryValueEx(
        hUserProf,              // The key to the registry.
        LPPROFNAME,             // Name of the value I want.
        NULL,                   // Reserved.
        &dwType,                // Holds the type.
        lpProfName,             // Holds the profile name.
        &cbSize                 // Size of the buffer.
        );
    RegCloseKey(hUserProf);     // Remember to close the key!!
    TRACE((TEXT("Leaving GetUserProfileName.\r\n")));
    return lResult == ERROR_SUCCESS;
}

// GetFaxPrinterName
//
// This routine searches the win9x registry for a printer on port "FAX:".  When it finds it,
// it returns the name in the provided buffer.
//
// Parameters:
//      lpPrinterName           Pointer to buffer that will hold the printer name.
//      cbSize                  Size of the buffer.
//
// Returns:
//      TRUE if a fax printer was found.  FALSE otherwise.  The data stored in
//      lpPrinterName is only valid on a return of TRUE.
//
// Author:
//      Brian Dewey (t-briand)  1997-8-6
static BOOL
GetFaxPrinterName(LPTSTR lpPrinterName, DWORD cbSize)
{
    HKEY  hPrinterSection;              // Printer information in the registry.
    HKEY  hPrinterKey;                  // Key to a specific printer.
    LONG  lResult;                      // Result of api calls.
    DWORD dwIndex;                      // Index for enumeration.
    TCHAR szTempBuf[MAX_PATH];          // Temporary buffer for printer names.
    DWORD cbBufSize;                    // Size of said buffer.
    FILETIME ftTime;                    // What time was the key last modified?
    static const TCHAR LPPORT[] = TEXT("Port"); // The value we want to query.
    static const TCHAR LPFAX[]  = TEXT("FAX:"); // What we're looking for.
    DWORD dwType;                       // Value type.
    TCHAR lpPortName[16];               // Should be amply big.
    DWORD cbPortSize;                   // Holds the size of the port name buffer.

    TRACE((TEXT("Attempting to get fax printer name.\r\n")));
    lResult = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,             // Start here.
        LPPRINTER,                      // We're going for the printer section...
        0,                              // Reserved.
        KEY_READ,                       // Get read permission
        &hPrinterSection                // Put the key here.
        );
    if(lResult != ERROR_SUCCESS) {
        TRACE((TEXT("GetFaxPrinterName:Unable to open HKEY_LOCAL_MACHINE\\%s.\r\n"),
               LPPRINTER));
        return FALSE;
    }
    dwIndex = 0;                // Start getting subkeys with the first.
    cbBufSize = sizeof(szTempBuf); // Initialize the size variable.
    while(RegEnumKeyEx(hPrinterSection, // Enumerate the printers.
                       dwIndex++,       // Keep incrementing the index.
                       szTempBuf,       // Store the name here.
                       &cbBufSize,      // This will hold the length of the name.
                       NULL,            // RESERVED.
                       NULL,            // Class info -- I don't need.
                       NULL,            // Size of class info -- also not needed.
                       &ftTime) == ERROR_SUCCESS) {
        TRACE((TEXT("GetFaxPrinterName:Examining printer %s.\r\n"),
                    szTempBuf));
        lResult = RegOpenKeyEx(
            hPrinterSection,
            szTempBuf,                  // Try to open this key.
            0,                          // Reserved.
            KEY_READ,                   // Get read-only permission
            &hPrinterKey                // Save the key here.
            );
        if(lResult != ERROR_SUCCESS) {
            RegCloseKey(hPrinterSection);
            return FALSE;
        }
        cbPortSize = sizeof(lpPortName);
        lResult = RegQueryValueEx(
            hPrinterKey,                // Look in here...
            LPPORT,                     // The name of the desired value.
            NULL,                       // Reserved.
            &dwType,                    // Holds the type.
            lpPortName,                 // Store the value here.
            &cbPortSize                 // Get the size.
            );
        RegCloseKey(hPrinterKey);
        if(lResult != ERROR_SUCCESS) {
            TRACE((TEXT("GetFaxPrinterName:Unable to get the port information.\r\n")));
            RegCloseKey(hPrinterSection);
            return FALSE;
        }
        TRACE((TEXT("GetFaxPrinterName:Port = %s (looking for %s).\r\n"),
               lpPortName, LPFAX));
        if(!_tcsnicmp(LPFAX, lpPortName, cbPortSize)) {
                // Found it!
            TRACE((TEXT("GetFaxPrinterName:Success!  Printer = %s.\r\n"),
                   szTempBuf));
            RegCloseKey(hPrinterSection);
            _tcsncpy(lpPrinterName, szTempBuf, cbSize);
            return TRUE;
        }

            // If we get this far, then just try again.
    }

        // couldn't find a fax printer...
    TRACE((TEXT("GetFaxPrinterName:Unable to get fax printer.\r\n")));
    return FALSE;
}

// GetRegProfileKey
//
// OK, this is a horrible routine.  Given a key to a user, and the name of
// that user's MAPI profile, it will get a key to FAX service section of the
// MAPI profile in the registry.  The advantage of this is I can get MAPI properties
// (such as user name, fax number, etc.) without using MAPI routines --
// they come straight from the registry.  But still, it seems like an awful
// hack.  I cringe.  You can see me cringe in the comments below.
//
// Parameters:
//      hUser                   The HKCU equivalent for setup.
//      lpProfName              Name of the user's default profile.
//      phRegProfileKey         (OUT) Pointer to the FAX section of the MAPI profile.
//
// Returns:
//      TRUE on success, FALSE on failure.
//
// Author:
//      Brian Dewey (t-briand)  1997-8-6
static BOOL
GetRegProfileKey(HKEY hUser, LPTSTR lpProfName, PHKEY phRegProfileKey)
{
    LONG lResult;
    HKEY hProfiles;             // Key to all the profiles.
    HKEY hUserProf;             // Key to the user's profile section
    BYTE abProfileUID[32];      // Holds the profile UID.
    DWORD cbProfileUID = sizeof(abProfileUID);
    TCHAR szProfileName[65];    // This will hold the encoded profile name.
    DWORD dwType;               // Data type for registry query
    UINT  i;                    // Loop index.

    TRACE((TEXT("In GetRegProfileKey.\r\n")));
    lResult = RegOpenKeyEx(
        hUser,                  // Opening a user key...
        LPPROFILES,             // This section of the registry...
        0,                      // Reserved; must be 0.
        KEY_READ,               // Read permission,
        &hProfiles
        );
    if(lResult != ERROR_SUCCESS) return FALSE;

    lResult = RegOpenKeyEx(
        hProfiles,              // Opening a user key...
        lpProfName,             // This section of the registry...
        0,                      // Reserved; must be 0.
        KEY_READ,               // Read permission,
        &hUserProf
        );
    if(lResult != ERROR_SUCCESS) return FALSE;

    lResult = RegQueryValueEx(
        hUserProf,              // From the current profile section,
        LPPROFUID,              // Get the profile root uid.
        NULL,
        &dwType,                // Holds the type of data
        abProfileUID,           // Store the value here.
        &cbProfileUID           // Holds the size.
        );
    if(lResult != ERROR_SUCCESS) {
        RegCloseKey(hUserProf);
        RegCloseKey(hProfiles);
        return FALSE;
    }

        // WARNING:  The following is an incredibly horrid hack.  I'm ashamed to write
        // code like this.  But anyway, I think the way to get to the registry entries
        // associated with a mapi profile is to get the root UID of the profile, add 5 to
        // the first byte, ignore the last byte, and use that as a registry key.  So that's
        // what I do.  It works on the win95 box I've got in my office... probably the
        // best thing to do is to connect to MAPI, but I don't want to think of that
        // possibility yet...
    abProfileUID[0] += 4;       // 5 is the magic offset???
    cbProfileUID--;             // Chop off the extraneous byte at the end.
    for(i=0; i < cbProfileUID; i++)
        _stprintf(szProfileName + (i*2), TEXT("%0*x"), 2, abProfileUID[i]);

    lResult = RegOpenKeyEx(
        hUserProf,              // This section...
        szProfileName,          // The long MAPIUID...
        0,                      // Reserved.
        KEY_READ,               // Read permission.
        phRegProfileKey         // Store the key here.
        );
    RegCloseKey(hUserProf);     // Don't need this key any more!
    RegCloseKey(hProfiles);     // Nor this one.
    TRACE((TEXT("Leaving GetRegProfileKey.\r\n")));
    return lResult == ERROR_SUCCESS;
}

// DumpUserInfo
//
// Writes user information out to 'faxuser.ini'.
//
// Parameters:
//      hUserInfo               Pointer to the fax section of the user's profile.
//      UserName                the user ID of this user.
//      szProfileName           The MAPI profile name the user uses.
//
// Returns:
//      Nothing.
//
// Author:
//      Brian Dewey (t-briand)  1997-8-6
static void
DumpUserInfo(HKEY hUserInfo, LPCSTR UserName, LPTSTR szProfileName)
{
        // Types
    typedef struct tagUSERINFO {
        DWORD dwPropID;         // Property ID
        LPTSTR szDescription;
    } USERINFO;

        // Data
    USERINFO auiProperties[] = {
        { PR_POSTAL_ADDRESS, TEXT("Address") },
        { PR_COMPANY_NAME, TEXT("Company") },
        { PR_DEPARTMENT_NAME, TEXT("Department") },
        { PR_SENDER_EMAIL_ADDRESS, TEXT("FaxNumber") },
        { PR_SENDER_NAME, TEXT("FullName") },
        { PR_HOME_TELEPHONE_NUMBER, TEXT("HomePhone") },
        { PR_OFFICE_LOCATION, TEXT("Office") },
        { PR_OFFICE_TELEPHONE_NUMBER, TEXT("OfficePhone") },
        { PR_TITLE, TEXT("Title") }
    };
    TCHAR szPropStr[9];         // DWORD == 32 bits == 4 bytes == 8 hex digits + 1 null
    UINT  iCount;               // Loop counter.
    UINT  iMax;                 // Largest property number.
    DWORD dwType;               // Type of registry data
    BYTE  abData[256];          // Data buffer.
    DWORD cbData;               // Size of the data buffer.
    LONG  lResult;              // Result of API call.
    UINT  i;                    // Loop counter.
    BOOL  bMailboxFound;        // Flag used when searching for a mailbox.
    TCHAR szUserBuf[9];         // used for annotating INF file.

    TRACE((TEXT("Entering DumpUserInfo.\r\n")));

        // Note that we're dumping this user's information.
    _stprintf(szUserBuf, "USER%04d", dwUserCount++);
    WritePrivateProfileString(
        TEXT("Users"),
        szUserBuf,
        UserName,
        szInfFileName
        );

        // Write the MAPI profile name.
    WritePrivateProfileString(
        TEXT(UserName),         // this works???
        TEXT("MAPI"),
        szProfileName,
        szInfFileName
        );
        

    iMax = sizeof(auiProperties) / sizeof(USERINFO);
    TRACE((TEXT("There are %d properties.\r\n"), iMax));
    for(iCount = 0; iCount < iMax; iCount++) {
        _stprintf(szPropStr, TEXT("%0*x"), 8, SWAPWORD(auiProperties[iCount].dwPropID));
        cbData = sizeof(abData); // Reset the size.
        lResult = RegQueryValueEx(
            hUserInfo,          // Get info from this key...
            szPropStr,          // using this name.
            NULL,               // reserved.
            &dwType,            // Will store the data type.
            abData,             // Data buffer.
            &cbData             // Size of data buffer.
            );
        if(lResult == ERROR_SUCCESS) {
                // TODO: handle more data types!
            if(_tcscmp(auiProperties[iCount].szDescription, TEXT("FullName")) == 0) {
                    // We've got the full name.  Remember this for the unattend.txt
                    // file.
                _tcscpy(szUserName, abData);
            }
            switch(dwType) {
              case REG_SZ:
                if(_tcscmp(auiProperties[iCount].szDescription, TEXT("FaxNumber")) == 0) {
                        // We special case the fax number.
                        // Why?  Because it's either a fax number -OR-
                        // it's "mailbox@faxnumber".  I search for the "@" in
                        // the string.  If it's there, everything before it goes
                        // into the mailbox property, everything after goes into
                        // the fax number.  If it's not there, I assume the entire
                        // string is a fax number.
                    i = 0;
                    bMailboxFound = FALSE;
                    while(abData[i] != _T('\0')) {
                        if(abData[i] == _T('@')) {
                                // Found it!
                            abData[i] = _T('\0');// Null terminate the mailbox name.
                            if(!WritePrivateProfileString(
                                TEXT(UserName),
                                TEXT("Mailbox"),
                                abData,
                                szInfFileName
                                )) {
                                DebugSystemError(GetLastError());
                            }
                            if(!WritePrivateProfileString(
                                TEXT(UserName),
                                TEXT("FaxNumber"),
                                abData + i + 1, // Print what was after the '@'.
                                szInfFileName
                                )) {
                                DebugSystemError(GetLastError());
                            }
                            SetGlobalFaxNumberInfo(abData + i + 1);
                            bMailboxFound = TRUE;
                            break; // while
                        }
                        i++;
                    }
                    if(bMailboxFound)
                        break;  // case -- if we found the mailbox, we're done.
                                // else we fall through to default processing.
                    else
                        SetGlobalFaxNumberInfo(abData);
                }// if
                    // Replace '\n' characters in the string with semicolons.
                i = 0;
                while(abData[i] != _T('\0')) {
                    if((abData[i] == _T('\n')) || (abData[i] == _T('\r')))
                        abData[i] = _T(';');
                    i++;
                }
                if(!WritePrivateProfileString(
                    TEXT(UserName),
                    auiProperties[iCount].szDescription,
                    abData,
                    szInfFileName
                    )) {
                    DebugSystemError(GetLastError());
                }
                TRACE((TEXT("%s = %s\r\n"), auiProperties[iCount].szDescription,
                         abData));
                break;

              case REG_BINARY:
                    // The data is just free-form binary.  Print it one byte at a time.
                TRACE((TEXT("%s = "), auiProperties[iCount].szDescription));
                for(i = 0; i < cbData; i++)
                    TRACE((TEXT("%0*x "), 2, abData[i]));
                TRACE((TEXT("\r\n")));
                break;

              default:
                TRACE((TEXT("Unknown data type (%d) for property '%s'.\r\n"),
                         dwType,
                         auiProperties[iCount].szDescription));
            }
        } else {
            TRACE((TEXT("Could not get property '%s'.\r\n"),
                     auiProperties[iCount].szDescription));
        }
    }
    TRACE((TEXT("Leaving DumpUserInfo.\r\n")));
}

// SetGlobalFaxNumberInfo
//
// This routine sets the global variables 'szFaxAreaCode' and 'szFaxNumber' based on
// the value in szPhone.  It expects szPhone to be in the following format:
//
//      [[<country code>] '(' <area code> ')'] <phone number>
//
// (Brackets denote something optional.  Literals are in single quotes, non-terminals are
// in angle brackets.  Note that if there's a country code, there must be an area code.)
//
// Parameters:
//      szPhone                 Described above.
//
// Returns:
//      Nothing.
//
// Side effects:
//      Sets the values of szFaxAreaCode and szFaxNumber.
//
// Author:
//      Brian Dewey (t-briand)  1997-7-24
static void
SetGlobalFaxNumberInfo(LPCTSTR szPhone)
{
    UINT i;                     // Loop index.
    UINT j;                     // Loop index.

        // First, look through the string for an area code.
    i = 0;
    while((szPhone[i] != _T('\0')) && (szPhone[i] != _T('(')))
        i++;
    if(szPhone[i] == _T('(')) {
            // We've found an area code!
            // are all area codes at most 3 digits??  I sized the buffer to 16, but this will
            // still AV on a badly-formed #.
        i++;
        j=0;
        while(szPhone[i] != _T(')')) {
            szFaxAreaCode[j] = szPhone[i];
            i++;
            j++;
        }
        i++;
            // szPhone[i] should now immediately after the ')' at the end
            // of the area code.  Everything from here on out is a phone number.
        while(_istspace(szPhone[i])) i++;
    } else {
            // If we're here, there was no area code.  We need to rewind either to
            // the beginning of the string or to the first whitespace.
        while((i >= 0) && (!_istspace(szPhone[i]))) {
            i--;
        }
        i++;                    // The loop always rewinds one too far.
    }

        // ASSERT:  We're now ready to begin copying from szPhone to
        // szFaxNumber.
    j = 0;
    while(szPhone[i] != '\0') {
        szFaxNumber[j] = szPhone[i];
        i++;
        j++;
    }
}

// GenerateIncompatableMessages
//
// This function writes incompatability messages to the MIGRATE.INF file.
//
// Parameters:
//      None.
//
// Returns:
//      Nothing.
//
// Author:
//      Brian Dewey (t-briand)  1997-8-1
static void
GenerateIncompatableMessages()
{
    return;
}

// InitializeInfFile
//
// This routine writes out the [Version] section of the inf file.
//
// Parameters:
//      None.
//
// Returns:
//      TRUE on success, FALSE on failure.
//
// Side effects:
//      Generates a fully-qualified file name in szInfFileName.  Currently, that's
//      given by <windows dir>\<base file name>.
//
// Author:
//      Brian Dewey (t-briand)  1997-8-5
static BOOL
InitializeInfFile(LPCTSTR WorkingDirectory)
{
    TCHAR szWindowsPath[MAX_PATH]; // This will hold the path to the windows directory.
    DWORD cbPathSize = sizeof(szWindowsPath);
    TCHAR szDriveLetter[2];      // Will hold the drive letter.
    
        // First, fully qualify the file name.
    if(!GetWindowsDirectory(szWindowsPath, cbPathSize)) {
        TRACE((TEXT("InitializeInfFile:Unable to get the windows directory!\r\n")));
        return FALSE;           // It must be serious if that system call failed.
    }
    szDriveLetter[0] = szWindowsPath[0];
    szDriveLetter[1] = 0;
    _stprintf(szInfFileName, TEXT("%s\\%s"), WorkingDirectory, szInfFileBase);
    TRACE((TEXT("InitializeInfFile:Will store all information in INF file = '%s'\r\n"),
           szInfFileName));


        // Now, put the version header on the inf file.
    WritePrivateProfileString(
        TEXT("Version"),
        TEXT("Signature"),
        TEXT("\"$WINDOWS NT$\""),
        szInfFileName
        );
       // now, write out the amount of space we'll need.  Currently, we
       // just put the awdvstub.exe program in the SystemRoot directory.
       // Even w/ symbols, that's under 500K.  Report that.
    WritePrivateProfileString(
       TEXT("NT Disk Space Requirements"),
        szDriveLetter,
        TEXT("500000"),
        szInfFileName
        );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\client.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    client.c

Abstract:

    This file implements the file copy code.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop


FILE_QUEUE_INFO ClientFileQueue[] =
{
//-----------------------------------------------------------------------------------------------------------------------------------------------------
//    Section Name                          Dest Dir            INF Dir Id          Dest Dir Id        Platforms                            Copy Flags
//-----------------------------------------------------------------------------------------------------------------------------------------------------
    { TEXT("ClientSystemFiles"),                NULL,         DIRID_SYSTEM,        DIRID_SYSTEM,   PLATFORM_NONE,                        SP_COPY_NEWER },
    { TEXT("HelpFilesCommon"),                  NULL,           DIRID_HELP,          DIRID_HELP,   PLATFORM_NONE,                        SP_COPY_NEWER },
    { TEXT("HelpFilesClient"),                  NULL,           DIRID_HELP,          DIRID_HELP,   PLATFORM_NONE,                        SP_COPY_NEWER },
    { TEXT("ServerPrinterFiles"),               NULL,   PRINTER_DRIVER_DIR,  DIRID_SPOOLDRIVERS,   PLATFORM_NONE,                        SP_COPY_NEWER },
    { TEXT("ClientCoverPageFiles"),    COVERPAGE_DIR, COVERPAGE_CLIENT_DIR,        DIRID_SYSTEM,   PLATFORM_NONE,                        SP_COPY_NEWER },
    { TEXT("OutlookConfigFile"),  OUTLOOKCONFIG_DIR,       OUTLOOK_ECF_DIR,       DIRID_WINDOWS,   PLATFORM_NONE,                        SP_COPY_NEWER }
};

#define CountClientFileQueue (sizeof(ClientFileQueue)/sizeof(FILE_QUEUE_INFO))


FILE_QUEUE_INFO PointPrintFileQueue[] =
{
//--------------------------------------------------------------------------------------------------------------------------------------
//    Section Name                         Dest Dir            INF Dir Id          Dest Dir Id               Platforms      Copy Flags
//--------------------------------------------------------------------------------------------------------------------------------------
    { TEXT("ClientSystemFiles"),     FAXCLIENTS_DIR,         DIRID_SYSTEM,  DIRID_SPOOLDRIVERS,   PLATFORM_USE_MACHINE,  SP_COPY_NEWER },
    { TEXT("HelpFilesCommon"),                 NULL,           DIRID_HELP,          DIRID_HELP,          PLATFORM_NONE,  SP_COPY_NEWER },
    { TEXT("HelpFilesClient"),                 NULL,           DIRID_HELP,          DIRID_HELP,          PLATFORM_NONE,  SP_COPY_NEWER },
    { TEXT("ServerPrinterFiles"),              NULL,   PRINTER_DRIVER_DIR,  DIRID_SPOOLDRIVERS,          PLATFORM_NONE,  SP_COPY_NEWER },
    { TEXT("ClientCoverPageFiles"),   COVERPAGE_DIR, COVERPAGE_CLIENT_DIR,        DIRID_SYSTEM,          PLATFORM_NONE,  SP_COPY_NEWER },
    { TEXT("OutlookConfigFile"),  OUTLOOKCONFIG_DIR,      OUTLOOK_ECF_DIR,       DIRID_WINDOWS,          PLATFORM_NONE,  SP_COPY_NEWER }
};

#define CountPointPrintFileQueue (sizeof(PointPrintFileQueue)/sizeof(FILE_QUEUE_INFO))




DWORD
ClientFileCopyThread(
    HWND hwnd
    )
{
    HINF FaxSetupInf;
    HSPFILEQ *FileQueue;
    PVOID QueueContext;
    DWORD ErrorCode = 0;


    if (InstallMode & INSTALL_NEW) {
        SendMessage( hwnd, WM_MY_PROGRESS, 0xff, 30 );
    }

    if (!InitializeFileQueue( hwnd, &FaxSetupInf, &FileQueue, &QueueContext, SourceDirectory )) {
        ErrorCode = IDS_COULD_NOT_COPY_FILES;
        goto error_exit;
    }

    if (!ProcessFileQueue( FaxSetupInf, FileQueue, QueueContext, SourceDirectory,
            ClientFileQueue, CountClientFileQueue, InstallQueueCallback, SETUP_ACTION_COPY )) {
        ErrorCode = IDS_COULD_NOT_COPY_FILES;
        goto error_exit;
    }

    if (!CloseFileQueue( FileQueue, QueueContext )) {
        ErrorCode = IDS_COULD_NOT_COPY_FILES;
        goto error_exit;
    }

    if (InstallMode & INSTALL_NEW) {
        SetProgress( hwnd, IDS_SETTING_REGISTRY );

        if (!SetClientRegistryData()) {
            PopUpMsg( hwnd, IDS_COULD_SET_REG_DATA, TRUE, 0 );
            PropSheet_PressButton( GetParent(hwnd), PSBTN_CANCEL );
            SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
            OkToCancel = TRUE;
            return TRUE;
        }

        SetProgress( hwnd, IDS_CREATING_FAXPRT );

        SetInstalledFlag( TRUE );
        SetInstallType( FAX_INSTALL_NETWORK_CLIENT );
        SetUnInstallInfo();

        ErrorCode = CreateClientFaxPrinter( hwnd, WizData.PrinterName );
        if (ErrorCode != ERROR_SUCCESS) {
            SetInstalledFlag( FALSE );
            ErrorCode = (ErrorCode == ERROR_ACCESS_DENIED) ?
                IDS_PERMISSION_CREATE_PRINTER : IDS_COULD_NOT_CREATE_PRINTER;
            goto error_exit;
        }

        SetProgress( hwnd, IDS_CREATING_GROUPS );

        CreateGroupItems( FALSE, NULL );
        InstallHelpFiles();
    }

    //
    // do the exchange stuff
    //
    DoExchangeInstall( hwnd );

    SetWindowLong( hwnd, DWL_MSGRESULT, 0 );
    PropSheet_PressButton( GetParent(hwnd), PSBTN_NEXT );

    return TRUE;

error_exit:

    InstallThreadError = ErrorCode;
    PopUpMsg( hwnd, ErrorCode, TRUE, 0 );
    OkToCancel = TRUE;
    PropSheet_PressButton( GetParent(hwnd), PSBTN_CANCEL );
    SetWindowLong( hwnd, DWL_MSGRESULT, -1 );

    return FALSE;
}


DWORD
PointPrintFileCopyThread(
    HWND hwnd
    )
{
    HINF FaxSetupInf;
    HSPFILEQ *FileQueue;
    PVOID QueueContext;
    DWORD ErrorCode = 0;


    SendMessage( hwnd, WM_MY_PROGRESS, 0xff, 20 );

    if (!InitializeFileQueue( hwnd, &FaxSetupInf, &FileQueue, &QueueContext, SourceDirectory )) {
        ErrorCode = IDS_COULD_NOT_COPY_FILES;
        goto error_exit;
    }

    if (!ProcessFileQueue( FaxSetupInf, FileQueue, QueueContext, SourceDirectory,
            PointPrintFileQueue, CountPointPrintFileQueue, InstallQueueCallback, SETUP_ACTION_COPY )) {
        ErrorCode = IDS_COULD_NOT_COPY_FILES;
        goto error_exit;
    }

    if (!CloseFileQueue( FileQueue, QueueContext )) {
        ErrorCode = IDS_COULD_NOT_COPY_FILES;
        goto error_exit;
    }

    SetProgress( hwnd, IDS_SETTING_REGISTRY );

    if (!SetClientRegistryData()) {
        PopUpMsg( hwnd, IDS_COULD_SET_REG_DATA, TRUE, 0 );
        PropSheet_PressButton( GetParent(hwnd), PSBTN_CANCEL );
        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
        OkToCancel = TRUE;
        return TRUE;
    }

    SetProgress( hwnd, IDS_CREATING_GROUPS );

    CreateGroupItems( FALSE, ClientSetupServerName );

    SetWindowLong( hwnd, DWL_MSGRESULT, 0 );
    PropSheet_PressButton( GetParent(hwnd), PSBTN_FINISH );

    return TRUE;

error_exit:

    InstallThreadError = ErrorCode;
    PopUpMsg( hwnd, ErrorCode, TRUE, 0 );
    OkToCancel = TRUE;
    PropSheet_PressButton( GetParent(hwnd), PSBTN_CANCEL );
    SetWindowLong( hwnd, DWL_MSGRESULT, -1 );

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\class.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    class.c

Abstract:

    This file implements the modem co-class
    installer for fax.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 31-Jul-1997

--*/

#include "wizard.h"
#pragma hdrstop


#if DBG

typedef struct _DIF_DEBUG {
    DWORD DifValue;
    LPTSTR DifString;
} DIF_DEBUG, *PDIF_DEBUG;

DIF_DEBUG DifDebug[] =
{
    { 0,                           TEXT("")                           },  //  0x00000000
    { DIF_SELECTDEVICE,            TEXT("DIF_SELECTDEVICE")           },  //  0x00000001
    { DIF_INSTALLDEVICE,           TEXT("DIF_INSTALLDEVICE")          },  //  0x00000002
    { DIF_ASSIGNRESOURCES,         TEXT("DIF_ASSIGNRESOURCES")        },  //  0x00000003
    { DIF_PROPERTIES,              TEXT("DIF_PROPERTIES")             },  //  0x00000004
    { DIF_REMOVE,                  TEXT("DIF_REMOVE")                 },  //  0x00000005
    { DIF_FIRSTTIMESETUP,          TEXT("DIF_FIRSTTIMESETUP")         },  //  0x00000006
    { DIF_FOUNDDEVICE,             TEXT("DIF_FOUNDDEVICE")            },  //  0x00000007
    { DIF_SELECTCLASSDRIVERS,      TEXT("DIF_SELECTCLASSDRIVERS")     },  //  0x00000008
    { DIF_VALIDATECLASSDRIVERS,    TEXT("DIF_VALIDATECLASSDRIVERS")   },  //  0x00000009
    { DIF_INSTALLCLASSDRIVERS,     TEXT("DIF_INSTALLCLASSDRIVERS")    },  //  0x0000000A
    { DIF_CALCDISKSPACE,           TEXT("DIF_CALCDISKSPACE")          },  //  0x0000000B
    { DIF_DESTROYPRIVATEDATA,      TEXT("DIF_DESTROYPRIVATEDATA")     },  //  0x0000000C
    { DIF_VALIDATEDRIVER,          TEXT("DIF_VALIDATEDRIVER")         },  //  0x0000000D
    { DIF_MOVEDEVICE,              TEXT("DIF_MOVEDEVICE")             },  //  0x0000000E
    { DIF_DETECT,                  TEXT("DIF_DETECT")                 },  //  0x0000000F
    { DIF_INSTALLWIZARD,           TEXT("DIF_INSTALLWIZARD")          },  //  0x00000010
    { DIF_DESTROYWIZARDDATA,       TEXT("DIF_DESTROYWIZARDDATA")      },  //  0x00000011
    { DIF_PROPERTYCHANGE,          TEXT("DIF_PROPERTYCHANGE")         },  //  0x00000012
    { DIF_ENABLECLASS,             TEXT("DIF_ENABLECLASS")            },  //  0x00000013
    { DIF_DETECTVERIFY,            TEXT("DIF_DETECTVERIFY")           },  //  0x00000014
    { DIF_INSTALLDEVICEFILES,      TEXT("DIF_INSTALLDEVICEFILES")     },  //  0x00000015
    { DIF_UNREMOVE,                TEXT("DIF_UNREMOVE")               },  //  0x00000016
    { DIF_SELECTBESTCOMPATDRV,     TEXT("DIF_SELECTBESTCOMPATDRV")    },  //  0x00000017
    { DIF_ALLOW_INSTALL,           TEXT("DIF_ALLOW_INSTALL")          },  //  0x00000018
    { DIF_REGISTERDEVICE,          TEXT("DIF_REGISTERDEVICE")         },  //  0x00000019
    { 0,                           TEXT("")                           },  //  0x0000001A
    { 0,                           TEXT("")                           },  //  0x0000001B
    { 0,                           TEXT("")                           },  //  0x0000001C
    { 0,                           TEXT("")                           },  //  0x0000001D
    { 0,                           TEXT("")                           },  //  0x0000001E
    { 0,                           TEXT("")                           },  //  0x0000001F
    { DIF_INSTALLINTERFACES,       TEXT("DIF_INSTALLINTERFACES")      },  //  0x00000020
    { DIF_DETECTCANCEL,            TEXT("DIF_DETECTCANCEL")           },  //  0x00000021
    { DIF_REGISTER_COINSTALLERS,   TEXT("DIF_REGISTER_COINSTALLERS")  },  //  0x00000022
    { 0,                           TEXT("")                           }   //  0x00000023
};

#endif






LRESULT
FaxModemDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch( message ) {
        case WM_INITDIALOG:
            break;

        case WM_COMMAND:
            switch( wParam ) {
                case IDCANCEL:
                    EndDialog( hwnd, IDCANCEL );
                    return TRUE;

                case IDOK:
                    EndDialog( hwnd, IDOK );
                    return TRUE;
            }
            break;
    }

    return FALSE;
}


DWORD
CALLBACK
FaxModemCoClassInstaller(
    IN DI_FUNCTION InstallFunction,
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL,
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    )
{
    DWORD rVal = NO_ERROR;
    HKEY hKey = INVALID_HANDLE_VALUE;
    LPTSTR FriendlyName = NULL;
    LPTSTR ModemAttachedTo = NULL;
    HANDLE hFile = NULL;
    TCHAR ComPortName[32];
#if 0
    int DlgErr;
#endif



    DebugPrint(( TEXT("FaxModemCoClassInstaller:  processing %s request"), DifDebug[InstallFunction].DifString ));

    if (InstallFunction == DIF_FIRSTTIMESETUP) {
        NtGuiMode = TRUE;
        return 0;
    }

    if (InstallFunction == DIF_INSTALLDEVICE) {

        if (!Context->PostProcessing) {
            DebugPrint(( TEXT("FaxModemCoClassInstaller:  pre-installation, waiting for post-installation call") ));
            return ERROR_DI_POSTPROCESSING_REQUIRED;
        }

        if (Context->InstallResult != NO_ERROR) {
            DebugPrint(( TEXT("FaxModemCoClassInstaller:  previous error causing installation failure, 0x%08x"), Context->InstallResult ));
            return Context->InstallResult;
        }

        //
        // get the modem information
        //

        hKey = SetupDiOpenDevRegKey(
            DeviceInfoSet,
            DeviceInfoData,
            DICS_FLAG_GLOBAL,
            0,
            DIREG_DRV,
            KEY_READ
            );
        if (hKey == INVALID_HANDLE_VALUE) {
            DebugPrint(( TEXT("FaxModemCoClassInstaller:  SetupDiOpenDevRegKey failed") ));
            rVal = ERROR_GEN_FAILURE;
            goto fax_install_exit;
        }

        FriendlyName = GetRegistryString( hKey, TEXT("FriendlyName"), EMPTY_STRING );
        ModemAttachedTo = GetRegistryString( hKey, TEXT("AttachedTo"), EMPTY_STRING );

        RegCloseKey( hKey );

        //
        // open the com port that the modem is attached to
        //

        _stprintf( ComPortName, TEXT("\\\\.\\%s"), ModemAttachedTo );

        hFile = CreateFile(
            ComPortName,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,
            0,
            NULL
            );
        if (hFile == INVALID_HANDLE_VALUE) {
            DebugPrint((
                TEXT("FaxModemCoClassInstaller:  could not open the com port for modem [%s][%s], ec=%d"),
                FriendlyName,
                ModemAttachedTo,
                GetLastError()
                ));
            rVal = ERROR_GEN_FAILURE;
            goto fax_install_exit;
        }

        //
        // get the fax class for the modem, zero is data only
        //

        if (GetModemClass( hFile ) == 0) {
            DebugPrint((
                TEXT("FaxModemCoClassInstaller:  modem is NOT a fax modem [%s][%s]"),
                FriendlyName,
                ModemAttachedTo
                ));
            CloseHandle( hFile );
            rVal = ERROR_GEN_FAILURE;
            goto fax_install_exit;
        }

        CloseHandle( hFile );

        //
        // the modem is a valid fax modem
        // ask the user if they want fax services
        //
 #if 0
        if (!NtGuiMode) {
            DlgErr = DialogBoxParam(
                FaxWizModuleHandle,
                MAKEINTRESOURCE(IDD_FAX_MODEM_INSTALL),
                NULL,
                FaxModemDlgProc,
                (LPARAM) 0
                );
            if (DlgErr == -1 || DlgErr == 0) {
                //
                // the user does not want fax services
                //
                DebugPrint((
                    TEXT("FaxModemCoClassInstaller:  user does not want fax service for modem [%s][%s]"),
                    FriendlyName,
                    ModemAttachedTo
                    ));
                goto fax_install_exit;
            }
        }
#endif
        if (!NtGuiMode) {
            //
            // create a fax printer
            //

            if (!CreateServerFaxPrinter( NULL, FAX_PRINTER_NAME )) {
                DebugPrint(( TEXT("CreateServerFaxPrinter() failed") ));
            }

            //
            // start the fax service
            //

            StartFaxService();

            //
            // create the program groups
            //

            CreateGroupItems( FALSE, NULL );
        }

fax_install_exit:

        MemFree( FriendlyName );
        MemFree( ModemAttachedTo );

        return rVal;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\dlgclast.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dialogs.c

Abstract:

    This file implements the dialog proc for the last wizard page in the client setup.

Environment:

    WIN32 User Mode

Author:

    Julia Robinson (a-juliar) 5-August-1996

--*/

#include "wizard.h"
#pragma hdrstop


LRESULT
LastClientPageDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch( msg ) {

        case WM_INITDIALOG:
            EnableWindow( GetDlgItem( GetParent( hwnd ), IDCANCEL ), FALSE );
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    if (Unattended) {
                        ExitProcess(0);
                    }
                    if (InstallMode == INSTALL_REMOVE ){
                        SetWindowLong( hwnd, DWL_MSGRESULT, IDD_LAST_UNINSTALL_PAGE );
                        return TRUE;
                    }
                    break;

                case PSN_WIZFINISH:
                    if (RebootRequired && !SuppressReboot) {
                        SetupPromptReboot( NULL, NULL, FALSE );
                    }
                    PostMessage( GetParent(GetParent(hwnd)), WM_USER+500, 0, 0 );
                    break;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\dlgcfcpy.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dlgcfcpy.c

Abstract:

    This file implements the dialog proc for the client file copies.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop



LRESULT
ClientFileCopyDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static BOOL OkToProceed = FALSE;
    static DWORD RangeMax = 0;
    HANDLE hThread;
    DWORD ThreadId;


    switch( msg ) {
        case WM_MY_PROGRESS:
            if (wParam == 0xfe) {
                lParam += RangeMax;
                SendDlgItemMessage( hwnd, IDC_COPY_PROGRESS, PBM_SETRANGE, 0, MAKELPARAM(0,(lParam)));
                SendDlgItemMessage( hwnd, IDC_COPY_PROGRESS, PBM_SETSTEP,  1, 0 );
            } else if (wParam == 0xff) {
                RangeMax = lParam;
            } else {
                SendDlgItemMessage( hwnd, IDC_COPY_PROGRESS, PBM_DELTAPOS, wParam, 0 );
            }
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    {

                    if (Unattended) {
                        if (InstallMode & INSTALL_REMOVE) {
                            UninstallThread( hwnd );
                        } else if (PointPrintSetup) {
                            PointPrintFileCopyThread( hwnd );
                        } else {
                            ClientFileCopyThread( hwnd );
                        }
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    SetDlgItemText(
                        hwnd,
                        IDC_FC_WAITMSG,
                        InstallMode & INSTALL_REMOVE ? GetString(IDS_DELETE_WAITMSG) : GetString(IDS_COPY_WAITMSG)
                        );

                    }
                    hThread = CreateThread(
                        NULL,
                        0,
                        (InstallMode & INSTALL_REMOVE) ?
                            (LPTHREAD_START_ROUTINE) UninstallThread :
                            PointPrintSetup ?
                                (LPTHREAD_START_ROUTINE) PointPrintFileCopyThread :
                                (LPTHREAD_START_ROUTINE) ClientFileCopyThread,
                        hwnd,
                        0,
                        &ThreadId
                        );
                    if (hThread) {

                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        PropSheet_SetWizButtons( GetParent(hwnd), 0 );
                        return FALSE;

                    } else {

                        //
                        // popup an error
                        //

                    }
                    break;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\dlgcomon.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dialogs.c

Abstract:

    This file implements the common dialog proc and other
    common code used by other dialog procs.  All global
    data used by the dialog procs lives here too.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop



LRESULT
CommonDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PWIZPAGE WizPage;


    WizPage = (PWIZPAGE) GetWindowLong( hwnd, DWL_USER );

    switch( msg ) {
        case WM_INITDIALOG:

            SetWindowLong( hwnd, DWL_USER, (LONG) ((LPPROPSHEETPAGE) lParam)->lParam );
            WizPage = (PWIZPAGE) ((LPPROPSHEETPAGE) lParam)->lParam;
            SetWizPageTitle( hwnd );
            break;

        case WM_NOTIFY:

            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:

                    PropSheet_SetWizButtons(
                        GetParent(hwnd),
                        WizPage->ButtonState
                        );

                    SetWindowLong( hwnd, DWL_MSGRESULT, 0 );
                    break;

                case PSN_QUERYCANCEL:
                    {
                        if (!OkToCancel) {
                            DWORD Answer;
                            MessageBeep(0);
                            Answer = PopUpMsg( hwnd, IDS_QUERY_CANCEL, FALSE, MB_YESNO );
                            if (Answer == IDNO) {
                                SetWindowLong( hwnd, DWL_MSGRESULT, 1 );
                                return TRUE;
                            } else {
                                InstallThreadError = ERROR_CANCELLED;
                            }
                        }
                    }
                    break;
            }
            break;
    }

    if (WizPage && WizPage->DlgProc) {
        return WizPage->DlgProc( hwnd,  msg, wParam, lParam );
    }

    return FALSE;
}


INT
BrowseCallbackProc(
    HWND    hwnd,
    UINT    uMsg,
    LPARAM  lParam,
    LPARAM  lpData
   )

/*++

Routine Description:

    Callback function for SHBrowseForFolder

Arguments:

    hwnd - Handle to the browse dialog box
    uMsg - Identifying the reason for the callback
    lParam - Message parameter
    lpData - Application-defined value given in BROWSEINFO.lParam

Return Value:

    0

--*/

{
    if (uMsg == BFFM_INITIALIZED) {

        TCHAR   buffer[MAX_PATH];
        HWND    hDlg = (HWND) lpData;

        if (GetDlgItemText(hDlg, IDC_DEST_DIRPATH, buffer, MAX_PATH)) {
            SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM) buffer);
        }
    }

    return 0;
}


BOOL
DoBrowseDestDir(
    HWND    hDlg
    )

/*++

Routine Description:

    Present a browse dialog to let user select a directory
    for storing inbound fax files

Arguments:

    hDlg - Handle to the "Receive Options" property page

Return Value:

    TRUE if successful, FALSE if user cancelled the dialog

--*/

{
    LPITEMIDLIST    pidl;
    TCHAR           buffer[MAX_PATH];
    TCHAR           title[MAX_TITLE_LEN];
    VOID            SHFree(LPVOID);
    BOOL            result = FALSE;

    BROWSEINFO bi = {

        hDlg,
        NULL,
        buffer,
        title,
        BIF_RETURNONLYFSDIRS,
        BrowseCallbackProc,
        (LPARAM) hDlg,
    };


    _tcsncpy( title, GetString( IDS_INBOUND_DIR ), MAX_TITLE_LEN );

    if (pidl = SHBrowseForFolder(&bi)) {

        if (SHGetPathFromIDList(pidl, buffer)) {

            SetDlgItemText(hDlg, IDC_DEST_DIRPATH, buffer);
            result = TRUE;
        }

        SHFree(pidl);
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\dlgdvsel.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dlgdvsel.c

Abstract:

    This file implements the dialog proc for the workstation
    device selection page.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop



LRESULT
DeviceSelectionDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static HWND hwndList;
    static DWORD TotalDevicesSelected;


    switch( msg ) {
        case WM_INITDIALOG:
            {
                HIMAGELIST himlState;
                int iItem = 0;
                DWORD i;
                LV_ITEM lvi;
                LV_COLUMN lvc = {0};


                for (i=0,lvi.iItem=0,TotalDevicesSelected=0; i<FaxDevices; i++) {
                    LineInfo[i].Selected = TRUE;
                    TotalDevicesSelected += 1;
                    if (RequestedSetupType & FAX_INSTALL_WORKSTATION && TotalDevicesSelected == MAX_DEVICES_NTW) {
                        break;
                    }
                }

                hwndList = GetDlgItem( hwnd, IDC_DEVICE_LIST );

                //
                // set/initialize the image list(s)
                //

                himlState = ImageList_Create( 16, 16, TRUE, 2, 0 );

                ImageList_AddMasked(
                    himlState,
                    LoadBitmap( FaxWizModuleHandle, MAKEINTRESOURCE(IDB_CHECKSTATES) ),
                    RGB (255,0,0)
                    );

                ListView_SetImageList( hwndList, himlState, LVSIL_STATE );

                //
                // set/initialize the columns
                //

                lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                lvc.fmt = LVCFMT_LEFT;
                lvc.cx = 274;
                lvc.pszText = TEXT("Device Name");
                lvc.iSubItem = 0;
                ListView_InsertColumn( hwndList, lvc.iSubItem, &lvc );

                //
                // add the data to the list
                //

                for (i=0,lvi.iItem=0; i<FaxDevices; i++) {

                    lvi.pszText = LineInfo[i].DeviceName;
                    lvi.iItem += 1;
                    lvi.iSubItem = 0;
                    lvi.iImage = 0;
                    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
                    lvi.state = LineInfo[i].Selected ? LVIS_GCCHECK : LVIS_GCNOCHECK;
                    lvi.stateMask = LVIS_STATEIMAGEMASK;
                    iItem = ListView_InsertItem( hwndList, &lvi );

                }

            }
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    if (Unattended) {
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    if (InstallMode & INSTALL_UPGRADE || InstallMode & INSTALL_REMOVE || FaxDevices == 1) {
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    break;

                case NM_CLICK:
                    {
                        DWORD           dwpos;
                        LV_HITTESTINFO  lvhti;
                        int             iItemClicked;
                        UINT            state;

                        //
                        // Find out where the cursor was
                        //
                        dwpos = GetMessagePos();
                        lvhti.pt.x = LOWORD(dwpos);
                        lvhti.pt.y = HIWORD(dwpos);

                        MapWindowPoints( HWND_DESKTOP, hwndList, &lvhti.pt, 1 );

                        //
                        // Now do a hittest with this point.
                        //
                        iItemClicked = ListView_HitTest( hwndList, &lvhti );

                        if (lvhti.flags & LVHT_ONITEMSTATEICON) {

                            //
                            // Now lets get the state from the item and toggle it.
                            //

                            state = ListView_GetItemState(
                                hwndList,
                                iItemClicked,
                                LVIS_STATEIMAGEMASK
                                );

                            if (state == LVIS_GCCHECK) {

                                //
                                // de-selecting a device
                                //

                                if (TotalDevicesSelected == 1) {
                                    MessageBeep(0);
                                    break;
                                }

                                TotalDevicesSelected -= 1;
                                LineInfo[iItemClicked].Selected = FALSE;

                                ListView_SetItemState(
                                    hwndList,
                                    iItemClicked,
                                    LVIS_GCNOCHECK,
                                    LVIS_STATEIMAGEMASK
                                    );

                            } else {

                                //
                                // selecting a new device
                                //

                                if (RequestedSetupType & FAX_INSTALL_WORKSTATION && TotalDevicesSelected == MAX_DEVICES_NTW) {
                                    MessageBeep(0);
                                    break;
                                }

                                TotalDevicesSelected += 1;
                                LineInfo[iItemClicked].Selected = TRUE;

                                ListView_SetItemState(
                                    hwndList,
                                    iItemClicked,
                                    LVIS_GCNOCHECK,
                                    LVIS_STATEIMAGEMASK
                                    );

                            }
                        }
                    }
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\dlgfcopy.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dialogs.c

Abstract:

    This file implements the dialog proc for the
    server file copy page.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop


LRESULT
FileCopyDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static BOOL OkToProceed = FALSE;
    static DWORD RangeMax = 0;
    HANDLE hThread;
    DWORD ThreadId;


    switch( msg ) {
        case WM_INITDIALOG:
            SetDlgItemText(
                hwnd,
                IDC_FC_WAITMSG,
                InstallMode & INSTALL_REMOVE ? GetString(IDS_DELETE_WAITMSG) : GetString(IDS_COPY_WAITMSG)
                );

            break ;
        case WM_MY_PROGRESS:
            if (wParam == 0xfe) {
                lParam += RangeMax;
                SendDlgItemMessage( hwnd, IDC_COPY_PROGRESS, PBM_SETRANGE, 0, MAKELPARAM(0,(lParam)));
                SendDlgItemMessage( hwnd, IDC_COPY_PROGRESS, PBM_SETSTEP,  1, 0 );
            } else if (wParam == 0xff) {
                RangeMax = lParam;
            } else {
                SendDlgItemMessage( hwnd, IDC_COPY_PROGRESS, PBM_DELTAPOS, wParam, 0 );
            }
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    if (Unattended) {
                        if (InstallMode & INSTALL_REMOVE) {
                            UninstallThread( hwnd );
                        } else {
                            ServerFileCopyThread( hwnd );
                        }
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    } else {
                        hThread = CreateThread(
                            NULL,
                            0,
                            (InstallMode & INSTALL_REMOVE) ?
                                (LPTHREAD_START_ROUTINE) UninstallThread :
                                (LPTHREAD_START_ROUTINE) ServerFileCopyThread,
                            hwnd,
                            0,
                            &ThreadId
                            );
                        if (hThread) {

                            SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                            PropSheet_SetWizButtons( GetParent(hwnd), 0 );
                            return FALSE;

                        } else {

                            //
                            // popup an error
                            //

                        }
                    }
                    break;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\dlgdev.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dialogs.c

Abstract:

    This file implements the dialog proc for the tapi
    device status page.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop


LRESULT
DeviceStatusDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static BOOL OkToProceed = FALSE;
    static HANDLE hThread;
    DWORD ThreadId;


    switch( msg ) {
        case WM_INITDIALOG:
            SetWindowText( GetDlgItem( hwnd, IDC_DEVICEINIT_LABEL01 ), GetString(IDS_DEVICEINIT_LABEL01) );
            break;

        case WM_MY_PROGRESS:
            if (wParam == 0xff) {
                SendDlgItemMessage( hwnd, IDC_DEVICE_PROGRESS, PBM_SETRANGE, 0, MAKELPARAM(0,(lParam)));
                SendDlgItemMessage( hwnd, IDC_DEVICE_PROGRESS, PBM_SETSTEP,  1, 0 );
            } else {
                SendDlgItemMessage( hwnd, IDC_DEVICE_PROGRESS, PBM_DELTAPOS, wParam, 0 );
            }
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    StopFaxService();

                    if (InstallMode != INSTALL_NEW) {
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }

                    if (Unattended) {
                        DeviceInitThread( hwnd );
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    } else {
                        hThread = CreateThread(
                            NULL,
                            0,
                            (LPTHREAD_START_ROUTINE) DeviceInitThread,
                            hwnd,
                            0,
                            &ThreadId
                            );
                        if (hThread) {

                            SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                            PropSheet_SetWizButtons( GetParent(hwnd), 0 );
                            return FALSE;

                        } else {

                            //
                            // popup an error
                            //

                        }
                    }
                    break;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\dlglastu.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dlglastu.c

Abstract:

    This file implements the dialog proc for the last wizard page,
    for uninstalling the workstation or server.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop


LRESULT
LastPageUninstallDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static BOOL Ok = TRUE;


    switch( msg ) {
        case WM_INITDIALOG:
            EnableWindow( GetDlgItem( GetParent( hwnd), IDCANCEL ), FALSE );
            SetWindowText( GetDlgItem( hwnd, IDC_LASTUNINSTALL_LABEL01 ), GetString(IDS_LASTUNINSTALL_LABEL01) );
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {

                case PSN_SETACTIVE:
                    if (InstallMode == INSTALL_REMOVE && Ok) {
                        Ok = FALSE;
                        SetWindowLong( hwnd, DWL_MSGRESULT, IDD_LAST_UNINSTALL_PAGE );
                        return TRUE;
                    }
                    break;

                case PSN_WIZFINISH:
                    if (RebootRequired && !SuppressReboot) {
                        SetupPromptReboot( NULL, NULL, FALSE );
                    }

                    PostMessage( GetParent(GetParent(hwnd)), WM_USER+500, 0, 0 );
                    break;

            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\dlglast.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dialogs.c

Abstract:

    This file implements the dialog proc for the last wizard page.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop


LRESULT
LastPageDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static BOOL Ok = TRUE;


    switch( msg ) {
        case WM_INITDIALOG:
            EnableWindow( GetDlgItem( GetParent( hwnd), IDCANCEL ), FALSE );
            SetDlgItemText(
                hwnd,
                IDC_LAST_LABEL01,
                RequestedSetupType == SETUP_TYPE_REMOTE_ADMIN ?
                    GetString( IDS_LABEL02_LAST ) : GetString( IDS_LABEL01_LAST )
                );
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    if (Unattended) {
                        if (NtGuiMode) {
                            //
                            // if we're running in nt gui mode setup then
                            // this is the end.  we cannot simply call
                            // ExitProcess() as in the normal faxsetup case
                            // because we'll end gui mode setup, doh!  the
                            // best thing to do is simply simulate the user
                            // pushing the finish button.
                            //
                            PostMessage( GetParent( hwnd), PSM_PRESSBUTTON, PSBTN_FINISH, 0 );
                            SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                            return TRUE;
                        }
                        if (RebootRequired && !SuppressReboot) {
                            SetupPromptReboot( NULL, NULL, FALSE );
                        }
                        ExitProcess(0);
                    }
                    if (InstallMode == INSTALL_REMOVE && Ok) {
                        Ok = FALSE;
                        SetWindowLong( hwnd, DWL_MSGRESULT, IDD_LAST_UNINSTALL_PAGE );
                        return TRUE;
                    }
                    break;

                case PSN_WIZFINISH:
                    if (RebootRequired && !SuppressReboot) {
                        SetupPromptReboot( NULL, NULL, FALSE );
                    }
                    PostMessage( GetParent(GetParent(hwnd)), WM_USER+500, 0, 0 );
                    break;

            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\dlgmail.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    digmail.c

Abstract:

    This file implements the dialog proc for the exchange
    routing profile page.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop


LRESULT
RouteMailDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LONG idx;


    switch( msg ) {
        case WM_INITDIALOG:
            if (InstallMode == INSTALL_NEW) {
                GetMapiProfiles( hwnd, IDC_DEST_PROFILENAME );
                if (WizData.UseExchange) {
                    //
                    // if the user wants to use exchange for
                    // addressing fax messages then lets
                    // default this profile selection to the
                    // same profile that the user chose for
                    // addressing
                    //
                    idx = SendDlgItemMessage(
                        hwnd,
                        IDC_DEST_PROFILENAME,
                        CB_FINDSTRING,
                        (WPARAM) -1,
                        (LPARAM) WizData.MapiProfile
                        );
                }
                else{
                    idx = 0;
                }

            }
            SendDlgItemMessage(
                hwnd,
                IDC_DEST_PROFILENAME,
                CB_SETCURSEL,
                idx == CB_ERR ? 0 : (WPARAM) idx,
                0
                );
            CheckDlgButton( hwnd, IDC_ANS_YES, BST_UNCHECKED );
            CheckDlgButton( hwnd, IDC_ANS_NO,  BST_CHECKED   );
            EnableWindow( GetDlgItem( hwnd, IDC_DEST_PROFILENAME ), FALSE );
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED) {
                switch (LOWORD(wParam)) {
                    case IDC_ANS_YES:
                        EnableWindow( GetDlgItem( hwnd, IDC_DEST_PROFILENAME ), TRUE );
                        SetFocus( GetDlgItem( hwnd, IDC_DEST_PROFILENAME ));
                        break;
                    case IDC_ANS_NO:
                        EnableWindow( GetDlgItem( hwnd, IDC_DEST_PROFILENAME ), FALSE );
                }
            }
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    if (Unattended) {
                        UnAttendGetAnswer(
                            UAA_ROUTE_MAIL,
                            (LPBYTE) &WizData.RouteMail,
                            sizeof(WizData.RouteMail)
                            );
                        if (WizData.RouteMail) {
                            WizData.UseExchange = TRUE;
                            UnAttendGetAnswer(
                                UAA_ROUTE_PROFILENAME,
                                (LPBYTE) WizData.RouteProfile,
                                sizeof(WizData.RouteProfile)
                                );
                            if (_wcsicmp( WizData.RouteProfile, L"<default>" ) == 0) {
                                if (!GetDefaultMapiProfile( WizData.RouteProfile )) {
                                    DWORD Size = sizeof(WizData.RouteProfile);
                                    GetUserName( WizData.RouteProfile, &Size );
                                }
                            }
                        }
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    if (InstallMode != INSTALL_NEW) {
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    break;

                case PSN_WIZNEXT:
                    WizData.RouteMail = IsDlgButtonChecked( hwnd, IDC_ANS_YES );
                    if (WizData.RouteMail) {
                        LONG idx = SendDlgItemMessage(
                                hwnd,
                                IDC_DEST_PROFILENAME,
                                CB_GETCURSEL,
                                0,
                                0
                                );
                        WizData.UseExchange = TRUE;
                        if (idx != CB_ERR) {
                            if (idx == 0) {
                                if (!GetDefaultMapiProfile( WizData.RouteProfile )) {
                                    DWORD Size = sizeof(WizData.RouteProfile);
                                    GetUserName( WizData.RouteProfile, &Size );
                                }
                            } else {
                                SendDlgItemMessage(
                                    hwnd,
                                    IDC_DEST_PROFILENAME,
                                    CB_GETLBTEXT,
                                    (WPARAM) idx,
                                    (LPARAM) WizData.RouteProfile
                                    );
                            }
                        }
                    }

                    if ((!WizData.RoutePrint) && (!WizData.RouteStore) && (!WizData.RouteMail)) {
                        PopUpMsg( hwnd, IDS_ROUTING_REQUIRED, TRUE, 0 );
                        SetWindowLong( hwnd, DWL_MSGRESULT, IDD_ROUTE_STOREDIR_PAGE );
                        return TRUE;
                    }
                    break;

            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\dlgexchg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dlgexchg.c

Abstract:

    This file implements the dialog proc for the exchange install page.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 7-Aug-1996

--*/

#include "wizard.h"
#pragma hdrstop


LRESULT
ExchangeDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch( msg ) {
        case WM_INITDIALOG:
            if (InstallMode == INSTALL_NEW) {
                GetMapiProfiles( hwnd, IDC_DEST_PROFILENAME );
            }
            CheckDlgButton( hwnd, IDC_ANS_YES, BST_UNCHECKED );
            CheckDlgButton( hwnd, IDC_ANS_NO,  BST_CHECKED   );
            EnableWindow( GetDlgItem( hwnd, IDC_DEST_PROFILENAME ), FALSE );
            SendDlgItemMessage(
                hwnd,
                IDC_DEST_PROFILENAME,
                CB_SETCURSEL,
                0,
                0
                );
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED) {
                switch (LOWORD(wParam)) {
                    case IDC_ANS_YES:
                        EnableWindow( GetDlgItem( hwnd, IDC_DEST_PROFILENAME ), TRUE );
                        SetFocus( GetDlgItem( hwnd, IDC_DEST_PROFILENAME ));
                        break;
                    case IDC_ANS_NO:
                        EnableWindow( GetDlgItem( hwnd, IDC_DEST_PROFILENAME ), FALSE );
                }
            }
            break;


        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    if (Unattended) {
                        UnAttendGetAnswer(
                            UAA_USE_EXCHANGE,
                            (LPBYTE) &WizData.UseExchange,
                            sizeof(WizData.UseExchange)
                            );
                        if (WizData.UseExchange) {
                            UnAttendGetAnswer(
                                UAA_DEST_PROFILENAME,
                                (LPBYTE) WizData.MapiProfile,
                                sizeof(WizData.MapiProfile)
                                );
                            if (_wcsicmp( WizData.MapiProfile, L"<default>" ) == 0) {
                                if (!GetDefaultMapiProfile( WizData.MapiProfile )) {
                                    DWORD Size = sizeof(WizData.MapiProfile);
                                    GetUserName( WizData.MapiProfile, &Size );
                                }
                            }
                        }
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    if (InstallMode != INSTALL_NEW) {
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    break;

                case PSN_WIZNEXT:
                    WizData.UseExchange = IsDlgButtonChecked( hwnd, IDC_ANS_YES );
                    if (WizData.UseExchange) {
                        LONG idx = SendDlgItemMessage(
                                hwnd,
                                IDC_DEST_PROFILENAME,
                                CB_GETCURSEL,
                                0,
                                0
                                );
                        if (idx != CB_ERR) {
                            if (idx == 0) {
                                if (MapiAvail) {
                                    if (!GetDefaultMapiProfile( WizData.MapiProfile )) {
                                        DWORD Size = sizeof(WizData.MapiProfile);
                                        GetUserName( WizData.MapiProfile, &Size );
                                    }
                                } else {
                                    DWORD Size = sizeof(WizData.MapiProfile);
                                    GetUserName( WizData.MapiProfile, &Size );
                                }
                            } else {
                                SendDlgItemMessage(
                                    hwnd,
                                    IDC_DEST_PROFILENAME,
                                    CB_GETLBTEXT,
                                    (WPARAM) idx,
                                    (LPARAM) WizData.MapiProfile
                                    );
                            }
                        }
                    }
                    break;

            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\dlgplat.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dialogs.c

Abstract:

    This file implements the dialog proc for the server
    platforms page.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop


LRESULT
PlatformsDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static HWND hwndList;
    static DWORD RequireThisPlatform ;
    SYSTEM_INFO SystemInfo;


    switch( msg ) {
        case WM_INITDIALOG:
            {
                HIMAGELIST himlState;
                int iItem = 0;
                DWORD i;
                LV_ITEM lvi;
                LV_COLUMN lvc = {0};

                GetSystemInfo( &SystemInfo );

                if ( (SystemInfo.wProcessorArchitecture > 3) || (EnumPlatforms[SystemInfo.wProcessorArchitecture] == WRONG_PLATFORM ) ) {
                   return FALSE;
                }

                RequireThisPlatform = EnumPlatforms[SystemInfo.wProcessorArchitecture];


                if (InstallMode != INSTALL_NEW) {
                    DWORD i, Mask;
                    for (i=0,Mask=InstalledPlatforms; i<CountPlatforms; i++) {
                        if (Mask & 1) {
                            Platforms[i].Selected = TRUE;
                        }
                        Mask = Mask >> 1;
                    }
                }
                if( RequireThisPlatform < 4 ) {
                    Platforms[RequireThisPlatform].Selected = TRUE;
                }


                hwndList = GetDlgItem( hwnd, IDC_PLATFORM_LIST );

                //
                // set/initialize the image list(s)
                //
                himlState = ImageList_Create( 16, 16, TRUE, 2, 0 );

                ImageList_AddMasked(
                    himlState,
                    LoadBitmap( FaxWizModuleHandle, MAKEINTRESOURCE(IDB_CHECKSTATES) ),
                    RGB (255,0,0)
                    );

                ListView_SetImageList( hwndList, himlState, LVSIL_STATE );

                //
                // set/initialize the columns
                //
                lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                lvc.fmt = LVCFMT_LEFT;
                lvc.cx = 274;
                lvc.pszText = TEXT("Platform");
                lvc.iSubItem = 0;
                ListView_InsertColumn( hwndList, lvc.iSubItem, &lvc );

                //
                // add the data to the list
                //

                for (i=0,lvi.iItem=0; i<MAX_PLATFORMS; i++) {

                    lvi.pszText = Platforms[i].PrintPlatform;
                    lvi.iItem += 1;
                    lvi.iSubItem = 0;
                    lvi.iImage = 0;
                    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
                    lvi.state = Platforms[i].Selected ? LVIS_GCCHECK : LVIS_GCNOCHECK;
                    lvi.stateMask = LVIS_STATEIMAGEMASK;
                    iItem = ListView_InsertItem( hwndList, &lvi );

                }

                //
                // Set focus to the list control and make first un-selected platform blue.
                //

                for (i = 0 ; i < MAX_PLATFORMS ; ++ i ){
                    if ( !Platforms[i].Selected ){
                        break ;
                    }
                }
                if (i == MAX_PLATFORMS ){
                    i = 0 ;
                }
                ListView_SetItemState( hwndList, i, LVIS_FOCUSED | LVNI_SELECTED, 0x000F );
            }
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    if (Unattended) {
                        WCHAR buf[128];
                        LPWSTR p = buf;
                        DWORD i;
                        UnAttendGetAnswer(
                            UAA_PLATFORM_LIST,
                            (LPBYTE) buf,
                            sizeof(buf)/sizeof(WCHAR)
                            );
                        p = wcstok( buf, L"," );
                        do {
                            for (i=0; i<CountPlatforms; i++) {
                                if (_wcsicmp( Platforms[i].OsPlatform, p ) == 0) {
                                    Platforms[i].Selected = TRUE;
                                    break;
                                }
                            }
                            p = wcstok( NULL, L"," );
                        } while(p);
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    if (InstallMode & INSTALL_UPGRADE || InstallMode & INSTALL_REMOVE) {
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    break;

                case NM_CLICK:
                    {
                        DWORD           dwpos;
                        LV_HITTESTINFO  lvhti;
                        int             iItemClicked;
                        UINT            state;

                        //
                        // Find out where the cursor was
                        //
                        dwpos = GetMessagePos();
                        lvhti.pt.x = LOWORD(dwpos);
                        lvhti.pt.y = HIWORD(dwpos);

                        MapWindowPoints( HWND_DESKTOP, hwndList, &lvhti.pt, 1 );

                        //
                        // Now do a hittest with this point.
                        //
                        iItemClicked = ListView_HitTest( hwndList, &lvhti );

                        if (lvhti.flags & LVHT_ONITEMSTATEICON) {
                            //
                            // Now lets get the state from the item and toggle it.
                            //
                            state = ListView_GetItemState(
                                hwndList,
                                iItemClicked,
                                LVIS_STATEIMAGEMASK
                                );

                            if ((InstallMode & INSTALL_DRIVERS &&
                                (1<<iItemClicked) & InstalledPlatforms &&
                                state == LVIS_GCCHECK) ||
                                ( (DWORD)iItemClicked == RequireThisPlatform)){

                                MessageBeep( MB_ICONEXCLAMATION );
                            }
                            else {

                                state = (state == LVIS_GCNOCHECK) ? LVIS_GCCHECK : LVIS_GCNOCHECK;

                                ListView_SetItemState(
                                    hwndList,
                                    iItemClicked,
                                    state,
                                    LVIS_STATEIMAGEMASK
                                    );

                                Platforms[iItemClicked].Selected = (state == LVIS_GCCHECK);

                            }

                        }


                    }
                    break;

                case LVN_KEYDOWN:

                    //
                    // Use space key to toggle check boxes
                    //

                    if (((LV_KEYDOWN *) lParam)->wVKey == VK_SPACE) {
                        INT index ;
                        UINT state ;
                            index = ListView_GetNextItem(hwndList, -1, LVNI_ALL|LVNI_SELECTED);
                            if (index == -1) {
                                return FALSE ;
                            }
                            //
                            // Toggle.
                            //
                            state = ListView_GetItemState(
                                hwndList,
                                index,
                                LVIS_STATEIMAGEMASK,
                                );
                            if ((InstallMode & INSTALL_DRIVERS &&
                                ( 1 << index ) & InstalledPlatforms &&
                                state == LVIS_GCCHECK) ||
                                ( (DWORD)index == RequireThisPlatform)){

                                MessageBeep( MB_ICONEXCLAMATION );

                            }
                            else {
                                state = ( state == LVIS_GCNOCHECK )? LVIS_GCCHECK : LVIS_GCNOCHECK ;
                                ListView_SetItemState(
                                    hwndList,
                                    index,
                                    state,
                                    LVIS_STATEIMAGEMASK
                                    );
                                Platforms[index].Selected = ( state == LVIS_GCCHECK );
                            }
                            return TRUE;
                    }
                    break;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\dlgra.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dlgra.c

Abstract:

    This file implements the dialog proc for the remote admin file copies.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop



LRESULT
RemoteAdminFileCopyDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static BOOL OkToProceed = FALSE;
    static DWORD RangeMax = 0;
    HANDLE hThread;
    DWORD ThreadId;


    switch( msg ) {
        case WM_MY_PROGRESS:
            if (wParam == 0xfe) {
                lParam += RangeMax;
                SendDlgItemMessage( hwnd, IDC_COPY_PROGRESS, PBM_SETRANGE, 0, MAKELPARAM(0,(lParam)));
                SendDlgItemMessage( hwnd, IDC_COPY_PROGRESS, PBM_SETSTEP,  1, 0 );
            } else if (wParam == 0xff) {
                RangeMax = lParam;
            } else {
                SendDlgItemMessage( hwnd, IDC_COPY_PROGRESS, PBM_DELTAPOS, wParam, 0 );
            }
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    SetDlgItemText(
                        hwnd,
                        IDC_FC_WAITMSG,
                        GetString( InstallMode & INSTALL_REMOVE ? IDS_DELETE_WAITMSG : IDS_COPY_WAITMSG )
                        );
                    hThread = CreateThread(
                        NULL,
                        0,
                        (InstallMode & INSTALL_REMOVE) ?
                            (LPTHREAD_START_ROUTINE) UninstallThread : RemoteAdminCopyThread,
                        hwnd,
                        0,
                        &ThreadId
                        );
                    if (hThread) {

                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        PropSheet_SetWizButtons( GetParent(hwnd), 0 );
                        return FALSE;

                    } else {

                        //
                        // popup an error
                        //

                    }
                    break;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\dlgpname.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dialogs.c

Abstract:

    This file implements the dialog proc for the
    printer name page.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop


LRESULT
PrinterNameDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static LPTSTR PrinterName;
    TCHAR Buffer[LT_PRINTER_NAME+1];


    switch( message ) {
        case WM_INITDIALOG:
            SendDlgItemMessage( hwnd, IDC_SERVER_NAME, EM_SETLIMITTEXT, LT_PRINTER_NAME, 0 );
            PrinterName = (LPTSTR) lParam;
            break;

        case WM_COMMAND:
            switch( wParam ) {
                case IDCANCEL:
                    EndDialog( hwnd, 0 );
                    return TRUE;

                case IDOK:
                    SendDlgItemMessage(
                        hwnd,
                        IDC_SERVER_NAME,
                        WM_GETTEXT,
                        LT_PRINTER_NAME,
                        (LPARAM) Buffer
                        );
                    if (!Buffer[0]) {
                        PopUpMsg( hwnd, IDS_PRINTER_NAME, TRUE, 0 );
                        return FALSE;
                    }
                    if (Buffer[0] == TEXT('\\') && Buffer[1] == TEXT('\\')) {
                        _tcscpy( PrinterName, Buffer );
                    } else {
                        PrinterName[0] = TEXT('\\');
                        PrinterName[1] = TEXT('\\');
                        PrinterName[2] = 0;
                        _tcscat( PrinterName, Buffer );
                    }
                    EndDialog( hwnd, 1 );
                    return TRUE;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\dlgstaid.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dialogs.c

Abstract:

    This file implements the dialog proc for the station
    identifier page (tsid & csid).

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop


LRESULT
StationIdDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch( msg ) {
        case WM_INITDIALOG:
            SendDlgItemMessage( hwnd, IDC_FAX_PHONE, EM_SETLIMITTEXT, LT_FAX_PHONE, 0 );
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    if (Unattended) {
                        UnAttendGetAnswer(
                            UAA_FAX_PHONE,
                            (LPBYTE) WizData.Csid,
                            LT_FAX_PHONE
                            );
                        _tcscpy( WizData.Tsid, WizData.Csid );
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    if (InstallMode != INSTALL_NEW) {
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    break;

                case PSN_WIZNEXT:
                    SendDlgItemMessage(
                        hwnd,
                        IDC_FAX_PHONE,
                        WM_GETTEXT,
                        LT_FAX_PHONE,
                        (LPARAM) WizData.Csid
                        );
                    if (!WizData.Csid[0]) {


                        PopUpMsg( hwnd, IDS_CSID, TRUE, 0 );

                        SetFocus( GetDlgItem( GetParent( hwnd ), IDCANCEL ));
                        PostMessage( hwnd, WM_NEXTDLGCTL, 1, FALSE );
                        PostMessage( hwnd, WM_NEXTDLGCTL, 1, FALSE );
                        PostMessage( hwnd, WM_NEXTDLGCTL, 1, FALSE );

                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    _tcscpy( WizData.Tsid, WizData.Csid );
                    break;

            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\dlgsec.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dlgsec.c

Abstract:

    This file implements the dialog proc for the
    security page.  This page captures the account
    name that the fax service runs under.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop

#define MY_SET_FOCUS    (WM_USER+1000)


LRESULT
RouteSecurityDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch( msg ) {
        case WM_INITDIALOG:
            SendDlgItemMessage( hwnd, IDC_ACCOUNT_NAME, EM_SETLIMITTEXT, LT_ACCOUNT_NAME, 0 );
            SendDlgItemMessage( hwnd, IDC_PASSWORD,     EM_SETLIMITTEXT, LT_PASSWORD,     0 );
            SendDlgItemMessage( hwnd, IDC_PASSWORD2,    EM_SETLIMITTEXT, LT_PASSWORD,     0 );

            {
                HANDLE hProcess, hAccessToken;
                BYTE InfoBuffer[1000];
                TCHAR szAccountName[200], szDomainName[200];
                PTOKEN_USER pTokenUser = (PTOKEN_USER)InfoBuffer;
                DWORD dwInfoBufferSize,dwAccountSize = 200, dwDomainSize = 200;
                SID_NAME_USE snu;
                hProcess = GetCurrentProcess();
                OpenProcessToken(
                    hProcess,
                    TOKEN_READ,
                    &hAccessToken
                    );
                GetTokenInformation(
                    hAccessToken,
                    TokenUser,
                    InfoBuffer,
                    1000,
                    &dwInfoBufferSize
                    );
                LookupAccountSid(
                    NULL,
                    pTokenUser->User.Sid,
                    szAccountName,
                    &dwAccountSize,
                    szDomainName,
                    &dwDomainSize,
                    &snu
                    );
                _stprintf( (LPTSTR)InfoBuffer, TEXT("%s\\%s"), szDomainName, szAccountName );
                SetDlgItemText( hwnd, IDC_ACCOUNT_NAME, (LPTSTR)InfoBuffer );
            }
            PostMessage( hwnd, MY_SET_FOCUS, 0, (LPARAM) GetDlgItem( hwnd, IDC_PASSWORD ) );
            return FALSE;

        case MY_SET_FOCUS:
            SetFocus( (HWND) lParam );
            SendMessage( (HWND) lParam, EM_SETSEL, 0, MAKELPARAM( 0, -1 ) );
            return FALSE;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    if (Unattended) {
                        if (!UnAttendGetAnswer(
                            UAA_ACCOUNT_NAME,
                            (LPBYTE) WizData.AccountName,
                            sizeof(WizData.AccountName)/sizeof(WCHAR)))
                        {
                            WizData.UseLocalSystem = TRUE;
                        } else {
                            if (!UnAttendGetAnswer(
                                UAA_PASSWORD,
                                (LPBYTE) WizData.Password,
                                sizeof(WizData.Password)/sizeof(WCHAR)))
                            {
                                WizData.UseLocalSystem = TRUE;
                            }
                        }

                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    if (InstallMode != INSTALL_NEW) {
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    break;

                case PSN_WIZNEXT:
                    {
                        TCHAR ConfirmPassword[64];

                        SendDlgItemMessage(
                            hwnd,
                            IDC_ACCOUNT_NAME,
                            WM_GETTEXT,
                            sizeof(WizData.AccountName),
                            (LPARAM) WizData.AccountName
                            );
                        SendDlgItemMessage(
                            hwnd,
                            IDC_PASSWORD,
                            WM_GETTEXT,
                            sizeof(WizData.Password),
                            (LPARAM) WizData.Password
                            );
                        if (!WizData.AccountName[0]) {
                            PopUpMsg( hwnd, IDS_ACCOUNTNAME, TRUE, 0 );
                            SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                            return TRUE;
                        }
                        SendDlgItemMessage(
                            hwnd,
                            IDC_PASSWORD2,
                            WM_GETTEXT,
                            sizeof(ConfirmPassword),
                            (LPARAM) ConfirmPassword
                            );
                        if (_tcscmp( ConfirmPassword, WizData.Password ) != 0) {
                            PopUpMsg( hwnd, IDS_PASSWORD, TRUE, 0 );
                            SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                            PostMessage( hwnd, MY_SET_FOCUS, 0, (LPARAM) GetDlgItem( hwnd, IDC_PASSWORD ) );
                            return TRUE;
                        }

                        if (!_tcschr( WizData.AccountName, TEXT('\\')))  {
                            TCHAR ComputerName[128];
                            DWORD Size = sizeof(ComputerName);
                            if (GetComputerName( ComputerName, &Size )) {
                                _tcscat( ComputerName, TEXT("\\") );
                                _tcscat( ComputerName, WizData.AccountName );
                                _tcscpy( WizData.AccountName, ComputerName );
                                SetDlgItemText( hwnd, IDC_ACCOUNT_NAME, WizData.AccountName );
                            }
                        }
                    }
                    break;

            }
            break;
    }

    return FALSE;
}


LRESULT
SecurityErrorDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static PSECURITY_INFO SecurityInfo;


    switch( message ) {
        case WM_INITDIALOG:
            SendDlgItemMessage( hwnd, IDC_ACCOUNT_NAME, EM_SETLIMITTEXT, LT_ACCOUNT_NAME, 0 );
            SendDlgItemMessage( hwnd, IDC_PASSWORD,     EM_SETLIMITTEXT, LT_PASSWORD,     0 );
            SendDlgItemMessage( hwnd, IDC_PASSWORD2,    EM_SETLIMITTEXT, LT_PASSWORD,     0 );
            SecurityInfo = (PSECURITY_INFO) lParam;
            SetDlgItemText( hwnd, IDC_ACCOUNT_NAME, (LPTSTR) SecurityInfo->AccountName );
            SetDlgItemText( hwnd, IDC_PASSWORD,     (LPTSTR) SecurityInfo->Password    );
            SetDlgItemText( hwnd, IDC_PASSWORD2,    (LPTSTR) SecurityInfo->Password    );
            break;

        case WM_COMMAND:
            switch( wParam ) {
                case IDCANCEL:
                    EndDialog( hwnd, 0 );
                    return TRUE;

                case IDOK:
                    {
                        TCHAR ConfirmPassword[64];

                        SendDlgItemMessage(
                            hwnd,
                            IDC_ACCOUNT_NAME,
                            WM_GETTEXT,
                            sizeof(SecurityInfo->AccountName),
                            (LPARAM) SecurityInfo->AccountName
                            );
                        SendDlgItemMessage(
                            hwnd,
                            IDC_PASSWORD,
                            WM_GETTEXT,
                            sizeof(SecurityInfo->Password),
                            (LPARAM) SecurityInfo->Password
                            );
                        if (!SecurityInfo->AccountName[0]) {
                            PopUpMsg( hwnd, IDS_ACCOUNTNAME, TRUE, 0 );
                            return TRUE;
                        }
                        SendDlgItemMessage(
                            hwnd,
                            IDC_PASSWORD2,
                            WM_GETTEXT,
                            sizeof(ConfirmPassword),
                            (LPARAM) ConfirmPassword
                            );
                        if (_tcscmp( ConfirmPassword, SecurityInfo->Password ) != 0) {
                            PopUpMsg( hwnd, IDS_PASSWORD, TRUE, 0 );
                            return TRUE;
                        }

                        if (!_tcschr( SecurityInfo->AccountName, TEXT('\\')))  {
                            TCHAR ComputerName[128];
                            DWORD Size = sizeof(ComputerName);
                            if (GetComputerName( ComputerName, &Size )) {
                                _tcscat( ComputerName, TEXT("\\") );
                                _tcscat( ComputerName, SecurityInfo->AccountName );
                                _tcscpy( SecurityInfo->AccountName, ComputerName );
                            }
                        }
                    }
                    EndDialog( hwnd, 1 );
                    return TRUE;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\dlgsvr.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dialogs.c

Abstract:

    This file implements the dialog proc for server name page.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop


LRESULT
ServerNameDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch( msg ) {
        case WM_INITDIALOG:
            {
                PPRINTER_INFO_4 PrinterInfo;
                DWORD           CountPrinters;

                SendDlgItemMessage( hwnd, IDC_PRINTER_NAME, EM_SETLIMITTEXT, LT_PRINTER_NAME, 0 );

                PrinterInfo = MyEnumPrinters( NULL, 4, &CountPrinters, 0);
                if (PrinterInfo && CountPrinters == 1) {
                    if (IsPrinterFaxPrinter( PrinterInfo[0].pPrinterName )) {
                        SetDlgItemText( hwnd, IDC_PRINTER_NAME, PrinterInfo[0].pPrinterName );
                    }
                }

                SetDlgItemText( hwnd, IDC_LABEL_PRINTERNAME, GetString(IDS_LABEL_PRINTERNAME) );
                SetDlgItemText( hwnd, IDC_PRINTER_NAME, GetString(IDS_DEFAULT_PRINTER_NAME) );
            }
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    if (Unattended) {
                        UnAttendGetAnswer(
                            UAA_PRINTER_NAME,
                            (LPBYTE) WizData.PrinterName,
                            LT_PRINTER_NAME
                            );
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    if (InstallMode != INSTALL_NEW) {
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    break;

                case PSN_WIZNEXT:
                    SendDlgItemMessage(
                        hwnd,
                        IDC_PRINTER_NAME,
                        WM_GETTEXT,
                        LT_PRINTER_NAME,
                        (LPARAM) WizData.PrinterName
                        );
                    if (!WizData.PrinterName[0]) {
                        PopUpMsg( hwnd, IDS_PRINTER_NAME, TRUE, 0 );
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }

                    if (_tcschr( WizData.PrinterName, TEXT('\\')) ||
                        _tcschr( WizData.PrinterName, TEXT('!')) ||
                        _tcschr( WizData.PrinterName, TEXT(','))){

                        PopUpMsg( hwnd, IDS_INVALID_LOCAL_PRINTER_NAME, TRUE, 0 );

                        ///Don't allow moving to the next page.

                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    break;

            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\dlgstore.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dialogs.c

Abstract:

    This file implements the dialog proc for the server
    routing directory store name page.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop


LRESULT
RouteStoreDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch( msg ) {
        case WM_INITDIALOG:
            CheckDlgButton( hwnd, IDC_ANS_NO,  BST_UNCHECKED );
            CheckDlgButton( hwnd, IDC_ANS_YES, BST_CHECKED   );
            EnableWindow( GetDlgItem( hwnd, IDC_DEST_DIRPATH ), TRUE );
            EnableWindow( GetDlgItem( hwnd, IDC_BROWSE_DIR   ), TRUE );
            ExpandEnvironmentStrings(
                DEFAULT_FAX_STORE_DIR,
                WizData.RouteDir,
                sizeof(WizData.RouteDir)
                );
            SetDlgItemText( hwnd, IDC_DEST_DIRPATH, WizData.RouteDir );
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED) {
                switch (LOWORD(wParam)) {
                    case IDC_ANS_YES:
                        EnableWindow( GetDlgItem( hwnd, IDC_DEST_DIRPATH ), TRUE );
                        EnableWindow( GetDlgItem( hwnd, IDC_BROWSE_DIR   ), TRUE );
                        break;

                    case IDC_ANS_NO:
                        EnableWindow( GetDlgItem( hwnd, IDC_DEST_DIRPATH ), FALSE );
                        EnableWindow( GetDlgItem( hwnd, IDC_BROWSE_DIR   ), FALSE );
                        break;

                    case IDC_BROWSE_DIR:
                        DoBrowseDestDir( hwnd );
                        break;
                }
            }
            break;


        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    if (Unattended) {
                        UnAttendGetAnswer(
                            UAA_ROUTE_FOLDER,
                            (LPBYTE) &WizData.RouteStore,
                            sizeof(WizData.RouteStore)
                            );
                        if (WizData.RouteStore) {
                            UnAttendGetAnswer(
                                UAA_DEST_DIRPATH,
                                (LPBYTE) WizData.RouteDir,
                                sizeof(WizData.RouteDir)/sizeof(WCHAR)
                                );
                            MakeDirectory( WizData.RouteDir );
                        }
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    if (InstallMode != INSTALL_NEW) {
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    break;

                case PSN_WIZNEXT:
                    WizData.RouteStore = IsDlgButtonChecked( hwnd, IDC_ANS_YES );
                    if (WizData.RouteStore) {
                        SendDlgItemMessage(
                            hwnd,
                            IDC_DEST_DIRPATH,
                            WM_GETTEXT,
                            sizeof(WizData.RouteDir),
                            (LPARAM) WizData.RouteDir
                            );
                        if (!WizData.RouteDir[0]) {
                            PopUpMsg( hwnd, IDS_DEST_DIR, TRUE, 0 );
                            SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                            return TRUE;
                        }
                        MakeDirectory( WizData.RouteDir );
                    } else {
                        WizData.RouteDir[0] = 0;
                    }
                    break;

            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\dlgprint.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dlgprint.c

Abstract:

    This file implements the dialog proc for the routing
    print page.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop


LRESULT
RoutePrintDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static DWORD CountPrinters = 0;
    static TCHAR DefaultPrinter[128];

    switch( msg ) {
        case WM_INITDIALOG:
            {
                PPRINTER_INFO_4 PrinterInfo;
                DWORD           i;
                DWORD           Cnt = 0;


                PrinterInfo = MyEnumPrinters( NULL, 4, &CountPrinters, 0);
                if (!PrinterInfo) {
                    return FALSE;
                }

                SendDlgItemMessage(
                    hwnd,
                    IDC_DEST_PRINTERLIST,
                    CB_RESETCONTENT,
                    0,
                    0
                    );

                //
                // check the default printer
                //

                GetProfileString(
                    TEXT("windows"),
                    TEXT("device"),
                    NULL,
                    DefaultPrinter,
                    sizeof(DefaultPrinter)
                    );

                if (DefaultPrinter[0]) {
                    SendDlgItemMessage(
                        hwnd,
                        IDC_DEST_PRINTERLIST,
                        CB_ADDSTRING,
                        0,
                        (LPARAM) GetString( IDS_DEFAULT_PRINTER )
                        );
                }
                EnableWindow( GetDlgItem( hwnd, IDC_DEST_PRINTERLIST ), TRUE );
                CheckDlgButton( hwnd, IDC_ANS_YES, BST_CHECKED   );
                CheckDlgButton( hwnd, IDC_ANS_NO, BST_UNCHECKED );

                //
                // add the printer names to the combobox
                //

                for (i=0; i<CountPrinters; i++) {
                    SendDlgItemMessage(
                        hwnd,
                        IDC_DEST_PRINTERLIST,
                        CB_ADDSTRING,
                        0,
                        (LPARAM) PrinterInfo[i].pPrinterName
                        );
                }

                SendDlgItemMessage(
                    hwnd,
                    IDC_DEST_PRINTERLIST,
                    CB_SETCURSEL,
                    0,
                    0
                    );
                SetFocus( GetDlgItem( hwnd, IDC_DEST_PRINTERLIST ));
                MemFree( PrinterInfo );
            }
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED) {
                switch (LOWORD(wParam)) {
                    case IDC_ANS_YES:
                        EnableWindow( GetDlgItem( hwnd, IDC_DEST_PRINTERLIST ),TRUE );
                        SetFocus( GetDlgItem( hwnd, IDC_DEST_PRINTERLIST ));
                        break;

                    case IDC_ANS_NO:
                        EnableWindow( GetDlgItem( hwnd, IDC_DEST_PRINTERLIST ), FALSE );
                }
            }
            break;


        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    if (Unattended) {
                        UnAttendGetAnswer(
                            UAA_ROUTE_PRINT,
                            (LPBYTE) &WizData.RoutePrint,
                            sizeof(WizData.RoutePrint)
                            );
                        if (WizData.RoutePrint) {
                            UnAttendGetAnswer(
                                UAA_DEST_PRINTERLIST,
                                (LPBYTE) WizData.RoutePrinterName,
                                sizeof(WizData.RoutePrinterName)/sizeof(WCHAR)
                                );
                            if (_wcsicmp( WizData.RoutePrinterName, L"<default>" ) == 0) {
                                LPTSTR p;

                                GetProfileString(
                                    TEXT("windows"),
                                    TEXT("device"),
                                    NULL,
                                    WizData.RoutePrinterName,
                                    sizeof(WizData.RoutePrinterName)
                                    );

                                p = _tcschr( WizData.RoutePrinterName, TEXT(',') );
                                if (p) {
                                    *p = 0;
                                }
                            }
                        }
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    if (InstallMode != INSTALL_NEW) {
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    if (!CountPrinters) {
                        //
                        // this system does not have any printers configured
                        // skip this wizard page
                        //
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    break;

                case PSN_WIZNEXT:

                    WizData.RoutePrint = IsDlgButtonChecked( hwnd, IDC_ANS_YES );
                    if (WizData.RoutePrint) {
                        int Index = SendDlgItemMessage(
                            hwnd,
                            IDC_DEST_PRINTERLIST,
                            CB_GETCURSEL,
                            0,
                            0
                            );

                        WizData.UseDefaultPrinter = DefaultPrinter[0] && !Index;

                        if (WizData.UseDefaultPrinter) {

                            LPTSTR p;

                            GetProfileString(
                                TEXT("windows"),
                                TEXT("device"),
                                NULL,
                                WizData.RoutePrinterName,
                                sizeof(WizData.RoutePrinterName)
                                );

                            p = _tcschr( WizData.RoutePrinterName, TEXT(',') );
                            if (p) {
                                *p = 0;
                            }

                        } else {

                            SendDlgItemMessage(
                                hwnd,
                                IDC_DEST_PRINTERLIST,
                                CB_GETLBTEXT,
                                Index,
                                (LPARAM) WizData.RoutePrinterName
                                );

                        }

                        if (IsPrinterFaxPrinter( WizData.RoutePrinterName )) {
                            PopUpMsg( hwnd, IDS_CANT_USE_FAX_PRINTER, TRUE, 0 );

                            //
                            // Set Focus to the combo box.
                            //
                            SetFocus( GetDlgItem( hwnd, IDC_DEST_PRINTERLIST ));

                            SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                            return TRUE;
                        }

                    }
                    break;

            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\dlgsvrnm.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dialogs.c

Abstract:

    This file implements the dialog proc for the client's
    server name page.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop


LRESULT
ClientServerNameDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    TCHAR Buffer[EM_SETLIMITTEXT+1];


    switch( msg ) {
        case WM_INITDIALOG:
            SendDlgItemMessage( hwnd, IDC_SERVER_NAME, EM_SETLIMITTEXT, LT_PRINTER_NAME, 0 );
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    if (Unattended) {
                        UnAttendGetAnswer(
                            UAA_PRINTER_NAME,
                            (LPBYTE) WizData.PrinterName,
                            LT_PRINTER_NAME
                            );
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    if (InstallMode & INSTALL_UPGRADE || InstallMode & INSTALL_REMOVE) {
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    break;

                case PSN_WIZNEXT:
                    SendDlgItemMessage(
                        hwnd,
                        IDC_SERVER_NAME,
                        WM_GETTEXT,
                        LT_PRINTER_NAME,
                        (LPARAM) Buffer
                        );
                    if (!Buffer[0]) {
                        PopUpMsg( hwnd, IDS_PRINTER_NAME, TRUE, 0 );
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    if (Buffer[0] == TEXT('\\') && Buffer[1] == TEXT('\\')) {
                        _tcscpy( WizData.PrinterName, Buffer );
                    } else {
                        WizData.PrinterName[0] = TEXT('\\');
                        WizData.PrinterName[1] = TEXT('\\');
                        WizData.PrinterName[2] = 0;
                        _tcscat( WizData.PrinterName, Buffer );
                    }
                    break;

            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\dlguser.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dialogs.c

Abstract:

    This file implements the dialog procs for the user
    information page.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop


LRESULT
ClientUserInfoDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch( msg ) {
        case WM_INITDIALOG:
            {
                LPTSTR UserName;
                LPTSTR AreaCode;
                LPTSTR FaxNumber;
                GetUserInformation( &UserName, &FaxNumber, &AreaCode );

                SendDlgItemMessage( hwnd, IDC_SENDER_NAME, EM_SETLIMITTEXT, LT_USER_NAME, 0 );
                SendDlgItemMessage( hwnd, IDC_SENDER_FAX_AREA_CODE, EM_SETLIMITTEXT, LT_AREA_CODE, 0 );
                SendDlgItemMessage( hwnd, IDC_SENDER_FAX_NUMBER, EM_SETLIMITTEXT, LT_PHONE_NUMBER, 0 );

                SetDlgItemText( hwnd, IDC_SENDER_NAME, UserName );
                SetDlgItemText( hwnd, IDC_SENDER_FAX_AREA_CODE, AreaCode );
                SetDlgItemText( hwnd, IDC_SENDER_FAX_NUMBER, FaxNumber );

                MemFree( UserName );
                MemFree( AreaCode );
                MemFree( FaxNumber );
            }
            break;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case PSN_SETACTIVE:
                    if (Unattended) {
                        UnAttendGetAnswer(
                            UAA_SENDER_NAME,
                            (LPBYTE) WizData.UserName,
                            LT_USER_NAME
                            );
                        UnAttendGetAnswer(
                            UAA_SENDER_FAX_AREA_CODE,
                            (LPBYTE) WizData.AreaCode,
                            LT_AREA_CODE+1
                            );
                        UnAttendGetAnswer(
                            UAA_SENDER_FAX_NUMBER,
                            (LPBYTE) WizData.PhoneNumber,
                            LT_PHONE_NUMBER+1
                            );
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    if (InstallMode & INSTALL_UPGRADE || InstallMode & INSTALL_REMOVE) {
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }
                    break;

                case PSN_WIZNEXT:
                    SendDlgItemMessage(
                        hwnd,
                        IDC_SENDER_NAME,
                        WM_GETTEXT,
                        LT_USER_NAME,
                        (LPARAM) WizData.UserName
                        );

                    SendDlgItemMessage(
                        hwnd,
                        IDC_SENDER_FAX_AREA_CODE,
                        WM_GETTEXT,
                        LT_AREA_CODE+1,
                        (LPARAM) WizData.AreaCode
                        );

                    SendDlgItemMessage(
                        hwnd,
                        IDC_SENDER_FAX_NUMBER,
                        WM_GETTEXT,
                        LT_PHONE_NUMBER+1,
                        (LPARAM) WizData.PhoneNumber
                        );

                    if (!WizData.UserName[0]) {
                        PopUpMsg( hwnd, IDS_INVALID_USER_NAME, TRUE, 0 );
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }

                    if (!WizData.AreaCode[0]) {
                        PopUpMsg( hwnd, IDS_INVALID_AREA_CODE, TRUE, 0 );
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }

                    if (!WizData.PhoneNumber[0]) {
                        PopUpMsg( hwnd, IDS_INVALID_PHONE_NUMBER, TRUE, 0 );
                        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
                        return TRUE;
                    }

                    break;

            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\faxwiz.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    wizard.c

Abstract:

    This file implements the setup wizard code for the
    FAX server setup.

Environment:

        WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop

// ------------------------------------------------------------
// Internal prototypes
BOOL Win9xUpg();		// t-briand: added for Win9x upgrade process.



WIZPAGE SetupWizardPages[WizPageMaximum] = {

    //
    // Device Status Page
    //
    {
       PSWIZB_NEXT,                                    // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageDeviceStatus,                            // page id
       DeviceStatusDlgProc,                            // dlg proc
     { 0,                                              // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_DEVICE_INIT_PAGE),          // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       CommonDlgProc,                                  // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // Device Selection Page
    //
    {
       PSWIZB_NEXT,                                    // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageDeviceSelection,                         // page id
       DeviceSelectionDlgProc,                         // dlg proc
     { 0,                                              // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_WORKSTATION_DEVICE_SELECT), // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       CommonDlgProc,                                  // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // Server name page
    //
    {
       PSWIZB_NEXT,                                    // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageServerName,                              // page id
       ServerNameDlgProc,                              // dlg proc
     { 0,                                              // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_SERVER_NAME_PAGE),          // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       CommonDlgProc,                                  // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // Exchange page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,                      // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageExchange,                                // page id
       ExchangeDlgProc,                                // dlg proc
     { 0,                                              // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_EXCHANGE_PAGE),             // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       CommonDlgProc,                                  // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // File copy page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,                      // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageFileCopy,                                // page id
       FileCopyDlgProc,                                // dlg proc
     { 0,                                              // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_FILE_COPY_PAGE),            // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       CommonDlgProc,                                  // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // Station Id page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,                      // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageStationId,                               // page id
       StationIdDlgProc,                               // dlg proc
     { 0,                                              // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_STATIONID_PAGE),            // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       CommonDlgProc,                                  // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // Routing Printer Name Page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,                      // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageRoutePrint,                              // page id
       RoutePrintDlgProc,                              // dlg proc
     { 0,                                              // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_ROUTE_PRINT_PAGE),          // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       CommonDlgProc,                                  // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // Routing Store Page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,                      // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageRouteStoreDir,                           // page id
       RouteStoreDlgProc,                              // dlg proc
     { 0,                                              // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_ROUTE_STOREDIR_PAGE),       // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       CommonDlgProc,                                  // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // Routing Inbox Page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,                      // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageRouteInbox,                              // page id
       RouteMailDlgProc,                               // dlg proc
     { 0,                                              // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_ROUTE_INBOX_PAGE),          // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       CommonDlgProc,                                  // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // Routing Security Page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,                      // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageRouteSecurity,                           // page id
       RouteSecurityDlgProc,                           // dlg proc
     { 0,                                              // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_ROUTE_USERPASS_PAGE),       // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       CommonDlgProc,                                  // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // Platforms Page
    //
    {
       PSWIZB_NEXT,                                    // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPagePlatforms,                               // page id
       PlatformsDlgProc,                               // dlg proc
     { 0,                                              // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_SERVER_PLATFORMS_PAGE),     // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       CommonDlgProc,                                  // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // Last server page
    //
    {
       PSWIZB_FINISH,                                  // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageLast,                                    // page id
       LastPageDlgProc,                                // dlg proc
     { 0,                                              // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_LAST_WIZARD_PAGE),          // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       CommonDlgProc,                                  // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // Last uninstall page
    //
    {
       PSWIZB_FINISH,                                  // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageLastUninstall,                           // page id
       LastPageUninstallDlgProc,                       // dlg proc
     { 0,                                              // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_LAST_UNINSTALL_PAGE),       // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       CommonDlgProc,                                  // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // Client's fax server name page
    //
    {
       PSWIZB_NEXT,                                    // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageClientServerName,                        // page id
       ClientServerNameDlgProc,                        // dlg proc
     { 0,                                              // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_CLIENT_SERVER_NAME_PAGE),   // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       CommonDlgProc,                                  // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // Client's user info page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,                      // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageClientUserInfo,                          // page id
       ClientUserInfoDlgProc,                          // dlg proc
     { 0,                                              // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_CLIENT_USER_INFO_PAGE),     // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       CommonDlgProc,                                  // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // Client file copy page
    //
    {
       PSWIZB_NEXT | PSWIZB_BACK,                      // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageClientFileCopy,                          // page id
       ClientFileCopyDlgProc,                          // dlg proc
     { 0,                                              // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_FILE_COPY_PAGE),            // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       CommonDlgProc,                                  // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // Last client page
    //
    {
       PSWIZB_FINISH,                                  // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageClientLast,                              // page id
       LastClientPageDlgProc,                          // dlg proc
     { 0,                                              // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_CLIENT_LAST_PAGE),          // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       CommonDlgProc,                                  // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }},

    //
    // Remote admin file copy page
    //
    {
       PSWIZB_NEXT,                                    // valid buttons
       0,                                              // help id
       NULL,                                           // title
       WizPageRemoteAdminCopy,                         // page id
       RemoteAdminFileCopyDlgProc,                     // dlg proc
     { 0,                                              // size of struct
       0,                                              // flags
       NULL,                                           // hinst (filled in at run time)
       MAKEINTRESOURCE(IDD_FILE_COPY_PAGE),            // dlg template
       NULL,                                           // icon
       NULL,                                           // title
       CommonDlgProc,                                  // dlg proc
       0,                                              // lparam
       NULL,                                           // callback
       NULL                                            // ref count
    }}

};


DWORD ServerWizardPages[] =
{

    WizPageDeviceStatus,
    WizPageServerName,
    WizPagePlatforms,
    WizPageStationId,
    WizPageExchange,
    WizPageRouteStoreDir,
    WizPageRoutePrint,
    WizPageRouteInbox,
    WizPageRouteSecurity,
    WizPageFileCopy,
    WizPageLast,
    WizPageLastUninstall,
    (DWORD)-1

};


DWORD WorkstationWizardPages[] =
{

    WizPageDeviceStatus,
    WizPageDeviceSelection,
    WizPageServerName,
    WizPageStationId,
    WizPageExchange,
    WizPageRouteStoreDir,
    WizPageRoutePrint,
    WizPageRouteInbox,
    WizPageRouteSecurity,
    WizPageFileCopy,
    WizPageLast,
    WizPageLastUninstall,
    (DWORD)-1

};


DWORD ClientWizardPages[] =
{

    WizPageClientServerName,
    WizPageClientUserInfo,
    WizPageExchange,
    WizPageClientFileCopy,
    WizPageClientLast,
    WizPageLastUninstall,
    (DWORD)-1

};


DWORD PointPrintWizardPages[] =
{

    WizPageClientUserInfo,
    WizPageClientFileCopy,
    (DWORD)-1

};


DWORD RemoteAdminPages[] =
{

    WizPageRemoteAdminCopy,
    WizPageLast,
    WizPageLastUninstall,
    (DWORD)-1

};


HINSTANCE   FaxWizModuleHandle;
TCHAR       SourceDirectory[4096];
TCHAR       ClientSetupServerName[128];
BOOL        MapiAvail;
BOOL        Unattended;
BOOL        SuppressReboot = FALSE;
BOOL        NtGuiMode;
WIZ_DATA    WizData;
BOOL        OkToCancel;

BOOL        PointPrintSetup;
DWORD       RequestedSetupType;
DWORD       InstallMode;
DWORD       Installed;
DWORD       InstallType;
DWORD       InstalledPlatforms;
DWORD       Enabled;
DWORD       InstallThreadError;


DWORD
FaxWizardDllInit(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )

/*++

Routine Description:

    DLL initialization function.

Arguments:

    hInstance   - Instance handle
    Reason      - Reason for the entrypoint being called
    Context     - Context record

Return Value:

    TRUE        - Initialization succeeded
    FALSE       - Initialization failed

--*/

{
    if (Reason == DLL_PROCESS_ATTACH) {
        FaxWizModuleHandle = hInstance;
        DisableThreadLibraryCalls( hInstance );
        HeapInitialize( NULL, NULL, NULL, 0 );
    }

    if (Reason == DLL_PROCESS_DETACH) {
        HeapCleanup();
    }

    return TRUE;
}


BOOL
WINAPI
FaxWizInit(
    VOID
    )
{
    InitializeStringTable();

    if (!NtGuiMode) {
        InitializeMapi();
    }

    GetInstallationInfo( &Installed, &InstallType, &InstalledPlatforms, &Enabled );

    //
    // Sequentially enumerate platforms.
    //

    EnumPlatforms[PROCESSOR_ARCHITECTURE_INTEL] =  0;
    EnumPlatforms[PROCESSOR_ARCHITECTURE_MIPS]  =  WRONG_PLATFORM;
    EnumPlatforms[PROCESSOR_ARCHITECTURE_ALPHA] =  1;
    EnumPlatforms[PROCESSOR_ARCHITECTURE_PPC]   =  WRONG_PLATFORM;

    return TRUE;
}


DWORD
WINAPI
FaxWizGetError(
    VOID
    )
{
    return InstallThreadError;
}


VOID
WINAPI
FaxWizSetInstallMode(
    DWORD RequestedInstallMode,
    DWORD RequestedInstallType,
    LPWSTR AnswerFile
    )
{
    InstallMode = RequestedInstallMode;
    InstallType = RequestedInstallType;

    if (InstallMode == (INSTALL_REMOVE | INSTALL_UNATTENDED) ) {

        InstallMode = INSTALL_REMOVE;
        Unattended = TRUE;

    }

    if (InstallMode == INSTALL_UNATTENDED) {

        //
        // initialize the answers
        //

        UnAttendInitialize( AnswerFile );

        //
        // set the install mode
        //

        if (_wcsicmp( UnattendAnswerTable[UAA_MODE].Answer.String, MODE_NEW ) == 0) {
            InstallMode = INSTALL_NEW;
        } else if (_wcsicmp( UnattendAnswerTable[UAA_MODE].Answer.String, MODE_UPGRADE ) == 0) {
            InstallMode = INSTALL_UPGRADE;
        } else if (_wcsicmp( UnattendAnswerTable[UAA_MODE].Answer.String, MODE_REMOVE ) == 0) {
            InstallMode = INSTALL_REMOVE;
        } else if (_wcsicmp( UnattendAnswerTable[UAA_MODE].Answer.String, MODE_DRIVERS ) == 0) {
            InstallMode = INSTALL_DRIVERS;
        } else {
            InstallMode = INSTALL_NEW;
        }

        if (InstallMode == INSTALL_UPGRADE && Installed == FALSE) {
            InstallMode = INSTALL_NEW;
        }

        //
        // remember that faxsetup is doing an unattended setup
        // this is the flag that all other code checks
        //

        Unattended = TRUE;
    }
}


BOOL
WINAPI
FaxWizPointPrint(
    LPTSTR DirectoryName,
    LPTSTR PrinterName
    )
{
    DWORD len;
    LPTSTR p;

    len = _tcslen(DirectoryName);
    _tcscpy( SourceDirectory, DirectoryName );

    p = _tcschr( SourceDirectory, TEXT('\\') );
    if (p) {
        *p = 0;
        _tcscpy( ClientSetupServerName, &SourceDirectory[2] );
        *p = TEXT('\\');
    }

    if (SourceDirectory[len-1] != TEXT('\\')) {
        SourceDirectory[len] = TEXT('\\');
        SourceDirectory[len+1] = 0;
    }

    if (PrinterName[0] == TEXT('\\') && PrinterName[1] == TEXT('\\')) {
        _tcscpy( WizData.PrinterName, PrinterName );
    } else {
        WizData.PrinterName[0] = TEXT('\\');
        WizData.PrinterName[1] = TEXT('\\');
        WizData.PrinterName[2] = 0;
        _tcscat( WizData.PrinterName, PrinterName );
    }

    InstallMode = INSTALL_NEW;
    PointPrintSetup = TRUE;

    return TRUE;
}


VOID
SetThisPlatform(
    VOID
    )
{
    SYSTEM_INFO SystemInfo;
    GetSystemInfo( &SystemInfo );
    if ((SystemInfo.wProcessorArchitecture > 3) || (EnumPlatforms[SystemInfo.wProcessorArchitecture] == WRONG_PLATFORM)) {
       return;
    }

    Platforms[EnumPlatforms[SystemInfo.wProcessorArchitecture]].Selected = TRUE;
}


LPHPROPSHEETPAGE
WINAPI
FaxWizGetServerPages(
    LPDWORD PageCount
    )
{
    SetThisPlatform();
    RequestedSetupType = SETUP_TYPE_SERVER;
    SetTitlesInStringTable();
    return CreateWizardPages( FaxWizModuleHandle, SetupWizardPages, ServerWizardPages, PageCount );
}


LPHPROPSHEETPAGE
WINAPI
FaxWizGetWorkstationPages(
    LPDWORD PageCount
    )
{
    SetThisPlatform();
    RequestedSetupType = SETUP_TYPE_WORKSTATION;
    SetTitlesInStringTable();
    return CreateWizardPages( FaxWizModuleHandle, SetupWizardPages, WorkstationWizardPages, PageCount );
}


LPHPROPSHEETPAGE
WINAPI
FaxWizGetClientPages(
    LPDWORD PageCount
    )
{
    SetThisPlatform();
    RequestedSetupType = SETUP_TYPE_CLIENT;
    SetTitlesInStringTable();
    return CreateWizardPages( FaxWizModuleHandle, SetupWizardPages, ClientWizardPages, PageCount );
}


LPHPROPSHEETPAGE
WINAPI
FaxWizGetPointPrintPages(
    LPDWORD PageCount
    )
{
    SetThisPlatform();
    RequestedSetupType = SETUP_TYPE_POINT_PRINT;
    SetTitlesInStringTable();
    return CreateWizardPages( FaxWizModuleHandle, SetupWizardPages, PointPrintWizardPages, PageCount );
}

LPHPROPSHEETPAGE
WINAPI
FaxWizRemoteAdminPages(
    LPDWORD PageCount
    )
{
    SetThisPlatform();
    RequestedSetupType = SETUP_TYPE_REMOTE_ADMIN;
    SetTitlesInStringTable();
    return CreateWizardPages( FaxWizModuleHandle, SetupWizardPages, RemoteAdminPages, PageCount );
}


PFNPROPSHEETCALLBACK WINAPI
FaxWizGetPropertySheetCallback(
    VOID
    )
{
    return WizardCallback;
}

DWORD
DllRegisterServer(
    VOID
    )
{
    OSVERSIONINFO OsVersion;
    DWORD ProductType;
    PROPSHEETHEADER psh;
    LPHPROPSHEETPAGE WizardPageHandles;
    DWORD PageCount;
    DWORD Size;
    LPTSTR EnvVar;
    BOOL UseDefaults = TRUE;
    SYSTEM_INFO SystemInfo;
    BOOL NtGuiModeUpgrade = FALSE;


    NtGuiMode = TRUE;

    if (!FaxWizInit()) {
        return 0;
    }

    ZeroMemory( &OsVersion, sizeof(OSVERSIONINFO) );
    OsVersion.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    GetVersionEx( &OsVersion );

    ProductType = GetProductType();
    if (ProductType == 0) {
        return 0;
    }

    GetSystemInfo( &SystemInfo );

    SetThisPlatform();

    if (ProductType == PRODUCT_TYPE_WINNT) {
        RequestedSetupType = SETUP_TYPE_WORKSTATION;
    } else {
        RequestedSetupType = SETUP_TYPE_SERVER;
    }

    InstallMode = INSTALL_NEW;
    Unattended = TRUE;

    EnvVar = GetEnvVariable( TEXT("Upgrade") );
    if (EnvVar) {
        if (_wcsicmp( EnvVar, L"True" ) == 0) {
            InstallMode = INSTALL_UPGRADE;
            NtGuiModeUpgrade = TRUE;
        }
        MemFree( EnvVar );
    }

    if (InstallMode == INSTALL_UPGRADE && Installed == FALSE) {
        InstallMode = INSTALL_NEW;
    }

    EnvVar = GetEnvVariable( TEXT("UnattendFile") );
    if (EnvVar) {
        if (UnAttendInitialize( EnvVar )) {
            UseDefaults = FALSE;
        }
        MemFree( EnvVar );
    } else if(Win9xUpg()) {
	    // t-briand: If we're upgrading from win9x, then we don't want to use the defaults.
	    // The unattend answer table will be set as a side effect of the call to Win9xUpg().
	UseDefaults = FALSE;
    }

    if (UseDefaults) {

        UnattendAnswerTable[0].Answer.String   = GetString( IDS_UAA_MODE );
        UnattendAnswerTable[1].Answer.String   = GetString( IDS_UAA_PRINTER_NAME );
        UnattendAnswerTable[2].Answer.String   = GetString( IDS_UAA_FAX_PHONE );
        UnattendAnswerTable[3].Answer.Bool     = FALSE;
        UnattendAnswerTable[4].Answer.String   = GetString( IDS_UAA_DEST_PROFILENAME );
        UnattendAnswerTable[5].Answer.Bool     = FALSE;
        UnattendAnswerTable[6].Answer.String   = GetString( IDS_UAA_ROUTE_PROFILENAME );
        UnattendAnswerTable[8].Answer.Bool     = FALSE;
        UnattendAnswerTable[9].Answer.String   = GetString( IDS_UAA_DEST_PRINTERLIST );
        UnattendAnswerTable[12].Answer.String  = GetString( IDS_UAA_FAX_PHONE );
        UnattendAnswerTable[14].Answer.Bool    = TRUE;
        UnattendAnswerTable[15].Answer.String  = GetString( IDS_UAA_SERVER_NAME );
        UnattendAnswerTable[16].Answer.String  = GetString( IDS_UAA_SENDER_NAME );
        UnattendAnswerTable[17].Answer.String  = GetString( IDS_UAA_SENDER_FAX_AREA_CODE );
        UnattendAnswerTable[18].Answer.String  = GetString( IDS_UAA_SENDER_FAX_NUMBER );

        UnattendAnswerTable[7].Answer.String =
            StringDup( Platforms[EnumPlatforms[SystemInfo.wProcessorArchitecture]].OsPlatform );

        UnattendAnswerTable[13].Answer.String = ExpandEnvironmentString( GetString( IDS_UAA_DEST_DIRPATH ) );
        if (UnattendAnswerTable[13].Answer.String == NULL) {
            return 0;
        }

    } else {

        if (UnattendAnswerTable[10].Answer.String) {
            MemFree( UnattendAnswerTable[10].Answer.String );
        }

        if (UnattendAnswerTable[11].Answer.String) {
            MemFree( UnattendAnswerTable[11].Answer.String );
        }

    }

    UnattendAnswerTable[10].Answer.String = NULL;
    UnattendAnswerTable[11].Answer.String = NULL;

    SetTitlesInStringTable();

    //
    // setup the wizard pages & property sheet
    //

    if (RequestedSetupType == SETUP_TYPE_WORKSTATION) {
        WizardPageHandles = CreateWizardPages( FaxWizModuleHandle, SetupWizardPages, WorkstationWizardPages, &PageCount );
    } else {
        WizardPageHandles = CreateWizardPages( FaxWizModuleHandle, SetupWizardPages, ServerWizardPages, &PageCount );
    }

    if (WizardPageHandles == NULL || PageCount == 0) {
        return 0;
    }

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_WIZARD;
    psh.hwndParent = NULL;
    psh.hInstance = FaxWizModuleHandle;
    psh.pszIcon = NULL;
    psh.pszCaption = EMPTY_STRING;
    psh.nPages = PageCount;
    psh.nStartPage = 0;
    psh.phpage = WizardPageHandles;
    psh.pfnCallback = NULL;

    __try {

        PropertySheet( &psh );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        Size = GetExceptionCode();

    }

    return 0;
}

// Win9xUpg
//
// This routine is the hook for the Windows 9x upgrade process.  It looks for
// the fax95upg.inf file in the %SystemRoot% directory.  If it's there, it
// uses it to prime the unattend answers.  If not, we're not upgrading from
// win9x and it does nothing.
//
// As I write this, I'm wondering why the separate INF file was necessary instead
// of the unattend file used by the rest of the migration process.  Ah well.
//
// Parameters:
//	None.
//
// Returns:
//	TRUE if we're doing a Win9x upgrade; this implies that the unattend
//	answers are properly set at the end of the function.  Returns FALSE
//	if not upgrading.
//
// Author:
//	Brian Dewey (t-briand)	1997-8-15
BOOL
Win9xUpg()
{
    TCHAR szFaxInfPath[MAX_PATH]; // Holds the full path to the INF file.
    TCHAR szFaxInfPathRes[MAX_PATH]; // Path template from resource file.
    BOOL bReturn;

    if(!LoadString(FaxWizModuleHandle,
		   IDS_W95_INF_NAME,
		   szFaxInfPathRes,
		   sizeof(szFaxInfPathRes))) {
	    // Unable to load resource.  Use default name.
	_tcscpy(szFaxInfPathRes, TEXT("%SystemRoot\\fax95upg.inf"));
    }
    ExpandEnvironmentStrings(szFaxInfPathRes,
			     szFaxInfPath,
			     sizeof(szFaxInfPath));
	// Assume success.  The failure will be caught in UnAttendInitialize when I
	// give it a bogus filename.
    bReturn = UnAttendInitialize(szFaxInfPath);
    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\printer.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    printer.c

Abstract:

    This file implements the printer/spooler code.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop



TCHAR Environment[MAX_PATH];
TCHAR DataFile[MAX_PATH];
TCHAR ConfigFile[MAX_PATH];
TCHAR DriverFile[MAX_PATH];
TCHAR MonitorFile[MAX_PATH];
TCHAR PrinterName[MAX_PATH];
TCHAR DriverDirectory[MAX_PATH];

DRIVER_INFO_2 DriverInfo =
{
    2,                               // cVersion
    FAX_DRIVER_NAME,                 // pName
    Environment,                     // pEnvironment
    DriverFile,                      // pDriverPath
    DataFile,                        // pDataFile
    ConfigFile                       // pConfigFile
};

PRINTER_INFO_2 PrinterInfo =
{
    NULL,                            // pServerName
    PrinterName,                     // pPrinterName
    NULL,                            // pShareName
    NULL,                            // pPortName
    FAX_DRIVER_NAME,                 // pDriverName
    NULL,                            // pComment
    NULL,                            // pLocation
    NULL,                            // pDevMode
    NULL,                            // pSepFile
    TEXT("winprint"),                // pPrintProcessor
    TEXT("RAW"),                     // pDatatype
    NULL,                            // pParameters
    NULL,                            // pSecurityDescriptor
    0,                               // Attributes
    0,                               // Priority
    0,                               // DefaultPriority
    0,                               // StartTime
    0,                               // UntilTime
    0,                               // Status
    0,                               // cJobs
    0                                // AveragePPM
};

MONITOR_INFO_2 MonitorInfo =
{
    FAX_MONITOR_NAME,                // pName
    Environment,                     // pEnvironment
    MonitorFile                      // pDLLName
};




BOOL
AddPrinterDrivers(
    VOID
    )
{
    DWORD i;
    DWORD BytesNeeded;


    for (i=0; i<MAX_PLATFORMS; i++) {

        if (!Platforms[i].Selected) {
            continue;
        }

        _tcscpy( Environment, Platforms[i].PrintPlatform );

        if (!GetPrinterDriverDirectory(
                 NULL,
                 Environment,
                 1,
                 (LPBYTE) DriverDirectory,
                 sizeof(DriverDirectory),
                 &BytesNeeded
                 )) {

            DebugPrint(( TEXT("GetPrinterDriverDirectory() failed, ec=%d"), GetLastError() ));
            return FALSE;

        }

        //
        // form the file names
        //

        _tcscpy( DriverFile, DriverDirectory );
        _tcscat( DriverFile, TEXT("\\faxdrv.dll") );

        _tcscpy( DataFile, DriverDirectory );
        _tcscat( DataFile, TEXT("\\faxwiz.dll") );

        _tcscpy( ConfigFile, DriverDirectory );
        _tcscat( ConfigFile, TEXT("\\faxui.dll") );

        if ((!AddPrinterDriver( NULL, 2, (LPBYTE) &DriverInfo )) &&
            (GetLastError() != ERROR_PRINTER_DRIVER_ALREADY_INSTALLED)) {

                DebugPrint(( TEXT("AddPrinterDriver() failed, ec=%d"), GetLastError() ));
                return FALSE;

        }

    }

    return TRUE;
}


BOOL
SetDefaultPrinter(
    LPTSTR PrinterName,
    BOOL OverwriteDefaultPrinter
    )
{
    HKEY hKey;
    LPTSTR PrinterInfo;
    LPTSTR DefaultPrinter;
    BOOL Rslt;


    if (!OverwriteDefaultPrinter) {
        //
        // check to see if there is a printer
        // marked as the default ptinter
        //

        hKey = OpenRegistryKey(
            HKEY_CURRENT_USER,
            TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows"),
            FALSE,
            KEY_READ
            );
        if (hKey == NULL) {
            return FALSE;
        }

        DefaultPrinter = GetRegistryString( hKey, TEXT("Device"), EMPTY_STRING );

        RegCloseKey( hKey );

        if (DefaultPrinter && DefaultPrinter[0]) {
            MemFree( DefaultPrinter );
            return FALSE;
        }
        //
        // ok, there is not a default printer
        // and we can proceed
        //

        MemFree( DefaultPrinter );
    }

    //
    // get the printer information for the requested printer
    //

    hKey = OpenRegistryKey(
        HKEY_CURRENT_USER,
        TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Devices"),
        FALSE,
        KEY_READ
        );
    if (hKey == NULL) {
        return FALSE;
    }

    PrinterInfo = GetRegistryString( hKey, PrinterName, EMPTY_STRING );

    RegCloseKey( hKey );

    if (PrinterInfo == NULL || PrinterInfo[0] == 0) {
        MemFree( PrinterInfo );
        return FALSE;
    }

    DefaultPrinter = MemAlloc( (_tcslen(PrinterName) + _tcslen(PrinterInfo) + 16) * sizeof(TCHAR) );
    if (!DefaultPrinter) {
        MemFree( PrinterInfo );
        return FALSE;
    }

    _tcscpy( DefaultPrinter, PrinterName );
    _tcscat( DefaultPrinter, TEXT(",") );
    _tcscat( DefaultPrinter, PrinterInfo );

    MemFree( PrinterInfo );

    hKey = OpenRegistryKey(
        HKEY_CURRENT_USER,
        TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows"),
        FALSE,
        KEY_ALL_ACCESS
        );
    if (hKey == NULL) {
        MemFree( DefaultPrinter );
        return FALSE;
    }

    Rslt = SetRegistryString( hKey, TEXT("Device"), DefaultPrinter );

    RegCloseKey( hKey );

    MemFree( DefaultPrinter );

    return Rslt;
}


BOOL
CreateServerFaxPrinter(
    HWND hwnd,
    LPTSTR FaxPrinterName
    )
{
    HANDLE hPrinter;
    SYSTEM_INFO SystemInfo;
    DWORD BytesNeeded;
    DWORD PortCount;
    PORT_INFO_2 *PortInfo = NULL;
    DWORD i;
    LPTSTR PortNames = NULL;
    LPTSTR p;
    PRINTER_DEFAULTS PrinterDefaults;



    //
    // set the printer name
    //

    _tcscpy( PrinterName, FaxPrinterName );

    //
    // add the fax port monitor
    // the fax ports that the fax monitor presents
    // to the spooler are dynamic.  they are ctreated
    // at the time the monitor initializes.  the ports
    // are created based on data that the monitor
    // gets from the fax service when it calls FaxEnumPorts().
    //

    GetSystemInfo( &SystemInfo );

    if ( (SystemInfo.wProcessorArchitecture > 3) || (EnumPlatforms[SystemInfo.wProcessorArchitecture] == WRONG_PLATFORM ) ) {
       return FALSE;
    }

    _tcscpy( Environment, Platforms[ EnumPlatforms[SystemInfo.wProcessorArchitecture] ].PrintPlatform );

    _tcscpy( MonitorFile, TEXT("faxmon.dll") );

    if ((!AddMonitor( NULL, 2, (LPBYTE) &MonitorInfo )) &&
        (GetLastError() != ERROR_PRINT_MONITOR_ALREADY_INSTALLED)) {

            DebugPrint(( TEXT("AddMonitor() failed, ec=%d"), GetLastError() ));
            return FALSE;

    }

    //
    // enumerate the ports so we can isolate the fax ports
    //

    if ((!EnumPorts( NULL, 2, NULL, 0, &BytesNeeded, &PortCount )) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        PortInfo = (PORT_INFO_2 *) MemAlloc( BytesNeeded );
        if (PortInfo) {
            if (EnumPorts( NULL, 2, (LPBYTE)PortInfo, BytesNeeded, &BytesNeeded, &PortCount )) {
                for (BytesNeeded=0,i=0; i<PortCount; i++) {
                    if (PortInfo[i].pMonitorName && (_tcscmp( PortInfo[i].pMonitorName, FAX_MONITOR_NAME ) == 0)) {
                        BytesNeeded += _tcslen( PortInfo[i].pPortName ) + 4;
                    }
                }
                if (!BytesNeeded) {

                    //
                    // there are no fax ports available
                    //
                    DebugPrint(( TEXT("There are no FAX ports available") ));
                    return FALSE;

                }
                PortNames = (LPTSTR) MemAlloc( (BytesNeeded + 16) * sizeof(TCHAR) );
                if (PortNames) {
                    p = PortNames;
                    for (p=PortNames,i=0; i<PortCount; i++) {
                        if (PortInfo[i].pMonitorName && (_tcscmp( PortInfo[i].pMonitorName, FAX_MONITOR_NAME ) == 0)) {
                            _tcscpy( p, PortInfo[i].pPortName );
                            _tcscat( p, TEXT(",") );
                            p += _tcslen( p );
                        }
                    }
                    *(p-1) = 0;
                    PrinterInfo.pPortName = PortNames;
                }
            }
        }
    }

    if (!PrinterInfo.pPortName) {

        //
        // there are no fax ports available
        //
        DebugPrint(( TEXT("There are no FAX ports available") ));
        return FALSE;

    }

    if (!AddPrinterDrivers()) {
        return FALSE;
    }

    //
    // add the printer, open it if it already exists
    //

    hPrinter = AddPrinter( NULL, 2, (LPBYTE) &PrinterInfo );
    if (!hPrinter) {
        if (GetLastError() == ERROR_PRINTER_ALREADY_EXISTS) {

            PrinterDefaults.pDatatype     = NULL;
            PrinterDefaults.pDevMode      = NULL;
            PrinterDefaults.DesiredAccess = PRINTER_ALL_ACCESS;

            if (!OpenPrinter( FaxPrinterName, &hPrinter, &PrinterDefaults )) {

                DebugPrint(( TEXT("OpenPrinter() failed, ec=%d"), GetLastError() ));
                return FALSE;

            }

        } else {

            DebugPrint(( TEXT("AddPrinter() failed, ec=%d"), GetLastError() ));
            return FALSE;

        }
    }

    //
    // share the printer
    //

    if (!ShareFaxPrinter( &hPrinter, FaxPrinterName )) {
        DebugPrint(( TEXT("ShareFaxPrinter() failed") ));
        if (!NtGuiMode) {
            PopUpMsg( hwnd, IDS_SHARE_FAX_PRINTER, FALSE, 0 );
        }
    }

    //
    // make the fax printer the default printer, if it is the only printer
    //

    SetDefaultPrinter( FaxPrinterName, FALSE );

    //
    // set the bit that allow status strings to display correctly
    //

    i = 1;

    i = SetPrinterData(
        hPrinter,
        SPLREG_UI_SINGLE_STATUS,
        REG_DWORD,
        (LPBYTE) &i,
        sizeof(DWORD)
        );
    if ((i != ERROR_SUCCESS) && (i != ERROR_SUCCESS_RESTART_REQUIRED)) {
        DebugPrint(( TEXT("SetPrinterData() failed, ec=%d"), i ));
        return FALSE;
    }

    //
    // release resources and leave...
    //

    MemFree( PortNames );
    MemFree( PortInfo );

    ClosePrinter( hPrinter );

    return TRUE;
}


DWORD
CreateClientFaxPrinter(
    HWND hwnd,
    LPTSTR FaxPrinterName
    )
{
    DWORD ec = ERROR_SUCCESS;
    SYSTEM_INFO SystemInfo;
    DWORD i;


    GetSystemInfo( &SystemInfo );

    if ((SystemInfo.wProcessorArchitecture > 3) || (EnumPlatforms[SystemInfo.wProcessorArchitecture] == WRONG_PLATFORM)) {
        return ERROR_INVALID_FUNCTION;
    }

    _tcscpy( Environment, Platforms[ EnumPlatforms[SystemInfo.wProcessorArchitecture] ].PrintPlatform );

    if (!GetPrinterDriverDirectory(
             NULL,
             Environment,
             1,
             (LPBYTE) DriverDirectory,
             sizeof(DriverDirectory),
             &i
             )) {

        ec = GetLastError();
        DebugPrint(( TEXT("GetPrinterDriverDirectory() failed, ec=%d"), ec ));
        return ec;
    }

    //
    // form the file names
    //

    _tcscpy( DriverFile, DriverDirectory );
    _tcscat( DriverFile, TEXT("\\faxdrv.dll") );

    _tcscpy( DataFile, DriverDirectory );
    _tcscat( DataFile, TEXT("\\faxwiz.dll") );

    _tcscpy( ConfigFile, DriverDirectory );
    _tcscat( ConfigFile, TEXT("\\faxui.dll") );

    if ((!AddPrinterDriver( NULL, 2, (LPBYTE) &DriverInfo )) &&
        (GetLastError() != ERROR_PRINTER_DRIVER_ALREADY_INSTALLED)) {

            ec = GetLastError();
            DebugPrint(( TEXT("AddPrinterDriver() failed, ec=%d"), GetLastError() ));
            return ec;
    }

    //
    // add the printer
    //

add_printer_connection:
    if (!AddPrinterConnection( FaxPrinterName )) {
        i = GetLastError();
        if (i == ERROR_INVALID_PRINTER_NAME) {
            int DlgErr = DialogBoxParam(
                FaxWizModuleHandle,
                MAKEINTRESOURCE(IDD_PRINTER_NAME),
                hwnd,
                PrinterNameDlgProc,
                (LPARAM) FaxPrinterName
                );

            if (DlgErr == -1 || DlgErr == 0) {
                DebugPrint(( TEXT("PrinterNameDlgProc() failed or was cancelled") ));
                return ERROR_INVALID_FUNCTION;
            }

            if (!AddPrinterConnection( FaxPrinterName )) {
                DebugPrint(( TEXT("AddPrinterConnection() failed, ec=%d"), i ));
                goto add_printer_connection;
            }

        } else {
            DebugPrint(( TEXT("AddPrinterConnection() failed, ec=%d"), i ));
            return i;
        }
    }

    //
    // make the fax printer the default printer, if it is the only printer
    //

    SetDefaultPrinter( FaxPrinterName, FALSE);

    return ERROR_SUCCESS;
}


BOOL
IsPrinterFaxPrinter(
    LPTSTR PrinterName
    )
{
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults;
    SYSTEM_INFO SystemInfo;
    DWORD Size;
    DWORD Rval = FALSE;
    LPDRIVER_INFO_2 DriverInfo = NULL;


    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_READ;

    if (!OpenPrinter( PrinterName, &hPrinter, &PrinterDefaults )) {

        DebugPrint(( TEXT("OpenPrinter() failed, ec=%d"), GetLastError() ));
        return FALSE;

    }

    GetSystemInfo( &SystemInfo );

    Size = 4096;

    DriverInfo = (LPDRIVER_INFO_2) MemAlloc( Size );
    if (!DriverInfo) {
        DebugPrint(( TEXT("Memory allocation failed, size=%d"), Size ));
        goto exit;
    }

    if ( (SystemInfo.wProcessorArchitecture > 3) || (EnumPlatforms[SystemInfo.wProcessorArchitecture] == WRONG_PLATFORM ) ) {
       return FALSE;
    }


    Rval = GetPrinterDriver(
        hPrinter,
        Platforms[ EnumPlatforms[SystemInfo.wProcessorArchitecture] ].PrintPlatform,
        2,
        (LPBYTE) DriverInfo,
        Size,
        &Size
        );
    if (!Rval) {
        DebugPrint(( TEXT("GetPrinterDriver() failed, ec=%d"), GetLastError() ));
        goto exit;
    }

    if (_tcscmp( DriverInfo->pName, FAX_DRIVER_NAME ) == 0) {
        Rval = TRUE;
    } else {
        Rval = FALSE;
    }

exit:

    MemFree( DriverInfo );
    ClosePrinter( hPrinter );
    return Rval;
}


LPTSTR
MakePrinterShareName(
    LPTSTR  pServerName,
    LPTSTR  pPrinterName
    )

/*++

Routine Description:

    Given a server name and a printer name, generate a unique share name.

Arguments:

    pServerName - Specifies the server name, NULL for local host
    pPrinterName - Specifies the printer name

Return Value:

    Pointer to the generated share name, NULL if there is an error

--*/

{
    static TCHAR    illegalDosChars[] = TEXT( " *?/\\|,;:+=<>[]\"" );
    TCHAR           shareName[16];
    INT             cch, shareSuffix;
    DWORD           dwFlags, cPrinters, index;
    LPTSTR          pDest, pShareName;
    PPRINTER_INFO_2 pPrinterInfo2;


    //
    // Copy up to the first 8 characters of the printer name
    //

    ZeroMemory( shareName, sizeof(shareName) );
    pDest = shareName;
    cch = 0;

    while (cch < 8 && *pPrinterName) {

        //
        // Skip invalid DOS filename characters
        //

        if (!_tcschr( illegalDosChars, *pPrinterName )) {

            *pDest++ = *pPrinterName;
            cch++;
        }

        pPrinterName++;
    }

    //
    // If the share name is empty, start with a default.
    // This should very rarely happen.
    //

    if (cch == 0) {
        _tcscpy( shareName, GetString( IDS_DEFAULT_SHARE ) );
        pDest += _tcslen(pDest);
    }

    //
    // Get the list of shared printers on the server.
    // Be aware that share names returned by EnumPrinters
    // may be in the form of \\servername\sharename.
    //

    dwFlags = PRINTER_ENUM_SHARED | (pServerName ? PRINTER_ENUM_NAME : PRINTER_ENUM_LOCAL);

    if (! (pPrinterInfo2 = MyEnumPrinters( pServerName, 2, &cPrinters, dwFlags ))) {
        cPrinters = 0;
    }

    for (index = 0; index < cPrinters; index++) {

        if (pPrinterInfo2[index].pShareName &&
            (pShareName = _tcsrchr(pPrinterInfo2[index].pShareName, TEXT('\\')))) {

            pPrinterInfo2[index].pShareName = pShareName + 1;

        }
    }

    //
    // Make sure the share name is unique. If not, add a numeric suffix to it.
    //

    for (shareSuffix = 0; shareSuffix < 1000; shareSuffix++) {

        if (shareSuffix > 0) {

            *pDest = TEXT('.');
            wsprintf( pDest + 1, TEXT("%d"), shareSuffix );
        }

        //
        // Check if the proposed share name matches any of the existing share names.
        //

        for (index = 0; index < cPrinters; index++) {

            if (pPrinterInfo2[index].pShareName &&
                _tcsicmp(pPrinterInfo2[index].pShareName, shareName) == 0) {
                break;
            }
        }

        //
        // Stop searching when we find a unique share name.
        //

        if (index >= cPrinters) {
            break;
        }
    }

    MemFree( pPrinterInfo2 );

    return (shareSuffix < 1000) ? StringDup( shareName ) : NULL;
}


BOOL
ShareFaxPrinter(
    LPHANDLE hPrinter,
    LPTSTR FaxPrinterName
    )
{
    DWORD i;
    DWORD Size;
    TCHAR String[4];
    HANDLE hPrinterServer;
    LPPRINTER_INFO_2 PrinterInfo = NULL;
    PRINTER_DEFAULTS PrinterDefaults;
    BOOL Rval = FALSE;
    LPTSTR ShareName;



    ShareName = MakePrinterShareName( NULL, FaxPrinterName );
    if (!ShareName) {
        return FALSE;
    }

    if ((!GetPrinter( *hPrinter, 2, NULL, 0, &i )) && (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {
        DebugPrint(( TEXT("GetPrinter() failed, ec=%d"), GetLastError() ));
        goto exit;
    }

    PrinterInfo = (LPPRINTER_INFO_2) MemAlloc( i );
    if (!PrinterInfo) {
        DebugPrint(( TEXT("MemAlloc() failed, size=%d"), i ));
        goto exit;
    }

    if (!GetPrinter( *hPrinter, 2, (LPBYTE) PrinterInfo, i, &i )) {
        DebugPrint(( TEXT("GetPrinter() failed, ec=%d"), GetLastError() ));
        goto exit;
    }

    PrinterInfo->pShareName  = ShareName;
    PrinterInfo->Attributes |= PRINTER_ATTRIBUTE_SHARED;
    PrinterInfo->pComment    = GetString( IDS_FAX_SHARE_COMMENT );

    if (!SetPrinter( *hPrinter, 2, (LPBYTE) PrinterInfo, 0 )) {
        DebugPrint(( TEXT("SetPrinter() failed, ec=%d"), GetLastError() ));
        goto exit;
    }

    //
    // allow the printer to have remote connections
    //

    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = SERVER_ACCESS_ADMINISTER;

    if (!OpenPrinter( NULL, &hPrinterServer, &PrinterDefaults )) {
        DebugPrint(( TEXT("OpenPrinter() failed, ec=%d"), GetLastError() ));
        goto exit;
    }

    //
    // remove the fax driver from the list of driver names
    //

    String[0] = 0;
    Size = sizeof(TCHAR);

    i = SetPrinterData(
        hPrinterServer,
        SPLREG_NO_REMOTE_PRINTER_DRIVERS,
        REG_SZ,
        (LPBYTE) String,
        Size
        );
    if ((i != ERROR_SUCCESS) && (i != ERROR_SUCCESS_RESTART_REQUIRED)) {
        DebugPrint(( TEXT("SetPrinterData() failed, ec=%d"), i ));
        goto exit;
    }

    //
    // we have to restart the spooler for the
    // SetPrinterData() to take affect
    //

    ClosePrinter( *hPrinter );

    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_ALL_ACCESS;

    if (!OpenPrinter( FaxPrinterName, hPrinter, &PrinterDefaults )) {
        DebugPrint(( TEXT("OpenPrinter() failed, ec=%d"), GetLastError() ));
        goto exit;
    }

    Rval = TRUE;

exit:
    MemFree( PrinterInfo );
    MemFree( ShareName );

    ClosePrinter( hPrinterServer );

    return Rval;
}


BOOL
DeleteFaxPrinters(
    HWND hwnd
    )
{
    PPRINTER_INFO_2 PrinterInfo;
    PMONITOR_INFO_2 MonitorInfo;
    DWORD Count;
    HANDLE hPrinter;
    PRINTER_DEFAULTS PrinterDefaults;
    DWORD i,j;
    LPTSTR FileName = NULL;
    PDRIVER_INFO_2 DriverInfo;
    PDRIVER_INFO_2 DriverInfoDel;
    TCHAR Buffer[MAX_PATH];


    PrinterInfo = MyEnumPrinters( NULL, 2, &Count, 0 );
    if (!PrinterInfo) {
        return FALSE;
    }

    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_ALL_ACCESS;

    for (i=0; i<Count; i++) {

        //
        // is this a fax printer??
        //

        if (_tcsicmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0) {

            if (PrinterInfo[i].Attributes & PRINTER_ATTRIBUTE_LOCAL) {

                if (!OpenPrinter( PrinterInfo[i].pPrinterName, &hPrinter, &PrinterDefaults )) {
                    DebugPrint(( TEXT("OpenPrinter() failed, ec=%d"), GetLastError() ));
                    continue;
                }
                {
                    BOOL DidWeDelete ;
                    BOOL DidWeClose ;
                    DWORD LastError ;
                    DidWeDelete = DeletePrinter( hPrinter ); // Returns 1 even when print jobs are in queue.
                    if( !DidWeDelete ){
                        LastError = GetLastError() ;
                    }
                    DidWeClose = ClosePrinter( hPrinter );
                    if( !DidWeClose ){
                        LastError = GetLastError();
                    }
                }

            } else {

                DeletePrinterConnection( PrinterInfo[i].pPrinterName );

            }

        }

    }
    MemFree( PrinterInfo );

    //
    // See if any FAX printers are still pending deletion.
    //

    PrinterInfo = MyEnumPrinters( NULL, 2, &Count, 0 );
    if (PrinterInfo) {

        for (i=0; i<Count; i++) {

        //
        // Is this a fax printer?  If so, warn the user that it wasn't deleted
        //

            if (_tcsicmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0) {
                if( PrinterInfo[i].Status == PRINTER_STATUS_PENDING_DELETION ){
                    PopUpMsgFmt(
                        hwnd,
                        IDS_FAX_PRINTER_PENDING_DELETION,
                        FALSE,
                        0,
                        PrinterInfo[i].pPrinterName
                        );
                }
                else {
                    PopUpMsgFmt(
                        hwnd,
                        IDS_COULD_NOT_DELETE_FAX_PRINTER,
                        FALSE,
                        0,
                        PrinterInfo[i].pPrinterName
                        );
                }
            }

        }
    }


    MemFree( PrinterInfo );

    MonitorInfo = MyEnumMonitors( &Count );
    if (MonitorInfo) {
        for (i=0; i<Count; i++) {
            if (_tcscmp( MonitorInfo[i].pName, FAX_MONITOR_NAME ) == 0) {
                FileName = MonitorInfo[i].pDLLName;
                break;
            }
        }
    }

    if (!DeleteMonitor( NULL, NULL, FAX_MONITOR_NAME )) {
        DebugPrint(( TEXT("DeleteMonitor() failed, ec=%d"), GetLastError() ));
    }

    if (FileName) {
        ExpandEnvironmentStrings( TEXT("%systemroot%\\system32\\"), Buffer, sizeof(Buffer)/sizeof(TCHAR) );
        _tcscat( Buffer, FileName );
        MyDeleteFile( Buffer );
    }

    if (MonitorInfo) {
        MemFree( MonitorInfo );
    }

    for (i=0; i<MAX_PLATFORMS; i++) {

        DriverInfo = MyEnumDrivers( Platforms[i].PrintPlatform, &Count );
        DriverInfoDel = NULL;
        if (DriverInfo) {
            for (j=0; j<Count; j++) {
                if (_tcscmp( DriverInfo[j].pName, FAX_DRIVER_NAME ) == 0) {
                    DriverInfoDel = &DriverInfo[j];
                    break;
                }
            }
        }

        if (!DeletePrinterDriver( NULL, Platforms[i].PrintPlatform, FAX_DRIVER_NAME )) {
            DebugPrint(( TEXT("DeletePrinterDriver() failed, ec=%d"), GetLastError() ));
        }

        if (DriverInfoDel) {
            MyDeleteFile( DriverInfoDel->pDriverPath );
            MyDeleteFile( DriverInfoDel->pDataFile );
            MyDeleteFile( DriverInfoDel->pConfigFile );
        }

        if (DriverInfo) {
            MemFree( DriverInfo );
        }
    }

    return TRUE;
}


PVOID
MyEnumPrinters(
    LPTSTR  pServerName,
    DWORD   level,
    PDWORD  pcPrinters,
    DWORD   Flags
    )
{
    PBYTE   pPrinterInfo = NULL;
    DWORD   cb;

    if (!Flags) {
        Flags = PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS;
    }

    if (!EnumPrinters(Flags, pServerName, level, NULL, 0, &cb, pcPrinters) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pPrinterInfo = MemAlloc(cb)) &&
        EnumPrinters(Flags, pServerName, level, pPrinterInfo, cb, &cb, pcPrinters))
    {
        return pPrinterInfo;
    }

    MemFree(pPrinterInfo);
    return NULL;
}


PVOID
MyEnumDrivers(
    LPTSTR pEnvironment,
    PDWORD pcDrivers
    )
{
    PBYTE   pDriverInfo = NULL;
    DWORD   cb;


    if (!EnumPrinterDrivers(NULL, pEnvironment, 2, 0, 0, &cb, pcDrivers ) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pDriverInfo = MemAlloc(cb)) &&
        EnumPrinterDrivers(NULL, pEnvironment, 2, pDriverInfo, cb, &cb, pcDrivers ))
    {
        return pDriverInfo;
    }

    MemFree(pDriverInfo);
    return NULL;
}


PVOID
MyEnumMonitors(
    PDWORD  pcMonitors
    )
{
    PBYTE   pMonitorInfo = NULL;
    DWORD   cb;


    if (!EnumMonitors(NULL, 2, 0, 0, &cb, pcMonitors ) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pMonitorInfo = MemAlloc(cb)) &&
        EnumMonitors(NULL, 2, pMonitorInfo, cb, &cb, pcMonitors ))
    {
        return pMonitorInfo;
    }

    MemFree(pMonitorInfo);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\groups.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    groups.c

Abstract:

    This file implements the file copy code.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop


GROUP_ITEMS RemoteAdminGroupItems[] =
{
    { TEXT("Fax"),
      TEXT("Remote Administration"),
      TEXT("%systemroot%\\system32\\faxcfg.exe"),
      TEXT("%systemroot%\\system32\\faxcfg.exe"),
      TEXT("%systemroot%\\system32"),
      USE_COMMON_GROUP,
      0,
      SW_NORMAL,
      0
    }
};

#define MAX_REMOTE_ADMIN_GROUP_ITEMS  (sizeof(RemoteAdminGroupItems)/sizeof(RemoteAdminGroupItems[0]))


GROUP_ITEMS GroupItems[] =
{
    { TEXT("Fax"),
      TEXT("Fax Queue Management"),
      TEXT("%systemroot%\\system32\\faxqueue.exe"),
      TEXT("%systemroot%\\system32\\faxqueue.exe"),
      TEXT("%systemroot%\\system32"),
      USE_COMMON_GROUP | USE_SERVER_NAME,
      0,
      SW_NORMAL,
      0
    },

    { TEXT("Fax"),
      TEXT("Cover Page Editor"),
      TEXT("%systemroot%\\system32\\faxcover.exe"),
      TEXT("%systemroot%\\system32\\faxcover.exe"),
      TEXT("%systemroot%\\system32"),
      USE_COMMON_GROUP,
      0,
      SW_NORMAL,
      0
    },

    { TEXT("Fax"),
      TEXT("Fax Send Utility"),
      TEXT("%systemroot%\\system32\\faxsend.exe"),
      TEXT("%systemroot%\\system32\\faxsend.exe"),
      TEXT("%systemroot%\\system32"),
      USE_COMMON_GROUP,
      0,
      SW_NORMAL,
      0
    },

    { TEXT("Fax"),
      TEXT("Fax Configuration"),
      TEXT("%systemroot%\\system32\\faxcfgst.exe"),
      TEXT("%systemroot%\\system32\\faxcfgst.exe"),
      TEXT("%systemroot%\\system32"),
      USE_COMMON_GROUP,
      0,
      SW_NORMAL,
      0
    },

    { TEXT("Fax"),
      TEXT("Fax Document Viewer"),
      TEXT("kodakimg.exe"),
      NULL,
      NULL,
      USE_COMMON_GROUP | USE_APP_PATH,
      0,
      SW_NORMAL,
      0
    },

    { TEXT("Fax"),
      TEXT("Help"),
      TEXT("%systemroot%\\system32\\winhlp32.exe %systemroot%\\help\\fax.hlp"),
      TEXT("%systemroot%\\system32\\winhlp32.exe"),
      TEXT("%systemroot%\\system32"),
      USE_COMMON_GROUP,
      0,
      SW_NORMAL,
      0
    }
};

#define MAX_GROUP_ITEMS  (sizeof(GroupItems)/sizeof(GroupItems[0]))

GROUP_ITEMS UserGroupItems[] =
{

    { TEXT("Startup"),
      TEXT("Fax Monitor"),
      TEXT("%systemroot%\\system32\\faxstat.exe"),
      TEXT("%systemroot%\\system32\\faxstat.exe"),
      TEXT("%systemroot%\\system32"),
      USE_USER_GROUP,
      0,
      SW_MINIMIZE,
      0
    }
};

#define MAX_USER_GROUP_ITEMS  (sizeof(UserGroupItems)/sizeof(UserGroupItems[0]))



VOID
CreateGroupItems(
    BOOL RemoteAdmin,
    LPTSTR ServerName
    )
{
    DWORD i;
    TCHAR Buffer[MAX_PATH*2];
    TCHAR CommandLine[MAX_PATH*2];
    TCHAR IconPath[MAX_PATH*2];
    TCHAR WorkingDirectory[MAX_PATH*2];
    PGROUP_ITEMS Groups;
    DWORD GroupCount;
    HKEY hKey;
    LPTSTR p;
    DWORD Size;



    if (InstallMode & INSTALL_UPGRADE) {
        DeleteGroupItems();
    }

    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_WINDOWS_CURRVER, FALSE, KEY_READ );
    if (hKey) {
        LPTSTR ProgFilesDir = GetRegistryString( hKey, REGVAL_PROGRAM_FILES_DIR, EMPTY_STRING );
        if (ProgFilesDir) {
            SetEnvironmentVariable( TEXT("%programfilesdir%"), ProgFilesDir );
            MemFree( ProgFilesDir );
        }
        RegCloseKey( hKey );
    }

    if (RemoteAdmin) {
        Groups = RemoteAdminGroupItems;
        GroupCount = MAX_REMOTE_ADMIN_GROUP_ITEMS;
    } else {
        Groups = GroupItems;
        GroupCount = MAX_GROUP_ITEMS;
    }

    for (i=0; i<GroupCount; i++) {

        CreateGroup( Groups[i].GroupName, Groups[i].Flags & USE_COMMON_GROUP );

        if (Groups[i].Flags & USE_APP_PATH) {
            hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_APP_PATHS, FALSE, KEY_READ );
            if (hKey) {
                Size = sizeof(Buffer) - sizeof(TCHAR);
                Buffer[0] = TEXT('\"');
                Size = RegQueryValue( hKey, Groups[i].CommandLine, &Buffer[1], &Size );
                if (Size == ERROR_SUCCESS || Size == ERROR_INVALID_DATA) {
                    _tcscat( Buffer, TEXT("\"") );
                    ExpandEnvironmentStrings( Buffer, CommandLine, sizeof(CommandLine)/sizeof(TCHAR) );
                    ExpandEnvironmentStrings( &Buffer[1], IconPath, sizeof(IconPath)/sizeof(TCHAR) );
                    IconPath[wcslen(IconPath)-1] = 0;
                    ExpandEnvironmentStrings( &Buffer[1], WorkingDirectory, sizeof(WorkingDirectory)/sizeof(TCHAR) );
                    p = _tcsrchr( WorkingDirectory, TEXT('\\') );
                    if (p) {
                        *p = 0;
                    } else {
                        continue;
                    }
                }
                RegCloseKey( hKey );
            } else {
                continue;
            }
        } else {
            ExpandEnvironmentStrings( Groups[i].CommandLine, CommandLine, sizeof(CommandLine)/sizeof(TCHAR) );
            ExpandEnvironmentStrings( Groups[i].IconPath, IconPath, sizeof(IconPath)/sizeof(TCHAR) );
            ExpandEnvironmentStrings( Groups[i].WorkingDirectory, WorkingDirectory, sizeof(WorkingDirectory)/sizeof(TCHAR) );
        }

        if ((Groups[i].Flags & USE_SERVER_NAME) && ServerName) {
            _tcscat( CommandLine, TEXT(" ") );
            _tcscat( CommandLine, ServerName );
        }

        AddItem(
            Groups[i].GroupName,
            Groups[i].Flags & USE_COMMON_GROUP,
            Groups[i].Description,
            CommandLine,
            IconPath,
            Groups[i].IconIndex,
            WorkingDirectory,
            Groups[i].HotKey,
            Groups[i].ShowCmd
            );

    }

    if (RequestedSetupType & FAX_INSTALL_WORKSTATION) {
        Groups = UserGroupItems;
        GroupCount = MAX_USER_GROUP_ITEMS;

        for (i=0; i<GroupCount; i++) {

            ExpandEnvironmentStrings( Groups[i].CommandLine, CommandLine, sizeof(CommandLine) );
            ExpandEnvironmentStrings( Groups[i].IconPath, IconPath, sizeof(IconPath) );
            ExpandEnvironmentStrings( Groups[i].WorkingDirectory, WorkingDirectory, sizeof(WorkingDirectory) );

            AddItem(
                Groups[i].GroupName,
                Groups[i].Flags & USE_COMMON_GROUP,
                Groups[i].Description,
                CommandLine,
                IconPath,
                Groups[i].IconIndex,
                WorkingDirectory,
                Groups[i].HotKey,
                Groups[i].ShowCmd
                );

        }

    }
}


VOID
DeleteGroupItems(
    VOID
    )
{
    DWORD i;

    for (i=0; i<MAX_GROUP_ITEMS; i++) {

        DeleteItem(
            GroupItems[i].GroupName,
            GroupItems[i].Flags & USE_COMMON_GROUP,
            GroupItems[i].Description,
            FALSE
            );

    }

    for (i=0; i<MAX_REMOTE_ADMIN_GROUP_ITEMS; i++) {

        DeleteItem(
            RemoteAdminGroupItems[i].GroupName,
            RemoteAdminGroupItems[i].Flags & USE_COMMON_GROUP,
            RemoteAdminGroupItems[i].Description,
            FALSE
            );

    }

    for (i=0; i<MAX_USER_GROUP_ITEMS; i++) {

        DeleteItem(
            UserGroupItems[i].GroupName,
            UserGroupItems[i].Flags & USE_COMMON_GROUP,
            UserGroupItems[i].Description,
            FALSE
            );

    }

    DeleteGroup( GroupItems[0].GroupName, GroupItems[0].Flags & USE_COMMON_GROUP );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\mapi.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mapi.c

Abstract:

    This file implements wrappers for all mapi apis.
    The wrappers are necessary because mapi does not
    implement unicode and this code must be non-unicode.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 7-Aug-1996

--*/

#undef UNICODE
#undef _UNICODE

#include <windows.h>
#include <mapiwin.h>
#include <mapix.h>
#include <stdio.h>

#define INTERNAL 1
#include "common.h"

#define MAPISVC_INF                 "%windir%\\system32\\mapisvc.inf"
#define PAB_FILE_NAME               "%windir%\\msfax.pab"
#define PST_FILE_NAME               "%windir%\\msfax.pst"

#define FAXAB_SERVICE_NAME          "MSFAX AB"
#define FAXXP_SERVICE_NAME          "MSFAX XP"
#define MSAB_SERVICE_NAME           "MSPST AB"
#define MSPST_SERVICE_NAME          "MSPST MS"
#define CONTAB_SERVICE_NAME         "CONTAB"
#define MSAB_SERVICE_NAME_W        L"MSPST AB"
#define MSPST_SERVICE_NAME_W       L"MSPST MS"
#define FAXAB_SERVICE_NAME_W       L"MSFAX AB"
#define CONTAB_SERVICE_NAME_W      L"CONTAB"


//
// pab property tags
//

#define PR_PAB_PATH                             PROP_TAG( PT_TSTRING, 0x6600 )
#define PR_PAB_PATH_W                           PROP_TAG( PT_UNICODE, 0x6600 )
#define PR_PAB_PATH_A                           PROP_TAG( PT_STRING8, 0x6600 )
#define PR_PAB_DET_DIR_VIEW_BY                  PROP_TAG( PT_LONG,    0x6601 )

#define PAB_DIR_VIEW_FIRST_THEN_LAST            0
#define PAB_DIR_VIEW_LAST_THEN_FIRST            1

//
// pst property tags
//

#define PR_PST_PATH                             PROP_TAG( PT_STRING8, 0x6700 )
#define PR_PST_REMEMBER_PW                      PROP_TAG( PT_BOOLEAN, 0x6701 )
#define PR_PST_ENCRYPTION                       PROP_TAG( PT_LONG,    0x6702 )
#define PR_PST_PW_SZ_OLD                        PROP_TAG( PT_STRING8, 0x6703 )
#define PR_PST_PW_SZ_NEW                        PROP_TAG( PT_STRING8, 0x6704 )

#define PSTF_NO_ENCRYPTION                      ((DWORD)0x80000000)
#define PSTF_COMPRESSABLE_ENCRYPTION            ((DWORD)0x40000000)
#define PSTF_BEST_ENCRYPTION                    ((DWORD)0x20000000)


//
// externs & globals
//

extern BOOL MapiAvail;

static HMODULE MapiMod = NULL;
static LPMAPIADMINPROFILES MapiAdminProfiles = NULL;
static LPMAPIINITIALIZE MapiInitialize = NULL;
static LPMAPILOGONEX MapiLogonEx;
static LPMAPIUNINITIALIZE MapiUnInitialize = NULL;
static LPMAPIFREEBUFFER pMAPIFreeBuffer = NULL;
static LPPROFADMIN lpProfAdmin;

static CHAR MapiSvcInf[MAX_PATH*2];
static BOOL MapiStartedByLogon;


static
LPWSTR
AnsiStringToUnicodeString(
    LPSTR AnsiString,
    LPWSTR UnicodeString
    )
{
    DWORD Count;


    //
    // first see how big the buffer needs to be
    //
    Count = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        AnsiString,
        -1,
        NULL,
        0
        );

    //
    // i guess the input string is empty
    //
    if (!Count) {
        return NULL;
    }

    //
    // convert the string
    //
    Count = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        AnsiString,
        -1,
        UnicodeString,
        Count
        );

    //
    // the conversion failed
    //
    if (!Count) {
        return NULL;
    }

    return UnicodeString;
}


static
LPSTR
UnicodeStringToAnsiString(
    LPWSTR UnicodeString,
    LPSTR AnsiString
    )
{
    DWORD Count;


    //
    // first see how big the buffer needs to be
    //
    Count = WideCharToMultiByte(
        CP_ACP,
        0,
        UnicodeString,
        -1,
        NULL,
        0,
        NULL,
        NULL
        );

    //
    // i guess the input string is empty
    //
    if (!Count) {
        return NULL;
    }

    //
    // convert the string
    //
    Count = WideCharToMultiByte(
        CP_ACP,
        0,
        UnicodeString,
        -1,
        AnsiString,
        Count,
        NULL,
        NULL
        );

    //
    // the conversion failed
    //
    if (!Count) {
        return NULL;
    }

    return AnsiString;
}


VOID
MyWriteProfileString(
    LPTSTR SectionName,
    LPTSTR KeyName,
    LPTSTR Value
    )
{
    WritePrivateProfileString(
        SectionName,
        KeyName,
        Value,
        MapiSvcInf
        );
}


VOID
AddFaxAbToMapiSvcInf(
    VOID
    )
{
    MyWriteProfileString( "Default Services", "MSFAX AB",                 "Fax Address Book" );
    MyWriteProfileString( "Services",         "MSFAX AB",                 "Fax Address Book" );

    MyWriteProfileString( "MSFAX AB",         "PR_DISPLAY_NAME",          "Fax Address Book" );
    MyWriteProfileString( "MSFAX AB",         "Providers",                "MSFAX ABP"        );
    MyWriteProfileString( "MSFAX AB",         "PR_SERVICE_DLL_NAME",      "FAXAB.DLL"        );
    MyWriteProfileString( "MSFAX AB",         "PR_SERVICE_SUPPORT_FILES", "FAXAB.DLL"        );
    MyWriteProfileString( "MSFAX AB",         "PR_SERVICE_ENTRY_NAME",    "FABServiceEntry"  );
    MyWriteProfileString( "MSFAX AB",         "PR_RESOURCE_FLAGS",        "SERVICE_SINGLE_COPY|SERVICE_NO_PRIMARY_IDENTITY" );

    MyWriteProfileString( "MSFAX ABP",        "PR_PROVIDER_DLL_NAME",     "FAXAB.DLL"        );
    MyWriteProfileString( "MSFAX ABP",        "PR_RESOURCE_TYPE",         "MAPI_AB_PROVIDER" );
    MyWriteProfileString( "MSFAX ABP",        "PR_DISPLAY_NAME",          "Fax Address Book" );
    MyWriteProfileString( "MSFAX ABP",        "PR_PROVIDER_DISPLAY",      "Fax Address Book" );
}


VOID
AddFaxXpToMapiSvcInf(
    VOID
    )
{
    MyWriteProfileString( "Default Services", "MSFAX XP",                 "Fax Mail Transport"          );
    MyWriteProfileString( "Services",         "MSFAX XP",                 "Fax Mail Transport"          );

    MyWriteProfileString( "MSFAX XP",         "PR_DISPLAY_NAME",          "Fax Mail Transport"          );
    MyWriteProfileString( "MSFAX XP",         "Providers",                "MSFAX XPP"                   );
    MyWriteProfileString( "MSFAX XP",         "PR_SERVICE_DLL_NAME",      "FAXXP.DLL"                   );
    MyWriteProfileString( "MSFAX XP",         "PR_SERVICE_SUPPORT_FILES", "FAXXP.DLL"                   );
    MyWriteProfileString( "MSFAX XP",         "PR_SERVICE_ENTRY_NAME",    "ServiceEntry"                );
    MyWriteProfileString( "MSFAX XP",         "PR_RESOURCE_FLAGS",        "SERVICE_SINGLE_COPY|SERVICE_NO_PRIMARY_IDENTITY" );

    MyWriteProfileString( "MSFAX XPP",        "PR_PROVIDER_DLL_NAME",     "FAXXP.DLL"                   );
    MyWriteProfileString( "MSFAX XPP",        "PR_RESOURCE_TYPE",         "MAPI_TRANSPORT_PROVIDER"     );
    MyWriteProfileString( "MSFAX XPP",        "PR_RESOURCE_FLAGS",        "STATUS_NO_DEFAULT_STORE"     );
    MyWriteProfileString( "MSFAX XPP",        "PR_DISPLAY_NAME",          "Fax Mail Transport"          );
    MyWriteProfileString( "MSFAX XPP",        "PR_PROVIDER_DISPLAY",      "Fax Mail Transport"          );
}


VOID
FreeSRowSet(
    LPSRowSet prws
    )
{
    ULONG irw;

    if (!prws) {
        return;
    }

    for(irw = 0; irw < prws->cRows; irw++) {
        pMAPIFreeBuffer( prws->aRow[irw].lpProps );
    }

    pMAPIFreeBuffer( prws );
}


ULONG
MLCRelease(
    LPUNKNOWN punk
    )
{
    return (punk) ? punk->lpVtbl->Release(punk) : 0;
}


BOOL
ValidateProp(
    LPSPropValue pval,
    ULONG ulPropTag
    )
{
    if (pval->ulPropTag != ulPropTag) {
        pval->ulPropTag = ulPropTag;
        pval->Value.lpszA = "???";
        return TRUE;
    }

    return FALSE;
}


BOOL
IsMapiServiceInstalled(
    LPWSTR ProfileNameW,
    LPWSTR ServiceNameW
    )
{
    SPropTagArray taga = {2,{PR_DISPLAY_NAME,PR_SERVICE_NAME}};
    BOOL rVal = FALSE;
    LPSERVICEADMIN lpSvcAdmin;
    LPMAPITABLE pmt = NULL;
    LPSRowSet prws = NULL;
    DWORD i;
    LPSPropValue pval;
    CHAR ProfileName[128];
    CHAR ServiceName[64];


    if (!MapiAvail) {
        goto exit;
    }

    UnicodeStringToAnsiString( ProfileNameW, ProfileName );
    UnicodeStringToAnsiString( ServiceNameW, ServiceName );

    if (lpProfAdmin->lpVtbl->AdminServices( lpProfAdmin, ProfileName, NULL, 0, 0, &lpSvcAdmin )) {
        goto exit;
    }

    if (lpSvcAdmin->lpVtbl->GetMsgServiceTable( lpSvcAdmin, 0, &pmt )) {
        goto exit;
    }

    if (pmt->lpVtbl->SetColumns( pmt, &taga, 0 )) {
        goto exit;
    }

    if (pmt->lpVtbl->QueryRows( pmt, 4000, 0, &prws )) {
        goto exit;
    }

    for (i=0; i<prws->cRows; i++) {
        pval = prws->aRow[i].lpProps;
        ValidateProp( &pval[0], PR_DISPLAY_NAME );
        ValidateProp( &pval[1], PR_SERVICE_NAME );
        if (_stricmp( pval[1].Value.lpszA, ServiceName ) == 0) {
            rVal = TRUE;
            break;
        }
    }

exit:
    FreeSRowSet( prws );
    MLCRelease( (LPUNKNOWN)pmt );
    return rVal;
}


BOOL
InstallFaxAddressBook(
    HWND hwnd,
    LPWSTR ProfileNameW
    )
{
    SPropTagArray taga = {2,{PR_SERVICE_NAME,PR_SERVICE_UID}};
    SPropValue spvProps[2] = { 0 };
    BOOL rVal = FALSE;
    LPSERVICEADMIN lpSvcAdmin;
    CHAR ProfileName[128];
    CHAR Buffer[128];
    HRESULT hResult;
    LPMAPITABLE pmt = NULL;
    LPSRowSet prws = NULL;
    DWORD i;
    LPSPropValue pval;
    BOOL ConfigurePst = FALSE;
    BOOL ConfigurePab = FALSE;
    LPMAPISESSION Session = NULL;


    if (!MapiAvail) {
        goto exit;
    }

    UnicodeStringToAnsiString( ProfileNameW, ProfileName );

    if (IsMapiServiceInstalled( ProfileNameW, CONTAB_SERVICE_NAME_W )) {
        //
        // we don't need a pab/fab if we have the outlook contact address book
        //
        goto exit;
    }

    hResult = lpProfAdmin->lpVtbl->AdminServices( lpProfAdmin, ProfileName, NULL, 0, 0, &lpSvcAdmin );
    if (hResult) {
        goto exit;
    }

    if (!IsMapiServiceInstalled( ProfileNameW, MSAB_SERVICE_NAME_W )) {
        hResult = lpSvcAdmin->lpVtbl->CreateMsgService( lpSvcAdmin, MSAB_SERVICE_NAME, NULL, 0, 0 );
        if (hResult && hResult != MAPI_E_NO_ACCESS) {
            //
            // mapi will return MAPI_E_NO_ACCESS when the service is already installed
            //
            goto exit;
        }
        ConfigurePab = TRUE;
    }

    if (!IsMapiServiceInstalled( ProfileNameW, MSPST_SERVICE_NAME_W )) {
        hResult = lpSvcAdmin->lpVtbl->CreateMsgService( lpSvcAdmin, MSPST_SERVICE_NAME, NULL, 0, 0 );
        if (hResult && hResult != MAPI_E_NO_ACCESS) {
            //
            // mapi will return MAPI_E_NO_ACCESS when the service is already installed
            //
            goto exit;
        }
        ConfigurePst = TRUE;
    }

    if (!IsMapiServiceInstalled( ProfileNameW, FAXAB_SERVICE_NAME_W )) {
        hResult = lpSvcAdmin->lpVtbl->CreateMsgService( lpSvcAdmin, FAXAB_SERVICE_NAME, NULL, 0, 0 );
        if (hResult && hResult != MAPI_E_NO_ACCESS) {
            //
            // mapi will return MAPI_E_NO_ACCESS when the service is already installed
            //
            goto exit;
        }
    }

    //
    // now configure the address book and pst
    //

    if (lpSvcAdmin->lpVtbl->GetMsgServiceTable( lpSvcAdmin, 0, &pmt )) {
        goto exit;
    }

    if (pmt->lpVtbl->SetColumns( pmt, &taga, 0 )) {
        goto exit;
    }

    if (pmt->lpVtbl->QueryRows( pmt, 4000, 0, &prws )) {
        goto exit;
    }

    for (i=0; i<prws->cRows; i++) {
        pval = prws->aRow[i].lpProps;
        ValidateProp( &pval[0], PR_SERVICE_NAME );
        if (ConfigurePab && (_stricmp( pval[0].Value.lpszA, MSAB_SERVICE_NAME) == 0)) {
            //
            // configure the pab service
            //

            ExpandEnvironmentStrings( PAB_FILE_NAME, Buffer, sizeof(Buffer) );

            spvProps[0].ulPropTag  = PR_PAB_PATH;
            spvProps[0].Value.LPSZ = Buffer;
            spvProps[1].ulPropTag  = PR_PAB_DET_DIR_VIEW_BY;
            spvProps[1].Value.ul   = PAB_DIR_VIEW_FIRST_THEN_LAST;

            if (lpSvcAdmin->lpVtbl->ConfigureMsgService( lpSvcAdmin, (LPMAPIUID)pval[1].Value.bin.lpb, (ULONG) hwnd, 0, 2, spvProps )) {

            }
        }
        if (ConfigurePst && (_stricmp( pval[0].Value.lpszA, MSPST_SERVICE_NAME) == 0)) {
            //
            // configure the pst service
            //

            ExpandEnvironmentStrings( PST_FILE_NAME, Buffer, sizeof(Buffer) );

            spvProps[0].ulPropTag  = PR_PST_PATH;
            spvProps[0].Value.LPSZ = Buffer;
            spvProps[1].ulPropTag  = PR_PST_ENCRYPTION;
            spvProps[1].Value.ul   = PSTF_NO_ENCRYPTION;

            if (lpSvcAdmin->lpVtbl->ConfigureMsgService( lpSvcAdmin, (LPMAPIUID)pval[1].Value.bin.lpb, (ULONG) hwnd, 0, 2, spvProps )) {

            }

        }
    }

    if (ConfigurePab || ConfigurePst) {
        __try {
            if (MapiLogonEx(
                0,
                ProfileName,
                NULL,
                MAPI_NEW_SESSION | MAPI_EXTENDED,
                &Session
                ) == 0)
            {
                MapiStartedByLogon = TRUE;
                Session->lpVtbl->Logoff( Session, 0, 0, 0 );
            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {

        }
    }

    rVal = TRUE;

exit:
    FreeSRowSet( prws );
    MLCRelease( (LPUNKNOWN)pmt );
    return rVal;
}


BOOL
InstallFaxTransport(
    LPWSTR ProfileNameW
    )
{
    BOOL rVal = FALSE;
    LPSERVICEADMIN lpSvcAdmin;
    CHAR ProfileName[128];


    if (!MapiAvail) {
        goto exit;
    }

    UnicodeStringToAnsiString( ProfileNameW, ProfileName );

    if (lpProfAdmin->lpVtbl->AdminServices( lpProfAdmin, ProfileName, NULL, 0, 0, &lpSvcAdmin )) {
        goto exit;
    }

    if (lpSvcAdmin->lpVtbl->CreateMsgService( lpSvcAdmin, FAXXP_SERVICE_NAME, NULL, 0, 0 )) {
        goto exit;
    }

    rVal = TRUE;

exit:
    return rVal;
}


BOOL
CreateDefaultMapiProfile(
    LPWSTR ProfileNameW
    )
{
    BOOL rVal = FALSE;
    CHAR ProfileName[128];


    if (!MapiAvail) {
        goto exit;
    }

    UnicodeStringToAnsiString( ProfileNameW, ProfileName );

    //
    // create the new profile
    //

    if (lpProfAdmin->lpVtbl->CreateProfile( lpProfAdmin, ProfileName, NULL, 0, 0 )) {
        goto exit;
    }

    if (lpProfAdmin->lpVtbl->SetDefaultProfile( lpProfAdmin, ProfileName, 0 )) {
        goto exit;
    }

    rVal = TRUE;

exit:
    return rVal;
}


BOOL
GetDefaultMapiProfile(
    LPWSTR ProfileName
    )
{
    BOOL rVal = FALSE;
    LPMAPITABLE pmt = NULL;
    LPSRowSet prws = NULL;
    LPSPropValue pval;
    DWORD i;
    DWORD j;

    if (!MapiAvail) {
        goto exit;
    }

    //
    // get the mapi profile table object
    //

    if (lpProfAdmin->lpVtbl->GetProfileTable( lpProfAdmin, 0, &pmt )) {
        goto exit;
    }

    //
    // get the actual profile data, FINALLY
    //

    if (pmt->lpVtbl->QueryRows( pmt, 4000, 0, &prws )) {
        goto exit;
    }

    //
    // enumerate the profiles looking for the default profile
    //

    for (i=0; i<prws->cRows; i++) {
        pval = prws->aRow[i].lpProps;
        for (j = 0; j < 2; j++) {
            if (pval[j].ulPropTag == PR_DEFAULT_PROFILE && pval[j].Value.b) {
            //
            // this is the default profile
            //
            AnsiStringToUnicodeString( pval[0].Value.lpszA, ProfileName );
            rVal = TRUE;
            break;
            }
        }
    }

exit:
    FreeSRowSet( prws );
    MLCRelease( (LPUNKNOWN)pmt );

    return rVal;
}

BOOL
DeleteMessageService(
    LPSTR ProfileName
    )
{
    SPropTagArray taga = {2,{PR_SERVICE_NAME,PR_SERVICE_UID}};
    BOOL rVal = FALSE;
    LPSERVICEADMIN lpSvcAdmin;
    LPMAPITABLE pmt = NULL;
    LPSRowSet prws = NULL;
    DWORD i;
    LPSPropValue pval;


    if (!MapiAvail) {
        goto exit;
    }

    if (lpProfAdmin->lpVtbl->AdminServices( lpProfAdmin, ProfileName, NULL, 0, 0, &lpSvcAdmin )) {
        goto exit;
    }

    if (lpSvcAdmin->lpVtbl->GetMsgServiceTable( lpSvcAdmin, 0, &pmt )) {
        goto exit;
    }

    if (pmt->lpVtbl->SetColumns( pmt, &taga, 0 )) {
        goto exit;
    }

    if (pmt->lpVtbl->QueryRows( pmt, 4000, 0, &prws )) {
        goto exit;
    }

    for (i=0; i<prws->cRows; i++) {

        pval = prws->aRow[i].lpProps;

        ValidateProp( &pval[0], PR_SERVICE_NAME );

        if (_stricmp( pval[0].Value.lpszA, "MSFAX AB" ) == 0) {
            lpSvcAdmin->lpVtbl->DeleteMsgService( lpSvcAdmin, (LPMAPIUID) pval[1].Value.bin.lpb );
        }

        if (_stricmp( pval[0].Value.lpszA, "MSFAX XP" ) == 0) {
            lpSvcAdmin->lpVtbl->DeleteMsgService( lpSvcAdmin, (LPMAPIUID) pval[1].Value.bin.lpb );
        }
    }

exit:
    FreeSRowSet( prws );
    MLCRelease( (LPUNKNOWN)pmt );
    return rVal;
}

BOOL
DeleteFaxMsgServices(
    VOID
    )
{
    BOOL rVal = FALSE;
    LPMAPITABLE pmt = NULL;
    LPSRowSet prws = NULL;
    LPSPropValue pval;
    DWORD i;
    DWORD j;

    if (!MapiAvail) {
        goto exit;
    }

    //
    // get the mapi profile table object
    //

    if (lpProfAdmin->lpVtbl->GetProfileTable( lpProfAdmin, 0, &pmt )) {
        goto exit;
    }

    //
    // get the actual profile data, FINALLY
    //

    if (pmt->lpVtbl->QueryRows( pmt, 4000, 0, &prws )) {
        goto exit;
    }

    //
    // enumerate the profiles looking for the default profile
    //

    for (i=0; i<prws->cRows; i++) {
        pval = prws->aRow[i].lpProps;
        for (j = 0; j < 2; j++) {
            if (pval[j].ulPropTag == PR_DISPLAY_NAME) {
                DeleteMessageService( pval[j].Value.lpszA );
            break;
            }
        }
    }

exit:
    FreeSRowSet( prws );
    MLCRelease( (LPUNKNOWN)pmt );

    return rVal;
}

BOOL
IsExchangeInstalled(
    VOID
    )
{
    BOOL MapiAvail = FALSE;
    CHAR MapiOption[4];
    HKEY hKey;
    LONG rVal;
    DWORD Bytes;
    DWORD Type;

    rVal = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        "Software\\Microsoft\\Windows Messaging Subsystem",
        &hKey
        );
    if (rVal == ERROR_SUCCESS) {
        Bytes = sizeof(MapiOption);
        rVal = RegQueryValueEx(
            hKey,
            "MAPIX",
            NULL,
            &Type,
            (LPBYTE) MapiOption,
            &Bytes
            );
        if (rVal == ERROR_SUCCESS) {
            if (Bytes && MapiOption[0] == '1') {
                MapiAvail = TRUE;
            }
        }
        RegCloseKey( hKey );
    }

    return MapiAvail;
}


BOOL
InitializeMapi(
    VOID
    )
{
    MAPIINIT_0 MapiInit;


    ExpandEnvironmentStrings( MAPISVC_INF, MapiSvcInf, sizeof(MapiSvcInf) );

    MapiAvail = IsExchangeInstalled();
    if (!MapiAvail) {
        goto exit;
    }

    //
    // load the mapi dll
    //

    MapiMod = LoadLibrary( "mapi32.dll" );
    if (!MapiMod) {
        MapiAvail = FALSE;
        goto exit;
    }

    //
    // get the addresses of the mapi functions that we need
    //

    MapiAdminProfiles = (LPMAPIADMINPROFILES) GetProcAddress( MapiMod, "MAPIAdminProfiles" );
    MapiInitialize = (LPMAPIINITIALIZE) GetProcAddress( MapiMod, "MAPIInitialize" );
    MapiUnInitialize = (LPMAPIUNINITIALIZE) GetProcAddress( MapiMod, "MAPIUninitialize" );
    pMAPIFreeBuffer = (LPMAPIFREEBUFFER) GetProcAddress( MapiMod, "MAPIFreeBuffer" );
    MapiLogonEx = (LPMAPILOGONEX) GetProcAddress( MapiMod, "MAPILogonEx" );
    if ((!MapiAdminProfiles) || (!MapiInitialize) || (!MapiUnInitialize) || (!pMAPIFreeBuffer) || (!MapiLogonEx)) {
        MapiAvail = FALSE;
        goto exit;
    }

    //
    // initialize mapi for our calls
    //

    MapiInit.ulVersion = 0;
    MapiInit.ulFlags = 0;

    if (MapiInitialize( &MapiInit )) {
        MapiAvail = FALSE;
        goto exit;
    }

    //
    // get the admin profile object
    //

    if (MapiAdminProfiles( 0, &lpProfAdmin )) {
        MapiAvail = FALSE;
        goto exit;
    }

exit:
    return MapiAvail;
}


BOOL
GetMapiProfiles(
    HWND hwnd,
    DWORD ResourceId
    )
{
    BOOL rVal = FALSE;
    HMODULE MapiMod = NULL;
    LPMAPITABLE pmt = NULL;
    LPSRowSet prws = NULL;
    LPSPropValue pval;
    DWORD i;



    //
    // add the default profile
    //

    SendDlgItemMessageA(
        hwnd,
        ResourceId,
        CB_ADDSTRING,
        0,
        (LPARAM) "<Default Profile>"
        );

    SendDlgItemMessage(
        hwnd,
        ResourceId,
        CB_SETCURSEL,
        0,
        0
        );

    if (!MapiAvail) {
        goto exit;
    }

    //
    // get the mapi table object
    //

    if (lpProfAdmin->lpVtbl->GetProfileTable( lpProfAdmin, 0, &pmt )) {
        goto exit;
    }

    //
    // get the actual profile data, FINALLY
    //

    if (pmt->lpVtbl->QueryRows( pmt, 4000, 0, &prws )) {
        goto exit;
    }

    //
    // enumerate the profiles and put the name
    // of each profile in the combo box
    //

    for (i=0; i<prws->cRows; i++) {
        pval = prws->aRow[i].lpProps;

        SendDlgItemMessageA(
            hwnd,
            ResourceId,
            CB_ADDSTRING,
            0,
            (LPARAM) pval[0].Value.lpszA
            );

        if (pval[2].Value.b) {
           //
           // this is the default profile
           //
        }
    }

    //
    // set the first one to be the current one
    //

    SendDlgItemMessage(
        hwnd,
        ResourceId,
        CB_SETCURSEL,
        0,
        0
        );

    rVal = TRUE;

exit:
    FreeSRowSet( prws );
    MLCRelease( (LPUNKNOWN)pmt );

    return rVal;
}


BOOL
GetExchangeInstallCommand(
    LPWSTR InstallCommandW
    )
{
    HKEY hKey;
    LONG rVal;
    DWORD Bytes;
    DWORD Type;
    CHAR InstallCommand[512];


    rVal = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        "Software\\Microsoft\\Windows Messaging Subsystem",
        &hKey
        );
    if (rVal == ERROR_SUCCESS) {
        Bytes = sizeof(InstallCommand);
        rVal = RegQueryValueEx(
            hKey,
            "InstallCmd",
            NULL,
            &Type,
            (LPBYTE) InstallCommand,
            &Bytes
            );
        RegCloseKey( hKey );
        if (rVal == ERROR_SUCCESS) {
            AnsiStringToUnicodeString( InstallCommand, InstallCommandW );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
InstallExchangeClientExtension(
    LPSTR  ExtensionName,
    LPSTR  FileName,
    LPSTR  ContextMask
    )
{
    HKEY hKey;
    LONG rVal;
    CHAR Buffer[512];
    CHAR ExpandedFileName[MAX_PATH];


    rVal = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        "Software\\Microsoft\\Exchange\\Client\\Extensions",
        &hKey
        );
    if (rVal == ERROR_SUCCESS) {

        ExpandEnvironmentStrings( FileName, ExpandedFileName, sizeof(ExpandedFileName) );

        sprintf( Buffer, "4.0;%s;1;%s", ExpandedFileName, ContextMask );

        rVal = RegSetValueEx(
            hKey,
            ExtensionName,
            0,
            REG_SZ,
            (LPBYTE) Buffer,
            strlen(Buffer) + 1
            );

        RegCloseKey( hKey );

        return rVal == ERROR_SUCCESS;
    }

    return FALSE;
}


DWORD
IsExchangeRunning(
    VOID
    )
{
    #define MAX_TASKS 256
    DWORD TaskCount;
    PTASK_LIST TaskList = NULL;
    DWORD ExchangePid = 0;
    DWORD i;


    if (MapiStartedByLogon) {
        return 0;
    }

    TaskList = (PTASK_LIST) malloc( MAX_TASKS * sizeof(TASK_LIST) );
    if (!TaskList) {
        goto exit;
    }

    TaskCount = GetTaskList( TaskList, MAX_TASKS );
    if (!TaskCount) {
        goto exit;
    }

    for (i=0; i<TaskCount; i++) {
        if (_stricmp( TaskList[i].ProcessName, "exchng32.exe" ) == 0) {
            ExchangePid = TaskList[i].dwProcessId;
            break;
        } else
        if (_stricmp( TaskList[i].ProcessName, "mapisp32.exe" ) == 0) {
            ExchangePid = TaskList[i].dwProcessId;
            break;
        }
    }

exit:
    free( TaskList );
    return ExchangePid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\fileq.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fileq.c

Abstract:

    This file implements the file copy code.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop


BOOL RebootRequired;



DWORD
SetupQueueXXXSection(
    HSPFILEQ QueueHandle,
    LPTSTR SourceRootPath,
    HINF InfHandle,
    HINF ListInfHandle,
    LPTSTR Section,
    DWORD CopyStyle,
    DWORD Action
    )
{
    if (Action == SETUP_ACTION_NONE) {
        return 0;
    }

    if (Action == SETUP_ACTION_COPY) {
        return SetupQueueCopySection(
            QueueHandle,
            SourceRootPath,
            InfHandle,
            ListInfHandle,
            Section,
            CopyStyle
            );
    }

    if (Action == SETUP_ACTION_DELETE) {
        return SetupQueueDeleteSection(
            QueueHandle,
            InfHandle,
            ListInfHandle,
            Section
            );
    }

    return 0;
}


BOOL
SetDestinationDir(
    HINF SetupInf,
    PFILE_QUEUE_INFO FileQueueInfo,
    PPLATFORM_INFO PlatformInfo
    )
{
    TCHAR Buffer[MAX_PATH*2];
    TCHAR DestDir[MAX_PATH*2];
    BOOL Rval;


    if (FileQueueInfo->InfDirId < DIRID_USER) {
        return TRUE;
    }

    DestDir[0] = 0;

    switch (FileQueueInfo->DestDirId) {
        case DIRID_SPOOLDRIVERS:
            _tcscat( DestDir, PlatformInfo->DriverDir );
            if (FileQueueInfo->DestDir) {
                RemoveLastNode( DestDir );
            }
            break;

        case DIRID_SYSTEM:
            ExpandEnvironmentStrings( TEXT("%systemroot%\\"), Buffer, sizeof(Buffer) );
            _tcscat( DestDir, Buffer );
            break;

        case DIRID_WINDOWS:
            ExpandEnvironmentStrings( TEXT("%windir%\\"), Buffer, sizeof(Buffer) );
            _tcscat( DestDir, Buffer );
            break;
    }

    if (FileQueueInfo->DestDir) {
        ExpandEnvironmentStrings( FileQueueInfo->DestDir, Buffer, sizeof(Buffer) );
        _tcscat( DestDir, Buffer );
    }

    if (FileQueueInfo->PlatformsFlag == PLATFORM_USE_MACHINE) {
        _tcscat( DestDir, TEXT("\\") );
        _tcscat( DestDir, PlatformInfo->OsPlatform );
    }

    DebugPrint(( TEXT("Setting destination dir: [%d] [%s]"), FileQueueInfo->InfDirId, DestDir ));

    MakeDirectory( DestDir );

    Rval = SetupSetDirectoryId(
        SetupInf,
        FileQueueInfo->InfDirId,
        DestDir
        );

    if (!Rval) {
        DebugPrint(( TEXT("SetupSetDirectoryId() failed, ec=%d"), GetLastError() ));
        return FALSE;
    }

    return TRUE;
}


BOOL
ProcessFileQueueEntry(
    HINF SetupInf,
    HSPFILEQ FileQueue,
    LPTSTR SourceRoot,
    PFILE_QUEUE_INFO FileQueueInfo,
    PPLATFORM_INFO PlatformInfo,
    DWORD ActionId,
    BOOL OsPlatformDir
    )
{
    TCHAR SourceDir[MAX_PATH*2];
    BOOL Rval;


    //
    // set the source directory
    //

    // work around Setupapi!SetupSetPlatformPathOverride bug

    if (PlatformInfo->ThisPlatform) {
       _tcscpy( SourceDir, SourceRoot );
    }
    else {
        if (! PlatformOverride(
            ThisPlatformName,
            PlatformInfo->OsPlatform,
            SourceRoot,
            SourceDir
           ) ) {

          DebugPrint(( TEXT("PlatformOverride() failed") ));
          return FALSE;
        }
    }

#if 0
    _tcscpy( SourceDir, SourceRoot );
    if (!PlatformInfo->ThisPlatform) {
        SetupSetPlatformPathOverride( PlatformInfo->OsPlatform );
    }
#endif

    //
    // set the destination directory
    //

    SetDestinationDir( SetupInf, FileQueueInfo, PlatformInfo );

    //
    // queue the operation
    //

    Rval = SetupQueueXXXSection(
        FileQueue,
        SourceDir,
        SetupInf,
        SetupInf,
        FileQueueInfo->SectionName,
        FileQueueInfo->CopyFlags,
        ActionId
        );
    if (!Rval) {
        return FALSE;
    }

    return TRUE;
}


UINT
FileQueueCallbackRoutine(
    IN LPDWORD FileCounter,
    IN UINT Notification,
    IN UINT Param1,
    IN UINT Param2
    )
{
    *FileCounter += 1;
    return NO_ERROR;
}


BOOL
ProcessFileQueue(
    HINF SetupInf,
    HSPFILEQ *FileQueue,
    PVOID QueueContext,
    LPTSTR SourceRoot,
    PFILE_QUEUE_INFO FileQueueInfo,
    DWORD CountFileQueueInfo,
    PSP_FILE_CALLBACK MyQueueCallback,
    DWORD ActionId
    )
{
    DWORD i;
    DWORD j;
    LPTSTR p;
    TCHAR Drive[_MAX_DRIVE];
    TCHAR Dir[_MAX_DIR];
    BOOL OsPlatformDir = FALSE;
    BOOL Rval;
    PFILE_QUEUE_CONTEXT FileQueueContext = (PFILE_QUEUE_CONTEXT) QueueContext;
    INT SetupReboot;
    DWORD FileCounter;


    //
    // check to see if the directory is a platform directory
    // if this is false then this is most likely an internal setup
    //

    _tsplitpath( SourceRoot, Drive, Dir, NULL, NULL );
    if (Dir[0] && Dir[1]) {
        p = Dir + _tcslen(Dir) - 1;
        *p = 0;
        p -= 1;
        while (*p != TEXT('\\')) {
            p -= 1;
        }
        p += 1;
        for (i=0; i<MAX_PLATFORMS; i++) {
            if (_tcsicmp(p, Platforms[i].OsPlatform) == 0) {
                OsPlatformDir = TRUE;
            }
        }
        p = Dir + _tcslen(Dir);
        *p = TEXT('\\');
    }

    //
    // process each entry in the file queue array
    //

    for (i=0; i<CountFileQueueInfo; i++) {

        switch (FileQueueInfo[i].PlatformsFlag) {
            case PLATFORM_NONE:
                for (j=0; j<CountPlatforms; j++) {
                    if (Platforms[j].ThisPlatform) {
                        break;
                    }
                }
                ProcessFileQueueEntry(
                    SetupInf,
                    FileQueue[j],
                    SourceRoot,
                    &FileQueueInfo[i],
                    &Platforms[j],
                    ActionId,
                    OsPlatformDir
                    );
                break;

            case PLATFORM_USE_MACHINE:
            case PLATFORM_USE_PRINTER:
                for (j=0; j<CountPlatforms; j++) {
                    if (Platforms[j].Selected) {
                        ProcessFileQueueEntry(
                            SetupInf,
                            FileQueue[j],
                            SourceRoot,
                            &FileQueueInfo[i],
                            &Platforms[j],
                            ActionId,
                            OsPlatformDir
                            );
                    }
                }
                break;

            default:
                Assert( FALSE && TEXT("Corrupt file queue array") );
                continue;
        }
    }

    //
    // now we scan the file queues to count the
    // number of files that got queued.  this is
    // necessary because we have 1 file queue per
    // platform and setupapi only send notification
    // messages to the callback function at the
    // beginning of the commit process for each queue.
    // this means that we cannot get a total count
    // of the files in advance of the first file being
    // copied.  the result being a hosed progress meter.
    //

    FileCounter = 0;
    for (i=0; i<CountPlatforms; i++) {
        if (Platforms[i].Selected) {
            SetupScanFileQueue(
                FileQueue[i],
                SPQ_SCAN_USE_CALLBACK,
                NULL,
                (PSP_FILE_CALLBACK) FileQueueCallbackRoutine,
                (PVOID) &FileCounter,
                &j
                );
        }
    }

    if (!Unattended) {
        SendMessage( FileQueueContext->hwnd, WM_MY_PROGRESS, 0xfe, (LPARAM) FileCounter );
    }

    //
    // copy the files
    //

    for (i=0; i<CountPlatforms; i++) {
        if (Platforms[i].Selected) {
            Rval = SetupCommitFileQueue(
                FileQueueContext->hwnd,
                FileQueue[i],
                MyQueueCallback,
                (PVOID) FileQueueContext
                );
            if (!Rval) {
                DebugPrint(( TEXT("SetupCommitFileQueue() failed, ec=%d"), GetLastError() ));
                return FALSE;
            }
        }
    }

    //
    // set to see if we need to reboot
    //

    if (!RebootRequired) {
        for (i=0; i<CountPlatforms; i++) {
            if (Platforms[i].Selected) {
                SetupReboot = SetupPromptReboot( FileQueue[i], NULL, TRUE );
                if (SetupReboot != -1) {
                    RebootRequired = SetupReboot & SPFILEQ_FILE_IN_USE;
                    if (RebootRequired) {
                        break;
                    }
                }
            }
        }
    }

    return TRUE;
}


BOOL
CloseFileQueue(
    HSPFILEQ *FileQueue,
    PVOID QueueContext
    )
{
    DWORD i;
    PFILE_QUEUE_CONTEXT FileQueueContext = (PFILE_QUEUE_CONTEXT) QueueContext;


    SetupTermDefaultQueueCallback( FileQueueContext->QueueContext );

    for (i=0; i<CountPlatforms; i++) {
        if (Platforms[i].Selected) {
            SetupCloseFileQueue( FileQueue[i] );
        }
    }

    return TRUE;
}


BOOL
InitializeFileQueue(
    HWND hwnd,
    HINF *SetupInf,
    HSPFILEQ **FileQueue,
    PVOID *QueueContext,
    LPTSTR SourceRoot
    )
{
    SYSTEM_INFO SystemInfo;
    DWORD i;
    BOOL Rval;
    DWORD Bytes;
    TCHAR Buffer[MAX_PATH*2];
    TCHAR Drive[_MAX_DRIVE];
    TCHAR Dir[_MAX_DIR];
    PFILE_QUEUE_CONTEXT FileQueueContext;


    GetSystemInfo( &SystemInfo );

    //
    // be sure that the spooler is running
    //

    StartSpoolerService();

    for (i=0; i<CountPlatforms; i++) {

        Rval = GetPrinterDriverDirectory(
            NULL,
            Platforms[i].PrintPlatform,
            1,
            (LPBYTE) Buffer,
            sizeof(Buffer),
            &Bytes
            );
        if (!Rval) {
            DebugPrint(( TEXT("GetPrinterDriverDirectory() failed, ec=%d"), GetLastError() ));
            return FALSE;
        }

        Platforms[i].DriverDir = StringDup( Buffer );
    }


    if ( (SystemInfo.wProcessorArchitecture > 3) || (EnumPlatforms[SystemInfo.wProcessorArchitecture] == WRONG_PLATFORM ) ) {
       return FALSE;
    }


    Platforms[ EnumPlatforms[SystemInfo.wProcessorArchitecture] ].ThisPlatform = TRUE;

    if (SourceRoot[0] == 0) {
        //
        // get the directory that the setup program is running from
        //

        GetModuleFileName( FaxWizModuleHandle, Buffer, sizeof(Buffer) );
        _tsplitpath( Buffer, Drive, Dir, NULL, NULL );
        _stprintf( SourceRoot, TEXT("%s%s"), Drive, Dir );
    }

    //
    // open the setup inf file
    //

    _stprintf( Buffer, TEXT("%sfaxsetup.inf"), SourceRoot );

    *SetupInf = SetupOpenInfFile(
        Buffer,
        NULL,
        INF_STYLE_WIN4,
        NULL
        );
    if (*SetupInf == INVALID_HANDLE_VALUE) {
        DebugPrint(( TEXT("SetupOpenInfFile() failed, ec=%d"), GetLastError() ));
        return FALSE;
    }

    //
    // open the file queues
    //

    *FileQueue = (HSPFILEQ*) MemAlloc( sizeof(HSPFILEQ) * CountPlatforms );
    if (!*FileQueue) {
        DebugPrint(( TEXT("Could not allocate memory for file queues") ));
        return FALSE;
    }

    for (i=0; i<CountPlatforms; i++) {
        if (Platforms[i].Selected) {
            (*FileQueue)[i] = SetupOpenFileQueue();
            if ((*FileQueue)[i] == INVALID_HANDLE_VALUE) {
                DebugPrint(( TEXT("SetupOpenFileQueue() failed, ec=%d"), GetLastError() ));
                return FALSE;
            }
        }
    }

    FileQueueContext = (PFILE_QUEUE_CONTEXT) MemAlloc( sizeof(FILE_QUEUE_CONTEXT) );
    if (!FileQueueContext) {
        return FALSE;
    }

    FileQueueContext->hwnd = hwnd;

    FileQueueContext->QueueContext = SetupInitDefaultQueueCallbackEx(
        hwnd,
        hwnd,
        WM_MY_PROGRESS,
        0,
        NULL
        );
    if (!FileQueueContext->QueueContext) {
        DebugPrint(( TEXT("SetupInitDefaultQueueCallbackEx() failed, ec=%d"), GetLastError() ));
        return FALSE;
    }

    *QueueContext = FileQueueContext;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\help.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    help.c

Abstract:

    This file implements the code for the help file installation.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop



#define HELP_INDEX_TAG          ":Index "
#define HELP_INDEX_SEP          '='
#define CRLF                    "\r\n"
#define FAX_HELP_STRING         ":Index Fax Help=fax.hlp"
#define FAX_HELP_TAG            "Fax Help"
#define HELP_INDEX_TAG_LEN      7
#define FAX_HELP_TAG_LEN        8
#define FAX_HELP_STRING_LEN     23
#define CRLF_LEN                2


BOOL
InstallHelpFiles(
    VOID
    )
{
    BOOL rVal = FALSE;
    TCHAR Buffer[MAX_PATH];
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hMap = NULL;
    LPSTR fPtr = NULL;
    LPSTR p,s;
    DWORD FileSize;
    INT cmp;


    ExpandEnvironmentStrings( TEXT("%windir%\\system32\\windows.cnt"), Buffer, sizeof(Buffer) );

    hFile = CreateFile(
        Buffer,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );
    if (hFile == INVALID_HANDLE_VALUE) {
        goto exit;
    }

    FileSize = GetFileSize( hFile, NULL );
    if (FileSize == 0xffffffff) {
        goto exit;
    }

    hMap = CreateFileMapping(
        hFile,
        NULL,
        PAGE_READWRITE,
        0,
        FileSize + 1024,
        NULL
        );
    if (!hMap) {
        goto exit;
    }

    fPtr = (LPSTR) MapViewOfFile(
        hMap,
        FILE_MAP_ALL_ACCESS,
        0,
        0,
        0
        );
    if (!fPtr) {
        goto exit;
    }

    p = fPtr;
    while (p<fPtr+FileSize) {
        if (_strnicmp( p, HELP_INDEX_TAG, HELP_INDEX_TAG_LEN ) == 0) {
            p += HELP_INDEX_TAG_LEN;
            s = strchr( p, HELP_INDEX_SEP );
            if (s) {
                cmp = strncmp( p, FAX_HELP_TAG, s-p );
                if (cmp == 0) {
                    //
                    // fax help is already installed
                    //
                    goto exit;
                } else if (cmp > 0) {
                    //
                    // this is where we insert it
                    //
                    p -= HELP_INDEX_TAG_LEN;
                    MoveMemory( p+FAX_HELP_STRING_LEN+CRLF_LEN, p, FileSize-(p-fPtr) );
                    CopyMemory( p, FAX_HELP_STRING, FAX_HELP_STRING_LEN );
                    p += FAX_HELP_STRING_LEN;
                    CopyMemory( p, CRLF, CRLF_LEN );
                    UnmapViewOfFile( fPtr );
                    CloseHandle( hMap );
                    fPtr = NULL;
                    hMap = NULL;
                    SetFilePointer( hFile, FileSize+FAX_HELP_STRING_LEN+CRLF_LEN, NULL, FILE_BEGIN );
                    SetEndOfFile( hFile );
                    break;
                }
            }
        }
        //
        // skip to the next line
        //
        while( *p != '\n' ) p++;
        p += 1;
    }

    ExpandEnvironmentStrings( TEXT("%windir%\\system32\\windows.gid"), Buffer, sizeof(Buffer) );
    MyDeleteFile( Buffer );

    ExpandEnvironmentStrings( TEXT("%windir%\\system32\\windows.fts"), Buffer, sizeof(Buffer) );
    MyDeleteFile( Buffer );

    ExpandEnvironmentStrings( TEXT("%windir%\\system32\\windows.ftg"), Buffer, sizeof(Buffer) );
    MyDeleteFile( Buffer );

    rVal = TRUE;

exit:
    if (fPtr) {
        UnmapViewOfFile( fPtr );
    }
    if (hMap) {
        CloseHandle( hMap );
    }
    if (hFile) {
        CloseHandle( hFile );
    }

    return rVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\resource.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    This file contains all manafest contants for FAXSETUP's resources.

Author:

    Wesley Witt (wesw) 27-June-1995

Environment:

    User Mode

--*/


#define WIZARD_WIDTH                         276
#define WIZARD_HEIGTH                        140

#define IDC_STATIC                           -1

//
// icons
//

#define IDI_ACMEICON                         501

//
// bitmaps
//

#define IDB_FAXWIZ_BITMAP                    502
#define IDB_CHECKSTATES                      503
#define IDB_WATERMARK16                      504
#define IDB_WATERMARK256                     505


//
// dialogs
//

#define IDD_WELCOME                          701
#define IDD_SERVER_NAME_PAGE                 702
#define IDD_FILE_COPY_PAGE                   703
#define IDD_STATIONID_PAGE                   704
#define IDD_ROUTING_PAGE                     705
#define IDD_ROUTE_PRINT_PAGE                 706
#define IDD_ROUTE_STOREDIR_PAGE              707
#define IDD_ROUTE_INBOX_PAGE                 708
#define IDD_ROUTE_USERPASS_PAGE              709
#define IDD_CLIENT_SERVER_NAME_PAGE          710
#define IDD_CLIENT_USER_INFO_PAGE            711
#define IDD_CLIENT_LAST_PAGE                 712
#define IDD_DEVICE_INIT_PAGE                 713
#define IDD_SERVER_PLATFORMS_PAGE            714
#define IDD_LAST_WIZARD_PAGE                 799
#define IDD_SECURITY_ERROR                   801
#define IDD_PRINTER_NAME                     802
#define IDD_LAST_UNINSTALL_PAGE              804
#define IDD_WORKSTATION_DEVICE_SELECT        805
#define IDD_EXCHANGE_PAGE                    806
#define IDD_FAX_MODEM_INSTALL                807

//
// controls
//

#define IDC_CONTINUE                         101
#define IDC_EXIT                             102
#define IDC_COPY_PROGRESS                    103
#define IDC_FAX_PHONE                        104
#define IDC_BITMAP_STATIC                    106
#define IDC_ANS_YES                          107
#define IDC_ANS_NO                           108
#define IDC_DEST_PRINTERLIST                 110
#define IDC_DEST_DIRPATH                     111
#define IDC_BROWSE_DIR                       112
#define IDC_DEST_PROFILENAME                 113
#define IDC_ACCOUNT_NAME                     114
#define IDC_PASSWORD                         115
#define IDT_STATIC                           116
#define IDC_WIZBMP                           117
#define IDC_PRINTER_NAME                     118
#define IDC_SERVER_NAME                      119
#define IDC_SENDER_NAME                      120
#define IDC_SENDER_FAX_AREA_CODE             121
#define IDC_SENDER_FAX_NUMBER                122
#define IDC_PROGRESS_TEXT                    123
#define IDC_PASSWORD2                        124
#define IDC_DEVICE_PROGRESS                  125
#define IDC_DEVICE_PROGRESS_TEXT             126
#define IDC_PLATFORM_LIST                    127
#define IDC_DEVICE_LIST                      131
#define IDC_LAST_LABEL01                     132
#define IDC_LAST_LABEL02                     133
#define IDC_FC_WAITMSG                       134
#define IDC_LABEL_PRINTERNAME                136
#define IDC_WELCOME_LABEL01                  137
#define IDC_WELCOME_LABEL02                  138
#define IDC_DEVICEINIT_LABEL01               139
#define IDC_LASTUNINSTALL_LABEL01            140
#define IDC_HEADER_BOTTOM                    142

//
// strings
//

#define IDS_TITLE_WKS                        201
#define IDS_TITLE_SRV                        202
#define IDS_COPYING                          203
#define IDS_COPY_WAITMSG                     204
#define IDS_COULD_NOT_DELETE_FAX_PRINTER     205
#define IDS_COULD_NOT_DELETE_FILES           206
#define IDS_CREATING_FAXPRT                  207
#define IDS_CREATING_GROUPS                  208
#define IDS_DEFAULT_PRINTER                  209
#define IDS_DEFAULT_SHARE                    210
#define IDS_DELETE_WAITMSG                   211
#define IDS_DELETING                         212
#define IDS_DELETING_FAX_PRINTERS            213
#define IDS_DELETING_FAX_SERVICE             214
#define IDS_DELETING_GROUPS                  215
#define IDS_DELETING_REGISTRY                216
#define IDS_DEVICEINIT_LABEL01               217
#define IDS_ERR_TITLE                        218
#define IDS_FAXCLIENT_SETUP                  219
#define IDS_FAX_PRINTER_PENDING_DELETION     220
#define IDS_FAX_SHARE_COMMENT                221
#define IDS_INBOUND_DIR                      222
#define IDS_INIT_TAPI                        223
#define IDS_INSTALLING_FAXSVC                224
#define IDS_INVALID_DIRECTORY                226
#define IDS_INVALID_LOCAL_PRINTER_NAME       227
#define IDS_LABEL01_LAST                     228
#define IDS_LABEL_PRINTERNAME                229
#define IDS_LASTUNINSTALL_LABEL01            230
#define IDS_NO_MODEM                         231
#define IDS_QUERY_CANCEL                     235
#define IDS_QUERY_UNINSTALL                  236
#define IDS_SETTING_REGISTRY                 237
#define IDS_SHARE_FAX_PRINTER                238
#define IDS_STARTING_FAXSVC                  239
#define IDS_TITLE                            240
#define IDS_WELCOME_LABEL01                  241
#define IDS_WELCOME_LABEL02                  242
#define IDS_WRN_SPOOLER                      243
#define IDS_WRN_TITLE                        244
#define IDS_PRINTER_NAME                     245
#define IDS_CSID                             246
#define IDS_TSID                             247
#define IDS_DEST_DIR                         248
#define IDS_PROFILE                          249
#define IDS_ACCOUNTNAME                      250
#define IDS_PASSWORD                         251
#define IDS_NO_TAPI_DEVICES                  252
#define IDS_USER_MUST_BE_ADMIN               253
#define IDS_COULD_NOT_INSTALL_FAX_SERVICE    254
#define IDS_COULD_NOT_START_FAX_SERVICE      255
#define IDS_COULD_NOT_CREATE_PRINTER         256
#define IDS_COULD_SET_REG_DATA               257
#define IDS_INVALID_USER                     258
#define IDS_INVALID_USER_NAME                259
#define IDS_INVALID_AREA_CODE                260
#define IDS_INVALID_PHONE_NUMBER             261
#define IDS_ROUTING_REQUIRED                 262
#define IDS_COULD_NOT_COPY_FILES             263
#define IDS_CANT_USE_FAX_PRINTER             264
#define IDS_CANT_SET_SERVICE_ACCOUNT         265
#define IDS_EXCHANGE_IS_RUNNING              266
#define IDS_DEFAULT_PRINTER_NAME             267
#define IDS_INSTALLING_EXCHANGE              268
#define IDS_NO_CLASS1                        269
#define IDS_351_MODEM                        270
#define IDS_LARGEFONTNAME                    271
#define IDS_LARGEFONTSIZE                    272
#define IDS_UAA_MODE                         273
#define IDS_UAA_PRINTER_NAME                 274
#define IDS_UAA_FAX_PHONE                    275
#define IDS_UAA_DEST_PROFILENAME             276
#define IDS_UAA_ROUTE_PROFILENAME            277
#define IDS_UAA_PLATFORM_LIST                278
#define IDS_UAA_DEST_PRINTERLIST             279
#define IDS_UAA_ACCOUNT_NAME                 280
#define IDS_UAA_PASSWORD                     281
#define IDS_UAA_DEST_DIRPATH                 283
#define IDS_UAA_SERVER_NAME                  284
#define IDS_UAA_SENDER_NAME                  285
#define IDS_UAA_SENDER_FAX_AREA_CODE         286
#define IDS_UAA_SENDER_FAX_NUMBER            287
#define IDS_PERMISSION_CREATE_PRINTER        288
#define IDS_TITLE_PP                         289
#define IDS_LABEL02_LAST                     290
#define IDS_TITLE_RA                         291
#define IDS_W95_INF_NAME                     292
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\security.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    service.c

Abstract:

    This file provides access to the service control
    manager for starting, stopping, adding, and removing
    services.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "wizard.h"

#include <ntsecapi.h>
#include <lm.h>



NTSTATUS
OpenPolicy(
    LPWSTR ServerName,          // machine to open policy on (Unicode)
    DWORD DesiredAccess,        // desired access to policy
    PLSA_HANDLE PolicyHandle    // resultant policy handle
    );

BOOL
GetAccountSid(
    LPTSTR SystemName,          // where to lookup account
    LPTSTR AccountName,         // account of interest
    PSID *Sid                   // resultant buffer containing SID
    );

NTSTATUS
SetPrivilegeOnAccount(
    LSA_HANDLE PolicyHandle,    // open policy handle
    PSID AccountSid,            // SID to grant privilege to
    LPWSTR PrivilegeName,       // privilege to grant (Unicode)
    BOOL bEnable                // enable or disable
    );

void
InitLsaString(
    PLSA_UNICODE_STRING LsaString, // destination
    LPWSTR String                  // source (Unicode)
    );

void
DisplayNtStatus(
    LPSTR szAPI,                // pointer to function name (ANSI)
    NTSTATUS Status             // NTSTATUS error value
    );

void
DisplayWinError(
    LPSTR szAPI,                // pointer to function name (ANSI)
    DWORD WinError              // DWORD WinError
    );

#define RTN_OK 0
#define RTN_USAGE 1
#define RTN_ERROR 13

//
// If you have the ddk, include ntstatus.h.
//
#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS  ((NTSTATUS)0x00000000L)
#endif


BOOL
GetDefaultDomainName(
    LPWSTR DomainName
    )
{
    OBJECT_ATTRIBUTES           ObjectAttributes;
    NTSTATUS                    NtStatus;
    DWORD                       err             = 0;
    LSA_HANDLE                  LsaPolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo      = NULL;


    //
    //  Open a handle to the local machine's LSA policy object.
    //

    InitializeObjectAttributes( &ObjectAttributes,  // object attributes
                                NULL,               // name
                                0L,                 // attributes
                                NULL,               // root directory
                                NULL );             // security descriptor

    NtStatus = LsaOpenPolicy( NULL,                 // system name
                              &ObjectAttributes,    // object attributes
                              POLICY_EXECUTE,       // access mask
                              &LsaPolicyHandle );   // policy handle

    if( !NT_SUCCESS( NtStatus ) )
    {
        return FALSE;
    }

    //
    //  Query the domain information from the policy object.
    //
    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyAccountDomainInformation,
                                          (PVOID *) &DomainInfo );

    if (!NT_SUCCESS(NtStatus))
    {
        LsaClose(LsaPolicyHandle);
        return FALSE;
    }


    (void) LsaClose(LsaPolicyHandle);

    //
    // Copy the domain name into our cache, and
    //

    CopyMemory( DomainName,
                DomainInfo->DomainName.Buffer,
                DomainInfo->DomainName.Length );

    //
    // Null terminate it appropriately
    //

    DomainName[DomainInfo->DomainName.Length / sizeof(WCHAR)] = L'\0';

    //
    // Clean up
    //
    LsaFreeMemory( (PVOID)DomainInfo );

    return TRUE;
}


LPWSTR
GetMachineName(
    LPWSTR AccountName
    )
{
    LSA_HANDLE PolicyHandle = NULL;
    WCHAR DomainName[128];
    WCHAR LocalComputerName[128];
    LPWSTR MachineName = NULL;
    LPWSTR p;
    LPWSTR DCName = NULL;
    NET_API_STATUS NetStatus;
    UNICODE_STRING NameStrings;
    PLSA_REFERENCED_DOMAIN_LIST ReferencedDomains = NULL;
    PLSA_TRANSLATED_SID LsaSids = NULL;
    PUSER_MODALS_INFO_1 Modals = NULL;
    DWORD Size;
    NTSTATUS Status;


    //
    // get the domain name
    //

    p = wcschr( AccountName, L'\\' );
    if (p) {
        *p = 0;
        wcscpy( DomainName, AccountName );
        *p = L'\\';
    } else {
        wcscpy( DomainName, AccountName );
    }

    //
    // Open the policy on the target machine.
    //
    Status = OpenPolicy(
        NULL,
        POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
        &PolicyHandle
        );
    if (Status != STATUS_SUCCESS) {
        goto exit;
    }

    //
    // lookup the domain name for the account
    //

    InitLsaString( &NameStrings, AccountName );

    Status = LsaLookupNames(
        PolicyHandle,
        1,
        &NameStrings,
        &ReferencedDomains,
        &LsaSids
        );
    if (Status != STATUS_SUCCESS) {
        goto exit;
    }

    //
    // get the local computer name
    //

    Size = sizeof(LocalComputerName);
    if (!GetComputerName( LocalComputerName, &Size )) {
        goto exit;
    }

    //
    // see if we are tring to set a local account
    //

    if (wcscmp( LocalComputerName, ReferencedDomains->Domains->Name.Buffer ) != 0) {

        //
        // see what part of the domain we are attempting to set
        //

        NetStatus = NetUserModalsGet( NULL, 1, (LPBYTE*) &Modals );
        if (NetStatus != NERR_Success) {
            goto exit;
        }

        if (Modals->usrmod1_role != UAS_ROLE_PRIMARY) {

            //
            // we know we are remote, so get the real dc name
            //

            NetStatus = NetGetDCName( NULL, DomainName, (LPBYTE*) &DCName );
            if (NetStatus != NERR_Success) {
                goto exit;
            }

            MachineName = StringDup( DCName );

        }
    }


exit:
    if (Modals) {
        NetApiBufferFree( Modals );
    }
    if (DCName) {
        NetApiBufferFree( DCName );
    }
    if (ReferencedDomains) {
        LsaFreeMemory( ReferencedDomains );
    }
    if (LsaSids) {
        LsaFreeMemory( LsaSids );
    }
    if (PolicyHandle) {
        LsaClose( PolicyHandle );
    }

    return MachineName;
}



DWORD
SetServiceSecurity(
    LPWSTR AccountName
    )
{
    LSA_HANDLE PolicyHandle;
    PSID pSid;
    NTSTATUS Status;
    int iRetVal=RTN_ERROR;
    LPWSTR MachineName;
    WCHAR NewAccountName[512];


    if (AccountName[0] == L'.') {
        if (GetDefaultDomainName( NewAccountName )) {
            wcscat( NewAccountName, &AccountName[1] );
            AccountName = NewAccountName;
        }
    }

    //
    // try to get the correct machine name
    //
    MachineName = GetMachineName( AccountName );

    //
    // Open the policy on the target machine.
    //
    Status = OpenPolicy(
        MachineName,
        POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
        &PolicyHandle
        );
    if (Status != STATUS_SUCCESS) {
        return RTN_ERROR;
    }

    //
    // Obtain the SID of the user/group.
    // Note that we could target a specific machine, but we don't.
    // Specifying NULL for target machine searches for the SID in the
    // following order: well-known, Built-in and local, primary domain,
    // trusted domains.
    //
    if(GetAccountSid(
            MachineName, // target machine
            AccountName,// account to obtain SID
            &pSid       // buffer to allocate to contain resultant SID
            )) {
        //
        // We only grant the privilege if we succeeded in obtaining the
        // SID. We can actually add SIDs which cannot be looked up, but
        // looking up the SID is a good sanity check which is suitable for
        // most cases.

        //
        // Grant the SeServiceLogonRight to users represented by pSid.
        //
        if((Status=SetPrivilegeOnAccount(
                    PolicyHandle,           // policy handle
                    pSid,                   // SID to grant privilege
                    L"SeServiceLogonRight", // Unicode privilege
                    TRUE                    // enable the privilege
                    )) == STATUS_SUCCESS) {
            iRetVal=RTN_OK;
        }
    }

    //
    // Close the policy handle.
    //
    LsaClose(PolicyHandle);

    //
    // Free memory allocated for SID.
    //
    if(pSid != NULL) MemFree(pSid);

    return iRetVal;
}


void
InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPWSTR String
    )
{
    DWORD StringLength;

    if (String == NULL) {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = wcslen(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
}

NTSTATUS
OpenPolicy(
    LPWSTR ServerName,
    DWORD DesiredAccess,
    PLSA_HANDLE PolicyHandle
    )
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server = NULL;

    //
    // Always initialize the object attributes to all zeroes.
    //
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    if (ServerName != NULL) {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        InitLsaString(&ServerString, ServerName);
        Server = &ServerString;
    }

    //
    // Attempt to open the policy.
    //
    return LsaOpenPolicy(
                Server,
                &ObjectAttributes,
                DesiredAccess,
                PolicyHandle
                );
}

/*++
This function attempts to obtain a SID representing the supplied
account on the supplied system.

If the function succeeds, the return value is TRUE. A buffer is
allocated which contains the SID representing the supplied account.
This buffer should be freed when it is no longer needed by calling
HeapFree(GetProcessHeap(), 0, buffer)

If the function fails, the return value is FALSE. Call GetLastError()
to obtain extended error information.
--*/

BOOL
GetAccountSid(
    LPTSTR SystemName,
    LPTSTR AccountName,
    PSID *Sid
    )
{
    LPTSTR ReferencedDomain=NULL;
    DWORD cbSid=128;    // initial allocation attempt
    DWORD cbReferencedDomain=32; // initial allocation size
    SID_NAME_USE peUse;
    BOOL bSuccess=FALSE; // assume this function will fail

    __try {

    //
    // initial memory allocations
    //
    if((*Sid=MemAlloc(cbSid)) == NULL) __leave;
    if((ReferencedDomain=MemAlloc(cbReferencedDomain)) == NULL) __leave;

    //
    // Obtain the SID of the specified account on the specified system.
    //
    while(!LookupAccountName(
                    SystemName,         // machine to lookup account on
                    AccountName,        // account to lookup
                    *Sid,               // SID of interest
                    &cbSid,             // size of SID
                    ReferencedDomain,   // domain account was found on
                    &cbReferencedDomain,
                    &peUse
                    )) {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            //
            // reallocate memory
            //
            if((*Sid=HeapReAlloc(
                        GetProcessHeap(),
                        0,
                        *Sid,
                        cbSid
                        )) == NULL) __leave;

            if((ReferencedDomain=HeapReAlloc(
                        GetProcessHeap(),
                        0,
                        ReferencedDomain,
                        cbReferencedDomain
                        )) == NULL) __leave;
        }
        else __leave;
    }

    //
    // Indicate success.
    //
    bSuccess=TRUE;

    } // finally
    __finally {

    //
    // Cleanup and indicate failure, if appropriate.
    //

    MemFree(ReferencedDomain);

    if(!bSuccess) {
        if(*Sid != NULL) {
            MemFree(*Sid);
            *Sid = NULL;
        }
    }

    } // finally

    return bSuccess;
}

NTSTATUS
SetPrivilegeOnAccount(
    LSA_HANDLE PolicyHandle,    // open policy handle
    PSID AccountSid,            // SID to grant privilege to
    LPWSTR PrivilegeName,       // privilege to grant (Unicode)
    BOOL bEnable                // enable or disable
    )
{
    LSA_UNICODE_STRING PrivilegeString;

    //
    // Create a LSA_UNICODE_STRING for the privilege name.
    //
    InitLsaString(&PrivilegeString, PrivilegeName);

    //
    // grant or revoke the privilege, accordingly
    //
    if(bEnable) {
        return LsaAddAccountRights(
                PolicyHandle,       // open policy handle
                AccountSid,         // target SID
                &PrivilegeString,   // privileges
                1                   // privilege count
                );
    }
    else {
        return LsaRemoveAccountRights(
                PolicyHandle,       // open policy handle
                AccountSid,         // target SID
                FALSE,              // do not disable all rights
                &PrivilegeString,   // privileges
                1                   // privilege count
                );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\registry.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    This file provides access to the registry.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop


BOOL
CreateDeviceProvider(
    HKEY hKey,
    LPTSTR ProviderKey,
    LPTSTR FriendlyName,
    LPTSTR ImageName,
    LPTSTR ProviderName
    )
{
    hKey = OpenRegistryKey( hKey, ProviderKey, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        DebugPrint(( TEXT("could not create/open registry key (test)") ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, REGVAL_FRIENDLY_NAME, FriendlyName )) {
        DebugPrint(( TEXT("could not add friendly name value") ));
        return FALSE;
    }

    if (!SetRegistryStringExpand( hKey, REGVAL_IMAGE_NAME, ImageName )) {
        DebugPrint(( TEXT("could not add image name value") ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, REGVAL_PROVIDER_NAME, ProviderName )) {
        DebugPrint(( TEXT("could not add provider name value") ));
        return FALSE;
    }

    RegCloseKey( hKey );

    return TRUE;
}


BOOL
CreateRoutingMethod(
    HKEY hKey,
    LPTSTR MethodName,
    LPTSTR FunctionName,
    LPTSTR FriendlyName,
    LPTSTR Guid
    )
{
    hKey = OpenRegistryKey( hKey, MethodName, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        DebugPrint(( TEXT("could not create/open registry key for routing method") ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, REGVAL_FUNCTION_NAME, FunctionName )) {
        DebugPrint(( TEXT("could not add function name value") ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, REGVAL_FRIENDLY_NAME, FriendlyName )) {
        DebugPrint(( TEXT("could not add friendly name value") ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, REGVAL_GUID, Guid )) {
        DebugPrint(( TEXT("could not add function name value") ));
        return FALSE;
    }

    RegCloseKey( hKey );

    return TRUE;
}


BOOL
CreateMicrosoftRoutingExtension(
    HKEY hKey,
    LPTSTR RoutingKey,
    LPTSTR FriendlyName,
    LPTSTR ImageName
    )
{
    HKEY hKeyMethods;


    hKey = OpenRegistryKey( hKey, RoutingKey, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        Assert(( ! TEXT("could not create/open registry key for routing extension") ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, REGVAL_FRIENDLY_NAME, FriendlyName )) {
        Assert(( ! TEXT("could not add friendly name value") ));
        return FALSE;
    }

    if (!SetRegistryStringExpand( hKey, REGVAL_IMAGE_NAME, ImageName )) {
        Assert(( ! TEXT("could not add image name value") ));
        return FALSE;
    }

    hKeyMethods = OpenRegistryKey( hKey, REGKEY_ROUTING_METHODS, TRUE, KEY_ALL_ACCESS );
    if (!hKeyMethods) {
        Assert(( ! TEXT("could not create/open registry key for routing methods") ));
        return FALSE;
    }

    CreateRoutingMethod( hKeyMethods, REGKEY_ROUTING_METHOD_EMAIL,    REGVAL_RM_EMAIL_FUNCTION,    REGVAL_RM_EMAIL_FRIENDLY,    REGVAL_RM_EMAIL_GUID    );
    CreateRoutingMethod( hKeyMethods, REGKEY_ROUTING_METHOD_FOLDER,   REGVAL_RM_FOLDER_FUNCTION,   REGVAL_RM_FOLDER_FRIENDLY,   REGVAL_RM_FOLDER_GUID   );
    CreateRoutingMethod( hKeyMethods, REGKEY_ROUTING_METHOD_INBOX,    REGVAL_RM_INBOX_FUNCTION,    REGVAL_RM_INBOX_FRIENDLY,    REGVAL_RM_INBOX_GUID    );
    CreateRoutingMethod( hKeyMethods, REGKEY_ROUTING_METHOD_PRINTING, REGVAL_RM_PRINTING_FUNCTION, REGVAL_RM_PRINTING_FRIENDLY, REGVAL_RM_PRINTING_GUID );

    RegCloseKey( hKeyMethods );
    RegCloseKey( hKey );

    return TRUE;
}


VOID
RegCreateFaxDevice(
    HKEY hKeyDev,
    DWORD PermanentLineID,
    DWORD Rings,
    DWORD Priority,
    DWORD Flags,
    LPTSTR DeviceName,
    LPTSTR ProviderName,
    LPTSTR Csid,
    LPTSTR Tsid,
    DWORD RoutingMask,
    LPTSTR RoutePrinterName,
    LPTSTR RouteDir,
    LPTSTR RouteProfile
    )
{
    HKEY hKey;
    HKEY hKeyRouting;
    TCHAR PortName[32];


    _stprintf( PortName, TEXT("%08d"), PermanentLineID );

    hKey = OpenRegistryKey( hKeyDev, PortName, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        Assert(( ! TEXT("Could not open device registry key") ));
        return;
    }

    if (!SetRegistryDword( hKey, REGVAL_PERMANENT_LINEID, PermanentLineID )) {
        Assert(( ! TEXT("Could not set device id registry value") ));
    }

    if (!SetRegistryDword( hKey, REGVAL_FLAGS, Flags )) {
        Assert(( ! TEXT("Could not set device flags registry value") ));
    }

    if (!SetRegistryDword( hKey, REGVAL_RINGS, Rings )) {
        Assert(( ! TEXT("Could not set device rings registry value") ));
    }

    if (!SetRegistryDword( hKey, REGVAL_PRIORITY, Priority )) {
        Assert(( ! TEXT("Could not set device rings registry value") ));
    }

    if (!SetRegistryString( hKey, REGVAL_DEVICE_NAME, DeviceName )) {
        Assert(( ! TEXT("Could not set device name registry value") ));
    }

    if (!SetRegistryString( hKey, REGVAL_PROVIDER, ProviderName )) {
        Assert(( ! TEXT("Could not set provider name registry value") ));
    }

    if (!SetRegistryString( hKey, REGVAL_ROUTING_CSID, Csid )) {
        Assert(( ! TEXT("Could not set csid registry value") ));
    }

    if (!SetRegistryString( hKey, REGVAL_ROUTING_TSID, Tsid )) {
        Assert(( ! TEXT("Could not set csid registry value") ));
    }

    hKeyRouting = OpenRegistryKey( hKey, REGKEY_ROUTING, TRUE, KEY_ALL_ACCESS );
    if (!hKeyRouting) {
        Assert(( ! TEXT("Could not open routing registry key") ));
        return;
    }

    if (!SetRegistryString( hKeyRouting, REGVAL_ROUTING_PRINTER, RoutePrinterName )) {
        Assert(( ! TEXT("Could not set printer name registry value") ));
    }

    if (!SetRegistryString( hKeyRouting, REGVAL_ROUTING_DIR, RouteDir )) {
        Assert(( ! TEXT("Could not set routing dir registry value") ));
    }

    if (!SetRegistryString( hKeyRouting, REGVAL_ROUTING_PROFILE, RouteProfile )) {
        Assert(( ! TEXT("Could not set routing profile name registry value") ));
    }

    if (!SetRegistryDword( hKeyRouting, REGVAL_ROUTING_MASK, RoutingMask )) {
        Assert(( ! TEXT("Could not set routing mask registry value") ));
    }

    RegCloseKey( hKeyRouting );
    RegCloseKey( hKey );
}



BOOL
SetServerRegistryData(
    VOID
    )
{
    HKEY hKey;
    LONG rVal;
    DWORD i;
    HKEY hKeyDev;
    HANDLE hNull;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    TCHAR CmdLine[128];
    DWORD RoutingMask;
    LPTSTR LodCmdLine;


    //
    // set top level defaults
    //

    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        Assert(( ! TEXT("Could not open software registry key") ));
        return FALSE;
    }

    if (InstallMode & INSTALL_NEW) {
        if (!SetRegistryDword( hKey, REGVAL_RETRIES, DEFAULT_REGVAL_RETRIES )) {
            Assert(( ! TEXT("Could not set retries registry value") ));
        }

        if (!SetRegistryDword( hKey, REGVAL_RETRYDELAY, DEFAULT_REGVAL_RETRYDELAY )) {
            Assert(( ! TEXT("Could not set retry delay registry value") ));
        }

        if (!SetRegistryDword( hKey, REGVAL_DIRTYDAYS, DEFAULT_REGVAL_DIRTYDAYS )) {
            Assert(( ! TEXT("Could not set dirty days registry value") ));
        }

        if (!SetRegistryDword( hKey, REGVAL_QUEUE_PAUSED, DEFAULT_REGVAL_QUEUE_PAUSED )) {
            Assert(( ! TEXT("Could not set queue paused registry value") ));
        }

        if (!SetRegistryDword( hKey, REGVAL_JOB_NUMBER, DEFAULT_REGVAL_JOB_NUMBER )) {
            Assert(( ! TEXT("Could not net job number registry value") ));
        }

        if (!SetRegistryDword( hKey, REGVAL_BRANDING, DEFAULT_REGVAL_BRANDING )) {
            Assert(( ! TEXT("Could not set branding registry value") ));
        }

        if (!SetRegistryDword( hKey, REGVAL_USE_DEVICE_TSID, DEFAULT_REGVAL_USEDEVICETSID )) {
            Assert(( ! TEXT("Could not set usedevicetsid registry value") ));
        }

        if (!SetRegistryString( hKey, REGVAL_INBOUND_PROFILE, EMPTY_STRING )) {
            Assert(( ! TEXT("Could not set inbound profile registry value") ));
        }

        if (!SetRegistryDword( hKey, REGVAL_SERVERCP, DEFAULT_REGVAL_SERVERCP )) {
            Assert(( ! TEXT("Could not set servercp registry value") ));
        }

        if (!SetRegistryDword( hKey, REGVAL_STARTCHEAP, DEFAULT_REGVAL_STARTCHEAP )) {
            Assert(( ! TEXT("Could not set startcheap registry value") ));
        }

        if (!SetRegistryDword( hKey, REGVAL_STOPCHEAP, DEFAULT_REGVAL_STOPCHEAP )) {
            Assert(( ! TEXT("Could not set stopcheap registry value") ));
        }

        if (!SetRegistryDword( hKey, REGVAL_ARCHIVEFLAG, DEFAULT_REGVAL_ARCHIVEFLAG )) {
            Assert(( ! TEXT("Could not set archiveflag registry value") ));
        }

        if (!SetRegistryString( hKey, REGVAL_ARCHIVEDIR, DEFAULT_REGVAL_ARCHIVEDIR )) {
            Assert(( ! TEXT("Could not set archive dir registry value") ));
        }

        RegCloseKey( hKey );
    }

    if (InstallMode & INSTALL_NEW) {
        hKeyDev = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_FAX_DEVICES, TRUE, KEY_ALL_ACCESS );
        if (!hKey) {
            Assert(( ! TEXT("Could not open devices registry key") ));
            return FALSE;
        }

        //
        // set the routing mask
        //

        RoutingMask = 0;

        if (WizData.RoutePrint) {
            RoutingMask |= LR_PRINT;
        }

        if (WizData.RouteStore) {
            RoutingMask |= LR_STORE;
        }

        if (WizData.RouteMail) {
            RoutingMask |= LR_INBOX;
        }

        if (WizData.UseDefaultPrinter || WizData.RoutePrinterName[0]) {
            RoutingMask |= LR_PRINT;
        }

        //
        // enumerate the devices and create the registry data
        //

        for (i=0; i<FaxDevices; i++) {

            if ((InstallType & FAX_INSTALL_WORKSTATION) && (!LineInfo[i].Selected)) {
                continue;
            }

            RegCreateFaxDevice(
                hKeyDev,
                LineInfo[i].PermanentLineID,
                LineInfo[i].Rings,
                i+1,
                LineInfo[i].Flags,
                LineInfo[i].DeviceName,
                LineInfo[i].ProviderName,
                WizData.Csid,
                WizData.Tsid,
                RoutingMask,
                WizData.RoutePrinterName,
                WizData.RouteDir,
                WizData.RouteProfile
                );

        }

        RegCloseKey( hKeyDev );
    }

    //
    // create the device providers
    //

    hKeyDev = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_DEVICE_PROVIDER_KEY, TRUE, KEY_ALL_ACCESS );
    if (!hKeyDev) {
        Assert(( ! TEXT("Could not open device provider registry key") ));
        return FALSE;
    }

    CreateDeviceProvider(
        hKeyDev,
        REGKEY_MODEM_PROVIDER,
        REGVAL_MODEM_FRIENDLY_NAME_TEXT,
        REGVAL_MODEM_IMAGE_NAME_TEXT,
        REGVAL_MODEM_PROVIDER_NAME_TEXT
        );

    RegCloseKey( hKeyDev );

    //
    // create the routing extensions
    //

    hKeyDev = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_ROUTING_EXTENSION_KEY, TRUE, KEY_ALL_ACCESS );
    if (!hKeyDev) {
        Assert(( ! TEXT("Could not open routing extension registry key") ));
        return FALSE;
    }

    CreateMicrosoftRoutingExtension(
        hKeyDev,
        REGKEY_ROUTING_EXTENSION,
        REGVAL_ROUTE_FRIENDLY_NAME,
        REGVAL_ROUTE_IMAGE_NAME
        );

    RegCloseKey( hKeyDev );

    //
    // set the user's preferences
    //

    if (InstallMode & INSTALL_NEW) {
        hKey = OpenRegistryKey( HKEY_CURRENT_USER, REGKEY_FAX_SETUP, TRUE, KEY_ALL_ACCESS );
        if (!hKey) {
            Assert(( ! TEXT("Could not open fax setup registry key") ));
            return FALSE;
        }

        if (!SetRegistryStringExpand( hKey, REGVAL_CP_LOCATION, DEFAULT_COVERPAGE_DIR )) {
            Assert(( ! TEXT("Could not set coverpage dir registry value") ));
        }

        if (!SetRegistryString( hKey, REGVAL_CP_EDITOR, COVERPAGE_EDITOR )) {
            Assert(( ! TEXT("Could not set coverpage editor registry value") ));
        }

        if (!SetRegistryString(
                hKey,
                REGVAL_FAX_PROFILE,
                WizData.MapiProfile[0] ? WizData.MapiProfile : DEFAULT_FAX_PROFILE  ))
        {
            Assert(( ! TEXT("Could not set fax profile name registry value") ));
        }

        RegCloseKey( hKey );
    }

    //
    // create the perfmon registry data
    //

    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_FAXPERF, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        Assert(( ! TEXT("Could not open fax perfmon registry key") ));
        return FALSE;
    }

    if (!SetRegistryStringExpand( hKey, REGVAL_OPEN, REGVAL_OPEN_DATA )) {
        Assert(( ! TEXT("Could not set perfmon registry value") ));
    }

    if (!SetRegistryStringExpand( hKey, REGVAL_CLOSE, REGVAL_CLOSE_DATA )) {
        Assert(( ! TEXT("Could not set perfmon registry value") ));
    }

    if (!SetRegistryStringExpand( hKey, REGVAL_COLLECT, REGVAL_COLLECT_DATA )) {
        Assert(( ! TEXT("Could not set perfmon registry value") ));
    }

    if (!SetRegistryStringExpand( hKey, REGVAL_LIBRARY, REGVAL_LIBRARY_DATA )) {
        Assert(( ! TEXT("Could not set perfmon registry value") ));
    }

    RegCloseKey( hKey );

    //
    // load the performance counters
    //

    hNull = CreateFile(
        TEXT("nul"),
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );

    if (hNull == INVALID_HANDLE_VALUE) {
        rVal = GetLastError();
        return FALSE;
    }

    GetStartupInfo( &si );
    si.hStdInput  = hNull;
    si.hStdOutput = hNull;
    si.hStdError  = hNull;
    si.dwFlags    = STARTF_USESTDHANDLES;

    _tcscpy( CmdLine, TEXT("unlodctr fax") );

    rVal = CreateProcess(
        NULL,
        CmdLine,
        NULL,
        NULL,
        TRUE,
        DETACHED_PROCESS,
        NULL,
        NULL,
        &si,
        &pi
        );

    if (!rVal) {
        rVal = GetLastError();
        return FALSE;
    }

    WaitForSingleObject( pi.hProcess, INFINITE );

    if (NtGuiMode) {
        LodCmdLine = ExpandEnvironmentString( TEXT("lodctr %windir%\\system32\\faxperf.ini") );
        if (!LodCmdLine) {
            return FALSE;
        }
    } else {
        LodCmdLine = TEXT("lodctr faxperf.ini");
    }

    _tcscpy( CmdLine, LodCmdLine );

    rVal = CreateProcess(
        NULL,
        CmdLine,
        NULL,
        NULL,
        TRUE,
        DETACHED_PROCESS,
        NULL,
        NtGuiMode ? NULL : SourceDirectory,
        &si,
        &pi
        );

    if (!rVal) {
        rVal = GetLastError();
        return FALSE;
    }

    WaitForSingleObject( pi.hProcess, INFINITE );

    CloseHandle( hNull );

    CreateFileAssociation(
        COVERPAGE_EXTENSION,
        COVERPAGE_ASSOC_NAME,
        COVERPAGE_ASSOC_DESC,
        COVERPAGE_OPEN_COMMAND,
        NULL,
        NULL,
        NULL,
        0
        );

    return TRUE;
}


BOOL
SetClientRegistryData(
    VOID
    )
{
    TCHAR FaxNumber[LT_USER_NAME+LT_AREA_CODE+1];
    HKEY hKey;


    if (InstallMode & INSTALL_NEW) {
        hKey = OpenRegistryKey( HKEY_CURRENT_USER, REGKEY_USERINFO, TRUE, KEY_ALL_ACCESS );
        if (!hKey) {
            Assert(( ! TEXT("Could not open fax user info registry key") ));
            return FALSE;
        }

        if (!SetRegistryString( hKey, REGVAL_FULLNAME, WizData.UserName )) {
            Assert(( ! TEXT("Could not set user name registry value") ));
        }

        if (WizData.AreaCode[0]) {
            _stprintf( FaxNumber, TEXT("(%s) %s"), WizData.AreaCode, WizData.PhoneNumber );
        } else {
            _tcscpy( FaxNumber, WizData.PhoneNumber );
        }

        if (!SetRegistryString( hKey, REGVAL_FAX_NUMBER, FaxNumber )) {
            Assert(( ! TEXT("Could not set fax phone number registry value") ));
        }

        if (!SetRegistryDword( hKey, REGVAL_LAST_COUNTRYID, CurrentCountryId )) {
            Assert(( ! TEXT("Could not set last country id registry value") ));
        }

        if (!SetRegistryDword( hKey, REGVAL_DIAL_AS_ENTERED, 0 )) {
            Assert(( ! TEXT("Could not set dial as entered registry value") ));
        }

        if (!SetRegistryDword( hKey, REGVAL_ALWAYS_ON_TOP, BST_UNCHECKED )) {
            Assert(( ! TEXT("Could not set always on top registry value") ));
        }

        if (!SetRegistryDword( hKey, REGVAL_SOUND_NOTIFICATION, BST_UNCHECKED )) {
            Assert(( ! TEXT("Could not set sound notification registry value") ));
        }

        if (!SetRegistryDword( hKey, REGVAL_ENABLE_MANUAL_ANSWER, BST_UNCHECKED )) {
            Assert(( ! TEXT("Could not set enable manual answer registry value") ));
        }

        if (!SetRegistryDword( hKey, REGVAL_TASKBAR, BST_CHECKED )) {
            Assert(( ! TEXT("Could not set enable manual answer registry value") ));
        }

        if (!SetRegistryDword( hKey, REGVAL_VISUAL_NOTIFICATION, BST_CHECKED )) {
            Assert(( ! TEXT("Could not set visual notification registry value") ));
        }

        if (!SetRegistryString( hKey, REGVAL_LAST_RECAREACODE, CurrentAreaCode )) {
            Assert(( ! TEXT("Could not set area code registry value") ));
        }

        RegCloseKey( hKey );

        hKey = OpenRegistryKey( HKEY_CURRENT_USER, REGKEY_FAX_SETUP, TRUE, KEY_ALL_ACCESS );
        if (!hKey) {
            Assert(( ! TEXT("Could not open fax setup registry key") ));
            return FALSE;
        }

        if (!SetRegistryDword( hKey, REGVAL_FAXINSTALLED, TRUE )) {
            Assert(( ! TEXT("Could not set installed registry value") ));
        }

        if (!SetRegistryDword( hKey, REGVAL_FAXINSTALL_TYPE, FAX_INSTALL_NETWORK_CLIENT )) {
            Assert(( ! TEXT("Could not set install type registry value") ));
        }

        if (!SetRegistryStringExpand( hKey, REGVAL_CP_LOCATION, DEFAULT_COVERPAGE_DIR )) {
            Assert(( ! TEXT("Could not set coverpage dir registry value") ));
        }

        if (!SetRegistryStringExpand( hKey, REGVAL_CP_EDITOR, COVERPAGE_EDITOR )) {
            Assert(( ! TEXT("Could not set coverpage editor registry value") ));
        }

        if (!SetRegistryString(
                hKey,
                REGVAL_FAX_PROFILE,
                WizData.MapiProfile[0] ? WizData.MapiProfile : DEFAULT_FAX_PROFILE ))
        {
            Assert(( ! TEXT("Could not set profile name registry value") ));
        }

        RegCloseKey( hKey );
    }

#ifdef MSFT_FAXVIEW

    hKey = OpenRegistryKey( HKEY_CURRENT_USER, REGKEY_FAXVIEW, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        Assert(( ! TEXT("Could not open fax viewer registry key") ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, REGVAL_LAST_DIR, WizData.RouteDir )) {
        Assert(( ! TEXT("Could not set coverpage editor registry value") ));
    }

    RegCloseKey( hKey );

#endif

    CreateFileAssociation(
        COVERPAGE_EXTENSION,
        COVERPAGE_ASSOC_NAME,
        COVERPAGE_ASSOC_DESC,
        COVERPAGE_OPEN_COMMAND,
        NULL,
        NULL,
        NULL,
        0
        );

#ifdef MSFT_FAXVIEW

    CreateFileAssociation(
        FAXVIEW_EXTENSION,
        FAXVIEW_ASSOC_NAME,
        FAXVIEW_ASSOC_DESC,
        FAXVIEW_OPEN_COMMAND,
        FAXVIEW_PRINT_COMMAND,
        FAXVIEW_PRINTTO_COMMAND,
        FAXVIEW_FILE_NAME,
        FAXVIEW_ICON_INDEX
        );

    CreateFileAssociation(
        FAXVIEW_EXTENSION2,
        FAXVIEW_ASSOC_NAME,
        FAXVIEW_ASSOC_DESC,
        FAXVIEW_OPEN_COMMAND,
        FAXVIEW_PRINT_COMMAND,
        FAXVIEW_PRINTTO_COMMAND,
        FAXVIEW_FILE_NAME,
        FAXVIEW_ICON_INDEX
        );

#endif

#ifdef USE_WORDPAD
    if (IsWordpadInstalled()) {
        ChangeTxtFileAssociation();
    } else if (InstallWordpad()) {
        ChangeTxtFileAssociation();
    }
#endif

    return TRUE;
}

BOOL
SetSoundRegistryData()
{
    HKEY hKey;


    hKey = OpenRegistryKey( HKEY_CURRENT_USER, REGKEY_EVENT_LABEL, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        Assert(( ! TEXT("Could not open event label registry key") ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, NULL, TEXT("Incoming Fax") )) {
        Assert(( ! TEXT("Could not set event label registry value") ));
    }

    RegCloseKey( hKey );

    hKey = OpenRegistryKey( HKEY_CURRENT_USER, REGKEY_FAXSTAT, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        Assert(( ! TEXT("Could not open faxstat registry key") ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, NULL, TEXT("Fax Monitor") )) {
        Assert(( ! TEXT("Could not set faxstat registry value") ));
    }

    RegCloseKey( hKey );

    hKey = OpenRegistryKey( HKEY_CURRENT_USER, REGKEY_SCHEMES_DEFAULT, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        Assert(( ! TEXT("Could not open default sound registry key") ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, NULL, TEXT("ringin.wav") )) {
        Assert(( ! TEXT("Could not set default sound registry value") ));
    }

    RegCloseKey( hKey );

    hKey = OpenRegistryKey( HKEY_CURRENT_USER, REGKEY_SCHEMES_CURRENT, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        Assert(( ! TEXT("Could not open current sound registry key") ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, NULL, TEXT("ringin.wav") )) {
        Assert(( ! TEXT("Could not set current sound registry value") ));
    }

    RegCloseKey( hKey );
}

BOOL
GetUserInformation(
    LPTSTR *UserName,
    LPTSTR *FaxNumber,
    LPTSTR *AreaCode
    )
{
    HKEY hKey;


    hKey = OpenRegistryKey( HKEY_CURRENT_USER, REGKEY_USERINFO, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        Assert(( ! TEXT("Could not open fax user info registry key") ));
        return FALSE;
    }

    *UserName = GetRegistryString( hKey, REGVAL_FULLNAME, EMPTY_STRING );
    if (!*UserName) {
        Assert(( ! TEXT("Could not query user name registry value") ));
    }

    *FaxNumber = GetRegistryString( hKey, REGVAL_FAX_NUMBER, EMPTY_STRING );
    if (!*FaxNumber) {
        Assert(( ! TEXT("Could not query fax number registry value") ));
    }

    *AreaCode = MemAlloc( (LT_AREA_CODE+1) * sizeof(TCHAR) );

    if (*AreaCode && (*FaxNumber)[0] == TEXT('(')) {
        LPTSTR p = _tcschr( *FaxNumber, TEXT('-') );
        if (p) {
            *p = 0;
            _tcscpy( *AreaCode, &(*FaxNumber)[1] );
            *p = TEXT('-');
        }
    }

    RegCloseKey( hKey );

    return TRUE;
}


BOOL
GetInstallationInfo(
    LPDWORD Installed,
    LPDWORD InstallType,
    LPDWORD InstalledPlatforms,
    LPDWORD Enabled
    )
{
    HKEY hKey;
    LONG rVal;


    if (Installed) {
        *Installed = 0;
    }
    if (InstallType) {
        *InstallType = 0;
    }
    if (InstalledPlatforms) {
        *InstalledPlatforms = 0;
    }

    rVal = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        REGKEY_FAX_SETUP,
        &hKey
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not open setup registry key, ec=0x%08x"), rVal ));
        return FALSE;
    }

    if (Installed) {
        *Installed = GetRegistryDword( hKey, REGVAL_FAXINSTALLED );
    }
    if (InstallType) {
        *InstallType = GetRegistryDword( hKey, REGVAL_FAXINSTALL_TYPE );
    }

    if (InstalledPlatforms) {
        *InstalledPlatforms = GetRegistryDword( hKey, REGVAL_FAXINSTALLED_PLATFORMS );
    }

    RegCloseKey( hKey );

    return TRUE;
}


BOOL
SetInstalledFlag(
    BOOL Installed
    )
{
    HKEY hKey;
    HKEY hKeySetup;
    DWORD RoutingMask;


    //
    // set the routing mask
    //

    RoutingMask = 0;

    if (WizData.RoutePrint) {
        RoutingMask |= LR_PRINT;
    }

    if (WizData.RouteStore) {
        RoutingMask |= LR_STORE;
    }

    if (WizData.RouteMail) {
        RoutingMask |= LR_INBOX;
    }

    if (WizData.UseDefaultPrinter || WizData.RoutePrinterName[0]) {
        RoutingMask |= LR_PRINT;
    }

    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_FAX_SETUP, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        Assert(( ! TEXT("Could not open setup registry key") ));
        return FALSE;
    }

    if (!SetRegistryDword( hKey, REGVAL_FAXINSTALLED, Installed )) {
        Assert(( ! TEXT("Could not set installed registry value") ));
    }

    hKeySetup = OpenRegistryKey( hKey, REGKEY_FAX_SETUP_ORIG, TRUE, KEY_ALL_ACCESS );
    if (!hKeySetup) {
        Assert(( ! TEXT("Could not open fax setup registry key") ));
        return FALSE;
    }

    if (!SetRegistryString( hKeySetup, REGVAL_ROUTING_PRINTER, WizData.RoutePrinterName )) {
        Assert(( ! TEXT("Could not set printer name registry value") ));
    }

    if (!SetRegistryString( hKeySetup, REGVAL_ROUTING_DIR, WizData.RouteDir )) {
        Assert(( ! TEXT("Could not set routing dir registry value") ));
    }

    if (!SetRegistryString( hKeySetup, REGVAL_ROUTING_PROFILE, WizData.RouteProfile )) {
        Assert(( ! TEXT("Could not set routing profile name registry value") ));
    }

    if (!SetRegistryString( hKeySetup, REGVAL_ROUTING_CSID, WizData.Csid )) {
        Assert(( ! TEXT("Could not set routing csid registry value") ));
    }

    if (!SetRegistryString( hKeySetup, REGVAL_ROUTING_TSID, WizData.Tsid )) {
        Assert(( ! TEXT("Could not set routing tsid registry value") ));
    }

    if (!SetRegistryDword( hKeySetup, REGVAL_ROUTING_MASK, RoutingMask )) {
        Assert(( ! TEXT("Could not set routing mask registry value") ));
    }

    if (!SetRegistryDword( hKeySetup, REGVAL_RINGS, 2 )) {
        Assert(( ! TEXT("Could not set rings registry value") ));
    }

    RegCloseKey( hKeySetup );
    RegCloseKey( hKey );

    return TRUE;
}


BOOL
SetInstallType(
    DWORD InstallType
    )
{
    HKEY hKey;


    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_FAX_SETUP, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        Assert(( ! TEXT("Could not open setup registry key") ));
        return FALSE;
    }

    InstallType |= GetRegistryDword( hKey, REGVAL_FAXINSTALL_TYPE );

    if (!SetRegistryDword( hKey, REGVAL_FAXINSTALL_TYPE, InstallType )) {
        Assert(( ! TEXT("Could not set install type registry value") ));
    }

    RegCloseKey( hKey );

    return TRUE;
}


BOOL
SetInstalledPlatforms(
    DWORD PlatformsMask
    )
{
    HKEY hKey;


    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_FAX_SETUP, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        Assert(( ! TEXT("Could not open setup registry key") ));
        return FALSE;
    }

    PlatformsMask |= GetRegistryDword( hKey, REGVAL_FAXINSTALLED_PLATFORMS );

    if (!SetRegistryDword( hKey, REGVAL_FAXINSTALLED_PLATFORMS, PlatformsMask )) {
        Assert(( ! TEXT("Could not set install type registry value") ));
    }

    RegCloseKey( hKey );

    return TRUE;
}


BOOL
DeleteRegistryTree(
    HKEY hKey,
    LPTSTR SubKey
    )
{
    LONG Rval;
    HKEY hKeyCur;
    TCHAR KeyName[256];
    DWORD KeyNameSize;
    FILETIME FileTime;
    DWORD KeyCount;


    Rval = RegOpenKeyEx( hKey, SubKey, 0, KEY_ALL_ACCESS, &hKeyCur );
    if (Rval != ERROR_SUCCESS) {
        return FALSE;
    }

    KeyCount = GetSubKeyCount( hKeyCur );
    if (KeyCount == 0) {
        RegCloseKey( hKeyCur );
        RegDeleteKey( hKey, SubKey );
        return TRUE;
    }

    while( TRUE ) {
        KeyNameSize = sizeof(KeyName);
        Rval = RegEnumKeyEx( hKeyCur, 0, KeyName, &KeyNameSize, 0, NULL, NULL, &FileTime );
        if (Rval == ERROR_NO_MORE_ITEMS) {
            break;
        } else if (Rval != ERROR_SUCCESS) {
            RegCloseKey( hKeyCur );
            return FALSE;
        }

        if (!DeleteRegistryTree( hKeyCur, KeyName )) {
            RegCloseKey( hKeyCur );
            return FALSE;
        }
    }

    RegCloseKey( hKeyCur );
    RegDeleteKey( hKey, SubKey );

    return TRUE;
}


BOOL
DeleteFaxRegistryData(
    VOID
    )
{
    LONG  Rval;
    HKEY  hKeyCur;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    HANDLE hNull;
    TCHAR CmdLine[128];


    DeleteRegistryTree( HKEY_LOCAL_MACHINE, REGKEY_FAXSERVER       );
    DeleteRegistryTree( HKEY_CURRENT_USER,  REGKEY_FAXSERVER       );
    DeleteRegistryTree( HKEY_LOCAL_MACHINE, REGKEY_SETUP_UNINSTALL );
    DeleteRegistryTree( HKEY_CURRENT_USER,  REGKEY_EVENT_LABEL     );
    DeleteRegistryTree( HKEY_CURRENT_USER,  REGKEY_FAXSTAT         );

#ifdef MSFT_FAXVIEW

    DeleteRegistryTree( HKEY_CLASSES_ROOT,  FAXVIEW_ASSOC_NAME     );

#endif

    Rval = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT( "Software\\Microsoft\\Exchange\\Client\\Extensions" ),
            0,
            KEY_ALL_ACCESS,
            &hKeyCur
            );
    if (Rval == ERROR_SUCCESS) {

        RegDeleteValue( hKeyCur, TEXT( EXCHANGE_CLIENT_EXT_NAME ) );

        RegCloseKey( hKeyCur );
    }

#ifdef MSFT_FAXVIEW

    ResetFileAssociation( FAXVIEW_EXTENSION,  WANGIMAGE_ASSOC_NAME );
    ResetFileAssociation( FAXVIEW_EXTENSION2, WANGIMAGE_ASSOC_NAME );

#endif

    //
    // unload the performance counters
    //

    hNull = CreateFile(
        TEXT("nul"),
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );
    if (hNull != INVALID_HANDLE_VALUE) {

        GetStartupInfo( &si );
        si.hStdInput  = hNull;
        si.hStdOutput = hNull;
        si.hStdError  = hNull;
        si.dwFlags    = STARTF_USESTDHANDLES;

        _tcscpy( CmdLine, TEXT("unlodctr fax") );

        if (CreateProcess(
            NULL,
            CmdLine,
            NULL,
            NULL,
            TRUE,
            DETACHED_PROCESS,
            NULL,
            NULL,
            &si,
            &pi
            ))
        {
            WaitForSingleObject( pi.hProcess, INFINITE );
            CloseHandle( pi.hThread );
            CloseHandle( pi.hProcess );
        }

        CloseHandle( hNull );
    }

    return TRUE;
}


VOID
DeleteModemRegistryKey(
    VOID
    )
{
    HKEY hKeyDev;
    INT rVal;
    DWORD MaxSubKeyLen;
    LPTSTR KeyNameBuf;
    DWORD i;
    DWORD SubKeyLen;
    DWORD KeyNameLen;

    rVal = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        REGKEY_FAX_DEVICES,
        0,
        KEY_ALL_ACCESS,
        &hKeyDev
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not open devices registry key, ec=0x%08x"), rVal ));
        return;
    }

    MaxSubKeyLen = GetMaxSubKeyLen( hKeyDev );
    if (!MaxSubKeyLen) {
        return;
    }

    KeyNameLen =
        MaxSubKeyLen +
        sizeof(TCHAR) +
        _tcslen( REGKEY_MODEM ) +
        sizeof(TCHAR) +
        32;

    KeyNameBuf = MemAlloc( KeyNameLen );

    if (KeyNameBuf == NULL) {
        DebugPrint(( TEXT("DeleteModemRegistryKey: MemAlloc failed" ) ));
        return;
    }

    rVal = ERROR_SUCCESS;
    i = 0;

    while (TRUE) {

        SubKeyLen = MaxSubKeyLen + sizeof(TCHAR);

        rVal = RegEnumKeyEx(
                    hKeyDev,
                    i++,
                    KeyNameBuf,
                    &SubKeyLen,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );
        if (rVal != ERROR_SUCCESS) {
            break;
        }

        _stprintf( &KeyNameBuf[SubKeyLen], TEXT( "\\%s") , REGKEY_MODEM );

        DeleteRegistryTree( hKeyDev, KeyNameBuf );

    };

    RegCloseKey( hKeyDev );
}


BOOL
SetUnInstallInfo(
    VOID
    )
{
    HKEY hKey;
    TCHAR UninstallString[MAX_PATH*2];


    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SETUP_UNINSTALL, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        Assert(( ! TEXT("Could not open setup uninstall registry key") ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, REGVAL_DISPLAY_NAME, GetProductName() )) {
        Assert(( ! TEXT("Could not set display name registry value") ));
    }

    ExpandEnvironmentStrings( UNINSTALL_STRING, UninstallString, sizeof(UninstallString) );

    if (!SetRegistryString( hKey, REGVAL_UNINSTALL_STRING, UninstallString )) {
        Assert(( ! TEXT("Could not set display name registry value") ));
    }

    RegCloseKey( hKey );

    return TRUE;
}


BOOL
DeleteUnInstallInfo(
    VOID
    )
{
    RegDeleteKey( HKEY_LOCAL_MACHINE, REGKEY_SETUP_UNINSTALL );
    return TRUE;
}


BOOL
ResetFileAssociation(
    LPWSTR FileExtension,
    LPWSTR FileAssociationName
    )
{
    HKEY hKey;


    hKey = OpenRegistryKey( HKEY_CLASSES_ROOT, FileExtension, TRUE, KEY_ALL_ACCESS );
    if (!hKey) {
        Assert(( ! TEXT("Could not open file extension registry key") ));
        return FALSE;
    }

    if (!SetRegistryString( hKey, NULL, FileAssociationName )) {
        Assert(( ! TEXT("Could not set file association name registry value") ));
    }

    RegCloseKey( hKey );

    return TRUE;
}


BOOL
CreateFileAssociation(
    LPWSTR FileExtension,
    LPWSTR FileAssociationName,
    LPWSTR FileAssociationDescription,
    LPWSTR OpenCommand,
    LPWSTR PrintCommand,
    LPWSTR PrintToCommand,
    LPWSTR FileName,
    DWORD  IconIndex
    )
{
    LONG rVal = 0;
    HKEY hKey = NULL;
    HKEY hKeyOpen = NULL;
    HKEY hKeyPrint = NULL;
    HKEY hKeyPrintTo = NULL;
    HKEY hKeyIcon = NULL;
    DWORD Disposition = 0;
    WCHAR Buffer[MAX_PATH*2];


    rVal = RegCreateKeyEx(
        HKEY_CLASSES_ROOT,
        FileExtension,
        0,
        NULL,
        0,
        KEY_ALL_ACCESS,
        NULL,
        &hKey,
        &Disposition
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    rVal = RegSetValueEx(
        hKey,
        NULL,
        0,
        REG_SZ,
        (LPBYTE) FileAssociationName,
        StringSize( FileAssociationName )
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    RegCloseKey( hKey );

    rVal = RegCreateKeyEx(
        HKEY_CLASSES_ROOT,
        FileAssociationName,
        0,
        NULL,
        0,
        KEY_ALL_ACCESS,
        NULL,
        &hKey,
        &Disposition
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    rVal = RegSetValueEx(
        hKey,
        NULL,
        0,
        REG_SZ,
        (LPBYTE) FileAssociationDescription,
        StringSize( FileAssociationDescription )
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    rVal = RegCreateKeyEx(
        hKey,
        L"Shell\\Open\\Command",
        0,
        NULL,
        0,
        KEY_ALL_ACCESS,
        NULL,
        &hKeyOpen,
        &Disposition
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    rVal = RegSetValueEx(
        hKeyOpen,
        NULL,
        0,
        REG_EXPAND_SZ,
        (LPBYTE) OpenCommand,
        StringSize( OpenCommand )
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    if (PrintCommand) {
        rVal = RegCreateKeyEx(
            hKey,
            L"Shell\\Print\\Command",
            0,
            NULL,
            0,
            KEY_ALL_ACCESS,
            NULL,
            &hKeyPrint,
            &Disposition
            );
        if (rVal != ERROR_SUCCESS) {
            goto exit;
        }

        rVal = RegSetValueEx(
            hKeyPrint,
            NULL,
            0,
            REG_EXPAND_SZ,
            (LPBYTE) PrintCommand,
            StringSize( PrintCommand )
            );
        if (rVal != ERROR_SUCCESS) {
            goto exit;
        }
    }

    if (PrintToCommand) {
        rVal = RegCreateKeyEx(
            hKey,
            L"Shell\\Printto\\Command",
            0,
            NULL,
            0,
            KEY_ALL_ACCESS,
            NULL,
            &hKeyPrintTo,
            &Disposition
            );
        if (rVal != ERROR_SUCCESS) {
            goto exit;
        }

        rVal = RegSetValueEx(
            hKeyPrintTo,
            NULL,
            0,
            REG_EXPAND_SZ,
            (LPBYTE) PrintToCommand,
            StringSize( PrintToCommand )
            );
        if (rVal != ERROR_SUCCESS) {
            goto exit;
        }
    }

    if (FileName) {
        rVal = RegCreateKeyEx(
            hKey,
            L"DefaultIcon",
            0,
            NULL,
            0,
            KEY_ALL_ACCESS,
            NULL,
            &hKeyIcon,
            &Disposition
            );
        if (rVal != ERROR_SUCCESS) {
            goto exit;
        }

        wsprintf( Buffer, L"%s,%d", FileName, IconIndex );

        rVal = RegSetValueEx(
            hKeyIcon,
            NULL,
            0,
            REG_EXPAND_SZ,
            (LPBYTE) Buffer,
            StringSize( Buffer )
            );
        if (rVal != ERROR_SUCCESS) {
            goto exit;
        }
    }

exit:
    RegCloseKey( hKey );
    RegCloseKey( hKeyOpen );
    RegCloseKey( hKeyPrint );
    RegCloseKey( hKeyPrintTo );
    RegCloseKey( hKeyIcon );

    return rVal == ERROR_SUCCESS;
}


BOOL
IsWordpadInstalled(
    VOID
    )
{
    HKEY hKey;
    LONG rVal;
    DWORD RegType;
    DWORD RegSize;
    TCHAR Data[16];


    rVal = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        REGKEY_WORDPAD,
        &hKey
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not open wordpad registry key, ec=0x%08x"), rVal ));
        return FALSE;
    }

    RegSize = sizeof(Data);

    rVal = RegQueryValueEx(
        hKey,
        REGVAL_WP_INSTALLED,
        0,
        &RegType,
        (LPBYTE) Data,
        &RegSize
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not query wordpad installed registry value, ec=0x%08x"), rVal ));
        Data[0] = 0;
    }

    RegCloseKey( hKey );

    if (_tcscmp( Data, TEXT("1") ) == 0) {
        return TRUE;
    }

    return FALSE;
}


BOOL
InstallWordpad(
    VOID
    )
{
    HKEY hKey;
    LONG rVal;
    DWORD RegType;
    DWORD RegSize;
    TCHAR InfName[32];
    TCHAR SectionName[32];
    TCHAR Command[256];
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    DWORD ExitCode;


    rVal = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        REGKEY_WORDPAD,
        &hKey
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not open wordpad registry key, ec=0x%08x"), rVal ));
        return FALSE;
    }

    RegSize = sizeof(InfName);
    rVal = RegQueryValueEx(
        hKey,
        REGVAL_WP_INF,
        0,
        &RegType,
        (LPBYTE) InfName,
        &RegSize
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not query wordpad inf name registry value, ec=0x%08x"), rVal ));
        InfName[0] = 0;
    }

    RegSize = sizeof(SectionName);
    rVal = RegQueryValueEx(
        hKey,
        REGVAL_WP_SECTION,
        0,
        &RegType,
        (LPBYTE) SectionName,
        &RegSize
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not query wordpad inf name registry value, ec=0x%08x"), rVal ));
        SectionName[0] = 0;
    }

    RegCloseKey( hKey );

    if (InfName[0] == 0 || SectionName[0] == 0) {
        return FALSE;
    }

    _stprintf( Command, RUNDLL32_INF_INSTALL_CMD, SectionName, InfName );

    GetStartupInfo( &si );

    rVal = CreateProcess(
        NULL,
        Command,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &si,
        &pi
        );

    if (rVal) {
        WaitForSingleObject( pi.hProcess, INFINITE );
        if (GetExitCodeProcess( pi.hProcess, &ExitCode ) && ExitCode == 0) {
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
ChangeTxtFileAssociation(
    VOID
    )
{
    LONG rVal = 0;
    HKEY hKey = NULL;
    HKEY hKeyCmd = NULL;
    DWORD Disposition = 0;


    DeleteRegistryTree( HKEY_CLASSES_ROOT, TEXT("txtfile\\shell") );

    rVal = RegOpenKey(
        HKEY_CLASSES_ROOT,
        TEXT("txtfile"),
        &hKey
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not open wordpad registry key, ec=0x%08x"), rVal ));
        return FALSE;
    }

    rVal = RegCreateKeyEx(
        hKey,
        TEXT("shell\\open\\command"),
        0,
        NULL,
        0,
        KEY_ALL_ACCESS,
        NULL,
        &hKeyCmd,
        &Disposition
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    rVal = RegSetValueEx(
        hKeyCmd,
        NULL,
        0,
        REG_EXPAND_SZ,
        (LPBYTE) WORDPAD_OPEN_CMD,
        StringSize( WORDPAD_OPEN_CMD )
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    RegCloseKey( hKeyCmd );

    rVal = RegCreateKeyEx(
        hKey,
        TEXT("shell\\print\\command"),
        0,
        NULL,
        0,
        KEY_ALL_ACCESS,
        NULL,
        &hKeyCmd,
        &Disposition
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    rVal = RegSetValueEx(
        hKeyCmd,
        NULL,
        0,
        REG_EXPAND_SZ,
        (LPBYTE) WORDPAD_PRINT_CMD,
        StringSize( WORDPAD_PRINT_CMD )
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    RegCloseKey( hKeyCmd );

    rVal = RegCreateKeyEx(
        hKey,
        TEXT("shell\\printto\\command"),
        0,
        NULL,
        0,
        KEY_ALL_ACCESS,
        NULL,
        &hKeyCmd,
        &Disposition
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    rVal = RegSetValueEx(
        hKeyCmd,
        NULL,
        0,
        REG_EXPAND_SZ,
        (LPBYTE) WORDPAD_PRINTTO_CMD,
        StringSize( WORDPAD_PRINTTO_CMD )
        );
    if (rVal != ERROR_SUCCESS) {
        goto exit;
    }

    RegCloseKey( hKeyCmd );

exit:
    RegCloseKey( hKey );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\service.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    service.c

Abstract:

    This file provides access to the service control
    manager for starting, stopping, adding, and removing
    services.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop



BOOL
InstallFaxService(
    BOOL UseLocalSystem,
    BOOL DemandStart,
    LPTSTR AccountName,
    LPTSTR Password
    )

/*++

Routine Description:

    Service installation function.  This function just
    calls the service controller to install the FAX service.
    It is required that the FAX service run in the context
    of a user so that the service can access MAPI, files on
    disk, the network, etc.

Arguments:

    UseLocalSystem  - Don't use the accountname/password, use LocalSystem
    Username        - User name where the service runs.
    Password        - Password for the user name.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/

{
    SC_HANDLE       hSvcMgr;
    SC_HANDLE       hService;
    SERVICE_STATUS  Status;
    DWORD           ErrorCode;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        DebugPrint(( TEXT("could not open service manager: error code = %u"), GetLastError() ));
        return FALSE;
    }

    hService = OpenService(
        hSvcMgr,
        FAX_SERVICE_NAME,
        SERVICE_ALL_ACCESS
        );

    if (hService) {

        //
        // the service exists, lets be sure that it is stopped
        //

        ControlService(
            hService,
            SERVICE_CONTROL_STOP,
            &Status
            );

        DeleteService( hService );

        CloseServiceHandle( hService );

    }

    if (!UseLocalSystem) {
        ErrorCode = SetServiceSecurity( AccountName );
        if (ErrorCode) {
            DebugPrint(( TEXT("Could not grant access rights to [%s] : error code = 0x%08x"), AccountName, ErrorCode ));
            SetLastError( ERROR_SERVICE_LOGON_FAILED );
            return FALSE;
        }
    }

    hService = CreateService(
        hSvcMgr,
        FAX_SERVICE_NAME,
        FAX_SERVICE_DISPLAY_NAME,
        SERVICE_ALL_ACCESS,
        SERVICE_WIN32_OWN_PROCESS,
        DemandStart ? SERVICE_DEMAND_START : SERVICE_AUTO_START,
        SERVICE_ERROR_NORMAL,
        FAX_SERVICE_IMAGE_NAME,
        NULL,
        NULL,
        FAX_SERVICE_DEPENDENCY,
        UseLocalSystem ? NULL : AccountName,
        UseLocalSystem ? NULL : Password
        );
    if (!hService) {
        DebugPrint(( TEXT("Could not create fax service: error code = %u"), GetLastError() ));
        return FALSE;
    }

    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return TRUE;
}


DWORD
StartTheService(
    LPTSTR ServiceName
    )
{
    DWORD                   rVal = 0;
    SC_HANDLE               hSvcMgr = NULL;
    SC_HANDLE               hService = NULL;
    SERVICE_STATUS          Status;
    DWORD                   OldCheckPoint = 0;
    DWORD                   i = 0;



    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        rVal = GetLastError();
        DebugPrint(( TEXT("could not open service manager: error code = %u"), rVal ));
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        rVal = GetLastError();
        DebugPrint((
            TEXT("could not open the %s service: error code = %u"),
            ServiceName,
            rVal
            ));
        goto exit;
    }

    //
    // the service exists, lets start it
    //

    if (!StartService( hService, 0, NULL )) {
        rVal = GetLastError();
        DebugPrint((
            TEXT("could not start the %s service: error code = %u"),
            ServiceName,
            rVal
            ));
        goto exit;
    }

    if (!QueryServiceStatus( hService, &Status )) {
        rVal = GetLastError();
        DebugPrint((
            TEXT("could not query status for the %s service: error code = %u"),
            ServiceName,
            rVal
            ));
        goto exit;
    }
#if 0
    while (Status.dwCurrentState != SERVICE_RUNNING) {

        OldCheckPoint = Status.dwCheckPoint;

        Sleep( Status.dwWaitHint );

        if (!QueryServiceStatus( hService, &Status )) {
            break;
        }

        if (OldCheckPoint >= Status.dwCheckPoint) {
            break;
        }

    }
#endif
    while (Status.dwCurrentState != SERVICE_RUNNING) {
        Sleep( 1000 );
        if (!QueryServiceStatus( hService, &Status )) {
            break;
        }
        i += 1;
        if (i > 60) {
            break;
        }
    }

    if (Status.dwCurrentState != SERVICE_RUNNING) {
        rVal = GetLastError();
        DebugPrint((
            TEXT("could not start the %s service: error code = %u"),
            ServiceName,
            rVal
            ));
        goto exit;
    }

    rVal = ERROR_SUCCESS;

exit:

    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}


DWORD
MyStartService(
    LPTSTR ServiceName
    )
{
    DWORD                   rVal = 0;
    SC_HANDLE               hSvcMgr = NULL;
    SC_HANDLE               hService = NULL;
    LPENUM_SERVICE_STATUS   EnumServiceStatus = NULL;



    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        rVal = GetLastError();
        DebugPrint(( TEXT("could not open service manager: error code = %u"), rVal ));
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        rVal = GetLastError();
        DebugPrint((
            TEXT("could not open the %s service: error code = %u"),
            ServiceName,
            rVal
            ));
        goto exit;
    }

    rVal = StartTheService( ServiceName );

exit:

    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}


BOOL
StopTheService(
    LPTSTR ServiceName
    )
{
    DWORD           rVal = 0;
    SC_HANDLE       hSvcMgr;
    SC_HANDLE       hService;
    SERVICE_STATUS  Status;
    DWORD           OldCheckPoint;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        DebugPrint(( TEXT("could not open service manager: error code = %u"), GetLastError() ));
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        DebugPrint((
            TEXT("could not open the %s service: error code = %u"),
            ServiceName,
            GetLastError()
            ));
        goto exit;
    }

    //
    // the service exists, lets stop it
    //

    ControlService(
        hService,
        SERVICE_CONTROL_STOP,
        &Status
        );

    if (!QueryServiceStatus( hService, &Status )) {
        DebugPrint((
            TEXT("could not query status for the %s service: error code = %u"),
            ServiceName,
            GetLastError()
            ));
        goto exit;
    }

    while (Status.dwCurrentState == SERVICE_RUNNING) {

        OldCheckPoint = Status.dwCheckPoint;

        Sleep( Status.dwWaitHint );

        if (!QueryServiceStatus( hService, &Status )) {
            break;
        }

        if (OldCheckPoint >= Status.dwCheckPoint) {
            break;
        }

    }

    if (Status.dwCurrentState == SERVICE_RUNNING) {
        DebugPrint((
            TEXT("could not stop the %s service: error code = %u"),
            ServiceName,
            GetLastError()
            ));
        goto exit;
    }

    rVal = TRUE;


exit:

    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}


BOOL
MyStopService(
    LPTSTR ServiceName
    )
{
    DWORD                   rVal = 0;
    SC_HANDLE               hSvcMgr;
    SC_HANDLE               hService;
    LPENUM_SERVICE_STATUS   EnumServiceStatus = NULL;
    DWORD                   BytesNeeded;
    DWORD                   ServiceCount;
    DWORD                   i;



    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        DebugPrint(( TEXT("could not open service manager: error code = %u"), GetLastError() ));
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        DebugPrint((
            TEXT("could not open the %s service: error code = %u"),
            ServiceName,
            GetLastError()
            ));
        goto exit;
    }

    if (!EnumDependentServices( hService, SERVICE_ACTIVE, NULL, 0, &BytesNeeded, &ServiceCount )) {
        if (GetLastError() != ERROR_MORE_DATA) {
            DebugPrint(( TEXT("could not enumerate dependent services, ec=%d"), GetLastError() ));
            goto exit;
        }
        EnumServiceStatus = (LPENUM_SERVICE_STATUS) MemAlloc( BytesNeeded );
        if (!EnumServiceStatus) {
            DebugPrint(( TEXT("could not allocate memory for EnumDependentServices()") ));
            goto exit;
        }
    }

    if (!EnumDependentServices( hService, SERVICE_ACTIVE, EnumServiceStatus, BytesNeeded, &BytesNeeded, &ServiceCount )) {
        DebugPrint(( TEXT("could not enumerate dependent services, ec=%d"), GetLastError() ));
        goto exit;
    }

    if (ServiceCount) {
        for (i=0; i<ServiceCount; i++) {
            StopTheService( EnumServiceStatus[i].lpServiceName );
        }
    }

    StopTheService( ServiceName );

exit:

    if (EnumServiceStatus) {
        MemFree( EnumServiceStatus );
    }

    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}


DWORD
StartFaxService(
    VOID
    )
{
    HANDLE          FaxServerEvent;
    DWORD           Rval;
    STARTUPINFO     si;
    PROCESS_INFORMATION pi;

    Rval = MyStartService( FAX_SERVICE_NAME );
    if (Rval != ERROR_SUCCESS) {
        return Rval;
    }

    FaxServerEvent = OpenEvent( SYNCHRONIZE, FALSE, TEXT("FaxServerEvent") );
    if (!FaxServerEvent) {
        Rval = GetLastError();
        DebugPrint(( TEXT("could not open a handle to the fax service event") ));
        return Rval;
    }

    //
    // wait for the server to signal us that the service
    // is REALLY ready to use
    //

    if (WaitForSingleObject( FaxServerEvent, 1000 * 60 ) == WAIT_TIMEOUT) {
        Rval = ERROR_SERVICE_REQUEST_TIMEOUT;
    } else {
        Rval = ERROR_SUCCESS;
    }

    CloseHandle( FaxServerEvent );

    if ((InstallType & FAX_INSTALL_WORKSTATION) && !(InstallMode & INSTALL_UPGRADE)) {

        TCHAR Command[256];
        TCHAR SysDir[256];
        BOOL ProcCreated;


        ExpandEnvironmentStrings( TEXT( "%windir%\\system32" ), SysDir, 256 );

        _stprintf( Command, TEXT( "%s\\%s" ), SysDir, FAX_MONITOR_CMD );

        GetStartupInfo( &si );

        ProcCreated = CreateProcess(
                    NULL,
                    Command,
                    NULL,
                    NULL,
                    FALSE,
                    0,
                    NULL,
                    SysDir,
                    &si,
                    &pi
                    );

        if (ProcCreated) {

            Rval = ERROR_SUCCESS;

        } else {

            Rval = GetLastError();

            DebugPrint(( TEXT( "Could not start faxstat.exe" ) ));
        }
    }

    return Rval;
}


BOOL
StopFaxService(
    VOID
    )
{
    return MyStopService( FAX_SERVICE_NAME );
}


BOOL
StartSpoolerService(
    VOID
    )
{
    if (!MyStartService( TEXT("Spooler") )) {
        return FALSE;
    }

    //
    // the spooler lies about it's starting state, but
    // doesn't provide a way to synchronize the completion
    // of it starting.  so we just wait for some random time period.
    //

    Sleep( 1000 * 7 );

    return TRUE;
}


BOOL
StopSpoolerService(
    VOID
    )
{
    return MyStopService( TEXT("Spooler") );
}


BOOL
SetServiceDependency(
    LPTSTR ServiceName,
    LPTSTR DependentServiceName
    )
{
    BOOL            rVal = FALSE;
    SC_HANDLE       hSvcMgr;
    SC_HANDLE       hService;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        DebugPrint(( TEXT("could not open service manager: error code = %u"), GetLastError() ));
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        DebugPrint((
            TEXT("could not open the %s service: error code = %u"),
            ServiceName,
            GetLastError()
            ));
        goto exit;
    }


    if (!ChangeServiceConfig(
        hService,               // handle to service
        SERVICE_NO_CHANGE,      // type of service
        SERVICE_NO_CHANGE,      // when to start service
        SERVICE_NO_CHANGE,      // severity if service fails to start
        NULL,                   // pointer to service binary file name
        NULL,                   // pointer to load ordering group name
        NULL,                   // pointer to variable to get tag identifier
        DependentServiceName,   // pointer to array of dependency names
        NULL,                   // pointer to account name of service
        NULL,                   // pointer to password for service account
        NULL                    // pointer to display name
        )) {
        DebugPrint(( TEXT("could not open change service configuration, ec=%d"), GetLastError() ));
        goto exit;
    }

    rVal = TRUE;

exit:
    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}


BOOL
SetServiceStart(
    LPTSTR ServiceName,
    DWORD StartType
    )
{
    BOOL            rVal = FALSE;
    SC_HANDLE       hSvcMgr;
    SC_HANDLE       hService;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        DebugPrint(( TEXT("could not open service manager: error code = %u"), GetLastError() ));
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        DebugPrint((
            TEXT("could not open the %s service: error code = %u"),
            ServiceName,
            GetLastError()
            ));
        goto exit;
    }


    if (!ChangeServiceConfig(
        hService,                        // handle to service
        SERVICE_NO_CHANGE,               // type of service
        StartType,                       // when to start service
        SERVICE_NO_CHANGE,               // severity if service fails to start
        NULL,                            // pointer to service binary file name
        NULL,                            // pointer to load ordering group name
        NULL,                            // pointer to variable to get tag identifier
        NULL,                            // pointer to array of dependency names
        NULL,                            // pointer to account name of service
        NULL,                            // pointer to password for service account
        NULL                             // pointer to display name
        ))
    {
        DebugPrint(( TEXT("could not open change service configuration, ec=%d"), GetLastError() ));
        goto exit;
    }

    rVal = TRUE;

exit:
    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}


BOOL
SetServiceAccount(
    LPTSTR ServiceName,
    PSECURITY_INFO SecurityInfo
    )
{
    BOOL            rVal = FALSE;
    SC_HANDLE       hSvcMgr;
    SC_HANDLE       hService;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        DebugPrint(( TEXT("could not open service manager: error code = %u"), GetLastError() ));
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        DebugPrint((
            TEXT("could not open the %s service: error code = %u"),
            ServiceName,
            GetLastError()
            ));
        goto exit;
    }


    if (!ChangeServiceConfig(
        hService,                        // handle to service
        SERVICE_NO_CHANGE,               // type of service
        SERVICE_NO_CHANGE,               // when to start service
        SERVICE_NO_CHANGE,               // severity if service fails to start
        NULL,                            // pointer to service binary file name
        NULL,                            // pointer to load ordering group name
        NULL,                            // pointer to variable to get tag identifier
        NULL,                            // pointer to array of dependency names
        SecurityInfo->AccountName,       // pointer to account name of service
        SecurityInfo->Password,          // pointer to password for service account
        NULL                             // pointer to display name
        )) {
        DebugPrint(( TEXT("could not open change service configuration, ec=%d"), GetLastError() ));
        goto exit;
    }

    rVal = TRUE;

exit:
    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}


BOOL
MyDeleteService(
    LPTSTR ServiceName
    )
{
    SC_HANDLE       hSvcMgr;
    SC_HANDLE       hService;
    SERVICE_STATUS  Status;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        return FALSE;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (hService) {

        //
        // the service exists, lets be sure that it is stopped
        //

        ControlService(
            hService,
            SERVICE_CONTROL_STOP,
            &Status
            );

        DeleteService( hService );

        CloseServiceHandle( hService );

    }

    CloseServiceHandle( hSvcMgr );
    return TRUE;
}


BOOL
DeleteFaxService(
    VOID
    )
{
    return MyDeleteService( FAX_SERVICE_NAME );
}


BOOL
SetFaxServiceAutoStart(
    VOID
    )
{
    return SetServiceStart( FAX_SERVICE_NAME, SERVICE_AUTO_START );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\ra.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    client.c

Abstract:

    This file implements the file copy code.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop


FILE_QUEUE_INFO RemoteAdminFileQueue[] =
{
//-----------------------------------------------------------------------------------------------------------------------------------------------------
//    Section Name                          Dest Dir            INF Dir Id          Dest Dir Id        Platforms                            Copy Flags
//-----------------------------------------------------------------------------------------------------------------------------------------------------
    { TEXT("RemoteAdminFiles"),                 NULL,         DIRID_SYSTEM,        DIRID_SYSTEM,   PLATFORM_NONE,                        SP_COPY_NEWER }
};

#define CountRemoteAdminFileQueue (sizeof(RemoteAdminFileQueue)/sizeof(FILE_QUEUE_INFO))



DWORD
RemoteAdminCopyThread(
    HWND hwnd
    )
{
    HINF FaxSetupInf;
    HSPFILEQ *FileQueue;
    PVOID QueueContext;
    DWORD ErrorCode = 0;


    if (InstallMode & INSTALL_NEW) {
        SendMessage( hwnd, WM_MY_PROGRESS, 0xff, 10 );
    }

    if (!InitializeFileQueue( hwnd, &FaxSetupInf, &FileQueue, &QueueContext, SourceDirectory )) {
        ErrorCode = IDS_COULD_NOT_COPY_FILES;
        goto error_exit;
    }

    if (!ProcessFileQueue( FaxSetupInf, FileQueue, QueueContext, SourceDirectory,
            RemoteAdminFileQueue, CountRemoteAdminFileQueue, InstallQueueCallback, SETUP_ACTION_COPY )) {
        ErrorCode = IDS_COULD_NOT_COPY_FILES;
        goto error_exit;
    }

    if (!CloseFileQueue( FileQueue, QueueContext )) {
        ErrorCode = IDS_COULD_NOT_COPY_FILES;
        goto error_exit;
    }

    if (InstallMode & INSTALL_NEW) {

        SetProgress( hwnd, IDS_CREATING_GROUPS );

        SetInstalledFlag( TRUE );
        SetInstallType( FAX_INSTALL_REMOTE_ADMIN );
        SetUnInstallInfo();

        CreateGroupItems( TRUE, NULL );
    }

    SetWindowLong( hwnd, DWL_MSGRESULT, 0 );
    PropSheet_PressButton( GetParent(hwnd), PSBTN_NEXT );

    return TRUE;

error_exit:

    InstallThreadError = ErrorCode;
    PopUpMsg( hwnd, ErrorCode, TRUE, 0 );
    OkToCancel = TRUE;
    PropSheet_PressButton( GetParent(hwnd), PSBTN_CANCEL );
    SetWindowLong( hwnd, DWL_MSGRESULT, -1 );

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\tapi.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tapi.c

Abstract:

    This file provides all access to tapi.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop

#include <initguid.h>
#include <devguid.h>

DWORD       TapiApiVersion;
HLINEAPP    hLineApp;
HANDLE      TapiEvent;
DWORD       TapiDevices;
DWORD       FaxDevices;
PLINE_INFO  LineInfo;
DWORD       CurrentLocationId;
DWORD       CurrentCountryId;
LPTSTR      CurrentAreaCode;


#include "modem.c"


LONG
MyLineGetTransCaps(
    LPLINETRANSLATECAPS *LineTransCaps
    )
{
    DWORD LineTransCapsSize;
    LONG Rslt = ERROR_SUCCESS;


    //
    // allocate the initial linetranscaps structure
    //

    LineTransCapsSize = sizeof(LINETRANSLATECAPS) + 4096;
    *LineTransCaps = (LPLINETRANSLATECAPS) MemAlloc( LineTransCapsSize );
    if (!*LineTransCaps) {
        DebugPrint(( TEXT("MemAlloc() failed, sz=0x%08x"), LineTransCapsSize ));
        Rslt = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    (*LineTransCaps)->dwTotalSize = LineTransCapsSize;

    Rslt = lineGetTranslateCaps(
        hLineApp,
        TapiApiVersion,
        *LineTransCaps
        );

    if (Rslt != 0) {
        DebugPrint(( TEXT("lineGetTranslateCaps() failed, ec=0x%08x"), Rslt ));
        goto exit;
    }

    if ((*LineTransCaps)->dwNeededSize > (*LineTransCaps)->dwTotalSize) {

        //
        // re-allocate the LineTransCaps structure
        //

        LineTransCapsSize = (*LineTransCaps)->dwNeededSize;

        MemFree( *LineTransCaps );

        *LineTransCaps = (LPLINETRANSLATECAPS) MemAlloc( LineTransCapsSize );
        if (!*LineTransCaps) {
            DebugPrint(( TEXT("MemAlloc() failed, sz=0x%08x"), LineTransCapsSize ));
            Rslt = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        (*LineTransCaps)->dwTotalSize = LineTransCapsSize;

        Rslt = lineGetTranslateCaps(
            hLineApp,
            TapiApiVersion,
            *LineTransCaps
            );

        if (Rslt != 0) {
            DebugPrint(( TEXT("lineGetTranslateCaps() failed, ec=0x%08x"), Rslt ));
            goto exit;
        }

    }

exit:
    if (Rslt != ERROR_SUCCESS) {
        MemFree( *LineTransCaps );
        *LineTransCaps = NULL;
    }

    return Rslt;
}


BOOL
LookFor351Modems(
    VOID
    )
{
    TCHAR FileName[MAX_PATH*2];
    TCHAR Ports[128];



    if (!ExpandEnvironmentStrings( TEXT("%windir%\\system32\\ras\\serial.ini"), FileName, sizeof(FileName)/sizeof(TCHAR) )) {
        return FALSE;
    }

    if (!GetPrivateProfileSectionNames( Ports, sizeof(Ports), FileName )) {
        return FALSE;
    }

    return TRUE;
}


DWORD
DeviceInitThread(
    HWND hwnd
    )
{
    DWORD rVal = 0;
    LONG Rslt;
    LINEINITIALIZEEXPARAMS LineInitializeExParams;
    LINEEXTENSIONID lineExtensionID;
    DWORD LineDevCapsSize;
    LPLINEDEVCAPS LineDevCaps = NULL;
    LPTSTR DeviceClassList;
    BOOL UnimodemDevice;
    DWORD i;
    LPLINETRANSLATECAPS LineTransCaps = NULL;
    LPLINELOCATIONENTRY LineLocation = NULL;
    BOOL FirstTime = TRUE;
    BOOL NoClass1 = FALSE;
    LPTSTR p;
    DWORD Answer;
    DWORD LocalTapiApiVersion;

    HKEY  hKey;
    DWORD ValType;
    DWORD ValSize;

    PMDM_DEVSPEC MdmDevSpec;
    LPSTR ModemKey = NULL;
    UINT  Res;
    TCHAR AdaptiveFileName[MAX_PATH*2];
    HANDLE AdaptiveFileHandle;
    BOOL  AdaptiveFileExists = FALSE;
    TCHAR Drive[_MAX_DRIVE];
    TCHAR Dir[_MAX_DIR];

#define   AdaptiveFileMaxSize  20000
    BYTE  AdaptiveFileBuffer[AdaptiveFileMaxSize];    // temporary needed. Currently < 1K anyway.
    DWORD BytesHaveRead;

#define   RespKeyMaxSize 1000
    BYTE  RespKeyName[RespKeyMaxSize];


    if (hLineApp) {
        return 0;
    }

    LineInitializeExParams.dwTotalSize      = sizeof(LINEINITIALIZEEXPARAMS);
    LineInitializeExParams.dwNeededSize     = 0;
    LineInitializeExParams.dwUsedSize       = 0;
    LineInitializeExParams.dwOptions        = LINEINITIALIZEEXOPTION_USEEVENT;
    LineInitializeExParams.Handles.hEvent   = NULL;
    LineInitializeExParams.dwCompletionKey  = 0;

    LocalTapiApiVersion = TapiApiVersion = 0x00020000;

    if (!Unattended) {
        SetDlgItemText(
            hwnd,
            IDC_DEVICE_PROGRESS_TEXT,
            GetString( IDS_INIT_TAPI )
            );
    }

    if (LookFor351Modems()) {
        PopUpMsg( hwnd, IDS_351_MODEM, TRUE, 0 );
    }

init_again:
    Rslt = lineInitializeEx(
        &hLineApp,
        FaxWizModuleHandle,
        NULL,
        TEXT("Fax Setup"),
        &TapiDevices,
        &LocalTapiApiVersion,
        &LineInitializeExParams
        );

    if (Rslt != 0) {
        DebugPrint(( TEXT("lineInitializeEx() failed, ec=0x%08x"), Rslt ));
        hLineApp = NULL;
        goto exit;
    }

    if (!FirstTime) {
        PopUpMsg( hwnd, IDS_NO_TAPI_DEVICES, TRUE, 0 );
        ExitProcess(0);
    }

    if (TapiDevices == 0) {
        if (NtGuiMode) {
            //
            // if running in nt gui mode setup and there
            // are no tapi devices then we do nothing,
            // but do allow the setup to continue.
            //
            lineShutdown( hLineApp );
            hLineApp = NULL;
            return 0;
        }

        Answer = PopUpMsg( hwnd, IDS_NO_MODEM, FALSE, MB_YESNO );
        if (Answer == IDYES) {
            if (!CallModemInstallWizard( hwnd )) {
                DebugPrint(( TEXT("CallModemInstallWizard() failed, ec=0x%08x"), GetLastError() ));
            }
        } else {
            DebugPrint(( TEXT("No tapi devices, user declined") ));
        }
        FirstTime = FALSE;
        lineShutdown( hLineApp );
        hLineApp = NULL;
        goto init_again;
    }

    //
    // determine the current location information
    //

    Rslt = MyLineGetTransCaps( &LineTransCaps );
    if (Rslt != ERROR_SUCCESS) {
        if (Rslt == LINEERR_INIFILECORRUPT) {
            //
            // need to set the location information
            //
            if (!NtGuiMode) {
                Rslt = lineTranslateDialog( hLineApp, 0, LocalTapiApiVersion, hwnd, NULL );
                if (Rslt == ERROR_SUCCESS) {
                    Rslt = MyLineGetTransCaps( &LineTransCaps );
                }
            }
        }
        if (Rslt != ERROR_SUCCESS) {
            DebugPrint(( TEXT("MyLineGetTransCaps() failed, ec=0x%08x"), Rslt ));
            goto exit;
        }
    }

    LineLocation = (LPLINELOCATIONENTRY) ((LPBYTE)LineTransCaps + LineTransCaps->dwLocationListOffset);
    for (i=0; i<LineTransCaps->dwNumLocations; i++) {
        if (LineTransCaps->dwCurrentLocationID == LineLocation[i].dwPermanentLocationID) {
            break;
        }
    }

    if (i == LineTransCaps->dwNumLocations) {
        DebugPrint(( TEXT("Could not determine the current location information") ));
        goto exit;
    }

    CurrentLocationId = LineTransCaps->dwCurrentLocationID;
    CurrentCountryId  = LineLocation->dwCountryID;
    CurrentAreaCode   = StringDup( (LPTSTR) ((LPBYTE)LineTransCaps + LineLocation->dwCityCodeOffset) );

    //
    // allocate the lineinfo structure
    //

    TapiEvent = LineInitializeExParams.Handles.hEvent;

    LineInfo = (PLINE_INFO) MemAlloc( TapiDevices * sizeof(LINE_INFO) );
    if (!LineInfo) {
        goto exit;
    }

    //
    // allocate the initial linedevcaps structure
    //

    LineDevCapsSize = sizeof(LINEDEVCAPS) + 4096;
    LineDevCaps = (LPLINEDEVCAPS) MemAlloc( LineDevCapsSize );
    if (!LineDevCaps) {
        goto exit;
    }

    if (!Unattended) {
        SendMessage( hwnd, WM_MY_PROGRESS, 0xff, TapiDevices * 20 );
    }

    //
    // open FaxAdapt.lst file to decide on enabling RX
    // try executable directory first, then- system directory
    //

    if ( ! GetModuleFileName( FaxWizModuleHandle, AdaptiveFileName, sizeof(AdaptiveFileName) ) ) {
       DebugPrint(( TEXT("GetModuleFileName fails , ec=0x%08x "), GetLastError()  ));
       goto l0;
    }

    _tsplitpath( AdaptiveFileName, Drive, Dir, NULL, NULL );
    _stprintf( AdaptiveFileName, TEXT("%s%s"), Drive, Dir );

    if ( _tcslen(AdaptiveFileName) + _tcslen( TEXT("FAXADAPT.LST") ) >= MAX_PATH )  {
       DebugPrint(( TEXT("GetCurrentDirectory() too long ,  MAX_PATH = %d"), MAX_PATH ));
       goto l0;
    }

    _tcscat (AdaptiveFileName, (TEXT ("FAXADAPT.LST")) );

    if ( (AdaptiveFileHandle = CreateFile(AdaptiveFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL) )
                             == INVALID_HANDLE_VALUE ) {

       DebugPrint(( TEXT("Could not open adaptive file %s ec=0x%08x"), AdaptiveFileName, GetLastError() ));
       goto l0;
     }

    if (! ReadFile(AdaptiveFileHandle, AdaptiveFileBuffer, AdaptiveFileMaxSize, &BytesHaveRead, NULL ) ) {
       DebugPrint(( TEXT("Could not read adaptive file %s ec=0x%08x"), AdaptiveFileName, GetLastError() ));
       CloseHandle(AdaptiveFileHandle);
       goto l1;
     }

    if (BytesHaveRead >= AdaptiveFileMaxSize) {
       DebugPrint(( TEXT("Adaptive file %s is too big - %d bytes"), AdaptiveFileName, BytesHaveRead ));
       CloseHandle(AdaptiveFileHandle);
       goto l1;
    }

    CloseHandle(AdaptiveFileHandle);

    AdaptiveFileBuffer[BytesHaveRead] = 0;  // need a string
    AdaptiveFileExists = TRUE;

    goto l1;

    //
    // only if there is no file in the current directory.
    //

l0:

    Res = GetSystemDirectory( AdaptiveFileName, MAX_PATH);
    if (Res == 0) {
       DebugPrint(( TEXT("GetSystemDirectory() failed 0, ec=0x%08x"), GetLastError() ));
       goto l1;
    }
    else if (Res > MAX_PATH) {
       DebugPrint(( TEXT("GetSystemDirectory() failed > MAX_PATH = %d"), MAX_PATH ));
       goto l1;
    }

    if (Res + _tcslen( TEXT("\\FAXADAPT.LST") ) >= MAX_PATH )  {
       DebugPrint(( TEXT("GetSystemDirectory() too long %d,  MAX_PATH = %d"), Res, MAX_PATH ));
       goto l1;
    }

    _tcscat (AdaptiveFileName, (TEXT ("\\FAXADAPT.LST")) );

    if ( (AdaptiveFileHandle = CreateFile(AdaptiveFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL) )
                             == INVALID_HANDLE_VALUE ) {

       DebugPrint(( TEXT("Could not open adaptive file %s ec=0x%08x"), AdaptiveFileName, GetLastError() ));
       goto l1;
     }

    if (! ReadFile(AdaptiveFileHandle, AdaptiveFileBuffer, AdaptiveFileMaxSize, &BytesHaveRead, NULL ) ) {
       DebugPrint(( TEXT("Could not read adaptive file %s ec=0x%08x"), AdaptiveFileName, GetLastError() ));
       CloseHandle(AdaptiveFileHandle);
       goto l1;
     }

    if (BytesHaveRead >= AdaptiveFileMaxSize) {
       DebugPrint(( TEXT("Adaptive file %s is too big - %d bytes"), AdaptiveFileName, BytesHaveRead ));
       CloseHandle(AdaptiveFileHandle);
       goto l1;
    }

    CloseHandle(AdaptiveFileHandle);

    AdaptiveFileBuffer[BytesHaveRead] = 0;  // need a string
    AdaptiveFileExists = TRUE;


l1:
    //
    // enumerate all of the tapi devices
    //

    i = 0;

    do {

        Rslt = lineNegotiateAPIVersion(
            hLineApp,
            i,
            0x00010003,
            TapiApiVersion,
            &LocalTapiApiVersion,
            &lineExtensionID
            );
        if (Rslt != 0) {
            DebugPrint(( TEXT("lineNegotiateAPIVersion() failed, ec=0x%08x"), Rslt ));
            goto next_device;
        }

        ZeroMemory( LineDevCaps, LineDevCapsSize );
        LineDevCaps->dwTotalSize = LineDevCapsSize;

        Rslt = lineGetDevCaps(
            hLineApp,
            i,
            LocalTapiApiVersion,
            0,
            LineDevCaps
            );

        if (Rslt != 0) {
            DebugPrint(( TEXT("lineGetDevCaps() failed, ec=0x%08x"), Rslt ));
            goto next_device;
        }

        if (LineDevCaps->dwNeededSize > LineDevCaps->dwTotalSize) {

            //
            // re-allocate the linedevcaps structure
            //

            LineDevCapsSize = LineDevCaps->dwNeededSize;

            MemFree( LineDevCaps );

            LineDevCaps = (LPLINEDEVCAPS) MemAlloc( LineDevCapsSize );
            if (!LineDevCaps) {
                rVal = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }

            Rslt = lineGetDevCaps(
                hLineApp,
                i,
                TapiApiVersion,
                0,
                LineDevCaps
                );

            if (Rslt != 0) {
                DebugPrint(( TEXT("lineGetDevCaps() failed, ec=0x%08x"), Rslt ));
                goto next_device;
            }

        }

        if (!Unattended) {
            SendMessage( hwnd, WM_MY_PROGRESS, 10, 0 );
        }

        if (!Unattended) {
            SetDlgItemText(
                hwnd,
                IDC_DEVICE_PROGRESS_TEXT,
                (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwLineNameOffset)
                );
        }

        if (TapiApiVersion != 0x00020000) {
            DebugPrint((
                TEXT("TAPI device is incompatible with the FAX server: %s"),
                (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwLineNameOffset)
                ));
            goto next_device;
        }

        //
        // save the line id
        //

        LineInfo[FaxDevices].PermanentLineID = LineDevCaps->dwPermanentLineID;
        LineInfo[FaxDevices].DeviceName = StringDup( (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwLineNameOffset) );
        LineInfo[FaxDevices].ProviderName = StringDup( (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwProviderInfoOffset) );
        LineInfo[FaxDevices].Rings = LineDevCaps->dwLineStates & LINEDEVSTATE_RINGING ? 2 : 0;
        LineInfo[FaxDevices].Flags = FPF_RECEIVE | FPF_SEND;

        //
        // filter out the commas because the spooler hates them
        //

        p = LineInfo[FaxDevices].DeviceName;
        while( p ) {
            p = _tcschr( p, TEXT(',') );
            if (p) {
                *p = TEXT('_');
            }
        }

        //
        // check for a modem device
        //

        UnimodemDevice = FALSE;

        if (LineDevCaps->dwDeviceClassesSize && LineDevCaps->dwDeviceClassesOffset) {
            DeviceClassList = (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwDeviceClassesOffset);
            while (*DeviceClassList) {
                if (_tcscmp(DeviceClassList,TEXT("comm/datamodem")) == 0) {
                    UnimodemDevice = TRUE;
                    break;
                }
                DeviceClassList += (_tcslen(DeviceClassList) + 1);
            }
        }

        if ((!(LineDevCaps->dwBearerModes & LINEBEARERMODE_VOICE)) ||
            (!(LineDevCaps->dwBearerModes & LINEBEARERMODE_PASSTHROUGH))) {
                //
                // unacceptable modem device type
                //
                UnimodemDevice = FALSE;
        }

        if (UnimodemDevice) {

            LINECALLPARAMS LineCallParams;
            HCALL hCall = NULL;
            HLINE hLine = NULL;
            LINEMESSAGE LineMessage;
            DWORD RequestId;


            LineInfo[FaxDevices].Flags = FPF_SEND;  // Unimodem default

            Rslt = lineOpen(
                hLineApp,
                i,
                &hLine,
                TapiApiVersion,
                0,
                0,
                LINECALLPRIVILEGE_OWNER,
                UnimodemDevice ? LINEMEDIAMODE_DATAMODEM : LINEMEDIAMODE_G3FAX,
                NULL
                );
            if (Rslt != 0) {
                DebugPrint(( TEXT("lineOpen() failed, ec=0x%08x"), Rslt ));
                goto next_device;
            }


            //
            // Get Unimodem key to search Adaptive list.
            //

            if (! AdaptiveFileExists) {
               goto l2;
            }

            if (! LineDevCaps->dwDevSpecificSize) {
               goto l2;
            }

            MdmDevSpec = (PMDM_DEVSPEC) ((LPBYTE) LineDevCaps + LineDevCaps->dwDevSpecificOffset);
            if (MdmDevSpec->Contents == 1 && MdmDevSpec->KeyOffset == 8) {
                ModemKey = MdmDevSpec->String;
            }
            else {
               goto l2;
            }

            if (!ModemKey) {
                DebugPrint(( TEXT("Can't get Unimodem key") ));
                goto l2;
            }

            //
            // Get ResponsesKeyName
            //

            Rslt = RegOpenKeyExA(
                            HKEY_LOCAL_MACHINE,
                            ModemKey,
                            0,
                            KEY_READ,
                            &hKey);

            if (Rslt != ERROR_SUCCESS) {
               DebugPrint(( TEXT("Can't open Unimodem key") ));
               goto l2;
            }

            ValSize = RespKeyMaxSize;

            Rslt = RegQueryValueExA(
                    hKey,
                    "ResponsesKeyName",
                    0,
                    &ValType,
                    RespKeyName,
                    &ValSize);

            RegCloseKey(hKey);

            if (Rslt != ERROR_SUCCESS) {
               DebugPrint(( TEXT("Can't get Unimodem ResponsesKeyName")  ));
               goto l2;
            }

            if ( (ValSize >= RespKeyMaxSize) || (ValSize == 0) )  {
               DebugPrint(( TEXT("Unimodem ResponsesKeyName key is invalid %d"),  RespKeyMaxSize ));
               goto l2;
            }

            if (!RespKeyName) {
               DebugPrint(( TEXT("Unimodem ResponsesKeyName key is NULL") ));
               goto l2;
            }

            _strupr(RespKeyName);

            //
            // check to see if this modem is defined in Adaptive modem list
            //

            if ( strstr (AdaptiveFileBuffer, RespKeyName) ) {

               // enable receive on this device: it is adaptive answer capable.

               LineInfo[FaxDevices].Flags = FPF_RECEIVE | FPF_SEND;
            }

l2:
            ZeroMemory( &LineCallParams, sizeof(LineCallParams) );
            LineCallParams.dwTotalSize = sizeof(LINECALLPARAMS);
            LineCallParams.dwBearerMode = LINEBEARERMODE_PASSTHROUGH;
            hCall = NULL;

            Rslt = lineMakeCall( hLine, &hCall, NULL, 0, &LineCallParams );
            if (Rslt > 0) {

                #define IDVARSTRINGSIZE    (sizeof(VARSTRING)+128)
                PDEVICEID DeviceID = NULL;
                LPVARSTRING LineIdBuffer = MemAlloc( IDVARSTRINGSIZE );
                LineIdBuffer->dwTotalSize = IDVARSTRINGSIZE;
                RequestId = (DWORD) Rslt;

                //
                // wait for the call to complete
                //

                while( TRUE ) {
                    if (WaitForSingleObject( TapiEvent, 5 * 60 * 1000 ) == WAIT_TIMEOUT) {
                        DebugPrint(( TEXT("Setup never received a tapi event") ));
                        rVal = ERROR_INVALID_FUNCTION;
                        goto exit;
                    }
                    Rslt = lineGetMessage( hLineApp, &LineMessage, 0 );
                    if (Rslt == 0) {
                        if (LineMessage.dwMessageID == LINE_REPLY && LineMessage.dwParam1 == RequestId) {
                            switch (LineMessage.dwParam2) {
                                case 0:
                                    break;

                                case LINEERR_CALLUNAVAIL:
                                    DebugPrint(( TEXT("lineMakeCall() failed (LINE_REPLY), ec=0x%08x"), LineMessage.dwParam2 ));
                                    goto next_device;

                                default:
                                    DebugPrint(( TEXT("lineMakeCall() failed (LINE_REPLY), ec=0x%08x"), LineMessage.dwParam2 ));
                                    rVal = LineMessage.dwParam2;
                                    goto exit;

                            }
                            break;
                        }
                    }
                }

                //
                // get the comm handle
                //

                Rslt = lineGetID(
                    hLine,
                    0,
                    hCall,
                    LINECALLSELECT_CALL,
                    LineIdBuffer,
                    TEXT("comm/datamodem")
                    );
                if (Rslt == 0 && LineIdBuffer->dwStringFormat == STRINGFORMAT_BINARY &&
                    LineIdBuffer->dwUsedSize >= sizeof(DEVICEID)) {

                        DeviceID = (PDEVICEID) ((LPBYTE)(LineIdBuffer)+LineIdBuffer->dwStringOffset);
                        if (GetModemClass( DeviceID->hComm ) != 1) {

                            Rslt = LINEERR_BADDEVICEID;
                            NoClass1 = TRUE;
                            DebugPrint(( TEXT("GetModemClass() failed, ec=0x%08x"), Rslt ));

                        } else {

                            FaxDevices += 1;

                        }

                        CloseHandle( DeviceID->hComm );

                } else {

                    DebugPrint(( TEXT("lineGetID() failed, ec=0x%08x"), Rslt ));

                }

                MemFree( LineIdBuffer );

            } else {

                DebugPrint(( TEXT("lineMakeCall() failed, ec=0x%08x"), Rslt ));

            }

            if (hCall) {
                lineDeallocateCall( hCall );
            }

            if (hLine) {
                lineClose( hLine );
            }

        } else {

            if (LineDevCaps->dwMediaModes & LINEMEDIAMODE_G3FAX) {

                //
                // save the line id
                //

                FaxDevices += 1;
            }


        }


next_device:
        if (!Unattended) {
            SendMessage( hwnd, WM_MY_PROGRESS, 10, 0 );
            Sleep( 1000 );
        }
        i += 1;

    } while ( i < TapiDevices );


exit:

    MemFree( LineDevCaps );
    MemFree( LineTransCaps );

    lineShutdown( hLineApp );

    if ((rVal != 0) || (FaxDevices == 0)) {
        if (NtGuiMode) {
            //
            // if running in nt gui mode setup and there
            // are no tapi devices then we do nothing,
            // but do allow the setup to continue.
            //
            hLineApp = NULL;
            return 0;
        }
        PopUpMsg( hwnd, NoClass1 ? IDS_NO_CLASS1 : IDS_NO_TAPI_DEVICES, TRUE, 0 );
        ExitProcess(0);
    }

    if (!Unattended) {
        SetWindowLong( hwnd, DWL_MSGRESULT, 0 );
        PropSheet_PressButton( GetParent(hwnd), PSBTN_NEXT );
    }

    return 0;
}


BOOL
CallModemInstallWizard(
   HWND hwnd
   )

   /* call the Modem.Cpl install wizard to enable the user to install one or more modems
   **
   ** Return TRUE if the wizard was successfully invoked, FALSE otherwise
   **
   */
{
   HDEVINFO hdi;
   BOOL     fReturn = FALSE;
   // Create a modem DeviceInfoSet

   hdi = SetupDiCreateDeviceInfoList((LPGUID)&GUID_DEVCLASS_MODEM, hwnd);
   if (hdi)
   {
      SP_INSTALLWIZARD_DATA iwd;

      // Initialize the InstallWizardData

      ZeroMemory(&iwd, sizeof(iwd));
      iwd.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
      iwd.ClassInstallHeader.InstallFunction = DIF_INSTALLWIZARD;
      iwd.hwndWizardDlg = hwnd;

      // Set the InstallWizardData as the ClassInstallParams

      if (SetupDiSetClassInstallParams(hdi, NULL, (PSP_CLASSINSTALL_HEADER)&iwd, sizeof(iwd)))
      {
         // Call the class installer to invoke the installation
         // wizard.
         if (SetupDiCallClassInstaller(DIF_INSTALLWIZARD, hdi, NULL))
         {
            // Success.  The wizard was invoked and finished.
            // Now cleanup.
            fReturn = TRUE;

            SetupDiCallClassInstaller(DIF_DESTROYWIZARDDATA, hdi, NULL);
         }
      }

      // Clean up
      SetupDiDestroyDeviceInfoList(hdi);
   }
   return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\server.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    server.c

Abstract:

    This file implements the server file copy code.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop



FILE_QUEUE_INFO ServerFileQueue[] =
{
//------------------------------------------------------------------------------------------------------------------------------------------------------------
//    Section Name                         Dest Dir            INF Dir Id          Dest Dir Id               Platforms                            Copy Flags
//------------------------------------------------------------------------------------------------------------------------------------------------------------
    { TEXT("ServerSystemFiles"),               NULL,         DIRID_SYSTEM,        DIRID_SYSTEM,          PLATFORM_NONE,                        SP_COPY_NEWER },
    { TEXT("HelpFilesCommon"),                 NULL,           DIRID_HELP,          DIRID_HELP,          PLATFORM_NONE,                        SP_COPY_NEWER },
    { TEXT("HelpFilesServer"),                 NULL,           DIRID_HELP,          DIRID_HELP,          PLATFORM_NONE,                        SP_COPY_NEWER },
    { TEXT("ServerPrinterFiles"),              NULL,   PRINTER_DRIVER_DIR,  DIRID_SPOOLDRIVERS,   PLATFORM_USE_PRINTER,                        SP_COPY_NEWER },
    { TEXT("ClientFiles"),           FAXCLIENTS_DIR,   PRINTER_CLIENT_DIR,  DIRID_SPOOLDRIVERS,   PLATFORM_USE_MACHINE,                        SP_COPY_NEWER },
    { TEXT("OutlookConfigFile"),  OUTLOOKCONFIG_DIR,      OUTLOOK_ECF_DIR,       DIRID_WINDOWS,          PLATFORM_NONE,                        SP_COPY_NEWER },
    { TEXT("ClientCoverPageFiles"),   COVERPAGE_DIR, COVERPAGE_CLIENT_DIR,        DIRID_SYSTEM,          PLATFORM_NONE,                        SP_COPY_NEWER },
    { TEXT("ClientCoverPageFiles"),   COVERPAGE_DIR, COVERPAGE_CLIENT_DIR,  DIRID_SPOOLDRIVERS,          PLATFORM_NONE,                        SP_COPY_NEWER }
    //
    // ClientCoverPageFiles MUST be the last section because when upgrading
    // the coverpages should not be installed.  This is accomplished by decrementing
    // file queue count.
    //

};

#define CountServerFileQueue (sizeof(ServerFileQueue)/sizeof(FILE_QUEUE_INFO))

FILE_QUEUE_INFO WorkstationFileQueue[] =
{
//------------------------------------------------------------------------------------------------------------------------------------------------------------
//    Section Name                         Dest Dir            INF Dir Id          Dest Dir Id               Platforms                            Copy Flags
//------------------------------------------------------------------------------------------------------------------------------------------------------------
    { TEXT("ServerSystemFiles"),               NULL,         DIRID_SYSTEM,        DIRID_SYSTEM,          PLATFORM_NONE,                        SP_COPY_NEWER },
    { TEXT("HelpFilesCommon"),                 NULL,           DIRID_HELP,          DIRID_HELP,          PLATFORM_NONE,                        SP_COPY_NEWER },
    { TEXT("HelpFilesServer"),                 NULL,           DIRID_HELP,          DIRID_HELP,          PLATFORM_NONE,                        SP_COPY_NEWER },
    { TEXT("HelpFilesWorkstation"),            NULL,           DIRID_HELP,          DIRID_HELP,          PLATFORM_NONE,                        SP_COPY_NEWER },
    { TEXT("ServerPrinterFiles"),              NULL,   PRINTER_DRIVER_DIR,  DIRID_SPOOLDRIVERS,   PLATFORM_USE_PRINTER,                        SP_COPY_NEWER },
    { TEXT("ClientFiles"),           FAXCLIENTS_DIR,   PRINTER_CLIENT_DIR,  DIRID_SPOOLDRIVERS,   PLATFORM_USE_MACHINE,                        SP_COPY_NEWER },
    { TEXT("OutlookConfigFile"),  OUTLOOKCONFIG_DIR,      OUTLOOK_ECF_DIR,       DIRID_WINDOWS,          PLATFORM_NONE,                        SP_COPY_NEWER },
    { TEXT("ClientCoverPageFiles"),   COVERPAGE_DIR, COVERPAGE_CLIENT_DIR,  DIRID_SPOOLDRIVERS,          PLATFORM_NONE,                        SP_COPY_NEWER }
    //
    // ClientCoverPageFiles MUST be the last section because when upgrading
    // the coverpages should not be installed.  This is accomplished by decrementing
    // file queue count.
    //

};

#define CountWorkstationFileQueue (sizeof(WorkstationFileQueue)/sizeof(FILE_QUEUE_INFO))

FILE_QUEUE_INFO DriverClientFileQueue[] =
{
//---------------------------------------------------------------------------------------------------------------------------------------------------------
//    Section Name                      Dest Dir            INF Dir Id          Dest Dir Id               Platforms                            Copy Flags
//---------------------------------------------------------------------------------------------------------------------------------------------------------
    { TEXT("ServerPrinterFiles"),           NULL,   PRINTER_DRIVER_DIR,  DIRID_SPOOLDRIVERS,   PLATFORM_USE_PRINTER,                        SP_COPY_NEWER },
    { TEXT("ClientFiles"),        FAXCLIENTS_DIR,   PRINTER_CLIENT_DIR,  DIRID_SPOOLDRIVERS,   PLATFORM_USE_MACHINE,                        SP_COPY_NEWER }
};

#define CountDriverClientFileQueue (sizeof(DriverClientFileQueue)/sizeof(FILE_QUEUE_INFO))


UINT
InstallQueueCallback(
    IN PVOID QueueContext,
    IN UINT  Notification,
    IN UINT  Param1,
    IN UINT  Param2
    )
{
    LPTSTR TextBuffer;
    DWORD len;
    PFILE_QUEUE_CONTEXT FileQueueContext = (PFILE_QUEUE_CONTEXT) QueueContext;


    if (Notification == SPFILENOTIFY_STARTCOPY) {

        TextBuffer = MemAlloc(
            ((_tcslen( ((PFILEPATHS)Param1)->Target ) + 32) * sizeof(TCHAR)) +
            ((_tcslen( ((PFILEPATHS)Param1)->Source ) + 32) * sizeof(TCHAR))
            );

        if (TextBuffer) {

            _stprintf(
                TextBuffer,
                TEXT("%s%s"),
                GetString( IDS_COPYING ),
                ((PFILEPATHS)Param1)->Target
                );

            len = ExtraChars( GetDlgItem( FileQueueContext->hwnd, IDC_PROGRESS_TEXT ), TextBuffer );
            if (len) {
                LPTSTR FileName = CompactFileName( ((PFILEPATHS)Param1)->Target, len );
                _stprintf(
                    TextBuffer,
                    TEXT("%s%s"),
                    GetString( IDS_COPYING ),
                    FileName
                    );
                MemFree( FileName );
            }

            SetDlgItemText(
                FileQueueContext->hwnd,
                IDC_PROGRESS_TEXT,
                TextBuffer
                );

            _stprintf(
                TextBuffer,
                TEXT("%s %s -> %s"),
                GetString( IDS_COPYING ),
                ((PFILEPATHS)Param1)->Source,
                ((PFILEPATHS)Param1)->Target
                );

            DebugPrint(( TEXT("%s"), TextBuffer ));

            MemFree( TextBuffer );

        }

    }

    //
    // Want default processing.
    //

    return SetupDefaultQueueCallback( FileQueueContext->QueueContext, Notification, Param1, Param2 );
}


VOID
SetProgress(
    HWND hwnd,
    DWORD StatusString
    )
{
    if (Unattended) {
        return;
    }

    SendMessage( hwnd, WM_MY_PROGRESS, 10, 0 );
    SetDlgItemText(
        hwnd,
        IDC_PROGRESS_TEXT,
        GetString( StatusString )
        );
}


DWORD
ServerFileCopyThread(
    HWND hwnd
    )
{
    HINF FaxSetupInf;
    HSPFILEQ *FileQueue;
    PVOID QueueContext;
    DWORD ErrorCode = 0;
    DWORD PlatformsMask;
    DWORD i;
    int DlgErr;
    SECURITY_INFO SecurityInfo;
    PFILE_QUEUE_INFO FileQueueInfo;
    DWORD CountFileQueueInfo;
    DWORD OldInstallType;
    TCHAR FileName[256];
    TCHAR SrcDir[MAX_PATH];
    TCHAR DestDir[MAX_PATH];
    DWORD BytesNeeded;
    BOOL CompleteInstall;


    if (NtGuiMode) {
        MyStartService( L"LanmanServer" );
        if (FaxDevices && Enabled) {
            CompleteInstall = TRUE;
        }
    } else {
        CompleteInstall = TRUE;
    }

    //
    // copy all of the files
    //

    ExpandEnvironmentStrings( TEXT("%windir%\\awmodem.inf"), FileName, sizeof(FileName)/sizeof(TCHAR) );
    MyDeleteFile( FileName );

    //
    // copy faxwiz.dll to the printer driver directory
    // this is necessary because layout.inf cannot have
    // duplicate entries and we need faxwiz.dll to be
    // copied to more than one location
    //

    if (NtGuiMode && (InstallMode & INSTALL_NEW)) {
        if (GetPrinterDriverDirectory( NULL, NULL, 1, (LPBYTE) DestDir, MAX_PATH, &BytesNeeded )) {
            _tcscat( DestDir, TEXT("\\faxwiz.dll") );
            ExpandEnvironmentStrings( TEXT("%systemroot%\\system32\\faxwiz.dll"), SrcDir, sizeof(SrcDir)/sizeof(TCHAR) );
            CopyFile( SrcDir, DestDir, FALSE );
        }
    }

    if (InstallMode & INSTALL_UPGRADE) {
        if (GetPrinterDriverDirectory( NULL, NULL, 1, (LPBYTE) SrcDir, MAX_PATH, &BytesNeeded )) {
            LPTSTR DirectoryPath = _tcsrchr( SrcDir, TEXT( '\\' ) );
            if (DirectoryPath) {
                *++DirectoryPath = 0;
                _tcscpy( DestDir, SrcDir );
                _tcscpy( DirectoryPath, OLD_COVERPAGE_DIR );
                _tcscat( DestDir, COVERPAGE_DIR );
                MoveFile( SrcDir, DestDir );
            }
        }
    }

    if (!Unattended) {
        if (InstallMode & INSTALL_NEW) {
            SendMessage( hwnd, WM_MY_PROGRESS, 0xff, 50 );
        } else  {
            SendMessage( hwnd, WM_MY_PROGRESS, 0xff, 10 );
        }
    }

    //
    // when running in nt gui mode setup
    // the files do not need to be copied
    // because they have been copied during
    // text mode setup.
    //

    if (!NtGuiMode) {
        if (!InitializeFileQueue( hwnd, &FaxSetupInf, &FileQueue, &QueueContext, SourceDirectory )) {
            ErrorCode = IDS_COULD_NOT_COPY_FILES;
            goto error_exit;
        }

        if (InstallType & FAX_INSTALL_WORKSTATION) {
            FileQueueInfo = WorkstationFileQueue;
            CountFileQueueInfo = CountWorkstationFileQueue;
            //
            // If upgrading, decrement the count to drop the coverpage section
            //
            if (InstallMode & INSTALL_UPGRADE) {
                CountFileQueueInfo--;
            }
        } else {
            FileQueueInfo = ServerFileQueue;
            CountFileQueueInfo = CountServerFileQueue;
            //
            // If upgrading, decrement the count to drop the coverpage section
            //
            if (InstallMode & INSTALL_UPGRADE) {
                CountFileQueueInfo--;
            }
        }

        if (InstallMode & INSTALL_DRIVERS) {
            FileQueueInfo = DriverClientFileQueue;
            CountFileQueueInfo = CountDriverClientFileQueue;
        }

        if (!ProcessFileQueue( FaxSetupInf, FileQueue, QueueContext, SourceDirectory,
                FileQueueInfo, CountFileQueueInfo, InstallQueueCallback, SETUP_ACTION_COPY )) {
            ErrorCode = IDS_COULD_NOT_COPY_FILES;
            goto error_exit;
        }

        if (!CloseFileQueue( FileQueue, QueueContext )) {
            ErrorCode = IDS_COULD_NOT_COPY_FILES;
            goto error_exit;
        }
    }

    //
    // set the registry data
    //

    SetProgress( hwnd, IDS_SETTING_REGISTRY );

    if (!SetServerRegistryData()) {
        DebugPrint(( TEXT("SetServerRegistryDatae() failed") ));
        ErrorCode = IDS_COULD_SET_REG_DATA;
        goto error_exit;
    }

    if (!SetClientRegistryData()) {
        DebugPrint(( TEXT("SetClientRegistryDatae() failed") ));
        ErrorCode = IDS_COULD_SET_REG_DATA;
        goto error_exit;
    }

    if (InstallType & FAX_INSTALL_WORKSTATION) {
        SetSoundRegistryData();
    }

#ifdef MSFT_FAXVIEW

    CreateFileAssociation(
        FAXVIEW_EXTENSION,
        FAXVIEW_ASSOC_NAME,
        FAXVIEW_ASSOC_DESC,
        FAXVIEW_OPEN_COMMAND,
        FAXVIEW_PRINT_COMMAND,
        FAXVIEW_PRINTTO_COMMAND,
        FAXVIEW_FILE_NAME,
        FAXVIEW_ICON_INDEX
        );

    CreateFileAssociation(
        FAXVIEW_EXTENSION2,
        FAXVIEW_ASSOC_NAME,
        FAXVIEW_ASSOC_DESC,
        FAXVIEW_OPEN_COMMAND,
        FAXVIEW_PRINT_COMMAND,
        FAXVIEW_PRINTTO_COMMAND,
        FAXVIEW_FILE_NAME,
        FAXVIEW_ICON_INDEX
        );

#endif

    DeleteModemRegistryKey();

    //
    // set all of the install flags in the registry
    // this must be done before the fax service is
    // started so it can query the values
    //

    for (i=0,PlatformsMask=0; i<CountPlatforms; i++) {
        if (Platforms[i].Selected) {
            PlatformsMask |= (1 << i);
        }
    }

    OldInstallType = InstallType;

    SetInstalledFlag( TRUE );
    SetInstallType( RequestedSetupType == SETUP_TYPE_WORKSTATION ? FAX_INSTALL_WORKSTATION : FAX_INSTALL_SERVER );
    SetInstalledPlatforms( PlatformsMask );
    SetUnInstallInfo();

    //
    // install the fax service
    //

    if (InstallMode & INSTALL_NEW) {

        SetProgress( hwnd, IDS_INSTALLING_FAXSVC );

        if (!InstallFaxService( WizData.UseLocalSystem, !CompleteInstall, WizData.AccountName, WizData.Password )) {

            ErrorCode = GetLastError();
            if (ErrorCode != ERROR_SERVICE_LOGON_FAILED) {
                DebugPrint(( TEXT("InstallFaxService() failed") ));
                goto error_exit;
            }

            if (NtGuiMode) {
                WizData.UseLocalSystem = TRUE;
                if (!InstallFaxService( WizData.UseLocalSystem, NtGuiMode, WizData.AccountName, WizData.Password )) {
                    DebugPrint(( TEXT("InstallFaxService() failed") ));
                    ErrorCode = IDS_COULD_NOT_INSTALL_FAX_SERVICE;
                    goto error_exit;
                }
            }

            while( ErrorCode == ERROR_SERVICE_LOGON_FAILED) {
                DWORD Answer ;
                ZeroMemory( &SecurityInfo, sizeof(SECURITY_INFO) );
                _tcscpy( SecurityInfo.AccountName, WizData.AccountName );
                _tcscpy( SecurityInfo.Password, WizData.Password );
                do{ // Return to here if user chooses CANCEL and then waffles on the decision.
                    DlgErr = DialogBoxParam(
                        FaxWizModuleHandle,
                        MAKEINTRESOURCE(IDD_SECURITY_ERROR),
                        hwnd,
                        SecurityErrorDlgProc,
                        (LPARAM) &SecurityInfo
                        );
                    Answer = IDYES ;
                    if (DlgErr == -1 || DlgErr == 0) {
                        DebugPrint(( TEXT("SecurityErrorDlgProc() failed or was cancelled -- First while loop") ));
                        Answer = PopUpMsg( hwnd, IDS_QUERY_CANCEL, FALSE, MB_YESNO );
                        if( Answer == IDYES ){
                            goto error_exit_no_popup;
                        }
                    }
                } while( Answer == IDNO );
                _tcscpy( WizData.AccountName, SecurityInfo.AccountName );
                _tcscpy( WizData.Password, SecurityInfo.Password );

                if (!InstallFaxService( WizData.UseLocalSystem, NtGuiMode, WizData.AccountName, WizData.Password )) {
                    DebugPrint(( TEXT("InstallFaxService() failed") ));
                    ErrorCode = GetLastError();
                    if (ErrorCode != ERROR_SERVICE_LOGON_FAILED) {
                        DebugPrint(( TEXT("InstallFaxService() failed") ));
                        ErrorCode = IDS_COULD_NOT_INSTALL_FAX_SERVICE;
                        goto error_exit;
                    }
                } else {
                    ErrorCode = 0;
                }
            }
        }
    }

    //
    // do the exchange stuff
    //
    SetProgress( hwnd, IDS_INSTALLING_EXCHANGE );
    DoExchangeInstall( hwnd );

    //
    // start the fax service
    //

    SetProgress( hwnd, IDS_STARTING_FAXSVC );

    //
    // can't start the fax service during gui mode
    // setup because netlogon has not yet been started
    // so the service controller cannot logon to the
    // account that the fax service runs under
    //

    if (!NtGuiMode) {
        ErrorCode = StartFaxService();
        if (ErrorCode == ERROR_SERVICE_LOGON_FAILED) {

            while( ErrorCode == ERROR_SERVICE_LOGON_FAILED) {
                DWORD Answer;
                ZeroMemory( &SecurityInfo, sizeof(SECURITY_INFO) );
                _tcscpy( SecurityInfo.AccountName, WizData.AccountName );
                _tcscpy( SecurityInfo.Password, WizData.Password );

                do{ // Return to here if user choses CANCEL and then waffles on the decision.

                    DlgErr = DialogBoxParam(
                        FaxWizModuleHandle,
                        MAKEINTRESOURCE(IDD_SECURITY_ERROR),
                        hwnd,
                        SecurityErrorDlgProc,
                        (LPARAM) &SecurityInfo
                        );
                    Answer = IDYES;
                    if (DlgErr == -1 || DlgErr == 0) {
                        DebugPrint(( TEXT("SecurityErrorDlgProc() failed or was cancelled -- Second while loop") ));
                        Answer = PopUpMsg( hwnd, IDS_QUERY_CANCEL, FALSE, MB_YESNO );
                        if( Answer == IDYES ){
                            goto error_exit_no_popup;
                        }
                    }
                } while( Answer == IDNO );
                _tcscpy( WizData.AccountName, SecurityInfo.AccountName );
                _tcscpy( WizData.Password, SecurityInfo.Password );

                if (!SetServiceAccount( TEXT("Fax"), &SecurityInfo )) {
                    DebugPrint(( TEXT("SetServiceSecurity() failed") ));
                    ErrorCode = IDS_CANT_SET_SERVICE_ACCOUNT;
                    goto error_exit;
                }

                ErrorCode = StartFaxService();
            }

        }
        if (ErrorCode != ERROR_SUCCESS) {
            ErrorCode = IDS_COULD_NOT_START_FAX_SERVICE;
            goto error_exit;
        }
    }

    if (InstallMode & INSTALL_NEW) {
        SetProgress( hwnd, IDS_CREATING_FAXPRT );
        if (CompleteInstall) {
            if (!CreateServerFaxPrinter( hwnd, WizData.PrinterName )) {
                DebugPrint(( TEXT("CreateServerFaxPrinter() failed") ));
                if (!NtGuiMode) {
                    StopFaxService();
                    DeleteFaxService();
                    SetInstalledFlag( FALSE );
                    ErrorCode = IDS_COULD_NOT_CREATE_PRINTER;
                    goto error_exit;
                }
            }
        }

    } else {

        AddPrinterDrivers();

    }

    if (((InstallMode & INSTALL_NEW) || (InstallMode & INSTALL_UPGRADE)) && CompleteInstall) {
        SetProgress( hwnd, IDS_CREATING_GROUPS );
        CreateGroupItems( FALSE, NULL );
    }

    if (InstallMode & INSTALL_NEW) {
        InstallHelpFiles();
    }

    if (InstallMode & INSTALL_NEW) {
        MakeDirectory( FAX_DIR );
        MakeDirectory( FAX_RECEIVE_DIR );
        MakeDirectory( FAX_QUEUE_DIR );
        CreateNetworkShare( FAX_DIR, FAX_SHARE, EMPTY_STRING );
    }

    //
    // create the client install shares, only if we're not installing on sam
    //

    CreateNetworkShare(
        FAXCLIENTS_FULL_PATH,
        FAXCLIENTS_DIR,
        FAXCLIENTS_COMMENT
        );

    if (!Unattended) {
        SetWindowLong( hwnd, DWL_MSGRESULT, 0 );
        PropSheet_PressButton( GetParent(hwnd), PSBTN_NEXT );
    }

    return TRUE;

error_exit:

    PopUpMsg( hwnd, ErrorCode, TRUE, 0 );

error_exit_no_popup:
    InstallThreadError = ErrorCode;
    OkToCancel = TRUE;

    if (!Unattended) {
        PropSheet_PressButton( GetParent(hwnd), PSBTN_CANCEL );
        SetWindowLong( hwnd, DWL_MSGRESULT, -1 );
    }

    //
    // reset the install registry data
    //

    SetInstalledFlag( Installed );
    SetInstallType( OldInstallType );
    SetInstalledPlatforms( InstalledPlatforms );
    if (!Installed) {
        DeleteUnInstallInfo();
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\unattend.c ===
#include "wizard.h"
#pragma hdrstop

UNATTEND_ANSWER UnattendAnswerTable[] =
{
    { UAA_MODE,                 SECTION_NAME, KEY_MODE,                 MODE_NEW,     DT_STRING,    0 },
    { UAA_PRINTER_NAME,         SECTION_NAME, KEY_FAX_PRINTER_NAME,     EMPTY_STRING, DT_STRING,    0 },
    { UAA_FAX_PHONE,            SECTION_NAME, KEY_FAX_NUMBER,           EMPTY_STRING, DT_STRING,    0 },
    { UAA_USE_EXCHANGE,         SECTION_NAME, KEY_USE_EXCHANGE,         EMPTY_STRING, DT_BOOLEAN,   0 },
    { UAA_DEST_PROFILENAME,     SECTION_NAME, KEY_PROFILE_NAME,         EMPTY_STRING, DT_STRING,    0 },
    { UAA_ROUTE_MAIL,           SECTION_NAME, KEY_ROUTE_MAIL,           EMPTY_STRING, DT_BOOLEAN,   0 },
    { UAA_ROUTE_PROFILENAME,    SECTION_NAME, KEY_ROUTE_PROFILENAME,    EMPTY_STRING, DT_STRING,    0 },
    { UAA_PLATFORM_LIST,        SECTION_NAME, KEY_PLATFORMS,            EMPTY_STRING, DT_STRING,    0 },
    { UAA_ROUTE_PRINT,          SECTION_NAME, KEY_ROUTE_PRINT,          EMPTY_STRING, DT_BOOLEAN,   0 },
    { UAA_DEST_PRINTERLIST,     SECTION_NAME, KEY_ROUTE_PRINTERNAME,    EMPTY_STRING, DT_STRING,    0 },
    { UAA_ACCOUNT_NAME,         SECTION_NAME, KEY_ACCOUNT_NAME,         EMPTY_STRING, DT_STRING,    0 },
    { UAA_PASSWORD,             SECTION_NAME, KEY_PASSWORD,             EMPTY_STRING, DT_STRING,    0 },
    { UAA_FAX_PHONE,            SECTION_NAME, KEY_FAX_PHONE,            EMPTY_STRING, DT_STRING,    0 },
    { UAA_DEST_DIRPATH,         SECTION_NAME, KEY_DEST_DIRPATH,         EMPTY_STRING, DT_STRING,    0 },
    { UAA_ROUTE_FOLDER,         SECTION_NAME, KEY_ROUTE_FOLDER,         EMPTY_STRING, DT_BOOLEAN,   0 },
    { UAA_SERVER_NAME,          SECTION_NAME, KEY_SERVER_NAME,          EMPTY_STRING, DT_STRING,    0 },
    { UAA_SENDER_NAME,          SECTION_NAME, KEY_SENDER_NAME,          EMPTY_STRING, DT_STRING,    0 },
    { UAA_SENDER_FAX_AREA_CODE, SECTION_NAME, KEY_SENDER_FAX_AREA_CODE, EMPTY_STRING, DT_STRING,    0 },
    { UAA_SENDER_FAX_NUMBER,    SECTION_NAME, KEY_SENDER_FAX_NUMBER,    EMPTY_STRING, DT_STRING,    0 }
};

#define NumAnswers (sizeof(UnattendAnswerTable)/sizeof(UNATTEND_ANSWER))



BOOL
UnAttendInitialize(
    IN LPWSTR AnswerFile
    )
{
    DWORD i;
    WCHAR Buf[1024];
    LPWSTR Sections;
    LPWSTR p;


    DebugPrint(( L"UnAttendInitialize(): Initializing all answers from the response file [%s]", AnswerFile ));

    //
    // make sure that there is a fax section in the file
    //

    i = 4096;
    Sections = (LPWSTR) MemAlloc( i * sizeof(TCHAR) );
    if (!Sections) {
        return FALSE;
    }

    while( GetPrivateProfileString( NULL, NULL, EMPTY_STRING, Sections, i, AnswerFile ) == i - 2) {
        i += 4096;
        MemFree( Sections );
        Sections = (LPWSTR) MemAlloc( i * sizeof(TCHAR) );
        if (!Sections) {
            return FALSE;
        }
    }

    p = Sections;
    while( *p ) {
        if (_tcsicmp( p, SECTION_NAME ) == 0) {
            i = 0;
            break;
        }
        p += _tcslen( p ) + 1;
    }

    MemFree( Sections );

    if (i) {
        return FALSE;
    }


    Buf[0] = 0;

    GetPrivateProfileString(
                        SECTION_NAME,
                        TEXT("SuppressReboot"),
                        EMPTY_STRING,
                        Buf,
                        sizeof(Buf),
                        AnswerFile
                        );
    
    if (Buf[0] == L'y' || Buf[0] == L'Y') {
        SuppressReboot = TRUE;
    }
    
    //
    // get the answers
    //

    for (i=0; i<NumAnswers; i++) {

        Buf[0] = 0;

        GetPrivateProfileString(
            UnattendAnswerTable[i].SectionName,
            UnattendAnswerTable[i].KeyName,
            UnattendAnswerTable[i].DefaultAnswer,
            Buf,
            sizeof(Buf),
            AnswerFile
            );

        DebugPrint(( L"%s\t%-30s  \"%s\"",
            UnattendAnswerTable[i].SectionName,
            UnattendAnswerTable[i].KeyName,
            Buf
            ));

        switch(UnattendAnswerTable[i].DataType) {
            case DT_STRING:
                UnattendAnswerTable[i].Answer.String = StringDup(Buf);
                break;

            case DT_LONGINT:
                UnattendAnswerTable[i].Answer.Num = _wtol(Buf);
                break;

            case DT_BOOLEAN:
                UnattendAnswerTable[i].Answer.Bool = ((Buf[0] == L'y') || (Buf[0] == L'Y'));
                break;
        }
    }

    return TRUE;
}


BOOL
UnAttendGetAnswer(
    DWORD ControlId,
    LPBYTE AnswerBuf,
    DWORD AnswerBufSize
    )
{
    DWORD i;


    for (i=0; i<NumAnswers; i++) {
        if (UnattendAnswerTable[i].ControlId == ControlId) {
            switch(UnattendAnswerTable[i].DataType) {
                case DT_STRING:
                    if (UnattendAnswerTable[i].Answer.String) {
                        CopyMemory( AnswerBuf, UnattendAnswerTable[i].Answer.String, StringSize(UnattendAnswerTable[i].Answer.String) );
                    } else {
                        return FALSE;
                    }
                    break;

                case DT_LONGINT:
                    CopyMemory( AnswerBuf, &UnattendAnswerTable[i].Answer.Num, sizeof(LONG) );
                    break;

                case DT_BOOLEAN:
                    CopyMemory( AnswerBuf, &UnattendAnswerTable[i].Answer.Bool, sizeof(BOOL) );
                    break;
            }
            break;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\uninstal.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    uninstal.c

Abstract:

    This file implements the un-install case.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop


FILE_QUEUE_INFO UninstallFileQueue[] =
{
//---------------------------------------------------------------------------------------------------------------------------------------
//    Section Name                          Dest Dir            INF Dir Id          Dest Dir Id               Platforms      Copy Flags
//---------------------------------------------------------------------------------------------------------------------------------------
    { TEXT("ServerSystemFiles"),                NULL,         DIRID_SYSTEM,        DIRID_SYSTEM,          PLATFORM_NONE,  SP_COPY_IN_USE_NEEDS_REBOOT },
    { TEXT("ServerPrinterFiles"),               NULL,   PRINTER_DRIVER_DIR,  DIRID_SPOOLDRIVERS,   PLATFORM_USE_PRINTER,  SP_COPY_IN_USE_NEEDS_REBOOT },
    { TEXT("HelpFilesCommon"),                  NULL,           DIRID_HELP,          DIRID_HELP,          PLATFORM_NONE,  SP_COPY_IN_USE_NEEDS_REBOOT },
    { TEXT("HelpFilesClient"),                  NULL,           DIRID_HELP,          DIRID_HELP,          PLATFORM_NONE,  SP_COPY_IN_USE_NEEDS_REBOOT },
    { TEXT("HelpFilesWorkstation"),             NULL,           DIRID_HELP,          DIRID_HELP,          PLATFORM_NONE,  SP_COPY_IN_USE_NEEDS_REBOOT },
    { TEXT("HelpFilesServer"),                  NULL,           DIRID_HELP,          DIRID_HELP,          PLATFORM_NONE,  SP_COPY_IN_USE_NEEDS_REBOOT },
    { TEXT("ClientFiles"),            FAXCLIENTS_DIR,   PRINTER_CLIENT_DIR,  DIRID_SPOOLDRIVERS,   PLATFORM_USE_MACHINE,  SP_COPY_IN_USE_NEEDS_REBOOT },
    { TEXT("ClientCoverPageFiles"),    COVERPAGE_DIR, COVERPAGE_CLIENT_DIR,  DIRID_SPOOLDRIVERS,          PLATFORM_NONE,  SP_COPY_IN_USE_NEEDS_REBOOT },
    { TEXT("ClientSystemFiles"),                NULL,         DIRID_SYSTEM,        DIRID_SYSTEM,          PLATFORM_NONE,  SP_COPY_IN_USE_NEEDS_REBOOT },
    { TEXT("ClientCoverPageFiles"),    COVERPAGE_DIR, COVERPAGE_CLIENT_DIR,        DIRID_SYSTEM,          PLATFORM_NONE,  SP_COPY_IN_USE_NEEDS_REBOOT },
    { TEXT("OutlookConfigFile"),   OUTLOOKCONFIG_DIR,      OUTLOOK_ECF_DIR,       DIRID_WINDOWS,          PLATFORM_NONE,  SP_COPY_IN_USE_NEEDS_REBOOT }
};

#define CountUninstallFileQueue (sizeof(UninstallFileQueue)/sizeof(FILE_QUEUE_INFO))




UINT
UninstallQueueCallback(
    IN PVOID QueueContext,
    IN UINT  Notification,
    IN UINT  Param1,
    IN UINT  Param2
    )
{
    LPTSTR TextBuffer;
    DWORD len;
    TCHAR Drive[_MAX_DRIVE];
    TCHAR Dir[_MAX_DIR];
    TCHAR Path[MAX_PATH];
    PFILE_QUEUE_CONTEXT FileQueueContext = (PFILE_QUEUE_CONTEXT) QueueContext;



    if (Notification == SPFILENOTIFY_ENDDELETE) {

        _tsplitpath( ((PFILEPATHS)Param1)->Target, Drive, Dir, NULL, NULL );
        _stprintf( Path, TEXT("%s%s"), Drive, Dir );
        RemoveDirectory( Path );

    } else if (Notification == SPFILENOTIFY_STARTDELETE) {

        TextBuffer = MemAlloc(
            ((_tcslen( ((PFILEPATHS)Param1)->Target ) + 32) * sizeof(TCHAR))
            );

        if (TextBuffer) {

            _stprintf(
                TextBuffer,
                TEXT("%s%s"),
                GetString( IDS_DELETING ),
                ((PFILEPATHS)Param1)->Target
                );

            len = ExtraChars( GetDlgItem( FileQueueContext->hwnd, IDC_PROGRESS_TEXT ), TextBuffer );
            if (len) {
                LPTSTR FileName = CompactFileName( ((PFILEPATHS)Param1)->Target, len );
                _stprintf(
                    TextBuffer,
                    TEXT("%s%s"),
                    GetString( IDS_DELETING ),
                    FileName
                    );
                MemFree( FileName );
            }

            SetDlgItemText(
                FileQueueContext->hwnd,
                IDC_PROGRESS_TEXT,
                TextBuffer
                );

            DebugPrint(( TEXT("%s"), TextBuffer ));

            MemFree( TextBuffer );

        }

    }

    //
    // Want default processing.
    //

    return SetupDefaultQueueCallback( FileQueueContext->QueueContext, Notification, Param1, Param2 );
}


DWORD
UninstallThread(
    HWND hwnd
    )
{
    HINF FaxSetupInf;
    HSPFILEQ *FileQueue;
    PVOID QueueContext;
    DWORD ErrorCode = 0;
    HKEY hKey;
    HKEY hKeyDevice;
    DWORD RegSize;
    DWORD RegType;
    LONG rVal;
    DWORD i = 0;
    WCHAR Buffer[MAX_PATH*2];


    SendMessage( hwnd, WM_MY_PROGRESS, 0xff, 40 );

    //
    // delete all the files
    //

    if ( !InitializeFileQueue( hwnd, &FaxSetupInf, &FileQueue, &QueueContext, SourceDirectory )) {
        ErrorCode = IDS_COULD_NOT_DELETE_FILES;
        goto error_exit;
    }

    SetProgress( hwnd, IDS_DELETING_FAX_PRINTERS );
    DeleteFaxPrinters( hwnd );

    if (!ProcessFileQueue( FaxSetupInf, FileQueue, QueueContext, SourceDirectory,
            UninstallFileQueue, CountUninstallFileQueue, UninstallQueueCallback, SETUP_ACTION_DELETE )) {
        ErrorCode = IDS_COULD_NOT_DELETE_FILES;
        goto error_exit;
    }

    if (!CloseFileQueue( FileQueue, QueueContext )) {
        ErrorCode = IDS_COULD_NOT_DELETE_FILES;
        goto error_exit;
    }

    //
    // kill the clients dir
    //

    wcscpy( Buffer,  Platforms[0].DriverDir );
    RemoveLastNode( Buffer );
    wcscat( Buffer, FAXCLIENTS_DIR );
    DeleteDirectoryTree( Buffer );

    //
    // kill the fax receieve dir(s)
    //

    rVal = RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_FAX_DEVICES, &hKey );
    if (rVal == ERROR_SUCCESS) {
        while (RegEnumKey( hKey, i++, Buffer, sizeof(Buffer)/sizeof(WCHAR) ) == ERROR_SUCCESS) {
            wcscat( Buffer, L"\\" );
            wcscat( Buffer, REGKEY_ROUTING );
            rVal = RegOpenKey( hKey, Buffer, &hKeyDevice );
            if (rVal == ERROR_SUCCESS) {
                RegSize = sizeof(Buffer);
                rVal = RegQueryValueEx(
                    hKeyDevice,
                    REGVAL_ROUTING_DIR,
                    0,
                    &RegType,
                    (LPBYTE) Buffer,
                    &RegSize
                    );
                if (rVal == ERROR_SUCCESS) {
                    DeleteDirectoryTree( Buffer );
                }
                RegCloseKey( hKeyDevice );
            }
        }
        RegCloseKey( hKey );
    }

    //
    // clean out the registry
    //

    SetProgress( hwnd, IDS_DELETING_REGISTRY );
    DeleteFaxRegistryData();

    //
    // remove the fax service
    //

    SetProgress( hwnd, IDS_DELETING_FAX_SERVICE );
    MyDeleteService( TEXT("Fax") );

    //
    // remove the program groups
    //

    SetProgress( hwnd, IDS_DELETING_GROUPS );
    DeleteGroupItems();

    DeleteFaxMsgServices();

    if (InstallType & FAX_INSTALL_SERVER) {
        DeleteNetworkShare( FAXCLIENTS_DIR );
    }

    //
    // allow the ui to continue
    //

    SetWindowLong( hwnd, DWL_MSGRESULT, 0 );
    PropSheet_PressButton( GetParent(hwnd), PSBTN_NEXT );

    return TRUE;

error_exit:

    PopUpMsg( hwnd, ErrorCode, TRUE, 0 );
    OkToCancel = TRUE;
    PropSheet_PressButton( GetParent(hwnd), PSBTN_CANCEL );
    SetWindowLong( hwnd, DWL_MSGRESULT, -1 );

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This file implements utility functions.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop

PLATFORM_INFO Platforms[] =
{
    {  TEXT("Windows NT x86"),        TEXT("i386"),    0, FAX_INSTALLED_PLATFORM_X86,   NULL, FALSE },
    {  TEXT("Windows NT Alpha_AXP"),  TEXT("alpha"),   0, FAX_INSTALLED_PLATFORM_ALPHA, NULL, FALSE },
};

DWORD CountPlatforms = (sizeof(Platforms)/sizeof(PLATFORM_INFO));

// Sequentially enumerate platforms
WORD EnumPlatforms[4];


typedef struct _STRING_TABLE {
    DWORD   ResourceId;
    BOOL    UseTitle;
    LPTSTR  String;
} STRING_TABLE, *PSTRING_TABLE;


static STRING_TABLE StringTable[] =
{
    { IDS_TITLE_WKS,                         FALSE,      NULL },
    { IDS_TITLE_SRV,                         FALSE,      NULL },
    { IDS_TITLE_PP,                          FALSE,      NULL },
    { IDS_TITLE_RA,                          FALSE,      NULL },
    { IDS_COPYING,                           FALSE,      NULL },
    { IDS_COPY_WAITMSG,                       TRUE,      NULL },
    { IDS_COULD_NOT_DELETE_FAX_PRINTER,      FALSE,      NULL },
    { IDS_COULD_NOT_DELETE_FILES,            FALSE,      NULL },
    { IDS_CREATING_FAXPRT,                   FALSE,      NULL },
    { IDS_CREATING_GROUPS,                   FALSE,      NULL },
    { IDS_DEFAULT_PRINTER,                   FALSE,      NULL },
    { IDS_DEFAULT_SHARE,                     FALSE,      NULL },
    { IDS_DELETE_WAITMSG,                     TRUE,      NULL },
    { IDS_DELETING,                          FALSE,      NULL },
    { IDS_DELETING_FAX_PRINTERS,             FALSE,      NULL },
    { IDS_DELETING_FAX_SERVICE,              FALSE,      NULL },
    { IDS_DELETING_GROUPS,                   FALSE,      NULL },
    { IDS_DELETING_REGISTRY,                 FALSE,      NULL },
    { IDS_DEVICEINIT_LABEL01,                 TRUE,      NULL },
    { IDS_ERR_TITLE,                          TRUE,      NULL },
    { IDS_FAXCLIENT_SETUP,                   FALSE,      NULL },
    { IDS_FAX_PRINTER_PENDING_DELETION,      FALSE,      NULL },
    { IDS_FAX_SHARE_COMMENT,                 FALSE,      NULL },
    { IDS_INBOUND_DIR,                       FALSE,      NULL },
    { IDS_INIT_TAPI,                         FALSE,      NULL },
    { IDS_INSTALLING_FAXSVC,                 FALSE,      NULL },
    { IDS_INVALID_DIRECTORY,                 FALSE,      NULL },
    { IDS_INVALID_LOCAL_PRINTER_NAME,        FALSE,      NULL },
    { IDS_LABEL01_LAST,                       TRUE,      NULL },
    { IDS_LABEL02_LAST,                       TRUE,      NULL },
    { IDS_LABEL_PRINTERNAME,                 FALSE,      NULL },
    { IDS_LASTUNINSTALL_LABEL01,              TRUE,      NULL },
    { IDS_NO_MODEM,                          FALSE,      NULL },
    { IDS_QUERY_CANCEL,                      FALSE,      NULL },
    { IDS_QUERY_UNINSTALL,                    TRUE,      NULL },
    { IDS_SETTING_REGISTRY,                  FALSE,      NULL },
    { IDS_SHARE_FAX_PRINTER,                 FALSE,      NULL },
    { IDS_STARTING_FAXSVC,                   FALSE,      NULL },
    { IDS_TITLE,                              TRUE,      NULL },
    { IDS_WELCOME_LABEL01,                    TRUE,      NULL },
    { IDS_WELCOME_LABEL02,                    TRUE,      NULL },
    { IDS_WRN_SPOOLER,                       FALSE,      NULL },
    { IDS_WRN_TITLE,                          TRUE,      NULL },
    { IDS_PRINTER_NAME,                      FALSE,      NULL },
    { IDS_CSID,                              FALSE,      NULL },
    { IDS_TSID,                              FALSE,      NULL },
    { IDS_DEST_DIR,                          FALSE,      NULL },
    { IDS_PROFILE,                           FALSE,      NULL },
    { IDS_ACCOUNTNAME,                       FALSE,      NULL },
    { IDS_PASSWORD,                          FALSE,      NULL },
    { IDS_NO_TAPI_DEVICES,                   FALSE,      NULL },
    { IDS_USER_MUST_BE_ADMIN,                 TRUE,      NULL },
    { IDS_COULD_NOT_INSTALL_FAX_SERVICE,     FALSE,      NULL },
    { IDS_COULD_NOT_START_FAX_SERVICE,       FALSE,      NULL },
    { IDS_COULD_NOT_CREATE_PRINTER,          FALSE,      NULL },
    { IDS_PERMISSION_CREATE_PRINTER,         FALSE,      NULL },
    { IDS_COULD_SET_REG_DATA,                FALSE,      NULL },
    { IDS_INVALID_USER,                      FALSE,      NULL },
    { IDS_INVALID_USER_NAME,                 FALSE,      NULL },
    { IDS_INVALID_AREA_CODE,                 FALSE,      NULL },
    { IDS_INVALID_PHONE_NUMBER,              FALSE,      NULL },
    { IDS_ROUTING_REQUIRED,                  FALSE,      NULL },
    { IDS_COULD_NOT_COPY_FILES,              FALSE,      NULL },
    { IDS_CANT_USE_FAX_PRINTER,              FALSE,      NULL },
    { IDS_CANT_SET_SERVICE_ACCOUNT,          FALSE,      NULL },
    { IDS_EXCHANGE_IS_RUNNING,               FALSE,      NULL },
    { IDS_DEFAULT_PRINTER_NAME,              FALSE,      NULL },
    { IDS_INSTALLING_EXCHANGE,               FALSE,      NULL },
    { IDS_351_MODEM,                         FALSE,      NULL },
    { IDS_LARGEFONTNAME,                     FALSE,      NULL },
    { IDS_LARGEFONTSIZE,                     FALSE,      NULL },
    { IDS_NO_CLASS1,                          TRUE,      NULL },
    { IDS_UAA_MODE,                          FALSE,      NULL },
    { IDS_UAA_PRINTER_NAME,                  FALSE,      NULL },
    { IDS_UAA_FAX_PHONE,                     FALSE,      NULL },
    { IDS_UAA_DEST_PROFILENAME,              FALSE,      NULL },
    { IDS_UAA_ROUTE_PROFILENAME,             FALSE,      NULL },
    { IDS_UAA_PLATFORM_LIST,                 FALSE,      NULL },
    { IDS_UAA_DEST_PRINTERLIST,              FALSE,      NULL },
    { IDS_UAA_ACCOUNT_NAME,                  FALSE,      NULL },
    { IDS_UAA_PASSWORD,                      FALSE,      NULL },
    { IDS_UAA_DEST_DIRPATH,                  FALSE,      NULL },
    { IDS_UAA_SERVER_NAME,                   FALSE,      NULL },
    { IDS_UAA_SENDER_NAME,                   FALSE,      NULL },
    { IDS_UAA_SENDER_FAX_AREA_CODE,          FALSE,      NULL },
    { IDS_UAA_SENDER_FAX_NUMBER,             FALSE,      NULL }
};

#define CountStringTable (sizeof(StringTable)/sizeof(STRING_TABLE))


VOID
SetTitlesInStringTable(
    VOID
    )
{
    DWORD i;
    TCHAR Buffer[1024];
    DWORD Index = 0;


    for (i=0; i<CountStringTable; i++) {
        if (StringTable[i].UseTitle) {
            if (LoadString(
                FaxWizModuleHandle,
                StringTable[i].ResourceId,
                Buffer,
                sizeof(Buffer)
                ))
            {
                if (StringTable[i].String) {
                    MemFree( StringTable[i].String );
                }
                StringTable[i].String = (LPTSTR) MemAlloc( StringSize( Buffer ) + 256 );
                if (StringTable[i].String) {
                    switch (RequestedSetupType) {
                        case SETUP_TYPE_SERVER:
                            Index = 1;
                            break;

                        case SETUP_TYPE_WORKSTATION:
                            Index = 0;
                            break;

                        case SETUP_TYPE_CLIENT:
                            Index = 2;
                            break;

                        case SETUP_TYPE_POINT_PRINT:
                            Index = 2;
                            break;

                        case SETUP_TYPE_REMOTE_ADMIN:
                            Index = 3;
                            break;
                    }
                    _stprintf( StringTable[i].String, Buffer, StringTable[Index].String );
                }
            }
        }
    }
}


VOID
InitializeStringTable(
    VOID
    )
{
    DWORD i;
    TCHAR Buffer[512];
    SYSTEM_INFO SystemInfo;


    GetSystemInfo( &SystemInfo );

    switch (SystemInfo.wProcessorArchitecture) {

    case PROCESSOR_ARCHITECTURE_INTEL:
       _stprintf(ThisPlatformName, TEXT("i386") );
       break;

    case PROCESSOR_ARCHITECTURE_ALPHA:
       _stprintf(ThisPlatformName, TEXT("alpha") );
       break;

    case PROCESSOR_ARCHITECTURE_MIPS:
       _stprintf(ThisPlatformName, TEXT("mips") );
       break;

    case PROCESSOR_ARCHITECTURE_PPC:
       _stprintf(ThisPlatformName, TEXT("ppc") );
       break;

    default:
       DebugPrint(( TEXT("Unsupported platform!") ));
       break;
    }


    for (i=0; i<CountStringTable; i++) {

        if (LoadString(
            FaxWizModuleHandle,
            StringTable[i].ResourceId,
            Buffer,
            sizeof(Buffer)
            )) {

            StringTable[i].String = (LPTSTR) MemAlloc( StringSize( Buffer ) + 256 );
            if (!StringTable[i].String) {
                StringTable[i].String = TEXT("");
            } else {
                _tcscpy( StringTable[i].String, Buffer );
            }

        } else {

            StringTable[i].String = TEXT("");

        }
    }

    SetTitlesInStringTable();
}


LPTSTR
GetString(
    DWORD ResourceId
    )
{
    DWORD i;

    for (i=0; i<CountStringTable; i++) {
        if (StringTable[i].ResourceId == ResourceId) {
            return StringTable[i].String;
        }
    }

    return NULL;
}


int
PopUpMsg(
    HWND hwnd,
    DWORD ResourceId,
    BOOL Error,
    DWORD Type
    )
{
    return MessageBox(
        hwnd,
        GetString( ResourceId ),
        GetString( Error ? IDS_ERR_TITLE : IDS_WRN_TITLE ),
        MB_SETFOREGROUND | (Error ? MB_ICONEXCLAMATION : MB_ICONINFORMATION) | (Type == 0 ? MB_OK : Type)
        );
}


int
PopUpMsgFmt(
    HWND hwnd,
    DWORD ResourceId,
    BOOL Error,
    DWORD Type,
    ...
    )
{
    TCHAR buf[1024];
    va_list arg_ptr;


    va_start(arg_ptr, Type);
    _vsntprintf( buf, sizeof(buf), GetString( ResourceId ), arg_ptr );

    return MessageBox(
        hwnd,
        buf,
        GetString( Error ? IDS_ERR_TITLE : IDS_WRN_TITLE ),
        MB_SETFOREGROUND | (Error ? MB_ICONEXCLAMATION : MB_ICONINFORMATION) | (Type == 0 ? MB_OK : Type)
        );
}


LPTSTR
GetProductName(
    VOID
    )
{
    DWORD Index;
    switch (RequestedSetupType) {
        case SETUP_TYPE_SERVER:
            Index = 1;
            break;

        case SETUP_TYPE_WORKSTATION:
            Index = 0;
            break;

        case SETUP_TYPE_CLIENT:
            Index = 2;
            break;

        case SETUP_TYPE_POINT_PRINT:
            Index = 2;
            break;

        case SETUP_TYPE_REMOTE_ADMIN:
            Index = 3;
            break;
    }
    return StringTable[Index].String;
}


VOID
SetWizPageTitle(
    HWND hWnd
    )
{
    PropSheet_SetTitle( hWnd, 0, GetProductName() );
}


LPTSTR
RemoveLastNode(
    LPTSTR Path
    )
{
    DWORD i;

    if (Path == NULL || Path[0] == 0) {
        return Path;
    }

    i = _tcslen(Path)-1;
    if (Path[i] == TEXT('\\')) {
        Path[i] = 0;
        i -= 1;
    }

    for (; i>0; i--) {
        if (Path[i] == TEXT('\\')) {
            Path[i+1] = 0;
            break;
        }
    }

    return Path;
}


DWORD
ExtraChars(
    HWND hwnd,
    LPTSTR TextBuffer
    )
{
    RECT Rect;
    SIZE Size;
    HDC  hdc;
    DWORD len;
    HFONT hFont;
    INT Fit;



    hdc = GetDC( hwnd );
    GetWindowRect( hwnd, &Rect );
    hFont = (HFONT)SendMessage( hwnd, WM_GETFONT, 0, 0 );
    if (hFont != NULL) {
        SelectObject( hdc, hFont );
    }

    len = _tcslen( TextBuffer );

    if (!GetTextExtentExPoint(
        hdc,
        TextBuffer,
        len,
        Rect.right - Rect.left,
        &Fit,
        NULL,
        &Size
        )) {

        //
        // can't determine the text extents so we return zero
        //

        Fit = len;
    }

    ReleaseDC( hwnd, hdc );

    if (Fit < (INT)len) {
        return len - Fit;
    }

    return 0;
}


LPTSTR
CompactFileName(
    LPCTSTR FileNameIn,
    DWORD CharsToRemove
    )
{
    LPTSTR start;
    LPTSTR FileName;
    DWORD  FileNameLen;
    LPTSTR lastPart;
    DWORD  lastPartLen;
    DWORD  lastPartPos;
    LPTSTR midPart;
    DWORD  midPartPos;

    if (! FileNameIn) {
       return NULL;
    }

    FileName = MemAlloc( (_tcslen( FileNameIn ) + 16) * sizeof(TCHAR) );
    if (! FileName) {
       return NULL;
    }

    _tcscpy( FileName, FileNameIn );

    FileNameLen = _tcslen(FileName);

    if (FileNameLen < CharsToRemove + 3) {
       // nothing to remove
       return FileName;
    }

    lastPart = _tcsrchr(FileName, TEXT('\\') );
    if (! lastPart) {
       // nothing to remove
       return FileName;
    }

    lastPartLen = _tcslen(lastPart);

    // temporary null-terminate FileName
    lastPartPos = lastPart - FileName;
    FileName[lastPartPos] = TEXT('\0');


    midPart = _tcsrchr(FileName, TEXT('\\') );

    // restore
    FileName[lastPartPos] = TEXT('\\');

    if (!midPart) {
       // nothing to remove
       return FileName;
    }

    midPartPos = midPart - FileName;


    if ( ((DWORD) (lastPart - midPart) ) >= (CharsToRemove + 3) ) {
       // found
       start = midPart+1;
       start[0] = start[1] = start[2] = TEXT('.');
       start += 3;
       _tcscpy(start, lastPart);
       start[lastPartLen] = TEXT('\0');

       return FileName;
    }



    do {
       FileName[midPartPos] = TEXT('\0');

       midPart = _tcsrchr(FileName, TEXT('\\') );

       // restore
       FileName[midPartPos] = TEXT('\\');

       if (!midPart) {
          // nothing to remove
          return FileName;
       }

       midPartPos = midPart - FileName;

       if ( (DWORD) ((lastPart - midPart) ) >= (CharsToRemove + 3) ) {
          // found
          start = midPart+1;
          start[0] = start[1] = start[2] = TEXT('.');
          start += 3;
          _tcscpy(start, lastPart);
          start[lastPartLen] = TEXT('\0');

          return FileName;
       }

    } while ( 1 );

}


VOID
DoExchangeInstall(
    HWND hwnd
    )
{
    //
    // always update the mapi service inf
    // so that the user can add the fax
    // service to their profile even if they
    // choose not to do so now.
    //

    AddFaxAbToMapiSvcInf();
    AddFaxXpToMapiSvcInf();

    InstallExchangeClientExtension(
        EXCHANGE_CLIENT_EXT_NAME,
        EXCHANGE_CLIENT_EXT_FILE,
        EXCHANGE_CONTEXT_MASK
        );

    if ((InstallMode & INSTALL_NEW) && WizData.UseExchange) {
        if (!MapiAvail) {
            //
            // the user wants to use exchange, but it has not
            // been installed yet.  so lets install it!
            //
            WCHAR InstallCommand[256];
            STARTUPINFO si;
            PROCESS_INFORMATION pi;
            GetExchangeInstallCommand( InstallCommand );
            GetStartupInfo( &si );
            if (CreateProcessW( NULL, InstallCommand, NULL, NULL,
                               FALSE, 0, NULL, NULL, &si, &pi )) {
                //
                // wait for the exchange install to finish
                //
                WaitForSingleObject( pi.hProcess, INFINITE );

                InitializeMapi();

                //
                // create a profile and add the fax address book
                //
                CreateDefaultMapiProfile( WizData.MapiProfile );
                InstallFaxAddressBook( hwnd, WizData.MapiProfile );
                InstallFaxTransport( WizData.MapiProfile );
            }
        } else {
            CreateDefaultMapiProfile( WizData.MapiProfile );
            if (!IsMapiServiceInstalled( WizData.MapiProfile, FAXAB_SERVICE_NAME )) {
                InstallFaxAddressBook( hwnd, WizData.MapiProfile );
            }
            if (!IsMapiServiceInstalled( WizData.MapiProfile, FAXXP_SERVICE_NAME )) {
                InstallFaxTransport( WizData.MapiProfile );
            }
        }

        //
        // check to see if exchange is running,
        // if is is then give the user a warning to restart it
        //

        if (IsExchangeRunning()) {

            PopUpMsg( hwnd, IDS_EXCHANGE_IS_RUNNING, FALSE, 0 );

        }
    }
}


BOOL
CreateNetworkShare(
    LPTSTR Path,
    LPTSTR ShareName,
    LPTSTR Comment
    )
{
    SHARE_INFO_2 ShareInfo;
    NET_API_STATUS rVal;
    TCHAR ExpandedPath[MAX_PATH*2];


    ExpandEnvironmentStrings( Path, ExpandedPath, sizeof(ExpandedPath) );

    ShareInfo.shi2_netname        = ShareName;
    ShareInfo.shi2_type           = STYPE_DISKTREE;
    ShareInfo.shi2_remark         = Comment;
    ShareInfo.shi2_permissions    = ACCESS_ALL;
    ShareInfo.shi2_max_uses       = (DWORD) -1,
    ShareInfo.shi2_current_uses   = (DWORD) -1;
    ShareInfo.shi2_path           = ExpandedPath;
    ShareInfo.shi2_passwd         = NULL;

    rVal = NetShareAdd(
        NULL,
        2,
        (LPBYTE) &ShareInfo,
        NULL
        );

    return rVal == 0;
}


BOOL
DeleteNetworkShare(
    LPTSTR ShareName
    )
{
    NET_API_STATUS rVal;


    rVal = NetShareDel(
        NULL,
        ShareName,
        0
        );

    return rVal == 0;
}


BOOL
DeleteDirectoryTree(
    LPWSTR Root
    )
{
    WCHAR FileName[MAX_PATH*2];
    WIN32_FIND_DATA FindData;
    HANDLE hFind;



    swprintf( FileName, L"%s\\*", Root );

    hFind = FindFirstFile( FileName, &FindData );
    if (hFind == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    do {

        if (FindData.cFileName[0] == L'.') {
            continue;
        }

        if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            DeleteDirectoryTree( FindData.cFileName );
        } else {
            MyDeleteFile( FindData.cFileName );
        }

    } while (FindNextFile( hFind, &FindData ));

    FindClose( hFind );

    RemoveDirectory( Root );

    return TRUE;
}


BOOL
MyDeleteFile(
    LPWSTR FileName
    )
{
    if (GetFileAttributes( FileName ) == 0xffffffff) {
        //
        // the file does not exists
        //
        return TRUE;
    }

    if (!DeleteFile( FileName )) {
        if (MoveFileEx( FileName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT )) {
            RebootRequired = TRUE;
            return TRUE;
        } else {
            return FALSE;
        }
    } else {
        return TRUE;
    }
}


//
// RafaelL: 4/3/97
// this is a work-around for Setupapi!SetupSetPlatformPathOverride bug.
// but this also can be useful for custom cross-platform layout.
//

BOOL
PlatformOverride(
    LPTSTR   ThisPlatformName,   // "i386"
    LPTSTR   Override,           // "alpha"
    LPTSTR   SourceRoot,         // "foo\...\bar\i386\"
    LPTSTR   Result              // "foo\...\bar\alpha\"
    )
{

    DWORD   Len;
    DWORD   Pos;
    LPTSTR  LastPart;
    LPTSTR  PlatformPart;
    BOOL    IsBackSlashAtEnd = 0;

    if ( (!ThisPlatformName) || (!Override) || (!SourceRoot) || (!Result) ) {
       // don't do anything: don't break anybody.
       return  TRUE;
    }

    _tcscpy( Result, SourceRoot );

    Len = _tcslen(Result);
    LastPart = _tcsrchr(Result, TEXT('\\') );

    if (!LastPart) {
       return FALSE;
    }

    Pos = LastPart - Result;

    if ( Pos == (Len - 1) ) {
       IsBackSlashAtEnd = 1;
       *LastPart = TEXT('\0');

       PlatformPart = _tcsrchr(Result, TEXT('\\') );

       if (!PlatformPart) {
          return FALSE;
       }
    }
    else {
       PlatformPart = LastPart;
    }

    PlatformPart++;

    if ( _tcsicmp( PlatformPart, ThisPlatformName) != 0 ) {
       return FALSE;
    }

    _tcscpy (PlatformPart, Override);

    Len = _tcslen(Result);
    if (IsBackSlashAtEnd) {
       Result[Len]   = TEXT ('\\');
       Result[Len+1] = TEXT ('\0');
    }
    else {
       Result[Len] = TEXT ('\0');
    }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\fax\setup\wizdll\wizard.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    wizard.c

Abstract:

    This file implements wizard functions.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 17-Feb-1996

--*/

#include "wizard.h"
#pragma hdrstop

//
// the following is not in the SDK
//
#include <pshpack2.h>
typedef struct _DLGTEMPLATE2 {
    WORD DlgVersion;
    WORD Signature;
    DWORD HelpId;
    DWORD StyleEx;
    DWORD Style;
    WORD cDlgItems;
    short x;
    short y;
    short cx;
    short cy;
} DLGTEMPLATE2;
#include <poppack.h>

//
// Enum for SetDialogFont().
//
typedef enum {
    DlgFontTitle,
    DlgFontSupertitle,
    DlgFontSubtitle
} MyDlgFont;

CONST BITMAPINFOHEADER *WatermarkBitmapInfoHeader;
HPALETTE WatermarkPalette;
UINT WatermarkPaletteColorCount;
UINT WatermarkHeaderHeight;


VOID
SetDialogFont(
    IN HWND      hdlg,
    IN UINT      ControlId,
    IN MyDlgFont WhichFont
    )
{
    static HFONT BigBoldFont = NULL;
    static HFONT BoldFont = NULL;
    HFONT Font;
    LOGFONT LogFont;
    int FontSize;
    HDC hdc;

    switch(WhichFont) {

    case DlgFontTitle:

        if(!BigBoldFont) {

            if(Font = (HFONT)SendDlgItemMessage(hdlg,ControlId,WM_GETFONT,0,0)) {

                if(GetObject(Font,sizeof(LOGFONT),&LogFont)) {

                    LogFont.lfWeight = FW_BOLD;

                    //
                    // Load size and name from resources, since these may change
                    // from locale to locale based on the size of the system font, etc.
                    //
                    lstrcpy(LogFont.lfFaceName,GetString(IDS_LARGEFONTNAME));
                    FontSize = _tcstoul(GetString(IDS_LARGEFONTSIZE),NULL,10);

                    if(hdc = GetDC(hdlg)) {

                        LogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);

                        BigBoldFont = CreateFontIndirect(&LogFont);

                        ReleaseDC(hdlg,hdc);
                    }
                }
            }
        }
        Font = BigBoldFont;
        break;

    case DlgFontSupertitle:

        if(!BoldFont) {

            if(Font = (HFONT)SendDlgItemMessage(hdlg,ControlId,WM_GETFONT,0,0)) {

                if(GetObject(Font,sizeof(LOGFONT),&LogFont)) {

                    LogFont.lfWeight = FW_BOLD;

                    if(hdc = GetDC(hdlg)) {
                        BoldFont = CreateFontIndirect(&LogFont);
                        ReleaseDC(hdlg,hdc);
                    }
                }
            }
        }
        Font = BoldFont;
        break;

    case DlgFontSubtitle:
    default:
        //
        // Nothing to do here.
        //
        Font = NULL;
        break;
    }

    if(Font) {
        SendDlgItemMessage(hdlg,ControlId,WM_SETFONT,(WPARAM)Font,0);
    }
}


BOOL
PaintWatermark(
    IN HWND hdlg,
    IN HDC  DialogDC,
    IN UINT XOffset,
    IN UINT YOffset,
    IN BOOL FullPage
    )
{
    HPALETTE OldPalette;
    RECT rect;
    int Height,Width;

    //
    // The correct palette is already realized in foreground from
    // WM_xxxPALETTExxx processing in dialog procs.
    //
    OldPalette = SelectPalette(DialogDC,WatermarkPalette,TRUE);

    SetDIBitsToDevice(
        //
        // Target the dialog's background.
        //
        DialogDC,

        //
        // Destination is upper left of dialog client area.
        //
        0,0,

        //
        // Assume that wizard pages are centered horizontally in the wizard dialog.
        //
        Width = WatermarkBitmapInfoHeader->biWidth - (2*XOffset),

        //
        // For full-page watermarks, the height is the height of the bitmap.
        // For header watermarks, the height is the header area's height.
        // Also account for the y offset within the source bitmap.
        //
        Height = (FullPage ? WatermarkBitmapInfoHeader->biHeight : WatermarkHeaderHeight) - YOffset,

        //
        // The x coord of the lower-left corner of the source is the X offset
        // within the source bitmap.
        //
        XOffset,

        //
        // Now we need the y coord of the lower-left corner of the source.
        // The lower-left corner is the origin.
        //
        FullPage ? 0 : (WatermarkBitmapInfoHeader->biHeight - WatermarkHeaderHeight),

        //
        // We don't do banding so the start scan line is always 0
        // and the scan line count is always the number of lines in the bitmap.
        //
        0,WatermarkBitmapInfoHeader->biHeight,

        //
        // Additional bitmap data.
        //
        (LPBYTE)WatermarkBitmapInfoHeader + WatermarkBitmapInfoHeader->biSize + (WatermarkPaletteColorCount * sizeof(RGBQUAD)),
        (BITMAPINFO *)WatermarkBitmapInfoHeader,

        //
        // Specify that the bitmap's color info is supplied in RGB and not in
        // palette indices.
        //
        DIB_RGB_COLORS
        );

    //
    // Fill in area below the watermark if needed. We do this by removing the area
    // we filled with watermark from the clipping area, and passing a return code
    // back from WM_ERASEBKGND indicating that we didn't erase the background.
    // The dialog manager will do its default thing, which is to fill the background
    // in the correct color, but won't touch what we just painted.
    //
    GetClientRect(hdlg,&rect);
    if((Height < rect.bottom) || (Width+(int)XOffset < rect.right)) {
        ExcludeClipRect(DialogDC,0,0,Width+XOffset,Height);
        return(FALSE);
    }

    return(TRUE);
}


HPALETTE
CreateDIBPalette(
    IN  LPBITMAPINFO  BitmapInfo,
    OUT int          *ColorCount
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    LPBITMAPINFOHEADER BitmapInfoHeader;
    LPLOGPALETTE LogicalPalette;
    HPALETTE Palette;
    int i;
    DWORD d;

    BitmapInfoHeader = (LPBITMAPINFOHEADER)BitmapInfo;

    //
    // No palette needed for >= 16 bpp
    //
    *ColorCount = (BitmapInfoHeader->biBitCount <= 8)
                ? (1 << BitmapInfoHeader->biBitCount)
                : 0;

    if(*ColorCount) {
        LogicalPalette = MemAlloc(sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * (*ColorCount)));
        if(!LogicalPalette) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(NULL);
        }

        LogicalPalette->palVersion = 0x300;
        LogicalPalette->palNumEntries = *ColorCount;

        for(i=0; i<*ColorCount; i++) {
            LogicalPalette->palPalEntry[i].peRed   = BitmapInfo->bmiColors[i].rgbRed;
            LogicalPalette->palPalEntry[i].peGreen = BitmapInfo->bmiColors[i].rgbGreen;
            LogicalPalette->palPalEntry[i].peBlue  = BitmapInfo->bmiColors[i].rgbBlue;
            LogicalPalette->palPalEntry[i].peFlags = 0;
        }

        Palette = CreatePalette(LogicalPalette);
        d = GetLastError();
        MemFree(LogicalPalette);
        SetLastError(d);
    } else {
        Palette = NULL;
    }

    return(Palette);
}


BOOL
GetBitmapDataAndPalette(
    IN  HINSTANCE                hInst,
    IN  LPCTSTR                  Id,
    OUT HPALETTE                *Palette,
    OUT PUINT                    ColorCount,
    OUT CONST BITMAPINFOHEADER **BitmapData
    )

/*++

Routine Description:

    Retreives device-independent bitmap data and a color table from a
    bitmap in a resource.

Arguments:

    hInst - supplies instance handle for module containing the bitmap resource.

    Id - supplies the id of the bitmap resource.

    Palette - if successful, receives a handle to a palette for the bitmap.

    ColorCount - if successful, receives the number of entries in the
        palette for the bitmap.

    BitmapData - if successful, receives a pointer to the bitmap info
        header structure in the resources. This is in read-only memory
        so the caller should not try to modify it.

Return Value:

    If successful, handle to the loaded bitmap (DIB).
    If not, NULL is returned. Check GetLastError().

--*/

{
    HRSRC BlockHandle;
    HGLOBAL MemoryHandle;

    //
    // None of FindResource(), LoadResource(), or LockResource()
    // need to have cleanup routines called in Win32.
    //
    BlockHandle = FindResource(hInst,Id,RT_BITMAP);
    if(!BlockHandle) {
        return(FALSE);
    }

    MemoryHandle = LoadResource(hInst,BlockHandle);
    if(!MemoryHandle) {
        return(FALSE);
    }

    *BitmapData = LockResource(MemoryHandle);
    if(*BitmapData == NULL) {
        return(FALSE);
    }

    *Palette = CreateDIBPalette((LPBITMAPINFO)*BitmapData,ColorCount);
    return(TRUE);
}


DLGITEMTEMPLATE *
FindControlInDialog(
    IN PVOID Template,
    IN UINT  ControlId
    )
{
    PVOID p;
    DLGTEMPLATE *pTemplate;
    DLGTEMPLATE2 *pTemplate2;
    DLGITEMTEMPLATE *pItem;
    WORD ItemCount;
    DWORD Style;
    WORD i;

    p = Template;

    //
    // Skip fixed part of template
    //
    if(((DLGTEMPLATE2 *)p)->Signature == 0xffff) {

        pTemplate2 = p;

        ItemCount = pTemplate2->cDlgItems;
        Style = pTemplate2->Style;

        p = pTemplate2 + 1;

    } else {

        pTemplate = p;

        ItemCount = pTemplate->cdit;
        Style = pTemplate->style;

        p = pTemplate + 1;
    }

    //
    // Skip menu. First word=0 means no menu
    // First word=0xffff means one more word follows
    // Else it's a nul-terminated string
    //
    switch(*(WORD *)p) {

    case 0xffff:
        p = (WORD *)p + 2;
        break;

    case 0:
        p = (WORD *)p + 1;
        break;

    default:
        p = (PWCHAR)p + lstrlenW(p) + 1;
        break;
    }

    //
    // Skip class, similar to menu
    //
    switch(*(WORD *)p) {

    case 0xffff:
        p = (WORD *)p + 2;
        break;

    case 0:
        p = (WORD *)p + 1;
        break;

    default:
        p = (PWCHAR)p + lstrlenW(p) + 1;
        break;
    }

    //
    // Skip title
    //
    p = (PWCHAR)p + lstrlenW(p) + 1;

    if(Style & DS_SETFONT) {
        //
        // Skip point size and typeface name
        //
        p = (WORD *)p + 1;
        p = (PWCHAR)p + lstrlenW(p) + 1;
    }

    //
    // Now we have a pointer to the first item in the dialog
    //
    for(i=0; i<ItemCount; i++) {

        //
        // Align to next DWORD boundary
        //
        p = (PVOID)(((DWORD)p + sizeof(DWORD) - 1) & (~(sizeof(DWORD) - 1)));
        pItem = p;

        if(pItem->id == (WORD)ControlId) {
            break;
        }

        //
        // Skip to next item in dialog.
        // First i