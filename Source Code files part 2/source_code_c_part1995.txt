vocationData,
    IN OUT DRM_DWORD            *f_pcbRevocationData,
    OUT    DRM_DWORD            *f_pidSerial);

DRM_API DRM_RESULT DRM_CALL DRM_RVK_CheckDeviceRevocation(
    __in  const DRM_CONST_STRING *f_pdstrDevCert,
    __in  const DRM_CONST_STRING *f_pdstrXMLExclusion,
    __out       DRM_BOOL         *f_pfExcluded );

DRM_RESULT DRM_CALL DRM_RVK_GetCRL(
    IN     DRM_CRYPTO_CONTEXT           *f_pContextCrypto,
    IN     DRM_REVOCATIONSTORE_CONTEXT  *f_pContextRev,
    IN     const DRM_GUID               *f_pguidRevocationType,
    __out_bcount_opt( *f_pcbCRL ) DRM_BYTE *f_pbCRL,
    IN OUT DRM_DWORD                    *f_pcbCRL,
       OUT DRM_DWORD                    *f_pdwCRLVersion);

#endif /* DRM_SUPPORT_DEVICE_REVOCATION */

DRM_API DRM_RESULT DRM_CALL DRM_RVK_SetCRL(
    IN     DRM_CRYPTO_CONTEXT           *f_pContextCrypto,
    IN     DRM_REVOCATIONSTORE_CONTEXT  *f_pContextRev,
    IN     const DRM_GUID               *f_pguidRevocationType,
    __in_bcount( f_cbCRL ) DRM_BYTE  *f_pbCRL,
    IN     DRM_DWORD                     f_cbCRL,
    __in_bcount( f_cbRevocationBuffer ) DRM_BYTE *f_pbRevocationBuffer,
    IN     DRM_DWORD                     f_cbRevocationBuffer,
    IN OUT DRM_BOOL                     *f_pfUpdated);

#if DRM_SUPPORT_WMDRMNET

DRM_RESULT DRM_CALL DRM_RVK_GetWMDRMNETRevocationEntries (
    __in_bcount( f_cbRevocationData ) DRM_BYTE *f_pbRevocationData,
    IN     DRM_DWORD            f_cbRevocationData,
       OUT DRM_DWORD           *f_pcEntries,
    __deref_out_ecount( *f_pcEntries ) WMDRMNET_CRL_ENTRY **f_ppEntries);

DRM_RESULT DRM_RVK_UpdateWMDRMNETRevocationList(
    IN          DRM_CRYPTO_CONTEXT   *f_pcontextCrypto,
    IN          DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    __in_ecount( f_pdasstrRevocationList->m_ich + f_pdasstrRevocationList->m_cch ) DRM_CHAR *f_rgchBase,
    IN  const   DRM_SUBSTRING        *f_pdasstrRevocationList,
    __in_bcount( f_cbRevocationBuffer ) DRM_BYTE *f_pbRevocationBuffer,
    IN          DRM_DWORD             f_cbRevocationBuffer,
    IN  const   PUBKEY               *f_ppubkey );

DRM_API DRM_RESULT DRM_CALL DRM_RVK_GetWMDRMNETList(
    IN      DRM_CRYPTO_CONTEXT   *f_pcontextCRYP,
    IN      DRM_REVOCATIONSTORE_CONTEXT *f_pContextRev,
    __out_bcount_opt( *f_pcbRevocationData ) DRM_BYTE *f_pbRevocationData,
    IN  OUT DRM_DWORD            *f_pcbRevocationData,
        OUT DRM_DWORD            *f_pidSerial);

#endif /* DRM_SUPPORT_WMDRMNET */

#endif /* DRM_SUPPORT_REVOCATION */

EXIT_PK_NAMESPACE;

#endif /* __DRMREVOCATION_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmsal.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMSAL_H__
#define __DRMSAL_H__


#if defined( _PREFAST_ ) || ( defined (_MSC_VER) && ( defined (_M_IX86) || defined (_M_IA64) || defined (_M_AMD64) ) && NO_DRM_CRT ) 
    /*
    ** Include the Standard Annotation Langauge header for compilers that have it (ie MSVC)
    */  
    #include <sal.h>
#else

    /*
    ** Ensure the SAL tags are a no-op during compilation.
    */
    #undef __ecount
    #undef __bcount
    #undef __in
    #undef __in_ecount
    #undef __in_bcount
    #undef __in_z
    #undef __in_ecount_z
    #undef __in_bcount_z                                  
    #undef __in_nz                                                 
    #undef __in_ecount_nz                 
    #undef __in_bcount_nz                                   
    #undef __out                                                   
    #undef __out_ecount                                    
    #undef __out_bcount                                
    #undef __out_ecount_part                         
    #undef __out_bcount_part                         
    #undef __out_ecount_full                             
    #undef __out_bcount_full                            
    #undef __out_z                                                 
    #undef __out_z_opt                                             
    #undef __out_ecount_z                             
    #undef __out_bcount_z                            
    #undef __out_ecount_part_z                       
    #undef __out_bcount_part_z                        
    #undef __out_ecount_full_z                          
    #undef __out_bcount_full_z                          
    #undef __out_nz                                                
    #undef __out_nz_opt                                            
    #undef __out_ecount_nz                               
    #undef __out_bcount_nz                                 
    #undef __inout                                                 
    #undef __inout_ecount
    #undef __inout_bcount
    #undef __inout_ecount_part
    #undef __inout_bcount_part
    #undef __inout_ecount_full
    #undef __inout_bcount_full
    #undef __inout_z                                               
    #undef __inout_ecount_z
    #undef __inout_bcount_z
    #undef __inout_nz                                              
    #undef __inout_ecount_nz
    #undef __inout_bcount_nz
    #undef __ecount_opt
    #undef __bcount_opt
    #undef __in_opt                                                
    #undef __in_ecount_opt
    #undef __in_bcount_opt
    #undef __in_z_opt                                              
    #undef __in_ecount_z_opt
    #undef __in_bcount_z_opt
    #undef __in_nz_opt                                             
    #undef __in_ecount_nz_opt
    #undef __in_bcount_nz_opt
    #undef __out_opt                                               
    #undef __out_ecount_opt
    #undef __out_bcount_opt
    #undef __out_ecount_part_opt
    #undef __out_bcount_part_opt
    #undef __out_ecount_full_opt
    #undef __out_bcount_full_opt
    #undef __out_ecount_z_opt
    #undef __out_bcount_z_opt
    #undef __out_ecount_part_z_opt
    #undef __out_bcount_part_z_opt
    #undef __out_ecount_full_z_opt
    #undef __out_bcount_full_z_opt
    #undef __out_ecount_nz_opt
    #undef __out_bcount_nz_opt
    #undef __inout_opt                                             
    #undef __inout_ecount_opt
    #undef __inout_bcount_opt
    #undef __inout_ecount_part_opt
    #undef __inout_bcount_part_opt
    #undef __inout_ecount_full_opt
    #undef __inout_bcount_full_opt
    #undef __inout_z_opt                                           
    #undef __inout_ecount_z_opt                           
    #undef __inout_ecount_z_opt                           
    #undef __inout_bcount_z_opt                           
    #undef __inout_nz_opt                                          
    #undef __inout_ecount_nz_opt                           
    #undef __inout_bcount_nz_opt                           
    #undef __deref_ecount                                  
    #undef __deref_bcount                                  
    #undef __deref_out                                             
    #undef __deref_out_ecount                              
    #undef __deref_out_bcount                              
    #undef __deref_out_ecount_part                    
    #undef __deref_out_bcount_part                    
    #undef __deref_out_ecount_full                    
    #undef __deref_out_bcount_full                    
    #undef __deref_out_z                                           
    #undef __deref_out_ecount_z                              
    #undef __deref_out_bcount_z                              
    #undef __deref_out_nz                                          
    #undef __deref_out_ecount_nz                           
    #undef __deref_out_bcount_nz                           
    #undef __deref_inout                                           
    #undef __deref_inout_z                                         
    #undef __deref_inout_ecount                            
    #undef __deref_inout_bcount                            
    #undef __deref_inout_ecount_part                
    #undef __deref_inout_bcount_part                
    #undef __deref_inout_ecount_full                
    #undef __deref_inout_bcount_full                
    #undef __deref_inout_z                                         
    #undef __deref_inout_ecount_z                        
    #undef __deref_inout_bcount_z                        
    #undef __deref_inout_nz                                        
    #undef __deref_inout_ecount_nz                         
    #undef __deref_inout_bcount_nz                         
    #undef __deref_ecount_opt                             
    #undef __deref_bcount_opt                             
    #undef __deref_out_opt                                         
    #undef __deref_out_ecount_opt                          
    #undef __deref_out_bcount_opt                          
    #undef __deref_out_ecount_part_opt              
    #undef __deref_out_bcount_part_opt              
    #undef __deref_out_ecount_full_opt              
    #undef __deref_out_bcount_full_opt              
    #undef __deref_out_z_opt                                       
    #undef __deref_out_ecount_z_opt                          
    #undef __deref_out_bcount_z_opt                          
    #undef __deref_out_nz_opt                                      
    #undef __deref_out_ecount_nz_opt                       
    #undef __deref_out_bcount_nz_opt                       
    #undef __deref_inout_opt                                       
    #undef __deref_inout_ecount_opt                        
    #undef __deref_inout_bcount_opt                        
    #undef __deref_inout_ecount_part_opt             
    #undef __deref_inout_bcount_part_opt             
    #undef __deref_inout_ecount_full_opt             
    #undef __deref_inout_bcount_full_opt             
    #undef __deref_inout_z_opt                                     
    #undef __deref_inout_ecount_z_opt                     
    #undef __deref_inout_bcount_z_opt                     
    #undef __deref_inout_nz_opt                                    
    #undef __deref_inout_ecount_nz_opt                     
    #undef __deref_inout_bcount_nz_opt                     
    #undef __deref_opt_ecount                            
    #undef __deref_opt_bcount                            
    #undef __deref_opt_out                                         
    #undef __deref_opt_out_z                                       
    #undef __deref_opt_out_ecount                          
    #undef __deref_opt_out_bcount                          
    #undef __deref_opt_out_ecount_part              
    #undef __deref_opt_out_bcount_part              
    #undef __deref_opt_out_ecount_full              
    #undef __deref_opt_out_bcount_full              
    #undef __deref_opt_inout                                       
    #undef __deref_opt_inout_ecount                         
    #undef __deref_opt_inout_bcount                         
    #undef __deref_opt_inout_ecount_part             
    #undef __deref_opt_inout_bcount_part             
    #undef __deref_opt_inout_ecount_full             
    #undef __deref_opt_inout_bcount_full             
    #undef __deref_opt_inout_z                                     
    #undef __deref_opt_inout_ecount_z                      
    #undef __deref_opt_inout_bcount_z                      
    #undef __deref_opt_inout_nz                                    
    #undef __deref_opt_inout_ecount_nz                     
    #undef __deref_opt_inout_bcount_nz                     
    #undef __deref_opt_ecount_opt                          
    #undef __deref_opt_bcount_opt                          
    #undef __deref_opt_out_opt                                     
    #undef __deref_opt_out_ecount_opt                      
    #undef __deref_opt_out_bcount_opt                      
    #undef __deref_opt_out_ecount_part_opt           
    #undef __deref_opt_out_bcount_part_opt           
    #undef __deref_opt_out_ecount_full_opt           
    #undef __deref_opt_out_bcount_full_opt           
    #undef __deref_opt_out_z_opt                                    
    #undef __deref_opt_out_ecount_z_opt                  
    #undef __deref_opt_out_bcount_z_opt                  
    #undef __deref_opt_out_nz_opt                                  
    #undef __deref_opt_out_ecount_nz_opt                   
    #undef __deref_opt_out_bcount_nz_opt                   
    #undef __deref_opt_inout_opt                                   
    #undef __deref_opt_inout_ecount_opt                    
    #undef __deref_opt_inout_bcount_opt                    
    #undef __deref_opt_inout_ecount_part_opt       
    #undef __deref_opt_inout_bcount_part_opt       
    #undef __deref_opt_inout_ecount_full_opt       
    #undef __deref_opt_inout_bcount_full_opt       
    #undef __deref_opt_inout_z_opt                                 
    #undef __deref_opt_inout_ecount_z_opt                  
    #undef __deref_opt_inout_bcount_z_opt                  
    #undef __deref_opt_inout_nz_opt                                
    #undef __deref_opt_inout_ecount_nz_opt                
    #undef __deref_opt_inout_bcount_nz_opt                
    #undef __success                    
    #undef __nullterminated                    
    #undef __nullnullterminated
    #undef __reserved                          
    #undef __checkReturn                       
    #undef __typefix                   
    #undef __override                          
    #undef __callback                          
    #undef __format_string
    #undef __blocksOn               
    #undef __control_entrypoint     
    #undef __data_entrypoint  
    #undef __fallthrough                       
    #undef __analysis_assume

    

    
    
    #define __ecount(size)
    #define __bcount(size)
    #define __in
    #define __in_ecount(size)
    #define __in_bcount(size)
    #define __in_z
    #define __in_ecount_z(size)
    #define __in_bcount_z(size)                                     
    #define __in_nz                                                 
    #define __in_ecount_nz(size)                                    
    #define __in_bcount_nz(size)                                    
    #define __out                                                   
    #define __out_ecount(size)                                      
    #define __out_bcount(size)                                      
    #define __out_ecount_part(size,length)                          
    #define __out_bcount_part(size,length)                          
    #define __out_ecount_full(size)                                 
    #define __out_bcount_full(size)                                 
    #define __out_z                                                 
    #define __out_z_opt                                             
    #define __out_ecount_z(size)                                    
    #define __out_bcount_z(size)                                    
    #define __out_ecount_part_z(size,length)                        
    #define __out_bcount_part_z(size,length)                        
    #define __out_ecount_full_z(size)                               
    #define __out_bcount_full_z(size)                               
    #define __out_nz                                                
    #define __out_nz_opt                                            
    #define __out_ecount_nz(size)                                   
    #define __out_bcount_nz(size)                                   
    #define __inout                                                 
    #define __inout_ecount(size)                                    
    #define __inout_bcount(size)                                    
    #define __inout_ecount_part(size,length)                        
    #define __inout_bcount_part(size,length)                        
    #define __inout_ecount_full(size)                               
    #define __inout_bcount_full(size)                               
    #define __inout_z                                               
    #define __inout_ecount_z(size)                                  
    #define __inout_bcount_z(size)                                  
    #define __inout_nz                                              
    #define __inout_ecount_nz(size)                                 
    #define __inout_bcount_nz(size)                                 
    #define __ecount_opt(size)                                      
    #define __bcount_opt(size)                                      
    #define __in_opt                                                
    #define __in_ecount_opt(size)                                   
    #define __in_bcount_opt(size)                                   
    #define __in_z_opt                                              
    #define __in_ecount_z_opt(size)                                 
    #define __in_bcount_z_opt(size)                                 
    #define __in_nz_opt                                             
    #define __in_ecount_nz_opt(size)                                
    #define __in_bcount_nz_opt(size)                                
    #define __out_opt                                               
    #define __out_ecount_opt(size)                                  
    #define __out_bcount_opt(size)                                  
    #define __out_ecount_part_opt(size,length)                      
    #define __out_bcount_part_opt(size,length)                      
    #define __out_ecount_full_opt(size)                             
    #define __out_bcount_full_opt(size)                             
    #define __out_ecount_z_opt(size)                                
    #define __out_bcount_z_opt(size)                                
    #define __out_ecount_part_z_opt(size,length)                    
    #define __out_bcount_part_z_opt(size,length)                    
    #define __out_ecount_full_z_opt(size)                           
    #define __out_bcount_full_z_opt(size)                           
    #define __out_ecount_nz_opt(size)                               
    #define __out_bcount_nz_opt(size)                               
    #define __inout_opt                                             
    #define __inout_ecount_opt(size)                                
    #define __inout_bcount_opt(size)                                
    #define __inout_ecount_part_opt(size,length)                    
    #define __inout_bcount_part_opt(size,length)                    
    #define __inout_ecount_full_opt(size)                           
    #define __inout_bcount_full_opt(size)                           
    #define __inout_z_opt                                           
    #define __inout_ecount_z_opt(size)                              
    #define __inout_ecount_z_opt(size)                              
    #define __inout_bcount_z_opt(size)                              
    #define __inout_nz_opt                                          
    #define __inout_ecount_nz_opt(size)                             
    #define __inout_bcount_nz_opt(size)                             
    #define __deref_ecount(size)                                    
    #define __deref_bcount(size)                                    
    #define __deref_out                                             
    #define __deref_out_ecount(size)                                
    #define __deref_out_bcount(size)                                
    #define __deref_out_ecount_part(size,length)                    
    #define __deref_out_bcount_part(size,length)                    
    #define __deref_out_ecount_full(size)                           
    #define __deref_out_bcount_full(size)                           
    #define __deref_out_z                                           
    #define __deref_out_ecount_z(size)                              
    #define __deref_out_bcount_z(size)                              
    #define __deref_out_nz                                          
    #define __deref_out_ecount_nz(size)                             
    #define __deref_out_bcount_nz(size)                             
    #define __deref_inout                                           
    #define __deref_inout_z                                         
    #define __deref_inout_ecount(size)                              
    #define __deref_inout_bcount(size)                              
    #define __deref_inout_ecount_part(size,length)                  
    #define __deref_inout_bcount_part(size,length)                  
    #define __deref_inout_ecount_full(size)                         
    #define __deref_inout_bcount_full(size)                         
    #define __deref_inout_z                                         
    #define __deref_inout_ecount_z(size)                            
    #define __deref_inout_bcount_z(size)                            
    #define __deref_inout_nz                                        
    #define __deref_inout_ecount_nz(size)                           
    #define __deref_inout_bcount_nz(size)                           
    #define __deref_ecount_opt(size)                                
    #define __deref_bcount_opt(size)                                
    #define __deref_out_opt                                         
    #define __deref_out_ecount_opt(size)                            
    #define __deref_out_bcount_opt(size)                            
    #define __deref_out_ecount_part_opt(size,length)                
    #define __deref_out_bcount_part_opt(size,length)                
    #define __deref_out_ecount_full_opt(size)                       
    #define __deref_out_bcount_full_opt(size)                       
    #define __deref_out_z_opt                                       
    #define __deref_out_ecount_z_opt(size)                          
    #define __deref_out_bcount_z_opt(size)                          
    #define __deref_out_nz_opt                                      
    #define __deref_out_ecount_nz_opt(size)                         
    #define __deref_out_bcount_nz_opt(size)                         
    #define __deref_inout_opt                                       
    #define __deref_inout_ecount_opt(size)                          
    #define __deref_inout_bcount_opt(size)                          
    #define __deref_inout_ecount_part_opt(size,length)              
    #define __deref_inout_bcount_part_opt(size,length)              
    #define __deref_inout_ecount_full_opt(size)                     
    #define __deref_inout_bcount_full_opt(size)                     
    #define __deref_inout_z_opt                                     
    #define __deref_inout_ecount_z_opt(size)                        
    #define __deref_inout_bcount_z_opt(size)                        
    #define __deref_inout_nz_opt                                    
    #define __deref_inout_ecount_nz_opt(size)                       
    #define __deref_inout_bcount_nz_opt(size)                       
    #define __deref_opt_ecount(size)                                
    #define __deref_opt_bcount(size)                                
    #define __deref_opt_out                                         
    #define __deref_opt_out_z                                       
    #define __deref_opt_out_ecount(size)                            
    #define __deref_opt_out_bcount(size)                            
    #define __deref_opt_out_ecount_part(size,length)                
    #define __deref_opt_out_bcount_part(size,length)                
    #define __deref_opt_out_ecount_full(size)                       
    #define __deref_opt_out_bcount_full(size)                       
    #define __deref_opt_inout                                       
    #define __deref_opt_inout_ecount(size)                          
    #define __deref_opt_inout_bcount(size)                          
    #define __deref_opt_inout_ecount_part(size,length)              
    #define __deref_opt_inout_bcount_part(size,length)              
    #define __deref_opt_inout_ecount_full(size)                     
    #define __deref_opt_inout_bcount_full(size)                     
    #define __deref_opt_inout_z                                     
    #define __deref_opt_inout_ecount_z(size)                        
    #define __deref_opt_inout_bcount_z(size)                        
    #define __deref_opt_inout_nz                                    
    #define __deref_opt_inout_ecount_nz(size)                       
    #define __deref_opt_inout_bcount_nz(size)                       
    #define __deref_opt_ecount_opt(size)                            
    #define __deref_opt_bcount_opt(size)                            
    #define __deref_opt_out_opt                                     
    #define __deref_opt_out_ecount_opt(size)                        
    #define __deref_opt_out_bcount_opt(size)                        
    #define __deref_opt_out_ecount_part_opt(size,length)            
    #define __deref_opt_out_bcount_part_opt(size,length)            
    #define __deref_opt_out_ecount_full_opt(size)                   
    #define __deref_opt_out_bcount_full_opt(size)                   
    #define __deref_opt_out_z_opt                                    
    #define __deref_opt_out_ecount_z_opt(size)                      
    #define __deref_opt_out_bcount_z_opt(size)                      
    #define __deref_opt_out_nz_opt                                  
    #define __deref_opt_out_ecount_nz_opt(size)                     
    #define __deref_opt_out_bcount_nz_opt(size)                     
    #define __deref_opt_inout_opt                                   
    #define __deref_opt_inout_ecount_opt(size)                      
    #define __deref_opt_inout_bcount_opt(size)                      
    #define __deref_opt_inout_ecount_part_opt(size,length)          
    #define __deref_opt_inout_bcount_part_opt(size,length)          
    #define __deref_opt_inout_ecount_full_opt(size)                 
    #define __deref_opt_inout_bcount_full_opt(size)                 
    #define __deref_opt_inout_z_opt                                 
    #define __deref_opt_inout_ecount_z_opt(size)                    
    #define __deref_opt_inout_bcount_z_opt(size)                    
    #define __deref_opt_inout_nz_opt                                
    #define __deref_opt_inout_ecount_nz_opt(size)                   
    #define __deref_opt_inout_bcount_nz_opt(size)                   
    #define __success(expr)                     
    #define __nullterminated                    
    #define __nullnullterminated
    #define __reserved                          
    #define __checkReturn                       
    #define __typefix(ctype)                    
    #define __override                          
    #define __callback                          
    #define __format_string
    #define __blocksOn(resource)                
    #define __control_entrypoint(category)      
    #define __data_entrypoint(category)         
    #define __fallthrough                       
    #define __analysis_assume(expr) 

#endif
    
#endif  /* __DRMSAL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmsecureclock.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMSECURECLOCK_H__
#define __DRMSECURECLOCK_H__

ENTER_PK_NAMESPACE;

typedef struct __tagDRM_SECSTORE_CLOCK_DATA
{
    DRM_TID        tid;
    DRM_DWORD      fInGracePeriod; /*Used as a DRM_BOOL. DWORD for compatibility*/
    DRM_UINT64     LastKnownGoodSecureClock;
    DRM_UINT64     LastKnownRealtimeSecureClock;
    DRM_UINT64     LastKnownGracePeriodStartTime;
    DRM_UINT64     RefreshDate;
    DRM_UINT64     ChallengeTime;
    DRM_DWORD      flag; /*One bit for each member. Starting from TID. For data validity*/
} DRM_SECSTORE_CLOCK_DATA;

#define CLK_TID_VALID           0x00000001
#define CLK_IN_GP_VALID         0x00000002
#define CLK_LK_GSC_VALID        0x00000004
#define CLK_LK_RSC_VALID        0x00000008
#define CLK_LK_GP_VALID         0x00000010
#define CLK_REFRESHDATE_VALID   0x00000020
#define CLK_CHALLENGETIME_VALID 0x00000040
#define CLK_EVER_SET            0x00000080

DRM_VOID _PrepareSecureClockDataForWriting( DRM_SECSTORE_CLOCK_DATA *pData );
#define _PrepareSecureClockDataForReading _PrepareSecureClockDataForWriting

/* pseudo-hashes to read/write Data in the secure store */

extern DRM_EXPORT_VAR const DRM_ID g_idSData;
extern DRM_EXPORT_VAR const DRM_ID g_idSDataPrev;


/**********************************************************************
** Function:    DRM_CLK_CreateChallenge
** Synopsis:    Creates a Secure Clock challenge.
** Arguments:   
**              [pdstrURL] -- pointer to DevCert struct
**              [rgbSecStoreInPswd] -- Secure store password
**              [pContext] -- pointer to DRM_CRYPTO_CONTEXT
**              [poDatastore] -- pointer to DST_CONTEXT
**              [poSecureStoreContext] -- pointer to Secure Store context
**              [pOEMContext] -- OEM implemented context
**              [pwszUrl] -- user allocated buffer to get URL in WCHAR
**              [pcchUrl] -- character count of pwszUrl. Can be NULL if URL is not required.
**              [pbData] -- user allocated buffer to be used as output buffer
**              [pcbData] -- size of pbData
** Returns:     DRM_SUCCESS on success. On Failure, it returns:
**              DRM_E_INVALIDARG
**              DRM_E_BUFFERTOOSMALL
** Notes:       To get the minimum size required, first call with pbData=NULL and
**              pcbData points to value 0. This will return DRM_E_BUFFERTOOSMALL 
**              and pcbData will point to a value of minimum context size.
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_CLK_CreateChallenge(
    IN const DRM_CONST_STRING        *pdstrURL,
    IN const DRM_BYTE                 rgbSecStoreInPswd [__CB_DECL(DRM_SHA1_DIGEST_LEN)],
    IN       DRM_CRYPTO_CONTEXT      *pContext, 
    IN       DRM_DST                 *poDatastore,
    IN       DRM_SECSTORE_CONTEXT    *poSecureStoreContext,
    IN       DRM_VOID                *pOEMContext,
    OUT      DRM_WCHAR               *pwszUrl,
    IN OUT   DRM_DWORD               *pcchUrl,
    IN       DRM_BYTE                *pbData,
    IN OUT   DRM_DWORD               *pcbData );


/**********************************************************************
** Function:    DRM_CLK_ProcessResponse
** Synopsis:    Process Secure clock request response received from server
** Arguments:   [pDevCert] -- pointer to DevCert struct
**              [pbResponse] -- Response string received from server
**              [cbResponse] -- size of pbResponse in bytes.
**              [rgbSecStoreInPswd] -- Secure store password
**              [pResult] --pointer to DRM_RESULT to get error from server included in response
**              [pContext] --pointer to the DRM_CRYPTO_CONTEXT
**              [poDatastore] -- pointer to DST_CONTEXT
**              [poSecureStoreContext] -- pointer to Secure Store context
**              [poLicEvalContext] -- pointer to LICEVAL_CONTEXT
**              [pOEMContext] -- OEM defined context
** Returns:     DRM_SUCCESS on success, or failed with 
**              DRM_E_INVALIDARG,
**              CLK_INVALID_RESPONSE, and
**              error codes from Licesne store.
**
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_CLK_ProcessResponse(
    IN const PUBKEY                *ppubkeySecureClockServer,
    IN       DRM_BYTE              *pbResponse,
    IN       DRM_DWORD              cbResponse,
    IN const DRM_BYTE               rgbSecStoreInPswd [__CB_DECL(DRM_SHA1_DIGEST_LEN)],
    OUT      DRM_RESULT            *pResult,
    IN       DRM_CRYPTO_CONTEXT    *pContext,
    IN       DRM_DST               *poDatastore,
    IN       DRM_SECSTORE_CONTEXT  *poSecureStoreContext,
    IN       DRM_LICEVAL_CONTEXT   *poLicEvalContext,
    IN       DRM_VOID              *pOEMContext );

/**********************************************************************
** Function:    DRM_CLK_GetSecureClock
** Synopsis:    Gets Secure clock.
** Arguments:   
**              [poSecureTime] -- pointer to WCHAR buffer to get Secure time 
**              [pcchSecureTime] -- size of buffer in WCHAR
**              [pdwFlags] -- pointer to DWORD. 0 not set, 1 set, 2 need refresh
**              [pbSecureTimeWithStatus] -- pointer to BYTE buffer to get Secure time and flag status in XML format. Optional 
**              [pcbSecureTimeWithStatus] -- size of buffer. Optioanl
**              [rgbSecStoreInPswd] -- Secure store password
**              [pContext] -- pointer to DRM_CRYPTO_CONTEXT
**              [poDatastore] -- pointer to DST_CONTEXT
**              [poSecureStoreContext] -- pointer to Secure Store context
**              [pOEMContext] -- OEM implmented context
** Returns:     DRM_SUCCESS on success. 
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_CLK_GetSecureClock(
    OUT      DRM_WCHAR            *pwszSecureTime,
    IN OUT   DRM_DWORD            *pcchSecureTime, 
    OUT      DRM_DWORD            *pdwFlags,
    IN       DRM_BYTE             *pbSecureTimeWithStatus,
    IN OUT   DRM_DWORD            *pcbSecureTimeWithStatus, 
    IN const DRM_BYTE              rgbSecStoreInPswd [__CB_DECL(DRM_SHA1_DIGEST_LEN)],
    IN       DRM_CRYPTO_CONTEXT   *pContext,
    IN       DRM_DST              *poDatastore,
    IN       DRM_SECSTORE_CONTEXT *poSecureStoreContext,
    IN       DRM_VOID             *pOEMContext );


/**********************************************************************
** Function:    DRM_CLK_InitCheckSecureClock
** Synopsis:    Initializes and checks Secure clock. Called by DRM_Manager_Init
** Arguments:   
**              [rgbSecStoreInPswd] -- Secure store password
**              [pContext] -- pointer to DRM_CRYPTO_CONTEXT
**              [poDatastore] -- pointer to DST_CONTEXT
**              [pfClockset] -- pointer to DRM_BOOL to know whether clock is set.
**              [poSecureStoreContext] -- pointer to Secure Store context
**              [poLicEvalContext] -- pointer to LICEVAL_CONTEXT
**              [pOEMContext] -- OEM implmented context
** Returns:     DRM_SUCCESS on success. 
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_CLK_InitCheckSecureClock(
    IN const DRM_BYTE              rgbSecStoreInPswd [__CB_DECL(DRM_SHA1_DIGEST_LEN)],
    IN       DRM_CRYPTO_CONTEXT   *pContext,
    IN       DRM_DST              *poDatastore,
    IN OUT   DRM_BOOL             *pfClockset,
    IN       DRM_SECSTORE_CONTEXT *poSecureStoreContext,
    IN       DRM_LICEVAL_CONTEXT  *poLicEvalContext,
    IN       DRM_VOID             *pOEMContext );

EXIT_PK_NAMESPACE;

#endif /*__DRMSECURECLOCK_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmrsa.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef _DRMRSA_H_
#define _DRMRSA_H_

#include <oemrsa.h>
#include <drmrsacommon.h>
#include <drmtypes.h>

ENTER_PK_NAMESPACE;

/*
** Definitions for OAEP padding scheme (see PKCS #1 v2.1)
*/ 
#define OAEP_IB_EM_START                    0
#define OAEP_CB_EM_START                    1

#define OAEP_IB_SEED                        ( OAEP_IB_EM_START + OAEP_CB_EM_START )
#define OAEP_CB_SEED                        DRM_SHA1_DIGEST_LEN

#define OAEP_IB_DATABLOCK                   ( OAEP_IB_SEED + OAEP_CB_SEED )
#define OAEP_CB_DATABLOCK( keyLength ) \
    ( OAEP_CB_ENCRYPTED_MSG( keyLength ) - OAEP_CB_EM_START - OAEP_CB_SEED )
#define OAEP_CB_DATABLOCK_MAX               OAEP_CB_DATABLOCK( eDRM_RSA_MAXIMUM_KEY_LENGTH )

#define OAEP_IB_DATABLOCK_HASH              OAEP_IB_DATABLOCK
#define OAEP_CB_DATABLOCK_HASH              DRM_SHA1_DIGEST_LEN

#define OAEP_IB_DATABLOCK_PS                ( OAEP_IB_DATABLOCK_HASH + OAEP_CB_DATABLOCK_HASH )
#define OAEP_CB_DATABLOCK_PS( keyLength, msgLength ) \
    ( OAEP_CB_DATABLOCK_MSG_MAX( keyLength ) - msgLength )  

#define OAEP_IB_DATABLOCK_MSG_START( keyLength, msgLength ) \
    ( OAEP_IB_DATABLOCK_PS + OAEP_CB_DATABLOCK_PS( keyLength, msgLength ) )                   
#define OAEP_CB_DATABLOCK_MSG_START         1

#define OAEP_IB_DATABLOCK_MSG( keyLength, msgLength ) \
    ( OAEP_IB_DATABLOCK_MSG_START( keyLength, msgLength ) + OAEP_CB_DATABLOCK_MSG_START )
#define OAEP_CB_DATABLOCK_MSG( msgLength )  ( msgLength )
#define OAEP_CB_DATABLOCK_MSG_MAX( keyLength ) \
    ( OAEP_CB_ENCRYPTED_MSG( keyLength ) - OAEP_CB_EM_START - OAEP_CB_SEED - OAEP_CB_DATABLOCK_HASH - OAEP_CB_DATABLOCK_MSG_START )

#define OAEP_CB_ENCRYPTED_MSG( keyLength )  DRM_RSA_CB_CIPHERTEXT( keyLength )
#define OAEP_CB_ENCRYPTED_MSG_MAX           DRM_RSA_CB_CIPHERTEXT( eDRM_RSA_MAXIMUM_KEY_LENGTH )
    
#define OAEP_B_EM_START                     0x00
#define OAEP_B_MSG_START                    0x01

/*
** Definitions for PSS signature scheme (see PKCS #1 v2.1)
*/
#define PSS_B_END_MSG      0xBC
#define PSS_CB_ZERO_PAD    8
#define PSS_CB_SALT        0
#define PSS_CB_MPRIME      ( BITS_PER_STANDARD_BYTE + DRM_SHA1_DIGEST_LEN + PSS_CB_SALT )
#define PSS_IB_SALT        ( PSS_CB_ZERO_PAD + DRM_SHA1_DIGEST_LEN )
 
/*
** Definitions for mask generation (MGF1)
*/ 
#define MGF1_CB_MAX_SEED( keyLength )   OAEP_CB_DATABLOCK( keyLength )
#define MGF1_CB_MAX_SEED_MAX            MGF1_CB_MAX_SEED( eDRM_RSA_MAXIMUM_KEY_LENGTH )
#define MGF1_CB_MAX_MASK( keyLength )   ( ( ( OAEP_CB_DATABLOCK( keyLength ) / DRM_SHA1_DIGEST_LEN ) + 1 ) * DRM_SHA1_DIGEST_LEN )
#define MGF1_CB_MAX_MASK_MAX            MGF1_CB_MAX_MASK( eDRM_RSA_MAXIMUM_KEY_LENGTH )


DRM_API DRM_RESULT DRM_CALL DRM_RSA_OaepDecrypt(
    __in const                          DRM_RSA_PRIVATE_KEY *f_pPrivateKey,
    __in const                          DRM_DWORD            f_cbCiphertext,
    __in_ecount( f_cbCiphertext ) const DRM_BYTE            *f_pbCiphertext,
    __inout                             DRM_DWORD           *f_pcbPlaintext,
    __out_ecount( *f_pcbPlaintext )     DRM_BYTE            *f_pbPlaintext,
    __in                                DRM_CRYPTO_CONTEXT  *f_pCryptoCtx 
    ); 

DRM_API DRM_RESULT DRM_CALL DRM_RSA_OaepEncrypt(
    __in_opt                           DRM_VOID           *f_pOEMContext,
    __in const                         DRM_RSA_PUBLIC_KEY *f_pPublicKey,
    __in const                         DRM_DWORD           f_cbPlaintext,
    __in_ecount( f_cbPlaintext ) const DRM_BYTE           *f_pbPlaintext,
    __inout                            DRM_DWORD          *f_pcbCiphertext,
    __out_ecount( *f_pcbCiphertext )   DRM_BYTE           *f_pbCiphertext,
    __in                               DRM_CRYPTO_CONTEXT *f_pCryptoCtx 
    );

DRM_API DRM_RESULT DRM_CALL DRM_RSA_PssSign(
    __in const                      DRM_RSA_PRIVATE_KEY *f_pPrivateKey,
    __in const                      DRM_DWORD            f_cbMsg,
    __in_ecount( f_cbMsg ) const    DRM_BYTE            *f_pbMsg,
    __in const                      DRM_DWORD            f_ibMsg,    
    __inout                         DRM_DWORD           *f_pcbSignature,
    __out_ecount( *f_pcbSignature ) DRM_BYTE            *f_pbSignature,
    __in                            DRM_CRYPTO_CONTEXT  *f_pCryptoCtx 
    );

DRM_API DRM_RESULT DRM_CALL DRM_RSA_PssVerify(
    __in const                         DRM_RSA_PUBLIC_KEY  *f_pPublicKey,
    __in                               DRM_DWORD            f_cbMsg,
    __in_ecount( f_cbMsg ) const       DRM_BYTE            *f_pbMsg,
    __in const                         DRM_DWORD            f_ibMsg,
    __in const                         DRM_DWORD            f_cbSignature,
    __in_ecount( f_cbSignature ) const DRM_BYTE            *f_pbSignature,
    __in                                DRM_CRYPTO_CONTEXT *f_pCryptoCtx 
    );
    
EXIT_PK_NAMESPACE;

#endif /* _DRMRSA_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmsecureclockstatus.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMSECURECLOCKSTATUS_H__
#define __DRMSECURECLOCKSTATUS_H__

ENTER_PK_NAMESPACE;

#define DRM_CLK_NOT_SET 0
#define DRM_CLK_SET 1
#define DRM_CLK_NEEDS_REFRESH 2
#define DRM_CLK_NOT_PRESENT 0xFFFFFFFF

EXIT_PK_NAMESPACE;

#endif /*__DRMSECURECLOCKSTATUS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmsha256.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMSHA256_H__
#define __DRMSHA256_H__ 1

#include <drmcommon.h>

ENTER_PK_NAMESPACE;

/*
** Sha-256 defines
*/

#define SHA256_DIGEST_SIZE_IN_BYTES  32
#define SHA256_STATE_SIZE_IN_BYTES   256
#define SHA256_STATE_SIZE_IN_DWORDS  8
#define SHA256_STATE_SIZE_IN_INT64S  4
#define SHA256_BLOCK_SIZE_IN_BYTES   64
#define SHA256_BLOCK_SIZE_IN_DWORDS  16
#define SHA256_NUM_ITERATIONS        64
#define SHA256_NUM_FRONT_ITERATIONS  16

/*
** Structs
*/
typedef struct __tagSHA256_CTX
{
    union 
    {
#if _WIN64
        DRM_UINT64 m_rgu64State64[ SHA256_STATE_SIZE_IN_INT64S ]; /* force alignment */
#endif
        DRM_DWORD  m_rgdwState[ SHA256_STATE_SIZE_IN_DWORDS ];   /* state (ABCDEFGH) */
    } m_rgUnion; /* end union */

    DRM_DWORD m_rgdwCount[ 2 ]; /* number of bytes, msb first */
    DRM_DWORD m_rgdwBuffer[SHA256_BLOCK_SIZE_IN_DWORDS]; /* input buffer */
} DRM_SHA256_Context;

typedef struct __tagSHA256_Digest
{
    DRM_BYTE m_rgbDigest[ __CB_DECL( SHA256_DIGEST_SIZE_IN_BYTES ) ];
} DRM_SHA256_Digest;


/*
** Function Prototypes
*/

DRM_API DRM_RESULT DRM_CALL DRM_SHA256_Init(
    __in_ecount( 1 ) DRM_SHA256_Context *f_pShaContext );

DRM_API DRM_RESULT DRM_CALL DRM_SHA256_Update(
    __inout_ecount( 1 )             DRM_SHA256_Context *f_pShaContext,
    __in_ecount( f_cbBuffer ) const DRM_BYTE            f_rgbBuffer[],
    __in                            DRM_DWORD           f_cbBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_SHA256_UpdateOffset(
    __inout_ecount( 1 )                                DRM_SHA256_Context *f_pShaContext,
    __in_ecount( f_cbBuffer + f_ibBufferOffset ) const DRM_BYTE            f_rgbBuffer[],
    __in                                               DRM_DWORD           f_cbBuffer,
    __in                                               DRM_DWORD           f_ibBufferOffset );

DRM_API DRM_RESULT DRM_CALL DRM_SHA256_Finalize(
    __inout_ecount( 1 ) DRM_SHA256_Context *f_pContext,
    __inout_ecount( 1 ) DRM_SHA256_Digest  *f_pDigest );

EXIT_PK_NAMESPACE;

#endif /* #ifndef __DRMSHA256_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmsecurestore.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMSECURESTORE_H__
#define __DRMSECURESTORE_H__

#include <drmtoken.h>
#include <drmblackbox.h>

ENTER_PK_NAMESPACE;

#define DRM_SEC_STORE_MAX_SLOT_SIZE     1024 + 2*SIZEOF(DRM_DWORD) + DRM_SHA1_DIGEST_LEN
#define DRM_MAX_ATTRIBUTES_PER_SST_KEY    25
#define DRM_MAX_ATTRIBUTE_STRING_LENGTH   25

/* 
    Secure store API users.  Please note that there are 3 modes these APIs open the secure store in.
    The standard DRM_SST_OpenKeyTokens API will open and cache a secure store entry.  This data will
    be flushed to disk on a call to DRM_SST_CloseKey.  No file I/O is done in the calls to 
    DRM_SST_GetTokenValue and DRM_SST_SetTokenValue in between.

    Using the enumerator APIs requries that the DST context the enum is given be kept open the whole 
    time.

    And finally the DRM_SST_GetData & DRM_SST_SetData are direct read/write tunnels to the secure data in
    the secure store.  The secure store opens and closes the DST during this call so no caching in on.
    If the Token APIs are too restrictive going directly to these raw read/write may be the best option; but these
    should be used with caution.
*/


typedef enum
{
    SECURE_STORE_UNDEFINED_DATA          = 0x0,    // Added for a PC client
    SECURE_STORE_LICENSE_DATA            = 0x1,
    SECURE_STORE_GLOBAL_DATA             = 0x2,
    SECURE_STORE_REVOCATION_DATA         = 0x3,
    SECURE_STORE_METERING_DATA           = 0x4,
    SECURE_STORE_PLAYLIST_BURNING_DATA   = 0x5,
    SECURE_STORE_DEVICE_REGISTRATION_DATA= 0x6,
    SECURE_STORE_CACHED_CERTIFICATE_DATA = 0x7,
    SECURE_STORE_TRANSIENT_DATA          = 0x8,
} eDRM_SECURE_STORE_TYPE;

#define DRM_SECURE_STORE_NUM_CHILD_NODES 0x10



/* In the slot meta data if the high bit is set it is raw data.  Otherwise it is TOKEN data */
#define DRM_SST_RAW_DATA                0x80000000
#define DRM_SST_SLOT_SIZE_MASK          0x3FFF0000
#define DRM_SST_SLOT_SIZE_VALID_MASK    0x40000000
#define DRM_SST_DEVREG_PREALLOCATE_SIZE 30000
#define DRM_SST_PREALLOCATE_SIZE        500
#define DRM_SST_SLOT_DATA_MASK          0x7FFFFF00
#define DRM_SST_SLOT_VERSION_MASK       0x0000FF00
#define DRM_SST_SLOT_VERSION            0x00000100


#define DRM_SST_SLOT_V0_HASH_OFFSET  SIZEOF(DRM_DWORD)
#define DRM_SST_SLOT_V0_DATA_OFFSET (DRM_SST_SLOT_V0_HASH_OFFSET + DRM_SHA1_DIGEST_LEN)
#define DRM_SST_SLOT_V0_HEADER_SIZE  DRM_SST_SLOT_V0_DATA_OFFSET

#define DRM_SST_SLOT_METADATA_SIZE     SIZEOF(DRM_DWORD)
#define DRM_SST_SLOT_SIZEDATA_SIZE     SIZEOF(DRM_DWORD)
#define DRM_SST_SLOT_HASH_OFFSET  DRM_SST_SLOT_METADATA_SIZE + DRM_SST_SLOT_SIZEDATA_SIZE
#define DRM_SST_SLOT_DATA_OFFSET (DRM_SST_SLOT_HASH_OFFSET + DRM_SHA1_DIGEST_LEN)
#define DRM_SST_SLOT_HEADER_SIZE  DRM_SST_SLOT_DATA_OFFSET

#define DRM_SST_SET_SLOT_SIZE_IN_METADATA( dwMetaData, cbSlotData ) \
        {                                                           \
                dwMetaData &= ~DRM_SST_SLOT_SIZE_MASK;              \
                dwMetaData |= (cbSlotData << 16)                    \
                           |  DRM_SST_SLOT_SIZE_VALID_MASK;         \
        }
#define DRM_SST_SET_SLOT_METADATA( dwMetaData )         \
        {                                                           \
                dwMetaData &= ~DRM_SST_SLOT_DATA_MASK;              \
                dwMetaData |= DRM_SST_SLOT_VERSION                  \
                           |  DRM_SST_SLOT_SIZE_VALID_MASK;         \
        }

#define DRM_SST_GET_SLOT_SIZE_FROM_METADATA( cbSlotData, dwMetaData ) cbSlotData = (dwMetaData & DRM_SST_SLOT_SIZE_MASK) >> 16;           

/* These are methods to resolve conflicts when data is written to the secure store but some other
** instance already wrote their changes to the secure store.
*/
#define DRM_TOKEN_RESOLVE_BITMASK    7
#define DRM_TOKEN_RESOLVE_CALLBACK   0 /* The supplied callback function will resolve the conflict */
#define DRM_TOKEN_RESOLVE_FIRST_WINS 1 /* The first data to be Committed will be persisted */
#define DRM_TOKEN_RESOLVE_LAST_WINS  2 /* The last data to be Commited will be persisted */
#define DRM_TOKEN_RESOLVE_DELTA      3 /* Available for TOKEN_LONG datatype or other numeric types only */

#define DRM_TOKEN_FLAG_DIRTY         16 /* The token has been changed since being loaded */

typedef struct __tagCachedAttribute
{
    PERSISTEDTOKEN    TokenDelta;
    DRM_CONST_STRING  dstrAttribute;

    /* First 2 bits of dwFlags is for DRM_TOKEN_RESOLVE_*
    */
    DRM_DWORD         dwFlags;
    
    DRM_BYTE         *pTokenValue;  /* Never assume this is aligned before accessing it!!*/
}CachedAttribute;

typedef struct __tagSEC_STORE_CONTEXT
{    
    DRM_DST_NAMESPACE_CONTEXT oNsContext;
    DRM_DST_SLOT_CONTEXT      oSlotContext;

    CachedAttribute rgAttributes [DRM_MAX_ATTRIBUTES_PER_SST_KEY];
    DRM_BYTE        rgbSlotData  [__CB_DECL(DRM_SEC_STORE_MAX_SLOT_SIZE)];
    DRM_BYTE        rgbPassword  [__CB_DECL(DRM_SHA1_DIGEST_LEN)];
        
    DRM_DST_KEY     rgbKey1;
    DRM_DST_KEY     rgbKey2;
    
    const DRM_DST_NAMESPACE *pNamespaceId;
    eDRM_SECURE_STORE_TYPE   eType;

    DRM_WORD wNumAttributes;
    DRM_WORD wNumOriginalAttributes;
    DRM_DWORD cbSlotData;
    DRM_DWORD cbSlot;
    DRM_BOOL fInited;
    DRM_DST  *pDatastore;
    DRM_BOOL fOpened;
    DRM_BOOL fLocked;
    DRM_BOOL fDirty;
    DRM_DWORD dwSlotVersion;
    DRM_BOOL  fNoPassword;
    DRM_DST_SLOT_HINT slotHint;
} DRM_SECSTORE_CONTEXT;

EXIT_PK_NAMESPACE;

#include <drmcallbacks.h>

ENTER_PK_NAMESPACE;

typedef enum _tag_EnumModeSST
{
    eSSTEnumNone=0,       /* no secure store entries found */    
    eSSTEnumFiltered,     /* enum for secure store entries matching given ID */
    eSSTEnumNatural       /* enum all secure store entries */
} _EnumModeSST;

typedef struct _tag_DRM_SECSTOREENUM_CONTEXT
{
    DRM_DST_ENUM_CONTEXT      oDstEnumContext;
    DRM_DST_NAMESPACE_CONTEXT oNsContext;
    DRM_DST_SLOT_CONTEXT      oSlotContext;
    DRM_BOOL                  fInited;
    _EnumModeSST              eMode;
    eDRM_SECURE_STORE_TYPE    eType;
    DRM_BOOL                  fCurrIsValid;
    DRM_KID                   oCurrKID;
    DRM_LID                   oCurrLID;
    DRM_DST                  *pDatastore;
} DRM_SECSTOREENUM_CONTEXT;


/* Flags for DRM_SST_OpenKeyTokens */
#define DRM_SECURE_STORE_CREATE_NEW             0x1
#define DRM_SECURE_STORE_OPEN_ALWAYS            0x2
#define DRM_SECURE_STORE_OPEN_EXISTING          0x4

#define DRM_SECURE_STORE_VALID_FLAGS    (DRM_SECURE_STORE_CREATE_NEW | DRM_SECURE_STORE_OPEN_ALWAYS | DRM_SECURE_STORE_OPEN_EXISTING)

DRM_RESULT DRM_SST_LoadAttributesIntoCache(
    IN const DRM_BYTE        *pbSlotData,
    IN       DRM_DWORD        cbSlotData,
       OUT   CachedAttribute  rgAttributes[DRM_MAX_ATTRIBUTES_PER_SST_KEY],
       OUT   DRM_WORD        *pwNumAttributes);

DRM_API DRM_RESULT DRM_CALL DRM_SST_GetTokenValueFromCache(
    IN const DRM_WORD              wRightID,
    IN const DRM_WORD              wRestrictionID,
    IN const DRM_CONST_STRING     *pdstrAttribute,
    IN  CachedAttribute            rgAttributes[DRM_MAX_ATTRIBUTES_PER_SST_KEY], 
    IN  DRM_WORD                   wNumAttributes,
       OUT   TOKEN                *pToken );

DRM_API DRM_RESULT DRM_CALL DRM_SST_LoadKeyTokens(
    IN OUT   DRM_SECSTORE_CONTEXT   *pcontextSST,
    IN       DRM_DWORD               dwFlags,
    IN       DRM_DST                *pDatastore );

DRM_API DRM_RESULT DRM_CALL DRM_SST_OpenKeyTokens(
    IN OUT   DRM_SECSTORE_CONTEXT   *pbSecureStoreContext,
    IN const DRM_ID                 *pKey1,
    IN const DRM_ID                 *pKey2,
    __in_bcount( DRM_SHA1_DIGEST_LEN ) const DRM_BYTE rgbPassword[__CB_DECL(DRM_SHA1_DIGEST_LEN)],
    IN       DRM_DWORD               dwFlags,
    IN       eDRM_SECURE_STORE_TYPE  eType,
    IN       DRM_DST                *pDatastore);

DRM_API DRM_RESULT DRM_CALL DRM_SST_GetTokenValue(
    IN       DRM_SECSTORE_CONTEXT *pbSecureStoreContext,
    IN const DRM_CONST_STRING     *pdstrAttribute,
       OUT   TOKEN                *pToken );

DRM_API DRM_RESULT DRM_CALL DRM_SST_GetExtendedTokenValue(
    IN       DRM_SECSTORE_CONTEXT *pcontextSST,
    IN const DRM_WORD              wRightID,
    IN const DRM_WORD              wRestrictionID,
    IN const DRM_CONST_STRING     *pdstrAttribute,
       OUT   TOKEN                *pToken );

DRM_API DRM_RESULT DRM_CALL DRM_SST_SetTokenValue(
    IN       DRM_SECSTORE_CONTEXT *pbSecureStoreContext,
    IN const DRM_CONST_STRING     *pdstrAttribute,
    IN const TOKEN                *pToken );

DRM_API DRM_RESULT DRM_CALL DRM_SST_SetExtendedTokenValue(
    IN       DRM_SECSTORE_CONTEXT *pcontextSST,
    IN const DRM_WORD              wRightID,
    IN const DRM_WORD              wRestrictionID,
    IN const DRM_CONST_STRING     *pdstrAttribute,
    IN const TOKEN                *pToken,
    IN       DRM_DWORD             dwFlags );

DRM_API DRM_RESULT DRM_CALL DRM_SST_CloseKey( 
    IN       DRM_SECSTORE_CONTEXT *pcontextSST, 
    IN       DRM_DST              *pDatastore,
    IN       DRMPFNPOLICYCALLBACK  pfnMergeCallback,
    IN       const DRM_VOID       *pvCallbackData );

DRM_API DRM_RESULT DRM_CALL DRM_SST_OpenAndLockSlot(
    IN          DRM_DST                *f_pDatastore,
    IN          eDRM_SECURE_STORE_TYPE  f_eType,
    IN  const   DRM_ID                 *f_pKey1,
    IN  const   DRM_ID                 *f_pKey2,
    __in_bcount( DRM_SHA1_DIGEST_LEN ) const DRM_BYTE f_rgbPassword[__CB_DECL(DRM_SHA1_DIGEST_LEN)],
    IN          DRM_DWORD               f_dwFlags,
        OUT     DRM_SECSTORE_CONTEXT   *f_pcontextSST,
        OUT     DRM_DWORD              *f_pcbData );

DRM_API DRM_RESULT DRM_CALL DRM_SST_GetLockedData(
    IN       DRM_SECSTORE_CONTEXT   *f_pcontextSST,
    __out_bcount_opt( *f_pcbData ) DRM_BYTE *f_pbData,
       OUT   DRM_DWORD              *f_pcbData );

DRM_API DRM_RESULT DRM_CALL DRM_SST_SetLockedData(
    IN          DRM_SECSTORE_CONTEXT   *f_pcontextSST,
    IN          DRM_DWORD               f_cbData,
    __in_bcount( f_cbData ) const DRM_BYTE *f_pbData );

DRM_API DRM_RESULT DRM_CALL DRM_SST_CloseLockedSlot( IN  DRM_SECSTORE_CONTEXT *f_pcontextSST );

DRM_API DRM_RESULT DRM_CALL DRM_SST_GetData(
    IN       DRM_SECSTORE_CONTEXT   *f_pcontextSST,
    IN const DRM_ID                 *f_pKey1,
    IN const DRM_ID                 *f_pKey2,
    __in_bcount( DRM_SHA1_DIGEST_LEN ) const DRM_BYTE f_rgbPassword[__CB_DECL(DRM_SHA1_DIGEST_LEN)],
    IN       eDRM_SECURE_STORE_TYPE  f_eType,
    IN       DRM_DST                *f_pDatastore,
    __out_bcount_opt( *f_pcbData ) DRM_BYTE *f_pbData,
       OUT   DRM_DWORD              *f_pcbData );

DRM_API DRM_RESULT DRM_CALL DRM_SST_SetData(
    IN       DRM_SECSTORE_CONTEXT   *f_pcontextSST,
    IN const DRM_ID                 *f_pKey1,
    IN const DRM_ID                 *f_pKey2,
    __in_bcount( DRM_SHA1_DIGEST_LEN ) const DRM_BYTE f_rgbPassword[__CB_DECL(DRM_SHA1_DIGEST_LEN)],
    IN       eDRM_SECURE_STORE_TYPE  f_eType,
    IN       DRM_DST                *f_pDatastore,
    __in_bcount( f_cbData ) const DRM_BYTE *f_pbData,
    IN       DRM_DWORD               f_cbData );


/* Delete an entry from the secure store.  Be careful when this happens -- it could open up the system for 
   replay attacks */
DRM_API DRM_RESULT DRM_CALL DRM_SST_DeleteKey(
    IN       DRM_SECSTORE_CONTEXT   *pbSecureStoreContext,
    IN       eDRM_SECURE_STORE_TYPE  eType,
    IN const DRM_ID                 *pid1,
    IN const DRM_ID                 *pid2,
    IN       DRM_DST                *pDatastore);


DRM_API DRM_RESULT DRM_CALL DRM_SST_GetAllData( 
    IN     DRM_SECSTORE_CONTEXT *pbSecureStoreContext,
    __out_bcount_opt( *pcbData ) DRM_BYTE *pbData,
    IN OUT DRM_DWORD            *pcbData );

/* The enumeration APIs work on 2 keys or IDs.  When opening an enumerator the caller should pass in key1 (the first key used 
    calls to DRM_SST_SetData and DRM_SST_OpenKeyTokens.  All entries with this value as the first key will be listed in the
    enumeration.  On calls to DRM_SST_EnumNext the value of key2 will be returned so that the caller can use the combination of
    key1 and key2 to open a unique SST entry. */

DRM_API DRM_RESULT DRM_CALL DRM_SST_OpenEnumerator(
    IN        eDRM_SECURE_STORE_TYPE    eType,
    IN  const DRM_ID                   *pKey1,
    OUT       DRM_SECSTOREENUM_CONTEXT *pSecEnumContext,
    IN        DRM_DST                  *pDatastore,
    IN        DRM_BOOL                  fExclusiveLock);

DRM_API DRM_RESULT DRM_CALL DRM_SST_EnumNext( 
    IN  DRM_SECSTOREENUM_CONTEXT *pSecEnumContext,
    OUT DRM_ID                   *pKey1,
    OUT DRM_ID                   *pKey2,
    OUT DRM_DWORD                *pcbData );

DRM_API DRM_RESULT DRM_CALL DRM_SST_EnumLoadCurrent( 
    IN       DRM_SECSTOREENUM_CONTEXT *pcontextSSTEnum,
    IN OUT   DRM_SECSTORE_CONTEXT     *pcontextSST,
    __in_bcount( DRM_SHA1_DIGEST_LEN ) const DRM_BYTE rgbPassword[__CB_DECL(DRM_SHA1_DIGEST_LEN)],
       OUT   DRM_ID                   *pKey1,
       OUT   DRM_ID                   *pKey2,
    IN OUT DRM_DWORD                  *pcbData);

DRM_API DRM_RESULT DRM_CALL DRM_SST_EnumDeleteCurrent( 
    IN       DRM_SECSTOREENUM_CONTEXT *pcontextSSTEnum,
    IN OUT   DRM_SECSTORE_CONTEXT     *pcontextSST);

DRM_API DRM_RESULT DRM_CALL DRM_SST_CreateGlobalStorePassword(
    __out_bcount( DRM_SHA1_DIGEST_LEN ) DRM_BYTE f_rgbPasswordSST[__CB_DECL(DRM_SHA1_DIGEST_LEN)],
    IN  DRM_BYTE       *f_pbContextBBX);

DRM_API DRM_RESULT DRM_CALL DRM_SST_CreateLicenseStatePassword(
    IN            const DRM_LID  *f_plid,
    __out_bcount( DRM_SHA1_DIGEST_LEN ) DRM_BYTE  f_rgbPasswordLST[__CB_DECL(DRM_SHA1_DIGEST_LEN)],
    IN            DRM_BB_CONTEXT *f_pContextBBX);

EXIT_PK_NAMESPACE;

#endif /* __DRMSECURESTORE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmsha1.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMSHA_1_H__
#define __DRMSHA_1_H__

#include <drmtypes.h>

ENTER_PK_NAMESPACE;

#define DRM_SHA1_DIGEST_LEN 20    /* 5 32-bit numbers which is 20 BYTES */
#define DRM_SHA1_BLOCK_SIZE 64    /* Sha operates on 64 BYTE blocks */

#define DRM_SHA1_B64ENC_DIGEST_LEN CCH_BASE64_EQUIV( DRM_SHA1_DIGEST_LEN )


/**********************************************************************
** Struct:      DRM_SHA1_CONTEXT
**
** Synopsis:    Maintains the running state of a sha operations
**
** Members:        [dwHighByteCount] -- High order of the byte count
**                [dwLowByteCount] -- Low order of the byte count
**                [bTempBuffer] -- Maximum temp buffer we may need 
**                [ABCDE] -- current SHA state
**
***********************************************************************/
typedef struct __tagDRM_SHA1_CONTEXT
{
    DRM_DWORD dwHighByteCount;
    DRM_DWORD dwLowByteCount;    
    DRM_BYTE  bTempBuffer[__CB_DECL( DRM_SHA1_BLOCK_SIZE )];
    DRM_DWORD ABCDE[5];
} DRM_SHA1_CONTEXT;

/*********************************************************************
**
**  Function:  DRM_SHA1_Init
**
**  Synopsis:  Start a clean new instance of Sha
**
**  Arguments:  
**     [pShaContext] -- Pointer to context to hold current state of sha
**
**  Returns:  None
**
*********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_SHA1_Init(
    IN OUT DRM_SHA1_CONTEXT* pShaContext );

/*********************************************************************
**
**  Function:  DRM_SHA1_Update
**
**  Synopsis:  
**
**  Arguments:  
**     [pbData] -- array of bytes to add to the sha computation
**     [cbData] -- length of pbData in bytes
**     [pShaContext] -- running sha context
**
**  Returns:  
**
*********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_SHA1_Update(
    __in_bcount( cbData ) const DRM_BYTE *pbData,
    IN       DRM_DWORD         cbData,
    IN OUT   DRM_SHA1_CONTEXT *pShaContext );


DRM_API DRM_RESULT DRM_CALL DRM_SHA1_UpdateOffset(
    __in_bcount( ibData + cbData ) const DRM_BYTE *pbData,
    IN       DRM_DWORD         ibData,
    IN       DRM_DWORD         cbData,
    IN OUT   DRM_SHA1_CONTEXT *pShaContext );

/*********************************************************************
**
**  Function:  DRM_SHA1_Finalize
**
**  Synopsis:  
**
**  Arguments:  
**     [pShaContext] -- current running sha context
**     [ShaDigest] -- resultant sha digest from sha operation
**
**  Returns:  None
**
*********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_SHA1_Finalize(
    IN     DRM_SHA1_CONTEXT *pShaContext,
    __out_bcount( DRM_SHA1_DIGEST_LEN ) DRM_BYTE rgbDigest[__CB_DECL(DRM_SHA1_DIGEST_LEN)] );

EXIT_PK_NAMESPACE;

#endif /* __DRMSHA_1_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmsoapxmlconstants.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_SOAP_XML_CONSTANTS_H
#define __DRM_SOAP_XML_CONSTANTS_H

ENTER_PK_NAMESPACE;

/*
** -------------------------------------------------------------------
** XML strings used in the parsing of status code from server response
** -------------------------------------------------------------------
*/
extern const DRM_ANSI_CONST_STRING g_dastrSOAPExceptionRootPath;

extern const DRM_ANSI_CONST_STRING g_dastrSOAPExceptionSignaturePath;

extern const DRM_ANSI_CONST_STRING g_dastrSOAPExceptionCustomDataPath;

extern const DRM_ANSI_CONST_STRING g_dastrSOAPStatusCodePath;

extern const DRM_ANSI_CONST_STRING g_dastrSOAPGARDCustomDataPath;

extern const DRM_ANSI_CONST_STRING g_dastrSOAPGARDRedirectUrlPath;

extern const DRM_ANSI_CONST_STRING g_dastrSOAPGARDServiceIdPath;

extern const DRM_ANSI_CONST_STRING g_dastrSOAPGARDAccountIdPath;


/*
** -----------------------------------------------------
** XML strings used in the construction of SOAP envelope
** -----------------------------------------------------
*/
extern const DRM_ANSI_CONST_STRING g_dastrXMLRootTag;

extern const DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeTag;

extern const DRM_ANSI_CONST_STRING g_dastrSOAPBodyTag;


extern const DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib1Name;
extern const DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib1Value;

extern const DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib2Name;
extern const DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib2Value;

extern const DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib3Name;
extern const DRM_ANSI_CONST_STRING g_dastrSOAPEnvelopeAttrib3Value;

extern const DRM_ANSI_CONST_STRING g_dastrSOAPPreserveSpaceAttribName;
extern const DRM_ANSI_CONST_STRING g_dastrSOAPPreserveSpaceAttribValue;

EXIT_PK_NAMESPACE;

#endif /* __DRM_SOAP_XML_CONSTANTS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmsoapxmlutility.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_SOAP_XML_UTILITY_H
#define __DRM_SOAP_XML_UTILITY_H

#include <drmxmlbuildera.h>
#include <drmxmlsig.h>
#include <drmmanager.h>
ENTER_PK_NAMESPACE;

/* Whether to generate SOAP envelope. */
#define DRM_USE_SOAP        1

/*
** Type of data element to be retrieved from the server response.
** GARD stands for Get Additional Response Data.
*/
enum
{
    /* Data type code for custom data. */
    DRM_GARD_CUSTOM_DATA  = 1,

    /* Data type code for redirected URL. */
    DRM_GARD_REDIRECT_URL = 2,

    /* Data type code for service ID. */
    DRM_GARD_SERVICE_ID   = 3,

    /* Data type code for account ID. */
    DRM_GARD_ACCOUNT_ID   = 4
};

/*
** ---------------------------------------
** SOAP XML utility API functions
** ---------------------------------------
*/
DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_EncodeData(
    __in_ecount( f_cchData )         const DRM_CHAR  *f_pchData,
    IN                                     DRM_DWORD  f_cchData,
    __out_ecount_opt( *f_pcchEncodedData ) DRM_CHAR  *f_pchEncodedData,
    OUT                                    DRM_DWORD *f_pcchEncodedData );

DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_DecodeData(
    __in_ecount( f_cchData )               DRM_CHAR  *f_pchData,
    IN                                     DRM_DWORD  f_cchData,
    __out_ecount_opt( *f_pcchDecodedData ) DRM_CHAR  *f_pchDecodedData,
    OUT                                    DRM_DWORD *f_pcchDecodedData );

DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_PadANSIString(
    IN OUT DRM_ANSI_STRING *f_pdastrIn,
    IN     DRM_DWORD        f_cchPad );

DRM_API DRM_BOOL DRM_CALL DRM_SOAPXML_IsBlankGUID(
    IN DRM_GUID *f_poGUID );

DRM_API DRM_DWORD DRM_CALL DRM_SOAPXML_CalcDWORDCharCount(
    IN DRM_DWORD f_dwNumber );

#if DRM_USE_SOAP

DRM_API DRM_DWORD DRM_CALL DRM_SOAPXML_CalcSOAPHeaderCharCount( DRM_VOID );

DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_SkipSOAPHeaders(
    __in_ecount( f_pdasstrResponse->m_ich + f_pdasstrResponse->m_cch ) DRM_CHAR      *f_pszResponse,
    IN OUT                                                             DRM_SUBSTRING *f_pdasstrResponse );

DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_PrependXMLRoot(
    IN OUT DRM_ANSI_STRING *f_pdastrXML );

DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_BuildSOAPHeaderXML(
    IN OUT _XMBContextA *f_poXMLContext,
    IN     DRM_DWORD     f_cbXMLContext );

#endif

DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_InitXMLKey(
    IN     DRM_VOID           *f_poOEMContext,
    OUT    DRM_XML_KEY        *f_poXMLKey,
    IN OUT DRM_CRYPTO_CONTEXT *f_pCryptoCtx );

DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_EncryptDataWithXMLKey(
    IN     DRM_VOID              *f_poOEMContext,
    IN OUT DRM_XML_KEY           *f_poXMLKey,
    IN OUT DRM_ANSI_CONST_STRING *f_pdastrData,
    IN OUT DRM_CRYPTO_CONTEXT    *f_pCrypto );

DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_GetDeviceCert(
    __in_opt                              DRM_VOID  *f_poOEMContext,
    IN                                    DRM_BOOL   f_fB64Encoded,
    __out_ecount_opt( *f_pcchDeviceCert ) DRM_CHAR  *f_pchDeviceCert,
    IN OUT                                DRM_DWORD *f_pcchDeviceCert );

DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_PrepareXMLContext(
    __in_bcount( f_cbXMLContext )          DRM_BYTE      *f_pbXMLContext,
    IN                                     DRM_DWORD      f_cbXMLContext,
    __deref_out_bcount( *f_pcbXMLContext ) _XMBContextA **f_ppoXMLContext,
    OUT                                    DRM_DWORD     *f_pcbXMLContext );

DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_ParseCustomDataForProtocol(
    __in_bcount( f_cbResponse )     const DRM_BYTE  *f_pbResponse,
    __in                                  DRM_DWORD  f_cbResponse,
    __in                                  DRM_DWORD  f_dwProtocolType,
    __out_ecount_opt( *f_pcchCustomData ) DRM_CHAR  *f_pchCustomData,
    __inout_opt                           DRM_DWORD *f_pcchCustomData );

DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_ValidateProtocolSignature(
    __in_bcount( f_cbResponse )   const DRM_BYTE       *f_pbResponse,
    __in                                DRM_DWORD       f_cbResponse,
    __inout_bcount( f_cbScratchBCertBuffer )
                                        DRM_BYTE       *f_pbScratchBCertBuffer,
    __in                          const DRM_DWORD       f_cbScratchBCertBuffer,
    __in                                DRM_BB_CONTEXT *f_poBBXContext,
    __inout                             DRM_DWORD      *f_pdwProtocolType );

DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_ParseStatusCodeAndChooseBest(
    __in_bcount( f_cbResponse ) const DRM_BYTE   *f_pbResponse,
    IN                                DRM_DWORD   f_cbResponse,
    IN                                DRM_RESULT  f_drOriginal,
    OUT                               DRM_RESULT *f_pResult );

DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_ParseStatusCode(
    __in_bcount( f_cbResponse ) const DRM_BYTE   *f_pbResponse,
    __in                              DRM_DWORD   f_cbResponse,
    __out                             DRM_RESULT *f_pResult );

DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_GetAdditionalResponseData(
    __in_bcount( f_cbResponse )     const DRM_BYTE  *f_pbResponse,
    IN                                    DRM_DWORD  f_cbResponse,
    IN                                    DRM_DWORD  f_dwDataType,
    __out_ecount_opt( *f_pcchDataString ) DRM_CHAR  *f_pchDataString,
    IN OUT                                DRM_DWORD *f_pcchDataString );

DRM_API DRM_RESULT DRM_CALL Drm_GetAdditionalResponseData(
    IN                                    DRM_APP_CONTEXT *f_poAppContext,
    __in_bcount( f_cbResponse )     const DRM_BYTE        *f_pbResponse,
    IN                                    DRM_DWORD        f_cbResponse,
    IN                                    DRM_DWORD        f_dwDataType,
    __out_ecount_opt( *f_pcchDataString ) DRM_CHAR        *f_pchDataString,
    IN OUT                                DRM_DWORD       *f_pcchDataString );

DRM_API DRM_RESULT DRM_CALL DRM_SOAPXML_EnsureTagValueNativeByteAligned(
    __inout _XMBContextA *f_poXMLContext,
    __in const DRM_ANSI_CONST_STRING *f_pdastrTagName );

enum DRM_SOAPXML_PROTOCOL_TYPE
{
    DRM_SOAPXML_PROTOCOL_UNKNOWN                   = 0x00,
    DRM_SOAPXML_PROTOCOL_EXCEPTION                 = 0x01,
    DRM_SOAPXML_PROTOCOL_DOMAIN_JOIN_RESPONSE      = 0x02,
    DRM_SOAPXML_PROTOCOL_DOMAIN_LEAVE_RESPONSE     = 0x03,
    DRM_SOAPXML_PROTOCOL_METERING_CERT_RESPONSE    = 0x04,
    DRM_SOAPXML_PROTOCOL_METERING_DATA_RESPONSE    = 0x05,
    DRM_SOAPXML_PROTOCOL_LIC_ACQ_RESPONSE          = 0x06,
    DRM_SOAPXML_PROTOCOL_LIC_ACQ_ACK_RESPONSE      = 0x07,
    DRM_SOAPXML_PROTOCOL_MAXIMUM_DEFINED           = 0x07
};

typedef struct tagDRM_SOAPXML_PROTOCOL_INTERNAL_DEFINE
{
    const DRM_ANSI_CONST_STRING *pdastrCustomDataPath;
    const DRM_ANSI_CONST_STRING *pdastrDataPath;
    const DRM_ANSI_CONST_STRING *pdastrSignaturePath;
    DRM_BOOL                     fSignatureRequired;
} DRM_SOAPXML_PROTOCOL_INTERNAL_DEFINE;

#define EMPTY_DRM_SOAPXML_PROTOCOL_INTERNAL_DEFINE { NULL, NULL, NULL, FALSE }

EXIT_PK_NAMESPACE;

#endif /* __DRM_SOAP_XML_UTILITY_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmstkalloc.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_STACK_ALLOCATOR__
#define __DRM_STACK_ALLOCATOR__

ENTER_PK_NAMESPACE;

#define DRM_STK_REQUIRED(cbData) \
    (   (cbData) \
    +   SIZEOF(DRM_DWORD) \
    +   ( ((cbData) % SIZEOF(DRM_DWORD_PTR) == 0) ? (0) : (SIZEOF(DRM_DWORD_PTR) - ((cbData) % SIZEOF(DRM_DWORD_PTR))) ) )  

typedef struct __tagDRM_STACK_ALLOCATOR_CONTEXT
{
    DRM_DWORD nStackTop;    /* position of stack top */
    DRM_DWORD cbStack;      /* size of stack */
    DRM_BYTE *pbStack;      /* stack buffer */
    DRM_BOOL  fWasPreAlloc; /* used to signal that we PreAlloc, and Alloc shouldn't fill mem with 0xaa */
} DRM_STACK_ALLOCATOR_CONTEXT;

/*********************************************************************
**
**  Function:  DRM_STK_Free
**
**  Synopsis:  Free a buffer that was allocated using DRM_STK_Alloc.
**
**  Arguments:  
**     [pContext] -- Stack allcator context that was used to allocate the pbBuffer parameter
**     [pbBuffer] -- Pointer returned from a call to DRM_STK_Alloc
**
**  Notes:  Pointers must be freed in LIFO order ( just like a stack ).
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STK_Free(
    IN DRM_STACK_ALLOCATOR_CONTEXT *pContext,
    IN DRM_VOID                    *pbBuffer);

#define SAFE_STK_FREE(pdsac,pv)    \
    if (pv != NULL)                \
    {                              \
        DRM_STK_Free (pdsac, pv);  \
        pv = NULL;                 \
    }

DRM_API DRM_RESULT DRM_CALL DRM_STK_PreAlloc(
    IN  DRM_STACK_ALLOCATOR_CONTEXT *pContext,
    OUT DRM_DWORD                   *pcbSize,
    __deref_out_bcount( *pcbSize ) DRM_VOID **ppbBuffer);

/*********************************************************************
**
**  Function:  DRM_STK_Alloc
**
**  Synopsis:  Allocates a buffer from a give stack context
**
**  Arguments:  
**     [pContext] -- Stack allocator context to allocate from
**     [cbSize] -- Size of the buffer needed
**     [ppbBuffer] -- Pointer to pointer to hold the new memory offset.
**
**  Notes:  Pointers must be freed in LIFO order ( just like a stack ).
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STK_Alloc(
    IN  DRM_STACK_ALLOCATOR_CONTEXT *pContext,
    IN  DRM_DWORD                    cbSize,
    __deref_out_bcount( cbSize ) DRM_VOID **ppbBuffer);

DRM_API DRM_RESULT DRM_CALL DRM_STK_Alloc_Aligned(
    IN  DRM_STACK_ALLOCATOR_CONTEXT *pContext,
    IN  DRM_DWORD                    cbSize,
    IN  DRM_DWORD                    cbAligned,
    __out_opt DRM_VOID             **ppbBufferRaw,
    __deref_out_bcount( cbSize ) DRM_VOID  **ppbBufferAligned );

/*********************************************************************
**
**  Function:  DRM_STK_Init
**
**  Synopsis:  Initializes stack with supplied buffer and size.
**             It is kind of trivial, but frees person from
               knoledge about stack structure. 
**  Arguments:  
**     [pContext] -- Stack allocator context to allocate from
**     [pbBuffer] -- Pointer for the buffer for the stack
**     [cbSize] --  Size of the buffer supplied
**
**  Notes:  Pointers must be freed in LIFO order ( just like a stack ).
**
*********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_STK_Init(
    IN  DRM_STACK_ALLOCATOR_CONTEXT *pContext,
    __in_bcount( cbSize) DRM_BYTE *pbBuffer,
    IN  DRM_DWORD                    cbSize   );

EXIT_PK_NAMESPACE;

#endif /* __DRM_STACK_ALLOCATOR__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmsyncstore.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_SYNC_STORE__
#define __DRM_SYNC_STORE__

#include <drmsyncstorecontext.h>

ENTER_PK_NAMESPACE;

/* Sync store helper functions */
DRM_RESULT _GetKIDStoreData(
    IN                                        DRM_SYNC_CONTEXT          *f_pcontextSYN,
    IN const                                  DRM_KID                   *f_pkid,
    IN                                        DRM_DST_SLOT_HINT         *f_pslotHint,
       OUT                                    DRM_LICENSE_STATE_DATA    *f_plsd,
       __out_ecount_opt(*f_pcchContentHeader) DRM_WCHAR                 *f_pwszContentHeader,
    IN OUT                                    DRM_DWORD                 *f_pcchContentHeader);

DRM_RESULT _GetKIDLicenseData (IN  DRM_DST                    *f_pDatastore,
                               IN  DRM_VIEW_RIGHTS_CONTEXT    *f_pcontextViewRightsIn,
                               OUT DRM_LICENSE_STATE_DATA     *f_plsd);

DRM_RESULT _SetKIDStoreData(
    IN       DRM_SYNC_CONTEXT          *f_pcontextSYN,
    IN const DRM_KID                   *f_pkid,
    IN       DRM_DST_SLOT_HINT         *f_pslotHint,
    IN const DRM_LICENSE_STATE_DATA    *f_plsd,
    IN const DRM_STRING                *f_pdstrContentHeader,
    IN       DRM_BOOL                   f_fCreateIfNotExisting );

DRM_BOOL _SyncRequired(DRM_VOID                  *pOEMContext,
                       DRM_DWORD                  cMaxCountIn,
                       DRM_DWORD                  cMaxHoursIn,
                       DRM_LICENSE_STATE_DATA    *plsd,
                       DRM_UINT64                *pui64ThreshholdTime);

DRM_BOOL _StoreRefreshRequired (
                IN DRM_VOID               *f_pOEMContext,
                IN DRM_LICENSE_STATE_DATA *f_plsd);

/* low-level access to the sync store */

/**********************************************************************
 *                     PUBLIC FUNCTION DRM_SNC_OpenStore
 **********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_SNC_OpenStore(
    IN  DRM_DST          *f_pDatastore,
    OUT DRM_SYNC_CONTEXT *f_pcontextSyncOut);

/**********************************************************************
 *                     PUBLIC FUNCTION DRM_SNC_CloseStore
 **********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_SNC_CloseStore(
    IN  DRM_SYNC_CONTEXT *f_pcontextSyncIn);


/**********************************************************************
 *                    PUBLIC FUNCTION DRM_SNC_InitEnum
 ***********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_SNC_InitEnum(
    IN  DRM_SYNC_CONTEXT       *f_pcontextSyncIn, 
    OUT DRM_SYNC_ENUM_CONTEXT  *f_pcontextSyncEnumOut);

DRM_API DRM_RESULT DRM_CALL DRM_SNC_EnumNext(
    IN  DRM_SYNC_ENUM_CONTEXT  *f_pcontextSYNEnum, 
    OUT DRM_KID                *f_pkid,
    OUT DRM_DST_SLOT_HINT      *f_pslotHint);

DRM_API DRM_RESULT DRM_CALL DRM_SNC_GetSyncStoreEntry(
    IN                                       DRM_SYNC_CONTEXT        *f_pcontextSYN, 
    IN const                                 DRM_KID                 *f_pkid,
       OUT                                   DRM_LICENSE_STATE_DATA  *f_plsd,
       __out_ecount_opt(*f_pcchContentHeader)DRM_WCHAR               *f_pwszContentHeader,
    IN OUT                                   DRM_DWORD               *f_pcchContentHeader);

DRM_API DRM_RESULT DRM_CALL DRM_SNC_UpdateKID(
    IN       DRM_SYNC_CONTEXT        *f_pcontextSYN, 
    IN       DRM_VIEW_RIGHTS_CONTEXT *f_pcontextViewRightsIn,
    IN const DRM_KID                 *f_pkid,
    IN const DRM_CONST_STRING        *f_pdstrContentHeader,
    IN       DRM_BOOL                 f_fForceSync );

#define DRM_SYNC_IGNORE_THRESHOLD_PARAMETER    0xFFFFFFFF

/* inner implementations of DRM_Manager-level Sync API */

DRM_API DRM_RESULT DRM_CALL DRM_SNC_DidLicenseExpire(
    IN     DRM_SYNC_CONTEXT          *f_pcontextSync,
    IN     DRM_VIEW_RIGHTS_CONTEXT   *f_pcontextViewRights,
    IN     DRM_DST                   *f_pDatastore,
    IN      DRM_KID                  *f_pKID,
       OUT  DRM_BOOL                 *f_pfExpired );

DRM_API DRM_RESULT DRM_CALL DRM_SNC_GenerateSyncChallenge (
    IN     DRM_SYNC_CONTEXT            *f_pcontextSync,
    IN     DRM_VIEW_RIGHTS_CONTEXT     *f_pcontextViewRights,
    IN     DRM_DST                     *f_pDatastore,
    IN     DRM_STACK_ALLOCATOR_CONTEXT *f_pcontextStack,
    IN     DRM_DWORD                    f_cMaxCount,
    IN     DRM_DWORD                    f_cMaxHours,
    IN     DRM_DWORD                    f_iKIDStart,
    IN     DRM_DWORD                    f_cKIDs,
       OUT DRM_DWORD                   *f_piKIDNext,
       OUT DRM_DWORD                   *f_pcKIDs,
       OUT _XMBContext                 *f_pbChallenge,
    IN OUT DRM_DWORD                   *f_pcbChallenge);


/*********************************************************************
** Function: DRM_SNC_DeleteKID
**
** Synopsis: delete the indicated KID from the sync store; its absense
**           is not an error
**
** Parameters:
**
** [f_pcontextSYN]          -- initialized SYNC context
** [f_pkid]                 -- pointer to KID to be added/updated
**********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_SNC_DeleteKID(
    IN       DRM_SYNC_CONTEXT *f_pcontextSYN, 
    IN const DRM_KID          *f_pkid);



extern const DRM_CONST_STRING* const g_apdstrActions [1];


EXIT_PK_NAMESPACE;

#endif /* __DRM_SYNC_STORE__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmsyncstorecontext.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_SYNC_STORE_CONTEXT__
#define __DRM_SYNC_STORE_CONTEXT__

ENTER_PK_NAMESPACE;

typedef struct _tagSyncContext
{    
    DRM_DST_SLOT_CONTEXT      contextDSTSlot;
    DRM_DST_NAMESPACE_CONTEXT contextNameSpace;
    DRM_DST                  *pDatastore;
    DRM_BOOL                  fInited;
} DRM_SYNC_CONTEXT_PRIVATE;

typedef struct _tagSyncListEntry
{
    DRM_BOOL fIsValid;
    DRM_KID  kid;
} SyncListEntry;

typedef struct _tagSyncEnumContext
{
    DRM_SYNC_CONTEXT_PRIVATE *pcontextSync;
    DRM_DST_ENUM_CONTEXT      contextDSTEnum;
    DRM_DST_SLOT_CONTEXT      contextDSTSlot;
    DRM_BOOL                  fInited,
                              fAny;
    SyncListEntry             itemSync;
} DRM_SYNC_ENUM_CONTEXT_PRIVATE;

/* opaque versions of contexts, corresponding to those actually declared in drmsyncstore.c */

typedef struct __tagDRM_SYNC_CONTEXT
{
    DRM_BYTE rgbOpaqueData [__CB_DECL(SIZEOF(DRM_SYNC_CONTEXT_PRIVATE))];
} DRM_SYNC_CONTEXT;

typedef struct __tagDRM_SYNC_ENUM_CONTEXT
{
    DRM_BYTE rgbOpaqueData [__CB_DECL(SIZEOF(DRM_SYNC_ENUM_CONTEXT_PRIVATE))];
} DRM_SYNC_ENUM_CONTEXT;


EXIT_PK_NAMESPACE;

#endif /* __DRM_SYNC_STORE_CONTEXT__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmtoken.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_TOKEN_H__
#define __DRM_TOKEN_H__

ENTER_PK_NAMESPACE;

typedef enum
{
    /* Tokens expected from the expression */
    TOKEN_VARIABLE=0,
    TOKEN_FUNCTION,
    
    TOKEN_LONG,
    TOKEN_DATETIME,
    TOKEN_BYTEBLOB, /* Indicates that the data is variable length raw binary */
    TOKEN_STRING,
    
    TOKEN_PLUS,
    TOKEN_MINUS,
    TOKEN_ADD,
    TOKEN_SUB,
    TOKEN_MUL,
    TOKEN_DIV,
    TOKEN_MOD,
    TOKEN_PREINCR,
    TOKEN_POSTINCR,
    TOKEN_PREDECR,
    TOKEN_POSTDECR,
    TOKEN_ASSIGN,
    TOKEN_LESS,
    TOKEN_LESSEQ,
    TOKEN_GREAT,
    TOKEN_GREATEQ,
    TOKEN_NOTEQ,
    TOKEN_EQ,
    TOKEN_NOT,
    TOKEN_AND,
    TOKEN_OR,
    TOKEN_IF,
    TOKEN_COLON,
    TOKEN_SEMICOLON,
    TOKEN_OPEN,
    TOKEN_CLOSE,
    TOKEN_COMMA,
    TOKEN_UNKNOWN,

    /* For internal Use of the processing algorithm */
    TOKEN_IFSKIP,
    TOKEN_COLONSKIP,
    TOKEN_ANDSKIP,
    TOKEN_ORSKIP,
    TOKEN_UNARYSYNC, /* indicates that the pre unary operator just pushed into operator stack needs  right operand. */
    TOKEN_FUNCTIONSYNC, /* indicates that the fucntion sysmbol just pushed need right arguments. Popping of arguments should stop at this token. */
} DRM_EXPR_TOKEN_TYPE;

typedef enum
{
    FN_DATEADD,
    FN_DATEDIFF,
    FN_MIN,
    FN_MAX,
    FN_INDEX,
    FN_DATEPART,
    FN_VERSIONCOMPARE,
    FN_DELETELICENSE,
    FN_EXISTS,
    FN_LENGTH
} DRM_EXPR_FUNCTION_TYPE;

/*
   In the context of the expression evaluator any token can be placed in here.  When one of these tokens
   is given to the secure store the only valid token types are 
       TOKEN_LONG and  TOKEN_DATETIME
*/


#if defined (_MSC_VER)
#pragma warning(disable:4103)
#pragma pack(push)
#pragma pack(1)
#endif

typedef struct tagTOKEN
{
    DRM_DWORD TokenType;
    union _tagTokenValue
    {
        DRM_UINT64 u64DateTime;
        DRM_LONG lValue;
        DRM_CONST_STRING stringValue;
        DRM_DWORD fnValue;
        DRM_BYTEBLOB byteValue;
    } val;
}TOKEN;

/*
** NOTE:  This structure should be 12 bytes long to allow for binary compatability of the secure store.
**        Using MS Visual C++ we have to use #pragma pack to achieve this 
*/
typedef struct tagPERSISTEDTOKEN
{
    DRM_DWORD TokenType;
    union _tagPersistedTokenValue
    {
        DRM_UINT64 u64DateTime;
        DRM_LONG   lValue;
        DRM_WORD   wValue;
    } val;
} PERSISTEDTOKEN;

/* Calculates the number of bytes the token takes up when persisted */
#define CALC_PERSISTEDTOKEN_FILE_LENGTH(pToken) (pToken->TokenType == TOKEN_BYTEBLOB ? max( SIZEOF( PERSISTEDTOKEN ), SIZEOF( PERSISTEDTOKEN ) + pToken->val.byteValue.cbBlob + (pToken->val.byteValue.cbBlob % 2)) : SIZEOF( PERSISTEDTOKEN ) )

#if defined (_MSC_VER)
#pragma pack(pop)
#pragma warning(default:4103)
#endif

EXIT_PK_NAMESPACE;

#endif /* __DRM_TOKEN_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmstringscfd.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMSTRINGSCFD_H__
#define __DRMSTRINGSCFD_H__

#include <drmtypes.h>

ENTER_PK_NAMESPACE;

    /* License Generation */
    extern const DRM_CONST_STRING       g_dstrTagLicensorInfo;
    extern const DRM_CONST_STRING       g_dstrTagEnablingBits;
    extern const DRM_CONST_STRING       g_dstrEnablingBitsAlgorithm;
    extern const DRM_CONST_STRING       g_dstrChainEnablingBitsAlgorithm;
    extern const DRM_CONST_STRING       g_dstrPUBKEY;               
    extern const DRM_CONST_STRING       g_dstrType;                 
    extern const DRM_CONST_STRING       g_dstrMachine;              
    extern const DRM_CONST_STRING       g_dstrVALUE;                
    extern const DRM_CONST_STRING       g_dstrXMLHeader;                             
    extern const DRM_CONST_STRING       g_dstrSOURCEID;                              
    extern const DRM_CONST_STRING       g_dstrConditionPlayAlways;                 
    extern const DRM_CONST_STRING       g_dstrConditionPlayCount;  
    extern const DRM_CONST_STRING       g_dstrActionPlayCountDecrement;
    extern const DRM_CONST_STRING       g_dstrActionPlayCountCheckDelete;
    extern const DRM_CONST_STRING       g_dstrActionSetFirstUseDate;
    extern const DRM_CONST_STRING       g_dstrTagONACTION;                           
    extern const DRM_CONST_STRING       g_dstrTypePlay;                              
    extern const DRM_CONST_STRING       g_dstrLicenseServerPrivateKey;               
    extern const DRM_CONST_STRING       g_dstrSignature;                             
    extern const DRM_CONST_STRING       g_dstrHashAlgorithmType;                     
    extern const DRM_CONST_STRING       g_dstrSignAlgorithmType;                     
    extern const DRM_CONST_STRING       g_dstrTagCertChain;                          
    extern const DRM_CONST_STRING       g_dstrCertificate2;                          
    extern const DRM_CONST_STRING       g_dstrCertificate1;                          
    extern const DRM_CONST_STRING       g_dstrTagISSUEDATE;
    
    extern const DRM_CONST_STRING       g_dstrCHAINCHECKSUM;
    extern const DRM_CONST_STRING       g_dstrUPLINK;
    
    /* ONSELECT */
    extern const DRM_CONST_STRING       g_dstrONSELECT;                              
    extern const DRM_CONST_STRING       g_dstrTagCondition;
    extern const DRM_CONST_STRING       g_dstrOnSelectSecurityLevel;                     
    extern const DRM_CONST_STRING       g_dstrOnSelectBeginDateCheckP1;      
    extern const DRM_CONST_STRING       g_dstrOnSelectBeginDateCheckP2;      
    extern const DRM_CONST_STRING       g_dstrOnSelectExpirationDateCheckP1; 
    extern const DRM_CONST_STRING       g_dstrOnSelectExpirationDateCheckP2; 
    extern const DRM_CONST_STRING       g_dstrOnSelectGracePeriod;
    extern const DRM_CONST_STRING       g_dstrOnSelectExpireHoursCheck1;
    extern const DRM_CONST_STRING       g_dstrOnSelectDelete;
    extern const DRM_CONST_STRING       g_dstrOnSelectExpireHoursCheck2;
    extern const DRM_CONST_STRING       g_dstrOnSelectDateTimeCheck1;
    extern const DRM_CONST_STRING       g_dstrOnSelectDateTimeCheck2;
    
    /* ONCLOCKROLLBACK */ 
    extern const DRM_CONST_STRING       g_dstrOnClockRollbackNode;
    
    /* ONSTORE */ 
    extern const DRM_CONST_STRING       g_dstrOnStoreHoursFromFirstUse;
    extern const DRM_CONST_STRING       g_dstrOnStorePlayCount;
    extern const DRM_CONST_STRING       g_dstrOnStoreBeginPlayCount;
    extern const DRM_CONST_STRING       g_dstrOnStoreOldSaveTime;
    extern const DRM_CONST_STRING       g_dstrOnStoreSecurityLevel;
    extern const DRM_CONST_STRING       g_dstrOnStoreBeginDate;
    extern const DRM_CONST_STRING       g_dstrOnStoreExpirationDate;

    extern const DRM_CONST_STRING       g_dstrREVINFOVERSION;                       

    /* RESTRICTIONS */
    extern const DRM_CONST_STRING       g_dstrRESTRICTIONS;                          
    extern const DRM_CONST_STRING       g_dstrTypeLevel;
    extern const DRM_CONST_STRING       g_dstrUNCOMPRESSEDDIGITALVIDEO;             
    extern const DRM_CONST_STRING       g_dstrCOMPRESSEDDIGITALVIDEO;                
    extern const DRM_CONST_STRING       g_dstrANALOGVIDEO;                           
    extern const DRM_CONST_STRING       g_dstrCOMPRESSEDDIGITALAUDIO;                
    extern const DRM_CONST_STRING       g_dstrUNCOMPRESSEDDIGITALAUDIO;              
    extern const DRM_CONST_STRING       g_dstrEXTENSIONLIST;                         
    extern const DRM_CONST_STRING       g_dstrEXTENSION;                             
    extern const DRM_CONST_STRING       g_dstrguid;
    extern const DRM_CONST_STRING       g_dstrvalue;

    extern const DRM_ANSI_CONST_STRING  g_dastrHeaderLicenseResponse;
    extern const DRM_ANSI_CONST_STRING  g_dastrHeaderSLK;
    extern const DRM_ANSI_CONST_STRING  g_dastrHeaderSLKclose;
    extern const DRM_ANSI_CONST_STRING  g_dastrHeaderSLKID;
    extern const DRM_ANSI_CONST_STRING  g_dastrHeaderSLKIDclose;
    extern const DRM_ANSI_CONST_STRING  g_dastrHeaderSLKDATA;
    extern const DRM_ANSI_CONST_STRING  g_dastrHeaderSLKDATAclose;
    extern const DRM_ANSI_CONST_STRING  g_dastrHeaderLicense;            
    extern const DRM_ANSI_CONST_STRING  g_dastrTailLicenseResponse;              
    
    /* CRL Update */
    extern const DRM_CONST_STRING       g_dstrLICENSERESPONSE;
    extern const DRM_CONST_STRING       g_dstrREVOCATIONINFO; 
    extern const DRM_CONST_STRING       g_dstrREVOCATION;     
    extern const DRM_CONST_STRING       g_dstrGUID;
    extern const DRM_CONST_STRING       g_dstrOpenTemplateTag; 
    extern const DRM_CONST_STRING       g_dstrCloseTemplateTag;

    /* Build Header */
    extern const DRM_CONST_STRING       g_dstrTagCID;
    
EXIT_PK_NAMESPACE;

#endif /* __DRMSTRINGSCFD_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmstrings.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMSTRINGS_H__
#define __DRMSTRINGS_H__

#include <drmtypes.h>

ENTER_PK_NAMESPACE;

    /* Declare the characters first */
    extern const DRM_WCHAR              g_wchPathSeperator;
    extern const DRM_WCHAR              g_wchNull;
    extern const DRM_WCHAR              g_wchMinus;
    extern const DRM_WCHAR              g_wchPlus;
    extern const DRM_WCHAR              g_wchForwardSlash;
    extern const DRM_WCHAR              g_wchColon;
    extern const DRM_WCHAR              g_wchComma;
    extern const DRM_WCHAR              g_wchQuote;
    extern const DRM_WCHAR              g_wchSingleQuote;

    extern const DRM_WCHAR              g_wchNewLine;
    extern const DRM_WCHAR              g_wchBackSlash;
    extern const DRM_WCHAR              g_wch0;
    extern const DRM_WCHAR              g_wch1;
    extern const DRM_WCHAR              g_wch2;
    extern const DRM_WCHAR              g_wch9;
    extern const DRM_WCHAR              g_wcha;
    extern const DRM_WCHAR              g_wchd;
    extern const DRM_WCHAR              g_wchf;
    extern const DRM_WCHAR              g_wchh;
    extern const DRM_WCHAR              g_wchm;
    extern const DRM_WCHAR              g_wchn;
    extern const DRM_WCHAR              g_wchs;
    extern const DRM_WCHAR              g_wchy;
    extern const DRM_WCHAR              g_wchA;
    extern const DRM_WCHAR              g_wchF;
    extern const DRM_WCHAR              g_wchx;
    extern const DRM_WCHAR              g_wchX;
    extern const DRM_WCHAR              g_wchUnderscore;
    extern const DRM_WCHAR              g_wchz;
    extern const DRM_WCHAR              g_wchZ;
    extern const DRM_WCHAR              g_wchPeriod;
    extern const DRM_WCHAR              g_wchQuestionMark;
    extern const DRM_WCHAR              g_wchExclamationMark;
    extern const DRM_WCHAR              g_wchOpenParen;
    extern const DRM_WCHAR              g_wchCloseParen;
    extern const DRM_WCHAR              g_wchPound;
    extern const DRM_WCHAR              g_wchSpace;
    extern const DRM_WCHAR              g_wchTab;
    extern const DRM_WCHAR              g_wchLineFeed;
    extern const DRM_WCHAR              g_wchVerticalTab;
    extern const DRM_WCHAR              g_wchFormFeed;
    extern const DRM_WCHAR              g_wchCarriageReturn;
    extern const DRM_WCHAR              g_wchEqual;
    extern const DRM_WCHAR              g_wchOpenCurly;
    extern const DRM_WCHAR              g_wchCloseCurly;
    extern const DRM_WCHAR              g_wchLessThan;
    extern const DRM_WCHAR              g_wchGreaterThan;
    extern const DRM_WCHAR              g_wchLeftBracket;
    extern const DRM_WCHAR              g_wchRightBracket;
    extern const DRM_WCHAR              g_wchAsterisk;
    extern const DRM_WCHAR              g_wchPercent;
    extern const DRM_WCHAR              g_wchSemiColon;
    extern const DRM_WCHAR              g_wchAmpersand;
    extern const DRM_WCHAR              g_wchPipe;
    extern const DRM_WCHAR              g_rgwchWMDRM_RIGHT_ALLOW_COPY[];
    extern const DRM_WCHAR              g_rgwchCreatePMLicense[];

    /* ANSI */
    extern const DRM_CHAR               g_chForwardSlash;

    extern const DRM_ANSI_CONST_STRING  g_dastrRootPubkey;

#if DRM_SUPPORT_REVOCATION
    extern const DRM_LID                g_lidPCRevInfoRevocation;
    extern const DRM_LID                g_lidRevocationInfo;
    extern const DRM_GUID               g_guidRevocationTypeRevInfo;
    extern const DRM_GUID               g_guidRevocationTypeRevInfo2;
#if DRM_SUPPORT_DEVICE_REVOCATION
    extern const DRM_LID                g_lidDeviceRevocation;
    extern const DRM_CONST_STRING       g_dstrRevocationGuidDevice;
    extern const DRM_ANSI_CONST_STRING  g_dastrRevocationGuidDevice;
    extern const DRM_GUID               g_guidRevocationTypeDevice;
#endif               

#if DRM_SUPPORT_WMDRMNET
    extern const DRM_LID                g_lidWMDRMNET_Revocation;
    extern const DRM_CONST_STRING       g_dstrRevocationGuidWMDRMNET;
    extern const DRM_ANSI_CONST_STRING  g_dastrRevocationGuidWMDRMNET;
    extern const DRM_GUID               g_guidRevocationTypeWMDRMNET;
#endif

#if DRM_SUPPORT_APP_REVOCATION
    extern const DRM_LID                g_lidAppRevocation;
    extern const DRM_CONST_STRING       g_dstrRevocationGuidApp;
    extern const DRM_ANSI_CONST_STRING  g_dastrRevocationGuidApp;
    extern const DRM_GUID               g_guidRevocationTypeApp;
#endif /* DRM_SUPPORT_APP_REVOCATION */

    /* The following GUIDs are implicitly known CRL types that we should be able to extract from RevInfo blob */
    extern const DRM_GUID   g_guidRevocationTypeHDCP;
    extern const DRM_GUID   g_guidRevocationTypeGRL;
    extern const DRM_LID    g_lidGRLRevocation;

    /* PlayReady revocation GUIDs */
    extern const DRM_GUID   g_guidRevocationTypeRevInfo2;
    extern const DRM_LID    g_lidRevocationInfo2;
    extern const DRM_GUID   g_guidRevocationTypePlayReadySilverLightRuntime;
    extern const DRM_GUID   g_guidRevocationTypePlayReadySilverLightApplication;

    /* LIDs for PlayReady CRLs */
    extern const DRM_LID g_lidPRRTRevocation;
    extern const DRM_LID g_lidPRAppRevocation;

#endif /* DRM_SUPPORT_REVOCATION */
    extern const DRM_ID                 g_idSLKSST;

    /* Now declare the strings */
    
    extern const DRM_ANSI_CONST_STRING  g_adstrAttributeVersion;
    extern const DRM_ANSI_CONST_STRING  g_dastrAttributeType;
    extern const DRM_ANSI_CONST_STRING  g_adstrLicenseRespTag;
    extern const DRM_ANSI_CONST_STRING  g_dastrTagLicense;
    extern const DRM_ANSI_CONST_STRING  g_dastrAttributeFALSE;
    extern const DRM_ANSI_CONST_STRING  g_adstrAttributeEncrypted;


    extern const DRM_ANSI_CONST_STRING  g_dastrFeaturesWMDRMTransmitter;
    extern const DRM_ANSI_CONST_STRING  g_dastrFeaturesWMDRMReceiver;


    extern const DRM_ANSI_CONST_STRING  g_dastrTagSLK;
    extern const DRM_ANSI_CONST_STRING  g_dastrTagSLKID;
    extern const DRM_ANSI_CONST_STRING  g_dastrTagSLKDATA;


    extern const DRM_CONST_STRING       g_dstrTagSLK;
    extern const DRM_CONST_STRING       g_dstrTagSLKID;
    extern const DRM_CONST_STRING       g_dstrTagSLKDATA;

    extern const DRM_CONST_STRING       g_dstrAttributeVersion;
    extern const DRM_CONST_STRING       g_dstrAttributeEncrypted;
    extern const DRM_CONST_STRING       g_dstrAttributeFALSE;
    extern const DRM_CONST_STRING       g_dstrLicVerAttrValue;
    extern const DRM_CONST_STRING       g_dstrLicenseRespTag;
    extern const DRM_CONST_STRING       g_dstrTagLicense;

    /* Script varibles used for license properties. */
    extern const DRM_CONST_STRING       g_dstrDRM_LS_BEGIN_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_COUNT_ATTR;

    extern const DRM_CONST_STRING       g_dstrDRM_LS_BEGDATE_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_ENDDATE_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_FIRSTUSE_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_FIRSTSTORE_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_EXPIRATION_AFTER_FIRSTUSE_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_MINAPPSECLEVEL_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_APPSEC_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_SAP_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_BURNTOCDCOUNT_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_TRANSFERCOUNT_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_PLAYCOUNT_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_COPYCOUNT_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_BEGINBURNTOCDCOUNT_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_BEGINTRANSFERCOUNT_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_BEGINPLAYCOUNT_ATTR;

    extern const DRM_CONST_STRING       g_dstrDRM_LS_DELETED_ATTR;

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
    extern const DRM_CONST_STRING       g_dstrDRM_LS_OLDSAVETIME_ATTR;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_MACHINE_DATETIME;
#endif

    extern const DRM_CONST_STRING       g_dstrDRM_LS_MACHINE_DATETIME_GE;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_MACHINE_DATETIME_LE;
    extern const DRM_CONST_STRING       g_dstrDRM_LS_APP_MINSECLEVEL_GE;
    extern const DRM_CONST_STRING       g_dstrEqual;

    extern const DRM_CONST_STRING       g_dstrDrmRestoreInfo;
    extern const DRM_CONST_STRING       g_dstrTagData;
    extern const DRM_CONST_STRING       g_dstrTagDataInclusionList;
    extern const DRM_CONST_STRING       g_dstrTagLID;

    extern const DRM_CONST_STRING       g_dstrTagIndex;
    extern const DRM_CONST_STRING       g_dstrTagEnablingbits;
    extern const DRM_CONST_STRING       g_dstrTagHashAlgorithm;
    extern const DRM_CONST_STRING       g_dstrTagSymValue;
    extern const DRM_CONST_STRING       g_dstrTagSymSig;

    extern const DRM_CONST_STRING       g_dstrTagPubkey;

    extern const DRM_CONST_STRING       g_dstrTagValue;
    extern const DRM_CONST_STRING       g_dstrTagSignature;
    extern const DRM_CONST_STRING       g_dstrTagHashAlg;
    extern const DRM_CONST_STRING       g_dstrTagSignAlg;
    extern const DRM_CONST_STRING       g_dstrSHA;
    extern const DRM_CONST_STRING       g_dstrMSDRM;
    extern const DRM_CONST_STRING       g_dstrMSDRM_CK;
    extern const DRM_CONST_STRING       g_dstrAttributeType;
    extern const DRM_CONST_STRING       g_dstrSavedDateTime;

    extern const DRM_CONST_STRING       g_dstrTagOEMPrivateKeys;
    extern const DRM_CONST_STRING       g_dstrTagKeyValue;
    extern const DRM_CONST_STRING       g_dstrTagRSAKeyValue;
    extern const DRM_CONST_STRING       g_dstrTagModulus;
    extern const DRM_CONST_STRING       g_dstrTagExponent;
    extern const DRM_CONST_STRING       g_dstrTagPrime0;
    extern const DRM_CONST_STRING       g_dstrTagPrime1;
    extern const DRM_CONST_STRING       g_dstrTagCRTExponent0;
    extern const DRM_CONST_STRING       g_dstrTagCRTExponent1;
    extern const DRM_CONST_STRING       g_dstrTagIQMP;
    extern const DRM_CONST_STRING       g_dstrTagPRIVKEY;
    extern const DRM_CONST_STRING       g_dstrXPathPrime0;
    extern const DRM_CONST_STRING       g_dstrXPathPrime1;
    extern const DRM_CONST_STRING       g_dstrXPathCRTExponent0;
    extern const DRM_CONST_STRING       g_dstrXPathCRTExponent1;
    extern const DRM_CONST_STRING       g_dstrXPathIQMP;
    extern const DRM_CONST_STRING       g_dstrWMDRMCertExponent;

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK    
    extern const DRM_CONST_STRING       g_dstrCheckClockRollback;
    extern const DRM_CONST_STRING       g_dstrResetRollbackedClock;
#endif
    
    extern const DRM_CONST_STRING       g_dstrSetSavedDateTime;
    extern const DRM_CONST_STRING       g_dstrCreatePMLicense;
    extern const DRM_CONST_STRING       g_dstrAttributeVersion;
    extern const DRM_CONST_STRING       g_dstrVersion_1_0;
    extern const DRM_CONST_STRING       g_dstrTagIndivPrivkey;
    extern const DRM_CONST_STRING       g_dstrTagDevinfo;
    extern const DRM_ANSI_CONST_STRING  g_dastrTagRevocation;
    extern const DRM_CONST_STRING       g_dstrTagError;
    extern const DRM_CONST_STRING       g_dstrXPathSigValue;
    extern const DRM_CONST_STRING       g_dstrFeatureIndivURL;
    extern const DRM_CONST_STRING       g_dstrCompatCert;
    extern const DRM_CONST_STRING       g_dstrCompatSecVersion;
    extern const DRM_CONST_STRING       g_dstrSubjectId;
    extern const DRM_CONST_STRING       g_dstrMaxSecLevel;
    extern const DRM_CONST_STRING       g_dstrAuthSecVer;
    extern const DRM_CONST_STRING       g_dstrAuthPubKey;
    extern const DRM_CONST_STRING       g_dstrXPathTagSignature;
    extern const DRM_CONST_STRING       g_dstrTagSignatureVal;
    extern const DRM_CONST_STRING       g_dstrXPathTagCertificateChain;
    extern const DRM_CONST_STRING       g_dstrTagSecurityLevel;
    extern const DRM_CONST_STRING       g_dstrAuthData;
    extern const DRM_CONST_STRING       g_dstrAuthHashAlg;
    extern const DRM_CONST_STRING       g_dstrAuthSignAlg;
    extern const DRM_CONST_STRING       g_dstrTagFallback;

    extern const DRM_CONST_STRING       g_dstrTagCertificate;
    extern const DRM_CONST_STRING       g_dstrXPathDataUniqueID;

    extern const DRM_CONST_STRING       g_dstrXPathManufacturer;
    extern const DRM_CONST_STRING       g_dstrXPathMake;
    extern const DRM_CONST_STRING       g_dstrXPathModel;
    extern const DRM_CONST_STRING       g_dstrXPathDistributor;
    extern const DRM_CONST_STRING       g_dstrXPathHardwareMajor;
    extern const DRM_CONST_STRING       g_dstrXPathHardwareMinor;
    extern const DRM_CONST_STRING       g_dstrXPathFirmwareMajor;
    extern const DRM_CONST_STRING       g_dstrXPathFirmwareMinor;
    extern const DRM_CONST_STRING       g_dstrXPathFeatureTemplate;
    extern const DRM_CONST_STRING       g_dstrXPathHeaderUplinks;
    extern const DRM_CONST_STRING       g_dstrXPathClientOldKeys;
    extern const DRM_CONST_STRING       g_dstrXPathClientEscrowKeys;
    extern const DRM_CONST_STRING       g_dstrXPathClientEscrowKey;
    extern const DRM_CONST_STRING       g_dstrXPathIndivServerEscrowKey;
    extern const DRM_CONST_STRING       g_dstrXPathDevicePublicKey;
    extern const DRM_CONST_STRING       g_dstrXPathOldKeysData;
    extern const DRM_CONST_STRING       g_dstrXPathIndivSvrPubKey;
    extern const DRM_CONST_STRING       g_dstrXPathSecureClock;
    extern const DRM_CONST_STRING       g_dstrXPathIndivType;
    extern const DRM_CONST_STRING       g_dstrXPathSecureStore;
    extern const DRM_CONST_STRING       g_dstrXPathMetering;
    extern const DRM_CONST_STRING       g_dstrXPathLicenseChain;
    extern const DRM_CONST_STRING       g_dstrFallback;

    extern const DRM_CONST_STRING       g_dstrTagDevCert;
    extern const DRM_CONST_STRING       g_dstrTagWrmHeader;
    extern const DRM_CONST_STRING       g_dstrAttributeHeaderXmlnsName;
    extern const DRM_CONST_STRING       g_dstrAttributeHeaderXmlnsValue;
    extern const DRM_CONST_STRING       g_dstrAttributeVersion2Value;
    extern const DRM_CONST_STRING       g_dstrAttributeVersion4Value;
    extern const DRM_CONST_STRING       g_dstrTagLAINFO;
    extern const DRM_CONST_STRING       g_dstrTagKID;
    extern const DRM_CONST_STRING       g_dstrTagV4DATA;
    extern const DRM_CONST_STRING       g_dstrTagLAURL;
    extern const DRM_CONST_STRING       g_dstrTagLUIURL;
    extern const DRM_CONST_STRING       g_dstrTagDSID;
    extern const DRM_CONST_STRING       g_dstrTagOEMData;
    extern const DRM_CONST_STRING       g_dstrTagContentID;
    extern const DRM_CONST_STRING       g_dstrTagChecksum;
    extern const DRM_CONST_STRING       g_dstrTagUplink;
    extern const DRM_CONST_STRING       g_dstrTagUplinks;

    extern const DRM_CONST_STRING       g_dstrTagLicenseRequest;
    extern const DRM_CONST_STRING       g_dstrTagAction;

    extern const DRM_CONST_STRING       g_dstrTagV1Challenge;
    extern const DRM_CONST_STRING       g_dstrDefaultV1Data;
    extern const DRM_CONST_STRING       g_dstrTagActionList;
    extern const DRM_CONST_STRING       g_dstrTagSecurityVersion;
    extern const DRM_CONST_STRING       g_dstrTagDevice;
    extern const DRM_CONST_STRING       g_dstrTagPrivateKey;
    extern const DRM_CONST_STRING       g_dstrKeyDataTag;
    extern const DRM_CONST_STRING       g_dstrGroupTag;
    extern const DRM_CONST_STRING       g_dstrTagMSDRMSignature;

    /*
    **  Devcert Non-indiv Tags
    */
    extern const DRM_CONST_STRING       g_dstrTagDNIUniqueID;
    extern const DRM_CONST_STRING       g_dstrTagMSDRMSignature;
    extern const DRM_CONST_STRING       g_dstrPrivateKeys;        
    extern const DRM_CONST_STRING       g_dstrCertTypeDevice;
    extern const DRM_CONST_STRING       g_dstrCerttypeGroup;
    extern const DRM_CONST_STRING       g_dstrCerttypeAuth;
    extern const DRM_CONST_STRING       g_dstrCerttypeAuthRoot;
    
    /*
    **  Devcert Non-indiv XPaths
    */
    extern const DRM_CONST_STRING       g_dstrXPathPubkeyData;
    extern const DRM_CONST_STRING       g_dstrXPathGCSecureClock;
    extern const DRM_CONST_STRING       g_dstrXPathGCSecureClockURL;
    extern const DRM_CONST_STRING       g_dstrXPathGCSecureClockPubKey;
    extern const DRM_CONST_STRING       g_dstrXPathGCMetering;
    extern const DRM_CONST_STRING       g_dstrXPathGCLicenseAcquisitionMode;
    extern const DRM_CONST_STRING       g_dstrXPathGCLicenseSyncMode;
    extern const DRM_CONST_STRING       g_dstrXPathGCSymmOptsMode;
    extern const DRM_CONST_STRING       g_dstrXPathGCEncryption;
    extern const DRM_CONST_STRING       g_dstrXPathGCSupportRevocation;
    extern const DRM_CONST_STRING       g_dstrXPathGCMaxChainDepth;
    extern const DRM_CONST_STRING       g_dstrXPathGCMaxLicenseSize;
    extern const DRM_CONST_STRING       g_dstrXPathGCMaxHeaderSize;
    extern const DRM_CONST_STRING       g_dstrXPathDeviceKeydata;
    extern const DRM_CONST_STRING       g_dstrXPathDACAuthID;

    extern const DRM_CONST_STRING       g_dstrReqTagClientInfo;
    extern const DRM_CONST_STRING       g_dstrReqTagClientID;
    extern const DRM_CONST_STRING       g_dstrReqTagClientVersion;
    extern const DRM_CONST_STRING       g_dstrReqTagAppSecurity;
    extern const DRM_CONST_STRING       g_dstrReqTagSubjectID1;
    extern const DRM_CONST_STRING       g_dstrReqTagSubjectID2;
    extern const DRM_CONST_STRING       g_dstrReqTagDrmkVersion;
    extern const DRM_CONST_STRING       g_dstrReqTagPlayReadyClientVersionData;
    extern const DRM_CONST_STRING       g_dstrReqTagWMDRMPDClientVersionData;
    extern const DRM_CONST_STRING       g_dstrReqTagSubjectID2Data;
    extern const DRM_CONST_STRING       g_dstrReqTagDrmkData;
    extern const DRM_CONST_STRING       g_dstrReqTagRevInfo;
	
    /*
    **  Devcert Support CRL  Tags
    */
    extern const DRM_CONST_STRING       g_dstrXPathGCSupportCRL;

    /* XML tags used in parsing licenses */
    extern const DRM_CONST_STRING       g_dstrLicense;
    extern const DRM_CONST_STRING       g_dstrGUID;
    extern const DRM_CONST_STRING       g_dstrLicensorInfoNode;
    extern const DRM_CONST_STRING       g_dstrLIData;
    extern const DRM_CONST_STRING       g_dstrMeta;

    /* Strings for various revocation queries */
    extern const DRM_CONST_STRING       g_dstrTagRevocation;
    extern const DRM_CONST_STRING       g_dstrTagRevocationInfo;
    extern const DRM_ANSI_CONST_STRING  g_dastrTagRevocationInfo;
    extern const DRM_CONST_STRING       g_dstrAppRevocation;

    extern const DRM_CONST_STRING       g_dstrDeviceRevocationLicenseTag;
    extern const DRM_CONST_STRING       g_dstrWMDRMNETRevocationLicenseTag;

    extern const DRM_ANSI_CONST_STRING  g_dastrAppRevocation;
    extern const DRM_CONST_STRING       g_dstrDeviceRevocationList;
    extern const DRM_CONST_STRING       g_dstrDeviceRevocation;
    extern const DRM_ANSI_CONST_STRING  g_dastrDeviceRevocation;
    extern const DRM_CONST_STRING       g_dstrWMDRMNET_Revocation;
    extern const DRM_ANSI_CONST_STRING  g_dastrWMDRMNET_Revocation;

    extern const DRM_CONST_STRING       g_dstrTagRevInfoVersion;
    extern const DRM_ANSI_CONST_STRING  g_dastrTagRevInfoVersion;
    extern const DRM_CONST_STRING       g_dstrTagSourceID;
    extern const DRM_ANSI_CONST_STRING  g_dastrTagSourceID;


    extern const DRM_CONST_STRING       g_dstrMeteringId;
    
    
    extern const DRM_CONST_STRING       g_dstrPriority;
    extern const DRM_CONST_STRING       g_dstrIssueDate;
    extern const DRM_CONST_STRING       g_dstrContentPubKey;
    extern const DRM_CONST_STRING       g_dstrContentRevocation;
    extern const DRM_CONST_STRING       g_dstrCondition;
    extern const DRM_CONST_STRING       g_dstrAction;
    extern const DRM_CONST_STRING       g_dstrRestrictions;
    extern const DRM_CONST_STRING       g_dstrChainedEnablingBits;
    extern const DRM_CONST_STRING       g_dstrDrmRestoreInfoEnablingBits;
    extern const DRM_CONST_STRING       g_dstrCertChain;
    extern const DRM_CONST_STRING       g_dstrXPathTagCertificate;
    extern const DRM_CONST_STRING       g_dstrLISigHashAlgo;
    extern const DRM_CONST_STRING       g_dstrLISigAlgo;
    extern const DRM_CONST_STRING       g_dstrLISigValue;
    extern const DRM_CONST_STRING       g_dstrOnActionPath;
    extern const DRM_CONST_STRING       g_dstrXPathSymSig;
    extern const DRM_CONST_STRING       g_dstrXPathSymValue;


    extern const DRM_CONST_STRING       g_dstrSequenceNumber;
    extern const DRM_CONST_STRING       g_dstrLSPubKey;
    extern const DRM_CONST_STRING       g_dstrUplinkKid;
    extern const DRM_CONST_STRING       g_dstrChainedCheckSum;
    extern const DRM_CONST_STRING       g_dstrTempMeterId;
    extern const DRM_CONST_STRING       g_dstrPMLicenseVersionString;
    extern const DRM_ANSI_CONST_STRING  g_dastrPMLicenseVersionString;
    extern const DRM_ANSI_CONST_STRING  g_dastrXMRLicenseVersionString;
    extern const DRM_CONST_STRING       g_dstrRevAttribute;
    extern const DRM_CONST_STRING       g_dstrDerivedLicTemplate;
    extern const DRM_CONST_STRING       g_dstrLicDataDerivedTmpl;
    extern const DRM_CONST_STRING       g_dstrSourceID;
    extern const DRM_CONST_STRING       g_dstrInclusionList;

    /* XML tags used in writing Challenge and parsing Response for metering */
    extern const DRM_CONST_STRING       g_dstrTagMetering;
    extern const DRM_CONST_STRING       g_dstrTagHash;
    extern const DRM_CONST_STRING       g_dstrXPathMID;
    extern const DRM_CONST_STRING       g_dstrTagMID;
    extern const DRM_CONST_STRING       g_dstrTagTID;
    extern const DRM_CONST_STRING       g_dstrTagCmd;
    extern const DRM_CONST_STRING       g_dstrTagPassword;
    extern const DRM_CONST_STRING       g_dstrTagRecords;
    extern const DRM_CONST_STRING       g_dstrTagPartialData;
    extern const DRM_CONST_STRING       g_dstrTagURL;
    extern const DRM_CONST_STRING       g_dstrLabelValue;
    extern const DRM_CONST_STRING       g_dstrHMAC;
    extern const DRM_CONST_STRING       g_dstrChallenge;
    extern const DRM_CONST_STRING       g_dstrResponse;
    extern const DRM_CONST_STRING       g_dstr1;
    extern const DRM_CONST_STRING       g_dstrReset;

    extern const DRM_ANSI_CONST_STRING  g_dastrTagMeterCert;
    extern const DRM_CONST_STRING       g_dstrTagMeterCert;

    extern const DRM_CONST_STRING       g_dstrTagCertificateChain;



    extern const DRM_ANSI_CONST_STRING  g_dastrAttributeAlgorithm;
    extern const DRM_ANSI_CONST_STRING  g_dastrAttributeVersionWMDRM;      
    extern const DRM_ANSI_CONST_STRING  g_dastrTagEscrowedKeys;            
    extern const DRM_ANSI_CONST_STRING  g_dastrKeyUsageSignCert;           
    extern const DRM_ANSI_CONST_STRING  g_dastrKeyUsageSignCRL;            
    extern const DRM_ANSI_CONST_STRING  g_dastrKeyUsageEncryptKey;         
    extern const DRM_ANSI_CONST_STRING  g_dastrOne;                        
    extern const DRM_ANSI_CONST_STRING  g_dastrPrefixManufacturer;         
    extern const DRM_ANSI_CONST_STRING  g_dastrTagCanonicalization;        
    extern const DRM_ANSI_CONST_STRING  g_dastrTagCertificateCollection;   
    extern const DRM_ANSI_CONST_STRING  g_dastrTagDigestMethod;            
    extern const DRM_ANSI_CONST_STRING  g_dastrURIDSigSHA1;                
    extern const DRM_ANSI_CONST_STRING  g_dastrTagDigestValue;             
    extern const DRM_ANSI_CONST_STRING  g_dastrTagSignatureValue;          
    extern const DRM_ANSI_CONST_STRING  g_dastrTagKeyInfo;                 
    extern const DRM_ANSI_CONST_STRING  g_dastrTagSymmetricKey;            
    extern const DRM_ANSI_CONST_STRING  g_dastrTagPublicKey;               
    extern const DRM_ANSI_CONST_STRING  g_dastrTagPrivateKey;              
    extern const DRM_ANSI_CONST_STRING  g_dastrTagKeyValue;               
    extern const DRM_ANSI_CONST_STRING  g_dastrTagRSAKeyValue;             
    extern const DRM_ANSI_CONST_STRING  g_dastrTagModulus;                 
    extern const DRM_ANSI_CONST_STRING  g_dastrTagExponent;
    extern const DRM_ANSI_CONST_STRING  g_dastrOpenEndTag;
    extern const DRM_ANSI_CONST_STRING  g_dastrOpenCDATATag;
    extern const DRM_ANSI_CONST_STRING  g_dastrCloseCDATATag;  

    extern const DRM_ANSI_CONST_STRING  g_dastrTagManufacturerName;           
    extern const DRM_ANSI_CONST_STRING  g_dastrTagManufacturerData;           
    extern const DRM_ANSI_CONST_STRING  g_dastrTagModelName;                  
    extern const DRM_ANSI_CONST_STRING  g_dastrTagModelNumber;    
    extern const DRM_ANSI_CONST_STRING  g_dastrTagHardwareID;
    extern const DRM_ANSI_CONST_STRING  g_dastrURIRSASHA1;                    
    extern const DRM_ANSI_CONST_STRING  g_dastrURIRSASHA1_Old;                
    extern const DRM_ANSI_CONST_STRING  g_dastrTagReference;                  
    extern const DRM_ANSI_CONST_STRING  g_dastrTagTransforms;                 
    extern const DRM_ANSI_CONST_STRING  g_dastrTagTransform;                  
    extern const DRM_ANSI_CONST_STRING  g_dastrURITransformMSCert;            
    extern const DRM_ANSI_CONST_STRING  g_dastrURITransformMSCertColl;        
    extern const DRM_ANSI_CONST_STRING  g_dastrURITransformMSCert_Old;        
    extern const DRM_ANSI_CONST_STRING  g_dastrURITransformC14N;              
    extern const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertificate;           
    extern const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMData;                  
    extern const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertPublicKey;         
    extern const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertSecurityVersion;   
    extern const DRM_ANSI_CONST_STRING  g_dastrSecurityVersion;   
    extern const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertSecurityLevel;     
    extern const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertSerialNumber;      
    extern const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertFeatures;          
    extern const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertKeyUsage;          

    extern const DRM_ANSI_CONST_STRING  g_dastrTagSignature;       
    extern const DRM_ANSI_CONST_STRING  g_dastrTagSignatureMethod; 
    extern const DRM_ANSI_CONST_STRING  g_dastrTagSignedInfo;      
    extern const DRM_ANSI_CONST_STRING  g_dastrURIC14N;            
    extern const DRM_ANSI_CONST_STRING  g_dastrVersionWMDRM;       
    extern const DRM_ANSI_CONST_STRING  g_dastrWMDRMCertExponent;  


    extern const DRM_ANSI_CONST_STRING  g_dastrFeatureSampleProtection;
    extern const DRM_ANSI_CONST_STRING  g_dastrFeatureExport;
    extern const DRM_ANSI_CONST_STRING  g_dastrFeatureExportIncl;

    extern const DRM_ANSI_CONST_STRING  g_dastrPrefixMicrosoftCert;
    extern const DRM_ANSI_CONST_STRING  g_dastrTagUnsignedTemplate;
    extern const DRM_ANSI_CONST_STRING  g_dastrMSNDRootPubKeyB64;

    /* tags used for sync lists */

    extern const DRM_CONST_STRING       g_dstrTagSyncList;

    extern const DRM_CONST_STRING       g_dstrBackup;
    extern const DRM_CONST_STRING       g_dstrRestore;
    extern const DRM_CONST_STRING       g_dstrRootSigValueVersionTag;
    extern const DRM_CONST_STRING       g_dstrRootSigValueVersionVal;
    extern const DRM_CONST_STRING       g_dstrPFRootTag;
    extern const DRM_CONST_STRING       g_dstrDACPubKeyTag;
    extern const DRM_CONST_STRING       g_dstrAuthRoot;
    extern const DRM_CONST_STRING       g_dstrTagNameValue;
    extern const DRM_CONST_STRING       g_dstrXPathTagSecurityLevel;
    extern const DRM_CONST_STRING       g_dstrTagDataId;
    extern const DRM_CONST_STRING       g_dstrTagDataPubKey;
    extern const DRM_CONST_STRING       g_dstrFallBack;
    extern const DRM_CONST_STRING       g_dstrTagName;
    extern const DRM_CONST_STRING       g_dstrManufacturer;
    extern const DRM_CONST_STRING       g_dstrModel;
    extern const DRM_CONST_STRING       g_dstrHwMajor;
    extern const DRM_CONST_STRING       g_dstrHwMinor;
    extern const DRM_CONST_STRING       g_dstrFwMajor;
    extern const DRM_CONST_STRING       g_dstrFwMinor;
    extern const DRM_CONST_STRING       g_dstrFeatures;
    extern const DRM_CONST_STRING       g_dstrSecureClockNotSet;
    extern const DRM_CONST_STRING       g_dstrSecureClockSet;
    extern const DRM_CONST_STRING       g_dstrSecureClockNeedsRefresh;
    extern const DRM_CONST_STRING       g_dstrTemplate;
    extern const DRM_CONST_STRING       g_dstrIndivPubKey;
    extern const DRM_CONST_STRING       g_dstrUniqueId;
    extern const DRM_CONST_STRING       g_dstrUnsignedtemplate;
    extern const DRM_CONST_STRING       g_dstrTagDataSecVer;
    extern const DRM_CONST_STRING       g_dstrExprFuncDateAdd;
    extern const DRM_CONST_STRING       g_dstrExprFuncDateDiff;
    extern const DRM_CONST_STRING       g_dstrExprFuncMin;
    extern const DRM_CONST_STRING       g_dstrExprFuncMax;
    extern const DRM_CONST_STRING       g_dstrExprFuncDatePart;
    extern const DRM_CONST_STRING       g_dstrExprFuncVersionCompare;
    extern const DRM_CONST_STRING       g_dstrExprFuncDeleteLicense;
    extern const DRM_CONST_STRING       g_dstrExprFuncExists;    

    /* Strings for license evaluator well known actions */
    extern const DRM_CONST_STRING       g_dstrLicEvalOnSelect;
    extern const DRM_CONST_STRING       g_dstrLicEvalOnDelete;
    extern const DRM_CONST_STRING       g_dstrLicEvalOnStore;
    extern const DRM_CONST_STRING       g_dstrLicEvalOnAction;
    extern const DRM_CONST_STRING       g_dstrLicEvalOnClockRollback;

    /* Strings for expression evaluator variable evaluation */
    extern const DRM_CONST_STRING       g_dstrDRM_PREFIX;
    extern const DRM_CONST_STRING       g_dstrDRMK_PREFIX;
    extern const DRM_CONST_STRING       g_dstrMACHINE_PREFIX;
    extern const DRM_CONST_STRING       g_dstrAPP_PREFIX;
    extern const DRM_CONST_STRING       g_dstrSECSTATE_PREFIX;
    extern const DRM_CONST_STRING       g_dstrLICENSE_PREFIX;
    extern const DRM_CONST_STRING       g_dstrCONTENT_PREFIX;
    extern const DRM_CONST_STRING       g_dstrDEVICE_PREFIX;
    extern const DRM_CONST_STRING       g_dstrPMLICENSE_PREFIX;
    extern const DRM_CONST_STRING       g_dstrSECURETIME_PREFIX;
    extern const DRM_CONST_STRING       g_dstrPLAYLISTBURN_PREFIX;

#if DRM_SUPPORT_SST_REDUNANCY
    extern const DRM_CONST_STRING       g_dstrSSTREDUNDANCY_PREFIX;
#endif

    extern const DRM_CONST_STRING       g_dstrExprVarVersion;
    extern const DRM_CONST_STRING       g_dstrExprVarParameter;
    extern const DRM_CONST_STRING       g_dstrExprVarReason;
    extern const DRM_CONST_STRING       g_dstrExprVarBBMSDRMVersion;
    extern const DRM_CONST_STRING       g_dstrExprVarDateTime;
    extern const DRM_CONST_STRING       g_dstrExprVarCount;
    extern const DRM_CONST_STRING       g_dstrExprVarMinSecLevel;
    extern const DRM_CONST_STRING       g_dstrExprVarSecLevel;
    extern const DRM_CONST_STRING       g_dstrExprVarAppSecLevel;
    extern const DRM_CONST_STRING       g_dstrExprVarSubjID;
    extern const DRM_CONST_STRING       g_dstrExprVarAppSubjID;
    extern const DRM_CONST_STRING       g_dstrExprVarGlobal;
    extern const DRM_CONST_STRING       g_dstrExprVarSaveDateTime;
    extern const DRM_CONST_STRING       g_dstrExprVarSavedDateTime;
    extern const DRM_CONST_STRING       g_dstrExprVarDRMReason;
    extern const DRM_CONST_STRING       g_dstrExprVarRights;
    extern const DRM_CONST_STRING       g_dstrExprVarExpiryDate;
    extern const DRM_CONST_STRING       g_dstrExprVarInGracePeriod;
    extern const DRM_CONST_STRING       g_dstrExprVarGpStartTime;
    extern const DRM_CONST_STRING       g_dstrExprVarIncrementCount;    
    extern const DRM_CONST_STRING       g_dstrExprVarDevReg;    
    extern const DRM_ANSI_CONST_STRING  g_dastrTagCDATA;
    extern const DRM_CONST_STRING       g_dstrTagCDATA;
    extern const DRM_ANSI_CONST_STRING  g_dastrTagCDATAOpenBracket;
    extern const DRM_CONST_STRING       g_dstrTagCDATAOpenBracket;
    extern const DRM_CONST_STRING       g_dstrOpenTag;
    extern const DRM_CONST_STRING       g_dstrSpace;
    extern const DRM_CONST_STRING       g_dstrOpenEndTag;
    extern const DRM_CONST_STRING       g_dstrCloseTag;
    extern const DRM_CONST_STRING       g_dstrEqualQuote;
    extern const DRM_CONST_STRING       g_dstrQuote;
    extern const DRM_CONST_STRING       g_dstrOpenCDATATag;
    extern const DRM_CONST_STRING       g_dstrCloseCDATATag;

    extern const DRM_CONST_STRING       g_dstrTagDRMReqRoot;
    extern const DRM_CONST_STRING       g_dstrResponse;
    extern const DRM_CONST_STRING       g_dstrStatus;
    extern const DRM_CONST_STRING       g_dstrFlag;
    extern const DRM_CONST_STRING       g_dstrTagGmtTime;
    extern const DRM_CONST_STRING       g_dstrTagRefreshDate;

    /* Output restriction strings */
    extern const DRM_CONST_STRING       g_dstrLabelGuid;
    extern const DRM_CONST_STRING       g_dstrLabelLevel;
    extern const DRM_CONST_STRING       g_dstrTagUncompressedDigitalVideo;
    extern const DRM_CONST_STRING       g_dstrTagCompressedDigitalVideo;
    extern const DRM_CONST_STRING       g_dstrTagUncompressedDigitalAudio;
    extern const DRM_CONST_STRING       g_dstrTagCompressedDigitalAudio;
    extern const DRM_CONST_STRING       g_dstrTagAnalogVideo;
    extern const DRM_CONST_STRING       g_dstrTagCopy;
    extern const DRM_CONST_STRING       g_dstrTagExtensionList;
    extern const DRM_CONST_STRING       g_dstrTagExtension;
    extern const DRM_CONST_STRING       g_dstrTagIncludeList;
    extern const DRM_CONST_STRING       g_dstrTagInclude;
    extern const DRM_CONST_STRING       g_dstrTagExcludeList;
    extern const DRM_CONST_STRING       g_dstrTagExclude;
    
    extern const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_NONE;
    extern const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_PLAYBACK;
    extern const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_COLLABORATIVE_PLAY;
    extern const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_COPY;
    extern const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_COPY_TO_SDMI_DEVICE;
    extern const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE;
    extern const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_CREATE_THUMBNAIL_IMAGE;

#if DRM_SUPPORT_PLAYLIST_BURN
    extern const DRM_CONST_STRING      g_dstrPlaylistBurnCount;
    extern const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_PLAYLIST_BURN;
#endif

#if DRM_SUPPORT_PMLICENSE
    extern const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_COPY_TO_SDMI_DEVICE;
    extern const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE;
#endif

#if DRM_BACKUP_RESTORE_SUPPORT
    extern const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_BACKUP;
#endif

    extern const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_COPY_TO_CD;    

    extern const DRM_CONST_STRING      g_dstrMSRootPubKey;

    extern const DRM_BYTE              g_rgbMSPlayReadyRootIssuerPubKey[];

/* License State strings */
    extern const DRM_CONST_STRING      g_dstrTagLicenseStateRequestRoot;
    extern const DRM_CONST_STRING      g_dstrTagCanBind;

/*Device License Revocation Blob Strings*/

    extern const DRM_CONST_STRING      g_dstrTagDeviceLicenseRevocationRoot;
    extern const DRM_CONST_STRING      g_dstrTagRevocationPubKey;

    extern const DRM_CONST_STRING      g_dstrInitialExtensibleStateAttributeName;

    extern const DRM_DWORD             g_dwWMDRMPDVersionMajor;
    extern const DRM_DWORD             g_dwWMDRMPDVersionMinor;
    extern const DRM_DWORD             g_dwWMDRMPDVersionBuild;
    extern const DRM_DWORD             g_dwWMDRMPDVersionRevision;
    

/*
** Actions GUIDs. Used with DRM_LEVL_PerformOperationsXMR() API
**
*/
    DRM_DECLARE_GUID( DRM_ACTION_PLAY );
    DRM_DECLARE_GUID( DRM_ACTION_COPY );
    DRM_DECLARE_GUID( DRM_ACTION_CREATE_THUMBNAIL );
    DRM_DECLARE_GUID( DRM_ACTION_COLLABORATIVE_PLAY );
    DRM_DECLARE_GUID( DRM_ACTION_PLAYLIST_BURN );
    DRM_DECLARE_GUID( DRM_ACTION_COPY_TO_CD );
    DRM_DECLARE_GUID( DRM_ACTION_CREATE_PM_LICENSE );
    DRM_DECLARE_GUID( DRM_ACTION_BACKUP_RESTORE );
    DRM_DECLARE_GUID( DRM_ACTION_COPY_TO_PC );
    DRM_DECLARE_GUID( DRM_ACTION_COPY_TO_DEVICE );

EXIT_PK_NAMESPACE;

#endif /* __DRMSTRINGS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmstrsafe.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMSTRSAFE_H__
#define __DRMSTRSAFE_H__

#include <drmcommon.h>

#ifdef __cplusplus
extern "C"
{
#endif

ENTER_PK_NAMESPACE;

#define DRM_STRSAFE_MAX_CCH 2147483647


#define DRM_MAX_CCH_BASE2_DWORD_STRING      32
#define DRM_MAX_CCH_BASE2_WORD_STRING       16
#define DRM_MAX_CCH_BASE2_BYTE_STRING       8

#define DRM_MAX_CCH_BASE10_DWORD_STRING     10
#define DRM_MAX_CCH_BASE10_WORD_STRING      5
#define DRM_MAX_CCH_BASE10_BYTE_STRING      3

#define DRM_MAX_CCH_BASE16_DWORD_STRING     8
#define DRM_MAX_CCH_BASE16_WORD_STRING      4
#define DRM_MAX_CCH_BASE16_BYTE_STRING      2


DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchLengthW(
    __in_z const DRM_WCHAR *f_pwsz,
    __in         DRM_DWORD  f_cchMax,
    __out_opt    DRM_DWORD *f_pcchLength );

DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchLengthA(
    __in_z              const DRM_CHAR  *f_psz,
    __in                      DRM_DWORD  f_cchMax,
    __out_opt                 DRM_DWORD *f_pcchLength);


DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchCopyNW( 
    __out_ecount_z(f_cchDest)     DRM_WCHAR  *f_pwszDest,
    __in                          DRM_DWORD   f_cchDest,
    __in_ecount( f_cchSrc ) const DRM_WCHAR  *f_pwszSrc,
    __in                          DRM_DWORD   f_cchSrc );

DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchCopyNA(
    __out_ecount_z(f_cchDest)      DRM_CHAR  *f_pszDest,
    __in                           DRM_DWORD  f_cchDest,
    __in_ecount(f_cchToCopy) const DRM_CHAR  *f_pszSrc,
    __in                           DRM_DWORD  f_cchToCopy);

DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchCopyW( 
    __out_ecount_z(f_cchDest) DRM_WCHAR  *f_pwszDest,
    __in                      DRM_DWORD   f_cchDest,
    __in_z              const DRM_WCHAR  *f_pwszSrc );

DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchCopyA(
    __out_ecount_z(f_cchDest) DRM_CHAR *f_pszDest,
    __in                      DRM_DWORD f_cchDest,
    __in_z              const DRM_CHAR *f_pszSrc);

DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchCatW
(   __out_ecount_z(f_cchDest) DRM_WCHAR *f_pwszDest,
    __in                      DRM_DWORD  f_cchDest,
    __in_z              const DRM_WCHAR *pwszSrc );

DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchCatA
(   __out_ecount_z(f_cchDest) DRM_CHAR  *f_pszDest,
    __in                      DRM_DWORD  f_cchDest,
    __in_z              const DRM_CHAR *pszSrc );

DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchCatNW
(   __out_ecount_z(f_cchDest)        DRM_WCHAR *f_pwszDest,
    __in                             DRM_DWORD  f_cchDest,
    __in_ecount(f_cchToAppend) const DRM_WCHAR *f_pwszSrc,
    __in                             DRM_DWORD  f_cchToAppend );

DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchCatNA
(   __out_ecount_z(f_cchDest)        DRM_CHAR     *f_pszDest,
    __in                             DRM_DWORD     f_cchDest,
    __in_ecount(f_cchToAppend) const DRM_CHAR     *f_pszSrc,
    __in                             DRM_DWORD     f_cchToAppend );

DRM_API DRM_RESULT DRM_CALL DRM_STR_NumberToString(
    __in                          DRM_DWORD  f_dwValue, 
    __out_ecount_z( f_cchBuffer ) DRM_WCHAR *f_pwszBuffer, 
    __in                          DRM_DWORD  f_cchBuffer,
    __in                          DRM_DWORD  f_dwPadZeros,
    __in                          DRM_DWORD  f_dwRadix,
    __out_opt                     DRM_DWORD *f_pcchRLength );

DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchPrintfW_1
(   __out_ecount_z(f_cchDest) DRM_WCHAR       *f_pwszDest,
    __in                      DRM_DWORD        f_cchDest,
    __in __format_string      DRM_WCHAR const *f_pwszFormat,
    __in                      DRM_DWORD        f_dwValue );

DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchPrintfExW_1
(   __out_ecount_z(f_cchDest)                DRM_WCHAR *f_pwszDest,
    __in                                     DRM_DWORD  f_cchDest,
    __deref_opt_out_ecount(*f_pcchRemaining) DRM_WCHAR**f_ppwszDestEnd,
    __out_opt                                DRM_DWORD *f_pcchRemaining,
    __in                                     DRM_DWORD  f_dwFlags,
    __in_z __format_string             const DRM_WCHAR *f_pwszFormat,
    __in                                     DRM_DWORD  f_dwValue );

DRM_API DRM_RESULT DRM_CALL DRM_STR_DstrCat(
    __inout    DRM_STRING       *f_pdstrTarget,
    __in const DRM_CONST_STRING *f_pdstrAdd,
    __in const DRM_DWORD         f_cchTargetMax );

DRM_API DRM_RESULT DRM_CALL DRM_STR_StringCchToLower(
    __inout_ecount_nz(f_cchToLower) DRM_WCHAR *f_prgwchToLower,
    __in                            DRM_DWORD  f_cchToLower );

DRM_API DRM_RESULT DRM_CALL DRM_STR_DstrToLower(
    __inout    DRM_STRING       *f_pdstrToLower );

EXIT_PK_NAMESPACE;

#ifdef __cplusplus
}
#endif


#endif /* __DRMSTRSAFE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmtrace.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMTRACE_H__
#define __DRMTRACE_H__

ENTER_PK_NAMESPACE;

/*
** Maximum number of components that can be defined. 
** DRM_TRACE_COMPONENT_ID macro is used to assign a component
** ID (DWORD) to a scope.
*/
#define MAX_TRACE_COMPONENT     256

/* Enumeration of the various trace level. */
typedef enum
{
    TRACE_NONE     = 0,
    TRACE_FATAL    = 1,
    TRACE_CRITICAL = 2,
    TRACE_WARNING  = 3,
    TRACE_INFO     = 4,
    TRACE_VERBOSE  = 5
} eTraceLevel;

/* Enumeration of the various robustness level. */
typedef enum
{
    TRACE_NON_ROBUST  = 0,
    TRACE_ROBUST      = 1,
    TRACE_MOST_ROBUST = 2
} eTraceRobustLevel;

#define TRACE_DEFAULT_ROBUST    TRACE_NON_ROBUST

/*
** Predefined event type for scope.
*/
typedef enum
{
    TRACE_DEFAULT_EVENT = 0,
    TRACE_ENTER_SCOPE   = 1,
    TRACE_LEAVE_SCOPE   = 2
    /* OEM may define customized events starting with value 4. */
} eTraceScopeEventType;

/* Enumeration of the various trace channels. */
typedef enum
{
    TRACE_CONSOLE_CHANNEL = 0x01,
    TRACE_FILE_CHANNEL    = 0x02,
    /* OEM may define customized channels starting with mask 0x04. */
} eTraceChannelType;

#if DRM_SUPPORT_TRACING

/* Global trace context data structure. */
typedef struct __tagTRACE_GLOBAL_CONTEXT
{
    /* Current global trace level. */
    eTraceLevel m_eTraceLevel;
    
    /* Default component trace levels. */
    eTraceLevel m_rgeComponentTraceLevels[ MAX_TRACE_COMPONENT ];
   
    /*
    ** Init flag to indicate whether the
    ** data structure has been initialized.
    */
    DRM_BOOL m_fInit;
    
    /*
    ** OEM data field to allow OEM to store its
    ** specific information (such as a trace log
    ** file pointer.
    */
    DRM_VOID *m_pvOEMData;

    /*
    ** Flag indicating whether is currently in
    ** Oem_Trace_Enter/LeaveScope() API. This flag
    ** is used to prevent recursive entering
    ** of Oem_Trace_Enter/LeaveScope().
    */
    DRM_BOOL m_fEnterScope;
    
    /* Bit mask of trace channel. */
    DRM_DWORD m_dwChannelMask;

} DRM_TRACE_GLOBAL_CONTEXT;

EXIT_PK_NAMESPACE;

#include <oemtrace.h>

ENTER_PK_NAMESPACE;

DRM_API DRM_TRACE_GLOBAL_CONTEXT * DRM_CALL Oem_Trace_GetGlobalContext( DRM_VOID );

/** OEM MUST provide its own mapping of the following DRM_TRACE macros in oemtrace.h. */

/*
** #define DRM_TRACE_ID( trace_id )
** Note: DRM_TRACE_ID macro is used to handle all trace_id's in a single location e.g if
**       the OEM layer would like to ignore (and hence not define) the trace ID's then
**       this macro can be used to define all such trace_id's to say 0.  If OEM layer is
**       going to use the trace_id's, then it must define the values for the trace_ids.
** 
** #define DRM_TRACE( szFormat )
** Note: DRM_TRACE macro is used to trace an arbitrary format string with arbitrary number
**       of parameters. The length of the result string is only limited by OEM's specific
**       implementation. All information must be enclosed by a pair of parenthesis. For example,
**       DRM_TRACE( ( "%s %d.", "Hello World", 123 ) ).
**       DRM_TRACE must be used within a scope that has already been defined by the
**       the DRM_PROFILING_ENTER_SCOPE and DRM_PROFILING_LEAVE_SCOPE macros.
** 
** #define DRM_TRACE_NO_SCOPE( szFormat )
** Note: DRM_TRACE_NO_SCOPE is almost identical to DRM_TRACE, with the only difference that
**       DRM_TRACE_NO_SCOPE can be used anywhere whether a scope has been defined or not.
**       Traces originated from DRM_TRACE_NO_SCOPE cannot be filtered since they are not
**       associated with either a specific scope or a specific component.
**       The TRACE macro is translated into DRM_TRACE_NO_SCOPE.
**
** #define DRM_TRACE_ID0( eRobust, dwID, dwParam0 )
** #define DRM_TRACE_ID1( eRobust, dwID, dwParam0, dwParam1 )
** #define DRM_TRACE_ID2( eRobust, dwID, dwParam0, dwParam1, dwParam2 )
** #define DRM_TRACE_ID3( eRobust, dwID, dwParam0, dwParam1, dwParam2, dwParam3 )
** Note: DRM_TRACE_IDX macros are used to trace a predefined format string specified by a
**       format string ID. The format string takes zero or more DWORD parameters.
**       If OEM wants to use format strings with more than three parameters, it can add more
**       macro definitions to the DRM_TRACE_IDX macro group.
**
** #define DRM_TRACE_ENTER_SCOPE( eRobust, dwScopeID )
** #define DRM_TRACE_LEAVE_SCOPE( eRobust, dwScopeID, dr )
** Note: The enter/leave scope trace maros are implicitly called by DRM_PROFILING_ENTER_SCOPE
**       and DRM_PROFILING_LEAVE_SCOPE macros. Generally user should not deal with these two
**       macros directly. It is recommended to set the filter level of enter/leave scope trace
**       at a higher trace level (e.g. equal to or above TRACE_INFO ) to avoid unnecessary
**       details.
**
** #define DRM_TRACE_STATUS_CODE( eRobust, dwEventID, dr )
** Note: The status trace macro is used to trace a status code associated with a specific
**       event ID. The exact meaning of an event ID is defined by the user.
**
** #define DRM_TRACE_START( pOEMContext, pdstrFilename )
** #define DRM_TRACE_STOP()
** Note: The start/stop trace macros are defined by OEM to start/stop the tracing machanism.
**       For example, OEM can open a trace log file when DRM_TRACE_START is called, and close
**       the trace log file when DRM_TRACE_STOP is called.
*/

/* The following macros are shared by all OEM tracing implementations. */

/*
** Set the global trace level to a certain level will filter out all traces from
** scopes that have scope tracel level higher than the global trace level.
*/
#define DRM_GLOBAL_TRACE_LEVEL( Level ) \
                                    Oem_Trace_GetGlobalContext()->m_eTraceLevel = ( Level );

/*
** Set the global component trace level to a certain level will filter out all traces from
** components that have component trace level higher than the global component trace level.
*/
#define DRM_GLOBAL_COMPONENT_TRACE_LEVEL( ID, Level ) \
                                    if ( ID >=0 && ID < MAX_TRACE_COMPONENT ) \
                                    { \
                                        Oem_Trace_GetGlobalContext()->m_rgeComponentTraceLevels[ ID ] = ( Level ); \
                                    }

/*
** Define the current scope trace level. The current scope must have already been defined
** by the DRM_PROFILING_ENTER_SCOPE and DRM_PROFILING_LEAVE_SCOPE macros.
*/
#define DRM_TRACE_LEVEL( Level )    ScopeContext.m_eTraceLevel = ( Level );

/*
** Associate the current scope with a component ID. By default all scopes belongs to component 0.
** Each scope can only be associated with one component at one time. The current scope must have
** already been defined by the DRM_PROFILING_ENTER_SCOPE and DRM_PROFILING_LEAVE_SCOPE macros.
*/
#define DRM_TRACE_COMPONENT_ID( ID ) \
                                    ScopeContext.m_dwComponent = ( ID );

/*
** Internal macro that is used to determine whether the trace from the current scope should be filtered.
** The trace from the current scope should be filtered if both of the following conditions are met:
** 1. The current scope has a scope tracel level that is higher than the global trace level.
** 2. The current scope has a component trace level that is higher than the global component trace level.
*/
#define _DRM_TRACE_IF_NOT_FILTERED   if ( Oem_Trace_GetGlobalContext()->m_eTraceLevel >= ScopeContext.m_eTraceLevel || \
                                          Oem_Trace_GetGlobalContext()->m_rgeComponentTraceLevels[ ScopeContext.m_dwComponent ] >= ScopeContext.m_eTraceLevel )

/* Turn on a specific trace channel. By default only console channel ( TRACE_CONSOLE_CHANNEL ) is turned on. */
#define DRM_TRACE_CHANNEL_ON( Channel ) \
                                    Oem_Trace_GetGlobalContext()->m_dwChannelMask |= ( ( Channel ) );

/* Turn off a specific trace channel. */
#define DRM_TRACE_CHANNEL_OFF( Channel ) \
                                    Oem_Trace_GetGlobalContext()->m_dwChannelMask &= ( ~( Channel ) );

#else

/* Define all trace macros to nothing is DRM_SUPPORT_TRACING is 0. */
#define DRM_TRACE_ID( trace_id )
#define DRM_TRACE( szFormat )
#define DRM_TRACE_NO_SCOPE( szFormat )
#define DRM_TRACE_ID0( eRobust, dwID, dwParam0 )
#define DRM_TRACE_ID1( eRobust, dwID, dwParam0, dwParam1 )
#define DRM_TRACE_ID2( eRobust, dwID, dwParam0, dwParam1, dwParam2 )
#define DRM_TRACE_ID3( eRobust, dwID, dwParam0, dwParam1, dwParam2, dwParam3 )
#define DRM_TRACE_ENTER_SCOPE( eRobust, dwScopeID )
#define DRM_TRACE_LEAVE_SCOPE( eRobust, dwScopeID, dr )
#define DRM_TRACE_STATUS_CODE( eRobust, dwEventID, dr )
#define DRM_TRACE_START( pOEMContext, pdstrFilename )
#define DRM_TRACE_STOP()

#define DRM_GLOBAL_TRACE_LEVEL( Level )
#define DRM_GLOBAL_COMPONENT_TRACE_LEVEL( ID, Level )
#define DRM_TRACE_LEVEL( Level )
#define DRM_TRACE_COMPONENT_ID( ID )
#define DRM_TRACE_IF_NOT_FILTERED
#define DRM_TRACE_CHANNEL_ON( Channel )
#define DRM_TRACE_CHANNEL_OFF( Channel )

#endif  /* DRM_SUPPORT_TRACING */

EXIT_PK_NAMESPACE;

#endif  /* __DBMTRACE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmtypes.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMTYPES_H__
#define __DRMTYPES_H__

#include <drmnamespace.h>   /* defining proper namespace (if used) */
#include <drmcompiler.h>
#include <drmint64.h>

ENTER_PK_NAMESPACE;

typedef void      DRM_VOID;

#ifndef DRM_RESULT_DEFINED
#define DRM_RESULT_DEFINED
typedef DRM_LONG  DRM_RESULT;
#endif /*DRM_RESULT_DEFINED*/

typedef DRM_WORD  DRM_LANGID;


#define CHAR_BIT      8                /* number of bits in a char    */
#define SCHAR_MIN   (-128)             /* minimum signed char value   */
#define SCHAR_MAX     127              /* maximum signed char value   */
#define UCHAR_MAX     0xff             /* maximum unsigned char value */
#define LONG_MIN    (-2147483647L - 1) /* minimum (signed) long value */
#define LONG_MAX      2147483647L      /* maximum (signed) long value */
#define ULONG_MAX     0xffffffffUL     /* maximum unsigned long value */

#if SIXTEEN_BIT_ADDRESSING
#define CB_NATIVE_BYTE 2
#define __CB_DECL(x) ((x)/CB_NATIVE_BYTE+(((x)%CB_NATIVE_BYTE)?1:0))
#else
#define CB_NATIVE_BYTE 1
#define __CB_DECL(x) (x)
#endif

#ifndef SIZEOF
#define SIZEOF(x) (sizeof(x)*CB_NATIVE_BYTE)
#endif

#ifndef BITS_PER_BYTE
#define BITS_PER_BYTE (CB_NATIVE_BYTE*8)
#endif

#if !defined( _W64 )
#if  ( defined(_X86_) || defined(_M_IX86) ) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif


#if defined( _WIN64)
typedef DRM_INT64 DRM_INT_PTR;
typedef DRM_UINT64 DRM_UINT_PTR;
typedef DRM_UINT64 DRM_DWORD_PTR;
typedef DRM_UINT64 DRM_SIZE_T;
#else
typedef _W64 DRM_INT DRM_INT_PTR;
typedef _W64 DRM_UINT DRM_UINT_PTR;
typedef _W64 DRM_DWORD DRM_DWORD_PTR;
typedef _W64 DRM_DWORD DRM_SIZE_T;
#endif

#define IS_DWORD_ALIGNED( x ) ( ( DRM_DWORD_PTR )( x ) % SIZEOF( DRM_DWORD_PTR ) == 0 )
#define DWORD_ALIGNED_SIZE( x ) ( ( (x) % SIZEOF( DRM_DWORD_PTR ) == 0 ) ? (x) : (x) + ( SIZEOF( DRM_DWORD_PTR ) - ( (x) % SIZEOF( DRM_DWORD_PTR ) ) ) )

typedef struct __tagDRM_GUID {
    DRM_DWORD Data1;
    DRM_WORD  Data2;
    DRM_WORD  Data3;
    DRM_BYTE  Data4 [__CB_DECL(8)];
} DRM_GUID;

#define EMPTY_DRM_GUID  { 0, 0, 0, { 0, 0, 0, 0, 0, 0, 0, 0 } }

#define IDENTICAL_GUIDS(p0,p1) \
    (MEMCMP((p0), (p1), SIZEOF(DRM_GUID)) == 0)

/*
** The following macro should be used to define GUIDs that are local to a single code file.
*/
#define DRM_DEFINE_LOCAL_GUID( name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8 )  \
        static const DRM_GUID name                                                 \
                = { l, w1, w2, { TWO_BYTES( b1, b2 ), TWO_BYTES( b3, b4 ),  \
                                 TWO_BYTES( b5, b6 ), TWO_BYTES( b7, b8 ) } }

/*
** The following two macros should be used to declare and define GUIDs that are
** shared among multiple code files.
*/
#define DRM_DEFINE_GUID( name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8 )  \
        const DRM_EXPORT_VAR DRM_GUID name                                  \
                = { l, w1, w2, { TWO_BYTES( b1, b2 ), TWO_BYTES( b3, b4 ),  \
                                 TWO_BYTES( b5, b6 ), TWO_BYTES( b7, b8 ) } }

#define DRM_DECLARE_GUID( name )    \
        extern const DRM_EXPORT_VAR DRM_GUID name

/*
** This macro will calculate the maximum value of an unsigned data type 
** where the type is passed in as x.
** For example MAX_UNSIGNED_TYPE( DRM_BYTE  ) will evaluate to 0xFF
**             MAX_UNSIGNED_TYPE( DRM_DWORD ) will evaluate to 0xFFFFFFFF
*/
#define MAX_UNSIGNED_TYPE(x) ( (x)~((x)0) )

/*
**
*/
typedef struct tagDRM_CONST_STRING
{
    const DRM_WCHAR *pwszString;
    DRM_DWORD        cchString;
} DRM_CONST_STRING;

/*
**
*/
typedef struct tagDRM_STRING
{
    DRM_WCHAR *pwszString;
    DRM_DWORD  cchString;
} DRM_STRING;

typedef struct tagDRM_ANSI_CONST_STRING
{
    const DRM_CHAR *pszString;
    DRM_DWORD       cchString;
} DRM_ANSI_CONST_STRING;

typedef struct tagDRM_ANSI_STRING
{
    DRM_CHAR  *pszString;
    DRM_DWORD  cchString;
} DRM_ANSI_STRING;

typedef struct __tagSubString
{
    DRM_DWORD m_ich;
    DRM_DWORD m_cch;
} DRM_SUBSTRING;

typedef struct tagDRM_STRING_WINDOW
{
    DRM_DWORD m_ichMin; /* inclusive */
    DRM_DWORD m_ichMaxExclusive; /* exclusive */
} DRM_STRING_WINDOW;

#define ASSIGN_DRM_ANSI_STRING(x,y) \
{ \
    (x).pszString = (y); \
    (x).cchString = NO_OF(y)-1; \
}

#define ASSIGN_DRM_STRING(x,y) \
{ \
    (x).pwszString = (y).pwszString; \
    (x).cchString  = (y).cchString; \
}

#define INIT_DRM_STRING(x) \
{ \
    (x).pwszString = NULL; \
    (x).cchString  = 0; \
}

#define INIT_DRM_ANSI_STRING(x) \
{ \
    (x).pszString = NULL; \
    (x).cchString = 0; \
}

/* This macro can only be used at the declaration of DRM_STRING 
** It initailizes DRM  string from DRM_WCHAR array.
*/

#if TARGET_LITTLE_ENDIAN || SIXTEEN_BIT_ADDRESSING
/* Little endian machines will use L"".  Packed strings will use TWO_BYTES( ) which will be a short and the right size */
#define CREATE_DRM_STRING(x) { ((const DRM_WCHAR *) (x)), (NO_OF(x)) - 1 }
#else
/* Big Endian processors that are 8-bit referencable will have strings like "S\0t\0r\0i\0n\0g\0" */
#define CREATE_DRM_STRING(x) { (DRM_WCHAR*) x, (NO_OF(x)-1)/SIZEOF(DRM_WCHAR)}
#endif

#if TARGET_LITTLE_ENDIAN || SIXTEEN_BIT_ADDRESSING
#define CREATE_ANSI_DRM_STRING(x) { ((const DRM_CHAR *) (x)), (NO_OF(x)) - 1 }
#else
#define CREATE_ANSI_DRM_STRING(x) { (DRM_CHAR*) x, SIZEOF(x) - 1}
#endif

/* This macro can be used to initialize DRM_STRING from DRM_WCHAR 
** in the middle of the function code
*/

#if TARGET_LITTLE_ENDIAN || SIXTEEN_BIT_ADDRESSING
/* 
** Little endian machines will use L"". Packed strings will use TWO_BYTES( ) 
** which will be a short and the right size 
**
** Assert if the pointer is not DRM_WCHAR aligned
*/
#define MAKE_DRM_STRING(x, y) \
    x.pwszString = y; \
    x.cchString = (NO_OF(y)) - 1; \
    DRMASSERT( (DRM_DWORD_PTR)(y) % sizeof( DRM_WCHAR ) == 0 );
#else
/* 
** Big Endian processors that are 8-bit referencable will have strings like "S\0t\0r\0i\0n\0g\0" 
*/
#define MAKE_DRM_STRING(x, y) \
    x.pwszString = (DRM_WCHAR*)y; \
    x.cchString = ((NO_OF(y)-1)/SIZEOF(DRM_WCHAR); \
    DRMASSERT( (DRM_DWORD_PTR)(y) % sizeof( DRM_WCHAR ) == 0 );
#endif 


#if TARGET_LITTLE_ENDIAN
#define WCHAR_CAST(x)   ((DRM_WCHAR)(x))
#define NATIVE_WCHAR(x) (x)
#else
#define WCHAR_CAST(x)   ((DRM_WCHAR)(x)<<8)
#define NATIVE_WCHAR(x) ((x)>>8)
#endif

/* 
** Note: in drmconstants.c CREATE_DRM_ANSI_STRING should be used
** with caution. When we create a const ansi string from const char[] arrays
** an array may have one or two trailing zero chars for alignment reasons,
** but this macro just always sets ansi string's char size into a size of array - 1.
*/
#define CREATE_DRM_ANSI_STRING(x) {(x),((NO_OF(x))-1)*CB_NATIVE_BYTE}

#define EMPTY_DRM_STRING        { NULL, 0 }
#define EMPTY_DRM_SUBSTRING     { 0, 0 }
#define EMPTY_DRM_STRING_WINDOW { 0, 0 }

#ifndef UNREFERENCED_PARAMETER
#define UNREFERENCED_PARAMETER(p)   (p)
#endif

/*
**  Assert if the pointer is not DRM_WCHAR aligned
 */

#define DSTR_FROM_PB(pdstr,pb,cb) \
    (pdstr)->cchString=(cb)/SIZEOF(DRM_WCHAR); \
    (pdstr)->pwszString=(DRM_WCHAR*)(pb); \
    DRMASSERT( (DRM_DWORD_PTR)(pb) % sizeof( DRM_WCHAR ) == 0 );

#define DASTR_FROM_PB(pdastr,pb,cb) \
    (pdastr)->cchString=(cb)/( SIZEOF( DRM_CHAR ) / CB_NATIVE_BYTE ); \
    (pdastr)->pszString=(DRM_CHAR*)(pb); 

/* for frequent uses of DRM_CONST_STRINGs' char counts and
  wide-char buffers as byte counts and byte buffers */

#define PB_DSTR(pdstr) (DRM_BYTE*)((pdstr)->pwszString)
#define CB_DSTR(pdstr) ((pdstr)->cchString*SIZEOF(DRM_WCHAR))

#define PB_DASTR(pdstr) (DRM_BYTE*)((pdstr)->pszString)
#define CB_DASTR(pdstr) ((pdstr)->cchString)

#define C_TICS_PER_SECOND 10000000
#define C_SECONDS_FROM_1601_TO_1970  DRM_UI64Mul(DRM_UI64(1164447360), DRM_UI64(10))
    
#define CREATE_FILE_TIME(dw, ft) {  \
            DRM_UINT64 ui64Tics = DRM_UI64Add( DRM_UI64( dw ), C_SECONDS_FROM_1601_TO_1970 ); \
            ui64Tics = DRM_UI64Mul( ui64Tics, DRM_UI64( C_TICS_PER_SECOND ) );                \
            UI64_TO_FILETIME( ui64Tics, ft );                                                 \
        }

#define FILE_TIME_TO_DWORD(ft, dw) {  \
            DRM_UINT64 ui64Tics; \
            FILETIME_TO_UI64( ft, ui64Tics ); \
            ui64Tics = DRM_UI64Div( ui64Tics, DRM_UI64( C_TICS_PER_SECOND ) );                \
            dw = DRM_UI64Low32( DRM_UI64Sub( ui64Tics, C_SECONDS_FROM_1601_TO_1970 ) ); \
        }

typedef struct _tagDRMSYSTEMTIME
{
    DRM_WORD wYear;
    DRM_WORD wMonth;
    DRM_WORD wDayOfWeek;
    DRM_WORD wDay;
    DRM_WORD wHour;
    DRM_WORD wMinute;
    DRM_WORD wSecond;
    DRM_WORD wMilliseconds;
}     DRMSYSTEMTIME;

#if TARGET_LITTLE_ENDIAN
typedef struct _tagDRMFILETIME
{
    DRM_DWORD dwLowDateTime;
    DRM_DWORD dwHighDateTime;
} DRMFILETIME;
#else
typedef struct _tagDRMFILETIME
{
    DRM_DWORD dwHighDateTime;
    DRM_DWORD dwLowDateTime;
} DRMFILETIME;
#endif
/* generic ID type, currently all the same size */

#define DRM_ID_SIZE  16

typedef struct _tagDRM_ID 
{
    DRM_BYTE rgb [__CB_DECL(DRM_ID_SIZE)];
} DRM_ID;

typedef DRM_ID DRM_MID;
typedef DRM_ID DRM_KID;
typedef DRM_ID DRM_LID;
typedef DRM_ID DRM_TID;

/* Structure that contains the definition of a domain ID. */
typedef struct
{
    /* Service ID. */
    DRM_GUID    m_oServiceID;

    /* Account ID. */
    DRM_GUID    m_oAccountID;

    /* Revision. */
    DRM_DWORD   m_dwRevision;
} DRM_DOMAIN_ID;

#define EMPTY_DRM_DOMAIN_ID { EMPTY_DRM_GUID, EMPTY_DRM_GUID, 0 }

/* SLK Size: SLK is either DES (8 byte) or AES (16 byte) */
#define DRM_SLK_SIZE 16

typedef struct __tagDRM_SLK
{
    DRM_BYTE  rgbKey[__CB_DECL( DRM_SLK_SIZE )];
    DRM_DWORD cbKey;
} DRM_SLK;

typedef struct _tagDRM_SLKDATA
{
    DRM_SLK slk;
    DRM_ID  idSLK;    
} DRM_SLKDATA;

typedef struct _tagDRM_BYTEBLOB
{
    DRM_BYTE *pbBlob;
    DRM_DWORD cbBlob;
} DRM_BYTEBLOB;

EXIT_PK_NAMESPACE;

/******* The following definitions are pulled from bigdefs.h and are for use by bignum *******/
#define DWORD_BITS 32
#define DWORD_LEFT_BIT 0x80000000UL

/*      Multiple-precision data is normally represented
**      in radix 2^RADIX_BITS, with RADIX_BITS bits per word.
**      Here ``word'' means type digit_t.  RADIX_BITS
**      should be 32 for all supported architectures */
#define RADIX_BITS      32
#define RADIX_BYTES     4

/* Datatypes used by bignum */
typedef DRM_DWORD       digit_t;
typedef DRM_LONG        sdigit_t;
struct bigctx_t;

#define DIGIT_ZERO ((digit_t)0)
#define DIGIT_ONE  ((digit_t)1)

#define RADIX_HALF (DIGIT_ONE << (RADIX_BITS - 1))
#define RADIXM1 (DIGIT_ZERO - DIGIT_ONE)

#define DWORDS_PER_DIGIT (RADIX_BITS/DWORD_BITS)

/* DWORDS_TO_DIGITS(lng_dwords) computes the number of digit_t
** elements required to store an array with -lng_dwords- DWORDs.
** DIGITS_TO_DWORDS converts in the opposite direction. */
#define DWORDS_TO_DIGITS(lng_dwords) \
                ( ((lng_dwords) + DWORDS_PER_DIGIT - 1)/DWORDS_PER_DIGIT)
#define DIGITS_TO_DWORDS(lng_digits) ((lng_digits) * DWORDS_PER_DIGIT)
#define BITS_TO_DIGITS(nb) (((nb) + RADIX_BITS - 1)/RADIX_BITS)
#define digit_getbit(iword, ibit) (((iword) >> (ibit)) & 1)

/*
**      Test whether a (possibly negative) number is odd or even.
*/
#define IS_EVEN(n) (~(DRM_UINT)(n) & 1)
#define IS_ODD(n) ((DRM_UINT)(n) & 1)

/*
        Maximum and minimum of two arguments
        (no side effects in arguments)
*/
#ifndef MAX
    #define MAX(x, y) ((x) > (y) ? (x) : (y))
#endif
#ifndef MIN
    #define MIN(x, y) ((x) > (y) ? (y) : (x))
#endif

#endif  /* __DRMTYPES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmutilities.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_UTILITIES_H__
#define __DRM_UTILITIES_H__

#include <drmcontextsizes.h>

ENTER_PK_NAMESPACE;

typedef enum DRM_ROOTPUBKEY_CATEGORY
{
    WM_DRM_ROOTPUBKEY_LICENSES = 0,
    WM_DRM_ROOTPUBKEY_LRB,   
    WM_DRM_ROOTPUBKEY_CLK,
    WM_DRM_ROOTPUBKEY_MTR   
} DRM_ROOTPUBKEY_CATEGORY;

DRM_API DRM_BOOL DRM_CALL DRM_UTL_IsCertDateOK(
    __in_opt    DRM_VOID        *pOEMContext,
    __in_bcount( 4 ) const DRM_BYTE  *f_pbDate);

DRM_API DRM_RESULT DRM_CALL DRM_UTL_CheckCertNoCache(
    IN const CERT               *f_pcert, 
    IN const PUBKEY             *f_ppubkey, 
    IN       DRM_BOOL            f_fCheckDate, 
    IN       DRM_CRYPTO_CONTEXT *f_pcontextCRYP,
    IN       DRM_VOID            *f_pOEMContext );

DRM_API DRM_RESULT DRM_CALL DRM_UTL_CheckCertificate(
    IN  const   CERT                    *f_pcert, 
    IN  const   PUBKEY                  *f_ppubkey, 
    IN          DRM_BOOL                 f_fCheckCertDate,   
    IN          DRM_LICEVAL_CONTEXT     *f_pcontextLEVL,
    IN          DRM_ROOTPUBKEY_CATEGORY  f_eRootPubkey);

DRM_API DRM_RESULT DRM_CALL DRM_UTL_CheckCert(
    IN const CERT                *f_pcert, 
    IN const PUBKEY              *f_ppubkey, 
    IN       DRM_BOOL             f_fCheckDate, 
    IN       DRM_LICEVAL_CONTEXT *f_pcontextLEVL );

DRM_API DRM_RESULT DRM_CALL DRM_UTL_CheckDACCert(
    IN const CERT                *f_pcert, 
    IN const PUBKEY              *f_ppubkey, 
    IN       DRM_BOOL             f_fCheckDate, 
    IN       DRM_LICEVAL_CONTEXT *f_pcontextLEVL );

#if DRM_SUPPORT_CERTIFICATE_CACHING
DRM_API DRM_RESULT DRM_CALL  DRM_UTL_AddCachedCertificate (
    IN       DRM_BB_CONTEXT       *f_pcontextBBX,
    IN       DRM_SECSTORE_CONTEXT *f_pcontextSSTRevocation,
    IN       DRM_DST              *f_pDatastore,
    IN const DRM_BYTE             *f_pbData,
    IN       DRM_DWORD             f_cbData );

DRM_API DRM_BOOL DRM_CALL DRM_UTL_VerifyCachedCertificate (
    IN       DRM_BB_CONTEXT       *f_pcontextBBX,
    IN       DRM_SECSTORE_CONTEXT *f_pcontextSST,
    IN       DRM_DST              *f_pDatastore,
    IN const DRM_BYTE             *f_pbData,
    IN       DRM_DWORD             f_cbData );
#endif

DRM_API DRM_RESULT DRM_CALL DRM_PK_EncryptLarge( 
    IN       DRM_VOID            *f_pOEMContext,
    IN const PUBKEY              *f_ppubkey,
    __inout_bcount( f_cbClear ) DRM_BYTE *f_pbClear, 
    IN       DRM_DWORD            f_cbClear, 
    __out_bcount( f_cbClear + DRM_ECC160_CIPHERTEXT_LEN ) DRM_BYTE *f_pbCipher, 
    IN       DRM_DWORD            f_cbKeySymmetric, 
    IN       DRM_CRYPTO_CONTEXT  *f_pcontextCRYP);

DRM_API DRM_RESULT DRM_CALL DRM_PK_DecryptLarge( 
    IN const PRIVKEY            *f_ppubkey,
    __inout_bcount( f_cbCipher) DRM_BYTE *f_pbCipher, 
    IN       DRM_DWORD           f_cbCipher, 
    __out_bcount( f_cbCipher - DRM_ECC160_CIPHERTEXT_LEN ) DRM_BYTE *f_pbClear, 
    IN       DRM_CRYPTO_CONTEXT *f_pcontextCRYP);

DRM_API DRM_RESULT DRM_CALL DRM_UTL_GetVersionAsString( 
    __in_bcount( VERSION_LEN ) DRM_BYTE  rgbVersion[__CB_DECL(VERSION_LEN)],
    __out_ecount( VER_STRING_MAX_LEN ) DRM_WCHAR wszVerString [VER_STRING_MAX_LEN]);

DRM_API DRM_RESULT DRM_CALL DRM_UTL_GetVersionFromString(
   __in_ecount( cchVersion ) const DRM_WCHAR  *pwszVersion,
   IN       DRM_DWORD   cchVersion,
   __out_ecount( VERSION_LEN ) DRM_WORD rgwVersion[VERSION_LEN] );

DRM_API DRM_RESULT DRM_CALL DRM_UTL_StringToGuid( 
    IN const DRM_CONST_STRING *pdstrString,
    OUT      DRM_GUID         *pGuid );

#define DRM_GUID_STRING_LEN 38
DRM_API DRM_RESULT DRM_CALL DRM_UTL_GuidToString
( 
    IN      const                           DRM_GUID  *pGuid, 
        __out_ecount(DRM_GUID_STRING_LEN)   DRM_WCHAR  rgwszString[DRM_GUID_STRING_LEN]
);

DRM_API DRM_RESULT DRM_CALL DRM_UTL_StringInsertSubString(
    IN OUT   DRM_STRING       *pdstrString,
    IN       DRM_DWORD         dwInsertPoint,
    IN const DRM_CONST_STRING *pdstrSubString);

DRM_API DRM_RESULT DRM_CALL DRM_UTL_StringRemoveSubString(
    IN OUT   DRM_STRING       *pdstrString,
    IN const DRM_CONST_STRING *pdstrSubString);

DRM_API DRM_RESULT DRM_CALL DRM_UTL_StringInsertBlankSubString(
    IN OUT DRM_STRING *f_pdstrTarget,
    IN     DRM_DWORD   f_ichInsertion,
    IN     DRM_DWORD   f_cch);

DRM_API DRM_RESULT DRM_CALL DRM_UTL_StringInsertBlankSubStringA(
    IN OUT DRM_ANSI_STRING *f_pdastrTarget,
    IN DRM_DWORD f_ichInsertion,
    IN DRM_DWORD f_cch );
    
DRM_API DRM_BOOL DRM_CALL DRM_UTL_DSTRStringsEqual(
    const DRM_CONST_STRING *pdstr1,
    const DRM_CONST_STRING *pdstr2);

DRM_API DRM_BOOL DRM_CALL DRM_UTL_DASTRStringsEqual(
    const DRM_ANSI_CONST_STRING *f_pdastr1,
    const DRM_ANSI_CONST_STRING *f_pdastr2);

DRM_API DRM_BOOL DRM_CALL DRM_UTL_DASSTRStringsEqual(
    __in_ecount( f_pdasstr->m_ich + f_pdasstr->m_cch ) const DRM_CHAR *f_pszBase,
    const DRM_SUBSTRING         *f_pdasstr,
    const DRM_ANSI_CONST_STRING *f_pdastr);

DRM_API DRM_BOOL DRM_CALL DRM_UTL_DASSTRStrings_CI_Equal(
    __in_ecount( f_pdasstr->m_ich + f_pdasstr->m_cch ) const DRM_CHAR      *f_pszBase,
    const DRM_SUBSTRING *f_pdasstr,
    const DRM_ANSI_CONST_STRING *f_pdastr );

DRM_API DRM_BOOL DRM_CALL DRM_UTL_DASSSTRStringsEqual(
    __in_ecount( f_pdasstr0->m_ich + f_pdasstr0->m_cch ) const DRM_CHAR *f_pszBase0,
    const DRM_SUBSTRING *f_pdasstr0,
    __in_ecount( f_pdasstr1->m_ich + f_pdasstr1->m_cch ) const DRM_CHAR *f_pszBase1,
    const DRM_SUBSTRING *f_pdasstr1);

DRM_API DRM_BOOL DRM_CALL DRM_UTL_DSTRSearch( 
    IN const DRM_CONST_STRING *f_pdstrString,
    IN const DRM_CONST_STRING *f_pdstrSubString,
       OUT   DRM_CONST_STRING *f_pdstrFoundString );

DRM_API DRM_BOOL DRM_CALL DRM_UTL_DSTRSearchReverse( 
    IN const DRM_CONST_STRING *f_pdstrString,
    IN const DRM_CONST_STRING *f_pdstrSubString,
       OUT   DRM_CONST_STRING *f_pdstrFoundString );

DRM_API DRM_RESULT DRM_CALL DRM_UTL_EnsureDataAlignment(
    __in_bcount( f_cbOriginal ) const DRM_BYTE   *f_pbOriginal,
    IN  const DRM_DWORD   f_cbOriginal,
    __deref_out_bcount( *f_pcbAligned ) DRM_BYTE  **f_ppbAligned,
    OUT       DRM_DWORD  *f_pcbAligned,
    IN  const DRM_DWORD   f_cbDataType,
    OUT       DRM_DWORD  *f_pcbAdjustment);

DRM_API DRM_RESULT DRM_CALL DRM_UTL_VerifyXMLSignature(
    IN  const   DRM_CONST_STRING        *f_pdstrSignedData,
    IN  const   DRM_CONST_STRING        *f_pdstrSignatureXML,
    IN  const   DRM_CONST_STRING        *f_pdstrCertChainXML,
    IN          DRM_BOOL                 f_fCheckExpiry,
    IN          DRM_BOOL                 f_fCheckCertChain,
    IN          DRM_ROOTPUBKEY_CATEGORY  f_eRootPubkey,
    IN  OUT     DRM_LICEVAL_CONTEXT     *f_pcontextLEVL);

DRM_API DRM_RESULT DRM_CALL DRM_UTL_VerifyXMLSignatureEx(
    IN  const   DRM_CONST_STRING        *f_pdstrSignedData,
    IN  const   DRM_CONST_STRING        *f_pdstrSignatureValue,
    IN  const   DRM_CONST_STRING        *f_pdstrCertChainXML,
    IN          DRM_BOOL                 f_fCheckExpiry,
    IN          DRM_BOOL                 f_fCheckCertChain,
    IN          DRM_ROOTPUBKEY_CATEGORY  f_eRootPubkey,
    IN  OUT     DRM_LICEVAL_CONTEXT     *f_pcontextLEVL);

DRM_API DRM_BOOL DRM_CALL DRM_UTL_DateLessThan(
    IN const DRMFILETIME* f_pFileTime1, 
    IN const DRMFILETIME* f_pFileTime2);

DRM_API DRM_RESULT DRM_CALL DRM_UTL_DecodeKID( 
    IN const DRM_CONST_STRING *f_pdstrKID, 
       OUT   DRM_KID          *f_pkid );
        
DRM_API DRM_VOID DRM_CALL DRM_UTL_PromoteASCIItoUNICODE(
    __in_ecount( f_pdassstrIn->m_ich + f_pdassstrIn->m_cch ) const DRM_CHAR *f_pszBase,
    const DRM_SUBSTRING *f_pdassstrIn, 
          DRM_STRING    *f_pdstrOut);    

DRM_API DRM_VOID DRM_CALL DRM_UTL_DemoteUNICODEtoASCII( 
    __in_ecount(cchMax) const DRM_WCHAR *pwszFileName, 
    __out_ecount(cchMax) DRM_CHAR  *pszFileName, 
                         DRM_DWORD  cchMax );

DRM_API DRM_RESULT DRM_CALL DRM_UTL_XMLDecode(
    __in_ecount( f_cchEncoded ) const DRM_WCHAR *f_pwszEncoded,
    IN                                  DRM_DWORD    f_cchEncoded,
    __out_ecount_opt(*f_pcchDecoded) DRM_WCHAR *f_pwszDecoded,
    IN  OUT                             DRM_DWORD   *f_pcchDecoded );

DRM_API DRM_RESULT DRM_CALL DRM_UTL_XMLDecodeUA(
    __in_ecount( f_cchEncoded ) const DRM_WCHAR *f_pwchEncoded,
    IN DRM_DWORD f_cchEncoded,
    __out_ecount_opt(*f_pcchDecoded) DRM_CHAR *f_pchDecoded,
    IN OUT DRM_DWORD *f_pcchDecoded );

DRM_API DRM_RESULT DRM_CALL DRM_UTL_XMLDecodeA(
    __in_ecount( f_cchEncoded ) const DRM_CHAR *f_pchEncoded,
    IN DRM_DWORD f_cchEncoded,
    __out_ecount_opt(*f_pcchDecoded) DRM_CHAR *f_pchDecoded,
    IN OUT DRM_DWORD *f_pcchDecoded );

DRM_API DRM_RESULT DRM_CALL DRM_UTL_XMLEncodeA(
    __in_ecount( f_cchDecoded ) const DRM_CHAR *f_pchDecoded,
    IN DRM_DWORD f_cchDecoded,
    __out_ecount_opt(*f_pcchEncoded) DRM_CHAR *f_pchEncoded,
    IN OUT DRM_DWORD *f_pcchEncoded );

DRM_API DRM_VOID DRM_CALL DRM_XOR( 
    __inout_bcount(cb)   DRM_BYTE *pbLHS, 
    __in_bcount(cb) const DRM_BYTE *pbRHS, 
    IN                   DRM_DWORD cb );

/************************************************
*  Reads GUID from specified offset in byte array
*  pointed by pbData.
*
************************************************/
#define DRM_GUID_LEN 16
DRM_API DRM_RESULT DRM_CALL DRM_UTL_ReadGUID(
   __in_bcount( cbData ) const DRM_BYTE *pbData, 
   IN  const    DRM_DWORD cbData,
   IN           DRM_DWORD ibGuidOffset,
   OUT          DRM_GUID *pDrmGuid );

/************************************************
*  Compares 2 GUID, returns 
*  pointed by pbData.
*
************************************************/

DRM_API DRM_BOOL DRM_CALL DRM_UTL_AreGUIDEqual( 
    const DRM_GUID *pDrmGuid1, 
    const DRM_GUID *pDrmGuid2 );


DRM_API DRM_BOOL DRM_CALL DRM_UTL_IsZeros(
    __in_bcount( cbBuff ) const DRM_BYTE *pbBuff,
    IN DRM_DWORD cbBuff );


DRM_API DRM_RESULT DRM_CALL DRM_UTL_LShift( 
    __in_bcount( f_cb ) const DRM_BYTE *f_pbIn, 
    __out_ecount(f_cb) DRM_BYTE *f_pbOut, 
    IN                 DRM_DWORD f_cb );


DRM_API DRM_RESULT DRM_CALL DRM_UTL_RShift( 
    __in_bcount( f_cb ) const DRM_BYTE *f_pbIn, 
    __out_ecount(f_cb) DRM_BYTE *f_pbOut, 
    IN                 DRM_DWORD f_cb );

DRM_API DRM_RESULT DRM_CALL DRM_UTL_MultiplyDWORDs(
    IN      DRM_DWORD   f_dwFirst,
    IN      DRM_DWORD   f_dwSecond,
        OUT DRM_DWORD  *f_pdwResult );

EXIT_PK_NAMESPACE;

#endif /* __DRM_UTILITIES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmutf.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_UTF_H
#define __DRM_UTF_H

ENTER_PK_NAMESPACE;

/* Test for little endian UTF-16 BOM (byte order mask) */
#define IS_LITTLE_ENDIAN_UTF16_BOM(_pbData_) ( GET_BYTE( _pbData_, 0 ) == 0xFFUL && GET_BYTE( _pbData_, 1 ) == 0xFEUL )

/* Test for big endian UTF-16 BOM (byte order mask) */
#define IS_BIG_ENDIAN_UTF16_BOM(_pbData_) ( GET_BYTE( _pbData_, 0 ) == 0xFEUL && GET_BYTE( _pbData_, 1 ) == 0xFFUL )

DRM_API DRM_RESULT DRM_CALL DRM_UTF8_VerifyBytes(
    __in_bcount( f_cbData ) const DRM_BYTE  *f_pbData,
    IN const DRM_DWORD f_cbData,
    IN const DRM_DWORD f_iStart,
    IN const DRM_DWORD f_iEnd );

DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF32toUTF16(
    __in_ecount( f_cchSource ) const DRM_WCHAR32 *f_pw32szSource, 
    IN     const DRM_DWORD    f_cchSource, 
    __out_ecount_z_opt( *f_pcchTarget ) DRM_WCHAR   *f_pwszTarget, 
    IN OUT       DRM_DWORD   *f_pcchTarget );

DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF32toDSTR(
    __in_ecount( f_cchSource ) const DRM_WCHAR32 *f_pw32szSource,
    IN     const DRM_DWORD    f_cchSource,
    IN OUT       DRM_STRING  *f_pdstrTarget );

DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF16toUTF32 (
    __in_ecount( f_cchSource ) const DRM_WCHAR   *f_pwszSource, 
    IN     const DRM_DWORD    f_cchSource, 
    __out_ecount_z_opt( *f_pcchTarget ) DRM_WCHAR32 *f_pw32szTarget, 
    IN OUT       DRM_DWORD   *f_pcchTarget );

DRM_API DRM_RESULT DRM_CALL DRM_STR_DSTRtoUTF32(
    IN     const DRM_STRING  *f_pdstrSource,
    __out_ecount_opt( *f_pcchTarget ) DRM_WCHAR32 *f_pw32szTarget,
    IN OUT       DRM_DWORD   *f_pcchTarget );

DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF16toUTF8(
    __in_ecount( f_cchSource ) const DRM_WCHAR   *f_pwszSource, 
    IN     const DRM_DWORD    f_cchSource, 
    __out_ecount_z_opt( *f_pcchTarget ) DRM_CHAR *f_pbTarget,
    IN     const DRM_DWORD    f_ichTarget,         
    IN OUT       DRM_DWORD   *f_pcchTarget );

DRM_API DRM_RESULT DRM_CALL DRM_STR_DSTRtoUTF8_ByWindow(
    IN     const DRM_STRING        *f_pdstrSource, 
    __out_ecount_opt( f_pdstrwTarget->m_ichMaxExclusive ) DRM_CHAR *f_pbTarget,     
    IN OUT       DRM_STRING_WINDOW *f_pdstrwTarget );

DRM_API DRM_RESULT DRM_CALL DRM_STR_DSTRtoUTF8(
    IN     const DRM_STRING *f_pdstrSource,
    __out_ecount_opt( *f_pcchTarget ) DRM_CHAR *f_pchTarget,
    IN OUT       DRM_DWORD  *f_pcchTarget );

DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF8toUTF16(
    __in_ecount( f_ichSource+ f_cchSource ) const DRM_CHAR  *f_pbSource, 
    IN     const DRM_DWORD  f_ichSource,
    IN     const DRM_DWORD  f_cchSource, 
    __out_ecount_z_opt( *f_pcchTarget ) DRM_WCHAR *f_pwszTarget, 
    IN OUT       DRM_DWORD *f_pcchTarget ); 

DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF8toDSTR_ByWindow(
    __in_ecount( f_pdstrwSource->m_ichMaxExclusive ) const DRM_CHAR *f_pbSource, 
    IN     const DRM_STRING_WINDOW *f_pdstrwSource, 
    IN OUT       DRM_STRING        *f_pdstrTarget );

DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF8toDSTR(
    __in_ecount( f_cchSource ) const DRM_CHAR *f_pchSource,
    IN     const DRM_DWORD   f_cchSource,
    IN OUT       DRM_STRING *f_pdstrTarget );

DRM_API DRM_RESULT DRM_CALL DRM_STR_ASCII_SUBSTRtoDSTR(
    __in_ecount( f_pdasstr->m_ich + f_pdasstr->m_cch ) const DRM_CHAR *f_pchSource,
    IN     const  DRM_SUBSTRING *f_pdasstr, 
    IN OUT        DRM_STRING    *f_pdstrTarget);

DRM_API DRM_RESULT DRM_CALL DRM_STR_ASCIItoDSTR(
    __in_ecount( f_cchSource ) const DRM_CHAR *f_pchSource,
    IN const DRM_DWORD   f_cchSource, 
    IN OUT   DRM_STRING *f_pdstrTarget );

DRM_API DRM_RESULT DRM_CALL DRM_STR_UTF16toASCII( 
    __in_ecount(f_cchSource) const DRM_WCHAR *f_pwszSource,
    IN  const DRM_DWORD                       f_cchSource,
    __inout_ecount(f_cchTarget)    DRM_CHAR  *f_pszTarget,
    IN  const DRM_DWORD                       f_cchTarget );

EXIT_PK_NAMESPACE;

#endif /* __DRM_UTF_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmwindowsenv.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_WINDOWS_ENV_H__
#define __DRM_WINDOWS_ENV_H__

/*  
# Abstract:
#
# This file contains compiler directives for disabling certain Windows CE 
# compiler-time warnings and allow the PK environment to be compiled under 
# elevated warning level
#
*/

#if defined (_MSC_VER)

#if defined (WINCE)
#pragma warning( push )
#pragma warning(disable:4115) /* 'type' : named type definition in parentheses */
#pragma warning(disable:4201) /* nonstandard extension used : nameless struct/union */
#pragma warning(disable:4214) /* nonstandard extension used : bit field types other than int */
#endif

#include <windows.h> 

#if defined (WINCE)
#pragma warning( pop )
#endif

#endif /* _MSC_VER */

#endif /* __DRM_WINDOWS_ENV_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmviewprops.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_VIEWPROPERTIES_H__
#define __DRM_VIEWPROPERTIES_H__

#include "drmoutputleveltypes.h"
#include "drmchain.h"

ENTER_PK_NAMESPACE;

/* We need: */
/* 1.  Content header KID */
/* 2.  Blackbox context */
/* 3.  Secure store open to global state */
/* 4.  Secure store context not open yet */
/* 5.  License store context ( we enum here ) */
/* 6.  License eval context */
#if DRM_SUPPORT_PMLICENSE == 1
#define DRM_MAX_RIGHTS_SUPPORTED 9
#else
#define DRM_MAX_RIGHTS_SUPPORTED 3
#endif


/* support up to 2 different KIDs for uplink root license for leaf license of the same KID */
#define DRM_MAX_CHAIN_ROOTVARIANCE_SUPPORT   2


#if !DRM_LICENSE_STATE_TYPES_DEFINED
#define DRM_LICENSE_STATE_TYPES_DEFINED 1

#define DRM_ASD_VAGUE       0x1
#define DRM_ASD_OPL         0x2
#define DRM_ASD_SAP         0x4
#define DRM_ASD_MU_EXT_REST 0x8 /* Has must understand extensible restrictions */

/* Enum and structure for license properties queries */
typedef enum DRM_LICENSE_STATE_CATEGORY
{
    DRM_LICENSE_STATE_NORIGHT = 0,
    DRM_LICENSE_STATE_UNLIM,
    DRM_LICENSE_STATE_COUNT,
    DRM_LICENSE_STATE_FROM,
    DRM_LICENSE_STATE_UNTIL,
    DRM_LICENSE_STATE_FROM_UNTIL,
    DRM_LICENSE_STATE_COUNT_FROM,
    DRM_LICENSE_STATE_COUNT_UNTIL,
    DRM_LICENSE_STATE_COUNT_FROM_UNTIL,
    DRM_LICENSE_STATE_EXPIRATION_AFTER_FIRSTUSE,
    DRM_LICENSE_STATE_FORCE_SYNC,
} DRM_LICENSE_STATE_CATEGORY;

typedef struct _DRM_LICENSE_STATE_DATA
{
    DRM_DWORD   dwStreamId;      /* 0 -> All streams, != 0 -> A particular stream. */
    DRM_DWORD   dwCategory;      /* Indicates the category of string to be displayed. */
    DRM_DWORD   dwNumCounts;     /* Number of items supplied in dwCount. */
    DRM_DWORD   dwCount  [4];    /* Up to 4 counts. */
    DRM_DWORD   dwNumDates;      /* Number of items supplied in dwDate. */
    DRMFILETIME datetime [4];    /* Up to 4 dates. */
    DRM_DWORD   dwVague;         /* 0 -> certain, 1 -> atleast.  (There could be more */
                                 /*               licenses. Aggregation not possible.) */
} DRM_LICENSE_STATE_DATA;
#endif /* DRM_LICENSE_STATE_TYPES_DEFINED */


/***************************************************************************/
/* Internal structures and data */
enum LicenseCategory
{
    LIC_TYPE_IGNORE = 0,
    LIC_TYPE_EXPIRY,
    LIC_TYPE_COUNTED_EXPIRY,
    LIC_TYPE_EXPIRATION_AFTER_FIRST_USE
};


typedef struct LicenseInfo
{
    enum LicenseCategory    dwCategory;     /* License Category. DIVX, counted etc.   */
    DRM_DWORD               dwStartCount;   /* How many counts were given originally. */
    DRM_DWORD               dwCount;        /* How many counts are left.              */
    DRM_DWORD               dwHours;        /* How many days are left. For expiration after first use licenses that are never used so far. */
    DRMFILETIME             begDate;        /* License valid only after this date.    */
    DRMFILETIME             endDate;        /* License not valid after this date.     */
    DRM_BOOL                fHasOPLs;       /* True if OPLs were seen in the license  */
    DRM_BOOL                fRequiresSAP;   /* True if the license requires SAP       */
    DRM_BOOL                fHasMUExtensibleRestrictions; /* True if the license has extensible restrictions that are marked as "must understand" */
} LicenseInfo;


typedef DRM_DWORD DRM_LICQUERY_RESULT_BITS;
#define DRM_LICQUERY_NOT_ENABLED                        0x00000001
#define DRM_LICQUERY_NOT_ENABLED_NO_LICENSE             0x00000002
#define DRM_LICQUERY_NOT_ENABLED_NO_RIGHT               0x00000004
#define DRM_LICQUERY_NOT_ENABLED_EXHAUSTED              0x00000008
#define DRM_LICQUERY_NOT_ENABLED_EXPIRED                0x00000010
#define DRM_LICQUERY_NOT_ENABLED_NOT_STARTED            0x00000020
#define DRM_LICQUERY_NOT_ENABLED_APPSEC_TOO_LOW         0x00000040
#define DRM_LICQUERY_NOT_ENABLED_REQ_INDIV              0x00000080
#define DRM_LICQUERY_NOT_ENABLED_COPY_OPL_TOO_LOW       0x00000100
#define DRM_LICQUERY_NOT_ENABLED_COPY_OPL_EXCLUDED      0x00000200
#define DRM_LICQUERY_NOT_ENABLED_NO_CLOCK_SUPPORT       0x00000400
#define DRM_LICQUERY_NOT_ENABLED_NO_METERING_SUPPORT    0x00000800
#define DRM_LICQUERY_NOT_ENABLED_CHAIN_DEPTH_TOO_HIGH   0x00001000
#define DRM_LICQUERY_NOT_ENABLED_NO_UPLINK              0x00002000
#define DRM_LICQUERY_SATISFIED                          0x10000000

typedef struct _DRM_CANDO_QUERY_CACHE
{
    DRM_LID   cachedLID;
    DRM_KID   parentKID;
    DRM_DWORD dwResult[DRM_MAX_RIGHTS_SUPPORTED];
    DRM_DWORD dwUplinkVector;
    LicenseInfo licInfo[DRM_MAX_RIGHTS_SUPPORTED];
} DRM_CANDO_QUERY_CACHE;


typedef struct __tagDRM_STATE_DATA_STACK
{
    DRM_LICENSE_STATE_DATA    rgStatePri[DRM_MAX_RIGHTS_SUPPORTED]; /* Caller shouldn't touch these */
    DRM_KID                   rgkidRoot  [DRM_MAX_CHAIN_ROOTVARIANCE_SUPPORT];
    DRM_LICENSE_STATE_DATA    rgRootState[DRM_MAX_CHAIN_ROOTVARIANCE_SUPPORT][DRM_MAX_RIGHTS_SUPPORTED]; /* Caller shouldn't touch these */
    DRM_LICENSE_STATE_DATA    rgLeafState[DRM_MAX_CHAIN_ROOTVARIANCE_SUPPORT][DRM_MAX_RIGHTS_SUPPORTED]; /* Caller shouldn't touch these */
} DRM_STATE_DATA_STACK;


typedef struct __tagDRM_VIEW_RIGHTS_CONTEXT
{
/*PUBLIC */
    DRM_KID                      KID;              /* Pointer to a DRM_KID_LENGTH byte buffer with the KID we are looking for */
    DRM_BB_CONTEXT              *pBBContext;       /* Pointer to a Blackbox context structure */
    DRM_SECSTORE_CONTEXT        *pbGlobalSecStore; /* Pointer to a secure store opened to the global key */
    DRM_SECSTORE_CONTEXT        *pbLIDSecStore;    /* Pointer to open secure store -- not opened to a specific key yet. */
    DRM_LICSTORE_CONTEXT        *pbLicenseStoreXML;/* Pointer to an open license store context */
    DRM_LICSTORE_CONTEXT        *pbLicenseStoreXMR;/* Pointer to an open license store context */
    DRM_LICSTOREENUM_CONTEXT    *rgpLicQueryContext[DRM_MAX_LICENSE_CHAIN_DEPTH]; /* Pointer to memory for a DRM_LICSTOREENUM_CONTEXT.  Should not be intialized!!!  Just need the memory */
    DRM_LICEVAL_CONTEXT         *pLicEval;         /* Pointer to a liceval context */
    DRM_BYTE                    *pbBuffer;         /* User gives a sandbox buffer to work in */
    DRM_DWORD                    cbBuffer;         /* Size of sandbox buffer.  If it is too small we will fail.  Don't know how big because licenses can be variable length */

    DRM_DEVICE_CERTIFICATE_CACHED_VALUES  cacheDevCert;
    DRM_BOOL                     fIsWMDRMPDDevice;
    DRM_DWORD                    dwDeviceCopyOPL;
    DRM_GUID                     deviceGUID;
    DRM_LONG                     lDeviceAppSec;
    DRM_BOOL                     fDeviceSupportMetering;
    DRM_BOOL                     fDeviceSupportClock;
    DRM_BOOL                     fDeviceHasSerialNum;
    DRM_BOOL                     fPCSupportMetering;
    DRM_DWORD                    dwLicChainDepth;
#if DRM_SUPPORT_COPY_OPL
    COPY_OPL_CHAIN               copyOPL;
#endif

/* private */
    DRM_STACK_ALLOCATOR_CONTEXT  stack;                 /* local stack allocator */
    DRM_BYTE                    *pbCurrentLicenseBuff;  /* pointer to XML lic buffer allocated from local stack */
    DRM_BOOL                     fCurrentLicenseIsXML;  /* TRUE if current lic is XML */
    DRM_LICSTORE_CONTEXT        *pActiveLicStore;       /* set at run time:  pbLicenseStoreXML or pbLicenseStoreXMR */
    DRM_XMR_LICENSE              licXMR;                /* XMR license structure */
    DRM_DWORD                    iCurrSlot;
    DRM_DWORD                    cCacheSlots;
    DRM_CANDO_QUERY_CACHE       *rgCacheSlots;
    DRM_STATE_DATA_STACK         rgStack[DRM_MAX_LICENSE_CHAIN_DEPTH];
    LicenseInfo                  rgLicInfo[DRM_MAX_RIGHTS_SUPPORTED]; /* Caller shouldn't touch these */
} DRM_VIEW_RIGHTS_CONTEXT;


#define DRM_ASD_AGGREGATE_ROOT_LICENSES            0
#define DRM_ASD_AGGREGATE_SIMPLE_AND_LEAF_LICENSES 1

DRM_API DRM_RESULT DRM_CALL DRM_ASD_GetLicenseAggregateData(
    IN const DRM_CONST_STRING*  const f_rgpdstrAction[], /* Array of DRM_CONST_STRING pointers */
       OUT   DRM_LICENSE_STATE_DATA   f_rgStateData[],   /* array of DRM_LICENSE_STATE_DATAs */
    IN       DRM_DWORD                f_cActionsQueried,
    IN OUT   DRM_VIEW_RIGHTS_CONTEXT *f_pcontextLQ,
    IN OUT   DRM_DST                 *f_pDatastore,
    IN       DRM_BOOL                 f_fDeleteExpiredLicenses,
    IN       DRM_DWORD                f_dwAggregationType,
    IN       DRMPFNPOLICYCALLBACK     f_pfnPolicyCallback,
    IN const DRM_VOID                *f_pv);


DRM_API DRM_RESULT DRM_CALL DRM_ASD_IsAllowed(
    IN const DRM_CONST_STRING        *pdstrAction,
    IN       DRM_VIEW_RIGHTS_CONTEXT *pContext,
    IN       DRM_DST                 *f_pDatastore );

DRM_API DRM_RESULT DRM_CALL DRM_ASD_ParseV2License(
    IN const DRM_CONST_STRING *f_pdstrLicense, 
    IN const DRM_CONST_STRING *f_pdstrAttrName,
       OUT   DRM_DWORD        *f_pdwValue, 
       OUT   DRMFILETIME      *f_pfiletime);


DRM_API DRM_RESULT DRM_CALL DRM_ASD_InitCanDoQuery(
    IN       DRM_CRYPTO_CONTEXT       *f_pDrmCrypto,
    IN       DRM_LICSTORE_CONTEXT     *f_pbLicenseStoreXML,
    IN       DRM_LICSTORE_CONTEXT     *f_pbLicenseStoreXMR,
    IN       DRM_LICSTOREENUM_CONTEXT *f_rgpLicQueryContext[DRM_MAX_LICENSE_CHAIN_DEPTH],
    IN       DRM_LICEVAL_CONTEXT      *f_pLicEval,
    IN       DRM_BYTE                 *f_pbBuffer,
    IN       DRM_DWORD                 f_cbBuffer,
    IN       DRM_LONG                  f_lDeviceAppSec,
    IN       DRM_BOOL                  f_fDeviceHasSerialNum,
    IN       DRM_DWORD                 f_dwDeviceCopyOPL,
    IN const DRM_GUID                 *f_pDeviceGUID,
    IN const DRM_CONST_STRING         *f_pdstrDevCert,
    IN       DRM_DWORD                 f_cCacheSlots,     /* must be >= 1 */
    IN       DRM_CANDO_QUERY_CACHE    *f_pCacheSlots,
       OUT   DRM_VIEW_RIGHTS_CONTEXT  *f_pLicQueryCtx);


DRM_API DRM_RESULT DRM_CALL DRM_ASD_CandoQuery(
    IN       DRM_KID                 *f_pKID,
    IN       DRM_DWORD                f_cActionsQueried,
    IN const DRM_CONST_STRING        *f_rgpdstrAction[],
    IN OUT   DRM_VIEW_RIGHTS_CONTEXT *f_pcontextLQ,
    IN OUT   DRM_DST                 *f_pDatastore,
    IN       DRM_BOOL                 f_fDeleteExpiredLicenses,
       OUT   DRM_DWORD                f_rgResults[]); 

EXIT_PK_NAMESPACE;

#endif /* __DRM_VIEWPROPERTIES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmxmlbuilder.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMXMLBUILDER_H__
#define __DRMXMLBUILDER_H__


#include <drmcommon.h>
#include <drmresults.h>
#include <drmtypes.h>
#include <drmlicense.h>
#include <drmhmac.h>

ENTER_PK_NAMESPACE;

#define CB_XMB_EXTRA              100
#define CCH_CDATA_EXTRA           12
#define CCH_CDATA_REQUIRED(pdstr) ((pdstr)->cchString+CCH_CDATA_EXTRA)


#define DRM_SIMXMLDOC_BUFFSIZE    192
#define DRM_XMB_OVERHEAD          (SIZEOF(_XMBContext) + CB_XMB_EXTRA)
#define SHA_B64ENC_DIGEST_LEN_CALC CCH_BASE64_EQUIV_SAL(DRM_SHA1_DIGEST_LEN)


extern const DRM_DWORD g_cbXMLBuilderMinimum;


typedef struct _tagXMBContext
{
    /*
    ** Usage of buffer:
    ** This context buffer is allocated by user at CreateDocument(). Its size  can be reallocated
    ** via ReallocDocument(). The XML string is built on the way when each of the API calls are
    ** made. The XML string grow from top to bottom. On the way, all opened node's open tag 
    ** position is kept and saved on the buffer from bottom to top. So when wNextStringPos
    ** and wNextOpenNodePos collides, NO_MEM is returned and user should reallocate more
    ** memory to finish the operation. 
    ** Note: The open nodes positions will be saved as DWORDs, so it aligns perfectly with the 
    ** growing XML string within the WCHAR buffer.
    */

    /* !!! Caller is ensuring only 2 byte alignment. Never add any member variable greater than 2 bytes*/
    
    DRM_BOOL fInited;
    DRM_BOOL fIsSimMode;        /* TRUE to create a faked doc to calculate the length needed */
    DRM_DWORD wMaxStackUsed;    /* Max stack space used for nested nodes */
    DRM_DWORD wSize;            /* size of context */
    DRM_DWORD wNextOpenNodePos; 
    DRM_DWORD wNextStringPos;   /* next insertion point */
    DRM_DWORD wBuffSize;        /* size of buffer in WCHARs*/
    DRM_WCHAR XmlString [1];
} _XMBContext;




/* state to be used for save/restore XML context during API calls */
typedef struct _tagXMBState
{
    DRM_DWORD cwchMaxStackUsed;    /* Max stack space used for nested nodes */
    DRM_DWORD iwchNextOpenNodePos; 
    DRM_DWORD iwchNextStringPos;   /* next insertion point */
} XMBState;


/*
*******************************************************************************
** API methods
*******************************************************************************
*/

DRM_API DRM_RESULT DRM_CALL DRM_XMB_SimulateCreateDocument(
    __in    const DRM_DWORD         cbXmlContext,
    __inout       _XMBContext      *pbXmlContext,
    __in    const DRM_CONST_STRING *pdstrRootNodeName);

DRM_API DRM_RESULT DRM_CALL DRM_XMB_CreateDocument(
    __in    const DRM_DWORD         cbXmlContext,
    __inout       _XMBContext      *pbXmlContext,
    __in    const DRM_CONST_STRING *pdstrRootNodeName);

DRM_API DRM_RESULT DRM_CALL DRM_XMB_ReallocDocument(
    __in          _XMBContext *pbOldXmlContext,
    __in    const DRM_DWORD    cbNewXmlContext,
    __inout       _XMBContext *pbNewXmlContext );
 
/**********************************************************************
** Function:    DRM_XMB_CloseDocument
** Synopsis:    Pop the opened nodes and close the document, if space allowed.
** Arguments:   
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_XMB_CloseDocument(
    __inout _XMBContext *pbXmlContext,
    __out   DRM_STRING  *pdstrXML);   /* if opened with DRM_XMB_SimulateCreateDocument, this contains the counts of WCHAR's needed for the real string */

DRM_API DRM_RESULT DRM_CALL DRM_XMB_OpenNode(
    __inout       _XMBContext      *pbXmlContext,
    __in    const DRM_CONST_STRING *pdstrNodeName);

DRM_API DRM_RESULT DRM_CALL DRM_XMB_SaveState(
    __inout _XMBContext *pbXmlContext,
    __out   XMBState    *pState);

DRM_API DRM_RESULT DRM_CALL DRM_XMB_RestoreState(
    __inout _XMBContext *pbXmlContext,
    __in    XMBState    *pState);


/**********************************************************************
** Function:    DRM_XMB_CloseCurrNode
** Synopsis:    
** Arguments:   [pbXmlContext] -- 
**              [pdstrXMLFragment] -- XML fragment of the current node, optional.
** Returns:     DRM_SUCCESS on success
** Notes:       
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_XMB_CloseCurrNode(
    __inout   _XMBContext *pbXmlContext,
    __out_opt DRM_STRING  *pdstrXMLFragment);    /* optional: XML fragment of the current node, optional. */

/**********************************************************************
** Function:    DRM_XMB_EncryptAndCloseCurrNode
** Synopsis:    Encrypt and Base64 encode the node (not including the tag)
** Arguments:   [pXmlContext] -- 
**              [pdstrXMLFragment] -- XML fragment of the current node, optional.
** Returns:     DRM_SUCCESS on success
** Notes:       encryption does not include the tag
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_XMB_EncryptAndCloseCurrNode(
    __inout         _XMBContext        *pXmlContext,
    __in            DRM_CRYPTO_CONTEXT *pCryptoContext,    /* Pointer to DRM_CRYPTO_CONTEXT */
    __in_opt        DRM_VOID           *pOEMContext,
    __in      const PUBKEY             *pPubkey,           /* pub key to use for encrypt */
    __out_opt       DRM_STRING         *pdstrXMLFragment); /* optional: XML fragment of the current node, optional. */

/**********************************************************************
** Function:    DRM_XMB_SignAndCloseCurrNode
** Synopsis:    Encrypt and Base64 encode the node (not including the tag)
** Arguments:   [pbXmlContext] -- 
**              [pdstrXMLFragment] -- XML fragment of the current node, optional.
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_XMB_SignAndCloseCurrNode(
    __inout                                       _XMBContext        *pbXmlContext,
    __in                                          DRM_CRYPTO_CONTEXT *pCryptoContext,  /* Pointer to DRM_CRYPTO_CONTEXT */
    __in    const                                 PRIVKEY            *pPrivkey,        /* pub key to use for encrypt */
    __in                                          DRM_BOOL            fIncludeTag,
    __out_bcount_opt(DRM_ECC160_SIGNATURE_LEN)    DRM_BYTE            rgbSign   [__CB_DECL(DRM_ECC160_SIGNATURE_LEN)], /* cannot be both NULL */
    __out_ecount_opt(DRM_ECC160_SIGNATURE_B64LEN) DRM_WCHAR           wszB64Sign[DRM_ECC160_SIGNATURE_B64LEN], /* cannot be both NULL */
    __out_opt                                     DRM_STRING         *pdstrXMLFragment);  /* optional: XML fragment of the current node, optional. */

DRM_API DRM_RESULT DRM_CALL DRM_XMB_KeyedHashAndCloseCurrNode(
    __inout                                      _XMBContext        *pbXmlContext,
    __in                                         DRM_HMAC_CONTEXT   *pHmacContext,     /* HMAC context */
    __in_bcount(cbHashkey) const                 DRM_BYTE           *pbHashkey,        /* Hash key for HMAC */
    __in                                         DRM_DWORD           cbHashkey,        /* byte count of HMAC */
    __in                                         DRM_BOOL            fIncludeTag,
    __out_bcount_opt(DRM_SHA1_DIGEST_LEN)        DRM_BYTE            rgbSign   [__CB_DECL(DRM_SHA1_DIGEST_LEN)],       /* cannot be both NULL */
    __out_ecount_opt(SHA_B64ENC_DIGEST_LEN_CALC) DRM_WCHAR           wszB64Sign[DRM_SHA1_B64ENC_DIGEST_LEN], /* cannot be both NULL */
    __out_opt                                    DRM_STRING         *pdstrXMLFragment);  /* optional: XML fragment of the current node, optional. */


DRM_API DRM_RESULT DRM_CALL DRM_XMB_GetCurrNodeName(
    __in  _XMBContext *pbXmlContext,
    __out DRM_STRING  *pdstrNodeName);

DRM_API DRM_RESULT DRM_CALL DRM_XMB_GetContextSize(
    __in  _XMBContext *pbXmlContext,
    __out DRM_DWORD   *pcbXmlContext);

DRM_API DRM_RESULT DRM_CALL DRM_XMB_AddAttribute(
    __inout       _XMBContext      *pXmlContext,
    __in    const DRM_CONST_STRING *pdstrAttrName,
    __in    const DRM_CONST_STRING *pdstrAttrValue );

DRM_API DRM_RESULT DRM_CALL DRM_XMB_AddData(
    __inout       _XMBContext      *pXmlContext,
    __in    const DRM_CONST_STRING *pdstrData );
 
DRM_API DRM_RESULT DRM_CALL DRM_XMB_ReserveSpace(
    __inout                 _XMBContext *f_poXMBContext,
    __in                    DRM_DWORD    f_cchData,
    __out_ecount(f_cchData) DRM_WCHAR  **f_ppwchData );

DRM_API DRM_RESULT DRM_CALL DRM_XMB_AddCData(
    __inout       _XMBContext      *pXmlContext,
    __in    const DRM_CONST_STRING *pdstrCData );

/**********************************************************************
** Function:    DRM_XMB_AppendNode
** Synopsis:    Appends a caller provided node nested from current opened node
** Arguments:   [pdwStamp] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       The caller is responsible for the validity of the appending node
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_XMB_AppendNode(
    __inout       _XMBContext      *pXmlContext,
    __in    const DRM_CONST_STRING *pdstrXmlString);

/**********************************************************************
** Function:    DRM_XMB_AddXMLNode
** Synopsis:    Appends a caller provided node nested from current opened node
** Arguments:   [dstrName]  -- Name for node tag
**              [dstrValue] -- Context of the node for node tag
** Returns:     DRM_SUCCESS on success
** Notes:       The caller is responsible for the validity of the appending node
***********************************************************************/


DRM_API DRM_RESULT DRM_CALL DRM_XMB_AddXMLNode  
(  
    __inout       _XMBContext        *pbXMLContext, 
    __in    const DRM_CONST_STRING   *dstrName, 
    __in    const DRM_CONST_STRING   *dstrValue 
);

/*******************************************************************
 *          PUBLIC FUNCTION DRM_XMB_RequiredCharsForTag
 *
 * purpose: calculates the number of XML characters required for
 *          the indicated tag, optional text, and optional 
 *          attribute label and text.
 ******************************************************************/

DRM_API DRM_DWORD DRM_CALL DRM_XMB_RequiredCharsForTag (
    __in const DRM_DWORD cchTag,
    __in const DRM_DWORD cchData,
    __in const DRM_DWORD cchAttrLabel,
    __in const DRM_DWORD cchAttrText);

/*******************************************************************
 *          PUBLIC FUNCTION DRM_XMB_RequiredCharsForTagNoClose
 *
 * purpose: calculates the number of XML characters required for
 *          the indicated tag, optional text, and optional 
 *          attribute label and text, without considering the closing
 *          tag.
 ******************************************************************/
DRM_API DRM_DWORD DRM_CALL DRM_XMB_RequiredCharsForTagNoClose (
    __in const DRM_DWORD cchTag,
    __in const DRM_DWORD cchData,
    __in const DRM_DWORD cchAttrLabel,
    __in const DRM_DWORD cchAttrText);

/*******************************************************************
 *          PUBLIC FUNCTION DRM_XMB_RequiredCharsForAttribute
 *
 * purpose: calculates the number of XML characters required for
 *          the an optional attribute label and text.
 ******************************************************************/
DRM_API DRM_DWORD DRM_CALL DRM_XMB_RequiredCharsForAttribute (
    __in const DRM_DWORD cchAttrLabel,
    __in const DRM_DWORD cchAttrText);

enum WriteTagType
{
    wttOpen,
    wttClosed
};

/*********************************************************************
 *                 PUBLIC FUNCTION DRM_XMB_WriteTag
 *                                                                   
 *      function: write one or both tags of an XML pair              
 *                  and optionally the enclosed data and/or
 *                  a single attribute
 *
 *      if parameter wtt is wttClosed, the tag is closed and the
 *      XML builder insertion point remains at the same scope as
 *      when the function was called
 *
 *        <TAG[ attrlabel="attrtext"]>[data][</TAG>]
 *
 ********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_XMB_WriteTag (
    __inout        _XMBContext      *pbDataOut,
    __in     const DRM_CONST_STRING *pdstrTag,
    __in_opt const DRM_CONST_STRING *pdstrData,
    __in_opt const DRM_CONST_STRING *pdstrAttrLabel,
    __in_opt const DRM_CONST_STRING *pdstrAttrText,
    __in     enum  WriteTagType      wtt);

/*********************************************************************
 *             PUBLIC FUNCTION DRM_XMB_WriteCDATATag
 *                                                                   
 * as above but writes a CDATA tag
 ********************************************************************/

DRM_API DRM_RESULT DRM_CALL DRM_XMB_WriteCDATATag (
    __inout        _XMBContext      *pbDataOut,
    __in     const DRM_CONST_STRING *pdstrTag,
    __in_opt const DRM_CONST_STRING *pdstrCDATA,
    __in_opt const DRM_CONST_STRING *pdstrAttrLabel,
    __in_opt const DRM_CONST_STRING *pdstrAttrText,
    __in     enum  WriteTagType      wtt);

DRM_API DRM_RESULT DRM_CALL DRM_XMB_RemainingBuffer(
    __in  _XMBContext *f_pbXMB,
    __out DRM_DWORD   *f_pcbRemaining);

EXIT_PK_NAMESPACE;

#endif      /* __XMLBUILDER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmxmlbuildera.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMXMLBUILDERA_H__
#define __DRMXMLBUILDERA_H__

#include <drmresults.h>
#include <drmtypes.h>
#include <oemaes.h>
#if DRM_SUPPORT_WMDRMNET
#include <oemrsa.h>
#endif /* DRM_SUPPORT_WMDRMNET */

ENTER_PK_NAMESPACE;

#define CB_XMB_EXTRA_A                      100
#define CCH_CDATA_EXTRA_A                   12
#define CCH_CDATA_REQUIRED_A( f_pdastr )    ( ( f_pdastr )->cchString + CCH_CDATA_EXTRA_A )

#define DRM_XMB_OVERHEAD_A                  ( SIZEOF ( _XMBContextA ) + CB_XMB_EXTRA_A )

#define DRM_XMB_RequiredCharsForTagA        DRM_XMB_RequiredCharsForTag

#define DRM_XMB_RequiredCharsForTagNoCloseA DRM_XMB_RequiredCharsForTagNoClose

#define DRM_XMB_RequiredCharsForAttributeA DRM_XMB_RequiredCharsForAttribute

extern const DRM_EXPORT_VAR DRM_DWORD g_cbXMLBuilderMinimumA;

/* XML builder context. */
typedef struct _tagXMBContextA
{
    /*
    ** Usage of buffer:
    **
    ** This context buffer is allocated by user at DRM_XMB_CreateDocumentA().
    ** The XML string is built on the way when each of the API calls are made.
    **
    ** The XML output string being generated grows from lower address to higher address. The end
    ** of the XML output string is indicated by ichNextString. All opened nodes' location at the
    ** buffer and the length of the tag name string are saved on a stack that grows from from higher
    ** address to lower address. The top of the stack is indicated by ichNextOpenNode.
    **
    ** When ichNextString and ichNextOpenNode collides, there is not enough memory available.
    */

    /* !!! Caller is ensuring only 2 byte alignment. Never add any member variable greater than 2 bytes. */
    
    /* Flag indicating whether the XML builder context has been initialized. */
    DRM_BOOL fInited;
    
    /* Max stack space used for nested nodes */
    DRM_DWORD cbMaxStackUsed;
    
    /* Size (number of bytes) of the XML builder context. */
    DRM_DWORD cbContext;
    
    /* The current pointer to the top of the stack to keep the open nodes. */
    DRM_DWORD ichNextOpenNode; 
    
    /* The current pointer to the output buffer for the XML output. */
    DRM_DWORD ichNextString;
    
    /* Size (number of CHARs) of internal buffer. */
    DRM_DWORD cchBuffer;

    /* The internal buffer. */
    DRM_CHAR  rgchXML [1];
} _XMBContextA;


/*
*******************************************************************************
** API methods
*******************************************************************************
*/
DRM_API DRM_RESULT DRM_CALL DRM_XMB_CreateDocumentA(
    __in                      const DRM_DWORD              f_cbXMBContextA,
    __inout_bcount(f_cbXMBContextA) DRM_BYTE              *f_pbXMBContextA,
    __in                      const DRM_ANSI_CONST_STRING *f_pdastrRootNode );

DRM_API DRM_RESULT DRM_CALL DRM_XMB_CloseDocumentA(
    __inout _XMBContextA  *f_poXMBContextA,
    __out   DRM_SUBSTRING *f_pdasstrXML );

DRM_API DRM_RESULT DRM_CALL DRM_XMB_OpenNodeA(
    __inout       _XMBContextA          *f_poXMBContextA,
    __in    const DRM_ANSI_CONST_STRING *f_pdastrNodeName );

DRM_API DRM_RESULT DRM_CALL DRM_XMB_CloseCurrNodeA(
    __inout   _XMBContextA  *f_pbXMBContextA,
    __out_opt DRM_SUBSTRING *f_pdasstrXMLFragment );

DRM_RESULT DRM_CALL DRM_XMB_AESEncryptAndCloseCurrNodeA(
    __inout _XMBContextA  *f_pbContextXMLA,
    __in    DRM_AES_KEY   *f_pkeyAES,
    __in    DRM_DWORD      f_dwNonce,
    __out   DRM_SUBSTRING *f_pdasstrXMLFragment );

#if DRM_SUPPORT_WMDRMNET

DRM_RESULT DRM_CALL DRM_XMB_RSASignAndCloseCurrNodeA(
    __inout         _XMBContextA        *f_pbContextXMLA,
    __in      const DRM_RSA_PRIVATE_KEY *f_pprivkeyRSA,
    __in            DRM_BOOL             f_fIncludeTag,
    __out           DRM_DWORD           *f_pcbSignature,
    __out_bcount    (*f_pcbSignature)  DRM_BYTE *f_pbSignature,    
    __out_ecount_opt(*f_pcchSignature) DRM_CHAR *f_pszSignature, 
    __inout         DRM_DWORD           *f_pcchSignature,
    __out_opt       DRM_SUBSTRING       *f_pdasstrXMLFragment,
    __in            DRM_CRYPTO_CONTEXT  *f_pCryptCtx);

DRM_RESULT DRM_CALL DRM_XMB_HashAndRSASignAndCloseCurrNodeA(
    __inout         _XMBContextA           *f_pbContextXMLA,
    __in            DRM_SHA1_CONTEXT       *f_pcontextSHA,
    __in      const DRM_RSA_PRIVATE_KEY    *f_pprivkeyRSA,
    __in            DRM_BOOL                f_fIncludeTag,
    __out_bcount(DRM_SHA1_DIGEST_LEN) DRM_BYTE f_rgbSHA  [__CB_DECL(DRM_SHA1_DIGEST_LEN)],
    __out_ecount(CCH_BASE64_EQUIV_SAL( DRM_SHA1_DIGEST_LEN )) DRM_CHAR f_rgchSHA [__CB_DECL(DRM_SHA1_B64ENC_DIGEST_LEN)],
    __out           DRM_DWORD              *f_pcbSignature,
    __out_bcount(*f_pcbSignature) DRM_BYTE *f_pbSignature,
    __out           DRM_DWORD              *f_pcchSignature,
    __out_ecount(CCH_BASE64_EQUIV_SAL(DRM_RSA_CB_PRIME_MAX)) DRM_CHAR f_rgchSignature [__CB_DECL(CCH_BASE64_EQUIV(DRM_RSA_CB_PRIME_MAX))],
    __out_opt       DRM_SUBSTRING          *f_pdasstrXMLFragment,
    __in            DRM_CRYPTO_CONTEXT     *f_pCryptCtx);

#endif /* DRM_SUPPORT_WMDRMNET */

DRM_RESULT DRM_CALL DRM_XMB_HashAndCloseCurrNodeA(
    __inout   _XMBContextA      *f_pbContextXMLA,
    __in      DRM_SHA1_CONTEXT  *f_pcontextSHA,
    __in      DRM_BOOL           f_fIncludeTag,
    __out_bcount(DRM_SHA1_DIGEST_LEN) DRM_BYTE f_rgbSHA [__CB_DECL(DRM_SHA1_DIGEST_LEN)],
    __out_ecount(CCH_BASE64_EQUIV_SAL( DRM_SHA1_DIGEST_LEN )) DRM_CHAR f_rgchSHA[__CB_DECL(DRM_SHA1_B64ENC_DIGEST_LEN)], 
    __out_opt DRM_SUBSTRING     *f_pdasstrXMLFragment);

DRM_API DRM_RESULT DRM_CALL DRM_XMB_AddAttributeA(
    __inout       _XMBContextA          *f_poXMBContextA,
    __in    const DRM_ANSI_CONST_STRING *f_pdastrAttrLabel,
    __in    const DRM_ANSI_CONST_STRING *f_pdastrAttrValue );

DRM_API DRM_RESULT DRM_CALL DRM_XMB_AddDataA(
    __inout       _XMBContextA          *f_poXMBContextA,
    __in    const DRM_ANSI_CONST_STRING *f_pdastrData );
 
DRM_API DRM_RESULT DRM_CALL DRM_XMB_WriteTagA(
    __inout        _XMBContextA *f_poXMBContextA,
    __in     const DRM_ANSI_CONST_STRING *f_pdastrTag,
    __in_opt const DRM_ANSI_CONST_STRING *f_pdastrData,
    __in_opt const DRM_ANSI_CONST_STRING *f_pdastrAttrLabel,
    __in_opt const DRM_ANSI_CONST_STRING *f_pdastrAttrValue,
    __in     enum  WriteTagType f_wtt );

DRM_API DRM_RESULT DRM_CALL DRM_XMB_GetXMLBaseA(
    __inout _XMBContextA *f_poXMBContextA,
    __out   DRM_CHAR    **f_ppchBase );

DRM_API DRM_RESULT DRM_CALL DRM_XMB_AddCDataA(
    __inout       _XMBContextA          *f_poXMBContextA,
    __in    const DRM_ANSI_CONST_STRING *f_pdastrCData );

DRM_API DRM_RESULT DRM_CALL DRM_XMB_WriteCDATATagA(
    __inout       _XMBContextA *f_poXMBContextA,
    __in    const DRM_ANSI_CONST_STRING *f_pdastrTag,
    __in    const DRM_ANSI_CONST_STRING *f_pdastrCData,
    __in    const DRM_ANSI_CONST_STRING *f_pdastrAttrLabel,
    __in    const DRM_ANSI_CONST_STRING *f_pdastrAttrValue,
    __in    enum  WriteTagType f_wtt );

DRM_API DRM_RESULT DRM_CALL DRM_XMB_ReserveSpaceA(
    __inout       _XMBContextA  *f_poXMBContextA,
    __in          DRM_DWORD      f_cchAlignment,
    __in    const DRM_DWORD      f_cchData,
    __out         DRM_SUBSTRING *f_pdasstrData );

DRM_API DRM_RESULT DRM_CALL DRM_XMB_ShiftDataFromCurrentPositionA(
    __inout       _XMBContextA *f_poXMBContextA,
    __in    const DRM_DWORD     f_cchShift,
    __in    const DRM_DWORD     f_cchData );

DRM_API DRM_RESULT DRM_CALL DRM_XMB_ShiftCurrentPointerA(
    __inout       _XMBContextA *f_poXMBContextA,
    __in    const DRM_DWORD     f_cchShift );

DRM_API DRM_RESULT DRM_CALL DRM_XMB_GetCurrentBufferPointerA(
    __inout _XMBContextA *f_poXMBContextA,
    __in    DRM_BOOL      f_fAligned,
    __out   DRM_CHAR    **f_ppchBufferPointer );

DRM_API DRM_RESULT DRM_CALL DRM_XMB_AppendNodeA(
    __inout       _XMBContextA          *f_poXMBContextA,
    __in    const DRM_ANSI_CONST_STRING *f_pdastrXmlString );

EXIT_PK_NAMESPACE;

#endif /* __DRMXMLBUILDERA_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmxmlsig.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_XML_SIG_H
#define __DRM_XML_SIG_H

#include <drmxmlbuildera.h>

ENTER_PK_NAMESPACE;

/*
** An AES key combo. The first 16 bytes forms an 128 bits initialization vector.
** The second 16 bytes forms a random 128 bits AES key.
*/
#define DRM_XML_AES_KEY_SIZE  ( DRM_AES_KEYSIZE_128 * 2 )

/*
***************************************************************************
**                        XML Key info
***************************************************************************
*/

/*
** The enumeration define type of RSA public key to be used.
*/
typedef enum
{
    /*
    ** Invalid Key info: not initialized or not consistent
    */
    DRM_XML_KEYINFO_INVALID,

    /*
    ** Key info that contains a public key only
    */
    DRM_XML_KEYINFO_SIMPLE,

    /*
    ** Key info that contains symmetric key
    ** encrypted with a public key;
    ** XML presentation will have <EncryptedKey> tag
    */
    DRM_XML_KEYINFO_ENCRYPTED

} DRM_XML_KEYINFO_TYPE;

/*
** The enumeration define type of RSA public key to be used.
*/
typedef enum
{
    /* Invalid key.  */
    DRM_XML_ECC256_INVALID_KEY,

    /*
    ** Full ECC-256 public key.
    */
    DRM_XML_ECC256_PUBLIC_KEY_DATA,

    /*
    ** ID of a pre-shared ECC-256 Public key:
    ** It means the ECC-256 public key in the <KeyInfo> segment
    ** only contains a key ID. Parties that see the key ID
    ** should understand the actual ECC-256 public key represented
    ** by the key ID.
    */
    DRM_XML_ECC256_SERVER_PUBLIC_KEY_ID,

    DRM_XML_ECC256_CLIENT_PUBLIC_KEY_ID,

    DRM_XML_ECC256_METERING_PUBLIC_KEY_ID
} DRM_XML_ECC256_KEY_FORMAT;

/*
** Union used to store either a clear or an ECC-256 encrypted AES key.
** Assumes the size of the ciphered version is equal or bigger
** than the size clear version. In other words, the size of
** the ciphered version determines the size of the union.
*/
typedef union
{
    /* A clear AES key combo. */
    DRM_BYTE m_rgbClearAESKey[ __CB_DECL( DRM_XML_AES_KEY_SIZE ) ];

    /* An ECC-256 encrypted AES key BLOB */
    DRM_BYTE m_rgbCipherAESKey[ __CB_DECL( ECC_P256_CIPHERTEXT_SIZE_IN_BYTES ) ];
} _AES_KEY;

/*
** Structure to contain information of a key in the <KeyInfo> XML segment.
*/
typedef struct
{
    /*
    ** KeyInfo type, can be simple or complex
    ** i.e. with another key encrypted inside
    */
    DRM_XML_KEYINFO_TYPE m_eKeyInfoType;

    /* AES key */
    _AES_KEY m_oAESKey;

    /*
    ** The format of the ECC-256 public key that is used to encrypt the AES key.
    ** If the values is DRM_XML_ECC256_PUBLIC_KEY_ID, a pre-shared ECC-256 public key
    ** will be used to decrypte the AES key.
    ** If the valus is DRM_XML_ECC-256_PUBLIC_KEY_DATA, a full ECC-256 public key
    ** stored in m_oECC256PubKey will be used to decrypt the AES key.
    */
    DRM_XML_ECC256_KEY_FORMAT m_eKeyFormat;

    /*
    ** If m_eKeyFormat is DRM_XML_ECC256_PUBLIC_KEY_DATA, m_oECC256PubKey
    ** contains a full ECC-256 public key used to decrypt the AES key, otherwise
    ** this field is not used.
    */
    PUBKEY_P256 m_oECC256PubKey;
} DRM_XML_KEY;

#define EMPTY_XML_KEY { DRM_XML_KEYINFO_INVALID, { 0 }, DRM_XML_ECC256_INVALID_KEY, { 0 } }


/*
***************************************************************************
**                        KeyInfo
***************************************************************************
*/
DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_GetSimpleECC256KeyInfoNodeCharCount(
    __in  const DRM_XML_ECC256_KEY_FORMAT f_eECC256KeyFormat,
    __out       DRM_DWORD                *f_pcchSize );

DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_BuildSimpleECC256KeyInfoNode(
    __inout       _XMBContextA             *f_poXMLContextA,
    __in    const PUBKEY_P256              *f_poECC256PubKey,
    __in    const DRM_XML_ECC256_KEY_FORMAT f_eECC256KeyFormat );

DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_ExtractSimpleECC256Key(
    __in_ecount( f_pdasstrXML->m_ich + f_pdasstrXML->m_cch ) const DRM_CHAR      *f_pszBase,
    __in                                                     const DRM_SUBSTRING *f_pdasstrXML,
    __out                                                          PUBKEY_P256   *f_poECC256PubKey );

DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_GetEncryptedKeyInfoNodeCharCount(
    __in    const DRM_XML_KEY *f_poXMLKey,
    __inout       DRM_DWORD   *f_pcchSize );

DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_BuildEncryptedKeyInfoNode(
    __inout       _XMBContextA *f_poXMLContextA,
    __in    const DRM_XML_KEY  *f_poXMLKey );

DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_ExtractEncryptedKey(
    __in                                                        const DRM_BB_CONTEXT *f_poBBXContext,
    __inout_ecount( f_pdasstrXML->m_ich + f_pdasstrXML->m_cch )       DRM_CHAR       *f_pszBase,
    __inout                                                           DRM_SUBSTRING  *f_pdasstrXML,
    __deref_out_bcount( *f_pcbKey )                                   DRM_BYTE      **f_ppbKey,
    __out                                                             DRM_DWORD      *f_pcbKey,
    __out                                                             DRM_SUBSTRING  *f_pdasstrKey,
    __out                                                             PUBKEY_P256    *f_poECC256PubKey );

/*
***************************************************************************
**                        XML Signature
***************************************************************************
*/
DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_GetSignatureNodeCharCount(
    __inout DRM_DWORD *f_pcchSize );

DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_BuildSignatureNode(
    __inout       _XMBContextA   *f_poXMLContextA,
    __inout       DRM_BB_CONTEXT *f_poBBXContext,
    __in_ecount( f_pdasstrData->m_ich + f_pdasstrData->m_cch )
            const DRM_CHAR       *f_pszBase,
    __in    const DRM_SUBSTRING  *f_pdasstrData );

DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_VerifySignature(
    __in_ecount( f_pdasstrData->m_ich + f_pdasstrData->m_cch )
            const DRM_CHAR       *f_pszDataBase,
    __in    const DRM_SUBSTRING  *f_pdasstrData,
    __in_ecount( f_pdasstrSignature->m_ich + f_pdasstrSignature->m_cch )
            const DRM_CHAR       *f_pszSignatureBase,
    __in    const DRM_SUBSTRING  *f_pdasstrSignature,
    __in    const PUBKEY_P256    *f_poECC256PubKey,
    __inout       DRM_BB_CONTEXT *f_pBBXCtx );

/*
***************************************************************************
**                        XML Encryption
***************************************************************************
*/
DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_GetEncryptedDataNodeCharCount(
    __in    const DRM_XML_KEY *f_poXMLKey,
    __in    const DRM_DWORD    f_cbData,
    __out         DRM_DWORD   *f_pcchSize );

DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_BuildEncryptedDataNode(
    __inout       _XMBContextA  *f_poXMLContextA,
    __in    const DRM_XML_KEY   *f_poXMLKey,
    __in    const DRM_DWORD      f_cbData,
    __out         DRM_SUBSTRING *f_pdasstrEncryptedData );

DRM_API DRM_RESULT DRM_CALL DRM_XMLSIG_ExtractEncryptedData(
    __inout                                DRM_BB_CONTEXT *f_poBBXContext,
    __inout_ecount( f_pdasstrXML->m_ich + f_pdasstrXML->m_cch )
                                           DRM_CHAR       *f_pszBase,
    __in                             const DRM_SUBSTRING  *f_pdasstrXML,
    __deref_out_bcount( *f_pcbData )       DRM_BYTE      **f_ppbData,
    __out                                  DRM_DWORD      *f_pcbData );

EXIT_PK_NAMESPACE;

#endif /* __DRM_XML_SIG_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmxmlutilities.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMXMLUTILS_H__
#define __DRMXMLUTILS_H__

ENTER_PK_NAMESPACE;

DRM_API DRM_RESULT DRM_CALL DRM_XMU_MatchNodeFromTemplate(
    IN  const   DRM_CONST_STRING    *f_pdstrXmlNodeList,
    IN  const   DRM_CONST_STRING    *f_pdstrXmlTemplate,
    IN          DRM_BOOL            f_fAttributeMatch,
        OUT     DRM_BOOL            *f_pfMatch);

EXIT_PK_NAMESPACE;

#endif      /* __DRMXMLUTILS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmxmlparser.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMXMLPARSER_H__
#define __DRMXMLPARSER_H__

#include <drmcommon.h>
#include <drmresults.h>
#include <drmtypes.h>
#include <drmlicense.h>
#include <drmhmac.h>

ENTER_PK_NAMESPACE;

/* 
** UNICODE  
*/

DRM_API DRM_RESULT DRM_CALL DRM_XML_GetNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD        f_iNode,
    OUT DRM_CONST_STRING       *f_pdstrXMLNode,
    OUT DRM_CONST_STRING       *f_pdstrXMLNodeData );

DRM_API DRM_RESULT DRM_CALL DRM_XML_GetAndDecryptNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD        f_iNode,
    IN  DRM_CRYPTO_CONTEXT     *f_pCryptoContext,
    IN  PRIVKEY                *f_pPrivkey,
    OUT DRM_CONST_STRING       *f_pdstrXMLNode,
    OUT DRM_CONST_STRING       *f_pdstrXMLNodeData );

DRM_API DRM_RESULT DRM_CALL DRM_XML_GetAndVerifyNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD        f_iNode,
    IN  DRM_CRYPTO_CONTEXT     *f_pCryptoContext,
    IN  const PUBKEY           *f_pPubkey,
    IN  DRM_BOOL               f_fIncludeTag,
    IN  DRM_CONST_STRING       *f_pdstrB64Signature,
    OUT DRM_CONST_STRING       *f_pdstrXMLNode,
    OUT DRM_CONST_STRING       *f_pdstrXMLNodeData );

#define DRM_XML_HASH_INCLUDE_TAGS   TRUE
#define DRM_XML_HASH_EXCLUDE_TAGS   FALSE

DRM_API DRM_RESULT DRM_CALL DRM_XML_GetAndVerifyKeyedHashNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD        f_iNode,
    IN  DRM_HMAC_CONTEXT       *f_pHmacContext,
    IN  DRM_BYTE               *f_pbHashkey, 
    IN  DRM_DWORD              f_cbHashkey, 
    IN  DRM_BOOL               f_fIncludeTag,
    IN  DRM_CONST_STRING       *f_pdstrB64Signature,
    OUT DRM_CONST_STRING       *f_pdstrXMLNode,
    OUT DRM_CONST_STRING       *f_pdstrXMLNodeData );

DRM_API DRM_RESULT DRM_CALL DRM_XML_GetNodeAttribute(
    IN  const DRM_CONST_STRING *f_pdstrXMLNode,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    OUT DRM_CONST_STRING       *f_pdstrAttrValue );

DRM_API DRM_RESULT DRM_CALL DRM_XML_GetNodeCData(
    IN  const DRM_CONST_STRING *f_pdstrXMLNode,
    OUT DRM_CONST_STRING       *f_pdstrCData );

DRM_API DRM_RESULT DRM_CALL DRM_XML_GetSubNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD        f_iNode,        
    OUT DRM_CONST_STRING       *f_pdstrXMLNode, 
    OUT DRM_CONST_STRING       *f_pdstrXMLNodeData,
    IN  DRM_DWORD              f_iLayer );    

DRM_API DRM_RESULT DRM_CALL DRM_XML_GetAndDecryptSubNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD        f_iNode, 
    IN  DRM_CRYPTO_CONTEXT     *f_pCryptoContext,
    IN  PRIVKEY                *f_pPrivkey,      
    OUT DRM_CONST_STRING       *f_pdstrXMLNode,  
    OUT DRM_CONST_STRING       *f_pdstrXMLNodeData,
    IN  DRM_DWORD              f_iLayer );   

DRM_API DRM_RESULT DRM_CALL DRM_XML_GetAndVerifySubNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD        f_iNode,
    IN  DRM_CRYPTO_CONTEXT     *f_pCryptoContext,  
    IN  const PUBKEY           *f_pPubkey,         
    IN  DRM_BOOL               f_fIncludeTag,
    IN  DRM_CONST_STRING       *f_pdstrB64Signature,
    OUT DRM_CONST_STRING       *f_pdstrXMLNode,    
    OUT DRM_CONST_STRING       *f_pdstrXMLNodeData,
    IN  DRM_DWORD              f_iLayer );


DRM_API DRM_RESULT DRM_CALL DRM_XML_GetAndVerifyKeyedHashSubNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    IN  const DRM_CONST_STRING *f_pdstrTag,
    IN  const DRM_CONST_STRING *f_pdstrAttrName,
    IN  const DRM_CONST_STRING *f_pdstrAttrValue,
    IN  const DRM_DWORD        f_iNode,        
    IN  DRM_HMAC_CONTEXT       *f_pHmacContext,
    IN  DRM_BYTE               *f_pbHashkey,   
    IN  DRM_DWORD              f_cbHashkey,    
    IN  DRM_BOOL               f_fIncludeTag,
    IN  DRM_CONST_STRING       *f_pdstrB64Signature,
    OUT DRM_CONST_STRING       *f_pdstrXMLNode,
    OUT DRM_CONST_STRING       *f_pdstrXMLNodeData, 
    IN  DRM_DWORD              f_iLayer );

DRM_API DRM_RESULT DRM_CALL DRM_XML_GetSubNodeByPath(
    IN const DRM_CONST_STRING *f_pdstrXML, 
    IN const DRM_CONST_STRING  *f_pdstrXMLNodeString, 
    IN const DRM_CONST_STRING  *f_pdstrAttrName, 
    IN const DRM_CONST_STRING  *f_pdstrAttrValue,
    OUT      DRM_CONST_STRING  *f_pdstrResultXML, 
    OUT      DRM_CONST_STRING  *f_pdstrResultXMLData,
    IN       DRM_WCHAR         f_chSeparator );


DRM_API DRM_RESULT DRM_CALL DRM_XML_EnumNextNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    OUT DRM_CONST_STRING       *f_pdstrTag,
    OUT DRM_CONST_STRING       *f_pdstrXMLNode,
    OUT DRM_CONST_STRING       *f_pdstrXMLNodeData,
    OUT DRM_CONST_STRING       *f_pdstr1stAttrName, 
    OUT DRM_CONST_STRING       *f_pdstr1stAttrValue, 
    OUT DRM_BOOL               *f_pfIsLeafNode );

DRM_API DRM_RESULT DRM_CALL DRM_XML_EnumNextSubNode(
    IN  const DRM_CONST_STRING *f_pdstrXML,
    OUT DRM_CONST_STRING       *f_pdstrTag,
    OUT DRM_CONST_STRING       *f_pdstrXMLNode,
    OUT DRM_CONST_STRING       *f_pdstrXMLNodeData,
    OUT DRM_CONST_STRING       *f_pdstr1stAttrName,
    OUT DRM_CONST_STRING       *f_pdstr1stAttrValue,
    OUT DRM_BOOL               *f_pfIsLeafNode,
    IN  DRM_DWORD              f_iLayer );

/* 
** ANSI
*/

DRM_API DRM_RESULT DRM_CALL DRM_XML_GetNodeA(
    __in_ecount( f_padstrXML->m_ich + f_padstrXML->m_cch ) const DRM_CHAR *f_pszBase,
    IN  const DRM_SUBSTRING         *f_padstrXML,
    IN  const DRM_ANSI_CONST_STRING *f_padstrTag,
    IN  const DRM_ANSI_CONST_STRING *f_padstrAttrName,
    IN  const DRM_ANSI_CONST_STRING *f_padstrAttrValue,
    IN  const DRM_DWORD             f_iNode,
    OUT DRM_SUBSTRING               *f_psubstrXMLNode,
    OUT DRM_SUBSTRING               *f_psubstrXMLNodeData );

DRM_API DRM_RESULT DRM_CALL DRM_XML_GetSubNodeA(
    __in_ecount( f_padstrXML->m_ich + f_padstrXML->m_cch ) const DRM_CHAR *f_pszBase,
    IN  const DRM_SUBSTRING         *f_padstrXML,
    IN  const DRM_ANSI_CONST_STRING *f_padstrTag,
    IN  const DRM_ANSI_CONST_STRING *f_padstrAttrName,
    IN  const DRM_ANSI_CONST_STRING *f_padstrAttrValue,
    IN  const DRM_DWORD             f_iNode,
    OUT DRM_SUBSTRING               *f_psubstrXMLNode,
    OUT DRM_SUBSTRING               *f_psubstrXMLNodeData,
    IN  DRM_DWORD                    f_iLayer );

DRM_API DRM_RESULT DRM_CALL DRM_XML_GetNodeAttributeA(
    __in_ecount( f_padstrXML->m_ich + f_padstrXML->m_cch ) const DRM_CHAR *f_pszBase,
    IN  const DRM_SUBSTRING         *f_padstrXML,
    IN  const DRM_ANSI_CONST_STRING *f_padstrAttrName,
    OUT DRM_SUBSTRING               *f_psubstrAttrValue );

DRM_API DRM_RESULT DRM_CALL DRM_XML_GetNodeCDataA(
    __in_ecount( f_pdasstrXML->m_ich + f_pdasstrXML->m_cch ) const DRM_CHAR *f_pszXMLBase,
    IN  const DRM_SUBSTRING *f_pdasstrXML,
    OUT DRM_SUBSTRING       *f_pdasstrCData );

DRM_API DRM_RESULT DRM_CALL DRM_XML_GetSubNodeByPathA(
    __in_ecount( f_pdasstrXML->m_ich + f_pdasstrXML->m_cch ) const DRM_CHAR *f_pszBase,
    IN  const DRM_SUBSTRING         *f_pdasstrXML,
    IN  const DRM_ANSI_CONST_STRING *f_pdastrNodePath,
    IN  const DRM_ANSI_CONST_STRING *f_pdastrAttrName,
    IN  const DRM_ANSI_CONST_STRING *f_pdastrAttrValue,
    OUT DRM_SUBSTRING               *f_pdasstrXMLNodeOut,
    OUT DRM_SUBSTRING               *f_pdasstrXMLDataOut,
    IN  DRM_CHAR                    chSeparator );

DRM_API DRM_RESULT DRM_CALL DRM_XML_EnumNextNodeA(
    __in_ecount( f_pdasstrXML->m_ich + f_pdasstrXML->m_cch ) const DRM_CHAR *f_pszBase,
    IN  const DRM_SUBSTRING *f_pdasstrXML,
    IN  const DRM_DWORD     f_iNode,
    OUT DRM_SUBSTRING       *f_pdasstrTag,
    OUT DRM_SUBSTRING       *f_pdasstrNode,
    OUT DRM_SUBSTRING       *f_pdasstrNodeData,
    OUT DRM_SUBSTRING       *f_pdasstr1stAttrName,
    OUT DRM_SUBSTRING       *f_pdasstr1stAttrValue );

DRM_API DRM_RESULT DRM_CALL DRM_XML_CountMatchingNodesA(
    __in_ecount( f_pdasstrXML->m_ich + f_pdasstrXML->m_cch ) const DRM_CHAR *f_pszBase,
    IN  const DRM_SUBSTRING         *f_pdasstrXML,
    IN  const DRM_ANSI_CONST_STRING *f_pdasstrTag,
    IN  DRM_ANSI_CONST_STRING       *f_pdasstr1stAttrName,
    IN  DRM_ANSI_CONST_STRING       *f_pdasstr1stAttrValue,
    OUT DRM_DWORD                   *f_cMatchingNodes );

DRM_API DRM_BOOL DRM_CALL DRM_XML_Validate(
    IN const DRM_CONST_STRING *f_pdstrXML );

EXIT_PK_NAMESPACE;

#endif      /* __DRMXMLPARSER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmxmr.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_XMR_H__
#define __DRM_XMR_H__

#include <drmcommon.h>
#include <drmoutputleveltypes.h>

ENTER_PK_NAMESPACE;

#define XMR_HEADER_LENGTH        ( SIZEOF( DRM_DWORD ) * 2 + SIZEOF( DRM_ID ) )
#define XMR_BASE_OBJECT_LENGTH   ( SIZEOF( DRM_WORD ) * 2  + SIZEOF( DRM_DWORD ) )
#define XMR_MAXIMUM_OBJECT_DEPTH  5

/*
** constants, enums and data types
*/
#define XMR_MAGIC_CONSTANT        0x584D5200 /* 'XMR\0' */

#define XMR_UNLIMITED             MAX_UNSIGNED_TYPE( DRM_DWORD )

enum XMR_VERSION
{
    XMR_VERSION_INVALID  = 0x0000,
    XMR_VERSION_1        = 0x0001,
    XMR_VERSION_2        = 0x0002,
    XMR_VERSION_3        = 0x0003,

    XMR_VERSION_MAX      = XMR_VERSION_3,
};

enum XMR_OBJECT_FLAGS
{
    XMR_FLAGS_NONE                  = 0x0000,
    XMR_FLAGS_MUST_UNDERSTAND       = 0x0001,
    XMR_FLAGS_CONTAINER             = 0x0002,
    XMR_FLAGS_ALLOW_EXTERNAL_PARSE  = 0x0004,
    XMR_FLAGS_BEST_EFFORT           = 0x0008,
    XMR_FLAGS_HAS_SECURE_STATE      = 0x0010
};

enum XMR_SETTINGS_FLAGS
{
    XMR_SETTINGS_FLAG_CANNOT_PERSIST  = 0x0001
};

/*
** Symmetric encryption types used for content encryption
*/
enum XMR_SYMMETRIC_ENCRYPTION_TYPE
{
    XMR_SYMMETRIC_ENCRYPTION_TYPE_INVALID      = 0x0000,
    XMR_SYMMETRIC_ENCRYPTION_TYPE_AES_128_CTR  = 0x0001,
    XMR_SYMMETRIC_ENCRYPTION_TYPE_RC4_CIPHER   = 0x0002,
    XMR_SYMMETRIC_ENCRYPTION_TYPE_AES_128_ECB  = 0x0003,
    XMR_SYMMETRIC_ENCRYPTION_TYPE_COCKTAIL     = 0x0004
};

/*
** Asymmetric encryption types used for encrypting the content key
*/
enum XMR_ASYMMETRIC_ENCRYPTION_TYPE
{
    XMR_ASYMMETRIC_ENCRYPTION_TYPE_INVALID          = 0x0000,
    XMR_ASYMMETRIC_ENCRYPTION_TYPE_RSA_1024         = 0x0001,
    XMR_ASYMMETRIC_ENCRYPTION_TYPE_CHAINED_LICENSE  = 0x0002,
    XMR_ASYMMETRIC_ENCRYPTION_TYPE_ECC_256          = 0x0003
};

/*
** Symmetric encryption types used for encrypting the content key (optimized)
*/
enum XMR_SYMMETRIC_KEY_ENCRYPTION_TYPE
{
    XMR_SYMMETRIC_KEY_ENCRYPTION_TYPE_INVALID          = 0x0000,
    XMR_SYMMETRIC_KEY_ENCRYPTION_TYPE_AES_128_ECB      = 0x0001,
    XMR_SYMMETRIC_KEY_ENCRYPTION_TYPE_AES_128_ECB_SLK  = 0x0002
};

enum XMR_ECC_CURVE_TYPE
{
    XMR_ECC_CURVE_TYPE_INVALID                = 0x0000,
    XMR_ECC_CURVE_TYPE_P256                   = 0x0001
};

enum XMR_SIGNATURE_TYPE
{
    XMR_SIGNATURE_TYPE_INVALID                = 0x0000,
    XMR_SIGNATURE_TYPE_AES_128_OMAC           = 0x0001,
    XMR_SIGNATURE_TYPE_SHA_256_HMAC           = 0x0002
};

enum XMR_GLOBAL_RIGHTS_SETTINGS
{
    XMR_RIGHTS_CANNOT_PERSIST                 = 0x001,
    XMR_RIGHTS_ALLOW_BACKUP_RESTORE           = 0x004,
    XMR_RIGHTS_COLLABORATIVE_PLAY             = 0x008,
    XMR_RIGHTS_BASE_LICENSE                   = 0x010,
                                             // 0x020 was previously used by THUMBNAIL right in Vista/Polaris and shouldn't be used
    XMR_RIGHTS_CANNOT_BIND_LICENSE            = 0x040
};

enum XMR_EXTENSIBLE_RESTRICTON_STATE
{
    XMR_EXTENSIBLE_RESTRICTON_STATE_COUNT      = 0x02,
    XMR_EXTENSIBLE_RESTRICTON_STATE_DATE       = 0x03,
    XMR_EXTENSIBLE_RESTRICTON_STATE_BYTEARRAY  = 0x04,
};

enum XMR_EMBEDDING_BEHAVIOR
{
    XMR_EMBEDDING_BEHAVIOR_INVALID = 0x00,
    XMR_EMBEDDING_BEHAVIOR_IGNORE  = 0x01,
    XMR_EMBEDDING_BEHAVIOR_COPY    = 0x02,
    XMR_EMBEDDING_BEHAVIOR_MOVE    = 0x03
};

enum XMR_UPLINK_CHECKSUM_TYPE
{
    XMR_UPLINK_CHECKSUM_TYPE_XMRV1      = 0x00,
    XMR_UPLINK_CHECKSUM_TYPE_AESOMAC1   = 0x01,
};

enum XMR_OBJECT_TYPE
{
    XMR_OBJECT_TYPE_INVALID                                            = 0x0000,
    XMR_OBJECT_TYPE_OUTER_CONTAINER                                    = 0x0001,
    XMR_OBJECT_TYPE_GLOBAL_POLICY_CONTAINER                            = 0x0002,
    XMR_OBJECT_TYPE_MINIMUM_ENVIRONMENT_OBJECT                         = 0x0003,
    XMR_OBJECT_TYPE_PLAYBACK_POLICY_CONTAINER                          = 0x0004,
    XMR_OBJECT_TYPE_OUTPUT_PROTECTION_OBJECT                           = 0x0005,
    XMR_OBJECT_TYPE_UPLINK_KID_OBJECT                                  = 0x0006,
    XMR_OBJECT_TYPE_EXPLICIT_ANALOG_VIDEO_OUTPUT_PROTECTION_CONTAINER  = 0x0007,
    XMR_OBJECT_TYPE_ANALOG_VIDEO_OUTPUT_CONFIGURATION_OBJECT           = 0x0008,
    XMR_OBJECT_TYPE_KEY_MATERIAL_CONTAINER                             = 0x0009,
    XMR_OBJECT_TYPE_CONTENT_KEY_OBJECT                                 = 0x000A,
    XMR_OBJECT_TYPE_SIGNATURE_OBJECT                                   = 0x000B,
    XMR_OBJECT_TYPE_SERIAL_NUMBER_OBJECT                               = 0x000C,
    XMR_OBJECT_TYPE_SETTINGS_OBJECT                                    = 0x000D,
    XMR_OBJECT_TYPE_COPY_POLICY_CONTAINER                              = 0x000E,
    XMR_OBJECT_TYPE_ALLOW_PLAYLISTBURN_POLICY_CONTAINER                = 0x000F,
    XMR_OBJECT_TYPE_INCLUSION_LIST_OBJECT                              = 0x0010,
    XMR_OBJECT_TYPE_PRIORITY_OBJECT                                    = 0x0011,
    XMR_OBJECT_TYPE_EXPIRATION_OBJECT                                  = 0x0012,
    XMR_OBJECT_TYPE_ISSUEDATE_OBJECT                                   = 0x0013,
    XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTUSE_OBJECT                   = 0x0014,
    XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTSTORE_OBJECT                 = 0x0015,
    XMR_OBJECT_TYPE_METERING_OBJECT                                    = 0x0016,
    XMR_OBJECT_TYPE_PLAYCOUNT_OBJECT                                   = 0x0017,
    XMR_OBJECT_TYPE_GRACE_PERIOD_OBJECT                                = 0x001A,
    XMR_OBJECT_TYPE_COPYCOUNT_OBJECT                                   = 0x001B,
    XMR_OBJECT_TYPE_COPY_PROTECTION_OBJECT                             = 0x001C,
    XMR_OBJECT_TYPE_PLAYLISTBURN_COUNT_OBJECT                          = 0x001F,
    XMR_OBJECT_TYPE_REVOCATION_INFORMATION_VERSION_OBJECT              = 0x0020,
    XMR_OBJECT_TYPE_RSA_DEVICE_KEY_OBJECT                              = 0x0021,
    XMR_OBJECT_TYPE_SOURCEID_OBJECT                                    = 0x0022,
    XMR_OBJECT_TYPE_REVOCATION_CONTAINER                               = 0x0025,
    XMR_OBJECT_TYPE_RSA_LICENSE_GRANTER_KEY_OBJECT                     = 0x0026,
    XMR_OBJECT_TYPE_USERID_OBJECT                                      = 0x0027,
    XMR_OBJECT_TYPE_RESTRICTED_SOURCEID_OBJECT                         = 0x0028,
    XMR_OBJECT_TYPE_DOMAIN_ID_OBJECT                                   = 0x0029,
    XMR_OBJECT_TYPE_ECC_DEVICE_KEY_OBJECT                              = 0x002A,
    XMR_OBJECT_TYPE_GENERATION_NUMBER_OBJECT                           = 0x002B,
    XMR_OBJECT_TYPE_POLICY_METADATA_OBJECT                             = 0x002C,
    XMR_OBJECT_TYPE_OPTIMIZED_CONTENT_KEY_OBJECT                       = 0x002D,
    XMR_OBJECT_TYPE_EXPLICIT_DIGITAL_AUDIO_OUTPUT_PROTECTION_CONTAINER = 0x002E,
    XMR_OBJECT_TYPE_RINGTONE_POLICY_CONTAINER                          = 0x002F,
    XMR_OBJECT_TYPE_EXPIRATION_AFTER_FIRSTPLAY_OBJECT                  = 0x0030,
    XMR_OBJECT_TYPE_DIGITAL_AUDIO_OUTPUT_CONFIGURATION_OBJECT          = 0x0031,
    XMR_OBJECT_TYPE_REVOCATION_INFORMATION_VERSION_2_OBJECT            = 0x0032,
    XMR_OBJECT_TYPE_EMBEDDING_BEHAVIOR_OBJECT                          = 0x0033,
    XMR_OBJECT_TYPE_SECURITY_LEVEL                                     = 0x0034,
    XMR_OBJECT_TYPE_COPY_TO_PC_CONTAINER                               = 0x0035,
    XMR_OBJECT_TYPE_PLAY_ENABLER_CONTAINER                             = 0x0036,
    XMR_OBJECT_TYPE_MOVE_ENABLER_OBJECT                                = 0x0037,
    XMR_OBJECT_TYPE_COPY_ENABLER_CONTAINER                             = 0x0038,
    XMR_OBJECT_TYPE_PLAY_ENABLER_OBJECT                                = 0x0039,
    XMR_OBJECT_TYPE_COPY_ENABLER_OBJECT                                = 0x003A,
    XMR_OBJECT_TYPE_UPLINK_KID_2_OBJECT                                = 0x003B,
    XMR_OBJECT_TYPE_COPY_POLICY_2_CONTAINER                            = 0x003C,
    XMR_OBJECT_TYPE_COPYCOUNT_2_OBJECT                                 = 0x003D,
    XMR_OBJECT_TYPE_RINGTONE_ENABLER_OBJECT                            = 0x003E,
    XMR_OBJECT_TYPE_EXECUTE_POLICY_CONTAINER                           = 0x003F,
    XMR_OBJECT_TYPE_MAXIMUM_DEFINED                                    = 0x003D
};

typedef struct
{
    DRM_BOOL                fIsContainer;
    DRM_WORD                wParent;
    DRM_WORD                wFlags;
} XMR_COMMON_INTERNAL_DEFINES;

extern const DRM_EXPORT_VAR XMR_COMMON_INTERNAL_DEFINES g_xmrCommonDefines[XMR_OBJECT_TYPE_MAXIMUM_DEFINED+1];


#define XMR_RIGHTS_COPY_FROM_V1 19



typedef struct __tagDRM_XMR_WORD
{
    DRM_BOOL fValid;
    DRM_WORD wValue;
} DRM_XMR_WORD;

typedef struct __tagDRM_XMR_DWORD
{
    DRM_BOOL  fValid;
    DRM_DWORD dwValue;
} DRM_XMR_DWORD;

typedef struct __tagDRM_XMR_GUID
{
    DRM_BOOL  fValid;
    DRM_BYTE  *pguidBuffer;
    DRM_DWORD  iGuid;
} DRM_XMR_GUID;

typedef struct __tagDRM_XMR_GUIDLIST
{
    DRM_BOOL   fValid;
    DRM_DWORD  cGUIDs;
    DRM_BYTE  *pguidBuffer;
    DRM_DWORD  iGuids;
} DRM_XMR_GUIDLIST;

typedef struct __tagDRM_XMR_BYTEARRAY
{
    DRM_BOOL   fValid;
    DRM_DWORD  cbData;
    DRM_BYTE  *pbDataBuffer;
    DRM_DWORD  iData;
} DRM_XMR_BYTEARRAY;

typedef struct __tagDRM_XMR_EMPTY
{
    DRM_BOOL  fValid;
} DRM_XMR_EMPTY;

typedef struct __tagDRM_XMR_DWORD_VERSIONED
{
    DRM_BOOL  fValid;
    DRM_DWORD dwVersion;    /* Only used for validation purposes during parsing */
    DRM_DWORD dwValue;
} DRM_XMR_DWORD_VERSIONED;


/*
** Structures for Global requirements container
*/
typedef struct __tagDRM_XMR_MINIMUM_ENVIRONMENT
{
    DRM_BOOL    fValid;
    DRM_DWORD   dwVersion;   /* Only used for validation purposes during parsing */
    DRM_WORD    wMinimumSecurityLevel;
    DRM_DWORD   dwMinimumAppRevocationListVersion;
    DRM_DWORD   dwMinimumDeviceRevocationListVersion;
} DRM_XMR_MINIMUM_ENVIRONMENT;


typedef DRM_XMR_BYTEARRAY           DRM_XMR_SERIAL_NUMBER;
typedef DRM_XMR_WORD                DRM_XMR_RIGHTS;
typedef DRM_XMR_DWORD_VERSIONED     DRM_XMR_REVOCATION_INFORMATION_VERSION;
typedef DRM_XMR_DWORD               DRM_XMR_PRIORITY;
typedef DRM_XMR_DWORD               DRM_XMR_SOURCEID;
typedef DRM_XMR_EMPTY               DRM_XMR_RESTRICTED_SOURCEID;
typedef DRM_XMR_WORD                DRM_XMR_EMBEDDING_BEHAVIOR;
typedef DRM_XMR_DWORD               DRM_XMR_MOVE_ENABLER;

enum  XMR_SOURCEID
{
    XMR_SOURCEID_NONE          = 0,
    XMR_SOURCEID_MACROVISION   = 1,
    XMR_SOURCEID_CGMSA         = 2,
    XMR_SOURCEID_WSS           = 3,
    XMR_SOURCEID_DIGITAL_CABLE = 4,
    XMR_SOURCEID_ATSC          = 5,
    XMR_SOURCEID_PDRM          = 260,
    XMR_SOURCEID_LEGACY_DVR    = 261,
    XMR_SOURCEID_V1            = 262,
};

#define XMR_SOURCEID_MAXCOUNT   100

typedef struct __tagDRM_XMR_EXPIRATION
{
    DRM_BOOL    fValid;
    DRM_DWORD   dwBeginDate;
    DRM_DWORD   dwEndDate;
} DRM_XMR_EXPIRATION;


typedef DRM_XMR_DWORD           DRM_XMR_ISSUEDATE;
typedef DRM_XMR_DWORD           DRM_XMR_GRACE_PERIOD;
typedef DRM_XMR_GUID            DRM_XMR_METERING;
typedef DRM_XMR_DWORD_VERSIONED DRM_XMR_EXPIRATION_AFTER_FIRSTUSE;
typedef DRM_XMR_DWORD           DRM_XMR_EXPIRATION_AFTER_FIRSTSTORE;
typedef DRM_XMR_GUIDLIST        DRM_XMR_INCLUSION_LIST;

typedef struct __tagDRM_XMR_UNKNOWN_OBJECT
{
    DRM_BOOL                            fValid;
    DRM_WORD                            wType;
    DRM_WORD                            wFlags;
    DRM_BYTE                           *pbBuffer;
    DRM_DWORD                           ibData;
    DRM_DWORD                           cbData;
    struct __tagDRM_XMR_UNKNOWN_OBJECT *pNext; /* Linked list */
} DRM_XMR_UNKNOWN_OBJECT;

typedef struct __tagDRM_XMR_UNKNOWN_CONTAINER
{
   DRM_BOOL                                         fValid;
   DRM_WORD                                         wType;
   DRM_WORD                                         wFlags;
   DRM_XMR_UNKNOWN_OBJECT                           *pObject;
   struct __tagDRM_XMR_UNKNOWN_CONTAINER            *pUnkChildcontainer;/* Linked list */
   struct __tagDRM_XMR_UNKNOWN_CONTAINER            *pNext; /* Linked list */
} DRM_XMR_UNKNOWN_CONTAINER;

typedef DRM_XMR_DWORD DRM_XMR_GENERATION_NUMBER;

typedef struct __tagDRM_XMR_DOMAIN_ID
{
    DRM_BOOL    fValid;
    DRM_BYTE   *pbAccountID;
    DRM_DWORD   ibAccountID;
    DRM_DWORD   cbAccountID;
    DRM_DWORD   dwRevision;
} DRM_XMR_DOMAIN_ID;

typedef struct __tagDRM_XMR_POLICY_METADATA_OBJECT
{
    DRM_BOOL     fValid;
    DRM_BYTE    *pMetadataTypeGuidBuffer;
    DRM_DWORD    iMetadataTypeGuid;
    DRM_DWORD    cbPolicyData;
    DRM_BYTE    *pbPolicyDataBuffer;
    DRM_DWORD    iPolicyData;
} DRM_XMR_POLICY_METADATA_OBJECT;

typedef struct __tagDRM_XMR_POLICY_METADATA_LIST
{
    DRM_XMR_POLICY_METADATA_OBJECT            MetadataObject;
    struct __tagDRM_XMR_POLICY_METADATA_LIST *pNext;
} DRM_XMR_POLICY_METADATA_LIST;

typedef struct __tagDRM_XMR_POLICY_METADATA
{
    DRM_BOOL                      fValid;
    DRM_DWORD                     cPolicyMetadataObjects;
    DRM_XMR_POLICY_METADATA_LIST *plistPolicyMetadataObjects;
} DRM_XMR_POLICY_METADATA;

typedef struct __tagDRM_XMR_GLOBAL_REQUIREMENTS
{
    DRM_BOOL                                 fValid;
    DRM_XMR_MINIMUM_ENVIRONMENT              MinimumEnvironment;
    DRM_XMR_SERIAL_NUMBER                    SerialNumber;
    DRM_XMR_RIGHTS                           Rights;
    DRM_XMR_PRIORITY                         Priority;
    DRM_XMR_SOURCEID                         SourceID;
    DRM_XMR_RESTRICTED_SOURCEID              RestrictedSourceID;
    DRM_XMR_EXPIRATION                       Expiration;
    DRM_XMR_ISSUEDATE                        IssueDate;
    DRM_XMR_GRACE_PERIOD                     GracePeriod;
    DRM_XMR_METERING                         Metering;
    DRM_XMR_EXPIRATION_AFTER_FIRSTUSE        ExpirationAfterUse;
    DRM_XMR_EXPIRATION_AFTER_FIRSTSTORE      ExpirationAfterStore;
    DRM_XMR_INCLUSION_LIST                   InclusionList;
    DRM_XMR_REVOCATION_INFORMATION_VERSION   RevocationInformationVersion;
    DRM_XMR_DOMAIN_ID                        DomainID;
    DRM_XMR_EMBEDDING_BEHAVIOR               EmbeddingBehavior;
    DRM_XMR_UNKNOWN_OBJECT                  *pUnknownObjects;
    DRM_XMR_POLICY_METADATA                  PolicyMetadata;
} DRM_XMR_GLOBAL_REQUIREMENTS;

/*
**  Structures for playback policies container
*/
typedef DRM_XMR_DWORD DRM_XMR_PLAYCOUNT;

typedef struct __tagDRM_XMR_MINIMUM_OUTPUT_PROTECTION_LEVELS
{
    DRM_BOOL fValid;
    DRM_WORD wCompressedDigitalVideo;
    DRM_WORD wUncompressedDigitalVideo;
    DRM_WORD wAnalogVideo;
    DRM_WORD wCompressedDigitalAudio;
    DRM_WORD wUncompressedDigitalAudio;
} DRM_XMR_MINIMUM_OUTPUT_PROTECTION_LEVELS;

typedef struct __tagDRM_XMR_OUTPUT_CONFIGURATION
{
    DRM_BOOL     fValid;
    DRM_BYTE    *pguidBuffer;
    DRM_DWORD    iGuid;
    DRM_DWORD    cbConfigData;
    DRM_BYTE    *pbConfigDataBuffer;
    DRM_DWORD    iConfigData;
} DRM_XMR_OUTPUT_CONFIGURATION;
typedef DRM_XMR_OUTPUT_CONFIGURATION DRM_XMR_VIDEO_OUTPUT_CONFIGURATION;
typedef DRM_XMR_OUTPUT_CONFIGURATION DRM_XMR_AUDIO_OUTPUT_CONFIGURATION;

typedef struct __tagDRM_XMR_OUTPUT_CONFIGURATION_LIST
{
    DRM_XMR_OUTPUT_CONFIGURATION                   Config;
    struct __tagDRM_XMR_OUTPUT_CONFIGURATION_LIST *pNext;
} DRM_XMR_OUTPUT_CONFIGURATION_LIST;
typedef DRM_XMR_OUTPUT_CONFIGURATION_LIST DRM_XMR_VIDEO_OUTPUT_CONFIGURATION_LIST;
typedef DRM_XMR_OUTPUT_CONFIGURATION_LIST DRM_XMR_AUDIO_OUTPUT_CONFIGURATION_LIST;

typedef struct __tagDRM_XMR_EXPLICIT_OUTPUT_PROTECTION
{
    DRM_BOOL    fValid;
    DRM_DWORD   cOutputProtectionIDs;
    DRM_XMR_OUTPUT_CONFIGURATION_LIST *plistOutputConfiguration;
} DRM_XMR_EXPLICIT_OUTPUT_PROTECTION;
typedef DRM_XMR_EXPLICIT_OUTPUT_PROTECTION DRM_XMR_EXPLICIT_ANALOG_VIDEO_PROTECTION;
typedef DRM_XMR_EXPLICIT_OUTPUT_PROTECTION DRM_XMR_EXPLICIT_DIGITAL_AUDIO_PROTECTION;

typedef struct __tagDRM_XMR_PLAYBACK_RIGHTS
{
    DRM_BOOL                                   fValid;
    DRM_XMR_PLAYCOUNT                          PlayCount;
    DRM_XMR_MINIMUM_OUTPUT_PROTECTION_LEVELS   opl;
    DRM_XMR_EXPLICIT_ANALOG_VIDEO_PROTECTION   containerExplicitAnalogVideoProtection;
    DRM_XMR_EXPLICIT_DIGITAL_AUDIO_PROTECTION  containerExplicitDigitalAudioProtection;
    DRM_XMR_UNKNOWN_OBJECT                    *pUnknownObjects;
    DRM_XMR_UNKNOWN_CONTAINER                  UnknownContainer;
} DRM_XMR_PLAYBACK_RIGHTS;

typedef struct __tagDRM_XMR_COPY_TO_PC
{
    DRM_BOOL                                   fValid;
} DRM_XMR_COPY_TO_PC;

/*
**  Maximum allowable CopyCount
*/
#define XMR_MAX_COPY_COUNT 249

/*
**  Structures for copy policies container
*/
typedef DRM_XMR_DWORD_VERSIONED     DRM_XMR_COPY_COUNT;
typedef DRM_XMR_WORD                DRM_XMR_COPY_PROTECTION_LEVEL;
typedef struct __tagDRM_XMR_COPY_RIGHTS
{
    DRM_BOOL                        fValid;
    DRM_DWORD                       dwVersion;      /* Used for validation purposes during parsing, used when building V1 XMR licenses to decide which object type to use (defaults to XMR_OBJECT_TYPE_COPY_POLICY_2_CONTAINER) */
    DRM_XMR_COPY_COUNT              CopyCount;      /* Object type for DRM_XMR_COPY_COUNT will be determined based on object type for DRM_XMR_COPY_RIGHTS */
    DRM_XMR_COPY_PROTECTION_LEVEL   CopyProtectionLevel;
    DRM_XMR_MOVE_ENABLER            MoveEnabler;
    DRM_XMR_UNKNOWN_OBJECT         *pUnknownObjects;
    DRM_XMR_UNKNOWN_CONTAINER       UnknownContainer;
} DRM_XMR_COPY_RIGHTS;

/*
**  Structures for playlistburn policies container
*/
typedef struct __tagDRM_XMR_PLAYLIST_BURN_RESTRICTIONS
{
    DRM_BOOL    fValid;
    DRM_DWORD   dwMaxPlaylistBurnCount;
    DRM_DWORD   dwPlaylistBurnTrackCount;
} DRM_XMR_PLAYLIST_BURN_RESTRICTIONS;

typedef struct __tagDRM_XMR_PLAYLIST_BURN_RIGHTS
{
    DRM_BOOL                           fValid;
    DRM_XMR_PLAYLIST_BURN_RESTRICTIONS Restrictions;
    DRM_XMR_UNKNOWN_OBJECT            *pUnknownObjects;
} DRM_XMR_PLAYLIST_BURN_RIGHTS;


/*
** Structures for Revocation container
*/
typedef struct __tagDRM_XMR_RSA_PUBKEY
{
    DRM_BOOL    fValid;
    DRM_DWORD   dwExponent;
    DRM_WORD    cbModulus;
    DRM_BYTE   *pbModulusBuffer;
    DRM_DWORD   iModulus;
} DRM_XMR_RSA_PUBKEY;

typedef DRM_XMR_RSA_PUBKEY DRM_XMR_RSA_LICENSE_GRANTER_KEY;

typedef struct __tagDRM_XMR_USERID
{
    DRM_BOOL     fValid;
    DRM_DWORD    cbUserID;
    DRM_BYTE    *pbUserID;
    DRM_DWORD    iUserID;
} DRM_XMR_USERID;

typedef struct __tagDRM_XMR_REVOCATION
{
    DRM_BOOL                        fValid;
    DRM_XMR_RSA_LICENSE_GRANTER_KEY RsaLicenseGranterKey;
    DRM_XMR_USERID                  UserID;
} DRM_XMR_REVOCATION;

/*
**  Structures for Key Material container
*/
typedef struct __tagDRM_XMR_CONTENT_KEY
{
    DRM_BOOL     fValid;
    DRM_BYTE    *pbguidKeyID;
    DRM_DWORD    iguidKeyID;
    DRM_WORD     wSymmetricCipherType;
    DRM_WORD     wKeyEncryptionCipherType;
    DRM_WORD     cbEncryptedKey;
    DRM_BYTE    *pbEncryptedKeyBuffer;
    DRM_DWORD    iEncryptedKey;
} DRM_XMR_CONTENT_KEY;

typedef struct __tagDRM_XMR_OPTIMIZED_CONTENT_KEY
{
    DRM_BOOL     fValid;
    DRM_WORD     wKeyEncryptionCipherType;
    DRM_WORD     cbEncryptedKey;
    DRM_BYTE    *pbEncryptedKeyBuffer;
    DRM_DWORD    iEncryptedKey;
} DRM_XMR_OPTIMIZED_CONTENT_KEY;

typedef struct __tagDRM_XMR_ECC_DEVICE_KEY
{
    DRM_BOOL    fValid;
    DRM_WORD    wEccCurveType;
    DRM_DWORD   iKeyData;
    DRM_WORD    cbKeyData;
    DRM_BYTE   *pbKeyData;
} DRM_XMR_ECC_DEVICE_KEY;

typedef DRM_XMR_RSA_PUBKEY DRM_XMR_DEVICE_KEY;


typedef struct __tagDRM_XMR_UPLINK_KID
{
    DRM_BOOL     fValid;
    DRM_DWORD    dwVersion;    /* Only used for validation purposes during parsing */
    DRM_BYTE    *pbguidUplinkKID;
    DRM_DWORD    iguidUplinkKID;
    DRM_WORD     cbChainedCheckSum;
    DRM_BYTE    *pbChainedCheckSumBuffer;
    DRM_DWORD    iChainedCheckSum;
    DRM_WORD     wChecksumType;
} DRM_XMR_UPLINK_KID;

typedef struct __tagDRM_XMR_KEY_MATERIAL
{
    DRM_BOOL                       fValid;
    DRM_XMR_CONTENT_KEY            ContentKey;
    DRM_XMR_OPTIMIZED_CONTENT_KEY  OptimizedContentKey;
    DRM_XMR_DEVICE_KEY             DeviceKey;
    DRM_XMR_ECC_DEVICE_KEY         ECCKey;
    DRM_XMR_UPLINK_KID             UplinkKid;
} DRM_XMR_KEY_MATERIAL;

/*
**  The signature object will be used by caller only during parsing. The
**  builder ignores any data that is passed in this object. It instead populates
**  it itself.
*/
typedef struct __tagDRM_XMR_SIGNATURE
{
    DRM_BOOL    fValid;
    DRM_WORD    wType;
    DRM_BYTE   *pbSignatureBuffer;
    DRM_DWORD   iSignature;
    DRM_WORD    cbSignature;
} DRM_XMR_SIGNATURE;

typedef struct __tagDRM_XMR_OUTER_CONTAINER
{
    DRM_BOOL                        fValid;
    DRM_XMR_GLOBAL_REQUIREMENTS     containerGlobalPolicies;
    DRM_XMR_PLAYBACK_RIGHTS         containerPlaybackPolicies;
    DRM_XMR_COPY_RIGHTS             containerCopyPolicies;
    DRM_XMR_COPY_TO_PC              containerCopyToPCPolicies;
    DRM_XMR_PLAYLIST_BURN_RIGHTS    containerPlaylistBurnPolicies;
    DRM_XMR_GENERATION_NUMBER       generationNumber;
    DRM_XMR_UNKNOWN_CONTAINER       containerUnknown;
    DRM_XMR_REVOCATION              containerRevocation;
    DRM_XMR_KEY_MATERIAL            containerKeys;
    DRM_XMR_SIGNATURE               signature;
} DRM_XMR_OUTER_CONTAINER;

typedef struct __tagDRM_XMR_LICENSE
{
    DRM_BYTE                   *pbRightsIdBuffer;
    DRM_DWORD                   iRightsId;
    DRM_DWORD                   dwVersion;
    DRM_BYTE                   *pbSignedDataBuffer;
    DRM_DWORD                   iSignedData;
    DRM_DWORD                   cbSignedData;
    DRM_XMR_OUTER_CONTAINER     containerOuter;
    DRM_BYTE                    *pbXMRLic;
    DRM_DWORD                   cbXMRLic;
} DRM_XMR_LICENSE;

/*
** License evaluation macros
*/
#define XMR_IS_RID_VALID( plicenseXMR )                                          \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && NULL != ( plicenseXMR )->pbRightsIdBuffer )                                \

#define XMR_IS_METERING_VALID( plicenseXMR )                                     \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.fValid             \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.Metering.fValid )

#define XMR_IS_KEY_MATERIAL_VALID( plicenseXMR )                \
    ( ( plicenseXMR )->containerOuter.fValid                    \
   && ( plicenseXMR )->containerOuter.containerKeys.fValid )    \

#define XMR_IS_UPLINK_KID_VALID( plicenseXMR )                                   \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerKeys.fValid                       \
   && ( plicenseXMR )->containerOuter.containerKeys.UplinkKid.fValid )

#define XMR_IS_PRIORITY_VALID( plicenseXMR )                                     \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.fValid             \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.Priority.fValid )

#define XMR_IS_SOURCEID_VALID( plicenseXMR )                                     \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.fValid             \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.SourceID.fValid )

#define XMR_IS_RESTRICTED_SOURCEID_VALID( plicenseXMR )                          \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
    && ( plicenseXMR )->containerOuter.containerGlobalPolicies.fValid            \
    && ( plicenseXMR )->containerOuter.containerGlobalPolicies.RestrictedSourceID.fValid )

#define XMR_IS_REVOCATION_INFORMATION_VERSION_VALID( plicenseXMR )               \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.fValid             \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.RevocationInformationVersion.fValid )

#define XMR_IS_GLOBAL_POLICIES_VALID( plicenseXMR )                              \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.fValid )

#define XMR_IS_EXPIRATION_VALID( plicenseXMR )                                   \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.fValid             \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.Expiration.fValid )

#define XMR_IS_ISSUEDATE_VALID( plicenseXMR )                                    \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.fValid             \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.IssueDate.fValid )

#define XMR_IS_GRACE_PERIOD_VALID( plicenseXMR )                                 \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.fValid             \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.GracePeriod.fValid )

#define XMR_IS_EXPIRATION_AFTER_FIRST_USE_VALID( plicenseXMR )                   \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.fValid             \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.ExpirationAfterUse.fValid )

#define XMR_IS_EXPIRATION_AFTER_STORE_VALID( plicenseXMR )                       \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.fValid             \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.ExpirationAfterStore.fValid )

#define XMR_IS_MINIMUM_ENVIRONMENT_VALID( plicenseXMR )                          \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.fValid             \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.MinimumEnvironment.fValid )

#define XMR_IS_SECURITY_LEVEL_VALID( plicenseXMR )                               \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.fValid             \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.MinimumEnvironment.fValid ) 

#define XMR_IS_OPL_VALID( plicenseXMR  )                                         \
    ( (plicenseXMR)->containerOuter.fValid                                       \
   && (plicenseXMR)->containerOuter.containerPlaybackPolicies.fValid             \
   && (plicenseXMR)->containerOuter.containerPlaybackPolicies.opl.fValid)        \

#define XMR_IS_EXPLICITANALOGVIDEOPROTECTION_VALID( plicenseXMR  )               \
    ( (plicenseXMR)->containerOuter.fValid                                       \
   && (plicenseXMR)->containerOuter.containerPlaybackPolicies.fValid             \
   && (plicenseXMR)->containerOuter.containerPlaybackPolicies.containerExplicitAnalogVideoProtection.fValid)

#define XMR_IS_EXPLICITDIGITALAUDIOPROTECTION_VALID( plicenseXMR  )              \
    ( (plicenseXMR)->containerOuter.fValid                                       \
   && (plicenseXMR)->containerOuter.containerPlaybackPolicies.fValid             \
   && (plicenseXMR)->containerOuter.containerPlaybackPolicies.containerExplicitDigitalAudioProtection.fValid)

#define XMR_IS_POLICYMETADATA_VALID( plicenseXMR )                               \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.fValid             \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.PolicyMetadata.fValid )

#define XMR_IS_INCLUSIONLIST_VALID( plicenseXMR )                                \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.fValid             \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.InclusionList.fValid )

#define XMR_IS_PLAYLISTBURN_VALID( plicenseXMR )                                 \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerPlaylistBurnPolicies.fValid )     \

#define XMR_IS_PLAYLISTBURN_RESTRICTIONS_VALID( plicenseXMR )                    \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerPlaylistBurnPolicies.fValid       \
   && ( plicenseXMR )->containerOuter.containerPlaylistBurnPolicies.Restrictions.fValid )

#define XMR_IS_PLAY_VALID( plicenseXMR )                                         \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerPlaybackPolicies.fValid )         \

#define XMR_IS_PLAYCOUNT_VALID( plicenseXMR )                                    \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerPlaybackPolicies.fValid           \
   && ( plicenseXMR )->containerOuter.containerPlaybackPolicies.PlayCount.fValid )

#define XMR_IS_COPY_TO_PC_VALID( plicenseXMR )                                   \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerCopyToPCPolicies.fValid )

#define XMR_IS_COPY_VALID( plicenseXMR )                                         \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerCopyPolicies.fValid )

#define XMR_IS_COPYCOUNT_VALID( plicenseXMR )                                    \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerCopyPolicies.fValid               \
   && ( plicenseXMR )->containerOuter.containerCopyPolicies.CopyCount.fValid )

#define XMR_IS_MOVEENABLER_VALID( plicenseXMR )                                  \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerCopyPolicies.fValid               \
   && ( plicenseXMR )->containerOuter.containerCopyPolicies.MoveEnabler.fValid )

#define XMR_IS_COPYPROTECTIONLEVEL_VALID( plicenseXMR )                          \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerCopyPolicies.fValid               \
   && ( plicenseXMR )->containerOuter.containerCopyPolicies.CopyProtectionLevel.fValid )

#define XMR_IS_REVOCATION_VALID( plicenseXMR )                                   \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerRevocation.fValid )               \

#define XMR_IS_RSA_LICENSE_GRANTER_KEY_VALID( plicenseXMR )                      \
    ( (plicenseXMR)->containerOuter.fValid                                       \
   && (plicenseXMR)->containerOuter.containerRevocation.fValid                   \
   && (plicenseXMR)->containerOuter.containerRevocation.RsaLicenseGranterKey.fValid )

#define XMR_IS_USERID_VALID( plicenseXMR )                                       \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerRevocation.fValid                 \
   && ( plicenseXMR )->containerOuter.containerRevocation.UserID.fValid )

#define XMR_IS_SIGNATURE_VALID( plicenseXMR )                                    \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.signature.fValid )

#define XMR_IS_CONTENT_KEY_VALID( plicenseXMR )                                  \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerKeys.fValid                       \
   && ( plicenseXMR )->containerOuter.containerKeys.ContentKey.fValid )

#define XMR_IS_OPTIMIZED_CONTENT_KEY_VALID( plicenseXMR )                        \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerKeys.fValid                       \
   && ( plicenseXMR )->containerOuter.containerKeys.OptimizedContentKey.fValid )

#define XMR_IS_DEVICE_KEY_VALID( plicenseXMR )                                   \
    ( (plicenseXMR)->containerOuter.fValid                                       \
   && (plicenseXMR)->containerOuter.containerKeys.fValid                         \
   && (plicenseXMR)->containerOuter.containerKeys.DeviceKey.fValid )             \

#define XMR_IS_ECC_DEVICE_KEY_VALID( plicenseXMR )                               \
    ( (plicenseXMR)->containerOuter.fValid                                       \
   && (plicenseXMR)->containerOuter.containerKeys.fValid                         \
   && (plicenseXMR)->containerOuter.containerKeys.ECCKey.fValid )                \

#define XMR_IS_RIGHTS_VALID( plicenseXMR )                                       \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.fValid             \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.Rights.fValid )

#define XMR_IS_DOMAIN_ID_VALID( plicenseXMR )                                    \
    ( (plicenseXMR)->containerOuter.fValid                                       \
   && (plicenseXMR)->containerOuter.containerGlobalPolicies.fValid               \
   && (plicenseXMR)->containerOuter.containerGlobalPolicies.DomainID.fValid )

#define XMR_IS_SERIAL_NUMBER_RESTRICTION_VALID( plicenseXMR  )                         \
    ( (plicenseXMR)->containerOuter.fValid                                             \
   && (plicenseXMR)->containerOuter.containerGlobalPolicies.fValid                     \
   && (plicenseXMR)->containerOuter.containerGlobalPolicies.SerialNumber.fValid)       \

#define XMR_IS_EMBEDDING_BEHAVIOR_VALID( plicenseXMR  )                                \
    ( (plicenseXMR)->containerOuter.fValid                                             \
   && (plicenseXMR)->containerOuter.containerGlobalPolicies.fValid                     \
   && (plicenseXMR)->containerOuter.containerGlobalPolicies.EmbeddingBehavior.fValid)  \

#define XMR_IS_GENERATION_NUMBER_VALID( plicenseXMR )           \
    ( (plicenseXMR)->containerOuter.fValid                      \
   && (plicenseXMR)->containerOuter.generationNumber.fValid )   \

#define XMR_IS_UNKNOWN_CONTAINER_VALID( plicenseXMR )           \
    ( (plicenseXMR)->containerOuter.fValid                      \
   && (plicenseXMR)->containerOuter.containerUnknown.fValid )   \

/*
**
**  'Create Thumbnail Image' is an implied right which uses "Play"
**  action to verify if it is allowed or not.
**  Restrictions are:
**    -  license must have unlimited play count
**    -  license must not have any time based restrictions:
**          - Expiration (END) date, Expiration after First Use, Expiration after First Storage
**          - Note that Expiration (BEGIN) date is OK to have
**
*/
#define XMR_IS_THUMBNAIL_VALID( plicenseXMR )                                                                   \
    ( XMR_IS_PLAY_VALID( plicenseXMR )                                                                          \
   && ( !XMR_IS_PLAYCOUNT_VALID( plicenseXMR )                                                                  \
     || ( XMR_IS_PLAYCOUNT_VALID( plicenseXMR )                                                                 \
       && ( ( plicenseXMR )->containerOuter.containerPlaybackPolicies.PlayCount.dwValue == XMR_UNLIMITED ) ) )  \
   && ( !XMR_IS_EXPIRATION_VALID( plicenseXMR )                                                                 \
     || ( ( plicenseXMR )->containerOuter.containerGlobalPolicies.Expiration.dwEndDate == XMR_UNLIMITED ) )     \
   && !XMR_IS_EXPIRATION_AFTER_STORE_VALID( plicenseXMR )                                                       \
   && !XMR_IS_EXPIRATION_AFTER_FIRST_USE_VALID( plicenseXMR ) )

/*
** Check if license should be disabled on clock rollback
*/
#define XMR_HAS_TIME_BASED_RESTRICTIONS( plicenseXMR )                           \
    ( ( plicenseXMR )->containerOuter.fValid                                     \
   && ( plicenseXMR )->containerOuter.containerGlobalPolicies.fValid             \
   && ( ( plicenseXMR )->containerOuter.containerGlobalPolicies.Expiration.fValid\
     || ( plicenseXMR )->containerOuter.containerGlobalPolicies.ExpirationAfterUse.fValid\
     || ( plicenseXMR )->containerOuter.containerGlobalPolicies.ExpirationAfterStore.fValid ) )

#define XMR_IS_EXPIRATION_DATE_VALID( plicenseXMR )                                                 \
    ( ( plicenseXMR )->containerOuter.containerGlobalPolicies.Expiration.dwBeginDate          != 0  \
   || ( plicenseXMR )->containerOuter.containerGlobalPolicies.Expiration.dwEndDate != XMR_UNLIMITED \
   || ( plicenseXMR )->containerOuter.containerGlobalPolicies.ExpirationAfterStore.dwValue    != 0  \
   || ( plicenseXMR )->containerOuter.containerGlobalPolicies.ExpirationAfterUse.dwValue      != 0 )

EXIT_PK_NAMESPACE;

#endif  /* __DRM_XMR_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmxmrparser.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_XMR_PARSER_H__
#define __DRM_XMR_PARSER_H__

#include <drmxmr.h>

ENTER_PK_NAMESPACE;

/*
** There is a finite set of objects which get allocated using
** DRM_STK_Alloc in the XMR parser which can potentially be larger
** than the original raw binary license data they contain.
**
** The smallest size of an XMR object is XMR_BASE_OBJECT_LENGTH.
**
** Therefore, the worst-case license, which contains nothing but
** instances of the highest-bloat object which needs to be allocated
** using DRM_STK_Alloc, will require this many bytes:
**  DRM_XMR_COMPUTED_MAX_UNPACK_ALLOC_FACTOR * sizeof(raw XMR license)
**
** In effect, that constant equals:
**  (Space needed for the Highest-Bloat object)
**    / (Smallest size that object could be in the raw XMR license)
**
** However, DRM_XMR_MAX_UNPACK_ALLOC_FACTOR is what should primarily
** be used by callers of DRM_XMR_UnpackLicense because that will
** ensure consistent allocation behavior on on architectures.
** Note: Inside DRM_XMR_UnpackLicense, there is a compile-time assert
** to validate that:
**     DRM_XMR_MAX_UNPACK_ALLOC_FACTOR
**  >= DRM_XMR_COMPUTED_MAX_UNPACK_ALLOC_FACTOR
**
** Therefore, callers of DRM_XMR_UnpackLicense that don't want
** to worry about potentially running out of space should ensure
** that f_pStack contains at least this many bytes:
**  (DRM_XMR_MAX_UNPACK_ALLOC_FACTOR * f_cbLicense)
**
** Additional notes about DRM_XMR_COMPUTED_MAX_UNPACK_ALLOC_FACTOR:
**  The extra "+ ( SIZEOF(DRM_DWORD_PTR) - 1 )" is due to the
**   fact that the memory allocation may need to be aligned.
**  The extra "+ 1" is due to the fact that the division will
**   round down.
*/

#define DRM_XMR_COMPUTED_MAX_UNPACK_ALLOC_FACTOR                                        \
    ( ( ( MAX(                                                                          \
              MAX(                                                                      \
                  MAX( SIZEOF(DRM_XMR_UNKNOWN_CONTAINER),                               \
                       SIZEOF(DRM_XMR_UNKNOWN_OBJECT) ),                                \
                  MAX( SIZEOF(DRM_XMR_VIDEO_OUTPUT_CONFIGURATION_LIST),                 \
                       SIZEOF(DRM_XMR_AUDIO_OUTPUT_CONFIGURATION_LIST) ) ),             \
              SIZEOF( DRM_XMR_POLICY_METADATA_LIST ) )                                  \
        + ( SIZEOF(DRM_DWORD_PTR) - 1 ) )                                               \
    / XMR_BASE_OBJECT_LENGTH ) + 1 )

#define DRM_XMR_MAX_UNPACK_ALLOC_FACTOR 7

DRM_API DRM_RESULT DRM_CALL DRM_XMR_UnpackLicense(
    IN  const   DRM_BYTE                    *f_pbLicense,
    IN          DRM_DWORD                    f_cbLicense,
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    OUT         DRM_XMR_LICENSE             *f_pXmrLicense );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_GetContainer(
    IN  const   DRM_BYTE                     *f_pbLicense,
    IN          DRM_DWORD                     f_cbLicense,
    IN          DRM_WORD                      f_wContainerType,
    IN          DRM_STACK_ALLOCATOR_CONTEXT  *f_pstack,
    IN  OUT     DRM_VOID                     *f_pvContainer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_PopulateInclusionList(
    IN          DRM_XMR_INCLUSION_LIST       *f_pInclusionList,
    IN OUT      DRM_GUID                      f_rgInclusionList[DRM_MAX_INCLUSION_GUIDS],
    IN OUT      DRM_BOOL                      f_rgfGuidValid[DRM_MAX_INCLUSION_GUIDS][DRM_MAX_LICENSE_CHAIN_DEPTH],
    IN          DRM_DWORD                     f_dwChainDepth );

/******************************************************************************
**
** Function :   DRM_XMR_ValidateLicenseObjects
**
** Synopsis :   Determines if the objects in the given license conform
**                  to the XMR specification based on the license's version
**
** Arguments :
**      [f_pXmrLicense]   : License to validate
**
** Returns :    DRM_SUCCESS             if the license is valid
**              DRM_E_INVALIDLICENSE    if the license is not valid
**              DRM_E_INVALIDARG        if f_pXmrLicense is NULL
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL DRM_XMR_ValidateLicenseObjects(
    IN          DRM_XMR_LICENSE             *f_pXmrLicense );

/******************************************************************************
**
** Function :   DRM_XMR_PARSE
**
** Synopsis :   Function Prototype to parse a serialized object buffer
**
** Arguments :
**      [f_pStack]   : Stack for intermediate usage
**      [f_pbBuffer] : Object Buffer
**      [f_iObject]  : Index marking beginning of object in the buffer
**      [f_cbObject] : Size of serialized object
**      [f_pvObject] : Actual object returned as void
**
** Returns :
**
** Notes :      Callers must keep the stack around as long as they use the
**              contents of the structure returned. The structure might have
**              some intermediate nodes allocated out of this stack
**
******************************************************************************/
typedef DRM_RESULT  ( DRM_CALL *DRM_XMR_PARSE )(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_Invalid(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_MinimumEnvironment(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_SecurityLevel(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_OPLs(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_Empty(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_UnknownContainer(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbLicense,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_UnknownObject(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_WORD(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_DWORD_Versioned(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_DWORD(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_GUID(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_GUIDLIST(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_BYTEARRAY(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_DomainID(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_VideoOutputConfig(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_AudioOutputConfig(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_ContentKey(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_Expiration(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_PlaylistBurnRights(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_RsaPubkey(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_EccDevicekey(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_UserID(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_UplinkKID(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_UplinkKID2(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_OuterContainer(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_GlobalContainer(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_PlaybackContainer(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_ExplicitAnalogVideoOutputProtectionContainer(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_ExplicitDigitalAudioOutputProtectionContainer(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_PolicyMetadata(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbLicense,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_RevocationContainer(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbLicense,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_KeyMaterialContainer(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_Signature(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_CopyToPCContainer(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE                    *f_pbLicense,
    IN          DRM_DWORD                    f_iObject,
    IN          DRM_DWORD                    f_cbObject,
    IN  OUT     DRM_VOID                    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_CopyContainer(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_PlaylistBurnContainer(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_PlaylistBurnRights(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Parse_OptimizedContentKey(
    IN          DRM_STACK_ALLOCATOR_CONTEXT *f_pStack,
    IN  const   DRM_BYTE    *f_pbBuffer,
    IN          DRM_DWORD    f_iObject,
    IN          DRM_DWORD    f_cbObject,
    IN  OUT     DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_FindObject(
    IN        DRM_WORD         f_wObjectType,
    IN  const DRM_BYTE        *f_pbLicense,
    IN        DRM_DWORD        f_cbLicense,
    OUT       DRM_DWORD       *f_piObject,
    OUT       DRM_DWORD       *f_pcbObject );

typedef struct
{
    DRM_XMR_PARSE           fnParse;
    DRM_BOOL                rgfIsVersionSupported[XMR_VERSION_MAX];
} XMR_PARSER_INTERNAL_DEFINES;

EXIT_PK_NAMESPACE;

#endif  /* __DRM_XMR_PARSER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmxmrbuilder.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_XMR_BUILDER_H__
#define __DRM_XMR_BUILDER_H__

#include <drmxmr.h>

ENTER_PK_NAMESPACE;

#define XMR_AES_OMAC_SIGNATURE_LENGTH     16
#define XMR_SHA256_HMAC_SIGNATURE_LENGTH  32
#define XMR_XPOLICY_HEADER_LEN 8

typedef struct __tagDRM_XMR_BUILDER_NODE
{
    DRM_WORD     wType;
    DRM_DWORD    cbLength;
    /*
    ** This can either be an object or a linked list of
    ** builder nodes depending on whether this is a
    ** leaf node or not
    */
    const DRM_VOID *pvObject;
} DRM_XMR_BUILDER_NODE;

typedef struct __tagDRM_XMR_BUILDER_LISTNODE
{
    DRM_XMR_BUILDER_NODE                  Node;
    struct __tagDRM_XMR_BUILDER_LISTNODE *pNext;
} DRM_XMR_BUILDER_LISTNODE;

typedef struct __tagDRM_XMR_BUILDER_UNKNOWNOBJECT_LISTNODE
{
    DRM_XMR_BUILDER_LISTNODE listNode;
    DRM_BOOL                 fDuplicateAllowed;
    DRM_WORD                 wFlags;
    DRM_WORD                 wParent;
    struct __tagDRM_XMR_BUILDER_UNKNOWNOBJECT_LISTNODE     *pNext;

} DRM_XMR_BUILDER_UNKNOWNOBJECT_LISTNODE;

typedef struct __tagDRM_XMR_BUILDER_CONTEXT_INTERNAL
{
    const DRM_ID                             *pidRights;
    DRM_DWORD                                 dwVersion;
    /*  In case of nodes which can have duplicates, the array below will hold the
    **  pointer to the last node of that type. In those cases, it is just used
    **  to keep track of the types of nodes added
    */
    DRM_XMR_BUILDER_NODE                    **rgpObjectNodes;
    DRM_XMR_BUILDER_UNKNOWNOBJECT_LISTNODE   *pUnknownObjects;
    DRM_STACK_ALLOCATOR_CONTEXT               contextStack;
} DRM_XMR_BUILDER_CONTEXT_INTERNAL;

#define DRM_XMR_BUILDER_CONTEXT_BUFFER_SIZE SIZEOF( DRM_XMR_BUILDER_CONTEXT_INTERNAL )

typedef struct __tagDRM_XMR_BUILDER_CONTEXT
{
    /*
    ** This data is Opaque.  Do not set any value in it.
    */
    DRM_BYTE rgbOpaqueBuffer[__CB_DECL( DRM_XMR_BUILDER_CONTEXT_BUFFER_SIZE )];
} DRM_XMR_BUILDER_CONTEXT;

DRM_API DRM_RESULT DRM_CALL DRM_XMR_StartLicense(
    __inout_bcount( f_cbStack ) DRM_BYTE                *f_pbStack,
    __in                        DRM_DWORD                f_cbStack,
    __in_ecount( 1 )      const DRM_ID                  *f_pidRights,
    __in                        DRM_DWORD                f_dwVersion,
    __inout_ecount( 1 )         DRM_XMR_BUILDER_CONTEXT *f_pcontextBuilder );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_InitializeObject(
    __in                DRM_WORD    f_wObjectType,
    __inout_ecount( 1 ) DRM_VOID   *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_AddObject(
    __inout_ecount( 1 )    DRM_XMR_BUILDER_CONTEXT *f_contextBuilder,
    __in                   DRM_WORD                 f_wObjectType,
    __in_ecount( 1 ) const DRM_VOID                *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_AddUnknownObject(
    __inout_ecount( 1 )                 DRM_XMR_BUILDER_CONTEXT *f_pcontextBuilder,
    __in                                DRM_WORD                 f_wObjectType,
    __in                                DRM_BOOL                 f_fDuplicateAllowed,
    __in                                DRM_WORD                 f_wParent,
    __in                                DRM_WORD                 f_wFlags,
    __in_bcount_opt( f_cbObject ) const DRM_BYTE                *f_pbObject,
    __in                                DRM_DWORD                f_cbObject );

DRM_API DRM_RESULT DRM_CALL  DRM_XMR_AddUnknownHierarchy (
    __inout_ecount( 1 )  DRM_XMR_BUILDER_CONTEXT_INTERNAL        *f_pcontextBuilder,
    __inout_ecount( 1 )  DRM_XMR_BUILDER_UNKNOWNOBJECT_LISTNODE  *f_plistnode );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_CreateExtensibleRestriction(
    __in_ecount( 1 )  const                   DRM_XMR_BUILDER_CONTEXT *f_pcontextBuilder,
    __in_bcount( f_wPolicyLen )               DRM_BYTE                *f_pbPolicy,
    __in                                      DRM_WORD                 f_wPolicyLen,
    __in                                      DRM_DWORD                f_dwSecureDataSize,
    __in                                      DRM_BYTE                 f_bStateType,
    __in_bcount( f_dwStateLen )               void                    *f_pvState,
    __in                                      DRM_WORD                 f_dwStateLen,
    __deref_inout_bcount( *f_cbRestriction )  DRM_BYTE               **f_ppbRestriction,
    __inout_ecount( 1 )                       DRM_DWORD               *f_cbRestriction );

/*
** Filters objects which are NOT must understand AND have a minimum
** version HIGHER than the specified verion
*/
DRM_API DRM_RESULT DRM_CALL DRM_XMR_FilterNonMustUnderstandObjectsByVersion(
    __in_ecount( 1 )       DRM_XMR_LICENSE  *f_pXmrLicense,
    __in                   DRM_DWORD         f_dwVersion );

/******************************************************************************
**
** Function :   DRM_XMR_CB_SIGNATURE
**
** Synopsis :   Callback function provided by caller of XMR Builder APIs to
**              create a signature using the integrity key. Integrity key is not
**              passed to the builder APIs for security reasons. In the client,
**              the clear integrity key should stay within the blackbox.
**
** Arguments :  f_pvSignatureContext  - Context needed by caller to retrieve
**                                      appropriate integrity key
**              f_pbData              - Data to be signed
**              f_cbData              - Lentgth of pbData
**              f_pbSignatureBuffer   - Buffer in which to put the signature
**              f_cbSignatureBuffer   - Length of signature buffer
**              f_ibSignatureBuffer   - Index in buffer at which signature should
**                                      be put
**
** Returns :
**
** Notes :
**
******************************************************************************/
typedef DRM_RESULT ( DRM_CALL *DRM_XMR_CB_SIGNATURE )(
    __in                                const DRM_VOID  *f_pvSignatureContext,
    __in_bcount( f_cbData )             const DRM_BYTE  *f_pbData,
    __in                                const DRM_DWORD  f_cbData,
    __out_bcount( f_cbSignatureBuffer )       DRM_BYTE  *f_pbSignatureBuffer,
    __in                                const DRM_DWORD  f_cbSignatureBuffer,
    __in                                const DRM_DWORD  f_ibSignatureBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_FinishLicense (
    __in_ecount( 1 ) const              DRM_XMR_BUILDER_CONTEXT *f_pcontextBuilder,
    __in_ecount( 1 ) const              DRM_VOID                *f_pvSignatureContext,
    __in                                DRM_XMR_CB_SIGNATURE     f_pfnSignature,
    __inout_bcount_opt( *f_pcbLicense ) DRM_BYTE                *f_pbLicense,
    __inout_ecount( 1 )                 DRM_DWORD               *f_pcbLicense );

/******************************************************************************
**
** Function :   DRM_XMR_SERIALIZE
**
** Synopsis :   Function Prototype to serialize the object ( sans the base ). The
**              base is assumed to have been serialized already.
**
** Arguments :
**      [f_pvObjectActual] : Object passed as void
**      [f_pbBuffer]       : Buffer in which to put the serialized object
**      [f_piBuffer]       : Index of buffer from where to start
**
** Returns :
**
** Notes :      It is assumed that the buffer has enough space to hold the
**              entire object. This is ensured because of the buffer calculation
**              before serialization begins
**
******************************************************************************/
typedef DRM_RESULT  ( DRM_CALL *DRM_XMR_SERIALIZE )(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

/******************************************************************************
**
** Function :   DRM_XMR_SET_DEFAULTS
**
** Synopsis :   Function Prototype to set the defaults in the object
**
** Arguments :
**      [f_pvObject] : Actual object passed as void
**
******************************************************************************/
typedef DRM_RESULT ( DRM_CALL *DRM_XMR_SET_DEFAULTS )( __in_ecount( 1 ) const DRM_VOID *f_pvObject );

/******************************************************************************
**
** Function :   DRM_XMR_PARSE_STRUCTURE
**
** Synopsis :   Function Prototype to parse the structure of a container and add
**              the children to the builder context
**
** Arguments :  f_pcontextBuilder - builder context
**              f_pvObject - Actual object passed as void
**
** Notes     :  This will add all the children of this container and also update
**              the length of f_pvObject
**
******************************************************************************/
typedef DRM_RESULT ( DRM_CALL *DRM_XMR_PARSE_STRUCTURE )(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject );

DRM_BOOL DRM_XMR_IsDuplicateAllowed( __in_ecount( 1 ) const DRM_XMR_BUILDER_LISTNODE *f_plistnode );

DRM_WORD DRM_XMR_GetParent( __in_ecount( 1 ) const DRM_XMR_BUILDER_LISTNODE *f_plistnode );

DRM_XMR_BUILDER_NODE* _DRM_XMR_GetBuilderNode(
    __in_ecount( 1 )  const DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in                    DRM_WORD                             f_wType );

DRM_API DRM_VOID DRM_CALL DRM_XMR_Serialize_BaseObject(
    __in                                                   DRM_WORD    f_wType,
    __in                                                   DRM_DWORD   f_dwLength,
    __inout_bcount( XMR_BASE_OBJECT_LENGTH + *f_piBuffer ) DRM_BYTE   *f_pbBuffer,
    __inout_ecount( 1 )                                    DRM_DWORD  *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_Container(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_DWORD DRM_CALL DRM_XMR_GetObjectLength(
    __in             DRM_WORD    f_wType,
    __in_opt const   DRM_VOID   *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_Invalid( __in_ecount( 1 ) const DRM_VOID *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_Invalid(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_ParseStructure_Invalid(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_MinimumEnvironment(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_MinimumEnvironment(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_SecurityObject(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_OPLs(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_GenerationNumber(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_OPLs(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_Empty(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_WORD(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_WORD(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_DomainID(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_EccDevicekey(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_GenerationNumber(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_UnknownObject(
    __in_ecount( 1 )  const                    DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer )               DRM_BYTE    *f_pbBuffer,
    __in                                       DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )                        DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_DWORD(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_DWORD(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_DWORD_Versioned(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_GUID(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_GUID(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_GUIDLIST(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_GUIDLIST(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_BYTEARRAY(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_BYTEARRAY(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_VideoOutputConfig(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_AudioOutputConfig(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_VideoOutputConfig(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_AudioOutputConfig(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_PolicyMetadata(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_ContentKey(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_ContentKey(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_Expiration(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_Expiration(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_PlaylistBurnRights(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_PlaylistBurnRights(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_RsaPubkey(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_RsaPubkey(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_UserID(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_UserID(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_UplinkKID(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_UplinkKID(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_UplinkKID2(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_Serialize_OptimizedContentKey(
    __in_ecount( 1 )  const      DRM_VOID    *f_pvObject,
    __inout_bcount( f_cbBuffer ) DRM_BYTE    *f_pbBuffer,
    __in                         DRM_DWORD    f_cbBuffer,
    __inout_ecount( 1 )          DRM_DWORD   *f_piBuffer );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_OuterContainer(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_ParseStructure_OuterContainer(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_GlobalContainer(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_ParseStructure_GlobalContainer(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_PlaybackContainer(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_ParseStructure_CopyToPCContainer(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_ParseStructure_PlaybackContainer(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_ExplicitAnalogVideoOutputProtectionContainer(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_ExplicitDigitalAudioOutputProtectionContainer(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_PolicyMetadata(
    __in_ecount( 1 ) const  DRM_VOID  *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_ParseStructure_ExplicitAnalogVideoOutputProtectionContainer(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_ParseStructure_ExplicitDigitalAudioOutputProtectionContainer(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_ParseStructure_PolicyMetadata(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_KeyMaterialContainer(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_ParseStructure_RevocationContainer(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_ParseStructure_KeyMaterialContainer(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_CopyContainer(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_ParseStructure_CopyContainer(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_PlaylistBurnContainer(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_ParseStructure_PlaylistBurnContainer(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_PlaylistBurnRights(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_ParseStructure_PlaylistBurnRights(
    __inout_ecount( 1 )     DRM_XMR_BUILDER_CONTEXT_INTERNAL    *f_pcontextBuilder,
    __in_ecount( 1 ) const  DRM_VOID                            *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_NoOP(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_Rights(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_Issuedate(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_GracePeriod(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_Priority(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_IssueDate(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_ExpirationAfterFirstUse(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_ExpirationAfterFirstStore(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_Playcount(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_CopyProtectionLevel(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_CopyCount(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_SourceID(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_OptimizedContentKey(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

DRM_API DRM_RESULT DRM_CALL DRM_XMR_SetDefaults_EmbeddingBehavior(
    __in_ecount( 1 )  const   DRM_VOID    *f_pvObject );

typedef struct
{
    DRM_XMR_SET_DEFAULTS    fnSetDefaults;
    DRM_XMR_SERIALIZE       fnSerialize;
    DRM_XMR_PARSE_STRUCTURE fnParseStructure;
    DRM_BOOL                fDuplicateAllowed;
    DRM_BOOL                fIsOptional;
    DRM_DWORD               cbStructureSize;
} XMR_BUILDER_INTERNAL_DEFINES;

EXIT_PK_NAMESPACE;

#endif  /* __DRM_XMR_BUILDER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drm_msdbpk_manager.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*  File drm_msdb_pk_manager.h - Public interface for Copy From Device PK
**  The purpose of this PK is local authoring of content with WM DRM protection:
**  1. Processing of CRL package, validation and saving of it.
**  2. Local encryption of content into WM DRM and creation of DRM header.
**  3. Issue of license for playback ( decryption ) of content
*/

#ifndef __DRM_MSDB_PK_MANAGER_H__
#define __DRM_MSDB_PK_MANAGER_H__

/* Includes required headers for drm_msdbpk_manager.h */
#include <drmcommon.h>
#include <drmcontextsizes.h>
#include <drmmanager.h>
#include <drmoutputleveltypes.h>
#include <drmcfdalloc.h>
#include <drmcfdtypes.h>
#include <drmkeygenerator.h>


ENTER_PK_NAMESPACE;

#define DRM_POLICY_VERSION1     0x00000001

/*
** Maximum character count for the custom data in generation of Encryption header
*/
#define DRM_MGR_MAX_CUSTOM_DATA_LENGTH 1024

/*
** Maximum number of CRL types supported per device certificate
**  - Device Revocation
**  - WMDRMNET Revocation
**  - Application Revocation
**  - <future placeholder>
*/
#define DRM_MGR_MAX_CRL_TYPE             4


/*
** Device Certificate Clock Support Values:
*/
#define DRM_MGR_DEVCERT_NO_CLOCK            0
#define DRM_MGR_DEVCERT_ANTIROLLBACK_CLOCK  1
#define DRM_MGR_DEVCERT_SECURE_CLOCK        2


typedef enum __tag_DRM_ENCRYPT_KEY_TYPE
{
    DRM_ENCRYPT_KEY_RC4 = 0,  /* type of key used by XML simple of leaf licenses */

    DRM_ENCRYPT_KEY_DES,      /* type of key used by XML root licenses */

    DRM_ENCRYPT_KEY_AES_128   /* type of key used by all XMR licenses */

} DRM_ENCRYPT_KEY_TYPE;


/**********************************************************************
** Structure for encryption keys context.
** There are 3 values for encryption keys context:
**  1. Key ID
**  2. RC4 Content key or DES root license key or AES key for PlayReady content.  Initialized as SHA( Seed, KID )
**  3. Enumeration value that tells type of the key in rgbKey. ( Content key or DES root key or AES key. )
***********************************************************************/

typedef struct __tagDRM_ENCRYPT_KEY_CONTEXT
{

    /* Key ID */
    DRM_KID                 keyID;

    /* Buffer for an encryption key storage long enough to fit all supported key types */
    DRM_BYTE                rgbKey[__CB_DECL(DRM_AES_KEYSIZE_128)];

    /* Type of rgbKey data */
    DRM_ENCRYPT_KEY_TYPE    eKeyType;
} DRM_ENCRYPT_KEY_CONTEXT;


/**********************************************************************
** Structure that keeps context for device certificate.
** There are 9 values for device certificate context:
**  1. Type of the public key.
       It could be ECC160 pbulic key ( DRM_ECC160_PUBLIC_KEY_LEN = 40 )
**     Or could be ECC256 pbulic key ( ECC_P256_POINT_SIZE_IN_BYTES = 64 )
**  2. Public key of device.
**  3. GUID(s) of revocation CRL(s) supported by device.
**  4. Count of the CRL(s) supported by device.
**  5. Boolean flag that tells if Symmetric Optimizations are supported.
**  6. The Symmetric Optimization data for this "session".
**  7. Group security level of the remote device.
**  8. Boolean flag that tells if Metering is supported.
**  9. Boolean flag that tells if License Sync is supported.
**  10.Indicates the type of clock supported on the device.
***********************************************************************/
typedef enum __tag_DRM_PUBLIC_KEY_TYPE
{
    DRM_PUBLIC_KEY_NONE = 0,
    DRM_PUBLIC_KEY_ECC160,
    DRM_PUBLIC_DEVICE_KEY_ECC256,
    DRM_PUBLIC_DOMAIN_KEY_ECC256,
    DRM_PUBLIC_PC_KEY_ECC256,
    DRM_PUBLIC_SILVERLIGHT_KEY_ECC256
} DRM_PUBLIC_KEY_TYPE;

typedef struct __tagDRM_DEVICE_CERT_CONTEXT
{
    DRM_PUBLIC_KEY_TYPE eDevicePubKeyType;
    PUBKEY_P256         devicePubKey;
    DRM_GUID            domainAccountID;
    DRM_DWORD           dwDomainRevision;
    DRM_GUID            drmCRLGUID[DRM_MGR_MAX_CRL_TYPE];
    DRM_DWORD           dwNumCRLTypesSupported;
    DRM_BOOL            fSymmetricOptimizationsSupported;
    DRM_SYMDATA         symmetricData;
    DRM_DWORD           dwSecurityLevel;
    DRM_BOOL            fMeteringSupported;
    DRM_BOOL            fLicenseSyncSupported;
    DRM_DWORD           dwClockTypeSupported;
} DRM_DEVICE_CERT_CONTEXT;


/*********************************************************************
** Structure for the license policy.
** The policy structure supports following functionality:
**
**   dwPriority     - Priority for the license.
**
**   Expiration of the content. Two fields are used:
**   startExprDate - start date when user may play the content.
**   endExprDate   - end date. After this date user cannot play the content.
**
**   Output level protection.
**   opl - structure keeps values of output protection level.
**
**   dwSourceID - Source ID of the content.
**
**   ExtendedAnalogVideoProtection_type - GUID with type of video output protection.
**   dwExtendedAnalogVideoProtection_config - configuration valud for video output protection.
**
**   dwInclusionGUIDCount - count of used ( filled ) GUIDs in inclusion list
**   InclusionList        - Array of GUID's for inclusion list. Maximum size of array is 20.
**                          Inclusion list is list of GUID's included into license under node <INCLUSIONLIST>
**                          Each GUID has specific ( some may be added in future ) meaning and provides additional rights for license policy
**
**   dwSecurityLevel - Minimum security level for the content.
**   Device with security level below the one specified in license should not be able to play the content.
**
**   rgwchMeteringID - metering ID for the license. Metering ID is 24 charaters UNICODE string.
**                     It is not NULL terminated string, 24 characters are always used for this string.
**
**   dwExpireOnStoreHours - number of hours to expire license after it was stored.
**   dwPlayCount          - maximum play  count for this file.
**   clockRollBackOption  - option to enable clock rollback policies in license
**
**   dwGracePeriod - Duration of the grace period in hours. Grace period is a time when content use allowed after resetting of device clock.
**
**   dwUsedFields - this flag provides options for using of fields in DRM_LICENSE_POLICY structure
**
**   DRM_LIC_POLICY_USE_EXPIRATIONDATE        - endExprDate will be used and added to the license
**   DRM_LIC_POLICY_USE_BEGINDATE             - startExprDate will be used and added to the license
**   DRM_LIC_POLICY_USEOPL                    - OPL will be used and output protection levels added to the license
**   DRM_LIC_POLICY_USEEXTVIDEOPROT           - Extended video protection type and config will be added to the license
**   DRM_LIC_POLICY_USESOURCEID               - dwSourceID will be used and added to the license
**   DRM_LIC_POLICY_USEMETERINGID             - rgwchMeteringID will be used and metering ID tag added to the license
**   DRM_LIC_POLICY_USE_PLAYCOUNT             - dwPlayCount will be used and play count support added to the license
**   DRM_LIC_POLICY_EXPIRE_ON_STORE           - dwExpireOnStoreHours will be used and expiration of license after string it will be enabled.
**   DRM_LIC_POLICY_GRACE_PERIOD              - dwGracePeriod will be used and grace period will be enabled in the license.
**   DRM_LIC_POLICY_DISABLE_ON_CLOCK_ROLLBACK - <ONCLOCKROLLBACK> tag will be added to the license with a statement that disables the license if the clock is rolled-back
**   DRM_LIC_POLICY_EXPIRE_AFTER_FIRST_USE    - license will expire after immediately after the first time it is used
**   DRM_LIC_POLICY_USE_WMDRMNET_REV_INDEX    - Insert the supplied WMDRMNET CRL version requirement into the license
**   DRM_LIC_POLICY_USE_DEVICE_REV_INDEX      - Insert the supplied Device CRL version requirement into the license
**
***********************************************************************/

#define DRM_LIC_POLICY_USE_EXPIRATIONDATE         0x00000001
#define DRM_LIC_POLICY_USE_BEGINDATE              0x00000002
#define DRM_LIC_POLICY_USEOPL                     0x00000004
#define DRM_LIC_POLICY_USEEXTVIDEOPROT            0x00000008
#define DRM_LIC_POLICY_USESOURCEID                0x00000010
#define DRM_LIC_POLICY_USEMETERINGID              0x00000020
#define DRM_LIC_POLICY_USE_PLAYCOUNT              0x00000040
#define DRM_LIC_POLICY_EXPIRE_ON_STORE            0x00000080
#define DRM_LIC_POLICY_GRACE_PERIOD               0x00000100
#define DRM_LIC_POLICY_DISABLE_ON_CLOCK_ROLLBACK  0x00000200
#define DRM_LIC_POLICY_EXPIRE_AFTER_FIRST_USE     0x00000400
#define DRM_LIC_POLICY_USE_WMDRMNET_REV_INDEX     0x00000800
#define DRM_LIC_POLICY_USE_DEVICE_REV_INDEX       0x00001000
#define DRM_LIC_POLICY_USE_REVINFO_INDEX          0x00002000

typedef struct __tagDRM_LICENSE_POLICY

{   DRM_DWORD                               dwLicensePolicyVersion;
    DRM_DWORD                               dwPriority;
    DRMSYSTEMTIME                           startExprDate;
    DRMSYSTEMTIME                           endExprDate;
    DRM_MINIMUM_OUTPUT_PROTECTION_LEVELS    opl;
    DRM_GUID                                ExtendedAnalogVideoProtection_type;
    DRM_DWORD                               dwExtendedAnalogVideoProtection_config;
    DRM_DWORD                               dwInclusionGUIDCount;
    DRM_GUID                                InclusionList[DRM_MAX_INCLUSION_GUIDS];
    DRM_DWORD                               dwSourceID;
    DRM_DWORD                               dwSecurityLevel;
    DRM_WCHAR                               rgwchMeteringID[__CB_DECL(CCH_BASE64_EQUIV(DRM_ID_SIZE))];
    DRM_DWORD                               dwExpirationHours;
    DRM_DWORD                               dwPlayCount;
    DRM_DWORD                               dwGracePeriod;
    DRM_DWORD                               dwWMDRMNETRevIndex;
    DRM_DWORD                               dwDEVICERevIndex;
    DRM_DWORD                               dwRevInfoIndex;
    DRM_DWORD                               dwUsedFields;
} DRM_LICENSE_POLICY;

DRM_API DRM_RESULT DRM_CALL Drm_Msdb_InitDeviceCertificateContext
(
    __inout                               DRM_APP_CONTEXT         *f_poAppContext,
    __inout_opt                           DRM_VOID                *f_pOEMContext,
    __in_bcount(f_cbDevCertData)    const DRM_BYTE                *f_pbDevCertData,
    __in                            const DRM_DWORD                f_cbDevCertData,
    __in_bcount_opt(f_cbDomainCert) const DRM_BYTE                *f_pbDomainCert,
    __in                            const DRM_DWORD                f_cbDomainCert,
    __out                                 DRM_DEVICE_CERT_CONTEXT *f_pCertContext,
    __out                                 DRM_DWORD               *f_pdwFlags
);

DRM_API DRM_RESULT DRM_CALL Drm_Msdb_InitEncryptionKeys
(
    __in_opt                         const DRM_KID                 *f_pKeyID,
    __in_bcount_opt(f_cbKey)         const DRM_BYTE                *f_pbKey,
    __in                             const DRM_DWORD                f_cbKey,
    __in_ecount_nz_opt(f_cchKeySeed) const DRM_WCHAR               *f_pwchKeySeed,
    __in                             const DRM_DWORD                f_cchKeySeed,
    __in                             const DRM_ENCRYPT_KEY_TYPE     f_eKeyType,
    __out                                  DRM_ENCRYPT_KEY_CONTEXT *f_pKeysContext
);

DRM_API DRM_RESULT DRM_CALL Drm_Msdb_CreateEncryptionHeader
(
    __in                              const DRM_CONTENT_SET_PROPERTY  f_eHeaderType,
    __in                              const DRM_ENCRYPT_KEY_CONTEXT  *f_pContentKeyCtx,
    __in                              const DRM_CONST_STRING          f_dstrDomainID,
    __in                              const DRM_CONST_STRING          f_dstrAcquisitionURL,
    __in                              const DRM_CONST_STRING          f_dstrUI_URL,
    __in                              const DRM_CONST_STRING          f_dstrCustomData,
    __in                              const DRM_DWORD                 f_dwContentID,
    __in_opt                          const DRM_PRIVATE_KEY          *f_pHDRSignKey,
    __out_ecount_z_opt(*f_pcchHeader)       DRM_WCHAR                *f_pwzHeader,
    __inout                                 DRM_DWORD                *f_pcchHeader
);

DRM_API DRM_RESULT DRM_CALL Drm_Msdb_InitEncrypt
(
    __in  const DRM_ENCRYPT_KEY_CONTEXT *f_pKeysContext,
    __out       DRM_CIPHER_CONTEXT      *f_pEncryptContext
);

DRM_API DRM_RESULT DRM_CALL Drm_Msdb_GenerateCRLUpdateResponse
(
    __inout                                  DRM_APP_CONTEXT            *f_poAppContext,
    __inout_opt                              DRM_VOID                   *f_pOEMContext,
    __in_ecount_nz_opt(f_cchDevInfo)   const DRM_WCHAR                  *f_pchDevInfo,
    __in                               const DRM_DWORD                   f_cchDevInfo,
    __in                               const DRM_DEVICE_CERT_CONTEXT    *f_pCertContext,
    __out_ecount_z_opt(*f_pcchCRLResp)       DRM_CHAR                   *f_pszCRLResp,
    __inout                                  DRM_DWORD                  *f_pcchCRLResp,
    __out                                    DRM_BOOL                   *f_pfIsDeviceUpdateRequired
);

DRM_API DRM_RESULT DRM_CALL Drm_Msdb_GenerateSimpleLicenseResponse
(
    __inout                                      DRM_APP_CONTEXT         *f_poAppContext,
    __inout_opt                                  DRM_VOID                *f_pOEMContext,
    __in                                   const DRM_ENCRYPT_KEY_CONTEXT *f_pContKeyContext,
    __in                                   const DRM_DEVICE_CERT_CONTEXT *f_pCertContext,
    __in                                   const DRM_LICENSE_POLICY      *f_pLicensePolicy,
    __out_ecount_z_opt(*f_pcchLicenseResp)       DRM_CHAR                *f_pwszLicenseResp,
    __inout                                      DRM_DWORD               *f_pcchLicenseResp
);

DRM_API DRM_RESULT DRM_CALL Drm_Msdb_GenerateRootLicenseResponse
(
    __inout                                      DRM_APP_CONTEXT         *f_poAppContext,
    __inout_opt                                  DRM_VOID                *f_pOEMContext,
    __in                                   const DRM_ENCRYPT_KEY_CONTEXT *f_pRootKeyContext,
    __in                                   const DRM_DEVICE_CERT_CONTEXT *f_pCertContext,
    __in                                   const DRM_LICENSE_POLICY      *f_pLicensePolicy,
    __out_ecount_z_opt(*f_pcchLicenseResp)       DRM_CHAR                *f_pwszLicenseResp,
    __inout                                      DRM_DWORD               *f_pcchLicenseResp
);

DRM_API DRM_RESULT DRM_CALL Drm_Msdb_GenerateLeafLicenseResponse
(
    __inout                                      DRM_APP_CONTEXT         *f_poAppContext,
    __inout_opt                                  DRM_VOID                *f_pOEMContext,
    __in                                   const DRM_ENCRYPT_KEY_CONTEXT *f_pContKeyContext,
    __in                                   const DRM_ENCRYPT_KEY_CONTEXT *f_pRootKeyContext,
    __in                                   const DRM_DEVICE_CERT_CONTEXT *f_pCertContext,
    __in                                   const DRM_LICENSE_POLICY      *f_pLicensePolicy,
    __out_ecount_z_opt(*f_pcchLicenseResp)       DRM_CHAR                *f_pwszLicenseResp,
    __inout                                      DRM_DWORD               *f_pcchLicenseResp
);

#if DRM_SUPPORT_REVOCATION

DRM_API DRM_RESULT DRM_CALL Drm_Revocation_StorePackage(
    __inout                        DRM_APP_CONTEXT *f_poAppContext,
    __in_bcount(f_cbPackage)       DRM_BYTE        *f_pbPackage,
    __in                     const DRM_DWORD        f_cbPackage );

#endif

EXIT_PK_NAMESPACE;

#endif /* __DRM_MSDB_PK_MANAGER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\ecurve.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#ifndef ECURVE_H
#define ECURVE_H 1
#include "bignum.h"
#include "field.h"
#include "bigpriv.h"

ENTER_PK_NAMESPACE;

//
//           This file (ecurve.h) has definitions for
//       elliptic curve operations.


//           Over a field GF(q), where q > 3 is prime,
//       an elliptic curve is all points (x, y) in GF(q) x GF(q)
//       satisfying the Weierstrass equation
//
//                y^2 = x^3 + ax + b,          (4a^3 + 27 b^2 != 0)
//
//       plus a point at infinity.  The points form an abelian group
//       under a well-known addition rule.
//
//           Over GF(2^m), the curve is instead
//
//                 y^2 + xy = x^3 + ax^2 + b   (b != 0)

//       Fields a and b of the struct should have length
//       elng = fdesc->elng.
//       generator should have length 2*elng or be NULL.
//       gorder, the order of generator, should be have length
//       elng+1 or be NULL.

//       Field deallocate is the address to pass to free
//       (unless it is NULL) when the curve becomes inactive.

// Points are usually in affine form, with only x and y.
// When b <> 0,  the point at infinity has x = y = 0.
// When b = 0, the point at infinity has x = 0 and y = 1.
// fdesc.elng digit_t words are used for each of x and y,
// with no gap between them.

Future_Struct(ecurve_t);

typedef DRM_BOOL DRM_CALL ec_exponentiation_t(const digit_t *, const digit_t *, const DRM_DWORD,
                                        digit_t *, const struct ecurve_t*,
                                        struct bigctx_t *f_pBigCtx);


typedef struct ecurve_t {
             const field_desc_t     *fdesc;
             digit_t           *a;
             digit_t           *b;
             digit_t        *generator;  // Generator of cyclic group
                                            // (affine form, x and y)
             digit_t           *gorder;     // Order of cyclic group
             digit_t           *deallocate;
             ec_exponentiation_t *fexpon;   // Special exponentiation code
                                            // Used for Koblitz curves
             DRM_BOOL               free_field; // Flag telling ec_free to call
                                            // Kfree.  For system use only.
             DRM_BOOL               biszero;    // Is b == 0?
             DRM_DWORD           ndigtemps;  // Number of digit_t temporaries
                                            // needed by EC
                                            // addition/subtraction routines:
                                            //
                                            //     ecaffine_addition
                                            //     ecaffine_addition_subtraction                                            
                                            //     ecaffine_on_curve
                                            //     ecaffine_PPQ
                                            //     ecaffine_random
                                            //
                                            // Includes enough for a
                                            // multiplication or inversion
                                            // (or Kmuladd, etc.)
                                            // in the base field.
             DRM_DWORD           lnggorder;  // Number of significant words
                                            // in *gorder, if not NULL.
             reciprocal_1_t     grecip;     // Reciprocal for gorder
} ecurve_t;

/*
** This number (MAX_ECTEMPS) was 5, but has been increased to 8
** because we have gone from 160bit to 256 bit encryption
** and this assumes that the minimum size of digit_t/digit_t 
** types is a 32 bit type
**
** Maximum number of field temporaries needed
** by any EC addition/subtraction/doubling routine,
** including
**
**     ecaffine_addition,
**     ecaffine_addition_subtraction
**     ecaffine_on_curve
**     ecaffine_PPQ
**     ecaffine_random
*/
#define MAX_ECTEMPS 8

DRM_API DRM_BOOL DRM_CALL ecaffine_addition
      (const digit_t *, const digit_t *, digit_t *,
       const DRM_INT, const struct ecurve_t*, digit_t *, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL ecaffine_addition_subtraction
      (const digit_t *, const digit_t *, digit_t *,
       digit_t *, const struct ecurve_t*, digit_t *, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL ecaffine_exponentiation
          (const digit_t *, const digit_t *, const DRM_DWORD, digit_t *,
           const struct ecurve_t*, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL ecaffine_is_infinite(const digit_t *, const struct ecurve_t*, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL ecaffine_multiply_pm1
          (const digit_t *, digit_t *, const DRM_INT, const struct ecurve_t*, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL ecaffine_negate(const digit_t *, digit_t *,
                                   const struct ecurve_t*, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL ecaffine_on_curve(const digit_t *, const struct ecurve_t*,
                                     const DRM_CHAR*, digit_t *, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL ecaffine_PPQ(const digit_t *, const digit_t *,
                                digit_t *, const DRM_INT,
                                const struct ecurve_t*, digit_t *, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL ecaffine_random(digit_t *, const struct ecurve_t*,
                                   digit_t *, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL ecaffine_set_infinite(digit_t *,
                                         const struct ecurve_t*, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL ec_initialize(const digit_t *, const digit_t *,
                                const field_desc_t*, struct ecurve_t*, struct bigctx_t *f_pBigCtx, struct bigctx_t*);

DRM_API DRM_BOOL DRM_CALL ec_free(struct ecurve_t*, struct bigctx_t *f_pBigCtx);     // IN/OUT

DRM_EXTERN_INLINE DRM_BOOL DRM_CALL ecaffine_exponentiation_tabular
          (const digit_t *, const DRM_DWORD, const DRM_DWORD, const digit_t *,
           const DRM_DWORD, digit_t *, const struct ecurve_t*, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL ecaffine_table_construction(const digit_t *, const DRM_DWORD,
                                               const DRM_DWORD, digit_t *,
                                               const struct ecurve_t*, struct bigctx_t *f_pBigCtx);

EXIT_PK_NAMESPACE;

#endif // ECURVE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\drmxmlsigconstants.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_XML_SIG_CONSTANTS_H
#define __DRM_XML_SIG_CONSTANTS_H

#include <drmeccp256.h>

ENTER_PK_NAMESPACE;

/* Well known WMRM ECC-256 public key */
extern const PUBKEY_P256 g_oWMRMECC256PubKey;

/*
** -------------------------------------------------------------
** XML strings used in the construction of signature XML segment
** -------------------------------------------------------------
*/
extern const DRM_ANSI_CONST_STRING g_dastrSigRootTag;

extern const DRM_ANSI_CONST_STRING g_dastrSigSignedInfoTag;

extern const DRM_ANSI_CONST_STRING g_dastrSigCanonicalizationMethodTag;

extern const DRM_ANSI_CONST_STRING g_dastrSigSignatureMethodTag;

extern const DRM_ANSI_CONST_STRING g_dastrSigReferenceTag;

extern const DRM_ANSI_CONST_STRING g_dastrSigDigestMethodTag;

extern const DRM_ANSI_CONST_STRING g_dastrSigDigestValueTag;

extern const DRM_ANSI_CONST_STRING g_dastrSigSignatureValueTag;

extern const DRM_ANSI_CONST_STRING g_dastrSigKeyInfoTag;

extern const DRM_ANSI_CONST_STRING g_dastrSigKeyValueTag;

extern const DRM_ANSI_CONST_STRING g_dastrSigECCKeyValueTag;

extern const DRM_ANSI_CONST_STRING g_dastrSigPublicKeyTag;


extern const DRM_ANSI_CONST_STRING g_dastrSigRootAttribName;
extern const DRM_ANSI_CONST_STRING g_dastrSigRootAttribValue;

extern const DRM_ANSI_CONST_STRING g_dastrSigSignedInfoAttribName;
extern const DRM_ANSI_CONST_STRING g_dastrSigSignedInfoAttribValue;

extern const DRM_ANSI_CONST_STRING g_dastrSigCanonicalizationMethodAttribName;
extern const DRM_ANSI_CONST_STRING g_dastrSigCanonicalizationMethodAttribValue;

extern const DRM_ANSI_CONST_STRING g_dastrSigSignatureMethodAttribName;
extern const DRM_ANSI_CONST_STRING g_dastrSigSignatureMethodAttribValue;

extern const DRM_ANSI_CONST_STRING g_dastrSigDigestMethodAttribName;
extern const DRM_ANSI_CONST_STRING g_dastrSigDigestMethodAttribValue;

extern const DRM_ANSI_CONST_STRING g_dastrSigKeyInfoAttribName;
extern const DRM_ANSI_CONST_STRING g_dastrSigKeyInfoAttribValue;



/*
** -----------------------------------------------------------------------
** XML strings used in the construction of XML encrypted data segment
** -----------------------------------------------------------------------
*/
extern const DRM_ANSI_CONST_STRING g_dastrSigEncryptedDataTag;

extern const DRM_ANSI_CONST_STRING g_dastrSigEncryptionMethodTag;

extern const DRM_ANSI_CONST_STRING g_dastrSigEncryptedKeyTag;

extern const DRM_ANSI_CONST_STRING g_dastrSigCipherDataTag;

extern const DRM_ANSI_CONST_STRING g_dastrSigCipherValueTag;


extern const DRM_ANSI_CONST_STRING g_dastrSigEncryptedDataAttrib1Name;
extern const DRM_ANSI_CONST_STRING g_dastrSigEncryptedDataAttrib1Value;

extern const DRM_ANSI_CONST_STRING g_dastrSigEncryptedDataAttrib2Name;
extern const DRM_ANSI_CONST_STRING g_dastrSigEncryptedDataAttrib2Value;

extern const DRM_ANSI_CONST_STRING g_dastrSigEncryptedDataAttrib3Name;
extern const DRM_ANSI_CONST_STRING g_dastrSigEncryptedDataAttrib3Value;

extern const DRM_ANSI_CONST_STRING g_dastrSigEncryptionMethodAttrib1Name;
extern const DRM_ANSI_CONST_STRING g_dastrSigEncryptionMethodAttrib1Value;

extern const DRM_ANSI_CONST_STRING g_dastrSigEncryptionMethodAttrib2Name;
extern const DRM_ANSI_CONST_STRING g_dastrSigEncryptionMethodAttrib2Value;

extern const DRM_ANSI_CONST_STRING g_dastrSigKeyInfoAttrib1Name;
extern const DRM_ANSI_CONST_STRING g_dastrSigKeyInfoAttrib1Value;

extern const DRM_ANSI_CONST_STRING g_dastrSigKeyNameTag;
extern const DRM_ANSI_CONST_STRING g_dastrSigKeyInfoKeyName1;
extern const DRM_ANSI_CONST_STRING g_dastrSigKeyInfoKeyName2;
extern const DRM_ANSI_CONST_STRING g_dastrSigKeyInfoKeyName3;

extern const DRM_ANSI_CONST_STRING g_dastrKeyInfoKeyNamePath;

extern const DRM_ANSI_CONST_STRING g_dastrSigReferenceAttribName;
extern const DRM_ANSI_CONST_STRING g_dastrSigReferenceAttribValue;

extern const DRM_ANSI_CONST_STRING g_dastrSigEncryptedKeyAttribName;
extern const DRM_ANSI_CONST_STRING g_dastrSigEncryptedKeyAttribValue;

extern const DRM_ANSI_CONST_STRING g_dastrRSAPrefixMSLP;
extern const DRM_ANSI_CONST_STRING g_dastrRSAURIMSLP;
extern const DRM_ANSI_CONST_STRING g_dastrTagRSAKeyPair;

/*
** --------------------------------------------------------
** XML strings used in the parsing of signature XML segment
** --------------------------------------------------------
*/
extern const DRM_ANSI_CONST_STRING g_dastrSigSignedInfoPath;

extern const DRM_ANSI_CONST_STRING g_dastrSigSignatureValuePath;

extern const DRM_ANSI_CONST_STRING g_dastrSigHashPath;

extern const DRM_ANSI_CONST_STRING g_dastrSigPublicKeyPath;



/*
** -------------------------------------------------------------
** XML strings used in the parsing of XML encrypted data segment
** -------------------------------------------------------------
*/
extern const DRM_ANSI_CONST_STRING g_dastrSigKeyInfoPath;

extern const DRM_ANSI_CONST_STRING g_dastrSigEncryptedKeyPath;

extern const DRM_ANSI_CONST_STRING g_dastrSigCipherValuePath;

EXIT_PK_NAMESPACE;

#endif /* __DRM_XML_SIG_CONSTANTS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\fieldpriv.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
/*
      File fieldpriv.h.   Version 20 September 2002

      Declarations for field routines which the application program
      doesn't need to know about.
*/

#ifndef __FIELDPRIV_H
#define __FIELDPRIV_H 1
#include "bigpriv.h"
#include "field.h"

ENTER_PK_NAMESPACE;

DRM_API DRM_BOOL DRM_CALL Kequaler_default (const digit_t *, const digit_t *,
                                     const DRM_DWORD, const field_desc_t*, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL Kfdesc_initialize(field_desc_t*, const DRM_DWORD, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL Kiszeroer_default(const digit_t *, const DRM_DWORD,
                                     const field_desc_t*, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL Kzeroizer_default(digit_t *, const DRM_DWORD,
                                     const field_desc_t*, struct bigctx_t *f_pBigCtx);


EXIT_PK_NAMESPACE;

#endif /* __FIELDPRIV_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\leakybucket.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __LEAKYBUCKET_H
#define __LEAKYBUCKET_H

#define LEAKYBUCKETFLAGS_AUTOADJUST_BITRATE ((DRM_DWORD) 0x1)

ENTER_PK_NAMESPACE;

typedef struct tagASF_LEAKY_BUCKET_CONTEXT
{
    DRM_UINT64      m_hnsBucketSize;
    DRM_DWORD       m_dwBitrate;

    DRM_DWORD       m_dwFlags;

    DRM_UINT64      m_hnsNextLeakTime;

    DRM_UINT64      m_hnsLastLeakTime;
    DRM_DWORD       m_cbLastLeakSize;

    DRM_DWORD       m_dwTotalBitrateAdjust;
    DRM_UINT64      m_hnsLastAutoAdjustInterval;
    DRM_DWORD       m_cbLastAutoAdjustSize;

} ASF_LEAKY_BUCKET_CONTEXT;

DRM_RESULT ASFLeakyBucket_Initialize(
    __out      ASF_LEAKY_BUCKET_CONTEXT * const pAsfLeakyBucketContext,
    __in const DRM_DWORD                        dwBitrate,
    __in const DRM_UINT64                       hnsBucketSize
);

DRM_RESULT ASFLeakyBucket_AddToBucket(
    __inout    ASF_LEAKY_BUCKET_CONTEXT * const pAsfLeakyBucketContext,
    __in const DRM_DWORD                        cbSize,
    __in const DRM_UINT64                       hnsTimestamp,
    __in const DRM_UINT64                       hnsLeakTimeFloor,
    __out      DRM_UINT64               * const phnsLeakTime 
);

EXIT_PK_NAMESPACE;

#endif /* __LEAKYBUCKET_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\field.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#ifndef __FIELD_H
#define __FIELD_H 1
#include "bignum.h"

ENTER_PK_NAMESPACE;

/*
        This file defines field_desc_t, a struct representing a field.
        The data structures allow
        GF(2^m) or GF(q) (with multiple precision q).
        finite-degree extensions.

        The letter `K' is often used in mathematics
        to denote a field.  We use names like Kadd
        for field addition, since the name `Fadd'
        suggests a floating point addition routine.

        A field element is an array of type digit_t.
        The elng element of the field_sesc_t struct tells its length

    Arithmetic routines:

        Kadd(f1, f2, f3, &fdesc) -- f3 = f1 + f2
        Kdiv(f1, f2, f3, &fdesc, ftemps) -- f3 = f1 / f2
                            Array of fdesc->ndigtemps_arith temps supplied
        Kequal (f1, f2,  &fdesc) -- Is f1 == f2?        
        Kimmediate(scalar, f1, &fdesc) -- f1 = scalar (a signed digit_t)
        Kinvert(f1, f2,  &fdesc, ftemps) -- f2 = 1/f1
                            Array of fdesc-->ndigtemps_invert1 supplied
        Kiszero(f1,      &fdesc) -- Is f1 == 0?
        Kmulpower2(f1, ishift, f3, fdesc) -- f3 = f1 * 2^ishift
        Kmul(f1, f2, f3, &fdesc) -- f3 = f1 * f2
        Kmul(f1, f2, f3, &fdesc, ftemps) -- f3 = f1*f2,
                        Array of fdesc->ndigtemps_mul temps supplied        
        Kmuladd(f1, f2, f3, f4, &fdesc, ftemps) -- f4 = f1 * f2 + f3
                            Array of fdesc->ndigtemps_arith temps supplied
        Knegate(f1, f2,  &fdesc) -- f2 = -f1
        Ksqrt(f1, f2,    &fdesc) -- f2 = sqrt(f1) (either root)
        Ksub(f1, f2, f3, &fdesc) -- f3 = f1 - f2

    Miscellaneous routines:

        Kclear_many(f1, nelmt,    &fdesc) -- Set nelmt elements to zero.               
        Kfree  (&fdesc)                -- Free any memory malloc-ed
                                          when field was initialized.     
        Kinitalize_normal2(m, T, &fdesc) -- Initialize for normal basis.
        
        Kinitialize_prime(&modulus, &fdesc)
                                       -- Initialize field with prime modulus.
*/
#include "bignum.h"

typedef enum {FIELD_TYPE_INVALID = 0,
              FIELD_Q_MP,          // Field mod multiple-precision prime q
              FIELD_2_NORMAL,      // Field GF(2^m) with normal basis over GF(2)
              FIELD_2_POLYNOMIAL}  // Field GF(2^m) with polynomial basis
                                   //   over GF(2)
           field_type_t;

#define CHARACTERISTIC_2(fdesc) ((fdesc)->ftype >= FIELD_2_NORMAL)
                         // Test for characteristic 2 field.

typedef digit_t flongest_t[MP_LONGEST];


   //   Special GF(2^m) fields defined by sparse polynomials.

typedef DRM_BOOL DRM_CALL gf2_reduction_t(digit_t *, struct bigctx_t *f_pBigCtx);

Future_Struct(field_desc_t);

typedef DRM_BOOL DRM_CALL field_0op_notemps_t (digit_t *, const DRM_DWORD,
                                      const struct field_desc_t*, struct bigctx_t *f_pBigCtx);
typedef DRM_BOOL DRM_CALL field_1op_notemps_t (const digit_t *, digit_t *,
                                      const DRM_DWORD, const struct field_desc_t*,
                                      struct bigctx_t *f_pBigCtx);
typedef DRM_BOOL DRM_CALL field_2op_notemps_t (const digit_t *, const digit_t *, digit_t *,
                                      const DRM_DWORD, const struct field_desc_t*,
                                      struct bigctx_t *f_pBigCtx);

typedef struct {
          field_2op_notemps_t *adder;       // x + y
          DRM_BOOL        (DRM_CALL *equaler)     (const digit_t *, const digit_t *,
                                             const DRM_DWORD,
                                             const struct field_desc_t*,
                                             struct bigctx_t *f_pBigCtx);
                                            // Does x == y?

                                            // Compute base^exponent
                                            // (exponent an integer)
          DRM_BOOL        (DRM_CALL *freer)       (struct field_desc_t*, struct bigctx_t *f_pBigCtx);
                                             // Free ftype-dependent data when
                                             // Kfree called.
          DRM_BOOL        (DRM_CALL *immediater)  (const sdigit_t*, digit_t *,
                                             const DRM_DWORD,
                                             const struct field_desc_t*,
                                             struct bigctx_t *f_pBigCtx);

          DRM_BOOL        (DRM_CALL *inverter1)   (const digit_t *, digit_t *,
                                             const struct field_desc_t*,
                                             const struct digit_tempinfo_t*,
                                             struct bigctx_t *f_pBigCtx);
          DRM_BOOL        (DRM_CALL *iszeroer)    (const digit_t *, const DRM_DWORD,
                                             const struct field_desc_t*,
                                             struct bigctx_t *f_pBigCtx);
                                            // Does x == 0?
          DRM_BOOL        (DRM_CALL *mulpower2er) (const digit_t *, const DRM_INT,
                                             digit_t *, const DRM_DWORD,
                                             const struct field_desc_t*,
                                             struct bigctx_t *f_pBigCtx);
                                            // Multiply by 2^(second argument)
          DRM_BOOL        (DRM_CALL *multiplier1) (const digit_t *, const digit_t *,
                                             digit_t *,
                                             const struct field_desc_t*,
                                             digit_t *, struct bigctx_t *f_pBigCtx);
                                            // x * y

          field_1op_notemps_t *negater;     // -x

          DRM_BOOL        (DRM_CALL *sizer) (digit_t *,  const struct field_desc_t*,
                                       struct bigctx_t *f_pBigCtx);
                                // Return size of field (array length elng+1)

          field_2op_notemps_t *subtracter;   // x - y
          field_0op_notemps_t *zeroizer;     // 0
} field_arithmetic_t;


#define Kadd_many(f1, f2, f3, nelmt, fdesc, ctx) \
        (((fdesc)->arithmetic->adder) ((f1), (f2), (f3), (nelmt), (fdesc), ctx))
#define Kclear_many(      f3, nelmt, fdesc, ctx) \
        (((fdesc)->arithmetic->zeroizer)  ((f3), (nelmt), (fdesc), ctx))
#define Kequal_many(f1, f2,   nelmt, fdesc, ctx) \
        (((fdesc)->arithmetic->equaler)   ((f1), (f2), (nelmt), (fdesc), ctx))

#define Kimmediate_many(sarray, f3, nelmt, fdesc, ctx) \
        (((fdesc)->arithmetic->immediater) \
                ((sarray), (f3), (nelmt), (fdesc), ctx))
#define Kiszero_many(f1,      nelmt, fdesc, ctx) \
        (((fdesc)->arithmetic->iszeroer)  ((f1), (nelmt), (fdesc), ctx))
#define Kmulpower2_many(f1, ishift, f3, nelmt, fdesc, ctx) \
        (((fdesc)->arithmetic->mulpower2er) \
         ( (f1), (ishift), (f3), (nelmt), (fdesc), ctx))
#define Knegate_many(f1,  f3, nelmt, fdesc, ctx) \
        (((fdesc)->arithmetic->negater)   ((f1), (f3), (nelmt), (fdesc), ctx))
#define Ksqrt_many(f1,    f3, nelmt, fdesc, are_squares, ctx) \
        (((fdesc)->arithmetic->sqrter) \
         ((f1), (f3), (nelmt), (fdesc), (are_squares), ctx))
#define Ksub_many(f1, f2, f3, nelmt, fdesc, ctx) \
      (((fdesc)->arithmetic->subtracter) \
             ((f1), (f2), (f3), (nelmt), (fdesc), ctx))


#define Kadd(f1, f2, f3, fdesc, ctx)   \
        Kadd_many(   (f1), (f2), (f3), 1, (fdesc), ctx)
#define Kequal(f1, f2,   fdesc, ctx)   \
        Kequal_many( (f1), (f2),       1, (fdesc), ctx)

#define Kiszero(f1,      fdesc, ctx)   \
        Kiszero_many((f1),             1, (fdesc), ctx)
#define Kmulpower2(f1, ishift, f3, fdesc, ctx)\
        Kmulpower2_many((f1), (ishift), (f3), 1, (fdesc), ctx)
#define Knegate(f1,  f3, fdesc, ctx)   \
        Knegate_many((f1),       (f3), 1, (fdesc), ctx)
#define Ksqrt(f1,    f3, fdesc, is_square, ctx)  \
        Ksqrt_many(  (f1),       (f3), 1, (fdesc), (is_square), ctx)
#define Ksub(f1, f2, f3, fdesc, ctx)   \
        Ksub_many(   (f1), (f2), (f3), 1, (fdesc), ctx)


typedef struct field_desc_t {
          DRM_DWORD     elng;   // Length of each field element, in digit_t's
          DRM_DWORD     degree; // Extension degree m if GF(2^m)
                               // Also used for extension fields
          DRM_DWORD     ndigtemps_arith;  // Number of digit_t temporaries
                                         // adequate for any of the following:

                                         //   (use subfield->ndigtemps_arith)
                                         // Kdiv
                                         // Kinvert
                                         // Kinvert_many
                                         // Kmul
                                         // Kmuladd
          DRM_DWORD     ndigtemps_mul;
                               // Number of digit_t temporaries
                               // needed for a multiplication.
          DRM_DWORD     ndigtemps_invert1;
                               // Number of digit_t temporaries
                               // needed for an inversion.
          field_type_t ftype;  // Type of base field
          DRM_BOOL         free_modulus;   // If TRUE, Kfree frees
                                       // the modulo field.
                                       // Can be set by application.
          digit_t      *one;   // Constant 1
          digit_t      *deallocate;

          const field_arithmetic_t *arithmetic;
                                     // Pointers to arithmetic routines

// Next items apply only for extension fields
          const struct field_desc_t *base_field;  // Recursive data type
                                 // NULL if not an extension field.
// Next item applies for extension fields and FIELD_2_POLYNOMIAL
          digit_t      *minimal_polynomial;

// Next items apply only if ftype = FIELD_Q_MP
          const mp_modulus_t *modulo;      // Information about q
          digit_t *inverse_adjustment;
                                      // Multiplier to adjust reciprocal
                                      // for FROM_RIGHT arithmetic
// Next items apply only if ftype = FIELD_2_NORMAL
          DRM_DWORD     T;      // See field2n.c
          DRM_DWORD     lng_mulshifts;
          struct k2nmulshifts_t *mulshifts;
                               // Pairs of shifts.  See field2n.c
// Next items apply only if ftype = FIELD_2_POLYNOMIAL or extension field.
//
          DRM_DWORD     nonzero_trace_power;
                               // Chosen so trace(alpha^nonzero_trace_power) = 1
          digit_t      *leading_inverse;
                     // FLOOR(X^(2*degree-1) / minimal_polynomial)
                     // N.B. Either leading_inverse = NULL or freduc = NULL.
// For extension fields, nonzero_trace_power is chosen so
//     minimal_polynomial = X^degree
//        + (nonzero const)*X^(nonzero_trace_power - 1) + ...
//     That is, it counts 1 + degree(minimal polynomial, minus leading term).

//     leading_inverse has signed bytes converting these low coefficients
//     into signed integers in [-16, 16], if possible.

          gf2_reduction_t  *freduc;

// Following apply to FIELD_2_NORMAL and FIELD_2_POLYNOMIAL.

          DRM_DWORD     unused_bits_top;  // elng*RADIX_BITS - degree
          digit_t      mask_used_bits;
                                  // Mask to avoid extraneous bits in
                                  // most significant word of a field element
} field_desc_t;


DRM_API DRM_BOOL DRM_CALL Kdiv(const digit_t *, const digit_t *, digit_t *,
                        const field_desc_t*, digit_t *, struct bigctx_t *f_pBigCtx);
DRM_API DRM_BOOL DRM_CALL Kfree   (field_desc_t*, struct bigctx_t *f_pBigCtx);
DRM_API DRM_BOOL DRM_CALL Kimmediate(const sdigit_t, digit_t *,
                              const field_desc_t*, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL Kinitialize_prime(const mp_modulus_t*, field_desc_t*,
                                     struct bigctx_t *,
                                     struct bigctx_t *f_pBigCtx);
DRM_API DRM_BOOL DRM_CALL Kinvert(const digit_t *, digit_t *,
                           const field_desc_t*, digit_t *, struct bigctx_t *f_pBigCtx);
DRM_API DRM_BOOL DRM_CALL Kinvert_many(const digit_t *, digit_t *,
                                const DRM_DWORD, const field_desc_t*,
                                digit_t *, struct bigctx_t *f_pBigCtx);

#define Kmul(f1, f2, f3, fdesc, temps, ctx) Kmul_many((f1), (f2),\
                                       (f3), 1, (fdesc), (temps), ctx)

DRM_API DRM_BOOL DRM_CALL Kmul_many(const digit_t *, const digit_t *, digit_t *,
                             const DRM_DWORD, const field_desc_t*,
                             digit_t *, struct bigctx_t *f_pBigCtx);
DRM_API DRM_BOOL DRM_CALL Kmuladd (const digit_t *, const digit_t *,
                          const digit_t *, digit_t *,
                          const field_desc_t*, digit_t *, struct bigctx_t *f_pBigCtx);

DRM_API DRM_BOOL DRM_CALL Kprime_sqrter
        (const digit_t      *f1,        // IN
         digit_t       *f3,        // OUT
         const DRM_DWORD      nelmt,     // IN
         const field_desc_t *fdesc,     // IN
         DRM_BOOL          *psquares,  // OUT
         struct bigctx_t *f_pBigCtx);

EXIT_PK_NAMESPACE;

#endif /* __FIELD_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\ndtasfdrm.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __NDTASFDRM_H__
#define __NDTASFDRM_H__

ENTER_PK_NAMESPACE;

DRM_RESULT NDTMGR_ASF_Internal_CheckFileDRM( 
    __inout     NDTMGR_INTERNAL_CONTENTSESSION_CONTEXT  * const f_pContSessContext,
    __in const  DRM_BOOL                                        f_fEncryptClear
);

EXIT_PK_NAMESPACE;

#endif /* __NDTASFDRM_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\mux.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef NDTASFMUX_H
#define NDTASFMUX_H

#include <muxstream.h>
#include <sendwindow.h>

ENTER_PK_NAMESPACE;

#define MFASF_MAX_STREAM_NUMBER 127

#define INVALID_SAMPLE_TIME DRM_UI64(-1)
#define MFASF_MULTIPLEXER_AUTOADJUST_BITRATE 0x1

typedef struct tagASF_MUX_STATISTICS
{
    DRM_DWORD cFramesWritten;
    DRM_DWORD cFramesDropped;

} ASF_MUX_STATISTICS;

typedef struct __tagASF_MULTIPLEXER_CONTEXT
{
    DRM_DWORD                      m_dwFlags;

    DRM_DWORD                      m_cbFixedPacketSize;
    DRM_UINT64                     m_msPreroll;
    DRM_UINT64                     m_msSyncTolerance;
    DRM_DWORD                      m_dwMaxBitratePlusOverhead;

    ASF_MUX_STREAM_CONTEXT        *m_rgpMuxStreams[ MFASF_MAX_STREAM_NUMBER + 1 ];
    DRM_WORD                      *m_StreamNumbers;
    DRM_WORD                       m_cStreamNumbers;
    ASF_MUX_STATISTICS             m_rgMuxStats[ MFASF_MAX_STREAM_NUMBER + 1 ];

    ASF_MUX_SEND_WINDOW_CONTEXT   *m_pMuxSendWindow;
    PTR_LIST                       m_WaitingPackets;

    ASF_MUX_QUEUE_OBJECT_CONTEXT **m_ppMuxQueueObjects;
    DRM_DWORD                      m_cMuxQueueObjects; /* for generating a payload from a sample/sample fragment */

    DRM_UINT64                     m_cPackets;
    DRM_UINT64                     m_hnsLastPacketSendTime;
    DRM_UINT64                     m_hnsLastPacketDuration;

} ASF_MULTIPLEXER_CONTEXT;


DRM_RESULT ASFMux_Initialize( 
    __inout    ASF_MULTIPLEXER_CONTEXT * const pAsfMuxContext,
    __in const PTR_LIST                * const pStreamInfoList,
    __in const DRM_DWORD                       dwFixedPacketSize,
    __in const DRM_UINT64                      qwPreroll,
    __in const DRM_DWORD                       dwMaxBitrate
);

DRM_VOID ASFMux_Uninitialize( 
    __in ASF_MULTIPLEXER_CONTEXT * const pAsfMuxContext
);

DRM_RESULT ASFMux_ProcessSample( 
    __inout    ASF_MULTIPLEXER_CONTEXT * const pAsfMuxContext,
    __in const DRM_WORD                        wStreamNumber,
    __in       ASF_SAMPLE              * const pISample,
    __in const DRM_UINT64                      hnsTimestampAdjust
);

DRM_RESULT ASFMux_GetNextPacket(
    __in  ASF_MULTIPLEXER_CONTEXT  * const pAsfMuxContext,
    __out ASF_SAMPLE                     **ppIPacket
);

DRM_RESULT ASFMux_Flush( 
    __in  ASF_MULTIPLEXER_CONTEXT  * const pAsfMuxContext
);

DRM_RESULT ASFMux_OnCompletedPacket(
    __inout    ASF_MULTIPLEXER_CONTEXT * const pAsfMuxContext,
    __inout    ASF_SAMPLE              * const pIPacket,
    __in const DRM_UINT64                      hnsSampleTime,
    __in const DRM_UINT64                      hnsSampleDuration
);

DRM_RESULT ASFMux_GetMinStreamSendtimeCutoff( 
    __in const ASF_MULTIPLEXER_CONTEXT * const pAsfMuxContext,
    __out      DRM_UINT64              * const phnsSendTimeCutoff 
);

DRM_RESULT ASFMux_AdjustSendTimeForOffset(    
    __in const ASF_MULTIPLEXER_CONTEXT      * const pAsfMuxContext,
    __in const DRM_DWORD                            cbOriginalObjectSize,
    __inout    ASF_MUX_QUEUE_OBJECT_CONTEXT * const pQueueObject
);

EXIT_PK_NAMESPACE;

#endif /* NDTASFMUX_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\muxstream.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#ifndef __NDTASFMUXSTREAM_H
#define __NDTASFMUXSTREAM_H

#include <sendwindow.h>
#include <leakybucket.h>

ENTER_PK_NAMESPACE;


typedef struct tagASF_MUX_STREAM_CONTEXT
{
    DRM_DWORD                            m_Type;
    DRM_UINT64                           m_msPreroll;
    struct __tagASF_MULTIPLEXER_CONTEXT *m_pMux;
    
    DRM_WORD                             m_wStreamNumber;
    DRM_DWORD                            m_dwMaxBitrate;
    DRM_DWORD                            m_msMaxBufferWindow;
    DRM_BOOL                             m_fAllObjectsAreCleanPoints;
                               
    DRM_DWORD                            m_dwNextObjectID;
    DRM_UINT64                           m_hnsFirstSendTime;
    DRM_UINT64                           m_msFirstPresTimeSeen;
    DRM_UINT64                           m_msLatestPresTimeSeen;
    DRM_UINT64                           m_msLatestDurationSeen;
    DRM_UINT64                           m_cFrames;
    DRM_UINT64                           m_cbFrameData;
    DRM_DWORD                            m_cbLargestObjectSeen;

    ASF_LEAKY_BUCKET_CONTEXT            *m_pLeakyBucket;

    /* AUDIO */
    DRM_BOOL                             m_fIsPayloadSizeFixed;
    DRM_DWORD                            m_cbFixedPayloadSize;

    ASF_WAVEFORMATEX                    *m_pWFX;
    DRM_DWORD                            m_cbWFX;
    ASF_MUX_QUEUE_OBJECT_CONTEXT        *m_pUnfragmentableObjectInProgress;

    /* VIDEO */
    DRM_UINT64                           m_hnsAvgTimePerFrame;
    DRM_BOOL                             m_fSetSampleDurations;
    ASF_MUX_QUEUE_OBJECT_CONTEXT        *m_pLastQueueObjectSeen;

} ASF_MUX_STREAM_CONTEXT;


DRM_RESULT ASFMuxStream_Initialize(
    __out      ASF_MUX_STREAM_CONTEXT              * const pAsfMuxStreamContext,
    __in       ASF_STREAM_INFO                     * const pIStreamConfig,
    __in const DRM_UINT64                                  msPreroll,
    __in const DRM_UINT64                                  hnsFirstSendTime,
    __in       struct __tagASF_MULTIPLEXER_CONTEXT * const pMuxContext
);

DRM_VOID ASFMuxStream_Uninitialize(
    __inout ASF_MUX_STREAM_CONTEXT * const pAsfMuxStreamContext
);

DRM_RESULT ASFMuxStream_HowManyObjectsWillBeReturned( 
    __in const ASF_MUX_STREAM_CONTEXT * const pAsfMuxStreamContext,
    __in const ASF_SAMPLE             * const pSample,
    __out      DRM_DWORD              * const pcObjects
);

DRM_RESULT ASFMuxStream_OnSample(
    __inout    ASF_MUX_STREAM_CONTEXT       * const pAsfMuxStreamContext,
    __in       ASF_SAMPLE                   * const pISample,
    __in const DRM_UINT64                           hnsTimestampAdjust,
    __in const DRM_DWORD                            dwFlags,
    __inout_ecount(*pcQueueObjects) ASF_MUX_QUEUE_OBJECT_CONTEXT  **ppMuxQueueObject,
    __inout    DRM_DWORD                    * const pcQueueObjects 
);

DRM_RESULT ASFMuxStream_GetObjectSizeForBandwidthPolicing(
    __in const ASF_MUX_STREAM_CONTEXT * const pAsfMuxStreamContext,
    __in const DRM_DWORD                      cbObjectSize,
    __out      DRM_DWORD              * const pcbNewObjectSize
);

DRM_RESULT ASFMuxStream_ApproxSampleDuration(
    __in const ASF_MUX_STREAM_CONTEXT * const pAsfMuxStreamContext,
    __in const ASF_SAMPLE             * const pISample,
    __out      DRM_UINT64             * const pmsDuration
);

DRM_RESULT ASFMuxStream_GetHappyCutoffSendtime(
    __in const ASF_MUX_STREAM_CONTEXT * const pAsfMuxStreamContext,
    __out      DRM_UINT64             * const phnsNextSendtime
);

DRM_RESULT ASFMuxStream_AdjustSendTimeForOffset(
    __in const ASF_MUX_STREAM_CONTEXT       * const pAsfMuxStreamContext,
    __in const DRM_DWORD                            cbOriginalObjectSize,
    __out      ASF_MUX_QUEUE_OBJECT_CONTEXT * const pQueueObject 
);

DRM_VOID ASFMuxStream_Cleanup(
    __inout ASF_MUX_STREAM_CONTEXT * const pAsfMuxStreamContext
);

DRM_RESULT ASFMuxStream_ReadMediaType(
    __inout ASF_MUX_STREAM_CONTEXT * const pAsfMuxStreamContext,
    __in    ASF_STREAM_INFO        * const pIStreamConfig 
);

EXIT_PK_NAMESPACE;

#endif /* __NDTASFMUXSTREAM_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\ndtasfguids.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __NDTASFGUIDS_H__
#define __NDTASFGUIDS_H__

#include <drmcommon.h>
#include <drmtypes.h>

#ifndef DRM_IsEqualGUID
#define DRM_IsEqualGUID( rguid1, rguid2 ) ( ! MEMCMP( rguid1, rguid2, SIZEOF( DRM_GUID ) ) )
#endif /* DRM_IsEqualGUID */

/***************************************************************************/
/* WMA/ASF GUIDs */
DRM_DECLARE_GUID( CLSID_ASFHeaderObjectV0 );

DRM_DECLARE_GUID( CLSID_ASFContentEncryptionObject );

DRM_DECLARE_GUID( CLSID_ASFContentEncryptionObjectEx );

DRM_DECLARE_GUID( CLSID_ASFPlayReadyObject );

DRM_DECLARE_GUID( CLSID_ASFStreamPropertiesObjectEx );

DRM_DECLARE_GUID( CLSID_ASFStreamPropertiesObjectV1 );

DRM_DECLARE_GUID( CLSID_ASFAdvancedContentEncryptionObject );

DRM_DECLARE_GUID( CLSID_ASFHeaderExtensionObject );

DRM_DECLARE_GUID( CLSID_ASFPacketClock1 );

DRM_DECLARE_GUID( CLSID_ASFFilePropertiesObjectV2 );

DRM_DECLARE_GUID( CLSID_ASFStreamBitratePropertiesObject );

/* WMDRM-ND/AES specific GUIDs */
DRM_DECLARE_GUID( CLSID_ASF_Payload_Extension_Encryption_SampleID );

DRM_DECLARE_GUID( CLSID_ASF_ContentEncryptionSystem_WMDRM_ND_AES );

/* ASF Media Stream Types */
DRM_DECLARE_GUID( CLSID_ASFStreamTypeUnknown );

DRM_DECLARE_GUID( CLSID_ASFStreamTypeAudioMedia );

DRM_DECLARE_GUID( CLSID_ASFStreamTypeVideoMedia );

DRM_DECLARE_GUID( CLSID_ASFStreamTypeCommandMedia );

DRM_DECLARE_GUID( CLSID_ASFStreamTypeJFIFMedia );

DRM_DECLARE_GUID( CLSID_ASFStreamTypeDegradableJPEGMedia );

DRM_DECLARE_GUID( CLSID_ASFStreamTypeFileTransferMedia );

DRM_DECLARE_GUID( CLSID_ASFStreamTypeBinaryMedia );


#endif /* __NDTASFGUIDS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\mprand.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*      File mprand.h */

#ifndef _MPRAND_H
#define _MPRAND_H

#include "bignum.h"

ENTER_PK_NAMESPACE;

DRM_API DRM_BOOL DRM_CALL random_bytes(DRM_BYTE*, const DRM_DWORD, struct bigctx_t *f_pBigCtx);
         // Procedure to be supplied by application.



#if !DRM_INLINING_SUPPORTED

DRM_API DRM_BOOL DRM_CALL     random_digits(digit_t*, const DRM_DWORD, struct bigctx_t *f_pBigCtx);

#endif // DRM_INLINING_SUPPORTED


// Following are extern on all platforms

DRM_API DRM_BOOL DRM_CALL random_digit_interval(const digit_t, const digit_t,
                                             digit_t*, struct bigctx_t *f_pBigCtx);
          /* Generate random digit_t or DRM_DWORD in specified closed interval. */

DRM_API DRM_BOOL DRM_CALL random_mod        (const digit_t *, digit_t *,
                                          const DRM_DWORD, struct bigctx_t *f_pBigCtx);

/*
** Checked stublib expects the function name to be new_random_mod_nonzero
** Temporary fix.
*/
#define random_mod_nonzero new_random_mod_nonzero
DRM_API DRM_BOOL DRM_CALL random_mod_nonzero(const digit_t *, digit_t *,
                                          const DRM_DWORD, struct bigctx_t *f_pBigCtx);
                        // Generate random value modulo another value.
                        // random_mod_nonzero generates a nonzero value.


#if DRM_INLINING_SUPPORTED

// Next four are inline, rather than macros, so compiler can issue
// error when array argument has wrong pointer type.

DRMINLINE DRM_BOOL DRM_CALL random_digits(digit_t dtArray[],
                                      const DRM_DWORD lng,
                                      struct bigctx_t *f_pBigCtx)
{    /* Generate random multiple-precision number */
     /* It may have a leading zero. */
    return random_bytes((DRM_BYTE*)dtArray,
                        (DRM_DWORD)lng*SIZEOF(digit_t),
                        f_pBigCtx);
} /* random digits */



#endif  // DRM_INLINING_SUPPORTED

EXIT_PK_NAMESPACE;

#endif   // _MPRAND_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\ndtasftypes.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __NDTASFTYPES_H__
#define __NDTASFTYPES_H__

#include <drmcommon.h>
#include <drmmanager.h>
#include <asfsample.h>

#define MAXSTREAMS 128

ENTER_PK_NAMESPACE;

typedef struct __tagASF_PACKET_PARSER_INFO
{
    DRM_BOOL      fParityPacket;
    DRM_BOOL      fEccPresent;
    DRM_BOOL      fMultiPayloads;
    DRM_DWORD     dwParseOffset;
    DRM_BYTE      bECLen;
    DRM_BYTE      bPacketLenType;
    DRM_BYTE      bPadLenType;
    DRM_BYTE      bSequenceLenType;
    DRM_DWORD     dwPacketLenTypeOffset;
    DRM_BYTE      bOffsetLenType;
    DRM_BYTE      bPayLenType;
    DRM_BYTE      bPayBytes;
    DRM_DWORD     dwPacketLenOffset;
    DRM_DWORD     dwExplicitPacketLength;
    DRM_DWORD     dwSequenceOffset;
    DRM_DWORD     dwSequenceNum;
    DRM_DWORD     dwPadLenOffset;
    DRM_DWORD     dwPadding;
    DRM_DWORD     dwSCR;
    DRM_DWORD     dwPayLenTypeOffset;
    DRM_DWORD     dwPayloads;
    DRM_WORD      wDuration;
    DRM_BYTE      bStreamIDLenType;
    DRM_BYTE      bObjectIDLenType;
    DRM_BYTE      bReplicatedDataLenType;
    DRM_BYTE      bReplicatedDataLenBytes;
    DRM_DWORD     cbPacketLength;
} ASF_PACKET_PARSER_INFO;

typedef struct __tagASF_PAYLOAD_PARSER_INFO
{
    DRM_WORD      wPacketOffset;
    DRM_WORD      wTotalSize;

    DRM_BYTE      bStreamId;
    DRM_BYTE      bObjectId;
    DRM_BYTE      bRepData;
    DRM_BYTE      bJunk;

    DRM_DWORD     dwObjectOffset;
    DRM_DWORD     dwObjectSize;
    DRM_DWORD     dwObjectPres;

    DRM_BOOL      fIsKeyFrame;
    DRM_BOOL      fIsCompressedPayload;
    DRM_WORD      wPayloadSize;
    DRM_WORD      wTotalDataBytes;
    DRM_DWORD     dwDeltaPresTime;

    DRM_WORD      wBytesRead;
    DRM_BYTE      bSubPayloadState;
    DRM_BYTE      bNextSubPayloadSize;
    DRM_WORD      wSubpayloadLeft;
    DRM_WORD      wSubCount;

    DRM_DWORD     dwPayloadDataStartBuffer;
    DRM_DWORD     cPayloadDataBuffers;

    DRM_BYTE      rgbRepData[256]; /* NOTE: dynamic allocation could save space here */

} ASF_PAYLOAD_PARSER_INFO;

typedef enum __tagASF_PARSE_STATE
{
    P_NOT_VALID = 0,
    P_NEW_PACKET,
    P_PACKET_HEADER,
    P_PAYLOAD_HEADER,
    P_PAYLOAD,
    P_UNCOMPRESSEDPAYLOAD,
    P_COMPRESSEDPAYLOAD,
    P_PAYLOAD_END,
    P_END
} ASF_PARSE_STATE;

typedef struct __tagASF_CONTENT_ENCRYPTION_OBJECT
{
    DRM_BYTE      *pbSecretData;
    DRM_DWORD      cbSecretData;

    DRM_BYTE      *pbProtectionType;
    DRM_DWORD      cbProtectionType;

    DRM_BYTE      *pbKeyID;
    DRM_DWORD      cbKeyID;

    DRM_BYTE      *pbLicenseURL;
    DRM_DWORD      cbLicenseURL;
} ASF_CONTENT_ENCRYPTION_OBJECT;

typedef struct __tagASF_CONTENT_ENCRYPTION_OBJECT_EXT
{
    DRM_BYTE      *pbData;
    DRM_DWORD      cbData;
} ASF_CONTENT_ENCRYPTION_OBJECT_EXT;

typedef struct
{
    DRM_BYTE      *pbData;
    DRM_DWORD      cbData;
} ASF_PLAYREADY_OBJECT;

typedef struct __tagASF_PAYLOAD_INFO
{
    DRM_WORD  wStreamNumber;
    DRM_BOOL  fIsKeyFrame;
    DRM_BYTE  bObjectID;
    DRM_DWORD msObjectPresTime;
    DRM_DWORD cbObjectOffset;
    DRM_DWORD cbObjectSize;
    DRM_DWORD cbPayloadDataSize;
} ASF_PAYLOAD_INFO;

typedef struct __tagASF_WAVEFORMATEX
{
    DRM_WORD  wFormatTag;
    DRM_WORD  nChannels;
    DRM_DWORD nSamplesPerSec;
    DRM_DWORD nAvgBytesPerSec;
    DRM_WORD  nBlockAlign;
    DRM_WORD  wBitsPerSample;
    DRM_WORD  cbSize;
} ASF_WAVEFORMATEX;

typedef struct __tagASF_BITMAPINFOHEADER
{
    DRM_DWORD  biSize;
    DRM_LONG   biWidth;
    DRM_LONG   biHeight;
    DRM_WORD   biPlanes;
    DRM_WORD   biBitCount;
    DRM_DWORD  biCompression;
    DRM_DWORD  biSizeImage;
    DRM_LONG   biXPelsPerMeter;
    DRM_LONG   biYPelsPerMeter;
    DRM_DWORD  biClrUsed;
    DRM_DWORD  biClrImportant;
} ASF_BITMAPINFOHEADER;

typedef struct __tagASF_STREAM_VIDEOINFOHEADER
{
    DRM_DWORD dwEncodedImageWidth;
    DRM_DWORD dwEncodedImageHeight;
    DRM_BYTE  bReserved;
    DRM_WORD  cbFormatDataSize;
    ASF_BITMAPINFOHEADER BMIH;
} ASF_STREAM_VIDEOINFOHEADER;

typedef struct __tagASF_STREAM_INFO
{
    DRM_WORD   wStreamNumber;
    DRM_GUID   guidStreamType;
    DRM_DWORD  dwAverageBitrate;

    ASF_WAVEFORMATEX   WFX;
    ASF_STREAM_VIDEOINFOHEADER VIH;
    DRM_UINT64     hnsAvgTimePerFrame;
    DRM_DWORD      dwFlags;

    DRM_DWORD   dwMaxBitrate;
    DRM_DWORD   msMaxBufferWindow;

    DRM_DWORD  dwCurrentObjectTotalSize;
    DRM_DWORD  dwCurrentObjectSize;
    DRM_UINT64 qwCurrentSampleOffset;
    DRM_UINT64 qwCurrentSampleID;

    DRM_BYTE *pbStreamPropertiesObj;

} ASF_STREAM_INFO;

typedef struct __tagASF_PARSER_STATE
{
    DRM_INT64                          iCurrentFileOffset;
    DRM_INT64                          iFirstPacketOffset;
    DRM_INT64                          iLastPacketOffset;
    DRM_INT64                          iPreviousPacketOffset;
    DRM_INT64                          iCurrentPacketOffset;
    DRM_INT64                          iNextPacketOffset;

    ASF_PACKET_PARSER_INFO            *pPacketInfo;
    ASF_PAYLOAD_PARSER_INFO           *pPayloadInfo;
    DRM_DWORD                          dwPayload;
    DRM_DWORD                          dwPayloadOffset;
    DRM_WORD                           wPayStart;
    DRM_BOOL                           fHeaderDone;
    DRM_BOOL                           fBigEndian;
    DRM_BOOL                           fSeekPositionSet;
    DRM_UINT64                         qwSeekPosition;
    DRM_DWORD                          dwTimePosition;
    DRM_UINT64                         qwSeekPacket;
    ASF_PARSE_STATE                    tParseState;
    DRM_DWORD                          dwPacketCount;
    DRM_DWORD                          dwPacketSize;
    DRM_DWORD                          dwMaxBitrate;
    DRM_DWORD                          dwTotalPackets;
    DRM_DWORD                          dwPacketsProcessed;
    ASF_CONTENT_ENCRYPTION_OBJECT     *pContentEncObj;
    ASF_CONTENT_ENCRYPTION_OBJECT_EXT *pContentEncObjExt;
    ASF_PLAYREADY_OBJECT              *pPlayReadyObj;
    DRM_UINT64                         qwHeaderSize;
    DRM_DWORD                          dwNoOfHeaders;
    DRM_DWORD                          dwNoOfStreams;
    DRM_BOOL                           fEncrypted;
    DRM_BOOL    fHeaderParsed;

    DRM_DWORD   cbOriginalHeaderSize;
    DRM_DWORD   cbContentEncryptionObject;
    DRM_DWORD   cbContentEncryptionObjectEx;
    DRM_DWORD   cbPlayReadyObject;
    /* TRUE if the PlayReady object is contained in the extended header object, FALSE
    ** if it's contained in the regular header. Only valid when there is a PlayReady
    ** object present (ie cbPlayReadyObject non-zero) */
    DRM_BOOL    fPlayReadyObjectInsideEHO;

    DRM_BOOL    fFoundStreamPropertiesObjectEx[MAXSTREAMS];
    DRM_BOOL    fFoundStream [MAXSTREAMS];
} ASF_PARSER_STATE;

typedef enum __eASF_TRANSCRYPTION_STATE
{
    ASF_TRANSCRYPTION_STATE_UNINITIALIZED = 0,
    ASF_TRANSCRYPTION_STATE_INITIALIZED,
    ASF_TRANSCRYPTION_STATE_HEADER_TRANSCRYPTED
} ASF_TRANSCRYPTION_STATE;

typedef struct __tagASF_TRANSCRYPT_HEADER_CONTEXT
{
    DRM_BYTE    *pbHeader;
    DRM_DWORD    cbHeaderSize;
    DRM_DWORD    dwHeaderOffset;

    /* Stores the offset to the file size QWORD in the File Properties Object */
    DRM_DWORD    dwFileSizeOffset;
    /* Stores the buffer offset for undelivered data
     * (data that will be sent on the next transcrypt call
     */
    DRM_DWORD    dwSentDataOffset;

    DRM_DWORD   cbHeaderExtensionObjectData;
    DRM_UINT64         qwFileSize;


    /* Stores the offset for the header extension object data size */
    DRM_DWORD   dwHeaderExtensionDataSize;
    DRM_DWORD   cbHeaderExtensionObjectExtra;
} ASF_TRANSCRYPT_HEADER_CONTEXT;

typedef struct __tagASF_DATA_CONTEXT
{
    DRM_BYTE    *pbDataBuffer;
    DRM_DWORD    cbDataBufferSize;
    DRM_DWORD    dwDataBufferOffset;

    /* Stores the buffer offset for undelivered data
     * (data that will be sent on the next transcrypt call
     */
    DRM_DWORD    dwSentDataOffset;
} ASF_DATA_CONTEXT;

typedef struct __tagASF_TRANSCRYPT_DATA_CONTEXT
{
    ASF_DATA_CONTEXT DataContext;
    DRM_UINT64   qwCurrentSampleID;
} ASF_TRANSCRYPT_DATA_CONTEXT;

typedef struct __tagASF_TRANSCRYPT_CONTEXT
{
    ASF_TRANSCRYPTION_STATE          State;

    DRM_GUID                         guidFileID;

    ASF_TRANSCRYPT_HEADER_CONTEXT    Header;
    ASF_TRANSCRYPT_DATA_CONTEXT      Data;

    DRM_DECRYPT_CONTEXT              decryptContext;


    DRM_VOID                        *pNDTManagerContext;
    DRM_ID                           idSession;

    DRM_BOOL                         fAllPacketsTranscrypted;

    DRM_BYTE                        *pbLicenseKeyID;
    DRM_DWORD                        cbLicenseKeyID;

    DRM_BOOL                         fIsVBRContent;

    DRM_VOID                        *pMux;
    ASF_SAMPLE                      *pOutputPacket;
} ASF_TRANSCRYPT_CONTEXT;

typedef struct __tagASF_FILE_INFO
{
    /* Content Encryption Object information */
    ASF_CONTENT_ENCRYPTION_OBJECT       *pContentEncObj;

    /* Extended Content Encryption Object information */
    ASF_CONTENT_ENCRYPTION_OBJECT_EXT   *pContentEncObjExt;

    /* PlayReady Object */
    ASF_PLAYREADY_OBJECT                *pPlayReadyObj;

    DRM_BOOL                             fAudioOnly;
    DRM_DWORD                            dwStreamCount;
} ASF_FILE_INFO;

EXIT_PK_NAMESPACE;

#endif /* __NDTASFTYPES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\ndtcontextsizes.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __NDTCONTEXTSIZES_H__
#define __NDTCONTEXTSIZES_H__

#include <ndttypes.h>
#include <drmcrt.h>
#include <drmaes.h>
#include <drmoutputleveltypes.h>
#include <drmcommon.h>
#include <oemndt.h>
#include <oemcontextsizes.h>
#include <ndtasftypes.h>
#include <drmptrlist.h>

ENTER_PK_NAMESPACE;

struct _tagNDTMGR_INTERNAL_SESSION_CONTEXT;

typedef struct _tagNDTMGR_INTERNAL_SESSION_CONTEXT
{
    DRM_ID                                      idSession;
    NDTMGR_SESSION_TYPE                         sessionType;
    struct _tagNDTMGR_INTERNAL_SESSION_CONTEXT *pNextContext;
    struct _tagNDTMGR_INTERNAL_SESSION_CONTEXT *pPrevContext;
} NDTMGR_INTERNAL_SESSION_CONTEXT;

typedef enum __tagNDT_REGISTRATION_STATE
{
    REG_STATE_INIT = 0,
    REG_STATE_PROCESSED_REGISTRATION_REQUEST,
    REG_STATE_PROXIMITY_CHALLENGE_SENT,
    REG_STATE_PROXIMITY_VERIFIED,
    REG_STATE_DONE
} NDT_REGISTRATION_STATE;

typedef enum __tagNDT_MEDIA_SESSION_STATE
{
    MEDIA_STATE_INITED = 0,
    MEDIA_STATE_SENDING_DATA,
    MEDIA_STATE_LICENSE_READY_FOR_LEAF,
    MEDIA_STATE_LICENSE_READY,
    MEDIA_STATE_CLOSE,
} NDT_MEDIA_SESSION_STATE;

typedef struct __tagNDT_CERTIFICATE_INFO
{
    DRM_BYTE            rgbReceiverIdentityHash[__CB_DECL(DRM_SHA1_DIGEST_LEN)];
    DRM_BYTE            rgbDigestValue[__CB_DECL(DRM_SHA1_DIGEST_LEN)];
    DRM_DWORD           dwSecurityLevel;
    DRM_DWORD           dwWMDRMNDFeatures;
    DRM_DWORD           dwPubKeyModulusSize;
    DRM_RSA_PUBLIC_KEY* pDevicePublicKey;
} NDT_CERTIFICATE_INFO;

typedef struct __tagNDT_ASF_CONTEXT
{
    /* Flag to determine if we are doing protedcted content play back */
    DRM_BOOL                     fProtectedContentPlayback;

    /* DRM status of the file, 1 if it is protected */
    DRM_DWORD                    dwDRMStatus;

    /* Encryption Type */
    DRM_SUPPORTED_CIPHERS        eCipherType;

    /* How many additional bytes will be added to the Payload Extension
    ** (a.k.a Replicated Data) section of each payload, which is dependent
    ** upon how the ASF file is encrypted.
    */
    DRM_DWORD                    dwAesPayloadExtensionAdditionalBytes;
    DRM_DWORD                    rgdwSampleIDRepDataOffset[MAXSTREAMS];

    /* License status of the file, 1 if we have license to play it */
    DRM_DWORD                    dwLicenseStatus;

    /* Are we performing clear content encryption */
    DRM_BOOL                     fEncryptClear;

    /* Delivery mode, sample or muxed */
    NDT_ASFDELIVERY_MODE         ASFDeliveryMode;

    /* TRUE if the license has been committed with DRM_MGR_Commit.
       This happens once the first data block is read, and does things such
       as decrementing playcounts and deleting licenses */
    DRM_BOOL                     fCommitted;

    /* Input file handle */
    OEM_FILEHDL                  hInFile;

    /* File buffer */
    DRM_BYTE                    *pbFileBuffer;
    ASF_PARSER_STATE             ParserState;

    DRM_UINT64                   qwSendDuration;
    DRM_UINT64                   qwDataPacketsCount;
    DRM_UINT64                   qwDuration;
    DRM_UINT64                   qwPreroll;
    DRM_DWORD                    dwFlags;

    DRM_DECRYPT_CONTEXT          decryptContext;
    DRM_BOOL                     fOPLValid;
    DRM_PLAY_OPL                 playOPLs;

    DRM_DWORD                    dwNoOfStreams;
    DRM_BOOL                     fAudioOnly;
    PTR_LIST                     StreamInfoList;
    PTR_LIST                     Samples;
    DRM_UINT64                   qwNextSampleID;
    DRM_DWORD                    dwOutputPacketSize;
    DRM_DWORD                    dwMaximumObjectSize;

    ASF_TRANSCRYPT_CONTEXT       ASFTranscryptContext;

    DRM_BOOL                     fInclusionListValid;
    DRM_GUIDLIST                 InclusionList;
    ASF_FILE_INFO                ASFFileInfo;
    
    DRM_BOOL                     fIsPlayReady;
} NDT_ASF_CONTEXT;

typedef struct __tagNDT_LICENSE_CONTEXT
{
    /* Used in XMR license */
    DRM_KID         idKID;
    DRM_ID          idRightsID;

    DRM_DWORD       dwClientCRLVersion;
    DRM_BYTE        rgbKeyMaterial[ __CB_DECL(2*DRM_AES_KEYSIZE_128) ];
    DRM_BYTE       *pbKeyContentEncryption;
    DRM_BYTE       *pbKeyContentIntegrity;
    DRM_AES_KEY    *pAESKeyContentEncryption;
    DRM_BOOL        fProtectedContentPlayback;
    DRM_WORD        wMinimumSecurityLevel;
} NDT_LICENSE_CONTEXT;

typedef NDT_LICENSE_CONTEXT NDT_SIMPLE_LICENSE_CONTEXT;
typedef struct tagNDT_CHAINED_LICENSE_CONTEXT
{
    NDT_LICENSE_CONTEXT rootLicenseContext;
    NDT_LICENSE_CONTEXT leafLicenseContext;
} NDT_CHAINED_LICENSE_CONTEXT;

typedef struct __tagNDTMGR_INTERNAL_CONTENTSESSION_CONTEXT
{
    NDTMGR_INTERNAL_SESSION_CONTEXT  sessionContext;
    DRM_APP_CONTEXT                 *pAppContext;
    NDT_MEDIA_SESSION_STATE          mediaSessionState;

    NDT_LICENSE_MODE                 licenseMode;
    DRM_VOID                        *pLicenseContext;
    NDT_ASF_CONTEXT                  asfContext;

    OEM_DEVICE_HANDLE                hDevice;
    DRM_BYTE                         rgbReceiverIdentityHash[__CB_DECL(DRM_SHA1_DIGEST_LEN)];

    DRM_DWORD                        dwReceiverSecurityLevel;
    DRM_DWORD                        dwReceiverWMDRMNDFeatures;
} NDTMGR_INTERNAL_CONTENTSESSION_CONTEXT;

typedef struct __tagNDTMGR_INTERNAL_REGISTRATIONSESSION_CONTEXT
{
    NDTMGR_INTERNAL_SESSION_CONTEXT sessionContext;
    NDT_REGISTRATION_STATE          state;

    DRM_BYTEBLOB                    DeviceID;
    OEM_DEVICE_HANDLE               hDevice;

    DRM_ID                          idSerial;
    DRM_ID                          idSeed;

    DRMFILETIME                     ftRegistrationStartTime;
    DRM_DWORD                       dwProximityStartTime;
    
    DRM_ID                          idNonce;
    DRM_BYTE                        bSequenceNumber;

    DRM_WORD                        wResult;

    DRM_BYTE                       *pbProximityDetectionAddress;
    DRM_WORD                        cbProximityDetectionAddress;
} NDTMGR_INTERNAL_REGISTRATIONSESSION_CONTEXT;


typedef struct __tagNDTMGR_CONTEXT_INTERNAL
{
    /*
     * Content transfer
     */
    DRM_APP_CONTEXT                 *pAppContext;

    OEM_DEVICESTORE_CONTEXT          deviceStoreContext;
    OEM_DEVICESTORE_CONTEXT          upperLayerDeviceStoreContext;
    DRM_DWORD                        dwDeviceStoreRegistrationCount;

    NDTMGR_INTERNAL_SESSION_CONTEXT *pFirstSession;

    DRM_DWORD                        dwOpenedCount;
    NDT_CERTIFICATE_INFO             certificateInfo;
    DRM_DWORD                        dwCRLVersion;
} NDTMGR_CONTEXT_INTERNAL;

#define NDTMGR_CONTEXT_BUFFER_SIZE SIZEOF(NDTMGR_CONTEXT_INTERNAL)

#define SIZEOF_U8 1

typedef enum tagNDT_ENCRYPTION_MODE
{
    NDT_ENCRYPTION_MODE_ASF = 0,
    NDT_ENCRYPTION_MODE_MPEG = 1,
    NDT_ENCRYPTION_MODE_LINK = 2
} NDT_ENCRYPTION_MODE;

typedef struct tagNDT_CRYPTO_DATA_ASF
{
    DRM_BYTEBLOB    SampleData;
    DRM_UINT64      qwSampleID;
    DRM_UINT64      qwOffset;
} NDT_CRYPTO_DATA_ASF;

typedef struct tagNDT_CRYPTO_DATA_MPEG
{
    DRM_BYTEBLOB    Data;
    DRM_UINT64      qwBaseCounter;
    DRM_UINT64      qwMinorCounter;
} NDT_CRYPTO_DATA_MPEG;

typedef struct tagNDT_CRYPTO_DATA_LINK
{
    DRM_BYTEBLOB    Data;
    DRM_UINT64      qwDataSegmentID;
    DRM_UINT64      qwOffset;
    DRM_UINT64      qwBlockID;
    DRM_BOOL        fNoEncrypt;
    DRM_BOOL        fNoBlockID;
    DRM_BYTEBLOB*   pDataSegmentDescriptor;
} NDT_CRYPTO_DATA_LINK;

EXIT_PK_NAMESPACE;

#endif  /* __NDTCONTEXTSIZES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\ndtasf_internal.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __NDTASF_INTERNAL_H__
#define __NDTASF_INTERNAL_H__

#include <drmcommon.h>
#include <drmcontextsizes.h>
#include <drmcipher.h>
#include <drmmanager.h>
#include <DrmAes.h>
#include <ndtcontextsizes.h>
#include <asfsample.h>

ENTER_PK_NAMESPACE;

/* File i/o buffer size (reading input file) */
#define FILE_BUFFER_SIZE                        65536
#define MIN_OBJ_SIZE                            24
#define DATA_OBJECT_SIZE                        50
#define ASF_TRANSCRYPT_WMDRMND_OBJECT_SIZE      MIN_OBJ_SIZE + 50

/* How many packets to transcrypt at a time */
#define ASF_PACKET_TRANSCRYPTS_PER_CALL         10

/* mux constants */
#define INVALID_SAMPLE_TIME                  DRM_UI64(-1)
#define WAVE_FORMAT_PCM                      1
#define MFASF_MULTIPLEXER_AUTOADJUST_BITRATE 0x1
#define ASF_STATUSFLAGS_INCOMPLETE           ((DRM_DWORD) 0x01)
#define STANDARD_REPLICATED_DATA_SIZE        8
#define PAYLOAD_OVERHEAD                     27
#define REASONABLE_LOOKAHEAD_FOR_PAYLOAD     20
#define MAX_PACKET_PAYLOADS                  63
#define MFASF_MAX_STREAM_NUMBER              127

/* parsing/writing asf data */
#define LoadBYTEOffset( b, p, i )                                                    \
{                                                                                    \
    b = GET_BYTE(p, i);                                                              \
    i += SIZEOF_U8;                                                                  \
}

#define LoadWORDOffset( w, p, i )                                                    \
{                                                                                    \
    DRM_BYT_CopyBytes( &(w), 0, (DRM_BYTE *) (p), (i), SIZEOF( DRM_WORD ) );         \
    FIX_ENDIAN_WORD((w));                                                            \
    (i) += SIZEOF( DRM_WORD );                                                       \
}

#define LoadDWORDOffset( dw, p, i )                                                  \
{                                                                                    \
    DRM_BYT_CopyBytes( &(dw), 0, (DRM_BYTE *) (p), (i), SIZEOF( DRM_DWORD ) );       \
    FIX_ENDIAN_DWORD((dw));                                                          \
    (i) += SIZEOF( DRM_DWORD );                                                      \
}

#define LoadQWORDOffset( qw, p, i )                                                  \
{                                                                                    \
    DRM_BYT_CopyBytes( &(qw), 0, (DRM_BYTE *) (p), (i), SIZEOF( DRM_UINT64 ) );      \
    FIX_ENDIAN_QWORD((qw));                                                          \
    (i) += SIZEOF( DRM_UINT64 );                                                     \
}

#define LoadGUIDOffset( g, p, i )                                                    \
{                                                                                    \
    LoadDWORDOffset( (g).Data1, p, i );                                              \
    LoadWORDOffset( (g).Data2, p, i );                                               \
    LoadWORDOffset( (g).Data3, p, i );                                               \
    PUT_BYTE((g).Data4, 0, GET_BYTE(p, i));                                          \
    PUT_BYTE((g).Data4, 1, GET_BYTE(p, (i + 1)));                                    \
    PUT_BYTE((g).Data4, 2, GET_BYTE(p, (i + 2)));                                    \
    PUT_BYTE((g).Data4, 3, GET_BYTE(p, (i + 3)));                                    \
    PUT_BYTE((g).Data4, 4, GET_BYTE(p, (i + 4)));                                    \
    PUT_BYTE((g).Data4, 5, GET_BYTE(p, (i + 5)));                                    \
    PUT_BYTE((g).Data4, 6, GET_BYTE(p, (i + 6)));                                    \
    PUT_BYTE((g).Data4, 7, GET_BYTE(p, (i + 7)));                                    \
    i += 8;                                                                          \
}

#define SaveBYTEOffset( byteptr, byte, i )                                           \
{                                                                                    \
    PUT_BYTE(byteptr, i, byte);                                                      \
    i += SIZEOF_U8;                                                                  \
}

#define SaveWORDOffset( byteptr, word, i )                                           \
{                                                                                    \
    FIX_ENDIAN_WORD((word));                                                         \
    DRM_BYT_CopyBytes((byteptr),(i),(DRM_BYTE*)&(word),0,SIZEOF(DRM_WORD));          \
    FIX_ENDIAN_WORD((word));                                                         \
    (i) += SIZEOF( DRM_WORD );                                                       \
}

#define SaveDWORDOffset( byteptr, dword, i )                                         \
{                                                                                    \
    FIX_ENDIAN_DWORD((dword));                                                       \
    DRM_BYT_CopyBytes((byteptr),(i),(DRM_BYTE*)&(dword),0,SIZEOF(DRM_DWORD));        \
    FIX_ENDIAN_DWORD((dword));                                                       \
    (i) += SIZEOF( DRM_DWORD );                                                      \
}

#define SaveQWORDOffset( byteptr, qword, i )                                         \
{                                                                                    \
    FIX_ENDIAN_QWORD((qword));                                                       \
    DRM_BYT_CopyBytes((byteptr),(i),(DRM_BYTE*)&(qword),0,SIZEOF(DRM_UINT64));       \
    FIX_ENDIAN_QWORD((qword));                                                       \
    (i) += SIZEOF( DRM_UINT64 );                                                     \
}

#define SaveGUIDOffset( p, g, i )                                                    \
{                                                                                    \
    SaveDWORDOffset( p, (g).Data1, i );                                              \
    SaveWORDOffset( p, (g).Data2, i );                                               \
    SaveWORDOffset( p, (g).Data3, i );                                               \
    PUT_BYTE(p, i, GET_BYTE((g).Data4, 0));                                          \
    PUT_BYTE(p, (i) + 1, GET_BYTE((g).Data4, 1));                                    \
    PUT_BYTE(p, (i) + 2, GET_BYTE((g).Data4, 2));                                    \
    PUT_BYTE(p, (i) + 3, GET_BYTE((g).Data4, 3));                                    \
    PUT_BYTE(p, (i) + 4, GET_BYTE((g).Data4, 4));                                    \
    PUT_BYTE(p, (i) + 5, GET_BYTE((g).Data4, 5));                                    \
    PUT_BYTE(p, (i) + 6, GET_BYTE((g).Data4, 6));                                    \
    PUT_BYTE(p, (i) + 7, GET_BYTE((g).Data4, 7));                                    \
    i += 8;                                                                          \
}


#ifdef DEBUG_MUX
#define MUX_TRACE(stuff) TRACE(stuff)
#else
#define MUX_TRACE(stuff)
#endif


DRM_RESULT DRM_CALL NDTMGR_ASF_Internal_InitializeTranscryption( 
    __out                       NDT_ASF_CONTEXT * const pAsfContext,
    __in                        DRM_VOID        * const pNDTManagerContext,
    __in const                  DRM_ID                  idSession,
    __in_bcount(cbLicenseKeyID) DRM_BYTE        * const pbLicenseKeyID,
    __in const                  DRM_DWORD               cbLicenseKeyID
);

DRM_RESULT DRM_CALL NDTMGR_ASF_Internal_Initialize( 
    __inout    NDT_ASF_CONTEXT * const pAsfContext,
    __in       OEM_FILEHDL             hFile
);

DRM_RESULT DRM_CALL NDTMGR_ASF_Internal_GetFileInfo( 
    __inout NDT_ASF_CONTEXT * const pAsfContext,
    __inout ASF_FILE_INFO   * const pFileInfo
);

DRM_RESULT DRM_CALL NDTMGR_ASF_Internal_ClearFileInfo( 
    __out ASF_FILE_INFO * const pFileInfo
);

DRM_RESULT DRM_CALL NDTMGR_ASF_Internal_SetTimePosition(
    __in_opt   DRM_VOID        *f_pOEMContext,
    __inout    NDT_ASF_CONTEXT *pAsfContext,
    __in       DRM_DWORD        dwTimePosition
);

DRM_RESULT DRM_CALL NDTMGR_ASF_Internal_Uninitialize( 
    __inout  NDT_ASF_CONTEXT * const pAsfContext
);

DRM_RESULT DRM_CALL NDTMGR_ASF_Internal_GetHeader(
    __in                     NDT_ASF_CONTEXT  * const pAsfContext,
    __out_bcount(*pcbHeader) DRM_BYTE         * const pbHeader,
    __inout                  DRM_DWORD        * const pcbHeader
);
DRM_RESULT NDTMGR_ASF_Internal_ReadData(
    __in_opt                 DRM_VOID        *f_pOEMContext,
    __inout                  NDT_ASF_CONTEXT *pAsfContext,
    __out_bcount(*f_pcbData) DRM_BYTE        *f_pbData,
    __inout                  DRM_DWORD       *f_pcbData
);
DRM_RESULT NDTMGR_ASF_Internal_ReadSample(
    __inout    NDT_ASF_CONTEXT  * const pAsfContext,
    __out      NDT_SAMPLEINFO   * const pSampleInfo,
    __out      ASF_SAMPLE             **ppSample,
    __in const DRM_DWORD        * const pcbSampleData
);

EXIT_PK_NAMESPACE;

#endif /* __NDTASF_INTERNAL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\ndtmanager_internal.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>

#if DRM_SUPPORT_REVOCATION
#include <drmrevocation.h>
#endif

#include <wmdrmndresults.h>
#include <ndtcontextsizes.h>
#include <drmndtmanager.h>
#include <oemndt.h>

#define CERTIFICATE_INFO_INITIALIZER { {0},  \
                                       {0},  \
                                       0,    \
                                       0,    \
                                       0,    \
                                       NULL  \
                                     }

ENTER_PK_NAMESPACE;

WMDRMND_RESULT DRM_NDT_DRToWMDRMNDError(
    __in const DRM_RESULT f_dr
);

DRM_RESULT DRM_CALL GetWMDRMNETRevocationEntries(
    __in_bcount(f_cbCRL) DRM_BYTE             *f_pbCRL,
    __in const           DRM_DWORD             f_cbCRL,
    __out                DRM_DWORD            *f_pcEntries,
    __out                WMDRMNET_CRL_ENTRY  **f_ppEntries
);

DRM_RESULT GetWMDRMNDRevocationList(
    __in  NDTMGR_CONTEXT_INTERNAL                 *f_pContext,
    __deref_out_bcount(*f_pcbCRLBuffer) DRM_BYTE **f_ppbCRLBuffer,
    __out DRM_DWORD                               *f_pcbCRLBuffer,
    __out DRM_DWORD                               *f_pdwCRLVersion
);

DRM_VOID LicenseFreeKey(
    __in     NDT_LICENSE_CONTEXT  *f_pLicContext
);

DRM_RESULT NDTMGR_Internal_FindSession(
    __in        NDTMGR_CONTEXT                      *f_pNdtMgrContext,
    __in const  DRM_ID                               f_idSession,
    __in const  NDTMGR_SESSION_TYPE                  f_SessionType,
    __out       NDTMGR_INTERNAL_SESSION_CONTEXT    **f_ppSessionContext
);

DRM_RESULT NDTMGR_Internal_CreateSession(
    __in_opt    DRM_VOID                            *f_pOEMContext,
    __in        NDTMGR_CONTEXT                      *f_pNdtMgrContext,
    __in const  NDTMGR_SESSION_TYPE                  f_sessionType,
    __in_opt    DRM_APP_CONTEXT                     *f_pAppContext,
    __out       NDTMGR_INTERNAL_SESSION_CONTEXT    **f_ppSessionContext
);

DRM_RESULT NDTMGR_Internal_RemoveSession(
    __in        NDTMGR_CONTEXT                      *f_pNdtMgrContext,
    __in        NDTMGR_INTERNAL_SESSION_CONTEXT     *f_pSessionContext
);

DRM_RESULT DRM_NDT_Proximity_VerifyEncryptedChallenge(
    __in_opt   DRM_VOID                 *f_pOEMContext,
    __in       NDTMGR_CONTEXT           *f_pNdtMgrContext,
    __in const DRM_ID                    f_idRegistrationSession,
    __in       DRM_ID                    f_EncryptedChallenge
);

DRM_RESULT DRM_NDT_Proximity_GetChallenge(
    __in_opt   DRM_VOID                 *f_pOEMContext,
    __in       NDTMGR_CONTEXT           *f_pNdtMgrContext,
    __in const DRM_ID                    f_idRegistrationSession,
    __out      DRM_ID                   *f_pChallenge
);

EXIT_PK_NAMESPACE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\ndtencrypt.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __NDTENCRYPT_H__
#define __NDTENCRYPT_H__

ENTER_PK_NAMESPACE;

DRM_API DRM_RESULT DRM_CALL NDTMGR_Encrypt(
    __in        NDTMGR_CONTEXT      *f_pNdtMgrContext,
    __in const  DRM_ID               f_idSession,
    __in const  NDT_ENCRYPTION_MODE  f_EncryptionMode,
    __inout     DRM_VOID            *f_CryptoData
);

EXIT_PK_NAMESPACE;

#endif  /* __NDTENCRYPT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\ndtconstants.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __NDTCONSTANTS_H__
#define __NDTCONSTANTS_H__

#include "ndttypes.h"

ENTER_PK_NAMESPACE;

#define MAXIMUM_LIMIT_FOR_OPENED_DEVICES      10
#define MS_TO_HNS_MULTIPLIER                  10000
#define NDT_FEATURE_RECEIVER                  0x1
#define NDT_FEATURE_TRANSMITTER               0x2
#define NDT_FEATURE_SHARED_CERT               0x4
#define NDTMGR_ASF_WMDRMPROTECTED             0x00000001
#define NDTMGR_ASF_LICENSE_PLAYAVAILABLE      0x00000002

/* Strings for expression evaluator variable evaluation */
extern const DRM_ANSI_CONST_STRING g_dastrTagWMDRMReceiver;         
extern const DRM_ANSI_CONST_STRING g_dastrTagWMDRMTransmitter;      
extern const DRM_ANSI_CONST_STRING g_dastrTagWMDRMSharedCertificate;
extern const DRM_ANSI_CONST_STRING g_dastrDRM_RIGHT_PLAYBACK;

extern const DRM_CONST_STRING      g_dstrDRM_RIGHT_PLAYBACK;
extern const DRM_ID                g_idNULLSessionID;
extern const DRM_CONST_STRING      g_dstrDeviceAttrLastValidationTime;

EXIT_PK_NAMESPACE;

#endif /*  __NDTCONSTANTS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\ndtrevguids.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __NDTREVGUIDS_H__
#define __NDTREVGUIDS_H__

#include <drmcommon.h>
#include <drmtypes.h>


#ifndef DRM_IsEqualGUID
#define DRM_IsEqualGUID( rguid1, rguid2 ) ( ! MEMCMP( rguid1, rguid2, SIZEOF( DRM_GUID ) ) )
#endif /* DRM_IsEqualGUID */

DRM_DECLARE_GUID( GUID_WMDRMRevocationTypeApp );

DRM_DECLARE_GUID( GUID_WMDRMRevocationTypeWmdrmpd );

DRM_DECLARE_GUID( GUID_WMDRMRevocationTypeWmdrmnd );

DRM_DECLARE_GUID( GUID_WMDRMRevocationTypeRiv );

#endif /* __NDTREVGUIDS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\ndtnetmsg.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef _NDTNETMSG_H_
#define _NDTNETMSG_H_

#include <drmcommon.h>
#include <drmrevocation.h>
#include <ndtcontextsizes.h>

ENTER_PK_NAMESPACE;

/*
 * Version of the WMDRMNET protocol
 */
#define WMDRMNET_VERSION_2 2

/*
 * Message Types of the WMDRMNET protocol
 */

/* Registration Message */
#define WMDRMNET_REGISTRATION_MESSAGE_TYPE 1
#define WMDRMNET_REGISTRATION_MESSAGE_SIZE ( \
            SIZEOF_U8 +                         /* Protocol Vesion */ \
            SIZEOF_U8 +                         /* Message Type */ \
            SIZEOF(DRM_ID) +                    /* Serial Number */ \
            SIZEOF(DRM_DWORD) )                 /* Certificate Length */ \


/* Registration Response Message */
#define WMDRMNET_REGISTRATION_RESPONSE_MESSAGE_TYPE 2
#define WMDRMNET_REGISTRATION_RESPONSE_MESSAGE_SIZE ( \
            SIZEOF_U8 +                         /* Protocol Vesion */ \
            SIZEOF_U8 +                         /* Message Type */ \
            SIZEOF(DRM_WORD) +                  /* Signature Offset */ \
            SIZEOF(DRM_ID) +                    /* Serial Number */ \
            SIZEOF(DRM_ID) +                    /* Session ID */ \
            SIZEOF(DRM_WORD) +                  /* Address Length */ \
            SIZEOF_U8 +                         /* Seed Encryption Type */  \
            SIZEOF(DRM_WORD) +                  /* Seed Length */  \
            SIZEOF_U8 +                         /* Signature Type */ \
            SIZEOF(DRM_WORD) )                  /* Signature Length */ \

/* Proximity Start Message */
#define WMDRMNET_PROXIMITY_START_MESSAGE_TYPE 3
#define WMDRMNET_PROXIMITY_START_MESSAGE_SIZE ( \
            SIZEOF_U8 +                  /* Protocol Vesion */ \
            SIZEOF_U8 +                  /* Message Type */ \
            SIZEOF(DRM_ID) )                    /* Session ID */ \


/* Proximity Challenge Message */
#define WMDRMNET_PROXIMITY_CHALLENGE_MESSAGE_TYPE 4
#define WMDRMNET_PROXIMITY_CHALLENGE_MESSAGE_SIZE ( \
            SIZEOF_U8 +                  /* Protocol Vesion */ \
            SIZEOF_U8 +                  /* Message Type */ \
            SIZEOF_U8 +                  /* Sequence Number */ \
            SIZEOF(DRM_ID) +                    /* Session ID */ \
            SIZEOF(DRM_ID) )                    /* Challenge */ \

/* Proximity Response Message */
#define WMDRMNET_PROXIMITY_RESPONSE_MESSAGE_TYPE 5
#define WMDRMNET_PROXIMITY_RESPONSE_MESSAGE_SIZE ( \
            SIZEOF_U8 +                  /* Protocol Vesion */ \
            SIZEOF_U8 +                  /* Message Type */ \
            SIZEOF_U8 +                  /* Sequence Number */ \
            SIZEOF(DRM_ID) )                    /* Session ID */ \

/* Proximity Result Message */
#define WMDRMNET_PROXIMITY_RESULT_MESSAGE_TYPE 6
#define WMDRMNET_PROXIMITY_RESULT_MESSAGE_SIZE ( \
            SIZEOF_U8 +                  /* Protocol Vesion */ \
            SIZEOF_U8 +                  /* Message Type */ \
            SIZEOF(DRM_ID) +                    /* Session ID */ \
            SIZEOF(DRM_WORD) )                  /* Result */

/* License Request Message */
#define WMDRMNET_LICENSE_REQUEST_MESSAGE_TYPE 7
#define WMDRMNET_LICENSE_REQUEST_MESSAGE_SIZE ( \
            SIZEOF_U8 +                         /* Protocol Vesion */ \
            SIZEOF_U8 +                         /* Message Type */ \
            SIZEOF(DRM_ID) +                    /* Rights ID */ \
            SIZEOF(DRM_DWORD) +                 /* Reserved */ \
            SIZEOF(DRM_ID) +                    /* Serial Number */ \
            SIZEOF(DRM_DWORD) +                 /* Certificate Length */ \
            SIZEOF(DRM_WORD) )                  /* Action Length */

/* License Response Message */
#define WMDRMNET_LICENSE_RESPONSE_MESSAGE_TYPE 8
#define WMDRMNET_LICENSE_RESPONSE_MESSAGE_SIZE ( \
            SIZEOF_U8 +                        /* Protocol Vesion */ \
            SIZEOF_U8 +                        /* Message Type */ \
            SIZEOF(DRM_DWORD) +                /* Length of Reserved field */ \
            SIZEOF(DRM_DWORD))                 /* Length of XMR License */ \

#define WMDRMNET_REVOCATION_LIST_REQUEST_MESSAGE_TYPE 10
#define WMDRMNET_REVOCATION_LIST_REQUEST_MESSAGE_SIZE ( \
            SIZEOF_U8 +                        /* Protocol Vesion */ \
            SIZEOF_U8 +                        /* Message Type */ \
            SIZEOF_U8 )                        /* Number of entries */ \

#define WMDRMNET_REVOCATION_LIST_RESPONSE_MESSAGE_TYPE 11
#define WMDRMNET_REVOCATION_LIST_RESPONSE_MESSAGE_SIZE ( \
            SIZEOF_U8 +                        /* Protocol Vesion */ \
            SIZEOF_U8 )                        /* Message Type */

/* Define signature types */
#define WMDRMNET_SIGNATURE_AES_OMAC_TYPE    1 /* AES OMAC1 */
#define WMDRMNET_SIGNATURE_SHA_RSAPSS_TYPE  2 /* SHA1 signed by the 1024-bit RSA private key */

#define WMDRMNET_SIGNATURE_AES_OMAC_LENGTH	DRM_AES_BLOCKLEN /* OMAC Signature Size */

/* Define encryption types */
#define WMDRMNET_ENCRYPT_RSA_OAEP 1   /* 1024-bit RSA OAEP */

/* Actions */
#define WMDRMNET_PLAY_ACTION "PLAY"
#define WMDRMNET_PLAY_ACTION_SIZE 4 /* unused */


/*
 *
 * Define a structure for packing and unpacking WmdrmNet messages
 */

typedef struct {

    /* Allocated Buffer */
    DRM_BYTE *Buffer;
    DRM_DWORD BufferSize;

    /* Current Offset into the buffer */
    DRM_DWORD Offset;

} WMDRMNET_MESSAGE_DESCRIPTOR;

/*
 * Low level procedures for packing and unpacking messages
 */

DRM_API DRM_RESULT DRM_CALL WmdrmNetAllocateMessageDescriptor(
    __in_bcount_opt(MessageSize) DRM_BYTE                    * const Message,
    __in const                   DRM_DWORD                           MessageSize,
    __out                        WMDRMNET_MESSAGE_DESCRIPTOR       **MessageDescriptor
);

DRM_API DRM_DWORD DRM_CALL WmdrmNetFixedMessageSize(
    __in const DRM_BYTE f_bMessageType
);

DRM_API DRM_VOID DRM_CALL WmdrmNetPackOctet(
    __out      WMDRMNET_MESSAGE_DESCRIPTOR * const MessageDescriptor,
    __in const DRM_BYTE                            Octet
);

DRM_API DRM_BOOL DRM_CALL WmdrmNetUnpackOctet(
    __inout WMDRMNET_MESSAGE_DESCRIPTOR * const MessageDescriptor,
    __out   DRM_BYTE                    * const Octet
);

DRM_API DRM_BOOL DRM_CALL WmdrmNetUnpackOctets(
    __inout                       WMDRMNET_MESSAGE_DESCRIPTOR * const MessageDescriptor,
    __deref_out_bcount(ValueSize) DRM_BYTE                          **Value,
    __in const                    DRM_DWORD                           ValueSize
);

DRM_API DRM_VOID DRM_CALL WmdrmNetPackWord(
    __out      WMDRMNET_MESSAGE_DESCRIPTOR * const MessageDescriptor,
    __in const DRM_WORD                            Value
);

DRM_API DRM_BOOL DRM_CALL WmdrmNetUnpackWord(
    __inout                        WMDRMNET_MESSAGE_DESCRIPTOR * const MessageDescriptor,
    __out_bcount(SIZEOF(DRM_WORD)) DRM_WORD                    * const Value
);

DRM_API DRM_VOID DRM_CALL WmdrmNetPackDword(
    __out      WMDRMNET_MESSAGE_DESCRIPTOR * const MessageDescriptor,
    __in const DRM_DWORD                           Value
);

DRM_API DRM_VOID DRM_CALL WmdrmNetPackUint64(
    __out      WMDRMNET_MESSAGE_DESCRIPTOR * const MessageDescriptor,
    __in const DRM_UINT64                          Value
);

DRM_API DRM_BOOL DRM_CALL WmdrmNetUnpackDword(
    __inout                         WMDRMNET_MESSAGE_DESCRIPTOR * const MessageDescriptor,
    __out_bcount(SIZEOF(DRM_DWORD)) DRM_DWORD                   * const Value
);

DRM_API DRM_BOOL DRM_CALL WmdrmNetUnpackVal128(
    __inout                      WMDRMNET_MESSAGE_DESCRIPTOR * const MessageDescriptor,
    __out_bcount(SIZEOF(DRM_ID)) DRM_ID                      * const Value
);

DRM_API DRM_VOID DRM_CALL WmdrmNetFreeMessageDescriptor(
    __out      WMDRMNET_MESSAGE_DESCRIPTOR *f_MessageDescriptor,
    __in const DRM_BOOL                     f_fDone
);




/*
 * Procedures for packing and unpacking messages
 */

DRM_API DRM_BYTE DRM_CALL WmdrmNetGetMessageType(
    __in_bcount(MessageSize) const DRM_BYTE  * const Message,
    __in                     const DRM_DWORD         MessageSize
);



/*
** ----------------------------------------------------------------------------
**                            REGISTRATION functions
** ----------------------------------------------------------------------------
*/

DRM_API DRM_RESULT DRM_CALL WmdrmNetUnpackRegistrationRequestMessage(
    __in_bcount(f_cbMessage)                    DRM_BYTE  * const f_pbMessage,
    __in const                                  DRM_DWORD         f_cbMessage,
    __out                                       DRM_ID    * const f_pSerialNumber,
    __deref_out_bcount(*f_pcbDeviceCertificate) DRM_BYTE        **f_ppbDeviceCertificate,
    __out                                       DRM_DWORD        *f_pcbDeviceCertificate
);

DRM_API DRM_RESULT DRM_CALL WmdrmNetPackRegistrationResponseMessage(
    __in const                     DRM_ID             * const f_pSerialNumber,
    __in const                     DRM_RSA_PUBLIC_KEY * const f_pDevicePublicKey,
    __in const                     DRM_DWORD                  f_cbPubKeyModulus,
    __in const                     DRM_ID             * const f_pSessionId,
    __in const                     DRM_ID             * const f_pSeed,
    __in_bcount(f_cbAddress) const DRM_BYTE           * const f_pAddress,
    __in const                     DRM_WORD                   f_cbAddress,
    __out_bcount(*f_pcbMessage)    DRM_BYTE           * const f_pbMessage,
    __inout                        DRM_DWORD          * const f_pcbMessage
);

DRM_API DRM_RESULT DRM_CALL WmdrmNetPackRegistrationMessage(
    __in const                               DRM_ID   * const SerialNumber,
    __in_bcount(DeviceCertificateSize) const DRM_BYTE * const DeviceCertificate,
    __in const                               DRM_DWORD        DeviceCertificateSize,
    __deref_out_bcount_full(*MessageSize)    DRM_BYTE       **Message,
    __out DRM_DWORD                                   * const MessageSize
);

DRM_API DRM_RESULT DRM_CALL WmdrmNetUnpackRegistrationResponseMessage(
    __in const                        DRM_RSA_PRIVATE_KEY * const f_pPrivateKey,
    __in_bcount(f_cbMessage)          DRM_BYTE            * const f_pbMessage,
    __in const                        DRM_DWORD                   f_cbMessage,
    __out                             DRM_ID              * const f_pidSeed,
    __out                             DRM_ID              * const f_pidSerialNumber,
    __out                             DRM_ID              * const f_pidSession,
    __deref_out_bcount(*f_pcbAddress) DRM_BYTE                  **f_ppbAddress,
    __out                             DRM_WORD            * const f_pcbAddress,
    __in                              DRM_CRYPTO_CONTEXT  *       f_pCryptoCtx    
);



/*
** ----------------------------------------------------------------------------
**                            PROXIMITY functions
** ----------------------------------------------------------------------------
*/

DRM_API DRM_RESULT DRM_CALL WmdrmNetPackProximityStartMessage(
    __in const                       DRM_ID     * const SessionId,
    __deref_out_bcount(*MessageSize) DRM_BYTE         **Message,
    __out                            DRM_DWORD  * const MessageSize
);

DRM_API DRM_RESULT DRM_CALL WmdrmNetUnpackProximityStartMessage(
    __in_bcount(MessageSize) DRM_BYTE * const Message,
    __in const               DRM_DWORD        MessageSize,
    __out                    DRM_ID   * const SessionID
);

DRM_API DRM_RESULT DRM_CALL WmdrmNetPackProximityChallengeMessage(
    __in const                       DRM_BYTE          bSequenceNumber,
    __in const                       DRM_ID    * const idSession,
    __in const                       DRM_ID    * const idChallenge,
    __deref_out_bcount(*MessageSize) DRM_BYTE        **Message,
    __out                            DRM_DWORD * const MessageSize
);

DRM_API DRM_RESULT DRM_CALL WmdrmNetUnpackProximityChallengeMessage(
    __in_bcount(MessageSize) DRM_BYTE  * const Message,
    __in const               DRM_DWORD         MessageSize,
    __out                    DRM_BYTE  * const Sequence,
    __out                    DRM_ID    * const SessionId,
    __out                    DRM_ID    * const Challenge
);

DRM_API DRM_RESULT DRM_CALL WmdrmNetPackProximityResponseMessage(
    __in const                       DRM_AES_KEY * const pAesKey,
    __in const                       DRM_BYTE            Sequence,
    __in const                       DRM_ID      * const SessionId,
    __in const                       DRM_ID      * const Challenge,
    __deref_out_bcount(*MessageSize) DRM_BYTE          **Message,
    __out                            DRM_DWORD   * const MessageSize
);

DRM_API DRM_RESULT DRM_CALL WmdrmNetUnpackProximityResponseMessage(
    __in_bcount(MessageSize) DRM_BYTE  * const Message,
    __in const               DRM_DWORD         MessageSize,
    __out                    DRM_BYTE  * const Sequence,
    __out                    DRM_ID    * const SessionID,
    __out                    DRM_ID    * const Nonce
);

DRM_API DRM_RESULT DRM_CALL WmdrmNetPackProximityResultMessage(
    __in const                       DRM_ID    * const SessionID,
    __in const                       DRM_WORD          Result,
    __deref_out_bcount(*MessageSize) DRM_BYTE        **Message,
    __out                            DRM_DWORD * const MessageSize
);

DRM_API DRM_RESULT DRM_CALL WmdrmNetUnpackProximityResultMessage(
    __in_bcount(MessageSize) DRM_BYTE  * const Message,
    __in const               DRM_DWORD         MessageSize,
    __out                    DRM_ID    * const SessionId,
    __out                    DRM_WORD  * const Result
);




/*
** ----------------------------------------------------------------------------
**                            LICENSE functions
** ----------------------------------------------------------------------------
*/

DRM_API DRM_RESULT DRM_CALL WmdrmNetUnpackLicenseRequestMessage(
    __in_bcount(f_cbMessage)         DRM_BYTE  * const f_pbMessage,
    __in const                       DRM_DWORD         f_cbMessage,
    __out                            DRM_ID    * const f_pRightsId,
    __out                            DRM_ID    * const f_pSerialNumber,
    __deref_out_bcount(*f_pcbDeviceCertificate) DRM_BYTE **f_ppbDeviceCertificate,
    __out                            DRM_DWORD * const f_pcbDeviceCertificate,
    __deref_out_bcount(*f_pcbAction) DRM_BYTE        **f_ppbAction,
    __out                            DRM_WORD  * const f_pcbAction,
    __out                            DRM_DWORD * const f_pdwCRLVersion
);

DRM_API DRM_RESULT DRM_CALL WmdrmNetPackLicenseResponseMessage(
    __in_bcount(f_cbLicense)   const  DRM_BYTE  * const f_pbLicense,
    __in                       const  DRM_DWORD         f_cbLicense,
    __in_bcount(f_cbCRLBuffer) const  DRM_BYTE  * const f_pbCRLBuffer,
    __in const                        DRM_DWORD         f_cbCRLBuffer,
    __deref_out_bcount(*f_pcbMessage) DRM_BYTE        **f_ppbMessage,
    __out                             DRM_DWORD * const f_pcbMessage
);

DRM_API DRM_RESULT DRM_CALL WmdrmNetPackLicenseRequestMessage(
    __in const                               DRM_ID    * const RightsId,
    __in const                               DRM_ID    * const SerialNumber,
    __in_bcount(DeviceCertificateSize) const DRM_BYTE  * const DeviceCertificate,
    __in const                               DRM_DWORD         DeviceCertificateSize,
    __in_bcount(ActionSize) const            DRM_BYTE  * const Action,
    __in const                               DRM_WORD          ActionSize,
    __deref_out_bcount(*MessageSize)         DRM_BYTE        **Message,
    __out                                    DRM_DWORD * const MessageSize
);

DRM_API DRM_RESULT DRM_CALL WmdrmNetUnpackLicenseResponseMessage(
    __in_bcount(MessageSize)       DRM_BYTE  * const Message,
    __in const                     DRM_DWORD         MessageSize,
    __deref_out_bcount(*cbLicense) DRM_BYTE        **ppbLicense,
    __out                          DRM_DWORD * const cbLicense
);




/*
** ----------------------------------------------------------------------------
**                            REVOCATION functions
** ----------------------------------------------------------------------------
*/

DRM_API DRM_RESULT DRM_CALL WmdrmNetUnpackRevocationListRequestMessage(
    __in_bcount(f_cbMessage)                      DRM_BYTE  * const f_pbMessage,
    __in const                                    DRM_DWORD         f_cbMessage,
    __out                                         DRM_DWORD * const f_pcguidsRevocationLists,
    __deref_out_ecount(*f_pcguidsRevocationLists) DRM_GUID        **f_ppguidsRevocationLists
);

DRM_API DRM_RESULT DRM_CALL WmdrmNetPackRevocationListResponseMessage(
    __in const                            DRM_DWORD            f_cRevocationLists,
    __in_ecount(f_cRevocationLists) const DRM_RVK_LIST * const f_pRevocationLists,
    __inout_bcount(*f_pcbMessage)         DRM_BYTE     * const f_pbMessage,
    __inout                               DRM_DWORD    * const f_pcbMessage
);

DRM_API DRM_RESULT DRM_CALL WmdrmNetPackRevocationListRequestMessage(
    __in const                                 DRM_DWORD         f_cguidsRevocationLists,
    __in_ecount(f_cguidsRevocationLists) const DRM_GUID  * const f_pguidsRevocationLists,
    __inout_bcount_opt(*f_pcbMessage)          DRM_BYTE  * const f_pbMessage,
    __inout                                    DRM_DWORD * const f_pcbMessage
);

DRM_API DRM_RESULT DRM_CALL WmdrmNetUnpackRevocationListResponseMessage(
    __in_bcount(f_cbMessage)                 DRM_BYTE     * const f_pbMessage,
    __in const                               DRM_DWORD            f_cbMessage,
    __inout                                  DRM_DWORD    * const f_pcRevocationLists,
    __inout_ecount_opt(*f_pcRevocationLists) DRM_RVK_LIST * const f_pRevocationLists
);

EXIT_PK_NAMESPACE;

#endif /* _NDTNETMSG_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\ndtreg.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __NDTREG_H__
#define __NDTREG_H__

#include <drmndtmanager.h>

ENTER_PK_NAMESPACE;

DRM_RESULT NDT_ValidateCertificate(
    __in        NDTMGR_CONTEXT_INTERNAL                  *f_pNdtMgrContext,
    __in_ecount(f_cbDeviceCertificate) DRM_CHAR   * const f_rgchDeviceCertificate,
    __in const  DRM_DWORD                                 f_cbDeviceCertificate,
    __inout     DRM_SUBSTRING                            *f_pdasstrWMDRMNDCertificate,
    __out       NDT_CERTIFICATE_INFO              * const f_pCertificateInfo,
    __deref_opt_out_bcount(*f_pcbCRL) DRM_BYTE          **f_ppbCRL,
    __out_opt   DRM_DWORD                         * const f_pcbCRL,
    __out       DRM_DWORD                         * const f_pdwCRLVersion
);

DRM_RESULT NDT_EncryptSeed( 
    __in const                  DRM_RSA_PUBLIC_KEY  * const f_pDevicePublicKey,
    __in const                  DRM_ID              * const f_pSeed,
    __in const                  DRM_DWORD                   f_wBufferSize,
    __out_bcount(f_wBufferSize) DRM_BYTE            * const f_pbEncryptedSeed,
    __out                       DRM_DWORD           * const f_pdwBytesWritten
);

DRM_RESULT NDT_SignRegistrationMessage(
    __in_bcount(f_cbMessage) const  DRM_BYTE    * const f_pbMessage,
    __in const                      DRM_DWORD           f_cbMessage,
    __in const                      DRM_ID      * const f_pSeed,
    __in const                      DRM_DWORD           f_cbSignature,
    __inout_bcount(f_cbSignature)   DRM_BYTE    * const f_pbSignature,
    __out                           DRM_DWORD   * const f_pdwBytesWritten
);

DRM_API DRM_AES_KEY * DRM_CALL WmdrmNetGetRegistrationKey(
    __in const DRM_ID    * const f_pSeed,
    __in const DRM_BOOL          f_bComputeContentIntegrityKey
);

EXIT_PK_NAMESPACE;

#endif /* __NDTREG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\ndttypes.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __NDTTYPES_H__
#define __NDTTYPES_H__

#include <drmtypes.h>
#include <drmoutputleveltypes.h>

ENTER_PK_NAMESPACE;

typedef enum _tagDRM_REVOCATION_LIST_TYPE
{
    DRM_REVOCATION_LIST_ALL = -1,
    DRM_REVOCATION_LIST_RIV,
    DRM_REVOCATION_LIST_APPS,
    DRM_REVOCATION_LIST_DEVICE,
    DRM_REVOCATION_LIST_NET
} DRM_REVOCATION_LIST_TYPE;

typedef enum _NDTMGR_SESSION_TYPE
{
    NDTMGR_SESSION_TYPE_REGISTRATION = 0x00,
    NDTMGR_SESSION_TYPE_CONTENT      = 0x01
} NDTMGR_SESSION_TYPE;

typedef enum _NDT_ASFDELIVERY_MODE
{
    NDT_ASFDELIVERY_MODE_MUXED   = 0,
    NDT_ASFDELIVERY_MODE_SAMPLES = 1
} NDT_ASFDELIVERY_MODE;

typedef struct _NDT_SAMPLEINFO
{
    DRM_DWORD    dwStreamID;
    DRM_UINT64   qwSampleTimeNS;
    DRM_UINT64   qwSampleDurationNS;
    DRM_UINT64   qwSampleID;
} NDT_SAMPLEINFO;

typedef enum tagNDT_LICENSE_MODE
{
    NDT_LICENSE_MODE_SIMPLE  = 0,
    NDT_LICENSE_MODE_CHAINED = 1
} NDT_LICENSE_MODE;

typedef struct __tagDRM_GUIDLIST
{
    DRM_DWORD  cGUIDs;
    DRM_BYTE  *pguidBuffer;
} DRM_GUIDLIST;

#ifndef __wmdrmsdk_h__

typedef enum tagWMDRMNET_POLICY_TYPE
{
	WMDRMNET_POLICY_TYPE_UNDEFINED      = 0x0000,
    WMDRMNET_POLICY_TYPE_TRANSCRYPTPLAY = 0x0001,
} WMDRMNET_POLICY_TYPE;

typedef struct tagWMDRMNET_POLICY
{
    WMDRMNET_POLICY_TYPE ePolicyType;
    DRM_BYTE pbPolicy[1];
} WMDRMNET_POLICY;

#endif

typedef struct tagWMDRMNET_POLICY_MINIMUM_ENVIRONMENT
{
    DRM_WORD wMinimumSecurityLevel;
    DRM_DWORD dwMinimumAppRevocationListVersion;
    DRM_DWORD dwMinimumDeviceRevocationListVersion;
} WMDRMNET_POLICY_MINIMUM_ENVIRONMENT;

typedef struct tagWMDRMNET_POLICY_GLOBAL_REQUIREMENTS
{
    WMDRMNET_POLICY_MINIMUM_ENVIRONMENT MinimumEnvironment;
    DRM_DWORD                           dwSourceID;
    DRM_GUIDLIST                        InclusionList;
    DRM_DWORD                           dwRiv;
} WMDRMNET_POLICY_GLOBAL_REQUIREMENTS;

#ifndef __wmdrmsdk_h__

typedef struct tagWMDRMNET_POLICY_TRANSCRYPTPLAY
{
    WMDRMNET_POLICY_GLOBAL_REQUIREMENTS globals;
    DRM_PLAY_OPL playOPLs;
} WMDRMNET_POLICY_TRANSCRYPTPLAY;

#endif

EXIT_PK_NAMESPACE;

#endif /* __NDTTYPES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\oemaes.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
**  oemaes.h
**
**  Contains structures and function definitions implemented in oemaes.c
**  
*/

#ifndef __OEMAES_H__
#define __OEMAES_H__

#include <oemaesimpl.h>
#include <drmaescommon.h>

ENTER_PK_NAMESPACE;

/*
** AES secret key
**
** The actual contents of the structure are opaque.
**
** The opaque data is represented as a byte array below.
** Do not access the array directly.
*/
typedef struct __tagDRM_AES_KEY 
{
    DRM_BYTE rgbOpaque[__CB_DECL( DRM_AES_KEYSIZE )];
} DRM_AES_KEY;

DRM_API DRM_RESULT DRM_CALL Oem_Aes_ZeroKey( 
    __inout_ecount( 1 )                      DRM_AES_KEY  *f_pKey );

DRM_API DRM_RESULT DRM_CALL Oem_Aes_SetKey(
    __in_bcount( DRM_AES_KEYSIZE_128 ) const DRM_BYTE      f_rgbKey[__CB_DECL( DRM_AES_KEYSIZE_128 )],
    __inout_ecount( 1 )                      DRM_AES_KEY  *f_pAesKey );

DRM_API DRM_RESULT DRM_CALL Oem_Aes_EncryptOne(
    __in_ecount( 1 )                   const DRM_AES_KEY  *f_pKey,        
    __inout_bcount( DRM_AES_BLOCKLEN )       DRM_BYTE      f_rgbData[__CB_DECL( DRM_AES_BLOCKLEN )] );

DRM_API DRM_RESULT DRM_CALL Oem_Aes_DecryptOne(
    __in_ecount( 1 )                   const DRM_AES_KEY  *f_pKey,    
    __inout_bcount( DRM_AES_BLOCKLEN )       DRM_BYTE      f_rgbData[__CB_DECL( DRM_AES_BLOCKLEN )] );

EXIT_PK_NAMESPACE;

#endif /* __OEMAES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\oemaesimpl.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
**  oemaesimpl.h
**
**  Contains AES secret key and key table definitions used in the oem aes implementation, and 
**  to create an opaque aes key structure in oemaes.h
**  
*/

#ifndef __OEMAESIMPL_H__
#define __OEMAESIMPL_H__

#include <drmaescommon.h>

ENTER_PK_NAMESPACE;

/*
** AES Key Table structures
*/
typedef struct 
{
    DRM_DWORD   keytabenc[DRM_AES_ROUNDS_128+1][4];
    DRM_DWORD   keytabdec[DRM_AES_ROUNDS_128+1][4];
} DRM_AESTable_128;

#define DRM_AESTable          DRM_AESTable_128
#define DRM_AES_TABLESIZE     SIZEOF( DRM_AESTable )

/*
** Internal AES secret key
*/
typedef struct 
{
    DRM_AESTable   AESTable;
    DRM_BYTE   rgbKey[__CB_DECL( DRM_AES_KEYSIZE_128 )];
} INTERNAL_DRM_AES_KEY;

#define DRM_AES_KEYSIZE  SIZEOF( INTERNAL_DRM_AES_KEY )


EXIT_PK_NAMESPACE;

#endif /* __OEMAESIMPL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\ndtlicense.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __NDTLICENSE_H__
#define __NDTLICENSE_H__

ENTER_PK_NAMESPACE;


#define DRM_XMR_CHAINED_CHECKSUM_LENGTH                 16
#define DRM_XMR_CHAINED_CHECKSUM_SHA_ITERATIONS         5


/* DRM status */
#define NDT_DRM_STATUS_UNPROTECTED 0
#define NDT_DRM_STATUS_PROTECTED   1

/* License status */
#define NDT_DRM_LICENSE_NOT_AVAILABLE   0
#define NDT_DRM_LICENSE_ALLOWS_PLAYBACK 1


DRM_VOID DRM_CALL DRM_NDT_License_FreePolicy(
    __out WMDRMNET_POLICY *f_pPolicy
);

DRM_RESULT DRM_CALL DRM_NDT_License_CreateDefaultPolicy(
    __in  NDTMGR_INTERNAL_CONTENTSESSION_CONTEXT  * const f_pContSessContext, 
    __deref_out_bcount(*f_pcbPolicy)  WMDRMNET_POLICY   **f_ppPolicy, 
    __out DRM_DWORD                               * const f_pcbPolicy
);

DRM_RESULT DRM_CALL DRM_NDT_License_SetRootPolicy( 
    __in  const NDTMGR_INTERNAL_CONTENTSESSION_CONTEXT  * const pContentSession,
    __out       WMDRMNET_POLICY                         * const pPolicy
);

DRM_RESULT DRM_CALL DRM_NDT_License_GenerateKeys(
    __in_opt  DRM_VOID                               *f_pOEMContext,
    __in      NDTMGR_INTERNAL_CONTENTSESSION_CONTEXT *f_pNdtContentSessionContext,
    __inout   NDT_LICENSE_CONTEXT                    *f_pLicContext
);

DRM_RESULT DRM_CALL NDT_RetrieveLicenseDataV1(
    __in NDTMGR_INTERNAL_CONTENTSESSION_CONTEXT        * const f_pNdtContentSessionContext,
    __in_bcount(f_cbKeyID)      const DRM_BYTE         * const f_pbKeyID,
    __in                        const DRM_DWORD                f_cbKeyID,
    __in_bcount(f_cbSecretData) const DRM_BYTE         * const f_pbSecretData,
    __in                        const DRM_DWORD                f_cbSecretData,
    __in_bcount(f_cbURL)        const DRM_BYTE         * const f_pbURL,
    __in                        const DRM_DWORD                f_cbURL,
    __in                        const DRM_CONST_STRING * const f_pdstrAction
);

DRM_API DRM_RESULT DRM_CALL NDT_RetrieveLicenseDataV2(
    __in       NDTMGR_INTERNAL_CONTENTSESSION_CONTEXT        * const f_pNdtContentSessionContext,
    __in_bcount(f_cbContentEncryptionObject) const DRM_BYTE  * const f_pbContentEncryptionObject,
    __in const DRM_DWORD                                             f_cbContentEncryptionObject,
    __in const DRM_CONST_STRING                              * const f_pdstrAction
);

DRM_RESULT DRM_CALL NDT_RetrieveLicenseDataPR(
    __in       NDTMGR_INTERNAL_CONTENTSESSION_CONTEXT * const f_pNdtContentSessionContext,
    __in_bcount(f_cbPlayReadyObject) const DRM_BYTE   * const f_pbPlayReadyObject,
    __in const DRM_DWORD                                      f_cbPlayReadyObject,
    __in const DRM_CONST_STRING                       * const f_pdstrAction
);

DRM_RESULT DRM_CALL NDT_License_BuildRootXMR(
    __in const  NDTMGR_CONTEXT                          * const f_pNdtMgrContext,
    __in const  NDTMGR_INTERNAL_CONTENTSESSION_CONTEXT  * const f_pNdtContentSessionContext,
    __in const  WMDRMNET_POLICY                         * const f_pPolicy,
    __in const  DRM_ID                                          f_idSerial,
    __in const  NDT_CERTIFICATE_INFO                    * const f_pCertificateInfo,
    __deref_out_bcount(*f_pcbXMR) DRM_BYTE                    **f_ppbXMR,
    __out       DRM_DWORD                                      *f_pcbXMR 
);

DRM_RESULT DRM_CALL NDT_License_BuildSimpleXMR(
    __in const  NDTMGR_CONTEXT                          * const f_pNdtMgrContext,
    __in const  NDTMGR_INTERNAL_CONTENTSESSION_CONTEXT  * const f_pNdtContentSessionContext,
    __in const  WMDRMNET_POLICY                         * const f_pPolicy,
    __in const  DRM_ID                                          f_idSerial,
    __in const  NDT_CERTIFICATE_INFO                    * const f_pCertificateInfo,
    __deref_out_bcount(*f_pcbXMR) DRM_BYTE                    **f_ppbXMR,
    __out       DRM_DWORD                                      *f_pcbXMR 
);

DRM_RESULT DRM_CALL NDT_License_BuildLeafXMR(
    __in const  NDTMGR_CONTEXT                          * const f_pNdtMgrContext,
    __in const  NDTMGR_INTERNAL_CONTENTSESSION_CONTEXT  * const f_pNdtContentSessionContext,
    __in const  WMDRMNET_POLICY                         * const f_pPolicy,
    __in const  DRM_ID                                          f_idSerial,
    __deref_out_bcount(*f_pcbXMR) DRM_BYTE                    **f_ppbXMR,
    __out       DRM_DWORD                                      *f_pcbXMR 
);

EXIT_PK_NAMESPACE;

#endif /* __NDTLICENSE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\oemcontextsizes.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __OEMCONTEXTSIZES_H__
#define __OEMCONTEXTSIZES_H__


#include <drmdevicestore.h>

ENTER_PK_NAMESPACE;

#if DRM_SUPPORT_DEVICESTORE
typedef DRM_DEVICESTORE_CONTEXT OEM_DEVICESTORE_CONTEXTINTERNAL;
#else
typedef DRM_BYTE OEM_DEVICESTORE_CONTEXTINTERNAL;
#endif

struct __tagOEM_DEVICESTORE_INITDATA;

typedef struct __tagOEM_DEVICESTORE_INITDATA OEM_DEVICESTORE_INITDATA;

#define OEM_DEVICESTORE_CONTEXT_BUFFER_SIZE SIZEOF(OEM_DEVICESTORE_CONTEXTINTERNAL)
typedef struct __tagOEM_DEVICESTORE_CONTEXT {
    DRM_BYTE rbgOpaqueBuffer[ __CB_DECL(OEM_DEVICESTORE_CONTEXT_BUFFER_SIZE ) ];
} OEM_DEVICESTORE_CONTEXT;


EXIT_PK_NAMESPACE;

#endif /* __OEMCONTEXTSIZESH__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\oemdebug.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __OEMDEBUG_H__
#define __OEMDEBUG_H__

ENTER_PK_NAMESPACE;

DRM_API DRM_VOID DRM_CALL Oem_Debug_Trace( 
    __in DRM_CHAR *szFmt,
    ... );

DRM_API DRM_VOID DRM_CALL Oem_Debug_HookTrace(
    __in DRM_VOID *pNewTraceFcn );

DRM_API DRM_VOID DRM_CALL Oem_Debug_Assert
(
    __in DRM_BOOL fAssert, 
    __in DRM_CHAR *assertcmd, 
    __in DRM_CHAR *file, 
    __in DRM_INT line
);

DRM_API DRM_VOID DRM_CALL Oem_Debug_HookAssert(
    __in DRM_VOID *pNewAssertFcn );


EXIT_PK_NAMESPACE;

#endif /* __OEMDEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\oemcommon.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __OEMCOMMON_H__
#define __OEMCOMMON_H__

#include <drmcommon.h>
#include <drmhash.h>
#include <drmpkcrypto.h>
#include <drmbase64.h>

ENTER_PK_NAMESPACE;

extern DRM_EXPORT_VAR DRM_CONST_STRING g_dstrDrmPath;

extern const DRM_CONST_STRING g_dstrPrivKey;
extern const DRM_CONST_STRING g_dstrZGPrivKey;
extern const DRM_CONST_STRING g_dstrZPrivKeySign;
extern const DRM_CONST_STRING g_dstrZPrivKeyEncrypt;
extern const DRM_CONST_STRING g_dstrNDRPrivKey;

extern const DRM_CONST_STRING g_dstrDevcert;
extern const DRM_CONST_STRING g_dstrDevcerttemplate;

extern const DRM_CONST_STRING g_dstrZDevcert;
extern const DRM_CONST_STRING g_dstrZGroupCert;

extern const DRM_CONST_STRING g_dstrReceiverCert;
extern const DRM_CONST_STRING g_dstrReceiverTemplate;

extern const DRM_CONST_STRING g_dstrDevcert;
extern const DRM_CONST_STRING g_dstrDevcerttemplate;

extern const DRM_CONST_STRING g_dstrReceiverCert;
extern const DRM_CONST_STRING g_dstrReceiverTemplate;

typedef enum DRMFILESPATH
{
    CERTPATH = 0,
    CERTTEMPLATEPATH,
    HDSPATH,
} DRMFILESPATH;

typedef enum
{
    DRM_DCT_WMDRMPD = 1,
    DRM_DCT_WMDRMPD_TEMPLATE,
    DRM_DCT_PLAYREADY,
    DRM_DCT_PLAYREADY_TEMPLATE,
    DRM_DCT_NETRECEIVER,
    DRM_DCT_NETRECEIVER_TEMPLATE,
} DRM_DEVICE_CERT_TYPE;

typedef enum
{
    DRM_DKT_WMDRMPD_GROUP = 1,
    DRM_DKT_WMDRMPD_FALLBACK,
    DRM_DKT_PLAYREADY_DEVICE_SIGN,
    DRM_DKT_PLAYREADY_DEVICE_ENCRYPT,
    DRM_DKT_PLAYREADY_MODEL,
    DRM_DKT_PLAYREADY_NDR,
    DRM_DKT_PLAYREADY_NDR_MODEL
} DRM_DEVICE_KEY_TYPE;

typedef enum
{
    DRM_DIT_WMDRMPD_ID = 1,
    DRM_DIT_PLAYREADY_ID,
} DRM_DEVICE_ID_TYPE;

typedef DRM_VOID * OEM_DEVICE_HANDLE;

/*
** Internal functions that should be implemented by each OEM
** implementation (oeminfo.c).
*/
DRM_API DRM_RESULT DRM_CALL _GetDRMFullPathName( 
    __out DRM_WCHAR **f_ppwszFullPath, 
    __in_opt const DRM_CONST_STRING *f_pdstrFilename,
    __in DRMFILESPATH f_eFilesPath );
    
DRM_RESULT _GetPrivateKey(
    __in_opt DRM_VOID *f_pOEMContext,
    __in const DRM_BOOL f_fGCprivkey,
    __out_bcount( f_cbPrivKey ) DRM_BYTE *f_pbPrivkey,
    __in DRM_DWORD f_cbPrivKey );

DRM_RESULT _GetHWID(
    __out_bcount(DRM_SHA1_DIGEST_LEN) DRM_BYTE *shaOut );

/* OEM device information functions. (oeminfo.c) */
DRM_API DRM_RESULT DRM_CALL Oem_Device_GetCert(
    __in_opt DRM_VOID *f_pOEMContext,
    __in const DRM_DEVICE_CERT_TYPE f_eCertType,
    __out_bcount_opt( *f_pcbDevCert ) DRM_BYTE *f_pbDevCert,
    __inout DRM_DWORD *f_pcbDevCert );

DRM_API DRM_RESULT DRM_CALL Oem_Device_SetCert(
    __in_opt DRM_VOID *f_pOEMContext,
    __in const DRM_DEVICE_CERT_TYPE f_eCertType,
    __in_bcount(f_cbDevCert) DRM_BYTE *f_pbDevCert,
    __in const DRM_DWORD f_cbDevCert );

DRM_API DRM_RESULT DRM_CALL Oem_Device_GetSecureStoreGlobalPasswordSeed( 
    __out_bcount(DRM_SHA1_DIGEST_LEN) DRM_BYTE f_rgbSecStorePassword[ __CB_DECL( DRM_SHA1_DIGEST_LEN ) ] );

DRM_API DRM_RESULT DRM_CALL Oem_Device_GetKey( 
    __in_opt DRM_VOID *f_pOEMContext,
    __in const DRM_DEVICE_KEY_TYPE f_eKeyType,
    __out_bcount_opt( *f_pcbKey ) DRM_BYTE *f_pbKey,
    __inout DRM_DWORD *f_pcbKey );

DRM_API DRM_RESULT DRM_CALL Oem_Device_SetKey( 
    __in_opt DRM_VOID *f_pOEMContext,
    __in const DRM_DEVICE_KEY_TYPE f_eKeyType,
    __in_bcount(f_cbKey) DRM_BYTE *f_pbKey,
    __in const DRM_DWORD f_cbKey );

DRM_API DRM_RESULT DRM_CALL Oem_Device_GetUniqueId( 
    __in_opt DRM_VOID *f_pOEMContext,
    __in const DRM_DEVICE_ID_TYPE f_eIDType,
    __out_bcount_opt(*f_pcbLength) DRM_BYTE *f_pbUniqueId, 
    __inout DRM_DWORD *f_pcbLength );

DRM_API DRM_RESULT DRM_CALL Oem_Clock_GetResetState( 
    __in_opt DRM_VOID *f_pOEMContext, 
    __out DRM_BOOL *f_pfReset );

DRM_API DRM_RESULT DRM_CALL Oem_Clock_SetResetState( 
    __in_opt DRM_VOID *f_pOEMContext, 
    __in DRM_BOOL f_fReset );


/*****************************************************************************
** Function:    Oem_Clock_GetTickCount
**
** Synopsis:    Returns the number of milliseconds since the system was started.
**
** Arguments:   [f_pOEMContext] : A pointer to the OEM context; may be NULL
**
** Returns:     DRM_DWORD - the number of milliseconds since the system was started
**
** Notes:       None.
**
******************************************************************************/
DRM_API DRM_DWORD DRM_CALL Oem_Clock_GetTickCount(
__in_opt    DRM_VOID      *f_pOEMContext
);


/* OEM file IO functions (oemfileio.c). */

/* File Handle */
typedef DRM_VOID *OEM_FILEHDL;
#define OEM_INVALID_HANDLE_VALUE ((OEM_FILEHDL)-1)

/* Oem_File_Open Access modes */
#define OEM_GENERIC_READ       (0x80000000L)
#define OEM_GENERIC_WRITE      (0x40000000L)
#define OEM_GENERIC_EXECUTE    (0x20000000L)
#define OEM_GENERIC_ALL        (0x10000000L)

/* Oem_File_Open Share modes */
#define OEM_FILE_SHARE_NONE     0x00000000  
#define OEM_FILE_SHARE_READ     0x00000001  
#define OEM_FILE_SHARE_WRITE    0x00000002  

/* Oem_File_Open Creation dispositions */
#define OEM_CREATE_NEW          1
#define OEM_CREATE_ALWAYS       2
#define OEM_OPEN_EXISTING       3
#define OEM_OPEN_ALWAYS         4
#define OEM_TRUNCATE_EXISTING   5

#define OEM_ATTRIBUTE_HIDDEN    0x00000002
#define OEM_ATTRIBUTE_SYSTEM    0x00000004
#define OEM_ATTRIBUTE_NORMAL    0x00000080

#define OEM_FILE_FLAG_WRITE_THROUGH 0x80000000

/* SetFilePointer move methods */
#define OEM_FILE_BEGIN          0
#define OEM_FILE_CURRENT        1
#define OEM_FILE_END            2

/*
** For information on these functions and parameters see MSDN 
** For Oem_File_Open see CreateFile in MSDN -- not all flags are supported.
*/

/**********************************************************************
** Function:    Oem_File_Open
** Synopsis:    Creates, opens, reopens a file
** Arguments:   [f_pOEMContext]--Optional pointer to OEM specific context data
**              [f_pwszFileName]--Pointer to DRM_WCHAR buffer holding File
**              name.
**              [f_dwAccessMode]--Type of access to the object. 
**              OEM_GENERIC_READ, OEM_GENERIC_WRITE,
**              OEM_GENERIC_EXECUTE and OEM_GENERIC_ALL
**              [f_dwShareMode]--Sharing mode of the object
**              OEM_FILE_SHARE_NONE, OEM_FILE_SHARE_READ
**              and OEM_FILE_SHARE_WRITE
**              [f_dwCreationDisposition]--Action to take on files 
**              that exist, and on files that do not exist.
**              OEM_CREATE_NEW, OEM_CREATE_ALWAYS, OEM_OPEN_EXISTING
**              OEM_OPEN_ALWAYS and OEM_TRUNCATE_EXISTING
**              [f_dwAttributes]--File attributes and flags.
**              OEM_ATTRIBUTE_HIDDEN, OEM_ATTRIBUTE_SYSTEM and
**              OEM_ATTRIBUTE_NORMAL
** Returns:     Valid OEM FILE HANDLE. If fails, 
**              returns OEM_INVALID_HANDLE_VALUE 
***********************************************************************/
DRM_API OEM_FILEHDL DRM_CALL Oem_File_Open(
    __in_opt DRM_VOID *f_pOEMContext,
    __in_z const DRM_WCHAR *f_pwszFileName,
    __in DRM_DWORD f_dwAccessMode,
    __in DRM_DWORD f_dwShareMode,
    __in DRM_DWORD f_dwCreationDisposition,
    __in DRM_DWORD f_dwAttributes );

/**********************************************************************
** Function:    Oem_File_Close
** Synopsis:    Closes an open handle opened by Oem_File_Open.
** Arguments:   [f_hFile]--File Handle
** Returns:     Non zero value if succeeds, zero if failed.
***********************************************************************/
DRM_API DRM_BOOL DRM_CALL Oem_File_Close(
    __in OEM_FILEHDL f_hFile );

/**********************************************************************
** Function:    Oem_File_Read
** Synopsis:    Reads data from a file.
** Arguments:   [f_hFile]--File Handle
**              [f_pvBuffer]--Pointer to the buffer that receives the 
**              data read from the file. 
**              [f_nNumberOfBytesToRead]--Number of bytes to read.
**              [f_pNumberOfBytesRead]--Total number of bytes read. 
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/
DRM_API DRM_BOOL DRM_CALL Oem_File_Read(
    __in OEM_FILEHDL f_hFile,
    __out_ecount_part( f_nNumberOfBytesToRead, *f_pNumberOfBytesRead ) DRM_VOID *f_pvBuffer,
    __in DRM_DWORD f_nNumberOfBytesToRead,
    __out DRM_DWORD *f_pNumberOfBytesRead );

/**********************************************************************
** Function:    Oem_File_Write
** Synopsis:    Writes data to a file.
** Arguments:   [f_hFile]--File Handle
**              [f_pvBuffer]--Pointer to the buffer holding the 
**              data read to the file. 
**              [f_nNumberOfBytesToWrite]--Number of bytes to write.
**              [f_pNumberOfBytesWritten]--Total number of bytes written. 
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/
DRM_API DRM_BOOL DRM_CALL Oem_File_Write(
    __in OEM_FILEHDL f_hFile,
    __in_ecount( f_nNumberOfBytesToWrite ) DRM_VOID *f_pvBuffer,
    __in DRM_DWORD f_nNumberOfBytesToWrite,
    __out DRM_DWORD *f_pNumberOfBytesWritten );

/**********************************************************************
** Function:    Oem_File_SetFilePointer
** Synopsis:    Sets File pointer.
** Arguments:   [f_lDistanceToMove]--Number of bytes to move
**              [f_dwMoveMethod]--Starting point for the file pointer move 
**              OEM_FILE_BEGIN, OEM_FILE_CURRENT and  OEM_FILE_END
**              [f_pdwNewFilePointer]--New File pointer.
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/
DRM_API DRM_BOOL DRM_CALL Oem_File_SetFilePointer(
    __in OEM_FILEHDL f_hFile,
    __in DRM_LONG f_lDistanceToMove,
    __in DRM_DWORD f_dwMoveMethod,
    __out_opt DRM_DWORD *f_pdwNewFilePointer );

/**********************************************************************
** Function:    Oem_File_Lock
** Synopsis:    Immidiately locks the portion of specified file. 
** Arguments:   [f_hFile]--File Handle
**              [f_fExclusive]-- If TRUE, locks file for exclusive access  
**              by the calling process.
**              [f_dwFileOffset]--Offset from begining of file.
**              [f_nNumberOfBytesToLock]--Number of bytes to lock. 
**              [f_fWait]--Whether to wait for the lock to complete.
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/
DRM_API DRM_BOOL DRM_CALL Oem_File_Lock(
    __in OEM_FILEHDL f_hFile,
    __in DRM_BOOL f_fExclusive,
    __in DRM_DWORD f_dwFileOffset,
    __in DRM_DWORD f_nNumberOfBytesToLock,
    __in DRM_BOOL f_fWait );

/**********************************************************************
** Function:    Oem_File_Unlock
** Synopsis:    Unlocks the locked portion of specified file. 
** Arguments:   [f_hFile]--File Handle
**              [f_dwFileOffset]--Offset from begining of file.
**              [f_nNumberOfBytesToLock]--Number of bytes to lock. 
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/
DRM_API DRM_BOOL DRM_CALL Oem_File_Unlock(
    __in OEM_FILEHDL f_hFile,
    __in DRM_DWORD f_dwFileOffset,
    __in DRM_DWORD f_nNumberOfBytesToUnlock );

/**********************************************************************
** Function:    Oem_File_SetEndOfFile
** Synopsis:    Moves the end-of-file (EOF) position for the 
**              specified file to the current position of the file 
**              pointer. 
** Arguments:   [f_hFile]--File Handle
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/
DRM_API DRM_BOOL DRM_CALL Oem_File_SetEndOfFile(
    __in OEM_FILEHDL f_hFile);

/**********************************************************************
** Function:    Oem_File_GetSize
** Synopsis:    Gets size of the file. 
** Arguments:   [f_hFile]--File Handle
**              [f_pdwFileSize]--Pointer to DRM_DWORD to get the size.
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/
DRM_API DRM_BOOL DRM_CALL Oem_File_GetSize(
    __in OEM_FILEHDL f_hFile,
    __out DRM_DWORD  *f_pdwFileSize );

/**********************************************************************
** Function:    Oem_File_FlushBuffers
** Synopsis:    Flushes the buffers of the specified file and causes 
**              all buffered data to be written to the file. 
** Arguments:   [f_hFile]--File Handle
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/
DRM_API DRM_BOOL DRM_CALL Oem_File_FlushBuffers(
    __in OEM_FILEHDL f_hFile );

/* OEM time functions (oemtime.c). */

/**********************************************************************
** Function:    Oem_Clock_SystemTimeToFileTime
** Synopsis:    Converts System Time format to File time format. 
** Arguments:   [f_lpSystemTime]--Pointer to DRMSYSTEMTIME structure 
**              containing system time
**              [f_lpFileTime]--Pointer to DRMFILETIME structure to get
**              the time.
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/
DRM_API DRM_BOOL DRM_CALL Oem_Clock_SystemTimeToFileTime(
    __in const DRMSYSTEMTIME *f_lpSystemTime,
    __out DRMFILETIME *f_lpFileTime );

/**********************************************************************
** Function:    Oem_Clock_FileTimeToSystemTime
** Synopsis:    Converts File time format to System Time format. 
** Arguments:   [f_lpFileTime]--Pointer to DRMFILETIME structure 
**              containing file time
**              [f_lpSystemTime]--Pointer to DRMSYSTEMTIME structure to 
**              get the time.
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/
DRM_API DRM_BOOL DRM_CALL Oem_Clock_FileTimeToSystemTime(
    __in const DRMFILETIME *f_lpFileTime,
    __out DRMSYSTEMTIME *f_lpSystemTime );

/**********************************************************************
** Function:    Oem_Clock_GetSystemTime
** Synopsis:    Gets current System time. It is expressed in UTC. 
** Arguments:   [f_pOEMContext]--OEM specific data
**              [f_lpSystemTime]--Pointer to DRMSYSTEMTIME structure 
**              to get the time.
***********************************************************************/
DRM_API DRM_VOID DRM_CALL Oem_Clock_GetSystemTime(
    __in_opt    DRM_VOID      *f_pOEMContext,
    __out       DRMSYSTEMTIME *f_psystime );

/**********************************************************************
** Function:    Oem_Clock_GetSystemTimeAsFileTime
** Synopsis:    Gets current System time. It is expressed in UTC. 
** Arguments:   [f_pOEMContext]--OEM specific data
**              [f_pfiletime]--Pointer to DRMFILETIME structure 
**              to get the time.
***********************************************************************/
DRM_API DRM_VOID DRM_CALL Oem_Clock_GetSystemTimeAsFileTime(
    __in_opt    DRM_VOID    *f_pOEMContext,
    __out       DRMFILETIME *f_pfiletime );

/**********************************************************************
** Function:    Oem_Clock_SetSystemTime
** Synopsis:    Sets the System time. It is expressed in UTC. 
** Arguments:   [f_pOEMContext]--OEM specific data
**              [f_lpSystemTime]--Pointer to DRMSYSTEMTIME structure 
**              holding the time.
***********************************************************************/
DRM_API DRM_VOID DRM_CALL Oem_Clock_SetSystemTime(
    __in_opt    DRM_VOID      *f_pOEMContext,
    __in        DRMSYSTEMTIME *f_lpSystemTime );

/* OEM memory allocation functions (oemimpl.c). */

DRM_API DRM_VOID * DRM_CALL Oem_MemAlloc(
    __in DRM_DWORD f_cbSize );

DRM_API DRM_VOID DRM_CALL Oem_MemFree(
    __in DRM_VOID *f_pv );

#define SAFE_OEM_FREE( p )            \
    if ( p != NULL )                  \
    {                                 \
        Oem_MemFree( ( DRM_VOID * )p );  \
        p = NULL;                     \
    }

DRM_API DRM_VOID * DRM_CALL Oem_MemRealloc( 
    __inout DRM_VOID  *f_pv, 
    __in DRM_DWORD f_cbSize );
    
/* OEM special implementation functions (oemimpl.c). */
#ifdef _MSC_VER

__forceinline DRM_VOID * DRM_CALL DRMCRT_ScrubMemory(
    __in_ecount( f_cbCount ) DRM_VOID  *f_ptr,
    IN DRM_DWORD  f_cbCount  )
{
    /*
    ** Casting the pointer to volatile makes the MS compiler act
    ** as if another thread can see and access the buffer. This 
    ** prevents the compiler from reordering or optimizing away 
    ** the writes. 
    */

    volatile char *vptr = (volatile char *)f_ptr;

    while (f_cbCount) 
    {
        *vptr = 0;
        vptr++;
        f_cbCount--;
    }

    return f_ptr;
}

#define OEM_SECURE_ZERO_MEMORY DRMCRT_ScrubMemory

#else

#error "Please provide implementation for OEM_SECURE_ZERO_MEMORY macro.\
 OEM_SECURE_ZERO_MEMORY is called to scrub memory on critical pieces of data before freeing buffers or exiting local scope.\
 Using of memset function on these buffers is not sufficient, since compiler\
 may optimize out zeroing of buffers that are not used afterwards.\
 Please verify the implementation will not be optimized out by your compiler.\
 Consult the documentation for your compiler to see how this can be done. \
 The Microsoft supplied example is only guaranteed to work on Microsoft compilers. "

#endif /* _MSC_VER */


#define SAFE_SECURE_OEM_FREE( p, c )                                    \
    if (p != NULL)                                                      \
    {                                                                   \
        OEM_SECURE_ZERO_MEMORY( p, c );                                 \
        Oem_MemFree( ( DRM_VOID * ) p );                                \
        p = NULL;                                                       \
    }

DRM_API DRM_VOID DRM_CALL Oem_Random_SetSeed(
    __in_opt DRM_VOID *f_pOEMContext,
    __in const DRM_UINT64 f_qwNewSeed );

DRM_API DRM_RESULT DRM_CALL Oem_Random_GetBytes( 
    __in_opt DRM_VOID *f_pOEMContext,
    __out_bcount(f_cbData) DRM_BYTE *f_pbData, 
    __in DRM_DWORD f_cbData );

DRM_API DRM_RESULT DRM_CALL Oem_Hds_GetSetReplayCheck(
    __in DRM_VOID *f_pvOpaqueData,
    __inout_bcount( f_cbKey ) DRM_BYTE *f_pbKey,
    __in DRM_DWORD f_cbKey,
    __in DRM_BOOL f_fGet );

#if DRM_SUPPORT_BLOCK_HEADER_CACHING

EXIT_PK_NAMESPACE;

#include <drmhds.h>

ENTER_PK_NAMESPACE;

/* Number of entries in the block header cache. Each entry will occupy
** SIZEOF( BLOCK_HEADER_CACHE_ENTRY ) bytes of memory. A larger cache
** will mean a lower chance of needing to load a block header from the disk
*/
#define MAX_CACHED_BLOCK_HEADERS 500

typedef struct
{
    DRM_DWORD dwBlockNumber;
    DRM_DWORD dwCacheHits;
    DRM_DWORD dwBlockHeaderMetadata;
    DRM_BYTE  rgbBlockHeader[CALC_MAXBLOCKHEADERLEN];
    DRM_DWORD cbBytesAvailable;

} BLOCK_HEADER_CACHE_ENTRY;

DRM_API DRM_VOID DRM_CALL Oem_Hds_ClearBlockHeaderCache( DRM_VOID );

DRM_API DRM_RESULT DRM_CALL Oem_Hds_CheckBlockHeaderCache(
    __in      DRM_DWORD   f_dwBlockNumber,
    __in_opt  OEM_FILEHDL f_hHDSFileHandle,
    __out_opt DRM_DWORD  *f_pdwBlockHeaderMetadata,
    __out_bcount_opt( f_cbBytesToRead ) DRM_BYTE   *f_pbBlock,
    __in      DRM_DWORD   f_cbBytesToRead );

DRM_API DRM_RESULT DRM_CALL Oem_Hds_UpdateBlockHeaderCache(
    __in     DRM_DWORD   f_dwBlockNumber,
    __in_opt OEM_FILEHDL f_hHDSFileHandle,
    __in     DRM_DWORD   f_dwBlockHeaderMetadata,
    __in_bcount_opt( f_cbBytesToWrite ) DRM_BYTE   *f_pbBlock,
    __in     DRM_DWORD   f_cbBytesToWrite );

#endif /* DRM_SUPPORT_BLOCK_HEADER_CACHING */

#if DRM_SUPPORT_SST_REDUNANCY

EXIT_PK_NAMESPACE;

#include <drmtoken.h>

ENTER_PK_NAMESPACE;

DRM_API DRM_RESULT DRM_CALL VariableSSTRedundancyGetorSet(
   __in const DRM_CONST_STRING *f_pdstrToken, 
   __in TOKEN *f_pNewValue, 
   __out TOKEN *f_pResult, 
   __inout DRM_VOID *f_pvOpaqueData, 
   __in DRM_BOOL f_fSet );
   
#endif /* DRM_SUPPORT_SST_REDUNANCY */

#if TEST_USE_OFFSET_CLOCK

typedef struct
{
    DRM_BOOL    fFreezeTickCount;
    DRM_DWORD   dwTickCount;
} DRM_TEST_OEM_CONTEXT;

#endif

EXIT_PK_NAMESPACE;

#endif /* __OEMCOMMON_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\oemdevstore.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __OEMDEVSTORE_H__
#define __OEMDEVSTORE_H__

#include <oemcommon.h>
#include <oemcontextsizes.h>

ENTER_PK_NAMESPACE;

DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_Initialize(
    __inout_ecount(1) OEM_DEVICESTORE_CONTEXT   *f_pDeviceStoreContext,
    __in_ecount(1)    OEM_DEVICESTORE_INITDATA  *f_pDeviceStoreInitData
);


DRM_API DRM_VOID DRM_CALL Oem_DeviceStore_Uninitialize(
    __inout_ecount(1)   OEM_DEVICESTORE_CONTEXT *f_pDeviceStoreContext
);


DRM_API DRM_VOID DRM_CALL Oem_DeviceStore_FreeDevice (
    __in     OEM_DEVICE_HANDLE            f_hDeviceHandle
);


DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_RegisterDevice(
    __inout_ecount(1) OEM_DEVICESTORE_CONTEXT      *f_pDeviceStoreContext,
    __in              DRM_BYTEBLOB                  f_DeviceID,
    __out_ecount(1)   OEM_DEVICE_HANDLE            *f_phDeviceHandle
);


DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_UnRegisterDevice(
    __inout_ecount(1) OEM_DEVICESTORE_CONTEXT      *f_pDeviceStoreContext,
    __in              DRM_BYTEBLOB                  f_DeviceID
);


DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_GetFirstDevice(
    __inout_ecount(1) OEM_DEVICESTORE_CONTEXT      *f_pDeviceStoreContext,
    __out_ecount(1)   OEM_DEVICE_HANDLE            *f_phDeviceHandle
);


DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_GetNextDevice(
    __in_ecount(1)    OEM_DEVICESTORE_CONTEXT      *f_pDeviceStoreContext,
    __inout_ecount(1) OEM_DEVICE_HANDLE            *f_phDeviceHandle
);


DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_GetDeviceByID(
    __inout_ecount(1) OEM_DEVICESTORE_CONTEXT      *f_pDeviceStoreContext,
    __in              DRM_BYTEBLOB                  f_DeviceID,
    __out_ecount(1)   OEM_DEVICE_HANDLE            *f_phDeviceHandle
);


DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_GetDeviceID(
    __in                         OEM_DEVICE_HANDLE    f_hDeviceHandle,
    __out_ecount(*f_pcbDeviceID) DRM_BYTE            *f_pbDeviceID,
    __inout_ecount(1)            DRM_DWORD           *f_pcbDeviceID
);


DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_GetDeviceAttr(
    __in                          OEM_DEVICE_HANDLE  f_hDeviceHandle,
    __in                          DRM_BYTEBLOB       f_AttrName,
    __out_bcount(*f_pcbAttrValue) DRM_BYTE          *f_pbAttrValue,
    __inout_ecount(1)             DRM_DWORD         *f_pcbAttrValue
);


DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_GetDeviceAttrCount(
    __in                OEM_DEVICE_HANDLE            f_hDeviceHandle,
       __out_ecount(1)  DRM_DWORD                   *f_pdwAttrCount
);


DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_GetDeviceAttrByIndex(
    __in                            OEM_DEVICE_HANDLE    f_hDeviceHandle,
    __in                            DRM_DWORD            f_dwAttrIndex,
    __inout_bcount(*f_pcbAttrName)  DRM_BYTE            *f_pbAttrName,
    __inout_ecount(1)               DRM_DWORD           *f_pcbAttrName,
    __inout_bcount(*f_pcbAttrValue) DRM_BYTE            *f_pbAttrValue,
    __inout_ecount(1)               DRM_DWORD           *f_pcbAttrValue
);


DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_SetDeviceAttr(
    __in     OEM_DEVICE_HANDLE                 f_hDeviceHandle,
    __in     DRM_BYTEBLOB                      f_AttrName,
    __in     DRM_BYTEBLOB                      f_AttrValue
);


DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_CommitDevice(
    __in     OEM_DEVICE_HANDLE            f_hDeviceHandle
);


EXIT_PK_NAMESPACE;

#endif /*  __OEMDEVSTORE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\oemprofile.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __OEMPROFILE_H__
#define __OEMPROFILE_H__

ENTER_PK_NAMESPACE;

#if DRM_SUPPORT_PROFILING

#include <drmprofile.h>

DRM_API PERF_GLOBAL_CONTEXT * DRM_CALL Oem_Profiling_GetProfileContext(DRM_VOID); 

/**********************************************************************
** Function:    Oem_Profiling_QueryPerformanceCounter
** Synopsis:    Returns the value of a high performance counter if one 
**              exists on the system, otherwise it works like Oem_Clock_GetTickCount()
** Parameters:  None
** Returns:     A DRM_UINT64 with the value of the system's counter.
***********************************************************************/
DRM_API DRM_UINT64 DRM_CALL Oem_Profiling_QueryPerformanceCounter( DRM_VOID );

/**********************************************************************
** Function:    Oem_Profiling_QueryPerformanceFrequency
** Synopsis:    Returns the frequency of the high performance counter  
**              in clocks per second.
** Parameters:  None
** Returns:     A DRM_UINT64 representing the number of ticks per second
**              used by Oem_Profiling_QueryPerformanceCounter.
***********************************************************************/
DRM_API DRM_UINT64 DRM_CALL Oem_Profiling_QueryPerformanceFrequency( DRM_VOID );

#endif  /* DRM_SUPPORT_PROFILING */

EXIT_PK_NAMESPACE;

#endif /* __OEMPROFILE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\oemndt.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __OEMNDT_H__
#define __OEMNDT_H__

#include <ndttypes.h>
#include <oemcommon.h>

ENTER_PK_NAMESPACE;

DRM_API DRM_RESULT DRM_CALL Oem_Ndt_AllowNewDeviceRegistration(
    __in     DRM_BYTEBLOB f_DeviceCertificate,
    __in     DRM_BYTEBLOB f_DeviceSerialNumber
);


DRM_API DRM_RESULT DRM_CALL Oem_Ndt_GetProximityDetectionAddress(
    __out_bcount_opt(*f_pcbAddress) DRM_BYTE       *f_pbAddress,
    __inout                         DRM_WORD       *f_pcbAddress
);


extern DRM_BOOL g_fOverride_OPL_Defaults;
extern DRM_WORD g_wAnalogVideo;
extern DRM_WORD g_wCompressedDigitalAudio;
extern DRM_WORD g_wCompressedDigitalVideo;
extern DRM_WORD g_wUncompressedDigitalAudio;
extern DRM_WORD g_wUncompressedDigitalVideo;
DRM_API DRM_RESULT DRM_CALL OEM_NDT_GetLicenseOPLs(
    __out_opt DRM_MINIMUM_OUTPUT_PROTECTION_LEVELS *f_MinPlayOpls,
    __out     DRM_BOOL                             *f_OplSet
);


extern DRM_BOOL  g_fOverride_InclusionList_Defaults;
extern DRM_DWORD g_cInclusionListGUIDs;
DRM_API DRM_RESULT DRM_CALL OEM_NDT_GetLicenseInclusionList(
    __inout_opt DRM_GUIDLIST *f_InclusionList,
    __out       DRM_BOOL     *f_fInclusionListSet
);


extern DRM_DWORD g_dwSourceID;
DRM_API DRM_RESULT DRM_CALL OEM_NDT_GetSourceID ( 
    __out_ecount(1)    DRM_DWORD                               *f_pdwSourceID );


extern DRM_DWORD g_dwRevInfo;
DRM_API DRM_RESULT DRM_CALL OEM_NDT_GetLicenseRevInfoVersion ( 
    __out_ecount(1)     DRM_DWORD                               *f_pdwRevInfo );


extern DRM_DWORD g_dwMinAppSec;
DRM_API DRM_RESULT DRM_CALL OEM_NDT_GetWMDRMNETMinAppSec(
    __out_ecount(1) DRM_DWORD                               *f_pdwMinAppSec );

EXIT_PK_NAMESPACE;

#endif /*  __OEMNDT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\oemrsaimpl.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __OEMRSAIMPL_H__
#define __OEMRSAIMPL_H__

#include <drmtypes.h>
#include <drmrsacommon.h>
#include <bigdefs.h>

ENTER_PK_NAMESPACE;

#define CBITS_PUBEXP                  ( DRM_RSA_CB_PUBEXP * BITS_PER_STANDARD_BYTE )

#define CBITS_PRIVEXP( keyLength )    ( DRM_RSA_CB_PRIVEXP( keyLength ) * BITS_PER_STANDARD_BYTE )
#define CBITS_PRIVEXP_MAX               CBITS_PRIVEXP( eDRM_RSA_MAXIMUM_KEY_LENGTH )

#define CDIGITS_MODULUS( keyLength )    BITS_TO_DIGITS( DRM_RSA_CBITS_MODULUS( keyLength ) )
#define CDIGITS_MODULUS_MAX             CDIGITS_MODULUS( eDRM_RSA_MAXIMUM_KEY_LENGTH )

#define CDIGITS_PUBEXP                  BITS_TO_DIGITS( CBITS_PUBEXP )

#define CDIGITS_PRIVEXP( keyLength )    BITS_TO_DIGITS( CBITS_PRIVEXP( keyLength ) )
#define CDIGITS_PRIVEXP_MAX             CDIGITS_PRIVEXP( eDRM_RSA_MAXIMUM_KEY_LENGTH )

/*
** Internal representation of public and private key structures
*/

/*
** In the following structures, a digit_t array represents a single big number,
** stored in big-endian format.  In other words, the most significant digit is 
** lowest in contiguous memory.  Since the digit_t itself is a multi-octet value, 
** please note that it is also stored in big-endian form; the most significant
** octet of a given digit_t instance is lowest in contiguous memory.
**
** Thus, a "big-endian" digit array is a sequence of digit_t's stored in 
** big-endian order, with the individual octets of each digit_t also stored
** in big-endian order.
*/

/*
** Public key: Contains only the modulus and exponent
*/
typedef struct __tagINTERNAL_DRM_RSA_PUBLIC_KEY
{       
    DRM_RSA_SUPPORTED_KEY_LENGTHS eKeyLength;                               /* key length in bits. */
    DRM_DWORD                     cdModulus;                                /* count of digits in the public modulus. */
    digit_t                       rgdPubExp[CDIGITS_PUBEXP];                /* public exponent; stored as big-endian digits. */
    digit_t                       rgdModulus[CDIGITS_MODULUS_MAX];          /* public modulus; stored as big-endian digits. */
} INTERNAL_DRM_RSA_PUBLIC_KEY;

/*
** Private key: Contains the primes, exponent, and chinese remainder theorem residuals
*/
typedef struct __tagINTERNAL_DRM_RSA_PRIVATE_KEY
{   
    DRM_RSA_SUPPORTED_KEY_LENGTHS eKeyLength;                               /* key length in bits. */
    DRM_DWORD                     cdPrimes[2];                              /* count of digits in each prime. */
    digit_t                       rgdPrimes[2][CDIGITS_MODULUS_MAX];        /* larger prime (p) stored first; stored as big-endian digits. */
    digit_t                       rgdCRTExponents[2][CDIGITS_MODULUS_MAX];  /* chinese remainder theorem exponents; stored as big-endian digits. */     
    digit_t                       rgdIQMP[CDIGITS_MODULUS_MAX];             /* stored as big-endian digits. */
} INTERNAL_DRM_RSA_PRIVATE_KEY;

EXIT_PK_NAMESPACE;

#endif /* __OEMRSAIMPL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\oemrsa.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __OEMRSA_H__
#define __OEMRSA_H__

#include <drmtypes.h>
#include <oemrsaimpl.h>
#include <drmrsacommon.h>
#include <drmlicense.h> 

ENTER_PK_NAMESPACE;

#define BITS_TO_BYTES( nb ) ( ( ( nb ) + BITS_PER_STANDARD_BYTE - 1 ) / BITS_PER_STANDARD_BYTE )
#define BYTES_TO_BITS( nb ) ( ( nb ) * BITS_PER_STANDARD_BYTE )

extern DRM_EXPORT_VAR const DRM_BYTE rgbDRM_RSA_DEFAULT_PUBEXP[__CB_DECL( DRM_RSA_CB_PUBEXP )];

#define DRM_RSA_DEFAULT_PUBEXP_DWORD 65537

/*
** Sizes of internal RSA key structures:
*/
#define DRM_RSA_CB_PUBKEY   SIZEOF( INTERNAL_DRM_RSA_PUBLIC_KEY )
#define DRM_RSA_CB_PRIVKEY  SIZEOF( INTERNAL_DRM_RSA_PRIVATE_KEY )

/*
** RSA public key
**
** The actual contents of the structure are opaque.
** The opaque data is represented as a byte array below.
** Do not access the array or assume the size of this structure.
*/
typedef struct __tagDRM_RSA_PUBLIC_KEY
{
    DRM_BYTE rgbOpaque[__CB_DECL( DRM_RSA_CB_PUBKEY )];
} DRM_RSA_PUBLIC_KEY;

/*
** RSA private key
**
** The actual contents of the structure are opaque.
** The opaque data is represented as a byte array below.
** Do not access the array or assume the size of this structure.
*/
typedef struct __tagDRM_RSA_PRIVATE_KEY
{
    DRM_BYTE rgbOpaque[__CB_DECL( DRM_RSA_CB_PRIVKEY )];
} DRM_RSA_PRIVATE_KEY;

/*
** Key management functions:
*/
DRM_API DRM_RESULT DRM_CALL OEM_RSA_GetPublicKeyLength(
    __in const DRM_RSA_PUBLIC_KEY            *f_pPublicKey,
    __out      DRM_RSA_SUPPORTED_KEY_LENGTHS *f_peKeyLength
    );

DRM_API DRM_RESULT DRM_CALL OEM_RSA_GetPrivateKeyLength(
    __in const DRM_RSA_PRIVATE_KEY           *f_pPrivateKey,
    __out      DRM_RSA_SUPPORTED_KEY_LENGTHS *f_peKeyLength 
    );

DRM_API DRM_RESULT DRM_CALL OEM_RSA_GetKeyLengthFromModulusLength(
    __in const DRM_DWORD                      f_cbModulus,
    __out      DRM_RSA_SUPPORTED_KEY_LENGTHS *f_peKeyLength 
    );

DRM_API DRM_RESULT DRM_CALL OEM_RSA_ParsePublicKey(
    __in const                        DRM_RSA_PUBLIC_KEY            *f_pPublicKey,
    __out_opt                         DRM_RSA_SUPPORTED_KEY_LENGTHS *f_peKeyLength,
    __inout_opt                       DRM_DWORD                     *f_pcbPubExp,
    __out_ecount_opt( *f_pcbPubExp )  DRM_BYTE                      *f_pbPubExp,
    __inout_opt                       DRM_DWORD                     *f_pcbModulus,
    __out_ecount_opt( *f_pcbModulus ) DRM_BYTE                      *f_pbModulus
    );

DRM_RESULT DRM_CALL OEM_RSA_ParsePrivateKey(
    __in const                        DRM_RSA_PRIVATE_KEY           *f_pPrivateKey,
    __out_opt                         DRM_RSA_SUPPORTED_KEY_LENGTHS *f_peKeyLength,
    __inout_opt                       DRM_DWORD                     *f_pcbPrivExp,
    __out_ecount_opt( *f_pcbPrivExp ) DRM_BYTE                      *f_pbPrivExp,
    __inout_opt                       DRM_DWORD                     *f_pcbPrimes,
    __out_ecount_opt( *f_pcbPrimes )  DRM_BYTE                      *f_pbPrime0,
    __out_ecount_opt( *f_pcbPrimes )  DRM_BYTE                      *f_pbPrime1 
    );

DRM_API DRM_RESULT DRM_CALL OEM_RSA_SetPublicKey(
    __in const                       DRM_RSA_SUPPORTED_KEY_LENGTHS  f_eKeyLength,
    __in const                       DRM_DWORD                      f_cbPubExp,
    __in_ecount( f_cbPubExp ) const  DRM_BYTE                      *f_pbPubExp,
    __in const                       DRM_DWORD                      f_cbModulus,
    __in_ecount( f_cbModulus ) const DRM_BYTE                      *f_pbModulus,
    __out                            DRM_RSA_PUBLIC_KEY            *f_pPublicKey 
    );

DRM_API DRM_RESULT DRM_CALL OEM_RSA_SetPrivateKey(
    __in const                       DRM_RSA_SUPPORTED_KEY_LENGTHS  f_eKeyLength,
    __in const                       DRM_DWORD                      f_cbPrivExp,
    __in_ecount( f_cbPrivExp ) const DRM_BYTE                      *f_pbPrivExp,
    __in const                       DRM_DWORD                      f_cbPrimes,
    __in_ecount( f_cbPrimes ) const  DRM_BYTE                      *f_pbPrime0,
    __in_ecount( f_cbPrimes ) const  DRM_BYTE                      *f_pbPrime1,
    __out                            DRM_RSA_PRIVATE_KEY           *f_pPrivateKey,
    __inout                          DRM_CRYPTO_CONTEXT            *f_pCryptoCtx
    );

DRM_API DRM_RESULT DRM_CALL OEM_RSA_ZeroPublicKey( 
    __in       DRM_RSA_PUBLIC_KEY            *f_pPublicKey 
    );

DRM_API DRM_RESULT DRM_CALL OEM_RSA_ZeroPrivateKey( 
    __in       DRM_RSA_PRIVATE_KEY           *f_pPrivateKey 
    );

/*
** Encryption and decryption functions
*/
DRM_API DRM_RESULT DRM_CALL OEM_RSA_Encrypt(
    __in const                      DRM_RSA_PUBLIC_KEY *f_pPublicKey,
    __in const                      DRM_DWORD           f_cbDataIn,
    __in_ecount( f_cbDataIn ) const DRM_BYTE           *f_pbDataIn,
    __out_ecount( f_cbDataIn )      DRM_BYTE           *f_pbDataOut,
    __in                            DRM_CRYPTO_CONTEXT *f_pCryptoCtx 
    );

DRM_API DRM_RESULT DRM_CALL OEM_RSA_Decrypt(
    __in const                      DRM_RSA_PRIVATE_KEY *f_pPrivateKey,
    __in const                      DRM_DWORD            f_cbDataIn,
    __in_ecount( f_cbDataIn ) const DRM_BYTE            *f_pbDataIn,
    __out_ecount( f_cbDataIn )      DRM_BYTE            *f_pbDataOut,
    __in                            DRM_CRYPTO_CONTEXT  *f_pCryptoCtx 
    );

/*
** Key generation
*/
DRM_API DRM_RESULT DRM_CALL OEM_RSA_GenerateKeyPair(
    __in const DRM_RSA_SUPPORTED_KEY_LENGTHS  f_eKeyLength,
    __out      DRM_RSA_PRIVATE_KEY           *f_pPrivateKey,
    __out      DRM_RSA_PUBLIC_KEY            *f_pPublicKey,
    __inout    DRM_CRYPTO_CONTEXT            *f_pCryptoCtx 
    );

EXIT_PK_NAMESPACE;

#endif /* __OEMRSA_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\pfddrmcontextsizes.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __PFDDRMCONTEXTSIZES_H__
#define __PFDDRMCONTEXTSIZES_H__

#include <drmcommon.h>
#include <ndttypes.h>
#include <drmndtmanager.h>
#include <ndtcontextsizes.h>
#include <drmdevstore.h>
#include <drmptrlist.h>

ENTER_PK_NAMESPACE;

typedef struct __tagPFDMGR_CONTENT_SESSION_CONTEXT_INTERNAL
{
    DRM_DWORD       dwSessionID;
    DRM_ID          idContentSession;

    DRM_BYTE       *pbLicenseResponseMsg;
    DRM_DWORD       cbLicenseResponseMsg;

    OEM_FILEHDL     hRawFile;

    /* 
    ** This is a per-session (file) context. One is needed for each file we
    ** might be streaming.
    */
    DRM_APP_CONTEXT AppContext;

} PFDMGR_CONTENT_SESSION_CONTEXT_INTERNAL;

typedef struct __tagPFDMGR_CONTEXT_INTERNAL
{
    /* 
    ** This is a global context used for revocation and other housekeeping. It
    ** should share the same HDS as the per-session contexts.
    */
    DRM_APP_CONTEXT AppContext;

    NDTMGR_CONTEXT  ndtMgrContext;

    DRM_DWORD       dwRegistrationTransactionID;
    DRM_ID          idRegistrationSession;
    DRM_BYTE       *pbRegistrationResponseMsg;
    DRM_DWORD       cbRegistrationResponseMsg;

    PTR_LIST        ContentSessions;

    DRM_BYTE       *pbCurrentRegistrationRequestMsg;
    DRM_DWORD       cbCurrentRegistrationRequestMsg;
} PFDMGR_CONTEXT_INTERNAL;

#define PFDMGR_CONTEXT_BUFFER_SIZE SIZEOF(PFDMGR_CONTEXT_INTERNAL)

EXIT_PK_NAMESPACE;

#endif  /* __PFDDRMCONTEXTSIZES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\packetwriter.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#ifndef __PACKETWRITER_H
#define __PACKETWRITER_H

#include <asfsample.h>

ENTER_PK_NAMESPACE;

typedef struct tagPACKET_SNAPSHOT
{
    ASF_PACKET_PARSER_INFO   PacketParseInfo;
    DRM_DWORD                cbFinalPayloadTotalSize;
    DRM_WORD                 cFinalCompressedSubPayloads;
    DRM_DWORD                cbFinalCompressedPayloadTotal;
    DRM_BYTE                 bFinalCompressedPresTimeDelta;    
} PACKET_SNAPSHOT;


typedef struct tagASF_PACKET_WRITER_CONTEXT
{
    ASF_PACKET_PARSER_INFO           m_ASFPacketInfo;
    PTR_LIST                         m_ASFPayloadInfos;
    PTR_LIST                         m_PayloadDataBuffers;
    DRM_DWORD                        m_cbFixedPacketSize;
} ASF_PACKET_WRITER_CONTEXT;


DRM_RESULT ASFPacketWriter_Initialize(
    __out      ASF_PACKET_WRITER_CONTEXT * const pAsfPacketWriterContext,
    __in const DRM_DWORD                         dwFixedPacketSize
);

DRM_VOID ASFPacketWriter_Uninitialize(
    __out ASF_PACKET_WRITER_CONTEXT * const pAsfPacketWriterContext
);

DRM_RESULT ASFPacketWriter_SetPacketInfo(
    __inout    ASF_PACKET_WRITER_CONTEXT * const pAsfPacketWriterContext,
    __in const ASF_PACKET_PARSER_INFO * const pPacketInfo
);

DRM_RESULT ASFPacketWriter_GetPacketInfo(
    __in const ASF_PACKET_WRITER_CONTEXT * const pAsfPacketWriterContext,
    __out      ASF_PACKET_PARSER_INFO    * const pPacketInfo 
);

DRM_RESULT ASFPacketWriter_GetDataSpaceAvailable(
    __inout    ASF_PACKET_WRITER_CONTEXT * const pAsfPacketWriterContext,
    __in const DRM_WORD                          wStreamNumber,
    __in const DRM_BYTE                          bObjectID,
    __in const ASF_SAMPLE                * const pMediaObjectWithAttributes,
    __out      DRM_DWORD                 * const pcbSpaceAvailable 
);

DRM_RESULT ASFPacketWriter_AddPayload(
    __inout    ASF_PACKET_WRITER_CONTEXT * const pAsfPacketWriterContext,
    __in const ASF_PAYLOAD_PARSER_INFO   * const pPayloadInfo,
    __in const ASF_SAMPLE                * const pMFSample,
    __in const DRM_BOOL                          fSampleIsCompleteMediaObject 
);

DRM_RESULT ASFPacketWriter_WritePacket(
    __in const ASF_PACKET_WRITER_CONTEXT * const pAsfPacketWriterContext,
    __out      ASF_SAMPLE                      **ppASFPacket
);

DRM_RESULT ASFPacketWriter_Clear(
    __out ASF_PACKET_WRITER_CONTEXT * const pAsfPacketWriterContext
);

EXIT_PK_NAMESPACE;

#endif /* __PACKETWRITER_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\pfddrmmtpextensions.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
 * pfddrmmtpextensions.h
 *
 * #defines used by the MTP extensions for PFD
 *
 */

#ifndef _PFDDRMMTPEXTENSIONS_H_
#define _PFDDRMMTPEXTENSIONS_H_

ENTER_PK_NAMESPACE;

/*
 * MTP operations for Advanced A/V Transfer (AAVT) extensions
 */
#define MTP_OPCODE_AAVT_OPENMEDIASESSION       0X9170
#define MTP_OPCODE_AAVT_CLOSEMEDIASESSION      0X9171
#define MTP_OPCODE_AAVT_GETNEXTDATABLOCK       0X9172
#define MTP_OPCODE_AAVT_SETCURRENTTIMEPOSITION 0X9173

/*
 * MTP response codes for Microsoft Advanced A/V Transfer (AAVT) extensions
 */
#define MTP_RESPONSECODE_AAVT_INVALID_MEDIA_SESSION_ID    0XA170
#define MTP_RESPONSECODE_AAVT_MEDIA_SESSION_LIMIT_REACHED 0XA171
#define MTP_RESPONSECODE_AAVT_NO_MORE_DATA                0XA172


/*
 * MTP operations for WMDRMND extensions
 */
#define MTP_OPCODE_WMDRMND_SENDREGISTRATIONREQUEST      0X9180
#define MTP_OPCODE_WMDRMND_GETREGISTRATIONRESPONSE      0X9181
#define MTP_OPCODE_WMDRMND_GETPROXIMITYCHALLENGE        0X9182
#define MTP_OPCODE_WMDRMND_SENDPROXIMITYRESPONSE        0X9183
#define MTP_OPCODE_WMDRMND_SENDWMDRMNDLICENSEREQUEST    0X9184
#define MTP_OPCODE_WMDRMND_GETWMDRMNDLICENSERESPONSE    0X9185

/*
 * MTP response codes for WMDRMND extensions
 */
#define MTP_RESPONSECODE_WMDRMND_INVALID_CERTIFICATE                 0xA180
#define MTP_RESPONSECODE_WMDRMND_CERTIFICATE_REVOKED                 0xA181
#define MTP_RESPONSECODE_WMDRMND_MUST_APPROVE                        0xA182
#define MTP_RESPONSECODE_WMDRMND_LICENSE_UNAVAILABLE                 0xA183
#define MTP_RESPONSECODE_WMDRMND_TRANSMITTER_FAILURE                 0xA184
#define MTP_RESPONSECODE_WMDRMND_DEVICE_LIMIT_REACHED                0xA185
#define MTP_RESPONSECODE_WMDRMND_UNABLE_TO_VERIFY_PROXIMITY          0xA186
#define MTP_RESPONSECODE_WMDRMND_MUST_REGISTER                       0xA187
#define MTP_RESPONSECODE_WMDRMND_MUST_REVALIDATE                     0xA188
#define MTP_RESPONSECODE_WMDRMND_INVALID_PROXIMITY_RESPONSE          0xA189
#define MTP_RESPONSECODE_WMDRMND_INVALID_SESSION                     0xA18A
#define MTP_RESPONSECODE_WMDRMND_UNABLE_TO_OPEN_FILE                 0xA18B
#define MTP_RESPONSECODE_WMDRMND_UNSUPPORTED_PROTOCOL_VERSION        0xA18C
#define MTP_RESPONSECODE_WMDRMND_BAD_REQUEST                         0xA18D
#define MTP_RESPONSECODE_WMDRMND_INVALID_TRANSACTION_REGISTRATION_ID 0xA18E

/*
 * Mappings of PTP and MTP object formats
 */
#define  WMDRMND_FORMATCODE_UNDEFINED      0x3000
#define  WMDRMND_FORMATCODE_ASSOCIATION    0x3001
#define  WMDRMND_FORMATCODE_SCRIPT         0x3002
#define  WMDRMND_FORMATCODE_EXECUTABLE     0x3003
#define  WMDRMND_FORMATCODE_TEXT           0x3004
#define  WMDRMND_FORMATCODE_HTML           0x3005
#define  WMDRMND_FORMATCODE_DPOF           0x3006
#define  WMDRMND_FORMATCODE_AIFF           0x3007
#define  WMDRMND_FORMATCODE_WAVE           0x3008
#define  WMDRMND_FORMATCODE_MP3            0x3009
#define  WMDRMND_FORMATCODE_AVI            0x300A
#define  WMDRMND_FORMATCODE_MPEG           0x300B
#define  WMDRMND_FORMATCODE_ASF            0x300C

#define  WMDRMND_FORMATCODE_UNDEFINED_FIRMWARE              0xB802
#define  WMDRMND_FORMATCODE_WINDOWS_IMAGE_FORMAT            0xB881
#define  WMDRMND_FORMATCODE_UNDEFINED_AUDIO                 0xB900
#define  WMDRMND_FORMATCODE_WMA                             0xB901
#define  WMDRMND_FORMATCODE_UNDEFINED_VIDEO                 0xB980
#define  WMDRMND_FORMATCODE_WMV                             0xB981
#define  WMDRMND_FORMATCODE_UNDEFINED_COLLECTION            0xBA00
#define  WMDRMND_FORMATCODE_ABSTRACT_MULTIMEDIA_ALBUM       0xBA01
#define  WMDRMND_FORMATCODE_ABSTRACT_IMAGE_ALBUM            0xBA02
#define  WMDRMND_FORMATCODE_ABSTRACT_AUDIO_ALBUM            0xBA03
#define  WMDRMND_FORMATCODE_ABSTRACT_VIDEO_ALBUM            0xBA04
#define  WMDRMND_FORMATCODE_ABSTRACT_AV_PLAYLIST            0xBA05
#define  WMDRMND_FORMATCODE_ABSTRACT_CONTACT_GROUP          0xBA06
#define  WMDRMND_FORMATCODE_ABSTRACT_MESSAGE_FOLDER         0xBA07
#define  WMDRMND_FORMATCODE_ABSTRACT_CHAPTERED_PRODUCTION   0xBA08
#define  WMDRMND_FORMATCODE_WPL_PLAYLIST                    0xBA10
#define  WMDRMND_FORMATCODE_M3U_PLAYLIST                    0xBA11
#define  WMDRMND_FORMATCODE_MPL_PLAYLIST                    0xBA12
#define  WMDRMND_FORMATCODE_ASX_PLAYLIST                    0xBA13
#define  WMDRMND_FORMATCODE_PLS_PLAYLIST                    0xBA14
#define  WMDRMND_FORMATCODE_UNDEFINED_DOCUMENT              0xBA80
#define  WMDRMND_FORMATCODE_ABSTRACT_DOCUMENT               0xBA81
#define  WMDRMND_FORMATCODE_UNDEFINED_MESSAGE               0xBB00
#define  WMDRMND_FORMATCODE_ABSTRACT_MESSAGE                0xBB01
#define  WMDRMND_FORMATCODE_UNDEFINED_CONTACT               0xBB80
#define  WMDRMND_FORMATCODE_ABSTRACT_CONTACT                0xBB81
#define  WMDRMND_FORMATCODE_VCARD2                          0xBB82
#define  WMDRMND_FORMATCODE_VCARD3                          0xBB83
#define  WMDRMND_FORMATCODE_UNDEFINED_CALENDAR_ITEM         0xBE00
#define  WMDRMND_FORMATCODE_ABSTRACT_CALENDAR_ITEM          0xBE01
#define  WMDRMND_FORMATCODE_VCALENDAR1                      0xBE02
#define  WMDRMND_FORMATCODE_UNDEFINED_WINDOWS_EXECUTABLE    0xBE80

EXIT_PK_NAMESPACE;    

#endif  /* _PFDDRMMTPEXTENSIONS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\oem_msdbpk.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
**  File oem_msdbpk.h - declarations for OEM functions required for MSDB PK.
**  These OEM functions are called by MSDB PK internally and should be implemented 
**  in order to link the project.
**  There is an example implementation of these functions in file oemcfdimpl.c
*/

#ifndef __OEM_MSDB_PK_H__
#define __OEM_MSDB_PK_H__

#include <drmkeygenerator.h>



/* The size of a Content Key Seed in raw (30 bytes), not B64 encoded (40 bytes), form. */
#define CKSEED_NOT_B64_ENCODED_LEN  30

ENTER_PK_NAMESPACE;

DRM_API DRM_RESULT DRM_CALL OEM_GetCRL(
   IN     DRM_GUID   f_guidCRL,      
   OUT    DRM_BYTE  *f_pbCRLData,    
   IN OUT DRM_DWORD *f_pcbCRLData    
);

DRM_API DRM_RESULT DRM_CALL OEM_SetCRL
(
   IN       DRM_GUID        f_guidCRL,  
   IN const DRM_BYTE       *f_pbCRLData,
   IN       DRM_DWORD       f_cbCRLData
);

DRM_API DRM_RESULT DRM_CALL OEM_GetContentKeySeed
(
      OUT  DRM_WCHAR        f_wszKeySeed[DRM_KEYSEED_BASE64_LEN]
);

DRM_API DRM_RESULT DRM_CALL OEM_GetLicenseServerPrivateKey
(
    OUT PRIVKEY   *f_pLSPrivateKey
);

DRM_API DRM_RESULT DRM_CALL OEM_GetLicenseCertificates
(
       OUT DRM_BYTE  *f_pbCertificate2,
    IN     DRM_DWORD  f_cbC2Size,
       OUT DRM_BYTE  *f_pbCertificate1,
    IN     DRM_DWORD  f_cbC1Size
);

EXIT_PK_NAMESPACE;

#endif /* __OEM_MSDB_PK_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\sel.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

const DRM_DWORD _DRM_Sel[8][64]={
    0x00000000,0x00000010,0x20000000,0x20000010,
    0x00010000,0x00010010,0x20010000,0x20010010,
    0x00000800,0x00000810,0x20000800,0x20000810,
    0x00010800,0x00010810,0x20010800,0x20010810,
    0x00000020,0x00000030,0x20000020,0x20000030,
    0x00010020,0x00010030,0x20010020,0x20010030,
    0x00000820,0x00000830,0x20000820,0x20000830,
    0x00010820,0x00010830,0x20010820,0x20010830,
    0x00080000,0x00080010,0x20080000,0x20080010,
    0x00090000,0x00090010,0x20090000,0x20090010,
    0x00080800,0x00080810,0x20080800,0x20080810,
    0x00090800,0x00090810,0x20090800,0x20090810,
    0x00080020,0x00080030,0x20080020,0x20080030,
    0x00090020,0x00090030,0x20090020,0x20090030,
    0x00080820,0x00080830,0x20080820,0x20080830,
    0x00090820,0x00090830,0x20090820,0x20090830,
    0x00000000,0x02000000,0x00002000,0x02002000,
    0x00200000,0x02200000,0x00202000,0x02202000,
    0x00000004,0x02000004,0x00002004,0x02002004,
    0x00200004,0x02200004,0x00202004,0x02202004,
    0x00000400,0x02000400,0x00002400,0x02002400,
    0x00200400,0x02200400,0x00202400,0x02202400,
    0x00000404,0x02000404,0x00002404,0x02002404,
    0x00200404,0x02200404,0x00202404,0x02202404,
    0x10000000,0x12000000,0x10002000,0x12002000,
    0x10200000,0x12200000,0x10202000,0x12202000,
    0x10000004,0x12000004,0x10002004,0x12002004,
    0x10200004,0x12200004,0x10202004,0x12202004,
    0x10000400,0x12000400,0x10002400,0x12002400,
    0x10200400,0x12200400,0x10202400,0x12202400,
    0x10000404,0x12000404,0x10002404,0x12002404,
    0x10200404,0x12200404,0x10202404,0x12202404,
    0x00000000,0x00000001,0x00040000,0x00040001,
    0x01000000,0x01000001,0x01040000,0x01040001,
    0x00000002,0x00000003,0x00040002,0x00040003,
    0x01000002,0x01000003,0x01040002,0x01040003,
    0x00000200,0x00000201,0x00040200,0x00040201,
    0x01000200,0x01000201,0x01040200,0x01040201,
    0x00000202,0x00000203,0x00040202,0x00040203,
    0x01000202,0x01000203,0x01040202,0x01040203,
    0x08000000,0x08000001,0x08040000,0x08040001,
    0x09000000,0x09000001,0x09040000,0x09040001,
    0x08000002,0x08000003,0x08040002,0x08040003,
    0x09000002,0x09000003,0x09040002,0x09040003,
    0x08000200,0x08000201,0x08040200,0x08040201,
    0x09000200,0x09000201,0x09040200,0x09040201,
    0x08000202,0x08000203,0x08040202,0x08040203,
    0x09000202,0x09000203,0x09040202,0x09040203,
    0x00000000,0x00100000,0x00000100,0x00100100,
    0x00000008,0x00100008,0x00000108,0x00100108,
    0x00001000,0x00101000,0x00001100,0x00101100,
    0x00001008,0x00101008,0x00001108,0x00101108,
    0x04000000,0x04100000,0x04000100,0x04100100,
    0x04000008,0x04100008,0x04000108,0x04100108,
    0x04001000,0x04101000,0x04001100,0x04101100,
    0x04001008,0x04101008,0x04001108,0x04101108,
    0x00020000,0x00120000,0x00020100,0x00120100,
    0x00020008,0x00120008,0x00020108,0x00120108,
    0x00021000,0x00121000,0x00021100,0x00121100,
    0x00021008,0x00121008,0x00021108,0x00121108,
    0x04020000,0x04120000,0x04020100,0x04120100,
    0x04020008,0x04120008,0x04020108,0x04120108,
    0x04021000,0x04121000,0x04021100,0x04121100,
    0x04021008,0x04121008,0x04021108,0x04121108,
    0x00000000,0x10000000,0x00010000,0x10010000,
    0x00000004,0x10000004,0x00010004,0x10010004,
    0x20000000,0x30000000,0x20010000,0x30010000,
    0x20000004,0x30000004,0x20010004,0x30010004,
    0x00100000,0x10100000,0x00110000,0x10110000,
    0x00100004,0x10100004,0x00110004,0x10110004,
    0x20100000,0x30100000,0x20110000,0x30110000,
    0x20100004,0x30100004,0x20110004,0x30110004,
    0x00001000,0x10001000,0x00011000,0x10011000,
    0x00001004,0x10001004,0x00011004,0x10011004,
    0x20001000,0x30001000,0x20011000,0x30011000,
    0x20001004,0x30001004,0x20011004,0x30011004,
    0x00101000,0x10101000,0x00111000,0x10111000,
    0x00101004,0x10101004,0x00111004,0x10111004,
    0x20101000,0x30101000,0x20111000,0x30111000,
    0x20101004,0x30101004,0x20111004,0x30111004,
    0x00000000,0x08000000,0x00000008,0x08000008,
    0x00000400,0x08000400,0x00000408,0x08000408,
    0x00020000,0x08020000,0x00020008,0x08020008,
    0x00020400,0x08020400,0x00020408,0x08020408,
    0x00000001,0x08000001,0x00000009,0x08000009,
    0x00000401,0x08000401,0x00000409,0x08000409,
    0x00020001,0x08020001,0x00020009,0x08020009,
    0x00020401,0x08020401,0x00020409,0x08020409,
    0x02000000,0x0A000000,0x02000008,0x0A000008,
    0x02000400,0x0A000400,0x02000408,0x0A000408,
    0x02020000,0x0A020000,0x02020008,0x0A020008,
    0x02020400,0x0A020400,0x02020408,0x0A020408,
    0x02000001,0x0A000001,0x02000009,0x0A000009,
    0x02000401,0x0A000401,0x02000409,0x0A000409,
    0x02020001,0x0A020001,0x02020009,0x0A020009,
    0x02020401,0x0A020401,0x02020409,0x0A020409,
    0x00000000,0x00000100,0x00080000,0x00080100,
    0x01000000,0x01000100,0x01080000,0x01080100,
    0x00000010,0x00000110,0x00080010,0x00080110,
    0x01000010,0x01000110,0x01080010,0x01080110,
    0x00200000,0x00200100,0x00280000,0x00280100,
    0x01200000,0x01200100,0x01280000,0x01280100,
    0x00200010,0x00200110,0x00280010,0x00280110,
    0x01200010,0x01200110,0x01280010,0x01280110,
    0x00000200,0x00000300,0x00080200,0x00080300,
    0x01000200,0x01000300,0x01080200,0x01080300,
    0x00000210,0x00000310,0x00080210,0x00080310,
    0x01000210,0x01000310,0x01080210,0x01080310,
    0x00200200,0x00200300,0x00280200,0x00280300,
    0x01200200,0x01200300,0x01280200,0x01280300,
    0x00200210,0x00200310,0x00280210,0x00280310,
    0x01200210,0x01200310,0x01280210,0x01280310,
    0x00000000,0x04000000,0x00040000,0x04040000,
    0x00000002,0x04000002,0x00040002,0x04040002,
    0x00002000,0x04002000,0x00042000,0x04042000,
    0x00002002,0x04002002,0x00042002,0x04042002,
    0x00000020,0x04000020,0x00040020,0x04040020,
    0x00000022,0x04000022,0x00040022,0x04040022,
    0x00002020,0x04002020,0x00042020,0x04042020,
    0x00002022,0x04002022,0x00042022,0x04042022,
    0x00000800,0x04000800,0x00040800,0x04040800,
    0x00000802,0x04000802,0x00040802,0x04040802,
    0x00002800,0x04002800,0x00042800,0x04042800,
    0x00002802,0x04002802,0x00042802,0x04042802,
    0x00000820,0x04000820,0x00040820,0x04040820,
    0x00000822,0x04000822,0x00040822,0x04040822,
    0x00002820,0x04002820,0x00042820,0x04042820,
    0x00002822,0x04002822,0x00042822,0x04042822,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\inc\oemaes.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
**  oemaes.h
**
**  Contains structures and function definitions implemented in oemaes.c
**  
*/

#ifndef __OEMAES_H__
#define __OEMAES_H__

#include <oemaesimpl.h>
#include <drmaescommon.h>

ENTER_PK_NAMESPACE;

/*
** AES secret key
**
** The actual contents of the structure are opaque.
**
** The opaque data is represented as a byte array below.
** Do not access the array directly.
*/
typedef struct __tagDRM_AES_KEY 
{
    DRM_BYTE rgbOpaque[__CB_DECL( DRM_AES_KEYSIZE )];
} DRM_AES_KEY;

DRM_API DRM_RESULT DRM_CALL Oem_Aes_ZeroKey( 
    __inout_ecount( 1 )                      DRM_AES_KEY  *f_pKey );

DRM_API DRM_RESULT DRM_CALL Oem_Aes_SetKey(
    __in_bcount( DRM_AES_KEYSIZE_128 ) const DRM_BYTE      f_rgbKey[__CB_DECL( DRM_AES_KEYSIZE_128 )],
    __inout_ecount( 1 )                      DRM_AES_KEY  *f_pAesKey );

DRM_API DRM_RESULT DRM_CALL Oem_Aes_EncryptOne(
    __in_ecount( 1 )                   const DRM_AES_KEY  *f_pKey,        
    __inout_bcount( DRM_AES_BLOCKLEN )       DRM_BYTE      f_rgbData[__CB_DECL( DRM_AES_BLOCKLEN )] );

DRM_API DRM_RESULT DRM_CALL Oem_Aes_DecryptOne(
    __in_ecount( 1 )                   const DRM_AES_KEY  *f_pKey,    
    __inout_bcount( DRM_AES_BLOCKLEN )       DRM_BYTE      f_rgbData[__CB_DECL( DRM_AES_BLOCKLEN )] );

EXIT_PK_NAMESPACE;

#endif /* __OEMAES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\sendwindow.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef NDTASFSENDWINDOW_H
#define NDTASFSENDWINDOW_H

#include <drmptrlist.h>
#include <drmorderedlist.h>
#include <packetwriter.h>

ENTER_PK_NAMESPACE;

#define ASF_MUX_QUEUE_TYPE_UNKNOWN        0
#define ASF_MUX_QUEUE_TYPE_FRAGMENTABLE   1
#define ASF_MUX_QUEUE_TYPE_UNFRAGMENTABLE 2

typedef struct tagASF_MUX_QUEUE_OBJECT_CONTEXT
{
    DRM_DWORD           m_dwType;
    DRM_DWORD           m_cRef;
    DRM_UINT64          m_msPresTime;
    DRM_UINT64          m_hnsSendTime;
    DRM_WORD            m_wStreamNumber;
    DRM_BYTE            m_bObjectID;
    DRM_DWORD           m_dwFlags;
    DRM_BOOL            m_fFragmentable;

    DRM_DWORD           m_cbSize;
    DRM_DWORD           m_cbTotalObjectSize;

    ASF_SAMPLE         *m_pMFSample;
    DRM_DWORD           m_cbAlreadyPacketized;
    DRM_DWORD           m_cbTargetSize;
    DRM_DWORD           m_cbOffsetIntoFirstSample;
    ASF_SAMPLE         *m_pInternalSample;

    PTR_LIST            m_SamplesToBeFinished;

} ASF_MUX_QUEUE_OBJECT_CONTEXT;


DRM_RESULT ASFMuxQueueObject_Initialize(
    __out      ASF_MUX_QUEUE_OBJECT_CONTEXT * const pAsfMuxQueueObjectContext,
    __in const DRM_DWORD                            dwType,
    __in       ASF_SAMPLE                   * const pMFSample,
    __in const DRM_DWORD                            cbOffsetIntoFirstSample,
    __in const DRM_DWORD                            cbTargetSize,
    __in const DRM_UINT64                           msPresTime,
    __in const DRM_UINT64                           hnsSendTime,
    __in const DRM_WORD                             wStreamNumber,
    __in const DRM_BYTE                             bObjectID,
    __in const DRM_DWORD                            dwFlags
);

DRM_VOID ASFMuxQueueObject_Uninitialize(
    __inout ASF_MUX_QUEUE_OBJECT_CONTEXT * const pAsfMuxQueueObjectContext
);

DRM_RESULT ASFMuxQueueObject_GeneratePayload( 
    __inout ASF_MUX_QUEUE_OBJECT_CONTEXT * const pAsfMuxQueueObjectContext,
    __inout ASF_PACKET_WRITER_CONTEXT    * const pASFPacketWriter
);

DRM_RESULT ASFMuxQueueObject_FillInASFPayloadInfo(
    __in const ASF_MUX_QUEUE_OBJECT_CONTEXT * const pAsfMuxQueueObjectContext,
    __out      ASF_PAYLOAD_PARSER_INFO      * const pASFPayloadInfo 
);

DRM_RESULT ASFMuxQueueObject_PopUsedSample( 
    __inout ASF_MUX_QUEUE_OBJECT_CONTEXT * const pAsfMuxQueueObjectContext,
    __out   ASF_SAMPLE                         **ppUsedSample
);

DRM_RESULT ASFMuxQueueObject_AddSegment(
    __inout    ASF_MUX_QUEUE_OBJECT_CONTEXT * const pAsfMuxQueueObjectContext,
    __in       ASF_SAMPLE                   * const pMFSample,
    __in const DRM_DWORD                            cbOffsetIntoSample,
    __out      DRM_DWORD                    * const pcbBytesUsed 
);

DRM_RESULT ASFMuxQueueObject_AddRef(
    __out ASF_MUX_QUEUE_OBJECT_CONTEXT * const pAsfMuxQueueObjectContext
);

DRM_VOID ASFMuxQueueObject_Release(
    __out ASF_MUX_QUEUE_OBJECT_CONTEXT *pAsfMuxQueueObjectContext
);

typedef struct tagASF_MUX_SEND_WINDOW_CONTEXT
{
    DRM_DWORD                                        m_msWindowSize;
    DRM_DWORD                                        m_cbFixedPacketSize;
    DRM_DWORD                                        m_msFirstPresTime;

    struct __tagASF_MULTIPLEXER_CONTEXT             *m_pMux;  /* Backpointer */

    ORDERED_LIST                                     m_Samples;
    DRM_UINT64                                       m_hnsLatestSendTimeQueued;

    /* Properties of in-progress write packet */
    ASF_PACKET_WRITER_CONTEXT                        m_ASFPacketWriterContext;
    DRM_UINT64                                       m_hnsWritePacketSendTime;

    /* Running stats */
    DRM_UINT64                                       m_cbSent;
    DRM_DWORD                                        m_cPacketsSent;
    DRM_UINT64                                       m_msLastSendTimeSent;
    DRM_UINT64                                       m_msLastPresTimeSent;
    DRM_UINT64                                       m_msLastSendDurationSent;
} ASF_MUX_SEND_WINDOW_CONTEXT;


DRM_RESULT ASFMuxSendWindow_Initialize(
    __out      ASF_MUX_SEND_WINDOW_CONTEXT         * const pAsfMuxSendWindowContext,
    __in const DRM_DWORD                                   msWindowSize,
    __in const DRM_DWORD                                   cbFixedPacketSize,
    __in const DRM_DWORD                                   msFirstPresTime,
    __in       struct __tagASF_MULTIPLEXER_CONTEXT * const pMux 
);

DRM_VOID ASFMuxSendWindow_Uninitialize(
    __inout ASF_MUX_SEND_WINDOW_CONTEXT * const pAsfMuxSendWindowContext
);

DRM_RESULT ASFMuxSendWindow_AddObjectsAndSendPackets(
    __inout               ASF_MUX_SEND_WINDOW_CONTEXT  * const pAsfMuxSendWindowContext,
    __in_ecount(cObjects) ASF_MUX_QUEUE_OBJECT_CONTEXT       **ppMuxQueueObjects,
    __in const            DRM_DWORD                            cObjects 
);

DRM_RESULT ASFMuxSendWindow_Flush(
    __inout ASF_MUX_SEND_WINDOW_CONTEXT * const pAsfMuxSendWindowContext
);

EXIT_PK_NAMESPACE;

#endif /* NDTASFSENDWINDOW_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\spb.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

const DRM_DWORD _DRM_Spbox[8][64] = {
    0x02080800,0x00080000,0x02000002,0x02080802,
    0x02000000,0x00080802,0x00080002,0x02000002,
    0x00080802,0x02080800,0x02080000,0x00000802,
    0x02000802,0x02000000,0x00000000,0x00080002,
    0x00080000,0x00000002,0x02000800,0x00080800,
    0x02080802,0x02080000,0x00000802,0x02000800,
    0x00000002,0x00000800,0x00080800,0x02080002,
    0x00000800,0x02000802,0x02080002,0x00000000,
    0x00000000,0x02080802,0x02000800,0x00080002,
    0x02080800,0x00080000,0x00000802,0x02000800,
    0x02080002,0x00000800,0x00080800,0x02000002,
    0x00080802,0x00000002,0x02000002,0x02080000,
    0x02080802,0x00080800,0x02080000,0x02000802,
    0x02000000,0x00000802,0x00080002,0x00000000,
    0x00080000,0x02000000,0x02000802,0x02080800,
    0x00000002,0x02080002,0x00000800,0x00080802,
    0x40108010,0x00000000,0x00108000,0x40100000,
    0x40000010,0x00008010,0x40008000,0x00108000,
    0x00008000,0x40100010,0x00000010,0x40008000,
    0x00100010,0x40108000,0x40100000,0x00000010,
    0x00100000,0x40008010,0x40100010,0x00008000,
    0x00108010,0x40000000,0x00000000,0x00100010,
    0x40008010,0x00108010,0x40108000,0x40000010,
    0x40000000,0x00100000,0x00008010,0x40108010,
    0x00100010,0x40108000,0x40008000,0x00108010,
    0x40108010,0x00100010,0x40000010,0x00000000,
    0x40000000,0x00008010,0x00100000,0x40100010,
    0x00008000,0x40000000,0x00108010,0x40008010,
    0x40108000,0x00008000,0x00000000,0x40000010,
    0x00000010,0x40108010,0x00108000,0x40100000,
    0x40100010,0x00100000,0x00008010,0x40008000,
    0x40008010,0x00000010,0x40100000,0x00108000,
    0x04000001,0x04040100,0x00000100,0x04000101,
    0x00040001,0x04000000,0x04000101,0x00040100,
    0x04000100,0x00040000,0x04040000,0x00000001,
    0x04040101,0x00000101,0x00000001,0x04040001,
    0x00000000,0x00040001,0x04040100,0x00000100,
    0x00000101,0x04040101,0x00040000,0x04000001,
    0x04040001,0x04000100,0x00040101,0x04040000,
    0x00040100,0x00000000,0x04000000,0x00040101,
    0x04040100,0x00000100,0x00000001,0x00040000,
    0x00000101,0x00040001,0x04040000,0x04000101,
    0x00000000,0x04040100,0x00040100,0x04040001,
    0x00040001,0x04000000,0x04040101,0x00000001,
    0x00040101,0x04000001,0x04000000,0x04040101,
    0x00040000,0x04000100,0x04000101,0x00040100,
    0x04000100,0x00000000,0x04040001,0x00000101,
    0x04000001,0x00040101,0x00000100,0x04040000,
    0x00401008,0x10001000,0x00000008,0x10401008,
    0x00000000,0x10400000,0x10001008,0x00400008,
    0x10401000,0x10000008,0x10000000,0x00001008,
    0x10000008,0x00401008,0x00400000,0x10000000,
    0x10400008,0x00401000,0x00001000,0x00000008,
    0x00401000,0x10001008,0x10400000,0x00001000,
    0x00001008,0x00000000,0x00400008,0x10401000,
    0x10001000,0x10400008,0x10401008,0x00400000,
    0x10400008,0x00001008,0x00400000,0x10000008,
    0x00401000,0x10001000,0x00000008,0x10400000,
    0x10001008,0x00000000,0x00001000,0x00400008,
    0x00000000,0x10400008,0x10401000,0x00001000,
    0x10000000,0x10401008,0x00401008,0x00400000,
    0x10401008,0x00000008,0x10001000,0x00401008,
    0x00400008,0x00401000,0x10400000,0x10001008,
    0x00001008,0x10000000,0x10000008,0x10401000,
    0x08000000,0x00010000,0x00000400,0x08010420,
    0x08010020,0x08000400,0x00010420,0x08010000,
    0x00010000,0x00000020,0x08000020,0x00010400,
    0x08000420,0x08010020,0x08010400,0x00000000,
    0x00010400,0x08000000,0x00010020,0x00000420,
    0x08000400,0x00010420,0x00000000,0x08000020,
    0x00000020,0x08000420,0x08010420,0x00010020,
    0x08010000,0x00000400,0x00000420,0x08010400,
    0x08010400,0x08000420,0x00010020,0x08010000,
    0x00010000,0x00000020,0x08000020,0x08000400,
    0x08000000,0x00010400,0x08010420,0x00000000,
    0x00010420,0x08000000,0x00000400,0x00010020,
    0x08000420,0x00000400,0x00000000,0x08010420,
    0x08010020,0x08010400,0x00000420,0x00010000,
    0x00010400,0x08010020,0x08000400,0x00000420,
    0x00000020,0x00010420,0x08010000,0x08000020,
    0x80000040,0x00200040,0x00000000,0x80202000,
    0x00200040,0x00002000,0x80002040,0x00200000,
    0x00002040,0x80202040,0x00202000,0x80000000,
    0x80002000,0x80000040,0x80200000,0x00202040,
    0x00200000,0x80002040,0x80200040,0x00000000,
    0x00002000,0x00000040,0x80202000,0x80200040,
    0x80202040,0x80200000,0x80000000,0x00002040,
    0x00000040,0x00202000,0x00202040,0x80002000,
    0x00002040,0x80000000,0x80002000,0x00202040,
    0x80202000,0x00200040,0x00000000,0x80002000,
    0x80000000,0x00002000,0x80200040,0x00200000,
    0x00200040,0x80202040,0x00202000,0x00000040,
    0x80202040,0x00202000,0x00200000,0x80002040,
    0x80000040,0x80200000,0x00202040,0x00000000,
    0x00002000,0x80000040,0x80002040,0x80202000,
    0x80200000,0x00002040,0x00000040,0x80200040,
    0x00004000,0x00000200,0x01000200,0x01000004,
    0x01004204,0x00004004,0x00004200,0x00000000,
    0x01000000,0x01000204,0x00000204,0x01004000,
    0x00000004,0x01004200,0x01004000,0x00000204,
    0x01000204,0x00004000,0x00004004,0x01004204,
    0x00000000,0x01000200,0x01000004,0x00004200,
    0x01004004,0x00004204,0x01004200,0x00000004,
    0x00004204,0x01004004,0x00000200,0x01000000,
    0x00004204,0x01004000,0x01004004,0x00000204,
    0x00004000,0x00000200,0x01000000,0x01004004,
    0x01000204,0x00004204,0x00004200,0x00000000,
    0x00000200,0x01000004,0x00000004,0x01000200,
    0x00000000,0x01000204,0x01000200,0x00004200,
    0x00000204,0x00004000,0x01004204,0x01000000,
    0x01004200,0x00000004,0x00004004,0x01004204,
    0x01000004,0x01004200,0x01004000,0x00004004,
    0x20800080,0x20820000,0x00020080,0x00000000,
    0x20020000,0x00800080,0x20800000,0x20820080,
    0x00000080,0x20000000,0x00820000,0x00020080,
    0x00820080,0x20020080,0x20000080,0x20800000,
    0x00020000,0x00820080,0x00800080,0x20020000,
    0x20820080,0x20000080,0x00000000,0x00820000,
    0x20000000,0x00800000,0x20020080,0x20800080,
    0x00800000,0x00020000,0x20820000,0x00000080,
    0x00800000,0x00020000,0x20000080,0x20820080,
    0x00020080,0x20000000,0x00000000,0x00820000,
    0x20800080,0x20020080,0x20020000,0x00800080,
    0x20820000,0x00000080,0x00800080,0x20020000,
    0x20820080,0x00800000,0x20800000,0x20000080,
    0x00820000,0x00020080,0x20020080,0x20800000,
    0x00000080,0x20820000,0x00820080,0x00000000,
    0x20000000,0x20800080,0x00020000,0x00820080,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\inc\wmdrmndresults.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef WMDMRND_RESULTS_H
#define WMDRMND_RESULTS_H

#include <drmtypes.h>

typedef DRM_WORD WMDRMND_RESULT;

#define WMDRMND_SUCCESS                          ((WMDRMND_RESULT)   0)
#define WMDRMND_E_INVALIDCERTIFICATE             ((WMDRMND_RESULT) 100)
#define WMDRMND_E_CERTIFICATEREVOKED             ((WMDRMND_RESULT) 101)
#define WMDRMND_E_MUSTAPPROVE                    ((WMDRMND_RESULT) 102)
#define WMDRMND_E_LICENSEUNAVAILABLE             ((WMDRMND_RESULT) 103)
#define WMDRMND_E_TRANSMITTERFAILURE             ((WMDRMND_RESULT) 104)
#define WMDRMND_E_DEVICELIMITREACHED             ((WMDRMND_RESULT) 105)
#define WMDRMND_E_UNABLETOVERIFYPROXIMITY        ((WMDRMND_RESULT) 106)
#define WMDRMND_E_MUSTREGISTER                   ((WMDRMND_RESULT) 107)
#define WMDRMND_E_MUSTREVALIDATE                 ((WMDRMND_RESULT) 108)
#define WMDRMND_E_INVALIDPROXIMITYRESPONSE       ((WMDRMND_RESULT) 109)
#define WMDRMND_E_INVALIDSESSION                 ((WMDRMND_RESULT) 110)
#define WMDRMND_E_UNABLETOOPENFILE               ((WMDRMND_RESULT) 111)
#define WMDRMND_E_UNSUPPORTEDPROTOCOLVERSION     ((WMDRMND_RESULT) 112)
#define WMDRMND_E_BADREQUEST                     ((WMDRMND_RESULT) 113)

#endif /* WMDRMND_RESULTS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\inc\oemaesimpl.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
**  oemaesimpl.h
**
**  Contains AES secret key and key table definitions used in the oem aes implementation, and 
**  to create an opaque aes key structure in oemaes.h
**  
*/

#ifndef __OEMAESIMPL_H__
#define __OEMAESIMPL_H__

#include <drmaescommon.h>

ENTER_PK_NAMESPACE;

/*
** AES Key Table structures
*/
typedef struct 
{
    DRM_DWORD   keytabenc[DRM_AES_ROUNDS_128+1][4];
    DRM_DWORD   keytabdec[DRM_AES_ROUNDS_128+1][4];
} DRM_AESTable_128;

#define DRM_AESTable          DRM_AESTable_128
#define DRM_AES_TABLESIZE     SIZEOF( DRM_AESTable )

/*
** Internal AES secret key
*/
typedef struct 
{
    DRM_AESTable   AESTable;
    DRM_BYTE   rgbKey[__CB_DECL( DRM_AES_KEYSIZE_128 )];
} INTERNAL_DRM_AES_KEY;

#define DRM_AES_KEYSIZE  SIZEOF( INTERNAL_DRM_AES_KEY )


EXIT_PK_NAMESPACE;

#endif /* __OEMAESIMPL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\inc\oem.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __OEM_H__
#define __OEM_H__

#include <oemcommon.h>

#include <oemplatform.h>

#if DRM_BUILD_PROFILE == DRM_BUILD_PROFILE_PC


#endif

#endif  /* __OEM_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\inc\oemdebug.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __OEMDEBUG_H__
#define __OEMDEBUG_H__

ENTER_PK_NAMESPACE;

DRM_API DRM_VOID DRM_CALL Oem_Debug_Trace( 
    __in DRM_CHAR *szFmt,
    ... );

DRM_API DRM_VOID DRM_CALL Oem_Debug_HookTrace(
    __in DRM_VOID *pNewTraceFcn );

DRM_API DRM_VOID DRM_CALL Oem_Debug_Assert
(
    __in DRM_BOOL fAssert, 
    __in DRM_CHAR *assertcmd, 
    __in DRM_CHAR *file, 
    __in DRM_INT line
);

DRM_API DRM_VOID DRM_CALL Oem_Debug_HookAssert(
    __in DRM_VOID *pNewAssertFcn );


EXIT_PK_NAMESPACE;

#endif /* __OEMDEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\inc\oemdevstore.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __OEMDEVSTORE_H__
#define __OEMDEVSTORE_H__

#include <oemcommon.h>
#include <oemcontextsizes.h>

ENTER_PK_NAMESPACE;

DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_Initialize(
    __inout_ecount(1) OEM_DEVICESTORE_CONTEXT   *f_pDeviceStoreContext,
    __in_ecount(1)    OEM_DEVICESTORE_INITDATA  *f_pDeviceStoreInitData
);


DRM_API DRM_VOID DRM_CALL Oem_DeviceStore_Uninitialize(
    __inout_ecount(1)   OEM_DEVICESTORE_CONTEXT *f_pDeviceStoreContext
);


DRM_API DRM_VOID DRM_CALL Oem_DeviceStore_FreeDevice (
    __in     OEM_DEVICE_HANDLE            f_hDeviceHandle
);


DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_RegisterDevice(
    __inout_ecount(1) OEM_DEVICESTORE_CONTEXT      *f_pDeviceStoreContext,
    __in              DRM_BYTEBLOB                  f_DeviceID,
    __out_ecount(1)   OEM_DEVICE_HANDLE            *f_phDeviceHandle
);


DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_UnRegisterDevice(
    __inout_ecount(1) OEM_DEVICESTORE_CONTEXT      *f_pDeviceStoreContext,
    __in              DRM_BYTEBLOB                  f_DeviceID
);


DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_GetFirstDevice(
    __inout_ecount(1) OEM_DEVICESTORE_CONTEXT      *f_pDeviceStoreContext,
    __out_ecount(1)   OEM_DEVICE_HANDLE            *f_phDeviceHandle
);


DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_GetNextDevice(
    __in_ecount(1)    OEM_DEVICESTORE_CONTEXT      *f_pDeviceStoreContext,
    __inout_ecount(1) OEM_DEVICE_HANDLE            *f_phDeviceHandle
);


DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_GetDeviceByID(
    __inout_ecount(1) OEM_DEVICESTORE_CONTEXT      *f_pDeviceStoreContext,
    __in              DRM_BYTEBLOB                  f_DeviceID,
    __out_ecount(1)   OEM_DEVICE_HANDLE            *f_phDeviceHandle
);


DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_GetDeviceID(
    __in                         OEM_DEVICE_HANDLE    f_hDeviceHandle,
    __out_ecount(*f_pcbDeviceID) DRM_BYTE            *f_pbDeviceID,
    __inout_ecount(1)            DRM_DWORD           *f_pcbDeviceID
);


DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_GetDeviceAttr(
    __in                          OEM_DEVICE_HANDLE  f_hDeviceHandle,
    __in                          DRM_BYTEBLOB       f_AttrName,
    __out_bcount(*f_pcbAttrValue) DRM_BYTE          *f_pbAttrValue,
    __inout_ecount(1)             DRM_DWORD         *f_pcbAttrValue
);


DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_GetDeviceAttrCount(
    __in                OEM_DEVICE_HANDLE            f_hDeviceHandle,
       __out_ecount(1)  DRM_DWORD                   *f_pdwAttrCount
);


DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_GetDeviceAttrByIndex(
    __in                            OEM_DEVICE_HANDLE    f_hDeviceHandle,
    __in                            DRM_DWORD            f_dwAttrIndex,
    __inout_bcount(*f_pcbAttrName)  DRM_BYTE            *f_pbAttrName,
    __inout_ecount(1)               DRM_DWORD           *f_pcbAttrName,
    __inout_bcount(*f_pcbAttrValue) DRM_BYTE            *f_pbAttrValue,
    __inout_ecount(1)               DRM_DWORD           *f_pcbAttrValue
);


DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_SetDeviceAttr(
    __in     OEM_DEVICE_HANDLE                 f_hDeviceHandle,
    __in     DRM_BYTEBLOB                      f_AttrName,
    __in     DRM_BYTEBLOB                      f_AttrValue
);


DRM_API DRM_RESULT DRM_CALL Oem_DeviceStore_CommitDevice(
    __in     OEM_DEVICE_HANDLE            f_hDeviceHandle
);


EXIT_PK_NAMESPACE;

#endif /*  __OEMDEVSTORE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\inc\oemndt.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __OEMNDT_H__
#define __OEMNDT_H__

#include <ndttypes.h>
#include <oemcommon.h>

ENTER_PK_NAMESPACE;

DRM_API DRM_RESULT DRM_CALL Oem_Ndt_AllowNewDeviceRegistration(
    __in     DRM_BYTEBLOB f_DeviceCertificate,
    __in     DRM_BYTEBLOB f_DeviceSerialNumber
);


DRM_API DRM_RESULT DRM_CALL Oem_Ndt_GetProximityDetectionAddress(
    __out_bcount_opt(*f_pcbAddress) DRM_BYTE       *f_pbAddress,
    __inout                         DRM_WORD       *f_pcbAddress
);


extern DRM_BOOL g_fOverride_OPL_Defaults;
extern DRM_WORD g_wAnalogVideo;
extern DRM_WORD g_wCompressedDigitalAudio;
extern DRM_WORD g_wCompressedDigitalVideo;
extern DRM_WORD g_wUncompressedDigitalAudio;
extern DRM_WORD g_wUncompressedDigitalVideo;
DRM_API DRM_RESULT DRM_CALL OEM_NDT_GetLicenseOPLs(
    __out_opt DRM_MINIMUM_OUTPUT_PROTECTION_LEVELS *f_MinPlayOpls,
    __out     DRM_BOOL                             *f_OplSet
);


extern DRM_BOOL  g_fOverride_InclusionList_Defaults;
extern DRM_DWORD g_cInclusionListGUIDs;
DRM_API DRM_RESULT DRM_CALL OEM_NDT_GetLicenseInclusionList(
    __inout_opt DRM_GUIDLIST *f_InclusionList,
    __out       DRM_BOOL     *f_fInclusionListSet
);


extern DRM_DWORD g_dwSourceID;
DRM_API DRM_RESULT DRM_CALL OEM_NDT_GetSourceID ( 
    __out_ecount(1)    DRM_DWORD                               *f_pdwSourceID );


extern DRM_DWORD g_dwRevInfo;
DRM_API DRM_RESULT DRM_CALL OEM_NDT_GetLicenseRevInfoVersion ( 
    __out_ecount(1)     DRM_DWORD                               *f_pdwRevInfo );


extern DRM_DWORD g_dwMinAppSec;
DRM_API DRM_RESULT DRM_CALL OEM_NDT_GetWMDRMNETMinAppSec(
    __out_ecount(1) DRM_DWORD                               *f_pdwMinAppSec );

EXIT_PK_NAMESPACE;

#endif /*  __OEMNDT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\inc\aesbox.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
** Module Name: aesbox.h
**
** Abstract:
**    This module contains the read-only table state for AES.
**
*/

#ifndef __AESBOX_H__
#define __AESBOX_H__

#include <drmcommon.h>

ENTER_PK_NAMESPACE;

/* 
** NOTE: 
** T and U tables will be accessed at DWORD boundaries, and
** therefore must be DWORD aligned.
*/

extern const DRM_BYTE S[__CB_DECL( 256 )];

extern const DRM_DWORD_ALIGN DRM_BYTE T1[256][__CB_DECL( 4 )];
extern const DRM_DWORD_ALIGN DRM_BYTE T2[256][__CB_DECL( 4 )];
extern const DRM_DWORD_ALIGN DRM_BYTE T3[256][__CB_DECL( 4 )];
extern const DRM_DWORD_ALIGN DRM_BYTE T4[256][__CB_DECL( 4 )];
extern const DRM_DWORD_ALIGN DRM_BYTE T5[256][__CB_DECL( 4 )];
extern const DRM_DWORD_ALIGN DRM_BYTE T6[256][__CB_DECL( 4 )];
extern const DRM_DWORD_ALIGN DRM_BYTE T7[256][__CB_DECL( 4 )];
extern const DRM_DWORD_ALIGN DRM_BYTE T8[256][__CB_DECL( 4 )];

extern const DRM_BYTE S5[__CB_DECL( 256 )];

extern const DRM_DWORD_ALIGN DRM_BYTE U1[256][__CB_DECL( 4 )];
extern const DRM_DWORD_ALIGN DRM_BYTE U2[256][__CB_DECL( 4 )];
extern const DRM_DWORD_ALIGN DRM_BYTE U3[256][__CB_DECL( 4 )];
extern const DRM_DWORD_ALIGN DRM_BYTE U4[256][__CB_DECL( 4 )];

extern const DRM_DWORD rcon[30];

EXIT_PK_NAMESPACE;

#endif /* __AESBOX_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\inc\aes128.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
** Module Name: aes128.h
**
** Abstract:
**    This module contains the public data structures and API definitions
**  needed to utilize the low-level AES encryption routines. 
**  
**  Routines are implemented in aes128.c
*/


#ifndef __AES128_H__
#define __AES128_H__

#include <drmaescommon.h>
#include <oemaesimpl.h>
#include <drmcommon.h>

ENTER_PK_NAMESPACE;

DRM_VOID Aes_CreateKey128(
    __out_ecount( 1 )                         DRM_AESTable *f_pKeyTable,
    __in_bcount( DRM_AES_KEYSIZE_128 )  const DRM_BYTE      f_rgbKey[__CB_DECL( DRM_AES_KEYSIZE_128 )] );

DRM_VOID Aes_Encrypt128( 
    __out_bcount( DRM_AES_KEYSIZE_128 )       DRM_BYTE   f_rgbEncrypted[__CB_DECL( DRM_AES_KEYSIZE_128 )],
    __in_bcount( DRM_AES_KEYSIZE_128 )  const DRM_BYTE   f_rgbClear[__CB_DECL( DRM_AES_KEYSIZE_128 )],
    __in_ecount( DRM_AES_ROUNDS_128+1 ) const DRM_DWORD  f_rgbKeys[DRM_AES_ROUNDS_128+1][4] );

DRM_VOID Aes_Decrypt128( 
    __out_bcount( DRM_AES_KEYSIZE_128 )       DRM_BYTE   f_rgbClear[__CB_DECL( DRM_AES_KEYSIZE_128 )],
    __in_bcount( DRM_AES_KEYSIZE_128 )  const DRM_BYTE   f_rgbEncrypted[__CB_DECL( DRM_AES_KEYSIZE_128 )],
    __in_ecount( DRM_AES_ROUNDS_128+1 ) const DRM_DWORD  f_rgbKeys[DRM_AES_ROUNDS_128+1][4] );


EXIT_PK_NAMESPACE;

#endif /* __AES128_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\inc\oemprofile.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __OEMPROFILE_H__
#define __OEMPROFILE_H__

ENTER_PK_NAMESPACE;

#if DRM_SUPPORT_PROFILING

#include <drmprofile.h>

DRM_API PERF_GLOBAL_CONTEXT * DRM_CALL Oem_Profiling_GetProfileContext(DRM_VOID); 

/**********************************************************************
** Function:    Oem_Profiling_QueryPerformanceCounter
** Synopsis:    Returns the value of a high performance counter if one 
**              exists on the system, otherwise it works like Oem_Clock_GetTickCount()
** Parameters:  None
** Returns:     A DRM_UINT64 with the value of the system's counter.
***********************************************************************/
DRM_API DRM_UINT64 DRM_CALL Oem_Profiling_QueryPerformanceCounter( DRM_VOID );

/**********************************************************************
** Function:    Oem_Profiling_QueryPerformanceFrequency
** Synopsis:    Returns the frequency of the high performance counter  
**              in clocks per second.
** Parameters:  None
** Returns:     A DRM_UINT64 representing the number of ticks per second
**              used by Oem_Profiling_QueryPerformanceCounter.
***********************************************************************/
DRM_API DRM_UINT64 DRM_CALL Oem_Profiling_QueryPerformanceFrequency( DRM_VOID );

#endif  /* DRM_SUPPORT_PROFILING */

EXIT_PK_NAMESPACE;

#endif /* __OEMPROFILE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\inc\oemrsa.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __OEMRSA_H__
#define __OEMRSA_H__

#include <drmtypes.h>
#include <oemrsaimpl.h>
#include <drmrsacommon.h>
#include <drmlicense.h> 

ENTER_PK_NAMESPACE;

#define BITS_TO_BYTES( nb ) ( ( ( nb ) + BITS_PER_STANDARD_BYTE - 1 ) / BITS_PER_STANDARD_BYTE )
#define BYTES_TO_BITS( nb ) ( ( nb ) * BITS_PER_STANDARD_BYTE )

extern DRM_EXPORT_VAR const DRM_BYTE rgbDRM_RSA_DEFAULT_PUBEXP[__CB_DECL( DRM_RSA_CB_PUBEXP )];

#define DRM_RSA_DEFAULT_PUBEXP_DWORD 65537

/*
** Sizes of internal RSA key structures:
*/
#define DRM_RSA_CB_PUBKEY   SIZEOF( INTERNAL_DRM_RSA_PUBLIC_KEY )
#define DRM_RSA_CB_PRIVKEY  SIZEOF( INTERNAL_DRM_RSA_PRIVATE_KEY )

/*
** RSA public key
**
** The actual contents of the structure are opaque.
** The opaque data is represented as a byte array below.
** Do not access the array or assume the size of this structure.
*/
typedef struct __tagDRM_RSA_PUBLIC_KEY
{
    DRM_BYTE rgbOpaque[__CB_DECL( DRM_RSA_CB_PUBKEY )];
} DRM_RSA_PUBLIC_KEY;

/*
** RSA private key
**
** The actual contents of the structure are opaque.
** The opaque data is represented as a byte array below.
** Do not access the array or assume the size of this structure.
*/
typedef struct __tagDRM_RSA_PRIVATE_KEY
{
    DRM_BYTE rgbOpaque[__CB_DECL( DRM_RSA_CB_PRIVKEY )];
} DRM_RSA_PRIVATE_KEY;

/*
** Key management functions:
*/
DRM_API DRM_RESULT DRM_CALL OEM_RSA_GetPublicKeyLength(
    __in const DRM_RSA_PUBLIC_KEY            *f_pPublicKey,
    __out      DRM_RSA_SUPPORTED_KEY_LENGTHS *f_peKeyLength
    );

DRM_API DRM_RESULT DRM_CALL OEM_RSA_GetPrivateKeyLength(
    __in const DRM_RSA_PRIVATE_KEY           *f_pPrivateKey,
    __out      DRM_RSA_SUPPORTED_KEY_LENGTHS *f_peKeyLength 
    );

DRM_API DRM_RESULT DRM_CALL OEM_RSA_GetKeyLengthFromModulusLength(
    __in const DRM_DWORD                      f_cbModulus,
    __out      DRM_RSA_SUPPORTED_KEY_LENGTHS *f_peKeyLength 
    );

DRM_API DRM_RESULT DRM_CALL OEM_RSA_ParsePublicKey(
    __in const                        DRM_RSA_PUBLIC_KEY            *f_pPublicKey,
    __out_opt                         DRM_RSA_SUPPORTED_KEY_LENGTHS *f_peKeyLength,
    __inout_opt                       DRM_DWORD                     *f_pcbPubExp,
    __out_ecount_opt( *f_pcbPubExp )  DRM_BYTE                      *f_pbPubExp,
    __inout_opt                       DRM_DWORD                     *f_pcbModulus,
    __out_ecount_opt( *f_pcbModulus ) DRM_BYTE                      *f_pbModulus
    );

DRM_RESULT DRM_CALL OEM_RSA_ParsePrivateKey(
    __in const                        DRM_RSA_PRIVATE_KEY           *f_pPrivateKey,
    __out_opt                         DRM_RSA_SUPPORTED_KEY_LENGTHS *f_peKeyLength,
    __inout_opt                       DRM_DWORD                     *f_pcbPrivExp,
    __out_ecount_opt( *f_pcbPrivExp ) DRM_BYTE                      *f_pbPrivExp,
    __inout_opt                       DRM_DWORD                     *f_pcbPrimes,
    __out_ecount_opt( *f_pcbPrimes )  DRM_BYTE                      *f_pbPrime0,
    __out_ecount_opt( *f_pcbPrimes )  DRM_BYTE                      *f_pbPrime1 
    );

DRM_API DRM_RESULT DRM_CALL OEM_RSA_SetPublicKey(
    __in const                       DRM_RSA_SUPPORTED_KEY_LENGTHS  f_eKeyLength,
    __in const                       DRM_DWORD                      f_cbPubExp,
    __in_ecount( f_cbPubExp ) const  DRM_BYTE                      *f_pbPubExp,
    __in const                       DRM_DWORD                      f_cbModulus,
    __in_ecount( f_cbModulus ) const DRM_BYTE                      *f_pbModulus,
    __out                            DRM_RSA_PUBLIC_KEY            *f_pPublicKey 
    );

DRM_API DRM_RESULT DRM_CALL OEM_RSA_SetPrivateKey(
    __in const                       DRM_RSA_SUPPORTED_KEY_LENGTHS  f_eKeyLength,
    __in const                       DRM_DWORD                      f_cbPrivExp,
    __in_ecount( f_cbPrivExp ) const DRM_BYTE                      *f_pbPrivExp,
    __in const                       DRM_DWORD                      f_cbPrimes,
    __in_ecount( f_cbPrimes ) const  DRM_BYTE                      *f_pbPrime0,
    __in_ecount( f_cbPrimes ) const  DRM_BYTE                      *f_pbPrime1,
    __out                            DRM_RSA_PRIVATE_KEY           *f_pPrivateKey,
    __inout                          DRM_CRYPTO_CONTEXT            *f_pCryptoCtx
    );

DRM_API DRM_RESULT DRM_CALL OEM_RSA_ZeroPublicKey( 
    __in       DRM_RSA_PUBLIC_KEY            *f_pPublicKey 
    );

DRM_API DRM_RESULT DRM_CALL OEM_RSA_ZeroPrivateKey( 
    __in       DRM_RSA_PRIVATE_KEY           *f_pPrivateKey 
    );

/*
** Encryption and decryption functions
*/
DRM_API DRM_RESULT DRM_CALL OEM_RSA_Encrypt(
    __in const                      DRM_RSA_PUBLIC_KEY *f_pPublicKey,
    __in const                      DRM_DWORD           f_cbDataIn,
    __in_ecount( f_cbDataIn ) const DRM_BYTE           *f_pbDataIn,
    __out_ecount( f_cbDataIn )      DRM_BYTE           *f_pbDataOut,
    __in                            DRM_CRYPTO_CONTEXT *f_pCryptoCtx 
    );

DRM_API DRM_RESULT DRM_CALL OEM_RSA_Decrypt(
    __in const                      DRM_RSA_PRIVATE_KEY *f_pPrivateKey,
    __in const                      DRM_DWORD            f_cbDataIn,
    __in_ecount( f_cbDataIn ) const DRM_BYTE            *f_pbDataIn,
    __out_ecount( f_cbDataIn )      DRM_BYTE            *f_pbDataOut,
    __in                            DRM_CRYPTO_CONTEXT  *f_pCryptoCtx 
    );

/*
** Key generation
*/
DRM_API DRM_RESULT DRM_CALL OEM_RSA_GenerateKeyPair(
    __in const DRM_RSA_SUPPORTED_KEY_LENGTHS  f_eKeyLength,
    __out      DRM_RSA_PRIVATE_KEY           *f_pPrivateKey,
    __out      DRM_RSA_PUBLIC_KEY            *f_pPublicKey,
    __inout    DRM_CRYPTO_CONTEXT            *f_pCryptoCtx 
    );

EXIT_PK_NAMESPACE;

#endif /* __OEMRSA_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\inc\oemrsaimpl.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __OEMRSAIMPL_H__
#define __OEMRSAIMPL_H__

#include <drmtypes.h>
#include <drmrsacommon.h>
#include <bigdefs.h>

ENTER_PK_NAMESPACE;

#define CBITS_PUBEXP                  ( DRM_RSA_CB_PUBEXP * BITS_PER_STANDARD_BYTE )

#define CBITS_PRIVEXP( keyLength )    ( DRM_RSA_CB_PRIVEXP( keyLength ) * BITS_PER_STANDARD_BYTE )
#define CBITS_PRIVEXP_MAX               CBITS_PRIVEXP( eDRM_RSA_MAXIMUM_KEY_LENGTH )

#define CDIGITS_MODULUS( keyLength )    BITS_TO_DIGITS( DRM_RSA_CBITS_MODULUS( keyLength ) )
#define CDIGITS_MODULUS_MAX             CDIGITS_MODULUS( eDRM_RSA_MAXIMUM_KEY_LENGTH )

#define CDIGITS_PUBEXP                  BITS_TO_DIGITS( CBITS_PUBEXP )

#define CDIGITS_PRIVEXP( keyLength )    BITS_TO_DIGITS( CBITS_PRIVEXP( keyLength ) )
#define CDIGITS_PRIVEXP_MAX             CDIGITS_PRIVEXP( eDRM_RSA_MAXIMUM_KEY_LENGTH )

/*
** Internal representation of public and private key structures
*/

/*
** In the following structures, a digit_t array represents a single big number,
** stored in big-endian format.  In other words, the most significant digit is 
** lowest in contiguous memory.  Since the digit_t itself is a multi-octet value, 
** please note that it is also stored in big-endian form; the most significant
** octet of a given digit_t instance is lowest in contiguous memory.
**
** Thus, a "big-endian" digit array is a sequence of digit_t's stored in 
** big-endian order, with the individual octets of each digit_t also stored
** in big-endian order.
*/

/*
** Public key: Contains only the modulus and exponent
*/
typedef struct __tagINTERNAL_DRM_RSA_PUBLIC_KEY
{       
    DRM_RSA_SUPPORTED_KEY_LENGTHS eKeyLength;                               /* key length in bits. */
    DRM_DWORD                     cdModulus;                                /* count of digits in the public modulus. */
    digit_t                       rgdPubExp[CDIGITS_PUBEXP];                /* public exponent; stored as big-endian digits. */
    digit_t                       rgdModulus[CDIGITS_MODULUS_MAX];          /* public modulus; stored as big-endian digits. */
} INTERNAL_DRM_RSA_PUBLIC_KEY;

/*
** Private key: Contains the primes, exponent, and chinese remainder theorem residuals
*/
typedef struct __tagINTERNAL_DRM_RSA_PRIVATE_KEY
{   
    DRM_RSA_SUPPORTED_KEY_LENGTHS eKeyLength;                               /* key length in bits. */
    DRM_DWORD                     cdPrimes[2];                              /* count of digits in each prime. */
    digit_t                       rgdPrimes[2][CDIGITS_MODULUS_MAX];        /* larger prime (p) stored first; stored as big-endian digits. */
    digit_t                       rgdCRTExponents[2][CDIGITS_MODULUS_MAX];  /* chinese remainder theorem exponents; stored as big-endian digits. */     
    digit_t                       rgdIQMP[CDIGITS_MODULUS_MAX];             /* stored as big-endian digits. */
} INTERNAL_DRM_RSA_PRIVATE_KEY;

EXIT_PK_NAMESPACE;

#endif /* __OEMRSAIMPL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\inc\oem_msdbpk.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
**  File oem_msdbpk.h - declarations for OEM functions required for MSDB PK.
**  These OEM functions are called by MSDB PK internally and should be implemented 
**  in order to link the project.
**  There is an example implementation of these functions in file oemcfdimpl.c
*/

#ifndef __OEM_MSDB_PK_H__
#define __OEM_MSDB_PK_H__

#include <drmkeygenerator.h>



/* The size of a Content Key Seed in raw (30 bytes), not B64 encoded (40 bytes), form. */
#define CKSEED_NOT_B64_ENCODED_LEN  30

ENTER_PK_NAMESPACE;

DRM_API DRM_RESULT DRM_CALL OEM_GetCRL(
   IN     DRM_GUID   f_guidCRL,      
   OUT    DRM_BYTE  *f_pbCRLData,    
   IN OUT DRM_DWORD *f_pcbCRLData    
);

DRM_API DRM_RESULT DRM_CALL OEM_SetCRL
(
   IN       DRM_GUID        f_guidCRL,  
   IN const DRM_BYTE       *f_pbCRLData,
   IN       DRM_DWORD       f_cbCRLData
);

DRM_API DRM_RESULT DRM_CALL OEM_GetContentKeySeed
(
      OUT  DRM_WCHAR        f_wszKeySeed[DRM_KEYSEED_BASE64_LEN]
);

DRM_API DRM_RESULT DRM_CALL OEM_GetLicenseServerPrivateKey
(
    OUT PRIVKEY   *f_pLSPrivateKey
);

DRM_API DRM_RESULT DRM_CALL OEM_GetLicenseCertificates
(
       OUT DRM_BYTE  *f_pbCertificate2,
    IN     DRM_DWORD  f_cbC2Size,
       OUT DRM_BYTE  *f_pbCertificate1,
    IN     DRM_DWORD  f_cbC1Size
);

EXIT_PK_NAMESPACE;

#endif /* __OEM_MSDB_PK_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\lib\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\inc\oemplatform.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __OEMPLATFORM_H__
#define __OEMPLATFORM_H__

ENTER_PK_NAMESPACE;

/* OEM critical sectiion function. */
#if defined(_WIN64)
#define OEM_CRITICAL_SECTION_SIZE     40
#else
#define OEM_CRITICAL_SECTION_SIZE     24
#endif

typedef struct __tagOEM_CRITICAL_SECTION
{
    DRM_BYTE rgb[__CB_DECL(OEM_CRITICAL_SECTION_SIZE)];
} OEM_CRITICAL_SECTION;

/**********************************************************************
** Function:    Oem_CritSec_Initialize
** Synopsis:    Initializes critical section. 
** Arguments:   [f_pCS]--Pointer to OEM_CRITICAL_SECTION structure to be
**              initialized.
***********************************************************************/
DRM_API DRM_VOID DRM_CALL Oem_CritSec_Initialize(
    __inout OEM_CRITICAL_SECTION *f_pCS );

/**********************************************************************
** Function:    Oem_CritSec_Delete
** Synopsis:    Deletes existing critical section. 
** Arguments:   [f_pCS]--Pointer to OEM_CRITICAL_SECTION structure to be
**              deleted.
***********************************************************************/
DRM_API DRM_VOID DRM_CALL Oem_CritSec_Delete(
    __inout OEM_CRITICAL_SECTION *f_pCS );

/**********************************************************************
** Function:    Oem_CritSec_Enter
** Synopsis:    Enters critical section. 
** Arguments:   [f_pCS]--Pointer to OEM_CRITICAL_SECTION structure to be
**              entered.
***********************************************************************/
DRM_API DRM_VOID DRM_CALL Oem_CritSec_Enter(
    __inout OEM_CRITICAL_SECTION *f_pCS );

/**********************************************************************
** Function:    Oem_CritSec_Leave
** Synopsis:    Leaves critical section. 
** Arguments:   [f_pCS]--Pointer to OEM_CRITICAL_SECTION structure to be
**              left.
***********************************************************************/
DRM_API DRM_VOID DRM_CALL Oem_CritSec_Leave(
    __inout OEM_CRITICAL_SECTION *f_pCS );

EXIT_PK_NAMESPACE;

#endif  /* __OEMPLATFORM_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\lib\aes128.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
** Module Name: aes128.c
**
** Abstract:
**    This module contains the low-level AES encryption routines
**    for 128-bit AES
**    Derived from public domain sources 
*/

#include "aes128.h"
#include "aesbox.h"

ENTER_PK_NAMESPACE_CODE;

/*********************************************************************************************
** Function:  Aes_CreateKey128
**
** Synopsis:  Set up an AES Key Table for a 128-bit AES key
**
** Arguments: [f_pKeyTable ]: The key table to set up ( output )
**            [f_rgbKey]    : The key data
**
** Returns:   None
**********************************************************************************************/
DRM_NO_INLINE DRM_VOID Aes_CreateKey128(
    __out_ecount( 1 )                        DRM_AESTable *f_pKeyTable,
    __in_bcount( DRM_AES_KEYSIZE_128 ) const DRM_BYTE      f_rgbKey[__CB_DECL( DRM_AES_KEYSIZE_128 )] )
{   
    /*
    ** Calculate the necessary round keys
    ** The number of calculations depends on keyBits and blockBits
    */
    DRM_DWORD  j           = 0; 
    DRM_DWORD  r           = 0; 
    DRM_DWORD  t           = 0;     
    DRM_DWORD  rconpointer = 0;    
    DRM_BYTE   bTmp        = 0;
    DRM_DWORD *w           = NULL;
    DRM_DWORD  tk[DRM_AES_ROUNDS_128 - 6] = { 0 };
    const DRM_DWORD  KC    = DRM_AES_ROUNDS_128 - 6;

    /*
    ** These assertions check that DWORD access of T and U arrays is valid
    */
    DRMASSERT( IS_DWORD_ALIGNED( T1[0] ) );
    DRMASSERT( IS_DWORD_ALIGNED( T2[0] ) );
    DRMASSERT( IS_DWORD_ALIGNED( T3[0] ) );
    DRMASSERT( IS_DWORD_ALIGNED( T4[0] ) );
    DRMASSERT( IS_DWORD_ALIGNED( T5[0] ) );
    DRMASSERT( IS_DWORD_ALIGNED( T6[0] ) );
    DRMASSERT( IS_DWORD_ALIGNED( T7[0] ) );
    DRMASSERT( IS_DWORD_ALIGNED( T8[0] ) );
    DRMASSERT( IS_DWORD_ALIGNED( U1[0] ) );
    DRMASSERT( IS_DWORD_ALIGNED( U2[0] ) );
    DRMASSERT( IS_DWORD_ALIGNED( U3[0] ) );
    DRMASSERT( IS_DWORD_ALIGNED( U4[0] ) );


    /*
    ** Compute keytabenc
    */

    for( j = KC; j > 0; j-- )
    {
        MEMCPY( ( DRM_BYTE * )&tk[j-1], &f_rgbKey[4 * ( j - 1 )], SIZEOF( DRM_DWORD ) );
    }

    /*
    ** copy values into round key array 
    */
    for( j = 0; ( j < KC ) && ( r < DRM_AES_ROUNDS_128 + 1 ); ) 
    {
        for ( ; ( j < KC ) && ( t < 4 ); j++, t++ ) 
        {
            f_pKeyTable->keytabenc[r][t] = tk[j];
        }
        if ( t == 4 )
        {
            r++;
            t = 0;
        }
    }
    /*
    ** while not enough round key material calculated
    ** calculate new values 
    */
    while ( r < DRM_AES_ROUNDS_128 + 1 ) 
    { 
        bTmp =  GET_BYTE( ( DRM_BYTE * )( tk + ( KC-1 ) ), 1 );
        bTmp =  GET_BYTE( S, bTmp );
        bTmp ^= GET_BYTE( ( DRM_BYTE * )( tk ), 0 );
        PUT_BYTE( ( DRM_BYTE * )( tk ), 0, bTmp );

        bTmp =  GET_BYTE( ( DRM_BYTE * )( tk + ( KC-1 ) ), 2 );
        bTmp =  GET_BYTE( S, bTmp );
        bTmp ^= GET_BYTE( ( DRM_BYTE * )( tk ), 1 );
        PUT_BYTE( ( DRM_BYTE * )( tk ), 1, bTmp );

        bTmp =  GET_BYTE( ( DRM_BYTE * )( tk + ( KC-1 ) ), 3 );
        bTmp =  GET_BYTE( S, bTmp );
        bTmp ^= GET_BYTE( ( DRM_BYTE * )( tk ), 2 );
        PUT_BYTE( ( DRM_BYTE * )( tk ), 2, bTmp );

        bTmp =  GET_BYTE( ( DRM_BYTE * )( tk + ( KC-1 ) ), 0 );
        bTmp =  GET_BYTE( S, bTmp );
        bTmp ^= GET_BYTE( ( DRM_BYTE * )( tk ), 3 );
        PUT_BYTE( ( DRM_BYTE * )( tk ), 3, bTmp );

        bTmp =  ( DRM_BYTE ) rcon[rconpointer++];
        bTmp ^= GET_BYTE( ( DRM_BYTE * )( tk ), 0 );
        PUT_BYTE( ( DRM_BYTE * )( tk ), 0, bTmp );

        for ( j = 1; j < KC; j++ ) 
        {
            tk[j] ^= tk[j-1];
        }
        
        /*
        ** Copy values into round key array 
        */
        for ( j = 0; ( j < KC ) && ( r < DRM_AES_ROUNDS_128 + 1 ); ) 
        {
            for ( ; ( j < KC ) && ( t < 4 ); j++, t++ ) 
            {
                f_pKeyTable->keytabenc[r][t] = tk[j];
            }
            if ( t == 4 ) 
            {
                r++;
                t = 0;
            }
        }
    }

    MEMCPY( ( DRM_BYTE * )( f_pKeyTable->keytabdec[0] ), 
            ( DRM_BYTE * )( f_pKeyTable->keytabenc[0] ),
            SIZEOF( f_pKeyTable->keytabenc ) );

    /*
    ** Compute keytabdec
    */
    for ( r = 1; r < DRM_AES_ROUNDS_128; r++ ) 
    {
        w = &f_pKeyTable->keytabdec[r][0];
        *w =
              *( ( DRM_DWORD* )U1[GET_BYTE( ( DRM_BYTE * )w, 0 )] )
            ^ *( ( DRM_DWORD* )U2[GET_BYTE( ( DRM_BYTE * )w, 1 )] )
            ^ *( ( DRM_DWORD* )U3[GET_BYTE( ( DRM_BYTE * )w, 2 )] )
            ^ *( ( DRM_DWORD* )U4[GET_BYTE( ( DRM_BYTE * )w, 3 )] );

        w = &f_pKeyTable->keytabdec[r][1];
        *w =
              *( ( DRM_DWORD* )U1[GET_BYTE( ( DRM_BYTE * )w, 0 )] )
            ^ *( ( DRM_DWORD* )U2[GET_BYTE( ( DRM_BYTE * )w, 1 )] )
            ^ *( ( DRM_DWORD* )U3[GET_BYTE( ( DRM_BYTE * )w, 2 )] )
            ^ *( ( DRM_DWORD* )U4[GET_BYTE( ( DRM_BYTE * )w, 3 )] );

        w = &f_pKeyTable->keytabdec[r][2];
        *w =
              *( ( DRM_DWORD* )U1[GET_BYTE( ( DRM_BYTE * )w, 0 )] )
            ^ *( ( DRM_DWORD* )U2[GET_BYTE( ( DRM_BYTE * )w, 1 )] )
            ^ *( ( DRM_DWORD* )U3[GET_BYTE( ( DRM_BYTE * )w, 2 )] )
            ^ *( ( DRM_DWORD* )U4[GET_BYTE( ( DRM_BYTE * )w, 3 )] );

        w = &f_pKeyTable->keytabdec[r][3];
        *w =
              *( ( DRM_DWORD* )U1[GET_BYTE( ( DRM_BYTE * )w, 0 )] )
            ^ *( ( DRM_DWORD* )U2[GET_BYTE( ( DRM_BYTE * )w, 1 )] )
            ^ *( ( DRM_DWORD* )U3[GET_BYTE( ( DRM_BYTE * )w, 2 )] )
            ^ *( ( DRM_DWORD* )U4[GET_BYTE( ( DRM_BYTE * )w, 3 )] );
    }   
}


/*********************************************************************************************
** Function:  Aes_Encrypt128
**
** Synopsis:  Encrypt a single block
**
** Arguments: 
**            [f_rgbEncrypted] : Returns the encrypted data
**            [f_rgbClear]     : Specifies the data to encrypt
**            [f_rgbKeys]      : The key table to use for decryption
**
** Returns:   None
**********************************************************************************************/
DRM_NO_INLINE DRM_VOID Aes_Encrypt128( 
    __out_bcount( DRM_AES_KEYSIZE_128 )       DRM_BYTE   f_rgbEncrypted[__CB_DECL( DRM_AES_KEYSIZE_128 )],
    __in_bcount( DRM_AES_KEYSIZE_128 )  const DRM_BYTE   f_rgbClear[__CB_DECL( DRM_AES_KEYSIZE_128 )],
    __in_ecount( DRM_AES_ROUNDS_128+1 ) const DRM_DWORD  f_rgbKeys[DRM_AES_ROUNDS_128+1][4] )
{
    DRM_DWORD r       = 0;
    DRM_DWORD c[4]    = { 0 };
    DRM_BYTE *d       = ( DRM_BYTE * )c;
    DRM_DWORD temp[4] = { 0 };
    DRM_BYTE  bTmp    = 0;

    MEMCPY( ( DRM_BYTE * )temp, f_rgbClear, DRM_AES_KEYSIZE_128 );

    temp[0] ^= f_rgbKeys[0][0];
    temp[1] ^= f_rgbKeys[0][1];
    temp[2] ^= f_rgbKeys[0][2];
    temp[3] ^= f_rgbKeys[0][3];
    
    c[0] = *( ( DRM_DWORD* )T1[GET_BYTE( ( ( DRM_BYTE * )temp ), 0 )] )
         ^ *( ( DRM_DWORD* )T2[GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 1 )] )
         ^ *( ( DRM_DWORD* )T3[GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 2 )] )
         ^ *( ( DRM_DWORD* )T4[GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 3 )] );

    c[1] = *( ( DRM_DWORD* )T1[GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 0 )] )
         ^ *( ( DRM_DWORD* )T2[GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 1 )] )
         ^ *( ( DRM_DWORD* )T3[GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 2 )] )
         ^ *( ( DRM_DWORD* )T4[GET_BYTE( ( ( DRM_BYTE * )temp ), 3 )] );

    c[2] = *( ( DRM_DWORD* )T1[GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 0 )] )
         ^ *( ( DRM_DWORD* )T2[GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 1 )] )
         ^ *( ( DRM_DWORD* )T3[GET_BYTE( ( ( DRM_BYTE * )temp ), 2 )] )
         ^ *( ( DRM_DWORD* )T4[GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 3 )] );

    c[3] = *( ( DRM_DWORD* )T1[GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 0 )] )
         ^ *( ( DRM_DWORD* )T2[GET_BYTE( ( ( DRM_BYTE * )temp ), 1 )] )
         ^ *( ( DRM_DWORD* )T3[GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 2 )] )
         ^ *( ( DRM_DWORD* )T4[GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 3 )] );

    for ( r = 1; r < DRM_AES_ROUNDS_128 - 1; r++ )
    {
        temp[0] = c[0] ^ f_rgbKeys[r][0];
        temp[1] = c[1] ^ f_rgbKeys[r][1];
        temp[2] = c[2] ^ f_rgbKeys[r][2];
        temp[3] = c[3] ^ f_rgbKeys[r][3];

        c[0] = *( ( DRM_DWORD* )T1[GET_BYTE( ( ( DRM_BYTE * )temp ), 0 )] )
             ^ *( ( DRM_DWORD* )T2[GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 1 )] )
             ^ *( ( DRM_DWORD* )T3[GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 2 )] )
             ^ *( ( DRM_DWORD* )T4[GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 3 )] );

        c[1] = *( ( DRM_DWORD* )T1[GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 0 )] )
             ^ *( ( DRM_DWORD* )T2[GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 1 )] )
             ^ *( ( DRM_DWORD* )T3[GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 2 )] )
             ^ *( ( DRM_DWORD* )T4[GET_BYTE( ( ( DRM_BYTE * )temp ), 3 )] );

        c[2] = *( ( DRM_DWORD* )T1[GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 0 )] )
             ^ *( ( DRM_DWORD* )T2[GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 1 )] )
             ^ *( ( DRM_DWORD* )T3[GET_BYTE( ( ( DRM_BYTE * )temp ), 2 )] )
             ^ *( ( DRM_DWORD* )T4[GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 3 )] );

        c[3] = *( ( DRM_DWORD* )T1[GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 0 )] )
             ^ *( ( DRM_DWORD* )T2[GET_BYTE( ( ( DRM_BYTE * )temp ), 1 )] )
             ^ *( ( DRM_DWORD* )T3[GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 2 )] )
             ^ *( ( DRM_DWORD* )T4[GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 3 )] );
    }

    /*
    ** last round is special 
    */
    temp[0] = c[0] ^ f_rgbKeys[DRM_AES_ROUNDS_128-1][0];
    temp[1] = c[1] ^ f_rgbKeys[DRM_AES_ROUNDS_128-1][1];
    temp[2] = c[2] ^ f_rgbKeys[DRM_AES_ROUNDS_128-1][2];
    temp[3] = c[3] ^ f_rgbKeys[DRM_AES_ROUNDS_128-1][3];

    bTmp = GET_BYTE( ( ( DRM_BYTE * )temp ), 0 );
    bTmp = GET_BYTE( T1[bTmp], 1 );
    PUT_BYTE( d, 0, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 1 );
    bTmp = GET_BYTE( T1[bTmp], 1 );
    PUT_BYTE( d, 1, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 2 );
    bTmp = GET_BYTE( T1[bTmp], 1 );
    PUT_BYTE( d, 2, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 3 );
    bTmp = GET_BYTE( T1[bTmp], 1 );
    PUT_BYTE( d, 3, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 0 );
    bTmp = GET_BYTE( T1[bTmp], 1 );
    PUT_BYTE( d, 4, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 1 );
    bTmp = GET_BYTE( T1[bTmp], 1 );
    PUT_BYTE( d, 5, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 2 );
    bTmp = GET_BYTE( T1[bTmp], 1 );
    PUT_BYTE( d, 6, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )temp ), 3 );
    bTmp = GET_BYTE( T1[bTmp], 1 );
    PUT_BYTE( d, 7, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 0 );
    bTmp = GET_BYTE( T1[bTmp], 1 );
    PUT_BYTE( d, 8, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 1 );
    bTmp = GET_BYTE( T1[bTmp], 1 );
    PUT_BYTE( d, 9, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )temp ), 2 );
    bTmp = GET_BYTE( T1[bTmp], 1 );
    PUT_BYTE( d, 10, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 3 );
    bTmp = GET_BYTE( T1[bTmp], 1 );
    PUT_BYTE( d, 11, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 0 );
    bTmp = GET_BYTE( T1[bTmp], 1 );
    PUT_BYTE( d, 12, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )temp ), 1 );
    bTmp = GET_BYTE( T1[bTmp], 1 );
    PUT_BYTE( d, 13, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 2 );
    bTmp = GET_BYTE( T1[bTmp], 1 );
    PUT_BYTE( d, 14, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 3 );
    bTmp = GET_BYTE( T1[bTmp], 1 );
    PUT_BYTE( d, 15, bTmp );

    c[0] ^= f_rgbKeys[DRM_AES_ROUNDS_128][0];
    c[1] ^= f_rgbKeys[DRM_AES_ROUNDS_128][1];
    c[2] ^= f_rgbKeys[DRM_AES_ROUNDS_128][2];
    c[3] ^= f_rgbKeys[DRM_AES_ROUNDS_128][3];
    MEMCPY( f_rgbEncrypted, c, SIZEOF( c ) );

    return;    
}

/*********************************************************************************************
** Function:  Aes_Decrypt128
**
** Synopsis:  Decrypt a single block
**
** Arguments: 
**            [f_rgbClear]     : Returns the decrypted data
**            [f_rgbEncrypted] : Specifies the data to decrypt
**            [f_rgbKeys]      : The table to use for encryption
**
** Returns:   None
**********************************************************************************************/
DRM_NO_INLINE DRM_VOID Aes_Decrypt128( 
    __out_bcount( DRM_AES_KEYSIZE_128 )       DRM_BYTE   f_rgbClear[__CB_DECL( DRM_AES_KEYSIZE_128 )],
    __in_bcount( DRM_AES_KEYSIZE_128 )  const DRM_BYTE   f_rgbEncrypted[__CB_DECL( DRM_AES_KEYSIZE_128 )],
    __in_ecount( DRM_AES_ROUNDS_128+1 ) const DRM_DWORD  f_rgbKeys[DRM_AES_ROUNDS_128+1][4] )
{
    DRM_DWORD r       = 0;
    DRM_DWORD temp[4] = { 0 };
    DRM_DWORD c[4]    = { 0 };
    DRM_BYTE  bTmp    = 0;

    MEMCPY( ( DRM_BYTE * )temp, f_rgbEncrypted, DRM_AES_KEYSIZE_128 );
    temp[0] ^= f_rgbKeys[DRM_AES_ROUNDS_128][0];
    temp[1] ^= f_rgbKeys[DRM_AES_ROUNDS_128][1];
    temp[2] ^= f_rgbKeys[DRM_AES_ROUNDS_128][2];
    temp[3] ^= f_rgbKeys[DRM_AES_ROUNDS_128][3];

    c[0] =  *( ( DRM_DWORD* )T5[GET_BYTE( ( ( DRM_BYTE * )temp ), 0 )] )
          ^ *( ( DRM_DWORD* )T6[GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 1 )] )
          ^ *( ( DRM_DWORD* )T7[GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 2 )] )
          ^ *( ( DRM_DWORD* )T8[GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 3 )] );
    c[1] = *( ( DRM_DWORD* )T5[GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 0 )] )
         ^ *( ( DRM_DWORD* )T6[GET_BYTE( ( ( DRM_BYTE * )temp ), 1 )] )
         ^ *( ( DRM_DWORD* )T7[GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 2 )] )
         ^ *( ( DRM_DWORD* )T8[GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 3 )] );
    c[2] = *( ( DRM_DWORD* )T5[GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 0 )] )
         ^ *( ( DRM_DWORD* )T6[GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 1 )] )
         ^ *( ( DRM_DWORD* )T7[GET_BYTE( ( ( DRM_BYTE * )temp ), 2 )] )
         ^ *( ( DRM_DWORD* )T8[GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 3 )] );
    c[3] = *( ( DRM_DWORD* )T5[GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 0 )] )
         ^ *( ( DRM_DWORD* )T6[GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 1 )] )
         ^ *( ( DRM_DWORD* )T7[GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 2 )] )
         ^ *( ( DRM_DWORD* )T8[GET_BYTE( ( ( DRM_BYTE * )temp ), 3 )] );

    for ( r = DRM_AES_ROUNDS_128 - 1; r > 1; r-- ) 
    {
        temp[0] = c[0] ^ f_rgbKeys[r][0];
        temp[1] = c[1] ^ f_rgbKeys[r][1];
        temp[2] = c[2] ^ f_rgbKeys[r][2];
        temp[3] = c[3] ^ f_rgbKeys[r][3];

        c[0] = *( ( DRM_DWORD* )T5[GET_BYTE( ( ( DRM_BYTE * )temp ), 0 )] )
             ^ *( ( DRM_DWORD* )T6[GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 1 )] )
             ^ *( ( DRM_DWORD* )T7[GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 2 )] )
             ^ *( ( DRM_DWORD* )T8[GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 3 )] );

        c[1] = *( ( DRM_DWORD* )T5[GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 0 )] )
             ^ *( ( DRM_DWORD* )T6[GET_BYTE( ( ( DRM_BYTE * )temp ), 1 )] )
             ^ *( ( DRM_DWORD* )T7[GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 2 )] )
             ^ *( ( DRM_DWORD* )T8[GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 3 )] );

        c[2] = *( ( DRM_DWORD* )T5[GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 0 )] )
             ^ *( ( DRM_DWORD* )T6[GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 1 )] )
             ^ *( ( DRM_DWORD* )T7[GET_BYTE( ( ( DRM_BYTE * )temp ), 2 )] )
             ^ *( ( DRM_DWORD* )T8[GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 3 )] );

        c[3] = *( ( DRM_DWORD* )T5[GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 0 )] )
             ^ *( ( DRM_DWORD* )T6[GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 1 )] )
             ^ *( ( DRM_DWORD* )T7[GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 2 )] )
             ^ *( ( DRM_DWORD* )T8[GET_BYTE( ( ( DRM_BYTE * )temp ), 3 )] );
    }

    /*
    ** last round is special 
    */
    MEMCPY( ( DRM_BYTE * )temp, ( DRM_BYTE * )c, DRM_AES_KEYSIZE_128 );
    temp[0] ^= f_rgbKeys[1][0];
    temp[1] ^= f_rgbKeys[1][1];
    temp[2] ^= f_rgbKeys[1][2];
    temp[3] ^= f_rgbKeys[1][3];

    bTmp = GET_BYTE( ( ( DRM_BYTE * )temp ), 0 );
    bTmp = GET_BYTE( S5, bTmp );
    PUT_BYTE( ( DRM_BYTE * )c, 0, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 1 );
    bTmp = GET_BYTE( S5, bTmp );
    PUT_BYTE( ( DRM_BYTE * )c, 1, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 2 );
    bTmp = GET_BYTE( S5, bTmp );
    PUT_BYTE( ( DRM_BYTE * )c, 2, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 3 );
    bTmp = GET_BYTE( S5, bTmp );
    PUT_BYTE( ( DRM_BYTE * )c, 3, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 0 );
    bTmp = GET_BYTE( S5, bTmp );
    PUT_BYTE( ( DRM_BYTE * )c, 4, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )temp ), 1 );
    bTmp = GET_BYTE( S5, bTmp );
    PUT_BYTE( ( DRM_BYTE * )c, 5, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 2 );
    bTmp = GET_BYTE( S5, bTmp );
    PUT_BYTE( ( DRM_BYTE * )c, 6, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 3 );
    bTmp = GET_BYTE( S5, bTmp );
    PUT_BYTE( ( DRM_BYTE * )c, 7, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 0 );
    bTmp = GET_BYTE( S5, bTmp );
    PUT_BYTE( ( DRM_BYTE * )c, 8, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 1 );
    bTmp = GET_BYTE( S5, bTmp );
    PUT_BYTE( ( DRM_BYTE * )c, 9, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )temp ), 2 );
    bTmp = GET_BYTE( S5, bTmp );
    PUT_BYTE( ( DRM_BYTE * )c, 10, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 3 );
    bTmp = GET_BYTE( S5, bTmp );
    PUT_BYTE( ( DRM_BYTE * )c, 11, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 3 ) ), 0 );
    bTmp = GET_BYTE( S5, bTmp );
    PUT_BYTE( ( DRM_BYTE * )c, 12, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 2 ) ), 1 );
    bTmp = GET_BYTE( S5, bTmp );
    PUT_BYTE( ( DRM_BYTE * )c, 13, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )( temp + 1 ) ), 2 );
    bTmp = GET_BYTE( S5, bTmp );
    PUT_BYTE( ( DRM_BYTE * )c, 14, bTmp );

    bTmp = GET_BYTE( ( ( DRM_BYTE * )temp ), 3 );
    bTmp = GET_BYTE( S5, bTmp );
    PUT_BYTE( ( DRM_BYTE * )c, 15, bTmp );

    c[0] ^= f_rgbKeys[0][0];
    c[1] ^= f_rgbKeys[0][1];
    c[2] ^= f_rgbKeys[0][2];
    c[3] ^= f_rgbKeys[0][3];

    MEMCPY( f_rgbClear, ( DRM_BYTE * )c, DRM_AES_KEYSIZE_128 );

    return;
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\lib\aesbox.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
** Module Name: aesbox.h
**
** Abstract:
**    This module contains the read-only table state for AES.
*/

#include "aesbox.h"

ENTER_PK_NAMESPACE_CODE;

#ifdef KMODE_RSA32
#pragma const_seg( "PAGER32R" )
#endif

/* 
** NOTE: 
** T and U tables will be accessed at DWORD boundaries, and
** therefore must be DWORD aligned.
*/

const DRM_BYTE S[__CB_DECL( 256 )] = 
{
TWO_BYTES(  99, 124 ), TWO_BYTES( 119, 123 ), TWO_BYTES( 242, 107 ), TWO_BYTES( 111, 197 ), 
TWO_BYTES(  48,   1 ), TWO_BYTES( 103,  43 ), TWO_BYTES( 254, 215 ), TWO_BYTES( 171, 118 ), 
TWO_BYTES( 202, 130 ), TWO_BYTES( 201, 125 ), TWO_BYTES( 250,  89 ), TWO_BYTES(  71, 240 ), 
TWO_BYTES( 173, 212 ), TWO_BYTES( 162, 175 ), TWO_BYTES( 156, 164 ), TWO_BYTES( 114, 192 ), 
TWO_BYTES( 183, 253 ), TWO_BYTES( 147,  38 ), TWO_BYTES(  54,  63 ), TWO_BYTES( 247, 204 ), 
TWO_BYTES(  52, 165 ), TWO_BYTES( 229, 241 ), TWO_BYTES( 113, 216 ), TWO_BYTES(  49,  21 ), 
TWO_BYTES(   4, 199 ), TWO_BYTES(  35, 195 ), TWO_BYTES(  24, 150 ), TWO_BYTES(   5, 154 ), 
TWO_BYTES(   7,  18 ), TWO_BYTES( 128, 226 ), TWO_BYTES( 235,  39 ), TWO_BYTES( 178, 117 ), 
TWO_BYTES(   9, 131 ), TWO_BYTES(  44,  26 ), TWO_BYTES(  27, 110 ), TWO_BYTES(  90, 160 ), 
TWO_BYTES(  82,  59 ), TWO_BYTES( 214, 179 ), TWO_BYTES(  41, 227 ), TWO_BYTES(  47, 132 ), 
TWO_BYTES(  83, 209 ), TWO_BYTES(   0, 237 ), TWO_BYTES(  32, 252 ), TWO_BYTES( 177,  91 ), 
TWO_BYTES( 106, 203 ), TWO_BYTES( 190,  57 ), TWO_BYTES(  74,  76 ), TWO_BYTES(  88, 207 ), 
TWO_BYTES( 208, 239 ), TWO_BYTES( 170, 251 ), TWO_BYTES(  67,  77 ), TWO_BYTES(  51, 133 ), 
TWO_BYTES(  69, 249 ), TWO_BYTES(   2, 127 ), TWO_BYTES(  80,  60 ), TWO_BYTES( 159, 168 ), 
TWO_BYTES(  81, 163 ), TWO_BYTES(  64, 143 ), TWO_BYTES( 146, 157 ), TWO_BYTES(  56, 245 ), 
TWO_BYTES( 188, 182 ), TWO_BYTES( 218,  33 ), TWO_BYTES(  16, 255 ), TWO_BYTES( 243, 210 ), 
TWO_BYTES( 205,  12 ), TWO_BYTES(  19, 236 ), TWO_BYTES(  95, 151 ), TWO_BYTES(  68,  23 ), 
TWO_BYTES( 196, 167 ), TWO_BYTES( 126,  61 ), TWO_BYTES( 100,  93 ), TWO_BYTES(  25, 115 ), 
TWO_BYTES(  96, 129 ), TWO_BYTES(  79, 220 ), TWO_BYTES(  34,  42 ), TWO_BYTES( 144, 136 ), 
TWO_BYTES(  70, 238 ), TWO_BYTES( 184,  20 ), TWO_BYTES( 222,  94 ), TWO_BYTES(  11, 219 ), 
TWO_BYTES( 224,  50 ), TWO_BYTES(  58,  10 ), TWO_BYTES(  73,   6 ), TWO_BYTES(  36,  92 ), 
TWO_BYTES( 194, 211 ), TWO_BYTES( 172,  98 ), TWO_BYTES( 145, 149 ), TWO_BYTES( 228, 121 ), 
TWO_BYTES( 231, 200 ), TWO_BYTES(  55, 109 ), TWO_BYTES( 141, 213 ), TWO_BYTES(  78, 169 ), 
TWO_BYTES( 108,  86 ), TWO_BYTES( 244, 234 ), TWO_BYTES( 101, 122 ), TWO_BYTES( 174,   8 ), 
TWO_BYTES( 186, 120 ), TWO_BYTES(  37,  46 ), TWO_BYTES(  28, 166 ), TWO_BYTES( 180, 198 ), 
TWO_BYTES( 232, 221 ), TWO_BYTES( 116,  31 ), TWO_BYTES(  75, 189 ), TWO_BYTES( 139, 138 ), 
TWO_BYTES( 112,  62 ), TWO_BYTES( 181, 102 ), TWO_BYTES(  72,   3 ), TWO_BYTES( 246,  14 ), 
TWO_BYTES(  97,  53 ), TWO_BYTES(  87, 185 ), TWO_BYTES( 134, 193 ), TWO_BYTES(  29, 158 ), 
TWO_BYTES( 225, 248 ), TWO_BYTES( 152,  17 ), TWO_BYTES( 105, 217 ), TWO_BYTES( 142, 148 ), 
TWO_BYTES( 155,  30 ), TWO_BYTES( 135, 233 ), TWO_BYTES( 206,  85 ), TWO_BYTES(  40, 223 ), 
TWO_BYTES( 140, 161 ), TWO_BYTES( 137,  13 ), TWO_BYTES( 191, 230 ), TWO_BYTES(  66, 104 ), 
TWO_BYTES(  65, 153 ), TWO_BYTES(  45,  15 ), TWO_BYTES( 176,  84 ), TWO_BYTES( 187,  22 )  
};


const DRM_DWORD_ALIGN DRM_BYTE T1[256][__CB_DECL( 4 )] = 
{
TWO_BYTES( 0xc6, 0x63 ), TWO_BYTES( 0x63, 0xa5 ), TWO_BYTES( 0xf8, 0x7c ), TWO_BYTES( 0x7c, 0x84 ),
TWO_BYTES( 0xee, 0x77 ), TWO_BYTES( 0x77, 0x99 ), TWO_BYTES( 0xf6, 0x7b ), TWO_BYTES( 0x7b, 0x8d ),
TWO_BYTES( 0xff, 0xf2 ), TWO_BYTES( 0xf2, 0x0d ), TWO_BYTES( 0xd6, 0x6b ), TWO_BYTES( 0x6b, 0xbd ),
TWO_BYTES( 0xde, 0x6f ), TWO_BYTES( 0x6f, 0xb1 ), TWO_BYTES( 0x91, 0xc5 ), TWO_BYTES( 0xc5, 0x54 ),
TWO_BYTES( 0x60, 0x30 ), TWO_BYTES( 0x30, 0x50 ), TWO_BYTES( 0x02, 0x01 ), TWO_BYTES( 0x01, 0x03 ),
TWO_BYTES( 0xce, 0x67 ), TWO_BYTES( 0x67, 0xa9 ), TWO_BYTES( 0x56, 0x2b ), TWO_BYTES( 0x2b, 0x7d ),
TWO_BYTES( 0xe7, 0xfe ), TWO_BYTES( 0xfe, 0x19 ), TWO_BYTES( 0xb5, 0xd7 ), TWO_BYTES( 0xd7, 0x62 ),
TWO_BYTES( 0x4d, 0xab ), TWO_BYTES( 0xab, 0xe6 ), TWO_BYTES( 0xec, 0x76 ), TWO_BYTES( 0x76, 0x9a ),
TWO_BYTES( 0x8f, 0xca ), TWO_BYTES( 0xca, 0x45 ), TWO_BYTES( 0x1f, 0x82 ), TWO_BYTES( 0x82, 0x9d ),
TWO_BYTES( 0x89, 0xc9 ), TWO_BYTES( 0xc9, 0x40 ), TWO_BYTES( 0xfa, 0x7d ), TWO_BYTES( 0x7d, 0x87 ),
TWO_BYTES( 0xef, 0xfa ), TWO_BYTES( 0xfa, 0x15 ), TWO_BYTES( 0xb2, 0x59 ), TWO_BYTES( 0x59, 0xeb ),
TWO_BYTES( 0x8e, 0x47 ), TWO_BYTES( 0x47, 0xc9 ), TWO_BYTES( 0xfb, 0xf0 ), TWO_BYTES( 0xf0, 0x0b ),
TWO_BYTES( 0x41, 0xad ), TWO_BYTES( 0xad, 0xec ), TWO_BYTES( 0xb3, 0xd4 ), TWO_BYTES( 0xd4, 0x67 ),
TWO_BYTES( 0x5f, 0xa2 ), TWO_BYTES( 0xa2, 0xfd ), TWO_BYTES( 0x45, 0xaf ), TWO_BYTES( 0xaf, 0xea ),
TWO_BYTES( 0x23, 0x9c ), TWO_BYTES( 0x9c, 0xbf ), TWO_BYTES( 0x53, 0xa4 ), TWO_BYTES( 0xa4, 0xf7 ),
TWO_BYTES( 0xe4, 0x72 ), TWO_BYTES( 0x72, 0x96 ), TWO_BYTES( 0x9b, 0xc0 ), TWO_BYTES( 0xc0, 0x5b ),
TWO_BYTES( 0x75, 0xb7 ), TWO_BYTES( 0xb7, 0xc2 ), TWO_BYTES( 0xe1, 0xfd ), TWO_BYTES( 0xfd, 0x1c ),
TWO_BYTES( 0x3d, 0x93 ), TWO_BYTES( 0x93, 0xae ), TWO_BYTES( 0x4c, 0x26 ), TWO_BYTES( 0x26, 0x6a ),
TWO_BYTES( 0x6c, 0x36 ), TWO_BYTES( 0x36, 0x5a ), TWO_BYTES( 0x7e, 0x3f ), TWO_BYTES( 0x3f, 0x41 ),
TWO_BYTES( 0xf5, 0xf7 ), TWO_BYTES( 0xf7, 0x02 ), TWO_BYTES( 0x83, 0xcc ), TWO_BYTES( 0xcc, 0x4f ),
TWO_BYTES( 0x68, 0x34 ), TWO_BYTES( 0x34, 0x5c ), TWO_BYTES( 0x51, 0xa5 ), TWO_BYTES( 0xa5, 0xf4 ),
TWO_BYTES( 0xd1, 0xe5 ), TWO_BYTES( 0xe5, 0x34 ), TWO_BYTES( 0xf9, 0xf1 ), TWO_BYTES( 0xf1, 0x08 ),
TWO_BYTES( 0xe2, 0x71 ), TWO_BYTES( 0x71, 0x93 ), TWO_BYTES( 0xab, 0xd8 ), TWO_BYTES( 0xd8, 0x73 ),
TWO_BYTES( 0x62, 0x31 ), TWO_BYTES( 0x31, 0x53 ), TWO_BYTES( 0x2a, 0x15 ), TWO_BYTES( 0x15, 0x3f ),
TWO_BYTES( 0x08, 0x04 ), TWO_BYTES( 0x04, 0x0c ), TWO_BYTES( 0x95, 0xc7 ), TWO_BYTES( 0xc7, 0x52 ),
TWO_BYTES( 0x46, 0x23 ), TWO_BYTES( 0x23, 0x65 ), TWO_BYTES( 0x9d, 0xc3 ), TWO_BYTES( 0xc3, 0x5e ),
TWO_BYTES( 0x30, 0x18 ), TWO_BYTES( 0x18, 0x28 ), TWO_BYTES( 0x37, 0x96 ), TWO_BYTES( 0x96, 0xa1 ),
TWO_BYTES( 0x0a, 0x05 ), TWO_BYTES( 0x05, 0x0f ), TWO_BYTES( 0x2f, 0x9a ), TWO_BYTES( 0x9a, 0xb5 ),
TWO_BYTES( 0x0e, 0x07 ), TWO_BYTES( 0x07, 0x09 ), TWO_BYTES( 0x24, 0x12 ), TWO_BYTES( 0x12, 0x36 ),
TWO_BYTES( 0x1b, 0x80 ), TWO_BYTES( 0x80, 0x9b ), TWO_BYTES( 0xdf, 0xe2 ), TWO_BYTES( 0xe2, 0x3d ),
TWO_BYTES( 0xcd, 0xeb ), TWO_BYTES( 0xeb, 0x26 ), TWO_BYTES( 0x4e, 0x27 ), TWO_BYTES( 0x27, 0x69 ),
TWO_BYTES( 0x7f, 0xb2 ), TWO_BYTES( 0xb2, 0xcd ), TWO_BYTES( 0xea, 0x75 ), TWO_BYTES( 0x75, 0x9f ),
TWO_BYTES( 0x12, 0x09 ), TWO_BYTES( 0x09, 0x1b ), TWO_BYTES( 0x1d, 0x83 ), TWO_BYTES( 0x83, 0x9e ),
TWO_BYTES( 0x58, 0x2c ), TWO_BYTES( 0x2c, 0x74 ), TWO_BYTES( 0x34, 0x1a ), TWO_BYTES( 0x1a, 0x2e ),
TWO_BYTES( 0x36, 0x1b ), TWO_BYTES( 0x1b, 0x2d ), TWO_BYTES( 0xdc, 0x6e ), TWO_BYTES( 0x6e, 0xb2 ),
TWO_BYTES( 0xb4, 0x5a ), TWO_BYTES( 0x5a, 0xee ), TWO_BYTES( 0x5b, 0xa0 ), TWO_BYTES( 0xa0, 0xfb ),
TWO_BYTES( 0xa4, 0x52 ), TWO_BYTES( 0x52, 0xf6 ), TWO_BYTES( 0x76, 0x3b ), TWO_BYTES( 0x3b, 0x4d ),
TWO_BYTES( 0xb7, 0xd6 ), TWO_BYTES( 0xd6, 0x61 ), TWO_BYTES( 0x7d, 0xb3 ), TWO_BYTES( 0xb3, 0xce ),
TWO_BYTES( 0x52, 0x29 ), TWO_BYTES( 0x29, 0x7b ), TWO_BYTES( 0xdd, 0xe3 ), TWO_BYTES( 0xe3, 0x3e ),
TWO_BYTES( 0x5e, 0x2f ), TWO_BYTES( 0x2f, 0x71 ), TWO_BYTES( 0x13, 0x84 ), TWO_BYTES( 0x84, 0x97 ),
TWO_BYTES( 0xa6, 0x53 ), TWO_BYTES( 0x53, 0xf5 ), TWO_BYTES( 0xb9, 0xd1 ), TWO_BYTES( 0xd1, 0x68 ),
TWO_BYTES( 0x00, 0x00 ), TWO_BYTES( 0x00, 0x00 ), TWO_BYTES( 0xc1, 0xed ), TWO_BYTES( 0xed, 0x2c ),
TWO_BYTES( 0x40, 0x20 ), TWO_BYTES( 0x20, 0x60 ), TWO_BYTES( 0xe3, 0xfc ), TWO_BYTES( 0xfc, 0x1f ),
TWO_BYTES( 0x79, 0xb1 ), TWO_BYTES( 0xb1, 0xc8 ), TWO_BYTES( 0xb6, 0x5b ), TWO_BYTES( 0x5b, 0xed ),
TWO_BYTES( 0xd4, 0x6a ), TWO_BYTES( 0x6a, 0xbe ), TWO_BYTES( 0x8d, 0xcb ), TWO_BYTES( 0xcb, 0x46 ),
TWO_BYTES( 0x67, 0xbe ), TWO_BYTES( 0xbe, 0xd9 ), TWO_BYTES( 0x72, 0x39 ), TWO_BYTES( 0x39, 0x4b ),
TWO_BYTES( 0x94, 0x4a ), TWO_BYTES( 0x4a, 0xde ), TWO_BYTES( 0x98, 0x4c ), TWO_BYTES( 0x4c, 0xd4 ),
TWO_BYTES( 0xb0, 0x58 ), TWO_BYTES( 0x58, 0xe8 ), TWO_BYTES( 0x85, 0xcf ), TWO_BYTES( 0xcf, 0x4a ),
TWO_BYTES( 0xbb, 0xd0 ), TWO_BYTES( 0xd0, 0x6b ), TWO_BYTES( 0xc5, 0xef ), TWO_BYTES( 0xef, 0x2a ),
TWO_BYTES( 0x4f, 0xaa ), TWO_BYTES( 0xaa, 0xe5 ), TWO_BYTES( 0xed, 0xfb ), TWO_BYTES( 0xfb, 0x16 ),
TWO_BYTES( 0x86, 0x43 ), TWO_BYTES( 0x43, 0xc5 ), TWO_BYTES( 0x9a, 0x4d ), TWO_BYTES( 0x4d, 0xd7 ),
TWO_BYTES( 0x66, 0x33 ), TWO_BYTES( 0x33, 0x55 ), TWO_BYTES( 0x11, 0x85 ), TWO_BYTES( 0x85, 0x94 ),
TWO_BYTES( 0x8a, 0x45 ), TWO_BYTES( 0x45, 0xcf ), TWO_BYTES( 0xe9, 0xf9 ), TWO_BYTES( 0xf9, 0x10 ),
TWO_BYTES( 0x04, 0x02 ), TWO_BYTES( 0x02, 0x06 ), TWO_BYTES( 0xfe, 0x7f ), TWO_BYTES( 0x7f, 0x81 ),
TWO_BYTES( 0xa0, 0x50 ), TWO_BYTES( 0x50, 0xf0 ), TWO_BYTES( 0x78, 0x3c ), TWO_BYTES( 0x3c, 0x44 ),
TWO_BYTES( 0x25, 0x9f ), TWO_BYTES( 0x9f, 0xba ), TWO_BYTES( 0x4b, 0xa8 ), TWO_BYTES( 0xa8, 0xe3 ),
TWO_BYTES( 0xa2, 0x51 ), TWO_BYTES( 0x51, 0xf3 ), TWO_BYTES( 0x5d, 0xa3 ), TWO_BYTES( 0xa3, 0xfe ),
TWO_BYTES( 0x80, 0x40 ), TWO_BYTES( 0x40, 0xc0 ), TWO_BYTES( 0x05, 0x8f ), TWO_BYTES( 0x8f, 0x8a ),
TWO_BYTES( 0x3f, 0x92 ), TWO_BYTES( 0x92, 0xad ), TWO_BYTES( 0x21, 0x9d ), TWO_BYTES( 0x9d, 0xbc ),
TWO_BYTES( 0x70, 0x38 ), TWO_BYTES( 0x38, 0x48 ), TWO_BYTES( 0xf1, 0xf5 ), TWO_BYTES( 0xf5, 0x04 ),
TWO_BYTES( 0x63, 0xbc ), TWO_BYTES( 0xbc, 0xdf ), TWO_BYTES( 0x77, 0xb6 ), TWO_BYTES( 0xb6, 0xc1 ),
TWO_BYTES( 0xaf, 0xda ), TWO_BYTES( 0xda, 0x75 ), TWO_BYTES( 0x42, 0x21 ), TWO_BYTES( 0x21, 0x63 ),
TWO_BYTES( 0x20, 0x10 ), TWO_BYTES( 0x10, 0x30 ), TWO_BYTES( 0xe5, 0xff ), TWO_BYTES( 0xff, 0x1a ),
TWO_BYTES( 0xfd, 0xf3 ), TWO_BYTES( 0xf3, 0x0e ), TWO_BYTES( 0xbf, 0xd2 ), TWO_BYTES( 0xd2, 0x6d ),
TWO_BYTES( 0x81, 0xcd ), TWO_BYTES( 0xcd, 0x4c ), TWO_BYTES( 0x18, 0x0c ), TWO_BYTES( 0x0c, 0x14 ),
TWO_BYTES( 0x26, 0x13 ), TWO_BYTES( 0x13, 0x35 ), TWO_BYTES( 0xc3, 0xec ), TWO_BYTES( 0xec, 0x2f ),
TWO_BYTES( 0xbe, 0x5f ), TWO_BYTES( 0x5f, 0xe1 ), TWO_BYTES( 0x35, 0x97 ), TWO_BYTES( 0x97, 0xa2 ),
TWO_BYTES( 0x88, 0x44 ), TWO_BYTES( 0x44, 0xcc ), TWO_BYTES( 0x2e, 0x17 ), TWO_BYTES( 0x17, 0x39 ),
TWO_BYTES( 0x93, 0xc4 ), TWO_BYTES( 0xc4, 0x57 ), TWO_BYTES( 0x55, 0xa7 ), TWO_BYTES( 0xa7, 0xf2 ),
TWO_BYTES( 0xfc, 0x7e ), TWO_BYTES( 0x7e, 0x82 ), TWO_BYTES( 0x7a, 0x3d ), TWO_BYTES( 0x3d, 0x47 ),
TWO_BYTES( 0xc8, 0x64 ), TWO_BYTES( 0x64, 0xac ), TWO_BYTES( 0xba, 0x5d ), TWO_BYTES( 0x5d, 0xe7 ),
TWO_BYTES( 0x32, 0x19 ), TWO_BYTES( 0x19, 0x2b ), TWO_BYTES( 0xe6, 0x73 ), TWO_BYTES( 0x73, 0x95 ),
TWO_BYTES( 0xc0, 0x60 ), TWO_BYTES( 0x60, 0xa0 ), TWO_BYTES( 0x19, 0x81 ), TWO_BYTES( 0x81, 0x98 ),
TWO_BYTES( 0x9e, 0x4f ), TWO_BYTES( 0x4f, 0xd1 ), TWO_BYTES( 0xa3, 0xdc ), TWO_BYTES( 0xdc, 0x7f ),
TWO_BYTES( 0x44, 0x22 ), TWO_BYTES( 0x22, 0x66 ), TWO_BYTES( 0x54, 0x2a ), TWO_BYTES( 0x2a, 0x7e ),
TWO_BYTES( 0x3b, 0x90 ), TWO_BYTES( 0x90, 0xab ), TWO_BYTES( 0x0b, 0x88 ), TWO_BYTES( 0x88, 0x83 ),
TWO_BYTES( 0x8c, 0x46 ), TWO_BYTES( 0x46, 0xca ), TWO_BYTES( 0xc7, 0xee ), TWO_BYTES( 0xee, 0x29 ),
TWO_BYTES( 0x6b, 0xb8 ), TWO_BYTES( 0xb8, 0xd3 ), TWO_BYTES( 0x28, 0x14 ), TWO_BYTES( 0x14, 0x3c ),
TWO_BYTES( 0xa7, 0xde ), TWO_BYTES( 0xde, 0x79 ), TWO_BYTES( 0xbc, 0x5e ), TWO_BYTES( 0x5e, 0xe2 ),
TWO_BYTES( 0x16, 0x0b ), TWO_BYTES( 0x0b, 0x1d ), TWO_BYTES( 0xad, 0xdb ), TWO_BYTES( 0xdb, 0x76 ),
TWO_BYTES( 0xdb, 0xe0 ), TWO_BYTES( 0xe0, 0x3b ), TWO_BYTES( 0x64, 0x32 ), TWO_BYTES( 0x32, 0x56 ),
TWO_BYTES( 0x74, 0x3a ), TWO_BYTES( 0x3a, 0x4e ), TWO_BYTES( 0x14, 0x0a ), TWO_BYTES( 0x0a, 0x1e ),
TWO_BYTES( 0x92, 0x49 ), TWO_BYTES( 0x49, 0xdb ), TWO_BYTES( 0x0c, 0x06 ), TWO_BYTES( 0x06, 0x0a ),
TWO_BYTES( 0x48, 0x24 ), TWO_BYTES( 0x24, 0x6c ), TWO_BYTES( 0xb8, 0x5c ), TWO_BYTES( 0x5c, 0xe4 ),
TWO_BYTES( 0x9f, 0xc2 ), TWO_BYTES( 0xc2, 0x5d ), TWO_BYTES( 0xbd, 0xd3 ), TWO_BYTES( 0xd3, 0x6e ),
TWO_BYTES( 0x43, 0xac ), TWO_BYTES( 0xac, 0xef ), TWO_BYTES( 0xc4, 0x62 ), TWO_BYTES( 0x62, 0xa6 ),
TWO_BYTES( 0x39, 0x91 ), TWO_BYTES( 0x91, 0xa8 ), TWO_BYTES( 0x31, 0x95 ), TWO_BYTES( 0x95, 0xa4 ),
TWO_BYTES( 0xd3, 0xe4 ), TWO_BYTES( 0xe4, 0x37 ), TWO_BYTES( 0xf2, 0x79 ), TWO_BYTES( 0x79, 0x8b ),
TWO_BYTES( 0xd5, 0xe7 ), TWO_BYTES( 0xe7, 0x32 ), TWO_BYTES( 0x8b, 0xc8 ), TWO_BYTES( 0xc8, 0x43 ),
TWO_BYTES( 0x6e, 0x37 ), TWO_BYTES( 0x37, 0x59 ), TWO_BYTES( 0xda, 0x6d ), TWO_BYTES( 0x6d, 0xb7 ),
TWO_BYTES( 0x01, 0x8d ), TWO_BYTES( 0x8d, 0x8c ), TWO_BYTES( 0xb1, 0xd5 ), TWO_BYTES( 0xd5, 0x64 ),
TWO_BYTES( 0x9c, 0x4e ), TWO_BYTES( 0x4e, 0xd2 ), TWO_BYTES( 0x49, 0xa9 ), TWO_BYTES( 0xa9, 0xe0 ),
TWO_BYTES( 0xd8, 0x6c ), TWO_BYTES( 0x6c, 0xb4 ), TWO_BYTES( 0xac, 0x56 ), TWO_BYTES( 0x56, 0xfa ),
TWO_BYTES( 0xf3, 0xf4 ), TWO_BYTES( 0xf4, 0x07 ), TWO_BYTES( 0xcf, 0xea ), TWO_BYTES( 0xea, 0x25 ),
TWO_BYTES( 0xca, 0x65 ), TWO_BYTES( 0x65, 0xaf ), TWO_BYTES( 0xf4, 0x7a ), TWO_BYTES( 0x7a, 0x8e ),
TWO_BYTES( 0x47, 0xae ), TWO_BYTES( 0xae, 0xe9 ), TWO_BYTES( 0x10, 0x08 ), TWO_BYTES( 0x08, 0x18 ),
TWO_BYTES( 0x6f, 0xba ), TWO_BYTES( 0xba, 0xd5 ), TWO_BYTES( 0xf0, 0x78 ), TWO_BYTES( 0x78, 0x88 ),
TWO_BYTES( 0x4a, 0x25 ), TWO_BYTES( 0x25, 0x6f ), TWO_BYTES( 0x5c, 0x2e ), TWO_BYTES( 0x2e, 0x72 ),
TWO_BYTES( 0x38, 0x1c ), TWO_BYTES( 0x1c, 0x24 ), TWO_BYTES( 0x57, 0xa6 ), TWO_BYTES( 0xa6, 0xf1 ),
TWO_BYTES( 0x73, 0xb4 ), TWO_BYTES( 0xb4, 0xc7 ), TWO_BYTES( 0x97, 0xc6 ), TWO_BYTES( 0xc6, 0x51 ),
TWO_BYTES( 0xcb, 0xe8 ), TWO_BYTES( 0xe8, 0x23 ), TWO_BYTES( 0xa1, 0xdd ), TWO_BYTES( 0xdd, 0x7c ),
TWO_BYTES( 0xe8, 0x74 ), TWO_BYTES( 0x74, 0x9c ), TWO_BYTES( 0x3e, 0x1f ), TWO_BYTES( 0x1f, 0x21 ),
TWO_BYTES( 0x96, 0x4b ), TWO_BYTES( 0x4b, 0xdd ), TWO_BYTES( 0x61, 0xbd ), TWO_BYTES( 0xbd, 0xdc ),
TWO_BYTES( 0x0d, 0x8b ), TWO_BYTES( 0x8b, 0x86 ), TWO_BYTES( 0x0f, 0x8a ), TWO_BYTES( 0x8a, 0x85 ),
TWO_BYTES( 0xe0, 0x70 ), TWO_BYTES( 0x70, 0x90 ), TWO_BYTES( 0x7c, 0x3e ), TWO_BYTES( 0x3e, 0x42 ),
TWO_BYTES( 0x71, 0xb5 ), TWO_BYTES( 0xb5, 0xc4 ), TWO_BYTES( 0xcc, 0x66 ), TWO_BYTES( 0x66, 0xaa ),
TWO_BYTES( 0x90, 0x48 ), TWO_BYTES( 0x48, 0xd8 ), TWO_BYTES( 0x06, 0x03 ), TWO_BYTES( 0x03, 0x05 ),
TWO_BYTES( 0xf7, 0xf6 ), TWO_BYTES( 0xf6, 0x01 ), TWO_BYTES( 0x1c, 0x0e ), TWO_BYTES( 0x0e, 0x12 ),
TWO_BYTES( 0xc2, 0x61 ), TWO_BYTES( 0x61, 0xa3 ), TWO_BYTES( 0x6a, 0x35 ), TWO_BYTES( 0x35, 0x5f ),
TWO_BYTES( 0xae, 0x57 ), TWO_BYTES( 0x57, 0xf9 ), TWO_BYTES( 0x69, 0xb9 ), TWO_BYTES( 0xb9, 0xd0 ),
TWO_BYTES( 0x17, 0x86 ), TWO_BYTES( 0x86, 0x91 ), TWO_BYTES( 0x99, 0xc1 ), TWO_BYTES( 0xc1, 0x58 ),
TWO_BYTES( 0x3a, 0x1d ), TWO_BYTES( 0x1d, 0x27 ), TWO_BYTES( 0x27, 0x9e ), TWO_BYTES( 0x9e, 0xb9 ),
TWO_BYTES( 0xd9, 0xe1 ), TWO_BYTES( 0xe1, 0x38 ), TWO_BYTES( 0xeb, 0xf8 ), TWO_BYTES( 0xf8, 0x13 ),
TWO_BYTES( 0x2b, 0x98 ), TWO_BYTES( 0x98, 0xb3 ), TWO_BYTES( 0x22, 0x11 ), TWO_BYTES( 0x11, 0x33 ),
TWO_BYTES( 0xd2, 0x69 ), TWO_BYTES( 0x69, 0xbb ), TWO_BYTES( 0xa9, 0xd9 ), TWO_BYTES( 0xd9, 0x70 ),
TWO_BYTES( 0x07, 0x8e ), TWO_BYTES( 0x8e, 0x89 ), TWO_BYTES( 0x33, 0x94 ), TWO_BYTES( 0x94, 0xa7 ),
TWO_BYTES( 0x2d, 0x9b ), TWO_BYTES( 0x9b, 0xb6 ), TWO_BYTES( 0x3c, 0x1e ), TWO_BYTES( 0x1e, 0x22 ),
TWO_BYTES( 0x15, 0x87 ), TWO_BYTES( 0x87, 0x92 ), TWO_BYTES( 0xc9, 0xe9 ), TWO_BYTES( 0xe9, 0x20 ),
TWO_BYTES( 0x87, 0xce ), TWO_BYTES( 0xce, 0x49 ), TWO_BYTES( 0xaa, 0x55 ), TWO_BYTES( 0x55, 0xff ),
TWO_BYTES( 0x50, 0x28 ), TWO_BYTES( 0x28, 0x78 ), TWO_BYTES( 0xa5, 0xdf ), TWO_BYTES( 0xdf, 0x7a ),
TWO_BYTES( 0x03, 0x8c ), TWO_BYTES( 0x8c, 0x8f ), TWO_BYTES( 0x59, 0xa1 ), TWO_BYTES( 0xa1, 0xf8 ),
TWO_BYTES( 0x09, 0x89 ), TWO_BYTES( 0x89, 0x80 ), TWO_BYTES( 0x1a, 0x0d ), TWO_BYTES( 0x0d, 0x17 ),
TWO_BYTES( 0x65, 0xbf ), TWO_BYTES( 0xbf, 0xda ), TWO_BYTES( 0xd7, 0xe6 ), TWO_BYTES( 0xe6, 0x31 ),
TWO_BYTES( 0x84, 0x42 ), TWO_BYTES( 0x42, 0xc6 ), TWO_BYTES( 0xd0, 0x68 ), TWO_BYTES( 0x68, 0xb8 ),
TWO_BYTES( 0x82, 0x41 ), TWO_BYTES( 0x41, 0xc3 ), TWO_BYTES( 0x29, 0x99 ), TWO_BYTES( 0x99, 0xb0 ),
TWO_BYTES( 0x5a, 0x2d ), TWO_BYTES( 0x2d, 0x77 ), TWO_BYTES( 0x1e, 0x0f ), TWO_BYTES( 0x0f, 0x11 ),
TWO_BYTES( 0x7b, 0xb0 ), TWO_BYTES( 0xb0, 0xcb ), TWO_BYTES( 0xa8, 0x54 ), TWO_BYTES( 0x54, 0xfc ),
TWO_BYTES( 0x6d, 0xbb ), TWO_BYTES( 0xbb, 0xd6 ), TWO_BYTES( 0x2c, 0x16 ), TWO_BYTES( 0x16, 0x3a )
};

const DRM_DWORD_ALIGN DRM_BYTE T2[256][__CB_DECL( 4 )] = 
{
TWO_BYTES( 0xa5, 0xc6 ), TWO_BYTES( 0x63, 0x63 ), TWO_BYTES( 0x84, 0xf8 ), TWO_BYTES( 0x7c, 0x7c ),
TWO_BYTES( 0x99, 0xee ), TWO_BYTES( 0x77, 0x77 ), TWO_BYTES( 0x8d, 0xf6 ), TWO_BYTES( 0x7b, 0x7b ),
TWO_BYTES( 0x0d, 0xff ), TWO_BYTES( 0xf2, 0xf2 ), TWO_BYTES( 0xbd, 0xd6 ), TWO_BYTES( 0x6b, 0x6b ),
TWO_BYTES( 0xb1, 0xde ), TWO_BYTES( 0x6f, 0x6f ), TWO_BYTES( 0x54, 0x91 ), TWO_BYTES( 0xc5, 0xc5 ),
TWO_BYTES( 0x50, 0x60 ), TWO_BYTES( 0x30, 0x30 ), TWO_BYTES( 0x03, 0x02 ), TWO_BYTES( 0x01, 0x01 ),
TWO_BYTES( 0xa9, 0xce ), TWO_BYTES( 0x67, 0x67 ), TWO_BYTES( 0x7d, 0x56 ), TWO_BYTES( 0x2b, 0x2b ),
TWO_BYTES( 0x19, 0xe7 ), TWO_BYTES( 0xfe, 0xfe ), TWO_BYTES( 0x62, 0xb5 ), TWO_BYTES( 0xd7, 0xd7 ),
TWO_BYTES( 0xe6, 0x4d ), TWO_BYTES( 0xab, 0xab ), TWO_BYTES( 0x9a, 0xec ), TWO_BYTES( 0x76, 0x76 ),
TWO_BYTES( 0x45, 0x8f ), TWO_BYTES( 0xca, 0xca ), TWO_BYTES( 0x9d, 0x1f ), TWO_BYTES( 0x82, 0x82 ),
TWO_BYTES( 0x40, 0x89 ), TWO_BYTES( 0xc9, 0xc9 ), TWO_BYTES( 0x87, 0xfa ), TWO_BYTES( 0x7d, 0x7d ),
TWO_BYTES( 0x15, 0xef ), TWO_BYTES( 0xfa, 0xfa ), TWO_BYTES( 0xeb, 0xb2 ), TWO_BYTES( 0x59, 0x59 ),
TWO_BYTES( 0xc9, 0x8e ), TWO_BYTES( 0x47, 0x47 ), TWO_BYTES( 0x0b, 0xfb ), TWO_BYTES( 0xf0, 0xf0 ),
TWO_BYTES( 0xec, 0x41 ), TWO_BYTES( 0xad, 0xad ), TWO_BYTES( 0x67, 0xb3 ), TWO_BYTES( 0xd4, 0xd4 ),
TWO_BYTES( 0xfd, 0x5f ), TWO_BYTES( 0xa2, 0xa2 ), TWO_BYTES( 0xea, 0x45 ), TWO_BYTES( 0xaf, 0xaf ),
TWO_BYTES( 0xbf, 0x23 ), TWO_BYTES( 0x9c, 0x9c ), TWO_BYTES( 0xf7, 0x53 ), TWO_BYTES( 0xa4, 0xa4 ),
TWO_BYTES( 0x96, 0xe4 ), TWO_BYTES( 0x72, 0x72 ), TWO_BYTES( 0x5b, 0x9b ), TWO_BYTES( 0xc0, 0xc0 ),
TWO_BYTES( 0xc2, 0x75 ), TWO_BYTES( 0xb7, 0xb7 ), TWO_BYTES( 0x1c, 0xe1 ), TWO_BYTES( 0xfd, 0xfd ),
TWO_BYTES( 0xae, 0x3d ), TWO_BYTES( 0x93, 0x93 ), TWO_BYTES( 0x6a, 0x4c ), TWO_BYTES( 0x26, 0x26 ),
TWO_BYTES( 0x5a, 0x6c ), TWO_BYTES( 0x36, 0x36 ), TWO_BYTES( 0x41, 0x7e ), TWO_BYTES( 0x3f, 0x3f ),
TWO_BYTES( 0x02, 0xf5 ), TWO_BYTES( 0xf7, 0xf7 ), TWO_BYTES( 0x4f, 0x83 ), TWO_BYTES( 0xcc, 0xcc ),
TWO_BYTES( 0x5c, 0x68 ), TWO_BYTES( 0x34, 0x34 ), TWO_BYTES( 0xf4, 0x51 ), TWO_BYTES( 0xa5, 0xa5 ),
TWO_BYTES( 0x34, 0xd1 ), TWO_BYTES( 0xe5, 0xe5 ), TWO_BYTES( 0x08, 0xf9 ), TWO_BYTES( 0xf1, 0xf1 ),
TWO_BYTES( 0x93, 0xe2 ), TWO_BYTES( 0x71, 0x71 ), TWO_BYTES( 0x73, 0xab ), TWO_BYTES( 0xd8, 0xd8 ),
TWO_BYTES( 0x53, 0x62 ), TWO_BYTES( 0x31, 0x31 ), TWO_BYTES( 0x3f, 0x2a ), TWO_BYTES( 0x15, 0x15 ),
TWO_BYTES( 0x0c, 0x08 ), TWO_BYTES( 0x04, 0x04 ), TWO_BYTES( 0x52, 0x95 ), TWO_BYTES( 0xc7, 0xc7 ),
TWO_BYTES( 0x65, 0x46 ), TWO_BYTES( 0x23, 0x23 ), TWO_BYTES( 0x5e, 0x9d ), TWO_BYTES( 0xc3, 0xc3 ),
TWO_BYTES( 0x28, 0x30 ), TWO_BYTES( 0x18, 0x18 ), TWO_BYTES( 0xa1, 0x37 ), TWO_BYTES( 0x96, 0x96 ),
TWO_BYTES( 0x0f, 0x0a ), TWO_BYTES( 0x05, 0x05 ), TWO_BYTES( 0xb5, 0x2f ), TWO_BYTES( 0x9a, 0x9a ),
TWO_BYTES( 0x09, 0x0e ), TWO_BYTES( 0x07, 0x07 ), TWO_BYTES( 0x36, 0x24 ), TWO_BYTES( 0x12, 0x12 ),
TWO_BYTES( 0x9b, 0x1b ), TWO_BYTES( 0x80, 0x80 ), TWO_BYTES( 0x3d, 0xdf ), TWO_BYTES( 0xe2, 0xe2 ),
TWO_BYTES( 0x26, 0xcd ), TWO_BYTES( 0xeb, 0xeb ), TWO_BYTES( 0x69, 0x4e ), TWO_BYTES( 0x27, 0x27 ),
TWO_BYTES( 0xcd, 0x7f ), TWO_BYTES( 0xb2, 0xb2 ), TWO_BYTES( 0x9f, 0xea ), TWO_BYTES( 0x75, 0x75 ),
TWO_BYTES( 0x1b, 0x12 ), TWO_BYTES( 0x09, 0x09 ), TWO_BYTES( 0x9e, 0x1d ), TWO_BYTES( 0x83, 0x83 ),
TWO_BYTES( 0x74, 0x58 ), TWO_BYTES( 0x2c, 0x2c ), TWO_BYTES( 0x2e, 0x34 ), TWO_BYTES( 0x1a, 0x1a ),
TWO_BYTES( 0x2d, 0x36 ), TWO_BYTES( 0x1b, 0x1b ), TWO_BYTES( 0xb2, 0xdc ), TWO_BYTES( 0x6e, 0x6e ),
TWO_BYTES( 0xee, 0xb4 ), TWO_BYTES( 0x5a, 0x5a ), TWO_BYTES( 0xfb, 0x5b ), TWO_BYTES( 0xa0, 0xa0 ),
TWO_BYTES( 0xf6, 0xa4 ), TWO_BYTES( 0x52, 0x52 ), TWO_BYTES( 0x4d, 0x76 ), TWO_BYTES( 0x3b, 0x3b ),
TWO_BYTES( 0x61, 0xb7 ), TWO_BYTES( 0xd6, 0xd6 ), TWO_BYTES( 0xce, 0x7d ), TWO_BYTES( 0xb3, 0xb3 ),
TWO_BYTES( 0x7b, 0x52 ), TWO_BYTES( 0x29, 0x29 ), TWO_BYTES( 0x3e, 0xdd ), TWO_BYTES( 0xe3, 0xe3 ),
TWO_BYTES( 0x71, 0x5e ), TWO_BYTES( 0x2f, 0x2f ), TWO_BYTES( 0x97, 0x13 ), TWO_BYTES( 0x84, 0x84 ),
TWO_BYTES( 0xf5, 0xa6 ), TWO_BYTES( 0x53, 0x53 ), TWO_BYTES( 0x68, 0xb9 ), TWO_BYTES( 0xd1, 0xd1 ),
TWO_BYTES( 0x00, 0x00 ), TWO_BYTES( 0x00, 0x00 ), TWO_BYTES( 0x2c, 0xc1 ), TWO_BYTES( 0xed, 0xed ),
TWO_BYTES( 0x60, 0x40 ), TWO_BYTES( 0x20, 0x20 ), TWO_BYTES( 0x1f, 0xe3 ), TWO_BYTES( 0xfc, 0xfc ),
TWO_BYTES( 0xc8, 0x79 ), TWO_BYTES( 0xb1, 0xb1 ), TWO_BYTES( 0xed, 0xb6 ), TWO_BYTES( 0x5b, 0x5b ),
TWO_BYTES( 0xbe, 0xd4 ), TWO_BYTES( 0x6a, 0x6a ), TWO_BYTES( 0x46, 0x8d ), TWO_BYTES( 0xcb, 0xcb ),
TWO_BYTES( 0xd9, 0x67 ), TWO_BYTES( 0xbe, 0xbe ), TWO_BYTES( 0x4b, 0x72 ), TWO_BYTES( 0x39, 0x39 ),
TWO_BYTES( 0xde, 0x94 ), TWO_BYTES( 0x4a, 0x4a ), TWO_BYTES( 0xd4, 0x98 ), TWO_BYTES( 0x4c, 0x4c ),
TWO_BYTES( 0xe8, 0xb0 ), TWO_BYTES( 0x58, 0x58 ), TWO_BYTES( 0x4a, 0x85 ), TWO_BYTES( 0xcf, 0xcf ),
TWO_BYTES( 0x6b, 0xbb ), TWO_BYTES( 0xd0, 0xd0 ), TWO_BYTES( 0x2a, 0xc5 ), TWO_BYTES( 0xef, 0xef ),
TWO_BYTES( 0xe5, 0x4f ), TWO_BYTES( 0xaa, 0xaa ), TWO_BYTES( 0x16, 0xed ), TWO_BYTES( 0xfb, 0xfb ),
TWO_BYTES( 0xc5, 0x86 ), TWO_BYTES( 0x43, 0x43 ), TWO_BYTES( 0xd7, 0x9a ), TWO_BYTES( 0x4d, 0x4d ),
TWO_BYTES( 0x55, 0x66 ), TWO_BYTES( 0x33, 0x33 ), TWO_BYTES( 0x94, 0x11 ), TWO_BYTES( 0x85, 0x85 ),
TWO_BYTES( 0xcf, 0x8a ), TWO_BYTES( 0x45, 0x45 ), TWO_BYTES( 0x10, 0xe9 ), TWO_BYTES( 0xf9, 0xf9 ),
TWO_BYTES( 0x06, 0x04 ), TWO_BYTES( 0x02, 0x02 ), TWO_BYTES( 0x81, 0xfe ), TWO_BYTES( 0x7f, 0x7f ),
TWO_BYTES( 0xf0, 0xa0 ), TWO_BYTES( 0x50, 0x50 ), TWO_BYTES( 0x44, 0x78 ), TWO_BYTES( 0x3c, 0x3c ),
TWO_BYTES( 0xba, 0x25 ), TWO_BYTES( 0x9f, 0x9f ), TWO_BYTES( 0xe3, 0x4b ), TWO_BYTES( 0xa8, 0xa8 ),
TWO_BYTES( 0xf3, 0xa2 ), TWO_BYTES( 0x51, 0x51 ), TWO_BYTES( 0xfe, 0x5d ), TWO_BYTES( 0xa3, 0xa3 ),
TWO_BYTES( 0xc0, 0x80 ), TWO_BYTES( 0x40, 0x40 ), TWO_BYTES( 0x8a, 0x05 ), TWO_BYTES( 0x8f, 0x8f ),
TWO_BYTES( 0xad, 0x3f ), TWO_BYTES( 0x92, 0x92 ), TWO_BYTES( 0xbc, 0x21 ), TWO_BYTES( 0x9d, 0x9d ),
TWO_BYTES( 0x48, 0x70 ), TWO_BYTES( 0x38, 0x38 ), TWO_BYTES( 0x04, 0xf1 ), TWO_BYTES( 0xf5, 0xf5 ),
TWO_BYTES( 0xdf, 0x63 ), TWO_BYTES( 0xbc, 0xbc ), TWO_BYTES( 0xc1, 0x77 ), TWO_BYTES( 0xb6, 0xb6 ),
TWO_BYTES( 0x75, 0xaf ), TWO_BYTES( 0xda, 0xda ), TWO_BYTES( 0x63, 0x42 ), TWO_BYTES( 0x21, 0x21 ),
TWO_BYTES( 0x30, 0x20 ), TWO_BYTES( 0x10, 0x10 ), TWO_BYTES( 0x1a, 0xe5 ), TWO_BYTES( 0xff, 0xff ),
TWO_BYTES( 0x0e, 0xfd ), TWO_BYTES( 0xf3, 0xf3 ), TWO_BYTES( 0x6d, 0xbf ), TWO_BYTES( 0xd2, 0xd2 ),
TWO_BYTES( 0x4c, 0x81 ), TWO_BYTES( 0xcd, 0xcd ), TWO_BYTES( 0x14, 0x18 ), TWO_BYTES( 0x0c, 0x0c ),
TWO_BYTES( 0x35, 0x26 ), TWO_BYTES( 0x13, 0x13 ), TWO_BYTES( 0x2f, 0xc3 ), TWO_BYTES( 0xec, 0xec ),
TWO_BYTES( 0xe1, 0xbe ), TWO_BYTES( 0x5f, 0x5f ), TWO_BYTES( 0xa2, 0x35 ), TWO_BYTES( 0x97, 0x97 ),
TWO_BYTES( 0xcc, 0x88 ), TWO_BYTES( 0x44, 0x44 ), TWO_BYTES( 0x39, 0x2e ), TWO_BYTES( 0x17, 0x17 ),
TWO_BYTES( 0x57, 0x93 ), TWO_BYTES( 0xc4, 0xc4 ), TWO_BYTES( 0xf2, 0x55 ), TWO_BYTES( 0xa7, 0xa7 ),
TWO_BYTES( 0x82, 0xfc ), TWO_BYTES( 0x7e, 0x7e ), TWO_BYTES( 0x47, 0x7a ), TWO_BYTES( 0x3d, 0x3d ),
TWO_BYTES( 0xac, 0xc8 ), TWO_BYTES( 0x64, 0x64 ), TWO_BYTES( 0xe7, 0xba ), TWO_BYTES( 0x5d, 0x5d ),
TWO_BYTES( 0x2b, 0x32 ), TWO_BYTES( 0x19, 0x19 ), TWO_BYTES( 0x95, 0xe6 ), TWO_BYTES( 0x73, 0x73 ),
TWO_BYTES( 0xa0, 0xc0 ), TWO_BYTES( 0x60, 0x60 ), TWO_BYTES( 0x98, 0x19 ), TWO_BYTES( 0x81, 0x81 ),
TWO_BYTES( 0xd1, 0x9e ), TWO_BYTES( 0x4f, 0x4f ), TWO_BYTES( 0x7f, 0xa3 ), TWO_BYTES( 0xdc, 0xdc ),
TWO_BYTES( 0x66, 0x44 ), TWO_BYTES( 0x22, 0x22 ), TWO_BYTES( 0x7e, 0x54 ), TWO_BYTES( 0x2a, 0x2a ),
TWO_BYTES( 0xab, 0x3b ), TWO_BYTES( 0x90, 0x90 ), TWO_BYTES( 0x83, 0x0b ), TWO_BYTES( 0x88, 0x88 ),
TWO_BYTES( 0xca, 0x8c ), TWO_BYTES( 0x46, 0x46 ), TWO_BYTES( 0x29, 0xc7 ), TWO_BYTES( 0xee, 0xee ),
TWO_BYTES( 0xd3, 0x6b ), TWO_BYTES( 0xb8, 0xb8 ), TWO_BYTES( 0x3c, 0x28 ), TWO_BYTES( 0x14, 0x14 ),
TWO_BYTES( 0x79, 0xa7 ), TWO_BYTES( 0xde, 0xde ), TWO_BYTES( 0xe2, 0xbc ), TWO_BYTES( 0x5e, 0x5e ),
TWO_BYTES( 0x1d, 0x16 ), TWO_BYTES( 0x0b, 0x0b ), TWO_BYTES( 0x76, 0xad ), TWO_BYTES( 0xdb, 0xdb ),
TWO_BYTES( 0x3b, 0xdb ), TWO_BYTES( 0xe0, 0xe0 ), TWO_BYTES( 0x56, 0x64 ), TWO_BYTES( 0x32, 0x32 ),
TWO_BYTES( 0x4e, 0x74 ), TWO_BYTES( 0x3a, 0x3a ), TWO_BYTES( 0x1e, 0x14 ), TWO_BYTES( 0x0a, 0x0a ),
TWO_BYTES( 0xdb, 0x92 ), TWO_BYTES( 0x49, 0x49 ), TWO_BYTES( 0x0a, 0x0c ), TWO_BYTES( 0x06, 0x06 ),
TWO_BYTES( 0x6c, 0x48 ), TWO_BYTES( 0x24, 0x24 ), TWO_BYTES( 0xe4, 0xb8 ), TWO_BYTES( 0x5c, 0x5c ),
TWO_BYTES( 0x5d, 0x9f ), TWO_BYTES( 0xc2, 0xc2 ), TWO_BYTES( 0x6e, 0xbd ), TWO_BYTES( 0xd3, 0xd3 ),
TWO_BYTES( 0xef, 0x43 ), TWO_BYTES( 0xac, 0xac ), TWO_BYTES( 0xa6, 0xc4 ), TWO_BYTES( 0x62, 0x62 ),
TWO_BYTES( 0xa8, 0x39 ), TWO_BYTES( 0x91, 0x91 ), TWO_BYTES( 0xa4, 0x31 ), TWO_BYTES( 0x95, 0x95 ),
TWO_BYTES( 0x37, 0xd3 ), TWO_BYTES( 0xe4, 0xe4 ), TWO_BYTES( 0x8b, 0xf2 ), TWO_BYTES( 0x79, 0x79 ),
TWO_BYTES( 0x32, 0xd5 ), TWO_BYTES( 0xe7, 0xe7 ), TWO_BYTES( 0x43, 0x8b ), TWO_BYTES( 0xc8, 0xc8 ),
TWO_BYTES( 0x59, 0x6e ), TWO_BYTES( 0x37, 0x37 ), TWO_BYTES( 0xb7, 0xda ), TWO_BYTES( 0x6d, 0x6d ),
TWO_BYTES( 0x8c, 0x01 ), TWO_BYTES( 0x8d, 0x8d ), TWO_BYTES( 0x64, 0xb1 ), TWO_BYTES( 0xd5, 0xd5 ),
TWO_BYTES( 0xd2, 0x9c ), TWO_BYTES( 0x4e, 0x4e ), TWO_BYTES( 0xe0, 0x49 ), TWO_BYTES( 0xa9, 0xa9 ),
TWO_BYTES( 0xb4, 0xd8 ), TWO_BYTES( 0x6c, 0x6c ), TWO_BYTES( 0xfa, 0xac ), TWO_BYTES( 0x56, 0x56 ),
TWO_BYTES( 0x07, 0xf3 ), TWO_BYTES( 0xf4, 0xf4 ), TWO_BYTES( 0x25, 0xcf ), TWO_BYTES( 0xea, 0xea ),
TWO_BYTES( 0xaf, 0xca ), TWO_BYTES( 0x65, 0x65 ), TWO_BYTES( 0x8e, 0xf4 ), TWO_BYTES( 0x7a, 0x7a ),
TWO_BYTES( 0xe9, 0x47 ), TWO_BYTES( 0xae, 0xae ), TWO_BYTES( 0x18, 0x10 ), TWO_BYTES( 0x08, 0x08 ),
TWO_BYTES( 0xd5, 0x6f ), TWO_BYTES( 0xba, 0xba ), TWO_BYTES( 0x88, 0xf0 ), TWO_BYTES( 0x78, 0x78 ),
TWO_BYTES( 0x6f, 0x4a ), TWO_BYTES( 0x25, 0x25 ), TWO_BYTES( 0x72, 0x5c ), TWO_BYTES( 0x2e, 0x2e ),
TWO_BYTES( 0x24, 0x38 ), TWO_BYTES( 0x1c, 0x1c ), TWO_BYTES( 0xf1, 0x57 ), TWO_BYTES( 0xa6, 0xa6 ),
TWO_BYTES( 0xc7, 0x73 ), TWO_BYTES( 0xb4, 0xb4 ), TWO_BYTES( 0x51, 0x97 ), TWO_BYTES( 0xc6, 0xc6 ),
TWO_BYTES( 0x23, 0xcb ), TWO_BYTES( 0xe8, 0xe8 ), TWO_BYTES( 0x7c, 0xa1 ), TWO_BYTES( 0xdd, 0xdd ),
TWO_BYTES( 0x9c, 0xe8 ), TWO_BYTES( 0x74, 0x74 ), TWO_BYTES( 0x21, 0x3e ), TWO_BYTES( 0x1f, 0x1f ),
TWO_BYTES( 0xdd, 0x96 ), TWO_BYTES( 0x4b, 0x4b ), TWO_BYTES( 0xdc, 0x61 ), TWO_BYTES( 0xbd, 0xbd ),
TWO_BYTES( 0x86, 0x0d ), TWO_BYTES( 0x8b, 0x8b ), TWO_BYTES( 0x85, 0x0f ), TWO_BYTES( 0x8a, 0x8a ),
TWO_BYTES( 0x90, 0xe0 ), TWO_BYTES( 0x70, 0x70 ), TWO_BYTES( 0x42, 0x7c ), TWO_BYTES( 0x3e, 0x3e ),
TWO_BYTES( 0xc4, 0x71 ), TWO_BYTES( 0xb5, 0xb5 ), TWO_BYTES( 0xaa, 0xcc ), TWO_BYTES( 0x66, 0x66 ),
TWO_BYTES( 0xd8, 0x90 ), TWO_BYTES( 0x48, 0x48 ), TWO_BYTES( 0x05, 0x06 ), TWO_BYTES( 0x03, 0x03 ),
TWO_BYTES( 0x01, 0xf7 ), TWO_BYTES( 0xf6, 0xf6 ), TWO_BYTES( 0x12, 0x1c ), TWO_BYTES( 0x0e, 0x0e ),
TWO_BYTES( 0xa3, 0xc2 ), TWO_BYTES( 0x61, 0x61 ), TWO_BYTES( 0x5f, 0x6a ), TWO_BYTES( 0x35, 0x35 ),
TWO_BYTES( 0xf9, 0xae ), TWO_BYTES( 0x57, 0x57 ), TWO_BYTES( 0xd0, 0x69 ), TWO_BYTES( 0xb9, 0xb9 ),
TWO_BYTES( 0x91, 0x17 ), TWO_BYTES( 0x86, 0x86 ), TWO_BYTES( 0x58, 0x99 ), TWO_BYTES( 0xc1, 0xc1 ),
TWO_BYTES( 0x27, 0x3a ), TWO_BYTES( 0x1d, 0x1d ), TWO_BYTES( 0xb9, 0x27 ), TWO_BYTES( 0x9e, 0x9e ),
TWO_BYTES( 0x38, 0xd9 ), TWO_BYTES( 0xe1, 0xe1 ), TWO_BYTES( 0x13, 0xeb ), TWO_BYTES( 0xf8, 0xf8 ),
TWO_BYTES( 0xb3, 0x2b ), TWO_BYTES( 0x98, 0x98 ), TWO_BYTES( 0x33, 0x22 ), TWO_BYTES( 0x11, 0x11 ),
TWO_BYTES( 0xbb, 0xd2 ), TWO_BYTES( 0x69, 0x69 ), TWO_BYTES( 0x70, 0xa9 ), TWO_BYTES( 0xd9, 0xd9 ),
TWO_BYTES( 0x89, 0x07 ), TWO_BYTES( 0x8e, 0x8e ), TWO_BYTES( 0xa7, 0x33 ), TWO_BYTES( 0x94, 0x94 ),
TWO_BYTES( 0xb6, 0x2d ), TWO_BYTES( 0x9b, 0x9b ), TWO_BYTES( 0x22, 0x3c ), TWO_BYTES( 0x1e, 0x1e ),
TWO_BYTES( 0x92, 0x15 ), TWO_BYTES( 0x87, 0x87 ), TWO_BYTES( 0x20, 0xc9 ), TWO_BYTES( 0xe9, 0xe9 ),
TWO_BYTES( 0x49, 0x87 ), TWO_BYTES( 0xce, 0xce ), TWO_BYTES( 0xff, 0xaa ), TWO_BYTES( 0x55, 0x55 ),
TWO_BYTES( 0x78, 0x50 ), TWO_BYTES( 0x28, 0x28 ), TWO_BYTES( 0x7a, 0xa5 ), TWO_BYTES( 0xdf, 0xdf ),
TWO_BYTES( 0x8f, 0x03 ), TWO_BYTES( 0x8c, 0x8c ), TWO_BYTES( 0xf8, 0x59 ), TWO_BYTES( 0xa1, 0xa1 ),
TWO_BYTES( 0x80, 0x09 ), TWO_BYTES( 0x89, 0x89 ), TWO_BYTES( 0x17, 0x1a ), TWO_BYTES( 0x0d, 0x0d ),
TWO_BYTES( 0xda, 0x65 ), TWO_BYTES( 0xbf, 0xbf ), TWO_BYTES( 0x31, 0xd7 ), TWO_BYTES( 0xe6, 0xe6 ),
TWO_BYTES( 0xc6, 0x84 ), TWO_BYTES( 0x42, 0x42 ), TWO_BYTES( 0xb8, 0xd0 ), TWO_BYTES( 0x68, 0x68 ),
TWO_BYTES( 0xc3, 0x82 ), TWO_BYTES( 0x41, 0x41 ), TWO_BYTES( 0xb0, 0x29 ), TWO_BYTES( 0x99, 0x99 ),
TWO_BYTES( 0x77, 0x5a ), TWO_BYTES( 0x2d, 0x2d ), TWO_BYTES( 0x11, 0x1e ), TWO_BYTES( 0x0f, 0x0f ),
TWO_BYTES( 0xcb, 0x7b ), TWO_BYTES( 0xb0, 0xb0 ), TWO_BYTES( 0xfc, 0xa8 ), TWO_BYTES( 0x54, 0x54 ),
TWO_BYTES( 0xd6, 0x6d ), TWO_BYTES( 0xbb, 0xbb ), TWO_BYTES( 0x3a, 0x2c ), TWO_BYTES( 0x16, 0x16 )
};

const DRM_DWORD_ALIGN DRM_BYTE T3[256][__CB_DECL( 4 )] = 
{
TWO_BYTES( 0x63, 0xa5 ), TWO_BYTES( 0xc6, 0x63 ), TWO_BYTES( 0x7c, 0x84 ), TWO_BYTES( 0xf8, 0x7c ),
TWO_BYTES( 0x77, 0x99 ), TWO_BYTES( 0xee, 0x77 ), TWO_BYTES( 0x7b, 0x8d ), TWO_BYTES( 0xf6, 0x7b ),
TWO_BYTES( 0xf2, 0x0d ), TWO_BYTES( 0xff, 0xf2 ), TWO_BYTES( 0x6b, 0xbd ), TWO_BYTES( 0xd6, 0x6b ),
TWO_BYTES( 0x6f, 0xb1 ), TWO_BYTES( 0xde, 0x6f ), TWO_BYTES( 0xc5, 0x54 ), TWO_BYTES( 0x91, 0xc5 ),
TWO_BYTES( 0x30, 0x50 ), TWO_BYTES( 0x60, 0x30 ), TWO_BYTES( 0x01, 0x03 ), TWO_BYTES( 0x02, 0x01 ),
TWO_BYTES( 0x67, 0xa9 ), TWO_BYTES( 0xce, 0x67 ), TWO_BYTES( 0x2b, 0x7d ), TWO_BYTES( 0x56, 0x2b ),
TWO_BYTES( 0xfe, 0x19 ), TWO_BYTES( 0xe7, 0xfe ), TWO_BYTES( 0xd7, 0x62 ), TWO_BYTES( 0xb5, 0xd7 ),
TWO_BYTES( 0xab, 0xe6 ), TWO_BYTES( 0x4d, 0xab ), TWO_BYTES( 0x76, 0x9a ), TWO_BYTES( 0xec, 0x76 ),
TWO_BYTES( 0xca, 0x45 ), TWO_BYTES( 0x8f, 0xca ), TWO_BYTES( 0x82, 0x9d ), TWO_BYTES( 0x1f, 0x82 ),
TWO_BYTES( 0xc9, 0x40 ), TWO_BYTES( 0x89, 0xc9 ), TWO_BYTES( 0x7d, 0x87 ), TWO_BYTES( 0xfa, 0x7d ),
TWO_BYTES( 0xfa, 0x15 ), TWO_BYTES( 0xef, 0xfa ), TWO_BYTES( 0x59, 0xeb ), TWO_BYTES( 0xb2, 0x59 ),
TWO_BYTES( 0x47, 0xc9 ), TWO_BYTES( 0x8e, 0x47 ), TWO_BYTES( 0xf0, 0x0b ), TWO_BYTES( 0xfb, 0xf0 ),
TWO_BYTES( 0xad, 0xec ), TWO_BYTES( 0x41, 0xad ), TWO_BYTES( 0xd4, 0x67 ), TWO_BYTES( 0xb3, 0xd4 ),
TWO_BYTES( 0xa2, 0xfd ), TWO_BYTES( 0x5f, 0xa2 ), TWO_BYTES( 0xaf, 0xea ), TWO_BYTES( 0x45, 0xaf ),
TWO_BYTES( 0x9c, 0xbf ), TWO_BYTES( 0x23, 0x9c ), TWO_BYTES( 0xa4, 0xf7 ), TWO_BYTES( 0x53, 0xa4 ),
TWO_BYTES( 0x72, 0x96 ), TWO_BYTES( 0xe4, 0x72 ), TWO_BYTES( 0xc0, 0x5b ), TWO_BYTES( 0x9b, 0xc0 ),
TWO_BYTES( 0xb7, 0xc2 ), TWO_BYTES( 0x75, 0xb7 ), TWO_BYTES( 0xfd, 0x1c ), TWO_BYTES( 0xe1, 0xfd ),
TWO_BYTES( 0x93, 0xae ), TWO_BYTES( 0x3d, 0x93 ), TWO_BYTES( 0x26, 0x6a ), TWO_BYTES( 0x4c, 0x26 ),
TWO_BYTES( 0x36, 0x5a ), TWO_BYTES( 0x6c, 0x36 ), TWO_BYTES( 0x3f, 0x41 ), TWO_BYTES( 0x7e, 0x3f ),
TWO_BYTES( 0xf7, 0x02 ), TWO_BYTES( 0xf5, 0xf7 ), TWO_BYTES( 0xcc, 0x4f ), TWO_BYTES( 0x83, 0xcc ),
TWO_BYTES( 0x34, 0x5c ), TWO_BYTES( 0x68, 0x34 ), TWO_BYTES( 0xa5, 0xf4 ), TWO_BYTES( 0x51, 0xa5 ),
TWO_BYTES( 0xe5, 0x34 ), TWO_BYTES( 0xd1, 0xe5 ), TWO_BYTES( 0xf1, 0x08 ), TWO_BYTES( 0xf9, 0xf1 ),
TWO_BYTES( 0x71, 0x93 ), TWO_BYTES( 0xe2, 0x71 ), TWO_BYTES( 0xd8, 0x73 ), TWO_BYTES( 0xab, 0xd8 ),
TWO_BYTES( 0x31, 0x53 ), TWO_BYTES( 0x62, 0x31 ), TWO_BYTES( 0x15, 0x3f ), TWO_BYTES( 0x2a, 0x15 ),
TWO_BYTES( 0x04, 0x0c ), TWO_BYTES( 0x08, 0x04 ), TWO_BYTES( 0xc7, 0x52 ), TWO_BYTES( 0x95, 0xc7 ),
TWO_BYTES( 0x23, 0x65 ), TWO_BYTES( 0x46, 0x23 ), TWO_BYTES( 0xc3, 0x5e ), TWO_BYTES( 0x9d, 0xc3 ),
TWO_BYTES( 0x18, 0x28 ), TWO_BYTES( 0x30, 0x18 ), TWO_BYTES( 0x96, 0xa1 ), TWO_BYTES( 0x37, 0x96 ),
TWO_BYTES( 0x05, 0x0f ), TWO_BYTES( 0x0a, 0x05 ), TWO_BYTES( 0x9a, 0xb5 ), TWO_BYTES( 0x2f, 0x9a ),
TWO_BYTES( 0x07, 0x09 ), TWO_BYTES( 0x0e, 0x07 ), TWO_BYTES( 0x12, 0x36 ), TWO_BYTES( 0x24, 0x12 ),
TWO_BYTES( 0x80, 0x9b ), TWO_BYTES( 0x1b, 0x80 ), TWO_BYTES( 0xe2, 0x3d ), TWO_BYTES( 0xdf, 0xe2 ),
TWO_BYTES( 0xeb, 0x26 ), TWO_BYTES( 0xcd, 0xeb ), TWO_BYTES( 0x27, 0x69 ), TWO_BYTES( 0x4e, 0x27 ),
TWO_BYTES( 0xb2, 0xcd ), TWO_BYTES( 0x7f, 0xb2 ), TWO_BYTES( 0x75, 0x9f ), TWO_BYTES( 0xea, 0x75 ),
TWO_BYTES( 0x09, 0x1b ), TWO_BYTES( 0x12, 0x09 ), TWO_BYTES( 0x83, 0x9e ), TWO_BYTES( 0x1d, 0x83 ),
TWO_BYTES( 0x2c, 0x74 ), TWO_BYTES( 0x58, 0x2c ), TWO_BYTES( 0x1a, 0x2e ), TWO_BYTES( 0x34, 0x1a ),
TWO_BYTES( 0x1b, 0x2d ), TWO_BYTES( 0x36, 0x1b ), TWO_BYTES( 0x6e, 0xb2 ), TWO_BYTES( 0xdc, 0x6e ),
TWO_BYTES( 0x5a, 0xee ), TWO_BYTES( 0xb4, 0x5a ), TWO_BYTES( 0xa0, 0xfb ), TWO_BYTES( 0x5b, 0xa0 ),
TWO_BYTES( 0x52, 0xf6 ), TWO_BYTES( 0xa4, 0x52 ), TWO_BYTES( 0x3b, 0x4d ), TWO_BYTES( 0x76, 0x3b ),
TWO_BYTES( 0xd6, 0x61 ), TWO_BYTES( 0xb7, 0xd6 ), TWO_BYTES( 0xb3, 0xce ), TWO_BYTES( 0x7d, 0xb3 ),
TWO_BYTES( 0x29, 0x7b ), TWO_BYTES( 0x52, 0x29 ), TWO_BYTES( 0xe3, 0x3e ), TWO_BYTES( 0xdd, 0xe3 ),
TWO_BYTES( 0x2f, 0x71 ), TWO_BYTES( 0x5e, 0x2f ), TWO_BYTES( 0x84, 0x97 ), TWO_BYTES( 0x13, 0x84 ),
TWO_BYTES( 0x53, 0xf5 ), TWO_BYTES( 0xa6, 0x53 ), TWO_BYTES( 0xd1, 0x68 ), TWO_BYTES( 0xb9, 0xd1 ),
TWO_BYTES( 0x00, 0x00 ), TWO_BYTES( 0x00, 0x00 ), TWO_BYTES( 0xed, 0x2c ), TWO_BYTES( 0xc1, 0xed ),
TWO_BYTES( 0x20, 0x60 ), TWO_BYTES( 0x40, 0x20 ), TWO_BYTES( 0xfc, 0x1f ), TWO_BYTES( 0xe3, 0xfc ),
TWO_BYTES( 0xb1, 0xc8 ), TWO_BYTES( 0x79, 0xb1 ), TWO_BYTES( 0x5b, 0xed ), TWO_BYTES( 0xb6, 0x5b ),
TWO_BYTES( 0x6a, 0xbe ), TWO_BYTES( 0xd4, 0x6a ), TWO_BYTES( 0xcb, 0x46 ), TWO_BYTES( 0x8d, 0xcb ),
TWO_BYTES( 0xbe, 0xd9 ), TWO_BYTES( 0x67, 0xbe ), TWO_BYTES( 0x39, 0x4b ), TWO_BYTES( 0x72, 0x39 ),
TWO_BYTES( 0x4a, 0xde ), TWO_BYTES( 0x94, 0x4a ), TWO_BYTES( 0x4c, 0xd4 ), TWO_BYTES( 0x98, 0x4c ),
TWO_BYTES( 0x58, 0xe8 ), TWO_BYTES( 0xb0, 0x58 ), TWO_BYTES( 0xcf, 0x4a ), TWO_BYTES( 0x85, 0xcf ),
TWO_BYTES( 0xd0, 0x6b ), TWO_BYTES( 0xbb, 0xd0 ), TWO_BYTES( 0xef, 0x2a ), TWO_BYTES( 0xc5, 0xef ),
TWO_BYTES( 0xaa, 0xe5 ), TWO_BYTES( 0x4f, 0xaa ), TWO_BYTES( 0xfb, 0x16 ), TWO_BYTES( 0xed, 0xfb ),
TWO_BYTES( 0x43, 0xc5 ), TWO_BYTES( 0x86, 0x43 ), TWO_BYTES( 0x4d, 0xd7 ), TWO_BYTES( 0x9a, 0x4d ),
TWO_BYTES( 0x33, 0x55 ), TWO_BYTES( 0x66, 0x33 ), TWO_BYTES( 0x85, 0x94 ), TWO_BYTES( 0x11, 0x85 ),
TWO_BYTES( 0x45, 0xcf ), TWO_BYTES( 0x8a, 0x45 ), TWO_BYTES( 0xf9, 0x10 ), TWO_BYTES( 0xe9, 0xf9 ),
TWO_BYTES( 0x02, 0x06 ), TWO_BYTES( 0x04, 0x02 ), TWO_BYTES( 0x7f, 0x81 ), TWO_BYTES( 0xfe, 0x7f ),
TWO_BYTES( 0x50, 0xf0 ), TWO_BYTES( 0xa0, 0x50 ), TWO_BYTES( 0x3c, 0x44 ), TWO_BYTES( 0x78, 0x3c ),
TWO_BYTES( 0x9f, 0xba ), TWO_BYTES( 0x25, 0x9f ), TWO_BYTES( 0xa8, 0xe3 ), TWO_BYTES( 0x4b, 0xa8 ),
TWO_BYTES( 0x51, 0xf3 ), TWO_BYTES( 0xa2, 0x51 ), TWO_BYTES( 0xa3, 0xfe ), TWO_BYTES( 0x5d, 0xa3 ),
TWO_BYTES( 0x40, 0xc0 ), TWO_BYTES( 0x80, 0x40 ), TWO_BYTES( 0x8f, 0x8a ), TWO_BYTES( 0x05, 0x8f ),
TWO_BYTES( 0x92, 0xad ), TWO_BYTES( 0x3f, 0x92 ), TWO_BYTES( 0x9d, 0xbc ), TWO_BYTES( 0x21, 0x9d ),
TWO_BYTES( 0x38, 0x48 ), TWO_BYTES( 0x70, 0x38 ), TWO_BYTES( 0xf5, 0x04 ), TWO_BYTES( 0xf1, 0xf5 ),
TWO_BYTES( 0xbc, 0xdf ), TWO_BYTES( 0x63, 0xbc ), TWO_BYTES( 0xb6, 0xc1 ), TWO_BYTES( 0x77, 0xb6 ),
TWO_BYTES( 0xda, 0x75 ), TWO_BYTES( 0xaf, 0xda ), TWO_BYTES( 0x21, 0x63 ), TWO_BYTES( 0x42, 0x21 ),
TWO_BYTES( 0x10, 0x30 ), TWO_BYTES( 0x20, 0x10 ), TWO_BYTES( 0xff, 0x1a ), TWO_BYTES( 0xe5, 0xff ),
TWO_BYTES( 0xf3, 0x0e ), TWO_BYTES( 0xfd, 0xf3 ), TWO_BYTES( 0xd2, 0x6d ), TWO_BYTES( 0xbf, 0xd2 ),
TWO_BYTES( 0xcd, 0x4c ), TWO_BYTES( 0x81, 0xcd ), TWO_BYTES( 0x0c, 0x14 ), TWO_BYTES( 0x18, 0x0c ),
TWO_BYTES( 0x13, 0x35 ), TWO_BYTES( 0x26, 0x13 ), TWO_BYTES( 0xec, 0x2f ), TWO_BYTES( 0xc3, 0xec ),
TWO_BYTES( 0x5f, 0xe1 ), TWO_BYTES( 0xbe, 0x5f ), TWO_BYTES( 0x97, 0xa2 ), TWO_BYTES( 0x35, 0x97 ),
TWO_BYTES( 0x44, 0xcc ), TWO_BYTES( 0x88, 0x44 ), TWO_BYTES( 0x17, 0x39 ), TWO_BYTES( 0x2e, 0x17 ),
TWO_BYTES( 0xc4, 0x57 ), TWO_BYTES( 0x93, 0xc4 ), TWO_BYTES( 0xa7, 0xf2 ), TWO_BYTES( 0x55, 0xa7 ),
TWO_BYTES( 0x7e, 0x82 ), TWO_BYTES( 0xfc, 0x7e ), TWO_BYTES( 0x3d, 0x47 ), TWO_BYTES( 0x7a, 0x3d ),
TWO_BYTES( 0x64, 0xac ), TWO_BYTES( 0xc8, 0x64 ), TWO_BYTES( 0x5d, 0xe7 ), TWO_BYTES( 0xba, 0x5d ),
TWO_BYTES( 0x19, 0x2b ), TWO_BYTES( 0x32, 0x19 ), TWO_BYTES( 0x73, 0x95 ), TWO_BYTES( 0xe6, 0x73 ),
TWO_BYTES( 0x60, 0xa0 ), TWO_BYTES( 0xc0, 0x60 ), TWO_BYTES( 0x81, 0x98 ), TWO_BYTES( 0x19, 0x81 ),
TWO_BYTES( 0x4f, 0xd1 ), TWO_BYTES( 0x9e, 0x4f ), TWO_BYTES( 0xdc, 0x7f ), TWO_BYTES( 0xa3, 0xdc ),
TWO_BYTES( 0x22, 0x66 ), TWO_BYTES( 0x44, 0x22 ), TWO_BYTES( 0x2a, 0x7e ), TWO_BYTES( 0x54, 0x2a ),
TWO_BYTES( 0x90, 0xab ), TWO_BYTES( 0x3b, 0x90 ), TWO_BYTES( 0x88, 0x83 ), TWO_BYTES( 0x0b, 0x88 ),
TWO_BYTES( 0x46, 0xca ), TWO_BYTES( 0x8c, 0x46 ), TWO_BYTES( 0xee, 0x29 ), TWO_BYTES( 0xc7, 0xee ),
TWO_BYTES( 0xb8, 0xd3 ), TWO_BYTES( 0x6b, 0xb8 ), TWO_BYTES( 0x14, 0x3c ), TWO_BYTES( 0x28, 0x14 ),
TWO_BYTES( 0xde, 0x79 ), TWO_BYTES( 0xa7, 0xde ), TWO_BYTES( 0x5e, 0xe2 ), TWO_BYTES( 0xbc, 0x5e ),
TWO_BYTES( 0x0b, 0x1d ), TWO_BYTES( 0x16, 0x0b ), TWO_BYTES( 0xdb, 0x76 ), TWO_BYTES( 0xad, 0xdb ),
TWO_BYTES( 0xe0, 0x3b ), TWO_BYTES( 0xdb, 0xe0 ), TWO_BYTES( 0x32, 0x56 ), TWO_BYTES( 0x64, 0x32 ),
TWO_BYTES( 0x3a, 0x4e ), TWO_BYTES( 0x74, 0x3a ), TWO_BYTES( 0x0a, 0x1e ), TWO_BYTES( 0x14, 0x0a ),
TWO_BYTES( 0x49, 0xdb ), TWO_BYTES( 0x92, 0x49 ), TWO_BYTES( 0x06, 0x0a ), TWO_BYTES( 0x0c, 0x06 ),
TWO_BYTES( 0x24, 0x6c ), TWO_BYTES( 0x48, 0x24 ), TWO_BYTES( 0x5c, 0xe4 ), TWO_BYTES( 0xb8, 0x5c ),
TWO_BYTES( 0xc2, 0x5d ), TWO_BYTES( 0x9f, 0xc2 ), TWO_BYTES( 0xd3, 0x6e ), TWO_BYTES( 0xbd, 0xd3 ),
TWO_BYTES( 0xac, 0xef ), TWO_BYTES( 0x43, 0xac ), TWO_BYTES( 0x62, 0xa6 ), TWO_BYTES( 0xc4, 0x62 ),
TWO_BYTES( 0x91, 0xa8 ), TWO_BYTES( 0x39, 0x91 ), TWO_BYTES( 0x95, 0xa4 ), TWO_BYTES( 0x31, 0x95 ),
TWO_BYTES( 0xe4, 0x37 ), TWO_BYTES( 0xd3, 0xe4 ), TWO_BYTES( 0x79, 0x8b ), TWO_BYTES( 0xf2, 0x79 ),
TWO_BYTES( 0xe7, 0x32 ), TWO_BYTES( 0xd5, 0xe7 ), TWO_BYTES( 0xc8, 0x43 ), TWO_BYTES( 0x8b, 0xc8 ),
TWO_BYTES( 0x37, 0x59 ), TWO_BYTES( 0x6e, 0x37 ), TWO_BYTES( 0x6d, 0xb7 ), TWO_BYTES( 0xda, 0x6d ),
TWO_BYTES( 0x8d, 0x8c ), TWO_BYTES( 0x01, 0x8d ), TWO_BYTES( 0xd5, 0x64 ), TWO_BYTES( 0xb1, 0xd5 ),
TWO_BYTES( 0x4e, 0xd2 ), TWO_BYTES( 0x9c, 0x4e ), TWO_BYTES( 0xa9, 0xe0 ), TWO_BYTES( 0x49, 0xa9 ),
TWO_BYTES( 0x6c, 0xb4 ), TWO_BYTES( 0xd8, 0x6c ), TWO_BYTES( 0x56, 0xfa ), TWO_BYTES( 0xac, 0x56 ),
TWO_BYTES( 0xf4, 0x07 ), TWO_BYTES( 0xf3, 0xf4 ), TWO_BYTES( 0xea, 0x25 ), TWO_BYTES( 0xcf, 0xea ),
TWO_BYTES( 0x65, 0xaf ), TWO_BYTES( 0xca, 0x65 ), TWO_BYTES( 0x7a, 0x8e ), TWO_BYTES( 0xf4, 0x7a ),
TWO_BYTES( 0xae, 0xe9 ), TWO_BYTES( 0x47, 0xae ), TWO_BYTES( 0x08, 0x18 ), TWO_BYTES( 0x10, 0x08 ),
TWO_BYTES( 0xba, 0xd5 ), TWO_BYTES( 0x6f, 0xba ), TWO_BYTES( 0x78, 0x88 ), TWO_BYTES( 0xf0, 0x78 ),
TWO_BYTES( 0x25, 0x6f ), TWO_BYTES( 0x4a, 0x25 ), TWO_BYTES( 0x2e, 0x72 ), TWO_BYTES( 0x5c, 0x2e ),
TWO_BYTES( 0x1c, 0x24 ), TWO_BYTES( 0x38, 0x1c ), TWO_BYTES( 0xa6, 0xf1 ), TWO_BYTES( 0x57, 0xa6 ),
TWO_BYTES( 0xb4, 0xc7 ), TWO_BYTES( 0x73, 0xb4 ), TWO_BYTES( 0xc6, 0x51 ), TWO_BYTES( 0x97, 0xc6 ),
TWO_BYTES( 0xe8, 0x23 ), TWO_BYTES( 0xcb, 0xe8 ), TWO_BYTES( 0xdd, 0x7c ), TWO_BYTES( 0xa1, 0xdd ),
TWO_BYTES( 0x74, 0x9c ), TWO_BYTES( 0xe8, 0x74 ), TWO_BYTES( 0x1f, 0x21 ), TWO_BYTES( 0x3e, 0x1f ),
TWO_BYTES( 0x4b, 0xdd ), TWO_BYTES( 0x96, 0x4b ), TWO_BYTES( 0xbd, 0xdc ), TWO_BYTES( 0x61, 0xbd ),
TWO_BYTES( 0x8b, 0x86 ), TWO_BYTES( 0x0d, 0x8b ), TWO_BYTES( 0x8a, 0x85 ), TWO_BYTES( 0x0f, 0x8a ),
TWO_BYTES( 0x70, 0x90 ), TWO_BYTES( 0xe0, 0x70 ), TWO_BYTES( 0x3e, 0x42 ), TWO_BYTES( 0x7c, 0x3e ),
TWO_BYTES( 0xb5, 0xc4 ), TWO_BYTES( 0x71, 0xb5 ), TWO_BYTES( 0x66, 0xaa ), TWO_BYTES( 0xcc, 0x66 ),
TWO_BYTES( 0x48, 0xd8 ), TWO_BYTES( 0x90, 0x48 ), TWO_BYTES( 0x03, 0x05 ), TWO_BYTES( 0x06, 0x03 ),
TWO_BYTES( 0xf6, 0x01 ), TWO_BYTES( 0xf7, 0xf6 ), TWO_BYTES( 0x0e, 0x12 ), TWO_BYTES( 0x1c, 0x0e ),
TWO_BYTES( 0x61, 0xa3 ), TWO_BYTES( 0xc2, 0x61 ), TWO_BYTES( 0x35, 0x5f ), TWO_BYTES( 0x6a, 0x35 ),
TWO_BYTES( 0x57, 0xf9 ), TWO_BYTES( 0xae, 0x57 ), TWO_BYTES( 0xb9, 0xd0 ), TWO_BYTES( 0x69, 0xb9 ),
TWO_BYTES( 0x86, 0x91 ), TWO_BYTES( 0x17, 0x86 ), TWO_BYTES( 0xc1, 0x58 ), TWO_BYTES( 0x99, 0xc1 ),
TWO_BYTES( 0x1d, 0x27 ), TWO_BYTES( 0x3a, 0x1d ), TWO_BYTES( 0x9e, 0xb9 ), TWO_BYTES( 0x27, 0x9e ),
TWO_BYTES( 0xe1, 0x38 ), TWO_BYTES( 0xd9, 0xe1 ), TWO_BYTES( 0xf8, 0x13 ), TWO_BYTES( 0xeb, 0xf8 ),
TWO_BYTES( 0x98, 0xb3 ), TWO_BYTES( 0x2b, 0x98 ), TWO_BYTES( 0x11, 0x33 ), TWO_BYTES( 0x22, 0x11 ),
TWO_BYTES( 0x69, 0xbb ), TWO_BYTES( 0xd2, 0x69 ), TWO_BYTES( 0xd9, 0x70 ), TWO_BYTES( 0xa9, 0xd9 ),
TWO_BYTES( 0x8e, 0x89 ), TWO_BYTES( 0x07, 0x8e ), TWO_BYTES( 0x94, 0xa7 ), TWO_BYTES( 0x33, 0x94 ),
TWO_BYTES( 0x9b, 0xb6 ), TWO_BYTES( 0x2d, 0x9b ), TWO_BYTES( 0x1e, 0x22 ), TWO_BYTES( 0x3c, 0x1e ),
TWO_BYTES( 0x87, 0x92 ), TWO_BYTES( 0x15, 0x87 ), TWO_BYTES( 0xe9, 0x20 ), TWO_BYTES( 0xc9, 0xe9 ),
TWO_BYTES( 0xce, 0x49 ), TWO_BYTES( 0x87, 0xce ), TWO_BYTES( 0x55, 0xff ), TWO_BYTES( 0xaa, 0x55 ),
TWO_BYTES( 0x28, 0x78 ), TWO_BYTES( 0x50, 0x28 ), TWO_BYTES( 0xdf, 0x7a ), TWO_BYTES( 0xa5, 0xdf ),
TWO_BYTES( 0x8c, 0x8f ), TWO_BYTES( 0x03, 0x8c ), TWO_BYTES( 0xa1, 0xf8 ), TWO_BYTES( 0x59, 0xa1 ),
TWO_BYTES( 0x89, 0x80 ), TWO_BYTES( 0x09, 0x89 ), TWO_BYTES( 0x0d, 0x17 ), TWO_BYTES( 0x1a, 0x0d ),
TWO_BYTES( 0xbf, 0xda ), TWO_BYTES( 0x65, 0xbf ), TWO_BYTES( 0xe6, 0x31 ), TWO_BYTES( 0xd7, 0xe6 ),
TWO_BYTES( 0x42, 0xc6 ), TWO_BYTES( 0x84, 0x42 ), TWO_BYTES( 0x68, 0xb8 ), TWO_BYTES( 0xd0, 0x68 ),
TWO_BYTES( 0x41, 0xc3 ), TWO_BYTES( 0x82, 0x41 ), TWO_BYTES( 0x99, 0xb0 ), TWO_BYTES( 0x29, 0x99 ),
TWO_BYTES( 0x2d, 0x77 ), TWO_BYTES( 0x5a, 0x2d ), TWO_BYTES( 0x0f, 0x11 ), TWO_BYTES( 0x1e, 0x0f ),
TWO_BYTES( 0xb0, 0xcb ), TWO_BYTES( 0x7b, 0xb0 ), TWO_BYTES( 0x54, 0xfc ), TWO_BYTES( 0xa8, 0x54 ),
TWO_BYTES( 0xbb, 0xd6 ), TWO_BYTES( 0x6d, 0xbb ), TWO_BYTES( 0x16, 0x3a ), TWO_BYTES( 0x2c, 0x16 )
};

const DRM_DWORD_ALIGN DRM_BYTE T4[256][__CB_DECL( 4 )] = 
{
TWO_BYTES( 0x63, 0x63 ), TWO_BYTES( 0xa5, 0xc6 ), TWO_BYTES( 0x7c, 0x7c ), TWO_BYTES( 0x84, 0xf8 ),
TWO_BYTES( 0x77, 0x77 ), TWO_BYTES( 0x99, 0xee ), TWO_BYTES( 0x7b, 0x7b ), TWO_BYTES( 0x8d, 0xf6 ),
TWO_BYTES( 0xf2, 0xf2 ), TWO_BYTES( 0x0d, 0xff ), TWO_BYTES( 0x6b, 0x6b ), TWO_BYTES( 0xbd, 0xd6 ),
TWO_BYTES( 0x6f, 0x6f ), TWO_BYTES( 0xb1, 0xde ), TWO_BYTES( 0xc5, 0xc5 ), TWO_BYTES( 0x54, 0x91 ),
TWO_BYTES( 0x30, 0x30 ), TWO_BYTES( 0x50, 0x60 ), TWO_BYTES( 0x01, 0x01 ), TWO_BYTES( 0x03, 0x02 ),
TWO_BYTES( 0x67, 0x67 ), TWO_BYTES( 0xa9, 0xce ), TWO_BYTES( 0x2b, 0x2b ), TWO_BYTES( 0x7d, 0x56 ),
TWO_BYTES( 0xfe, 0xfe ), TWO_BYTES( 0x19, 0xe7 ), TWO_BYTES( 0xd7, 0xd7 ), TWO_BYTES( 0x62, 0xb5 ),
TWO_BYTES( 0xab, 0xab ), TWO_BYTES( 0xe6, 0x4d ), TWO_BYTES( 0x76, 0x76 ), TWO_BYTES( 0x9a, 0xec ),
TWO_BYTES( 0xca, 0xca ), TWO_BYTES( 0x45, 0x8f ), TWO_BYTES( 0x82, 0x82 ), TWO_BYTES( 0x9d, 0x1f ),
TWO_BYTES( 0xc9, 0xc9 ), TWO_BYTES( 0x40, 0x89 ), TWO_BYTES( 0x7d, 0x7d ), TWO_BYTES( 0x87, 0xfa ),
TWO_BYTES( 0xfa, 0xfa ), TWO_BYTES( 0x15, 0xef ), TWO_BYTES( 0x59, 0x59 ), TWO_BYTES( 0xeb, 0xb2 ),
TWO_BYTES( 0x47, 0x47 ), TWO_BYTES( 0xc9, 0x8e ), TWO_BYTES( 0xf0, 0xf0 ), TWO_BYTES( 0x0b, 0xfb ),
TWO_BYTES( 0xad, 0xad ), TWO_BYTES( 0xec, 0x41 ), TWO_BYTES( 0xd4, 0xd4 ), TWO_BYTES( 0x67, 0xb3 ),
TWO_BYTES( 0xa2, 0xa2 ), TWO_BYTES( 0xfd, 0x5f ), TWO_BYTES( 0xaf, 0xaf ), TWO_BYTES( 0xea, 0x45 ),
TWO_BYTES( 0x9c, 0x9c ), TWO_BYTES( 0xbf, 0x23 ), TWO_BYTES( 0xa4, 0xa4 ), TWO_BYTES( 0xf7, 0x53 ),
TWO_BYTES( 0x72, 0x72 ), TWO_BYTES( 0x96, 0xe4 ), TWO_BYTES( 0xc0, 0xc0 ), TWO_BYTES( 0x5b, 0x9b ),
TWO_BYTES( 0xb7, 0xb7 ), TWO_BYTES( 0xc2, 0x75 ), TWO_BYTES( 0xfd, 0xfd ), TWO_BYTES( 0x1c, 0xe1 ),
TWO_BYTES( 0x93, 0x93 ), TWO_BYTES( 0xae, 0x3d ), TWO_BYTES( 0x26, 0x26 ), TWO_BYTES( 0x6a, 0x4c ),
TWO_BYTES( 0x36, 0x36 ), TWO_BYTES( 0x5a, 0x6c ), TWO_BYTES( 0x3f, 0x3f ), TWO_BYTES( 0x41, 0x7e ),
TWO_BYTES( 0xf7, 0xf7 ), TWO_BYTES( 0x02, 0xf5 ), TWO_BYTES( 0xcc, 0xcc ), TWO_BYTES( 0x4f, 0x83 ),
TWO_BYTES( 0x34, 0x34 ), TWO_BYTES( 0x5c, 0x68 ), TWO_BYTES( 0xa5, 0xa5 ), TWO_BYTES( 0xf4, 0x51 ),
TWO_BYTES( 0xe5, 0xe5 ), TWO_BYTES( 0x34, 0xd1 ), TWO_BYTES( 0xf1, 0xf1 ), TWO_BYTES( 0x08, 0xf9 ),
TWO_BYTES( 0x71, 0x71 ), TWO_BYTES( 0x93, 0xe2 ), TWO_BYTES( 0xd8, 0xd8 ), TWO_BYTES( 0x73, 0xab ),
TWO_BYTES( 0x31, 0x31 ), TWO_BYTES( 0x53, 0x62 ), TWO_BYTES( 0x15, 0x15 ), TWO_BYTES( 0x3f, 0x2a ),
TWO_BYTES( 0x04, 0x04 ), TWO_BYTES( 0x0c, 0x08 ), TWO_BYTES( 0xc7, 0xc7 ), TWO_BYTES( 0x52, 0x95 ),
TWO_BYTES( 0x23, 0x23 ), TWO_BYTES( 0x65, 0x46 ), TWO_BYTES( 0xc3, 0xc3 ), TWO_BYTES( 0x5e, 0x9d ),
TWO_BYTES( 0x18, 0x18 ), TWO_BYTES( 0x28, 0x30 ), TWO_BYTES( 0x96, 0x96 ), TWO_BYTES( 0xa1, 0x37 ),
TWO_BYTES( 0x05, 0x05 ), TWO_BYTES( 0x0f, 0x0a ), TWO_BYTES( 0x9a, 0x9a ), TWO_BYTES( 0xb5, 0x2f ),
TWO_BYTES( 0x07, 0x07 ), TWO_BYTES( 0x09, 0x0e ), TWO_BYTES( 0x12, 0x12 ), TWO_BYTES( 0x36, 0x24 ),
TWO_BYTES( 0x80, 0x80 ), TWO_BYTES( 0x9b, 0x1b ), TWO_BYTES( 0xe2, 0xe2 ), TWO_BYTES( 0x3d, 0xdf ),
TWO_BYTES( 0xeb, 0xeb ), TWO_BYTES( 0x26, 0xcd ), TWO_BYTES( 0x27, 0x27 ), TWO_BYTES( 0x69, 0x4e ),
TWO_BYTES( 0xb2, 0xb2 ), TWO_BYTES( 0xcd, 0x7f ), TWO_BYTES( 0x75, 0x75 ), TWO_BYTES( 0x9f, 0xea ),
TWO_BYTES( 0x09, 0x09 ), TWO_BYTES( 0x1b, 0x12 ), TWO_BYTES( 0x83, 0x83 ), TWO_BYTES( 0x9e, 0x1d ),
TWO_BYTES( 0x2c, 0x2c ), TWO_BYTES( 0x74, 0x58 ), TWO_BYTES( 0x1a, 0x1a ), TWO_BYTES( 0x2e, 0x34 ),
TWO_BYTES( 0x1b, 0x1b ), TWO_BYTES( 0x2d, 0x36 ), TWO_BYTES( 0x6e, 0x6e ), TWO_BYTES( 0xb2, 0xdc ),
TWO_BYTES( 0x5a, 0x5a ), TWO_BYTES( 0xee, 0xb4 ), TWO_BYTES( 0xa0, 0xa0 ), TWO_BYTES( 0xfb, 0x5b ),
TWO_BYTES( 0x52, 0x52 ), TWO_BYTES( 0xf6, 0xa4 ), TWO_BYTES( 0x3b, 0x3b ), TWO_BYTES( 0x4d, 0x76 ),
TWO_BYTES( 0xd6, 0xd6 ), TWO_BYTES( 0x61, 0xb7 ), TWO_BYTES( 0xb3, 0xb3 ), TWO_BYTES( 0xce, 0x7d ),
TWO_BYTES( 0x29, 0x29 ), TWO_BYTES( 0x7b, 0x52 ), TWO_BYTES( 0xe3, 0xe3 ), TWO_BYTES( 0x3e, 0xdd ),
TWO_BYTES( 0x2f, 0x2f ), TWO_BYTES( 0x71, 0x5e ), TWO_BYTES( 0x84, 0x84 ), TWO_BYTES( 0x97, 0x13 ),
TWO_BYTES( 0x53, 0x53 ), TWO_BYTES( 0xf5, 0xa6 ), TWO_BYTES( 0xd1, 0xd1 ), TWO_BYTES( 0x68, 0xb9 ),
TWO_BYTES( 0x00, 0x00 ), TWO_BYTES( 0x00, 0x00 ), TWO_BYTES( 0xed, 0xed ), TWO_BYTES( 0x2c, 0xc1 ),
TWO_BYTES( 0x20, 0x20 ), TWO_BYTES( 0x60, 0x40 ), TWO_BYTES( 0xfc, 0xfc ), TWO_BYTES( 0x1f, 0xe3 ),
TWO_BYTES( 0xb1, 0xb1 ), TWO_BYTES( 0xc8, 0x79 ), TWO_BYTES( 0x5b, 0x5b ), TWO_BYTES( 0xed, 0xb6 ),
TWO_BYTES( 0x6a, 0x6a ), TWO_BYTES( 0xbe, 0xd4 ), TWO_BYTES( 0xcb, 0xcb ), TWO_BYTES( 0x46, 0x8d ),
TWO_BYTES( 0xbe, 0xbe ), TWO_BYTES( 0xd9, 0x67 ), TWO_BYTES( 0x39, 0x39 ), TWO_BYTES( 0x4b, 0x72 ),
TWO_BYTES( 0x4a, 0x4a ), TWO_BYTES( 0xde, 0x94 ), TWO_BYTES( 0x4c, 0x4c ), TWO_BYTES( 0xd4, 0x98 ),
TWO_BYTES( 0x58, 0x58 ), TWO_BYTES( 0xe8, 0xb0 ), TWO_BYTES( 0xcf, 0xcf ), TWO_BYTES( 0x4a, 0x85 ),
TWO_BYTES( 0xd0, 0xd0 ), TWO_BYTES( 0x6b, 0xbb ), TWO_BYTES( 0xef, 0xef ), TWO_BYTES( 0x2a, 0xc5 ),
TWO_BYTES( 0xaa, 0xaa ), TWO_BYTES( 0xe5, 0x4f ), TWO_BYTES( 0xfb, 0xfb ), TWO_BYTES( 0x16, 0xed ),
TWO_BYTES( 0x43, 0x43 ), TWO_BYTES( 0xc5, 0x86 ), TWO_BYTES( 0x4d, 0x4d ), TWO_BYTES( 0xd7, 0x9a ),
TWO_BYTES( 0x33, 0x33 ), TWO_BYTES( 0x55, 0x66 ), TWO_BYTES( 0x85, 0x85 ), TWO_BYTES( 0x94, 0x11 ),
TWO_BYTES( 0x45, 0x45 ), TWO_BYTES( 0xcf, 0x8a ), TWO_BYTES( 0xf9, 0xf9 ), TWO_BYTES( 0x10, 0xe9 ),
TWO_BYTES( 0x02, 0x02 ), TWO_BYTES( 0x06, 0x04 ), TWO_BYTES( 0x7f, 0x7f ), TWO_BYTES( 0x81, 0xfe ),
TWO_BYTES( 0x50, 0x50 ), TWO_BYTES( 0xf0, 0xa0 ), TWO_BYTES( 0x3c, 0x3c ), TWO_BYTES( 0x44, 0x78 ),
TWO_BYTES( 0x9f, 0x9f ), TWO_BYTES( 0xba, 0x25 ), TWO_BYTES( 0xa8, 0xa8 ), TWO_BYTES( 0xe3, 0x4b ),
TWO_BYTES( 0x51, 0x51 ), TWO_BYTES( 0xf3, 0xa2 ), TWO_BYTES( 0xa3, 0xa3 ), TWO_BYTES( 0xfe, 0x5d ),
TWO_BYTES( 0x40, 0x40 ), TWO_BYTES( 0xc0, 0x80 ), TWO_BYTES( 0x8f, 0x8f ), TWO_BYTES( 0x8a, 0x05 ),
TWO_BYTES( 0x92, 0x92 ), TWO_BYTES( 0xad, 0x3f ), TWO_BYTES( 0x9d, 0x9d ), TWO_BYTES( 0xbc, 0x21 ),
TWO_BYTES( 0x38, 0x38 ), TWO_BYTES( 0x48, 0x70 ), TWO_BYTES( 0xf5, 0xf5 ), TWO_BYTES( 0x04, 0xf1 ),
TWO_BYTES( 0xbc, 0xbc ), TWO_BYTES( 0xdf, 0x63 ), TWO_BYTES( 0xb6, 0xb6 ), TWO_BYTES( 0xc1, 0x77 ),
TWO_BYTES( 0xda, 0xda ), TWO_BYTES( 0x75, 0xaf ), TWO_BYTES( 0x21, 0x21 ), TWO_BYTES( 0x63, 0x42 ),
TWO_BYTES( 0x10, 0x10 ), TWO_BYTES( 0x30, 0x20 ), TWO_BYTES( 0xff, 0xff ), TWO_BYTES( 0x1a, 0xe5 ),
TWO_BYTES( 0xf3, 0xf3 ), TWO_BYTES( 0x0e, 0xfd ), TWO_BYTES( 0xd2, 0xd2 ), TWO_BYTES( 0x6d, 0xbf ),
TWO_BYTES( 0xcd, 0xcd ), TWO_BYTES( 0x4c, 0x81 ), TWO_BYTES( 0x0c, 0x0c ), TWO_BYTES( 0x14, 0x18 ),
TWO_BYTES( 0x13, 0x13 ), TWO_BYTES( 0x35, 0x26 ), TWO_BYTES( 0xec, 0xec ), TWO_BYTES( 0x2f, 0xc3 ),
TWO_BYTES( 0x5f, 0x5f ), TWO_BYTES( 0xe1, 0xbe ), TWO_BYTES( 0x97, 0x97 ), TWO_BYTES( 0xa2, 0x35 ),
TWO_BYTES( 0x44, 0x44 ), TWO_BYTES( 0xcc, 0x88 ), TWO_BYTES( 0x17, 0x17 ), TWO_BYTES( 0x39, 0x2e ),
TWO_BYTES( 0xc4, 0xc4 ), TWO_BYTES( 0x57, 0x93 ), TWO_BYTES( 0xa7, 0xa7 ), TWO_BYTES( 0xf2, 0x55 ),
TWO_BYTES( 0x7e, 0x7e ), TWO_BYTES( 0x82, 0xfc ), TWO_BYTES( 0x3d, 0x3d ), TWO_BYTES( 0x47, 0x7a ),
TWO_BYTES( 0x64, 0x64 ), TWO_BYTES( 0xac, 0xc8 ), TWO_BYTES( 0x5d, 0x5d ), TWO_BYTES( 0xe7, 0xba ),
TWO_BYTES( 0x19, 0x19 ), TWO_BYTES( 0x2b, 0x32 ), TWO_BYTES( 0x73, 0x73 ), TWO_BYTES( 0x95, 0xe6 ),
TWO_BYTES( 0x60, 0x60 ), TWO_BYTES( 0xa0, 0xc0 ), TWO_BYTES( 0x81, 0x81 ), TWO_BYTES( 0x98, 0x19 ),
TWO_BYTES( 0x4f, 0x4f ), TWO_BYTES( 0xd1, 0x9e ), TWO_BYTES( 0xdc, 0xdc ), TWO_BYTES( 0x7f, 0xa3 ),
TWO_BYTES( 0x22, 0x22 ), TWO_BYTES( 0x66, 0x44 ), TWO_BYTES( 0x2a, 0x2a ), TWO_BYTES( 0x7e, 0x54 ),
TWO_BYTES( 0x90, 0x90 ), TWO_BYTES( 0xab, 0x3b ), TWO_BYTES( 0x88, 0x88 ), TWO_BYTES( 0x83, 0x0b ),
TWO_BYTES( 0x46, 0x46 ), TWO_BYTES( 0xca, 0x8c ), TWO_BYTES( 0xee, 0xee ), TWO_BYTES( 0x29, 0xc7 ),
TWO_BYTES( 0xb8, 0xb8 ), TWO_BYTES( 0xd3, 0x6b ), TWO_BYTES( 0x14, 0x14 ), TWO_BYTES( 0x3c, 0x28 ),
TWO_BYTES( 0xde, 0xde ), TWO_BYTES( 0x79, 0xa7 ), TWO_BYTES( 0x5e, 0x5e ), TWO_BYTES( 0xe2, 0xbc ),
TWO_BYTES( 0x0b, 0x0b ), TWO_BYTES( 0x1d, 0x16 ), TWO_BYTES( 0xdb, 0xdb ), TWO_BYTES( 0x76, 0xad ),
TWO_BYTES( 0xe0, 0xe0 ), TWO_BYTES( 0x3b, 0xdb ), TWO_BYTES( 0x32, 0x32 ), TWO_BYTES( 0x56, 0x64 ),
TWO_BYTES( 0x3a, 0x3a ), TWO_BYTES( 0x4e, 0x74 ), TWO_BYTES( 0x0a, 0x0a ), TWO_BYTES( 0x1e, 0x14 ),
TWO_BYTES( 0x49, 0x49 ), TWO_BYTES( 0xdb, 0x92 ), TWO_BYTES( 0x06, 0x06 ), TWO_BYTES( 0x0a, 0x0c ),
TWO_BYTES( 0x24, 0x24 ), TWO_BYTES( 0x6c, 0x48 ), TWO_BYTES( 0x5c, 0x5c ), TWO_BYTES( 0xe4, 0xb8 ),
TWO_BYTES( 0xc2, 0xc2 ), TWO_BYTES( 0x5d, 0x9f ), TWO_BYTES( 0xd3, 0xd3 ), TWO_BYTES( 0x6e, 0xbd ),
TWO_BYTES( 0xac, 0xac ), TWO_BYTES( 0xef, 0x43 ), TWO_BYTES( 0x62, 0x62 ), TWO_BYTES( 0xa6, 0xc4 ),
TWO_BYTES( 0x91, 0x91 ), TWO_BYTES( 0xa8, 0x39 ), TWO_BYTES( 0x95, 0x95 ), TWO_BYTES( 0xa4, 0x31 ),
TWO_BYTES( 0xe4, 0xe4 ), TWO_BYTES( 0x37, 0xd3 ), TWO_BYTES( 0x79, 0x79 ), TWO_BYTES( 0x8b, 0xf2 ),
TWO_BYTES( 0xe7, 0xe7 ), TWO_BYTES( 0x32, 0xd5 ), TWO_BYTES( 0xc8, 0xc8 ), TWO_BYTES( 0x43, 0x8b ),
TWO_BYTES( 0x37, 0x37 ), TWO_BYTES( 0x59, 0x6e ), TWO_BYTES( 0x6d, 0x6d ), TWO_BYTES( 0xb7, 0xda ),
TWO_BYTES( 0x8d, 0x8d ), TWO_BYTES( 0x8c, 0x01 ), TWO_BYTES( 0xd5, 0xd5 ), TWO_BYTES( 0x64, 0xb1 ),
TWO_BYTES( 0x4e, 0x4e ), TWO_BYTES( 0xd2, 0x9c ), TWO_BYTES( 0xa9, 0xa9 ), TWO_BYTES( 0xe0, 0x49 ),
TWO_BYTES( 0x6c, 0x6c ), TWO_BYTES( 0xb4, 0xd8 ), TWO_BYTES( 0x56, 0x56 ), TWO_BYTES( 0xfa, 0xac ),
TWO_BYTES( 0xf4, 0xf4 ), TWO_BYTES( 0x07, 0xf3 ), TWO_BYTES( 0xea, 0xea ), TWO_BYTES( 0x25, 0xcf ),
TWO_BYTES( 0x65, 0x65 ), TWO_BYTES( 0xaf, 0xca ), TWO_BYTES( 0x7a, 0x7a ), TWO_BYTES( 0x8e, 0xf4 ),
TWO_BYTES( 0xae, 0xae ), TWO_BYTES( 0xe9, 0x47 ), TWO_BYTES( 0x08, 0x08 ), TWO_BYTES( 0x18, 0x10 ),
TWO_BYTES( 0xba, 0xba ), TWO_BYTES( 0xd5, 0x6f ), TWO_BYTES( 0x78, 0x78 ), TWO_BYTES( 0x88, 0xf0 ),
TWO_BYTES( 0x25, 0x25 ), TWO_BYTES( 0x6f, 0x4a ), TWO_BYTES( 0x2e, 0x2e ), TWO_BYTES( 0x72, 0x5c ),
TWO_BYTES( 0x1c, 0x1c ), TWO_BYTES( 0x24, 0x38 ), TWO_BYTES( 0xa6, 0xa6 ), TWO_BYTES( 0xf1, 0x57 ),
TWO_BYTES( 0xb4, 0xb4 ), TWO_BYTES( 0xc7, 0x73 ), TWO_BYTES( 0xc6, 0xc6 ), TWO_BYTES( 0x51, 0x97 ),
TWO_BYTES( 0xe8, 0xe8 ), TWO_BYTES( 0x23, 0xcb ), TWO_BYTES( 0xdd, 0xdd ), TWO_BYTES( 0x7c, 0xa1 ),
TWO_BYTES( 0x74, 0x74 ), TWO_BYTES( 0x9c, 0xe8 ), TWO_BYTES( 0x1f, 0x1f ), TWO_BYTES( 0x21, 0x3e ),
TWO_BYTES( 0x4b, 0x4b ), TWO_BYTES( 0xdd, 0x96 ), TWO_BYTES( 0xbd, 0xbd ), TWO_BYTES( 0xdc, 0x61 ),
TWO_BYTES( 0x8b, 0x8b ), TWO_BYTES( 0x86, 0x0d ), TWO_BYTES( 0x8a, 0x8a ), TWO_BYTES( 0x85, 0x0f ),
TWO_BYTES( 0x70, 0x70 ), TWO_BYTES( 0x90, 0xe0 ), TWO_BYTES( 0x3e, 0x3e ), TWO_BYTES( 0x42, 0x7c ),
TWO_BYTES( 0xb5, 0xb5 ), TWO_BYTES( 0xc4, 0x71 ), TWO_BYTES( 0x66, 0x66 ), TWO_BYTES( 0xaa, 0xcc ),
TWO_BYTES( 0x48, 0x48 ), TWO_BYTES( 0xd8, 0x90 ), TWO_BYTES( 0x03, 0x03 ), TWO_BYTES( 0x05, 0x06 ),
TWO_BYTES( 0xf6, 0xf6 ), TWO_BYTES( 0x01, 0xf7 ), TWO_BYTES( 0x0e, 0x0e ), TWO_BYTES( 0x12, 0x1c ),
TWO_BYTES( 0x61, 0x61 ), TWO_BYTES( 0xa3, 0xc2 ), TWO_BYTES( 0x35, 0x35 ), TWO_BYTES( 0x5f, 0x6a ),
TWO_BYTES( 0x57, 0x57 ), TWO_BYTES( 0xf9, 0xae ), TWO_BYTES( 0xb9, 0xb9 ), TWO_BYTES( 0xd0, 0x69 ),
TWO_BYTES( 0x86, 0x86 ), TWO_BYTES( 0x91, 0x17 ), TWO_BYTES( 0xc1, 0xc1 ), TWO_BYTES( 0x58, 0x99 ),
TWO_BYTES( 0x1d, 0x1d ), TWO_BYTES( 0x27, 0x3a ), TWO_BYTES( 0x9e, 0x9e ), TWO_BYTES( 0xb9, 0x27 ),
TWO_BYTES( 0xe1, 0xe1 ), TWO_BYTES( 0x38, 0xd9 ), TWO_BYTES( 0xf8, 0xf8 ), TWO_BYTES( 0x13, 0xeb ),
TWO_BYTES( 0x98, 0x98 ), TWO_BYTES( 0xb3, 0x2b ), TWO_BYTES( 0x11, 0x11 ), TWO_BYTES( 0x33, 0x22 ),
TWO_BYTES( 0x69, 0x69 ), TWO_BYTES( 0xbb, 0xd2 ), TWO_BYTES( 0xd9, 0xd9 ), TWO_BYTES( 0x70, 0xa9 ),
TWO_BYTES( 0x8e, 0x8e ), TWO_BYTES( 0x89, 0x07 ), TWO_BYTES( 0x94, 0x94 ), TWO_BYTES( 0xa7, 0x33 ),
TWO_BYTES( 0x9b, 0x9b ), TWO_BYTES( 0xb6, 0x2d ), TWO_BYTES( 0x1e, 0x1e ), TWO_BYTES( 0x22, 0x3c ),
TWO_BYTES( 0x87, 0x87 ), TWO_BYTES( 0x92, 0x15 ), TWO_BYTES( 0xe9, 0xe9 ), TWO_BYTES( 0x20, 0xc9 ),
TWO_BYTES( 0xce, 0xce ), TWO_BYTES( 0x49, 0x87 ), TWO_BYTES( 0x55, 0x55 ), TWO_BYTES( 0xff, 0xaa ),
TWO_BYTES( 0x28, 0x28 ), TWO_BYTES( 0x78, 0x50 ), TWO_BYTES( 0xdf, 0xdf ), TWO_BYTES( 0x7a, 0xa5 ),
TWO_BYTES( 0x8c, 0x8c ), TWO_BYTES( 0x8f, 0x03 ), TWO_BYTES( 0xa1, 0xa1 ), TWO_BYTES( 0xf8, 0x59 ),
TWO_BYTES( 0x89, 0x89 ), TWO_BYTES( 0x80, 0x09 ), TWO_BYTES( 0x0d, 0x0d ), TWO_BYTES( 0x17, 0x1a ),
TWO_BYTES( 0xbf, 0xbf ), TWO_BYTES( 0xda, 0x65 ), TWO_BYTES( 0xe6, 0xe6 ), TWO_BYTES( 0x31, 0xd7 ),
TWO_BYTES( 0x42, 0x42 ), TWO_BYTES( 0xc6, 0x84 ), TWO_BYTES( 0x68, 0x68 ), TWO_BYTES( 0xb8, 0xd0 ),
TWO_BYTES( 0x41, 0x41 ), TWO_BYTES( 0xc3, 0x82 ), TWO_BYTES( 0x99, 0x99 ), TWO_BYTES( 0xb0, 0x29 ),
TWO_BYTES( 0x2d, 0x2d ), TWO_BYTES( 0x77, 0x5a ), TWO_BYTES( 0x0f, 0x0f ), TWO_BYTES( 0x11, 0x1e ),
TWO_BYTES( 0xb0, 0xb0 ), TWO_BYTES( 0xcb, 0x7b ), TWO_BYTES( 0x54, 0x54 ), TWO_BYTES( 0xfc, 0xa8 ),
TWO_BYTES( 0xbb, 0xbb ), TWO_BYTES( 0xd6, 0x6d ), TWO_BYTES( 0x16, 0x16 ), TWO_BYTES( 0x3a, 0x2c )
};

const DRM_DWORD_ALIGN DRM_BYTE T5[256][__CB_DECL( 4 )] = 
{
TWO_BYTES( 0x51, 0xf4 ), TWO_BYTES( 0xa7, 0x50 ), TWO_BYTES( 0x7e, 0x41 ), TWO_BYTES( 0x65, 0x53 ),
TWO_BYTES( 0x1a, 0x17 ), TWO_BYTES( 0xa4, 0xc3 ), TWO_BYTES( 0x3a, 0x27 ), TWO_BYTES( 0x5e, 0x96 ), 
TWO_BYTES( 0x3b, 0xab ), TWO_BYTES( 0x6b, 0xcb ), TWO_BYTES( 0x1f, 0x9d ), TWO_BYTES( 0x45, 0xf1 ),
TWO_BYTES( 0xac, 0xfa ), TWO_BYTES( 0x58, 0xab ), TWO_BYTES( 0x4b, 0xe3 ), TWO_BYTES( 0x03, 0x93 ), 
TWO_BYTES( 0x20, 0x30 ), TWO_BYTES( 0xfa, 0x55 ), TWO_BYTES( 0xad, 0x76 ), TWO_BYTES( 0x6d, 0xf6 ),
TWO_BYTES( 0x88, 0xcc ), TWO_BYTES( 0x76, 0x91 ), TWO_BYTES( 0xf5, 0x02 ), TWO_BYTES( 0x4c, 0x25 ), 
TWO_BYTES( 0x4f, 0xe5 ), TWO_BYTES( 0xd7, 0xfc ), TWO_BYTES( 0xc5, 0x2a ), TWO_BYTES( 0xcb, 0xd7 ),
TWO_BYTES( 0x26, 0x35 ), TWO_BYTES( 0x44, 0x80 ), TWO_BYTES( 0xb5, 0x62 ), TWO_BYTES( 0xa3, 0x8f ), 
TWO_BYTES( 0xde, 0xb1 ), TWO_BYTES( 0x5a, 0x49 ), TWO_BYTES( 0x25, 0xba ), TWO_BYTES( 0x1b, 0x67 ),
TWO_BYTES( 0x45, 0xea ), TWO_BYTES( 0x0e, 0x98 ), TWO_BYTES( 0x5d, 0xfe ), TWO_BYTES( 0xc0, 0xe1 ), 
TWO_BYTES( 0xc3, 0x2f ), TWO_BYTES( 0x75, 0x02 ), TWO_BYTES( 0x81, 0x4c ), TWO_BYTES( 0xf0, 0x12 ),
TWO_BYTES( 0x8d, 0x46 ), TWO_BYTES( 0x97, 0xa3 ), TWO_BYTES( 0x6b, 0xd3 ), TWO_BYTES( 0xf9, 0xc6 ), 
TWO_BYTES( 0x03, 0x8f ), TWO_BYTES( 0x5f, 0xe7 ), TWO_BYTES( 0x15, 0x92 ), TWO_BYTES( 0x9c, 0x95 ),
TWO_BYTES( 0xbf, 0x6d ), TWO_BYTES( 0x7a, 0xeb ), TWO_BYTES( 0x95, 0x52 ), TWO_BYTES( 0x59, 0xda ), 
TWO_BYTES( 0xd4, 0xbe ), TWO_BYTES( 0x83, 0x2d ), TWO_BYTES( 0x58, 0x74 ), TWO_BYTES( 0x21, 0xd3 ),
TWO_BYTES( 0x49, 0xe0 ), TWO_BYTES( 0x69, 0x29 ), TWO_BYTES( 0x8e, 0xc9 ), TWO_BYTES( 0xc8, 0x44 ), 
TWO_BYTES( 0x75, 0xc2 ), TWO_BYTES( 0x89, 0x6a ), TWO_BYTES( 0xf4, 0x8e ), TWO_BYTES( 0x79, 0x78 ),
TWO_BYTES( 0x99, 0x58 ), TWO_BYTES( 0x3e, 0x6b ), TWO_BYTES( 0x27, 0xb9 ), TWO_BYTES( 0x71, 0xdd ), 
TWO_BYTES( 0xbe, 0xe1 ), TWO_BYTES( 0x4f, 0xb6 ), TWO_BYTES( 0xf0, 0x88 ), TWO_BYTES( 0xad, 0x17 ),
TWO_BYTES( 0xc9, 0x20 ), TWO_BYTES( 0xac, 0x66 ), TWO_BYTES( 0x7d, 0xce ), TWO_BYTES( 0x3a, 0xb4 ), 
TWO_BYTES( 0x63, 0xdf ), TWO_BYTES( 0x4a, 0x18 ), TWO_BYTES( 0xe5, 0x1a ), TWO_BYTES( 0x31, 0x82 ),
TWO_BYTES( 0x97, 0x51 ), TWO_BYTES( 0x33, 0x60 ), TWO_BYTES( 0x62, 0x53 ), TWO_BYTES( 0x7f, 0x45 ), 
TWO_BYTES( 0xb1, 0x64 ), TWO_BYTES( 0x77, 0xe0 ), TWO_BYTES( 0xbb, 0x6b ), TWO_BYTES( 0xae, 0x84 ),
TWO_BYTES( 0xfe, 0x81 ), TWO_BYTES( 0xa0, 0x1c ), TWO_BYTES( 0xf9, 0x08 ), TWO_BYTES( 0x2b, 0x94 ), 
TWO_BYTES( 0x70, 0x48 ), TWO_BYTES( 0x68, 0x58 ), TWO_BYTES( 0x8f, 0x45 ), TWO_BYTES( 0xfd, 0x19 ),
TWO_BYTES( 0x94, 0xde ), TWO_BYTES( 0x6c, 0x87 ), TWO_BYTES( 0x52, 0x7b ), TWO_BYTES( 0xf8, 0xb7 ), 
TWO_BYTES( 0xab, 0x73 ), TWO_BYTES( 0xd3, 0x23 ), TWO_BYTES( 0x72, 0x4b ), TWO_BYTES( 0x02, 0xe2 ),
TWO_BYTES( 0xe3, 0x1f ), TWO_BYTES( 0x8f, 0x57 ), TWO_BYTES( 0x66, 0x55 ), TWO_BYTES( 0xab, 0x2a ), 
TWO_BYTES( 0xb2, 0xeb ), TWO_BYTES( 0x28, 0x07 ), TWO_BYTES( 0x2f, 0xb5 ), TWO_BYTES( 0xc2, 0x03 ),
TWO_BYTES( 0x86, 0xc5 ), TWO_BYTES( 0x7b, 0x9a ), TWO_BYTES( 0xd3, 0x37 ), TWO_BYTES( 0x08, 0xa5 ), 
TWO_BYTES( 0x30, 0x28 ), TWO_BYTES( 0x87, 0xf2 ), TWO_BYTES( 0x23, 0xbf ), TWO_BYTES( 0xa5, 0xb2 ),
TWO_BYTES( 0x02, 0x03 ), TWO_BYTES( 0x6a, 0xba ), TWO_BYTES( 0xed, 0x16 ), TWO_BYTES( 0x82, 0x5c ), 
TWO_BYTES( 0x8a, 0xcf ), TWO_BYTES( 0x1c, 0x2b ), TWO_BYTES( 0xa7, 0x79 ), TWO_BYTES( 0xb4, 0x92 ),
TWO_BYTES( 0xf3, 0x07 ), TWO_BYTES( 0xf2, 0xf0 ), TWO_BYTES( 0x4e, 0x69 ), TWO_BYTES( 0xe2, 0xa1 ), 
TWO_BYTES( 0x65, 0xda ), TWO_BYTES( 0xf4, 0xcd ), TWO_BYTES( 0x06, 0x05 ), TWO_BYTES( 0xbe, 0xd5 ),
TWO_BYTES( 0xd1, 0x34 ), TWO_BYTES( 0x62, 0x1f ), TWO_BYTES( 0xc4, 0xa6 ), TWO_BYTES( 0xfe, 0x8a ), 
TWO_BYTES( 0x34, 0x2e ), TWO_BYTES( 0x53, 0x9d ), TWO_BYTES( 0xa2, 0xf3 ), TWO_BYTES( 0x55, 0xa0 ),
TWO_BYTES( 0x05, 0x8a ), TWO_BYTES( 0xe1, 0x32 ), TWO_BYTES( 0xa4, 0xf6 ), TWO_BYTES( 0xeb, 0x75 ), 
TWO_BYTES( 0x0b, 0x83 ), TWO_BYTES( 0xec, 0x39 ), TWO_BYTES( 0x40, 0x60 ), TWO_BYTES( 0xef, 0xaa ),
TWO_BYTES( 0x5e, 0x71 ), TWO_BYTES( 0x9f, 0x06 ), TWO_BYTES( 0xbd, 0x6e ), TWO_BYTES( 0x10, 0x51 ), 
TWO_BYTES( 0x3e, 0x21 ), TWO_BYTES( 0x8a, 0xf9 ), TWO_BYTES( 0x96, 0xdd ), TWO_BYTES( 0x06, 0x3d ),
TWO_BYTES( 0xdd, 0x3e ), TWO_BYTES( 0x05, 0xae ), TWO_BYTES( 0x4d, 0xe6 ), TWO_BYTES( 0xbd, 0x46 ), 
TWO_BYTES( 0x91, 0x54 ), TWO_BYTES( 0x8d, 0xb5 ), TWO_BYTES( 0x71, 0xc4 ), TWO_BYTES( 0x5d, 0x05 ),
TWO_BYTES( 0x04, 0x06 ), TWO_BYTES( 0xd4, 0x6f ), TWO_BYTES( 0x60, 0x50 ), TWO_BYTES( 0x15, 0xff ), 
TWO_BYTES( 0x19, 0x98 ), TWO_BYTES( 0xfb, 0x24 ), TWO_BYTES( 0xd6, 0xbd ), TWO_BYTES( 0xe9, 0x97 ),
TWO_BYTES( 0x89, 0x40 ), TWO_BYTES( 0x43, 0xcc ), TWO_BYTES( 0x67, 0xd9 ), TWO_BYTES( 0x9e, 0x77 ), 
TWO_BYTES( 0xb0, 0xe8 ), TWO_BYTES( 0x42, 0xbd ), TWO_BYTES( 0x07, 0x89 ), TWO_BYTES( 0x8b, 0x88 ),
TWO_BYTES( 0xe7, 0x19 ), TWO_BYTES( 0x5b, 0x38 ), TWO_BYTES( 0x79, 0xc8 ), TWO_BYTES( 0xee, 0xdb ), 
TWO_BYTES( 0xa1, 0x7c ), TWO_BYTES( 0x0a, 0x47 ), TWO_BYTES( 0x7c, 0x42 ), TWO_BYTES( 0x0f, 0xe9 ),
TWO_BYTES( 0xf8, 0x84 ), TWO_BYTES( 0x1e, 0xc9 ), TWO_BYTES( 0x00, 0x00 ), TWO_BYTES( 0x00, 0x00 ), 
TWO_BYTES( 0x09, 0x80 ), TWO_BYTES( 0x86, 0x83 ), TWO_BYTES( 0x32, 0x2b ), TWO_BYTES( 0xed, 0x48 ),
TWO_BYTES( 0x1e, 0x11 ), TWO_BYTES( 0x70, 0xac ), TWO_BYTES( 0x6c, 0x5a ), TWO_BYTES( 0x72, 0x4e ), 
TWO_BYTES( 0xfd, 0x0e ), TWO_BYTES( 0xff, 0xfb ), TWO_BYTES( 0x0f, 0x85 ), TWO_BYTES( 0x38, 0x56 ),
TWO_BYTES( 0x3d, 0xae ), TWO_BYTES( 0xd5, 0x1e ), TWO_BYTES( 0x36, 0x2d ), TWO_BYTES( 0x39, 0x27 ), 
TWO_BYTES( 0x0a, 0x0f ), TWO_BYTES( 0xd9, 0x64 ), TWO_BYTES( 0x68, 0x5c ), TWO_BYTES( 0xa6, 0x21 ),
TWO_BYTES( 0x9b, 0x5b ), TWO_BYTES( 0x54, 0xd1 ), TWO_BYTES( 0x24, 0x36 ), TWO_BYTES( 0x2e, 0x3a ), 
TWO_BYTES( 0x0c, 0x0a ), TWO_BYTES( 0x67, 0xb1 ), TWO_BYTES( 0x93, 0x57 ), TWO_BYTES( 0xe7, 0x0f ),
TWO_BYTES( 0xb4, 0xee ), TWO_BYTES( 0x96, 0xd2 ), TWO_BYTES( 0x1b, 0x9b ), TWO_BYTES( 0x91, 0x9e ), 
TWO_BYTES( 0x80, 0xc0 ), TWO_BYTES( 0xc5, 0x4f ), TWO_BYTES( 0x61, 0xdc ), TWO_BYTES( 0x20, 0xa2 ),
TWO_BYTES( 0x5a, 0x77 ), TWO_BYTES( 0x4b, 0x69 ), TWO_BYTES( 0x1c, 0x12 ), TWO_BYTES( 0x1a, 0x16 ), 
TWO_BYTES( 0xe2, 0x93 ), TWO_BYTES( 0xba, 0x0a ), TWO_BYTES( 0xc0, 0xa0 ), TWO_BYTES( 0x2a, 0xe5 ),
TWO_BYTES( 0x3c, 0x22 ), TWO_BYTES( 0xe0, 0x43 ), TWO_BYTES( 0x12, 0x1b ), TWO_BYTES( 0x17, 0x1d ), 
TWO_BYTES( 0x0e, 0x09 ), TWO_BYTES( 0x0d, 0x0b ), TWO_BYTES( 0xf2, 0x8b ), TWO_BYTES( 0xc7, 0xad ),
TWO_BYTES( 0x2d, 0xb6 ), TWO_BYTES( 0xa8, 0xb9 ), TWO_BYTES( 0x14, 0x1e ), TWO_BYTES( 0xa9, 0xc8 ), 
TWO_BYTES( 0x57, 0xf1 ), TWO_BYTES( 0x19, 0x85 ), TWO_BYTES( 0xaf, 0x75 ), TWO_BYTES( 0x07, 0x4c ),
TWO_BYTES( 0xee, 0x99 ), TWO_BYTES( 0xdd, 0xbb ), TWO_BYTES( 0xa3, 0x7f ), TWO_BYTES( 0x60, 0xfd ), 
TWO_BYTES( 0xf7, 0x01 ), TWO_BYTES( 0x26, 0x9f ), TWO_BYTES( 0x5c, 0x72 ), TWO_BYTES( 0xf5, 0xbc ),
TWO_BYTES( 0x44, 0x66 ), TWO_BYTES( 0x3b, 0xc5 ), TWO_BYTES( 0x5b, 0xfb ), TWO_BYTES( 0x7e, 0x34 ), 
TWO_BYTES( 0x8b, 0x43 ), TWO_BYTES( 0x29, 0x76 ), TWO_BYTES( 0xcb, 0x23 ), TWO_BYTES( 0xc6, 0xdc ),
TWO_BYTES( 0xb6, 0xed ), TWO_BYTES( 0xfc, 0x68 ), TWO_BYTES( 0xb8, 0xe4 ), TWO_BYTES( 0xf1, 0x63 ), 
TWO_BYTES( 0xd7, 0x31 ), TWO_BYTES( 0xdc, 0xca ), TWO_BYTES( 0x42, 0x63 ), TWO_BYTES( 0x85, 0x10 ),
TWO_BYTES( 0x13, 0x97 ), TWO_BYTES( 0x22, 0x40 ), TWO_BYTES( 0x84, 0xc6 ), TWO_BYTES( 0x11, 0x20 ), 
TWO_BYTES( 0x85, 0x4a ), TWO_BYTES( 0x24, 0x7d ), TWO_BYTES( 0xd2, 0xbb ), TWO_BYTES( 0x3d, 0xf8 ),
TWO_BYTES( 0xae, 0xf9 ), TWO_BYTES( 0x32, 0x11 ), TWO_BYTES( 0xc7, 0x29 ), TWO_BYTES( 0xa1, 0x6d ), 
TWO_BYTES( 0x1d, 0x9e ), TWO_BYTES( 0x2f, 0x4b ), TWO_BYTES( 0xdc, 0xb2 ), TWO_BYTES( 0x30, 0xf3 ),
TWO_BYTES( 0x0d, 0x86 ), TWO_BYTES( 0x52, 0xec ), TWO_BYTES( 0x77, 0xc1 ), TWO_BYTES( 0xe3, 0xd0 ), 
TWO_BYTES( 0x2b, 0xb3 ), TWO_BYTES( 0x16, 0x6c ), TWO_BYTES( 0xa9, 0x70 ), TWO_BYTES( 0xb9, 0x99 ),
TWO_BYTES( 0x11, 0x94 ), TWO_BYTES( 0x48, 0xfa ), TWO_BYTES( 0x47, 0xe9 ), TWO_BYTES( 0x64, 0x22 ), 
TWO_BYTES( 0xa8, 0xfc ), TWO_BYTES( 0x8c, 0xc4 ), TWO_BYTES( 0xa0, 0xf0 ), TWO_BYTES( 0x3f, 0x1a ),
TWO_BYTES( 0x56, 0x7d ), TWO_BYTES( 0x2c, 0xd8 ), TWO_BYTES( 0x22, 0x33 ), TWO_BYTES( 0x90, 0xef ), 
TWO_BYTES( 0x87, 0x49 ), TWO_BYTES( 0x4e, 0xc7 ), TWO_BYTES( 0xd9, 0x38 ), TWO_BYTES( 0xd1, 0xc1 ),
TWO_BYTES( 0x8c, 0xca ), TWO_BYTES( 0xa2, 0xfe ), TWO_BYTES( 0x98, 0xd4 ), TWO_BYTES( 0x0b, 0x36 ), 
TWO_BYTES( 0xa6, 0xf5 ), TWO_BYTES( 0x81, 0xcf ), TWO_BYTES( 0xa5, 0x7a ), TWO_BYTES( 0xde, 0x28 ),
TWO_BYTES( 0xda, 0xb7 ), TWO_BYTES( 0x8e, 0x26 ), TWO_BYTES( 0x3f, 0xad ), TWO_BYTES( 0xbf, 0xa4 ), 
TWO_BYTES( 0x2c, 0x3a ), TWO_BYTES( 0x9d, 0xe4 ), TWO_BYTES( 0x50, 0x78 ), TWO_BYTES( 0x92, 0x0d ),
TWO_BYTES( 0x6a, 0x5f ), TWO_BYTES( 0xcc, 0x9b ), TWO_BYTES( 0x54, 0x7e ), TWO_BYTES( 0x46, 0x62 ), 
TWO_BYTES( 0xf6, 0x8d ), TWO_BYTES( 0x13, 0xc2 ), TWO_BYTES( 0x90, 0xd8 ), TWO_BYTES( 0xb8, 0xe8 ),
TWO_BYTES( 0x2e, 0x39 ), TWO_BYTES( 0xf7, 0x5e ), TWO_BYTES( 0x82, 0xc3 ), TWO_BYTES( 0xaf, 0xf5 ), 
TWO_BYTES( 0x9f, 0x5d ), TWO_BYTES( 0x80, 0xbe ), TWO_BYTES( 0x69, 0xd0 ), TWO_BYTES( 0x93, 0x7c ),
TWO_BYTES( 0x6f, 0xd5 ), TWO_BYTES( 0x2d, 0xa9 ), TWO_BYTES( 0xcf, 0x25 ), TWO_BYTES( 0x12, 0xb3 ), 
TWO_BYTES( 0xc8, 0xac ), TWO_BYTES( 0x99, 0x3b ), TWO_BYTES( 0x10, 0x18 ), TWO_BYTES( 0x7d, 0xa7 ),
TWO_BYTES( 0xe8, 0x9c ), TWO_BYTES( 0x63, 0x6e ), TWO_BYTES( 0xdb, 0x3b ), TWO_BYTES( 0xbb, 0x7b ), 
TWO_BYTES( 0xcd, 0x26 ), TWO_BYTES( 0x78, 0x09 ), TWO_BYTES( 0x6e, 0x59 ), TWO_BYTES( 0x18, 0xf4 ),
TWO_BYTES( 0xec, 0x9a ), TWO_BYTES( 0xb7, 0x01 ), TWO_BYTES( 0x83, 0x4f ), TWO_BYTES( 0x9a, 0xa8 ), 
TWO_BYTES( 0xe6, 0x95 ), TWO_BYTES( 0x6e, 0x65 ), TWO_BYTES( 0xaa, 0xff ), TWO_BYTES( 0xe6, 0x7e ),
TWO_BYTES( 0x21, 0xbc ), TWO_BYTES( 0xcf, 0x08 ), TWO_BYTES( 0xef, 0x15 ), TWO_BYTES( 0xe8, 0xe6 ), 
TWO_BYTES( 0xba, 0xe7 ), TWO_BYTES( 0x9b, 0xd9 ), TWO_BYTES( 0x4a, 0x6f ), TWO_BYTES( 0x36, 0xce ),
TWO_BYTES( 0xea, 0x9f ), TWO_BYTES( 0x09, 0xd4 ), TWO_BYTES( 0x29, 0xb0 ), TWO_BYTES( 0x7c, 0xd6 ), 
TWO_BYTES( 0x31, 0xa4 ), TWO_BYTES( 0xb2, 0xaf ), TWO_BYTES( 0x2a, 0x3f ), TWO_BYTES( 0x23, 0x31 ),
TWO_BYTES( 0xc6, 0xa5 ), TWO_BYTES( 0x94, 0x30 ), TWO_BYTES( 0x35, 0xa2 ), TWO_BYTES( 0x66, 0xc0 ), 
TWO_BYTES( 0x74, 0x4e ), TWO_BYTES( 0xbc, 0x37 ), TWO_BYTES( 0xfc, 0x82 ), TWO_BYTES( 0xca, 0xa6 ),
TWO_BYTES( 0xe0, 0x90 ), TWO_BYTES( 0xd0, 0xb0 ), TWO_BYTES( 0x33, 0xa7 ), TWO_BYTES( 0xd8, 0x15 ), 
TWO_BYTES( 0xf1, 0x04 ), TWO_BYTES( 0x98, 0x4a ), TWO_BYTES( 0x41, 0xec ), TWO_BYTES( 0xda, 0xf7 ),
TWO_BYTES( 0x7f, 0xcd ), TWO_BYTES( 0x50, 0x0e ), TWO_BYTES( 0x17, 0x91 ), TWO_BYTES( 0xf6, 0x2f ), 
TWO_BYTES( 0x76, 0x4d ), TWO_BYTES( 0xd6, 0x8d ), TWO_BYTES( 0x43, 0xef ), TWO_BYTES( 0xb0, 0x4d ),
TWO_BYTES( 0xcc, 0xaa ), TWO_BYTES( 0x4d, 0x54 ), TWO_BYTES( 0xe4, 0x96 ), TWO_BYTES( 0x04, 0xdf ), 
TWO_BYTES( 0x9e, 0xd1 ), TWO_BYTES( 0xb5, 0xe3 ), TWO_BYTES( 0x4c, 0x6a ), TWO_BYTES( 0x88, 0x1b ),
TWO_BYTES( 0xc1, 0x2c ), TWO_BYTES( 0x1f, 0xb8 ), TWO_BYTES( 0x46, 0x65 ), TWO_BYTES( 0x51, 0x7f ), 
TWO_BYTES( 0x9d, 0x5e ), TWO_BYTES( 0xea, 0x04 ), TWO_BYTES( 0x01, 0x8c ), TWO_BYTES( 0x35, 0x5d ),
TWO_BYTES( 0xfa, 0x87 ), TWO_BYTES( 0x74, 0x73 ), TWO_BYTES( 0xfb, 0x0b ), TWO_BYTES( 0x41, 0x2e ), 
TWO_BYTES( 0xb3, 0x67 ), TWO_BYTES( 0x1d, 0x5a ), TWO_BYTES( 0x92, 0xdb ), TWO_BYTES( 0xd2, 0x52 ),
TWO_BYTES( 0xe9, 0x10 ), TWO_BYTES( 0x56, 0x33 ), TWO_BYTES( 0x6d, 0xd6 ), TWO_BYTES( 0x47, 0x13 ), 
TWO_BYTES( 0x9a, 0xd7 ), TWO_BYTES( 0x61, 0x8c ), TWO_BYTES( 0x37, 0xa1 ), TWO_BYTES( 0x0c, 0x7a ),
TWO_BYTES( 0x59, 0xf8 ), TWO_BYTES( 0x14, 0x8e ), TWO_BYTES( 0xeb, 0x13 ), TWO_BYTES( 0x3c, 0x89 ), 
TWO_BYTES( 0xce, 0xa9 ), TWO_BYTES( 0x27, 0xee ), TWO_BYTES( 0xb7, 0x61 ), TWO_BYTES( 0xc9, 0x35 ),
TWO_BYTES( 0xe1, 0x1c ), TWO_BYTES( 0xe5, 0xed ), TWO_BYTES( 0x7a, 0x47 ), TWO_BYTES( 0xb1, 0x3c ), 
TWO_BYTES( 0x9c, 0xd2 ), TWO_BYTES( 0xdf, 0x59 ), TWO_BYTES( 0x55, 0xf2 ), TWO_BYTES( 0x73, 0x3f ),
TWO_BYTES( 0x18, 0x14 ), TWO_BYTES( 0xce, 0x79 ), TWO_BYTES( 0x73, 0xc7 ), TWO_BYTES( 0x37, 0xbf ), 
TWO_BYTES( 0x53, 0xf7 ), TWO_BYTES( 0xcd, 0xea ), TWO_BYTES( 0x5f, 0xfd ), TWO_BYTES( 0xaa, 0x5b ),
TWO_BYTES( 0xdf, 0x3d ), TWO_BYTES( 0x6f, 0x14 ), TWO_BYTES( 0x78, 0x44 ), TWO_BYTES( 0xdb, 0x86 ), 
TWO_BYTES( 0xca, 0xaf ), TWO_BYTES( 0xf3, 0x81 ), TWO_BYTES( 0xb9, 0x68 ), TWO_BYTES( 0xc4, 0x3e ),
TWO_BYTES( 0x38, 0x24 ), TWO_BYTES( 0x34, 0x2c ), TWO_BYTES( 0xc2, 0xa3 ), TWO_BYTES( 0x40, 0x5f ), 
TWO_BYTES( 0x16, 0x1d ), TWO_BYTES( 0xc3, 0x72 ), TWO_BYTES( 0xbc, 0xe2 ), TWO_BYTES( 0x25, 0x0c ),
TWO_BYTES( 0x28, 0x3c ), TWO_BYTES( 0x49, 0x8b ), TWO_BYTES( 0xff, 0x0d ), TWO_BYTES( 0x95, 0x41 ), 
TWO_BYTES( 0x39, 0xa8 ), TWO_BYTES( 0x01, 0x71 ), TWO_BYTES( 0x08, 0x0c ), TWO_BYTES( 0xb3, 0xde ),
TWO_BYTES( 0xd8, 0xb4 ), TWO_BYTES( 0xe4, 0x9c ), TWO_BYTES( 0x64, 0x56 ), TWO_BYTES( 0xc1, 0x90 ), 
TWO_BYTES( 0x7b, 0xcb ), TWO_BYTES( 0x84, 0x61 ), TWO_BYTES( 0xd5, 0x32 ), TWO_BYTES( 0xb6, 0x70 ),
TWO_BYTES( 0x48, 0x6c ), TWO_BYTES( 0x5c, 0x74 ), TWO_BYTES( 0xd0, 0xb8 ), TWO_BYTES( 0x57, 0x42 )
};

const DRM_DWORD_ALIGN DRM_BYTE T6[256][__CB_DECL( 4 )] = 
{
TWO_BYTES( 0x50, 0x51 ), TWO_BYTES( 0xf4, 0xa7 ), TWO_BYTES( 0x53, 0x7e ), TWO_BYTES( 0x41, 0x65 ),
TWO_BYTES( 0xc3, 0x1a ), TWO_BYTES( 0x17, 0xa4 ), TWO_BYTES( 0x96, 0x3a ), TWO_BYTES( 0x27, 0x5e ), 
TWO_BYTES( 0xcb, 0x3b ), TWO_BYTES( 0xab, 0x6b ), TWO_BYTES( 0xf1, 0x1f ), TWO_BYTES( 0x9d, 0x45 ),
TWO_BYTES( 0xab, 0xac ), TWO_BYTES( 0xfa, 0x58 ), TWO_BYTES( 0x93, 0x4b ), TWO_BYTES( 0xe3, 0x03 ), 
TWO_BYTES( 0x55, 0x20 ), TWO_BYTES( 0x30, 0xfa ), TWO_BYTES( 0xf6, 0xad ), TWO_BYTES( 0x76, 0x6d ),
TWO_BYTES( 0x91, 0x88 ), TWO_BYTES( 0xcc, 0x76 ), TWO_BYTES( 0x25, 0xf5 ), TWO_BYTES( 0x02, 0x4c ), 
TWO_BYTES( 0xfc, 0x4f ), TWO_BYTES( 0xe5, 0xd7 ), TWO_BYTES( 0xd7, 0xc5 ), TWO_BYTES( 0x2a, 0xcb ),
TWO_BYTES( 0x80, 0x26 ), TWO_BYTES( 0x35, 0x44 ), TWO_BYTES( 0x8f, 0xb5 ), TWO_BYTES( 0x62, 0xa3 ), 
TWO_BYTES( 0x49, 0xde ), TWO_BYTES( 0xb1, 0x5a ), TWO_BYTES( 0x67, 0x25 ), TWO_BYTES( 0xba, 0x1b ),
TWO_BYTES( 0x98, 0x45 ), TWO_BYTES( 0xea, 0x0e ), TWO_BYTES( 0xe1, 0x5d ), TWO_BYTES( 0xfe, 0xc0 ), 
TWO_BYTES( 0x02, 0xc3 ), TWO_BYTES( 0x2f, 0x75 ), TWO_BYTES( 0x12, 0x81 ), TWO_BYTES( 0x4c, 0xf0 ),
TWO_BYTES( 0xa3, 0x8d ), TWO_BYTES( 0x46, 0x97 ), TWO_BYTES( 0xc6, 0x6b ), TWO_BYTES( 0xd3, 0xf9 ), 
TWO_BYTES( 0xe7, 0x03 ), TWO_BYTES( 0x8f, 0x5f ), TWO_BYTES( 0x95, 0x15 ), TWO_BYTES( 0x92, 0x9c ),
TWO_BYTES( 0xeb, 0xbf ), TWO_BYTES( 0x6d, 0x7a ), TWO_BYTES( 0xda, 0x95 ), TWO_BYTES( 0x52, 0x59 ), 
TWO_BYTES( 0x2d, 0xd4 ), TWO_BYTES( 0xbe, 0x83 ), TWO_BYTES( 0xd3, 0x58 ), TWO_BYTES( 0x74, 0x21 ),
TWO_BYTES( 0x29, 0x49 ), TWO_BYTES( 0xe0, 0x69 ), TWO_BYTES( 0x44, 0x8e ), TWO_BYTES( 0xc9, 0xc8 ), 
TWO_BYTES( 0x6a, 0x75 ), TWO_BYTES( 0xc2, 0x89 ), TWO_BYTES( 0x78, 0xf4 ), TWO_BYTES( 0x8e, 0x79 ),
TWO_BYTES( 0x6b, 0x99 ), TWO_BYTES( 0x58, 0x3e ), TWO_BYTES( 0xdd, 0x27 ), TWO_BYTES( 0xb9, 0x71 ), 
TWO_BYTES( 0xb6, 0xbe ), TWO_BYTES( 0xe1, 0x4f ), TWO_BYTES( 0x17, 0xf0 ), TWO_BYTES( 0x88, 0xad ),
TWO_BYTES( 0x66, 0xc9 ), TWO_BYTES( 0x20, 0xac ), TWO_BYTES( 0xb4, 0x7d ), TWO_BYTES( 0xce, 0x3a ), 
TWO_BYTES( 0x18, 0x63 ), TWO_BYTES( 0xdf, 0x4a ), TWO_BYTES( 0x82, 0xe5 ), TWO_BYTES( 0x1a, 0x31 ),
TWO_BYTES( 0x60, 0x97 ), TWO_BYTES( 0x51, 0x33 ), TWO_BYTES( 0x45, 0x62 ), TWO_BYTES( 0x53, 0x7f ), 
TWO_BYTES( 0xe0, 0xb1 ), TWO_BYTES( 0x64, 0x77 ), TWO_BYTES( 0x84, 0xbb ), TWO_BYTES( 0x6b, 0xae ),
TWO_BYTES( 0x1c, 0xfe ), TWO_BYTES( 0x81, 0xa0 ), TWO_BYTES( 0x94, 0xf9 ), TWO_BYTES( 0x08, 0x2b ), 
TWO_BYTES( 0x58, 0x70 ), TWO_BYTES( 0x48, 0x68 ), TWO_BYTES( 0x19, 0x8f ), TWO_BYTES( 0x45, 0xfd ),
TWO_BYTES( 0x87, 0x94 ), TWO_BYTES( 0xde, 0x6c ), TWO_BYTES( 0xb7, 0x52 ), TWO_BYTES( 0x7b, 0xf8 ), 
TWO_BYTES( 0x23, 0xab ), TWO_BYTES( 0x73, 0xd3 ), TWO_BYTES( 0xe2, 0x72 ), TWO_BYTES( 0x4b, 0x02 ),
TWO_BYTES( 0x57, 0xe3 ), TWO_BYTES( 0x1f, 0x8f ), TWO_BYTES( 0x2a, 0x66 ), TWO_BYTES( 0x55, 0xab ), 
TWO_BYTES( 0x07, 0xb2 ), TWO_BYTES( 0xeb, 0x28 ), TWO_BYTES( 0x03, 0x2f ), TWO_BYTES( 0xb5, 0xc2 ),
TWO_BYTES( 0x9a, 0x86 ), TWO_BYTES( 0xc5, 0x7b ), TWO_BYTES( 0xa5, 0xd3 ), TWO_BYTES( 0x37, 0x08 ), 
TWO_BYTES( 0xf2, 0x30 ), TWO_BYTES( 0x28, 0x87 ), TWO_BYTES( 0xb2, 0x23 ), TWO_BYTES( 0xbf, 0xa5 ),
TWO_BYTES( 0xba, 0x02 ), TWO_BYTES( 0x03, 0x6a ), TWO_BYTES( 0x5c, 0xed ), TWO_BYTES( 0x16, 0x82 ), 
TWO_BYTES( 0x2b, 0x8a ), TWO_BYTES( 0xcf, 0x1c ), TWO_BYTES( 0x92, 0xa7 ), TWO_BYTES( 0x79, 0xb4 ),
TWO_BYTES( 0xf0, 0xf3 ), TWO_BYTES( 0x07, 0xf2 ), TWO_BYTES( 0xa1, 0x4e ), TWO_BYTES( 0x69, 0xe2 ), 
TWO_BYTES( 0xcd, 0x65 ), TWO_BYTES( 0xda, 0xf4 ), TWO_BYTES( 0xd5, 0x06 ), TWO_BYTES( 0x05, 0xbe ),
TWO_BYTES( 0x1f, 0xd1 ), TWO_BYTES( 0x34, 0x62 ), TWO_BYTES( 0x8a, 0xc4 ), TWO_BYTES( 0xa6, 0xfe ), 
TWO_BYTES( 0x9d, 0x34 ), TWO_BYTES( 0x2e, 0x53 ), TWO_BYTES( 0xa0, 0xa2 ), TWO_BYTES( 0xf3, 0x55 ),
TWO_BYTES( 0x32, 0x05 ), TWO_BYTES( 0x8a, 0xe1 ), TWO_BYTES( 0x75, 0xa4 ), TWO_BYTES( 0xf6, 0xeb ), 
TWO_BYTES( 0x39, 0x0b ), TWO_BYTES( 0x83, 0xec ), TWO_BYTES( 0xaa, 0x40 ), TWO_BYTES( 0x60, 0xef ),
TWO_BYTES( 0x06, 0x5e ), TWO_BYTES( 0x71, 0x9f ), TWO_BYTES( 0x51, 0xbd ), TWO_BYTES( 0x6e, 0x10 ), 
TWO_BYTES( 0xf9, 0x3e ), TWO_BYTES( 0x21, 0x8a ), TWO_BYTES( 0x3d, 0x96 ), TWO_BYTES( 0xdd, 0x06 ),
TWO_BYTES( 0xae, 0xdd ), TWO_BYTES( 0x3e, 0x05 ), TWO_BYTES( 0x46, 0x4d ), TWO_BYTES( 0xe6, 0xbd ), 
TWO_BYTES( 0xb5, 0x91 ), TWO_BYTES( 0x54, 0x8d ), TWO_BYTES( 0x05, 0x71 ), TWO_BYTES( 0xc4, 0x5d ),
TWO_BYTES( 0x6f, 0x04 ), TWO_BYTES( 0x06, 0xd4 ), TWO_BYTES( 0xff, 0x60 ), TWO_BYTES( 0x50, 0x15 ), 
TWO_BYTES( 0x24, 0x19 ), TWO_BYTES( 0x98, 0xfb ), TWO_BYTES( 0x97, 0xd6 ), TWO_BYTES( 0xbd, 0xe9 ),
TWO_BYTES( 0xcc, 0x89 ), TWO_BYTES( 0x40, 0x43 ), TWO_BYTES( 0x77, 0x67 ), TWO_BYTES( 0xd9, 0x9e ), 
TWO_BYTES( 0xbd, 0xb0 ), TWO_BYTES( 0xe8, 0x42 ), TWO_BYTES( 0x88, 0x07 ), TWO_BYTES( 0x89, 0x8b ),
TWO_BYTES( 0x38, 0xe7 ), TWO_BYTES( 0x19, 0x5b ), TWO_BYTES( 0xdb, 0x79 ), TWO_BYTES( 0xc8, 0xee ), 
TWO_BYTES( 0x47, 0xa1 ), TWO_BYTES( 0x7c, 0x0a ), TWO_BYTES( 0xe9, 0x7c ), TWO_BYTES( 0x42, 0x0f ),
TWO_BYTES( 0xc9, 0xf8 ), TWO_BYTES( 0x84, 0x1e ), TWO_BYTES( 0x00, 0x00 ), TWO_BYTES( 0x00, 0x00 ), 
TWO_BYTES( 0x83, 0x09 ), TWO_BYTES( 0x80, 0x86 ), TWO_BYTES( 0x48, 0x32 ), TWO_BYTES( 0x2b, 0xed ),
TWO_BYTES( 0xac, 0x1e ), TWO_BYTES( 0x11, 0x70 ), TWO_BYTES( 0x4e, 0x6c ), TWO_BYTES( 0x5a, 0x72 ), 
TWO_BYTES( 0xfb, 0xfd ), TWO_BYTES( 0x0e, 0xff ), TWO_BYTES( 0x56, 0x0f ), TWO_BYTES( 0x85, 0x38 ),
TWO_BYTES( 0x1e, 0x3d ), TWO_BYTES( 0xae, 0xd5 ), TWO_BYTES( 0x27, 0x36 ), TWO_BYTES( 0x2d, 0x39 ), 
TWO_BYTES( 0x64, 0x0a ), TWO_BYTES( 0x0f, 0xd9 ), TWO_BYTES( 0x21, 0x68 ), TWO_BYTES( 0x5c, 0xa6 ),
TWO_BYTES( 0xd1, 0x9b ), TWO_BYTES( 0x5b, 0x54 ), TWO_BYTES( 0x3a, 0x24 ), TWO_BYTES( 0x36, 0x2e ), 
TWO_BYTES( 0xb1, 0x0c ), TWO_BYTES( 0x0a, 0x67 ), TWO_BYTES( 0x0f, 0x93 ), TWO_BYTES( 0x57, 0xe7 ),
TWO_BYTES( 0xd2, 0xb4 ), TWO_BYTES( 0xee, 0x96 ), TWO_BYTES( 0x9e, 0x1b ), TWO_BYTES( 0x9b, 0x91 ), 
TWO_BYTES( 0x4f, 0x80 ), TWO_BYTES( 0xc0, 0xc5 ), TWO_BYTES( 0xa2, 0x61 ), TWO_BYTES( 0xdc, 0x20 ),
TWO_BYTES( 0x69, 0x5a ), TWO_BYTES( 0x77, 0x4b ), TWO_BYTES( 0x16, 0x1c ), TWO_BYTES( 0x12, 0x1a ), 
TWO_BYTES( 0x0a, 0xe2 ), TWO_BYTES( 0x93, 0xba ), TWO_BYTES( 0xe5, 0xc0 ), TWO_BYTES( 0xa0, 0x2a ),
TWO_BYTES( 0x43, 0x3c ), TWO_BYTES( 0x22, 0xe0 ), TWO_BYTES( 0x1d, 0x12 ), TWO_BYTES( 0x1b, 0x17 ), 
TWO_BYTES( 0x0b, 0x0e ), TWO_BYTES( 0x09, 0x0d ), TWO_BYTES( 0xad, 0xf2 ), TWO_BYTES( 0x8b, 0xc7 ),
TWO_BYTES( 0xb9, 0x2d ), TWO_BYTES( 0xb6, 0xa8 ), TWO_BYTES( 0xc8, 0x14 ), TWO_BYTES( 0x1e, 0xa9 ), 
TWO_BYTES( 0x85, 0x57 ), TWO_BYTES( 0xf1, 0x19 ), TWO_BYTES( 0x4c, 0xaf ), TWO_BYTES( 0x75, 0x07 ),
TWO_BYTES( 0xbb, 0xee ), TWO_BYTES( 0x99, 0xdd ), TWO_BYTES( 0xfd, 0xa3 ), TWO_BYTES( 0x7f, 0x60 ), 
TWO_BYTES( 0x9f, 0xf7 ), TWO_BYTES( 0x01, 0x26 ), TWO_BYTES( 0xbc, 0x5c ), TWO_BYTES( 0x72, 0xf5 ),
TWO_BYTES( 0xc5, 0x44 ), TWO_BYTES( 0x66, 0x3b ), TWO_BYTES( 0x34, 0x5b ), TWO_BYTES( 0xfb, 0x7e ), 
TWO_BYTES( 0x76, 0x8b ), TWO_BYTES( 0x43, 0x29 ), TWO_BYTES( 0xdc, 0xcb ), TWO_BYTES( 0x23, 0xc6 ),
TWO_BYTES( 0x68, 0xb6 ), TWO_BYTES( 0xed, 0xfc ), TWO_BYTES( 0x63, 0xb8 ), TWO_BYTES( 0xe4, 0xf1 ), 
TWO_BYTES( 0xca, 0xd7 ), TWO_BYTES( 0x31, 0xdc ), TWO_BYTES( 0x10, 0x42 ), TWO_BYTES( 0x63, 0x85 ),
TWO_BYTES( 0x40, 0x13 ), TWO_BYTES( 0x97, 0x22 ), TWO_BYTES( 0x20, 0x84 ), TWO_BYTES( 0xc6, 0x11 ), 
TWO_BYTES( 0x7d, 0x85 ), TWO_BYTES( 0x4a, 0x24 ), TWO_BYTES( 0xf8, 0xd2 ), TWO_BYTES( 0xbb, 0x3d ),
TWO_BYTES( 0x11, 0xae ), TWO_BYTES( 0xf9, 0x32 ), TWO_BYTES( 0x6d, 0xc7 ), TWO_BYTES( 0x29, 0xa1 ), 
TWO_BYTES( 0x4b, 0x1d ), TWO_BYTES( 0x9e, 0x2f ), TWO_BYTES( 0xf3, 0xdc ), TWO_BYTES( 0xb2, 0x30 ),
TWO_BYTES( 0xec, 0x0d ), TWO_BYTES( 0x86, 0x52 ), TWO_BYTES( 0xd0, 0x77 ), TWO_BYTES( 0xc1, 0xe3 ), 
TWO_BYTES( 0x6c, 0x2b ), TWO_BYTES( 0xb3, 0x16 ), TWO_BYTES( 0x99, 0xa9 ), TWO_BYTES( 0x70, 0xb9 ),
TWO_BYTES( 0xfa, 0x11 ), TWO_BYTES( 0x94, 0x48 ), TWO_BYTES( 0x22, 0x47 ), TWO_BYTES( 0xe9, 0x64 ), 
TWO_BYTES( 0xc4, 0xa8 ), TWO_BYTES( 0xfc, 0x8c ), TWO_BYTES( 0x1a, 0xa0 ), TWO_BYTES( 0xf0, 0x3f ),
TWO_BYTES( 0xd8, 0x56 ), TWO_BYTES( 0x7d, 0x2c ), TWO_BYTES( 0xef, 0x22 ), TWO_BYTES( 0x33, 0x90 ), 
TWO_BYTES( 0xc7, 0x87 ), TWO_BYTES( 0x49, 0x4e ), TWO_BYTES( 0xc1, 0xd9 ), TWO_BYTES( 0x38, 0xd1 ),
TWO_BYTES( 0xfe, 0x8c ), TWO_BYTES( 0xca, 0xa2 ), TWO_BYTES( 0x36, 0x98 ), TWO_BYTES( 0xd4, 0x0b ), 
TWO_BYTES( 0xcf, 0xa6 ), TWO_BYTES( 0xf5, 0x81 ), TWO_BYTES( 0x28, 0xa5 ), TWO_BYTES( 0x7a, 0xde ),
TWO_BYTES( 0x26, 0xda ), TWO_BYTES( 0xb7, 0x8e ), TWO_BYTES( 0xa4, 0x3f ), TWO_BYTES( 0xad, 0xbf ), 
TWO_BYTES( 0xe4, 0x2c ), TWO_BYTES( 0x3a, 0x9d ), TWO_BYTES( 0x0d, 0x50 ), TWO_BYTES( 0x78, 0x92 ),
TWO_BYTES( 0x9b, 0x6a ), TWO_BYTES( 0x5f, 0xcc ), TWO_BYTES( 0x62, 0x54 ), TWO_BYTES( 0x7e, 0x46 ), 
TWO_BYTES( 0xc2, 0xf6 ), TWO_BYTES( 0x8d, 0x13 ), TWO_BYTES( 0xe8, 0x90 ), TWO_BYTES( 0xd8, 0xb8 ),
TWO_BYTES( 0x5e, 0x2e ), TWO_BYTES( 0x39, 0xf7 ), TWO_BYTES( 0xf5, 0x82 ), TWO_BYTES( 0xc3, 0xaf ), 
TWO_BYTES( 0xbe, 0x9f ), TWO_BYTES( 0x5d, 0x80 ), TWO_BYTES( 0x7c, 0x69 ), TWO_BYTES( 0xd0, 0x93 ),
TWO_BYTES( 0xa9, 0x6f ), TWO_BYTES( 0xd5, 0x2d ), TWO_BYTES( 0xb3, 0xcf ), TWO_BYTES( 0x25, 0x12 ), 
TWO_BYTES( 0x3b, 0xc8 ), TWO_BYTES( 0xac, 0x99 ), TWO_BYTES( 0xa7, 0x10 ), TWO_BYTES( 0x18, 0x7d ),
TWO_BYTES( 0x6e, 0xe8 ), TWO_BYTES( 0x9c, 0x63 ), TWO_BYTES( 0x7b, 0xdb ), TWO_BYTES( 0x3b, 0xbb ), 
TWO_BYTES( 0x09, 0xcd ), TWO_BYTES( 0x26, 0x78 ), TWO_BYTES( 0xf4, 0x6e ), TWO_BYTES( 0x59, 0x18 ),
TWO_BYTES( 0x01, 0xec ), TWO_BYTES( 0x9a, 0xb7 ), TWO_BYTES( 0xa8, 0x83 ), TWO_BYTES( 0x4f, 0x9a ), 
TWO_BYTES( 0x65, 0xe6 ), TWO_BYTES( 0x95, 0x6e ), TWO_BYTES( 0x7e, 0xaa ), TWO_BYTES( 0xff, 0xe6 ),
TWO_BYTES( 0x08, 0x21 ), TWO_BYTES( 0xbc, 0xcf ), TWO_BYTES( 0xe6, 0xef ), TWO_BYTES( 0x15, 0xe8 ), 
TWO_BYTES( 0xd9, 0xba ), TWO_BYTES( 0xe7, 0x9b ), TWO_BYTES( 0xce, 0x4a ), TWO_BYTES( 0x6f, 0x36 ),
TWO_BYTES( 0xd4, 0xea ), TWO_BYTES( 0x9f, 0x09 ), TWO_BYTES( 0xd6, 0x29 ), TWO_BYTES( 0xb0, 0x7c ), 
TWO_BYTES( 0xaf, 0x31 ), TWO_BYTES( 0xa4, 0xb2 ), TWO_BYTES( 0x31, 0x2a ), TWO_BYTES( 0x3f, 0x23 ),
TWO_BYTES( 0x30, 0xc6 ), TWO_BYTES( 0xa5, 0x94 ), TWO_BYTES( 0xc0, 0x35 ), TWO_BYTES( 0xa2, 0x66 ), 
TWO_BYTES( 0x37, 0x74 ), TWO_BYTES( 0x4e, 0xbc ), TWO_BYTES( 0xa6, 0xfc ), TWO_BYTES( 0x82, 0xca ),
TWO_BYTES( 0xb0, 0xe0 ), TWO_BYTES( 0x90, 0xd0 ), TWO_BYTES( 0x15, 0x33 ), TWO_BYTES( 0xa7, 0xd8 ), 
TWO_BYTES( 0x4a, 0xf1 ), TWO_BYTES( 0x04, 0x98 ), TWO_BYTES( 0xf7, 0x41 ), TWO_BYTES( 0xec, 0xda ),
TWO_BYTES( 0x0e, 0x7f ), TWO_BYTES( 0xcd, 0x50 ), TWO_BYTES( 0x2f, 0x17 ), TWO_BYTES( 0x91, 0xf6 ), 
TWO_BYTES( 0x8d, 0x76 ), TWO_BYTES( 0x4d, 0xd6 ), TWO_BYTES( 0x4d, 0x43 ), TWO_BYTES( 0xef, 0xb0 ),
TWO_BYTES( 0x54, 0xcc ), TWO_BYTES( 0xaa, 0x4d ), TWO_BYTES( 0xdf, 0xe4 ), TWO_BYTES( 0x96, 0x04 ), 
TWO_BYTES( 0xe3, 0x9e ), TWO_BYTES( 0xd1, 0xb5 ), TWO_BYTES( 0x1b, 0x4c ), TWO_BYTES( 0x6a, 0x88 ),
TWO_BYTES( 0xb8, 0xc1 ), TWO_BYTES( 0x2c, 0x1f ), TWO_BYTES( 0x7f, 0x46 ), TWO_BYTES( 0x65, 0x51 ), 
TWO_BYTES( 0x04, 0x9d ), TWO_BYTES( 0x5e, 0xea ), TWO_BYTES( 0x5d, 0x01 ), TWO_BYTES( 0x8c, 0x35 ),
TWO_BYTES( 0x73, 0xfa ), TWO_BYTES( 0x87, 0x74 ), TWO_BYTES( 0x2e, 0xfb ), TWO_BYTES( 0x0b, 0x41 ), 
TWO_BYTES( 0x5a, 0xb3 ), TWO_BYTES( 0x67, 0x1d ), TWO_BYTES( 0x52, 0x92 ), TWO_BYTES( 0xdb, 0xd2 ),
TWO_BYTES( 0x33, 0xe9 ), TWO_BYTES( 0x10, 0x56 ), TWO_BYTES( 0x13, 0x6d ), TWO_BYTES( 0xd6, 0x47 ), 
TWO_BYTES( 0x8c, 0x9a ), TWO_BYTES( 0xd7, 0x61 ), TWO_BYTES( 0x7a, 0x37 ), TWO_BYTES( 0xa1, 0x0c ),
TWO_BYTES( 0x8e, 0x59 ), TWO_BYTES( 0xf8, 0x14 ), TWO_BYTES( 0x89, 0xeb ), TWO_BYTES( 0x13, 0x3c ), 
TWO_BYTES( 0xee, 0xce ), TWO_BYTES( 0xa9, 0x27 ), TWO_BYTES( 0x35, 0xb7 ), TWO_BYTES( 0x61, 0xc9 ),
TWO_BYTES( 0xed, 0xe1 ), TWO_BYTES( 0x1c, 0xe5 ), TWO_BYTES( 0x3c, 0x7a ), TWO_BYTES( 0x47, 0xb1 ), 
TWO_BYTES( 0x59, 0x9c ), TWO_BYTES( 0xd2, 0xdf ), TWO_BYTES( 0x3f, 0x55 ), TWO_BYTES( 0xf2, 0x73 ),
TWO_BYTES( 0x79, 0x18 ), TWO_BYTES( 0x14, 0xce ), TWO_BYTES( 0xbf, 0x73 ), TWO_BYTES( 0xc7, 0x37 ), 
TWO_BYTES( 0xea, 0x53 ), TWO_BYTES( 0xf7, 0xcd ), TWO_BYTES( 0x5b, 0x5f ), TWO_BYTES( 0xfd, 0xaa ),
TWO_BYTES( 0x14, 0xdf ), TWO_BYTES( 0x3d, 0x6f ), TWO_BYTES( 0x86, 0x78 ), TWO_BYTES( 0x44, 0xdb ), 
TWO_BYTES( 0x81, 0xca ), TWO_BYTES( 0xaf, 0xf3 ), TWO_BYTES( 0x3e, 0xb9 ), TWO_BYTES( 0x68, 0xc4 ),
TWO_BYTES( 0x2c, 0x38 ), TWO_BYTES( 0x24, 0x34 ), TWO_BYTES( 0x5f, 0xc2 ), TWO_BYTES( 0xa3, 0x40 ), 
TWO_BYTES( 0x72, 0x16 ), TWO_BYTES( 0x1d, 0xc3 ), TWO_BYTES( 0x0c, 0xbc ), TWO_BYTES( 0xe2, 0x25 ),
TWO_BYTES( 0x8b, 0x28 ), TWO_BYTES( 0x3c, 0x49 ), TWO_BYTES( 0x41, 0xff ), TWO_BYTES( 0x0d, 0x95 ), 
TWO_BYTES( 0x71, 0x39 ), TWO_BYTES( 0xa8, 0x01 ), TWO_BYTES( 0xde, 0x08 ), TWO_BYTES( 0x0c, 0xb3 ),
TWO_BYTES( 0x9c, 0xd8 ), TWO_BYTES( 0xb4, 0xe4 ), TWO_BYTES( 0x90, 0x64 ), TWO_BYTES( 0x56, 0xc1 ), 
TWO_BYTES( 0x61, 0x7b ), TWO_BYTES( 0xcb, 0x84 ), TWO_BYTES( 0x70, 0xd5 ), TWO_BYTES( 0x32, 0xb6 ),
TWO_BYTES( 0x74, 0x48 ), TWO_BYTES( 0x6c, 0x5c ), TWO_BYTES( 0x42, 0xd0 ), TWO_BYTES( 0xb8, 0x57 )
};

const DRM_DWORD_ALIGN DRM_BYTE T7[256][__CB_DECL( 4 )] = 
{
TWO_BYTES( 0xa7, 0x50 ), TWO_BYTES( 0x51, 0xf4 ), TWO_BYTES( 0x65, 0x53 ), TWO_BYTES( 0x7e, 0x41 ),
TWO_BYTES( 0xa4, 0xc3 ), TWO_BYTES( 0x1a, 0x17 ), TWO_BYTES( 0x5e, 0x96 ), TWO_BYTES( 0x3a, 0x27 ), 
TWO_BYTES( 0x6b, 0xcb ), TWO_BYTES( 0x3b, 0xab ), TWO_BYTES( 0x45, 0xf1 ), TWO_BYTES( 0x1f, 0x9d ),
TWO_BYTES( 0x58, 0xab ), TWO_BYTES( 0xac, 0xfa ), TWO_BYTES( 0x03, 0x93 ), TWO_BYTES( 0x4b, 0xe3 ), 
TWO_BYTES( 0xfa, 0x55 ), TWO_BYTES( 0x20, 0x30 ), TWO_BYTES( 0x6d, 0xf6 ), TWO_BYTES( 0xad, 0x76 ),
TWO_BYTES( 0x76, 0x91 ), TWO_BYTES( 0x88, 0xcc ), TWO_BYTES( 0x4c, 0x25 ), TWO_BYTES( 0xf5, 0x02 ), 
TWO_BYTES( 0xd7, 0xfc ), TWO_BYTES( 0x4f, 0xe5 ), TWO_BYTES( 0xcb, 0xd7 ), TWO_BYTES( 0xc5, 0x2a ),
TWO_BYTES( 0x44, 0x80 ), TWO_BYTES( 0x26, 0x35 ), TWO_BYTES( 0xa3, 0x8f ), TWO_BYTES( 0xb5, 0x62 ), 
TWO_BYTES( 0x5a, 0x49 ), TWO_BYTES( 0xde, 0xb1 ), TWO_BYTES( 0x1b, 0x67 ), TWO_BYTES( 0x25, 0xba ),
TWO_BYTES( 0x0e, 0x98 ), TWO_BYTES( 0x45, 0xea ), TWO_BYTES( 0xc0, 0xe1 ), TWO_BYTES( 0x5d, 0xfe ), 
TWO_BYTES( 0x75, 0x02 ), TWO_BYTES( 0xc3, 0x2f ), TWO_BYTES( 0xf0, 0x12 ), TWO_BYTES( 0x81, 0x4c ),
TWO_BYTES( 0x97, 0xa3 ), TWO_BYTES( 0x8d, 0x46 ), TWO_BYTES( 0xf9, 0xc6 ), TWO_BYTES( 0x6b, 0xd3 ), 
TWO_BYTES( 0x5f, 0xe7 ), TWO_BYTES( 0x03, 0x8f ), TWO_BYTES( 0x9c, 0x95 ), TWO_BYTES( 0x15, 0x92 ),
TWO_BYTES( 0x7a, 0xeb ), TWO_BYTES( 0xbf, 0x6d ), TWO_BYTES( 0x59, 0xda ), TWO_BYTES( 0x95, 0x52 ), 
TWO_BYTES( 0x83, 0x2d ), TWO_BYTES( 0xd4, 0xbe ), TWO_BYTES( 0x21, 0xd3 ), TWO_BYTES( 0x58, 0x74 ),
TWO_BYTES( 0x69, 0x29 ), TWO_BYTES( 0x49, 0xe0 ), TWO_BYTES( 0xc8, 0x44 ), TWO_BYTES( 0x8e, 0xc9 ), 
TWO_BYTES( 0x89, 0x6a ), TWO_BYTES( 0x75, 0xc2 ), TWO_BYTES( 0x79, 0x78 ), TWO_BYTES( 0xf4, 0x8e ),
TWO_BYTES( 0x3e, 0x6b ), TWO_BYTES( 0x99, 0x58 ), TWO_BYTES( 0x71, 0xdd ), TWO_BYTES( 0x27, 0xb9 ), 
TWO_BYTES( 0x4f, 0xb6 ), TWO_BYTES( 0xbe, 0xe1 ), TWO_BYTES( 0xad, 0x17 ), TWO_BYTES( 0xf0, 0x88 ),
TWO_BYTES( 0xac, 0x66 ), TWO_BYTES( 0xc9, 0x20 ), TWO_BYTES( 0x3a, 0xb4 ), TWO_BYTES( 0x7d, 0xce ), 
TWO_BYTES( 0x4a, 0x18 ), TWO_BYTES( 0x63, 0xdf ), TWO_BYTES( 0x31, 0x82 ), TWO_BYTES( 0xe5, 0x1a ),
TWO_BYTES( 0x33, 0x60 ), TWO_BYTES( 0x97, 0x51 ), TWO_BYTES( 0x7f, 0x45 ), TWO_BYTES( 0x62, 0x53 ), 
TWO_BYTES( 0x77, 0xe0 ), TWO_BYTES( 0xb1, 0x64 ), TWO_BYTES( 0xae, 0x84 ), TWO_BYTES( 0xbb, 0x6b ),
TWO_BYTES( 0xa0, 0x1c ), TWO_BYTES( 0xfe, 0x81 ), TWO_BYTES( 0x2b, 0x94 ), TWO_BYTES( 0xf9, 0x08 ), 
TWO_BYTES( 0x68, 0x58 ), TWO_BYTES( 0x70, 0x48 ), TWO_BYTES( 0xfd, 0x19 ), TWO_BYTES( 0x8f, 0x45 ),
TWO_BYTES( 0x6c, 0x87 ), TWO_BYTES( 0x94, 0xde ), TWO_BYTES( 0xf8, 0xb7 ), TWO_BYTES( 0x52, 0x7b ), 
TWO_BYTES( 0xd3, 0x23 ), TWO_BYTES( 0xab, 0x73 ), TWO_BYTES( 0x02, 0xe2 ), TWO_BYTES( 0x72, 0x4b ),
TWO_BYTES( 0x8f, 0x57 ), TWO_BYTES( 0xe3, 0x1f ), TWO_BYTES( 0xab, 0x2a ), TWO_BYTES( 0x66, 0x55 ), 
TWO_BYTES( 0x28, 0x07 ), TWO_BYTES( 0xb2, 0xeb ), TWO_BYTES( 0xc2, 0x03 ), TWO_BYTES( 0x2f, 0xb5 ),
TWO_BYTES( 0x7b, 0x9a ), TWO_BYTES( 0x86, 0xc5 ), TWO_BYTES( 0x08, 0xa5 ), TWO_BYTES( 0xd3, 0x37 ), 
TWO_BYTES( 0x87, 0xf2 ), TWO_BYTES( 0x30, 0x28 ), TWO_BYTES( 0xa5, 0xb2 ), TWO_BYTES( 0x23, 0xbf ),
TWO_BYTES( 0x6a, 0xba ), TWO_BYTES( 0x02, 0x03 ), TWO_BYTES( 0x82, 0x5c ), TWO_BYTES( 0xed, 0x16 ), 
TWO_BYTES( 0x1c, 0x2b ), TWO_BYTES( 0x8a, 0xcf ), TWO_BYTES( 0xb4, 0x92 ), TWO_BYTES( 0xa7, 0x79 ),
TWO_BYTES( 0xf2, 0xf0 ), TWO_BYTES( 0xf3, 0x07 ), TWO_BYTES( 0xe2, 0xa1 ), TWO_BYTES( 0x4e, 0x69 ), 
TWO_BYTES( 0xf4, 0xcd ), TWO_BYTES( 0x65, 0xda ), TWO_BYTES( 0xbe, 0xd5 ), TWO_BYTES( 0x06, 0x05 ),
TWO_BYTES( 0x62, 0x1f ), TWO_BYTES( 0xd1, 0x34 ), TWO_BYTES( 0xfe, 0x8a ), TWO_BYTES( 0xc4, 0xa6 ), 
TWO_BYTES( 0x53, 0x9d ), TWO_BYTES( 0x34, 0x2e ), TWO_BYTES( 0x55, 0xa0 ), TWO_BYTES( 0xa2, 0xf3 ),
TWO_BYTES( 0xe1, 0x32 ), TWO_BYTES( 0x05, 0x8a ), TWO_BYTES( 0xeb, 0x75 ), TWO_BYTES( 0xa4, 0xf6 ), 
TWO_BYTES( 0xec, 0x39 ), TWO_BYTES( 0x0b, 0x83 ), TWO_BYTES( 0xef, 0xaa ), TWO_BYTES( 0x40, 0x60 ),
TWO_BYTES( 0x9f, 0x06 ), TWO_BYTES( 0x5e, 0x71 ), TWO_BYTES( 0x10, 0x51 ), TWO_BYTES( 0xbd, 0x6e ), 
TWO_BYTES( 0x8a, 0xf9 ), TWO_BYTES( 0x3e, 0x21 ), TWO_BYTES( 0x06, 0x3d ), TWO_BYTES( 0x96, 0xdd ),
TWO_BYTES( 0x05, 0xae ), TWO_BYTES( 0xdd, 0x3e ), TWO_BYTES( 0xbd, 0x46 ), TWO_BYTES( 0x4d, 0xe6 ), 
TWO_BYTES( 0x8d, 0xb5 ), TWO_BYTES( 0x91, 0x54 ), TWO_BYTES( 0x5d, 0x05 ), TWO_BYTES( 0x71, 0xc4 ),
TWO_BYTES( 0xd4, 0x6f ), TWO_BYTES( 0x04, 0x06 ), TWO_BYTES( 0x15, 0xff ), TWO_BYTES( 0x60, 0x50 ), 
TWO_BYTES( 0xfb, 0x24 ), TWO_BYTES( 0x19, 0x98 ), TWO_BYTES( 0xe9, 0x97 ), TWO_BYTES( 0xd6, 0xbd ),
TWO_BYTES( 0x43, 0xcc ), TWO_BYTES( 0x89, 0x40 ), TWO_BYTES( 0x9e, 0x77 ), TWO_BYTES( 0x67, 0xd9 ), 
TWO_BYTES( 0x42, 0xbd ), TWO_BYTES( 0xb0, 0xe8 ), TWO_BYTES( 0x8b, 0x88 ), TWO_BYTES( 0x07, 0x89 ),
TWO_BYTES( 0x5b, 0x38 ), TWO_BYTES( 0xe7, 0x19 ), TWO_BYTES( 0xee, 0xdb ), TWO_BYTES( 0x79, 0xc8 ), 
TWO_BYTES( 0x0a, 0x47 ), TWO_BYTES( 0xa1, 0x7c ), TWO_BYTES( 0x0f, 0xe9 ), TWO_BYTES( 0x7c, 0x42 ),
TWO_BYTES( 0x1e, 0xc9 ), TWO_BYTES( 0xf8, 0x84 ), TWO_BYTES( 0x00, 0x00 ), TWO_BYTES( 0x00, 0x00 ), 
TWO_BYTES( 0x86, 0x83 ), TWO_BYTES( 0x09, 0x80 ), TWO_BYTES( 0xed, 0x48 ), TWO_BYTES( 0x32, 0x2b ),
TWO_BYTES( 0x70, 0xac ), TWO_BYTES( 0x1e, 0x11 ), TWO_BYTES( 0x72, 0x4e ), TWO_BYTES( 0x6c, 0x5a ), 
TWO_BYTES( 0xff, 0xfb ), TWO_BYTES( 0xfd, 0x0e ), TWO_BYTES( 0x38, 0x56 ), TWO_BYTES( 0x0f, 0x85 ),
TWO_BYTES( 0xd5, 0x1e ), TWO_BYTES( 0x3d, 0xae ), TWO_BYTES( 0x39, 0x27 ), TWO_BYTES( 0x36, 0x2d ), 
TWO_BYTES( 0xd9, 0x64 ), TWO_BYTES( 0x0a, 0x0f ), TWO_BYTES( 0xa6, 0x21 ), TWO_BYTES( 0x68, 0x5c ),
TWO_BYTES( 0x54, 0xd1 ), TWO_BYTES( 0x9b, 0x5b ), TWO_BYTES( 0x2e, 0x3a ), TWO_BYTES( 0x24, 0x36 ), 
TWO_BYTES( 0x67, 0xb1 ), TWO_BYTES( 0x0c, 0x0a ), TWO_BYTES( 0xe7, 0x0f ), TWO_BYTES( 0x93, 0x57 ),
TWO_BYTES( 0x96, 0xd2 ), TWO_BYTES( 0xb4, 0xee ), TWO_BYTES( 0x91, 0x9e ), TWO_BYTES( 0x1b, 0x9b ), 
TWO_BYTES( 0xc5, 0x4f ), TWO_BYTES( 0x80, 0xc0 ), TWO_BYTES( 0x20, 0xa2 ), TWO_BYTES( 0x61, 0xdc ),
TWO_BYTES( 0x4b, 0x69 ), TWO_BYTES( 0x5a, 0x77 ), TWO_BYTES( 0x1a, 0x16 ), TWO_BYTES( 0x1c, 0x12 ), 
TWO_BYTES( 0xba, 0x0a ), TWO_BYTES( 0xe2, 0x93 ), TWO_BYTES( 0x2a, 0xe5 ), TWO_BYTES( 0xc0, 0xa0 ),
TWO_BYTES( 0xe0, 0x43 ), TWO_BYTES( 0x3c, 0x22 ), TWO_BYTES( 0x17, 0x1d ), TWO_BYTES( 0x12, 0x1b ), 
TWO_BYTES( 0x0d, 0x0b ), TWO_BYTES( 0x0e, 0x09 ), TWO_BYTES( 0xc7, 0xad ), TWO_BYTES( 0xf2, 0x8b ),
TWO_BYTES( 0xa8, 0xb9 ), TWO_BYTES( 0x2d, 0xb6 ), TWO_BYTES( 0xa9, 0xc8 ), TWO_BYTES( 0x14, 0x1e ), 
TWO_BYTES( 0x19, 0x85 ), TWO_BYTES( 0x57, 0xf1 ), TWO_BYTES( 0x07, 0x4c ), TWO_BYTES( 0xaf, 0x75 ),
TWO_BYTES( 0xdd, 0xbb ), TWO_BYTES( 0xee, 0x99 ), TWO_BYTES( 0x60, 0xfd ), TWO_BYTES( 0xa3, 0x7f ), 
TWO_BYTES( 0x26, 0x9f ), TWO_BYTES( 0xf7, 0x01 ), TWO_BYTES( 0xf5, 0xbc ), TWO_BYTES( 0x5c, 0x72 ),
TWO_BYTES( 0x3b, 0xc5 ), TWO_BYTES( 0x44, 0x66 ), TWO_BYTES( 0x7e, 0x34 ), TWO_BYTES( 0x5b, 0xfb ), 
TWO_BYTES( 0x29, 0x76 ), TWO_BYTES( 0x8b, 0x43 ), TWO_BYTES( 0xc6, 0xdc ), TWO_BYTES( 0xcb, 0x23 ),
TWO_BYTES( 0xfc, 0x68 ), TWO_BYTES( 0xb6, 0xed ), TWO_BYTES( 0xf1, 0x63 ), TWO_BYTES( 0xb8, 0xe4 ), 
TWO_BYTES( 0xdc, 0xca ), TWO_BYTES( 0xd7, 0x31 ), TWO_BYTES( 0x85, 0x10 ), TWO_BYTES( 0x42, 0x63 ),
TWO_BYTES( 0x22, 0x40 ), TWO_BYTES( 0x13, 0x97 ), TWO_BYTES( 0x11, 0x20 ), TWO_BYTES( 0x84, 0xc6 ), 
TWO_BYTES( 0x24, 0x7d ), TWO_BYTES( 0x85, 0x4a ), TWO_BYTES( 0x3d, 0xf8 ), TWO_BYTES( 0xd2, 0xbb ),
TWO_BYTES( 0x32, 0x11 ), TWO_BYTES( 0xae, 0xf9 ), TWO_BYTES( 0xa1, 0x6d ), TWO_BYTES( 0xc7, 0x29 ), 
TWO_BYTES( 0x2f, 0x4b ), TWO_BYTES( 0x1d, 0x9e ), TWO_BYTES( 0x30, 0xf3 ), TWO_BYTES( 0xdc, 0xb2 ),
TWO_BYTES( 0x52, 0xec ), TWO_BYTES( 0x0d, 0x86 ), TWO_BYTES( 0xe3, 0xd0 ), TWO_BYTES( 0x77, 0xc1 ), 
TWO_BYTES( 0x16, 0x6c ), TWO_BYTES( 0x2b, 0xb3 ), TWO_BYTES( 0xb9, 0x99 ), TWO_BYTES( 0xa9, 0x70 ),
TWO_BYTES( 0x48, 0xfa ), TWO_BYTES( 0x11, 0x94 ), TWO_BYTES( 0x64, 0x22 ), TWO_BYTES( 0x47, 0xe9 ), 
TWO_BYTES( 0x8c, 0xc4 ), TWO_BYTES( 0xa8, 0xfc ), TWO_BYTES( 0x3f, 0x1a ), TWO_BYTES( 0xa0, 0xf0 ),
TWO_BYTES( 0x2c, 0xd8 ), TWO_BYTES( 0x56, 0x7d ), TWO_BYTES( 0x90, 0xef ), TWO_BYTES( 0x22, 0x33 ), 
TWO_BYTES( 0x4e, 0xc7 ), TWO_BYTES( 0x87, 0x49 ), TWO_BYTES( 0xd1, 0xc1 ), TWO_BYTES( 0xd9, 0x38 ),
TWO_BYTES( 0xa2, 0xfe ), TWO_BYTES( 0x8c, 0xca ), TWO_BYTES( 0x0b, 0x36 ), TWO_BYTES( 0x98, 0xd4 ), 
TWO_BYTES( 0x81, 0xcf ), TWO_BYTES( 0xa6, 0xf5 ), TWO_BYTES( 0xde, 0x28 ), TWO_BYTES( 0xa5, 0x7a ),
TWO_BYTES( 0x8e, 0x26 ), TWO_BYTES( 0xda, 0xb7 ), TWO_BYTES( 0xbf, 0xa4 ), TWO_BYTES( 0x3f, 0xad ), 
TWO_BYTES( 0x9d, 0xe4 ), TWO_BYTES( 0x2c, 0x3a ), TWO_BYTES( 0x92, 0x0d ), TWO_BYTES( 0x50, 0x78 ),
TWO_BYTES( 0xcc, 0x9b ), TWO_BYTES( 0x6a, 0x5f ), TWO_BYTES( 0x46, 0x62 ), TWO_BYTES( 0x54, 0x7e ), 
TWO_BYTES( 0x13, 0xc2 ), TWO_BYTES( 0xf6, 0x8d ), TWO_BYTES( 0xb8, 0xe8 ), TWO_BYTES( 0x90, 0xd8 ),
TWO_BYTES( 0xf7, 0x5e ), TWO_BYTES( 0x2e, 0x39 ), TWO_BYTES( 0xaf, 0xf5 ), TWO_BYTES( 0x82, 0xc3 ), 
TWO_BYTES( 0x80, 0xbe ), TWO_BYTES( 0x9f, 0x5d ), TWO_BYTES( 0x93, 0x7c ), TWO_BYTES( 0x69, 0xd0 ),
TWO_BYTES( 0x2d, 0xa9 ), TWO_BYTES( 0x6f, 0xd5 ), TWO_BYTES( 0x12, 0xb3 ), TWO_BYTES( 0xcf, 0x25 ), 
TWO_BYTES( 0x99, 0x3b ), TWO_BYTES( 0xc8, 0xac ), TWO_BYTES( 0x7d, 0xa7 ), TWO_BYTES( 0x10, 0x18 ),
TWO_BYTES( 0x63, 0x6e ), TWO_BYTES( 0xe8, 0x9c ), TWO_BYTES( 0xbb, 0x7b ), TWO_BYTES( 0xdb, 0x3b ), 
TWO_BYTES( 0x78, 0x09 ), TWO_BYTES( 0xcd, 0x26 ), TWO_BYTES( 0x18, 0xf4 ), TWO_BYTES( 0x6e, 0x59 ),
TWO_BYTES( 0xb7, 0x01 ), TWO_BYTES( 0xec, 0x9a ), TWO_BYTES( 0x9a, 0xa8 ), TWO_BYTES( 0x83, 0x4f ), 
TWO_BYTES( 0x6e, 0x65 ), TWO_BYTES( 0xe6, 0x95 ), TWO_BYTES( 0xe6, 0x7e ), TWO_BYTES( 0xaa, 0xff ),
TWO_BYTES( 0xcf, 0x08 ), TWO_BYTES( 0x21, 0xbc ), TWO_BYTES( 0xe8, 0xe6 ), TWO_BYTES( 0xef, 0x15 ), 
TWO_BYTES( 0x9b, 0xd9 ), TWO_BYTES( 0xba, 0xe7 ), TWO_BYTES( 0x36, 0xce ), TWO_BYTES( 0x4a, 0x6f ),
TWO_BYTES( 0x09, 0xd4 ), TWO_BYTES( 0xea, 0x9f ), TWO_BYTES( 0x7c, 0xd6 ), TWO_BYTES( 0x29, 0xb0 ), 
TWO_BYTES( 0xb2, 0xaf ), TWO_BYTES( 0x31, 0xa4 ), TWO_BYTES( 0x23, 0x31 ), TWO_BYTES( 0x2a, 0x3f ),
TWO_BYTES( 0x94, 0x30 ), TWO_BYTES( 0xc6, 0xa5 ), TWO_BYTES( 0x66, 0xc0 ), TWO_BYTES( 0x35, 0xa2 ), 
TWO_BYTES( 0xbc, 0x37 ), TWO_BYTES( 0x74, 0x4e ), TWO_BYTES( 0xca, 0xa6 ), TWO_BYTES( 0xfc, 0x82 ),
TWO_BYTES( 0xd0, 0xb0 ), TWO_BYTES( 0xe0, 0x90 ), TWO_BYTES( 0xd8, 0x15 ), TWO_BYTES( 0x33, 0xa7 ), 
TWO_BYTES( 0x98, 0x4a ), TWO_BYTES( 0xf1, 0x04 ), TWO_BYTES( 0xda, 0xf7 ), TWO_BYTES( 0x41, 0xec ),
TWO_BYTES( 0x50, 0x0e ), TWO_BYTES( 0x7f, 0xcd ), TWO_BYTES( 0xf6, 0x2f ), TWO_BYTES( 0x17, 0x91 ), 
TWO_BYTES( 0xd6, 0x8d ), TWO_BYTES( 0x76, 0x4d ), TWO_BYTES( 0xb0, 0x4d ), TWO_BYTES( 0x43, 0xef ),
TWO_BYTES( 0x4d, 0x54 ), TWO_BYTES( 0xcc, 0xaa ), TWO_BYTES( 0x04, 0xdf ), TWO_BYTES( 0xe4, 0x96 ), 
TWO_BYTES( 0xb5, 0xe3 ), TWO_BYTES( 0x9e, 0xd1 ), TWO_BYTES( 0x88, 0x1b ), TWO_BYTES( 0x4c, 0x6a ),
TWO_BYTES( 0x1f, 0xb8 ), TWO_BYTES( 0xc1, 0x2c ), TWO_BYTES( 0x51, 0x7f ), TWO_BYTES( 0x46, 0x65 ), 
TWO_BYTES( 0xea, 0x04 ), TWO_BYTES( 0x9d, 0x5e ), TWO_BYTES( 0x35, 0x5d ), TWO_BYTES( 0x01, 0x8c ),
TWO_BYTES( 0x74, 0x73 ), TWO_BYTES( 0xfa, 0x87 ), TWO_BYTES( 0x41, 0x2e ), TWO_BYTES( 0xfb, 0x0b ), 
TWO_BYTES( 0x1d, 0x5a ), TWO_BYTES( 0xb3, 0x67 ), TWO_BYTES( 0xd2, 0x52 ), TWO_BYTES( 0x92, 0xdb ),
TWO_BYTES( 0x56, 0x33 ), TWO_BYTES( 0xe9, 0x10 ), TWO_BYTES( 0x47, 0x13 ), TWO_BYTES( 0x6d, 0xd6 ), 
TWO_BYTES( 0x61, 0x8c ), TWO_BYTES( 0x9a, 0xd7 ), TWO_BYTES( 0x0c, 0x7a ), TWO_BYTES( 0x37, 0xa1 ),
TWO_BYTES( 0x14, 0x8e ), TWO_BYTES( 0x59, 0xf8 ), TWO_BYTES( 0x3c, 0x89 ), TWO_BYTES( 0xeb, 0x13 ), 
TWO_BYTES( 0x27, 0xee ), TWO_BYTES( 0xce, 0xa9 ), TWO_BYTES( 0xc9, 0x35 ), TWO_BYTES( 0xb7, 0x61 ),
TWO_BYTES( 0xe5, 0xed ), TWO_BYTES( 0xe1, 0x1c ), TWO_BYTES( 0xb1, 0x3c ), TWO_BYTES( 0x7a, 0x47 ), 
TWO_BYTES( 0xdf, 0x59 ), TWO_BYTES( 0x9c, 0xd2 ), TWO_BYTES( 0x73, 0x3f ), TWO_BYTES( 0x55, 0xf2 ),
TWO_BYTES( 0xce, 0x79 ), TWO_BYTES( 0x18, 0x14 ), TWO_BYTES( 0x37, 0xbf ), TWO_BYTES( 0x73, 0xc7 ), 
TWO_BYTES( 0xcd, 0xea ), TWO_BYTES( 0x53, 0xf7 ), TWO_BYTES( 0xaa, 0x5b ), TWO_BYTES( 0x5f, 0xfd ),
TWO_BYTES( 0x6f, 0x14 ), TWO_BYTES( 0xdf, 0x3d ), TWO_BYTES( 0xdb, 0x86 ), TWO_BYTES( 0x78, 0x44 ), 
TWO_BYTES( 0xf3, 0x81 ), TWO_BYTES( 0xca, 0xaf ), TWO_BYTES( 0xc4, 0x3e ), TWO_BYTES( 0xb9, 0x68 ),
TWO_BYTES( 0x34, 0x2c ), TWO_BYTES( 0x38, 0x24 ), TWO_BYTES( 0x40, 0x5f ), TWO_BYTES( 0xc2, 0xa3 ), 
TWO_BYTES( 0xc3, 0x72 ), TWO_BYTES( 0x16, 0x1d ), TWO_BYTES( 0x25, 0x0c ), TWO_BYTES( 0xbc, 0xe2 ),
TWO_BYTES( 0x49, 0x8b ), TWO_BYTES( 0x28, 0x3c ), TWO_BYTES( 0x95, 0x41 ), TWO_BYTES( 0xff, 0x0d ), 
TWO_BYTES( 0x01, 0x71 ), TWO_BYTES( 0x39, 0xa8 ), TWO_BYTES( 0xb3, 0xde ), TWO_BYTES( 0x08, 0x0c ),
TWO_BYTES( 0xe4, 0x9c ), TWO_BYTES( 0xd8, 0xb4 ), TWO_BYTES( 0xc1, 0x90 ), TWO_BYTES( 0x64, 0x56 ), 
TWO_BYTES( 0x84, 0x61 ), TWO_BYTES( 0x7b, 0xcb ), TWO_BYTES( 0xb6, 0x70 ), TWO_BYTES( 0xd5, 0x32 ),
TWO_BYTES( 0x5c, 0x74 ), TWO_BYTES( 0x48, 0x6c ), TWO_BYTES( 0x57, 0x42 ), TWO_BYTES( 0xd0, 0xb8 )
};

const DRM_DWORD_ALIGN DRM_BYTE T8[256][__CB_DECL( 4 )] = 
{
TWO_BYTES( 0xf4, 0xa7 ), TWO_BYTES( 0x50, 0x51 ), TWO_BYTES( 0x41, 0x65 ), TWO_BYTES( 0x53, 0x7e ),
TWO_BYTES( 0x17, 0xa4 ), TWO_BYTES( 0xc3, 0x1a ), TWO_BYTES( 0x27, 0x5e ), TWO_BYTES( 0x96, 0x3a ), 
TWO_BYTES( 0xab, 0x6b ), TWO_BYTES( 0xcb, 0x3b ), TWO_BYTES( 0x9d, 0x45 ), TWO_BYTES( 0xf1, 0x1f ),
TWO_BYTES( 0xfa, 0x58 ), TWO_BYTES( 0xab, 0xac ), TWO_BYTES( 0xe3, 0x03 ), TWO_BYTES( 0x93, 0x4b ), 
TWO_BYTES( 0x30, 0xfa ), TWO_BYTES( 0x55, 0x20 ), TWO_BYTES( 0x76, 0x6d ), TWO_BYTES( 0xf6, 0xad ),
TWO_BYTES( 0xcc, 0x76 ), TWO_BYTES( 0x91, 0x88 ), TWO_BYTES( 0x02, 0x4c ), TWO_BYTES( 0x25, 0xf5 ), 
TWO_BYTES( 0xe5, 0xd7 ), TWO_BYTES( 0xfc, 0x4f ), TWO_BYTES( 0x2a, 0xcb ), TWO_BYTES( 0xd7, 0xc5 ),
TWO_BYTES( 0x35, 0x44 ), TWO_BYTES( 0x80, 0x26 ), TWO_BYTES( 0x62, 0xa3 ), TWO_BYTES( 0x8f, 0xb5 ), 
TWO_BYTES( 0xb1, 0x5a ), TWO_BYTES( 0x49, 0xde ), TWO_BYTES( 0xba, 0x1b ), TWO_BYTES( 0x67, 0x25 ),
TWO_BYTES( 0xea, 0x0e ), TWO_BYTES( 0x98, 0x45 ), TWO_BYTES( 0xfe, 0xc0 ), TWO_BYTES( 0xe1, 0x5d ), 
TWO_BYTES( 0x2f, 0x75 ), TWO_BYTES( 0x02, 0xc3 ), TWO_BYTES( 0x4c, 0xf0 ), TWO_BYTES( 0x12, 0x81 ),
TWO_BYTES( 0x46, 0x97 ), TWO_BYTES( 0xa3, 0x8d ), TWO_BYTES( 0xd3, 0xf9 ), TWO_BYTES( 0xc6, 0x6b ), 
TWO_BYTES( 0x8f, 0x5f ), TWO_BYTES( 0xe7, 0x03 ), TWO_BYTES( 0x92, 0x9c ), TWO_BYTES( 0x95, 0x15 ),
TWO_BYTES( 0x6d, 0x7a ), TWO_BYTES( 0xeb, 0xbf ), TWO_BYTES( 0x52, 0x59 ), TWO_BYTES( 0xda, 0x95 ), 
TWO_BYTES( 0xbe, 0x83 ), TWO_BYTES( 0x2d, 0xd4 ), TWO_BYTES( 0x74, 0x21 ), TWO_BYTES( 0xd3, 0x58 ),
TWO_BYTES( 0xe0, 0x69 ), TWO_BYTES( 0x29, 0x49 ), TWO_BYTES( 0xc9, 0xc8 ), TWO_BYTES( 0x44, 0x8e ), 
TWO_BYTES( 0xc2, 0x89 ), TWO_BYTES( 0x6a, 0x75 ), TWO_BYTES( 0x8e, 0x79 ), TWO_BYTES( 0x78, 0xf4 ),
TWO_BYTES( 0x58, 0x3e ), TWO_BYTES( 0x6b, 0x99 ), TWO_BYTES( 0xb9, 0x71 ), TWO_BYTES( 0xdd, 0x27 ), 
TWO_BYTES( 0xe1, 0x4f ), TWO_BYTES( 0xb6, 0xbe ), TWO_BYTES( 0x88, 0xad ), TWO_BYTES( 0x17, 0xf0 ),
TWO_BYTES( 0x20, 0xac ), TWO_BYTES( 0x66, 0xc9 ), TWO_BYTES( 0xce, 0x3a ), TWO_BYTES( 0xb4, 0x7d ), 
TWO_BYTES( 0xdf, 0x4a ), TWO_BYTES( 0x18, 0x63 ), TWO_BYTES( 0x1a, 0x31 ), TWO_BYTES( 0x82, 0xe5 ),
TWO_BYTES( 0x51, 0x33 ), TWO_BYTES( 0x60, 0x97 ), TWO_BYTES( 0x53, 0x7f ), TWO_BYTES( 0x45, 0x62 ), 
TWO_BYTES( 0x64, 0x77 ), TWO_BYTES( 0xe0, 0xb1 ), TWO_BYTES( 0x6b, 0xae ), TWO_BYTES( 0x84, 0xbb ),
TWO_BYTES( 0x81, 0xa0 ), TWO_BYTES( 0x1c, 0xfe ), TWO_BYTES( 0x08, 0x2b ), TWO_BYTES( 0x94, 0xf9 ), 
TWO_BYTES( 0x48, 0x68 ), TWO_BYTES( 0x58, 0x70 ), TWO_BYTES( 0x45, 0xfd ), TWO_BYTES( 0x19, 0x8f ),
TWO_BYTES( 0xde, 0x6c ), TWO_BYTES( 0x87, 0x94 ), TWO_BYTES( 0x7b, 0xf8 ), TWO_BYTES( 0xb7, 0x52 ), 
TWO_BYTES( 0x73, 0xd3 ), TWO_BYTES( 0x23, 0xab ), TWO_BYTES( 0x4b, 0x02 ), TWO_BYTES( 0xe2, 0x72 ),
TWO_BYTES( 0x1f, 0x8f ), TWO_BYTES( 0x57, 0xe3 ), TWO_BYTES( 0x55, 0xab ), TWO_BYTES( 0x2a, 0x66 ), 
TWO_BYTES( 0xeb, 0x28 ), TWO_BYTES( 0x07, 0xb2 ), TWO_BYTES( 0xb5, 0xc2 ), TWO_BYTES( 0x03, 0x2f ),
TWO_BYTES( 0xc5, 0x7b ), TWO_BYTES( 0x9a, 0x86 ), TWO_BYTES( 0x37, 0x08 ), TWO_BYTES( 0xa5, 0xd3 ), 
TWO_BYTES( 0x28, 0x87 ), TWO_BYTES( 0xf2, 0x30 ), TWO_BYTES( 0xbf, 0xa5 ), TWO_BYTES( 0xb2, 0x23 ),
TWO_BYTES( 0x03, 0x6a ), TWO_BYTES( 0xba, 0x02 ), TWO_BYTES( 0x16, 0x82 ), TWO_BYTES( 0x5c, 0xed ), 
TWO_BYTES( 0xcf, 0x1c ), TWO_BYTES( 0x2b, 0x8a ), TWO_BYTES( 0x79, 0xb4 ), TWO_BYTES( 0x92, 0xa7 ),
TWO_BYTES( 0x07, 0xf2 ), TWO_BYTES( 0xf0, 0xf3 ), TWO_BYTES( 0x69, 0xe2 ), TWO_BYTES( 0xa1, 0x4e ), 
TWO_BYTES( 0xda, 0xf4 ), TWO_BYTES( 0xcd, 0x65 ), TWO_BYTES( 0x05, 0xbe ), TWO_BYTES( 0xd5, 0x06 ),
TWO_BYTES( 0x34, 0x62 ), TWO_BYTES( 0x1f, 0xd1 ), TWO_BYTES( 0xa6, 0xfe ), TWO_BYTES( 0x8a, 0xc4 ), 
TWO_BYTES( 0x2e, 0x53 ), TWO_BYTES( 0x9d, 0x34 ), TWO_BYTES( 0xf3, 0x55 ), TWO_BYTES( 0xa0, 0xa2 ),
TWO_BYTES( 0x8a, 0xe1 ), TWO_BYTES( 0x32, 0x05 ), TWO_BYTES( 0xf6, 0xeb ), TWO_BYTES( 0x75, 0xa4 ), 
TWO_BYTES( 0x83, 0xec ), TWO_BYTES( 0x39, 0x0b ), TWO_BYTES( 0x60, 0xef ), TWO_BYTES( 0xaa, 0x40 ),
TWO_BYTES( 0x71, 0x9f ), TWO_BYTES( 0x06, 0x5e ), TWO_BYTES( 0x6e, 0x10 ), TWO_BYTES( 0x51, 0xbd ), 
TWO_BYTES( 0x21, 0x8a ), TWO_BYTES( 0xf9, 0x3e ), TWO_BYTES( 0xdd, 0x06 ), TWO_BYTES( 0x3d, 0x96 ),
TWO_BYTES( 0x3e, 0x05 ), TWO_BYTES( 0xae, 0xdd ), TWO_BYTES( 0xe6, 0xbd ), TWO_BYTES( 0x46, 0x4d ), 
TWO_BYTES( 0x54, 0x8d ), TWO_BYTES( 0xb5, 0x91 ), TWO_BYTES( 0xc4, 0x5d ), TWO_BYTES( 0x05, 0x71 ),
TWO_BYTES( 0x06, 0xd4 ), TWO_BYTES( 0x6f, 0x04 ), TWO_BYTES( 0x50, 0x15 ), TWO_BYTES( 0xff, 0x60 ), 
TWO_BYTES( 0x98, 0xfb ), TWO_BYTES( 0x24, 0x19 ), TWO_BYTES( 0xbd, 0xe9 ), TWO_BYTES( 0x97, 0xd6 ),
TWO_BYTES( 0x40, 0x43 ), TWO_BYTES( 0xcc, 0x89 ), TWO_BYTES( 0xd9, 0x9e ), TWO_BYTES( 0x77, 0x67 ), 
TWO_BYTES( 0xe8, 0x42 ), TWO_BYTES( 0xbd, 0xb0 ), TWO_BYTES( 0x89, 0x8b ), TWO_BYTES( 0x88, 0x07 ),
TWO_BYTES( 0x19, 0x5b ), TWO_BYTES( 0x38, 0xe7 ), TWO_BYTES( 0xc8, 0xee ), TWO_BYTES( 0xdb, 0x79 ), 
TWO_BYTES( 0x7c, 0x0a ), TWO_BYTES( 0x47, 0xa1 ), TWO_BYTES( 0x42, 0x0f ), TWO_BYTES( 0xe9, 0x7c ),
TWO_BYTES( 0x84, 0x1e ), TWO_BYTES( 0xc9, 0xf8 ), TWO_BYTES( 0x00, 0x00 ), TWO_BYTES( 0x00, 0x00 ), 
TWO_BYTES( 0x80, 0x86 ), TWO_BYTES( 0x83, 0x09 ), TWO_BYTES( 0x2b, 0xed ), TWO_BYTES( 0x48, 0x32 ),
TWO_BYTES( 0x11, 0x70 ), TWO_BYTES( 0xac, 0x1e ), TWO_BYTES( 0x5a, 0x72 ), TWO_BYTES( 0x4e, 0x6c ), 
TWO_BYTES( 0x0e, 0xff ), TWO_BYTES( 0xfb, 0xfd ), TWO_BYTES( 0x85, 0x38 ), TWO_BYTES( 0x56, 0x0f ),
TWO_BYTES( 0xae, 0xd5 ), TWO_BYTES( 0x1e, 0x3d ), TWO_BYTES( 0x2d, 0x39 ), TWO_BYTES( 0x27, 0x36 ), 
TWO_BYTES( 0x0f, 0xd9 ), TWO_BYTES( 0x64, 0x0a ), TWO_BYTES( 0x5c, 0xa6 ), TWO_BYTES( 0x21, 0x68 ),
TWO_BYTES( 0x5b, 0x54 ), TWO_BYTES( 0xd1, 0x9b ), TWO_BYTES( 0x36, 0x2e ), TWO_BYTES( 0x3a, 0x24 ), 
TWO_BYTES( 0x0a, 0x67 ), TWO_BYTES( 0xb1, 0x0c ), TWO_BYTES( 0x57, 0xe7 ), TWO_BYTES( 0x0f, 0x93 ),
TWO_BYTES( 0xee, 0x96 ), TWO_BYTES( 0xd2, 0xb4 ), TWO_BYTES( 0x9b, 0x91 ), TWO_BYTES( 0x9e, 0x1b ), 
TWO_BYTES( 0xc0, 0xc5 ), TWO_BYTES( 0x4f, 0x80 ), TWO_BYTES( 0xdc, 0x20 ), TWO_BYTES( 0xa2, 0x61 ),
TWO_BYTES( 0x77, 0x4b ), TWO_BYTES( 0x69, 0x5a ), TWO_BYTES( 0x12, 0x1a ), TWO_BYTES( 0x16, 0x1c ), 
TWO_BYTES( 0x93, 0xba ), TWO_BYTES( 0x0a, 0xe2 ), TWO_BYTES( 0xa0, 0x2a ), TWO_BYTES( 0xe5, 0xc0 ),
TWO_BYTES( 0x22, 0xe0 ), TWO_BYTES( 0x43, 0x3c ), TWO_BYTES( 0x1b, 0x17 ), TWO_BYTES( 0x1d, 0x12 ), 
TWO_BYTES( 0x09, 0x0d ), TWO_BYTES( 0x0b, 0x0e ), TWO_BYTES( 0x8b, 0xc7 ), TWO_BYTES( 0xad, 0xf2 ),
TWO_BYTES( 0xb6, 0xa8 ), TWO_BYTES( 0xb9, 0x2d ), TWO_BYTES( 0x1e, 0xa9 ), TWO_BYTES( 0xc8, 0x14 ), 
TWO_BYTES( 0xf1, 0x19 ), TWO_BYTES( 0x85, 0x57 ), TWO_BYTES( 0x75, 0x07 ), TWO_BYTES( 0x4c, 0xaf ),
TWO_BYTES( 0x99, 0xdd ), TWO_BYTES( 0xbb, 0xee ), TWO_BYTES( 0x7f, 0x60 ), TWO_BYTES( 0xfd, 0xa3 ), 
TWO_BYTES( 0x01, 0x26 ), TWO_BYTES( 0x9f, 0xf7 ), TWO_BYTES( 0x72, 0xf5 ), TWO_BYTES( 0xbc, 0x5c ),
TWO_BYTES( 0x66, 0x3b ), TWO_BYTES( 0xc5, 0x44 ), TWO_BYTES( 0xfb, 0x7e ), TWO_BYTES( 0x34, 0x5b ), 
TWO_BYTES( 0x43, 0x29 ), TWO_BYTES( 0x76, 0x8b ), TWO_BYTES( 0x23, 0xc6 ), TWO_BYTES( 0xdc, 0xcb ),
TWO_BYTES( 0xed, 0xfc ), TWO_BYTES( 0x68, 0xb6 ), TWO_BYTES( 0xe4, 0xf1 ), TWO_BYTES( 0x63, 0xb8 ), 
TWO_BYTES( 0x31, 0xdc ), TWO_BYTES( 0xca, 0xd7 ), TWO_BYTES( 0x63, 0x85 ), TWO_BYTES( 0x10, 0x42 ),
TWO_BYTES( 0x97, 0x22 ), TWO_BYTES( 0x40, 0x13 ), TWO_BYTES( 0xc6, 0x11 ), TWO_BYTES( 0x20, 0x84 ), 
TWO_BYTES( 0x4a, 0x24 ), TWO_BYTES( 0x7d, 0x85 ), TWO_BYTES( 0xbb, 0x3d ), TWO_BYTES( 0xf8, 0xd2 ),
TWO_BYTES( 0xf9, 0x32 ), TWO_BYTES( 0x11, 0xae ), TWO_BYTES( 0x29, 0xa1 ), TWO_BYTES( 0x6d, 0xc7 ), 
TWO_BYTES( 0x9e, 0x2f ), TWO_BYTES( 0x4b, 0x1d ), TWO_BYTES( 0xb2, 0x30 ), TWO_BYTES( 0xf3, 0xdc ),
TWO_BYTES( 0x86, 0x52 ), TWO_BYTES( 0xec, 0x0d ), TWO_BYTES( 0xc1, 0xe3 ), TWO_BYTES( 0xd0, 0x77 ), 
TWO_BYTES( 0xb3, 0x16 ), TWO_BYTES( 0x6c, 0x2b ), TWO_BYTES( 0x70, 0xb9 ), TWO_BYTES( 0x99, 0xa9 ),
TWO_BYTES( 0x94, 0x48 ), TWO_BYTES( 0xfa, 0x11 ), TWO_BYTES( 0xe9, 0x64 ), TWO_BYTES( 0x22, 0x47 ), 
TWO_BYTES( 0xfc, 0x8c ), TWO_BYTES( 0xc4, 0xa8 ), TWO_BYTES( 0xf0, 0x3f ), TWO_BYTES( 0x1a, 0xa0 ),
TWO_BYTES( 0x7d, 0x2c ), TWO_BYTES( 0xd8, 0x56 ), TWO_BYTES( 0x33, 0x90 ), TWO_BYTES( 0xef, 0x22 ), 
TWO_BYTES( 0x49, 0x4e ), TWO_BYTES( 0xc7, 0x87 ), TWO_BYTES( 0x38, 0xd1 ), TWO_BYTES( 0xc1, 0xd9 ),
TWO_BYTES( 0xca, 0xa2 ), TWO_BYTES( 0xfe, 0x8c ), TWO_BYTES( 0xd4, 0x0b ), TWO_BYTES( 0x36, 0x98 ), 
TWO_BYTES( 0xf5, 0x81 ), TWO_BYTES( 0xcf, 0xa6 ), TWO_BYTES( 0x7a, 0xde ), TWO_BYTES( 0x28, 0xa5 ),
TWO_BYTES( 0xb7, 0x8e ), TWO_BYTES( 0x26, 0xda ), TWO_BYTES( 0xad, 0xbf ), TWO_BYTES( 0xa4, 0x3f ), 
TWO_BYTES( 0x3a, 0x9d ), TWO_BYTES( 0xe4, 0x2c ), TWO_BYTES( 0x78, 0x92 ), TWO_BYTES( 0x0d, 0x50 ),
TWO_BYTES( 0x5f, 0xcc ), TWO_BYTES( 0x9b, 0x6a ), TWO_BYTES( 0x7e, 0x46 ), TWO_BYTES( 0x62, 0x54 ), 
TWO_BYTES( 0x8d, 0x13 ), TWO_BYTES( 0xc2, 0xf6 ), TWO_BYTES( 0xd8, 0xb8 ), TWO_BYTES( 0xe8, 0x90 ),
TWO_BYTES( 0x39, 0xf7 ), TWO_BYTES( 0x5e, 0x2e ), TWO_BYTES( 0xc3, 0xaf ), TWO_BYTES( 0xf5, 0x82 ), 
TWO_BYTES( 0x5d, 0x80 ), TWO_BYTES( 0xbe, 0x9f ), TWO_BYTES( 0xd0, 0x93 ), TWO_BYTES( 0x7c, 0x69 ),
TWO_BYTES( 0xd5, 0x2d ), TWO_BYTES( 0xa9, 0x6f ), TWO_BYTES( 0x25, 0x12 ), TWO_BYTES( 0xb3, 0xcf ), 
TWO_BYTES( 0xac, 0x99 ), TWO_BYTES( 0x3b, 0xc8 ), TWO_BYTES( 0x18, 0x7d ), TWO_BYTES( 0xa7, 0x10 ),
TWO_BYTES( 0x9c, 0x63 ), TWO_BYTES( 0x6e, 0xe8 ), TWO_BYTES( 0x3b, 0xbb ), TWO_BYTES( 0x7b, 0xdb ), 
TWO_BYTES( 0x26, 0x78 ), TWO_BYTES( 0x09, 0xcd ), TWO_BYTES( 0x59, 0x18 ), TWO_BYTES( 0xf4, 0x6e ),
TWO_BYTES( 0x9a, 0xb7 ), TWO_BYTES( 0x01, 0xec ), TWO_BYTES( 0x4f, 0x9a ), TWO_BYTES( 0xa8, 0x83 ), 
TWO_BYTES( 0x95, 0x6e ), TWO_BYTES( 0x65, 0xe6 ), TWO_BYTES( 0xff, 0xe6 ), TWO_BYTES( 0x7e, 0xaa ),
TWO_BYTES( 0xbc, 0xcf ), TWO_BYTES( 0x08, 0x21 ), TWO_BYTES( 0x15, 0xe8 ), TWO_BYTES( 0xe6, 0xef ), 
TWO_BYTES( 0xe7, 0x9b ), TWO_BYTES( 0xd9, 0xba ), TWO_BYTES( 0x6f, 0x36 ), TWO_BYTES( 0xce, 0x4a ),
TWO_BYTES( 0x9f, 0x09 ), TWO_BYTES( 0xd4, 0xea ), TWO_BYTES( 0xb0, 0x7c ), TWO_BYTES( 0xd6, 0x29 ), 
TWO_BYTES( 0xa4, 0xb2 ), TWO_BYTES( 0xaf, 0x31 ), TWO_BYTES( 0x3f, 0x23 ), TWO_BYTES( 0x31, 0x2a ),
TWO_BYTES( 0xa5, 0x94 ), TWO_BYTES( 0x30, 0xc6 ), TWO_BYTES( 0xa2, 0x66 ), TWO_BYTES( 0xc0, 0x35 ), 
TWO_BYTES( 0x4e, 0xbc ), TWO_BYTES( 0x37, 0x74 ), TWO_BYTES( 0x82, 0xca ), TWO_BYTES( 0xa6, 0xfc ),
TWO_BYTES( 0x90, 0xd0 ), TWO_BYTES( 0xb0, 0xe0 ), TWO_BYTES( 0xa7, 0xd8 ), TWO_BYTES( 0x15, 0x33 ), 
TWO_BYTES( 0x04, 0x98 ), TWO_BYTES( 0x4a, 0xf1 ), TWO_BYTES( 0xec, 0xda ), TWO_BYTES( 0xf7, 0x41 ),
TWO_BYTES( 0xcd, 0x50 ), TWO_BYTES( 0x0e, 0x7f ), TWO_BYTES( 0x91, 0xf6 ), TWO_BYTES( 0x2f, 0x17 ), 
TWO_BYTES( 0x4d, 0xd6 ), TWO_BYTES( 0x8d, 0x76 ), TWO_BYTES( 0xef, 0xb0 ), TWO_BYTES( 0x4d, 0x43 ),
TWO_BYTES( 0xaa, 0x4d ), TWO_BYTES( 0x54, 0xcc ), TWO_BYTES( 0x96, 0x04 ), TWO_BYTES( 0xdf, 0xe4 ), 
TWO_BYTES( 0xd1, 0xb5 ), TWO_BYTES( 0xe3, 0x9e ), TWO_BYTES( 0x6a, 0x88 ), TWO_BYTES( 0x1b, 0x4c ),
TWO_BYTES( 0x2c, 0x1f ), TWO_BYTES( 0xb8, 0xc1 ), TWO_BYTES( 0x65, 0x51 ), TWO_BYTES( 0x7f, 0x46 ), 
TWO_BYTES( 0x5e, 0xea ), TWO_BYTES( 0x04, 0x9d ), TWO_BYTES( 0x8c, 0x35 ), TWO_BYTES( 0x5d, 0x01 ),
TWO_BYTES( 0x87, 0x74 ), TWO_BYTES( 0x73, 0xfa ), TWO_BYTES( 0x0b, 0x41 ), TWO_BYTES( 0x2e, 0xfb ), 
TWO_BYTES( 0x67, 0x1d ), TWO_BYTES( 0x5a, 0xb3 ), TWO_BYTES( 0xdb, 0xd2 ), TWO_BYTES( 0x52, 0x92 ),
TWO_BYTES( 0x10, 0x56 ), TWO_BYTES( 0x33, 0xe9 ), TWO_BYTES( 0xd6, 0x47 ), TWO_BYTES( 0x13, 0x6d ), 
TWO_BYTES( 0xd7, 0x61 ), TWO_BYTES( 0x8c, 0x9a ), TWO_BYTES( 0xa1, 0x0c ), TWO_BYTES( 0x7a, 0x37 ),
TWO_BYTES( 0xf8, 0x14 ), TWO_BYTES( 0x8e, 0x59 ), TWO_BYTES( 0x13, 0x3c ), TWO_BYTES( 0x89, 0xeb ), 
TWO_BYTES( 0xa9, 0x27 ), TWO_BYTES( 0xee, 0xce ), TWO_BYTES( 0x61, 0xc9 ), TWO_BYTES( 0x35, 0xb7 ),
TWO_BYTES( 0x1c, 0xe5 ), TWO_BYTES( 0xed, 0xe1 ), TWO_BYTES( 0x47, 0xb1 ), TWO_BYTES( 0x3c, 0x7a ), 
TWO_BYTES( 0xd2, 0xdf ), TWO_BYTES( 0x59, 0x9c ), TWO_BYTES( 0xf2, 0x73 ), TWO_BYTES( 0x3f, 0x55 ),
TWO_BYTES( 0x14, 0xce ), TWO_BYTES( 0x79, 0x18 ), TWO_BYTES( 0xc7, 0x37 ), TWO_BYTES( 0xbf, 0x73 ), 
TWO_BYTES( 0xf7, 0xcd ), TWO_BYTES( 0xea, 0x53 ), TWO_BYTES( 0xfd, 0xaa ), TWO_BYTES( 0x5b, 0x5f ),
TWO_BYTES( 0x3d, 0x6f ), TWO_BYTES( 0x14, 0xdf ), TWO_BYTES( 0x44, 0xdb ), TWO_BYTES( 0x86, 0x78 ), 
TWO_BYTES( 0xaf, 0xf3 ), TWO_BYTES( 0x81, 0xca ), TWO_BYTES( 0x68, 0xc4 ), TWO_BYTES( 0x3e, 0xb9 ),
TWO_BYTES( 0x24, 0x34 ), TWO_BYTES( 0x2c, 0x38 ), TWO_BYTES( 0xa3, 0x40 ), TWO_BYTES( 0x5f, 0xc2 ), 
TWO_BYTES( 0x1d, 0xc3 ), TWO_BYTES( 0x72, 0x16 ), TWO_BYTES( 0xe2, 0x25 ), TWO_BYTES( 0x0c, 0xbc ),
TWO_BYTES( 0x3c, 0x49 ), TWO_BYTES( 0x8b, 0x28 ), TWO_BYTES( 0x0d, 0x95 ), TWO_BYTES( 0x41, 0xff ), 
TWO_BYTES( 0xa8, 0x01 ), TWO_BYTES( 0x71, 0x39 ), TWO_BYTES( 0x0c, 0xb3 ), TWO_BYTES( 0xde, 0x08 ),
TWO_BYTES( 0xb4, 0xe4 ), TWO_BYTES( 0x9c, 0xd8 ), TWO_BYTES( 0x56, 0xc1 ), TWO_BYTES( 0x90, 0x64 ), 
TWO_BYTES( 0xcb, 0x84 ), TWO_BYTES( 0x61, 0x7b ), TWO_BYTES( 0x32, 0xb6 ), TWO_BYTES( 0x70, 0xd5 ),
TWO_BYTES( 0x6c, 0x5c ), TWO_BYTES( 0x74, 0x48 ), TWO_BYTES( 0xb8, 0x57 ), TWO_BYTES( 0x42, 0xd0 )
};

const DRM_BYTE S5[__CB_DECL( 256 )] = 
{
TWO_BYTES( 0x52, 0x09 ), TWO_BYTES( 0x6a, 0xd5 ),
TWO_BYTES( 0x30, 0x36 ), TWO_BYTES( 0xa5, 0x38 ),
TWO_BYTES( 0xbf, 0x40 ), TWO_BYTES( 0xa3, 0x9e ),
TWO_BYTES( 0x81, 0xf3 ), TWO_BYTES( 0xd7, 0xfb ),
TWO_BYTES( 0x7c, 0xe3 ), TWO_BYTES( 0x39, 0x82 ),
TWO_BYTES( 0x9b, 0x2f ), TWO_BYTES( 0xff, 0x87 ),
TWO_BYTES( 0x34, 0x8e ), TWO_BYTES( 0x43, 0x44 ),
TWO_BYTES( 0xc4, 0xde ), TWO_BYTES( 0xe9, 0xcb ),
TWO_BYTES( 0x54, 0x7b ), TWO_BYTES( 0x94, 0x32 ),
TWO_BYTES( 0xa6, 0xc2 ), TWO_BYTES( 0x23, 0x3d ),
TWO_BYTES( 0xee, 0x4c ), TWO_BYTES( 0x95, 0x0b ),
TWO_BYTES( 0x42, 0xfa ), TWO_BYTES( 0xc3, 0x4e ),
TWO_BYTES( 0x08, 0x2e ), TWO_BYTES( 0xa1, 0x66 ),
TWO_BYTES( 0x28, 0xd9 ), TWO_BYTES( 0x24, 0xb2 ),
TWO_BYTES( 0x76, 0x5b ), TWO_BYTES( 0xa2, 0x49 ),
TWO_BYTES( 0x6d, 0x8b ), TWO_BYTES( 0xd1, 0x25 ),
TWO_BYTES( 0x72, 0xf8 ), TWO_BYTES( 0xf6, 0x64 ),
TWO_BYTES( 0x86, 0x68 ), TWO_BYTES( 0x98, 0x16 ),
TWO_BYTES( 0xd4, 0xa4 ), TWO_BYTES( 0x5c, 0xcc ),
TWO_BYTES( 0x5d, 0x65 ), TWO_BYTES( 0xb6, 0x92 ),
TWO_BYTES( 0x6c, 0x70 ), TWO_BYTES( 0x48, 0x50 ),
TWO_BYTES( 0xfd, 0xed ), TWO_BYTES( 0xb9, 0xda ),
TWO_BYTES( 0x5e, 0x15 ), TWO_BYTES( 0x46, 0x57 ),
TWO_BYTES( 0xa7, 0x8d ), TWO_BYTES( 0x9d, 0x84 ),
TWO_BYTES( 0x90, 0xd8 ), TWO_BYTES( 0xab, 0x00 ),
TWO_BYTES( 0x8c, 0xbc ), TWO_BYTES( 0xd3, 0x0a ),
TWO_BYTES( 0xf7, 0xe4 ), TWO_BYTES( 0x58, 0x05 ),
TWO_BYTES( 0xb8, 0xb3 ), TWO_BYTES( 0x45, 0x06 ),
TWO_BYTES( 0xd0, 0x2c ), TWO_BYTES( 0x1e, 0x8f ),
TWO_BYTES( 0xca, 0x3f ), TWO_BYTES( 0x0f, 0x02 ),
TWO_BYTES( 0xc1, 0xaf ), TWO_BYTES( 0xbd, 0x03 ),
TWO_BYTES( 0x01, 0x13 ), TWO_BYTES( 0x8a, 0x6b ),
TWO_BYTES( 0x3a, 0x91 ), TWO_BYTES( 0x11, 0x41 ),
TWO_BYTES( 0x4f, 0x67 ), TWO_BYTES( 0xdc, 0xea ),
TWO_BYTES( 0x97, 0xf2 ), TWO_BYTES( 0xcf, 0xce ),
TWO_BYTES( 0xf0, 0xb4 ), TWO_BYTES( 0xe6, 0x73 ),
TWO_BYTES( 0x96, 0xac ), TWO_BYTES( 0x74, 0x22 ),
TWO_BYTES( 0xe7, 0xad ), TWO_BYTES( 0x35, 0x85 ),
TWO_BYTES( 0xe2, 0xf9 ), TWO_BYTES( 0x37, 0xe8 ),
TWO_BYTES( 0x1c, 0x75 ), TWO_BYTES( 0xdf, 0x6e ),
TWO_BYTES( 0x47, 0xf1 ), TWO_BYTES( 0x1a, 0x71 ),
TWO_BYTES( 0x1d, 0x29 ), TWO_BYTES( 0xc5, 0x89 ),
TWO_BYTES( 0x6f, 0xb7 ), TWO_BYTES( 0x62, 0x0e ),
TWO_BYTES( 0xaa, 0x18 ), TWO_BYTES( 0xbe, 0x1b ),
TWO_BYTES( 0xfc, 0x56 ), TWO_BYTES( 0x3e, 0x4b ),
TWO_BYTES( 0xc6, 0xd2 ), TWO_BYTES( 0x79, 0x20 ),
TWO_BYTES( 0x9a, 0xdb ), TWO_BYTES( 0xc0, 0xfe ),
TWO_BYTES( 0x78, 0xcd ), TWO_BYTES( 0x5a, 0xf4 ),
TWO_BYTES( 0x1f, 0xdd ), TWO_BYTES( 0xa8, 0x33 ),
TWO_BYTES( 0x88, 0x07 ), TWO_BYTES( 0xc7, 0x31 ),
TWO_BYTES( 0xb1, 0x12 ), TWO_BYTES( 0x10, 0x59 ),
TWO_BYTES( 0x27, 0x80 ), TWO_BYTES( 0xec, 0x5f ),
TWO_BYTES( 0x60, 0x51 ), TWO_BYTES( 0x7f, 0xa9 ),
TWO_BYTES( 0x19, 0xb5 ), TWO_BYTES( 0x4a, 0x0d ),
TWO_BYTES( 0x2d, 0xe5 ), TWO_BYTES( 0x7a, 0x9f ),
TWO_BYTES( 0x93, 0xc9 ), TWO_BYTES( 0x9c, 0xef ),
TWO_BYTES( 0xa0, 0xe0 ), TWO_BYTES( 0x3b, 0x4d ),
TWO_BYTES( 0xae, 0x2a ), TWO_BYTES( 0xf5, 0xb0 ),
TWO_BYTES( 0xc8, 0xeb ), TWO_BYTES( 0xbb, 0x3c ),
TWO_BYTES( 0x83, 0x53 ), TWO_BYTES( 0x99, 0x61 ),
TWO_BYTES( 0x17, 0x2b ), TWO_BYTES( 0x04, 0x7e ),
TWO_BYTES( 0xba, 0x77 ), TWO_BYTES( 0xd6, 0x26 ),
TWO_BYTES( 0xe1, 0x69 ), TWO_BYTES( 0x14, 0x63 ),
TWO_BYTES( 0x55, 0x21 ), TWO_BYTES( 0x0c, 0x7d )
};

const DRM_DWORD_ALIGN DRM_BYTE U1[256][__CB_DECL( 4 )] = 
{
TWO_BYTES( 0x00, 0x00 ), TWO_BYTES( 0x00, 0x00 ), TWO_BYTES( 0x0e, 0x09 ), TWO_BYTES( 0x0d, 0x0b ),
TWO_BYTES( 0x1c, 0x12 ), TWO_BYTES( 0x1a, 0x16 ), TWO_BYTES( 0x12, 0x1b ), TWO_BYTES( 0x17, 0x1d ), 
TWO_BYTES( 0x38, 0x24 ), TWO_BYTES( 0x34, 0x2c ), TWO_BYTES( 0x36, 0x2d ), TWO_BYTES( 0x39, 0x27 ),
TWO_BYTES( 0x24, 0x36 ), TWO_BYTES( 0x2e, 0x3a ), TWO_BYTES( 0x2a, 0x3f ), TWO_BYTES( 0x23, 0x31 ), 
TWO_BYTES( 0x70, 0x48 ), TWO_BYTES( 0x68, 0x58 ), TWO_BYTES( 0x7e, 0x41 ), TWO_BYTES( 0x65, 0x53 ),
TWO_BYTES( 0x6c, 0x5a ), TWO_BYTES( 0x72, 0x4e ), TWO_BYTES( 0x62, 0x53 ), TWO_BYTES( 0x7f, 0x45 ), 
TWO_BYTES( 0x48, 0x6c ), TWO_BYTES( 0x5c, 0x74 ), TWO_BYTES( 0x46, 0x65 ), TWO_BYTES( 0x51, 0x7f ),
TWO_BYTES( 0x54, 0x7e ), TWO_BYTES( 0x46, 0x62 ), TWO_BYTES( 0x5a, 0x77 ), TWO_BYTES( 0x4b, 0x69 ), 
TWO_BYTES( 0xe0, 0x90 ), TWO_BYTES( 0xd0, 0xb0 ), TWO_BYTES( 0xee, 0x99 ), TWO_BYTES( 0xdd, 0xbb ),
TWO_BYTES( 0xfc, 0x82 ), TWO_BYTES( 0xca, 0xa6 ), TWO_BYTES( 0xf2, 0x8b ), TWO_BYTES( 0xc7, 0xad ), 
TWO_BYTES( 0xd8, 0xb4 ), TWO_BYTES( 0xe4, 0x9c ), TWO_BYTES( 0xd6, 0xbd ), TWO_BYTES( 0xe9, 0x97 ),
TWO_BYTES( 0xc4, 0xa6 ), TWO_BYTES( 0xfe, 0x8a ), TWO_BYTES( 0xca, 0xaf ), TWO_BYTES( 0xf3, 0x81 ), 
TWO_BYTES( 0x90, 0xd8 ), TWO_BYTES( 0xb8, 0xe8 ), TWO_BYTES( 0x9e, 0xd1 ), TWO_BYTES( 0xb5, 0xe3 ),
TWO_BYTES( 0x8c, 0xca ), TWO_BYTES( 0xa2, 0xfe ), TWO_BYTES( 0x82, 0xc3 ), TWO_BYTES( 0xaf, 0xf5 ), 
TWO_BYTES( 0xa8, 0xfc ), TWO_BYTES( 0x8c, 0xc4 ), TWO_BYTES( 0xa6, 0xf5 ), TWO_BYTES( 0x81, 0xcf ),
TWO_BYTES( 0xb4, 0xee ), TWO_BYTES( 0x96, 0xd2 ), TWO_BYTES( 0xba, 0xe7 ), TWO_BYTES( 0x9b, 0xd9 ), 
TWO_BYTES( 0xdb, 0x3b ), TWO_BYTES( 0xbb, 0x7b ), TWO_BYTES( 0xd5, 0x32 ), TWO_BYTES( 0xb6, 0x70 ),
TWO_BYTES( 0xc7, 0x29 ), TWO_BYTES( 0xa1, 0x6d ), TWO_BYTES( 0xc9, 0x20 ), TWO_BYTES( 0xac, 0x66 ), 
TWO_BYTES( 0xe3, 0x1f ), TWO_BYTES( 0x8f, 0x57 ), TWO_BYTES( 0xed, 0x16 ), TWO_BYTES( 0x82, 0x5c ),
TWO_BYTES( 0xff, 0x0d ), TWO_BYTES( 0x95, 0x41 ), TWO_BYTES( 0xf1, 0x04 ), TWO_BYTES( 0x98, 0x4a ), 
TWO_BYTES( 0xab, 0x73 ), TWO_BYTES( 0xd3, 0x23 ), TWO_BYTES( 0xa5, 0x7a ), TWO_BYTES( 0xde, 0x28 ),
TWO_BYTES( 0xb7, 0x61 ), TWO_BYTES( 0xc9, 0x35 ), TWO_BYTES( 0xb9, 0x68 ), TWO_BYTES( 0xc4, 0x3e ), 
TWO_BYTES( 0x93, 0x57 ), TWO_BYTES( 0xe7, 0x0f ), TWO_BYTES( 0x9d, 0x5e ), TWO_BYTES( 0xea, 0x04 ),
TWO_BYTES( 0x8f, 0x45 ), TWO_BYTES( 0xfd, 0x19 ), TWO_BYTES( 0x81, 0x4c ), TWO_BYTES( 0xf0, 0x12 ), 
TWO_BYTES( 0x3b, 0xab ), TWO_BYTES( 0x6b, 0xcb ), TWO_BYTES( 0x35, 0xa2 ), TWO_BYTES( 0x66, 0xc0 ),
TWO_BYTES( 0x27, 0xb9 ), TWO_BYTES( 0x71, 0xdd ), TWO_BYTES( 0x29, 0xb0 ), TWO_BYTES( 0x7c, 0xd6 ), 
TWO_BYTES( 0x03, 0x8f ), TWO_BYTES( 0x5f, 0xe7 ), TWO_BYTES( 0x0d, 0x86 ), TWO_BYTES( 0x52, 0xec ),
TWO_BYTES( 0x1f, 0x9d ), TWO_BYTES( 0x45, 0xf1 ), TWO_BYTES( 0x11, 0x94 ), TWO_BYTES( 0x48, 0xfa ), 
TWO_BYTES( 0x4b, 0xe3 ), TWO_BYTES( 0x03, 0x93 ), TWO_BYTES( 0x45, 0xea ), TWO_BYTES( 0x0e, 0x98 ),
TWO_BYTES( 0x57, 0xf1 ), TWO_BYTES( 0x19, 0x85 ), TWO_BYTES( 0x59, 0xf8 ), TWO_BYTES( 0x14, 0x8e ), 
TWO_BYTES( 0x73, 0xc7 ), TWO_BYTES( 0x37, 0xbf ), TWO_BYTES( 0x7d, 0xce ), TWO_BYTES( 0x3a, 0xb4 ),
TWO_BYTES( 0x6f, 0xd5 ), TWO_BYTES( 0x2d, 0xa9 ), TWO_BYTES( 0x61, 0xdc ), TWO_BYTES( 0x20, 0xa2 ), 
TWO_BYTES( 0xad, 0x76 ), TWO_BYTES( 0x6d, 0xf6 ), TWO_BYTES( 0xa3, 0x7f ), TWO_BYTES( 0x60, 0xfd ),
TWO_BYTES( 0xb1, 0x64 ), TWO_BYTES( 0x77, 0xe0 ), TWO_BYTES( 0xbf, 0x6d ), TWO_BYTES( 0x7a, 0xeb ), 
TWO_BYTES( 0x95, 0x52 ), TWO_BYTES( 0x59, 0xda ), TWO_BYTES( 0x9b, 0x5b ), TWO_BYTES( 0x54, 0xd1 ),
TWO_BYTES( 0x89, 0x40 ), TWO_BYTES( 0x43, 0xcc ), TWO_BYTES( 0x87, 0x49 ), TWO_BYTES( 0x4e, 0xc7 ), 
TWO_BYTES( 0xdd, 0x3e ), TWO_BYTES( 0x05, 0xae ), TWO_BYTES( 0xd3, 0x37 ), TWO_BYTES( 0x08, 0xa5 ),
TWO_BYTES( 0xc1, 0x2c ), TWO_BYTES( 0x1f, 0xb8 ), TWO_BYTES( 0xcf, 0x25 ), TWO_BYTES( 0x12, 0xb3 ), 
TWO_BYTES( 0xe5, 0x1a ), TWO_BYTES( 0x31, 0x82 ), TWO_BYTES( 0xeb, 0x13 ), TWO_BYTES( 0x3c, 0x89 ),
TWO_BYTES( 0xf9, 0x08 ), TWO_BYTES( 0x2b, 0x94 ), TWO_BYTES( 0xf7, 0x01 ), TWO_BYTES( 0x26, 0x9f ), 
TWO_BYTES( 0x4d, 0xe6 ), TWO_BYTES( 0xbd, 0x46 ), TWO_BYTES( 0x43, 0xef ), TWO_BYTES( 0xb0, 0x4d ),
TWO_BYTES( 0x51, 0xf4 ), TWO_BYTES( 0xa7, 0x50 ), TWO_BYTES( 0x5f, 0xfd ), TWO_BYTES( 0xaa, 0x5b ), 
TWO_BYTES( 0x75, 0xc2 ), TWO_BYTES( 0x89, 0x6a ), TWO_BYTES( 0x7b, 0xcb ), TWO_BYTES( 0x84, 0x61 ),
TWO_BYTES( 0x69, 0xd0 ), TWO_BYTES( 0x93, 0x7c ), TWO_BYTES( 0x67, 0xd9 ), TWO_BYTES( 0x9e, 0x77 ), 
TWO_BYTES( 0x3d, 0xae ), TWO_BYTES( 0xd5, 0x1e ), TWO_BYTES( 0x33, 0xa7 ), TWO_BYTES( 0xd8, 0x15 ),
TWO_BYTES( 0x21, 0xbc ), TWO_BYTES( 0xcf, 0x08 ), TWO_BYTES( 0x2f, 0xb5 ), TWO_BYTES( 0xc2, 0x03 ), 
TWO_BYTES( 0x05, 0x8a ), TWO_BYTES( 0xe1, 0x32 ), TWO_BYTES( 0x0b, 0x83 ), TWO_BYTES( 0xec, 0x39 ),
TWO_BYTES( 0x19, 0x98 ), TWO_BYTES( 0xfb, 0x24 ), TWO_BYTES( 0x17, 0x91 ), TWO_BYTES( 0xf6, 0x2f ), 
TWO_BYTES( 0x76, 0x4d ), TWO_BYTES( 0xd6, 0x8d ), TWO_BYTES( 0x78, 0x44 ), TWO_BYTES( 0xdb, 0x86 ),
TWO_BYTES( 0x6a, 0x5f ), TWO_BYTES( 0xcc, 0x9b ), TWO_BYTES( 0x64, 0x56 ), TWO_BYTES( 0xc1, 0x90 ), 
TWO_BYTES( 0x4e, 0x69 ), TWO_BYTES( 0xe2, 0xa1 ), TWO_BYTES( 0x40, 0x60 ), TWO_BYTES( 0xef, 0xaa ),
TWO_BYTES( 0x52, 0x7b ), TWO_BYTES( 0xf8, 0xb7 ), TWO_BYTES( 0x5c, 0x72 ), TWO_BYTES( 0xf5, 0xbc ), 
TWO_BYTES( 0x06, 0x05 ), TWO_BYTES( 0xbe, 0xd5 ), TWO_BYTES( 0x08, 0x0c ), TWO_BYTES( 0xb3, 0xde ),
TWO_BYTES( 0x1a, 0x17 ), TWO_BYTES( 0xa4, 0xc3 ), TWO_BYTES( 0x14, 0x1e ), TWO_BYTES( 0xa9, 0xc8 ), 
TWO_BYTES( 0x3e, 0x21 ), TWO_BYTES( 0x8a, 0xf9 ), TWO_BYTES( 0x30, 0x28 ), TWO_BYTES( 0x87, 0xf2 ),
TWO_BYTES( 0x22, 0x33 ), TWO_BYTES( 0x90, 0xef ), TWO_BYTES( 0x2c, 0x3a ), TWO_BYTES( 0x9d, 0xe4 ), 
TWO_BYTES( 0x96, 0xdd ), TWO_BYTES( 0x06, 0x3d ), TWO_BYTES( 0x98, 0xd4 ), TWO_BYTES( 0x0b, 0x36 ),
TWO_BYTES( 0x8a, 0xcf ), TWO_BYTES( 0x1c, 0x2b ), TWO_BYTES( 0x84, 0xc6 ), TWO_BYTES( 0x11, 0x20 ), 
TWO_BYTES( 0xae, 0xf9 ), TWO_BYTES( 0x32, 0x11 ), TWO_BYTES( 0xa0, 0xf0 ), TWO_BYTES( 0x3f, 0x1a ),
TWO_BYTES( 0xb2, 0xeb ), TWO_BYTES( 0x28, 0x07 ), TWO_BYTES( 0xbc, 0xe2 ), TWO_BYTES( 0x25, 0x0c ), 
TWO_BYTES( 0xe6, 0x95 ), TWO_BYTES( 0x6e, 0x65 ), TWO_BYTES( 0xe8, 0x9c ), TWO_BYTES( 0x63, 0x6e ),
TWO_BYTES( 0xfa, 0x87 ), TWO_BYTES( 0x74, 0x73 ), TWO_BYTES( 0xf4, 0x8e ), TWO_BYTES( 0x79, 0x78 ), 
TWO_BYTES( 0xde, 0xb1 ), TWO_BYTES( 0x5a, 0x49 ), TWO_BYTES( 0xd0, 0xb8 ), TWO_BYTES( 0x57, 0x42 ),
TWO_BYTES( 0xc2, 0xa3 ), TWO_BYTES( 0x40, 0x5f ), TWO_BYTES( 0xcc, 0xaa ), TWO_BYTES( 0x4d, 0x54 ), 
TWO_BYTES( 0x41, 0xec ), TWO_BYTES( 0xda, 0xf7 ), TWO_BYTES( 0x4f, 0xe5 ), TWO_BYTES( 0xd7, 0xfc ),
TWO_BYTES( 0x5d, 0xfe ), TWO_BYTES( 0xc0, 0xe1 ), TWO_BYTES( 0x53, 0xf7 ), TWO_BYTES( 0xcd, 0xea ), 
TWO_BYTES( 0x79, 0xc8 ), TWO_BYTES( 0xee, 0xdb ), TWO_BYTES( 0x77, 0xc1 ), TWO_BYTES( 0xe3, 0xd0 ),
TWO_BYTES( 0x65, 0xda ), TWO_BYTES( 0xf4, 0xcd ), TWO_BYTES( 0x6b, 0xd3 ), TWO_BYTES( 0xf9, 0xc6 ), 
TWO_BYTES( 0x31, 0xa4 ), TWO_BYTES( 0xb2, 0xaf ), TWO_BYTES( 0x3f, 0xad ), TWO_BYTES( 0xbf, 0xa4 ),
TWO_BYTES( 0x2d, 0xb6 ), TWO_BYTES( 0xa8, 0xb9 ), TWO_BYTES( 0x23, 0xbf ), TWO_BYTES( 0xa5, 0xb2 ), 
TWO_BYTES( 0x09, 0x80 ), TWO_BYTES( 0x86, 0x83 ), TWO_BYTES( 0x07, 0x89 ), TWO_BYTES( 0x8b, 0x88 ),
TWO_BYTES( 0x15, 0x92 ), TWO_BYTES( 0x9c, 0x95 ), TWO_BYTES( 0x1b, 0x9b ), TWO_BYTES( 0x91, 0x9e ), 
TWO_BYTES( 0xa1, 0x7c ), TWO_BYTES( 0x0a, 0x47 ), TWO_BYTES( 0xaf, 0x75 ), TWO_BYTES( 0x07, 0x4c ),
TWO_BYTES( 0xbd, 0x6e ), TWO_BYTES( 0x10, 0x51 ), TWO_BYTES( 0xb3, 0x67 ), TWO_BYTES( 0x1d, 0x5a ), 
TWO_BYTES( 0x99, 0x58 ), TWO_BYTES( 0x3e, 0x6b ), TWO_BYTES( 0x97, 0x51 ), TWO_BYTES( 0x33, 0x60 ),
TWO_BYTES( 0x85, 0x4a ), TWO_BYTES( 0x24, 0x7d ), TWO_BYTES( 0x8b, 0x43 ), TWO_BYTES( 0x29, 0x76 ), 
TWO_BYTES( 0xd1, 0x34 ), TWO_BYTES( 0x62, 0x1f ), TWO_BYTES( 0xdf, 0x3d ), TWO_BYTES( 0x6f, 0x14 ),
TWO_BYTES( 0xcd, 0x26 ), TWO_BYTES( 0x78, 0x09 ), TWO_BYTES( 0xc3, 0x2f ), TWO_BYTES( 0x75, 0x02 ), 
TWO_BYTES( 0xe9, 0x10 ), TWO_BYTES( 0x56, 0x33 ), TWO_BYTES( 0xe7, 0x19 ), TWO_BYTES( 0x5b, 0x38 ),
TWO_BYTES( 0xf5, 0x02 ), TWO_BYTES( 0x4c, 0x25 ), TWO_BYTES( 0xfb, 0x0b ), TWO_BYTES( 0x41, 0x2e ), 
TWO_BYTES( 0x9a, 0xd7 ), TWO_BYTES( 0x61, 0x8c ), TWO_BYTES( 0x94, 0xde ), TWO_BYTES( 0x6c, 0x87 ),
TWO_BYTES( 0x86, 0xc5 ), TWO_BYTES( 0x7b, 0x9a ), TWO_BYTES( 0x88, 0xcc ), TWO_BYTES( 0x76, 0x91 ), 
TWO_BYTES( 0xa2, 0xf3 ), TWO_BYTES( 0x55, 0xa0 ), TWO_BYTES( 0xac, 0xfa ), TWO_BYTES( 0x58, 0xab ),
TWO_BYTES( 0xbe, 0xe1 ), TWO_BYTES( 0x4f, 0xb6 ), TWO_BYTES( 0xb0, 0xe8 ), TWO_BYTES( 0x42, 0xbd ), 
TWO_BYTES( 0xea, 0x9f ), TWO_BYTES( 0x09, 0xd4 ), TWO_BYTES( 0xe4, 0x96 ), TWO_BYTES( 0x04, 0xdf ),
TWO_BYTES( 0xf6, 0x8d ), TWO_BYTES( 0x13, 0xc2 ), TWO_BYTES( 0xf8, 0x84 ), TWO_BYTES( 0x1e, 0xc9 ), 
TWO_BYTES( 0xd2, 0xbb ), TWO_BYTES( 0x3d, 0xf8 ), TWO_BYTES( 0xdc, 0xb2 ), TWO_BYTES( 0x30, 0xf3 ),
TWO_BYTES( 0xce, 0xa9 ), TWO_BYTES( 0x27, 0xee ), TWO_BYTES( 0xc0, 0xa0 ), TWO_BYTES( 0x2a, 0xe5 ), 
TWO_BYTES( 0x7a, 0x47 ), TWO_BYTES( 0xb1, 0x3c ), TWO_BYTES( 0x74, 0x4e ), TWO_BYTES( 0xbc, 0x37 ),
TWO_BYTES( 0x66, 0x55 ), TWO_BYTES( 0xab, 0x2a ), TWO_BYTES( 0x68, 0x5c ), TWO_BYTES( 0xa6, 0x21 ), 
TWO_BYTES( 0x42, 0x63 ), TWO_BYTES( 0x85, 0x10 ), TWO_BYTES( 0x4c, 0x6a ), TWO_BYTES( 0x88, 0x1b ),
TWO_BYTES( 0x5e, 0x71 ), TWO_BYTES( 0x9f, 0x06 ), TWO_BYTES( 0x50, 0x78 ), TWO_BYTES( 0x92, 0x0d ), 
TWO_BYTES( 0x0a, 0x0f ), TWO_BYTES( 0xd9, 0x64 ), TWO_BYTES( 0x04, 0x06 ), TWO_BYTES( 0xd4, 0x6f ),
TWO_BYTES( 0x16, 0x1d ), TWO_BYTES( 0xc3, 0x72 ), TWO_BYTES( 0x18, 0x14 ), TWO_BYTES( 0xce, 0x79 ), 
TWO_BYTES( 0x32, 0x2b ), TWO_BYTES( 0xed, 0x48 ), TWO_BYTES( 0x3c, 0x22 ), TWO_BYTES( 0xe0, 0x43 ),
TWO_BYTES( 0x2e, 0x39 ), TWO_BYTES( 0xf7, 0x5e ), TWO_BYTES( 0x20, 0x30 ), TWO_BYTES( 0xfa, 0x55 ), 
TWO_BYTES( 0xec, 0x9a ), TWO_BYTES( 0xb7, 0x01 ), TWO_BYTES( 0xe2, 0x93 ), TWO_BYTES( 0xba, 0x0a ),
TWO_BYTES( 0xf0, 0x88 ), TWO_BYTES( 0xad, 0x17 ), TWO_BYTES( 0xfe, 0x81 ), TWO_BYTES( 0xa0, 0x1c ), 
TWO_BYTES( 0xd4, 0xbe ), TWO_BYTES( 0x83, 0x2d ), TWO_BYTES( 0xda, 0xb7 ), TWO_BYTES( 0x8e, 0x26 ),
TWO_BYTES( 0xc8, 0xac ), TWO_BYTES( 0x99, 0x3b ), TWO_BYTES( 0xc6, 0xa5 ), TWO_BYTES( 0x94, 0x30 ), 
TWO_BYTES( 0x9c, 0xd2 ), TWO_BYTES( 0xdf, 0x59 ), TWO_BYTES( 0x92, 0xdb ), TWO_BYTES( 0xd2, 0x52 ),
TWO_BYTES( 0x80, 0xc0 ), TWO_BYTES( 0xc5, 0x4f ), TWO_BYTES( 0x8e, 0xc9 ), TWO_BYTES( 0xc8, 0x44 ), 
TWO_BYTES( 0xa4, 0xf6 ), TWO_BYTES( 0xeb, 0x75 ), TWO_BYTES( 0xaa, 0xff ), TWO_BYTES( 0xe6, 0x7e ),
TWO_BYTES( 0xb8, 0xe4 ), TWO_BYTES( 0xf1, 0x63 ), TWO_BYTES( 0xb6, 0xed ), TWO_BYTES( 0xfc, 0x68 ), 
TWO_BYTES( 0x0c, 0x0a ), TWO_BYTES( 0x67, 0xb1 ), TWO_BYTES( 0x02, 0x03 ), TWO_BYTES( 0x6a, 0xba ),
TWO_BYTES( 0x10, 0x18 ), TWO_BYTES( 0x7d, 0xa7 ), TWO_BYTES( 0x1e, 0x11 ), TWO_BYTES( 0x70, 0xac ), 
TWO_BYTES( 0x34, 0x2e ), TWO_BYTES( 0x53, 0x9d ), TWO_BYTES( 0x3a, 0x27 ), TWO_BYTES( 0x5e, 0x96 ),
TWO_BYTES( 0x28, 0x3c ), TWO_BYTES( 0x49, 0x8b ), TWO_BYTES( 0x26, 0x35 ), TWO_BYTES( 0x44, 0x80 ), 
TWO_BYTES( 0x7c, 0x42 ), TWO_BYTES( 0x0f, 0xe9 ), TWO_BYTES( 0x72, 0x4b ), TWO_BYTES( 0x02, 0xe2 ),
TWO_BYTES( 0x60, 0x50 ), TWO_BYTES( 0x15, 0xff ), TWO_BYTES( 0x6e, 0x59 ), TWO_BYTES( 0x18, 0xf4 ), 
TWO_BYTES( 0x44, 0x66 ), TWO_BYTES( 0x3b, 0xc5 ), TWO_BYTES( 0x4a, 0x6f ), TWO_BYTES( 0x36, 0xce ),
TWO_BYTES( 0x58, 0x74 ), TWO_BYTES( 0x21, 0xd3 ), TWO_BYTES( 0x56, 0x7d ), TWO_BYTES( 0x2c, 0xd8 ), 
TWO_BYTES( 0x37, 0xa1 ), TWO_BYTES( 0x0c, 0x7a ), TWO_BYTES( 0x39, 0xa8 ), TWO_BYTES( 0x01, 0x71 ),
TWO_BYTES( 0x2b, 0xb3 ), TWO_BYTES( 0x16, 0x6c ), TWO_BYTES( 0x25, 0xba ), TWO_BYTES( 0x1b, 0x67 ), 
TWO_BYTES( 0x0f, 0x85 ), TWO_BYTES( 0x38, 0x56 ), TWO_BYTES( 0x01, 0x8c ), TWO_BYTES( 0x35, 0x5d ),
TWO_BYTES( 0x13, 0x97 ), TWO_BYTES( 0x22, 0x40 ), TWO_BYTES( 0x1d, 0x9e ), TWO_BYTES( 0x2f, 0x4b ), 
TWO_BYTES( 0x47, 0xe9 ), TWO_BYTES( 0x64, 0x22 ), TWO_BYTES( 0x49, 0xe0 ), TWO_BYTES( 0x69, 0x29 ),
TWO_BYTES( 0x5b, 0xfb ), TWO_BYTES( 0x7e, 0x34 ), TWO_BYTES( 0x55, 0xf2 ), TWO_BYTES( 0x73, 0x3f ), 
TWO_BYTES( 0x7f, 0xcd ), TWO_BYTES( 0x50, 0x0e ), TWO_BYTES( 0x71, 0xc4 ), TWO_BYTES( 0x5d, 0x05 ),
TWO_BYTES( 0x63, 0xdf ), TWO_BYTES( 0x4a, 0x18 ), TWO_BYTES( 0x6d, 0xd6 ), TWO_BYTES( 0x47, 0x13 ), 
TWO_BYTES( 0xd7, 0x31 ), TWO_BYTES( 0xdc, 0xca ), TWO_BYTES( 0xd9, 0x38 ), TWO_BYTES( 0xd1, 0xc1 ),
TWO_BYTES( 0xcb, 0x23 ), TWO_BYTES( 0xc6, 0xdc ), TWO_BYTES( 0xc5, 0x2a ), TWO_BYTES( 0xcb, 0xd7 ), 
TWO_BYTES( 0xef, 0x15 ), TWO_BYTES( 0xe8, 0xe6 ), TWO_BYTES( 0xe1, 0x1c ), TWO_BYTES( 0xe5, 0xed ),
TWO_BYTES( 0xf3, 0x07 ), TWO_BYTES( 0xf2, 0xf0 ), TWO_BYTES( 0xfd, 0x0e ), TWO_BYTES( 0xff, 0xfb ), 
TWO_BYTES( 0xa7, 0x79 ), TWO_BYTES( 0xb4, 0x92 ), TWO_BYTES( 0xa9, 0x70 ), TWO_BYTES( 0xb9, 0x99 ),
TWO_BYTES( 0xbb, 0x6b ), TWO_BYTES( 0xae, 0x84 ), TWO_BYTES( 0xb5, 0x62 ), TWO_BYTES( 0xa3, 0x8f ), 
TWO_BYTES( 0x9f, 0x5d ), TWO_BYTES( 0x80, 0xbe ), TWO_BYTES( 0x91, 0x54 ), TWO_BYTES( 0x8d, 0xb5 ),
TWO_BYTES( 0x83, 0x4f ), TWO_BYTES( 0x9a, 0xa8 ), TWO_BYTES( 0x8d, 0x46 ), TWO_BYTES( 0x97, 0xa3 )
};

const DRM_DWORD_ALIGN DRM_BYTE U2[256][__CB_DECL( 4 )] = 
{
TWO_BYTES( 0x00, 0x00 ), TWO_BYTES( 0x00, 0x00 ), TWO_BYTES( 0x0b, 0x0e ), TWO_BYTES( 0x09, 0x0d ),
TWO_BYTES( 0x16, 0x1c ), TWO_BYTES( 0x12, 0x1a ), TWO_BYTES( 0x1d, 0x12 ), TWO_BYTES( 0x1b, 0x17 ), 
TWO_BYTES( 0x2c, 0x38 ), TWO_BYTES( 0x24, 0x34 ), TWO_BYTES( 0x27, 0x36 ), TWO_BYTES( 0x2d, 0x39 ),
TWO_BYTES( 0x3a, 0x24 ), TWO_BYTES( 0x36, 0x2e ), TWO_BYTES( 0x31, 0x2a ), TWO_BYTES( 0x3f, 0x23 ), 
TWO_BYTES( 0x58, 0x70 ), TWO_BYTES( 0x48, 0x68 ), TWO_BYTES( 0x53, 0x7e ), TWO_BYTES( 0x41, 0x65 ),
TWO_BYTES( 0x4e, 0x6c ), TWO_BYTES( 0x5a, 0x72 ), TWO_BYTES( 0x45, 0x62 ), TWO_BYTES( 0x53, 0x7f ), 
TWO_BYTES( 0x74, 0x48 ), TWO_BYTES( 0x6c, 0x5c ), TWO_BYTES( 0x7f, 0x46 ), TWO_BYTES( 0x65, 0x51 ),
TWO_BYTES( 0x62, 0x54 ), TWO_BYTES( 0x7e, 0x46 ), TWO_BYTES( 0x69, 0x5a ), TWO_BYTES( 0x77, 0x4b ), 
TWO_BYTES( 0xb0, 0xe0 ), TWO_BYTES( 0x90, 0xd0 ), TWO_BYTES( 0xbb, 0xee ), TWO_BYTES( 0x99, 0xdd ),
TWO_BYTES( 0xa6, 0xfc ), TWO_BYTES( 0x82, 0xca ), TWO_BYTES( 0xad, 0xf2 ), TWO_BYTES( 0x8b, 0xc7 ), 
TWO_BYTES( 0x9c, 0xd8 ), TWO_BYTES( 0xb4, 0xe4 ), TWO_BYTES( 0x97, 0xd6 ), TWO_BYTES( 0xbd, 0xe9 ),
TWO_BYTES( 0x8a, 0xc4 ), TWO_BYTES( 0xa6, 0xfe ), TWO_BYTES( 0x81, 0xca ), TWO_BYTES( 0xaf, 0xf3 ), 
TWO_BYTES( 0xe8, 0x90 ), TWO_BYTES( 0xd8, 0xb8 ), TWO_BYTES( 0xe3, 0x9e ), TWO_BYTES( 0xd1, 0xb5 ),
TWO_BYTES( 0xfe, 0x8c ), TWO_BYTES( 0xca, 0xa2 ), TWO_BYTES( 0xf5, 0x82 ), TWO_BYTES( 0xc3, 0xaf ), 
TWO_BYTES( 0xc4, 0xa8 ), TWO_BYTES( 0xfc, 0x8c ), TWO_BYTES( 0xcf, 0xa6 ), TWO_BYTES( 0xf5, 0x81 ),
TWO_BYTES( 0xd2, 0xb4 ), TWO_BYTES( 0xee, 0x96 ), TWO_BYTES( 0xd9, 0xba ), TWO_BYTES( 0xe7, 0x9b ), 
TWO_BYTES( 0x7b, 0xdb ), TWO_BYTES( 0x3b, 0xbb ), TWO_BYTES( 0x70, 0xd5 ), TWO_BYTES( 0x32, 0xb6 ),
TWO_BYTES( 0x6d, 0xc7 ), TWO_BYTES( 0x29, 0xa1 ), TWO_BYTES( 0x66, 0xc9 ), TWO_BYTES( 0x20, 0xac ), 
TWO_BYTES( 0x57, 0xe3 ), TWO_BYTES( 0x1f, 0x8f ), TWO_BYTES( 0x5c, 0xed ), TWO_BYTES( 0x16, 0x82 ),
TWO_BYTES( 0x41, 0xff ), TWO_BYTES( 0x0d, 0x95 ), TWO_BYTES( 0x4a, 0xf1 ), TWO_BYTES( 0x04, 0x98 ), 
TWO_BYTES( 0x23, 0xab ), TWO_BYTES( 0x73, 0xd3 ), TWO_BYTES( 0x28, 0xa5 ), TWO_BYTES( 0x7a, 0xde ),
TWO_BYTES( 0x35, 0xb7 ), TWO_BYTES( 0x61, 0xc9 ), TWO_BYTES( 0x3e, 0xb9 ), TWO_BYTES( 0x68, 0xc4 ), 
TWO_BYTES( 0x0f, 0x93 ), TWO_BYTES( 0x57, 0xe7 ), TWO_BYTES( 0x04, 0x9d ), TWO_BYTES( 0x5e, 0xea ),
TWO_BYTES( 0x19, 0x8f ), TWO_BYTES( 0x45, 0xfd ), TWO_BYTES( 0x12, 0x81 ), TWO_BYTES( 0x4c, 0xf0 ), 
TWO_BYTES( 0xcb, 0x3b ), TWO_BYTES( 0xab, 0x6b ), TWO_BYTES( 0xc0, 0x35 ), TWO_BYTES( 0xa2, 0x66 ),
TWO_BYTES( 0xdd, 0x27 ), TWO_BYTES( 0xb9, 0x71 ), TWO_BYTES( 0xd6, 0x29 ), TWO_BYTES( 0xb0, 0x7c ), 
TWO_BYTES( 0xe7, 0x03 ), TWO_BYTES( 0x8f, 0x5f ), TWO_BYTES( 0xec, 0x0d ), TWO_BYTES( 0x86, 0x52 ),
TWO_BYTES( 0xf1, 0x1f ), TWO_BYTES( 0x9d, 0x45 ), TWO_BYTES( 0xfa, 0x11 ), TWO_BYTES( 0x94, 0x48 ), 
TWO_BYTES( 0x93, 0x4b ), TWO_BYTES( 0xe3, 0x03 ), TWO_BYTES( 0x98, 0x45 ), TWO_BYTES( 0xea, 0x0e ),
TWO_BYTES( 0x85, 0x57 ), TWO_BYTES( 0xf1, 0x19 ), TWO_BYTES( 0x8e, 0x59 ), TWO_BYTES( 0xf8, 0x14 ), 
TWO_BYTES( 0xbf, 0x73 ), TWO_BYTES( 0xc7, 0x37 ), TWO_BYTES( 0xb4, 0x7d ), TWO_BYTES( 0xce, 0x3a ),
TWO_BYTES( 0xa9, 0x6f ), TWO_BYTES( 0xd5, 0x2d ), TWO_BYTES( 0xa2, 0x61 ), TWO_BYTES( 0xdc, 0x20 ), 
TWO_BYTES( 0xf6, 0xad ), TWO_BYTES( 0x76, 0x6d ), TWO_BYTES( 0xfd, 0xa3 ), TWO_BYTES( 0x7f, 0x60 ),
TWO_BYTES( 0xe0, 0xb1 ), TWO_BYTES( 0x64, 0x77 ), TWO_BYTES( 0xeb, 0xbf ), TWO_BYTES( 0x6d, 0x7a ), 
TWO_BYTES( 0xda, 0x95 ), TWO_BYTES( 0x52, 0x59 ), TWO_BYTES( 0xd1, 0x9b ), TWO_BYTES( 0x5b, 0x54 ),
TWO_BYTES( 0xcc, 0x89 ), TWO_BYTES( 0x40, 0x43 ), TWO_BYTES( 0xc7, 0x87 ), TWO_BYTES( 0x49, 0x4e ), 
TWO_BYTES( 0xae, 0xdd ), TWO_BYTES( 0x3e, 0x05 ), TWO_BYTES( 0xa5, 0xd3 ), TWO_BYTES( 0x37, 0x08 ),
TWO_BYTES( 0xb8, 0xc1 ), TWO_BYTES( 0x2c, 0x1f ), TWO_BYTES( 0xb3, 0xcf ), TWO_BYTES( 0x25, 0x12 ), 
TWO_BYTES( 0x82, 0xe5 ), TWO_BYTES( 0x1a, 0x31 ), TWO_BYTES( 0x89, 0xeb ), TWO_BYTES( 0x13, 0x3c ),
TWO_BYTES( 0x94, 0xf9 ), TWO_BYTES( 0x08, 0x2b ), TWO_BYTES( 0x9f, 0xf7 ), TWO_BYTES( 0x01, 0x26 ), 
TWO_BYTES( 0x46, 0x4d ), TWO_BYTES( 0xe6, 0xbd ), TWO_BYTES( 0x4d, 0x43 ), TWO_BYTES( 0xef, 0xb0 ),
TWO_BYTES( 0x50, 0x51 ), TWO_BYTES( 0xf4, 0xa7 ), TWO_BYTES( 0x5b, 0x5f ), TWO_BYTES( 0xfd, 0xaa ), 
TWO_BYTES( 0x6a, 0x75 ), TWO_BYTES( 0xc2, 0x89 ), TWO_BYTES( 0x61, 0x7b ), TWO_BYTES( 0xcb, 0x84 ),
TWO_BYTES( 0x7c, 0x69 ), TWO_BYTES( 0xd0, 0x93 ), TWO_BYTES( 0x77, 0x67 ), TWO_BYTES( 0xd9, 0x9e ), 
TWO_BYTES( 0x1e, 0x3d ), TWO_BYTES( 0xae, 0xd5 ), TWO_BYTES( 0x15, 0x33 ), TWO_BYTES( 0xa7, 0xd8 ),
TWO_BYTES( 0x08, 0x21 ), TWO_BYTES( 0xbc, 0xcf ), TWO_BYTES( 0x03, 0x2f ), TWO_BYTES( 0xb5, 0xc2 ), 
TWO_BYTES( 0x32, 0x05 ), TWO_BYTES( 0x8a, 0xe1 ), TWO_BYTES( 0x39, 0x0b ), TWO_BYTES( 0x83, 0xec ),
TWO_BYTES( 0x24, 0x19 ), TWO_BYTES( 0x98, 0xfb ), TWO_BYTES( 0x2f, 0x17 ), TWO_BYTES( 0x91, 0xf6 ), 
TWO_BYTES( 0x8d, 0x76 ), TWO_BYTES( 0x4d, 0xd6 ), TWO_BYTES( 0x86, 0x78 ), TWO_BYTES( 0x44, 0xdb ),
TWO_BYTES( 0x9b, 0x6a ), TWO_BYTES( 0x5f, 0xcc ), TWO_BYTES( 0x90, 0x64 ), TWO_BYTES( 0x56, 0xc1 ), 
TWO_BYTES( 0xa1, 0x4e ), TWO_BYTES( 0x69, 0xe2 ), TWO_BYTES( 0xaa, 0x40 ), TWO_BYTES( 0x60, 0xef ),
TWO_BYTES( 0xb7, 0x52 ), TWO_BYTES( 0x7b, 0xf8 ), TWO_BYTES( 0xbc, 0x5c ), TWO_BYTES( 0x72, 0xf5 ), 
TWO_BYTES( 0xd5, 0x06 ), TWO_BYTES( 0x05, 0xbe ), TWO_BYTES( 0xde, 0x08 ), TWO_BYTES( 0x0c, 0xb3 ),
TWO_BYTES( 0xc3, 0x1a ), TWO_BYTES( 0x17, 0xa4 ), TWO_BYTES( 0xc8, 0x14 ), TWO_BYTES( 0x1e, 0xa9 ), 
TWO_BYTES( 0xf9, 0x3e ), TWO_BYTES( 0x21, 0x8a ), TWO_BYTES( 0xf2, 0x30 ), TWO_BYTES( 0x28, 0x87 ),
TWO_BYTES( 0xef, 0x22 ), TWO_BYTES( 0x33, 0x90 ), TWO_BYTES( 0xe4, 0x2c ), TWO_BYTES( 0x3a, 0x9d ), 
TWO_BYTES( 0x3d, 0x96 ), TWO_BYTES( 0xdd, 0x06 ), TWO_BYTES( 0x36, 0x98 ), TWO_BYTES( 0xd4, 0x0b ),
TWO_BYTES( 0x2b, 0x8a ), TWO_BYTES( 0xcf, 0x1c ), TWO_BYTES( 0x20, 0x84 ), TWO_BYTES( 0xc6, 0x11 ), 
TWO_BYTES( 0x11, 0xae ), TWO_BYTES( 0xf9, 0x32 ), TWO_BYTES( 0x1a, 0xa0 ), TWO_BYTES( 0xf0, 0x3f ),
TWO_BYTES( 0x07, 0xb2 ), TWO_BYTES( 0xeb, 0x28 ), TWO_BYTES( 0x0c, 0xbc ), TWO_BYTES( 0xe2, 0x25 ), 
TWO_BYTES( 0x65, 0xe6 ), TWO_BYTES( 0x95, 0x6e ), TWO_BYTES( 0x6e, 0xe8 ), TWO_BYTES( 0x9c, 0x63 ),
TWO_BYTES( 0x73, 0xfa ), TWO_BYTES( 0x87, 0x74 ), TWO_BYTES( 0x78, 0xf4 ), TWO_BYTES( 0x8e, 0x79 ), 
TWO_BYTES( 0x49, 0xde ), TWO_BYTES( 0xb1, 0x5a ), TWO_BYTES( 0x42, 0xd0 ), TWO_BYTES( 0xb8, 0x57 ),
TWO_BYTES( 0x5f, 0xc2 ), TWO_BYTES( 0xa3, 0x40 ), TWO_BYTES( 0x54, 0xcc ), TWO_BYTES( 0xaa, 0x4d ), 
TWO_BYTES( 0xf7, 0x41 ), TWO_BYTES( 0xec, 0xda ), TWO_BYTES( 0xfc, 0x4f ), TWO_BYTES( 0xe5, 0xd7 ),
TWO_BYTES( 0xe1, 0x5d ), TWO_BYTES( 0xfe, 0xc0 ), TWO_BYTES( 0xea, 0x53 ), TWO_BYTES( 0xf7, 0xcd ), 
TWO_BYTES( 0xdb, 0x79 ), TWO_BYTES( 0xc8, 0xee ), TWO_BYTES( 0xd0, 0x77 ), TWO_BYTES( 0xc1, 0xe3 ),
TWO_BYTES( 0xcd, 0x65 ), TWO_BYTES( 0xda, 0xf4 ), TWO_BYTES( 0xc6, 0x6b ), TWO_BYTES( 0xd3, 0xf9 ), 
TWO_BYTES( 0xaf, 0x31 ), TWO_BYTES( 0xa4, 0xb2 ), TWO_BYTES( 0xa4, 0x3f ), TWO_BYTES( 0xad, 0xbf ),
TWO_BYTES( 0xb9, 0x2d ), TWO_BYTES( 0xb6, 0xa8 ), TWO_BYTES( 0xb2, 0x23 ), TWO_BYTES( 0xbf, 0xa5 ), 
TWO_BYTES( 0x83, 0x09 ), TWO_BYTES( 0x80, 0x86 ), TWO_BYTES( 0x88, 0x07 ), TWO_BYTES( 0x89, 0x8b ),
TWO_BYTES( 0x95, 0x15 ), TWO_BYTES( 0x92, 0x9c ), TWO_BYTES( 0x9e, 0x1b ), TWO_BYTES( 0x9b, 0x91 ), 
TWO_BYTES( 0x47, 0xa1 ), TWO_BYTES( 0x7c, 0x0a ), TWO_BYTES( 0x4c, 0xaf ), TWO_BYTES( 0x75, 0x07 ),
TWO_BYTES( 0x51, 0xbd ), TWO_BYTES( 0x6e, 0x10 ), TWO_BYTES( 0x5a, 0xb3 ), TWO_BYTES( 0x67, 0x1d ), 
TWO_BYTES( 0x6b, 0x99 ), TWO_BYTES( 0x58, 0x3e ), TWO_BYTES( 0x60, 0x97 ), TWO_BYTES( 0x51, 0x33 ),
TWO_BYTES( 0x7d, 0x85 ), TWO_BYTES( 0x4a, 0x24 ), TWO_BYTES( 0x76, 0x8b ), TWO_BYTES( 0x43, 0x29 ), 
TWO_BYTES( 0x1f, 0xd1 ), TWO_BYTES( 0x34, 0x62 ), TWO_BYTES( 0x14, 0xdf ), TWO_BYTES( 0x3d, 0x6f ),
TWO_BYTES( 0x09, 0xcd ), TWO_BYTES( 0x26, 0x78 ), TWO_BYTES( 0x02, 0xc3 ), TWO_BYTES( 0x2f, 0x75 ), 
TWO_BYTES( 0x33, 0xe9 ), TWO_BYTES( 0x10, 0x56 ), TWO_BYTES( 0x38, 0xe7 ), TWO_BYTES( 0x19, 0x5b ),
TWO_BYTES( 0x25, 0xf5 ), TWO_BYTES( 0x02, 0x4c ), TWO_BYTES( 0x2e, 0xfb ), TWO_BYTES( 0x0b, 0x41 ), 
TWO_BYTES( 0x8c, 0x9a ), TWO_BYTES( 0xd7, 0x61 ), TWO_BYTES( 0x87, 0x94 ), TWO_BYTES( 0xde, 0x6c ),
TWO_BYTES( 0x9a, 0x86 ), TWO_BYTES( 0xc5, 0x7b ), TWO_BYTES( 0x91, 0x88 ), TWO_BYTES( 0xcc, 0x76 ), 
TWO_BYTES( 0xa0, 0xa2 ), TWO_BYTES( 0xf3, 0x55 ), TWO_BYTES( 0xab, 0xac ), TWO_BYTES( 0xfa, 0x58 ),
TWO_BYTES( 0xb6, 0xbe ), TWO_BYTES( 0xe1, 0x4f ), TWO_BYTES( 0xbd, 0xb0 ), TWO_BYTES( 0xe8, 0x42 ), 
TWO_BYTES( 0xd4, 0xea ), TWO_BYTES( 0x9f, 0x09 ), TWO_BYTES( 0xdf, 0xe4 ), TWO_BYTES( 0x96, 0x04 ),
TWO_BYTES( 0xc2, 0xf6 ), TWO_BYTES( 0x8d, 0x13 ), TWO_BYTES( 0xc9, 0xf8 ), TWO_BYTES( 0x84, 0x1e ), 
TWO_BYTES( 0xf8, 0xd2 ), TWO_BYTES( 0xbb, 0x3d ), TWO_BYTES( 0xf3, 0xdc ), TWO_BYTES( 0xb2, 0x30 ),
TWO_BYTES( 0xee, 0xce ), TWO_BYTES( 0xa9, 0x27 ), TWO_BYTES( 0xe5, 0xc0 ), TWO_BYTES( 0xa0, 0x2a ), 
TWO_BYTES( 0x3c, 0x7a ), TWO_BYTES( 0x47, 0xb1 ), TWO_BYTES( 0x37, 0x74 ), TWO_BYTES( 0x4e, 0xbc ),
TWO_BYTES( 0x2a, 0x66 ), TWO_BYTES( 0x55, 0xab ), TWO_BYTES( 0x21, 0x68 ), TWO_BYTES( 0x5c, 0xa6 ), 
TWO_BYTES( 0x10, 0x42 ), TWO_BYTES( 0x63, 0x85 ), TWO_BYTES( 0x1b, 0x4c ), TWO_BYTES( 0x6a, 0x88 ),
TWO_BYTES( 0x06, 0x5e ), TWO_BYTES( 0x71, 0x9f ), TWO_BYTES( 0x0d, 0x50 ), TWO_BYTES( 0x78, 0x92 ), 
TWO_BYTES( 0x64, 0x0a ), TWO_BYTES( 0x0f, 0xd9 ), TWO_BYTES( 0x6f, 0x04 ), TWO_BYTES( 0x06, 0xd4 ),
TWO_BYTES( 0x72, 0x16 ), TWO_BYTES( 0x1d, 0xc3 ), TWO_BYTES( 0x79, 0x18 ), TWO_BYTES( 0x14, 0xce ), 
TWO_BYTES( 0x48, 0x32 ), TWO_BYTES( 0x2b, 0xed ), TWO_BYTES( 0x43, 0x3c ), TWO_BYTES( 0x22, 0xe0 ),
TWO_BYTES( 0x5e, 0x2e ), TWO_BYTES( 0x39, 0xf7 ), TWO_BYTES( 0x55, 0x20 ), TWO_BYTES( 0x30, 0xfa ), 
TWO_BYTES( 0x01, 0xec ), TWO_BYTES( 0x9a, 0xb7 ), TWO_BYTES( 0x0a, 0xe2 ), TWO_BYTES( 0x93, 0xba ),
TWO_BYTES( 0x17, 0xf0 ), TWO_BYTES( 0x88, 0xad ), TWO_BYTES( 0x1c, 0xfe ), TWO_BYTES( 0x81, 0xa0 ), 
TWO_BYTES( 0x2d, 0xd4 ), TWO_BYTES( 0xbe, 0x83 ), TWO_BYTES( 0x26, 0xda ), TWO_BYTES( 0xb7, 0x8e ),
TWO_BYTES( 0x3b, 0xc8 ), TWO_BYTES( 0xac, 0x99 ), TWO_BYTES( 0x30, 0xc6 ), TWO_BYTES( 0xa5, 0x94 ), 
TWO_BYTES( 0x59, 0x9c ), TWO_BYTES( 0xd2, 0xdf ), TWO_BYTES( 0x52, 0x92 ), TWO_BYTES( 0xdb, 0xd2 ),
TWO_BYTES( 0x4f, 0x80 ), TWO_BYTES( 0xc0, 0xc5 ), TWO_BYTES( 0x44, 0x8e ), TWO_BYTES( 0xc9, 0xc8 ), 
TWO_BYTES( 0x75, 0xa4 ), TWO_BYTES( 0xf6, 0xeb ), TWO_BYTES( 0x7e, 0xaa ), TWO_BYTES( 0xff, 0xe6 ),
TWO_BYTES( 0x63, 0xb8 ), TWO_BYTES( 0xe4, 0xf1 ), TWO_BYTES( 0x68, 0xb6 ), TWO_BYTES( 0xed, 0xfc ), 
TWO_BYTES( 0xb1, 0x0c ), TWO_BYTES( 0x0a, 0x67 ), TWO_BYTES( 0xba, 0x02 ), TWO_BYTES( 0x03, 0x6a ),
TWO_BYTES( 0xa7, 0x10 ), TWO_BYTES( 0x18, 0x7d ), TWO_BYTES( 0xac, 0x1e ), TWO_BYTES( 0x11, 0x70 ), 
TWO_BYTES( 0x9d, 0x34 ), TWO_BYTES( 0x2e, 0x53 ), TWO_BYTES( 0x96, 0x3a ), TWO_BYTES( 0x27, 0x5e ),
TWO_BYTES( 0x8b, 0x28 ), TWO_BYTES( 0x3c, 0x49 ), TWO_BYTES( 0x80, 0x26 ), TWO_BYTES( 0x35, 0x44 ), 
TWO_BYTES( 0xe9, 0x7c ), TWO_BYTES( 0x42, 0x0f ), TWO_BYTES( 0xe2, 0x72 ), TWO_BYTES( 0x4b, 0x02 ),
TWO_BYTES( 0xff, 0x60 ), TWO_BYTES( 0x50, 0x15 ), TWO_BYTES( 0xf4, 0x6e ), TWO_BYTES( 0x59, 0x18 ), 
TWO_BYTES( 0xc5, 0x44 ), TWO_BYTES( 0x66, 0x3b ), TWO_BYTES( 0xce, 0x4a ), TWO_BYTES( 0x6f, 0x36 ),
TWO_BYTES( 0xd3, 0x58 ), TWO_BYTES( 0x74, 0x21 ), TWO_BYTES( 0xd8, 0x56 ), TWO_BYTES( 0x7d, 0x2c ), 
TWO_BYTES( 0x7a, 0x37 ), TWO_BYTES( 0xa1, 0x0c ), TWO_BYTES( 0x71, 0x39 ), TWO_BYTES( 0xa8, 0x01 ),
TWO_BYTES( 0x6c, 0x2b ), TWO_BYTES( 0xb3, 0x16 ), TWO_BYTES( 0x67, 0x25 ), TWO_BYTES( 0xba, 0x1b ), 
TWO_BYTES( 0x56, 0x0f ), TWO_BYTES( 0x85, 0x38 ), TWO_BYTES( 0x5d, 0x01 ), TWO_BYTES( 0x8c, 0x35 ),
TWO_BYTES( 0x40, 0x13 ), TWO_BYTES( 0x97, 0x22 ), TWO_BYTES( 0x4b, 0x1d ), TWO_BYTES( 0x9e, 0x2f ), 
TWO_BYTES( 0x22, 0x47 ), TWO_BYTES( 0xe9, 0x64 ), TWO_BYTES( 0x29, 0x49 ), TWO_BYTES( 0xe0, 0x69 ),
TWO_BYTES( 0x34, 0x5b ), TWO_BYTES( 0xfb, 0x7e ), TWO_BYTES( 0x3f, 0x55 ), TWO_BYTES( 0xf2, 0x73 ), 
TWO_BYTES( 0x0e, 0x7f ), TWO_BYTES( 0xcd, 0x50 ), TWO_BYTES( 0x05, 0x71 ), TWO_BYTES( 0xc4, 0x5d ),
TWO_BYTES( 0x18, 0x63 ), TWO_BYTES( 0xdf, 0x4a ), TWO_BYTES( 0x13, 0x6d ), TWO_BYTES( 0xd6, 0x47 ), 
TWO_BYTES( 0xca, 0xd7 ), TWO_BYTES( 0x31, 0xdc ), TWO_BYTES( 0xc1, 0xd9 ), TWO_BYTES( 0x38, 0xd1 ),
TWO_BYTES( 0xdc, 0xcb ), TWO_BYTES( 0x23, 0xc6 ), TWO_BYTES( 0xd7, 0xc5 ), TWO_BYTES( 0x2a, 0xcb ), 
TWO_BYTES( 0xe6, 0xef ), TWO_BYTES( 0x15, 0xe8 ), TWO_BYTES( 0xed, 0xe1 ), TWO_BYTES( 0x1c, 0xe5 ),
TWO_BYTES( 0xf0, 0xf3 ), TWO_BYTES( 0x07, 0xf2 ), TWO_BYTES( 0xfb, 0xfd ), TWO_BYTES( 0x0e, 0xff ), 
TWO_BYTES( 0x92, 0xa7 ), TWO_BYTES( 0x79, 0xb4 ), TWO_BYTES( 0x99, 0xa9 ), TWO_BYTES( 0x70, 0xb9 ),
TWO_BYTES( 0x84, 0xbb ), TWO_BYTES( 0x6b, 0xae ), TWO_BYTES( 0x8f, 0xb5 ), TWO_BYTES( 0x62, 0xa3 ), 
TWO_BYTES( 0xbe, 0x9f ), TWO_BYTES( 0x5d, 0x80 ), TWO_BYTES( 0xb5, 0x91 ), TWO_BYTES( 0x54, 0x8d ),
TWO_BYTES( 0xa8, 0x83 ), TWO_BYTES( 0x4f, 0x9a ), TWO_BYTES( 0xa3, 0x8d ), TWO_BYTES( 0x46, 0x97 )
};

const DRM_DWORD_ALIGN DRM_BYTE U3[256][__CB_DECL( 4 )] = 
{
TWO_BYTES( 0x00, 0x00 ), TWO_BYTES( 0x00, 0x00 ), TWO_BYTES( 0x0d, 0x0b ), TWO_BYTES( 0x0e, 0x09 ),
TWO_BYTES( 0x1a, 0x16 ), TWO_BYTES( 0x1c, 0x12 ), TWO_BYTES( 0x17, 0x1d ), TWO_BYTES( 0x12, 0x1b ), 
TWO_BYTES( 0x34, 0x2c ), TWO_BYTES( 0x38, 0x24 ), TWO_BYTES( 0x39, 0x27 ), TWO_BYTES( 0x36, 0x2d ),
TWO_BYTES( 0x2e, 0x3a ), TWO_BYTES( 0x24, 0x36 ), TWO_BYTES( 0x23, 0x31 ), TWO_BYTES( 0x2a, 0x3f ), 
TWO_BYTES( 0x68, 0x58 ), TWO_BYTES( 0x70, 0x48 ), TWO_BYTES( 0x65, 0x53 ), TWO_BYTES( 0x7e, 0x41 ),
TWO_BYTES( 0x72, 0x4e ), TWO_BYTES( 0x6c, 0x5a ), TWO_BYTES( 0x7f, 0x45 ), TWO_BYTES( 0x62, 0x53 ), 
TWO_BYTES( 0x5c, 0x74 ), TWO_BYTES( 0x48, 0x6c ), TWO_BYTES( 0x51, 0x7f ), TWO_BYTES( 0x46, 0x65 ),
TWO_BYTES( 0x46, 0x62 ), TWO_BYTES( 0x54, 0x7e ), TWO_BYTES( 0x4b, 0x69 ), TWO_BYTES( 0x5a, 0x77 ), 
TWO_BYTES( 0xd0, 0xb0 ), TWO_BYTES( 0xe0, 0x90 ), TWO_BYTES( 0xdd, 0xbb ), TWO_BYTES( 0xee, 0x99 ),
TWO_BYTES( 0xca, 0xa6 ), TWO_BYTES( 0xfc, 0x82 ), TWO_BYTES( 0xc7, 0xad ), TWO_BYTES( 0xf2, 0x8b ), 
TWO_BYTES( 0xe4, 0x9c ), TWO_BYTES( 0xd8, 0xb4 ), TWO_BYTES( 0xe9, 0x97 ), TWO_BYTES( 0xd6, 0xbd ),
TWO_BYTES( 0xfe, 0x8a ), TWO_BYTES( 0xc4, 0xa6 ), TWO_BYTES( 0xf3, 0x81 ), TWO_BYTES( 0xca, 0xaf ), 
TWO_BYTES( 0xb8, 0xe8 ), TWO_BYTES( 0x90, 0xd8 ), TWO_BYTES( 0xb5, 0xe3 ), TWO_BYTES( 0x9e, 0xd1 ),
TWO_BYTES( 0xa2, 0xfe ), TWO_BYTES( 0x8c, 0xca ), TWO_BYTES( 0xaf, 0xf5 ), TWO_BYTES( 0x82, 0xc3 ), 
TWO_BYTES( 0x8c, 0xc4 ), TWO_BYTES( 0xa8, 0xfc ), TWO_BYTES( 0x81, 0xcf ), TWO_BYTES( 0xa6, 0xf5 ),
TWO_BYTES( 0x96, 0xd2 ), TWO_BYTES( 0xb4, 0xee ), TWO_BYTES( 0x9b, 0xd9 ), TWO_BYTES( 0xba, 0xe7 ), 
TWO_BYTES( 0xbb, 0x7b ), TWO_BYTES( 0xdb, 0x3b ), TWO_BYTES( 0xb6, 0x70 ), TWO_BYTES( 0xd5, 0x32 ),
TWO_BYTES( 0xa1, 0x6d ), TWO_BYTES( 0xc7, 0x29 ), TWO_BYTES( 0xac, 0x66 ), TWO_BYTES( 0xc9, 0x20 ), 
TWO_BYTES( 0x8f, 0x57 ), TWO_BYTES( 0xe3, 0x1f ), TWO_BYTES( 0x82, 0x5c ), TWO_BYTES( 0xed, 0x16 ),
TWO_BYTES( 0x95, 0x41 ), TWO_BYTES( 0xff, 0x0d ), TWO_BYTES( 0x98, 0x4a ), TWO_BYTES( 0xf1, 0x04 ), 
TWO_BYTES( 0xd3, 0x23 ), TWO_BYTES( 0xab, 0x73 ), TWO_BYTES( 0xde, 0x28 ), TWO_BYTES( 0xa5, 0x7a ),
TWO_BYTES( 0xc9, 0x35 ), TWO_BYTES( 0xb7, 0x61 ), TWO_BYTES( 0xc4, 0x3e ), TWO_BYTES( 0xb9, 0x68 ), 
TWO_BYTES( 0xe7, 0x0f ), TWO_BYTES( 0x93, 0x57 ), TWO_BYTES( 0xea, 0x04 ), TWO_BYTES( 0x9d, 0x5e ),
TWO_BYTES( 0xfd, 0x19 ), TWO_BYTES( 0x8f, 0x45 ), TWO_BYTES( 0xf0, 0x12 ), TWO_BYTES( 0x81, 0x4c ), 
TWO_BYTES( 0x6b, 0xcb ), TWO_BYTES( 0x3b, 0xab ), TWO_BYTES( 0x66, 0xc0 ), TWO_BYTES( 0x35, 0xa2 ),
TWO_BYTES( 0x71, 0xdd ), TWO_BYTES( 0x27, 0xb9 ), TWO_BYTES( 0x7c, 0xd6 ), TWO_BYTES( 0x29, 0xb0 ), 
TWO_BYTES( 0x5f, 0xe7 ), TWO_BYTES( 0x03, 0x8f ), TWO_BYTES( 0x52, 0xec ), TWO_BYTES( 0x0d, 0x86 ),
TWO_BYTES( 0x45, 0xf1 ), TWO_BYTES( 0x1f, 0x9d ), TWO_BYTES( 0x48, 0xfa ), TWO_BYTES( 0x11, 0x94 ), 
TWO_BYTES( 0x03, 0x93 ), TWO_BYTES( 0x4b, 0xe3 ), TWO_BYTES( 0x0e, 0x98 ), TWO_BYTES( 0x45, 0xea ),
TWO_BYTES( 0x19, 0x85 ), TWO_BYTES( 0x57, 0xf1 ), TWO_BYTES( 0x14, 0x8e ), TWO_BYTES( 0x59, 0xf8 ), 
TWO_BYTES( 0x37, 0xbf ), TWO_BYTES( 0x73, 0xc7 ), TWO_BYTES( 0x3a, 0xb4 ), TWO_BYTES( 0x7d, 0xce ),
TWO_BYTES( 0x2d, 0xa9 ), TWO_BYTES( 0x6f, 0xd5 ), TWO_BYTES( 0x20, 0xa2 ), TWO_BYTES( 0x61, 0xdc ), 
TWO_BYTES( 0x6d, 0xf6 ), TWO_BYTES( 0xad, 0x76 ), TWO_BYTES( 0x60, 0xfd ), TWO_BYTES( 0xa3, 0x7f ),
TWO_BYTES( 0x77, 0xe0 ), TWO_BYTES( 0xb1, 0x64 ), TWO_BYTES( 0x7a, 0xeb ), TWO_BYTES( 0xbf, 0x6d ), 
TWO_BYTES( 0x59, 0xda ), TWO_BYTES( 0x95, 0x52 ), TWO_BYTES( 0x54, 0xd1 ), TWO_BYTES( 0x9b, 0x5b ),
TWO_BYTES( 0x43, 0xcc ), TWO_BYTES( 0x89, 0x40 ), TWO_BYTES( 0x4e, 0xc7 ), TWO_BYTES( 0x87, 0x49 ), 
TWO_BYTES( 0x05, 0xae ), TWO_BYTES( 0xdd, 0x3e ), TWO_BYTES( 0x08, 0xa5 ), TWO_BYTES( 0xd3, 0x37 ),
TWO_BYTES( 0x1f, 0xb8 ), TWO_BYTES( 0xc1, 0x2c ), TWO_BYTES( 0x12, 0xb3 ), TWO_BYTES( 0xcf, 0x25 ), 
TWO_BYTES( 0x31, 0x82 ), TWO_BYTES( 0xe5, 0x1a ), TWO_BYTES( 0x3c, 0x89 ), TWO_BYTES( 0xeb, 0x13 ),
TWO_BYTES( 0x2b, 0x94 ), TWO_BYTES( 0xf9, 0x08 ), TWO_BYTES( 0x26, 0x9f ), TWO_BYTES( 0xf7, 0x01 ), 
TWO_BYTES( 0xbd, 0x46 ), TWO_BYTES( 0x4d, 0xe6 ), TWO_BYTES( 0xb0, 0x4d ), TWO_BYTES( 0x43, 0xef ),
TWO_BYTES( 0xa7, 0x50 ), TWO_BYTES( 0x51, 0xf4 ), TWO_BYTES( 0xaa, 0x5b ), TWO_BYTES( 0x5f, 0xfd ), 
TWO_BYTES( 0x89, 0x6a ), TWO_BYTES( 0x75, 0xc2 ), TWO_BYTES( 0x84, 0x61 ), TWO_BYTES( 0x7b, 0xcb ),
TWO_BYTES( 0x93, 0x7c ), TWO_BYTES( 0x69, 0xd0 ), TWO_BYTES( 0x9e, 0x77 ), TWO_BYTES( 0x67, 0xd9 ), 
TWO_BYTES( 0xd5, 0x1e ), TWO_BYTES( 0x3d, 0xae ), TWO_BYTES( 0xd8, 0x15 ), TWO_BYTES( 0x33, 0xa7 ),
TWO_BYTES( 0xcf, 0x08 ), TWO_BYTES( 0x21, 0xbc ), TWO_BYTES( 0xc2, 0x03 ), TWO_BYTES( 0x2f, 0xb5 ), 
TWO_BYTES( 0xe1, 0x32 ), TWO_BYTES( 0x05, 0x8a ), TWO_BYTES( 0xec, 0x39 ), TWO_BYTES( 0x0b, 0x83 ),
TWO_BYTES( 0xfb, 0x24 ), TWO_BYTES( 0x19, 0x98 ), TWO_BYTES( 0xf6, 0x2f ), TWO_BYTES( 0x17, 0x91 ), 
TWO_BYTES( 0xd6, 0x8d ), TWO_BYTES( 0x76, 0x4d ), TWO_BYTES( 0xdb, 0x86 ), TWO_BYTES( 0x78, 0x44 ),
TWO_BYTES( 0xcc, 0x9b ), TWO_BYTES( 0x6a, 0x5f ), TWO_BYTES( 0xc1, 0x90 ), TWO_BYTES( 0x64, 0x56 ), 
TWO_BYTES( 0xe2, 0xa1 ), TWO_BYTES( 0x4e, 0x69 ), TWO_BYTES( 0xef, 0xaa ), TWO_BYTES( 0x40, 0x60 ),
TWO_BYTES( 0xf8, 0xb7 ), TWO_BYTES( 0x52, 0x7b ), TWO_BYTES( 0xf5, 0xbc ), TWO_BYTES( 0x5c, 0x72 ), 
TWO_BYTES( 0xbe, 0xd5 ), TWO_BYTES( 0x06, 0x05 ), TWO_BYTES( 0xb3, 0xde ), TWO_BYTES( 0x08, 0x0c ),
TWO_BYTES( 0xa4, 0xc3 ), TWO_BYTES( 0x1a, 0x17 ), TWO_BYTES( 0xa9, 0xc8 ), TWO_BYTES( 0x14, 0x1e ), 
TWO_BYTES( 0x8a, 0xf9 ), TWO_BYTES( 0x3e, 0x21 ), TWO_BYTES( 0x87, 0xf2 ), TWO_BYTES( 0x30, 0x28 ),
TWO_BYTES( 0x90, 0xef ), TWO_BYTES( 0x22, 0x33 ), TWO_BYTES( 0x9d, 0xe4 ), TWO_BYTES( 0x2c, 0x3a ), 
TWO_BYTES( 0x06, 0x3d ), TWO_BYTES( 0x96, 0xdd ), TWO_BYTES( 0x0b, 0x36 ), TWO_BYTES( 0x98, 0xd4 ),
TWO_BYTES( 0x1c, 0x2b ), TWO_BYTES( 0x8a, 0xcf ), TWO_BYTES( 0x11, 0x20 ), TWO_BYTES( 0x84, 0xc6 ), 
TWO_BYTES( 0x32, 0x11 ), TWO_BYTES( 0xae, 0xf9 ), TWO_BYTES( 0x3f, 0x1a ), TWO_BYTES( 0xa0, 0xf0 ),
TWO_BYTES( 0x28, 0x07 ), TWO_BYTES( 0xb2, 0xeb ), TWO_BYTES( 0x25, 0x0c ), TWO_BYTES( 0xbc, 0xe2 ), 
TWO_BYTES( 0x6e, 0x65 ), TWO_BYTES( 0xe6, 0x95 ), TWO_BYTES( 0x63, 0x6e ), TWO_BYTES( 0xe8, 0x9c ),
TWO_BYTES( 0x74, 0x73 ), TWO_BYTES( 0xfa, 0x87 ), TWO_BYTES( 0x79, 0x78 ), TWO_BYTES( 0xf4, 0x8e ), 
TWO_BYTES( 0x5a, 0x49 ), TWO_BYTES( 0xde, 0xb1 ), TWO_BYTES( 0x57, 0x42 ), TWO_BYTES( 0xd0, 0xb8 ),
TWO_BYTES( 0x40, 0x5f ), TWO_BYTES( 0xc2, 0xa3 ), TWO_BYTES( 0x4d, 0x54 ), TWO_BYTES( 0xcc, 0xaa ), 
TWO_BYTES( 0xda, 0xf7 ), TWO_BYTES( 0x41, 0xec ), TWO_BYTES( 0xd7, 0xfc ), TWO_BYTES( 0x4f, 0xe5 ),
TWO_BYTES( 0xc0, 0xe1 ), TWO_BYTES( 0x5d, 0xfe ), TWO_BYTES( 0xcd, 0xea ), TWO_BYTES( 0x53, 0xf7 ), 
TWO_BYTES( 0xee, 0xdb ), TWO_BYTES( 0x79, 0xc8 ), TWO_BYTES( 0xe3, 0xd0 ), TWO_BYTES( 0x77, 0xc1 ),
TWO_BYTES( 0xf4, 0xcd ), TWO_BYTES( 0x65, 0xda ), TWO_BYTES( 0xf9, 0xc6 ), TWO_BYTES( 0x6b, 0xd3 ), 
TWO_BYTES( 0xb2, 0xaf ), TWO_BYTES( 0x31, 0xa4 ), TWO_BYTES( 0xbf, 0xa4 ), TWO_BYTES( 0x3f, 0xad ),
TWO_BYTES( 0xa8, 0xb9 ), TWO_BYTES( 0x2d, 0xb6 ), TWO_BYTES( 0xa5, 0xb2 ), TWO_BYTES( 0x23, 0xbf ), 
TWO_BYTES( 0x86, 0x83 ), TWO_BYTES( 0x09, 0x80 ), TWO_BYTES( 0x8b, 0x88 ), TWO_BYTES( 0x07, 0x89 ),
TWO_BYTES( 0x9c, 0x95 ), TWO_BYTES( 0x15, 0x92 ), TWO_BYTES( 0x91, 0x9e ), TWO_BYTES( 0x1b, 0x9b ), 
TWO_BYTES( 0x0a, 0x47 ), TWO_BYTES( 0xa1, 0x7c ), TWO_BYTES( 0x07, 0x4c ), TWO_BYTES( 0xaf, 0x75 ),
TWO_BYTES( 0x10, 0x51 ), TWO_BYTES( 0xbd, 0x6e ), TWO_BYTES( 0x1d, 0x5a ), TWO_BYTES( 0xb3, 0x67 ), 
TWO_BYTES( 0x3e, 0x6b ), TWO_BYTES( 0x99, 0x58 ), TWO_BYTES( 0x33, 0x60 ), TWO_BYTES( 0x97, 0x51 ),
TWO_BYTES( 0x24, 0x7d ), TWO_BYTES( 0x85, 0x4a ), TWO_BYTES( 0x29, 0x76 ), TWO_BYTES( 0x8b, 0x43 ), 
TWO_BYTES( 0x62, 0x1f ), TWO_BYTES( 0xd1, 0x34 ), TWO_BYTES( 0x6f, 0x14 ), TWO_BYTES( 0xdf, 0x3d ),
TWO_BYTES( 0x78, 0x09 ), TWO_BYTES( 0xcd, 0x26 ), TWO_BYTES( 0x75, 0x02 ), TWO_BYTES( 0xc3, 0x2f ), 
TWO_BYTES( 0x56, 0x33 ), TWO_BYTES( 0xe9, 0x10 ), TWO_BYTES( 0x5b, 0x38 ), TWO_BYTES( 0xe7, 0x19 ),
TWO_BYTES( 0x4c, 0x25 ), TWO_BYTES( 0xf5, 0x02 ), TWO_BYTES( 0x41, 0x2e ), TWO_BYTES( 0xfb, 0x0b ), 
TWO_BYTES( 0x61, 0x8c ), TWO_BYTES( 0x9a, 0xd7 ), TWO_BYTES( 0x6c, 0x87 ), TWO_BYTES( 0x94, 0xde ),
TWO_BYTES( 0x7b, 0x9a ), TWO_BYTES( 0x86, 0xc5 ), TWO_BYTES( 0x76, 0x91 ), TWO_BYTES( 0x88, 0xcc ), 
TWO_BYTES( 0x55, 0xa0 ), TWO_BYTES( 0xa2, 0xf3 ), TWO_BYTES( 0x58, 0xab ), TWO_BYTES( 0xac, 0xfa ),
TWO_BYTES( 0x4f, 0xb6 ), TWO_BYTES( 0xbe, 0xe1 ), TWO_BYTES( 0x42, 0xbd ), TWO_BYTES( 0xb0, 0xe8 ), 
TWO_BYTES( 0x09, 0xd4 ), TWO_BYTES( 0xea, 0x9f ), TWO_BYTES( 0x04, 0xdf ), TWO_BYTES( 0xe4, 0x96 ),
TWO_BYTES( 0x13, 0xc2 ), TWO_BYTES( 0xf6, 0x8d ), TWO_BYTES( 0x1e, 0xc9 ), TWO_BYTES( 0xf8, 0x84 ), 
TWO_BYTES( 0x3d, 0xf8 ), TWO_BYTES( 0xd2, 0xbb ), TWO_BYTES( 0x30, 0xf3 ), TWO_BYTES( 0xdc, 0xb2 ),
TWO_BYTES( 0x27, 0xee ), TWO_BYTES( 0xce, 0xa9 ), TWO_BYTES( 0x2a, 0xe5 ), TWO_BYTES( 0xc0, 0xa0 ), 
TWO_BYTES( 0xb1, 0x3c ), TWO_BYTES( 0x7a, 0x47 ), TWO_BYTES( 0xbc, 0x37 ), TWO_BYTES( 0x74, 0x4e ),
TWO_BYTES( 0xab, 0x2a ), TWO_BYTES( 0x66, 0x55 ), TWO_BYTES( 0xa6, 0x21 ), TWO_BYTES( 0x68, 0x5c ), 
TWO_BYTES( 0x85, 0x10 ), TWO_BYTES( 0x42, 0x63 ), TWO_BYTES( 0x88, 0x1b ), TWO_BYTES( 0x4c, 0x6a ),
TWO_BYTES( 0x9f, 0x06 ), TWO_BYTES( 0x5e, 0x71 ), TWO_BYTES( 0x92, 0x0d ), TWO_BYTES( 0x50, 0x78 ), 
TWO_BYTES( 0xd9, 0x64 ), TWO_BYTES( 0x0a, 0x0f ), TWO_BYTES( 0xd4, 0x6f ), TWO_BYTES( 0x04, 0x06 ),
TWO_BYTES( 0xc3, 0x72 ), TWO_BYTES( 0x16, 0x1d ), TWO_BYTES( 0xce, 0x79 ), TWO_BYTES( 0x18, 0x14 ), 
TWO_BYTES( 0xed, 0x48 ), TWO_BYTES( 0x32, 0x2b ), TWO_BYTES( 0xe0, 0x43 ), TWO_BYTES( 0x3c, 0x22 ),
TWO_BYTES( 0xf7, 0x5e ), TWO_BYTES( 0x2e, 0x39 ), TWO_BYTES( 0xfa, 0x55 ), TWO_BYTES( 0x20, 0x30 ), 
TWO_BYTES( 0xb7, 0x01 ), TWO_BYTES( 0xec, 0x9a ), TWO_BYTES( 0xba, 0x0a ), TWO_BYTES( 0xe2, 0x93 ),
TWO_BYTES( 0xad, 0x17 ), TWO_BYTES( 0xf0, 0x88 ), TWO_BYTES( 0xa0, 0x1c ), TWO_BYTES( 0xfe, 0x81 ), 
TWO_BYTES( 0x83, 0x2d ), TWO_BYTES( 0xd4, 0xbe ), TWO_BYTES( 0x8e, 0x26 ), TWO_BYTES( 0xda, 0xb7 ),
TWO_BYTES( 0x99, 0x3b ), TWO_BYTES( 0xc8, 0xac ), TWO_BYTES( 0x94, 0x30 ), TWO_BYTES( 0xc6, 0xa5 ), 
TWO_BYTES( 0xdf, 0x59 ), TWO_BYTES( 0x9c, 0xd2 ), TWO_BYTES( 0xd2, 0x52 ), TWO_BYTES( 0x92, 0xdb ),
TWO_BYTES( 0xc5, 0x4f ), TWO_BYTES( 0x80, 0xc0 ), TWO_BYTES( 0xc8, 0x44 ), TWO_BYTES( 0x8e, 0xc9 ), 
TWO_BYTES( 0xeb, 0x75 ), TWO_BYTES( 0xa4, 0xf6 ), TWO_BYTES( 0xe6, 0x7e ), TWO_BYTES( 0xaa, 0xff ),
TWO_BYTES( 0xf1, 0x63 ), TWO_BYTES( 0xb8, 0xe4 ), TWO_BYTES( 0xfc, 0x68 ), TWO_BYTES( 0xb6, 0xed ), 
TWO_BYTES( 0x67, 0xb1 ), TWO_BYTES( 0x0c, 0x0a ), TWO_BYTES( 0x6a, 0xba ), TWO_BYTES( 0x02, 0x03 ),
TWO_BYTES( 0x7d, 0xa7 ), TWO_BYTES( 0x10, 0x18 ), TWO_BYTES( 0x70, 0xac ), TWO_BYTES( 0x1e, 0x11 ), 
TWO_BYTES( 0x53, 0x9d ), TWO_BYTES( 0x34, 0x2e ), TWO_BYTES( 0x5e, 0x96 ), TWO_BYTES( 0x3a, 0x27 ),
TWO_BYTES( 0x49, 0x8b ), TWO_BYTES( 0x28, 0x3c ), TWO_BYTES( 0x44, 0x80 ), TWO_BYTES( 0x26, 0x35 ), 
TWO_BYTES( 0x0f, 0xe9 ), TWO_BYTES( 0x7c, 0x42 ), TWO_BYTES( 0x02, 0xe2 ), TWO_BYTES( 0x72, 0x4b ),
TWO_BYTES( 0x15, 0xff ), TWO_BYTES( 0x60, 0x50 ), TWO_BYTES( 0x18, 0xf4 ), TWO_BYTES( 0x6e, 0x59 ), 
TWO_BYTES( 0x3b, 0xc5 ), TWO_BYTES( 0x44, 0x66 ), TWO_BYTES( 0x36, 0xce ), TWO_BYTES( 0x4a, 0x6f ),
TWO_BYTES( 0x21, 0xd3 ), TWO_BYTES( 0x58, 0x74 ), TWO_BYTES( 0x2c, 0xd8 ), TWO_BYTES( 0x56, 0x7d ), 
TWO_BYTES( 0x0c, 0x7a ), TWO_BYTES( 0x37, 0xa1 ), TWO_BYTES( 0x01, 0x71 ), TWO_BYTES( 0x39, 0xa8 ),
TWO_BYTES( 0x16, 0x6c ), TWO_BYTES( 0x2b, 0xb3 ), TWO_BYTES( 0x1b, 0x67 ), TWO_BYTES( 0x25, 0xba ), 
TWO_BYTES( 0x38, 0x56 ), TWO_BYTES( 0x0f, 0x85 ), TWO_BYTES( 0x35, 0x5d ), TWO_BYTES( 0x01, 0x8c ),
TWO_BYTES( 0x22, 0x40 ), TWO_BYTES( 0x13, 0x97 ), TWO_BYTES( 0x2f, 0x4b ), TWO_BYTES( 0x1d, 0x9e ), 
TWO_BYTES( 0x64, 0x22 ), TWO_BYTES( 0x47, 0xe9 ), TWO_BYTES( 0x69, 0x29 ), TWO_BYTES( 0x49, 0xe0 ),
TWO_BYTES( 0x7e, 0x34 ), TWO_BYTES( 0x5b, 0xfb ), TWO_BYTES( 0x73, 0x3f ), TWO_BYTES( 0x55, 0xf2 ), 
TWO_BYTES( 0x50, 0x0e ), TWO_BYTES( 0x7f, 0xcd ), TWO_BYTES( 0x5d, 0x05 ), TWO_BYTES( 0x71, 0xc4 ),
TWO_BYTES( 0x4a, 0x18 ), TWO_BYTES( 0x63, 0xdf ), TWO_BYTES( 0x47, 0x13 ), TWO_BYTES( 0x6d, 0xd6 ), 
TWO_BYTES( 0xdc, 0xca ), TWO_BYTES( 0xd7, 0x31 ), TWO_BYTES( 0xd1, 0xc1 ), TWO_BYTES( 0xd9, 0x38 ),
TWO_BYTES( 0xc6, 0xdc ), TWO_BYTES( 0xcb, 0x23 ), TWO_BYTES( 0xcb, 0xd7 ), TWO_BYTES( 0xc5, 0x2a ), 
TWO_BYTES( 0xe8, 0xe6 ), TWO_BYTES( 0xef, 0x15 ), TWO_BYTES( 0xe5, 0xed ), TWO_BYTES( 0xe1, 0x1c ),
TWO_BYTES( 0xf2, 0xf0 ), TWO_BYTES( 0xf3, 0x07 ), TWO_BYTES( 0xff, 0xfb ), TWO_BYTES( 0xfd, 0x0e ), 
TWO_BYTES( 0xb4, 0x92 ), TWO_BYTES( 0xa7, 0x79 ), TWO_BYTES( 0xb9, 0x99 ), TWO_BYTES( 0xa9, 0x70 ),
TWO_BYTES( 0xae, 0x84 ), TWO_BYTES( 0xbb, 0x6b ), TWO_BYTES( 0xa3, 0x8f ), TWO_BYTES( 0xb5, 0x62 ), 
TWO_BYTES( 0x80, 0xbe ), TWO_BYTES( 0x9f, 0x5d ), TWO_BYTES( 0x8d, 0xb5 ), TWO_BYTES( 0x91, 0x54 ),
TWO_BYTES( 0x9a, 0xa8 ), TWO_BYTES( 0x83, 0x4f ), TWO_BYTES( 0x97, 0xa3 ), TWO_BYTES( 0x8d, 0x46 )
};

const DRM_DWORD_ALIGN DRM_BYTE U4[256][__CB_DECL( 4 )] = 
{
TWO_BYTES( 0x00, 0x00 ), TWO_BYTES( 0x00, 0x00 ), TWO_BYTES( 0x09, 0x0d ), TWO_BYTES( 0x0b, 0x0e ),
TWO_BYTES( 0x12, 0x1a ), TWO_BYTES( 0x16, 0x1c ), TWO_BYTES( 0x1b, 0x17 ), TWO_BYTES( 0x1d, 0x12 ), 
TWO_BYTES( 0x24, 0x34 ), TWO_BYTES( 0x2c, 0x38 ), TWO_BYTES( 0x2d, 0x39 ), TWO_BYTES( 0x27, 0x36 ),
TWO_BYTES( 0x36, 0x2e ), TWO_BYTES( 0x3a, 0x24 ), TWO_BYTES( 0x3f, 0x23 ), TWO_BYTES( 0x31, 0x2a ), 
TWO_BYTES( 0x48, 0x68 ), TWO_BYTES( 0x58, 0x70 ), TWO_BYTES( 0x41, 0x65 ), TWO_BYTES( 0x53, 0x7e ),
TWO_BYTES( 0x5a, 0x72 ), TWO_BYTES( 0x4e, 0x6c ), TWO_BYTES( 0x53, 0x7f ), TWO_BYTES( 0x45, 0x62 ), 
TWO_BYTES( 0x6c, 0x5c ), TWO_BYTES( 0x74, 0x48 ), TWO_BYTES( 0x65, 0x51 ), TWO_BYTES( 0x7f, 0x46 ),
TWO_BYTES( 0x7e, 0x46 ), TWO_BYTES( 0x62, 0x54 ), TWO_BYTES( 0x77, 0x4b ), TWO_BYTES( 0x69, 0x5a ), 
TWO_BYTES( 0x90, 0xd0 ), TWO_BYTES( 0xb0, 0xe0 ), TWO_BYTES( 0x99, 0xdd ), TWO_BYTES( 0xbb, 0xee ),
TWO_BYTES( 0x82, 0xca ), TWO_BYTES( 0xa6, 0xfc ), TWO_BYTES( 0x8b, 0xc7 ), TWO_BYTES( 0xad, 0xf2 ), 
TWO_BYTES( 0xb4, 0xe4 ), TWO_BYTES( 0x9c, 0xd8 ), TWO_BYTES( 0xbd, 0xe9 ), TWO_BYTES( 0x97, 0xd6 ),
TWO_BYTES( 0xa6, 0xfe ), TWO_BYTES( 0x8a, 0xc4 ), TWO_BYTES( 0xaf, 0xf3 ), TWO_BYTES( 0x81, 0xca ), 
TWO_BYTES( 0xd8, 0xb8 ), TWO_BYTES( 0xe8, 0x90 ), TWO_BYTES( 0xd1, 0xb5 ), TWO_BYTES( 0xe3, 0x9e ),
TWO_BYTES( 0xca, 0xa2 ), TWO_BYTES( 0xfe, 0x8c ), TWO_BYTES( 0xc3, 0xaf ), TWO_BYTES( 0xf5, 0x82 ), 
TWO_BYTES( 0xfc, 0x8c ), TWO_BYTES( 0xc4, 0xa8 ), TWO_BYTES( 0xf5, 0x81 ), TWO_BYTES( 0xcf, 0xa6 ),
TWO_BYTES( 0xee, 0x96 ), TWO_BYTES( 0xd2, 0xb4 ), TWO_BYTES( 0xe7, 0x9b ), TWO_BYTES( 0xd9, 0xba ), 
TWO_BYTES( 0x3b, 0xbb ), TWO_BYTES( 0x7b, 0xdb ), TWO_BYTES( 0x32, 0xb6 ), TWO_BYTES( 0x70, 0xd5 ),
TWO_BYTES( 0x29, 0xa1 ), TWO_BYTES( 0x6d, 0xc7 ), TWO_BYTES( 0x20, 0xac ), TWO_BYTES( 0x66, 0xc9 ), 
TWO_BYTES( 0x1f, 0x8f ), TWO_BYTES( 0x57, 0xe3 ), TWO_BYTES( 0x16, 0x82 ), TWO_BYTES( 0x5c, 0xed ),
TWO_BYTES( 0x0d, 0x95 ), TWO_BYTES( 0x41, 0xff ), TWO_BYTES( 0x04, 0x98 ), TWO_BYTES( 0x4a, 0xf1 ), 
TWO_BYTES( 0x73, 0xd3 ), TWO_BYTES( 0x23, 0xab ), TWO_BYTES( 0x7a, 0xde ), TWO_BYTES( 0x28, 0xa5 ),
TWO_BYTES( 0x61, 0xc9 ), TWO_BYTES( 0x35, 0xb7 ), TWO_BYTES( 0x68, 0xc4 ), TWO_BYTES( 0x3e, 0xb9 ), 
TWO_BYTES( 0x57, 0xe7 ), TWO_BYTES( 0x0f, 0x93 ), TWO_BYTES( 0x5e, 0xea ), TWO_BYTES( 0x04, 0x9d ),
TWO_BYTES( 0x45, 0xfd ), TWO_BYTES( 0x19, 0x8f ), TWO_BYTES( 0x4c, 0xf0 ), TWO_BYTES( 0x12, 0x81 ), 
TWO_BYTES( 0xab, 0x6b ), TWO_BYTES( 0xcb, 0x3b ), TWO_BYTES( 0xa2, 0x66 ), TWO_BYTES( 0xc0, 0x35 ),
TWO_BYTES( 0xb9, 0x71 ), TWO_BYTES( 0xdd, 0x27 ), TWO_BYTES( 0xb0, 0x7c ), TWO_BYTES( 0xd6, 0x29 ), 
TWO_BYTES( 0x8f, 0x5f ), TWO_BYTES( 0xe7, 0x03 ), TWO_BYTES( 0x86, 0x52 ), TWO_BYTES( 0xec, 0x0d ),
TWO_BYTES( 0x9d, 0x45 ), TWO_BYTES( 0xf1, 0x1f ), TWO_BYTES( 0x94, 0x48 ), TWO_BYTES( 0xfa, 0x11 ), 
TWO_BYTES( 0xe3, 0x03 ), TWO_BYTES( 0x93, 0x4b ), TWO_BYTES( 0xea, 0x0e ), TWO_BYTES( 0x98, 0x45 ),
TWO_BYTES( 0xf1, 0x19 ), TWO_BYTES( 0x85, 0x57 ), TWO_BYTES( 0xf8, 0x14 ), TWO_BYTES( 0x8e, 0x59 ), 
TWO_BYTES( 0xc7, 0x37 ), TWO_BYTES( 0xbf, 0x73 ), TWO_BYTES( 0xce, 0x3a ), TWO_BYTES( 0xb4, 0x7d ),
TWO_BYTES( 0xd5, 0x2d ), TWO_BYTES( 0xa9, 0x6f ), TWO_BYTES( 0xdc, 0x20 ), TWO_BYTES( 0xa2, 0x61 ), 
TWO_BYTES( 0x76, 0x6d ), TWO_BYTES( 0xf6, 0xad ), TWO_BYTES( 0x7f, 0x60 ), TWO_BYTES( 0xfd, 0xa3 ),
TWO_BYTES( 0x64, 0x77 ), TWO_BYTES( 0xe0, 0xb1 ), TWO_BYTES( 0x6d, 0x7a ), TWO_BYTES( 0xeb, 0xbf ), 
TWO_BYTES( 0x52, 0x59 ), TWO_BYTES( 0xda, 0x95 ), TWO_BYTES( 0x5b, 0x54 ), TWO_BYTES( 0xd1, 0x9b ),
TWO_BYTES( 0x40, 0x43 ), TWO_BYTES( 0xcc, 0x89 ), TWO_BYTES( 0x49, 0x4e ), TWO_BYTES( 0xc7, 0x87 ), 
TWO_BYTES( 0x3e, 0x05 ), TWO_BYTES( 0xae, 0xdd ), TWO_BYTES( 0x37, 0x08 ), TWO_BYTES( 0xa5, 0xd3 ),
TWO_BYTES( 0x2c, 0x1f ), TWO_BYTES( 0xb8, 0xc1 ), TWO_BYTES( 0x25, 0x12 ), TWO_BYTES( 0xb3, 0xcf ), 
TWO_BYTES( 0x1a, 0x31 ), TWO_BYTES( 0x82, 0xe5 ), TWO_BYTES( 0x13, 0x3c ), TWO_BYTES( 0x89, 0xeb ),
TWO_BYTES( 0x08, 0x2b ), TWO_BYTES( 0x94, 0xf9 ), TWO_BYTES( 0x01, 0x26 ), TWO_BYTES( 0x9f, 0xf7 ), 
TWO_BYTES( 0xe6, 0xbd ), TWO_BYTES( 0x46, 0x4d ), TWO_BYTES( 0xef, 0xb0 ), TWO_BYTES( 0x4d, 0x43 ),
TWO_BYTES( 0xf4, 0xa7 ), TWO_BYTES( 0x50, 0x51 ), TWO_BYTES( 0xfd, 0xaa ), TWO_BYTES( 0x5b, 0x5f ), 
TWO_BYTES( 0xc2, 0x89 ), TWO_BYTES( 0x6a, 0x75 ), TWO_BYTES( 0xcb, 0x84 ), TWO_BYTES( 0x61, 0x7b ),
TWO_BYTES( 0xd0, 0x93 ), TWO_BYTES( 0x7c, 0x69 ), TWO_BYTES( 0xd9, 0x9e ), TWO_BYTES( 0x77, 0x67 ), 
TWO_BYTES( 0xae, 0xd5 ), TWO_BYTES( 0x1e, 0x3d ), TWO_BYTES( 0xa7, 0xd8 ), TWO_BYTES( 0x15, 0x33 ),
TWO_BYTES( 0xbc, 0xcf ), TWO_BYTES( 0x08, 0x21 ), TWO_BYTES( 0xb5, 0xc2 ), TWO_BYTES( 0x03, 0x2f ), 
TWO_BYTES( 0x8a, 0xe1 ), TWO_BYTES( 0x32, 0x05 ), TWO_BYTES( 0x83, 0xec ), TWO_BYTES( 0x39, 0x0b ),
TWO_BYTES( 0x98, 0xfb ), TWO_BYTES( 0x24, 0x19 ), TWO_BYTES( 0x91, 0xf6 ), TWO_BYTES( 0x2f, 0x17 ), 
TWO_BYTES( 0x4d, 0xd6 ), TWO_BYTES( 0x8d, 0x76 ), TWO_BYTES( 0x44, 0xdb ), TWO_BYTES( 0x86, 0x78 ),
TWO_BYTES( 0x5f, 0xcc ), TWO_BYTES( 0x9b, 0x6a ), TWO_BYTES( 0x56, 0xc1 ), TWO_BYTES( 0x90, 0x64 ), 
TWO_BYTES( 0x69, 0xe2 ), TWO_BYTES( 0xa1, 0x4e ), TWO_BYTES( 0x60, 0xef ), TWO_BYTES( 0xaa, 0x40 ),
TWO_BYTES( 0x7b, 0xf8 ), TWO_BYTES( 0xb7, 0x52 ), TWO_BYTES( 0x72, 0xf5 ), TWO_BYTES( 0xbc, 0x5c ), 
TWO_BYTES( 0x05, 0xbe ), TWO_BYTES( 0xd5, 0x06 ), TWO_BYTES( 0x0c, 0xb3 ), TWO_BYTES( 0xde, 0x08 ),
TWO_BYTES( 0x17, 0xa4 ), TWO_BYTES( 0xc3, 0x1a ), TWO_BYTES( 0x1e, 0xa9 ), TWO_BYTES( 0xc8, 0x14 ), 
TWO_BYTES( 0x21, 0x8a ), TWO_BYTES( 0xf9, 0x3e ), TWO_BYTES( 0x28, 0x87 ), TWO_BYTES( 0xf2, 0x30 ),
TWO_BYTES( 0x33, 0x90 ), TWO_BYTES( 0xef, 0x22 ), TWO_BYTES( 0x3a, 0x9d ), TWO_BYTES( 0xe4, 0x2c ), 
TWO_BYTES( 0xdd, 0x06 ), TWO_BYTES( 0x3d, 0x96 ), TWO_BYTES( 0xd4, 0x0b ), TWO_BYTES( 0x36, 0x98 ),
TWO_BYTES( 0xcf, 0x1c ), TWO_BYTES( 0x2b, 0x8a ), TWO_BYTES( 0xc6, 0x11 ), TWO_BYTES( 0x20, 0x84 ), 
TWO_BYTES( 0xf9, 0x32 ), TWO_BYTES( 0x11, 0xae ), TWO_BYTES( 0xf0, 0x3f ), TWO_BYTES( 0x1a, 0xa0 ),
TWO_BYTES( 0xeb, 0x28 ), TWO_BYTES( 0x07, 0xb2 ), TWO_BYTES( 0xe2, 0x25 ), TWO_BYTES( 0x0c, 0xbc ), 
TWO_BYTES( 0x95, 0x6e ), TWO_BYTES( 0x65, 0xe6 ), TWO_BYTES( 0x9c, 0x63 ), TWO_BYTES( 0x6e, 0xe8 ),
TWO_BYTES( 0x87, 0x74 ), TWO_BYTES( 0x73, 0xfa ), TWO_BYTES( 0x8e, 0x79 ), TWO_BYTES( 0x78, 0xf4 ), 
TWO_BYTES( 0xb1, 0x5a ), TWO_BYTES( 0x49, 0xde ), TWO_BYTES( 0xb8, 0x57 ), TWO_BYTES( 0x42, 0xd0 ),
TWO_BYTES( 0xa3, 0x40 ), TWO_BYTES( 0x5f, 0xc2 ), TWO_BYTES( 0xaa, 0x4d ), TWO_BYTES( 0x54, 0xcc ), 
TWO_BYTES( 0xec, 0xda ), TWO_BYTES( 0xf7, 0x41 ), TWO_BYTES( 0xe5, 0xd7 ), TWO_BYTES( 0xfc, 0x4f ),
TWO_BYTES( 0xfe, 0xc0 ), TWO_BYTES( 0xe1, 0x5d ), TWO_BYTES( 0xf7, 0xcd ), TWO_BYTES( 0xea, 0x53 ), 
TWO_BYTES( 0xc8, 0xee ), TWO_BYTES( 0xdb, 0x79 ), TWO_BYTES( 0xc1, 0xe3 ), TWO_BYTES( 0xd0, 0x77 ),
TWO_BYTES( 0xda, 0xf4 ), TWO_BYTES( 0xcd, 0x65 ), TWO_BYTES( 0xd3, 0xf9 ), TWO_BYTES( 0xc6, 0x6b ), 
TWO_BYTES( 0xa4, 0xb2 ), TWO_BYTES( 0xaf, 0x31 ), TWO_BYTES( 0xad, 0xbf ), TWO_BYTES( 0xa4, 0x3f ),
TWO_BYTES( 0xb6, 0xa8 ), TWO_BYTES( 0xb9, 0x2d ), TWO_BYTES( 0xbf, 0xa5 ), TWO_BYTES( 0xb2, 0x23 ), 
TWO_BYTES( 0x80, 0x86 ), TWO_BYTES( 0x83, 0x09 ), TWO_BYTES( 0x89, 0x8b ), TWO_BYTES( 0x88, 0x07 ),
TWO_BYTES( 0x92, 0x9c ), TWO_BYTES( 0x95, 0x15 ), TWO_BYTES( 0x9b, 0x91 ), TWO_BYTES( 0x9e, 0x1b ), 
TWO_BYTES( 0x7c, 0x0a ), TWO_BYTES( 0x47, 0xa1 ), TWO_BYTES( 0x75, 0x07 ), TWO_BYTES( 0x4c, 0xaf ),
TWO_BYTES( 0x6e, 0x10 ), TWO_BYTES( 0x51, 0xbd ), TWO_BYTES( 0x67, 0x1d ), TWO_BYTES( 0x5a, 0xb3 ), 
TWO_BYTES( 0x58, 0x3e ), TWO_BYTES( 0x6b, 0x99 ), TWO_BYTES( 0x51, 0x33 ), TWO_BYTES( 0x60, 0x97 ),
TWO_BYTES( 0x4a, 0x24 ), TWO_BYTES( 0x7d, 0x85 ), TWO_BYTES( 0x43, 0x29 ), TWO_BYTES( 0x76, 0x8b ), 
TWO_BYTES( 0x34, 0x62 ), TWO_BYTES( 0x1f, 0xd1 ), TWO_BYTES( 0x3d, 0x6f ), TWO_BYTES( 0x14, 0xdf ),
TWO_BYTES( 0x26, 0x78 ), TWO_BYTES( 0x09, 0xcd ), TWO_BYTES( 0x2f, 0x75 ), TWO_BYTES( 0x02, 0xc3 ), 
TWO_BYTES( 0x10, 0x56 ), TWO_BYTES( 0x33, 0xe9 ), TWO_BYTES( 0x19, 0x5b ), TWO_BYTES( 0x38, 0xe7 ),
TWO_BYTES( 0x02, 0x4c ), TWO_BYTES( 0x25, 0xf5 ), TWO_BYTES( 0x0b, 0x41 ), TWO_BYTES( 0x2e, 0xfb ), 
TWO_BYTES( 0xd7, 0x61 ), TWO_BYTES( 0x8c, 0x9a ), TWO_BYTES( 0xde, 0x6c ), TWO_BYTES( 0x87, 0x94 ),
TWO_BYTES( 0xc5, 0x7b ), TWO_BYTES( 0x9a, 0x86 ), TWO_BYTES( 0xcc, 0x76 ), TWO_BYTES( 0x91, 0x88 ), 
TWO_BYTES( 0xf3, 0x55 ), TWO_BYTES( 0xa0, 0xa2 ), TWO_BYTES( 0xfa, 0x58 ), TWO_BYTES( 0xab, 0xac ),
TWO_BYTES( 0xe1, 0x4f ), TWO_BYTES( 0xb6, 0xbe ), TWO_BYTES( 0xe8, 0x42 ), TWO_BYTES( 0xbd, 0xb0 ), 
TWO_BYTES( 0x9f, 0x09 ), TWO_BYTES( 0xd4, 0xea ), TWO_BYTES( 0x96, 0x04 ), TWO_BYTES( 0xdf, 0xe4 ),
TWO_BYTES( 0x8d, 0x13 ), TWO_BYTES( 0xc2, 0xf6 ), TWO_BYTES( 0x84, 0x1e ), TWO_BYTES( 0xc9, 0xf8 ), 
TWO_BYTES( 0xbb, 0x3d ), TWO_BYTES( 0xf8, 0xd2 ), TWO_BYTES( 0xb2, 0x30 ), TWO_BYTES( 0xf3, 0xdc ),
TWO_BYTES( 0xa9, 0x27 ), TWO_BYTES( 0xee, 0xce ), TWO_BYTES( 0xa0, 0x2a ), TWO_BYTES( 0xe5, 0xc0 ), 
TWO_BYTES( 0x47, 0xb1 ), TWO_BYTES( 0x3c, 0x7a ), TWO_BYTES( 0x4e, 0xbc ), TWO_BYTES( 0x37, 0x74 ),
TWO_BYTES( 0x55, 0xab ), TWO_BYTES( 0x2a, 0x66 ), TWO_BYTES( 0x5c, 0xa6 ), TWO_BYTES( 0x21, 0x68 ), 
TWO_BYTES( 0x63, 0x85 ), TWO_BYTES( 0x10, 0x42 ), TWO_BYTES( 0x6a, 0x88 ), TWO_BYTES( 0x1b, 0x4c ),
TWO_BYTES( 0x71, 0x9f ), TWO_BYTES( 0x06, 0x5e ), TWO_BYTES( 0x78, 0x92 ), TWO_BYTES( 0x0d, 0x50 ), 
TWO_BYTES( 0x0f, 0xd9 ), TWO_BYTES( 0x64, 0x0a ), TWO_BYTES( 0x06, 0xd4 ), TWO_BYTES( 0x6f, 0x04 ),
TWO_BYTES( 0x1d, 0xc3 ), TWO_BYTES( 0x72, 0x16 ), TWO_BYTES( 0x14, 0xce ), TWO_BYTES( 0x79, 0x18 ), 
TWO_BYTES( 0x2b, 0xed ), TWO_BYTES( 0x48, 0x32 ), TWO_BYTES( 0x22, 0xe0 ), TWO_BYTES( 0x43, 0x3c ),
TWO_BYTES( 0x39, 0xf7 ), TWO_BYTES( 0x5e, 0x2e ), TWO_BYTES( 0x30, 0xfa ), TWO_BYTES( 0x55, 0x20 ), 
TWO_BYTES( 0x9a, 0xb7 ), TWO_BYTES( 0x01, 0xec ), TWO_BYTES( 0x93, 0xba ), TWO_BYTES( 0x0a, 0xe2 ),
TWO_BYTES( 0x88, 0xad ), TWO_BYTES( 0x17, 0xf0 ), TWO_BYTES( 0x81, 0xa0 ), TWO_BYTES( 0x1c, 0xfe ), 
TWO_BYTES( 0xbe, 0x83 ), TWO_BYTES( 0x2d, 0xd4 ), TWO_BYTES( 0xb7, 0x8e ), TWO_BYTES( 0x26, 0xda ),
TWO_BYTES( 0xac, 0x99 ), TWO_BYTES( 0x3b, 0xc8 ), TWO_BYTES( 0xa5, 0x94 ), TWO_BYTES( 0x30, 0xc6 ), 
TWO_BYTES( 0xd2, 0xdf ), TWO_BYTES( 0x59, 0x9c ), TWO_BYTES( 0xdb, 0xd2 ), TWO_BYTES( 0x52, 0x92 ),
TWO_BYTES( 0xc0, 0xc5 ), TWO_BYTES( 0x4f, 0x80 ), TWO_BYTES( 0xc9, 0xc8 ), TWO_BYTES( 0x44, 0x8e ), 
TWO_BYTES( 0xf6, 0xeb ), TWO_BYTES( 0x75, 0xa4 ), TWO_BYTES( 0xff, 0xe6 ), TWO_BYTES( 0x7e, 0xaa ),
TWO_BYTES( 0xe4, 0xf1 ), TWO_BYTES( 0x63, 0xb8 ), TWO_BYTES( 0xed, 0xfc ), TWO_BYTES( 0x68, 0xb6 ), 
TWO_BYTES( 0x0a, 0x67 ), TWO_BYTES( 0xb1, 0x0c ), TWO_BYTES( 0x03, 0x6a ), TWO_BYTES( 0xba, 0x02 ),
TWO_BYTES( 0x18, 0x7d ), TWO_BYTES( 0xa7, 0x10 ), TWO_BYTES( 0x11, 0x70 ), TWO_BYTES( 0xac, 0x1e ), 
TWO_BYTES( 0x2e, 0x53 ), TWO_BYTES( 0x9d, 0x34 ), TWO_BYTES( 0x27, 0x5e ), TWO_BYTES( 0x96, 0x3a ),
TWO_BYTES( 0x3c, 0x49 ), TWO_BYTES( 0x8b, 0x28 ), TWO_BYTES( 0x35, 0x44 ), TWO_BYTES( 0x80, 0x26 ), 
TWO_BYTES( 0x42, 0x0f ), TWO_BYTES( 0xe9, 0x7c ), TWO_BYTES( 0x4b, 0x02 ), TWO_BYTES( 0xe2, 0x72 ),
TWO_BYTES( 0x50, 0x15 ), TWO_BYTES( 0xff, 0x60 ), TWO_BYTES( 0x59, 0x18 ), TWO_BYTES( 0xf4, 0x6e ), 
TWO_BYTES( 0x66, 0x3b ), TWO_BYTES( 0xc5, 0x44 ), TWO_BYTES( 0x6f, 0x36 ), TWO_BYTES( 0xce, 0x4a ),
TWO_BYTES( 0x74, 0x21 ), TWO_BYTES( 0xd3, 0x58 ), TWO_BYTES( 0x7d, 0x2c ), TWO_BYTES( 0xd8, 0x56 ), 
TWO_BYTES( 0xa1, 0x0c ), TWO_BYTES( 0x7a, 0x37 ), TWO_BYTES( 0xa8, 0x01 ), TWO_BYTES( 0x71, 0x39 ),
TWO_BYTES( 0xb3, 0x16 ), TWO_BYTES( 0x6c, 0x2b ), TWO_BYTES( 0xba, 0x1b ), TWO_BYTES( 0x67, 0x25 ), 
TWO_BYTES( 0x85, 0x38 ), TWO_BYTES( 0x56, 0x0f ), TWO_BYTES( 0x8c, 0x35 ), TWO_BYTES( 0x5d, 0x01 ),
TWO_BYTES( 0x97, 0x22 ), TWO_BYTES( 0x40, 0x13 ), TWO_BYTES( 0x9e, 0x2f ), TWO_BYTES( 0x4b, 0x1d ), 
TWO_BYTES( 0xe9, 0x64 ), TWO_BYTES( 0x22, 0x47 ), TWO_BYTES( 0xe0, 0x69 ), TWO_BYTES( 0x29, 0x49 ),
TWO_BYTES( 0xfb, 0x7e ), TWO_BYTES( 0x34, 0x5b ), TWO_BYTES( 0xf2, 0x73 ), TWO_BYTES( 0x3f, 0x55 ), 
TWO_BYTES( 0xcd, 0x50 ), TWO_BYTES( 0x0e, 0x7f ), TWO_BYTES( 0xc4, 0x5d ), TWO_BYTES( 0x05, 0x71 ),
TWO_BYTES( 0xdf, 0x4a ), TWO_BYTES( 0x18, 0x63 ), TWO_BYTES( 0xd6, 0x47 ), TWO_BYTES( 0x13, 0x6d ), 
TWO_BYTES( 0x31, 0xdc ), TWO_BYTES( 0xca, 0xd7 ), TWO_BYTES( 0x38, 0xd1 ), TWO_BYTES( 0xc1, 0xd9 ),
TWO_BYTES( 0x23, 0xc6 ), TWO_BYTES( 0xdc, 0xcb ), TWO_BYTES( 0x2a, 0xcb ), TWO_BYTES( 0xd7, 0xc5 ), 
TWO_BYTES( 0x15, 0xe8 ), TWO_BYTES( 0xe6, 0xef ), TWO_BYTES( 0x1c, 0xe5 ), TWO_BYTES( 0xed, 0xe1 ),
TWO_BYTES( 0x07, 0xf2 ), TWO_BYTES( 0xf0, 0xf3 ), TWO_BYTES( 0x0e, 0xff ), TWO_BYTES( 0xfb, 0xfd ), 
TWO_BYTES( 0x79, 0xb4 ), TWO_BYTES( 0x92, 0xa7 ), TWO_BYTES( 0x70, 0xb9 ), TWO_BYTES( 0x99, 0xa9 ),
TWO_BYTES( 0x6b, 0xae ), TWO_BYTES( 0x84, 0xbb ), TWO_BYTES( 0x62, 0xa3 ), TWO_BYTES( 0x8f, 0xb5 ), 
TWO_BYTES( 0x5d, 0x80 ), TWO_BYTES( 0xbe, 0x9f ), TWO_BYTES( 0x54, 0x8d ), TWO_BYTES( 0xb5, 0x91 ),
TWO_BYTES( 0x4f, 0x9a ), TWO_BYTES( 0xa8, 0x83 ), TWO_BYTES( 0x46, 0x97 ), TWO_BYTES( 0xa3, 0x8d )
};

const DRM_DWORD rcon[30] = 
{
  0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 
  0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91
};

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\lib\oemaes.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
** oemaes.c
**
** This file implements AES encryption of a single block sized buffer 
** Each OEM is expected to implement its own version of these routines.
*/

#include <oemaes.h>
#include "aes128.h"
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

/*********************************************************************************************
** Function:  Oem_Aes_ZeroKey 
**
** Synopsis:  Zeroes out an AES secret key
**
** Arguments: [f_pKey]  : The key to zero
**
** Returns:   DRM_SUCCESS
**              Success
**            DRM_E_INVALIDARG
**              f_pKey was NULL
**********************************************************************************************/
DRM_API DRM_RESULT DRM_CALL Oem_Aes_ZeroKey( 
    __inout_ecount( 1 )  DRM_AES_KEY  *f_pKey )
{
    DRM_RESULT            dr           = DRM_SUCCESS;
    INTERNAL_DRM_AES_KEY *pInternalKey = ( INTERNAL_DRM_AES_KEY * )f_pKey;
    
    ChkArg( f_pKey != NULL );

    /*
    ** Clear the key itself for security reasons 
    */
    OEM_SECURE_ZERO_MEMORY( pInternalKey->rgbKey, DRM_AES_BLOCKLEN );

    /*
    ** Clear the AES table computed from the key for security reasons 
    */
    OEM_SECURE_ZERO_MEMORY( &pInternalKey->AESTable, SIZEOF( pInternalKey->AESTable ) );

ErrorExit:
    return dr;
}


/*********************************************************************************************
** Function:  Oem_Aes_SetKey 
**
** Synopsis:  Initializes an AES secret key given the value of the key.
**
** Arguments: [f_rgbKey]  : Buffer containing the key data
**            [f_pAesKey] : Returns the AES key structure
**
** Returns:   DRM_SUCCESS
**               Success
**            DRM_E_INVALIDARG
**               One of the pointers was NULL or f_cbKey was an invalid size
**********************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL Oem_Aes_SetKey(
    __in_bcount( DRM_AES_KEYSIZE_128 ) const DRM_BYTE      f_rgbKey[__CB_DECL( DRM_AES_KEYSIZE_128 )],
    __inout_ecount( 1 )                      DRM_AES_KEY  *f_pAesKey )
{
    DRM_RESULT            dr           = DRM_SUCCESS;
    INTERNAL_DRM_AES_KEY *pInternalKey = ( INTERNAL_DRM_AES_KEY * )f_pAesKey;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_OEMAES, PERF_FUNC_Oem_Aes_SetKey );

    ChkArg ( f_pAesKey != NULL );
    ChkArg ( f_rgbKey   != NULL );
          
    /*
    ** Copy the actual key into the buffer
    */
    MEMCPY( pInternalKey->rgbKey, f_rgbKey, DRM_AES_KEYSIZE_128 );

    Aes_CreateKey128( &pInternalKey->AESTable, pInternalKey->rgbKey );

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}

/*********************************************************************************************
** Function:  Oem_Aes_EncryptOne 
**
** Synopsis:  AES encrypts one block in-place.
**
** Arguments: [f_pKey]    : A pointer to the opaque key structure
**            [f_rgbData] : Specifies the data to encrypt (in place)
**
** Returns:   DRM_SUCCESS
**                success
**            DRM_E_INVALIDARG
**                one of the arguments was NULL or improperly initialized
**            DRM_E_CIPHER_NOTINITIALIZED
**                The aes key has not been properly initialized with Oem_Aes_SetKey
**********************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL Oem_Aes_EncryptOne(
    __in_ecount( 1 )             const DRM_AES_KEY  *f_pKey,        
    __inout_bcount( DRM_AES_BLOCKLEN ) DRM_BYTE      f_rgbData[__CB_DECL( DRM_AES_BLOCKLEN )] )
{
    DRM_RESULT            dr           = DRM_SUCCESS;    
    INTERNAL_DRM_AES_KEY *pInternalKey = ( INTERNAL_DRM_AES_KEY * )f_pKey;    
    DRM_BYTE              rgbTemp[__CB_DECL( DRM_AES_BLOCKLEN )] = { 0 };

    /*
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_OEMAES, PERF_FUNC_Oem_Aes_EncryptOne );
    */

    ChkArg( f_pKey != NULL );

    /*
    ** Simply use the system's AES routine
    */
    Aes_Encrypt128( rgbTemp, f_rgbData, pInternalKey->AESTable.keytabenc );
    MEMCPY( f_rgbData, rgbTemp, DRM_AES_BLOCKLEN );

ErrorExit:
    /*
    DRM_PROFILING_LEAVE_SCOPE;
    */
    return dr;
}


/*********************************************************************************************
** Function:  Oem_Aes_DecryptOne 
**
** Synopsis:  AES decrypts one block in-place.
**
** Arguments: [f_pKey]    : A pointer to the opaque key structure
**            [f_rgbData] : Specifies the data to decrypt (in place)
**
** Returns:   DRM_SUCCESS
**                success
**            DRM_E_INVALIDARG
**                one of the arguments was NULL or improperly initialized
**            DRM_E_CIPHER_NOTINITIALIZED
**                The aes key has not been properly initialized with Oem_Aes_SetKey
**********************************************************************************************/
DRM_API DRM_NO_INLINE DRM_RESULT DRM_CALL Oem_Aes_DecryptOne(
    __in_ecount( 1 )             const DRM_AES_KEY  *f_pKey,        
    __inout_bcount( DRM_AES_BLOCKLEN ) DRM_BYTE      f_rgbData[__CB_DECL( DRM_AES_BLOCKLEN )] )
{
    DRM_RESULT            dr           = DRM_SUCCESS;    
    INTERNAL_DRM_AES_KEY *pInternalKey = ( INTERNAL_DRM_AES_KEY * )f_pKey;    
    DRM_BYTE              rgbTemp[__CB_DECL( DRM_AES_BLOCKLEN )] = { 0 };

    /*
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_OEMAES, PERF_FUNC_Oem_Aes_DecryptOne );
    */

    ChkArg( f_pKey != NULL );

    /*
    ** Simply use the system's AES routine
    */
    Aes_Decrypt128( rgbTemp, f_rgbData, pInternalKey->AESTable.keytabdec );
    MEMCPY( f_rgbData, rgbTemp, DRM_AES_BLOCKLEN );

ErrorExit:
    /*
    DRM_PROFILING_LEAVE_SCOPE;
    */
    return dr;
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\lib\oemcfdimpl.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmkeygenerator.h>
#include <oem_msdbpk.h>
#include <drmdebug.h>
#include <drmcrt.h>

ENTER_PK_NAMESPACE_CODE;


/**********************************************************************
** Function:    _readFile
**
** Synopsis:    Read all the bytes from the supplied file name into the parameter passed in.
**
** Arguments:   [f_pchFileName] --  Buffer for the seed to be put into. 
**              [f_pbData]      --  Filled with the data from the file
**              [f_cbData]      --  Size of the provided buffer; must match the size of the file
**
** Returns:     DRM_SUCCESS          - on success
**              DRM_E_INVALIDARG     - if any parameter is invalid
**              DRM_E_FILENOTFOUND   - if the file cannot be opened
**              DRM_E_BUFFERTOOSMALL - if the buffer passed in is too small
**              DRM_E_FILEREADERROR  - if there is an error reading the file
**
** Notes:       None.
***********************************************************************/
static DRM_RESULT _readFile(
    IN       DRM_CHAR           *f_pchFileName,
        OUT  DRM_BYTE           *f_pbData,
    IN  OUT  DRM_DWORD           f_cbData
)
{
    DRM_RESULT    dr                        = DRM_SUCCESS;
    DRM_WCHAR     swzFileName[DRM_MAX_PATH] = {0};
    DRM_STRING    dstrFileName              = EMPTY_DRM_STRING;
    DRM_SUBSTRING dasstrSubString           = EMPTY_DRM_SUBSTRING;
    OEM_FILEHDL   hFile                     = OEM_INVALID_HANDLE_VALUE;
    DRM_DWORD     dwFileLen                 = 0;


    /* 
    ** Check the parameters and convert the filename into equilivant DRMString
    */
    ChkArg( f_pchFileName != NULL );
    ChkArg( f_pbData      != NULL );
    ChkArg( f_cbData       > 0    );
    
    dasstrSubString.m_cch   = (DRM_DWORD)DRMCRT_strlen( f_pchFileName );
    dstrFileName.cchString  = DRM_MAX_PATH;
    dstrFileName.pwszString = swzFileName;

    /* Assume that filename contains ASCII (0-255) symbols only */
    DRM_UTL_PromoteASCIItoUNICODE( f_pchFileName, &dasstrSubString, &dstrFileName );
        
    hFile = Oem_File_Open( NULL,
                          dstrFileName.pwszString, 
                          OEM_GENERIC_READ, 
                          OEM_FILE_SHARE_READ, 
                          OEM_OPEN_EXISTING, 
                          OEM_ATTRIBUTE_NORMAL);
    ChkBOOL( hFile != OEM_INVALID_HANDLE_VALUE, DRM_E_FILENOTFOUND );
    
    /* 
    ** Get the file length and make sure that the supplied buffer is big enough 
    */
    ChkBOOL( Oem_File_GetSize( hFile, &dwFileLen ), DRM_E_FILEREADERROR );
    ChkBOOL( dwFileLen != 0, DRM_E_FILEREADERROR );
    ChkBOOL( dwFileLen <= f_cbData, DRM_E_BUFFERTOOSMALL );
    
    /*
    ** Read the data from the file and ensure that all bytes were read 
    */   
    ChkBOOL( Oem_File_Read( hFile, f_pbData, f_cbData, &dwFileLen ), DRM_E_FILEREADERROR );
    ChkBOOL( dwFileLen == f_cbData, DRM_E_FILEREADERROR );

ErrorExit:
    if ( hFile != OEM_INVALID_HANDLE_VALUE )
    {   
        Oem_File_Close( hFile );
    }
    return dr;
}



/**********************************************************************
** Function:    OEM_GetContentKeySeed
**
** Synopsis:    Retrieve Content Key Seed for generation of content key. The seed should be
**              specific for particular device. This means it should be different for different
**              devices, but never changed on a particular device
**
** Arguments:   [f_wszKeySeed] --  Buffer for the seed to be put into. 
**                                 The buffer should be of size of DRM_KEYSEED_BASE64_LEN DRM_WCHAR characters 
**
** Returns:     DRM_SUCCESS          - on success
**              DRM_E_INVALIDARG     - if the supplied buffer parameter is NULL
**
** Notes:       None.
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL OEM_GetContentKeySeed
(                                            
      OUT  DRM_WCHAR        f_wszKeySeed[DRM_KEYSEED_BASE64_LEN]
)
{   
    DRM_RESULT dr                                       = DRM_SUCCESS;
    
    /* 
    ** If output buffer is present and large enough, get the data.
    */
    ChkArg( f_wszKeySeed != NULL );
    ChkDR( _readFile( "contentKeySeed.txt", (DRM_BYTE *)f_wszKeySeed, DRM_KEYSEED_BASE64_LEN * SIZEOF( DRM_WCHAR )  ) );

ErrorExit :
    if ( dr == DRM_E_FILENOTFOUND )
    {
        TRACE(("contentKeySeed.txt file not found"));
    }

    return dr;
}



/**********************************************************************
** Function:    OEM_GetLicenseServerPrivateKey
**
** Synopsis:    Copies into the parameter the binary version of the license server's
**              private key
**
** Arguments:   [f_pLSPrivateKey] : Pointer to the private key 
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG - if the supplied parameter is NULL
**              or other errors from decoding
**
** Notes:       None.
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL OEM_GetLicenseServerPrivateKey
(
    OUT PRIVKEY   *f_pLSPrivateKey
)
{
    DRM_RESULT        dr                                                           = DRM_SUCCESS;
    DRM_WCHAR         swzLSPrivKey[CCH_BASE64_EQUIV(DRM_ECC160_PRIVATE_KEY_LEN)+1] = {0};
    DRM_DWORD         cbrgbPrivKey                                                 = DRM_ECC160_PRIVATE_KEY_LEN;
    DRM_CONST_STRING  dstrLicenseServerPrivateKey                                  = EMPTY_DRM_STRING;

    ChkArg( f_pLSPrivateKey != NULL );
    
    ChkDR( _readFile( "licenseServerPrivateKey.txt", (DRM_BYTE *)swzLSPrivKey, SIZEOF( swzLSPrivKey ) ) );

    dstrLicenseServerPrivateKey.pwszString = swzLSPrivKey;
    dstrLicenseServerPrivateKey.cchString  = CCH_BASE64_EQUIV( DRM_ECC160_PRIVATE_KEY_LEN );
    
    ChkDR( DRM_B64_DecodeW( &dstrLicenseServerPrivateKey, &cbrgbPrivKey, f_pLSPrivateKey->x, 0 ) );

 ErrorExit:
    if ( dr == DRM_E_FILENOTFOUND )
    {
        TRACE(("licenseServerPrivateKey.txt file not found"));
    }

    return dr;
}


/**********************************************************************
** Function:    OEM_GetLicenseCertificates
**
** Synopsis:    Updates the buffers passed-in to contain to the respective certificates 
**              in not-NULL-terminated B64 WCHAR format
**
** Arguments:   [f_pbCertificate2] -- Pointer to buffer in which to copy Certificate #2
**              [f_cbC2Size]       -- Size of the Certificate #2 buffer
**              [f_pbCertificate1] -- Pointer to buffer in which to copy Certificate #1
**              [f_cbC1Size]       -- Size of the Certificate #1 buffer
**
** Returns:     DRM_SUCCESS          - on success
**              DRM_E_INVALIDARG     - if any parameter is invalid
**
** Notes:       The minimum buffer size to allocate prior to calling this fucntion
**              can be accurately calculated via the following:
**                 __CB_DECL(CCH_BASE64_EQUIV(SIZEOF(CERT))*SIZEOF(DRM_WCHAR))
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL OEM_GetLicenseCertificates
(
       OUT DRM_BYTE  *f_pbCertificate2,
    IN     DRM_DWORD  f_cbC2Size,
       OUT DRM_BYTE  *f_pbCertificate1,
    IN     DRM_DWORD  f_cbC1Size
)
{
    DRM_RESULT   dr = DRM_SUCCESS;


    ChkArg( f_pbCertificate2 != NULL );
    ChkArg( f_pbCertificate1 != NULL );
    ChkArg( f_cbC2Size > 0 );
    ChkArg( f_cbC1Size > 0 );

    ChkDR( _readFile( "licenseCertificate2.txt", f_pbCertificate2, f_cbC2Size ) );
    ChkDR( _readFile( "licenseCertificate1.txt", f_pbCertificate1, f_cbC1Size ) );
    
 ErrorExit:
    if ( dr == DRM_E_FILENOTFOUND )
    {
        TRACE(("licenseCertificate1.txt or licenseCertificate2.txt file not found"));
    }

    return dr;
}


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\lib\oemcriticalsection.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <windows.h>
#include <drmcommon.h>
#include <oem.h>

ENTER_PK_NAMESPACE_CODE;

DRM_API DRM_VOID DRM_CALL Oem_CritSec_Initialize(
    __inout OEM_CRITICAL_SECTION *pCS)
{
#if DRM_SUPPORT_MULTI_THREADING
    CRITICAL_SECTION *poCS=(CRITICAL_SECTION *)pCS;
    DRMSIZEASSERT(SIZEOF(OEM_CRITICAL_SECTION), SIZEOF(CRITICAL_SECTION));
    
    InitializeCriticalSection(poCS);
#endif
}

DRM_API DRM_VOID DRM_CALL Oem_CritSec_Delete(
    __inout OEM_CRITICAL_SECTION *pCS)
{
#if DRM_SUPPORT_MULTI_THREADING
    CRITICAL_SECTION *poCS=(CRITICAL_SECTION *)pCS;
    DRMSIZEASSERT(SIZEOF(OEM_CRITICAL_SECTION), SIZEOF(CRITICAL_SECTION));
    
    DeleteCriticalSection(poCS);

    MEMSET(poCS, 0, SIZEOF(CRITICAL_SECTION));
#endif
}

DRM_API DRM_VOID DRM_CALL Oem_CritSec_Enter(
    __inout OEM_CRITICAL_SECTION *pCS)
{
#if DRM_SUPPORT_MULTI_THREADING
    CRITICAL_SECTION *poCS=(CRITICAL_SECTION *)pCS;
    DRMSIZEASSERT(SIZEOF(OEM_CRITICAL_SECTION), SIZEOF(CRITICAL_SECTION));
    
    EnterCriticalSection(poCS);
#endif
}

DRM_API DRM_VOID DRM_CALL Oem_CritSec_Leave(
    __inout OEM_CRITICAL_SECTION *pCS)
{
#if DRM_SUPPORT_MULTI_THREADING
    CRITICAL_SECTION *poCS=(CRITICAL_SECTION *)pCS;
    DRMSIZEASSERT(SIZEOF(OEM_CRITICAL_SECTION), SIZEOF(CRITICAL_SECTION));
    
    LeaveCriticalSection(poCS);
#endif
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\inc\oemcommon.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __OEMCOMMON_H__
#define __OEMCOMMON_H__

#include <drmcommon.h>
#include <drmhash.h>
#include <drmpkcrypto.h>
#include <drmbase64.h>

ENTER_PK_NAMESPACE;

extern DRM_EXPORT_VAR DRM_CONST_STRING g_dstrDrmPath;

extern const DRM_CONST_STRING g_dstrPrivKey;
extern const DRM_CONST_STRING g_dstrZGPrivKey;
extern const DRM_CONST_STRING g_dstrZPrivKeySign;
extern const DRM_CONST_STRING g_dstrZPrivKeyEncrypt;
extern const DRM_CONST_STRING g_dstrNDRPrivKey;

extern const DRM_CONST_STRING g_dstrDevcert;
extern const DRM_CONST_STRING g_dstrDevcerttemplate;

extern const DRM_CONST_STRING g_dstrZDevcert;
extern const DRM_CONST_STRING g_dstrZGroupCert;

extern const DRM_CONST_STRING g_dstrReceiverCert;
extern const DRM_CONST_STRING g_dstrReceiverTemplate;

extern const DRM_CONST_STRING g_dstrDevcert;
extern const DRM_CONST_STRING g_dstrDevcerttemplate;

extern const DRM_CONST_STRING g_dstrReceiverCert;
extern const DRM_CONST_STRING g_dstrReceiverTemplate;

typedef enum DRMFILESPATH
{
    CERTPATH = 0,
    CERTTEMPLATEPATH,
    HDSPATH,
} DRMFILESPATH;

typedef enum
{
    DRM_DCT_WMDRMPD = 1,
    DRM_DCT_WMDRMPD_TEMPLATE,
    DRM_DCT_PLAYREADY,
    DRM_DCT_PLAYREADY_TEMPLATE,
    DRM_DCT_NETRECEIVER,
    DRM_DCT_NETRECEIVER_TEMPLATE,
} DRM_DEVICE_CERT_TYPE;

typedef enum
{
    DRM_DKT_WMDRMPD_GROUP = 1,
    DRM_DKT_WMDRMPD_FALLBACK,
    DRM_DKT_PLAYREADY_DEVICE_SIGN,
    DRM_DKT_PLAYREADY_DEVICE_ENCRYPT,
    DRM_DKT_PLAYREADY_MODEL,
    DRM_DKT_PLAYREADY_NDR,
    DRM_DKT_PLAYREADY_NDR_MODEL
} DRM_DEVICE_KEY_TYPE;

typedef enum
{
    DRM_DIT_WMDRMPD_ID = 1,
    DRM_DIT_PLAYREADY_ID,
} DRM_DEVICE_ID_TYPE;

typedef DRM_VOID * OEM_DEVICE_HANDLE;

/*
** Internal functions that should be implemented by each OEM
** implementation (oeminfo.c).
*/
DRM_API DRM_RESULT DRM_CALL _GetDRMFullPathName( 
    __out DRM_WCHAR **f_ppwszFullPath, 
    __in_opt const DRM_CONST_STRING *f_pdstrFilename,
    __in DRMFILESPATH f_eFilesPath );
    
DRM_RESULT _GetPrivateKey(
    __in_opt DRM_VOID *f_pOEMContext,
    __in const DRM_BOOL f_fGCprivkey,
    __out_bcount( f_cbPrivKey ) DRM_BYTE *f_pbPrivkey,
    __in DRM_DWORD f_cbPrivKey );

DRM_RESULT _GetHWID(
    __out_bcount(DRM_SHA1_DIGEST_LEN) DRM_BYTE *shaOut );

/* OEM device information functions. (oeminfo.c) */
DRM_API DRM_RESULT DRM_CALL Oem_Device_GetCert(
    __in_opt DRM_VOID *f_pOEMContext,
    __in const DRM_DEVICE_CERT_TYPE f_eCertType,
    __out_bcount_opt( *f_pcbDevCert ) DRM_BYTE *f_pbDevCert,
    __inout DRM_DWORD *f_pcbDevCert );

DRM_API DRM_RESULT DRM_CALL Oem_Device_SetCert(
    __in_opt DRM_VOID *f_pOEMContext,
    __in const DRM_DEVICE_CERT_TYPE f_eCertType,
    __in_bcount(f_cbDevCert) DRM_BYTE *f_pbDevCert,
    __in const DRM_DWORD f_cbDevCert );

DRM_API DRM_RESULT DRM_CALL Oem_Device_GetSecureStoreGlobalPasswordSeed( 
    __out_bcount(DRM_SHA1_DIGEST_LEN) DRM_BYTE f_rgbSecStorePassword[ __CB_DECL( DRM_SHA1_DIGEST_LEN ) ] );

DRM_API DRM_RESULT DRM_CALL Oem_Device_GetKey( 
    __in_opt DRM_VOID *f_pOEMContext,
    __in const DRM_DEVICE_KEY_TYPE f_eKeyType,
    __out_bcount_opt( *f_pcbKey ) DRM_BYTE *f_pbKey,
    __inout DRM_DWORD *f_pcbKey );

DRM_API DRM_RESULT DRM_CALL Oem_Device_SetKey( 
    __in_opt DRM_VOID *f_pOEMContext,
    __in const DRM_DEVICE_KEY_TYPE f_eKeyType,
    __in_bcount(f_cbKey) DRM_BYTE *f_pbKey,
    __in const DRM_DWORD f_cbKey );

DRM_API DRM_RESULT DRM_CALL Oem_Device_GetUniqueId( 
    __in_opt DRM_VOID *f_pOEMContext,
    __in const DRM_DEVICE_ID_TYPE f_eIDType,
    __out_bcount_opt(*f_pcbLength) DRM_BYTE *f_pbUniqueId, 
    __inout DRM_DWORD *f_pcbLength );

DRM_API DRM_RESULT DRM_CALL Oem_Clock_GetResetState( 
    __in_opt DRM_VOID *f_pOEMContext, 
    __out DRM_BOOL *f_pfReset );

DRM_API DRM_RESULT DRM_CALL Oem_Clock_SetResetState( 
    __in_opt DRM_VOID *f_pOEMContext, 
    __in DRM_BOOL f_fReset );


/*****************************************************************************
** Function:    Oem_Clock_GetTickCount
**
** Synopsis:    Returns the number of milliseconds since the system was started.
**
** Arguments:   [f_pOEMContext] : A pointer to the OEM context; may be NULL
**
** Returns:     DRM_DWORD - the number of milliseconds since the system was started
**
** Notes:       None.
**
******************************************************************************/
DRM_API DRM_DWORD DRM_CALL Oem_Clock_GetTickCount(
__in_opt    DRM_VOID      *f_pOEMContext
);


/* OEM file IO functions (oemfileio.c). */

/* File Handle */
typedef DRM_VOID *OEM_FILEHDL;
#define OEM_INVALID_HANDLE_VALUE ((OEM_FILEHDL)-1)

/* Oem_File_Open Access modes */
#define OEM_GENERIC_READ       (0x80000000L)
#define OEM_GENERIC_WRITE      (0x40000000L)
#define OEM_GENERIC_EXECUTE    (0x20000000L)
#define OEM_GENERIC_ALL        (0x10000000L)

/* Oem_File_Open Share modes */
#define OEM_FILE_SHARE_NONE     0x00000000  
#define OEM_FILE_SHARE_READ     0x00000001  
#define OEM_FILE_SHARE_WRITE    0x00000002  

/* Oem_File_Open Creation dispositions */
#define OEM_CREATE_NEW          1
#define OEM_CREATE_ALWAYS       2
#define OEM_OPEN_EXISTING       3
#define OEM_OPEN_ALWAYS         4
#define OEM_TRUNCATE_EXISTING   5

#define OEM_ATTRIBUTE_HIDDEN    0x00000002
#define OEM_ATTRIBUTE_SYSTEM    0x00000004
#define OEM_ATTRIBUTE_NORMAL    0x00000080

#define OEM_FILE_FLAG_WRITE_THROUGH 0x80000000

/* SetFilePointer move methods */
#define OEM_FILE_BEGIN          0
#define OEM_FILE_CURRENT        1
#define OEM_FILE_END            2

/*
** For information on these functions and parameters see MSDN 
** For Oem_File_Open see CreateFile in MSDN -- not all flags are supported.
*/

/**********************************************************************
** Function:    Oem_File_Open
** Synopsis:    Creates, opens, reopens a file
** Arguments:   [f_pOEMContext]--Optional pointer to OEM specific context data
**              [f_pwszFileName]--Pointer to DRM_WCHAR buffer holding File
**              name.
**              [f_dwAccessMode]--Type of access to the object. 
**              OEM_GENERIC_READ, OEM_GENERIC_WRITE,
**              OEM_GENERIC_EXECUTE and OEM_GENERIC_ALL
**              [f_dwShareMode]--Sharing mode of the object
**              OEM_FILE_SHARE_NONE, OEM_FILE_SHARE_READ
**              and OEM_FILE_SHARE_WRITE
**              [f_dwCreationDisposition]--Action to take on files 
**              that exist, and on files that do not exist.
**              OEM_CREATE_NEW, OEM_CREATE_ALWAYS, OEM_OPEN_EXISTING
**              OEM_OPEN_ALWAYS and OEM_TRUNCATE_EXISTING
**              [f_dwAttributes]--File attributes and flags.
**              OEM_ATTRIBUTE_HIDDEN, OEM_ATTRIBUTE_SYSTEM and
**              OEM_ATTRIBUTE_NORMAL
** Returns:     Valid OEM FILE HANDLE. If fails, 
**              returns OEM_INVALID_HANDLE_VALUE 
***********************************************************************/
DRM_API OEM_FILEHDL DRM_CALL Oem_File_Open(
    __in_opt DRM_VOID *f_pOEMContext,
    __in_z const DRM_WCHAR *f_pwszFileName,
    __in DRM_DWORD f_dwAccessMode,
    __in DRM_DWORD f_dwShareMode,
    __in DRM_DWORD f_dwCreationDisposition,
    __in DRM_DWORD f_dwAttributes );

/**********************************************************************
** Function:    Oem_File_Close
** Synopsis:    Closes an open handle opened by Oem_File_Open.
** Arguments:   [f_hFile]--File Handle
** Returns:     Non zero value if succeeds, zero if failed.
***********************************************************************/
DRM_API DRM_BOOL DRM_CALL Oem_File_Close(
    __in OEM_FILEHDL f_hFile );

/**********************************************************************
** Function:    Oem_File_Read
** Synopsis:    Reads data from a file.
** Arguments:   [f_hFile]--File Handle
**              [f_pvBuffer]--Pointer to the buffer that receives the 
**              data read from the file. 
**              [f_nNumberOfBytesToRead]--Number of bytes to read.
**              [f_pNumberOfBytesRead]--Total number of bytes read. 
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/
DRM_API DRM_BOOL DRM_CALL Oem_File_Read(
    __in OEM_FILEHDL f_hFile,
    __out_ecount_part( f_nNumberOfBytesToRead, *f_pNumberOfBytesRead ) DRM_VOID *f_pvBuffer,
    __in DRM_DWORD f_nNumberOfBytesToRead,
    __out DRM_DWORD *f_pNumberOfBytesRead );

/**********************************************************************
** Function:    Oem_File_Write
** Synopsis:    Writes data to a file.
** Arguments:   [f_hFile]--File Handle
**              [f_pvBuffer]--Pointer to the buffer holding the 
**              data read to the file. 
**              [f_nNumberOfBytesToWrite]--Number of bytes to write.
**              [f_pNumberOfBytesWritten]--Total number of bytes written. 
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/
DRM_API DRM_BOOL DRM_CALL Oem_File_Write(
    __in OEM_FILEHDL f_hFile,
    __in_ecount( f_nNumberOfBytesToWrite ) DRM_VOID *f_pvBuffer,
    __in DRM_DWORD f_nNumberOfBytesToWrite,
    __out DRM_DWORD *f_pNumberOfBytesWritten );

/**********************************************************************
** Function:    Oem_File_SetFilePointer
** Synopsis:    Sets File pointer.
** Arguments:   [f_lDistanceToMove]--Number of bytes to move
**              [f_dwMoveMethod]--Starting point for the file pointer move 
**              OEM_FILE_BEGIN, OEM_FILE_CURRENT and  OEM_FILE_END
**              [f_pdwNewFilePointer]--New File pointer.
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/
DRM_API DRM_BOOL DRM_CALL Oem_File_SetFilePointer(
    __in OEM_FILEHDL f_hFile,
    __in DRM_LONG f_lDistanceToMove,
    __in DRM_DWORD f_dwMoveMethod,
    __out_opt DRM_DWORD *f_pdwNewFilePointer );

/**********************************************************************
** Function:    Oem_File_Lock
** Synopsis:    Immidiately locks the portion of specified file. 
** Arguments:   [f_hFile]--File Handle
**              [f_fExclusive]-- If TRUE, locks file for exclusive access  
**              by the calling process.
**              [f_dwFileOffset]--Offset from begining of file.
**              [f_nNumberOfBytesToLock]--Number of bytes to lock. 
**              [f_fWait]--Whether to wait for the lock to complete.
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/
DRM_API DRM_BOOL DRM_CALL Oem_File_Lock(
    __in OEM_FILEHDL f_hFile,
    __in DRM_BOOL f_fExclusive,
    __in DRM_DWORD f_dwFileOffset,
    __in DRM_DWORD f_nNumberOfBytesToLock,
    __in DRM_BOOL f_fWait );

/**********************************************************************
** Function:    Oem_File_Unlock
** Synopsis:    Unlocks the locked portion of specified file. 
** Arguments:   [f_hFile]--File Handle
**              [f_dwFileOffset]--Offset from begining of file.
**              [f_nNumberOfBytesToLock]--Number of bytes to lock. 
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/
DRM_API DRM_BOOL DRM_CALL Oem_File_Unlock(
    __in OEM_FILEHDL f_hFile,
    __in DRM_DWORD f_dwFileOffset,
    __in DRM_DWORD f_nNumberOfBytesToUnlock );

/**********************************************************************
** Function:    Oem_File_SetEndOfFile
** Synopsis:    Moves the end-of-file (EOF) position for the 
**              specified file to the current position of the file 
**              pointer. 
** Arguments:   [f_hFile]--File Handle
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/
DRM_API DRM_BOOL DRM_CALL Oem_File_SetEndOfFile(
    __in OEM_FILEHDL f_hFile);

/**********************************************************************
** Function:    Oem_File_GetSize
** Synopsis:    Gets size of the file. 
** Arguments:   [f_hFile]--File Handle
**              [f_pdwFileSize]--Pointer to DRM_DWORD to get the size.
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/
DRM_API DRM_BOOL DRM_CALL Oem_File_GetSize(
    __in OEM_FILEHDL f_hFile,
    __out DRM_DWORD  *f_pdwFileSize );

/**********************************************************************
** Function:    Oem_File_FlushBuffers
** Synopsis:    Flushes the buffers of the specified file and causes 
**              all buffered data to be written to the file. 
** Arguments:   [f_hFile]--File Handle
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/
DRM_API DRM_BOOL DRM_CALL Oem_File_FlushBuffers(
    __in OEM_FILEHDL f_hFile );

/* OEM time functions (oemtime.c). */

/**********************************************************************
** Function:    Oem_Clock_SystemTimeToFileTime
** Synopsis:    Converts System Time format to File time format. 
** Arguments:   [f_lpSystemTime]--Pointer to DRMSYSTEMTIME structure 
**              containing system time
**              [f_lpFileTime]--Pointer to DRMFILETIME structure to get
**              the time.
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/
DRM_API DRM_BOOL DRM_CALL Oem_Clock_SystemTimeToFileTime(
    __in const DRMSYSTEMTIME *f_lpSystemTime,
    __out DRMFILETIME *f_lpFileTime );

/**********************************************************************
** Function:    Oem_Clock_FileTimeToSystemTime
** Synopsis:    Converts File time format to System Time format. 
** Arguments:   [f_lpFileTime]--Pointer to DRMFILETIME structure 
**              containing file time
**              [f_lpSystemTime]--Pointer to DRMSYSTEMTIME structure to 
**              get the time.
** Returns:     Non zero value if succeeds, zero if failed. 
***********************************************************************/
DRM_API DRM_BOOL DRM_CALL Oem_Clock_FileTimeToSystemTime(
    __in const DRMFILETIME *f_lpFileTime,
    __out DRMSYSTEMTIME *f_lpSystemTime );

/**********************************************************************
** Function:    Oem_Clock_GetSystemTime
** Synopsis:    Gets current System time. It is expressed in UTC. 
** Arguments:   [f_pOEMContext]--OEM specific data
**              [f_lpSystemTime]--Pointer to DRMSYSTEMTIME structure 
**              to get the time.
***********************************************************************/
DRM_API DRM_VOID DRM_CALL Oem_Clock_GetSystemTime(
    __in_opt    DRM_VOID      *f_pOEMContext,
    __out       DRMSYSTEMTIME *f_psystime );

/**********************************************************************
** Function:    Oem_Clock_GetSystemTimeAsFileTime
** Synopsis:    Gets current System time. It is expressed in UTC. 
** Arguments:   [f_pOEMContext]--OEM specific data
**              [f_pfiletime]--Pointer to DRMFILETIME structure 
**              to get the time.
***********************************************************************/
DRM_API DRM_VOID DRM_CALL Oem_Clock_GetSystemTimeAsFileTime(
    __in_opt    DRM_VOID    *f_pOEMContext,
    __out       DRMFILETIME *f_pfiletime );

/**********************************************************************
** Function:    Oem_Clock_SetSystemTime
** Synopsis:    Sets the System time. It is expressed in UTC. 
** Arguments:   [f_pOEMContext]--OEM specific data
**              [f_lpSystemTime]--Pointer to DRMSYSTEMTIME structure 
**              holding the time.
***********************************************************************/
DRM_API DRM_VOID DRM_CALL Oem_Clock_SetSystemTime(
    __in_opt    DRM_VOID      *f_pOEMContext,
    __in        DRMSYSTEMTIME *f_lpSystemTime );

/* OEM memory allocation functions (oemimpl.c). */

DRM_API DRM_VOID * DRM_CALL Oem_MemAlloc(
    __in DRM_DWORD f_cbSize );

DRM_API DRM_VOID DRM_CALL Oem_MemFree(
    __in DRM_VOID *f_pv );

#define SAFE_OEM_FREE( p )            \
    if ( p != NULL )                  \
    {                                 \
        Oem_MemFree( ( DRM_VOID * )p );  \
        p = NULL;                     \
    }

DRM_API DRM_VOID * DRM_CALL Oem_MemRealloc( 
    __inout DRM_VOID  *f_pv, 
    __in DRM_DWORD f_cbSize );
    
/* OEM special implementation functions (oemimpl.c). */
#ifdef _MSC_VER

__forceinline DRM_VOID * DRM_CALL DRMCRT_ScrubMemory(
    __in_ecount( f_cbCount ) DRM_VOID  *f_ptr,
    IN DRM_DWORD  f_cbCount  )
{
    /*
    ** Casting the pointer to volatile makes the MS compiler act
    ** as if another thread can see and access the buffer. This 
    ** prevents the compiler from reordering or optimizing away 
    ** the writes. 
    */

    volatile char *vptr = (volatile char *)f_ptr;

    while (f_cbCount) 
    {
        *vptr = 0;
        vptr++;
        f_cbCount--;
    }

    return f_ptr;
}

#define OEM_SECURE_ZERO_MEMORY DRMCRT_ScrubMemory

#else

#error "Please provide implementation for OEM_SECURE_ZERO_MEMORY macro.\
 OEM_SECURE_ZERO_MEMORY is called to scrub memory on critical pieces of data before freeing buffers or exiting local scope.\
 Using of memset function on these buffers is not sufficient, since compiler\
 may optimize out zeroing of buffers that are not used afterwards.\
 Please verify the implementation will not be optimized out by your compiler.\
 Consult the documentation for your compiler to see how this can be done. \
 The Microsoft supplied example is only guaranteed to work on Microsoft compilers. "

#endif /* _MSC_VER */


#define SAFE_SECURE_OEM_FREE( p, c )                                    \
    if (p != NULL)                                                      \
    {                                                                   \
        OEM_SECURE_ZERO_MEMORY( p, c );                                 \
        Oem_MemFree( ( DRM_VOID * ) p );                                \
        p = NULL;                                                       \
    }

DRM_API DRM_VOID DRM_CALL Oem_Random_SetSeed(
    __in_opt DRM_VOID *f_pOEMContext,
    __in const DRM_UINT64 f_qwNewSeed );

DRM_API DRM_RESULT DRM_CALL Oem_Random_GetBytes( 
    __in_opt DRM_VOID *f_pOEMContext,
    __out_bcount(f_cbData) DRM_BYTE *f_pbData, 
    __in DRM_DWORD f_cbData );

DRM_API DRM_RESULT DRM_CALL Oem_Hds_GetSetReplayCheck(
    __in DRM_VOID *f_pvOpaqueData,
    __inout_bcount( f_cbKey ) DRM_BYTE *f_pbKey,
    __in DRM_DWORD f_cbKey,
    __in DRM_BOOL f_fGet );

#if DRM_SUPPORT_BLOCK_HEADER_CACHING

EXIT_PK_NAMESPACE;

#include <drmhds.h>

ENTER_PK_NAMESPACE;

/* Number of entries in the block header cache. Each entry will occupy
** SIZEOF( BLOCK_HEADER_CACHE_ENTRY ) bytes of memory. A larger cache
** will mean a lower chance of needing to load a block header from the disk
*/
#define MAX_CACHED_BLOCK_HEADERS 500

typedef struct
{
    DRM_DWORD dwBlockNumber;
    DRM_DWORD dwCacheHits;
    DRM_DWORD dwBlockHeaderMetadata;
    DRM_BYTE  rgbBlockHeader[CALC_MAXBLOCKHEADERLEN];
    DRM_DWORD cbBytesAvailable;

} BLOCK_HEADER_CACHE_ENTRY;

DRM_API DRM_VOID DRM_CALL Oem_Hds_ClearBlockHeaderCache( DRM_VOID );

DRM_API DRM_RESULT DRM_CALL Oem_Hds_CheckBlockHeaderCache(
    __in      DRM_DWORD   f_dwBlockNumber,
    __in_opt  OEM_FILEHDL f_hHDSFileHandle,
    __out_opt DRM_DWORD  *f_pdwBlockHeaderMetadata,
    __out_bcount_opt( f_cbBytesToRead ) DRM_BYTE   *f_pbBlock,
    __in      DRM_DWORD   f_cbBytesToRead );

DRM_API DRM_RESULT DRM_CALL Oem_Hds_UpdateBlockHeaderCache(
    __in     DRM_DWORD   f_dwBlockNumber,
    __in_opt OEM_FILEHDL f_hHDSFileHandle,
    __in     DRM_DWORD   f_dwBlockHeaderMetadata,
    __in_bcount_opt( f_cbBytesToWrite ) DRM_BYTE   *f_pbBlock,
    __in     DRM_DWORD   f_cbBytesToWrite );

#endif /* DRM_SUPPORT_BLOCK_HEADER_CACHING */

#if DRM_SUPPORT_SST_REDUNANCY

EXIT_PK_NAMESPACE;

#include <drmtoken.h>

ENTER_PK_NAMESPACE;

DRM_API DRM_RESULT DRM_CALL VariableSSTRedundancyGetorSet(
   __in const DRM_CONST_STRING *f_pdstrToken, 
   __in TOKEN *f_pNewValue, 
   __out TOKEN *f_pResult, 
   __inout DRM_VOID *f_pvOpaqueData, 
   __in DRM_BOOL f_fSet );
   
#endif /* DRM_SUPPORT_SST_REDUNANCY */

#if TEST_USE_OFFSET_CLOCK

typedef struct
{
    DRM_BOOL    fFreezeTickCount;
    DRM_DWORD   dwTickCount;
} DRM_TEST_OEM_CONTEXT;

#endif

EXIT_PK_NAMESPACE;

#endif /* __OEMCOMMON_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\lib\oemdebug.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <drmcommon.h>
#include <drmtrace.h>

#define TRACE_MAX_STRING_BUFFER         1024

ENTER_PK_NAMESPACE_CODE;

/**********************************************************************
** Function:   _oem_trace
**
** Synopsis:   static function that prints to console  
**
** Arguments:  [f_pszFormat] -- Format string of the variable arguments to follow.
**             [f_ArgList]   -- Pointer to variable argument list.
**
** Returns:       None
**
***********************************************************************/
static void DRM_CALL _oem_trace(
    __in DRM_CHAR* f_pszFormat,
    __in va_list f_ArgList )
{
    DRM_CHAR rgchBuffer[ TRACE_MAX_STRING_BUFFER + 1 ] = { 0 };

    vsprintf_s( rgchBuffer,
                TRACE_MAX_STRING_BUFFER,
                f_pszFormat,
                f_ArgList );

    DRM_TRACE_NO_SCOPE( ( rgchBuffer ) );
}

/**********************************************************************
** Type definition and pointer to global callback for the tracing.
***********************************************************************/

typedef void (DRM_CALL *fncdrmtrace)( DRM_CHAR*, va_list f_ArgList );

#pragma prefast(suppress:22110) /* security mitigation warning */
fncdrmtrace g_TraceCallback = _oem_trace;

/**********************************************************************
** Function:   Oem_Debug_Trace
**
** Synopsis:   Trace function that prints that calls global callback
**             to pring data to file or to console.  
**
** Arguments:  [f_szFmt] -- Format string of the variable arguments to follow.
**
** Returns:       None
**
***********************************************************************/
DRM_API DRM_VOID DRM_CALL Oem_Debug_Trace(
    __in DRM_CHAR *f_szFmt,
    ... )
{
    va_list alist;
    va_start( alist, f_szFmt );
    g_TraceCallback( f_szFmt, alist );
    va_end (alist);
}

/* Disables warning of conversion from void to function pointer */
#pragma warning( disable : 4055 )

/**********************************************************************
** Function:    Oem_Debug_HookTrace
**
** Synopsis:    Change the global trace handler to one of the callers choosing.
**
** Arguments:    [pNewTraceFcn] -- Ptr to a function that handles traces.
**
** Returns:        None
**
** Notes:        
**
***********************************************************************/
DRM_API DRM_VOID DRM_CALL Oem_Debug_HookTrace(
    __in DRM_VOID *f_pNewTraceFcn )
{
#if DBG
    if ( NULL == f_pNewTraceFcn )
    {
        g_TraceCallback = _oem_trace;
    }
    else
    {
        g_TraceCallback = (fncdrmtrace)f_pNewTraceFcn;
    }
#endif
}

/**********************************************************************
** Function:   __drmassert
**
** Synopsis:   Implements assert functionality. 
**             If fAssert is false, then trace string that assert 
**             was rised and calls int 3 on x86 system.
**
** Arguments:  [f_fAssert]   -- Condiiton to test. If FALSE - rise assert
**             [f_assertcmd] -- Text string explainin the condition.
**             [f_file]      -- File where assert happened.
**             [f_line-      -- Line where assert happened.
**
** Returns:       None
**
***********************************************************************/
static DRM_VOID DRM_CALL __drmassert(
    __in DRM_BOOL fAssert, 
    __in DRM_CHAR *assertcmd, 
    __in DRM_CHAR *file, 
    __in DRM_INT line)
{
#if DBG
    if ( !fAssert ) 
    { 
        DRM_TRACE_NO_SCOPE( ( "DRMASSERT %s failed at %s(%d)\r\n", assertcmd, file, line ) );

#if _M_IX86
        __asm int 3
#endif
    }
#endif /* DBG */

}

/***************************************************************************  
**  This type is to allow the ASSERT macro to have another implementation
**    defined by the caller of Oem_Debug_HookAssert 
***************************************************************************/
        
typedef void (DRM_CALL *fncdrmassert)(DRM_BOOL,DRM_CHAR*, DRM_CHAR*,DRM_INT);

/* Global callback assert function. It is changed by test framework during BVT test */
#pragma prefast(suppress:22110) /* security mitigation warning */
fncdrmassert g_AssertCallback = __drmassert;

/**********************************************************************
** Function:   Oem_Debug_Assert
**
** Synopsis:   Implements assert functionality. Can either create visual 
**             feedback or log to file depending on implementation.
**
** Arguments:  [f_fAssert]   -- Condiiton to test. If FALSE - rise assert
**             [f_assertcmd] -- Text string explainin the condition.
**             [f_file]      -- File where assert happened.
**             [f_line-      -- Line where assert happened.
**
** Returns:       None
**
***********************************************************************/
DRM_API DRM_VOID DRM_CALL Oem_Debug_Assert
(
    __in DRM_BOOL f_fAssert, 
    __in DRM_CHAR *f_assertcmd, 
    __in DRM_CHAR *f_file, 
    __in DRM_INT f_line )
{
    g_AssertCallback( f_fAssert, f_assertcmd, f_file, f_line );
}

/**********************************************************************
** Function:    Oem_Debug_HookAssert
**
** Synopsis:    Change the global assert handler to one of the callers choosing.
**
** Arguments:    [pNewAssertFcn] -- Ptr to a function that handles asserts.
**
** Returns:        None
**
** Notes:        
**
***********************************************************************/
DRM_API DRM_VOID DRM_CALL Oem_Debug_HookAssert(
    __in DRM_VOID *pNewAssertFcn )
{
#if DBG
    if(NULL == pNewAssertFcn)
    {
        g_AssertCallback = __drmassert;
    }
    else
    {
        g_AssertCallback = (fncdrmassert)pNewAssertFcn;
    }
#endif
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\lib\oemfileio.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <windows.h>
#include <stdlib.h>
#include <drmcommon.h>
#include <drmutilities.h>

ENTER_PK_NAMESPACE_CODE;

#define DRM_LOCK_WAIT_DURATION  10000   /* ~10 seconds   */

DRM_API OEM_FILEHDL DRM_CALL Oem_File_Open(
    __in_opt DRM_VOID *f_pOEMContext,
    __in_z const DRM_WCHAR *f_pwszFileName,
    __in DRM_DWORD f_dwAccessMode,
    __in DRM_DWORD f_dwShareMode,
    __in DRM_DWORD f_dwCreationDisposition,
    __in DRM_DWORD f_dwAttributes )
{   
#if DRM_SUPPORT_TRACING
    DRM_RESULT dr = DRM_SUCCESS;
#endif
    HANDLE hFile = 0;
    SECURITY_ATTRIBUTES SecurityAttributes = { 0 };

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_OEMFILEIO, PERF_FUNC_Oem_File_Open);
    DRM_PROFILING_DETAIL_LEVEL(3);

    SecurityAttributes.nLength = SIZEOF( SecurityAttributes );
    SecurityAttributes.lpSecurityDescriptor = NULL;
    SecurityAttributes.bInheritHandle = TRUE;

    /* On Win32 the FILE_FLAG_WRITE_THROUGH option actually 
    ** writes through directly to physical media. We don't
    ** need quite such a drastic guarantee. We rely on all
    ** file handles able to see the same file data immediately,
    ** and data should make it to disk expediently. Normal
    ** Win32 I/O suffices adequately.
    **/
    f_dwAttributes = f_dwAttributes & ~OEM_FILE_FLAG_WRITE_THROUGH;

    hFile = CreateFileW( ( LPCWSTR )f_pwszFileName,
                           f_dwAccessMode,
                           f_dwShareMode,
                           &SecurityAttributes, 
                           f_dwCreationDisposition,
                           f_dwAttributes,
                           NULL );
#if DBG
    if ( hFile == INVALID_HANDLE_VALUE )
    {  /*
       ** Opening of file failed we trace it and provide last error.
       ** This greatly helps to diagnostic
       */
       DRM_CHAR pzFilePath[_MAX_PATH + 1] = {0};
       /* Retrieve last error as first operation after CreateFileW */
       DRM_DWORD dwError = GetLastError();
       
       /* Convert to ASCII and trace */
       DRM_UTL_DemoteUNICODEtoASCII( f_pwszFileName, pzFilePath, SIZEOF( pzFilePath ) - 1 );
       TRACE(("Open of file %s failed. GetLastError returns %d", pzFilePath, dwError ));
    }
#endif 
        
    DRM_PROFILING_LEAVE_SCOPE;
    return ( OEM_FILEHDL )hFile;
}

DRM_API DRM_BOOL DRM_CALL Oem_File_Close(
    __in OEM_FILEHDL f_hFile )
{
    return CloseHandle( ( HANDLE )f_hFile );
}

DRM_API DRM_BOOL DRM_CALL Oem_File_Read(
    __in OEM_FILEHDL f_hFile,
    __out_ecount_part( f_nNumberOfBytesToRead, *f_pNumberOfBytesRead ) DRM_VOID *f_pBuffer,
    __in DRM_DWORD f_nNumberOfBytesToRead,
    __out DRM_DWORD *f_pNumberOfBytesRead )
{
#if DRM_SUPPORT_TRACING    
    DRM_RESULT dr = DRM_SUCCESS;
#endif
    DRM_BOOL fResult = FALSE;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_OEMFILEIO, PERF_FUNC_Oem_File_Read);
    DRM_PROFILING_DETAIL_LEVEL(3);

    fResult = ReadFile( ( HANDLE )f_hFile,
                     f_pBuffer,
                     f_nNumberOfBytesToRead,
                     (LPDWORD)f_pNumberOfBytesRead,
                     NULL );

    DRM_PROFILING_LEAVE_SCOPE;
    return fResult;
}

DRM_API DRM_BOOL DRM_CALL Oem_File_Write(
    __in OEM_FILEHDL f_hFile,
    __in_ecount( f_nNumberOfBytesToWrite ) DRM_VOID *f_pBuffer,
    __in DRM_DWORD f_nNumberOfBytesToWrite,
    __out DRM_DWORD *f_pNumberOfBytesWritten )
{
#if DRM_SUPPORT_TRACING
    DRM_RESULT dr = DRM_SUCCESS;
#endif
    DRM_BOOL fResult = FALSE;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_OEMFILEIO, PERF_FUNC_Oem_File_Write);
    DRM_PROFILING_DETAIL_LEVEL(3);

    fResult = WriteFile( ( HANDLE )f_hFile,
                         f_pBuffer,
                         f_nNumberOfBytesToWrite,
                         (LPDWORD)f_pNumberOfBytesWritten,
                         NULL );

    if ( !fResult )
    {
        TRACE(("Oem_File_Write error %d\n",GetLastError()));
    }
    DRM_PROFILING_LEAVE_SCOPE;
    return fResult;
}

DRM_API DRM_BOOL DRM_CALL Oem_File_SetFilePointer(
    __in OEM_FILEHDL f_hFile,
    __in DRM_LONG f_lDistanceToMove,
    __in DRM_DWORD f_dwMoveMethod,
    __out_opt DRM_DWORD *f_pdwNewFilePointer )
{
#if DRM_SUPPORT_TRACING
    DRM_RESULT dr = DRM_SUCCESS;
#endif
    DRM_DWORD dwNewFilePointer = 0;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_OEMFILEIO, PERF_FUNC_Oem_File_SetFilePointer);
    DRM_PROFILING_DETAIL_LEVEL(3);

    dwNewFilePointer = SetFilePointer( ( HANDLE )f_hFile,
                                                 f_lDistanceToMove,
                                                 NULL,
                                                 f_dwMoveMethod );

    if ( dwNewFilePointer == INVALID_SET_FILE_POINTER )
    {
        return FALSE;
    }

    if ( f_pdwNewFilePointer != NULL )
    {
        *f_pdwNewFilePointer = dwNewFilePointer;
    }
    
    DRM_PROFILING_LEAVE_SCOPE;
    return TRUE;
}

DRM_API DRM_BOOL DRM_CALL Oem_File_Lock(
    __in OEM_FILEHDL f_hFile,
    __in DRM_BOOL f_fExclusive,
    __in DRM_DWORD f_dwFileOffset,
    __in DRM_DWORD f_nNumberOfBytesToLock,
    __in DRM_BOOL f_fWait )
{
#if DRM_SUPPORT_TRACING
    DRM_RESULT dr = DRM_SUCCESS;
#endif
    DRM_BOOL fResult = FALSE;
    DRM_DWORD dwFlags = 0;
    DRM_DWORD dwTickCountBegin = 0;        
    OVERLAPPED Overlapped = { 0 };

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_OEMFILEIO, PERF_FUNC_Oem_File_Lock);
    DRM_PROFILING_DETAIL_LEVEL(3);

    /* we are using LOCKFILE_FAIL_IMMEDIATELY only instead of supporting the wait
    ** option of Filesys. We wait in a loop for the lock. This is to solve the problem of
    ** sharing a single file handle acrosss multiple threads that causes deeadlock.
    ** we wait max of 10 seconds and return error if not able to lock when fWait 
    ** is TRUE.
    */
    dwFlags = LOCKFILE_FAIL_IMMEDIATELY;

    if (f_fExclusive)
    {
        dwFlags |= LOCKFILE_EXCLUSIVE_LOCK;
    }

    Overlapped.hEvent = 0;
    Overlapped.Offset = f_dwFileOffset;
    Overlapped.OffsetHigh = 0;

    dwTickCountBegin = GetTickCount();
    
    while( TRUE )
    {
        fResult = LockFileEx( ( HANDLE )f_hFile,
                              dwFlags,
                              0,
                              f_nNumberOfBytesToLock,
                              0,
                              &Overlapped );

        /*  
        **  Due to the nature of unsigned arithmetic, this code works correctly 
        **  even if the return value of GetTickCount() wraps around.
        */
        if ( fResult ||
             !f_fWait ||
             ( GetTickCount() - dwTickCountBegin ) > DRM_LOCK_WAIT_DURATION )
        {
            break;
        }
        
        Sleep( 0 );
    }

    DRM_PROFILING_LEAVE_SCOPE;
    return fResult;
}

DRM_API DRM_BOOL DRM_CALL Oem_File_Unlock(
    __in OEM_FILEHDL f_hFile,
    __in DRM_DWORD f_dwFileOffset,
    __in DRM_DWORD f_nNumberOfBytesToUnlock )
{
#if DRM_SUPPORT_TRACING
    DRM_RESULT dr = DRM_SUCCESS;
#endif
    OVERLAPPED Overlapped = { 0 };
    DRM_BOOL fResult = FALSE;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_OEMFILEIO, PERF_FUNC_Oem_File_Unlock);
    DRM_PROFILING_DETAIL_LEVEL(4);

    Overlapped.hEvent = 0;
    Overlapped.Offset = f_dwFileOffset;
    Overlapped.OffsetHigh = 0;

    fResult = UnlockFileEx( ( HANDLE )f_hFile, 0, f_nNumberOfBytesToUnlock, 0, &Overlapped );

    DRM_PROFILING_LEAVE_SCOPE;
    return fResult;
}

DRM_API DRM_BOOL DRM_CALL Oem_File_SetEndOfFile(
    __in OEM_FILEHDL f_hFile )
{
    return SetEndOfFile( ( HANDLE )f_hFile );
}

DRM_API DRM_BOOL DRM_CALL Oem_File_GetSize(
    __in OEM_FILEHDL f_hFile,
    __out DRM_DWORD *f_pdwFileSize )
{
#if DRM_SUPPORT_TRACING
    DRM_RESULT dr = DRM_SUCCESS;
#endif
    DRM_DWORD dwFileSize = 0;
    DRM_BOOL  fResult = FALSE;

    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_OEMFILEIO, PERF_FUNC_Oem_File_GetSize);
    DRM_PROFILING_DETAIL_LEVEL(4);

    dwFileSize = GetFileSize( ( HANDLE )f_hFile, NULL );

    if ( dwFileSize == INVALID_FILE_SIZE )
    {
        return FALSE;
    }

    if( f_pdwFileSize != NULL )
    {
        *f_pdwFileSize = dwFileSize;
        fResult = TRUE;
    }
    else
    {
        DRMASSERT( FALSE );
    }

    DRM_PROFILING_LEAVE_SCOPE;
    return fResult;
}

DRM_API DRM_BOOL DRM_CALL Oem_File_FlushBuffers(
    __in OEM_FILEHDL f_hFile )
{
#if DRM_SUPPORT_TRACING
    DRM_RESULT dr = DRM_SUCCESS;
#endif
    DRM_BOOL fResult = FALSE;
    
    DRM_PROFILING_ENTER_SCOPE(PERF_MOD_OEMFILEIO, PERF_FUNC_Oem_File_FlushBuffers);
    DRM_PROFILING_DETAIL_LEVEL(2);

    fResult = FlushFileBuffers( ( HANDLE )f_hFile );
    
    DRM_PROFILING_LEAVE_SCOPE;
    return fResult;
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\lib\oemimpl.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <windows.h>
#include <drmcommon.h>

ENTER_PK_NAMESPACE_CODE;

#if DRM_TEST_MEM_ALLOC_CHECK
typedef struct __tagDRM_MEM_ALLOC_INFO 
{
    DRM_DWORD      dwAllocatedSize;
    DRM_DWORD      dwRequestedSize;
    DRM_DWORD_PTR  pOriginal;
    DRM_DWORD      dwSignature;
} DRM_MEM_ALLOC_INFO;

#define DRM_MEM_ALLOC_SIGNATURE 234532

static DRM_DWORD _GetPageSize()
{
    static DRM_DWORD dwPageSize = 0;
    if ( dwPageSize == 0 )
    {
        SYSTEM_INFO oSysInfo={0};
        GetSystemInfo(&oSysInfo);
        dwPageSize = oSysInfo.dwPageSize;
    }
    return dwPageSize;
}

static DRM_BOOL _GetMemAllocInfo( DRM_VOID *pv, DRM_MEM_ALLOC_INFO **ppMemInfo )
{
    DRM_BOOL fRet = TRUE;

    *ppMemInfo = (DRM_MEM_ALLOC_INFO *) ( ( ( DRM_DWORD_PTR )pv ) - SIZEOF( DRM_MEM_ALLOC_INFO ) );
    if ( (*ppMemInfo)->dwSignature != DRM_MEM_ALLOC_SIGNATURE )
    {
        fRet = FALSE;
    }
    
    return fRet;
}
#endif

/**********************************************************************
** Memory allocation functions 
***********************************************************************
*/
DRM_API DRM_VOID * DRM_CALL Oem_MemAlloc(
    __in DRM_DWORD size )
{
#if !DRM_TEST_MEM_ALLOC_CHECK
    return (size > 0) ? HeapAlloc( GetProcessHeap(), 0, size ) : NULL;
#else
    DRM_DWORD dwPages = 0;
    DRM_DWORD dwSize = size;
    DRM_DWORD dwProtect = 0;
    DRM_BYTE *pRet = NULL;
    DRM_MEM_ALLOC_INFO oMemInfo = {0};

    if ( size == 0 )
    {
        return NULL;
    }

    dwSize += SIZEOF( DRM_MEM_ALLOC_INFO );

    if ( dwSize % SIZEOF( DRM_DWORD_PTR ) != 0 )
    {
        dwSize += SIZEOF( DRM_DWORD_PTR ) - ( dwSize % SIZEOF( DRM_DWORD_PTR ) );
    }
    dwPages = dwSize / _GetPageSize();
    if ( dwSize % _GetPageSize() != 0 )
    {
        dwPages++;
    }
    dwPages++;

    oMemInfo.dwRequestedSize = size;

    oMemInfo.dwAllocatedSize = dwPages * _GetPageSize();

    if ( oMemInfo.dwAllocatedSize < oMemInfo.dwAllocatedSize - _GetPageSize() )
    {
        TRACE(("Integer Overflow Allocating Memory"));
        return NULL;
    }

    pRet = ( DRM_BYTE * ) VirtualAlloc(NULL, oMemInfo.dwAllocatedSize, MEM_COMMIT, PAGE_READWRITE );
    
    if( pRet == NULL )
    {
        TRACE(("error allocating memory: %d", GetLastError() ));
        return NULL;
    }
    oMemInfo.pOriginal = ( DRM_DWORD_PTR ) pRet;
    oMemInfo.dwSignature = DRM_MEM_ALLOC_SIGNATURE;

    pRet += oMemInfo.dwAllocatedSize - _GetPageSize();

    if ( VirtualProtect( pRet, _GetPageSize(), PAGE_NOACCESS, (PDWORD)&dwProtect ) != TRUE )
    {
        TRACE(("error protecting memory: %d", GetLastError() ));
        return NULL;
    }

    pRet -= dwSize;
    MEMCPY(pRet, (DRM_BYTE *) &oMemInfo, SIZEOF( DRM_MEM_ALLOC_INFO ) );
    pRet += SIZEOF( DRM_MEM_ALLOC_INFO );
    
    return ( DRM_VOID *) pRet;
 #endif
    
}

DRM_API DRM_VOID DRM_CALL Oem_MemFree( 
    __in DRM_VOID *pv )
{
#if !DRM_TEST_MEM_ALLOC_CHECK
#if SET_FREE_MEMORY
    DRM_DWORD dwHeapSize =0;
    dwHeapSize = HeapSize( GetProcessHeap(), 0, pv );
    if ( 0xFFFFFFFF != dwHeapSize )
    {
        memset( pv, 0, dwHeapSize );
    }
#endif
    HeapFree( GetProcessHeap(), 0, pv );
#else
    DRM_MEM_ALLOC_INFO *pMemInfo = NULL;
    DRM_BYTE *pbTemp = NULL;

    if ( !_GetMemAllocInfo( pv, &pMemInfo ) )
    {
        return;
    }

    pbTemp = ( DRM_BYTE * ) pMemInfo->pOriginal;

    if ( VirtualFree( pbTemp, 0, MEM_RELEASE ) != TRUE )
    {
        TRACE(("error freeing memory: %d", GetLastError() ));
    }
#endif
    return;
}

DRM_API DRM_VOID * DRM_CALL Oem_MemRealloc(
    __inout DRM_VOID *pv, 
    __in DRM_DWORD size )
{
#if !DRM_TEST_MEM_ALLOC_CHECK
    if( pv )
    {
        return HeapReAlloc( GetProcessHeap(), 0, pv, size );
    }

    return HeapAlloc( GetProcessHeap(), 0, size );
#else
    DRM_BYTE *pbTemp = NULL;
    DRM_MEM_ALLOC_INFO *pOldMemInfo = NULL;

    pbTemp = ( DRM_BYTE * ) Oem_MemAlloc( size );
    if( pv != NULL && pbTemp != NULL )
    {
        if ( !_GetMemAllocInfo( pv, &pOldMemInfo ) )
        {
            return NULL;
        }
        MEMCPY( pbTemp, (DRM_BYTE *)pv, min( size , pOldMemInfo->dwRequestedSize ) );
        Oem_MemFree(pv);
    }
    return pbTemp; 
#endif
}

/**********************************************************************
** Random number generation functions 
***********************************************************************
*/
static       DRM_UINT64 g_qwRandomSeed     =  DRM_UI64LITERAL( 0x25B946EB, 0xC0B36173); /* default value */   
static       DRM_BOOL   g_fSeedInitialized =  FALSE;
static const DRM_UINT64 RANDOM_MULTIPLIER  =  DRM_UI64LITERAL( 0x2B992DDF, 0xA23249D5 ); /* odd */ 
static const DRM_UINT64 INIT_MULTIPLIER    =  DRM_UI64LITERAL( 0,          14142135 );

/**********************************************************************
** Function:    Oem_Random_SetSeed
**
** Synopsis:    Manually set the seed for the random number generator. 
**              The seed is multiplied by INIT_MULTIPLIER before use
**
** Arguments:   [f_pOEMContext] -- OEM specified context
**              [f_qwNewSeed]   -- The new seed value
**
** Returns:     None
**
***********************************************************************/
DRM_API DRM_VOID DRM_CALL Oem_Random_SetSeed (
    __in_opt DRM_VOID *f_pOEMContext,
    __in const DRM_UINT64  f_qwNewSeed )
{
    g_qwRandomSeed     = DRM_UI64Mul( INIT_MULTIPLIER, f_qwNewSeed );
    g_fSeedInitialized = TRUE;
}

#define PACKED_CHAR_BIT ( CHAR_BIT / CB_NATIVE_BYTE )

/**********************************************************************
** Function:    Oem_Random_GetBytes
**
** Synopsis:    Generate pseudo-random array of bytes using an OEM provided 
**              random number generator. Initializes the random seed if it has 
**              not already been set using Oem_Random_SetSeed or a previous call
**              to Oem_Random_GetBytes.
**
** Arguments:   [f_pOEMContext] -- OEM specified context
**              [f_pbData]      -- Buffer to hold the random bytes
**              [f_cbData]      -- Count of bytes to generate and fill in pbData
**
** Returns:     DRM_SUCCESS
**                  Success
**              DRM_E_ARITHMETIC_OVERFLOW
**                  An arithmetic overflow occurred during processing.
**
** Notes:       This generator has not been designed to be fast, nor to have
**              good cryptographic or statistical properties. It is not designed
**              for multitasking.
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL Oem_Random_GetBytes( 
    __in_opt DRM_VOID *f_pOEMContext,
    __out_bcount( f_cbData ) DRM_BYTE *f_pbData, 
    __in DRM_DWORD f_cbData )
{
    const DRM_DWORD SHIFT_COUNT = PACKED_CHAR_BIT * ( SIZEOF( DRM_UINT64 ) - SIZEOF( DRM_DWORD ) );
    DRM_RESULT  dr           = DRM_SUCCESS;
    DRM_DWORD   cbBytesLeft  = f_cbData;
    DRM_DWORD   ib           = 0;
    DRM_DWORD   cbCurrent    = 0;
    DRM_DWORD   dwValue      = 0;
    DRMFILETIME ft           = { 0 };
    DRM_UINT64  u64          = DRM_UI64LITERAL( 0, 0 );

    ChkArg( f_pbData != NULL );

    /*
    ** Set random seed the first time, unless it has been manually set using
    ** Oem_Random_SetSeed
    */
    if ( !g_fSeedInitialized )
    {
        Oem_Clock_GetSystemTimeAsFileTime( f_pOEMContext, &ft );
        FILETIME_TO_UI64( ft, u64 );
        Oem_Random_SetSeed( f_pOEMContext, u64 );
    }
    while ( cbBytesLeft != 0 )
    {
        cbCurrent = min( cbBytesLeft, SIZEOF( DRM_DWORD ) );
        cbBytesLeft -= cbCurrent;
        g_qwRandomSeed = DRM_UI64Add( DRM_UI64Mul( g_qwRandomSeed, RANDOM_MULTIPLIER ), DRM_UI64( 1 ) );
        dwValue = DRM_I64ToUI32( DRM_UI2I64( DRM_UI64ShR( g_qwRandomSeed, SHIFT_COUNT ) ) );
        do 
        {
            ChkBOOL( ib < f_cbData, DRM_E_ARITHMETIC_OVERFLOW ); 

            PUT_BYTE( f_pbData, ib, ( DRM_BYTE )( dwValue & UCHAR_MAX ) );
            ib++;
            dwValue >>= PACKED_CHAR_BIT;
            cbCurrent--;
        } while ( cbCurrent != 0 );
    }
    
ErrorExit:
    return dr;
} 

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\lib\oeminfo.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmtypes.h>
#include <drmutilities.h>

ENTER_PK_NAMESPACE_CODE;

/* C:\\WMDRMPD\\ */
static const DRM_WCHAR g_rgwchDrmPath [] =
{
    ONE_WCHAR('C', '\0'),  ONE_WCHAR(':', '\0'),  ONE_WCHAR('\\', '\0'), ONE_WCHAR('w', '\0'),
    ONE_WCHAR('m', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('m', '\0'),
    ONE_WCHAR('p', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('\\', '\0'), ONE_WCHAR('\0', '\0')
};

/* The DRM path may be overridden by the test code */
DRM_EXPORT_VAR DRM_CONST_STRING g_dstrDrmPath   = CREATE_DRM_STRING( g_rgwchDrmPath );

/* priv.dat */
static const DRM_WCHAR g_rgwchPrivKey [] = 
{
    ONE_WCHAR('p', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('v', '\0'),
    ONE_WCHAR('.', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),
    ONE_WCHAR('\0', '\0')
};

const DRM_CONST_STRING g_dstrPrivKey = CREATE_DRM_STRING( g_rgwchPrivKey );

DRM_BOOL g_fDeviceResetState = TRUE;

DRM_API DRM_RESULT DRM_CALL _GetDRMFullPathName( 
    __out DRM_WCHAR **ppwszFullPath, 
    __in_opt const DRM_CONST_STRING *pdstrFilename,
    __in DRMFILESPATH eFilesPath )
{
    DRM_RESULT dr          = DRM_SUCCESS;
    DRM_DWORD  cchFullPath = 0;
    DRM_DWORD  cchPath     = g_dstrDrmPath.cchString;

    ChkArg( ppwszFullPath != NULL );

    ChkDRMString( pdstrFilename );

    *ppwszFullPath = NULL;
    cchFullPath    = pdstrFilename->cchString 
                   + g_dstrDrmPath.cchString 
                   + 2;

    if( pdstrFilename->cchString + g_dstrDrmPath.cchString     < pdstrFilename->cchString
     || pdstrFilename->cchString + g_dstrDrmPath.cchString + 2 < pdstrFilename->cchString
     || cchFullPath > cchFullPath * SIZEOF( DRM_WCHAR ) )
    {
        ChkDR( DRM_E_ARITHMETIC_OVERFLOW );
    }
    
    ChkMem( *ppwszFullPath = ( DRM_WCHAR * )Oem_MemAlloc( cchFullPath * SIZEOF( DRM_WCHAR ) ) );
    ChkDR( DRM_STR_StringCchCopyNW( *ppwszFullPath, cchFullPath, g_dstrDrmPath.pwszString, g_dstrDrmPath.cchString + 1 ) );

    /* Need to check whether it is ended with a backslash "\" */
    if ( (*ppwszFullPath)[ cchPath - 1 ] != g_wchPathSeperator )
    {
        (*ppwszFullPath)[ cchPath ] = g_wchPathSeperator;
        cchPath++;
    }

    ChkDR( DRM_STR_StringCchCopyNW( *ppwszFullPath + cchPath, 
                               cchFullPath - cchPath, 
                               pdstrFilename->pwszString, 
                               pdstrFilename->cchString + 1 ) );
ErrorExit:
    return dr;
}

/*****************************************************************************
** Function:    _GetPrivateKey
**
** Synopsis:    Obtains either the Group Certificate (GC) private key, or 
**              the Fallback signing key from the privkey file.
**
** Arguments:   [f_pOEMContext] : A pointer to the OEM context; may be NULL
**              [f_fGCprivkey]  : TRUE for GC privkey, FALSE for Fallback signing key
**              [f_pbPrivkey]   : Returned privkey
**              [f_cbPrivKey]   : Size of the key buffer
**
** Returns:     DRM_SUCCESS            - on success
**              DRM_E_PRIVKEYREADERROR - on any failure
**
** Notes:       The GC privkey and Fallback privkey are in the same file; the
**              GC privkey is the first 20 bytes, the Fallback signing key is the second 20 bytes.
**
******************************************************************************/
DRM_RESULT _GetPrivateKey(
    __in_opt DRM_VOID *f_pOEMContext,
    __in const  DRM_BOOL  f_fGCprivkey,
    __out_bcount( f_cbPrivKey ) DRM_BYTE *f_pbPrivkey,
    __in DRM_DWORD f_cbPrivKey )
{
    DRM_RESULT   dr       = DRM_SUCCESS;
    OEM_FILEHDL  fp       = OEM_INVALID_HANDLE_VALUE;
    DRM_WCHAR   *pwszPath = NULL; 
    DRM_DWORD    iRead    = 0;
    DRM_DWORD    cbFile   = 0;


    ChkArg( f_pbPrivkey != NULL );
    ChkDR( _GetDRMFullPathName ( &pwszPath, &g_dstrPrivKey, CERTPATH ) );
    fp = Oem_File_Open( f_pOEMContext,
                       pwszPath, 
                       OEM_GENERIC_READ, 
                       OEM_FILE_SHARE_READ, 
                       OEM_OPEN_EXISTING, 
                       OEM_ATTRIBUTE_HIDDEN );
    if ( fp == OEM_INVALID_HANDLE_VALUE )
    {
        ChkDR( DRM_E_FILENOTFOUND );
    }

    /* load file content in memory */
    if ( !Oem_File_GetSize( fp, &cbFile ) )
    {
        ChkDR( DRM_E_FILEREADERROR );
    }

    if ( cbFile != ( 2 * SIZEOF( PRIVKEY ) ) )
    {
        ChkDR( DRM_E_PRIVKEYREADERROR );
    }

    if ( !Oem_File_SetFilePointer( fp, ( f_fGCprivkey? 0 : SIZEOF( PRIVKEY ) ),
        OEM_FILE_BEGIN, NULL) )
    {
        ChkDR( DRM_E_FILESEEKERROR );
    }
    
    ChkBOOL( f_cbPrivKey >= SIZEOF( PRIVKEY ), DRM_E_BUFFERTOOSMALL );
    
    if ( !Oem_File_Read( fp, f_pbPrivkey, SIZEOF( PRIVKEY ), &iRead) || iRead != SIZEOF( PRIVKEY ) )
    {
        ChkDR( DRM_E_FILEREADERROR );
    }
    
ErrorExit:
    if( fp != OEM_INVALID_HANDLE_VALUE )
    {
        Oem_File_Close( fp );
    }
    
    SAFE_OEM_FREE( pwszPath );

    return dr;
}

DRM_RESULT _GetHWID(
    __out_bcount(DRM_SHA1_DIGEST_LEN) DRM_BYTE *shaOut )
{
    DRM_RESULT dr = DRM_SUCCESS;
    
    ChkArg( shaOut != NULL );

    MEMSET( shaOut, 0xa, DRM_SHA1_DIGEST_LEN );
    
ErrorExit:
    
    return dr;
}

/* NOTE TO OEM: Full implementation required */
/**********************************************************************
** Function:    Oem_Clock_GetResetState
** Synopsis:    Get the Secure Clock Reset state.
** Arguments:   [pOEMContext] -- OEM implemented context
**              [pfReset]     -- Bool to get the state
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL Oem_Clock_GetResetState(
    __in_opt DRM_VOID *pOEMContext,
    __out DRM_BOOL *pfReset )
{
    DRM_RESULT dr=DRM_SUCCESS;
    ChkArg( pfReset != NULL );

    *pfReset = g_fDeviceResetState;

ErrorExit:
    return dr;
}

/* NOTE TO OEM: Full implementation required */
/**********************************************************************
** Function:    Oem_Clock_SetResetState
** Synopsis:    Set the Secure Clock Reset state.
** Arguments:   [pOEMContext] -- OEM implemented context
**              [pfReset]     -- Bool to set the state
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL Oem_Clock_SetResetState(
    __in_opt DRM_VOID *pOEMContext,
    __in DRM_BOOL fReset )
{
    DRM_RESULT dr=DRM_SUCCESS;
    
    g_fDeviceResetState = fReset;
   
    return dr;
}

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\lib\oemimpl_common.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <drmcommon.h>
#include <drmcrt.h>
#include <drmcmdlnpars.h>

#if DRM_SUPPORT_SST_REDUNANCY
#include <drmtoken.h>
#endif /* DRM_SUPPORT_SST_REDUNANCY */

ENTER_PK_NAMESPACE_CODE;

#if DRM_SUPPORT_SST_REDUNANCY
DRM_API DRM_RESULT DRM_CALL VariableSSTRedundancyGetorSet(
    __in const DRM_CONST_STRING *pdstrToken, 
   __in TOKEN *pNewValue, 
   __out TOKEN *pResult, 
   __inout DRM_VOID *pvOpaqueData, 
   __in DRM_BOOL fSet )
{
    return DRM_E_NOTIMPL;
}

#endif /* DRM_SUPPORT_SST_REDUNANCY */



/**********************************************************************
** Function:    Oem_Hds_GetSetReplayCheck
** 
** Synopsis:    This function locks the hashed data store (HDS) to the device.
**
** Arguments:   [f_pvOpaqueData] - Pointer to a license evaluator context, which is used
**                                 to access the blackbox context to hash data.
**              [f_pbKey]        - When setting this value, it is the pointer to a buffer containing
**                                 the data store key that is written to the device rendundancy
**                                 location on the device.
**                                 When getting this value, it is the buffer to be filled in.
**              [f_cbKey]        - Contains the count of bytes in f_pbKey.
**              [f_fGet]         - Indicates whether getting (true) or setting (false) the value.
**
** Returns:     DRM_E_NOTIMPL
**
** Notes:       The HDS is locked to the device using a redundant time stamp as a check point. 
**              Two time stamps are stored on the device. One is stored in the HDS and the other is
**              stored somewhere else. You can store the non-HDS time stamp in memory or in a flash
**              location. Whenever content is stored to the device, an HDS time stamp and a non-HDS
**              time stamp are created for the content.
**
**              This function prevents content from being played after an HDS has been backed up and
**              restored to try to get more play counts. Playback is prevented because the value of
**              the data store key and the value stored in the device redundancy location must match
**              for the data store to be valid. 
**
**              The sample OEM implementation does not implement this functionality because the
**              non-HDS time stamp storage location will vary from implementation to implementation.
**              In implementations with multiple hashed data stores, this function must have 
**              multiple locations for storing the non-HDS time stamps.
**
***********************************************************************/
DRM_API DRM_RESULT DRM_CALL Oem_Hds_GetSetReplayCheck(
    __in DRM_VOID *f_pvOpaqueData,
    __inout_bcount( f_cbKey ) DRM_BYTE *f_pbKey,
    __in DRM_DWORD f_cbKey,
    __in DRM_BOOL f_fGet )
{
    return DRM_E_NOTIMPL;
}

#if DRM_SUPPORT_BLOCK_HEADER_CACHING

/*
**      NOTE TO IMPLEMENTOR:
**
**      This cache MUST be global to all instances of the porting kit sharing
**      the same HDS file. Also, there should be appropriate resource locking
**      added around access to the cache to protect its integrity. Also, if
**      multiple HDS files are used, the caches for each file must be separate.
**
*/
static BLOCK_HEADER_CACHE_ENTRY g_rgBlockHeaderCache[MAX_CACHED_BLOCK_HEADERS] = {0};

/*****************************************************************************
** Function: Oem_Hds_ClearBlockHeaderCache
**
** Synopsis: This function should clear any cached data. This function will
**           be triggered if Drm_ClearAllCaches is called, and is used
**           when the HDS, devcert, or private key may have changed
**           (ie if the device is formatted)
**
*****************************************************************************/
DRM_API DRM_VOID DRM_CALL Oem_Hds_ClearBlockHeaderCache( DRM_VOID )
{
    DRM_DWORD i;

    for( i = 0; i < MAX_CACHED_BLOCK_HEADERS; i++ )
    {
        g_rgBlockHeaderCache[i].dwBlockNumber = 0;
    }
}

/*****************************************************************************
** Function: Oem_Hds_CheckBlockHeaderCache
**
** Synopsis: This function should attempt to retrieve the block header for the
**           specified block number from the cache. If there is no matching entry
**           in the cache, the function should return DRM_E_HDS_BLOCK_CACHE_MISS
**
** Arguments:
**           IN   f_dwBlockNumber          -- Block number of the block header to be retrieved,
**                                            note that it will always be greater than 0
**           IN   f_pHDSFileHandle         -- The OEM filehandle to the HDS file. This may be useful
**                                            if multiple HDS files are used on the same system, each
**                                            HDS file must have its own unique cache.
**           OUT  f_pdwBlockHeaderMetadata -- Returns metadata associated with the block header
**           OUT *f_pbBlock                -- Pointer to a buffer to receive the block header
**           IN   f_cbBytesToRead          -- Number of bytes to read from the cache
**
** Returns:
**           DRM_SUCCESS                 -- On success
**           DRM_E_INVALIDARG            -- if any argument is invalid
**           DRM_E_HDS_BLOCK_CACHE_MISS  -- A matching cache entry was not found
*****************************************************************************/
DRM_API DRM_RESULT DRM_CALL Oem_Hds_CheckBlockHeaderCache(
    __in      DRM_DWORD   f_dwBlockNumber,
    __in_opt  OEM_FILEHDL f_hHDSFileHandle,
    __out_opt DRM_DWORD  *f_pdwBlockHeaderMetadata,
    __out_bcount_opt( f_cbBytesToRead ) DRM_BYTE   *f_pbBlock,
    __in      DRM_DWORD   f_cbBytesToRead )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  i = 0;

    ChkArg( f_dwBlockNumber > 0 );

    if( f_cbBytesToRead > 0 )
    {
        ChkArg( f_pbBlock != NULL && 
                f_cbBytesToRead <= CALC_MAXBLOCKHEADERLEN );
    }

    for( i = 0; i < MAX_CACHED_BLOCK_HEADERS; i++ )
    {
        if( g_rgBlockHeaderCache[i].dwBlockNumber == f_dwBlockNumber )
        {
            if( g_rgBlockHeaderCache[i].cbBytesAvailable < f_cbBytesToRead )
            {
                break;
            }
            
            /* We've got a cache hit */
            if( f_pdwBlockHeaderMetadata != NULL )
            {
                *f_pdwBlockHeaderMetadata = g_rgBlockHeaderCache[i].dwBlockHeaderMetadata;
            }

            if( f_cbBytesToRead > 0 )
            {
                MEMCPY( f_pbBlock, g_rgBlockHeaderCache[i].rgbBlockHeader, f_cbBytesToRead );
            }

            /* Track how many hits we get for this block header, the data can be used
            ** to throw out infrequently used entries */
            g_rgBlockHeaderCache[i].dwCacheHits++;

            goto ErrorExit;
        }
    }

    ChkDR( DRM_E_DST_BLOCK_CACHE_MISS );
    
ErrorExit:
    
    return dr;
}

/*****************************************************************************
** Function: Oem_Hds_UpdateBlockHeaderCache
**
** Synopsis: This function should attempt to retrieve the block header for the
**           specified block number from the cache. If there is no matching entry
**           in the cache, the function should return DRM_E_HDS_BLOCK_CACHE_MISS
**
** Arguments:
**           IN   f_dwBlockNumber          -- Block number of the block header to be updated,
**                                            note that it will always be greater than 0
**           IN   f_pHDSFileHandle         -- The OEM filehandle to the HDS file. This may be useful
**                                            if multiple HDS files are used on the same system, each
**                                            HDS file must have its own unique cache.
**           IN   f_dwBlockHeaderMetadata  -- Specifies metadata to be associated with the block header
**           IN  *f_pbBlock                -- Pointer to a buffer containg the block header data
**           IN   f_cbBytesToRead          -- Number of bytes to write to the cache
**
** Returns:
**           DRM_SUCCESS                 -- On success
**           DRM_E_INVALIDARG            -- if any argument is invalid
**           DRM_S_FALSE                 -- No space to create a new cache entry
*****************************************************************************/
DRM_API DRM_RESULT DRM_CALL Oem_Hds_UpdateBlockHeaderCache(
    __in     DRM_DWORD   f_dwBlockNumber,
    __in_opt OEM_FILEHDL f_hHDSFileHandle,
    __in     DRM_DWORD   f_dwBlockHeaderMetadata,
    __in_bcount_opt( f_cbBytesToWrite ) DRM_BYTE   *f_pbBlock,
    __in     DRM_DWORD   f_cbBytesToWrite )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_LONG i = 0;
    DRM_LONG iLastEmpty = -1;

    ChkArg( f_dwBlockNumber > 0 );
    
    if ( f_cbBytesToWrite > 0 )
    {
        ChkArg( f_pbBlock != NULL &&
                f_cbBytesToWrite <= CALC_MAXBLOCKHEADERLEN );
    }

    for ( i = 0; i < MAX_CACHED_BLOCK_HEADERS; i++ )
    {
        if ( g_rgBlockHeaderCache[i].dwBlockNumber == f_dwBlockNumber )
        {
            /* We've already got a cache entry, update it */
            
            g_rgBlockHeaderCache[i].dwBlockHeaderMetadata = f_dwBlockHeaderMetadata;

            if ( f_cbBytesToWrite > 0 )
            {
                MEMCPY ( g_rgBlockHeaderCache[i].rgbBlockHeader, f_pbBlock, f_cbBytesToWrite );
                
                if ( g_rgBlockHeaderCache[i].cbBytesAvailable < f_cbBytesToWrite )
                {
                    g_rgBlockHeaderCache[i].cbBytesAvailable = f_cbBytesToWrite;
                }
            }

            /* We're done */
            goto ErrorExit;
        }
        else if ( g_rgBlockHeaderCache[i].dwBlockNumber == 0 && iLastEmpty == -1 )
        {
            /* Take note of the empty block cache entry, we may need it */
            iLastEmpty = i;
        }
    }

    /* No existing entry, if there's empty space then create a new entry */
    if ( iLastEmpty > -1 )
    {
        g_rgBlockHeaderCache[iLastEmpty].dwBlockHeaderMetadata = f_dwBlockHeaderMetadata;

        if ( f_cbBytesToWrite > 0 )
        {
            MEMCPY ( g_rgBlockHeaderCache[iLastEmpty].rgbBlockHeader, f_pbBlock, f_cbBytesToWrite );
            g_rgBlockHeaderCache[iLastEmpty].cbBytesAvailable = f_cbBytesToWrite;
        }

        g_rgBlockHeaderCache[iLastEmpty].dwBlockNumber = f_dwBlockNumber;

        goto ErrorExit;
    }

    /* No room to cache this one */
    dr = DRM_S_FALSE;

ErrorExit:
    
    return dr;
}

#endif /* DRM_SUPPORT_BLOCK_HEADER_CACHING */

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\lib\oemndt.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmcrt.h>
#include <drmtypes.h>
#include <ndttypes.h>
#include <oemndt.h>

ENTER_PK_NAMESPACE_CODE;


/* "MTP" */
#define PROXIMITYDETECTIONADDRESS_LEN 4 /* include NULL terminator */
static DRM_BYTE s_szProximityDetectionAddress[__CB_DECL(PROXIMITYDETECTIONADDRESS_LEN)] = { 
    TWO_BYTES('M', 'T'), TWO_BYTES('P', '\0')
};


/**********************************************************************
**
** Function:    Oem_Ndt_AllowNewDeviceRegistration
**
** Synopsis:    This OEM function is called by the NDT PK if it 
**              receives a registration request from a device that is 
**              not already registered in the OEM device store.  If 
**              this function returns success, then the device will be 
**              added to the device store.  Else it will not be added 
**              and the NDT PK will fail the original call that 
**              required the device to be registered.
**
**              This function can be used by OEMs who want to pop a 
**              UI or take some decision about whether to add a new 
**              device.
**
**              For this sample/default implementation, this function just always
**              succeeds.
**
** Arguments:   [f_DeviceCertificate]  -- device certificate
**              [f_DeviceSerialNumber] -- device serial number
**
** Returns:     DRM_SUCCESS -- Always
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL Oem_Ndt_AllowNewDeviceRegistration(
    __in     DRM_BYTEBLOB   f_DeviceCertificate,
    __in     DRM_BYTEBLOB   f_DeviceSerialNumber
)
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_NDT, PERF_FUNC_OEM_NDT_AllowNewDeviceRegistration );

    ChkDR( dr );

    UNREFERENCED_PARAMETER( f_DeviceCertificate );
    UNREFERENCED_PARAMETER( f_DeviceSerialNumber );

 ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



/**********************************************************************
**
** Function:    Oem_Ndt_GetProximityDetectionAddress
**
** Synopsis:    Gets the proximity detection address for a device.
**              The caller (viz the NDT PK) must allocate f_pbAddress 
**              and supply the size in *f_pcbAddress.  If the buffer 
**              size is sufficient and the function succeeds, it returns 
**              the number of bytes copied into the buffer via 
**              *f_pcbAddress.  
**              If the buffer size is not sufficent, the function will 
**              fail with DRM_E_BUFFERTOOSMALL and return the required 
**              size in *f_pcbAddress.  This feature can be used by the
**              caller to determine the size of buffer needed to hold 
**              the address.  If all the caller wants to do is find out
**              the size of buffer needed, f_pbAddress can be NULL.
**
** Arguments:   [f_pbAddress]             -- caller-allocated pointer to hold address
**              [f_pcbAddress]            -- input  - size of buffer available
**                                           output - size of buffer used
**
** Returns:     DRM_E_BUFFERTOOSMALL - if *f_pcbAddress is too small
**              DRM_SUCCESS          - ON SUCCESS
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL Oem_Ndt_GetProximityDetectionAddress(
    __out_bcount_opt(*f_pcbAddress) DRM_BYTE       *f_pbAddress,
    __inout                         DRM_WORD       *f_pcbAddress
)
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_NDT, PERF_FUNC_OEM_NDT_GetProximityDetectionAddress );

    ChkArg( f_pcbAddress != NULL );

    if ( *f_pcbAddress < PROXIMITYDETECTIONADDRESS_LEN )
    {
        *f_pcbAddress = PROXIMITYDETECTIONADDRESS_LEN;
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    ChkArg( f_pbAddress != NULL );

    DRM_BYT_CopyBytes( f_pbAddress, 
                       0, 
                       s_szProximityDetectionAddress, 
                       0, 
                       PROXIMITYDETECTIONADDRESS_LEN );
                       
    *f_pcbAddress = PROXIMITYDETECTIONADDRESS_LEN;

 ErrorExit:   
    DRM_PROFILING_LEAVE_SCOPE;
    return dr;
}



/******************************************************************************
**
** Function:  OEM_NDT_GetLicenseOPLs
**
** Synopsis:  Sets the OPL (Output Protection Level) values, in the content sessions's ASF Context,
**            to be used in the generation of an XMR license for clear content.
**
** Arguments: [f_MinPlayOpls] -- Supplies a pointer to a variable that 
**                               optionally receives the minimum OPL set to use
**                               for clear content.
**            [f_fOplSet] -- Supplies a pointer to a variable that will be 
**                           updated with TRUE if f_MinPlayOpls was set, FALSE
**                           otherwise. In the latter case, the content will 
**                           have a default set of minimal OPLs corresponding
**                           to test content (in other words, analog copying 
**                           allowed.) On error, this value is undefined.
**
** Returns:   DRM_E_INVALIDARG - if the parameter is NULL
**            DRM_SUCCESS      - ON SUCCESS
**
******************************************************************************/
DRM_BOOL   g_fOverride_OPL_Defaults    = FALSE;
DRM_WORD   g_wAnalogVideo              = 200;
DRM_WORD   g_wCompressedDigitalAudio   = 200;
DRM_WORD   g_wCompressedDigitalVideo   = 200;
DRM_WORD   g_wUncompressedDigitalAudio = 200;
DRM_WORD   g_wUncompressedDigitalVideo = 200;

DRM_API DRM_RESULT DRM_CALL OEM_NDT_GetLicenseOPLs(
    __out_opt DRM_MINIMUM_OUTPUT_PROTECTION_LEVELS *f_MinPlayOpls,
    __out     DRM_BOOL                             *f_fOplSet
)
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_NDT, PERF_FUNC_OEM_NDT_GetLicenseOPLs );

    if ( g_fOverride_OPL_Defaults )
    {
        f_MinPlayOpls->wAnalogVideo              = g_wAnalogVideo;
        f_MinPlayOpls->wCompressedDigitalAudio   = g_wCompressedDigitalAudio;
        f_MinPlayOpls->wCompressedDigitalVideo   = g_wCompressedDigitalVideo;
        f_MinPlayOpls->wUncompressedDigitalAudio = g_wUncompressedDigitalAudio;
        f_MinPlayOpls->wUncompressedDigitalVideo = g_wUncompressedDigitalVideo;

        *f_fOplSet = TRUE;
    }
    else
    {
        *f_fOplSet = FALSE;        
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}



/******************************************************************************
**
** Function:  OEM_NDT_GetLicenseInclusionList
**
** Synopsis:  Sets the Inclusion List GUIDs, in the content sessions's ASF Context,
**            to be used in the generation of an XMR license for clear content.
**
** Arguments: [f_InclusionList] -- Supplies a pointer to a variable that 
**                                 optionally receives an inclusion list whose 
**                                 array was allocated with Oem_MemAlloc.
**            [f_fInclusionListSet] -- Supplies a variable that receives TRUE
**                                     if the list was populated, FALSE 
**                                     otherwise. On error, this value is 
**                                     undefined.
**
** Returns:   DRM_E_INVALIDARG  - if the parameter is NULL
**            DRM_E_OUTOFMEMORY - if the memory allocation fails
**            DRM_SUCCESS       - ON SUCCESS
**
******************************************************************************/
DRM_BOOL   g_fOverride_InclusionList_Defaults = FALSE;
DRM_DWORD  g_cInclusionListGUIDs              = 2;
DRM_GUID   g_TestGUIDs[3] = 
{
    { 0xE0FB055E, 0x4F34, 0x4d46, { TWO_BYTES(0x8C,0xBE), TWO_BYTES(0x41,0xC6), TWO_BYTES(0xCB,0x0A), TWO_BYTES(0xF5,0x46) }},
    { 0x3A6390E8, 0x9467, 0x4f08, { TWO_BYTES(0xA2,0xA4), TWO_BYTES(0x29,0xB9), TWO_BYTES(0x51,0xBE), TWO_BYTES(0xE8,0x28) }},
    { 0xB0D58B22, 0x64F6, 0x4931, { TWO_BYTES(0xA7,0xA1), TWO_BYTES(0xD3,0xAB), TWO_BYTES(0x56,0xED), TWO_BYTES(0xAC,0x6C) }},
};
/*  {E0FB055E-4F34-4d46-8CBE-41C6CB0AF546}
**  {3A6390E8-9467-4f08-A2A4-29B951BEE828}
**  {B0D58B22-64F6-4931-A7A1-D3AB56EDAC6C}
*/

DRM_API DRM_RESULT DRM_CALL OEM_NDT_GetLicenseInclusionList(
    __inout_opt DRM_GUIDLIST *f_InclusionList,
    __out       DRM_BOOL     *f_fInclusionListSet
)
{
    DRM_RESULT dr       = DRM_SUCCESS;
    DRM_DWORD  i        = 0;
    DRM_DWORD  dwOffset = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_NDT, PERF_FUNC_OEM_NDT_GetLicenseInclusionList );

    if (   ( g_fOverride_InclusionList_Defaults ) 
        && ( g_cInclusionListGUIDs >  0 ) 
        && ( g_cInclusionListGUIDs <= 3 ) )
    {
        f_InclusionList->cGUIDs = g_cInclusionListGUIDs;

        /* 
        ** The following memory is freed by routine NDTMGR_ASF_Internal_Uninitialize()
        */
        DRMASSERT( f_InclusionList->pguidBuffer == NULL );
        ChkMem( f_InclusionList->pguidBuffer = 
                (DRM_BYTE *)Oem_MemAlloc( SIZEOF(DRM_GUID) * f_InclusionList->cGUIDs ));

        for (i = 0; i < g_cInclusionListGUIDs; i++)
        {
            DRM_BYT_CopyBytes( f_InclusionList->pguidBuffer, 
                               dwOffset,
                               (DRM_BYTE *)&g_TestGUIDs[i], 
                               0,
                               SIZEOF( DRM_GUID ) );
            dwOffset += SIZEOF( DRM_GUID );
        }

        *f_fInclusionListSet = TRUE;
    }
    else
    {
        *f_fInclusionListSet = FALSE;
    }
    
 ErrorExit:    

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/******************************************************************************
**
** Function:  OEM_NDT_GetSourceID
**
** Synopsis:  Gets the Source ID to be used in the XMR license.
**
** Arguments: [f_pdwSourceID]      -- pointer to value to update
**
** Returns:   DRM_E_INVALIDARG  - if the parameter is NULL
**            DRM_SUCCESS       - ON SUCCESS
**
******************************************************************************/
DRM_DWORD g_dwSourceID = 0;
DRM_API DRM_RESULT DRM_CALL OEM_NDT_GetSourceID ( 
    __out_ecount(1)    DRM_DWORD                               *f_pdwSourceID )
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_NDT, PERF_FUNC_OEM_NDT_GetSourceID );

    ChkArg( f_pdwSourceID      != NULL );

    *f_pdwSourceID = g_dwSourceID;
    
ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/******************************************************************************
**
** Function:  OEM_NDT_GetLicenseRevInfoVersion
**
** Synopsis:  Gets the Revocation Information Version to be used in the XMR license.
**
** Arguments: [f_pdwRevInfo]       -- pointer to value to update
**
** Returns:   DRM_E_INVALIDARG  - if the parameter is NULL
**            DRM_SUCCESS       - ON SUCCESS
**
******************************************************************************/
DRM_DWORD g_dwRevInfo = 0;
DRM_API DRM_RESULT DRM_CALL OEM_NDT_GetLicenseRevInfoVersion ( 
    __out_ecount(1)     DRM_DWORD                               *f_pdwRevInfo )
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_NDT, PERF_FUNC_OEM_NDT_GetLicenseRevInfoVersion );

    ChkArg( f_pdwRevInfo       != NULL );

    *f_pdwRevInfo = g_dwRevInfo;
    
ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/******************************************************************************
**
** Function:  OEM_NDT_GetWMDRMNETMinAppSec
**
** Synopsis:  Gets the WMDRMNET Minimum Application Security Level to be used in the XMR license.
**
** Arguments: [f_pdwMinAppSec]     -- pointer to value to update
**
** Returns:   DRM_E_INVALIDARG  - if the parameter is NULL
**            DRM_SUCCESS       - ON SUCCESS
**
******************************************************************************/
DRM_DWORD g_dwMinAppSec = 0;
DRM_API DRM_RESULT DRM_CALL OEM_NDT_GetWMDRMNETMinAppSec(
    __out_ecount(1) DRM_DWORD                               *f_pdwMinAppSec )
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_NDT, PERF_FUNC_OEM_NDT_GetWMDRMNETMinAppSec );

    ChkArg( f_pdwMinAppSec      != NULL );

    *f_pdwMinAppSec = g_dwMinAppSec;
    
ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\lib\oeminfo_common.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmcrt.h>
#include <drmbase64.h>
#include <drmstrings.h>

ENTER_PK_NAMESPACE_CODE;

/* zgpriv.dat */
static const DRM_WCHAR g_rgwchZGPrivKey [] = 
{
    ONE_WCHAR('z', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('r', '\0'),  
    ONE_WCHAR('i', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('d', '\0'),  
    ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')
};

/* zprivsig.dat */
static const DRM_WCHAR g_rgwchZPrivKeySign [] = 
{
    ONE_WCHAR('z', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('i', '\0'),  
    ONE_WCHAR('v', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('g', '\0'),  
    ONE_WCHAR('.', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  
    ONE_WCHAR('\0', '\0')
};

/* zprivencr.dat */
static const DRM_WCHAR g_rgwchZPrivKeyEncrypt [] = 
{
    ONE_WCHAR('z', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('i', '\0'),  
    ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('c', '\0'),  
    ONE_WCHAR('r', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  
    ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')
};

/* ndrpriv.dat */
static const DRM_WCHAR g_rgwchNDRPrivKey [] = 
{
    ONE_WCHAR('n', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('p', '\0'),  
    ONE_WCHAR('r', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('.', '\0'),  
    ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')
};

/* ndrgpriv.dat - group (model) private key for ndr */
static const DRM_WCHAR g_rgwchNDRGPrivKey [] = 
{
    ONE_WCHAR('n', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('g', '\0'),  
    ONE_WCHAR('p', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('v', '\0'),  
    ONE_WCHAR('.', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  
    ONE_WCHAR('\0', '\0')
};

const DRM_CONST_STRING g_dstrZGPrivKey = CREATE_DRM_STRING( g_rgwchZGPrivKey );
const DRM_CONST_STRING g_dstrZPrivKeySign = CREATE_DRM_STRING( g_rgwchZPrivKeySign );
const DRM_CONST_STRING g_dstrZPrivKeyEncrypt = CREATE_DRM_STRING( g_rgwchZPrivKeyEncrypt );
const DRM_CONST_STRING g_dstrNDRPrivKey = CREATE_DRM_STRING( g_rgwchNDRPrivKey );
const DRM_CONST_STRING g_dstrNDRGPrivKey = CREATE_DRM_STRING( g_rgwchNDRGPrivKey );

/*
**  XML format device certificate chain files
*/

/* devcert.dat */
static const DRM_WCHAR g_rgwchDevcert [] =
{
    ONE_WCHAR('d', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('c', '\0'),
    ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('.', '\0'),
    ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')
};

/* devcerttemplate.dat */
static const DRM_WCHAR g_rgwchDevcerttemplate [] =
{
    ONE_WCHAR('d', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('c', '\0'),
    ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('t', '\0'),
    ONE_WCHAR('e', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('l', '\0'),
    ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),
    ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')
};

const DRM_CONST_STRING g_dstrDevcert = CREATE_DRM_STRING( g_rgwchDevcert );
const DRM_CONST_STRING g_dstrDevcerttemplate = CREATE_DRM_STRING( g_rgwchDevcerttemplate );


/*
**  Binary format device certificate chain files
*/

/* bdevcert.dat */
static const DRM_WCHAR g_rgwchZDevcert [] =
{
    ONE_WCHAR('b', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('v', '\0'),
    ONE_WCHAR('c', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('t', '\0'),
    ONE_WCHAR('.', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  
    ONE_WCHAR('\0', '\0')
};

/* bgroupcert.dat */
static const DRM_WCHAR g_rgwchZGroupCert [] =
{
    ONE_WCHAR('b', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('o', '\0'),
    ONE_WCHAR('u', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('e', '\0'),
    ONE_WCHAR('r', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('d', '\0'),  
    ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')
};

extern const DRM_CONST_STRING g_dstrZDevcert = CREATE_DRM_STRING( g_rgwchZDevcert );
extern const DRM_CONST_STRING g_dstrZGroupCert = CREATE_DRM_STRING( g_rgwchZGroupCert );


/*
**  ND Receiver certificate chain files
*/

/* ndrcert.dat */
static const DRM_WCHAR g_rgwchReceiverCert [] =
{
    ONE_WCHAR('n', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('c', '\0'),
    ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('.', '\0'),
    ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')
};

/* ndrcerttemplate.dat */
static const DRM_WCHAR g_rgwchReceiverTemplate [] =
{
    ONE_WCHAR('n', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('c', '\0'),
    ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('t', '\0'),
    ONE_WCHAR('e', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('l', '\0'),
    ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),
    ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')
};

const DRM_CONST_STRING g_dstrReceiverCert     = CREATE_DRM_STRING( g_rgwchReceiverCert );
const DRM_CONST_STRING g_dstrReceiverTemplate = CREATE_DRM_STRING( g_rgwchReceiverTemplate );

static const DRM_BYTE _rgbSecStorePassword [] = 
{
    TWO_BYTES('1','2'), TWO_BYTES('3','4'), TWO_BYTES('5','6'), TWO_BYTES('7','8'), TWO_BYTES('9','0'),
    TWO_BYTES('1','2'), TWO_BYTES('3','4'), TWO_BYTES('5','6'), TWO_BYTES('7','8'), TWO_BYTES('9','0')
};

/*****************************************************************************
** Function:    _ReadFromFile
**
** Synopsis:    Reads the file specified into the provided buffer.
**              If this function is called with a NULL buffer pointer, 
**              then the buffer size parm is updated with the required size (in bytes).
**
** Arguments:   [f_pOEMContext] : A pointer to the OEM context; may be NULL
**              [f_pbBuffer]    : Buffer pointer in which to store the file contents; may be NULL
**              [f_pcbBuffer]   : A pointer to the buffer size (in bytes); may be updated
**              [f_pwszPath]    : The full path to the file to read
**
** Returns:     DRM_SUCCESS          - on success
**              DRM_E_FILEREADERROR  - if failure to read the file
**              DRM_E_FILESEEKERROR  - if failure to seek to the beginning of the file
**              DRM_E_BUFFERTOOSMALL - if the supplied buffer is NULL or too small
**              DRM_E_FILENOTFOUND   - if the specified file could not be found
**              DRM_E_INVALIDARG     - if any parameter is invalid
**
** Notes:       None.
**
******************************************************************************/
static DRM_RESULT _ReadFromFile(
    __in_opt     DRM_VOID  *f_pOEMContext,
    __out        DRM_BYTE  *f_pbBuffer,
    __inout      DRM_DWORD *f_pcbBuffer,
    __in         DRM_WCHAR *f_pwszPath )
{
    DRM_RESULT  dr     = DRM_SUCCESS;
    OEM_FILEHDL hfp    = OEM_INVALID_HANDLE_VALUE;
    DRM_DWORD   cbRead = 0;
    DRM_DWORD   cbFile = 0;


    ChkArg( f_pcbBuffer != NULL );
    ChkArg( f_pwszPath  != NULL );

    hfp = Oem_File_Open( f_pOEMContext,
                        f_pwszPath, 
                        OEM_GENERIC_READ, 
                        OEM_FILE_SHARE_READ, 
                        OEM_OPEN_EXISTING, 
                        OEM_ATTRIBUTE_HIDDEN );

    if ( hfp != OEM_INVALID_HANDLE_VALUE )
    {
        if ( !Oem_File_GetSize( hfp, &cbFile ) )
        {
            ChkDR( DRM_E_FILEREADERROR );
        }

        if ( ( *f_pcbBuffer < cbFile ) || ( f_pbBuffer == NULL ) )
        {
            *f_pcbBuffer = cbFile;
            ChkDR( DRM_E_BUFFERTOOSMALL );
        }
        
        if ( !Oem_File_SetFilePointer( hfp, 0, OEM_FILE_BEGIN, NULL ) )
        {
            ChkDR( DRM_E_FILESEEKERROR );
        }
        *f_pcbBuffer = cbFile;    
        if (!Oem_File_Read( hfp, f_pbBuffer, cbFile, &cbRead ) || cbRead != cbFile )
        {
            ChkDR( DRM_E_FILEREADERROR );
        }
    }
    else
    {
        ChkDR( DRM_E_FILENOTFOUND );
    }
    
ErrorExit:    
    if( hfp != OEM_INVALID_HANDLE_VALUE )
    {
        Oem_File_Close( hfp );
    }

    return dr;
}

/*****************************************************************************
** Function:    Oem_Device_GetKey
**
** Synopsis:    Obtains the specified private key.
**
** Arguments:   [f_pOEMContext] : A pointer to the OEM Context; may be NULL
**              [f_eKeyType]    : The type of key to obtain
**              [f_pbKey]       : A pointer to the buffer in which to put the key
**              [f_pcbKey]      : The size of the key buffer (in bytes); may be updated
**
** Returns:     DRM_SUCCESS            - on success
**              DRM_E_BUFFERTOOSMALL   - if the provided buffer is NULL or too small
**              DRM_E_PRIVKEYREADERROR - on any other error
**
** Notes:       None.
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL Oem_Device_GetKey( 
    __in_opt         DRM_VOID              *f_pOEMContext,
    __in      const  DRM_DEVICE_KEY_TYPE    f_eKeyType,
    __out_bcount_opt( *f_pcbKey ) DRM_BYTE *f_pbKey,
    __inout          DRM_DWORD             *f_pcbKey
)
{
    DRM_RESULT   dr          = DRM_SUCCESS;
    DRM_WCHAR   *pwszPath    = NULL; 


    ChkArg( f_pcbKey != NULL );
    
    switch( f_eKeyType )
    {
        case DRM_DKT_WMDRMPD_GROUP:
        {
            ChkArg( *f_pcbKey == SIZEOF( PRIVKEY ) );
            ChkDR( _GetPrivateKey( f_pOEMContext, TRUE, f_pbKey, *f_pcbKey ) );
            break;
        }

        case DRM_DKT_WMDRMPD_FALLBACK:
        {
            ChkArg( *f_pcbKey == SIZEOF( PRIVKEY ) );
            ChkDR( _GetPrivateKey( f_pOEMContext, FALSE, f_pbKey, *f_pcbKey ) );
            break;
        }

        case DRM_DKT_PLAYREADY_MODEL:
        {
            ChkDR( _GetDRMFullPathName( &pwszPath, &g_dstrZGPrivKey, CERTTEMPLATEPATH) );
            ChkDR( _ReadFromFile( f_pOEMContext, f_pbKey, f_pcbKey, pwszPath ) );
            break;
        }

        case DRM_DKT_PLAYREADY_DEVICE_SIGN:
        {
            ChkDR( _GetDRMFullPathName( &pwszPath, &g_dstrZPrivKeySign, CERTPATH) );
            ChkDR( _ReadFromFile( f_pOEMContext, f_pbKey, f_pcbKey, pwszPath ) );
            break;
        }
        
        case DRM_DKT_PLAYREADY_DEVICE_ENCRYPT:
        {
            ChkDR( _GetDRMFullPathName( &pwszPath, &g_dstrZPrivKeyEncrypt, CERTPATH) );
            ChkDR( _ReadFromFile( f_pOEMContext, f_pbKey, f_pcbKey, pwszPath ) );
            break;
        }
        
        case DRM_DKT_PLAYREADY_NDR:
        {
            ChkDR( _GetDRMFullPathName( &pwszPath, &g_dstrNDRPrivKey, CERTPATH) );
            ChkDR( _ReadFromFile( f_pOEMContext, f_pbKey, f_pcbKey, pwszPath ) );
            break;
        }

        case DRM_DKT_PLAYREADY_NDR_MODEL:
        {
            ChkDR( _GetDRMFullPathName( &pwszPath, &g_dstrNDRGPrivKey, CERTTEMPLATEPATH) );
            ChkDR( _ReadFromFile( f_pOEMContext, f_pbKey, f_pcbKey, pwszPath ) );
            break;
        }

        default:
        {
            ChkDR( DRM_E_INVALIDARG );
            break;
        }
    }

 ErrorExit:   
    SAFE_OEM_FREE( pwszPath );
    
    if ( DRM_FAILED ( dr ) && dr != DRM_E_BUFFERTOOSMALL )
    {
        dr = DRM_E_PRIVKEYREADERROR;
    }
    
    return dr;
}

/*****************************************************************************
** Function:    Oem_Device_SetKey
**
** Synopsis:    Saves the specified private key.
**
** Arguments:   [f_pOEMContext] : A pointer to the OEM Context; may be NULL
**              [f_eKeyType]    : The type of key to set
**              [f_pbKey]       : A pointer to a buffer containing the key
**              [f_cbKey]       : The size of the key buffer (in bytes)
**
** Returns:     DRM_SUCCESS      - on success
**              DRM_E_INVALIDARG - if any parameter is invalid
**              or other return code from a function called within
**
** Notes:       None.
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL Oem_Device_SetKey( 
    __in_opt                     DRM_VOID            *f_pOEMContext,
    __in                  const  DRM_DEVICE_KEY_TYPE  f_eKeyType,
    __in_bcount(f_cbKey)         DRM_BYTE            *f_pbKey,
    __in                  const  DRM_DWORD            f_cbKey
)
{
    DRM_RESULT   dr        = DRM_SUCCESS;
    OEM_FILEHDL  hfp       = OEM_INVALID_HANDLE_VALUE;
    DRM_DWORD    cbWritten = 0;
    DRM_WCHAR   *pwszPath  = NULL; 

    ChkArg( f_pbKey != NULL );
    ChkArg( f_cbKey != 0    );
    /*
    ** Currently, it is only valid for a playready and ndr devices to save its private key
    */
    switch( f_eKeyType )
    {
        case DRM_DKT_PLAYREADY_DEVICE_SIGN:
            ChkDR( _GetDRMFullPathName ( &pwszPath, &g_dstrZPrivKeySign, CERTPATH ) );
            break;

        case DRM_DKT_PLAYREADY_DEVICE_ENCRYPT:
            ChkDR( _GetDRMFullPathName ( &pwszPath, &g_dstrZPrivKeyEncrypt, CERTPATH ) );
            break;

        case DRM_DKT_PLAYREADY_NDR:
            ChkDR( _GetDRMFullPathName ( &pwszPath, &g_dstrNDRPrivKey, CERTPATH ) );
            break;
        default:
            ChkDR( DRM_E_INVALIDARG );
    }

    hfp = Oem_File_Open( f_pOEMContext,
                         pwszPath, 
                         OEM_GENERIC_READ    | OEM_GENERIC_WRITE,
                         OEM_FILE_SHARE_READ | OEM_FILE_SHARE_WRITE, 
                         OEM_CREATE_ALWAYS, 
                         OEM_ATTRIBUTE_HIDDEN );
     
    if ( hfp != OEM_INVALID_HANDLE_VALUE )
    {
        if ( !Oem_File_Write( hfp, ( DRM_BYTE * )f_pbKey, f_cbKey, &cbWritten ) ||
             cbWritten != f_cbKey )
        {
            ChkDR( DRM_E_FILEWRITEERROR );
        }
    }
    else
    {
        ChkDR( DRM_E_FILENOTFOUND );
    }

 ErrorExit:   
    if( hfp != OEM_INVALID_HANDLE_VALUE )
    {
        Oem_File_Close( hfp );
    }
    
    SAFE_OEM_FREE( pwszPath );
    return dr;
}

/*****************************************************************************
** Function:    Oem_Device_GetCert
**
** Synopsis:    Obtains the specified device certificate chain.
**              If this function is called with a NULL cert chain buffer pointer, 
**              then the buffer size parm is updated with the required size (in bytes).
**
** Arguments:   [f_pOEMContext] : A pointer to the OEM context; may be NULL
**              [f_eCertType]   : The type of certificate chain to get
**              [f_pbDevCert]   : A pointer to a buffer in which to store the cert chain; may be NULL
**              [f_pcbDevCert]  : A pointer to cert chain buffer size (in bytes); may be updated
**
** Returns:     DRM_SUCCESS                    - on success
**              DRM_E_DEVCERTREADERROR         - if failure to get the device cert chain
**              DRM_E_DEVCERTTEMPLATEREADERROR - if failure to get the device cert template
**              DRM_E_BUFFERTOOSMALL           - if the supplied buffer is NULL or too small
**              DRM_E_INVALIDARG               - if any parameter is invalid
**
** Notes:       None.
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL Oem_Device_GetCert(
    __in_opt        DRM_VOID             *f_pOEMContext,
    __in    const   DRM_DEVICE_CERT_TYPE  f_eCertType,
    __out_bcount_opt( *f_pcbDevCert ) DRM_BYTE *f_pbDevCert,
    __inout         DRM_DWORD            *f_pcbDevCert
)
{
    DRM_RESULT   dr          = DRM_SUCCESS;
    DRM_RESULT   drReadError = DRM_SUCCESS;
    DRM_WCHAR   *pwszPath    = NULL; 


    switch ( f_eCertType )
    {
        case DRM_DCT_WMDRMPD:
        {
            drReadError = DRM_E_DEVCERTREADERROR;
            ChkDR( _GetDRMFullPathName ( &pwszPath, &g_dstrDevcert, CERTPATH ) );
            break;
        }
        
        case DRM_DCT_PLAYREADY:
        {
            drReadError = DRM_E_DEVCERTREADERROR;
            ChkDR( _GetDRMFullPathName ( &pwszPath, &g_dstrZDevcert, CERTPATH ) );
            break;
        }
        
        case DRM_DCT_NETRECEIVER:
        {
            drReadError = DRM_E_DEVCERTREADERROR;
            ChkDR( _GetDRMFullPathName ( &pwszPath, &g_dstrReceiverCert, CERTPATH ) );
            break;
        }
        
        case DRM_DCT_WMDRMPD_TEMPLATE:
        {
            drReadError = DRM_E_DEVCERTTEMPLATEREADERROR;
            ChkDR( _GetDRMFullPathName ( &pwszPath, &g_dstrDevcerttemplate, CERTTEMPLATEPATH ) );
            break;
        }
        
        case DRM_DCT_PLAYREADY_TEMPLATE:
        {
            drReadError = DRM_E_DEVCERTTEMPLATEREADERROR;
            ChkDR( _GetDRMFullPathName ( &pwszPath, &g_dstrZGroupCert, CERTTEMPLATEPATH ) );
            break;
        }

        case DRM_DCT_NETRECEIVER_TEMPLATE:
        {
            drReadError = DRM_E_DEVCERTTEMPLATEREADERROR;
            ChkDR( _GetDRMFullPathName ( &pwszPath, &g_dstrReceiverTemplate, CERTTEMPLATEPATH ) );
            break;
        }

        default:
        {
            ChkDR( DRM_E_INVALIDARG );
            break;
        }
    }

    ChkDR( _ReadFromFile( f_pOEMContext, f_pbDevCert, f_pcbDevCert, pwszPath ) );

ErrorExit:    

    if( DRM_FAILED( dr ) )
    {
        if( dr != DRM_E_BUFFERTOOSMALL && dr != DRM_E_INVALIDARG )
        {
            dr = drReadError;
        }
    }

    SAFE_OEM_FREE( pwszPath );
    return dr;
}

/*****************************************************************************
** Function:    Oem_Device_GetSecureStoreGlobalPasswordSeed
**
** Synopsis:    Retreives the local device global secure store password.
**
** Arguments:   [f_rgbSecStorePassword] -- buffer to hold the secure store global password
**
** Returns:     DRM_SUCCESS on success. On Failure, it returns:
**              DRM_E_INVALIDARG
**
** Notes:       None.
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL Oem_Device_GetSecureStoreGlobalPasswordSeed( 
    __out_bcount(DRM_SHA1_DIGEST_LEN) DRM_BYTE f_rgbSecStorePassword[ __CB_DECL( DRM_SHA1_DIGEST_LEN ) ]
)
{
    DRM_RESULT dr=DRM_SUCCESS;
    
    ChkArg( f_rgbSecStorePassword != NULL );
        
    MEMCPY( f_rgbSecStorePassword, _rgbSecStorePassword, DRM_SHA1_DIGEST_LEN );

ErrorExit:    
    return dr;
}

/*****************************************************************************
** Function:    Oem_Device_SetCert
**
** Synopsis:    Saves the specified device certificate chain.
**
** Arguments:   [f_pOEMContext] : A pointer to the OEM context; may be NULL
**              [f_eCertType]   : The type of certificate chain to save
**              [f_pbDevCert]   : A pointer to a buffer containing the cert chain
**              [f_cbDevCert]   : The cert chain buffer size (in bytes)
**
** Returns:     DRM_SUCCESS          - on success
**              DRM_E_INVALIDARG     - if any parameter is invalid
**              DRM_E_FILEWRITEERROR - if failure to save the dev cert chain
**              DRM_E_FILENOTFOUND   - if the file cannot be found
**
** Notes:       None.
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL Oem_Device_SetCert(
    __in_opt                        DRM_VOID             *f_pOEMContext,
    __in                     const  DRM_DEVICE_CERT_TYPE  f_eCertType,
    __in_bcount(f_cbDevCert)        DRM_BYTE             *f_pbDevCert,
    __in                     const  DRM_DWORD             f_cbDevCert )
{
    DRM_RESULT   dr        = DRM_SUCCESS;
    OEM_FILEHDL  hfp       = OEM_INVALID_HANDLE_VALUE;
    DRM_WCHAR   *pwszPath  = NULL; 
    DRM_DWORD    cbWritten = 0;

    ChkArg( f_pbDevCert != NULL );
    ChkArg( f_cbDevCert != 0    );
    
    switch( f_eCertType )
    {
        case DRM_DCT_WMDRMPD:
        {
            ChkDR( _GetDRMFullPathName ( &pwszPath, &g_dstrDevcert, CERTPATH ) );
            break;
        }

        case DRM_DCT_PLAYREADY:
        {
            ChkDR( _GetDRMFullPathName ( &pwszPath, &g_dstrZDevcert, CERTPATH ) );
            break;
        }

        case DRM_DCT_NETRECEIVER:
        {
            ChkDR( _GetDRMFullPathName ( &pwszPath, &g_dstrReceiverCert, CERTPATH ) );
            break;
        }

        default:
        {
            ChkDR( DRM_E_INVALIDARG );
            break;
        }
    }

    hfp = Oem_File_Open( f_pOEMContext,
                         pwszPath, 
                         OEM_GENERIC_READ    | OEM_GENERIC_WRITE,
                         OEM_FILE_SHARE_READ | OEM_FILE_SHARE_WRITE, 
                         OEM_CREATE_ALWAYS, 
                         OEM_ATTRIBUTE_HIDDEN );

    if ( hfp != OEM_INVALID_HANDLE_VALUE )
    {
        if ( !Oem_File_Write( hfp, ( DRM_BYTE * )f_pbDevCert, f_cbDevCert, &cbWritten ) ||
            cbWritten != f_cbDevCert )
        {
            ChkDR( DRM_E_FILEWRITEERROR );
        }
    }
    else
    {
        ChkDR( DRM_E_FILENOTFOUND );
    }
    
ErrorExit:
    if( hfp != OEM_INVALID_HANDLE_VALUE )
    {
        Oem_File_Close( hfp );
    }
    
    SAFE_OEM_FREE( pwszPath );

    return dr;
}

/*****************************************************************************
** Function:    Oem_Device_GetUniqueId
**
** Synopsis:    Obtains a unique identifier for the device.
**
** Arguments:   [f_pOEMContext] : A pointer to the OEM context; may be NULL
**              [f_eIDType]     : The type of ID to obtain
**              [f_pbUniqueId]  : A pointer to the buffer to receive the unique ID
**              [f_pcbLength]   : The length of the obtained unique ID (in bytes)
**
** Returns:     DRM_SUCCESS          - on success
**              DRM_E_INVALIDARG     - if the length pointer is NULL
**              DRM_E_BUFFERTOOSMALL - if the buffer is NULL or too small
**              or other return code from a function called within
**
** Notes:       None.
**
******************************************************************************/
DRM_API DRM_RESULT DRM_CALL Oem_Device_GetUniqueId( 
    __in_opt                             DRM_VOID            *f_pOEMContext,
    __in                           const DRM_DEVICE_ID_TYPE   f_eIDType,
    __out_bcount_opt(*f_pcbLength)       DRM_BYTE            *f_pbUniqueId, 
    __inout                              DRM_DWORD           *f_pcbLength )
{    
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE shaOut [ __CB_DECL( DRM_SHA1_DIGEST_LEN ) ] = {0};

    ChkArg( f_pcbLength != NULL );

    switch ( f_eIDType )
    {
        case DRM_DIT_WMDRMPD_ID:
        {
            DRM_DWORD  dwSize = CCH_BASE64_EQUIV( DRM_SHA1_DIGEST_LEN ) * SIZEOF( DRM_WCHAR );
    
            if ( f_pbUniqueId == NULL || *f_pcbLength < dwSize )
            {
                *f_pcbLength = dwSize;
                ChkDR( DRM_E_BUFFERTOOSMALL );
            }
            
            _GetHWID( shaOut );
            
            dwSize = *f_pcbLength / SIZEOF( DRM_WCHAR );
            ChkDR( DRM_B64_EncodeW( shaOut, DRM_SHA1_DIGEST_LEN, (DRM_WCHAR *)f_pbUniqueId, &dwSize, 0 ) );
            
            *f_pcbLength = dwSize * SIZEOF( DRM_WCHAR );
            break;
        }

        case DRM_DIT_PLAYREADY_ID:
        {
            if ( ( f_pbUniqueId == NULL ) || ( *f_pcbLength < DRM_ID_SIZE ) )
            {
                *f_pcbLength = DRM_ID_SIZE;
                ChkDR( DRM_E_BUFFERTOOSMALL );
            }
            
            _GetHWID( shaOut );

            MEMCPY( f_pbUniqueId, shaOut, DRM_ID_SIZE );
            
            *f_pcbLength = DRM_ID_SIZE;
            break;
        }

        default:
        {
            ChkDR( DRM_E_INVALIDARG );
            break;
        }
    }
        
ErrorExit:    
    return dr;
}


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\lib\stdafx.h ===
#pragma once
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\lib\oemprofile.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <windows.h>
#include <drmcommon.h>
#include <drmprofile.h>

ENTER_PK_NAMESPACE_CODE;

#if DRM_SUPPORT_PROFILING

DRM_API DRM_UINT64 DRM_CALL Oem_Profiling_QueryPerformanceCounter( DRM_VOID )
{
    DRM_UINT64 ui64Count = DRM_UI64( 0 );

    QueryPerformanceCounter( (LARGE_INTEGER*)&ui64Count );
    
    return  ui64Count;
}

DRM_API DRM_UINT64 DRM_CALL Oem_Profiling_QueryPerformanceFrequency( DRM_VOID )
{
    DRM_UINT64 ui64Frequency = DRM_UI64( 0 );
    
    QueryPerformanceFrequency( ( LARGE_INTEGER *) &ui64Frequency );

    return ui64Frequency;
}

#endif

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\lib\oemprofile_common.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <oemprofile.h>

ENTER_PK_NAMESPACE_CODE;

#if DRM_SUPPORT_PROFILING

/* Default global context: check detail level, do not check feature set 
/* Future enhancement: read default values of flags from a global configuration file */
/* so the flags can be set at runtime. */
static PERF_GLOBAL_CONTEXT g_PerfContext = {
    /* Scope stack */
    {0}, 
    
    /* Point to top of the scope stack */
    1,
    
    /* Logging detail level*/
    3,
    
    /* Logging feature set mask */
    0,
    
    /* Next PER_AGG_SCOPE_CONTEXT slot number to be assigned */
    0,
    
    /* File handle for normal scope samples */
    OEM_INVALID_HANDLE_VALUE,
    
    /* File handle for aggregated scope samples */
    OEM_INVALID_HANDLE_VALUE,
    
    /* Buffer to cache normal scope samples to minimize I/O */
    {0},
    
    /* Next cache buffer (sample) slot to be assigned */
    0,
    
    /* Global aggregated scope context */
    {0},
    
    /* Flag indicating whether the profiling machanism is enable or not */
    FALSE,
    
    /* Flag to prevent recursive profiling */
    FALSE,

    /*Setting the time spent in writing profiling logs to 0 initially*/
    0

#if PROFILE_USER_DATA
    , 
    
    /* File handle for user data logging */
    OEM_INVALID_HANDLE_VALUE,
    
    /* Buffer to cache user data to minimize I/O */
    {0},
    
    /* Next cache buffer (user data) slot to be assigned */
     0
#endif

#if PROFILE_STACK_SIZE
    ,

    /*File handle for logging stack utilization data*/
    OEM_INVALID_HANDLE_VALUE,

    /*Max stack size*/
    0,

    /*Stack Base*/
    0,

    /*Scope ID of the PK API leading to max stack usage*/
    0,

    /*Max stack usage over all the PK APIs involved in a specific scenario*/
    0
#endif

};

/**********************************************************************
** Function:    Oem_Profiling_GetProfileContext
** Synopsis:    Returns pointer to global profiling object. 
** Arguments:   None 
** Returns:     pointer to global profiling object. 
**              This function should always return pointer to valid object.
** Notes:       Common for most OEM platforms.
**              Requires special implementation on Symbian since 
**              global variables are not available.
*******************************************************************/
DRM_API PERF_GLOBAL_CONTEXT * DRM_CALL Oem_Profiling_GetProfileContext(DRM_VOID)
{ 
    return &g_PerfContext;
}

#endif  /* DRM_SUPPORT_PROFILING */

EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\lib\stdafx.cpp ===
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\lib\oemrsa.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <bignum.h>
#include <oemrsaimpl.h>
#include <oemrsa.h>

/*
**  To ensure that no name mangling occurs this function declarations are wrapped 
**  into PK namespace block
*/
ENTER_PK_NAMESPACE;

DRM_API DRM_RESULT DRM_CALL _BigEndianBytesToDigits(   
    __in_ecount( BITS_TO_BYTES( f_cBitsData ) ) const DRM_BYTE  *f_pbData,    
    __in const                                        DRM_DWORD  f_cBitsData,
    __out_ecount( BITS_TO_DIGITS( f_cBitsData ) )     digit_t   *f_pDigits
    );

DRM_API DRM_RESULT DRM_CALL _DigitsToBigEndianBytes(
    __in_ecount( BITS_TO_DIGITS( f_cBitsData ) ) const digit_t   *f_pDigits,
    __in                                               DRM_DWORD  f_cBitsData,
    __out_ecount( BITS_TO_BYTES( f_cBitsData ) )       DRM_BYTE  *f_pbData 
    );

EXIT_PK_NAMESPACE;

ENTER_PK_NAMESPACE_CODE;

DRM_EXPORT_VAR const DRM_BYTE rgbDRM_RSA_DEFAULT_PUBEXP[__CB_DECL( DRM_RSA_CB_PUBEXP )] =
{
    TWO_BYTES( 0x00, 0x01 ), TWO_BYTES( 0x00, 0x01 ) /* 65537 */
};
        
/**********************************************************************
**
** Function:    _BigEndianBytesToDigits
**
** Synopsis:    Copy a big-endian DRM_BYTE array to a digit_t array.
**
** Arguments:   
**      [f_pbData]   : Input array of DRM_BYTEs
**      [f_cBitsData]: Length of array in BITs
**      [f_pDigits]  : Output array of digit_ts
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the pointer args was NULL or f_cBitsData was less
**          than or equal to zero.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL _BigEndianBytesToDigits(   
    __in_ecount( BITS_TO_BYTES( f_cBitsData ) ) const DRM_BYTE  *f_pbData,    
    __in const                                        DRM_DWORD  f_cBitsData,
    __out_ecount( BITS_TO_DIGITS( f_cBitsData ) )     digit_t   *f_pDigits
    )
{
    DRM_RESULT      dr          = DRM_SUCCESS; 
    DRM_DWORD       iDigits     = 0;
    DRM_DWORD       iBytes      = 0;
    DRM_DWORD       cbRemaining = 0;
    const DRM_DWORD cDigits     = BITS_TO_DIGITS( f_cBitsData );
 
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_RSA, PERF_FUNC__BigEndianBytesToDigits );

    ChkArg( f_pbData    != NULL );
    ChkArg( f_cBitsData >  0 );
    ChkArg( f_pDigits   != NULL );

    ZEROMEM( f_pDigits, cDigits * SIZEOF( digit_t ) );

    for( iDigits = 0; iDigits < cDigits; iDigits++ )
    {
        cbRemaining = ( f_cBitsData + BITS_PER_STANDARD_BYTE - 1 ) / BITS_PER_STANDARD_BYTE 
                    - RADIX_BYTES * iDigits;
        f_pDigits[iDigits] = 0;
        
        for( iBytes = 0; iBytes < MIN( RADIX_BYTES, cbRemaining ); iBytes++ )
        {
            f_pDigits[iDigits] ^= ( digit_t )GET_BYTE( f_pbData, ( cbRemaining - 1 ) - iBytes )
                               << ( 8 * iBytes );
        }
    } 

    /*
    ** Strip high bits 
    */
    f_pDigits[cDigits - 1] &= RADIXM1 >> ( RADIX_BITS * cDigits - f_cBitsData );

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
} 

/**********************************************************************
**
** Function:    _DigitsToBigEndianBytes
**
** Synopsis:    Convert a digit_t array to big-endian bytes
**
** Arguments:
**      [f_pDigits]    : Input array of digit_ts
**      [f_cBitsData]  : Length of data in bits
**      [f_pbData]     : Output array of BYTEs
**
** Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the pointer args was NULL or f_cBitsData was less
**          than or equal to zero.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL _DigitsToBigEndianBytes(
    __in_ecount( BITS_TO_DIGITS( f_cBitsData ) ) const digit_t   *f_pDigits,
    __in                                               DRM_DWORD  f_cBitsData,
    __out_ecount( BITS_TO_BYTES( f_cBitsData ) )       DRM_BYTE  *f_pbData 
    )
{
    DRM_RESULT      dr          = DRM_SUCCESS; 
    DRM_DWORD       iDigits     = 0;
    DRM_DWORD       iBytes      = 0;
    DRM_DWORD       cbRemaining = 0;
    digit_t         digCurrent  = 0;

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_RSA, PERF_FUNC__DigitsToBigEndianBytes );

    ChkArg( f_pDigits   != NULL );
    ChkArg( f_cBitsData >  0 );
    ChkArg( f_pbData    != NULL );

    for ( iDigits = 0; iDigits < BITS_TO_DIGITS( f_cBitsData ); iDigits++ )
    {
        cbRemaining = ( f_cBitsData + BITS_PER_STANDARD_BYTE - 1 ) / BITS_PER_STANDARD_BYTE 
                    - RADIX_BYTES * iDigits;
        digCurrent = f_pDigits[iDigits];
        for ( iBytes = 0; iBytes != MIN( cbRemaining, RADIX_BYTES ); iBytes++ )
        {
            //
            // Xbox LIVE specific: disabling conversion warning (C4296) after review.
            //
            #pragma warning( disable:4296 )
            AssertChkArg( ( cbRemaining - 1 ) - iBytes >= 0 &&
                          ( cbRemaining - 1 ) - iBytes < BITS_TO_BYTES( f_cBitsData ) );
            #pragma warning( default:4296 )
            //
            // End Xbox LIVE specific
            //

            PUT_BYTE( f_pbData, 
                     ( cbRemaining - 1 ) - iBytes, 
                     ( DRM_BYTE )( digCurrent & 0xFF ) );
            digCurrent >>= 8;
        }
    } 

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
} 


/**********************************************************************
**
**  Function: _ModularExponentiate
**
**  Synopsis: Does modular exponentiation on the input buffer
**            rgbDataOut = rgbDataIn^pbExp MOD rgbModulus
**
**  Arguments:
**     [f_eKeyLength] : Specifies the key length
**     [f_rgbDataIn]  : Specifies the data to exponentiate
**     [f_pbExp]      : Specifies the exponent
**     [f_cbExp]      : Specifies the length of the exponent
**     [f_rgbModulus] : Specifies the modulus
**     [f_rgbDataOut] : Returns the processed data
**     [f_pCryptoCtx] : Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pPublicKey was NULL 
**      DRM_E_OEM_RSA_MESSAGE_TOO_BIG
**          The message data is too long to sign with the given modulus
**      DRM_E_MODULAR_ARITHMETIC_FAILURE
*           A failure occurred in the modular arithmetic
**
**********************************************************************/
static DRM_RESULT DRM_CALL _ModularExponentiate(
    __in const                       DRM_RSA_SUPPORTED_KEY_LENGTHS  f_eKeyLength,
    __in const                       DRM_DWORD                      f_cbDataIn,
    __in_ecount( f_cbDataIn ) const  DRM_BYTE                      *f_pbDataIn,
    __in const                       DRM_DWORD                      f_cdExp,
    __in_ecount( f_cdExp ) const     digit_t                       *f_pdExp,
    __in const                       DRM_DWORD                      f_cdModulus,
    __in_ecount( f_cdModulus ) const digit_t                       *f_pdModulus,
    __out_ecount( f_cbDataIn )       DRM_BYTE                      *f_pbDataOut,
    __inout                          DRM_CRYPTO_CONTEXT            *f_pCryptoCtx 
    )
{
    DRM_RESULT      dr                           = DRM_SUCCESS;
    digit_t         rgdTemp[CDIGITS_MODULUS_MAX] = { 0 };
    mp_modulus_t    modulus_data                 = { 0 };
    DRM_BOOL        fModulusCreated              = FALSE;    

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_RSA, PERF_FUNC__ModularExponentiate );

    ChkArg( IS_VALID_DRM_RSA_KEY_LENGTH( f_eKeyLength ) );
    ChkArg( DRM_RSA_CB_MODULUS( (DRM_DWORD)f_eKeyLength ) == f_cbDataIn );
    ChkArg( NULL != f_pbDataIn );
    ChkArg( 0 < f_cdExp );
    ChkArg( CDIGITS_PUBEXP >= f_cdExp );
    ChkArg( NULL != f_pdExp );
    ChkArg( 0 < f_cdModulus );
    ChkArg( CDIGITS_MODULUS( (DRM_DWORD)f_eKeyLength ) >= f_cdModulus );
    ChkArg( NULL != f_pdModulus );
    ChkArg( NULL != f_pbDataOut );
    ChkArg( NULL != f_pCryptoCtx );
    
    DRM_ECC_PKInit( (struct bigctx_t *)f_pCryptoCtx->rgbCryptoContext, NULL );

    /*
    ** Convert message to digits
    */
    ChkDR( _BigEndianBytesToDigits( f_pbDataIn, DRM_RSA_CBITS_MODULUS( f_eKeyLength ), rgdTemp ) );
    
    /*
    ** Make sure the base is less than the modulus    
    */ 
    ChkBOOL( compare_same( f_pdModulus, rgdTemp, CDIGITS_MODULUS( f_eKeyLength ) ) > 0,
             DRM_E_OEM_RSA_MESSAGE_TOO_BIG );   
             
    /*
    ** Create modulus-specific structures
    */
    ChkBOOL( create_modulus( f_pdModulus, 
                             f_cdModulus, 
                             FROM_RIGHT, 
                            &modulus_data, 
                             (struct bigctx_t *)f_pCryptoCtx->rgbCryptoContext, 
                             (struct bigctx_t *)f_pCryptoCtx->rgbCryptoContext ), DRM_E_MODULAR_ARITHMETIC_FAILURE );
    fModulusCreated = TRUE;          
    
    /*
    ** Convert message to modular representation
    */      
    ChkBOOL( to_modular( rgdTemp, CDIGITS_MODULUS( f_eKeyLength ), rgdTemp, &modulus_data, NULL ), 
             DRM_E_MODULAR_ARITHMETIC_FAILURE );                 
    
    /*
    ** Do the modular exponentiation
    */
    ChkBOOL( mod_exp( rgdTemp, 
                      f_pdExp, 
                      f_cdExp, 
                      rgdTemp, 
                      &modulus_data, 
                      (struct bigctx_t *)f_pCryptoCtx->rgbCryptoContext ), DRM_E_MODULAR_ARITHMETIC_FAILURE ); 
   
    /*
    ** Convert message from modular representation    
    */
    ChkBOOL( from_modular( rgdTemp, rgdTemp, &modulus_data ), 
             DRM_E_MODULAR_ARITHMETIC_FAILURE );                 

    /*
    ** Convert back from digits
    */
    ChkDR( _DigitsToBigEndianBytes( rgdTemp, DRM_RSA_CBITS_MODULUS( f_eKeyLength ), f_pbDataOut ) );
             
ErrorExit:
    if( fModulusCreated )
    {
        uncreate_modulus( &modulus_data, (struct bigctx_t *)f_pCryptoCtx->rgbCryptoContext );
    }

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}    

/**********************************************************************
**
**  Function: OEM_RSA_GetPublicKeyLength
**
**  Synopsis: Get the length of the public key in bits.
**
**  Arguments:
**     [f_pPublicKey]   : Specifies the public key
**     [f_peKeyLength]  : Returns the public key length in bits
**
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pPublicKey was NULL 
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL OEM_RSA_GetPublicKeyLength(
    __in const DRM_RSA_PUBLIC_KEY            *f_pPublicKey,
    __out      DRM_RSA_SUPPORTED_KEY_LENGTHS *f_peKeyLength
    )
{
    DRM_RESULT dr = DRM_SUCCESS;
    INTERNAL_DRM_RSA_PUBLIC_KEY *pPubKeyInternal = ( INTERNAL_DRM_RSA_PUBLIC_KEY * )f_pPublicKey;

    ChkArg( NULL != f_pPublicKey );
    ChkArg( NULL != f_peKeyLength );

    *f_peKeyLength = pPubKeyInternal->eKeyLength;
    ChkArg( IS_VALID_DRM_RSA_KEY_LENGTH( *f_peKeyLength ) );

ErrorExit:
    return dr;
}

/**********************************************************************
**
**  Function: OEM_RSA_GetPrivateKeyLength
**
**  Synopsis: Get the length of the private key in bits.
**
**  Arguments:
**     [f_pPrivateKey]  : Specifies the private key
**     [f_peKeyLength]  : Returns the private key length in bits
**
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pPublicKey was NULL 
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL OEM_RSA_GetPrivateKeyLength(
    __in const DRM_RSA_PRIVATE_KEY           *f_pPrivateKey,
    __out      DRM_RSA_SUPPORTED_KEY_LENGTHS *f_peKeyLength 
    )
{
    DRM_RESULT dr = DRM_SUCCESS;
    INTERNAL_DRM_RSA_PRIVATE_KEY *pPvKeyInternal = ( INTERNAL_DRM_RSA_PRIVATE_KEY * )f_pPrivateKey;

    ChkArg( NULL != f_pPrivateKey );
    ChkArg( NULL != f_peKeyLength );

    *f_peKeyLength = pPvKeyInternal->eKeyLength;
    ChkArg( IS_VALID_DRM_RSA_KEY_LENGTH( *f_peKeyLength ) );

ErrorExit:
    return dr;
}

/**********************************************************************
**
**  Function: OEM_RSA_GetKeyLengthFromModulusLength
**
**  Synopsis: Get the length of the public key in bits.
**
**  Arguments:
**     [f_cbModulus]    : Specifies the modulus length of the key
**     [f_peKeyLength]  : Returns the public key length in bits
**
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_cbModulus was an invalid value
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL OEM_RSA_GetKeyLengthFromModulusLength(
    __in const DRM_DWORD                      f_cbModulus,
    __out      DRM_RSA_SUPPORTED_KEY_LENGTHS *f_peKeyLength 
    )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( NULL != f_peKeyLength );

    if ( DRM_RSA_CB_MODULUS( eDRM_RSA_1024 ) == f_cbModulus )
    {
        *f_peKeyLength = eDRM_RSA_1024;
    }
    else if ( DRM_RSA_CB_MODULUS( eDRM_RSA_2048 ) == f_cbModulus )
    {
        *f_peKeyLength = eDRM_RSA_2048;
    }
    else
    {
        DRMASSERT( !"invalid modulus length" );
        dr = DRM_E_INVALIDARG;
    }

ErrorExit:
    return dr;    
}


/**********************************************************************
**
**  Function: OEM_RSA_SetPublicKey
**
**  Synopsis: Sets up an internal form of an RSA public key
**
**  Arguments:
**     [f_rgbPubExp]    : Specifies the public exponent
**     [f_rgbModulus]   : Specifies the public key modulus
**     [f_pPublicKey]   : Returns the public key in external format
**
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pPublicKey was NULL 
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL OEM_RSA_SetPublicKey(
    __in const                       DRM_RSA_SUPPORTED_KEY_LENGTHS  f_eKeyLength,
    __in const                       DRM_DWORD                      f_cbPubExp,
    __in_ecount( f_cbPubExp ) const  DRM_BYTE                      *f_pbPubExp,
    __in const                       DRM_DWORD                      f_cbModulus,
    __in_ecount( f_cbModulus ) const DRM_BYTE                      *f_pbModulus,
    __out                            DRM_RSA_PUBLIC_KEY            *f_pPublicKey 
    )
{
    DRM_RESULT dr = DRM_SUCCESS;
    INTERNAL_DRM_RSA_PUBLIC_KEY *pPubKeyInternal = ( INTERNAL_DRM_RSA_PUBLIC_KEY * )f_pPublicKey;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_RSA, PERF_FUNC_OEM_RSA_SetPublicKey );

    ChkArg( IS_VALID_DRM_RSA_KEY_LENGTH( f_eKeyLength ) );
    ChkArg( DRM_RSA_CB_PUBEXP == f_cbPubExp );
    ChkArg( NULL != f_pbPubExp );
    ChkArg( DRM_RSA_CB_MODULUS( (DRM_DWORD)f_eKeyLength ) == f_cbModulus );
    ChkArg( NULL != f_pbModulus );
    ChkArg( NULL != f_pPublicKey );

    pPubKeyInternal->eKeyLength = f_eKeyLength;
    
    ChkDR( _BigEndianBytesToDigits( f_pbModulus, 
                                    DRM_RSA_CBITS_MODULUS( f_eKeyLength ), 
                                    pPubKeyInternal->rgdModulus ) );
    
    pPubKeyInternal->cdModulus = significant_digit_count( pPubKeyInternal->rgdModulus,
                                                          CDIGITS_MODULUS( f_eKeyLength ) );                                
    
    ChkDR( _BigEndianBytesToDigits( f_pbPubExp, 
                                    CBITS_PUBEXP, 
                                    pPubKeyInternal->rgdPubExp ) );
                                    
ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/**********************************************************************
**
**  Function: OEM_RSA_SetPrivateKey
**
**  Synopsis: Sets up an internal form of an RSA private key
**
**  Arguments:
**     [f_rgbPrivExp]  : Specifies the private exponent
**     [f_rgbPrimes]   : Specifies the primes
**     [f_pPrivateKey] : Returns the private key in external format
**     [f_pCryptoCtx] : Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pPrivateKey was NULL or an argument was out of range
**      DRM_E_MODULAR_ARITHMETIC_FAILURE
**           A failure occurred in the modular arithmetic
**
**  Note:    Size of the primes is the same as f_eKeyLength (not f_eKeyLength/2). 
**           Primes uses lowest half part of the buffer.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL OEM_RSA_SetPrivateKey(
    __in const                       DRM_RSA_SUPPORTED_KEY_LENGTHS  f_eKeyLength,
    __in const                       DRM_DWORD                      f_cbPrivExp,
    __in_ecount( f_cbPrivExp ) const DRM_BYTE                      *f_pbPrivExp,
    __in const                       DRM_DWORD                      f_cbPrimes,
    __in_ecount( f_cbPrimes ) const  DRM_BYTE                      *f_pbPrime0,
    __in_ecount( f_cbPrimes ) const  DRM_BYTE                      *f_pbPrime1,
    __out                            DRM_RSA_PRIVATE_KEY           *f_pPrivateKey,
    __inout                          DRM_CRYPTO_CONTEXT            *f_pCryptoCtx
    )
{
    DRM_RESULT dr      = DRM_SUCCESS;
    INTERNAL_DRM_RSA_PRIVATE_KEY *pPvKeyInternal = ( INTERNAL_DRM_RSA_PRIVATE_KEY * )f_pPrivateKey;
    digit_t    rgdTemp1[CDIGITS_MODULUS_MAX]     = { 0 };
    digit_t    rgdTemp2[CDIGITS_MODULUS_MAX]     = { 0 };
    digit_t    rgdTemp3[CDIGITS_MODULUS_MAX]     = { 0 };
    digit_t   *pdTemp1 = rgdTemp1;
    digit_t   *pdTemp2 = rgdTemp2;      

    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_RSA, PERF_FUNC_OEM_RSA_SetPrivateKey );

    ChkArg( IS_VALID_DRM_RSA_KEY_LENGTH( f_eKeyLength ) );
    ChkArg( DRM_RSA_CB_PRIVEXP( (DRM_DWORD)f_eKeyLength ) == f_cbPrivExp );
    ChkArg( NULL != f_pbPrivExp );
    ChkArg( DRM_RSA_CB_PRIME( (DRM_DWORD)f_eKeyLength ) == f_cbPrimes );
    ChkArg( NULL != f_pbPrime0 );
    ChkArg( NULL != f_pbPrime1 );
    ChkArg( NULL != f_pPrivateKey );
    ChkArg( NULL != f_pCryptoCtx );

    pPvKeyInternal->eKeyLength = f_eKeyLength;
        
    DRM_ECC_PKInit( (struct bigctx_t *)f_pCryptoCtx->rgbCryptoContext, NULL );

    ChkDR( _BigEndianBytesToDigits( f_pbPrime0, DRM_RSA_CBITS_MODULUS( f_eKeyLength ), rgdTemp1 ) );
    ChkDR( _BigEndianBytesToDigits( f_pbPrime1, DRM_RSA_CBITS_MODULUS( f_eKeyLength ), rgdTemp2 ) );
           
    /*
    ** Determine the larger prime (p) and copy both primes (p and q)
    */
    if ( compare_same( rgdTemp1, rgdTemp2, CDIGITS_MODULUS( f_eKeyLength ) ) < 0 )
    {      
        pdTemp1 = rgdTemp2;
        pdTemp2 = rgdTemp1;
    }
    MEMCPY( pPvKeyInternal->rgdPrimes[0], pdTemp1, DRM_RSA_CB_PRIME( f_eKeyLength ) );
    MEMCPY( pPvKeyInternal->rgdPrimes[1], pdTemp2, DRM_RSA_CB_PRIME( f_eKeyLength ) );
    pPvKeyInternal->cdPrimes[0] = significant_digit_count( pdTemp1, CDIGITS_MODULUS( f_eKeyLength ) ); 
    pPvKeyInternal->cdPrimes[1] = significant_digit_count( pdTemp2, CDIGITS_MODULUS( f_eKeyLength ) );

    ChkArg( pPvKeyInternal->cdPrimes[0] <= CDIGITS_MODULUS_MAX &&
            pPvKeyInternal->cdPrimes[1] <= CDIGITS_MODULUS_MAX );

    /*
    ** Compute CRT Exponents: d mod ( prime - 1 )
    */    
    ChkBOOL( sub_immediate( pdTemp1, 1, pdTemp1, pPvKeyInternal->cdPrimes[0] ) == 0,
             DRM_E_MODULAR_ARITHMETIC_FAILURE );   
    ChkBOOL( sub_immediate( pdTemp2, 1, pdTemp2, pPvKeyInternal->cdPrimes[0] ) == 0,
             DRM_E_MODULAR_ARITHMETIC_FAILURE );          
    ChkDR( _BigEndianBytesToDigits( f_pbPrivExp, CBITS_PRIVEXP( f_eKeyLength ), pPvKeyInternal->rgdIQMP ) );    
    ChkBOOL( divide( pPvKeyInternal->rgdIQMP, 
                     CDIGITS_PRIVEXP( f_eKeyLength ), 
                     pdTemp1,
                     pPvKeyInternal->cdPrimes[0],
                     NULL,     
                     rgdTemp3,
                     pPvKeyInternal->rgdCRTExponents[0] ), DRM_E_MODULAR_ARITHMETIC_FAILURE );       
    ChkBOOL( divide( pPvKeyInternal->rgdIQMP, 
                     CDIGITS_PRIVEXP( f_eKeyLength ), 
                     pdTemp2,
                     pPvKeyInternal->cdPrimes[1],
                     NULL,     
                     rgdTemp3,
                     pPvKeyInternal->rgdCRTExponents[1] ), DRM_E_MODULAR_ARITHMETIC_FAILURE );                     
                         
    /*
    ** Compute iqmp: modular inverse of q (smaller prime) modulo p (larger prime)
    */                   
    ChkBOOL( mp_invert( pPvKeyInternal->rgdPrimes[1], 
                        pPvKeyInternal->rgdPrimes[0], 
                        pPvKeyInternal->cdPrimes[0], 
                        pPvKeyInternal->rgdIQMP, 
                        NULL, 
                        NULL, 
                        (struct bigctx_t *)f_pCryptoCtx->rgbCryptoContext ), DRM_E_MODULAR_ARITHMETIC_FAILURE );                                                                  
                                    
ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}   


/**********************************************************************
**
**  Function: OEM_RSA_ParsePublicKey
**
**  Synopsis: Parses the elements from an internal form of an RSA public key
**
**  Arguments:
**     [f_pPublicKey]   : Specifies the public key in external format
**     [f_rgbPubExp]    : Returns the public exponent
**     [f_rgbModulus]   : Returns the public key modulus
**
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pPublicKey was NULL 
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL OEM_RSA_ParsePublicKey(
    __in const                        DRM_RSA_PUBLIC_KEY            *f_pPublicKey,
    __out_opt                         DRM_RSA_SUPPORTED_KEY_LENGTHS *f_peKeyLength,
    __inout_opt                       DRM_DWORD                     *f_pcbPubExp,
    __out_ecount_opt( *f_pcbPubExp )  DRM_BYTE                      *f_pbPubExp,
    __inout_opt                       DRM_DWORD                     *f_pcbModulus,
    __out_ecount_opt( *f_pcbModulus ) DRM_BYTE                      *f_pbModulus
    )
{
    DRM_RESULT dr = DRM_SUCCESS;
    INTERNAL_DRM_RSA_PUBLIC_KEY *pPubKeyInternal = ( INTERNAL_DRM_RSA_PUBLIC_KEY * )f_pPublicKey;
    DRM_DWORD cbPubExp = 0;
    DRM_DWORD cbModulus = 0;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_RSA, PERF_FUNC_OEM_RSA_ParsePublicKey );

    ChkArg( NULL != f_pPublicKey );

    if ( NULL != f_peKeyLength )
    {
        *f_peKeyLength = pPubKeyInternal->eKeyLength;
    }

    if ( NULL != f_pcbPubExp )
    {
        cbPubExp = *f_pcbPubExp;
        *f_pcbPubExp = DRM_RSA_CB_PUBEXP;
        if ( cbPubExp < *f_pcbPubExp )
        {
            ChkDR( DRM_E_BUFFERTOOSMALL );
        }
        if ( NULL != f_pbPubExp )
        {
            ChkDR( _DigitsToBigEndianBytes( pPubKeyInternal->rgdPubExp,
                                            CBITS_PUBEXP,
                                            f_pbPubExp ) );
        }
    }
                                    
    if ( NULL != f_pcbModulus )
    {
        cbModulus = *f_pcbModulus;
        *f_pcbModulus = DRM_RSA_CB_MODULUS( pPubKeyInternal->eKeyLength );
        if ( cbModulus < *f_pcbModulus )
        {
            ChkDR( DRM_E_BUFFERTOOSMALL );
        }
        if ( NULL != f_pbModulus )
        {
            ChkDR( _DigitsToBigEndianBytes( pPubKeyInternal->rgdModulus,
                                            DRM_RSA_CBITS_MODULUS( pPubKeyInternal->eKeyLength ),
                                            f_pbModulus ) );
        }
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}

/**********************************************************************
**
**  Function: OEM_RSA_ParsePrivateKey
**
**  Synopsis: Parses the elements from an internal form of an RSA private key
**
**  Arguments:
**     [f_pPrivateKey]  : Specifies the public key in external format
**     [f_peKeyLength]  : Returns the key length
**     [f_pcbPrivExp]   : Supplies size of the private key exponent buffer
**                        Returns actial size of the private key exponent
**     [f_pbPrivExp]    : Returns the private exponent
**     [f_pcbPrimes]    : Supplies size of the private key buffer
**                        Returns actual size of the private key primes
**     [f_pbPrime0]     : Returns the private key prime0
**     [f_pbPrime1]     : Returns the private key prime1
**
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          f_pPublicKey was NULL 
**
**********************************************************************/
DRM_RESULT DRM_CALL OEM_RSA_ParsePrivateKey(
    __in const                        DRM_RSA_PRIVATE_KEY           *f_pPrivateKey,
    __out_opt                         DRM_RSA_SUPPORTED_KEY_LENGTHS *f_peKeyLength,
    __inout_opt                       DRM_DWORD                     *f_pcbPrivExp,
    __out_ecount_opt( *f_pcbPrivExp ) DRM_BYTE                      *f_pbPrivExp,
    __inout_opt                       DRM_DWORD                     *f_pcbPrimes,
    __out_ecount_opt( *f_pcbPrimes )  DRM_BYTE                      *f_pbPrime0,
    __out_ecount_opt( *f_pcbPrimes )  DRM_BYTE                      *f_pbPrime1 
    )
{
    DRM_RESULT dr = DRM_SUCCESS;
    INTERNAL_DRM_RSA_PRIVATE_KEY *pPvKeyInternal = ( INTERNAL_DRM_RSA_PRIVATE_KEY * )f_pPrivateKey;    
    DRM_DWORD cbPrivExp = 0;
    DRM_DWORD cbPrimes  = 0;
        

    if ( NULL != f_peKeyLength )
    {
        *f_peKeyLength = pPvKeyInternal->eKeyLength;
    }

    if ( NULL != f_pcbPrivExp )
    {
        cbPrivExp = *f_pcbPrivExp;
        *f_pcbPrivExp = DRM_RSA_CB_PRIVEXP( pPvKeyInternal->eKeyLength );
        ChkBOOL ( cbPrivExp >= *f_pcbPrivExp, DRM_E_BUFFERTOOSMALL );
        if( f_pbPrivExp != NULL )
        {
            /*
             *   Extracting the private exponent from the privkey structure isn't implemented yet
             */
            DRMASSERT( FALSE );
            ChkDR( DRM_E_NOTIMPL );
        }
    }

    if ( NULL != f_pcbPrimes )
    {
        cbPrimes = *f_pcbPrimes;
        *f_pcbPrimes = DRM_RSA_CB_PRIME( pPvKeyInternal->eKeyLength );
        ChkBOOL ( cbPrimes >= *f_pcbPrimes, DRM_E_BUFFERTOOSMALL );
        if( f_pbPrime0 != NULL )
        {
            ChkDR( _DigitsToBigEndianBytes( pPvKeyInternal->rgdPrimes[ 0 ], 
                                            DRM_RSA_CBITS_MODULUS( pPvKeyInternal->eKeyLength ), 
                                            f_pbPrime0 ) );
        }
        if( f_pbPrime1 != NULL )
        {
            ChkDR( _DigitsToBigEndianBytes( pPvKeyInternal->rgdPrimes[ 1 ], 
                                            DRM_RSA_CBITS_MODULUS( pPvKeyInternal->eKeyLength ), 
                                            f_pbPrime1 ) );
        }
    }

ErrorExit:
    return dr;
}

/**********************************************************************
**
**  Function: OEM_RSA_ZeroPublicKey
**
**  Synopsis: Securely zeroes out the internal representation of a 
**            public key
**
**  Arguments:
**     [f_pPublicKey] : Specifies the key to clear
**
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          The key parameter is NULL
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL OEM_RSA_ZeroPublicKey( 
    __in       DRM_RSA_PUBLIC_KEY            *f_pPublicKey 
    )
{
    DRM_RESULT dr = DRM_SUCCESS;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_RSA, PERF_FUNC_OEM_RSA_ZeroPublicKey );

    ChkArg( NULL != f_pPublicKey );
    
    OEM_SECURE_ZERO_MEMORY( f_pPublicKey, SIZEOF( *f_pPublicKey ) );
       
ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/**********************************************************************
**
**  Function: OEM_RSA_ZeroPrivateKey
**
**  Synopsis: Securely zeroes out the internal representation of a 
**            private key
**
**  Arguments:
**     [f_pPrivateKey] : Specifies the key to clear
**
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          The key parameter is NULL
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL OEM_RSA_ZeroPrivateKey( 
    __in       DRM_RSA_PRIVATE_KEY           *f_pPrivateKey 
    )
{
    DRM_RESULT dr = DRM_SUCCESS;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_RSA, PERF_FUNC_OEM_RSA_ZeroPrivateKey );

    ChkArg( NULL != f_pPrivateKey );
    
    OEM_SECURE_ZERO_MEMORY( f_pPrivateKey, SIZEOF( *f_pPrivateKey ) );
       
ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}


/**********************************************************************
**
**  Function: OEM_RSA_Encrypt
**
**  Synopsis: Encrypts a fixed size buffer using RSA
**
**  Arguments:
**     [f_pPublicKey] : Specifies the public key to use
**     [f_rgbDataIn]  : Specifies the data to encrypt
**     [f_rgbDataOut] : Returns the encrypted data
**     [f_pCryptoCtx] : Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL or out of range
**      DRM_E_OEM_RSA_ENCRYPTION_ERROR
**          An error occurred during encryption
**  Notes:
**      Both data buffers and key elements are in big endian byte format.
**
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL OEM_RSA_Encrypt (
    __in const                      DRM_RSA_PUBLIC_KEY *f_pPublicKey,
    __in const                      DRM_DWORD           f_cbDataIn,
    __in_ecount( f_cbDataIn ) const DRM_BYTE           *f_pbDataIn,
    __out_ecount( f_cbDataIn )      DRM_BYTE           *f_pbDataOut,
    __in                            DRM_CRYPTO_CONTEXT *f_pCryptoCtx 
    )
{
    DRM_RESULT dr = DRM_SUCCESS;
    INTERNAL_DRM_RSA_PUBLIC_KEY *pPubKeyInternal = ( INTERNAL_DRM_RSA_PUBLIC_KEY * )f_pPublicKey;
    
    ChkArg( NULL != f_pPublicKey );
    ChkArg( DRM_RSA_CB_MODULUS( (DRM_DWORD)pPubKeyInternal->eKeyLength ) == f_cbDataIn );
    ChkArg( NULL != f_pbDataIn );
    ChkArg( NULL != f_pbDataOut );
    ChkArg( NULL != f_pCryptoCtx);

    ChkArg( pPubKeyInternal->cdModulus > 0 &&
            pPubKeyInternal->cdModulus <= CDIGITS_MODULUS_MAX );

    ChkBOOL( DRM_SUCCEEDED( _ModularExponentiate( pPubKeyInternal->eKeyLength,
                                                  f_cbDataIn,
                                                  f_pbDataIn, 
                                                  CDIGITS_PUBEXP,
                                                  pPubKeyInternal->rgdPubExp,
                                                  pPubKeyInternal->cdModulus,
                                                  pPubKeyInternal->rgdModulus,
                                                  f_pbDataOut,
                                                  f_pCryptoCtx ) ),
             DRM_E_OEM_RSA_ENCRYPTION_ERROR );

ErrorExit:
    return dr;
}

/**********************************************************************
**
**  Function: OEM_RSA_Decrypt
**
**  Synopsis: Decrypts a fixed size buffer using RSA
**
**  Arguments:
**     [f_pPrivateKey] : Specifies the private key to use. NULL
**                       indicates the private key baked into the 
**                       device should be used
**     [f_rgbDataIn]   : Specifies the data to decrypt
**     [f_rgbDataOut]  : Returns the decrypted data
**     [f_pCryptoCtx] : Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL or out of range
**      DRM_E_OEM_RSA_DECRYPTION_ERROR
**          An error occurred during encryption
**
**  Notes:
**      Both data buffers and key elements are in big endian byte format.
** 
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL OEM_RSA_Decrypt(
    __in const                      DRM_RSA_PRIVATE_KEY *f_pPrivateKey,
    __in const                      DRM_DWORD            f_cbDataIn,
    __in_ecount( f_cbDataIn ) const DRM_BYTE            *f_pbDataIn,
    __out_ecount( f_cbDataIn )      DRM_BYTE            *f_pbDataOut,
    __in                            DRM_CRYPTO_CONTEXT  *f_pCryptoCtx 
    )
{
    DRM_RESULT  dr = DRM_SUCCESS;    
    INTERNAL_DRM_RSA_PRIVATE_KEY *pPvKeyInternal  = ( INTERNAL_DRM_RSA_PRIVATE_KEY * )f_pPrivateKey;    
    digit_t         rgdTemp1[CDIGITS_MODULUS_MAX] = { 0 };
    digit_t         rgdTemp2[CDIGITS_MODULUS_MAX] = { 0 };
    digit_t         rgdTemp3[CDIGITS_MODULUS_MAX] = { 0 };
    mp_modulus_t    mod                           = { 0 };
    DRM_BOOL        fModCreated                   = FALSE;
    DRM_BOOL        fNegModular                   = FALSE;
    struct bigctx_t *pBigCtx                      = NULL;
    
    DRM_PROFILING_ENTER_SCOPE( PERF_MOD_RSA, PERF_FUNC_OEM_RSA_Decrypt );

    ChkArg( NULL != f_pPrivateKey );
    ChkArg( DRM_RSA_CB_MODULUS( (DRM_DWORD)pPvKeyInternal->eKeyLength ) == f_cbDataIn );
    ChkArg( NULL != f_pbDataIn );
    ChkArg( NULL != f_pbDataOut );
    ChkArg( NULL != f_pCryptoCtx );
    ChkArg( ( SIZEOF( rgdTemp1 ) / SIZEOF( rgdTemp1[ 0 ] ) ) >= pPvKeyInternal->cdPrimes[ 1 ] );

    pBigCtx = (struct bigctx_t *)f_pCryptoCtx->rgbCryptoContext;
    DRM_ECC_PKInit( pBigCtx, NULL );

    ChkArg( pPvKeyInternal->cdPrimes[0] <= CDIGITS_MODULUS( (DRM_DWORD)pPvKeyInternal->eKeyLength ) );
    ChkArg( pPvKeyInternal->cdPrimes[1] <= CDIGITS_MODULUS( (DRM_DWORD)pPvKeyInternal->eKeyLength ) );
    
    ChkDR( _BigEndianBytesToDigits( f_pbDataIn, DRM_RSA_CBITS_MODULUS( pPvKeyInternal->eKeyLength ), rgdTemp1 ) );  
  
    /*
    ** Compute m2 = cipher^CRTExponents[1] mod q
    */   
    ChkBOOL( create_modulus( pPvKeyInternal->rgdPrimes[1], 
                             pPvKeyInternal->cdPrimes[1], 
                             FROM_RIGHT, 
                            &mod, 
                             pBigCtx, 
                             pBigCtx ), DRM_E_OEM_RSA_DECRYPTION_ERROR );
    fModCreated = TRUE;                              
    ChkBOOL( to_modular( rgdTemp1, CDIGITS_MODULUS( pPvKeyInternal->eKeyLength ), rgdTemp2, &mod, pBigCtx ), 
             DRM_E_OEM_RSA_DECRYPTION_ERROR );                           
    ChkBOOL( mod_exp( rgdTemp2, 
                      pPvKeyInternal->rgdCRTExponents[1], 
                      pPvKeyInternal->cdPrimes[1], 
                      rgdTemp2, 
                     &mod, 
                      pBigCtx ), DRM_E_OEM_RSA_DECRYPTION_ERROR );
    ChkBOOL( from_modular( rgdTemp2, rgdTemp2, &mod ), DRM_E_OEM_RSA_DECRYPTION_ERROR );
    uncreate_modulus( &mod, pBigCtx );
    fModCreated = FALSE;       
                                 
    /*
    ** Compute m1 = cipher^CRTExponents[0] mod p
    */                                  
    ChkBOOL( create_modulus( pPvKeyInternal->rgdPrimes[0], 
                             pPvKeyInternal->cdPrimes[0], 
                             FROM_RIGHT, 
                            &mod, 
                             pBigCtx, 
                             pBigCtx ), DRM_E_OEM_RSA_DECRYPTION_ERROR );
    fModCreated = TRUE; 
    ChkBOOL( to_modular( rgdTemp1, CDIGITS_MODULUS( pPvKeyInternal->eKeyLength ), rgdTemp1, &mod, pBigCtx ), 
             DRM_E_OEM_RSA_DECRYPTION_ERROR );
    ChkBOOL( mod_exp( rgdTemp1, 
                      pPvKeyInternal->rgdCRTExponents[0], 
                      pPvKeyInternal->cdPrimes[0], 
                      rgdTemp1, 
                     &mod, 
                      pBigCtx ), DRM_E_OEM_RSA_DECRYPTION_ERROR );
    ChkBOOL( from_modular( rgdTemp1, rgdTemp1, &mod ), DRM_E_OEM_RSA_DECRYPTION_ERROR );
       
    /*
    ** Compute iqmp * ( m1 - m2 ) mod p
    */
    if( compare_diff( rgdTemp1, 
                      pPvKeyInternal->cdPrimes[0], 
                      rgdTemp2, 
                      pPvKeyInternal->cdPrimes[1] ) < 0 )
    {
        /*
        ** ( m1 - m2 ) < 0, works around negative modular division
        */
        fNegModular = TRUE;
        ChkBOOL( sub_same( rgdTemp2,
                           rgdTemp1,
                           rgdTemp1,
                           pPvKeyInternal->cdPrimes[1] ) == 0, DRM_E_OEM_RSA_DECRYPTION_ERROR );
    }
    else
    {
        ChkBOOL( sub_diff( rgdTemp1, 
                           pPvKeyInternal->cdPrimes[0], 
                           rgdTemp2, 
                           pPvKeyInternal->cdPrimes[1], 
                           rgdTemp1,
                           NULL ), DRM_E_OEM_RSA_DECRYPTION_ERROR );                
    }
    
    /*
    ** multiply by iqmp % p
    */          
    ChkBOOL( to_modular( pPvKeyInternal->rgdIQMP, 
                         pPvKeyInternal->cdPrimes[0], 
                         rgdTemp3, 
                        &mod, 
                         pBigCtx ), DRM_E_OEM_RSA_DECRYPTION_ERROR );
    ChkBOOL( to_modular( rgdTemp1, 
                         pPvKeyInternal->cdPrimes[0],
                         rgdTemp1, 
                        &mod, 
                         pBigCtx ), DRM_E_OEM_RSA_DECRYPTION_ERROR );                                     
    ChkBOOL( mod_mul( rgdTemp1, rgdTemp3, rgdTemp1, &mod, NULL, pBigCtx ),
             DRM_E_OEM_RSA_DECRYPTION_ERROR );  
    ChkBOOL( from_modular( rgdTemp1, rgdTemp1, &mod ), DRM_E_OEM_RSA_DECRYPTION_ERROR );

    if( fNegModular && compare_immediate( rgdTemp1, 0, pPvKeyInternal->cdPrimes[0] ) != 0 )
    {       
        /*
        ** if remainder != 0, subtract from modulus (negative modular division)
        */                          
        ChkBOOL( sub_same( pPvKeyInternal->rgdPrimes[0],
                           rgdTemp1,                            
                           rgdTemp1,
                           pPvKeyInternal->cdPrimes[0] ) == 0, DRM_E_OEM_RSA_DECRYPTION_ERROR );
    }
    
    /*
    ** Compute message = m2 + ( iqmp * ( m1 - m2 ) % p ) * q
    */              
    DRM_BYT_SetBytes( rgdTemp1, 
                      pPvKeyInternal->cdPrimes[0], 
                      SIZEOF( digit_t ) * ( CDIGITS_MODULUS( pPvKeyInternal->eKeyLength ) - pPvKeyInternal->cdPrimes[0] ), 
                      0x00 );                          
    multiply_low( rgdTemp1, pPvKeyInternal->rgdPrimes[1], rgdTemp3, CDIGITS_MODULUS( pPvKeyInternal->eKeyLength ) );
    ChkBOOL( add_diff( rgdTemp3, 
                       CDIGITS_MODULUS( pPvKeyInternal->eKeyLength ),
                       rgdTemp2, 
                       pPvKeyInternal->cdPrimes[1],
                       rgdTemp2,
                       NULL ), DRM_E_OEM_RSA_DECRYPTION_ERROR );                                     

    /*
    ** Convert back from digits
    */
    ChkDR( _DigitsToBigEndianBytes( rgdTemp2, DRM_RSA_CBITS_MODULUS( pPvKeyInternal->eKeyLength ), f_pbDataOut ) );      
                                    
ErrorExit:
    if( fModCreated )
    {
        uncreate_modulus( &mod, pBigCtx );
    }   

    DRM_PROFILING_LEAVE_SCOPE;

    return dr;
}



EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\lib\oemrsakeygen.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#include <bignum.h>
#include <mprand.h>
#include <oemrsaimpl.h>
#include <oemrsa.h>
#include <drmrsacommon.h>

ENTER_PK_NAMESPACE;

DRM_API DRM_RESULT DRM_CALL _BigEndianBytesToDigits(   
    __in_ecount( BITS_TO_BYTES( f_cBitsData ) ) const DRM_BYTE  *f_pbData,    
    __in const                                        DRM_DWORD  f_cBitsData,
    __out_ecount( BITS_TO_DIGITS( f_cBitsData ) )     digit_t   *f_pDigits
    );

DRM_API DRM_RESULT DRM_CALL _DigitsToBigEndianBytes(
    __in_ecount( BITS_TO_DIGITS( f_cBitsData ) ) const digit_t   *f_pDigits,
    __in                                               DRM_DWORD  f_cBitsData,
    __out_ecount( BITS_TO_BYTES( f_cBitsData ) )       DRM_BYTE  *f_pbData 
    );

EXIT_PK_NAMESPACE;

ENTER_PK_NAMESPACE_CODE;

typedef struct {
    DRM_DWORD  candidates;                   /* Candidates tried */
    DRM_DWORD  primes_found;
    DRM_DWORD  trial_division_eliminations;  /* Rejections, small divisor found */
    DRM_DWORD  rabin_eliminations;           /* Rejections, Rabin test failed */
    DRM_DWORD  other_eliminations;           /* Other rejections */
} big_prime_search_stat_t;

/* 25K for low primes */
#define DRM_RSA_PKCRYPTO_LOW_PRIME_SIZE 25000

static const DRM_DWORD NUM_RABIN_TEST       = 50;
static const DRM_DWORD MAX_PRIME_CANDIDATES = 5000;


/******************************************************************************
** 
** Function :   big_prime_search
** 
** Synopsis :   Search for a huge prime, perhaps 512 or 1024 bits.
**
**              Choose a random bit pattern of the requested length.
**              Set its two most significant bits and the lower bit.
**              Test for divisibility by primes in our table.
**              If no factor found, do some Rabin-like primality checks.
**              When not prime, restart with new random bit-pattern.
**
**              An odd 512-bit integer is prime with probabilty
**              approximately 2 / ln(2^512) or 1 in 180.
**              If we have checked for divisors below a bound B,
**              this probability grows to ln(B)/ln(2^256) ~= log10(B)/78.
**              With B = 10^5, this probability is 15%.
**
** Arguments :  [bitlen_p]     - Length in bits (must be at least 32)
**              [p]            - primes
**              [lowprods]     - From low_prime_prod_construction
**              [clowprods]    - count of elements in the prime table.
**              [pbpstat]      - statistics
**              [f_pCryptoCtx] - Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
** Returns :    TRUE  - if primes were successfully created
**              FALSE - otherwise 
******************************************************************************/
static DRM_BOOL big_prime_search(
    __in                                     const DRM_DWORD                bitlen_p,       
    __inout_ecount(BITS_TO_DIGITS(bitlen_p))       digit_t                 *p,              
    __in_ecount( clowprods )                 const digit_t                 *lowprods,
    __in                                     const DRM_DWORD                clowprods,
    __inout                                        big_prime_search_stat_t *pbpstat,        
    __inout                                        DRM_CRYPTO_CONTEXT      *f_pCryptoCtx )
{
    const DRM_DWORD diglen_p     = BITS_TO_DIGITS(bitlen_p);
    DRM_BOOL     OK              = TRUE;
    DRM_BOOL     big_prime_found = FALSE;
	DRM_BOOL     modulus_created = FALSE;
    digit_t     *dtemps          = NULL;
    mp_modulus_t p_modulus       = { 0 };
    struct bigctx_t *pBigCtx     = NULL;

    DRMASSERT( p != NULL);
    DRMASSERT( lowprods != NULL && clowprods > 0 );
    DRMASSERT( pbpstat != NULL );

    if( f_pCryptoCtx != NULL )
    {
        pBigCtx = (struct bigctx_t *)f_pCryptoCtx->rgbCryptoContext;
        DRM_RSA_PKInit( pBigCtx );

        if (bitlen_p < 32) 
        {   /* Comes too close to primes in prods[] array */
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INVALID_DATA, "big_prime_search");
        } else 
        {
            dtemps = digit_allocate(4*diglen_p, "big_prime_search", pBigCtx);
            if (dtemps == NULL) OK = FALSE;
        }
    }
    else
    {
        OK = FALSE;
    }

    while (OK && !big_prime_found) 
    {
        digit_t *base     = dtemps;              /* All length diglen_p */
        digit_t *exponent = dtemps +   diglen_p;
        digit_t *minus1   = dtemps + 2*diglen_p;
        digit_t *result   = dtemps + 3*diglen_p;
        DRM_BOOL hit_minus1 = FALSE;
        digit_t gcdtest = 0;

        if (pbpstat->candidates >= MAX_PRIME_CANDIDATES) 
        {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_TOO_MANY_ITERATIONS, "big_prime_search");
        } else 
        {
            pbpstat->candidates++;
/* 
 *  If job is running interactively, perhaps print pbpstat->candidates 
 *  and pbpstat->primes_found to the screen occasionally.
 */
        }
        OK = OK && random_digits(p, diglen_p, pBigCtx);
        p[diglen_p - 1] >>= (RADIX_BITS*diglen_p - bitlen_p);
        p[0] |= 1;
        mp_setbit(p, bitlen_p-1, 1);
        mp_setbit(p, bitlen_p-2, 1);

        /* Test for a divisor from the table of small primes */
        OK = OK && low_prime_divisibility(p, diglen_p, lowprods, clowprods, &gcdtest, pBigCtx);
        if (!OK) 
        {
        } 
        else if (gcdtest != 1) 
        {
            pbpstat->trial_division_eliminations++;
        } 
        else 
        {
            DRM_DWORD irabin;
			DRM_BOOL reject_p = FALSE;
            MEMSET(&p_modulus, 0, sizeof(p_modulus));  /* Avoid warnings */
            OK = OK && create_modulus(p, diglen_p, FROM_RIGHT, &p_modulus, pBigCtx, pBigCtx);
            modulus_created = OK;

/*
 *   p has no divisor from our tables.
 *   Do some Rabin tests.  Use base 2 for first test.
 */

            OK = OK && neg_mod(p_modulus.one, minus1, p_modulus.modulus, p_modulus.length);
            OK = OK && mp_shift(p, -1, exponent, diglen_p);

			/* exponent = (p - 1)/2 */
            for (irabin = 1;
                OK && irabin <= NUM_RABIN_TEST && !reject_p;
                irabin++) 
            {
                if (irabin == 1) 
                {  /* base = 1 + 1 = 2 */
                    OK = OK && add_mod(p_modulus.one, p_modulus.one,
                                       base, p_modulus.modulus, p_modulus.length);
                } 
                else 
                {
                    OK = OK && random_mod_nonzero(p, base, diglen_p, pBigCtx);
                }
                OK = OK && mod_exp(base, exponent, diglen_p,
                                   result, &p_modulus, pBigCtx);

                /* If p is prime, result of exponentiation will be +1 or -1 */
                if (!OK) 
                {  
                } 
                else if (compare_same(result, minus1, diglen_p) == 0) 
                {
                    hit_minus1 = TRUE;   /* Got a -1 */
                } 
                else if (compare_same(result, p_modulus.one, diglen_p) != 0) 
                {
                    reject_p = TRUE;     /* Neither -1 nor +1 */
                    pbpstat->rabin_eliminations++;
                }
            } /* for irabin */

            if (OK && !reject_p) 
            {
                big_prime_found = hit_minus1;
                if (!hit_minus1) 
                {
                    pbpstat->other_eliminations++;
                    TRACE( ( "Potential prime passed %d Rabin tests but never gave -1\n", 
                           ( DRM_INT )NUM_RABIN_TEST ) );
                }  /* Don't use it */
            }
            if (modulus_created) 
            {
                uncreate_modulus(&p_modulus, pBigCtx);
            }
            modulus_created = FALSE;
        } /* Radin tests */
    }  /* while (!big_prime_found) */

    if (dtemps != NULL) 
    {
        Free_Temporaries(dtemps, pBigCtx);
    }
    if (modulus_created) 
    {
        uncreate_modulus(&p_modulus, pBigCtx);
    }
    return OK;
} /* end big_prime_search */

/******************************************************************************
** 
** Function :   rsa_construction
** 
** Synopsis :   
**    Construct an RSA modulus for which the primes have lengths
**    bitlen_p1 and bitlen_p2.  Both primes will start with 11 (binary),
**    ensuring their product has a full bitlen_p1 + bitlen_p2 bits.
**    The public exponent will be 65537.
** 
** Arguments :  [bitlen_p1]    - 
**              [bitlen_p2]    - 
**              [f_pbModulus]  - pointer to public key modulus
**              [f_pbPrivExp]  - pointer to private key exponent
**              [f_pbPrime0]   - pointer to first (greater) prime
**              [f_pbPrime1]   - pointer to second (smaller) prime
**              [f_pCryptoCtx] - Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
** Returns :    DRM_SUCCESS - 
******************************************************************************/
static DRM_RESULT rsa_construction(
    __in const                                             DRM_DWORD           bitlen_p1,
    __in const                                             DRM_DWORD           bitlen_p2,
    __out_ecount( BITS_TO_BYTES( bitlen_p1 + bitlen_p2 ) ) DRM_BYTE           *f_pbModulus,
    __out_ecount( BITS_TO_BYTES( bitlen_p1 + bitlen_p2 ) ) DRM_BYTE           *f_pbPrivExp,
    __out_ecount( BITS_TO_BYTES( bitlen_p1 + bitlen_p2 ) ) DRM_BYTE           *f_pbPrime0,
    __out_ecount( BITS_TO_BYTES( bitlen_p1 + bitlen_p2 ) ) DRM_BYTE           *f_pbPrime1,
    __inout                                                DRM_CRYPTO_CONTEXT *f_pCryptoCtx
    )
{
    DRM_RESULT dr = DRM_SUCCESS;
    big_prime_search_stat_t stats = { 0 };
    big_prime_search_stat_t* pbpstat = &stats;
    const DRM_BYTE pubexp_bytes[] = {1, 0x00, 0x01}; /* Public expon 65537 = 0x101 */
    const DRM_DWORD bitlen_pubexp = 17;       /* Length of public exponent in bits */
    const DRM_DWORD bitlen_modulus = bitlen_p1 + bitlen_p2;
                                              /* No leading zero after multiply */

    const DRM_DWORD diglen_pubexp  = BITS_TO_DIGITS(bitlen_pubexp);
    const DRM_DWORD diglen_p1      = BITS_TO_DIGITS(bitlen_p1);
    const DRM_DWORD diglen_p2      = BITS_TO_DIGITS(bitlen_p2);
    const DRM_DWORD diglen_plonger = MAX(diglen_p1, diglen_p2);
    const DRM_DWORD diglen_pboth   = diglen_p1 + diglen_p2;
    const DRM_DWORD num_dtemps     = 5*diglen_plonger + 3*diglen_pboth + diglen_pubexp;

    digit_t *primes   = NULL;
    digit_t *privexp  = NULL;
    digit_t *modulus  = NULL;
    digit_t *pubexp   = NULL;
    digit_t *gcd      = NULL;
    digit_t *temp1    = NULL;
    digit_t *temp2    = NULL;
    digit_t *temp3    = NULL;

    DRM_DWORD lgcd = 0, nprime_found = 0;    /* Need 2 primes -- none found yet */
    digit_t *dtemps                  = NULL; /* Freed at end of procedure */
    digit_t *lowprods                = NULL; /* Freed at end of procedure */
    DRM_DWORD clowprods              = 0;
    struct bigctx_t *pBigCtx         = NULL;

    struct bigctx_t *pBigCtxPrimes            = NULL;
    ChkMem( pBigCtxPrimes = (struct bigctx_t*)Oem_MemAlloc( DRM_RSA_PKCRYPTO_LOW_PRIME_SIZE ) );
    DRM_RSA_PKInitWithSize( pBigCtxPrimes, DRM_RSA_PKCRYPTO_LOW_PRIME_SIZE );

    ChkArg( IS_VALID_DRM_RSA_KEY_LENGTH( bitlen_p1 + bitlen_p2 ) );
    ChkArg( NULL != f_pbModulus );
    ChkArg( NULL != f_pbPrivExp );
    ChkArg( NULL != f_pbPrime0 );
    ChkArg( NULL != f_pbPrime1 );
    ChkArg( NULL != f_pCryptoCtx );
    ChkBOOL( bitlen_p1 == bitlen_p2, DRM_E_NOTIMPL ); /* limitation of current implementation */

    pBigCtx = (struct bigctx_t *)f_pCryptoCtx->rgbCryptoContext;
    DRM_RSA_PKInit( pBigCtx );

    ChkArg( bitlen_pubexp > 1
         && IS_ODD(pubexp_bytes[0]) );

    ChkMem( dtemps = digit_allocate(num_dtemps, "rsa_construction 1", pBigCtx) );
    ChkMem( lowprods = low_prime_prod_construction(pBigCtxPrimes, &clowprods) );

    primes   = dtemps;                     /* Lengths diglen_p1 and diglen_p2 */
    privexp  = dtemps  + diglen_pboth;     /* Lengths diglen_p1 and diglen_p2 */
    modulus  = privexp + diglen_pboth;     /* Length  2*diglen_plonger */
    pubexp   = modulus + 2*diglen_plonger; /* Length  diglen_pubexp */
    gcd      = pubexp  + diglen_pubexp;    /* Length  diglen_plonger */
    temp1    = gcd     + diglen_plonger;   /* Length  diglen_plonger */
    temp2    = temp1   + diglen_plonger;   /* Length  diglen_plonger */
    temp3    = temp2   + diglen_plonger;   /* Length  diglen_pboth */

    {        
        DRMASSERT(dtemps + num_dtemps == temp3 + diglen_pboth);
        
        ChkDR( _BigEndianBytesToDigits(pubexp_bytes,
                                       bitlen_pubexp, pubexp));

        MEMSET(pbpstat, 0, sizeof(big_prime_search_stat_t)); /* Clear statistics */
        while (nprime_found != 2)
        {
            const DRM_DWORD bitlen_pnow = /*bitlen_p[nprime_found];*/ (nprime_found==0)?bitlen_p1:bitlen_p2;
            const DRM_DWORD poffset = diglen_p1*nprime_found;  /* Offset in primes array */
            digit_t *pnow = primes + poffset;            /* Location of latest prime */

            ChkBOOL( big_prime_search(bitlen_pnow, pnow, lowprods, clowprods, pbpstat, f_pCryptoCtx), DRM_E_FAIL );

            if( nprime_found == 1
             && compare_diff(primes            , diglen_p1,
                             primes + diglen_p1, diglen_p2) == 0)
            {
                pbpstat->other_eliminations++;
            } 
            else 
            {
                pbpstat->primes_found++;  /* same as nprime_found */
                nprime_found++;
            }
        } /* while */

        multiply(primes, diglen_p1, primes + diglen_p1, diglen_p2, modulus);

        sub_immediate(primes,             1, temp1, diglen_p1);    /* temp1 = p - 1 */
        sub_immediate(primes + diglen_p1, 1, temp2, diglen_p2);    /* temp2 = q - 1 */

        multiply(temp1, diglen_p1, temp2, diglen_p2, temp3);

        ChkBOOL( mp_gcdex( pubexp,
                           diglen_pubexp, 
                           temp3,
                           diglen_pboth,
                           privexp,
                           NULL, 
                           gcd,
                           NULL, 
                          &lgcd,
                           NULL, 
                           pBigCtx), DRM_E_FAIL );

        if( compare_immediate(gcd, 1, lgcd) != 0 )
        {
            /* Cannot solve privexp*pubexp == 1 (mod p-1) */
            ChkDR( DRM_E_FAIL );
        }

        if( mp_significant_bit_count(modulus, diglen_pboth ) != bitlen_modulus )
        {
            SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                             "rsa_construction -- wrong bit count" );

            ChkDR( DRM_E_FAIL );
        }
      
        /* Limitation of current implementation */
        DRMASSERT( bitlen_p1 == bitlen_p2 && bitlen_p1%BITS_PER_STANDARD_BYTE == 0);
        /* OACR validations */
        ChkOverflow( f_pbPrime0 + DRM_RSA_CB_PRIME( bitlen_modulus ) / 2, f_pbPrime0 );
        ChkOverflow( f_pbPrime1 + DRM_RSA_CB_PRIME( bitlen_modulus ) / 2, f_pbPrime1 );
        DRMASSERT( BITS_TO_BYTES( bitlen_modulus ) - DRM_RSA_CB_PRIME( bitlen_p2 ) >= BITS_TO_BYTES( bitlen_p1 ) );
        DRMASSERT( BITS_TO_BYTES( bitlen_modulus ) - DRM_RSA_CB_PRIME( bitlen_p1 ) >= BITS_TO_BYTES( bitlen_p2 ) );

        ChkDR( _DigitsToBigEndianBytes(modulus, bitlen_modulus,      f_pbModulus));        
        ChkDR( _DigitsToBigEndianBytes(privexp, bitlen_p1+bitlen_p2, f_pbPrivExp));

        MEMSET( f_pbPrime0,  0, BITS_TO_BYTES( bitlen_modulus ) );            
        MEMSET( f_pbPrime1,  0, BITS_TO_BYTES( bitlen_modulus ) );            

        ChkBOOL( BITS_TO_BYTES( bitlen_p1 + bitlen_p2 ) >= DRM_RSA_CB_PRIME( bitlen_p2 ), DRM_E_BUFFERTOOSMALL );
        
        ChkDR( _DigitsToBigEndianBytes(primes                    ,   bitlen_p1, f_pbPrime0 + DRM_RSA_CB_PRIME( bitlen_p2 ))); 

        ChkBOOL( BITS_TO_BYTES( bitlen_p1 + bitlen_p2 ) >= DRM_RSA_CB_PRIME( bitlen_p1 ), DRM_E_BUFFERTOOSMALL );
        
        ChkDR( _DigitsToBigEndianBytes(primes + ( 1 * diglen_p1 ),   bitlen_p2, f_pbPrime1 + DRM_RSA_CB_PRIME( bitlen_p1 ) ));            
    }
    
ErrorExit:    
    if (dtemps != NULL)
    {
        Free_Temporaries(dtemps, pBigCtx);
    }
    if (lowprods != NULL)
    {
        low_prime_prod_destruction(lowprods, pBigCtxPrimes);
    }
    SAFE_OEM_FREE( pBigCtxPrimes );

    return dr;
}



/**********************************************************************
**
**  Function: OEM_RSA_GenerateKeyPair
**
**  Synopsis: Generates RSA public/private key pair
**
**  Arguments:
**     [f_eKeyLength]  : RSA key length in bits
**     [f_pPrivateKey] : Returns pointer to RSA private key.
**     [f_pPublicKey]  : Returns pointer to RSA public key
**     [f_pCryptoCtx]  : Pointer to DRM_CRYPTO_CONTEXT used for temporary data in crypto code.
**
**  Returns:
**      DRM_SUCCESS
**          Success
**      DRM_E_INVALIDARG
**          One of the arguments was NULL or out of range
**      DRM_E_OEM_RSA_DECRYPTION_ERROR
**          An error occurred during encryption
**
**  Notes:
**      Both data buffers and key elements are in big endian byte format.
** 
**********************************************************************/
DRM_API DRM_RESULT DRM_CALL OEM_RSA_GenerateKeyPair(
    __in const DRM_RSA_SUPPORTED_KEY_LENGTHS  f_eKeyLength,
    __out      DRM_RSA_PRIVATE_KEY           *f_pPrivateKey,
    __out      DRM_RSA_PUBLIC_KEY            *f_pPublicKey,
    __inout    DRM_CRYPTO_CONTEXT            *f_pCryptoCtx 
    )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE   rgbModulus  [__CB_DECL( DRM_RSA_CB_MODULUS_MAX )];
    DRM_BYTE   rgbPrivExp  [__CB_DECL( DRM_RSA_CB_PRIVEXP_MAX )];
    DRM_BYTE   rgbPrimes[2][__CB_DECL( DRM_RSA_CB_PRIME_MAX )];
    DRM_DWORD  nbit = f_eKeyLength;

    ChkArg( IS_VALID_DRM_RSA_KEY_LENGTH( f_eKeyLength ) );
    ChkArg( NULL != f_pPrivateKey );
    ChkArg( NULL != f_pPublicKey );
    ChkArg( NULL != f_pCryptoCtx );

    ChkDR( rsa_construction( nbit / 2, 
                             nbit / 2, 
                             rgbModulus,
                             rgbPrivExp,
                             rgbPrimes[ 0 ],
                             rgbPrimes[ 1 ],
                             f_pCryptoCtx) );

    ChkDR( OEM_RSA_SetPublicKey( f_eKeyLength, 
                                 sizeof( rgbDRM_RSA_DEFAULT_PUBEXP ),
                                 rgbDRM_RSA_DEFAULT_PUBEXP, 
                                 DRM_RSA_CB_MODULUS( f_eKeyLength ),
                                 rgbModulus, 
                                 f_pPublicKey ) );
    
    ChkDR( OEM_RSA_SetPrivateKey( f_eKeyLength, 
                                  DRM_RSA_CB_PRIVEXP( f_eKeyLength ),
                                  rgbPrivExp,
                                  DRM_RSA_CB_PRIME( f_eKeyLength ),
                                  rgbPrimes[ 0 ],
                                  rgbPrimes[ 1 ],
                                  f_pPrivateKey, 
                                  f_pCryptoCtx ) );

ErrorExit:
    if( f_pCryptoCtx != NULL )
    {
        MEMSET( f_pCryptoCtx, 0, sizeof( DRM_CRYPTO_CONTEXT ) );
    }
    return dr;
}


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\lib\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_drmplayreadyoem_none_12.4.56.0_none_976e848dfaba90ad
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_drmplayreadyoem_no-public-key_12.4.56.0_x-ww_73a45bfd
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=drmplayreadyoem
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_drmplayreadyoem_no-public-key_12.4.56.0_x-ww_73a45bfd
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_drmplayreadyoem_no-public-key_12.4.56.0_x-ww_73a45bfd.manifest
XP_MANIFEST_PATH=manifests\x86_drmplayreadyoem_no-public-key_12.4.56.0_x-ww_73a45bfd.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_drmplayreadyoem_no-public-key_12.4.56.0_x-ww_73a45bfd.cat
XP_CATALOG_PATH=manifests\x86_drmplayreadyoem_no-public-key_12.4.56.0_x-ww_73a45bfd.cat
XP_PAYLOAD_PATH=x86_drmplayreadyoem_no-public-key_12.4.56.0_x-ww_73a45bfd
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=drmplayreadyoem,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\lib\oemtime.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft PlayReady
** Copyright (c) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <windows.h>
#include <drmcommon.h>

ENTER_PK_NAMESPACE_CODE;

#define C_TICS_PER_SECOND 10000000

#if TEST_USE_OFFSET_CLOCK
/* This global will allow an offset to be added to the main system's clock,
 * and is used by the test code to adjust the clock
 */
DRM_EXPORT_VAR DRM_LONG g_lOEMTimeOffset = 0;
#endif

DRM_API DRM_BOOL DRM_CALL Oem_Clock_SystemTimeToFileTime(
    __in const DRMSYSTEMTIME *lpSystemTime,
    __out DRMFILETIME *lpFileTime )
{
    return SystemTimeToFileTime( ( const SYSTEMTIME * )lpSystemTime, ( FILETIME * )lpFileTime );
}

DRM_API DRM_BOOL DRM_CALL Oem_Clock_FileTimeToSystemTime(
    __in const DRMFILETIME *lpFileTime,
    __out DRMSYSTEMTIME *lpSystemTime )
{
    return FileTimeToSystemTime( ( const FILETIME * )lpFileTime, ( SYSTEMTIME * )lpSystemTime );
}

DRM_API DRM_VOID DRM_CALL Oem_Clock_GetSystemTime(
    __in_opt    DRM_VOID      *pOEMContext,
    __out       DRMSYSTEMTIME *psystime )
{
#if TEST_USE_OFFSET_CLOCK
    /* If the offset clock option is on, we should load the time as a
    ** FILETIME since it's easier to do the offset
    */
    DRMFILETIME filetime = {0};

    Oem_Clock_GetSystemTimeAsFileTime( pOEMContext, &filetime );
    Oem_Clock_FileTimeToSystemTime( &filetime, psystime );
#else
    DRMCASSERT( SIZEOF( DRMSYSTEMTIME ) == SIZEOF( SYSTEMTIME ) );

    GetSystemTime( (SYSTEMTIME*)psystime );
#endif
}

DRM_API DRM_VOID DRM_CALL Oem_Clock_GetSystemTimeAsFileTime(
    __in_opt    DRM_VOID    *pOEMContext,
    __out       DRMFILETIME *pfiletime )
{
    SYSTEMTIME systime;
#if TEST_USE_OFFSET_CLOCK
    DRM_UINT64 ui64Time = DRM_UI64LITERAL( 0, 0 );
#endif

    GetSystemTime( &systime );
    SystemTimeToFileTime (&systime, ( FILETIME * ) pfiletime );

#if TEST_USE_OFFSET_CLOCK
    FILETIME_TO_UI64( *pfiletime, ui64Time ); 

    if ( g_lOEMTimeOffset >= 0 )
    {
        ui64Time = DRM_UI64Add( ui64Time, DRM_UI64Mul( DRM_UI64( C_TICS_PER_SECOND ), DRM_UI64( g_lOEMTimeOffset ) ) );
    }
    else
    {
        ui64Time = DRM_UI64Sub( ui64Time, DRM_UI64Mul( DRM_UI64( C_TICS_PER_SECOND ), DRM_UI64( -g_lOEMTimeOffset ) ) );
    }
        
    UI64_TO_FILETIME( ui64Time, *pfiletime );
#endif
}

DRM_API DRM_VOID DRM_CALL Oem_Clock_SetSystemTime(
    __in_opt    DRM_VOID      *pOEMContext,
    __in        DRMSYSTEMTIME *lpSystemTime )
{
#if TEST_USE_OFFSET_CLOCK
    DRMFILETIME ftCurrent  = {0};
    DRMFILETIME ftNew      = {0};
    DRM_UINT64 ui64Current = DRM_UI64LITERAL( 0, 0 );
    DRM_UINT64 ui64New     = DRM_UI64LITERAL( 0, 0 );

    Oem_Clock_GetSystemTimeAsFileTime( pOEMContext, &ftCurrent );

    if ( DRM_SUCCEEDED( Oem_Clock_SystemTimeToFileTime( lpSystemTime, &ftNew ) ) )
    {
        FILETIME_TO_UI64( ftCurrent, ui64Current );
        FILETIME_TO_UI64( ftNew, ui64New );
         
        g_lOEMTimeOffset += DRM_I64ToUI32( DRM_I64Div( DRM_I64Sub( DRM_UI2I64( ui64New ), DRM_UI2I64( ui64Current ) ), DRM_I64( C_TICS_PER_SECOND ) ) );
    }
#else
    SetSystemTime( ( SYSTEMTIME * )lpSystemTime );
#endif
}



DRM_API DRM_DWORD DRM_CALL Oem_Clock_GetTickCount(
    __in_opt    DRM_VOID      *f_pOEMContext )
{
    DRM_DWORD  dwTickCount = GetTickCount();

#if TEST_USE_OFFSET_CLOCK
    if ( f_pOEMContext != NULL )
    {
        DRM_TEST_OEM_CONTEXT *pTestOemContext = (DRM_TEST_OEM_CONTEXT *)f_pOEMContext;

        if ( ( pTestOemContext->fFreezeTickCount ) && ( pTestOemContext->dwTickCount > 0 ) )
        {
            dwTickCount = pTestOemContext->dwTickCount;
        }
    }
#endif
    
    return dwTickCount;
}


EXIT_PK_NAMESPACE_CODE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\PlayReady\oem_win32\lib\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_drmplayreadyoem_none_12.4.56.0_none_976e848dfaba90ad
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_drmplayreadyoem_no-public-key_12.4.56.0_x-ww_73a45bfd
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=drmplayreadyoem
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_drmplayreadyoem_no-public-key_12.4.56.0_x-ww_73a45bfd
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_drmplayreadyoem_no-public-key_12.4.56.0_x-ww_73a45bfd.manifest
XP_MANIFEST_PATH=manifests\x86_drmplayreadyoem_no-public-key_12.4.56.0_x-ww_73a45bfd.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_drmplayreadyoem_no-public-key_12.4.56.0_x-ww_73a45bfd.cat
XP_CATALOG_PATH=manifests\x86_drmplayreadyoem_no-public-key_12.4.56.0_x-ww_73a45bfd.cat
XP_PAYLOAD_PATH=x86_drmplayreadyoem_no-public-key_12.4.56.0_x-ww_73a45bfd
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=drmplayreadyoem,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\ansXsig\ansXsig.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.LiveService;
using ServerTestFramework;
using System.Security.Cryptography;



namespace ansXsig
{
    public class AnsXSigTestSuite : TestSuite
    {

        private static XSignature sig;

        public override void  InitializeStress(System.Xml.XmlDocument config)
        {
            sig = new XRLGetSigningKey().Execute();
        }

        [StressTest, StressInstantiate]
        public class XSigGetSigningKey : TestBase
        {
            override protected void Execute()
            {
                // what might fail here?  Need to do some validation.
                XSignature newsig = new XRLGetSigningKey().Execute();
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [StressTest, StressInstantiate]
        public class XSigVerifySignature : TestBase
        {
            protected override void Execute()
            {
                byte[] data = new System.Text.ASCIIEncoding().GetBytes("here is some clear text");
                uint[] hresults = new XRLVerifySignature().Execute(new XSigAuthenticator(data));
                if (hresults[0] == HResult.S_OK)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    Global.RO.Error("Verify Signature failed with hr: " + hresults[0].ToString("X"));
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [StressTest, StressInstantiate]
        public class XSigSignOnBehalf : TestBase
        {
            protected override void Execute()
            {
                byte[] data = System.Text.Encoding.ASCII.GetBytes("Hello, how are you?");
                SigningRequest req = null;

                req = new SigningRequest((uint)XOService.Presence, data);
                SignOnBehalfResult[] result = new XRLSignOnBehalf().Execute(req);
                if (result[0].HResult == HResult.S_OK)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                { 
                    Global.RO.Error("SignOnBehalf failed with hr: " + result[0].HResult.ToString("X"));
                    ResultCode = TEST_RESULTS.FAILED;
                }

                
            }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\dvt\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\Carbon\Crypto.cs ===
using System;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;

using ServerTestFramework;

namespace SigTest.Carbon
{
    public static class Win32
    {
        [DllImport("crypt32.dll")]
        public static extern bool CryptDecodeObject(
            uint CertEncodingType,
            uint lpszStructType,
            byte[] pbEncoded,
            uint cbEncoded,
            uint flags,
            [In, Out] byte[] pvStructInfo,
            ref uint cbStructInfo);
    }

    /// <summary>
    /// Provides conversions of big- and little-endian byte arrays to little-endian built-in types
    /// </summary>
    public static class ConvertEx
    {
        public static byte[] SubArray(byte[] source, int index)
        {
            return ArrayEx.GetSubArray(source, index);
        }

        public static byte[] SubArray(byte[] source, int index, int count)
        {
            return ArrayEx.GetSubArray(source, index, count);
        }

        public static uint LEByteArrayToLEUInt(byte[] source)
        {
            if (source.Length != 4)
            {
                throw new IndexOutOfRangeException();
            }
            return (uint)source[3] << 24 | (uint)source[2] << 16 | (uint)source[1] << 8 | (uint)source[0];
        }

        public static ulong LEByteArrayToLEULong(byte[] source)
        {
            if (source.Length != 8)
            {
                throw new IndexOutOfRangeException();
            }
            return (ulong)LEByteArrayToLEUInt(SubArray(source, 0, 4)) << 32 |
                   LEByteArrayToLEUInt(SubArray(source, 4, 4));
        }

        public static ulong[] LEByteArrayToLEULongArray(byte[] source)
        {
            if (source.Length % 8 != 0)
            {
                throw new IndexOutOfRangeException();
            }
            int count = source.Length / 8;
            ulong[] dest = new ulong[count];

            for (int i = 0; i < count; i++)
            {
                dest[i] = LEByteArrayToLEULong(SubArray(source, i * 8, 8));
            }
            return dest;
        }

        /// <summary>
        /// Converts a big-endian 4 byte array to a little-endian 32-bit uint
        /// </summary>
        /// <param name="source">Big-endian 4 byte array</param>
        /// <returns>Little-endian 32-bit uint</returns>
        public static uint BEByteArrayToLEUInt(byte[] source)
        {
            return LEByteArrayToLEUInt(ArrayEx.Reverse(source));
        }

        /// <summary>
        /// Converts a big-endian 8 byte array to a little-endian 64-bit ulong
        /// </summary>
        /// <param name="source">Big-endian 8 byte array</param>
        /// <returns>Little-endian 64-bit ulong</returns>
        public static ulong BEByteArrayToLEULong(byte[] source)
        {
            return LEByteArrayToLEULong(ArrayEx.Reverse(source));
        }

        /// <summary>
        /// Converts a big-endian byte array to a little-endian 64-bit ulong array
        /// </summary>
        /// <param name="source">Big-endian byte array</param>
        /// <returns>Little-endian 64-bit ulong array</returns>
        public static ulong[] BEByteArrayToLEULongArray(byte[] source)
        {
            if (source.Length % 8 != 0)
            {
                throw new IndexOutOfRangeException();
            }
            int count = source.Length / 8;
            ulong[] dest = new ulong[count];

            for (int i = 0; i < count; i++)
            {
                dest[i] = BEByteArrayToLEULong(SubArray(source, i * 8, 8));
            }
            return dest;
        }
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct PUBKEYBLOBHEADERS
    {
        public byte bType;   //BLOBHEADER
        public byte bVersion;   //BLOBHEADER
        public ushort reserved;   //BLOBHEADER
        public uint aiKeyAlg;   //BLOBHEADER
        public uint magic;   //RSAPUBKEY
        public uint bitlen;   //RSAPUBKEY
        public uint pubexp;   //RSAPUBKEY

        public string GetDumpString()
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("btype\t" + bType);
            sb.AppendLine("bversion\t" + bVersion);
            sb.AppendLine("reserved\t" + reserved);
            sb.AppendLine("aiKeyAlg\t0x" + aiKeyAlg.ToString("X8"));
            String magicstring = (new ASCIIEncoding()).GetString(BitConverter.GetBytes(magic));
            sb.AppendLine("magic\t0x" + magic.ToString("X8") + "\t'" + magicstring + "'");
            sb.AppendLine("bitlen\t" + bitlen);
            sb.AppendLine("pubexp\t" + pubexp);
            return sb.ToString();
        }
    }

    public class CspImport
    {
        public PUBKEYBLOBHEADERS headers = new PUBKEYBLOBHEADERS();
        public ulong[] modulus = new ulong[32];

        public void Load(byte[] key)
        {
            headers.bType = key[0];
            headers.bVersion = key[1];
            headers.reserved = (ushort)((ushort)key[2] << 8 | key[3]);
            headers.aiKeyAlg = ConvertEx.LEByteArrayToLEUInt(ConvertEx.SubArray(key, 4, 4));
            headers.magic = ConvertEx.LEByteArrayToLEUInt(ConvertEx.SubArray(key, 8, 4));
            headers.bitlen = ConvertEx.LEByteArrayToLEUInt(ConvertEx.SubArray(key, 12, 4));
            headers.pubexp = ConvertEx.LEByteArrayToLEUInt(ConvertEx.SubArray(key, 16, 4));
            modulus = ConvertEx.LEByteArrayToLEULongArray(ConvertEx.SubArray(key, 20));
        }
    }

    public class CryptoHelper
    {
        const uint X509_ASN_ENCODING = 0x00000001;
        const uint PKCS_7_ASN_ENCODING  = 0x00010000;
        const uint ENCODING_TYPE = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
        const uint RSA_CSP_PUBLICKEYBLOB = 19;

        public static byte[] GetCertPublicKey(X509Certificate2 cert)
        {
            byte[] encodedpubkey = cert.GetPublicKey(); // ASN.1 encoded public key
            byte[] publickeyblob;
            uint blobbytes = 0;
            if (Win32.CryptDecodeObject(ENCODING_TYPE, RSA_CSP_PUBLICKEYBLOB,
                encodedpubkey, (uint)encodedpubkey.Length, 0, null, ref blobbytes))
            {
                publickeyblob = new byte[blobbytes];
                Win32.CryptDecodeObject(ENCODING_TYPE, RSA_CSP_PUBLICKEYBLOB,
                    encodedpubkey, (uint)encodedpubkey.Length, 0, publickeyblob, ref blobbytes);
            }
            else
            {
                Global.RO.Error("Couldn't decode publickeyblob from certificate publickey");
                return null;
            }

            PUBKEYBLOBHEADERS pkheaders = new PUBKEYBLOBHEADERS();
            int headerslength = Marshal.SizeOf(pkheaders);
            IntPtr buffer = Marshal.AllocHGlobal(headerslength);
            Marshal.Copy(publickeyblob, 0, buffer, headerslength);
            pkheaders = (PUBKEYBLOBHEADERS)Marshal.PtrToStructure(buffer, typeof(PUBKEYBLOBHEADERS));
            Marshal.FreeHGlobal(buffer);

            // Get public key size in bits
            uint certkeysize = pkheaders.bitlen;

            // Get public exponent
            byte[] exponent = BitConverter.GetBytes(pkheaders.pubexp); // Little-endian ordered
            Array.Reverse(exponent);    // Convert to big-endian order
            byte[] certkeyexponent = exponent;

            // Get modulus
            int modulusbytes = (int)pkheaders.bitlen / 8;
            byte[] modulus = new byte[modulusbytes];
            try
            {
                Array.Copy(publickeyblob, headerslength, modulus, 0, modulusbytes);
                Array.Reverse(modulus);   // Convert from little to big-endian ordering.
            }
            catch (Exception)
            {
                Console.WriteLine("Problem getting modulus from publickeyblob");
                return null;
            }
            return publickeyblob;
        }
    }

    public class RSA2048Header
    {
        public uint cqw = 0;
        public uint dwPubExp = 0;
        public ulong qwReserved = 0;
    }

    public abstract class RSAPub2048Key
    {
        public RSA2048Header RsaHeader = new RSA2048Header();
        public ulong[] aqwM = new ulong[32];

        public abstract void Load(byte[] key);

        public override bool Equals(object obj)
        {
            // null values are unequal to this
            if (obj == null)
            {
                return false;
            }

            // Inconvertible objects are unequal to this
            RSAPub2048Key rhsKey = obj as RSAPub2048Key;
            if ((object)rhsKey == null)
            {
                return false;
            }

            // Compare qword counts, exponents, and NOT reserved
            if (this.RsaHeader.cqw != rhsKey.RsaHeader.cqw ||
                this.RsaHeader.dwPubExp != rhsKey.RsaHeader.dwPubExp)
            {
                return false;
            }
            // Compare moduli
            if (!ArrayEx.Compare(this.aqwM, rhsKey.aqwM))
            {
                return false;
            }
            return true;
        }

        public override int GetHashCode()
        {
            return (int)aqwM[0];
        }
    }

    public class ConsoleRSAPub2048Key : RSAPub2048Key
    {
        public override void Load(byte[] key)
        {
            RsaHeader.cqw = ConvertEx.BEByteArrayToLEUInt(ConvertEx.SubArray(key, 0, 4));
            RsaHeader.dwPubExp = ConvertEx.BEByteArrayToLEUInt(ConvertEx.SubArray(key, 4, 4));
            RsaHeader.qwReserved = ConvertEx.BEByteArrayToLEULong(ConvertEx.SubArray(key, 8, 8));
            aqwM = ConvertEx.BEByteArrayToLEULongArray(ConvertEx.SubArray(key, 16));
        }
    }

    public class ServerRSAPub2048Key : RSAPub2048Key
    {
        /// <summary>
        /// Creates an RSAPub2048Key derived from an X509Certificate2 public key
        /// </summary>
        /// <param name="key">Decoded X509Certificate2 public key</param>
        public override void Load(byte[] key)
        {
            CspImport cspImport = new CspImport();
            cspImport.Load(key);

            RsaHeader.cqw = (uint)cspImport.modulus.Length;
            RsaHeader.dwPubExp = cspImport.headers.pubexp;
            RsaHeader.qwReserved = 0;
            aqwM = cspImport.modulus;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\Carbon\CarbonUtils.cs ===
using System;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.Utilities;
using xonline.common.protocol;

namespace SigTest.Carbon
{
    public class Utils
    {
        /// <summary>
        /// Carbon server GUIDs are generated based on a console's ID using this format:
        /// 
        /// Xbox Live Signature     Padding		    Console-ID (‘XE.DDDDDDDDDDDC’)
        /// 4 bytes			        4 bytes		    8 Bytes
        /// 09201997		        0000-0000	    0000-DDDDDDDDDDDC
        /// 
        /// Ex: A console ID of "XE.548311350326" results in
        /// the GUID: {09201997-0000-0000-0000-548311340326}.
        /// </summary>
        public static string SerialNumberToGuid(string serialNumber)
        {
            if (serialNumber.Length != "XE.DDDDDDDDDDDC".Length)
            {
                throw new UnexpectedTestResultException("serialNumber (" + serialNumber +
                    ") is not in XE.DDDDDDDDDDDC format");
            }
            if (!serialNumber.StartsWith("XE."))
            {
                throw new UnexpectedTestResultException("serialNumber (" + serialNumber +
                    ") does not begin with \"XE.\"");
            }
            // Remove leading "XE."
            serialNumber = serialNumber.Substring(3);
            // Format it as a GUID string
            serialNumber = "09201997-0000-0000-0000-" + serialNumber;
            return serialNumber;
        }
        
        /// <summary>
        /// Clone the provided key
        /// </summary>
        /// <returns>A copy of the cloned key</returns>
        public static byte[] CloneKey(byte[] key)
        {
            byte[] clone = new byte[XRLXmstvCreateCertificate.RSAPUB_2048_SIZE];
            key.CopyTo(clone, 0);
            return clone;
        }

        //generates a valid keyed hash from a given request
        public static byte[] GenerateKeyedHash(XmstvCreateCertificateRequest request)
        {
            //first get the (endian-corrected) bytes for the portion of the request used for this
            List<byte> requestBytes = new List<byte>();
            requestBytes.AddRange(ConvertPrimitive(request.Flags, BitConverter.GetBytes));
            requestBytes.AddRange(request.AvPubKey);
            requestBytes.AddRange(request.NonAvPubKey);
            requestBytes.AddRange(ConvertPrimitive(request.KeyNonce, BitConverter.GetBytes));
            byte[] origBytes = requestBytes.ToArray();

            //compute the SHA1 hash of the bytes
            byte[] digest = new SHA1Managed().ComputeHash(origBytes);
            return digest;

            //TODO: Take into account the Primary Actvitanion Key encrypted portion.

            /*byte[] hash = new byte[XRLMSTVCreateCertificateRequest.SHA_DIGEST_SIZE];
            random.NextBytes(hash);
            return hash;*/
        }

        //copied from dev code - the intent looks to be to take a value and reverse the endianness order
        private static byte[] ConvertPrimitive<T>(T prim, Converter<T, byte[]> converter)
        {
            byte[] bytes = converter(prim);
            Array.Reverse(bytes);
            return bytes;
        }

        /// <summary>
        /// A set of ChainStatus flags that will be ignored during validation.  
        /// This is useful for stress tests where certificates required to 
        /// validate the response are not installed, or small timing issues 
        /// cause verification to fail.
        /// </summary>
        public static X509ChainStatusFlags ChainFlagsToIgnore = X509ChainStatusFlags.NotTimeValid;

        public static void VerifyCertificate(string serialNumber, byte[] requestKey, X509Certificate2 cert)
        {
            X509Chain chain = new X509Chain();

            // Check entire chain for revocation
            chain.ChainPolicy.RevocationFlag = X509RevocationFlag.EndCertificateOnly;
            // Check revocation lists online
            chain.ChainPolicy.RevocationMode = X509RevocationMode.NoCheck;
            // No exceptions, check all properties
            chain.ChainPolicy.VerificationFlags = X509VerificationFlags.NoFlag;

            chain.Build(cert);

            for (int i = 0; i < chain.ChainStatus.Length; i++)
            {
                //remove the flags that we know are OK and/or expected
                X509ChainStatusFlags currFlags = chain.ChainStatus[i].Status;
                currFlags &= ~ChainFlagsToIgnore;

                if (currFlags != X509ChainStatusFlags.NoError)
                {
                    throw new UnexpectedTestResultException(String.Format("Unexpected flags in chain (index {0}) status: {1}", i, currFlags));
                }
            }

            // NotBefore: {3/9/2007 2:46:27 AM}
            DateTime notBefore = cert.NotBefore;
            DateTime now = DateTime.Now;
            TimeSpan delta = now - notBefore;
            if (delta.Duration().Minutes > 5)
            {
                throw new UnexpectedTestResultException("Cert NotBefore timestamp (" +
                    cert.NotBefore.ToString() + ") was not within 5 mins of Now (" +
                    now.ToString() + ")");
            }

            // NotAfter: {3/9/2017 2:46:27 AM}
            if (cert.NotAfter != notBefore.AddYears(10))
            {
                throw new UnexpectedTestResultException("Cert NotAfter timestamp (" +
                    cert.NotAfter.ToString() + ") was not exactly 10 years ahead of NotBefore (" +
                    cert.NotBefore.ToString() + ")");
            }

            // Issuer:     "CN=Test Xbox Sub-CA 006, O=006, C=US"
            if (cert.Issuer != "CN=Test Xbox Sub-CA 006, O=006, C=US")
            {
                throw new UnexpectedTestResultException("Cert Issuer (" +
                    cert.Issuer + ") not equal to CN=Test Xbox Sub-CA 006, O=006, C=US");
            }

            // Subject:     "C=US, O=006, OU=Client Authentication, 
            //               CN=97192009-0000-0000-a031-48a66e0000f0, SN=XE.297022594820"
            string[] subjectParts = cert.Subject.Split(',');
            foreach (string part in subjectParts)
            {
                string[] elems = part.Split('=');
                switch (elems[0].Trim())
                {
                    case "C":
                        if (elems[1].Trim() != "US")
                        {
                            throw new UnexpectedTestResultException("C != US; cert.Subject:" +
                                cert.Subject);
                        }
                        break;
                    case "O":
                        if (elems[1].Trim() != "006")
                        {
                            throw new UnexpectedTestResultException("O != 006; cert.Subject:" +
                                cert.Subject);
                        }
                        break;
                    case "OU":
                        if (elems[1].Trim() != "Client Authentication")
                        {
                            throw new UnexpectedTestResultException(
                                "OU != Client Authentication; cert.Subject:" +
                                cert.Subject);
                        }
                        break;
                    case "CN":
                        if (elems[1].Trim() != Utils.SerialNumberToGuid(serialNumber))
                        {
                            throw new UnexpectedTestResultException(
                                "CN != " + Utils.SerialNumberToGuid(serialNumber) + "; cert.Subject:" +
                                cert.Subject);
                        }
                        break;
                    case "SN":
                        if (elems[1].Trim() != serialNumber)
                        {
                            throw new UnexpectedTestResultException("SN != " + serialNumber +
                                "; cert.Subject:" + cert.Subject);
                        }
                        break;
                    default:
                        throw new UnexpectedTestResultException("Unknown certificate subject element: " +
                            elems[0].Trim() + " == " + elems[1].Trim() + "; cert.Subject:" +
                            cert.Subject);
                }
            }

            // Break open the console's public key
            ConsoleRSAPub2048Key consoleKey = new ConsoleRSAPub2048Key();
            consoleKey.Load(requestKey);

            // Convert the response certificate's public key into a comparable format
            ServerRSAPub2048Key serverKey = new ServerRSAPub2048Key();
            byte[] pubkey = CryptoHelper.GetCertPublicKey(cert);
            serverKey.Load(pubkey);

            if (!consoleKey.Equals(serverKey))
            {
                throw new UnexpectedTestResultException("Certificate response key does not match request key");
            }
        }
    }

    public class XMSTVCreateCertificateHelper
    {
        private static readonly byte[] Key = Hexer.unhex("00000020000100010000000000000000ECA1D8681FC1E539F03FEAE24BD3D4CECCE1F30A44A9FDC5968E209BA7E0589B485B82342144A8B3F1F40F237E921F2504306DA007DBDE53BEAD9A56DFF108088FBD2D89DADCB14BD94554893C338B8A04882135DA7DAF8B9082F5580531E3D3DA471D16BEA3539FF252F8730FA0B45F636F5C76129D5633BCBAB859DEDE249CCFDB50986690AC3A63AC4A38009465FA33B9D1FD1CF6BB796326B3335C3C66DDCC84EF7B4F00544AA46C368845C27BD397702D22AD6352F0CD09FC348775C2D95461FD1A2F518A371A642B16A49BDE2103EA245E5555FD85E0A6854B4088B6390C6E4CF88CB85D07C4F716DAA09227ADB7EF46D5BC266B96A873E8DDC37F1929");

        private MachineEditor machine;

        private XRLXmstvCreateCertificate xrl;
        public XRLXmstvCreateCertificate Xrl
        {
            get { return xrl; }
        }

        /// <summary>
        /// Convenience accessor for the internal xrl request object
        /// </summary>
        public XmstvCreateCertificateRequest Request
        {
            get { return xrl.Request; }
        }

        /// <summary>
        /// Convenience accessor for the internal xrl response object
        /// </summary>
        public XmstvCreateCertificateResponse Response
        {
            get { return xrl.Response; }
        }
                
        public uint ExpectedXErr = HResult.S_OK;

        public XMSTVCreateCertificateHelper()
        {
            Reset();
        }

        /// <summary>
        /// Resets the request object to the standard starting state
        /// </summary>
        public void Reset()
        {
            if (xrl == null)
            {
                xrl = new XRLXmstvCreateCertificate();
            }
            xrl.Request.Flags = 0;
            xrl.Request.AvPubKey = Utils.CloneKey(Key);
            xrl.Request.NonAvPubKey = Utils.CloneKey(Key);
            xrl.Request.KeyNonce = RandomEx.GlobalRandGen.NextUlong();
            xrl.Slot = ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.FakeSG.GetSlot();
            RecalcValidKeyedHash();
        }

        /// <summary>
        /// regenerates KeyedHash (which is based on the Request bytes) to be a valid value
        /// </summary>
        public void RecalcValidKeyedHash()
        {
            xrl.Request.KeyedHash = Utils.GenerateKeyedHash(xrl.Request);
        }

        /// <summary>
        /// Execute the positive test path and verify the response
        /// </summary>
        public void ExecutePositive()
        {
            machine = MachineEditor.CreateNew(MachineType.Xbox360);
            ExecutePositive(true, machine);
        }

        /// <summary>
        /// Execute the positive test path and optionally verify the response
        /// </summary>
        /// <param name="verifyResponse">If true, the response will be verified</param>
        public void ExecutePositive(bool verifyResponse, MachineEditor machine)
        {
            xrl.Slot.machinePuid = machine.Id;
            if (xrl.Execute())
            {
                if (verifyResponse)
                {
                    VerifyResponse(machine);
                }
            }
            else
            {
                String errorMsg = "XRLMSTVCreateCertificateRequest.Execute() failed: " +
                    xrl.GetDumpString();
                Global.RO.Error(errorMsg);

                throw new UnexpectedTestResultException(errorMsg);
            }
        }

        public void ExecuteNegative()
        {
            MachineEditor machine = MachineEditor.CreateNew(MachineType.Xbox360);
            xrl.Slot.machinePuid = machine.Id; //TODO: make this optional for future negative cases
            if (!xrl.Execute())
            {
                if (xrl.XErr == ExpectedXErr)
                {
                    Global.RO.Debug("Got expected error: " + Global.XErrToString(ExpectedXErr));
                }
                else
                {
                    String errorMsg = String.Format("Expected: {0}; Got: {1}",
                        Global.XErrToString(ExpectedXErr), Global.XErrToString(xrl.XErr));
                    Global.RO.Error("XRLMSTVCreateCertificate.Execute() failed with wrong error");
                    Global.RO.Error(errorMsg);
                    Global.RO.Error(xrl.GetDumpString());

                    throw new UnexpectedTestResultException(errorMsg + '\n' + xrl.GetDumpString());
                }
            }
            else
            {
                Global.RO.Error("XRLMSTVCreateCertificateRequest.Execute() succeeded unexpectedly");
            }
        }

        public void VerifyResponse(MachineEditor machine)
        {
            XmstvCreateCertificateResponse Response = xrl.Response;

            // Validate the response
            if (Response == null)
            {
                throw new UnexpectedTestResultException("Response == null");
            }

            //Xenon bug #87983 - "Fix response service ID for XmstvCreateService.asph"
            Dictionary<string, string> header = xrl.xAct.GetHeader();
            string contentType;
            if (!header.TryGetValue("Content-Type", out contentType))
            {
                throw new UnexpectedTestResultException("ContentType not found in response header");
            }
            // ContentType value is in the form of "xon/5" (example for User_Account)
            if (contentType.ToLower() != "xon/c")
            {
                throw new UnexpectedTestResultException("ContentType contained invalid service ID: " +
                    contentType);
            }

            // Validate AvCertificate
            if (Response.AvCertificateSize == 0)
            {
                throw new UnexpectedTestResultException("Response.AvCertificateSize == 0");
            }
            if (Response.AvCertificate == null)
            {
                throw new UnexpectedTestResultException("Response.AvCertificate == null");
            }
            if (Response.AvCertificate.Length != Response.AvCertificateSize)
            {
                throw new UnexpectedTestResultException("Response.AvCertificate.Length != Response.AvCertificateSize");
            }

            X509Certificate2 avCert = new X509Certificate2(Response.AvCertificate);
            Utils.VerifyCertificate(machine.ConsoleId, xrl.Request.AvPubKey, avCert);
            Global.RO.Debug("AvPubKey passed validation");

            // Validate NonAvCertificate
            if (Response.NonAvCertificateSize == 0)
            {
                throw new UnexpectedTestResultException("Response.NonAvCertificateSize == 0");
            }
            if (Response.NonAvCertificate == null)
            {
                throw new UnexpectedTestResultException("Response.NonAvCertificate == null");
            }
            if (Response.NonAvCertificate.Length != Response.NonAvCertificateSize)
            {
                throw new UnexpectedTestResultException("Response.NonAvCertificate.Length != Response.NonAvCertificateSize");
            }

            // Create and verify the cert
            X509Certificate2 nonAvCert = new X509Certificate2(Response.NonAvCertificate);
            Utils.VerifyCertificate(machine.ConsoleId, xrl.Request.NonAvPubKey, nonAvCert);
            Global.RO.Debug("NonAvPubKey passed validation");

            bool validExtensions = true;
            // Check for AV Specific Extensions
            // Should find the MSTVAV Extension and Should not find the Client Auth Extension
            if(!CertHelper.CheckForExtension(avCert, "1.3.6.1.4.1.311.53.1.1.2") ||
                CertHelper.CheckForExtension(avCert, "1.3.6.1.5.5.7.3.2"))
            {
                validExtensions = false;
                Global.RO.Error("Extensions error with AV Cert:");
                CertHelper.DumpExtensions(avCert);
            }

            // Check for NonAv Specific Extensions
            // Should find client auth extension and Should not find MSTVAV extension 
            if (!CertHelper.CheckForExtension(nonAvCert, "1.3.6.1.5.5.7.3.2") ||
                CertHelper.CheckForExtension(nonAvCert, "1.3.6.1.4.1.311.53.1.1.2"))
            {
                validExtensions = false;
                Global.RO.Error("Extensions error with NonAV Cert:");
                CertHelper.DumpExtensions(nonAvCert);
            }

            if (!validExtensions)
            {                
                throw new UnexpectedTestResultException("There was an error with the extensions on the returned certs.  See log for more details.");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\Carbon\CreateCertificate.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;


namespace SigTest.Carbon.Functional
{
    [TestGroup, Owner("BenRan"), TestFrequency("Regression")]
    [AsyncGroup(2, 1)]
    public class Carbon
    {
        [TestGroup, Description("Test cases for Carbon XMSTVCreateCertificate API")]
        public class CreateCertificate : TestNode
        {
            public XMSTVCreateCertificateHelper requestHelper;

            public override void OneTimeSetup()
            {
                requestHelper = new XMSTVCreateCertificateHelper();
            }

            [TestCase, TestCasePriority(1), Description("The typical mainline case that exposes most options")]
            public void P_Mainline()
            {
                requestHelper.Reset();
                requestHelper.ExecutePositive();
            }

            [TestCase, TestCasePriority(2), Description("KeyNonce set to 0 (ulong.Min)")]
            public void P_KeyNonce_Min()
            {
                requestHelper.Reset();
                requestHelper.Request.KeyNonce = ulong.MinValue;
                requestHelper.RecalcValidKeyedHash();
                requestHelper.ExecutePositive();
            }

            [TestCase, TestCasePriority(2), Description("KeyNonce set to 4,294,967,296 (ulong.Max)")]
            public void P_KeyNonce_Max()
            {
                requestHelper.Reset();
                requestHelper.Request.KeyNonce = ulong.MaxValue;
                requestHelper.RecalcValidKeyedHash();
                requestHelper.ExecutePositive();
            }

            [TestCase, TestCasePriority(2), Description("Invalid (random data) AVPubKey")]
            public void N_AVPubKey_Invalid()
            {
                requestHelper.Reset();
                for (int i = 0; i < requestHelper.Request.AvPubKey.Length; i++)
                {
                    requestHelper.Request.AvPubKey[i] = (byte)RandomEx.GlobalRandGen.Next(byte.MinValue, byte.MaxValue + 1);
                }
                requestHelper.RecalcValidKeyedHash();
                requestHelper.ExpectedXErr= HResult.XONLINE_E_INVALID_REQUEST;
                requestHelper.ExecuteNegative();
            }

            [TestCase, TestCasePriority(2), Description("Invalid (random data) NonAVPubKey")]
            public void N_NonAVPubKey_Invalid()
            {
                requestHelper.Reset();
                for (int i = 0; i < requestHelper.Request.NonAvPubKey.Length; i++)
                {
                    requestHelper.Request.NonAvPubKey[i] = (byte)RandomEx.GlobalRandGen.Next(byte.MinValue, byte.MaxValue + 1);
                }
                requestHelper.RecalcValidKeyedHash();
                requestHelper.ExpectedXErr= HResult.XONLINE_E_INVALID_REQUEST;
                requestHelper.ExecuteNegative();
            }

            [TestCase, TestCasePriority(3), Description("All elements of KeyedHash set to byte.MinValue")]
            public void N_KeyedHash_Min()
            {
                requestHelper.Reset();
                for (int i = 0; i < requestHelper.Request.KeyedHash.Length; i++)
                {
                    requestHelper.Request.KeyedHash[i] = byte.MinValue;
                }
                requestHelper.ExpectedXErr= HResult.E_ACCESSDENIED;
                requestHelper.ExecuteNegative();
            }

            [TestCase, TestCasePriority(3), Description("All elements of KeyedHash set to byte.MaxValue")]
            public void N_KeyedHash_Max()
            {
                requestHelper.Reset();
                for (int i = 0; i < requestHelper.Request.KeyedHash.Length; i++)
                {
                    requestHelper.Request.KeyedHash[i] = byte.MaxValue;
                }
                requestHelper.ExpectedXErr= HResult.E_ACCESSDENIED;
                requestHelper.ExecuteNegative();
            }

            [TestCase, TestCasePriority(2), Description("One element of KeyedHash set to a different value")]
            public void N_KeyedHash_Invalid()
            {
                requestHelper.Reset();
                RandomEx.GlobalRandGen.NextBytes(requestHelper.Request.KeyedHash);
                requestHelper.ExpectedXErr= HResult.E_ACCESSDENIED;
                requestHelper.ExecuteNegative();
            }

            [TestCase, TestCasePriority(2), Description("All elements of KeyedHash set to random values")]
            public void N_KeyedHash_Random()
            {
                requestHelper.Reset();
                for (int i = 0; i < requestHelper.Request.KeyedHash.Length; i++)
                {
                    requestHelper.Request.KeyedHash[i] = (byte)RandomEx.GlobalRandGen.Next(byte.MinValue, byte.MaxValue + 1);
                }
                requestHelper.ExpectedXErr= HResult.E_ACCESSDENIED;
                requestHelper.ExecuteNegative();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\SigUtils.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.Billing.License;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;

using xonline.common.protocol;

using OfferExpectedPrice = ServerTestFramework.LiveService.Billing.OfferExpectedPrice;
using OfferMediaTypeExpectedPrice = ServerTestFramework.LiveService.Billing.OfferMediaTypeExpectedPrice;

namespace SigTest
{
    /// <summary>
    /// Represents a Certificate Public Key
    /// </summary>
    public class RsaKeyBlob
    {
        /// <summary>
        /// Client Key structure
        /// </summary>
        [StructLayout(LayoutKind.Sequential, Pack=1)]
        public struct XECRYPT_RSAPUB_2048
        {
            /// <summary>
            /// Number of QWORD digits in modulus
            /// </summary>
            public Int32 cqw;
            /// <summary>
            /// Public exponent
            /// </summary>
            public Int32 dwPubExp;
            /// <summary>
            /// Reserved (was qwMI)
            /// </summary>
            public Int64 qwReserved;
            /// <summary>
            /// [BnQwNe] Modulus (32 QWORDS)
            /// </summary>
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
            public Int64[] aqwM;

            public XECRYPT_RSAPUB_2048(byte[] pubExp, byte[] modulus)
            {
                // This is hardcoded to 32 for now
                cqw = IPAddress.NetworkToHostOrder(32);

                // The exponent we get is only 3 bytes long usually
                if (pubExp.Length < 4)
                {
                    Array.Resize(ref pubExp, 4);
                }
                dwPubExp = IPAddress.NetworkToHostOrder(BitConverter.ToInt32(pubExp, 0));

                qwReserved = IPAddress.NetworkToHostOrder(0);

                aqwM = new Int64[32];
                for (int i = 0; i < 32; i++)
                {
                    //aqwM[i] = IPAddress.NetworkToHostOrder(BitConverter.ToInt64(modulus, i * 8));
                    // So basically, since the console is big endian, the certificate it gets
                    // has to have the certificate with the public key is big endian format.  If
                    // we get the cert in this format, we can't just swap it because it breaks the
                    // encryption.  So, we DON'T swap the endian here, so that the cert we get back
                    // has the key in the format we expect.
                    aqwM[31-i] = BitConverter.ToInt64(modulus, i * 8);
                }
            }

            public byte[] GetBytes()
            {
                int size = Marshal.SizeOf(typeof(XECRYPT_RSAPUB_2048));
                MemoryStream stream = new MemoryStream(size);
                BinaryWriter writer = new BinaryWriter(stream);
                writer.Write(cqw);
                writer.Write(dwPubExp);
                writer.Write(qwReserved);
                foreach (Int64 qwM in aqwM)
                {
                    writer.Write(qwM);
                }

                Byte[] buffer = stream.GetBuffer();
                writer.Close();

                return buffer;
            }

            public static XECRYPT_RSAPUB_2048 FromBytes(byte[] bytes)
            {
                MemoryStream stream = new MemoryStream(bytes);
                BinaryReader reader = new BinaryReader(stream);

                XECRYPT_RSAPUB_2048 key;

                key.cqw = reader.ReadInt32();
                key.dwPubExp = reader.ReadInt32();
                key.qwReserved = reader.ReadInt64();

                int length = IPAddress.HostToNetworkOrder(key.cqw);
                if(length != 32)
                {
                    throw new InvalidOperationException("Invalid modulus length");
                }
                key.aqwM = new Int64[length];
                for (int i = 0; i < length; i++)
                {
                    key.aqwM[i] = reader.ReadInt64();
                }
                reader.Close();

                return key;
            }

            public static XECRYPT_RSAPUB_2048 Generate(byte[] pubExp, byte[] modulus)
            {
                return new XECRYPT_RSAPUB_2048(pubExp, modulus);
            }

            public static XECRYPT_RSAPUB_2048 GenerateRandom()
            {
                Byte[] pubExp = new Byte[4];
                Byte[] modulus = new Byte[256]; // 32(Blocks)*8(Bytes) = 256(Bytes) = 2048 Bits

                RandomEx.GlobalRandGen.NextBytes(pubExp);
                RandomEx.GlobalRandGen.NextBytes(modulus);

                return new XECRYPT_RSAPUB_2048(pubExp, modulus);
            }
        }
            
        /// <summary>
        /// Internal format used for key generation
        /// </summary>
        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        public struct KEYHEADER
        {
            /// <summary>
            /// _PUBLICKEYSTRUC
            /// </summary>
            [StructLayout(LayoutKind.Sequential, Pack=1)]
            public struct BLOBHEADER
            {
                public Byte bType;
                public Byte bVersion;
                public UInt16 reserved;
                public UInt32 aiKeyAlg;
            }

            /// <summary>
            /// _RSAPUBKEY
            /// </summary>
            [StructLayout(LayoutKind.Sequential, Pack=1)]
            public struct RSAPUBKEY
            {
                public UInt32 magic;                  // Has to be RSA1
                public UInt32 bitlen;                 // # of bits in modulus
                public UInt32 pubexp;                 // public exponent
            }

            public BLOBHEADER blob;
            public RSAPUBKEY rsa;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
            public UInt64[] aqwM;

            public static KEYHEADER FromConsoleKeyBlob(byte[] blob)
            {
                KEYHEADER keyHeader = new KEYHEADER();
                // Setting to values obtained from WinCrypt.h
                keyHeader.blob.bType = 0x6; // PUBLICKEYBLOB;
                keyHeader.blob.bVersion = 2; // CUR_BLOB_VERSION;
                keyHeader.blob.reserved = 0;
                keyHeader.blob.aiKeyAlg = 0xFF; // Garbage until we figure a reason we need this

                MemoryStream stream = new MemoryStream(blob);
                BinaryReader reader = new BinaryReader(stream);

                keyHeader.rsa.magic = 0x31415352; // #define RSA_PUB_MAGIC

                Int32 modulusLength = IPAddress.HostToNetworkOrder(reader.ReadInt32());
                keyHeader.rsa.bitlen = (uint)modulusLength * 64;
                keyHeader.rsa.pubexp = (UInt32)IPAddress.HostToNetworkOrder(reader.ReadInt32());
                Int64 reserved = IPAddress.HostToNetworkOrder(reader.ReadInt64()); // Ignoring this
                
                keyHeader.aqwM = new UInt64[modulusLength];
                for (int i = 0; i < modulusLength; i++)
                {
                    keyHeader.aqwM[i] = (UInt64)IPAddress.HostToNetworkOrder(reader.ReadInt64());
                }

                return keyHeader;
            }
        }

        public RSACryptoServiceProvider serviceProvider;
        private RSAParameters rsaParams;

        private XECRYPT_RSAPUB_2048 consolePublicKeyBlob;
        public XECRYPT_RSAPUB_2048 ConsolePublicKeyBlob
        {
            get
            {
                return consolePublicKeyBlob;
            }
        }

        public RsaKeyBlob()
        {
            serviceProvider = new RSACryptoServiceProvider(2048);
            rsaParams = serviceProvider.ExportParameters(true);

            consolePublicKeyBlob = new XECRYPT_RSAPUB_2048(rsaParams.Exponent, rsaParams.Modulus);
        }

        public RsaKeyBlob(byte[] srcBytes)
        {
            serviceProvider = new RSACryptoServiceProvider(2048);
            serviceProvider.ImportCspBlob(srcBytes);
            rsaParams = serviceProvider.ExportParameters(false);
        }
    }

    /// <summary>
    /// Used to create and track the state of a certificate request
    /// </summary>
    public class CertState
    {
        public static readonly string DefaultAppId = "generic_ssl";

        public ulong MachineId = 0;
        public string ConsoleId = "";
        public ulong UserPuid = 0;

        public byte[] PublicKey = new byte[CreateCertificateRequest.RSAPUB_2048_SIZE];

        public string AppId = "";

        public RsaKeyBlob keyBlob;

        /// <summary>
        /// Generates a new CertState with a new xenon machine, user, and valid request data
        /// and the default AppID
        /// </summary>
        /// <returns>A new CertState object</returns>
        public static CertState Create()
        {
            return Create(DefaultAppId, true, true);
        }

        /// <summary>
        /// Generates a new CertState with a new xenon machine, user, and valid request data
        /// and the given AppID
        /// </summary>
        /// <param name="appId">The app id to use in the request</param>
        /// <returns>A new CertState object</returns>
        public static CertState Create(string appId)
        {
            return Create(appId, true, true);
        }

        /// <summary>
        /// Generates a new CertState with valid request data and a given AppId.
        /// Optionally initailizes a new xenon machine, user, and valid 
        /// </summary>
        /// <returns>A new CertState object</returns>
        /// <remarks>
        /// No validation is done on the input parameters to allow invalid values 
        /// for negative test cases.
        /// </remarks>
        public static CertState Create(string appId, bool createMachine, bool createUser)
        {
            CertState cs = new CertState(appId);

            if (createMachine)
            {
                XmacsClient xmacs = SignatureUtils.CreateClient();
                cs.MachineId = xmacs.GetMachinePuid();
                cs.ConsoleId = xmacs.ConsoleId;
            }

            if (createUser)
            {
                UserEditor user = UserEditor.CreateNew();
                cs.UserPuid = user.Puid;
            }

            return cs;
        }
        
        public static CertState CreateOscar()
        {
            return Create("Oscar", true, true);
        }

        public static CertState CreateOscar(bool createMachine, bool createUser)
        {
            return Create("Oscar", createMachine, createUser);
        }

        public CertState(String appId)
        {
            this.AppId = appId;

            // We need to provide some additional information to RsaKeyBlob beore we can use
            // it to produce ConsolePublicKeys
            this.keyBlob = new RsaKeyBlob();
            this.PublicKey = this.keyBlob.ConsolePublicKeyBlob.GetBytes();

            //TODO: temp.. use a known valid one until we have a way to generate our own
            //      Also, this is valid for Oscar, but I don't know if it's valid for 
            //      other appIds
            //cs.PublicKey = System.IO.File.ReadAllBytes("SuitesData\\Signature\\Oscar\\example_PublicKey.bin");

            /*
            //TEMP: validation of our ConsolePublicKey function
            byte[] reconvertedBytes = ConsolePublicKey.FromBytes(cs.PublicKey).GetBytes();
            if (!ServerTestFramework.ArrayEx.Compare(reconvertedBytes, cs.PublicKey))
            {
                throw new System.Exception("Oh noes!  Either ConsolePublicKey's FromBytes or GetBytes is broken!");
            }
             */
        }

        //does a request from the data in this struct
        public CreateCertificateResponse DoRequest()
        {
            XRLCreateCertificate xrl = new XRLCreateCertificate();
            xrl.Request.PubKey = PublicKey;
            xrl.Request.appId = AppId;
            xrl.Request.userPuid = UserPuid;

            if (!xrl.Execute(MachineId))
            {
                throw new XErrException(xrl.XErr, xrl.GetDumpString());
            }

            return xrl.Response;
        }

        /// <summary>
        /// Sets the private key on the given cert to the one that was used in this
        /// create certificate state to get the public key blob
        /// </summary>
        /// <param name="cert"></param>
        public void SetPrivateKey(X509Certificate2 cert)
        {
            RSACryptoServiceProvider certPubKey = cert.PublicKey.Key as RSACryptoServiceProvider;
            RSACryptoServiceProvider blobPubKey = keyBlob.serviceProvider;

            RSAParameters certParams = certPubKey.ExportParameters(false);
            RSAParameters blobParams = blobPubKey.ExportParameters(false);

            Console.WriteLine("Modulus: {0}\nExponent: {1}", certParams.Modulus, certParams.Exponent);
            Console.WriteLine("Modulus: {0}\nExponent: {1}", blobParams.Modulus, blobParams.Exponent);

            cert.PrivateKey = keyBlob.serviceProvider;
        }
    }

    public class CertHelper
    {
        public static X509Certificate2 RootCA = new X509Certificate2(@"SuitesData\Signature\int-net.xboxlive.com.cer");

        private static bool initialized = false;
        private static object initLock = new object();

        /// <summary>
        /// Initializes the certificate helper by loading the certificate 
        /// required for validation into the cert store.
        /// </summary>
        public static void Initialize()
        {
            if (!initialized)
            {
                lock (initLock)
                {
                    if (!initialized)
                    {
                        // Check if it's expired
                        if (DateTime.UtcNow > RootCA.NotAfter)
                        {
                            Global.RO.Warn("Certificate used to validate generated certs has expired.\nVerification will likely fail.");
                        }

                        // Open the store, and add the Root CA to it if we need to.
                        // Note: We MUST use the LocalMachine store because if we use the CurrentUser
                        // store, then an attempt to add any certificates to the root store will result
                        // in a Message Box that will stall the tests and basically halt any automated
                        // test run.
                        X509Store store = new X509Store(StoreName.Root, StoreLocation.LocalMachine);
                        store.Open(OpenFlags.ReadWrite);
                        store.Add(RootCA);
                        store.Close();

                        initialized = true;
                    }
                }
            }
        }

        /// <summary>
        /// Cleans up certificates added to the cert store.
        /// </summary>
        /// <remarks>
        /// We allow this to run even if initialize has not been run since
        /// it's possible that the certificate has been added before or was
        /// added manually or something
        /// </remarks>
        public static void CleanUp()
        {
            lock (initLock)
            {
                X509Store store = new X509Store(StoreName.Root, StoreLocation.LocalMachine);
                store.Open(OpenFlags.ReadWrite);
                store.Remove(RootCA);
                store.Close();

                initialized = false;
            }
        }

        /// <summary>
        /// Load the certificate settings for a given app id from the database
        /// </summary>
        /// <param name="appId">The appId to get settings for</param>
        /// <param name="subjectPattern">The pattern used or the subject</param>
        /// <param name="certLifetimeHours">The lifetime of the cert to use</param>
        public static void LoadCertSettingsFromDb(string appId, out string subjectPattern, out int certLifetimeHours, out int notBeforeAdjustment)
        {
            Npdb npdb = new Npdb();
            npdb.ConnectToServer();

            String sqlCmd = String.Format("EXECUTE p_casvc_get_settings_for_appid '{0}'", appId);

            System.Data.SqlClient.SqlDataReader reader = null;
            npdb.ReadData(sqlCmd, out reader);
            if (!reader.Read())
            {
                throw new UnexpectedTestResultException("Unable to read certificate settings");    
            }
            
            subjectPattern = reader.GetString(reader.GetOrdinal("vc_subject_name_pattern"));
            certLifetimeHours = reader.GetInt32(reader.GetOrdinal("i_cert_lifetime"));
            notBeforeAdjustment = reader.GetInt32(reader.GetOrdinal("i_not_before_clock_skew_seconds"));
        }

        /// <summary>
        /// Describes a cert and its chain in a user-readable way
        /// </summary>
        /// <param name="cert">The cert to describe</param>
        /// <returns>A readable defenition of the cert</returns>
        public static string GetCertDescriptionString(X509Certificate2 cert)
        {
            string desc=cert.ToString();
            desc+="\n";

            X509Chain chain = new X509Chain();
            chain.ChainPolicy.UrlRetrievalTimeout=new System.TimeSpan(0,0,0,0,1); //we do not care about revocation stuff
            chain.ChainPolicy.RevocationMode=X509RevocationMode.NoCheck;
            chain.Build(cert);

            desc+="Chain Status Length="+chain.ChainStatus.Length+"\n";
            foreach (X509ChainStatus cs in chain.ChainStatus)
            {
                desc+="  ";
                desc+=cs.Status;
                desc+=": ";
                desc+=cs.StatusInformation;
                desc+="\n";
            }

            desc+="Chain Elements Length="+chain.ChainElements.Count+"\n";
            foreach (X509ChainElement el in chain.ChainElements)
            {
                desc+="  ";
                desc+="cert: ";
                desc+="issuer("+el.Certificate.Issuer+") ";
                desc+="subject("+el.Certificate.Subject+") ";
                desc+="info: "+el.Information;
                desc+="\n";
            }

            desc+="Extensions Count="+cert.Extensions.Count+"\n";
            foreach (X509Extension ext in cert.Extensions)
            {
                desc+="Oid="+ext.Oid.FriendlyName+" ("+ext.Oid.Value+")";
                desc+="\n";
            }

            return desc;
        }

        public static void VerifyCertificates(CertState state, byte[] normalBytes, byte[] serializedBytes)
        {
            Global.RO.Info("Reading normal cert...");
            X509Certificate2 certNorm = new X509Certificate2(normalBytes);

            Global.RO.Info("Reading serialized cert...");
            X509Certificate2 certSer = new X509Certificate2(serializedBytes);

            VerifyCertificates(state, certNorm, certSer);
        }

        public static void VerifyCertificates(CertState state, X509Certificate2 normalCert, X509Certificate2 serializedCert)
        {
            Global.RO.Info("Comparing certs...");
            CertHelper.CompareCerts(normalCert, serializedCert);

            Global.RO.Info("Verifying cert...");
            CertHelper.VerifyCert(normalCert, state);
        }

        /// <summary>
        /// These flags indicate which flags will be ignored during certificate verification
        /// </summary>
        public static X509ChainStatusFlags ChainFlagsToIgnore = X509ChainStatusFlags.NotTimeValid;
        
        /// <summary>
        /// Verifies that all the cert fields are what we expect (be wary of 
        /// verifying a freshly retrieved cert, if clocks are not exactly in 
        /// sync it may not be valid for a fraction of a second yet)
        /// </summary>
        /// <param name="cert">The certificate to verify</param>
        /// <param name="state">The state to verify it against</param>
        public static void VerifyCert(X509Certificate2 cert, CertState state)
        {
            VerifyCert(cert, state.AppId, state.ConsoleId);
        }

        /// <summary>
        /// Verifies that all the cert fields are what we expect (be wary of 
        /// verifying a freshly retrieved cert, if clocks are not exactly in 
        /// sync it may not be valid for a fraction of a second yet)
        /// </summary>
        /// <param name="cert">The certificate to verify</param>
        /// <param name="appId">The appId used to generate the cert</param>
        /// <param name="consoleId">The consoleId used to generate the cert</param>
        public static void VerifyCert(X509Certificate2 cert, String appId, String consoleId)
        {
            String subjectPattern;
            int certLifetimeHours;
            int notBeforeSkewSeconds;
            LoadCertSettingsFromDb(appId, out subjectPattern, out certLifetimeHours, out notBeforeSkewSeconds);
            
            //verify some global properties
            ValueCheck.Test("Is Archived", false, cert.Archived);
            ValueCheck.Test("X509 version", 3, cert.Version);

            //verify subject
            Dictionary<string, string> subjects=BreakupCommaSeparatedPairs(cert.Subject);

            ValueCheck.Test("OU exists in subject", true, subjects.ContainsKey("OU"));
            ValueCheck.Test("Subject OU", "Xbox Live", subjects["OU"]);
            subjects.Remove("OU");

            ValueCheck.Test("O exists in subject", true, subjects.ContainsKey("O"));
            ValueCheck.Test("Subject O", "Microsoft", subjects["O"]);
            subjects.Remove("O");

            ValueCheck.Test("S exists in subject", true, subjects.ContainsKey("S"));
            ValueCheck.Test("Subject S", "Washington", subjects["S"]);
            subjects.Remove("S");

            ValueCheck.Test("C exists in subject", true, subjects.ContainsKey("C"));
            ValueCheck.Test("Subject C", "US", subjects["C"]);
            subjects.Remove("C");

            ValueCheck.Test("CN exists in subject", true, subjects.ContainsKey("CN"));
            ValueCheck.Test("Subject CN", "XBLIVE-"+consoleId, subjects["CN"]);
            subjects.Remove("CN");

            ValueCheck.Test("L exists in subject", true, subjects.ContainsKey("L"));
            ValueCheck.Test("Subject L", "Redmond", subjects["L"]);
            subjects.Remove("L");

            if (subjects.Count>0)
            {
                foreach (KeyValuePair<string, string> kvp in subjects)
                {
                    Global.RO.Error("Extra subject entry found: "+kvp.Key+"="+kvp.Value);
                }

                throw new UnexpectedTestResultException("Got extra entries in subject.");
            }

            //verify issuer
            Dictionary<string, string> issuers=BreakupCommaSeparatedPairs(cert.Issuer);

            ValueCheck.Test("CN exists in Issuer", true, issuers.ContainsKey("CN"));
            ValueCheck.Test("Issuer CN", "int-net.xboxlive.com", issuers["CN"]);
            issuers.Remove("CN");

            ValueCheck.Test("OU exists in Issuer", true, issuers.ContainsKey("OU"));
            ValueCheck.Test("Issuer OU", "Microsoft", issuers["OU"]);
            issuers.Remove("OU");

            ValueCheck.Test("O exists in Issuer", true, issuers.ContainsKey("O"));
            ValueCheck.Test("Issuer O", "Xbox LIVE", issuers["O"]);
            issuers.Remove("O");

            ValueCheck.Test("S exists in Issuer", true, issuers.ContainsKey("S"));
            ValueCheck.Test("Issuer S", "WA", issuers["S"]);
            issuers.Remove("S");

            ValueCheck.Test("C exists in Issuer", true, issuers.ContainsKey("C"));
            ValueCheck.Test("Issuer C", "US", issuers["C"]);
            issuers.Remove("C");

            ValueCheck.Test("L exists in Issuer", true, issuers.ContainsKey("L"));
            ValueCheck.Test("Issuer L", "Redmond", issuers["L"]);
            issuers.Remove("L");

            if (issuers.Count>0)
            {
                foreach (KeyValuePair<string, string> kvp in issuers)
                {
                    Global.RO.Error("Extra issuer entry found: "+kvp.Key+"="+kvp.Value);
                }

                throw new UnexpectedTestResultException("Got extra entries in issuer.");
            }

            // Verify certificate dates
            // NotBefore and NotAfter are *local* times, so we should deal with local times too.

            // Get the expected not before time
            TimeSpan notBeforeSkew = TimeSpan.FromSeconds(notBeforeSkewSeconds);
            DateTime expectedNotBefore = DateTime.Now + notBeforeSkew;
            TimeSpan notBeforeDiff = (expectedNotBefore - cert.NotBefore).Duration();

            // The certificate should be valid around the expected time, if it's more than 5 minutes we have an issue.
            if (notBeforeDiff.TotalMinutes > 5)
            {
                throw new UnexpectedTestResultException("Expected cert start date to be around " + expectedNotBefore + " but it was " + cert.NotBefore);
            }

            TimeSpan expectedDuration = TimeSpan.FromHours(certLifetimeHours);
            TimeSpan certDuration = (cert.NotAfter - cert.NotBefore + notBeforeSkew).Duration();
            TimeSpan certDurationDiff = (certDuration - expectedDuration).Duration();

            // If difference between the expected and actual cert duration is more than
            // about 5 minutes than throw an error
            if (certDurationDiff.TotalMinutes > 5) 
            {
                throw new UnexpectedTestResultException(
                    String.Format("Expected cert duration to be {0} hours, but it was {1}", expectedDuration, certDuration));
            }

            // Verify that the serial number is not negative
            Byte[] serialNumber = Hexer.unhex(cert.SerialNumber);
            if ((serialNumber[0] & 0x80) != 0)
            {
                throw new UnexpectedTestResultException("Certificate serial number was negative.");
            }

            //verify chain
            //Note: This also verifies the signature and some other properties.
            X509Chain chain = new X509Chain();
            chain.ChainPolicy.UrlRetrievalTimeout=new System.TimeSpan(0,0,0,0,1); //we do not care about revocation stuff
            chain.ChainPolicy.RevocationMode=X509RevocationMode.NoCheck;
            // We check the time earlier in a way that allows us to bypass stupid clock skew problems
            // So just ignore any time errors here.
            chain.ChainPolicy.VerificationFlags |= X509VerificationFlags.IgnoreNotTimeValid;
            chain.Build(cert);

            for(int i=0; i<chain.ChainStatus.Length; i++)
            {
                //remove the flags that we know are ok and expected
                X509ChainStatusFlags currFlags = chain.ChainStatus[i].Status;
                currFlags &= ~ChainFlagsToIgnore;

                // WOAH! Big Hack Here.  We ignore a bunch of extra stuff on the second item in the chain
                // This is the issuer of the cert, but it was improperly generated so it's got lots of 
                // problems including the fact that it's just NOT supposed to be generating certificates,
                // i.e. it's not a CA.  Just ignore them for now, until I can get a better cert
                currFlags &= ~(X509ChainStatusFlags.InvalidBasicConstraints | X509ChainStatusFlags.NotValidForUsage);

                if (currFlags != X509ChainStatusFlags.NoError)
                {
                    throw new UnexpectedTestResultException(String.Format("Unexpected flags in chain (index {0}) status: {1}", i, currFlags));
                }
            }

            //verify public and private key
            if (cert.HasPrivateKey)
            {
                throw new UnexpectedTestResultException("Did not expect cert to have a private key, but it does.");
            }

            //Verify extensions
            foreach (X509Extension ext in cert.Extensions)
            {
                if (ext.Oid.Value=="2.5.29.1") //Authority Key Identifier
                {
                    //no .net class for this one, so extract the value and just sanity check it
                    AsnEncodedData asn=new AsnEncodedData(ext.Oid, ext.RawData);
                    string authKeyString=asn.Format(false);
                    string authKeyLower=authKeyString.ToLower();

                    if (!authKeyLower.Contains("cn=microsoft secure server authority"))
                    {
                        throw new UnexpectedTestResultException("Authority Key Identifier (extension) does not contain the expected cn: "+authKeyString);
                    }
                }
                else if (ext.Oid.Value=="2.5.29.14") //Subject Key Identifier
                {
                    if (!(ext is X509SubjectKeyIdentifierExtension))
                    {
                        throw new UnexpectedTestResultException("Cert extension says oid="+ext.Oid.Value+" but the member is not of the right type for some reason.");
                    }

                    X509SubjectKeyIdentifierExtension ski=(X509SubjectKeyIdentifierExtension)ext;
                    ValueCheck.Test("Subject Key Identifier (extension) Length", 20*2, ski.SubjectKeyIdentifier.Length);
                }
                else if (ext.Oid.Value=="2.5.29.15") //Key Usage
                {
                    if (!(ext is X509KeyUsageExtension))
                    {
                        throw new UnexpectedTestResultException("Cert extension says oid="+ext.Oid.Value+" but the member is not of the right type for some reason.");
                    }
                    
                    X509KeyUsageExtension ku=(X509KeyUsageExtension)ext;
                    ValueCheck.Test("Key Usage (extension)", X509KeyUsageFlags.DataEncipherment|X509KeyUsageFlags.KeyEncipherment|X509KeyUsageFlags.DigitalSignature, ku.KeyUsages);
                }
                else if (ext.Oid.Value=="2.5.29.37") //Enhanced Key Usage
                {
                    if (!(ext is X509EnhancedKeyUsageExtension))
                    {
                        throw new UnexpectedTestResultException("Cert extension says oid="+ext.Oid.Value+" but the member is not of the right type for some reason.");
                    }

                    X509EnhancedKeyUsageExtension eku=(X509EnhancedKeyUsageExtension)ext;

                    ValueCheck.Test("Enchanced Key Usage (extension) uses count", 1, eku.EnhancedKeyUsages.Count);
                    foreach (Oid oid in eku.EnhancedKeyUsages)
                    {
                        ValueCheck.Test("Enchanced Key Usage (extension) oid", "1.3.6.1.5.5.7.3.2", oid.Value); //Client Authentication
                    }
                }
                else
                {
                    throw new UnexpectedTestResultException("Unexpected certificate extension: "+ext.Oid.Value+" ("+ext.Oid.FriendlyName+")");
                }

                if (cert.Extensions.Count!=4)
                {
                    throw new UnexpectedTestResultException("Expected cert to have 4 extensions, but it has "+cert.Extensions.Count);
                }
            }
        }

        /// <summary>
        /// Compares to certs to determine if they are equal and throws an 
        /// exception if they aren't
        /// </summary>
        /// <param name="c1">The first cert to compare</param>
        /// <param name="c2">The second cert to compare</param>
        public static void CompareCerts(X509Certificate2 c1, X509Certificate2 c2)
        {
            if (!c1.Equals(c2))
            {
                throw new UnexpectedTestResultException(
                    String.Format("Certs are different.\n--first cert--:\n{0}\n--second cert--\n{1}", c1.ToString(), c2.ToString()));
            }
        }

        /// <summary>
        /// Checks a certificate for a given extension
        /// </summary>
        /// <param name="certificate">The certificate to search</param>
        /// <param name="extension">The extension to search for</param>
        /// <returns>True if the extension was found, false otherwise</returns>
        public static bool CheckForExtension(X509Certificate2 certificate, string extension)
        {
            extension = extension.ToLower();

            // Check each extension in the cert
            foreach (X509Extension ext in certificate.Extensions)
            {
                String extFormat = ext.Format(false).ToLower();
                if (extFormat.Contains(extension))
                {
                    // We found this extennsion
                    return true;
                }
            }

            // We couldn't find the extension
            return false;
        }

        /// <summary>
        /// Check a certificate for a given extension and throw an exception if it was expected 
        /// but not found and vice versa.
        /// </summary>
        /// <param name="certificate">The certificate to search</param>
        /// <param name="extension">The extension to search for</param>
        /// <param name="shouldFind">True if we should find the exception, false if we should NOT find it</param>
        /// <exception cref="UnexpectedTestResultException">
        /// Thrown if the extension is found and shouldFind is false, or if the extension is not 
        /// found and shouldFind is true.
        /// </exception>
        public static void AssertForExtension(X509Certificate2 certificate, string extension, bool shouldFind)
        {
            bool found = CheckForExtension(certificate, extension);

            // If we found it
            if (found)
            {
                // And we should not 
                if (!shouldFind)
                {
                    throw new UnexpectedTestResultException("Found an unexpected extension in the cert: " + extension);
                }
            }
            else
            {
                // But if we didn't find it, and should have
                if (shouldFind)
                {
                    throw new UnexpectedTestResultException("Unable to find expected extension: " + extension);
                }
            }
        }

        public static void DumpExtensions(X509Certificate2 certificate)
        {
            StringBuilder sb = null;
            foreach (X509Extension ext in certificate.Extensions)
            {
                sb = new StringBuilder();
                sb.Append(ext.Critical?"! ":"  ");
                sb.AppendFormat("Oid - {0}:{1}; {2}\n", ext.Oid.FriendlyName, ext.Oid.Value, ext.Format(false));
                Global.RO.Info(sb.ToString());
            }
        }

        /// <summary>
        /// Takes a string of comma separated, name=value pairs (i.e. a=b, c=d) and parses 
        /// them into a dictionary
        /// </summary>
        /// <param name="str">The string to parse</param>
        /// <returns>A dictionary of name-value pairs from the string</returns>
        public static Dictionary<string, string> BreakupCommaSeparatedPairs(string str)
        {
            Dictionary<string, string> dict = new Dictionary<string, string>();

            string[] commaParts = str.Split(new char[] { ',' });
            foreach (string part in commaParts)
            {
                string[] eqParts = part.Split(new char[] { '=' });
                string key = eqParts[0].Trim();
                string val = eqParts[1].Trim();
                dict.Add(key, val);
            }

            return dict;
        }
    }

    public class StressBulkHelper
    {
        // Bulk user stuff
        protected static BulkUserSet bulkUserSet = null;
        private static int bulkUserIndex = 0;

         // Bulk machines stuff
        public MachineEditor[] bulkMachineSet = null;
        private static int bulkMachineIndex = 0;

        public StressBulkHelper()
        {
        }

        public void Initialize()
        {
            // Setup bulk users
            Global.RO.Debug("Getting bulk user info");
            bulkUserSet = STFLiveGlobal.GetUserSet("xenon");
            if (bulkUserSet == null || bulkUserSet.Count == 0)
            {
                throw new System.Exception("Bulk user set is empty.  Cannot run stress without bulk users.");
            }

            // Setup bulk machines
            try
            {
                if (bulkMachineSet == null)
                {
                    Global.RO.Debug("Getting bulk machine info");
                    bulkMachineSet = new MachineEditor[128];
                    for (int i = 0; i < bulkMachineSet.Length; ++i)
                    {
                        XmacsClient xmacs = SignatureUtils.CreateClient(AuthContext.ClientTypes.Xenon, false);
                        xmacs.EmulateClientBehavior = true;
                        xmacs.SignInXmacs();

                        bulkMachineSet[i] = MachineEditor.FromId(xmacs.GetMachinePuid());
                        bulkMachineSet[i].UseCaching = true;
                    }
                }
            }
            catch //empty out our state so we don't think we're in a good state if we try again
            {
                bulkMachineSet = null;
                throw;
            }
        }

        public ulong GetNextBulkUserPuid()
        {
            uint index = (uint)System.Threading.Interlocked.Increment(ref bulkUserIndex);
            if (bulkUserIndex >= bulkUserSet.Count)
            {
                bulkUserIndex = 0;
                index = index % bulkUserSet.Count;
            }
            return bulkUserSet.Base + (ulong)index;
        }

        public MachineEditor GetNextBulkMachine()
        {
            uint i = (uint)System.Threading.Interlocked.Increment(ref bulkMachineIndex);
            if (bulkMachineIndex >= bulkMachineSet.Length)
            {
                bulkMachineIndex = 0;
                i = i % (uint)bulkMachineSet.Length;
            }
            return bulkMachineSet[i];
        }
    }

    public interface IMachine
    {
        ulong Puid { get; }
        String ConsoleId { get; }
        String ConsoleIdNoPrefix { get; }
    }

    public abstract class MachineBase : IMachine
    {
        public abstract ulong Puid { get; }
        public abstract String ConsoleId { get; }
        public abstract String ConsoleIdNoPrefix { get; }

        public static implicit operator MachineBase(MachineEditor editor)
        {
            return new MachineEditorWrapper(editor);
        }

        public static implicit operator MachineBase(XmacsClient client)
        {
            return new XmacsClientWrapper(client);
        }

        public override string ToString()
        {
            return String.Format("{0} (0x{1:X16})", ConsoleId, Puid);
        }
    }

    public class MachineEditorWrapper : MachineBase
    {
        public MachineEditor Editor { get; set; }

        public MachineEditorWrapper(MachineEditor editor)
        {
            this.Editor = editor;
        }

        public override ulong Puid { get { return Editor.Id; } }
        public override String ConsoleId { get { return Editor.ConsoleId; } }
        public override String ConsoleIdNoPrefix { get { return Editor.ConsoleId.Substring(3); } }
    }

    public class XmacsClientWrapper : MachineBase
    {
        public XmacsClient Client { get; set; }

        public XmacsClientWrapper(XmacsClient client)
        {
            this.Client = client;
        }

        public static implicit operator XmacsClientWrapper(XmacsClient client)
        {
            return new XmacsClientWrapper(client);
        }

        public override ulong Puid { get { return Client.MachinePuid; } }
        public override String ConsoleId { get { return "XE." + Client.ConsoleId; } }
        public override string ConsoleIdNoPrefix { get { return this.ConsoleId.Substring(3); } }

        /// <summary>
        /// Delegates directly to the xmacs client, used mostly to make 
        /// this wrapper a drop in replacement for XmacsClient
        /// </summary>
        public void SignInXmacs()
        {
            Client.SignInXmacs();
        }
    }

    public interface IUser
    {
        ulong Puid { get; }
        ulong MachinePuid { get; set; }
        ulong PassportPuid { get; set; }

        byte CountryId { get; set; }
        ushort LanguageId { get; set; }
    }

    public abstract class UserBase : IUser
    {
        public abstract ulong Puid { get; }
        public abstract ulong MachinePuid { get; set; }
        public abstract ulong PassportPuid { get; set; }

        public abstract byte CountryId { get; set; }
        public abstract ushort LanguageId { get; set; }

        public static implicit operator UserBase(XeUser user)
        {
            return new XeUserWrapper(user);
        }

        public static implicit operator UserBase(UserEditor editor)
        {
            return new UserEditorWrapper(editor);
        }
    }

    public class XeUserWrapper : UserBase
    {
        public XeUser XeUser { get; set; }

        public XeUserWrapper(XeUser user)
        {
            this.XeUser = user;
        }

        public override ulong Puid { get { return XeUser.UserPuid; } }
        public override ulong MachinePuid { get { return XeUser.MachinePuid; } set { XeUser.MachinePuid = value; } }
        public override ulong PassportPuid { get { return XeUser.PassportUserPuid; } set { XeUser.PassportUserPuid = value; } }
        public override byte CountryId { get { return XeUser.CountryId; } set { XeUser.CountryId = value; } }
        public override ushort LanguageId { get { return XeUser.LanguageId; } set { XeUser.LanguageId = value; } }
    }

    public class UserEditorWrapper : UserBase
    {
        public UserEditor Editor { get; set; }

        public UserEditorWrapper(UserEditor editor)
        {
            this.Editor = editor;
        }

        public override ulong Puid { get { return Editor.Puid; } }
        public override ulong MachinePuid { get { return unchecked((ulong)Editor.MachinePuid); } set { Editor.MachinePuid = unchecked((long)value); } }
        public override ulong PassportPuid { get { return unchecked((ulong)Editor.UserPassportPuid); } set { Editor.UserPassportPuid = unchecked((long)value); } }
        public override byte CountryId { get { return Editor.CountryId; } set { Editor.CountryId = value; } }
        public override ushort LanguageId { get { return (ushort)Editor.LanguageId; } set { Editor.CountryId = (byte)value; } }
    }

    /// <summary>
    /// A generic test helper class which can be overridden for tests of any time.
    /// Automatically creates a user and client object and can be easily modified to
    /// create batches of users for easier testing.  Also provides a number of helper
    /// properties to easily access common properties of the user and client.
    /// </summary>
    public class TestHelper
    {
        /// <summary>
        /// The type of client that this helper should create.  Defaults to Xenon
        /// </summary>
        protected AuthContext.ClientTypes clientType = AuthContext.ClientTypes.Xenon;

        protected MachineType machineType = MachineType.Xbox360;

        /// <summary>
        /// Determines whether users created with this helper should be gold users or not.
        /// </summary>
        /// <remarks>
        /// This is protected since we don't want you to be able to easily change the type
        /// of user a helper uses after it's been created.  A new helper should be used if
        /// that is the desired functionality.
        /// </remarks>
        protected bool createGoldUser = true;

        /// <summary>
        /// Indicates whether or not a user should be returned
        /// </summary>
        public Boolean ReuseUser { get; set; }

        protected IUser user;
        /// <summary>
        /// A user object that can be used by this helper to make requests
        /// </summary>
        public IUser User
        {
            get { return user; }
            set { user = value; }
        }

        /// <summary>
        /// The user puid of the user object associated with this helper
        /// </summary>
        public ulong UserPuid
        {
            get { return User.Puid; }
        }

        protected IMachine machine;
        /// <summary>
        /// A client object that can be used by this helper to make requests
        /// </summary>
        public IMachine Machine
        {
            get { return machine; }
            set { machine = value; }
        }

        /// <summary>
        /// The machine puid of the client object associated with this helper
        /// </summary>
        public ulong MachinePuid
        {
            get { return Machine.Puid; }
        }

        /// <summary>
        /// Creates a test helper using the defualt options.
        /// </summary>
        public TestHelper() 
        {
            // By default, we will return the users to the 
            // shared pool when we are done with them.
            ReuseUser = true;
        }

        public TestHelper(MachineType machineType)
            : this()
        {
        }

        /// <summary>
        /// Creates a test helper using a pre-existing client object and creates
        /// a user of the default options.
        /// </summary>
        /// <param name="client">The pre-existing client to use</param>
        public TestHelper(IMachine client) : this(client, null) { }

        /// <summary>
        /// Creates a test helper using a pre-existing user object and creates
        /// a client of the default type.
        /// </summary>
        /// <param name="user">The pre-existing user to use</param>
        public TestHelper(IUser user) : this(null, user) { }

        /// <summary>
        /// Create a test helper object using a provided client and user
        /// </summary>
        /// <param name="client">The client to create the helper with</param>
        /// <param name="user">The user to create the helper with</param>
        public TestHelper(IMachine client, IUser user) : base()
        {
            this.machine = client;
            this.user = user;
            //if (this.user != null)
            //{
            //    // We're making our own user, so we allow it to be reused
            //    ReuseUser = true;
            //}
        }

        /// <summary>
        /// Creates a test helper using the same user and client as the provided one
        /// </summary>
        /// <param name="helper">The other test helper to copy the client and user from</param>
        public TestHelper(TestHelper helper)
            : this(helper.Machine, helper.User)
        {
        }

        /// <summary>
        /// Revert the helper to a known state by clearing out all purchased media
        /// and creating a new user and client
        /// </summary>
        public virtual void Reset()
        {
            Reset(true);
        }

        /// <summary>
        /// Revert tho helper to a known state by clearing out all purchased media
        /// and optionally created a new user and client
        /// </summary>
        /// <param name="forceNewUserAndClient"></param>
        public virtual void Reset(bool forceNewUserAndClient)
        {
            // If a client was not already provided or we're 
            // forcing a new one then create a new client
            if (forceNewUserAndClient || machine == null)
            {
                machine = GetSharedMachine(machineType);
            }

            // Then create a user if one was not already provided 
            // or we're forcing a new one
            if (forceNewUserAndClient || user == null)
            {
                if (user != null && ReuseUser)
                {
                    ReturnSharedUser(user);
                }
                user = GetSharedUser(createGoldUser);
            }
        }

        public virtual void Cleanup()
        {
            if (user != null && ReuseUser)
            {
                ReturnSharedUser(user);
                user = null;
            }
        }

        public static int UserCreateCount = 10;
        public static TimeSpan UserCreateTimeout = TimeSpan.FromMinutes(5);
        public static Queue<IUser> sharedUsersGold = new Queue<IUser>();
        public static Queue<IUser> sharedUsersSilver = new Queue<IUser>();
        public static Int32 totalUsersCreated = 0;

        private static Boolean creatingUsers = false;
        private static Boolean createUsersFailed = false;

        public static IUser GetSharedUser()
        {
            return GetSharedUser(true);
        }

        /// <summary>
        /// Provides an easy way to create a bunch of users at the 'same' time so 
        /// that we don't have to wait 30 seconds each time a user is created, we 
        /// just wait in batches.  
        /// </summary>
        /// <param name="createGoldUser">If true, Gold users will be created</param>
        /// <returns>A valid IUser if the creation was successful</returns>
        public static IUser GetSharedUser(bool createGoldUser)
        {
            Queue<IUser> sharedUsers = null;
            IUser newUser = null;

            if (createGoldUser)
            {
                sharedUsers = sharedUsersGold;
            }
            else
            {
                sharedUsers = sharedUsersSilver;
            }

            do
            {
                // If there are no users and nobody is creating users
                if (sharedUsers.Count == 0 && !creatingUsers)
                {
                    if (createUsersFailed)
                    {
                        // This indicates a fatal failure in the user creation thread
                        // This is to allow optimistic retry if we run the tests again later.
                        createUsersFailed = false;

                        throw new UnexpectedTestResultException("Create users thread failed to create any users.");
                    }
                    else
                    {
                        Global.RO.Info("Starting background thread to create users...");

                        // Starting a background thread to create some users
                        new Thread(new ParameterizedThreadStart(CreateSharedUsers)).Start(createGoldUser);

                        // Yield to the new user creation thread
                        Thread.Sleep(100);
                    }
                }

                // We'll wait for the user queue for some length of time 
                // before giving up. This will occur if we just can't create
                // a user, or if the creation thread deadlocked.
                if (Monitor.TryEnter(sharedUsers, UserCreateTimeout))
                {
                    try
                    {
                        if (sharedUsers.Count > 0)
                        {
                            Global.RO.Debug("Got a new user from the queue.");
                            newUser = sharedUsers.Dequeue();
                        }
                    }
                    finally
                    {
                        Monitor.Exit(sharedUsers);
                    }

                    if (newUser == null)
                    {
                        // We didn't get a user yet, but it's probably being 
                        // created so just wait a second before checking again.
                        Global.RO.Debug("No user available yet.");
                        Thread.Sleep(5000);
                    }
                }
                else
                {
                    // This means that we were unable to acquire the lock 
                    // after the given timeout.
                    throw new UnexpectedTestResultException(
                        "Unable to acquire user queue lock.  This indicates a problem creating users.");
                }

            } while (newUser == null);

            return newUser;
        }

        public static void CreateSharedUsers(object createGoldUserObj)
        {
            Boolean createGoldUser;
            Queue<IUser> sharedUsers = null;
            Int32 retriesLeft = 3;
            Int32 usersBeingCreated = 0;
            Int32 xcacheRefreshIntervalMs = 5000;

            try
            {
                creatingUsers = true;
                createGoldUser = (Boolean)createGoldUserObj;

                if (createGoldUser)
                {
                    sharedUsers = sharedUsersGold;
                }
                else
                {
                    sharedUsers = sharedUsersSilver;
                }

                for (int i = 0; i < UserCreateCount; i++)
                {
                    Global.RO.Debug("Creating user ({0})...", i);
                    try
                    {
                        DateTime startTime = DateTime.UtcNow;
                        Interlocked.Increment(ref usersBeingCreated);
                        IUser newUser = null;
                        
                        UserEditor userEditor = UserEditor.CreateNew();
                        if(!createGoldUser)
                        {
                            userEditor.RemoveAllSubscriptions(true);
                            userEditor.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                        }
                        newUser = (UserBase)userEditor;
                                                
                        TimeSpan dur = DateTime.UtcNow - startTime;
                        Int32 durMs = (int)dur.TotalMilliseconds;
                        Global.RO.Info("User created in {0}ms.", durMs);
                        
                        // Now we've successfully created a user, spawn a thread to
                        // wait until the user is ready, then queue it up.
                        new Thread(() =>
                        {
                            try
                            {
                                Int32 sleepDuration = xcacheRefreshIntervalMs;
                                Global.RO.Info("Sleeping for {0}s until they are picked up by XCache", (Int32)(sleepDuration / 1000));
                                Thread.Sleep(sleepDuration);

                                Interlocked.Increment(ref totalUsersCreated);
                                Global.RO.Debug("User ready, adding to queue ({0})...", totalUsersCreated);
                                lock (sharedUsers)
                                {
                                    sharedUsers.Enqueue(newUser);
                                }
                            }
                            finally
                            {
                                // Now we're done creating the user (or we failed)
                                Interlocked.Decrement(ref usersBeingCreated);
                            }

                            // Yield to somebody else so they can get the lock and grab the now ready user
                            System.Threading.Thread.Sleep(0);
                        }).Start();
                    }
                    catch
                    {
                        // We failed user creation, we need to decrement the users being created count
                        Interlocked.Decrement(ref usersBeingCreated);

                        // If we didn't manage to create any users yet
                        if (sharedUsers.Count == 0)
                        {
                            // and there are no retries left
                            if (--retriesLeft < 0)
                            {
                                // Then throw the exception out
                                throw;
                            }
                            else
                            {
                                i--;
                                Global.RO.Warn("User creation failed.  {0} Retries left", retriesLeft);
                            }
                        }
                        else
                        {
                            // But if we made at least one user, then return that user and 
                            // stop creating users for new.  It's probably a transient error 
                            // and we'll try again next time someone asks for a user
                            Global.RO.Warn("Failed to create a user, after at least one was created. Probably a transient error");
                            break;
                        }
                    }
                }
            }
            catch(Exception ex)
            {
                // If we're throwing an exception, the user 
                // creation failed so signal that to the users
                createUsersFailed = true;

                // Hmm, STF doesn't catch this exception, just dump it out
                Global.RO.Error("User creation failed.");
                Global.RO.Error(ex.ToString());
                //throw;
            }
            finally
            {
                // We don't want somebody else to come in and try to create some 
                // users, so wait here until the other requests complete
                while (usersBeingCreated > 0)
                {
                    Thread.Sleep(1000);
                }
                Global.RO.Debug("Finished creating users.");

                creatingUsers = false;
            }
        }

        public static void ReturnSharedUser(IUser user)
        {
            ReturnSharedUser(user, true);
        }

        public static void ReturnSharedUser(IUser user, Boolean goldUser)
        {
            if (user == null)
            {
                return;
            }

            Queue<IUser> sharedUsers = null;

            if (goldUser)
            {
                sharedUsers = sharedUsersGold;
            }
            else
            {
                sharedUsers = sharedUsersSilver;
            }

            lock(sharedUsers)
            {
                if (!sharedUsers.Contains(user))
                {
                    sharedUsers.Enqueue(user);
                }
            }
        }

        public static IMachine GetSharedMachine()
        {
            return GetSharedMachine(MachineType.Xbox360);
        }

        public static IMachine GetSharedMachine(MachineType machineType)
        {
            // Right now we don't actually create shared machines because there's 
            // no delay and there isn't a good reason to bother.  Just create a
            // machine editor and hand that back for now.
            return (MachineBase)MachineEditor.CreateNew(machineType);
        }
    }

    public class SignatureUtils
    {
        public static Report SigRO = new Report("Sig");

        /// <summary>
        /// Creates a Gold 360 user and waits on XCache to pick it up
        /// </summary>
        /// <returns>A Xenon User</returns>
        public static XeUser CreateUser()
        {
            return CreateUser(true, false, true);
        }

        /// <summary>
        /// Create a Gold 360 user and optionally waits on XCache to pick it up
        /// </summary>
        /// <param name="waitForXCache">Indicates if we should wait for XCache to pickup the user</param>
        /// <returns>A Xenon User</returns>
        public static XeUser CreateUser(bool waitForXCache)
        {
            return CreateUser(waitForXCache, false, true);
        }

        /// <summary>
        /// Create a 360 user and optionally waits on XCache to pick it up
        /// </summary>
        /// <param name="waitForXCache">If true, wait 31 seconds for XCache to pickup user</param>
        /// <param name="createPassport">Indicates if a passport should be created for the user</param>
        /// <param name="createAsGold">Indicates if a gold user account should be created</param>
        /// <returns>A Xenon User</returns>
        public static XeUser CreateUser(bool waitForXCache, bool createPassport, bool createAsGold)
        {
            XeUser user = AuthContext.MakeNewBillingUser(createPassport, createAsGold, true);
            if (waitForXCache)
            {
                SigRO.Info("Waiting 31 seconds for new user to be picked up by XCache...");
                System.Threading.Thread.Sleep(31 * 1000);
            }

            return user;
        }

        /// <summary>
        /// Creates a Xenon Xmacs Client and signs it in
        /// </summary>
        /// <returns>A Xenon Xmacs Client</returns>
        public static XmacsClient CreateClient()
        {
            return CreateClient(AuthContext.ClientTypes.Xenon, true);
        }

        /// <summary>
        /// Creates and Xmacs Client and signs it in
        /// </summary>
        /// <param name="clientType">The type of client you want to create</param>
        /// <returns>An Xmacs client of the specified type</returns>
        public static XmacsClient CreateClient(AuthContext.ClientTypes clientType)
        {
            return CreateClient(clientType, true);
        }

        /// <summary>
        /// Creates and Xmacs Client and optionally signs it in
        /// </summary>
        /// <param name="clientType">The type of client you want to create</param>
        /// <param name="signInXmacs">If true, the client will be signed into Xmacs</param>
        /// <returns>An Xmacs client of the specified type</returns>
        public static XmacsClient CreateClient(AuthContext.ClientTypes clientType, bool signInXmacs)
        {
            XmacsClient client = new XmacsClient(new AuthContext(clientType));
            if (signInXmacs)
            {
                client.SignInXmacs();
            }

            return client;
        }

        public static void AddPoints(IUser user, ulong machinePuid, Offers.PointsOffers offer)
        {
            AddPoints(user, machinePuid, offer, PaymentTypeEnum.Token);
        }

        public static void AddPoints(IUser user, ulong machinePuid, Offers.PointsOffers offer, PaymentTypeEnum paymentType)
        {
            Global.RO.Debug("Purchasing points offer {0} for user 0x{0:X}", offer, user.Puid);

            XRLXeOfferPurchase xrl = new XRLXeOfferPurchase();
            xrl.CountryID = user.CountryId;
            xrl.LanguageID = (ushort)user.LanguageId;
            xrl.Tier = 6;

            xrl.UserPuid = user.Puid;
            xrl.MachinePuid = machinePuid;
            
            xrl.OfferID = 0;
            xrl.OfferIDs = new ulong[] { Offers.GetPointsOfferId(offer) };
            xrl.OfferIDLength = (uint)xrl.OfferIDs.Length;

            xrl.PaymentType = (uint)PaymentTypeEnum.Token;
            xrl.BillingToken = Offers.GetPointsOfferVoucherCode(offer);
            xrl.BillingTokenLength = (ushort)xrl.BillingToken.Length;
            xrl.PaymentInstrumentID = "";
            xrl.PaymentInstrumentIDLength = (ushort)xrl.PaymentInstrumentID.Length;

            for (int i = 0; i < 5; i++)
            {
                if (!xrl.Execute())
                {
                    if (i < 4)
                    {
                        Global.RO.Warn("Error attempting to purchase points.  Retrying. " + xrl.GetDumpString());
                        System.Threading.Thread.Sleep(1000);
                    }
                    else
                    {
                        throw new XErrException(xrl.XErr,
                            String.Format("Unable to purchase points offer {0} for user 0x{1:X} - {2}", offer, user.Puid, xrl.GetDumpString()));
                    }
                }
                else
                {
                    break;
                }
            }
        }

        public static void AddPoints(ulong userPuid, ulong machinePuid, Offers.PointsOffers offer)
        {
            AddPoints(userPuid, machinePuid, offer, PaymentTypeEnum.Points);
        }

        public static void AddPoints(ulong userPuid, ulong machinePuid, Offers.PointsOffers offer, PaymentTypeEnum paymentType)
        {
            Global.RO.Debug("Purchasing points offer {0} for user 0x{0:X}", offer, userPuid);

            XRLXeOfferPurchase xrl = new XRLXeOfferPurchase();
            xrl.CountryID = 103;
            xrl.LanguageID = 1;
            xrl.Tier = 6;

            xrl.UserPuid = userPuid;
            xrl.MachinePuid = machinePuid;

            xrl.OfferID = 0;
            xrl.OfferIDs = new ulong[] { Offers.GetPointsOfferId(offer) };
            xrl.OfferIDLength = (uint)xrl.OfferIDs.Length;

            xrl.PaymentType = (uint)PaymentTypeEnum.Token;
            xrl.BillingToken = Offers.GetPointsOfferVoucherCode(offer);
            xrl.BillingTokenLength = (ushort)xrl.BillingToken.Length;
            xrl.PaymentInstrumentID = "";
            xrl.PaymentInstrumentIDLength = (ushort)xrl.PaymentInstrumentID.Length;

            for (int i = 0; i < 5; i++)
            {
                if (!xrl.Execute())
                {
                    if (i < 4)
                    {
                        Global.RO.Warn("Error attempting to purchase points.  Retrying. " + xrl.GetDumpString());
                        System.Threading.Thread.Sleep(1000);
                    }
                    else
                    {
                        throw new XErrException(xrl.XErr,
                            String.Format("Unable to purchase points offer {0} for user 0x{1:X} - {2}", offer, userPuid, xrl.GetDumpString()));
                    }
                }
                else
                {
                    break;
                }
            }
        }

        public static bool PurchaseMediaOffers(ulong userPuid, ulong machinePuid, params OfferMediaTypeExpectedPrice[] offers)
        {
            if (offers == null)
            {
                // We'll just pass an empty array to allow for negative test cases
                offers = new OfferMediaTypeExpectedPrice[0];
            }

            XRLPurchaseMediaOffers purchase = new XRLPurchaseMediaOffers();

            purchase.MachinePuid = machinePuid;
            purchase.UserPuid = userPuid;
            purchase.Offers = offers.Select(omtep => 
                new ServerTestFramework.LiveService.Billing.OfferMediaTypeExpectedPrice 
                {
                    OfferId = omtep.OfferId,
                    MediaTypeId = omtep.MediaTypeId,
                    ExpectedPriceWhole = omtep.ExpectedPriceWhole,
                    ExpectedPriceFractional = omtep.ExpectedPriceFractional,
                }).ToArray();

            purchase.PaymentType = (uint)PaymentTypeEnum.Points;
            purchase.BillingToken = "";
            purchase.PaymentInstrumentID = "";
            purchase.StoreId = (uint)StoreEnum.Xbox;

            bool res = purchase.Execute();

            if (!res)
            {
                Global.RO.Error("Unable to purchase media offers(s). " + purchase.GetDumpString());
            }

            return res;
        }

        /// <summary>
        /// Verifies the LIVE signature of a block of data. If the check fails with the test key,
        /// then it is checked against the nCipher key.  It only needs to pass on test.
        /// </summary>
        /// <param name="data">Blob of data to verify</param>
        /// <param name="signature">Signature that we have to compare against</param>
        /// <returns></returns>
        public static bool VerifySignature(Byte[] data, Byte[] signature)
        {
            if(ManagedSigUtil.VerifySignature(data, signature))
            {
                // If we're here, that means we verified the signature against the test key
                return true;
            }

            Global.RO.Warn("Verification failed against Test key, checking against nCipher key");
            if(ManagedSigUtil.VerifySignatureDrmNCipher(data, signature))
            {
                // If we're here, that means we verified the signature against the nCipher key
                return true;
            }

            Global.RO.Fatal("Verification failed against nCipher key too, verification failed.");
            return false;
        }
    }

    public class Signature
    {
        #region Licensing
        public static XRLAcquireMediaLicenses GenerateAcquireMediaLicensesRequest(ulong userPuid, params MediaInstanceIdOfferIdPair[] idPairs)
        {
            var acquire = new XRLAcquireMediaLicenses();
            acquire.Request.clientInfoBlocks = XRLAcquireMediaLicenses.GetValidSampleBlocks();
            acquire.Request.clientInfoBlockCount = (ushort)acquire.Request.clientInfoBlocks.Length;

            acquire.Request.userPuid = userPuid;
            acquire.Request.idPairs = idPairs;

            return acquire;
        }

        public static MediaLicense[] AcquireMediaLicenses(ulong userPuid, params MediaInstanceIdOfferIdPair[] idPairs)
        {
            XRLAcquireMediaLicenses acquire = new XRLAcquireMediaLicenses();

            acquire.Request.clientInfoBlockCount = 1;
            acquire.Request.clientInfoBlocks = XRLAcquireMediaLicenses.GetValidSampleBlocks();
            acquire.Request.clientInfoBlockCount = (ushort)acquire.Request.clientInfoBlocks.Length;

            acquire.Request.userPuid = userPuid;
            acquire.Request.idPairs = idPairs;

            if (acquire.Execute())
            {
                return acquire.Response.mediaLicenses;
            }
            else
            {
                throw new XErrException(acquire.XErr, acquire.GetDumpString());
            }
        }

        public static MediaLicense[] AcquireMediaLicenses(ulong userPuid, ulong machinePuid, params MediaInstanceIdOfferIdPair[] idPairs)
        {
            XRLAcquireMediaLicenses acquire = GenerateAcquireMediaLicensesRequest(userPuid, idPairs);
            
            if (acquire.Execute(machinePuid))
            {
                return acquire.Response.mediaLicenses;
            }
            else
            {
                throw new XErrException(acquire.XErr, acquire.GetDumpString());
            }
        }

        public static XRLAcknowlegeLicensesDelivery GenerateAcknowledgeLicensesDeliveryRequest(ulong userPuid, params MediaInstanceIdOfferIdPair[] idPairs)
        {
            var ack = new XRLAcknowlegeLicensesDelivery();

            ack.Request.idPairs = idPairs;
            ack.Request.userPuid = userPuid;

            return ack;
        }

        public static Acknowledgement[] AcknowledgeLicensesDelivery(ulong userPuid, params MediaInstanceIdOfferIdPair[] idPairs)
        {
            XRLAcknowlegeLicensesDelivery ack = new XRLAcknowlegeLicensesDelivery();

            ack.Request.idPairs = idPairs;
            ack.Request.userPuid = userPuid;

            if (ack.Execute())
            {
                return ack.Response.acknowledgements;
            }
            else
            {
                throw new XErrException(ack.XErr, ack.GetDumpString());
            }
        }

        public static Acknowledgement[] AcknowledgeLicensesDelivery(ulong userPuid, ulong machinePuid, params MediaInstanceIdOfferIdPair[] idPairs)
        {
            XRLAcknowlegeLicensesDelivery ack = GenerateAcknowledgeLicensesDeliveryRequest(userPuid, idPairs);

            if (ack.Execute(machinePuid))
            {
                return ack.Response.acknowledgements;
            }
            else
            {
                throw new XErrException(ack.XErr, ack.GetDumpString());
            }
        }

        public static MediaLicense[] AcquireMediaLicensesWeb(
            ulong userPuid, 
            ulong passportPuid, 
            params MediaInstanceIdOfferIdPair[] idPairs)
        {
            return AcquireMediaLicensesWeb(userPuid, passportPuid, null, idPairs);
        }

        public static MediaLicense[] AcquireMediaLicensesWeb(
            ulong userPuid, 
            ulong passportPuid, 
            String ipAddress, 
            params MediaInstanceIdOfferIdPair[] idPairs)
        {
            String clientInfo = "<CLIENTINFO><CLIENTID>AgAAAKtvzNznbmgjPmtp0xa3c3zy4UFDftjEW3RbO7OLkEzDmusID2zrvxDsRvzLRKRQGYq8Rlq6F!DICE1CFfDA1dEPxiI73oQIWPDDko2ikvBDamWraqeS8vrFSBT4Mn!ucLn5lvFrob37crvgU1xHUMqcCFsZfg8OuB14GaHfQa9PeNunCxXsoWu*FLs3mlObIOS8OOclm7MVsPcquYwrQ7NY!NE2</CLIENTID><MACHINECERTIFICATE>PGM6Q2VydGlmaWNhdGVDb2xsZWN0aW9uIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIiB4bWxuczpjPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIGM6VmVyc2lvbj0iMi4wIj48YzpDZXJ0aWZpY2F0ZSBjOlZlcnNpb249IjIuMCIgeG1sbnM6Yz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9jZXJ0Ij48YzpEYXRhIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIiB4bWxuczpjPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIHhtbG5zOm09Imh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9tc2xwIj48YzpTZWN1cml0eVZlcnNpb24!My44LjAuMTwvYzpTZWN1cml0eVZlcnNpb24!PGM6UHVibGljS2V5PjxLZXlWYWx1ZT48UlNBS2V5VmFsdWU!PE1vZHVsdXM!eUVmT0o0VEpvZVoxdjNzTFV6clk0U0Q1YTVQTTBHM0ROdTN2cjRrNDNVcWpTWkJsNzMrRUwydHVURDN4bHozRFFyUDNWVk00TVB4RmY5cHQvTDduMXRhOGRVM2FrSU9Sb1E2SHdaZnIvL2Y2VG9Nb016UXJ0d0dvdTloeisyQnRveW5lV2lCbThwYnVqaW1oamtrM2JGVTJsOUpCRG5pSDhwOFRLZnFLR0dNPTwvTW9kdWx1cz48RXhwb25lbnQ!QVFBQjwvRXhwb25lbnQ!PC9SU0FLZXlWYWx1ZT48L0tleVZhbHVlPjwvYzpQdWJsaWNLZXk!PGM6UEtDZXJ0PnphUEZRazM5SnpHcm1VTVpYczJjeE5jVGNHeXJ2WXpJTGEvaDhSOEczbjBiSERUT2RrUFFaUUlKQUFHMnJVcHRkK0ViQUVOOGNNRytGVjkvTWxYdEtjT3M1dFcwV0xmd0xhMDYxM1h4Vlc3QnU1NVc8L2M6UEtDZXJ0PjxjOlBLU2lnbmluZ0NlcnQ!RVN3MisvNUVINE9MUkhDRjZtRytkUnNhRGtzNVEwTGVKWS9IQjFkajBvZStEYjBlMUR2blVBSUpBQUdGLzlUV2VNQThqSG5WOTd4N1Zucjh2bStzU2ZMYlljQlk4dGFkMmhvUGljV3dHdE9uakt0ZDwvYzpQS1NpZ25pbmdDZXJ0PjxjOkhhcmR3YXJlSUQ!d0hmWG03QmcyU1liKzIxQlZzaG0vOEg1c2pJPTwvYzpIYXJkd2FyZUlEPjxjOlNlY3VyaXR5TGV2ZWw!MjAwMDwvYzpTZWN1cml0eUxldmVsPjxjOktleVVzYWdlPjxjOkVuY3J5cHRLZXk!MTwvYzpFbmNyeXB0S2V5PjwvYzpLZXlVc2FnZT48YzpGZWF0dXJlcz48YzpXTURSTVRyYW5zbWl0dGVyPjE8L2M6V01EUk1UcmFuc21pdHRlcj48YzpXTURSTVJlY2VpdmVyPjE8L2M6V01EUk1SZWNlaXZlcj48YzpXTURSTVNoYXJlZENlcnRpZmljYXRlPjE8L2M6V01EUk1TaGFyZWRDZXJ0aWZpY2F0ZT48L2M6RmVhdHVyZXM!PGM6TWFudWZhY3R1cmVyRGF0YT48YzpNYW51ZmFjdHVyZXJOYW1lPlVua25vd248L2M6TWFudWZhY3R1cmVyTmFtZT48YzpNb2RlbE5hbWU!VW5rbm93bjwvYzpNb2RlbE5hbWU!PGM6TW9kZWxOdW1iZXI!VW5rbm93bjwvYzpNb2RlbE51bWJlcj48L2M6TWFudWZhY3R1cmVyRGF0YT48L2M6RGF0YT48U2lnbmF0dXJlIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj48U2lnbmVkSW5mbz48Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLXhtbC1jMTRuLTIwMDEwMzE1Ij48L0Nhbm9uaWNhbGl6YXRpb25NZXRob2Q!PFNpZ25hdHVyZU1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vRFJNLzIwMDQvMDIvQ0VSVC9Sc2Etc2hhMSI!PC9TaWduYXR1cmVNZXRob2Q!PFJlZmVyZW5jZT48VHJhbnNmb3Jtcz48VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9DRVJUL0RhdGEiPjwvVHJhbnNmb3JtPjxUcmFuc2Zvcm0gQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy14bWwtYzE0bi0yMDAxMDMxNSI!PC9UcmFuc2Zvcm0!PC9UcmFuc2Zvcm1zPjxEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjc2hhMSI!PC9EaWdlc3RNZXRob2Q!PERpZ2VzdFZhbHVlPmNHWWJwS0hnNG0zeXZTbmt6d0tnblNHdXV6bz08L0RpZ2VzdFZhbHVlPjwvUmVmZXJlbmNlPjwvU2lnbmVkSW5mbz48U2lnbmF0dXJlVmFsdWU!VklTWWtEV0ZmcGJGeGFlSUhCNFhFWkc5RXI1bThvalVZM3FXM0orUndjbXlBbDIyN2ZCSnNKcW1icGJzSFlMelVNZ1ZoVVNPdEVzVUF5RGN2Y0pzU293bTh6OG95eXViWmJsTjFYMVZRNWdoT0J1MGZlUzE0eWI3RjRMQjZkRmFPYTFhZEVxdnlGMFIvTHh1U3pMcXhENHJvMUNEdkhpcVlOMGVyTDFBSERnPTwvU2lnbmF0dXJlVmFsdWU!PEtleUluZm8!PEtleVZhbHVlPjxSU0FLZXlWYWx1ZT48TW9kdWx1cz50M2o1cGFFa0JLL1pFWW1IZis1SEVUVWkzSmFaZ2xreDNPbU1oOThWQllOeW9sR1EwTUpFMFgwS3dYdnVWMGRxR2JGK2ZlcEJON0c1RC9uOTE4RDdiUy9ROTZyNGYzOXFrSkRlUk1hbTg1K3p5aUhOQWpBbUdvWG44bWliUTlkZk9CZXdUUlluVVJBVEVlTHRMR01TaGJnSytESHN6WDJyUzdrUU4xYUVUOWM9PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48L1JTQUtleVZhbHVlPjwvS2V5VmFsdWU!PC9LZXlJbmZvPjwvU2lnbmF0dXJlPjwvYzpDZXJ0aWZpY2F0ZT48YzpDZXJ0aWZpY2F0ZSBjOlZlcnNpb249IjIuMCIgeG1sbnM6Yz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9jZXJ0Ij48YzpEYXRhIHhtbG5zPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIHhtbG5zOm09Imh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8xMS9tc2xwIj48YzpTZWN1cml0eVZlcnNpb24!My44LjAuMTwvYzpTZWN1cml0eVZlcnNpb24!PGM6UHVibGljS2V5PjxLZXlWYWx1ZT48UlNBS2V5VmFsdWU!PE1vZHVsdXM!dDNqNXBhRWtCSy9aRVltSGYrNUhFVFVpM0phWmdsa3gzT21NaDk4VkJZTnlvbEdRME1KRTBYMEt3WHZ1VjBkcUdiRitmZXBCTjdHNUQvbjkxOEQ3YlMvUTk2cjRmMzlxa0pEZVJNYW04NSt6eWlITkFqQW1Hb1huOG1pYlE5ZGZPQmV3VFJZblVSQVRFZUx0TEdNU2hiZ0srREhzelgyclM3a1FOMWFFVDljPTwvTW9kdWx1cz48RXhwb25lbnQ!QVFBQjwvRXhwb25lbnQ!PC9SU0FLZXlWYWx1ZT48L0tleVZhbHVlPjwvYzpQdWJsaWNLZXk!PFZhbGlkYXRpb25NZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL2RybS8yMDA0LzAyL2NlcnQvdmFsaWRhdGVfdjIiIFZlcnNpb249IjIuMCI!PC9WYWxpZGF0aW9uTWV0aG9kPjxjOlNlY3VyaXR5TGV2ZWw!MjAwMDwvYzpTZWN1cml0eUxldmVsPjxjOktleVVzYWdlPjxjOlNpZ25DZXJ0aWZpY2F0ZT4xPC9jOlNpZ25DZXJ0aWZpY2F0ZT48L2M6S2V5VXNhZ2U!PGM6RmVhdHVyZXM!PG06V01EUk1UcmFuc21pdHRlcj4xPC9tOldNRFJNVHJhbnNtaXR0ZXI!PC9jOkZlYXR1cmVzPjxjOk1hbnVmYWN0dXJlckRhdGE!PGM6TWFudWZhY3R1cmVyTmFtZT5NaWNyb3NvZnQ8L2M6TWFudWZhY3R1cmVyTmFtZT48L2M6TWFudWZhY3R1cmVyRGF0YT48L2M6RGF0YT48U2lnbmF0dXJlIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj48U2lnbmVkSW5mbz48Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLXhtbC1jMTRuLTIwMDEwMzE1Ij48L0Nhbm9uaWNhbGl6YXRpb25NZXRob2Q!PFNpZ25hdHVyZU1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vRFJNLzIwMDQvMDIvQ0VSVC9Sc2Etc2hhMSI!PC9TaWduYXR1cmVNZXRob2Q!PFJlZmVyZW5jZT48VHJhbnNmb3Jtcz48VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9DRVJUL0RhdGEiPjwvVHJhbnNmb3JtPjxUcmFuc2Zvcm0gQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy14bWwtYzE0bi0yMDAxMDMxNSI!PC9UcmFuc2Zvcm0!PC9UcmFuc2Zvcm1zPjxEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjc2hhMSI!PC9EaWdlc3RNZXRob2Q!PERpZ2VzdFZhbHVlPjJjRmtmYkNYQ21GSS9jSXF0SGpEenF2UTZpRT08L0RpZ2VzdFZhbHVlPjwvUmVmZXJlbmNlPjwvU2lnbmVkSW5mbz48U2lnbmF0dXJlVmFsdWU!TzRWWUVHWjBMdElzQ01LcUYyd2ROMG9TMmdIS2g2cUV4cEN2ZWp3TWphTndVc1dHRVAwbVZocWp0eVprOWp1ZHRodFBqdERHUERnMERMNWcxOHNtMWgvUHJlcHF1SFVia0NPejU5YUhIRGZqRXMyYVFZbW5hbnRmeFFEWWQxQnJBc25Sa3Flbk1RWWFPS1J3dWlycitXMWxNblVUZXYvUzN5aGtNYXBuZkYwPTwvU2lnbmF0dXJlVmFsdWU!PEtleUluZm8!PEtleVZhbHVlPjxSU0FLZXlWYWx1ZT48TW9kdWx1cz53VFI2T0F0ajNydjZxNHprTWc2ak5DSkloaEVFblBwMDNocnlnNkprSWRhanI4RE5ra3RSWlAxNlRzOXpaWE10UHRJSjF5aGtGT3RkclFTZ1FOamlGdm9WZk5BclNxcHpzN2RZelozNUM1WEU0K0Jid2dzOWNwVTc0UEFERk84MTZtWEpZTGx4N3lEcWdPZXVleTE3UGhVTkhteXFOcE9pSGI4bTljcjZPZXM9PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48L1JTQUtleVZhbHVlPjwvS2V5VmFsdWU!PC9LZXlJbmZvPjwvU2lnbmF0dXJlPjwvYzpDZXJ0aWZpY2F0ZT48YzpDZXJ0aWZpY2F0ZSBjOlZlcnNpb249IjIuMCIgeG1sbnM6Yz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9jZXJ0Ij48YzpEYXRhIHhtbG5zPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIHhtbG5zOm09Imh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8xMS9tc2xwIj48YzpTZWN1cml0eVZlcnNpb24!NC4wLjAuMTwvYzpTZWN1cml0eVZlcnNpb24!PGM6UHVibGljS2V5PjxLZXlWYWx1ZT48UlNBS2V5VmFsdWU!PE1vZHVsdXM!d1RSNk9BdGozcnY2cTR6a01nNmpOQ0pJaGhFRW5QcDAzaHJ5ZzZKa0lkYWpyOEROa2t0UlpQMTZUczl6WlhNdFB0SUoxeWhrRk90ZHJRU2dRTmppRnZvVmZOQXJTcXB6czdkWXpaMzVDNVhFNCtCYndnczljcFU3NFBBREZPODE2bVhKWUxseDd5RHFnT2V1ZXkxN1BoVU5IbXlxTnBPaUhiOG05Y3I2T2VzPTwvTW9kdWx1cz48RXhwb25lbnQ!QVFBQjwvRXhwb25lbnQ!PC9SU0FLZXlWYWx1ZT48L0tleVZhbHVlPjwvYzpQdWJsaWNLZXk!PFZhbGlkYXRpb25NZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL2RybS8yMDA0LzAyL2NlcnQvdmFsaWRhdGVfdjIiIFZlcnNpb249IjIuMCI!PC9WYWxpZGF0aW9uTWV0aG9kPjxjOlNlY3VyaXR5TGV2ZWw!MjAwMDwvYzpTZWN1cml0eUxldmVsPjxjOktleVVzYWdlPjxjOlNpZ25DZXJ0aWZpY2F0ZT4xPC9jOlNpZ25DZXJ0aWZpY2F0ZT48L2M6S2V5VXNhZ2U!PGM6RmVhdHVyZXM!PG06V01EUk1UcmFuc21pdHRlcj4xPC9tOldNRFJNVHJhbnNtaXR0ZXI!PC9jOkZlYXR1cmVzPjxjOk1hbnVmYWN0dXJlckRhdGE!PGM6TWFudWZhY3R1cmVyTmFtZT5NaWNyb3NvZnQ8L2M6TWFudWZhY3R1cmVyTmFtZT48L2M6TWFudWZhY3R1cmVyRGF0YT48L2M6RGF0YT48U2lnbmF0dXJlIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj48U2lnbmVkSW5mbz48Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLXhtbC1jMTRuLTIwMDEwMzE1Ij48L0Nhbm9uaWNhbGl6YXRpb25NZXRob2Q!PFNpZ25hdHVyZU1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vRFJNLzIwMDQvMDIvQ0VSVC9Sc2Etc2hhMSI!PC9TaWduYXR1cmVNZXRob2Q!PFJlZmVyZW5jZT48VHJhbnNmb3Jtcz48VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9DRVJUL0RhdGEiPjwvVHJhbnNmb3JtPjxUcmFuc2Zvcm0gQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy14bWwtYzE0bi0yMDAxMDMxNSI!PC9UcmFuc2Zvcm0!PC9UcmFuc2Zvcm1zPjxEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjc2hhMSI!PC9EaWdlc3RNZXRob2Q!PERpZ2VzdFZhbHVlPlFFWmltSGQ2ZmZvUENDaFhYVXBRNFZMNzMxRT08L0RpZ2VzdFZhbHVlPjwvUmVmZXJlbmNlPjwvU2lnbmVkSW5mbz48U2lnbmF0dXJlVmFsdWU!Q3Z4MlFraEMvVEk0UHhpM1NqYkprb0JxNlcvV2JxMXhWU21HN1VsR0lRR1Qwd0lqWTgvT2RkK2tOZkpCajVIQjRQb09TSWFRNTlFNEVXaGwrVkdyejJWVXBPVjZXUnp0MlBwVmRqODltM2pHdjN6S3psZFhsTXV1ejJRT0lieG1tUUF6WnI5aHo4Z1NFeHJqcktBekt2R0VQWUFHcDhCbUVybUI2ZzdZWXQ4PTwvU2lnbmF0dXJlVmFsdWU!PEtleUluZm8!PEtleVZhbHVlPjxSU0FLZXlWYWx1ZT48TW9kdWx1cz5wam9lV0xTVExEb25RRzhTaGU2UWhrWWJZb3R0OWZQWjh0SGRCMTI4WkVUY2dobjVLSG95aW43SGtKRWNQSjBFZzRVZFN2YTBLRElZRGpBM0VYZDY5UjNDTjJXcC9ReU9vMFpQWVdZcDNOWHBKNzAwdEtQZ0lwbHpvNXdWZC82OWc3aitqOE02Nlc3Vk5tRHdhTnM5bURjMXAyK1ZWTXNEaE9zVi9BdTZFK0U9PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48L1JTQUtleVZhbHVlPjwvS2V5VmFsdWU!PC9LZXlJbmZvPjwvU2lnbmF0dXJlPjwvYzpDZXJ0aWZpY2F0ZT48L2M6Q2VydGlmaWNhdGVDb2xsZWN0aW9uPg==</MACHINECERTIFICATE><REVINFO></REVINFO><CLIENTVERSION>11.0.8102.0</CLIENTVERSION><SECURITYVERSION>2.9.0.1</SECURITYVERSION><APPSECURITY>50</APPSECURITY><SUBJECTID1>221</SUBJECTID1><SUBJECTID2></SUBJECTID2></CLIENTINFO>";
            return AcquireMediaLicensesWeb(userPuid, passportPuid, ipAddress, clientInfo, idPairs);
        }

        public static MediaLicense[] AcquireMediaLicensesWeb(
            ulong userPuid, 
            ulong passportPuid, 
            String ipAddress, 
            String clientInfo, 
            params MediaInstanceIdOfferIdPair[] idPairs)
        {
            XSigWebClient web = new XSigWebClient();
            web.UserAgent = "zune/00.05.0187.00";
            web.PassportPuid = passportPuid;
            web.UserPuid = userPuid;
            if (ipAddress != null)
            {
                web.IPAddress = ipAddress;
            }

            return web.AcquireMediaLicenses(idPairs.Select(p => p.miid.ToString()).ToArray(),
                                            idPairs.Select(p => p.oid.ToString()).ToArray(),
                                            userPuid.ToString(), clientInfo);
        }

        public static Acknowledgement[] AcknowledgeLicensesDeliveryWeb(ulong userPuid, ulong passportPuid, params MediaInstanceIdOfferIdPair[] idPairs)
        {
            XSigWebClient web = new XSigWebClient();
            web.UserAgent = "zune/00.05.0187.00";
            web.PassportPuid = passportPuid;
            web.UserPuid = userPuid;

            return web.AcknowledgeLicensesDelivery(idPairs.Select(p => p.miid.ToString()).ToArray(),
                                                   idPairs.Select(p => p.oid.ToString()).ToArray(),
                                                   userPuid.ToString());
        }

        public static Availability[] CheckLicensesAvalabilityWeb(ulong userPuid, ulong passportPuid, params MediaInstanceIdOfferIdPair[] idPairs)
        {
            return CheckLicensesAvalabilityWeb(userPuid, passportPuid, null, idPairs);
        }

        public static Availability[] CheckLicensesAvalabilityWeb(ulong userPuid, ulong passportPuid, String ipAddress, params MediaInstanceIdOfferIdPair[] idPairs)
        {
            XSigWebClient web = new XSigWebClient();
            web.UserAgent = "zune/00.05.0187.00";
            web.PassportPuid = passportPuid;
            web.UserPuid = userPuid;

            if (ipAddress != null)
            {
                web.IPAddress = ipAddress;
            }

            return web.CheckLicensesAvailability(idPairs.Select(p => p.miid.ToString()).ToArray(),
                                          idPairs.Select(p => p.oid.ToString()).ToArray(),
                                          userPuid.ToString());
        }

        public static XRLRefreshGameLicense GenerateRefreshGameLicenseRequest(ulong userPuid, ulong machinePuid, ContentLicense license)
        {
            var refresh = new XRLRefreshGameLicense();

            refresh.Request.license = (Byte[])license;
            refresh.Request.licenseLength = (ushort)refresh.Request.license.Length;

            refresh.Request.userId = userPuid;
            refresh.Request.machineId = machinePuid;

            return refresh;
        }

        public static ContentLicense RefreshGameLicense(ulong userPuid, ulong machinePuid, byte[] contentId)
        {
            return RefreshGameLicense(userPuid, machinePuid, SigTest.License.Utils.GenerateLicenseData(contentId, new ulong[] { userPuid }));
        }

        public static ContentLicense RefreshGameLicense(ulong[] userPuids, ulong machinePuid, byte[] contentId)
        {
            if (userPuids == null)
            {
                throw new ArgumentNullException("userPuids");
            }

            return RefreshGameLicense(userPuids[0], machinePuid, SigTest.License.Utils.GenerateLicenseData(contentId, userPuids));
        }

        public static ContentLicense RefreshGameLicense(ulong userPuid, ulong machinePuid, ContentLicense license)
        {
            XRLRefreshGameLicense refresh = GenerateRefreshGameLicenseRequest(userPuid, machinePuid, license);

            if (refresh.Execute())
            {
                ContentLicense refreshedLicense = new ContentLicense();
                refreshedLicense.ReadBytes(refresh.Response.license);

                return refreshedLicense;
            }
            else
            {
                throw new XErrException(refresh.XErr, refresh.GetDumpString());
            }
        }

        #endregion //Licensing

        #region LicenseMigration
        public void UpdateLicenseTransferState(ulong userPuid, UpdateTransferStateEnum command)
        {
            XRLUpdateLicenseTransferState update = new XRLUpdateLicenseTransferState();

            update.Request.command = command;
            update.Request.userPuid = userPuid;

            if (!update.Execute())
            {                
                throw new XErrException(update.XErr, update.GetDumpString());
            }
        }

        public GetLicenseTransferStateResponse GetLicenseTransferState(ulong userPuid)
        {
            XRLGetLicenseTransferState get = new XRLGetLicenseTransferState();

            get.Request.userPuid = userPuid;

            if (get.Execute())
            {
                // Just return the whole response cause there's a bunch of data in it.
                return get.Response;
            }
            else
            {
                throw new XErrException(get.XErr, get.GetDumpString());
            }
        }
        #endregion // LicenseMigration

        #region CertificateStuff
        public CreateCertificateResponse CreateCertificate(ulong userPuid, string appId, byte[] publicKey)
        {
            XRLCreateCertificate create = new XRLCreateCertificate();

            create.Request.appId = appId;
            create.Request.userPuid = userPuid;
            create.Request.PubKey = publicKey;

            if (create.Execute())
            {
                return create.Response;
            }
            else
            {
                throw new XErrException(create.XErr, create.GetDumpString());
            }
        }

        public CreateCertificateResponse CreateCertificate(ulong userPuid, ulong machinePuid, string appId, byte[] publicKey)
        {
            XRLCreateCertificate create = new XRLCreateCertificate();

            create.Request.appId = appId;
            create.Request.userPuid = userPuid;
            create.Request.PubKey = publicKey;

            if (create.Execute(machinePuid))
            {
                return create.Response;
            }
            else
            {
                throw new XErrException(create.XErr, create.GetDumpString());
            }
        }

        public CreateCertificate2Response CreateCertificate2(byte[] consoleCertificate, byte[] signature)
        {
            return CreateCertificate2("generic_ssl", consoleCertificate, signature);
        }

        public CreateCertificate2Response CreateCertificate2(string appId, byte[] consoleCertificate, byte[] signature)
        {
            XRLCreateCertificate2 create = new XRLCreateCertificate2();

            create.Request.appId = appId;
            create.Request.ConsoleCertificate = consoleCertificate;
            create.Request.Signature = signature;

            if (create.Execute())
            {
                return create.Response;
            }
            else
            {
                throw new XErrException(create.XErr, create.GetDumpString());
            }
        }

        public XmstvCreateCertificateResponse XmstvCreateCertificate(byte[] avPubKey, byte[] nonAvPubKey, byte[] keyedHash, uint flags, ulong keyNonce)
        {
            XRLXmstvCreateCertificate create = new XRLXmstvCreateCertificate();

            create.Request.AvPubKey = avPubKey;
            create.Request.NonAvPubKey = nonAvPubKey;
            create.Request.KeyedHash = keyedHash;
            create.Request.Flags = flags;
            create.Request.KeyNonce = keyNonce;

            if (create.Execute())
            {
                return create.Response;
            }
            else
            {
                throw new XErrException(create.XErr, create.GetDumpString());
            }
        }

        public void ValidateCertificate()
        {
            XRLValidateCertificate validate = new XRLValidateCertificate();
        }
        #endregion //CertificateStuff
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\dvt\LicenseDvts.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Net;
using System.Security.Cryptography;

using ServerTestFramework;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.config;
using xonline.common.offer;
using xonline.common.billing;
using xonline.common.diagnostics;
using xonline.common.puidmgr;
using xonline.common.stfutil;
using xonline.common.utilities;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.user;

namespace LicenseDvts
{
    public class LicenseDvtsSuite: TestSuite
    {
    }

    [TestGroup]
    public class LicenseDvtsGroup: TestNode
    {
        private static xonline.common.service.XOService UacsServiceId = xonline.common.service.XOService.User_Account;
        private static xonline.common.service.XOService XbosServiceId = xonline.common.service.XOService.Billing_Offering;

        [TestCase, Description("Tests the AcquireMediaLicenses API for the binary protocol.")]
        class TestAcquireMediaLicenses : TestBase
        {
            // Breakpont:  XmstvDvt.XmstvDvtGroup.TestAcquireMediaLicenses.Execute
            protected override void Execute()
            {
                // create a new account
                CreateLiveAccountRequest claReq = AccountsUtil.CreateAdultUserRequest(CardTypeEnum.Visa);
                User u = AccountsUtil.CreateUserFromRequest(claReq);
                CSGInfo slot = AccountsUtil.CreateSGInfoSlot(u);

                // get the paymentInstrumentId
                GetPaymentInstrumentsRequest piReq = new GetPaymentInstrumentsRequest();
                piReq.userPuid = u.Puid;
                piReq.machinePuid = u.MachinePuid;
                GetPaymentInstrumentsResponse piResp = new GetPaymentInstrumentsResponse();
                XRLObject2 xrlo = piResp;
                uint hr = StfXrlUtil.PostXrlRequest(ref slot, UacsServiceId, piReq.Xrl, piReq, ref xrlo);
                Assert.IsTrue(HResult.Succeeded(hr), "0x" + hr.ToString("x8"));

                // get the points balance (should be 0) to create the user's dmp account
                XeGetPointsBalanceRequest gpbReq = new XeGetPointsBalanceRequest();
                gpbReq.userPuid = u.Puid;
                gpbReq.machinePuid = slot.machinePuid;
                XeGetPointsBalanceResponse gpbResp = new XeGetPointsBalanceResponse();
                xrlo = gpbResp;
                hr = StfXrlUtil.PostXrlRequest(ref slot, UacsServiceId, gpbReq.Xrl, gpbReq, ref xrlo);
                Assert.IsTrue(HResult.Succeeded(hr), "0x" + hr.ToString("x8"));

                // now purchase some points so we can buy something else
                XeOfferPurchaseRequest opReq = new XeOfferPurchaseRequest();
                opReq.userPuid = u.Puid;
                opReq.countryID = u.CountryId;
                opReq.languageID = (ushort) u.LanguageId;
                opReq.tier = (byte) u.Tier;
                opReq.machinePuid = slot.machinePuid;
                opReq.offerIDs = new ulong[] { 0xFFFE07D10FF00009 };
                opReq.offerIDLength = (uint) opReq.offerIDs.Length;
                opReq.paymentType = (uint) PaymentTypeEnum.CreditCard;
                opReq.billingToken = "";
                opReq.paymentInstrumentID = piResp.paymentInstrumentInfo[0].paymentInstrumentId;
                hr = StfXrlUtil.PostXrlRequest(ref slot, XbosServiceId, opReq.Xrl, opReq);
                Assert.IsTrue(HResult.Succeeded(hr), "0x" + hr.ToString("x8"));

                // buy a test media (populated by ems test data msi, then hacked by custom dwalther scripts)
                PurchaseOffersRequest poReq = new PurchaseOffersRequest();
                poReq.userPuid = u.Puid;
                poReq.machinePuid = u.MachinePuid;
                poReq.offers = new OfferExpectedPrice[1];
                poReq.offers[0] = new OfferExpectedPrice();
                poReq.offers[0].offerId = new Guid("0FF39000-0000-0000-0000-000000000000");
                poReq.offers[0].expectedPrice = 200;
                poReq.offersLength = (uint) poReq.offers.Length;
                poReq.paymentType = (uint) PaymentTypeEnum.Points;
                hr = StfXrlUtil.PostXrlRequest(ref slot, XbosServiceId, poReq.Xrl, poReq);
                Assert.IsTrue(HResult.Succeeded(hr), "0x" + hr.ToString("x8"));

                // now we can query to get the license for the purchased media
                AcquireMediaLicensesRequest request = new AcquireMediaLicensesRequest();
                request.userPuid = u.Puid;

                byte[] challengeInBytes = LoadClientInfo();
                xonline.common.protocol.BlockSerializer serializer = new xonline.common.protocol.BlockSerializer(challengeInBytes, 1, AcquireMediaLicensesRequest.CLIENT_INFO_BLOCK_MAX_COUNT);
                if (serializer.IsBlockCountOutOfRange)
                {
                    string errorString = "In TestAcquireMediaLicenses, the client-info is out of range.";
                    Global.RO.Info(errorString);
                    throw new Exception(errorString);
                }

                request.clientInfoBlocks = serializer.Serialize();
                request.clientInfoBlockCount = (ushort)request.clientInfoBlocks.Length;

                request.idPairs = new MediaInstanceIdOfferIdPair[1];
                request.idPairs[0] = new MediaInstanceIdOfferIdPair();
                request.idPairs[0].miid = new Guid("AAAAAAAA-AAAA-AAAA-AAAA-100000000000");
                request.idPairs[0].oid = new Guid("0FF39000-0000-0000-0000-000000000000");

                AcquireMediaLicensesResponse response = new AcquireMediaLicensesResponse();
                XRLObject2 xresp = response;

                hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Signature_Server, request.Xrl, request, ref xresp);

                if (HResult.Succeeded(hr))
                {
                    for (int idx = 0; idx < response.mediaLicenses.Length; ++idx)
                    {
                        if (response.mediaLicenses[idx].idPair.miid != request.idPairs[idx].miid)
                        {
                            Global.RO.Info("License for miid {0} is wrong.", request.idPairs[idx].miid);
                            hr = HResult.E_FAIL;
                        }
                        else if (response.mediaLicenses[idx].idPair.oid != request.idPairs[idx].oid)
                        {
                            Global.RO.Info("License for oid {0} is wrong.", request.idPairs[idx].oid);
                            hr = HResult.E_FAIL;
                        }
                        else if (response.mediaLicenses[idx].hr != 0)
                        {
                            Global.RO.Info("Status code for miid {0} is 0x{1:X8}.", request.idPairs[idx].miid, response.mediaLicenses[idx].hr);
                            hr = HResult.E_FAIL;
                        }
                    }
                }

                ResultCode = HResult.Failed(hr) ? TEST_RESULTS.FAILED : TEST_RESULTS.PASSED;
            }

            private static byte[] LoadClientInfo()
            {
                string file = String.Format("{0}{1}", System.Environment.CurrentDirectory, "\\suites\\clientinfo.bin");

                FileInfo fileInfo = new FileInfo(file);
                using (BinaryReader reader = new BinaryReader(new FileStream(file, FileMode.Open)))
                {
                    return reader.ReadBytes((int)fileInfo.Length);
                }
            }
        }

        [TestCase, Description("Tests the AcknowledgeLicensesDelivery API for the binary protocol.")]
        class TestAcknowledgeLicensesDelivery : TestBase
        {
            // Breakpont:  XmstvDvt.XmstvDvtGroup.TestAcquireMediaLicenses.Execute
            protected override void Execute()
            {
                // Make sure to get data from GenerateTestData in order for this
                // to work.  Right now that must be done manually.
                CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
                slot.machinePuid = 0xfa00ffffdeadbeef;

                AcknowledgeLicensesDeliveryRequest request = new AcknowledgeLicensesDeliveryRequest();
                request.userPuid = 0xfa00ffffe3e3e3e3;
                request.idPairs = new MediaInstanceIdOfferIdPair[5];
                for (int idx = 0; idx < request.idPairs.Length; ++idx)
                {
                    request.idPairs[idx] = new MediaInstanceIdOfferIdPair();
                    request.idPairs[idx].miid = Guid.NewGuid();
                    request.idPairs[idx].oid = Guid.NewGuid();
                }

                AcknowledgeLicensesDeliveryResponse response = new AcknowledgeLicensesDeliveryResponse();
                XRLObject2 xresp = response;

                uint hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Signature_Server, request.Xrl, request, ref xresp);

                if (HResult.Succeeded(hr))
                {
                    for (int idx = 0; idx < response.acknowledgements.Length; ++idx)
                    {
                        if (response.acknowledgements[idx].idPair.miid != request.idPairs[idx].miid)
                        {
                            Global.RO.Info("License for miid {0} is wrong.", request.idPairs[idx].miid);
                            hr = HResult.E_FAIL;
                        }
                        else if (response.acknowledgements[idx].idPair.oid != request.idPairs[idx].oid)
                        {
                            Global.RO.Info("License for oid {0} is wrong.", request.idPairs[idx].oid);
                            hr = HResult.E_FAIL;
                        }
                        else if (response.acknowledgements[idx].hr != 0)
                        {
                            Global.RO.Info("Status code for miid {0} is 0x{1:X8}.", request.idPairs[idx].miid, response.acknowledgements[idx].hr);
                            hr = HResult.E_FAIL;
                        }
                    }
                }

                ResultCode = HResult.Failed(hr) ? TEST_RESULTS.FAILED : TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Tests the RefreshGameLicense API for the binary protocol.")]
        class TestRefreshGameLicense : TestBase
        {
            // Breakpont:  XmstvDvt.XmstvDvtGroup.TestAcquireMediaLicenses.Execute
            protected override void Execute()
            {
                // Make sure to get data from GenerateTestData in order for this
                // to work.  Right now that must be done manually.
                CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
                slot.machinePuid = 0xfa000000008f00c8;
                slot.userPuid0 = 0x93CF3CF3D5384;

                RefreshGameLicenseRequest request = new RefreshGameLicenseRequest();
                request.userId = slot.userPuid0;
                request.machineId = slot.machinePuid;

                if (useSavedInfo)
                {
                    request.license = LoadLicenseInfo();
                }
                else
                {
                    ContentLicenseSignature signature = new ContentLicenseSignature();
                    signature.signatureType = 0;
                    signature.reserved = new byte[ContentLicense.ReservedLen];
                    signature.signature = new byte[ContentLicense.LiveSignatureLen];

                    ContentLicenseBody body = new ContentLicenseBody();
                    body.licensees = new ContentLicensee[ContentLicense.LicenseesLen];

                    for (int i = 0; i < body.licensees.Length; i++)
                    {
                        body.licensees[i] = new ContentLicensee();
                        body.licensees[i].licenseeId = 0;
                        body.licensees[i].licenseBits = 0;
                        body.licensees[i].licenseFlags = 0;
                    }

                    body.ContentId = new byte[(int)XOn.XONLINE_CONTENT_ID_LEN] { 0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF };


                    ContentLicense license = new ContentLicense();
                    license.signature = signature;
                    license.body = body;

                    request.license = (byte[])license;
                }

                RefreshGameLicenseResponse response = new RefreshGameLicenseResponse();
                XRLObject2 xresp = response;

                uint hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Signature_Server, request.Xrl, request, ref xresp);

                if (HResult.Succeeded(hr))
                {
                    if (writeInfo)
                    {
                        WriteLicenseInfo(response.license);
                    }
                    else
                    {
                        byte[] licenseInfo = LoadLicenseInfo();

                        if (response.license.Length == licenseInfo.Length)
                        {
                            // Can't find a better way to do a memcmp
                            for (int idx = 0; idx < response.license.Length; ++idx)
                            {
                                if (licenseInfo[idx] != response.license[idx])
                                {
                                    Global.RO.Info("Returned license not the same as expected license.");
                                    hr = HResult.E_FAIL;
                                    break;

                                }
                            }
                        }
                        else
                        {
                            Global.RO.Info("Returned license not the same length as expected license.");
                            hr = HResult.E_FAIL;
                        }
                    }
                }

                ResultCode = HResult.Failed(hr) ? TEST_RESULTS.FAILED : TEST_RESULTS.PASSED;
            }

            private static byte[] LoadLicenseInfo()
            {
                string file = String.Format("{0}{1}", System.Environment.CurrentDirectory, "\\suites\\license.bin");

                FileInfo fileInfo = new FileInfo(file);
                using (BinaryReader reader = new BinaryReader(new FileStream(file, FileMode.Open)))
                {
                    return reader.ReadBytes((int)fileInfo.Length);
                }
            }

            private static void WriteLicenseInfo(byte[] license)
            {
                string file = String.Format("{0}{1}", System.Environment.CurrentDirectory, "\\suites\\license.bin");

                FileInfo fileInfo = new FileInfo(file);
                using (BinaryWriter writer = new BinaryWriter(new FileStream(file, FileMode.Create)))
                {
                    writer.Write(license);
                }
            }

            private bool writeInfo = false;
            private bool useSavedInfo = false;
        }

        [TestCase, Description("Tests the License transfer flow for the binary protocol")]
        class TestTransferUserLicenses : TestBase
        {
            protected override void Execute()
            {
                CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
                slot.machinePuid = 0xfa00ffffdeadbeef;

//                ulong userPuid = 0x0009FFFFFFFFFFFF;
                ulong userPuid = GetIdForGamerTag("xblob");
                WebHeaderCollection headers = new WebHeaderCollection();
                HTTPAuthData authdata = new HTTPAuthData(0, (uint)Dns.GetHostEntry(Environment.MachineName).AddressList[0].GetHashCode(), 1, userPuid, 0, 12, 1);
                headers.Add(XHttpHdr.HTTPAUTHDATA + ":" + authdata.GetBase64EncodedString());
                
                GetLicenseTransferStateRequest getRequest = new GetLicenseTransferStateRequest();

                getRequest.userPuid = userPuid;

                GetLicenseTransferStateResponse getResp = new GetLicenseTransferStateResponse();
                XRLObject2 xresp = getResp;

                uint hr;
                hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Signature_Server, true, getRequest.Xrl, headers, getRequest, ref xresp);

                if (HResult.Failed(hr))
                {
                    Global.RO.Info(String.Format("Failed to get the initial status hr={0:X8}", hr));
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                if (getResp.currentStatus != LicenseTransferStatusEnum.NotStarted || !getResp.restartAllowed)
                {
                    Global.RO.Info(String.Format("Not in startable state, status={0}, restartAllowed={1}", getResp.currentStatus, getResp.restartAllowed));
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                UpdateLicenseTransferStateRequest updRequest = new UpdateLicenseTransferStateRequest();
                byte[] resp;

                Global.RO.Info("Trying to send invalid complete command.");
                updRequest.command = UpdateTransferStateEnum.Complete;
                updRequest.userPuid = userPuid;
                hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Signature_Server, true, updRequest.Xrl, headers, updRequest, out resp);

                if (HResult.Succeeded(hr) || hr != HResult.XONLINE_E_SIGNATURE_LICENSE_TRANSFER_BAD_COMMAND)
                {
                    Global.RO.Info(String.Format("Unable to get the correct failure for bad command. hr={0:X8}", hr));
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                Global.RO.Info("Trying to send cancel command.");
                updRequest.userPuid = userPuid;
                updRequest.command = UpdateTransferStateEnum.Cancel;
                hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Signature_Server, true, updRequest.Xrl, updRequest, out resp);

                if (HResult.Failed(hr) && hr != HResult.XONLINE_E_SIGNATURE_LICENSE_TRANSFER_BAD_COMMAND)
                {
                    Global.RO.Info(String.Format("Failed to cancel transfer hr={0:X8}", hr));
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
                Global.RO.Info("Trying to send start command.");
                updRequest.userPuid = userPuid;
                updRequest.command = UpdateTransferStateEnum.Start;
                hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Signature_Server, true, updRequest.Xrl, updRequest, out resp);

                if (HResult.Failed(hr))
                {
                    Global.RO.Info(String.Format("Failed to start transfer hr={0:X8}", hr));
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                // Currently, this test will fail, because it needs to wait for the machine to sign-in.  Doing it manually.
                /*Global.RO.Info("Trying to send complete command.");
                updRequest.userPuid = 0x0009FFFFFFFFFFFF;
                updRequest.command = UpdateTransferStateEnum.Complete;
                hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Signature_Server, true, updRequest.Xrl, updRequest, out resp);

                if (HResult.Failed(hr))
                {
                    Global.RO.Info(String.Format("Failed to start transfer hr={0:X8}", hr));
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                } */
                
                ResultCode = TEST_RESULTS.PASSED;
            }

            static ulong GetIdForGamerTag(string gamertag)
            {
                ulong puid = XCache.LookupPUID(gamertag);

                if (puid == 0)
                    throw new Exception(String.Format("Can't find puid for gamertag '{0}', please create account for user", gamertag));

                return puid;
            }
        }

        [TestCase, Description("Tests the signed header api.")]
        class TestGetSignedHeader : TestBase
        {
            protected override void Execute()
            {
                CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
                slot.machinePuid = 0xfa00ffffdeadbeef;

                WebHeaderCollection headers = new WebHeaderCollection();
                HTTPAuthData authdata = new HTTPAuthData(0, (uint)Dns.GetHostEntry(Environment.MachineName).AddressList[0].GetHashCode(), 1, 0, 0, 12, 1);
                headers.Add(XHttpHdr.HTTPAUTHDATA + ":" + authdata.GetBase64EncodedString());

                GetSignedHeaderRequest req = new GetSignedHeaderRequest();

                byte[] fileBytes = GetFileBytes(String.Format("{0}{1}", System.Environment.CurrentDirectory, @"\suites\license.bin"));
                req.fileSize = (uint)fileBytes.Length;
                req.fileType = 1;
                SHA1Managed sha1 = new SHA1Managed();
                req.fileHash = sha1.ComputeHash(fileBytes);

                GetSignedHeaderResponse resp = new GetSignedHeaderResponse();
                XRLObject2 xresp = resp;

                uint hr;
                hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Signature_Server, true, req.Xrl, headers, req, ref xresp);

                if (HResult.Failed(hr))
                {
                    Global.RO.Info(String.Format("Failed to get the initial status hr={0:X8}", hr));
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                ResultCode = TEST_RESULTS.PASSED;
            }

            private static byte[] GetFileBytes(string fileName)
            {
                FileInfo fileInfo = new FileInfo(fileName);
                using (BinaryReader reader = new BinaryReader(new FileStream(fileName, FileMode.Open)))
                {
                    return reader.ReadBytes((int)fileInfo.Length);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\Carbon\CreateCertificateStress.cs ===
﻿using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using System.Security.Cryptography.X509Certificates;

namespace SigTest.Carbon.Stress
{
    [TestGroup, Owner("BenRan"), TestFrequency("Regression")]
    public class CarbonStress
    {
        [TestGroup]
        public class CreateCertificateStress : TestNode
        {
            private static readonly String MaximumCertificatesSetting = "xmstv_maximumCertificatesAllowed";

            XMSTVCreateCertificateHelper requestOnlyHelper = null;
            XMSTVCreateCertificateHelper requestVerifyHelper = null;
            StressBulkHelper bulkHelper = null;

            SettingState maxCertificatesState = null;

            public override void OneTimeSetup()
            {
                // We create these in here so that we don't attempt to connect 
                // NPDB during the test node construction.  Should speed up test
                // load times.
                bulkHelper = new StressBulkHelper();

                Carbon.Utils.ChainFlagsToIgnore = X509ChainStatusFlags.PartialChain | X509ChainStatusFlags.NotTimeValid;
            }

            public override void PreRun()
            {
                // Causes the helper to load and create any users and it needs
                bulkHelper.Initialize();

                maxCertificatesState = Global.XEnv.OverrideSetting("ALL", "ALL", MaximumCertificatesSetting, "3000000");

                base.PreRun();
            }

            public override void PostRun()
            {
                if (maxCertificatesState != null)
                {
                    Global.XEnv.RestoreOverrideSettingState(maxCertificatesState);
                }

                base.PostRun();
            }

            [StressTest, Description("Perform an MSTV Certificate Request")]
            public void RequestOnly()
            {
                requestOnlyHelper = new XMSTVCreateCertificateHelper();
                requestOnlyHelper.ExecutePositive(false, bulkHelper.GetNextBulkMachine());
            }

            [StressTest, Description("Perform an MSTV Certificate Request and verify the response")]
            public void RequestAndVerify()
            {
                requestVerifyHelper = new XMSTVCreateCertificateHelper();
                requestVerifyHelper.ExecutePositive(true, bulkHelper.GetNextBulkMachine());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\License\StressAcquireMediaLicenses.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.billing;

namespace SigTest.License.Stress
{
    [TestGroup, Owner("BenRan"), TestFrequency("Regression")]
    public class StressAcquireMediaLicenses : TestNode
    {
        private static StressHelperQueue<AcquireMediaLicenseHelper> xboxHelpers;
        private static StressHelperQueue<AcquireMediaLicenseHelper> zuneHelpers;

        public override void OneTimeSetup()
        {
            xboxHelpers = new StressHelperQueue<AcquireMediaLicenseHelper>();
            xboxHelpers.HelperCreated += (s, e) =>
            {
                Global.RO.Debug("Created new Xbox AcquireMediaLicense helper.");
                
                e.Helper.Reset();
                e.Helper.ValidateResponse = false;

                // Since we clear purchase information after each acquire,
                // we don't need to pre purchase anything.
            };

            zuneHelpers = new StressHelperQueue<AcquireMediaLicenseHelper>();
            zuneHelpers.HelperCreated += (s, e) =>
            {
                Global.RO.Debug("Created new Zune AcquireMediaLicense helper.");

                e.Helper.Reset();
                e.Helper.UseXSigWeb = true;
                e.Helper.ValidateResponse = false;

                // Since we clear purchase information after each acquire,
                // we don't need to pre purchase anything.
            };
        }

        public override void PreRun()
        {
            xboxHelpers.PreFill(10);
            zuneHelpers.PreFill(5);
        }

        public override void PostRun()
        {
            xboxHelpers.Cleanup();
            zuneHelpers.Cleanup();
        }

        [StressTest]
        public class AcquireMediaLicense_DTO : TestNode
        {
            VideoInformation episode;

            public override void PreRun()
            {
                // Generate a random episode
                episode = VideoInformation.Generate(LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode);
            }

            public override void Run()
            {
                AcquireMediaLicenseHelper helper = null;
                try
                {
                    // Grab a random new helper
                    helper = xboxHelpers.GetHelper();
                    // Purchase the generated video
                    helper.Purchase(episode);
                    // And acquire the license
                    helper.AcquireMediaLicense();
                    // Cleanup the user
                    helper.CleanupUser();
                }
                finally
                {
                    xboxHelpers.ReturnHelper(helper);
                }
            }

            public override void PostRun()
            {
                episode.RemoveFromCatalog();
            }
        }

        [StressTest]
        public class AcquireMediaLicense_DTO_Async : TestNode
        {
            public static Int32 InProgressCount = 0;

            VideoInformation episode;

            public override void PreRun()
            {
                // Generate a random episode
                episode = VideoInformation.Generate(LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode);
            }

            public override void Run()
            {
                // Grab a random new helper
                AcquireMediaLicenseHelper helper = xboxHelpers.GetHelper();
                // Purchase the generated video
                helper.Purchase(episode);
                // Start the acquire process
                var requestNum = System.Threading.Interlocked.Increment(ref InProgressCount);
                Global.RO.Info("Begin: " + requestNum);
                helper.BeginAcquireMediaLicense(CompleteAcquire, helper);
            }

            public void CompleteAcquire(IAsyncResult result)
            {
                var requestNum = System.Threading.Interlocked.Decrement(ref InProgressCount);
                Global.RO.Info("  End: " + requestNum);

                var helper = result.AsyncState as AcquireMediaLicenseHelper;
                try
                {
                    helper.EndAcquireMediaLicense(result);
                    helper.CleanupUser();
                }
                finally
                {
                    xboxHelpers.ReturnHelper(helper);
                }
            }

            public override void PostRun()
            {
                episode.RemoveFromCatalog();
            }
        }

        [StressTest]
        public class AcquireMediaLicense_PPV : TestNode
        {
            VideoInformation movie;

            public override void PreRun()
            {
                // Generate a random episode
                movie = VideoInformation.Generate(LicenseType.SyncCastPPV, MediaTypeInfo.Movie);
            }

            public override void Run()
            {
                AcquireMediaLicenseHelper helper = null;
                try
                {
                    // Grab a random new helper
                    helper = xboxHelpers.GetHelper();
                    // Purchase the generated video
                    helper.Purchase(movie);
                    // And acquire and ack the license
                    helper.AcquireMediaLicense();
                    helper.AcknowledgeMediaLicense();
                    // Cleanup the user
                    helper.CleanupUser();
                }
                finally
                {
                    xboxHelpers.ReturnHelper(helper);
                }
            }

            public override void PostRun()
            {
                movie.RemoveFromCatalog();
            }
        }

        [StressTest]
        public class AcquireMediaLicense_Zune : TestNode
        {
            public override void Run()
            {
                AcquireMediaLicenseHelper helper = null;
                try
                {
                    // Grab a random new helper
                    helper = zuneHelpers.GetHelper();
                    // Purchase a piece of video content
                    helper.Purchase(MediaMatrix.ZuneDTOVideoOffer_1);
                    // And acquire the license
                    helper.AcquireMediaLicense();
                    // Cleanup and return the user
                    helper.CleanupUser();
                }
                finally
                {
                    zuneHelpers.ReturnHelper(helper);
                }
            }
        }

        [StressTest]
        public class CheckLicensesAvailability_Zune : TestNode
        {
            public override void Run()
            {
                AcquireMediaLicenseHelper helper = null;
                try
                {
                    // Grab a random new helper
                    helper = zuneHelpers.GetHelper();
                    // Purchase a piece of video content
                    helper.Purchase(MediaMatrix.ZuneDTOVideoOffer_1);
                    // And check availability
                    helper.CheckLicensesAvailability();
                    // Cleanup and return the user
                    helper.CleanupUser();
                }
                finally
                {
                    zuneHelpers.ReturnHelper(helper);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\dvt\sigdevtest.cs ===
using System;
using System.Collections;
using System.IO;
using System.Net;
using System.Text;
using System.Data;
using System.Data.SqlClient;

using ServerTestFramework;
using LiveService = ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.diagnostics;
using xonline.common.service;
using xonline.common.protocol;

using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.sql.sqlclient;
using xonline.common.stfutil;


[TestGroup, DVT]
public class StatsDevTest : TestNode
{
    private const uint   TITLE_ID         = 0xfeedfeed;
    private const ulong  TEST_MACHINE_ID  = 0xf00df00df00df00d;
    private const int    MAX_USERS        = 101;
    private const int    MAX_COLUMNS      = 64;
    private const int    MAX_TEAMS        = 101;
    private const long   RATING_SEED      = 1000;
    private const int    PAGE_SIZE        = 10;
    
    private static byte[] _goodDigest = new byte[] 
        { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };
        
    private static byte[] _badDigest = new byte[] 
        { 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5 };
        
    static byte[] _badConsoleId = new byte[]  { 0xbb, 0xaa, 0xaa, 0xaa, 0xdd } ;
    const ulong _badConsolePuid = 0xbaadbaadbaadf00d;
    const uint _badTitleId = 0xbaadbaad;
    const uint _badTitleVersion = 13;
    const ulong _badUser = 0x0009FFFF000000bad;
    
    

        
    public class StatsDevTestSuite : TestSuite
    {

    }

    [TestGroupSetup]
    public void Setup()
    {
        using (SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString))
        {
            cxn.Open();

            string sqlfile = Path.Combine(Config.AssemblyDirectory, "sig_dev_test_data.sql");
            DbUtil.ExecuteSqlFile(cxn, sqlfile);
            
        }
        
        Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.xsig, "e :xsig blacklistload");
    }

    #region StatPost tests

    [TestCase]
    public void CheckRevocation_Mult()
    {
        ulong userID1 = 0x0009FFFF00000000 + (ulong)(new Random()).Next();
        ulong consolePuid = 0x0009FFFF00000000 + (ulong)(new Random()).Next();
        CSGInfo slot;
        uint hr;

        CheckRevocationRequest req = new CheckRevocationRequest();
        CheckRevocationResponse resp = new CheckRevocationResponse();
        
        req.Tuples = new ContentTuple[2];
        
        req.Tuples[0] = new ContentTuple();
        req.Tuples[0].TitleId = TITLE_ID;
        req.Tuples[0].TitleVersion = 0;
        req.Tuples[0].UserPuid = new ulong[4];
        req.Tuples[0].UserPuid[0] = userID1;
        req.Tuples[0].ConsolePuid = consolePuid;
        req.Tuples[0].Digest = _goodDigest;
        
        req.Tuples[1] = new ContentTuple();
        req.Tuples[1].TitleId = TITLE_ID;
        req.Tuples[1].TitleVersion = 0;
        req.Tuples[1].UserPuid = new ulong[4];
        req.Tuples[1].UserPuid[0] = userID1 + 1;
        req.Tuples[0].ConsolePuid = consolePuid + 1;
        req.Tuples[1].Digest = _goodDigest;
        
        slot = GlobalFakeSG.FakeSG.GetSlot();
        slot.titleId = TITLE_ID;
        slot.userPuid0 = userID1;
        
        XRLObject2 xrlo = (XRLObject2)resp;
        
        hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Signature_Server, false, req.GetXRL(), req, ref xrlo);
        Assert.AreEqual(hr, HResult.S_OK);
        
        Assert.AreEqual(resp.NumHrs, 2);
        Assert.AreEqual(resp.Hrs[0], HResult.S_OK);
        Assert.AreEqual(resp.Hrs[1], HResult.S_OK);
    }

    
    [TestCase]
    public void CheckRevocation_Digest()
    {
        ulong userID1 = 0x0009FFFF00000000 + (ulong)(new Random()).Next();
        CSGInfo slot;
        uint hr;

        CheckRevocationRequest req = CreateCheckRevocationRequest(1);
        req.Tuples[0].Digest = _badDigest;

        slot = GetSlot(TITLE_ID, userID1);
        
        CheckRevocationResponse resp = new CheckRevocationResponse();
        XRLObject2 xrlo = (XRLObject2)resp;
        
        hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Signature_Server, false, req.GetXRL(), req, ref xrlo);
        Assert.AreEqual(hr, HResult.S_OK);
        
        Assert.AreEqual(resp.NumHrs, 1);
        Assert.AreEqual(resp.Hrs[0], HResult.XONLINE_E_SIGNATURE_BANNED_DIGEST);
    }
              
    [TestCase]
    public void CheckRevocation_ConsolePuid()
    {
        ulong userID1 = 0x0009FFFF00000000 + (ulong)(new Random()).Next();
        CSGInfo slot;
        uint hr;
        
        CheckRevocationRequest req = CreateCheckRevocationRequest(1);
        req.Tuples[0].ConsolePuid = _badConsolePuid;

        slot = GetSlot(TITLE_ID, userID1);
        
        CheckRevocationResponse resp = new CheckRevocationResponse();
        XRLObject2 xrlo = (XRLObject2)resp;
        
        hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Signature_Server, false, req.GetXRL(), req, ref xrlo);
        Assert.AreEqual(hr, HResult.S_OK);
        
        Assert.AreEqual(resp.NumHrs, 1);
        Assert.AreEqual(resp.Hrs[0], HResult.XONLINE_E_SIGNATURE_BANNED_XBOX);
    }
    
    [TestCase]
    public void CheckRevocation_ConsoleId()
    {
        ulong userID1 = 0x0009FFFF00000000 + (ulong)(new Random()).Next();
        CSGInfo slot;
        uint hr;
        
        CheckRevocationRequest req = CreateCheckRevocationRequest(1);
        req.Tuples[0].ConsoleId = _badConsoleId;

        slot = GetSlot(TITLE_ID, userID1);
        
        CheckRevocationResponse resp = new CheckRevocationResponse();
        XRLObject2 xrlo = (XRLObject2)resp;
        
        hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Signature_Server, false, req.GetXRL(), req, ref xrlo);
        Assert.AreEqual(hr, HResult.S_OK);
        
        Assert.AreEqual(resp.NumHrs, 1);
        Assert.AreEqual(resp.Hrs[0], HResult.XONLINE_E_SIGNATURE_BANNED_XBOX);
    }
                   
                   
    [TestCase]
    public void CheckRevocation_TitleIdVersion()
    {
        ulong userID1 = 0x0009FFFF00000000 + (ulong)(new Random()).Next();
        CSGInfo slot;
        uint hr;
        
        CheckRevocationRequest req = CreateCheckRevocationRequest(1);
        req.Tuples[0].TitleId = _badTitleId;
        req.Tuples[0].TitleVersion = _badTitleVersion;

        slot = GetSlot(TITLE_ID, userID1);
        
        CheckRevocationResponse resp = new CheckRevocationResponse();
        XRLObject2 xrlo = (XRLObject2)resp;
        
        hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Signature_Server, false, req.GetXRL(), req, ref xrlo);
        Assert.AreEqual(hr, HResult.S_OK);
        
        Assert.AreEqual(resp.NumHrs, 1);
        Assert.AreEqual(resp.Hrs[0], HResult.XONLINE_E_SIGNATURE_BANNED_TITLE);
    }
                   
    [TestCase]
    public void CheckRevocation_User()
    {
        ulong userID1 = 0x0009FFFF00000000 + (ulong)(new Random()).Next();
        CSGInfo slot;
        uint hr;
        
        CheckRevocationRequest req = CreateCheckRevocationRequest(1);
        req.Tuples[0].UserPuid[1] = _badUser;

        slot = GetSlot(TITLE_ID, userID1);
        
        CheckRevocationResponse resp = new CheckRevocationResponse();
        XRLObject2 xrlo = (XRLObject2)resp;
        
        hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Signature_Server, false, req.GetXRL(), req, ref xrlo);
        Assert.AreEqual(hr, HResult.S_OK);
        
        Assert.AreEqual(resp.NumHrs, 1);
        Assert.AreEqual(resp.Hrs[0], HResult.XONLINE_E_SIGNATURE_BANNED_USER);
    }
                   
                   
                   
                   
                   
                   
                   
                   
    public static CSGInfo GetSlot(uint titleId, ulong userId)
    {
        CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
        slot.titleId = TITLE_ID;
        slot.userPuid0 = 0x0009FFFF00000000;
        
        return slot;
        
    }   
    
    public static CheckRevocationRequest CreateCheckRevocationRequest(int numTuples)
    {
        CheckRevocationRequest req = new CheckRevocationRequest();
                
        req.Tuples = new ContentTuple[numTuples];
        
        for (int i = 0; i < numTuples; i++)
        {
            req.Tuples[i] = new ContentTuple();
            req.Tuples[i].TitleId = TITLE_ID;
            req.Tuples[i].TitleVersion = 0;
            req.Tuples[i].UserPuid = new ulong[4];
            req.Tuples[i].UserPuid[i] = 0x0009FFFF00000000;
            req.Tuples[i].Digest = _goodDigest;
        }
        
        return req;        
    }                
    
    
    
    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\License\RefreshGameLicense.cs ===
﻿using System;
using System.Collections.Generic;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
using xonline.common.billing;
using xonline.common.service;
using xonline.common.utilities;
using ContentLicense = ServerTestFramework.LiveService.Billing.License.ContentLicense;

namespace SigTest.License.Functional
{
    //[TestGroup]
    public partial class License : TestNode
    {
        [TestGroup, Owner("BenRan"), TestFrequency("Regression"), EnvRequirement("Billing")]
        [AsyncGroup(1)]
        public class RefreshGameLicense : TestNode
        {
            [TestCase, TestCasePriority(1), Description("Purchases a piece of game content and then requests a license refresh for it.")]
            public class P_BVT_Refresh : TestNode
            {
                RefreshGameLicenseHelper helper;

                public override void PreRun()
                {
                    helper = new RefreshGameLicenseHelper();
                    helper.Reset();

                    helper.Purchase(MediaMatrix.TexasHoldEmOffer);
                }

                public override void Run()
                {
                    helper.RefreshGameLicense();
                }

                public override void PostRun()
                {
                    helper.Cleanup();
                }
            }

            [TestCase, AsyncGroup(10), AsyncThreadCount(10), AsyncThreadDelay(250)]
            [CompoundCase("AvatarItem", LicenseType.GamesPerUser, MediaTypeInfo.AvatarItem, BaseSubscriptions.Xbox360Gold)]
            [CompoundCase("SimpleBundle", LicenseType.GamesMachineAndUser, MediaTypeInfo.Bundle, BaseSubscriptions.Xbox360Gold)]
            [CompoundCase("GameDemo", LicenseType.GamesUnrestricted, MediaTypeInfo.GameDemo, BaseSubscriptions.Xbox360Gold)]
            public class P_BasicPurchaseRefresh : TestNode
            {
                protected RefreshGameLicenseHelper helper;
                protected GameInformation gameInfo;

                protected override void EditInstances(ref List<CompoundCaseAttribute> instances)
                {
                    var subscriptionTypes = new BaseSubscriptions[] 
                    {
                        BaseSubscriptions.Xbox360Silver, 
                        BaseSubscriptions.Xbox360Gold, 
                        BaseSubscriptions.Xbox360FamilyGold
                    };

                    var mediaTypes = new Int32[]
                    {
                        MediaTypeInfo.Game360, // 1
                        MediaTypeInfo.ArcadeGame, // 23
                        MediaTypeInfo.Xbox1Game, // 21
                        MediaTypeInfo.XNACommunityGame, // 37
                        MediaTypeInfo.InGameContent, // 18
                        MediaTypeInfo.InGameConsumable, // 24
                        MediaTypeInfo.Theme360, // 20
                        MediaTypeInfo.GamerTile, // 22
                    };

                    for (LicenseType licenseType = LicenseType.GamesPerMachine; licenseType <= LicenseType.GamesUserPC; licenseType++)
                    {
                        foreach (var mediaType in mediaTypes)
                        {
                            foreach (var subscriptionType in subscriptionTypes)
                            {
                                String testName = String.Format("{0}_{1}_{2}", licenseType, mediaType, subscriptionType);
                                instances.Add(new CompoundCaseAttribute(testName, licenseType, mediaType, subscriptionType));
                            }
                        }
                    }

                    base.EditInstances(ref instances);
                }

                public override void PreRun()
                {
                    LicenseType licenseType = (LicenseType)MyValues[0];
                    Int32 mediaType = (Int32)MyValues[1];
                    BaseSubscriptions subscriptionType = (BaseSubscriptions)MyValues[2];

                    Global.RO.Info("Generating random game offer...");
                    gameInfo = GameInformation.Generate(licenseType, mediaType);

                    UserEditor userEditor = UserEditor.CreateNew();
                    userEditor.RemoveAllSubscriptions(true);
                    userEditor.AddBaseSubscription(subscriptionType);

                    helper = new RefreshGameLicenseHelper((UserBase)userEditor);
                    helper.Reset(false);

                    Global.RO.Info("(Fake) Purchasing game offer...");
                    helper.Purchase(gameInfo);
                }

                public override void Run()
                {
                    helper.RefreshGameLicense();
                }

                public override void PostRun()
                {
                    helper.Cleanup();
                }
            }

            [TestCase, TestCasePriority(1), Description("Refresh a game license for an unowned piece of content.")]
            public class P_Refresh_NoPurchase : TestNode
            {
                RefreshGameLicenseHelper helper;

                public override void PreRun()
                {
                    helper = new RefreshGameLicenseHelper();
                    helper.Reset();
                }

                public override void Run()
                {
                    helper.RefreshGameLicense(MediaMatrix.TexasHoldEmOffer.ContentId, LicenseType.GamesUnrestricted);
                }

                public override void PostRun()
                {
                    helper.Cleanup();
                }
            }

            [TestCase, TestCasePriority(1), Description("Purchases a piece of game content on a console with a duplicate requests a license refresh for it.")]
            public class P_Refresh_DuplicateConsole : TestNode
            {
                RefreshGameLicenseHelper helper;
                RefreshGameLicenseHelper duplicateHelper;

                public override void PreRun()
                {
                    helper = new RefreshGameLicenseHelper();
                    helper.Reset();

                    duplicateHelper = new RefreshGameLicenseHelper(
                        (MachineBase)MachineEditor.CreateDuplicateXbox360(helper.Machine.ConsoleId),
                        helper.User);
                    duplicateHelper.Reset(false);

                    helper.Purchase(MediaMatrix.TexasHoldEmOffer);
                }

                public override void Run()
                {
                    // Refresh the game license, and check that we got a type 14 license
                    helper.RefreshGameLicense();

                    // Then attempt to refresh the license with the duplicate console, 
                    // we should just get the regular unrestricted license
                    duplicateHelper.RefreshGameLicense(MediaMatrix.TexasHoldEmOffer.ContentId, LicenseType.GamesMachineAndUser);
                }

                public override void PostRun()
                {
                    helper.Cleanup();
                    duplicateHelper.Cleanup();
                }
            }

            [TestCase, TestCasePriority(3), Description("Call RefreshGameLicense and dump the response")]
            public class P_Refresh_DumpLicense : TestNode
            {
                RefreshGameLicenseHelper helper;

                public override void PreRun()
                {
                    helper = new RefreshGameLicenseHelper();
                    helper.Reset();

                    helper.Purchase(MediaMatrix.TexasHoldEmOffer);
                }
                public override void Run()
                {
                    ContentLicense license = helper.RefreshGameLicense();

                    Utils.DumpLicense(license);
                }

                public override void PostRun()
                {
                    helper.Cleanup();
                }
            }

            [TestCase, TestCasePriority(2), Description("RefreshGameLicense Avatar License"), EnvRequirement("Manual")]
            public class P_Refresh_Avatar_Gold : TestNode
            {
                RefreshGameLicenseHelper helper;

                public override void PreRun()
                {
                    helper = new RefreshGameLicenseHelper();
                    helper.Reset();

                    // Purchase Avatar Item
                    helper.Purchase(MediaMatrix.AvatarOffer);
                }

                public override void Run()
                {
                    // This will refresh the game license and validate that it has a Per User License
                    ContentLicense license = helper.RefreshGameLicense();

                    // We also want to check that it has an unrestricted license
                    Utils.VerifyGameLicense((Byte[])license, LicenseType.GamesUnrestricted, new ulong[] { helper.UserPuid }, helper.MachinePuid);
                }

                public override void PostRun()
                {
                    helper.Cleanup();
                }
            }

            [TestCase, TestCasePriority(2), Description("RefreshGameLicense GreenlightApp"), EnvRequirement("Manual")]
            public class P_Refresh_GreenlightApp_Gold : TestNode
            {
                RefreshGameLicenseHelper helper;

                public override void PreRun()
                {
                    helper = new RefreshGameLicenseHelper();
                    helper.Reset();

                    // Purchase Avatar Item
                    MediaMatrix.GreenlightApp.InsertIntoCatalog(false);
                    helper.Purchase(MediaMatrix.GreenlightApp);
                }

                public override void Run()
                {
                    // This will refresh the game license and validate that it has an appropriate license.
                    helper.RefreshGameLicense();
                }

                public override void PostRun()
                {
                    helper.Cleanup();
                }
            }

            [TestCase, TestCasePriority(2), Description("Verifies consistent license refreshing.")]
            public class P_Refresh_VerifyLicense : TestNode
            {
                RefreshGameLicenseHelper helper;

                public override void PreRun()
                {
                    helper = new RefreshGameLicenseHelper();
                    helper.Reset();

                    helper.Purchase(MediaMatrix.TexasHoldEmOffer);
                }

                public override void Run()
                {
                    ContentLicense original = helper.RefreshGameLicense();

                    for (int i = 0; i < 5; i++)
                    {
                        ContentLicense newLicense = helper.RefreshGameLicense();

                        // Check the new license against the original license
                        if (!Utils.CompareLicensesValid(original, newLicense, true))
                        {
                            throw new UnexpectedTestResultException("New license does not match the original license. License generation is not consistent.");
                        }
                        else
                        {
                            Global.RO.Success("License [{0}] matches original license", i);
                        }
                    }
                }

                public override void PostRun()
                {
                    helper.Cleanup();
                }
            }

            [TestCase, TestCasePriority(1), Description("Verifies that license bits are retrieved properly in the standard ArcadeGame/Trial situation")]
            public class P_ArcadeTrial_LicenseBits : TestNode
            {
                public override void Run()
                {
                    Global.RO.Info("Generating Trial and Full Version Arcade game");
                    // Trial game info offer
                    var trialInfo = GameInformation.Generate(LicenseType.GamesUnrestricted, MediaTypeInfo.Game360);

                    // Full game info offer
                    var fullInfo = trialInfo.GenerateNewOffer(0x1, LicenseType.GamesMachineAndUser);

                    RefreshGameLicenseHelper helper = new RefreshGameLicenseHelper();
                    helper.Reset();

                    UInt64 consoleLicenseeId = ConsoleIdUtil.GetConsoleIdFromMachineId(helper.MachinePuid, XOn.XPLT_XBOX360);

                    Global.RO.Info("Refreshing license for arcade trial");
                    // Grab a license for the trial
                    var l = helper.RefreshGameLicense(trialInfo.ContentId, LicenseType.GamesUnrestricted);
                    l.RevertLicenseesByteOrder();
                    // Verify that there is an unrestricted license with license bits equal to 0
                    l.VerifyLicensee(0xFFFFFFFFFFFFFFFF, 0x0, null);

                    Global.RO.Info("Purchasing full version offer and refreshing license");
                    // Purchase the full game offer and refresh the license
                    helper.Purchase(fullInfo);
                    l = helper.RefreshGameLicense(trialInfo.ContentId, LicenseType.GamesMachineAndUser);
                    l.RevertLicenseesByteOrder();

                    // Verify we still have an unrestricted license with bits = 0
                    l.VerifyLicensee(0xFFFFFFFFFFFFFFFF, 0x0, null);
                    // Verify that there is both a user and a machine license with license bits equal to 1
                    l.VerifyLicensee(helper.UserPuid, 0x1, null);
                    l.VerifyLicensee(consoleLicenseeId, 0x1, null);

                    helper.Cleanup();
                }
            }

            [TestCase, TestCasePriority(2), Description("Verify license bits are properly set for multiple pieces of DLC on different consoles")]
            public class P_MultiDlc_MultiConsole : TestNode
            {
                protected RefreshGameLicenseHelper helperMain;
                protected RefreshGameLicenseHelper helperAlt;
                protected GameInformation gameInfo;
                protected GameInformation dlcInfo1;
                protected GameInformation dlcInfo2;
                protected GameInformation dlcInfo3;

                public override void PreRun()
                {
                    Global.RO.Info("Generating random game offer and three pieces of DLC...");
                    gameInfo = GameInformation.Generate(LicenseType.GamesMachineAndUser, MediaTypeInfo.ArcadeGame);

                    // This basically generates three new offers for the same piece of content, but with
                    // different sets of license bits.  This is how some DLC content is handled, the game
                    // just checks for specific bits to determine if a piece of content is owned.
                    dlcInfo1 = gameInfo.GenerateNewOffer(0x01);
                    dlcInfo2 = gameInfo.GenerateNewOffer(0x02);
                    dlcInfo3 = gameInfo.GenerateNewOffer(0x04);

                    helperMain = new RefreshGameLicenseHelper();
                    helperMain.Reset();

                    helperAlt = new RefreshGameLicenseHelper(helperMain.User);
                    helperAlt.Reset(false);

                    Global.RO.Info("Purchasing game offer and dlc on first console...");
                    helperMain.Purchase(gameInfo);
                    helperMain.Purchase(dlcInfo1);
                    helperMain.Purchase(dlcInfo2);

                    Global.RO.Info("Purchasing third dlc on second console...");
                    helperAlt.Purchase(dlcInfo3);
                }

                public override void Run()
                {
                    UInt64 mainConsoleId = ConsoleIdUtil.GetConsoleIdFromMachineId(helperMain.MachinePuid, XOn.XPLT_XBOX360);
                    UInt64 altConsoleId = ConsoleIdUtil.GetConsoleIdFromMachineId(helperAlt.MachinePuid, XOn.XPLT_XBOX360);

                    ContentLicense mainLicense = helperMain.RefreshGameLicense(gameInfo.ContentId, LicenseType.GamesMachineAndUser);
                    mainLicense.RevertLicenseesByteOrder();
                    ContentLicense altLicense = helperAlt.RefreshGameLicense(gameInfo.ContentId, LicenseType.GamesMachineAndUser);
                    altLicense.RevertLicenseesByteOrder();

                    Global.RO.Info("Verifying license bits on main console...");
                    // Should contain bits for the first two pieces of content
                    mainLicense.VerifyLicensee(mainConsoleId, 0x3, null);
                    // Should contain bits for all pieces of content
                    mainLicense.VerifyLicensee(helperMain.UserPuid, 0x7, null);

                    Global.RO.Info("Verifying license bits on alt console...");
                    // Should contain bits for the last piece of content
                    altLicense.VerifyLicensee(altConsoleId, 0x4, null);
                    // Should contain bits for all pieces of content
                    altLicense.VerifyLicensee(helperAlt.UserPuid, 0x7, null);
                }

                public override void PostRun()
                {
                    helperMain.Cleanup();
                    helperAlt.Cleanup();
                }
            }

            [TestCase, TestCasePriority(2), Description("Verify license bits are properly set for multiple pieces on the same console")]
            [Ignore("There's an issue with the signatures generated on the licenses which causes them to get fully refreshed each time")]
            public class P_DifferentUsersCombinedBits : TestNode
            {
                protected RefreshGameLicenseHelper helperMain;
                protected RefreshGameLicenseHelper helperAlt;
                protected GameInformation gameInfo;
                protected GameInformation dlcInfo1;
                protected GameInformation dlcInfo2;

                public override void PreRun()
                {
                    Global.RO.Info("Generating random game offer and two pieces of DLC...");
                    gameInfo = GameInformation.Generate(LicenseType.GamesMachineAndUser, MediaTypeInfo.ArcadeGame);

                    dlcInfo1 = gameInfo.GenerateNewOffer(0x01);
                    dlcInfo2 = gameInfo.GenerateNewOffer(0x02);

                    helperMain = new RefreshGameLicenseHelper();
                    helperMain.Reset();

                    helperAlt = new RefreshGameLicenseHelper(helperMain.Machine);
                    helperAlt.Reset(false);

                    Global.RO.Info("Purchasing game offer one with user one...");
                    helperMain.Purchase(gameInfo);
                    helperMain.Purchase(dlcInfo1);

                    Global.RO.Info("Purchasing game offer two with user two...");
                    helperAlt.Purchase(gameInfo);
                    helperAlt.Purchase(dlcInfo2);
                }

                public override void Run()
                {
                    UInt64 mainConsoleId = ConsoleIdUtil.GetConsoleIdFromMachineId(helperMain.MachinePuid, XOn.XPLT_XBOX360);

                    ContentLicense altLicense = helperAlt.RefreshGameLicense();
                    altLicense.RevertLicenseesByteOrder();
                    ContentLicense mainLicense = helperMain.RefreshGameLicense(altLicense, LicenseType.GamesMachineAndUser);
                    mainLicense.RevertLicenseesByteOrder();
                    
                    Global.RO.Info("Verifying console license bits...");
                    // Should contain bits for both pieces of content
                    mainLicense.VerifyLicensee(mainConsoleId, 0x3, null);

                    Global.RO.Info("Verifying user license bits...");
                    // Should contain bits for the first piece of content
                    mainLicense.VerifyLicensee(helperMain.UserPuid, 0x1, null);

                    // Should contain bits for the last piece of content
                    mainLicense.VerifyLicensee(helperAlt.UserPuid, 0x2, null);
                }

                public override void PostRun()
                {
                    helperMain.Cleanup();
                    helperAlt.Cleanup();
                }
            }

            [TestCase, TestCasePriority(2), Description("Verify license bits properly set on different consoles for multiple offers on same content")]
            public class P_RefreshOnAlternateConsole : TestNode
            {
                protected RefreshGameLicenseHelper helperMain;
                protected RefreshGameLicenseHelper helperAlt;
                protected GameInformation gameInfo;
                protected GameInformation dlcOneInfo;
                protected GameInformation dlcTwoInfo;

                public override void PreRun()
                {
                    Global.RO.Info("Generating random game offer and two pieces of DLC...");
                    gameInfo = GameInformation.Generate(LicenseType.GamesMachineAndUser, MediaTypeInfo.ArcadeGame);

                    dlcOneInfo = gameInfo.GenerateNewOffer(0x01);
                    dlcTwoInfo = gameInfo.GenerateNewOffer(0x02);

                    UserEditor userEditor = UserEditor.CreateNew();
                    userEditor.RemoveAllSubscriptions(true);
                    userEditor.AddBaseSubscription(BaseSubscriptions.Xbox360Gold);

                    helperMain = new RefreshGameLicenseHelper((UserBase)userEditor);
                    helperMain.Reset(false);

                    helperAlt = new RefreshGameLicenseHelper((UserBase)userEditor);
                    helperAlt.Reset(false);

                    Global.RO.Info("Purchasing game offer...");
                    helperMain.Purchase(gameInfo);
                }

                public override void Run()
                {
                    UInt64 mainConsoleId = ConsoleIdUtil.GetConsoleIdFromMachineId(helperMain.MachinePuid, XOn.XPLT_XBOX360);
                    UInt64 altConsoleId = ConsoleIdUtil.GetConsoleIdFromMachineId(helperAlt.MachinePuid, XOn.XPLT_XBOX360);

                    ContentLicense mainLicense;
                    ContentLicense altLicense;

                    Global.RO.Info("Verifying license bits on main console...");
                    mainLicense = helperMain.RefreshGameLicense();
                    Utils.RevertByteOrder(mainLicense.body.licensees);
                    ValueCheck.Test("MachineLicenseBits", 0x00, mainLicense[mainConsoleId].licenseBits);

                    Global.RO.Info("Purchasing DLC1 on main console...");
                    helperMain.Purchase(dlcOneInfo);

                    Global.RO.Info("Verifying license bits on main console again...");
                    mainLicense = helperMain.RefreshGameLicense();
                    Utils.RevertByteOrder(mainLicense.body.licensees);
                    ValueCheck.Test("MainMachineLicenseBits", 0x01, mainLicense[mainConsoleId].licenseBits);

                    Global.RO.Info("Purchasing DLC2 on alt console...");
                    helperAlt.Purchase(dlcTwoInfo);

                    Global.RO.Info("Verifying license bits on both consoles...");
                    mainLicense = helperMain.RefreshGameLicense();
                    Utils.RevertByteOrder(mainLicense.body.licensees);
                    ValueCheck.Test("MainMachineLicenseBits", 0x01, mainLicense[mainConsoleId].licenseBits);

                    altLicense = helperAlt.RefreshGameLicense(gameInfo.ContentId, LicenseType.GamesMachineAndUser);
                    Utils.RevertByteOrder(altLicense.body.licensees);
                    ValueCheck.Test("AltMachineLicenseBits", 0x02, altLicense[altConsoleId].licenseBits);
                }

                public override void PostRun()
                {
                    helperMain.Cleanup();
                    helperAlt.Cleanup();
                }
            }

            [TestCase, TestCasePriority(2), Description("Attempt to RefreshGameLicense with an invalid ConsoleId.")]
            public class N_Refresh_NonExistant_MachinePuid : TestNode
            {
                RefreshGameLicenseHelper helper;
                UInt64 machinePuid;

                public override void PreRun()
                {
                    // Create using a silver user
                    helper = new RefreshGameLicenseHelper(false);
                    helper.Reset();

                    helper.Purchase(MediaMatrix.TexasHoldEmOffer);

                    machinePuid = MachineEditor.AllocateMachinePuid(MachineType.Xbox360);
                }

                public override void Run()
                {
                    helper.RefreshGameLicense(HResult.XONLINE_E_LOGON_MISSING_CONSOLE_ID, machinePuid);
                }

                public override void PostRun()
                {
                    helper.Cleanup();
                }
            }

            [TestCase, TestCasePriority(2), Description("Attempt to RefreshGameLicense with an invalid ContentId.")]
            public class N_Refresh_Invalid_ContentId : TestNode
            {
                RefreshGameLicenseHelper helper;

                public override void PreRun()
                {
                    // Create using a silver user
                    helper = new RefreshGameLicenseHelper(false);
                    helper.Reset();

                    helper.Purchase(MediaMatrix.TexasHoldEmOffer);
                }

                public override void Run()
                {
                    Byte[] invalidContentId = new Byte[] { 0xAA, 0xBB, 0xCC, 0xDD,
                                                           0xAA, 0xBB, 0xCC, 0xDD,
                                                           0xAA, 0xBB, 0xCC, 0xDD,
                                                           0xAA, 0xBB, 0xCC, 0xDD,
                                                           0xAA, 0xBB, 0xCC, 0xDD };

                    helper.RefreshGameLicense(HResult.XONLINE_E_CONTENT_NOT_FOUND, invalidContentId);
                }

                public override void PostRun()
                {
                    helper.Cleanup();
                }
            }

            [TestCase, TestCasePriority(2), Description("Attempt to RefreshGameLicense with an empty license.")]
            public class N_Refresh_EmptyLicense : TestNode
            {
                RefreshGameLicenseHelper helper;

                public override void PreRun()
                {
                    // Create using a silver user
                    helper = new RefreshGameLicenseHelper(false);
                    helper.Reset();

                    helper.Purchase(MediaMatrix.TexasHoldEmOffer);
                }

                public override void Run()
                {
                    Byte[] empty = new Byte[20];
                    ContentLicense license = Utils.GenerateLicenseData(empty, new ulong[] { helper.UserPuid });

                    helper.RefreshGameLicense(HResult.XONLINE_E_CONTENT_NOT_FOUND, license);
                }

                public override void PostRun()
                {
                    helper.Cleanup();
                }
            }

            [TestCase, TestCasePriority(2), Description("Attempt to refresh a geofenced game license while out of region.")]
            [CompoundCase("OutOfCountry", "24.36.22.55", false, "Stoney Creek, ON, Canada", true)]
            [CompoundCase("OutOfCountry_NotGeofenced", "24.36.22.55", true, "Stoney Creek, ON, Canada", false)]
            [CompoundCase("MappedTerritory_PuertoRico", "24.42.0.0", true, "Pureto Rico, USA", true)]
            [CompoundCase("MappedTerritory_Guam", "116.68.0.0", true, "Guam, USA", true)]
            [CompoundCase("UnknownLocation", "1.1.1.1", true, "Unknown Location", true)]
            public class P_Refresh_Geofenced : TestNode
            {
                RefreshGameLicenseHelper helper;
                GameInformation gameInfo;

                public override void PreRun()
                {
                    Boolean shouldGeofence = (Boolean)MyValues[3];

                    // Generate a piece of geofenced (or not) content
                    gameInfo = GameInformation.Generate(LicenseType.GamesMachineAndUser, MediaTypeInfo.ArcadeGame, false);
                    gameInfo.GeoCheckPolicy = shouldGeofence ? GeoCheckPolicy.GeoFence : GeoCheckPolicy.DoNotGeoFence;
                    gameInfo.InsertIntoCatalog();

                    helper = new RefreshGameLicenseHelper(false);
                    helper.Reset();

                    // Purchase the geofenced game
                    helper.Purchase(gameInfo);
                }

                public override void Run()
                {
                    // Check if geo fencing is enabled
                    if (!Global.XEnv.GetBoolSetting("geofencing_offerGeoFencingEnabled"))
                    {
                        throw new DidNotExecuteException("Offer GeoFencing is not enabled, unable to run geofencing test.  Check geofencing_offerGeoFencingEnabled");
                    }

                    Global.RO.Info("Refreshing a geofenced game license normally...");
                    helper.RefreshGameLicense();
                    Global.RO.Info("Successfully refreshed the game license normally");

                    String ipAddressString = (String)MyValues[0];
                    Boolean shouldSucceed = (Boolean)MyValues[1];
                    String newLocation = (String)MyValues[2];

                    Global.RO.Info("'Moving' to {0}[{1}]...", newLocation, ipAddressString);
                    XRLRefreshGameLicense refresh = new XRLRefreshGameLicense();
                    // Set the IP address to the one provided
                    refresh.Slot.ipaI = BitConverter.ToUInt32(IPAddress.Parse(ipAddressString).GetAddressBytes(), 0);

                    refresh.Request.license = (Byte[])helper.License;
                    refresh.Request.userId = helper.UserPuid;
                    refresh.Request.machineId = helper.MachinePuid;

                    if (refresh.Execute())
                    {
                        if (shouldSucceed)
                        {
                            Global.RO.Success("Request succeeded as expected");
                        }
                        else
                        {
                            throw new UnexpectedTestResultException("Expected RefreshGameLicense call to fail.");
                        }
                    }
                    else
                    {
                        // If it should fail
                        if(!shouldSucceed)
                        {
                            // Make sure that we got the geo fence failure
                            ServerTestFramework.Utilities.ValueCheck.Test<HResult, HResult>("HResult", HResult.XONLINE_E_GEO_DENIED, refresh.XErr);
                            Global.RO.Success("Request failed as expected with geofenced request.");
                        }
                        else
                        {
                            // It should have succeeded but it failed
                            throw new UnexpectedTestResultException("RefreshGameLicense call failed: " + refresh.GetDumpString());
                        }
                    }
                }

                public override void PostRun()
                {
                    helper.Cleanup();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\License\LicenseHelpers.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Billing.License;
using ServerTestFramework.LiveService.Signature;
using xonline.common.protocol;
using xonline.common.service;
using OfferMediaTypeExpectedPrice = ServerTestFramework.LiveService.Billing.OfferMediaTypeExpectedPrice;
using xonline.common.config;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace SigTest.License
{
    /// <summary>
    /// A generic test helper class with access to various types of media.
    /// Provieds methods for purchasing video and game offers and automatically
    /// tracks which items have been purchased.
    /// </summary>
    public class MediaTestHelper : TestHelper
    {
        public Boolean RealPurchase { get; set; }

        protected List<VideoInformation> videoInfo = new List<VideoInformation>();
        public List<VideoInformation> VideoInfo { get { return videoInfo; } }
        protected List<GameInformation> gameInfo = new List<GameInformation>();
        public List<GameInformation> GameInfo { get { return gameInfo; } }

        public MediaTestHelper()
            : base() { }

        public MediaTestHelper(MachineType machineType)
            : base(machineType) { }

        public MediaTestHelper(IUser user)
            : base(user) { }

        public MediaTestHelper(IMachine client)
            : base(client) { }

        public MediaTestHelper(IMachine client, IUser user)
            : base(client, user) { }

        public override void Reset(bool forceNewUserAndClient)
        {
            videoInfo.Clear();
            gameInfo.Clear();

            base.Reset(forceNewUserAndClient);
        }

        public void AddPurchasedItem(params VideoInformation[] videoInfoToAdd)
        {
            AddPurchasedItem((IEnumerable<VideoInformation>)videoInfoToAdd);
        }

        public void AddPurchasedItem(IEnumerable<VideoInformation> videoInfoToAdd)
        {
            foreach (VideoInformation info in videoInfoToAdd)
            {
                if (!videoInfo.Contains(info))
                {
                    videoInfo.Add(info);
                }
            }
        }

        public void AddPurchasedItem(params GameInformation[] gameInfoToAdd)
        {
            AddPurchasedItem((IEnumerable<GameInformation>)gameInfoToAdd);
        }

        public void AddPurchasedItem(IEnumerable<GameInformation> gameInfoToAdd)
        {
            foreach (GameInformation info in gameInfoToAdd)
            {
                if (!gameInfo.Contains(info))
                {
                    gameInfo.Add(info);
                }
            }
        }

        public void AddPurchasedItem(IEnumerable<MediaInformation> media)
        {
            foreach (var mediaInfo in media)
            {
                AddPurchasedItem(mediaInfo);
            }
        }

        public void AddPurchasedItem(MediaInformation mediaInfo)
        {
            GameInformation game = mediaInfo as GameInformation;
            if (game != null)
            {
                if (!gameInfo.Contains(game))
                {
                    gameInfo.Add(game);
                }
            }
            else
            {
                VideoInformation video = mediaInfo as VideoInformation;
                if (video != null)
                {
                    if (!videoInfo.Contains(video))
                    {
                        videoInfo.Add(video);
                    }
                }
            }
        }

        public void Purchase(params MediaInformation[] media)
        {
            Purchase(this.UserPuid, this.MachinePuid, (IEnumerable<MediaInformation>)media);
        }

        public void Purchase(Puid userPuid, Puid machinePuid, params MediaInformation[] media)
        {
            Purchase(userPuid, machinePuid, (IEnumerable<MediaInformation>)media);
        }

        public virtual void Purchase(Puid userPuid, Puid machinePuid, IEnumerable<MediaInformation> media)
        {
            Global.RO.Debug("Purchasing {0} media offer(s)...", media.Count());

            if (RealPurchase)
            {
                // If we're doing a real purchase, get the OfferMediaTypeExpectedPrice info
                // and call the PurchaseMediaOffers API
                OfferMediaTypeExpectedPrice[] offers;
                if (media == null)
                {
                    offers = new OfferMediaTypeExpectedPrice[0];
                }
                else
                {
                    offers = media.Select(m => m.OfferMediaTypeExpectedPrice).ToArray();
                }

                if (!SignatureUtils.PurchaseMediaOffers(userPuid, machinePuid, offers))
                {
                    throw new UnexpectedTestResultException("Unable to purchase media offer(s).");
                }
            }
            else
            {
                // If we're doing fake purchases, just insert the media info into the database
                StringBuilder cmd = new StringBuilder();
                // We simulate a purchase 5 minutes ago, to prevent some problems with clock skews.
                DateTime now = DateTime.UtcNow.AddMinutes(-5);
                Random r = new Random();

                foreach (var medium in media)
                {   
                    UserCommercedbWS.SimulatePurchaseOffers(userPuid, machinePuid, medium.OfferInstanceId, medium.OfferId, medium.MediaType, 1, now.AddMinutes(-5));

                    using (var ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
                    {
                        Guid trackingGuid = Guid.NewGuid();

                        ws.PartitionType = WstPartitionType.Logical;
                        ws.SetHashVal((ulong)userPuid);

                        // Add a few common parameters
                        ws.AddParameter("bi_user_puid", userPuid);
                        ws.AddParameter("bi_machine_puid", machinePuid);
                        ws.AddParameter("si_hash_bucket", ws.Partition);
                        
                        ws.AddParameter("uid_tracking_guid", trackingGuid);
                        ws.AddParameter("dt_posting_date", DateTime.UtcNow);
                        ws.AddParameter("ti_purchase_origin", 1);

                        // Now record some reporting information
                        // NOTE: Not sure if we need to use the older record_purchase_intent sproc for games
                        // or if it's all supposed to be handled by the new record_media_purchase_intent.
                        //
                        //if (medium is GameInformation)
                        //{
                        //    ws.StoredProc = "p_dmp_record_purchase_intent";
                        //    ws.AddParameter("xml_offers", String.Format("<o>{0}</o>", r.Next()));
                        //    ws.AddParameter("vc_alternate_url", "");

                        //    ws.ExecuteNonQuery();

                        //    ws.ClearParameters();

                        //    ws.StoredProc = "p_dmp_record_purchase_success";
                        //    ws.PartitionType = WstPartitionType.Logical;
                        //    ws.SetHashVal((ulong)userPuid);

                        //    ws.AddParameter("uid_tracking_guid", trackingGuid);
                        //    ws.AddParameter("vc_confirmation_id", "BogusConfirmationId");
                        //    ws.AddParameter("dt_transaction_end", DateTime.UtcNow);
                        //    ws.AddParameter("i_status_id", 2); // See t_dmp_transaction_status table for status codes, 2 == Success
                        //}

                        ws.StoredProc = "p_dmp_record_media_purchase_intent";
                        ws.AddParameter("ti_has_music_offers", 0);
                        ws.AddParameter("i_store_id", 1); // Need to see if this matters
                        ws.AddParameter("xml_items",
                            String.Format(@"<item oid='{0}' oiid='{1}' mediaId='{2}' mediaTypeId='{3}' retailPoints='{4}' retailPrice='{5}' retailCurrency='MPT' wholesalePrice='{6}' wholesaleCurrency='MPT' pricingRuleId='24'/>",
                                medium.OfferId,
                                medium.OfferInstanceId,
                                medium.MediaId,
                                medium.MediaType,
                                medium.ExpectedPrice,
                                medium.ExpectedPrice,
                                medium.ExpectedPrice));
                        ws.AddParameter("xml_assets", null, System.Data.DbType.Xml);
                        ws.AddParameter("vc_alternate_dmp_url", "");
                        ws.AddParameter("vc_external_id", "SigTest Purchase");
                        ws.AddParameter("vc_ip_address", "192.168.0.1");
                        ws.AddParameter("vc_alternate_musicnet_url", "");

                        ws.ExecuteNonQuery();
                        ws.ClearParameters();

                        ws.StoredProc = "p_dmp_record_media_purchase_success";
                        ws.PartitionType = WstPartitionType.Logical;
                        ws.SetHashVal((ulong)userPuid);

                        ws.AddParameter("uid_tracking_guid", trackingGuid);
                        ws.AddParameter("vc_confirmation_id", "BogusConfirmationId");
                        ws.AddParameter("dt_transaction_end", DateTime.UtcNow);
                        ws.AddParameter("bi_user_puid", userPuid);
                        ws.AddParameter("bi_machine_puid", machinePuid);
                        ws.AddParameter("ti_has_music_offers", 0);
                        ws.AddParameter("xml_offers", 
                            String.Format(@"<item oiid='{0}' oid='{1}' offerMediaId='{2}' />",
                                medium.OfferInstanceId,
                                medium.OfferId,
                                medium.MediaId));
                        ws.AddParameter("xml_assets", "");
                        ws.AddParameter("si_hash_bucket", ws.Partition);

                        // This sproc must occur within a transaction
                        ws.BeginTransaction();
                        ws.ExecuteNonQuery();
                        ws.CommitTransaction();
                    }
                }
            }

            // Add purchased items to media info list
            AddPurchasedItem(media);
        }

        /// <summary>
        /// Purchase a single video item.
        /// </summary>
        /// <param name="licenseType">The license type to associate with the video item</param>
        /// <param name="mediaType">The type of media to purchase</param>
        /// <returns>The media information for the item that was purchased</returns>
        /// <remarks>
        /// This item is automatically tracked internally by the helper so that we 
        /// can easily acquire and acknowledge licenses for them
        /// </remarks>
        public VideoInformation PurchaseVideo(LicenseType licenseType, Int32 mediaType)
        {
            return PurchaseVideo(licenseType, mediaType, VideoQuality.HD, 1)[0];
        }

        /// <summary>
        /// Purchase a single video item.
        /// </summary>
        /// <param name="licenseType">The license type to associate with the video item</param>
        /// <param name="mediaType">The type of media to purchase</param>
        /// <param name="quality">The quality of media to purchase</param>
        /// <returns>The media information for the item that was purchased</returns>
        /// <remarks>
        /// This item is automatically tracked internally by the helper so that we 
        /// can easily acquire and acknowledge licenses for them
        /// </remarks>
        public VideoInformation PurchaseVideo(LicenseType licenseType, Int32 mediaType, VideoQuality quality)
        {
            return PurchaseVideo(licenseType, mediaType, quality, 1)[0];
        }

        /// <summary>
        /// Purchase a specific number of video items.
        /// </summary>
        /// <param name="licenseType">The license type to associate with the video item</param>
        /// <param name="mediaType">The type of media to purchase</param>
        /// <param name="count">The number of items to purchase</param>
        /// <returns>The media information for the items that were purchased</returns>
        /// <remarks>
        /// These items are automatically tracked internally by the helper so that we 
        /// can easily acquire and acknowledge licenses for them
        /// </remarks>
        public List<VideoInformation> PurchaseVideo(LicenseType licenseType, Int32 mediaType, UInt32 count)
        {
            return PurchaseVideo(licenseType, mediaType, VideoQuality.HD, count);
        }

        /// <summary>
        /// Purchase a specific number of video items.
        /// </summary>
        /// <param name="licenseType">The license type to associate with the video item</param>
        /// <param name="mediaType">The type of media to purchase</param>
        /// <param name="quality">The quality of media to purchase</param>
        /// <param name="count">The number of items to purchase</param>
        /// <returns>The media information for the items that were purchased</returns>
        /// <remarks>
        /// These items are automatically tracked internally by the helper so that we 
        /// can easily acquire and acknowledge licenses for them
        /// </remarks>
        public List<VideoInformation> PurchaseVideo(LicenseType licenseType, Int32 mediaType, VideoQuality quality, UInt32 count)
        {
            List<VideoInformation> videos = new List<VideoInformation>();
            for (int i = 0; i < count; i++)
            {
                videos.Add(VideoInformation.Generate(licenseType, mediaType));
            }

            // NOTE: We're not doing anything with the video quality yet!!

            Purchase(UserPuid, MachinePuid, videos.Cast<MediaInformation>());

            return videos;
        }

        public void CleanupUser()
        {
            MediaTestHelper.CleanupUser(user);
        }

        public override void Cleanup()
        {
            // Only removed generated items from the catalog
            // so we don't accidentally clear out real data
            foreach (var video in videoInfo)
            {
                if (video.IsGenerated)
                {
                    video.RemoveFromCatalog();
                }
            }

            foreach (var game in gameInfo)
            {
                if (game.IsGenerated)
                {
                    game.RemoveFromCatalog();
                }
            }

            CleanupUser();

            base.Cleanup();
        }

        public static void CleanupUser(IUser user)
        {
            // First get rid of the reporting info
            UserCommercedbWS.ExecuteSQLNonQuery(String.Format(
                @"delete from t_dmp_purchase_transaction_media_details where uid_tracking_guid in 
                      (select uid_tracking_guid from t_dmp_purchase_transactions where bi_user_puid = 0x{0:X})
                  delete from t_dmp_purchase_transaction_media where uid_tracking_guid in 
	                  (select uid_tracking_guid from t_dmp_purchase_transactions where bi_user_puid = 0x{0:X})
                  delete from t_dmp_purchase_transaction_media_assets where uid_tracking_guid in 
	                  (select uid_tracking_guid from t_dmp_purchase_transactions where bi_user_puid = 0x{0:X})
                  delete from t_dmp_purchase_transaction_offers where uid_tracking_guid in 
	                  (select uid_tracking_guid from t_dmp_purchase_transactions where bi_user_puid = 0x{0:X})
                  delete from t_dmp_purchase_transactions where bi_user_puid = 0x{0:X}
                  delete from t_user_license_pending_dmp_reporting where bi_xuid = 0x{0:X}", user.Puid), user.Puid);

            // And some other licensing stuff (license state and transfer history)
            UserCommercedbWS.ExecuteSQLNonQuery(String.Format(
                @"delete from t_user_media_instance_license_state where bi_user_puid = 0x{0:X}
                  delete from t_user_license_transfer where bi_xuid = 0x{0:X}", user.Puid), user.Puid);

            // And finally all of the purchases
            UserCommercedbWS.DeleteUserOfferPurchaseInstances(user.Puid);
        }
    }

    public class AcquireMediaLicenseHelper : MediaTestHelper
    {
        private bool validateResponse = true;
        public Boolean ValidateResponse
        {
            get { return validateResponse; }
            set { validateResponse = value; }
        }

        public Boolean UseXSigWeb { get; set; }

        public AcquireMediaLicenseHelper() : base() { }

        public AcquireMediaLicenseHelper(MachineType machineType)
            : base(machineType) { }

        public AcquireMediaLicenseHelper(IMachine client) : base(client) { }

        public AcquireMediaLicenseHelper(IUser user) : base(user) { }

        public AcquireMediaLicenseHelper(IMachine client, IUser user) : base(client, user) { }

        public void AcquireMediaLicense()
        {
            AcquireMediaLicense(new uint[0]);
        }

        public void AcquireMediaLicense(params uint[] expectedResults)
        {
            if (videoInfo.Count == 0)
            {
                throw new InvalidOperationException("You must purchase at least one media item before trying to acquire a license");
            }

            AcquireMediaLicense(videoInfo.ToArray(), expectedResults);
        }

        public void AcquireMediaLicense(List<VideoInformation> mediaToAcq)
        {
            AcquireMediaLicense(mediaToAcq.ToArray());
        }

        public void AcquireMediaLicense(params VideoInformation[] mediaToAcq)
        {
            AcquireMediaLicense(mediaToAcq, new uint[0]);
        }

        public void AcquireMediaLicense(List<VideoInformation> mediaToAcq, uint[] expectedResults)
        {
            AcquireMediaLicense(mediaToAcq.ToArray(), expectedResults);
        }

        public void AcquireMediaLicense(VideoInformation[] mediaToAcq, uint[] expectedResults)
        {
            MediaInstanceIdOfferIdPair[] mioids = mediaToAcq.Select(v => v.MediaInstanceIdOfferIdPair).ToArray();

            AcquireMediaLicense(mioids, expectedResults);
        }

        public void AcquireMediaLicense(MediaInstanceIdOfferIdPair[] mediaToAcq, uint[] expectedResults)
        {
            if (expectedResults == null || expectedResults.Length == 0)
            {
                expectedResults = new uint[mediaToAcq.Length];
            }

            if (expectedResults.Length != mediaToAcq.Length)
            {
                throw new ArgumentException("expectedResults is not the same length as mediaToAcq");
            }

            MediaLicense[] mediaLicenses = null;
            if (!UseXSigWeb)
            {
                mediaLicenses = Signature.AcquireMediaLicenses(user.Puid, machine.Puid, mediaToAcq);
            }
            else
            {
                mediaLicenses = Signature.AcquireMediaLicensesWeb(user.Puid, user.PassportPuid, mediaToAcq);
            }

            if (validateResponse && !VerifyAcquireResponse(mediaLicenses, expectedResults, mediaToAcq))
            {
                throw new UnexpectedTestResultException("AcquireMediaLicenes returned an unexpected result");
            }
        }

        //private Action acquireMediaLicenseAsync;
        private Func<UInt64, Boolean> acquireDelegate;

        public IAsyncResult BeginAcquireMediaLicense(AsyncCallback callback, Object state)
        {
            //acquireMediaLicenseAsync = new Action(AcquireMediaLicense);
            //return acquireMediaLicenseAsync.BeginInvoke(callback, state);

            XRLAcquireMediaLicenses acquire = Signature.GenerateAcquireMediaLicensesRequest(
                this.UserPuid, 
                this.VideoInfo.Select(i => i.MediaInstanceIdOfferIdPair).ToArray());

            acquireDelegate = new Func<UInt64, Boolean>(acquire.Execute);
            return acquireDelegate.BeginInvoke(this.MachinePuid, callback, state);
        }

        public void EndAcquireMediaLicense(IAsyncResult result)
        {
            //acquireMediaLicenseAsync.EndInvoke(result);

            XRLAcquireMediaLicenses acquire = acquireDelegate.Target as XRLAcquireMediaLicenses;
            if (!acquireDelegate.EndInvoke(result))
            {
                throw new XErrException(acquire.XErr, acquire.GetDumpString());
            }
        }

        public void AcknowledgeMediaLicense()
        {
            AcknowledgeMediaLicense(new uint[0]);
        }

        public void AcknowledgeMediaLicense(params uint[] expectedResults)
        {
            // Select all the media that is PPV (i.e. a movie for right now)
            List<VideoInformation> mediaToAck = videoInfo.FindAll(
                delegate(VideoInformation mi)
                {
                    return mi.MediaType == 2;
                }
                );

            AcknowledgeMediaLicense(mediaToAck.ToArray(), expectedResults);
        }

        public void AcknowledgeMediaLicense(List<VideoInformation> mediaToAck)
        {
            AcknowledgeMediaLicense(mediaToAck.ToArray());
        }

        public void AcknowledgeMediaLicense(params VideoInformation[] mediaToAck)
        {
            AcknowledgeMediaLicense(mediaToAck, new uint[0]);
        }

        public void AcknowledgeMediaLicense(List<VideoInformation> mediaToAck, uint[] expectedResults)
        {
            AcknowledgeMediaLicense(mediaToAck.ToArray(), expectedResults);
        }

        public void AcknowledgeMediaLicense(VideoInformation[] mediaToAck, uint[] expectedResults)
        {
            MediaInstanceIdOfferIdPair[] mioids = mediaToAck.Select(v => v.MediaInstanceIdOfferIdPair).ToArray();

            AcknowledgeMediaLicense(mioids, expectedResults);
        }

        public void AcknowledgeMediaLicense(MediaInstanceIdOfferIdPair[] mediaToAck, uint[] expectedResults)
        {
            // If expected results is null, then we just expect success
            // This creates an array of zeros.
            if (expectedResults == null || expectedResults.Length == 0)
            {
                expectedResults = new uint[mediaToAck.Length];
            }

            Acknowledgement[] acknowledgements = null;

            if (!UseXSigWeb)
            {
                acknowledgements = Signature.AcknowledgeLicensesDelivery(user.Puid, machine.Puid, mediaToAck);
            }
            else
            {
                acknowledgements = Signature.AcknowledgeLicensesDeliveryWeb(user.Puid, user.PassportPuid, mediaToAck);
            }

            if (validateResponse && !VerifyAckResponse(acknowledgements, expectedResults, mediaToAck))
            {
                throw new UnexpectedTestResultException("AcknowledgeLicensesDelivery returned an unexpected result");
            }

        }

        public void CheckLicensesAvailability()
        {
            CheckLicensesAvailability(VideoInfo.Select(v => v.MediaInstanceIdOfferIdPair).ToArray(), new uint[0]);
        }

        public void CheckLicensesAvailability(uint[] expectedResults)
        {
            CheckLicensesAvailability(VideoInfo.Select(v => v.MediaInstanceIdOfferIdPair).ToArray(), expectedResults);
        }

        public void CheckLicensesAvailability(MediaInstanceIdOfferIdPair[] mediaToCheck, uint[] expectedResults)
        {
            // If expected results is null, then we just expect success
            // This creates an array of zeros.
            if (expectedResults == null || expectedResults.Length == 0)
            {
                expectedResults = new uint[mediaToCheck.Length];
            }

            Availability[] availabilities = Signature.CheckLicensesAvalabilityWeb(user.Puid, user.PassportPuid, mediaToCheck);

            if (validateResponse && !VerifyCheckAvailabilityResponse(availabilities, expectedResults, mediaToCheck))
            {
                throw new UnexpectedTestResultException("CheckLicensesAvailability return an unexpected result");
            }
        }

        public static bool VerifyAcquireResponse(MediaLicense[] mediaLicenses, uint[] _expectedResults, MediaInstanceIdOfferIdPair[] _mediaInfo)
        {
            bool isVerified = true;

            if (mediaLicenses.Length != _expectedResults.Length)
            {
                Global.RO.Error("Number of licenses returned and the expected number are not the same.");
                Global.RO.Error("Returned: {0} | Expected: {1}", mediaLicenses.Length, _expectedResults.Length);
                return false;
            }

            for (int i = 0; i < mediaLicenses.Length; i++)
            {
                for (int j = 0; j < _mediaInfo.Length; j++)
                {
                    //
                    // If the mediainstance matches the one in our results table
                    // print out the results and continue.
                    //
                    if (mediaLicenses[i].idPair.miid == _mediaInfo[j].miid
                        && mediaLicenses[i].idPair.oid == _mediaInfo[j].oid)
                    {
                        // Check if the result is the one expected
                        if (mediaLicenses[i].hr != _expectedResults[j])
                        {
                            Global.RO.Error("Acquire Error - Expected: {0} | Recieved: {1}", (HResult)_expectedResults[j], mediaLicenses[i].hr);
                            Global.RO.Error("MediaId: {0} | OfferId: {1}", mediaLicenses[i].idPair.miid, mediaLicenses[i].idPair.oid);
                            isVerified = false;
                        }
                        else
                        {
                            Global.RO.Success("Verified Response of {0} for MediaId: {1} | OfferId: {2}", mediaLicenses[i].hr, mediaLicenses[i].idPair.miid, mediaLicenses[i].idPair.oid);
                        }

                        // Dump the license response if we want it
                        /*
                        if (_display)
                        {
                            // This might be an AA call, which just stores the entire license not cut into blocks.
                            if (mediaLicenses[i].licenseBlockCount == 0)
                            {
                                // If the call was successful, then dump the license;
                                if (mediaLicenses[i].hr == 0 && mediaLicenses[i].license.Length > 0)
                                {
                                    //string licenseString = Hexer.tohex(mediaLicenses[i].license);
                                    //Global.RO.Info(HexAsciiConvert(licenseString));
                                    // TODO: I Think this is the same
                                    Global.RO.Info(Encoding.ASCII.GetString(mediaLicenses[i].license));
                                }
                            }
                            else
                            {
                                for (int k = 0; k < mediaLicenses[i].licenseBlockCount; k++)
                                {                                    
                                    //string licenseBlock = Hexer.tohex(mediaLicenses[i].licenseBlocks[k].block);
                                    //Global.RO.Info(HexAsciiConvert(licenseBlock));
                                    // TODO: I Think this is the same
                                    Global.RO.Info(Encoding.ASCII.GetString(mediaLicenses[i].licenseBlocks[k].block));
                                }
                            }
                        }
                        */

                        break;
                    }
                }
            }

            if (!isVerified)
            {
                Global.RO.Error("One or more media licenses were not granted.");
            }

            return isVerified;
        }

        public static bool VerifyAckResponse(Acknowledgement[] acknowledgements, uint[] _expectedResults, MediaInstanceIdOfferIdPair[] _mediaInfo)
        {
            bool isVerified = true;
            Global.RO.Info("Verifying Acknowledgement Response...");

            if (acknowledgements.Length != _expectedResults.Length)
            {
                Global.RO.Error("Number of licenses acknowledgements returned and the expected number are not the same.");
                Global.RO.Error("Returned: {0} | Expected: {1}", acknowledgements.Length, _expectedResults.Length);
                return false;
            }

            // Check each ack that came back.
            for (int i = 0; i < acknowledgements.Length; i++)
            {
                for (int j = 0; j < _mediaInfo.Length; j++)
                {
                    if (acknowledgements[i].idPair.miid == _mediaInfo[j].miid
                        && acknowledgements[i].idPair.oid == _mediaInfo[j].oid)
                    {
                        Global.RO.Info("* Expected: {0} Received: {1}", (HResult)_expectedResults[j], acknowledgements[i].hr);
                        if (acknowledgements[i].hr != _expectedResults[j])
                        {
                            Global.RO.Error("Acknowledgement Error - Expected: {0} | Recieved: {1}", (HResult)_expectedResults[j], acknowledgements[i].hr);
                            Global.RO.Error("Media Id: {0} | OfferId: {1}", acknowledgements[i].idPair.miid, acknowledgements[i].idPair.oid);
                            isVerified = false;
                        }
                        else
                        {
                            Global.RO.Success("Media Id: {0} | OfferId: {1}", acknowledgements[i].idPair.miid, acknowledgements[i].idPair.oid);
                        }
                        break;
                    }
                }
            }
            if (!isVerified)
            {
                Global.RO.Error("One or more license acknowledgements failed.");
            }

            return isVerified;
        }

        public static bool VerifyCheckAvailabilityResponse(Availability[] availabilities, uint[] expectedResults, MediaInstanceIdOfferIdPair[] mediaInfo)
        {
            bool isVerified = true;
            Global.RO.Info("Verifying Availability Response...");

            if (availabilities.Length != expectedResults.Length)
            {
                Global.RO.Error("Number of licenses acknowledgements returned and the expected number are not the same.");
                Global.RO.Error("Returned: {0} | Expected: {1}", availabilities.Length, expectedResults.Length);
                return false;
            }

            // Check each ack that came back.
            for (int i = 0; i < availabilities.Length; i++)
            {
                for (int j = 0; j < mediaInfo.Length; j++)
                {
                    if (availabilities[i].idPair.miid == mediaInfo[j].miid
                        && availabilities[i].idPair.oid == mediaInfo[j].oid)
                    {
                        Global.RO.Info("* Expected: 0x{0:x8} Received: 0x{1:x8}", expectedResults[j], (uint)availabilities[i].hr);
                        if (availabilities[i].hr != expectedResults[j])
                        {
                            Global.RO.Error("Availability Error - Expected: 0x{0:X8} | Recieved: 0x{1:X8}", expectedResults[j], (uint)availabilities[i].hr);
                            Global.RO.Error("Media Id: {0} | OfferId: {1}", availabilities[i].idPair.miid, availabilities[i].idPair.oid);
                            isVerified = false;
                        }
                        else
                        {
                            Global.RO.Success("Media Id: {0} | OfferId: {1}", availabilities[i].idPair.miid, availabilities[i].idPair.oid);
                        }
                        break;
                    }
                }
            }
            if (!isVerified)
            {
                Global.RO.Error("One or more license availability checks failed.");
            }

            return isVerified;
        }
    }

    public class RefreshGameLicenseHelper : MediaTestHelper
    {
        private bool validateResponse = true;
        public Boolean ValidateResponse
        {
            get { return validateResponse; }
            set { validateResponse = value; }
        }

        /// <summary>
        /// Returns the license that will be used to make the RefreshGameLicense call.
        /// </summary>
        public ContentLicense License
        {
            get
            {
                ContentLicense license = Utils.GenerateLicenseData(gameInfo[0].ContentId, new ulong[] { this.UserPuid });
                return license;
            }
        }

        public RefreshGameLicenseHelper() : base() { }

        public RefreshGameLicenseHelper(MachineType machineType) : base(machineType) { }

        public RefreshGameLicenseHelper(bool createGoldUser) : base()
        {
            this.createGoldUser = createGoldUser;
        }

        public RefreshGameLicenseHelper(MachineType machineType, bool createGoldUser)
            : base(machineType)
        {
            this.createGoldUser = createGoldUser;
        }

        public RefreshGameLicenseHelper(IMachine client) : base(client, null) { }

        public RefreshGameLicenseHelper(IUser user) : base(null, user) { }

        public RefreshGameLicenseHelper(IMachine client, IUser user) : base(client, user) { }

        /// <summary>
        /// Requests a refresh of the purchased game content and verifies the response
        /// </summary>
        public ContentLicense RefreshGameLicense()
        {
            return RefreshGameLicense(gameInfo[0].ContentId, gameInfo[0].LicenseType, this.MachinePuid, this.UserPuid);
        }

        /// <summary>
        /// Requests a refresh of the purchased game content using the first provided 
        /// user PUID and verifies the response using all of the provided PUIDs
        /// </summary>
        /// <param name="userPuids">The user puids to perform and validate the request with</param>
        public ContentLicense RefreshGameLicense(params ulong[] userPuids)
        {
            return RefreshGameLicense(gameInfo[0].ContentId, gameInfo[0].LicenseType, this.MachinePuid, userPuids);
        }

        /// <summary>
        /// Requests a refresh of a game license generated using the provided content
        /// id and validated as a specific license type.
        /// </summary>
        /// <param name="contentId">The content id to generate the license with</param>
        /// <param name="licenseType">The expected license type</param>
        public ContentLicense RefreshGameLicense(Byte[] contentId, LicenseType licenseType)
        {
            return RefreshGameLicense(contentId, licenseType, this.MachinePuid, this.UserPuid);
        }

        /// <summary>
        /// Requests a refresh of a game license generated using the provided content
        /// id and validated as a specific license type.
        /// </summary>
        /// <param name="contentId">The content id to generate the license with</param>
        /// <param name="licenseType">The expected license type</param>
        /// <param name="machinePuid">The machine to perform the request as</param>
        public ContentLicense RefreshGameLicense(Byte[] contentId, LicenseType licenseType, ulong machinePuid)
        {
            return RefreshGameLicense(contentId, licenseType, machinePuid, this.UserPuid);
        }

        /// <summary>
        /// Requests a refresh of a game license generated using the provided content
        /// id and user puids.  Then perform the request using the first provided user
        /// puid and validate the response.
        /// </summary>
        /// <param name="contentId">The content id to generate the license with</param>
        /// <param name="licenseType">The expected license type</param>
        /// <param name="machinePuid">The machine to perform the request as</param>
        public ContentLicense RefreshGameLicense(Byte[] contentId, LicenseType licenseType, ulong machinePuid, params ulong[] userPuids)
        {
            ContentLicense license = Signature.RefreshGameLicense(userPuids, machinePuid, contentId);

            if (validateResponse && !Utils.VerifyGameLicense((Byte[])license, licenseType, userPuids, machinePuid))
            {
                throw new UnexpectedTestResultException("RefreshGameLicense returned an unexpected result");
            }

            return license;
        }

        /// <summary>
        /// Requests a refresh of the provided game license and validates it as 
        /// a specific license type.
        /// </summary>
        /// <param name="license">The license to refresh</param>
        /// <param name="licenseType">The expected license type</param>
        public ContentLicense RefreshGameLicense(ContentLicense license, LicenseType licenseType)
        {
            return RefreshGameLicense(license, licenseType, this.MachinePuid, this.UserPuid);
        }

        /// <summary>
        /// Requests a refresh of the provided game license.  Then perform the 
        /// request using the first provided user puid and validate the response.
        /// </summary>
        /// <param name="contentId">The content id to generate the license with</param>
        /// <param name="licenseType">The expected license type</param>
        /// <param name="machinePuid">The machine to perform the request as</param>
        public ContentLicense RefreshGameLicense(ContentLicense license, LicenseType licenseType, ulong machinePuid, params ulong[] userPuids)
        {
            ContentLicense newLicense = Signature.RefreshGameLicense(userPuids[0], machinePuid, license);

            if (validateResponse && !Utils.VerifyGameLicense((Byte[])newLicense, licenseType, userPuids, machinePuid))
            {
                throw new UnexpectedTestResultException("RefreshGameLicense returned an unexpected result");
            }

            Global.RO.Success("License successfully refreshed.");

            return newLicense;
        }

        /// <summary>
        /// Execute a negative test of RefreshGameLicense.
        /// </summary>
        /// <param name="expectedError">The XErr result expected to be returned</param>
        public void RefreshGameLicense(uint expectedError)
        {
            RefreshGameLicense(expectedError, gameInfo[0].ContentId, this.MachinePuid, this.UserPuid);
        }

        /// <summary>
        /// Execute a negative test of RefreshGameLicense with a licens created with the provided content id.
        /// </summary>
        /// <param name="expectedError">The XErr result expected to be returned</param>
        /// <param name="contentId">The content id to generate the license for</param>
        public void RefreshGameLicense(uint expectedError, Byte[] contentId)
        {
            RefreshGameLicense(expectedError, contentId, this.MachinePuid, this.UserPuid);
        }

        /// <summary>
        /// Execute a negative test of RefreshGameLicense with a specific license.
        /// </summary>
        /// <param name="expectedError">The XErr result expected to be returned</param>
        /// <param name="license">The license to request with</param>
        public void RefreshGameLicense(uint expectedError, ContentLicense license)
        {
            RefreshGameLicense(expectedError, license, this.MachinePuid, this.UserPuid);
        }

        /// <summary>
        /// Execute a negative test of RefreshGameLicense with a given machine and user set.
        /// </summary>
        /// <param name="expectedError">The XErr result expected to be returned</param>
        /// <param name="machinePuid">The machine puid</param>
        /// <param name="userPuids">The user puids to generate the license with</param>
        public void RefreshGameLicense(uint expectedError, ulong machinePuid, params ulong[] userPuids)
        {
            RefreshGameLicense(expectedError, gameInfo[0].ContentId, machinePuid, userPuids);
        }

        /// <summary>
        /// Execute a negative test of RefreshGameLicense with a created license.
        /// </summary>
        /// <param name="expectedError">The XErr result expected to be returned</param>
        /// <param name="contentId">The content ID to generate the license with</param>
        /// <param name="machinePuid">The machine puid</param>
        /// <param name="userPuids">The user puids to generate the license with</param>
        public void RefreshGameLicense(uint expectedError, Byte[] contentId, ulong machinePuid, params ulong[] userPuids)
        {
            if (userPuids == null)
            {
                throw new ArgumentNullException("userPuids");
            }

            ContentLicense license = Utils.GenerateLicenseData(contentId, userPuids);

            // It's possible to generate a license with zero licensees, but we want to 
            // use a valid puid for the request.  If you want to make the request with 
            // a null user puid just pass in 0 as the only user puid.
            ulong userPuid = 0;
            if (userPuids.Length > 0)
            {
                userPuid = userPuids[0];
            }
            else
            {
                userPuid = this.UserPuid;
            }

            RefreshGameLicense(expectedError, license, machinePuid, userPuid);
        }

        /// <summary>
        /// Execute a negative test of RefreshGameLicense with a given license and user/client.
        /// </summary>
        /// <param name="expectedError">The XErr result expected to be returned</param>
        /// <param name="license">The license to make the request with</param>
        /// <param name="machinePuid">The machine to perform the request with</param>
        /// <param name="userPuid">The user to perform the request with</param>
        public void RefreshGameLicense(uint expectedError, ContentLicense license, ulong machinePuid, ulong userPuid)
        {
            try
            {
                ContentLicense newLicense = Signature.RefreshGameLicense(userPuid, machinePuid, license);

                throw new UnexpectedTestResultException("RefreshGameLicense call succeeded unexpectedly");
            }
            catch (XErrException xe)
            {
                ServerTestFramework.Utilities.ValueCheck.Test<HResult, HResult>("ExpectedError", expectedError, xe.XErr);
            }

            Global.RO.Success("Refresh game license failed with {0} as expected", (HResult)expectedError);
        }
    }

    public class StressHelperQueue<THelper>
        where THelper : TestHelper, new()
    {
        public class StressHelperEventArgs : EventArgs
        {
            public THelper Helper { get; protected set; }

            public StressHelperEventArgs(THelper helper)
            {
                this.Helper = helper;
            }
        }

        public event EventHandler<StressHelperEventArgs> HelperCreated;

        public Queue<THelper> helpers = new Queue<THelper>();

        public THelper GetHelper()
        {
            THelper helper = null;

            if (helpers.Count > 0)
            {
                lock (helpers)
                {
                    if (helpers.Count > 0)
                    {
                        helper = helpers.Dequeue();
                    }
                }
            }

            return helper ?? CreateHelper();
        }

        public THelper CreateHelper()
        {
            THelper helper = new THelper();

            if (HelperCreated != null)
            {
                HelperCreated(this, new StressHelperQueue<THelper>.StressHelperEventArgs(helper));
            }

            return helper;
        }

        public void ReturnHelper(THelper helper)
        {
            if (helper != null)
            {
                lock (helpers)
                {
                    helpers.Enqueue(helper);
                }
            }
        }

        public void PreFill(Int32 helperCount)
        {
            for (int i = 0; i < helperCount; i++)
            {
                ReturnHelper(CreateHelper());
            }
        }

        public void Cleanup()
        {
            lock (helpers)
            {
                foreach (var helper in helpers)
                {
                    helper.Cleanup();
                }

                helpers.Clear();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\License\StressRefreshGameLicense.cs ===
﻿using System;
using System.Collections.Generic;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.billing;

namespace SigTest.License.Stress
{
    [TestGroup, Owner("BenRan"), TestFrequency("Regression")]
    public class StressRefreshGameLicense : TestNode
    {
        [StressTest, Description("Basic RefreshGameLicense stress test")]
        public class RefreshGameLicense : TestNode
        {
            StressHelperQueue<RefreshGameLicenseHelper> helperQueue;

            public override void OneTimeSetup()
            {
                helperQueue = new StressHelperQueue<RefreshGameLicenseHelper>();
                helperQueue.HelperCreated += (s, e) => 
                {
                    Global.RO.Info("Created new RefreshGameLicense helper.");

                    e.Helper.ValidateResponse = false;
                    e.Helper.Reset();

                    // Each helper gets a unique game
                    GameInformation game = GameInformation.Generate(LicenseType.GamesMachineAndUser, MediaTypeInfo.ArcadeGame);
                    e.Helper.Purchase(game);
                };
            }

            public override void PreRun()
            {
                // Create a minimum of 5 users with purchases
                helperQueue.PreFill(5);                
            }

            public override void Run()
            {
                RefreshGameLicenseHelper helper = null;
                try
                {
                    helper = helperQueue.GetHelper();
                    helper.RefreshGameLicense();
                }
                finally
                {
                    helperQueue.ReturnHelper(helper);
                }
            }

            public override void PostRun()
            {
                helperQueue.Cleanup();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\License\LicenseUtils.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Billing.WebBilling;
using ServerTestFramework.LiveService.Catalog;
using ServerTestFramework.Utilities;
using xonline.common.billing;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.utilities;
// Resolve the collisons between xonline and ServerTestFramework
using ContentLicense = ServerTestFramework.LiveService.Billing.License.ContentLicense;
using ContentLicenseBody = ServerTestFramework.LiveService.Billing.License.ContentLicenseBody;
using ContentLicensee = ServerTestFramework.LiveService.Billing.License.ContentLicensee;
using ContentLicenseSignature = ServerTestFramework.LiveService.Billing.License.ContentLicenseSignature;
using OfferExpectedPrice = ServerTestFramework.LiveService.Billing.OfferExpectedPrice;
using OfferMediaTypeExpectedPrice = ServerTestFramework.LiveService.Billing.OfferMediaTypeExpectedPrice;
using xonline.common.config;

namespace SigTest.License
{
    public class Utils
    {
        public static string HexAsciiConvert(string hex)
        {
            StringBuilder sb = new StringBuilder();

            for (int i = 0; i <= hex.Length - 2; i += 2)
            {
                sb.Append(Convert.ToString(Convert.ToChar(Int32.Parse(hex.Substring(i, 2),
                System.Globalization.NumberStyles.HexNumber))));
            }
            return sb.ToString();
        }

        public static ContentLicense GenerateLicenseData(Byte[] _contentId, ulong[] _licensees)
        {
            ContentLicenseSignature signature = new ContentLicenseSignature();
            signature.signatureType = 0;
            signature.reserved = new byte[ContentLicense.ReservedLen];
            signature.signature = new byte[ContentLicense.LiveSignatureLen];

            ContentLicenseBody body = new ContentLicenseBody();
            body.licensees = new ContentLicensee[ContentLicense.LicenseesLen];

            for (int i = 0; i < ContentLicense.LicenseesLen; i++)
            {
                if (i < _licensees.Length)
                {
                    body.licensees[i] = new ContentLicensee();
                    body.licensees[i].licenseeId = _licensees[i];
                    body.licensees[i].licenseBits = 0;
                    body.licensees[i].licenseFlags = 0;
                }
                else
                {
                    body.licensees[i] = new ContentLicensee();
                    body.licensees[i].licenseeId = 0;
                    body.licensees[i].licenseBits = 0;
                    body.licensees[i].licenseFlags = 0;
                }
            }

            body.ContentId = _contentId;

            ContentLicense license = new ContentLicense();
            license.signature = signature;
            license.body = body;

            return license;
        }

        /// <summary>
        /// Dumps the data from a content license out to the screen.
        /// </summary>
        /// <param name="_license">The license to dump</param>
        public static void DumpLicense(ContentLicense license)
        {
            Global.RO.Debug("####[License Dump]####");
            Global.RO.Debug("-[Signature]-");
            Global.RO.Debug("--SignatureType: \t" +license.signature.signatureType);
            Global.RO.Debug("--Signature : \t\t" + Hexer.tohex(license.signature.signature).Substring(0, 64) + "...");
            Global.RO.Debug("-[Body]-");
            Global.RO.Debug("--ContentId: \t\t" + Hexer.tohex(license.body.ContentId));
            Global.RO.Debug("-[Licensees]-");

            RevertByteOrder(license.body.licensees);

            foreach (ContentLicensee licensee in license.body.licensees)
            {
                if (licensee.licenseeId != 0)
                {
                    Global.RO.Debug("--[Licensee]-- ");
                    Global.RO.Debug("---LicenseeId: \t\t0x{0:x8}", licensee.licenseeId);
                    Global.RO.Debug("---LicenseeFlags: \t" + licensee.licenseFlags);
                    Global.RO.Debug("---LicenseeBits: \t" + licensee.licenseBits);
                    Global.RO.Debug("---SchemaVersion: \t" + licensee.SchemaVersion);
                }
            }
            Global.RO.Debug("--SchemaVersion: \t" + license.body.SchemaVersion);
            Global.RO.Debug("--SizeOfHeaders: \t" + license.body.SizeOfHeaders);
            Global.RO.Debug("##[End License Dump]##");
        }

        /// <summary>
        /// Loads some predefined license information from a file
        /// </summary>
        /// <returns>The raw data from the license file</returns>
        private static byte[] LoadLicenseInfo()
        {
            string file = String.Format("{0}{1}", System.Environment.CurrentDirectory, "\\SuitesData\\SignatureCommon\\license.bin");

            FileInfo fileInfo = new FileInfo(file);
            using (BinaryReader reader = new BinaryReader(new FileStream(file, FileMode.Open)))
            {
                return reader.ReadBytes((int)fileInfo.Length);
            }
        }

        /// <summary>
        /// Save some raw license data to a file
        /// </summary>
        /// <param name="license">The license data to save</param>
        private static void WriteLicenseInfo(byte[] license)
        {
            string file = String.Format("{0}{1}", System.Environment.CurrentDirectory, "\\SuitesData\\SignatureCommon\\license.bin");

            FileInfo fileInfo = new FileInfo(file);
            using (BinaryWriter writer = new BinaryWriter(new FileStream(file, FileMode.Create)))
            {
                writer.Write(license);
            }
        }

        /// <summary>
        /// Takes two licenses and verifies that they match. By verifying at the top 
        /// level first and walking down into only when necessary this should be faster
        /// than checking all the pieces individually every time.
        /// </summary>
        /// <param name="expected">The expected license</param>
        /// <param name="actual">The actual license to check</param>
        /// <returns>True if the licenses are identical, false otherwise</returns>
        public static bool CompareLicensesValid(ContentLicense expected, ContentLicense actual)
        {
            return CompareLicensesValid(expected, actual, false);
        }

        /// <summary>
        /// Takes two licenses and verifies that they match. By verifying at the top 
        /// level first and walking down into only when necessary this should be faster
        /// than checking all the pieces individually every time.
        /// </summary>
        /// <param name="expected">The expected license</param>
        /// <param name="actual">The actual license to check</param>
        /// <param name="silent">If true, additional debug output will be stopped</param>
        /// <returns>True if the licenses are identical, false otherwise</returns>
        public static bool CompareLicensesValid(ContentLicense expected, ContentLicense actual, bool silent)
        {
            bool isValid = true;

            Byte[] expectedRaw = (Byte[])expected;
            Byte[] actualRaw = (Byte[])actual;
            
            if (!silent)
            {
                DumpLicense(expected);
                DumpLicense(actual);
            }

            // Check the license length
            if (expectedRaw.Length != actualRaw.Length)
            {
                isValid = false;
                Global.RO.Error("License Length was invalid - Expected: {0}, Actual: {1}", expectedRaw.Length, actualRaw.Length);
            }
            else if (!ArrayEx.Equals(expectedRaw, actualRaw))
            {
                // Check the licenses byte for byte
                isValid = false;
                Global.RO.Error("Licenses were not identical as expected");
            }
            else
            {
                // The license are identical byte for byte, so just return
                return true;
            }

            // If they are not identical, pull them apart to get a better look
            // Check the schema 
            if (expected.SchemaVersion != actual.SchemaVersion)
            {
                isValid = false;
                Global.RO.Error("License SchemaVersion was invalid");
                Global.RO.Error("Expected: \t" + expected.SchemaVersion);
                Global.RO.Error("Actual: \t" + actual.SchemaVersion);
            }

            // Check the signature
            if (!ArrayEx.Equals((byte[])expected.signature, (byte[])actual.signature))
            {
                isValid = false;
                Global.RO.Error("License Signature was invalid");
                Global.RO.Error("Expected: \t" + Hexer.tohex((Byte[])expected.signature));
                Global.RO.Error("Actual: \t" + Hexer.tohex((Byte[])actual.signature));
            }

            //
            // Check the body
            //
            if (!ArrayEx.Equals((byte[])expected.body, (byte[])actual.body))
            {
                isValid = false;
                Global.RO.Error("License Body was invalid");
                if (!ArrayEx.Equals(expected.body.ContentId, actual.body.ContentId))
                {
                    Global.RO.Error("License Body.ContentId was invalid");
                    Global.RO.Error("Expected: \t" + Hexer.tohex(expected.body.ContentId));
                    Global.RO.Error("Actual: \t" + Hexer.tohex(actual.body.ContentId));
                }


                for (int i = 0; i < expected.body.licensees.Length; i++)
                {
                    if (!ArrayEx.Equals((Byte[])expected.body.licensees[i], (Byte[])actual.body.licensees[i]))
                    {
                        Global.RO.Error("Licensee[{0}] was invalid", i);
                        Global.RO.Error("Expected LicenseeId: \t0x{0:x8}", expected.body.licensees[i].licenseeId);
                        Global.RO.Error("Actual LicenseeId: \t0x{0:x8}", actual.body.licensees[i].licenseeId);
                        Global.RO.Error("Expeted LicenseBits: \t" + expected.body.licensees[i].licenseBits);
                        Global.RO.Error("Actual LicenseBits: \t" + actual.body.licensees[i].licenseBits);
                        Global.RO.Error("Expeted LicenseFlags: \t" + expected.body.licensees[i].licenseFlags);
                        Global.RO.Error("Actual LicenseFlags: \t" + actual.body.licensees[i].licenseFlags);
                        Global.RO.Error("Expeted SchemaVersion: \t" + expected.body.licensees[i].SchemaVersion);
                        Global.RO.Error("Actual SchemaVersion: \t" + actual.body.licensees[i].SchemaVersion);
                    }
                }
            }

            return isValid;
        }

        /// <summary>
        /// Walks through the list of passed in puids and verifies that
        /// the users were granted a license.
        /// </summary>
        /// <param name="_userPuids">Array of user puids to check</param>
        /// <param name="_license">The license to check into</param>
        /// <returns></returns>
        public static bool VerifyGameLicense(Byte[] _license, LicenseType _licenseType, ulong[] _userPuids, ulong _machinePuid)
        {
            Global.RO.Info("Validating license of type: " + _licenseType);

            bool isValid = true;
            bool checkUser = false;
            bool checkPcUser = false;
            bool checkMachine = false;
            bool checkUnrestricted = false;
            bool checkOfflineUser = false;
            
            //
            // Convert to a ContentLicense so that we can easily look into it
            //
            ContentLicense license = new ContentLicense();
            license.ReadBytes(_license);

            //
            // I can't read the key from the db since this may be running through a test gateway
            // for now I am just going to check the signature with the drm key and the testkey
            //
            if (!SignatureUtils.VerifySignature((Byte[])license.body, (Byte[])license.signature.signature))
            {
                isValid = false;
                Global.RO.Error("Failed to verify signature. Failed both NCipher and TestKey validation");
            }

            // 
            // Reverse the byte order since this is coming from the server.
            //
            RevertByteOrder(license.body.licensees);

            // 
            // Make sure we look for the right things in each license
            // 
            switch (_licenseType)
            {
                case LicenseType.GamesPerMachine: // Xbox Live Games Per Machine
                    checkMachine = true;
                    break;
                case LicenseType.GamesPerUser: // Xbox Live Games Per User
                    checkUser = true;
                    break;
                case LicenseType.GamesUnrestricted: // Xbox Live Games Unrestricted
                    checkUnrestricted = true;
                    break;
                case LicenseType.GamesMachineAndUser: // Xbox Live Games Machine and User
                    checkMachine = true;
                    checkUser = true;
                    break;
                case LicenseType.GamesUserPC: // Xbox Live Games User PC
                    checkPcUser = true;
                    break;
            };

            // 
            // Check the user if the license type said it should
            // have rights
            //
            if (checkUser || checkPcUser || checkOfflineUser)
            {
                bool onlineRestriction = false;
                bool foundLicensee = false;
                foreach (ulong puid in _userPuids)
                {
                    foreach (ContentLicensee licensee in license.body.licensees)
                    {
                        if (licensee.licenseeId == puid)
                        {
                            foundLicensee = true;
                            Global.RO.Success("Found User Licensee [0x{0:x8}] in ContentLicense.body.licensees", puid);
                            if ((licensee.licenseFlags & ContentLicense.LicenseFlagRequireOnline)== ContentLicense.LicenseFlagRequireOnline)
                            {
                                onlineRestriction = true;
                            }
                            break;
                        }
                    }
                    if (!foundLicensee)
                    {
                        isValid = false;
                        Global.RO.Error("Failed to find User Licensee [0x{0:x8}] in ContentLicense.body.licensees", puid);
                    }
                    else if (checkUser && !onlineRestriction)
                    {
                        // If we're checking regular user licenses and there is no online restriction, we have a problem
                        isValid = false;
                        Global.RO.Error("Require Online restriction was not present. User licenses should be limited on require online connectivity.");
                    }
                    else if ((checkOfflineUser || checkPcUser) && onlineRestriction)
                    {
                        // If we're checking offline user licenses and there IS an online restriction, we have a problem
                        // Note: PC user licenses are not restricted to online only too
                        isValid = false;
                        Global.RO.Error("Require Online restriction was present for {0} when not expected", checkOfflineUser?"Offline User":"PC User");
                    }
                }

            }

            // 
            // Check the machine if the license type said it should
            // have rights.
            //
            if (checkMachine)
            {
                ulong tempConsoleId = ConsoleIdUtil.GetConsoleIdFromMachineId(_machinePuid, XOn.XPLT_XBOX360);
                //ulong tempConsoleId = Utils.GetConsoleIdFromMachinePuid(_machinePuid);
                bool foundLicensee = false;
                foreach (ContentLicensee licensee in license.body.licensees)
                {
                    if (licensee.licenseeId == tempConsoleId)
                    {
                        foundLicensee = true;
                        Global.RO.Success("Found Machine Licensee [0x{0:x8}] in ContentLicense.body.licensees", tempConsoleId);
                        break;
                    }
                }
                if (!foundLicensee)
                {
                    isValid = false;
                    Global.RO.Error("Failed to find Machine Licensee [0x{0:x8}] in ContentLicense.body.licensees", tempConsoleId);
                }
            }

            if (checkUnrestricted)
            {
                ulong unrestricted = 0xffffffffffffffff;
                bool foundLicensee = false;
                foreach (ContentLicensee licensee in license.body.licensees)
                {
                    if (licensee.licenseeId == unrestricted)
                    {
                        foundLicensee = true;
                        Global.RO.Success("Found Unrestricted Licensee [0x{0:x8}] in ContentLicense.body.licensees", unrestricted);
                        break;
                    }
                }
                if (!foundLicensee)
                {
                    isValid = false;
                    Global.RO.Error("Failed to find Unrestricted Licensee [0x{0:x8}] in ContentLicense.body.licensees", unrestricted);
                }
            }

            return isValid;
        }

        public static void RevertByteOrder(ContentLicensee[] licensees)
        {
            for (int i = 0; i < licensees.Length; i++)
            {
                licensees[i].licenseeId = ContentLicense.RevertByteOrder(licensees[i].licenseeId);
                licensees[i].licenseBits = ContentLicense.RevertByteOrder(licensees[i].licenseBits);
                licensees[i].licenseFlags = ContentLicense.RevertByteOrder(licensees[i].licenseFlags);
            }
        }

        public static String GetPurchaseHistory(ulong userPuid, ulong machinePuid, string locale, string legalLocale,
                                              int store, int pageSize, int pageNum, int detailView, int[] mediaTypes, int orderBy, int orderDir)
        {
            PurchaseHistoryFilter filter = new PurchaseHistoryFilter();
            filter.Locale = locale;
            filter.LegalLocale = legalLocale;
            filter.Store = store;
            filter.PageSize = pageSize;
            filter.PageNum = pageNum;
            filter.DetailView = detailView;
            filter.MediaTypes = mediaTypes.ToList();
            filter.OrderBy = orderBy;
            filter.OrderDirection = orderDir;

            PurchaseHistoryWebRequest req = new PurchaseHistoryWebRequest(userPuid, machinePuid, filter);

            // Get the passport puid
            ulong passportPuid = ServerTestFramework.Database.UodbWS.GetUserPassportOwnerPuid(userPuid);

            if (!req.SendRequest(passportPuid))
            {
                throw new UnexpectedTestResultException(String.Format("Error while performing PurchaseHistoryRequest: 0x{0:X}", req.XErr));
            }

            return req.Response;
        }

        //gets the number of items in the billing history for a user
        public static int GetUserHistoryBillingCount(ulong userPuid, ulong machinePuid)
        {
            Global.RO.Debug("Looking up billing history...");

            List<Int32> mediaTypes = new List<Int32>();
            for (int mediaType = 1; mediaType <= 50; mediaType++)
            {
                mediaTypes.Add(mediaType);
            }

            // Do the call
            String rawResp = GetPurchaseHistory(userPuid, machinePuid, "en-US", "en-US", 1, 10, 1, 5, mediaTypes.ToArray(), 0, 1);           
            Global.RO.Debug("PurchaseHistory response: " + rawResp);

            //parse the response we care about out... example: <live:totalItems>1</live:totalItems>
            XDocument resp = XDocument.Parse(rawResp);
            XNamespace lns = resp.Root.GetNamespaceOfPrefix("live");

            var totalItemsElements = from ti in resp.Descendants(lns + "totalitems")
                                     select (int)ti;

            if (totalItemsElements.Count() > 0)
            {
                return totalItemsElements.First();
            }
            else
            {
                throw new UnexpectedTestResultException("Unable to find a totalitems count in response");
            }
        }
    }

    /// <summary>
    /// Defines the video quality levels available in the catalog
    /// </summary>
    public enum VideoQuality
    {
        /// <summary>
        /// High definition video quality
        /// </summary>
        HD = 0,
        /// <summary>
        /// Standard definition video quality
        /// </summary>
        SD,
        /// <summary>
        /// XD Quality implies both HD and SD, so if a user requestes XD, they should get a license for both
        /// </summary>
        XD,
    }

    public enum LicenseType
    {
        /// <summary>
        /// Used in places where we don't care about the licenseType
        /// </summary>
        None = 0,
        SyncCastDTO = 1,
        SyncCastPPV = 2,
        XblDTO = 3,
        XblPPV = 4,
        XblPPVMacrovision = 5,
        XblPPVICT = 6,
        XBLPPVMicrovisionICT = 7,
        ZunePCDTO = 8,
        ZuneDeviceDTO = 9,
        ZunePCSyncCastDTO = 10,
        /// <summary>
        /// Per-Machine License
        /// </summary>
        GamesPerMachine = 11, 
        /// <summary>
        /// Per-User License
        /// </summary>
        GamesPerUser = 12,
        /// <summary>
        /// Unrestricted License
        /// </summary>
        GamesUnrestricted = 13,
        /// <summary>
        /// Machine and User License
        /// </summary>
        GamesMachineAndUser = 14,
        /// <summary>
        /// PC User License
        /// </summary>
        GamesUserPC = 15,
    }

    public class MediaMatrix
    {
        public List<VideoInformation> MovieOffers;
        public List<VideoInformation> TVOffers;

        /// <summary>
        /// A simple Zune
        /// </summary>
        public static VideoInformation ZuneDTOVideoOffer_1;
        public static VideoInformation ZuneDTOVideoOffer_2;
        public static VideoInformation ZuneDTOVideoPromo;

        public static GameInformation TexasHoldEmOffer;
        public static GameInformation AvatarOffer;
        public static GameInformation ArcadeGame;
        public static GameInformation GreenlightApp;

        static MediaMatrix()
        {
            ZuneDTOVideoOffer_1 = new VideoInformation(
                    new Guid("68602d7a-d6ce-4b70-b989-11b48e3f4dc7"),
                    new Guid("c4f5435a-ed3a-46b5-b26a-2f39f40551fe"),
                    MediaTypeInfo.TVEpisode,
                    "ZuneDTOVideoOffer_1", 0);
            ZuneDTOVideoOffer_1.MediaInstanceId = new Guid("5482715d-e60d-4694-8b06-0e3ae887fff2");
            ZuneDTOVideoOffer_1.OfferInstanceId = new Guid("421cb780-ed1a-43c2-a6d3-2a8d43e80d08");
            ZuneDTOVideoOffer_1.LicenseType = LicenseType.ZunePCDTO;
            ZuneDTOVideoOffer_1.ClientTypeId = CatalogClientTypeEnum.WindowsPcClient;
            ZuneDTOVideoOffer_1.ExpectedPrice = 160;

            ZuneDTOVideoOffer_2 = new VideoInformation(
                    new Guid("3b2b540f-c83e-4da1-9ab5-09d5fd6a93ac"),
                    new Guid("dbdf7384-05a9-465b-942e-f259dfb29ca0"),
                    MediaTypeInfo.TVEpisode,
                    "ZuneDTOVideoOffer_2", 0);
            ZuneDTOVideoOffer_2.MediaInstanceId = new Guid("c7dd6abc-7935-429c-9615-acbd58dad95b");
            ZuneDTOVideoOffer_2.OfferInstanceId = new Guid("ab1f4ded-16af-4852-8807-38e09253e06d");
            ZuneDTOVideoOffer_2.LicenseType = LicenseType.ZunePCDTO;
            ZuneDTOVideoOffer_2.ClientTypeId = CatalogClientTypeEnum.WindowsPcClient;
            ZuneDTOVideoOffer_2.ExpectedPrice = 160;

            ZuneDTOVideoPromo = new VideoInformation(
                    new Guid("bb8d7d31-20ad-4c49-92f9-14356255d01f"),
                    new Guid("9847735f-90bf-4ab2-9a38-007f18b2aced"),
                    MediaTypeInfo.Promotional,
                    "ZuneDTOPromoVideo", 0);
            ZuneDTOVideoPromo.MediaInstanceId = new Guid("e4d933db-a2b6-434f-ad57-544a5a5fc4dd");
            ZuneDTOVideoPromo.OfferInstanceId = new Guid("3c8992eb-50aa-4ed6-bb54-ba1450d1b508");
            ZuneDTOVideoPromo.LicenseType = LicenseType.ZunePCDTO;
            ZuneDTOVideoPromo.ClientTypeId = CatalogClientTypeEnum.WindowsPcClient;

            TexasHoldEmOffer = new GameInformation(
                new Guid("00000001-0000-4000-8000-0000584107F6"),
                800,
                LicenseType.GamesMachineAndUser,
                MediaTypeInfo.ArcadeGame,
                new Guid("00000001-2067-4001-8000-0000584107f6"));
            TexasHoldEmOffer.ContentId = new Byte[] { 0xBD, 0x58, 0xCC, 0x03, 0xA4, 0xAA, 0x36, 0x99, 0x59, 0x0E, 
                                                      0x34, 0xE4, 0xE0, 0x65, 0xBB, 0xC0, 0x56, 0xDE, 0x59, 0x8F };

            AvatarOffer = new GameInformation(
                new Guid("00000047-0000-4000-8000-000050190002"),
                0,
                LicenseType.GamesPerUser,
                MediaTypeInfo.AvatarItem,
                new Guid("00000047-0000-4001-8000-000050190000"));
            AvatarOffer.ContentId = Hexer.unhex("0x1000000000470000000050190000");

            ArcadeGame = new GameInformation(new Guid("000000B6-0000-4000-8000-0000FFFE07D1"), 0, LicenseType.GamesMachineAndUser);

            GreenlightApp = new GameInformation(new Guid("E25074E5-D885-486F-9676-5D52FBFCAD0D"), 0, LicenseType.GamesMachineAndUser,
                61/*MediaTypeInfo.GreenlightApp*/, new Guid("8EBE3A2B-9945-4515-897A-A3ACDF02C57A"));
            GreenlightApp.MediaId = new Guid("66acd000-77fe-1000-9115-d802584109a8");
            GreenlightApp.ContentId = Convert.FromBase64String("GuUP+Fdsc3vrqLvsvxPFPajI5V8=");
            //MediaInstanceId/PackageId 
            //GreenlightApp.InstanceId = new Guid("1AE50FF8-576C-4073-807B-EBA8BBECBF13");
            GreenlightApp.MetadataProviderId = 123;
            GreenlightApp.Title = "Test Offer";
        }

        public MediaMatrix()
        {
            MovieOffers = new List<VideoInformation>();
            TVOffers = new List<VideoInformation>();
        }

        /// <summary>
        /// Dumps out the data about each offer that was collected from the query.
        /// </summary>
        public void DumpMediaInfo()
        {

            Global.RO.Info("####[ Movie Offers: {0} ]####", MovieOffers.Count);
            foreach (MediaInformation info in MovieOffers)
            {
                info.Dump();
            }

            Global.RO.Info("####[ TV Offers: {0} ]####", TVOffers.Count);
            foreach (MediaInformation info in TVOffers)
            {
                info.Dump();
            }
        }

        /// <summary>
        ///  Searches the specified list for the offer.
        /// </summary>
        /// <param name="offers">The list of media info to search</param>
        /// <param name="offer">The item to look for</param>
        /// <returns>True if the item exists, false otherwise</returns>        
        private bool OfferExist<T>(List<T> offers, T offer) where T : MediaInformation
        {
            return offers.Exists(delegate(T t)
                {
                    return t.Equals(offer);
                });
        }

        /// <summary>
        /// Get a single media information object from the catalog
        /// </summary>
        /// <param name="type">The type of media to find</param>
        /// <param name="quality">The quality of media to find</param>
        /// <returns>A list contaning a single media item of the requested type</returns>
        public List<VideoInformation> GetOffers(Int32 type, VideoQuality quality)
        {
            return GetOffers(type, quality, 1);
        }

        /// <summary>
        /// Get a number of media information objects from the catalog
        /// </summary>
        /// <param name="type">The type of media to find</param>
        /// <param name="quality">The quality of media to find</param>
        /// <param name="count">The number of items to find</param>
        /// <returns>A list contaning media items of the requested type</returns>
        public List<VideoInformation> GetOffers(Int32 type, VideoQuality quality, uint count)
        {
            List<VideoInformation> results = new List<VideoInformation>();

            switch (type)
            {
                case MediaTypeInfo.Movie:
                    if (MovieOffers.Count >= count)
                    {
                        for (int i = 0; i < count; i++)
                        {
                            // Find the movie offer instance with the quality we want
                            if ((MovieOffers[i].Flags & (uint)quality) == (uint)quality)
                            {
                                results.Add(MovieOffers[i]);
                                break;
                            }
                        }
                    }
                    break;

                case MediaTypeInfo.TVEpisode:
                    if (TVOffers.Count >= count)
                    {
                        for (int i = 0; i < count; i++)
                        {
                            results.Add(TVOffers[i]);
                        }
                    }
                    break;
            };

            return results;
        }

        /// <summary>
        /// Runs a FindVideoOffer query and populates the matrix with the data it
        /// collected.  Creates a user and client automatically for the requests
        /// </summary>
        public void PopulateOfferTable()
        {
            Global.RO.Info("Populating offer info...");

            TVOffers.Clear();
            MovieOffers.Clear();

            QueryRequest<FindVideosFilter> findVideos = new QueryRequest<FindVideosFilter>();
            //QueryWebPayload<FindVideosFilter> findVideos = new QueryWebPayload<FindVideosFilter>();
            findVideos.Filter.Locale = "en-US";
            findVideos.Filter.LegalLocale = "en-US";
            findVideos.Filter.Store = 1;
            findVideos.Filter.PageSize = 25;
            findVideos.Filter.PageNum = 1;
            findVideos.Filter.DetailView = 3;
            findVideos.Filter.OfferFilterLevel = 2;
            findVideos.Filter.UserTypes = new List<Int32> { 2 };
            findVideos.Filter.MediaTypes = new List<Int32> { 2 };
            findVideos.Filter.OrderBy = 3;
            findVideos.Filter.OrderDirection = 2;
            findVideos.Filter.VideoFilter = 1;

            Global.RO.Info("Requesting Movie media...");
            if (findVideos.SendRequest())
            {
                ParseFindVideoResponse(findVideos.Response);
            }
            else
            {
                Global.RO.Error("Unable to request movie media");
                return;
            }

            List<Guid> allMediaIds = new List<Guid>();
            allMediaIds.AddRange(MovieOffers.Select(mo => mo.MediaId));

            findVideos = new QueryRequest<FindVideosFilter>();
            //findVideos = new QueryWebPayload<FindVideosFilter>();
            findVideos.Filter.Locale = "en-US";
            findVideos.Filter.LegalLocale = "en-US";
            findVideos.Filter.Store = 1;
            findVideos.Filter.PageSize = 25;
            findVideos.Filter.PageNum = 1;
            findVideos.Filter.DetailView = 3;
            findVideos.Filter.OfferFilterLevel = 2;
            findVideos.Filter.UserTypes = new List<Int32> { 2 };
            findVideos.Filter.MediaTypes = new List<Int32> { 8 };
            findVideos.Filter.OrderBy = 3;
            findVideos.Filter.OrderDirection = 2;
            findVideos.Filter.VideoFilter = 1;

            Global.RO.Info("Requesting TV media...");
            if(findVideos.SendRequest())
            {
                ParseFindVideoResponse(findVideos.Response);
            }
            else
            {
                Global.RO.Error("Unable to request tv media");
                return;
            }

            if (TVOffers.Count + MovieOffers.Count == 0)
            {
                return;
            }

            allMediaIds.AddRange(TVOffers.Select(to => to.MediaId));

            QueryRequest<FindVideoOffersFilter> findOffers = new QueryRequest<FindVideoOffersFilter>();
            //QueryWebPayload<FindVideoOffersFilter> findOffers = new QueryWebPayload<FindVideoOffersFilter>();
            findOffers.Filter.Locale = "en-US";
            findOffers.Filter.LegalLocale = "en-US";
            findOffers.Filter.Store = 1;
            findOffers.Filter.PageSize = 100;
            findOffers.Filter.PageNum = 1;
            findOffers.Filter.DetailView = 5;
            findOffers.Filter.MediaIds = allMediaIds;
            findOffers.Filter.UserTypes = new List<Int32> { 2 };
            findOffers.Filter.MediaTypes = new List<Int32> { 2, 8 };

            Global.RO.Info("Requesting media offers...");
            if (findOffers.SendRequest())
            {
                ParseFindVideoOffersResponse(findOffers.Response);
            }
            else
            {
                Global.RO.Error("Unable to request media offers");
                return;
            }

            CleanUpList(TVOffers);
            CleanUpList(MovieOffers);
            // Prints out all the different groups of content
            DumpMediaInfo();

            Global.RO.Info("Offer info successfully populated.");
        }

        /// <summary>
        /// Parses the repsonse recieved from a catalog FindVideo request and 
        /// stores all of the discovered media items in the MediaMatrix
        /// </summary>
        /// <param name="responseXml">The XML Catalog FindVideo response</param>
        private void ParseFindVideoResponse(string responseXml)
        {
            // Load the response
            XDocument resp = XDocument.Parse(responseXml);
            // And create the namespaces we need
            XNamespace ns = resp.Root.GetDefaultNamespace();
            XNamespace lns = resp.Root.GetNamespaceOfPrefix("live");

            // Look for each entry and grab the MediaId, Title and MediaType
            var entries = from e in resp.Descendants(ns + "entry")
                          select new
                          {
                              id = StripGuidTags((String)e.Element(ns + "id")),
                              title = (String)e.Element(ns + "title"),
                              mediaType = (int)e.Element(lns + "media").Element(lns + "mediaType"),
                          };

            // Create a VideoInfo object for each entry
            foreach (var entry in entries)
            {
                VideoInformation vinfo = new VideoInformation();
                vinfo.MediaId = entry.id;
                vinfo.Title = entry.title;
                vinfo.MediaType = entry.mediaType;

                // And store it in the appropriate list
                switch (vinfo.MediaType)
                {
                    case 2: // Movie
                        {
                            if (!OfferExist(MovieOffers, vinfo))
                                MovieOffers.Add(vinfo);
                        }
                        break;
                    case 8: // TVEpisode
                        {
                            if (!OfferExist(TVOffers, vinfo))
                                TVOffers.Add(vinfo);
                        }
                        break;
                };
            }
        }

        /// <summary>
        /// Parses the repsonse recieved from a catalog FindVideoOffers request 
        /// and stores all of the discovered offers in the MediaMatrix
        /// </summary>
        /// <param name="responseXml">The XML Catalog FindVideoOffers response</param>
        private void ParseFindVideoOffersResponse(string responseXml)
        {
            // Load the document from the response
            XDocument resp = XDocument.Parse(responseXml);
            // And create the namespaces we need to use
            XNamespace ns = resp.Root.GetDefaultNamespace();
            XNamespace lns = resp.Root.GetNamespaceOfPrefix("live");

            // Look through each of the entries
            var entries = from e in resp.Descendants(ns + "entry")
                          select new
                          {
                              // And extract the offer data we want
                              offerId = StripGuidTags((String)e.Element(ns + "id")),
                              mediaType = (UInt32)e.Element(lns + "offer").Element(lns + "mediaType"),
                              price = (UInt32)e.Element(lns + "offer").Element(lns + "offerInstances").Element(lns + "offerInstance").Element(lns + "pointsPrice"),
                              mediaId = StripGuidTags((String)e.Element(lns + "mediaInstances").Element(lns + "videoMediaInstance").Element(lns + "mediaId")),
                              videoInstanceId = StripGuidTags((String)e.Element(lns + "mediaInstances").Element(lns + "videoMediaInstance").Element(lns + "videoInstanceId")),
                              videoDefinition = (String)e.Element(lns + "mediaInstances").Element(lns + "videoMediaInstance").Element(lns + "videoDefinition")
                          };

            // Then loop through each entry
            foreach (var entry in entries)
            {
                VideoInformation videoInfo = null;

                // Find a media item with the same media id and
                // media type as the one in the current offer
                var media = from mi in MovieOffers.Concat(TVOffers)
                            where entry.mediaId == mi.MediaId
                               && entry.mediaType == mi.MediaType
                            select mi;

                // If no media found, continue. This shouldn't happen, 
                // but that's not what we're testing
                if (media.Count() == 0)
                {
                    continue;
                }

                // Get the media item
                videoInfo = media.First();

                throw new NotImplementedException("This currently doesn't properly load video instances");
                
                // And add an offer instance
                //videoInfo.videoInstances.Add(
                //    new MediaInstanceInfo(
                //        entry.offerId, 
                //        entry.videoInstanceId, 
                //        entry.price,
                //        GetVideoInstanceFlags(entry.videoDefinition)
                //    ));

            }
        } // END ParseXML

        /// <summary>
        /// Strip any indentifier tags from the beginning of a GUID string
        /// and return the guid represented by the data
        /// </summary>
        /// <param name="guidString">The string from the XML document representing a GUID</param>
        /// <returns>A Guid representation of the string data</returns>
        private Guid StripGuidTags(string guidString)
        {
            return new Guid(guidString.Substring(guidString.LastIndexOf(':') + 1));
        }

        /// <summary>
        /// Convert a string video definition into it's corresponding flags
        /// </summary>
        /// <param name="videoDefinition">The video definition string</param>
        /// <returns>A UInt32 representation of the flags</returns>
        private UInt32 GetVideoInstanceFlags(String videoDefinition)
        {
            UInt32 flags = 0x0;

            switch (videoDefinition.ToLower())
            {
                case "hd":
                    flags = (UInt32)VideoQuality.HD;
                    break;
                case "sd":
                    flags = (UInt32)VideoQuality.SD;
                    break;
                case "xd":
                    flags = (UInt32)VideoQuality.XD;
                    break;
                default:
                    break;
            }

            return flags;
        }
                
        /// <summary>
        /// Loop through a list of media info items and remove all
        /// empty media items (media with no instances)
        /// </summary>
        /// <param name="videoInfoList">The list of items to clean</param>
        private void CleanUpList(List<VideoInformation> videoInfoList)
        {
            // Loop through each video info object
            videoInfoList.RemoveAll(
                delegate(VideoInformation vi)
                {
                    // Remove all empty media items with no instances
                    return vi.MediaInstanceId == Guid.Empty;
                }
            );
        }
    }

    /// <summary>
    /// Encapsulates all of the information for a single media item, including the media type, 
    /// offer and media ids and information and specific media instances
    /// </summary>
    public class MediaInformation : ICloneable
    {
        protected Boolean disposed = false;

        public Boolean IsGenerated { get; protected set; }

        public Guid OfferId { get; set; }
        public Guid OfferInstanceId { get; set; }
        public Guid MediaId { get; set; }
        public Guid MediaInstanceId { get; set; }
        public UInt32 ExpectedPrice { get; set; }
        public Int32 MediaType { get; set; }
        public String Title { get; set; }
        public Int32 MetadataProviderId { get; set; }

        /// <summary>
        /// Indicates whether or not geofencing is enabled
        /// </summary>
        public GeoCheckPolicy GeoCheckPolicy { get; set; }

        /// <summary>
        /// The type of license associated with this piece of content
        /// </summary>
        public LicenseType LicenseType { get; set; }

        //1 = HD, 2 = SD, 3 = XD?
        public UInt32 Flags { get; set; }
        
        public OfferMediaTypeExpectedPrice OfferMediaTypeExpectedPrice
        {
            get
            {
                return new OfferMediaTypeExpectedPrice
                {
                    OfferId = this.OfferId,
                    MediaTypeId = MediaType,
                    ExpectedPriceWhole = ExpectedPrice,
                    ExpectedPriceFractional = 0,
                };
            }
        }

        public OfferExpectedPrice OfferExpectedPrice
        {
            get
            {
                return new OfferExpectedPrice
                {
                    offerId = this.OfferId,
                    expectedPrice = this.ExpectedPrice,
                };
            }
        }

        public MediaInstanceIdOfferIdPair MediaInstanceIdOfferIdPair
        {
            get
            {
                return new MediaInstanceIdOfferIdPair
                {
                    miid = this.MediaInstanceId,
                    oid = this.OfferId,
                };
            }
        }

        /// <summary>
        /// Create an empty MediaInformation object
        /// </summary>
        public MediaInformation()
        {
            this.GeoCheckPolicy = GeoCheckPolicy.DoNotGeoFence;
            this.MetadataProviderId = 6;
        }

        /// <summary>
        /// Creates a MediaInformation object for the given offerId with one or more media instances
        /// </summary>
        /// <param name="offerId">The Offer GUID to create the info for</param>
        public MediaInformation(Guid offerId) : this()
        {
            this.OfferId = offerId;
            this.OfferInstanceId = offerId;
        }

        /// <summary>
        /// Creates a MediaInformation object for the given media properties
        /// </summary>
        /// <param name="offerId">The Offer GUID to create the info for</param>
        /// <param name="mediaId">The Media GUID to create the info for</param>
        /// <param name="mediaType">The media type of the media item</param>
        /// <param name="title">The title of the media item</param>
        /// <param name="flags">Additional media information</param>
        public MediaInformation(Guid offerId, Guid mediaId, int mediaType, string title, uint flags) : this()
        {
            this.OfferId = offerId;
            this.OfferInstanceId = offerId;
            this.MediaId = mediaId;
            this.MediaInstanceId = mediaId;
            this.MediaType = mediaType;
            this.Title = title;
            this.Flags = flags;
        }

        public MediaInformation(MediaInformation other)
        {
            this.OfferId = other.OfferId;
            this.OfferInstanceId = other.OfferInstanceId;
            this.MediaId = other.MediaId;
            this.MediaInstanceId = other.MediaInstanceId;
            this.ExpectedPrice = other.ExpectedPrice;
            this.MediaType = other.MediaType;
            this.MetadataProviderId = other.MetadataProviderId;
            this.GeoCheckPolicy = other.GeoCheckPolicy;
            this.Title = other.Title;
            this.Flags = other.Flags;
            this.LicenseType = other.LicenseType;
        }

        /// <summary>
        /// Clone this media information object.
        /// </summary>
        /// <returns>A deep copy of this media information object</returns>
        public virtual MediaInformation Clone()
        {
            return new MediaInformation(this);
        }

        object ICloneable.Clone()
        {
            return this.Clone();
        }

        public MediaInformation GenerateNewOffer()
        {
            return GenerateNewOffer(this.LicenseType, true);
        }

        public MediaInformation GenerateNewOffer(LicenseType licenseType)
        {
            return GenerateNewOffer(licenseType, true);
        }

        public virtual MediaInformation GenerateNewOffer(LicenseType licenseType, Boolean insertIntoCatalog)
        {
            MediaInformation newOffer = this.Clone();
            newOffer.OfferId = GetUnusedId();
            newOffer.OfferInstanceId = newOffer.OfferId;
            newOffer.LicenseType = licenseType;

            if (insertIntoCatalog)
            {
                newOffer.InsertIntoCatalog();
            }

            return newOffer;
        }

        public MediaInformation GenerateNewMediaInstance()
        {
            return GenerateNewMediaInstance(true);
        }

        public virtual MediaInformation GenerateNewMediaInstance(Boolean insertIntoCatalog)
        {
            MediaInformation newMediaInstance = this.Clone();
            newMediaInstance.MediaInstanceId = GetUnusedId();

            if (insertIntoCatalog)
            {
                newMediaInstance.InsertIntoCatalog();
            }

            return newMediaInstance;
        }

        /// <summary>
        /// Dump a bunch of debug information about this media item
        /// </summary>
        public virtual void Dump()
        {
            Global.RO.Debug("-------------------------------------------------- ");
            Global.RO.Debug("## [Title]\t\t\t" + Title);
            Global.RO.Debug("## [MediaType]\t\t" + MediaType);
            Global.RO.Debug("## [OfferId]\t\t\t" + OfferId);
            Global.RO.Debug("## [MediaId]\t\t\t" + MediaId);            
        }

        public void InsertIntoCatalog()
        {
            InsertIntoCatalog(true);
        }

        public void InsertIntoCatalog(Boolean overwrite)
        {
            String connectionString = ConfigUtil.FECatalogDBXboxConnectionString;
            Int32 storeId = (Int32)Store.Xbox360;

            if(CatalogUtil.IsInZuneCatalog(storeId, this.MediaType))
            {
                // Then we need to add a multisetting override to make it look in the Xbox Catalog
                String mediaTypeCatalogOverride = String.Format("{0},{1},FECatalogDBXbox", storeId, this.MediaType);
                // To make it less 'impactfull', just override the setting xsig and unknown, this allows STFGui to get it.
                //Global.XEnv.MultiSettingAdd(Config.Environment, "xsig", "-1", "ALL", "catalog_storeMediaTypeCatalogOverride", mediaTypeCatalogOverride);
                //Global.XEnv.MultiSettingAdd(Config.Environment, "unknown", "-1", "ALL", "catalog_storeMediaTypeCatalogOverride", mediaTypeCatalogOverride);
                Global.XEnv.MultiSettingAdd(Config.Environment, "ALL", "-1", "ALL", "catalog_storeMediaTypeCatalogOverride", mediaTypeCatalogOverride);
            }
            /*
            // This may be a bit simplistic, but it should work
            if (!CatalogUtil.IsInZuneCatalog((Int32)Store.Xbox360, this.MediaType))
            {
                connectionString = xonline.common.config.ConfigUtil.FECatalogDBXboxConnectionString;
            }
            else
            {
                try
                {
                    connectionString = xonline.common.config.ConfigUtil.FECatalogDBZuneConnectionString;
                    // This is not supported right now due to differences in the catalog schema
                    // between the Xbox and Zune DBs
                    //Global.RO.Warn("Waring, content must be in the ZuneCatalogDB.  This is unsupported by MediaInformation so content must already exist.");
                    //return;
                }
                catch
                {
                    // If FECatalogDBZune is not defined in the virtual interface list, this can fail
                    // we'll just use the Xbox DB if that ends up happening.
                    connectionString = xonline.common.config.ConfigUtil.FECatalogDBXboxConnectionString;
                }
            }
             */

            using (CatalogDb catalog = new CatalogDb(connectionString))
            {
                if (!overwrite)
                {
                    // Check to see if a piece of media with this id already exists.  Given that we check for use when
                    // generating random media, this should only occur if we're creating media from predefined data
                    // that might already exist in the database, it should be okay to just check for the Media.
                    String checkExistsSql = String.Format("select count(null) from Media m where m.mediaId = '{0}'", this.MediaId);
                    if (catalog.ExecuteCount(checkExistsSql) != 0)
                    {
                        return;
                    }
                }

                InsertIntoCatalog(catalog);
            }
        }

        protected virtual void InsertIntoCatalog(CatalogDb catalog)
        {
            // The media table lets us know the media type in addition 
            // to a few other values that we don't use
            catalog.Insert(new CatalogDb.Media
            {
                mediaId = MediaId,
                mediaTypeId = (Int32)MediaType,
                metadataProviderId = MetadataProviderId,
                providerId = MetadataProviderId,
                visibilityStatusId = 3,
                geoCheckPolicy = (Byte)GeoCheckPolicy,
            });

            // Okay we have a unique instance id and media/everything id.
            // Map the two of them together
            catalog.Insert(new CatalogDb.MediaInstance
            {
                mediaInstanceId = MediaInstanceId,
                mediaId = MediaId,
                isAcquirable = 1,
            });

            // Which then maps us to a media id for the offer id
            catalog.Insert(new CatalogDb.Offer
            {
                offerId = OfferId,
                mediaId = MediaId,
                name = Title,
            });


            // From the offer instance we get the offer id
            catalog.Insert(new CatalogDb.OfferInstance
            {
                offerInstanceId = OfferId,
                offerId = OfferId,
                countryCode = "us",
                sku = "",
            });

            Int32 result = 0;
            // The media instance also points us to an offer instance, in
            // addition to providing us with license type (important stuff).
            // Note: This table doesn't exist in the Zune catalog
            catalog.TryInsert(new CatalogDb.OfferInstanceMediaInstance
            {
                offerInstanceId = OfferInstanceId,
                mediaInstanceId = MediaInstanceId,
                visibilityStatusId = 3,
                providerId = 500,
                licenseTypeId = (Int32)LicenseType,
            }, out result);
        }

        public void RemoveFromCatalog()
        {
            using (CatalogDb catalog = new CatalogDb())
            {
                RemoveFromCatalog(catalog);
            }
        }

        public virtual void RemoveFromCatalog(CatalogDb catalog)
        {
            catalog.Remove(new CatalogDb.Media
            {
                mediaId = MediaId,
                mediaTypeId = (Int32)MediaType,
            });

            catalog.Remove(new CatalogDb.MediaInstance
            {
                mediaInstanceId = MediaInstanceId,
                mediaId = MediaId,
            });

            catalog.Remove(new CatalogDb.Offer
            {
                offerId = OfferId,
                mediaId = MediaId,
            });

            catalog.Remove(new CatalogDb.OfferInstance
            {
                offerInstanceId = OfferId,
                offerId = OfferId,
            });

            catalog.Remove(new CatalogDb.OfferInstanceMediaInstance
            {
                offerInstanceId = OfferInstanceId,
                mediaInstanceId = MediaInstanceId,
            });
        }

        public static Guid GetUnusedId()
        {
            Guid id;
            // We're basically just checking the default tables to findout if the identifier
            // has been used already, we're not doing anything exhaustive, but these are the 
            // ones that we should worry about the most.
            String cmdFormat = @"declare @id uniqueidentifier = '{0}'
                                 select 1 where
                                     exists(select null from Media m where m.mediaId = @id) or
                                     exists(select null from MediaInstance mi where mi.mediaInstanceId = @id) or
                                     exists(select null from Offer o where o.offerId = @id) or
                                     exists(select null from OfferInstance oi where oi.offerInstanceId = @id)";
            String cmd;

            using (CatalogDb catalog = new CatalogDb())
            {
                do
                {
                    // Generate a new guid
                    id = Guid.NewGuid();

                    // Generate the query string
                    cmd = String.Format(cmdFormat, id);
                } 
                while (catalog.ExecuteCount(cmd) > 0);
            }

            return id;
        }

        public static Boolean IsIdInUse(Guid id)
        {
            String cmdFormat = @"declare @id uniqueidentifier = '{0}'
                                 select 1 where
                                     exists(select null from Media m where m.mediaId = @id) or
                                     exists(select null from MediaInstance mi where mi.mediaInstanceId = @id) or
                                     exists(select null from Offer o where o.offerId = @id) or
                                     exists(select null from OfferInstance oi where oi.offerInstanceId = @id)";
            String cmd = String.Format(cmdFormat, id);

            using (CatalogDb catalog = new CatalogDb())
            {
                return catalog.ExecuteCount(cmd) > 0;
            }
        }
    }

    public class VideoInformation : MediaInformation
    {
        /// <summary>
        /// Represents the client type that this media is valid for.
        /// </summary>
        public CatalogClientTypeEnum ClientTypeId { get; set; }

        public static VideoInformation Generate(LicenseType licenseType, Int32 mediaType)
        {
            return Generate(licenseType, mediaType, true);
        }

        public static VideoInformation Generate(LicenseType licenseType, Int32 mediaType, Boolean insertIntoCatalog)
        {
            Guid videoId = GetUnusedId();

            VideoInformation videoInfo = new VideoInformation(videoId, videoId, mediaType, "TestVideo" + videoId, 0);
            videoInfo.IsGenerated = true;
            videoInfo.LicenseType = licenseType;
            videoInfo.ClientTypeId = CatalogClientTypeEnum.Xbox360;

            if (insertIntoCatalog)
            {
                videoInfo.InsertIntoCatalog();
            }

            return videoInfo;
        }

        /// <summary>
        /// Create and empty VideoInformation object
        /// </summary>
        public VideoInformation()
            : base()
        { }

        /// <summary>
        /// Creates a VideoInformation object for the given offerId with one or more media instances
        /// </summary>
        /// <param name="offerId">The Offer GUID to create the info for</param>
        /// <param name="videoInstanceList">MediaInstance information for the given offer</param>
        public VideoInformation(Guid offerId)
            : base(offerId)
        {
        }

        /// <summary>
        /// Creates a VideoInformation object for the given media properties
        /// </summary>
        /// <param name="offerId">The Offer GUID to create the info for</param>
        /// <param name="mediaId">The Media GUID to create the info for</param>
        /// <param name="mediaType">The media type of the media item</param>
        /// <param name="title">The title of the media item</param>
        /// <param name="flags">Additional media information</param>
        public VideoInformation(Guid offerId, Guid mediaId, int mediaType, string title, uint flags)
            : base(offerId, mediaId, mediaType, title, flags)
        { }

        public VideoInformation(VideoInformation other)
            : base(other) 
        {
            this.ClientTypeId = other.ClientTypeId;
        }

        /// <summary>
        /// Clone this media information object.  Does not clone video instances
        /// </summary>
        /// <returns>A deep copy of this media information object</returns>
        public override MediaInformation Clone()
        {
            return new VideoInformation(this);
        }

        /// <summary>
        /// Inserts this offer into the Catalog database
        /// </summary>
        /// <param name="catalog">The database interface to insert into</param>
        protected override void InsertIntoCatalog(CatalogDb catalog)
        {
            base.InsertIntoCatalog(catalog);

            DateTime now = DateTime.UtcNow;
            DateTime today = now.Date;
            String scoid = "SCOID_" + MediaInstanceId;

            // Insert the video information.  This defines the HD/SD offer stuff.  Probably don't need this

            Int32 result = 0;
            // We also need to map the ProviderTerm stuff
            catalog.TryInsert(new CatalogDb.ProviderTerm
            {
                providerTermId = MediaId,
                mediaId = MediaId,
                wholesalePrice = this.ExpectedPrice,
                wholesalePriceCurrencyCode = "USD",
                startDatetime = today.AddYears(-1),
                endDatetime = today.AddYears(1),
                countryCode = "us",
                modifiedBy = "signature_test",
            }, out result);

            catalog.Insert(new CatalogDb.OfferInstanceProviderTerm
            {
                offerInstanceId = OfferInstanceId,
                providerTermId = MediaId,
                visibilityStatusId = 0,
                modifiedDate = today,
            });

            // It gives us the licenseType
            catalog.Insert(new CatalogDb.ProviderTermMediaInstance
            {
                providerTermId = MediaId,
                mediaInstanceId = MediaInstanceId,
                licenseTypeId = (Int32)LicenseType,
                expirationDate = today.AddYears(1),
            });

            // and allows us to map on or more client types
            catalog.Insert(new CatalogDb.ProviderTermMediaInstanceClientType
            {
                mediaInstanceId = MediaInstanceId,
                providerTermId = MediaId,
                clientTypeId = (Int32)ClientTypeId,
            });

            // SyncCast stuff allows generation of synccast license things
            catalog.Insert(new CatalogDb.SyncCastKeyInfo
            {
                SCOID = scoid,
                syncCastKey = "SignatureTest_SyncCastKey",
                // An 'arbitrary' encryted key ("ABCDABCDABCD"). Seriously WTF.  
                // Keys have 32 bit (little endian) length prefix So this is the 
                // Base64 encrypted 12 byte key with length: "\xC\0\0\0ABCDABCDABCD"
                encryptedSeed = "Ies5c4M5slg9YjBSAnoDoKNdl4CPsnSH7I75LaqCBXI=",
            });

            catalog.Insert(new CatalogDb.SyncCastMediaInstanceMap
            {
                SCOID = scoid,
                mediaInstanceId = MediaInstanceId,
            });
        }

        /// <summary>
        /// Removes this offer from the Catalog database
        /// </summary>
        /// <param name="catalog">The database interface to remove from</param>
        public override void RemoveFromCatalog(CatalogDb catalog)
        {
            base.RemoveFromCatalog(catalog);

            String scoid = "SCOID_" + MediaInstanceId;

            catalog.Remove(new CatalogDb.ProviderTerm
            {
                providerTermId = MediaId,
                mediaId = MediaId,
            });

            catalog.Remove(new CatalogDb.OfferInstanceProviderTerm
            {
                offerInstanceId = OfferInstanceId,
                providerTermId = MediaId,
            });

            catalog.Remove(new CatalogDb.ProviderTermMediaInstance
            {
                providerTermId = MediaId,
                mediaInstanceId = MediaInstanceId,
            });

            catalog.Remove(new CatalogDb.ProviderTermMediaInstanceClientType
            {
                mediaInstanceId = MediaInstanceId,
                providerTermId = MediaId,
            });

            catalog.Remove(new CatalogDb.SyncCastKeyInfo
            {
                SCOID = scoid,
            });

            catalog.Remove(new CatalogDb.SyncCastMediaInstanceMap
            {
                SCOID = scoid,
                mediaInstanceId = MediaInstanceId,
            });
        }
    }

    public class GameInformation : MediaInformation
    {
        public static GameInformation Generate(LicenseType licenseType, Int32 mediaType)
        {
            return Generate(licenseType, mediaType, true);
        }

        public static GameInformation Generate(LicenseType licenseType, Int32 mediaType, Boolean insertIntoCatalog)
        {
            Byte[] contentId;
            Guid mediaInstanceId;
            Guid gameId = GetUnusedId();

            // Since the mediaInstanceId is based on the content id, we're generating that here manually.
            using (CatalogDb catalog = new CatalogDb())
            {
                String cmd;
                String mediaInstanceSqlFormat = "select 1 where exists(select * from MediaInstance where mediaInstanceId = '{0}')";

                do
                {
                    // Make a random content id
                    contentId = RandomEx.GlobalRandGen.GenerateRandomBlob(20);
                    // and a matching media instance id
                    mediaInstanceId = CatalogUtil.ContentIdToMediaInstanceId(contentId);
                    cmd = String.Format(mediaInstanceSqlFormat, mediaInstanceId);
                    // and make sure it doesn't exist already
                }
                while (catalog.ExecuteCount(cmd) > 0);
            }

            // Okay we have a unique instance id and media/everything id.
            GameInformation gameInfo = new GameInformation(gameId, 200, licenseType, mediaType);
            gameInfo.IsGenerated = true;
            gameInfo.ContentId = contentId;
            
            if (insertIntoCatalog)
            {
                gameInfo.InsertIntoCatalog();
            }

            return gameInfo;
        }

        public static GameInformation Generate(Guid offerId, Byte[] contentId, LicenseType licenseType, Int32 mediaType)
        {
            using (CatalogDb catalog = new CatalogDb())
            {
                Guid instanceId = CatalogUtil.ContentIdToMediaInstanceId(contentId);
                String mediaInstanceSqlFormat = "select 1 where exists(select null from MediaInstance where mediaInstanceId = '{0}')";
                String mediaInstanceCheckCmd = String.Format(mediaInstanceSqlFormat, instanceId);

                // We're use the same GUID for mediaId, offerId, and offerInstanceId, and the offers mediaId
                String gameIdSqlFormat = @"declare @id uniqueidentifier = '{0}'
                                           select 1 where 
                                               exists(select null from Media m where m.mediaId = @id) or
                                               exists(select null from MediaInstance mi where mi.mediaInstanceId = @id) or
                                               exists(select null from Offer o where o.offerId = @id) or
                                               exists(select null from OfferInstance oi where oi.offerInstanceId = @id)";
                String gameIdCheckCmd = String.Format(gameIdSqlFormat, offerId);

                GameInformation gameInfo = new GameInformation(offerId, 200, licenseType, (Int32)mediaType);
                gameInfo.ContentId = contentId;

                // Check if it already exists in the database
                if (((Int32)catalog.ExecuteScalar(mediaInstanceSqlFormat)) > 0)
                {
                    Global.RO.Debug("MediaInstance {0} already exists.", instanceId);
                }
                else if (((Int32)catalog.ExecuteScalar(gameIdCheckCmd)) > 0)
                {
                    Global.RO.Debug("OfferId {0} already exists somewhere in the catalog.", offerId);
                }
                else
                {
                    // Okay, it's unique so lets add it
                    gameInfo.InsertIntoCatalog();
                }

                return gameInfo;
            }
        }

        /// <summary>
        /// This is currently just set to a default content ID that seems to work for the tests
        /// </summary>
        private Byte[] contentId = new Byte[] { 0xB7, 0xC6, 0x18, 0xDC, 
                                                0x4D, 0x87, 0xE8, 0x9B, 
                                                0x8E, 0x8E, 0x76, 0xAF, 
                                                0x6D, 0xC9, 0xB0, 0x50, 
                                                0x60, 0x3A, 0xFE, 0x9D };
        public Byte[] ContentId
        {
            get { return contentId; }
            set 
            {  
                contentId = value; 
                // The media instance id and content id are logically 
                // related, so just reset the value here as appropriate
                this.MediaInstanceId = CatalogUtil.ContentIdToMediaInstanceId(contentId);
            }
        }

        /// <summary>
        /// A set of additional information bits associated with this
        /// piece of content.  This can represent a number of things 
        /// including the content index, trial status, or other.
        /// </summary>
        public Int32 LicenseBits { get; set; }

        public GameInformation(Guid offerId, UInt32 expectedPrice)
            : this(offerId, expectedPrice, LicenseType.GamesPerMachine, 23, offerId)
        { }

        public GameInformation(Guid offerId, UInt32 expectedPrice, LicenseType licenseType)
            : this(offerId, expectedPrice, licenseType, 23, offerId)
        { }

        public GameInformation(Guid offerId, UInt32 expectedPrice, LicenseType licenseType, int mediaType)
            : this(offerId, expectedPrice, licenseType, mediaType, offerId)
        { }

        public GameInformation(Guid offerId, UInt32 expectedPrice, LicenseType licenseType, Int32 mediaType, Guid offerInstanceId)
            : base(offerId, offerId, mediaType, "TestGameOffer_" + offerId, 0x0)
        {
            this.OfferInstanceId = offerInstanceId;
            this.ExpectedPrice = expectedPrice;
            this.LicenseType = licenseType;
        }

        public GameInformation(GameInformation other)
            : base(other)
        {
            this.ContentId = other.ContentId;
            this.LicenseBits = other.LicenseBits;
        }

        public override MediaInformation Clone()
        {
            return new GameInformation(this);
        }

        public GameInformation GenerateNewOffer(Int32 licenseBits)
        {
            return GenerateNewOffer(licenseBits, this.LicenseType);
        }

        /// <summary>
        /// Generate a new offer and offer instance for the the same piece of content
        /// </summary>
        /// <param name="licenseBits"></param>
        /// <param name="licenseType"></param>
        /// <returns></returns>
        public GameInformation GenerateNewOffer(Int32 licenseBits, LicenseType licenseType)
        {
            // Don't insert because we need to add the licenseBits
            GameInformation newOfferInfo = (GameInformation)this.GenerateNewOffer(licenseType, false);
            newOfferInfo.LicenseBits = licenseBits;
            newOfferInfo.InsertIntoCatalog();

            return newOfferInfo;
        }

        /// <summary>
        /// Inserts this offer into the Catalog database
        /// </summary>
        /// <param name="catalog">The database interface to insert into</param>
        protected override void InsertIntoCatalog(CatalogDb catalog)
        {
            base.InsertIntoCatalog(catalog);

            // Last but not least, make sure there is a mapping for 
            // the offer instance and media instnce
            catalog.Insert(new CatalogDb.OfferInstanceGameContentInstance
            {
                offerInstanceId = OfferId,
                gameContentInstanceId = MediaInstanceId,
                licenseExtensionBits = LicenseBits,
            });
        }        

        /// <summary>
        /// Removes this offer from the Catalog database
        /// </summary>
        /// <param name="catalog">The database interface to remove from</param>
        public override void RemoveFromCatalog(CatalogDb catalog)
        {
            base.RemoveFromCatalog(catalog);

            // Last but not least, make sure there is a mapping for 
            // the offer instance and media instnce
            catalog.Remove(new CatalogDb.OfferInstanceGameContentInstance
            {
                offerInstanceId = OfferInstanceId,
                gameContentInstanceId = MediaInstanceId,
                licenseExtensionBits = LicenseBits
            });
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\LicenseMigration\LiceMig.cs ===
using System.Windows.Forms;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Billing.License;

namespace SigTest.LicenseMigration.Functional
{
    [TestGroup, AsyncGroup(1, 1)]
    partial class LiceMigTests : TestNode
    {
        public static Report ro { get { return LicenseMigrationUtils.RO; } }
        public static SigTest.License.MediaMatrix matrix;

        public override void PreRun()
        {
            //init IDCRL
            AuthClientBase.InitializePassportIDCRL();

            matrix = new SigTest.License.MediaMatrix();
        }
    }

    //gui options
    public class SettingsGuiMenu : STFGui.Plugins.IPluginGui
    {
        public MenuItem GetNewMenu()
        {
            MenuItem baseMenu = new MenuItem("LicenseMigration");

            MenuItem miFakeVideo = new MenuItem("Use Fake Video Guids", MenuChoice_UseFakeVideo);
            miFakeVideo.Checked = LicenseMigrationUtils.LiceMigSettings.UseFakeVideoGuid;
            baseMenu.MenuItems.Add(miFakeVideo);

            MenuItem miStressFakeUsers = new MenuItem("Stress: Use direct users with fake purchases", MenuChoice_UseStressFakeUsers);
            miStressFakeUsers.Checked = LicenseMigrationUtils.LiceMigSettings.UseFakeUsersForStress;
            baseMenu.MenuItems.Add(miStressFakeUsers);

            return baseMenu;
        }

        private void MenuChoice_UseFakeVideo(object sender, System.EventArgs args)
        {
            MenuItem mi = (MenuItem)sender;
            mi.Checked = !mi.Checked;
            LicenseMigrationUtils.LiceMigSettings.UseFakeVideoGuid = mi.Checked;
            Global.RO.Info("UseFakeVideoGuid=" + LicenseMigrationUtils.LiceMigSettings.UseFakeVideoGuid);
        }

        private void MenuChoice_UseStressFakeUsers(object sender, System.EventArgs args)
        {
            MenuItem mi = (MenuItem)sender;
            mi.Checked = !mi.Checked;
            LicenseMigrationUtils.LiceMigSettings.UseFakeUsersForStress = mi.Checked;
            Global.RO.Info("UseFakeUsersForStress=" + LicenseMigrationUtils.LiceMigSettings.UseFakeUsersForStress);
        }

        #region IPluginGui Members

        public STFGui.Plugins.MainGuiHooks GuiHooks
        {
            get;
            set;
        }

        public TabPage GetNewTabPage ()
        {
            return null;
        }

        public void OnGuiShown ()
        {
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\License\AcquireMediaLicenses.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;

using xonline.common.billing;
using xonline.common.protocol;
using xonline.common.service;

namespace SigTest.License.Functional
{
    [TestGroup, AsyncGroup(1, 1)]
    public partial class License : TestNode
    {
        public static VideoInformation zunePpvVideo;

        public override void PreRun()
        {
            MediaMatrix.ZuneDTOVideoOffer_1.InsertIntoCatalog(false);
            MediaMatrix.ZuneDTOVideoOffer_2.InsertIntoCatalog(false);
            MediaMatrix.ZuneDTOVideoPromo.InsertIntoCatalog(false);

            Guid ppvVideoId = Guid.NewGuid();
            zunePpvVideo = new VideoInformation(
                    ppvVideoId,
                    ppvVideoId,
                    MediaTypeInfo.Movie,
                    "ZunePPVVideoOffer", 0);
            // Seriously doesn't make much sense, but basically this 'movie' is an XboxPPV 
            // piece of content, but it's 'available' to the Zune Windows client.
            zunePpvVideo.LicenseType = LicenseType.XblPPV;
            zunePpvVideo.ClientTypeId = CatalogClientTypeEnum.WindowsPcClient;
            zunePpvVideo.InsertIntoCatalog();
        }

        public override void PostRun()
        {
            zunePpvVideo.RemoveFromCatalog();
        }

        [TestGroup, Owner("BenRan"), TestFrequency("Regression")]
        public class AcquireMediaLicenses : TestNode
        {
            // Bad ClientInfo blocks
            private const string ClientInfoNoDevCert =               "<CLIENTINFO><CLIENTID>AgAAAPiqsL8f!76t6sjrZjnhKc2gzpxSdxXFerkjLITea76j0i0M9DE3SCVe!EGYFlss5zJrvmNeh1x*afnOY3L2GxY0eYpAAHE1NuMeoIJ1iWxnlJlkEzKyEz!0djMKmtMHANTrLE2L7ADYzg2Ej0ulrbVR4zsAFbzH0CAMcGJbMo10gCaqwaPXoqBKdA1nKSV9UIg2VagA8YAEsKg94aF!ciQy!4S5</CLIENTID><CLIENTVERSION>9.00.00.2778</CLIENTVERSION><SECURITYVERSION>2.4.105.189</SECURITYVERSION><APPSECURITY>2000</APPSECURITY><SUBJECTID1>1313</SUBJECTID1><SUBJECTID2></SUBJECTID2><DRMKVERSION></DRMKVERSION></CLIENTINFO>";
            private const string ClientInfoEmptyDevCert1 =           "<CLIENTINFO><CLIENTID>AgAAAPiqsL8f!76t6sjrZjnhKc2gzpxSdxXFerkjLITea76j0i0M9DE3SCVe!EGYFlss5zJrvmNeh1x*afnOY3L2GxY0eYpAAHE1NuMeoIJ1iWxnlJlkEzKyEz!0djMKmtMHANTrLE2L7ADYzg2Ej0ulrbVR4zsAFbzH0CAMcGJbMo10gCaqwaPXoqBKdA1nKSV9UIg2VagA8YAEsKg94aF!ciQy!4S5</CLIENTID><CLIENTVERSION>9.00.00.2778</CLIENTVERSION><SECURITYVERSION>2.4.105.189</SECURITYVERSION><APPSECURITY>2000</APPSECURITY><SUBJECTID1>1313</SUBJECTID1><SUBJECTID2></SUBJECTID2><DRMKVERSION></DRMKVERSION><DEVCERT>  </DEVCERT></CLIENTINFO>";
            private const string ClientInfoEmptyDevCert2 =           "<CLIENTINFO><CLIENTID>AgAAAPiqsL8f!76t6sjrZjnhKc2gzpxSdxXFerkjLITea76j0i0M9DE3SCVe!EGYFlss5zJrvmNeh1x*afnOY3L2GxY0eYpAAHE1NuMeoIJ1iWxnlJlkEzKyEz!0djMKmtMHANTrLE2L7ADYzg2Ej0ulrbVR4zsAFbzH0CAMcGJbMo10gCaqwaPXoqBKdA1nKSV9UIg2VagA8YAEsKg94aF!ciQy!4S5</CLIENTID><CLIENTVERSION>9.00.00.2778</CLIENTVERSION><SECURITYVERSION>2.4.105.189</SECURITYVERSION><APPSECURITY>2000</APPSECURITY><SUBJECTID1>1313</SUBJECTID1><SUBJECTID2></SUBJECTID2><DRMKVERSION></DRMKVERSION><DEVCERT/></CLIENTINFO>";
            private const string ClientInfoBothDevAndMachineCert =   "<CLIENTINFO><CLIENTID>AgAAAPiqsL8f!76t6sjrZjnhKc2gzpxSdxXFerkjLITea76j0i0M9DE3SCVe!EGYFlss5zJrvmNeh1x*afnOY3L2GxY0eYpAAHE1NuMeoIJ1iWxnlJlkEzKyEz!0djMKmtMHANTrLE2L7ADYzg2Ej0ulrbVR4zsAFbzH0CAMcGJbMo10gCaqwaPXoqBKdA1nKSV9UIg2VagA8YAEsKg94aF!ciQy!4S5</CLIENTID><CLIENTVERSION>9.00.00.2778</CLIENTVERSION><SECURITYVERSION>2.4.105.189</SECURITYVERSION><APPSECURITY>2000</APPSECURITY><SUBJECTID1>1313</SUBJECTID1><SUBJECTID2></SUBJECTID2><DRMKVERSION></DRMKVERSION><DEVCERT>lY6J1+KSUbabQ0AV7pPyM/S6aYUNuRM739Mcg5sp+bgdGXu8sOnnSc+TluSjB6saCSEjSyJk33jLKnAWdVrdCumX/YlZNmAfKxMRkNqoR2iBiARbXcIhQF/XuiyI91rDLQVG/s1+u2IynSvMz53LRbV76HEaJlGc6AL6aes8oeiNa6YfI2NYp0Vd52LaGdavhM6ZJfmOeZf/CtCCkcfjfmjBjy7HtslzrKJZqUYAsiQQKafEuPTegGCnAno5ywhWRLX81au7fg2svpWWwfOwNtxeocTphmd5hH3eQB+MNw+wfb4uV1QGf4gvkTDAUs8/E9jIcf9oPT3yqUv4MiEcv1WAx4Ys50JO9iPu02Sd3X9bKzvli6SLC0di7H2zx63TjK2RUVs8JFJDqq2SMydfDE4llH0py2Rv8nMwo2QlkkrhmzaZDse2aRhVGV7wymfoZDSvSsLUs69P2g1Y6Ay1KqWSg+mpi7+mZO+JVvQeFwKIPP3DHW+415OmQzOof4o2ElGBGNjVj5Z+QpjmlzROthl4uxp8p7gvGvaYlvM5U2qi7eThBgRvWTkX14uxW05R737JuCfXl4bPQfeNN9ZgdqN5eFKxgROIdQ4BZ89qQG1oak6aMEcgDKSit3oO217/RPQ/6SxkuQcl4EXAqjhzcdvcsrfoTS9GXpxOP9zUj3GeEqjh43dODSwlNNnG4vokXjEPfxlwKLl7nUEXpWpzVRw8gNIydM8rB+hbUsQ3LCETpfFgdRvZFdCQ5pLVm3fr4OqkCG6nJlX71IfzclaW4V+07+KBN/Smag1BstkETJQKpzpJ7OZFVfVBwUxvLiN8KHMTe2/nAW7bAGMjC/Ls4BTnUICgm7cEPOjDIvRzrzAoz3kHvGr1HFw+kdExuEJLzmEVWp61f6QlREFFdo1ucTLss5mgvG78YuaM7E6irjikClc8NeZsYWrkpqqz9wccq6bYq5cWm86FlBOzLHUOBfov5IOK0VCyFpRQ0neYtr4noCjMvrH7H/OT33lHcfMRc+ZX9lSMa2gbTYJLuUS19BXf1Q7ybUH6CBLkeuVwSs6zrXDZs+sfzlmf+NMLIafB+93sQUO22wLs7OfxImrivRXhOQmD/yiBLVOvDtlHcv9F8sTPO1uFl1ZaCeZ4uHqUZsTeCLcrY8l21At0s7QA2An/8gDMwNVBqH6VsaMSMcf1YzTiGRBRBGkWEbsGwl+KPzn6Q6PXPT/VUPMgLoZjtY/kEHHF3QPYridz648qE6nSCSgouaF5YzgElq6TRmH81qtU6VkJiE6PPRZBEzmmasdYlmJ/DDQCIOJk+6sXaZODwv53wrS69fxxBXX7gjCqGWnrOXxUZQearKBJzGAzrUg/0ZzfEB6j7+zfKp0orPVEA9yPSl7flGratHGBUYYmGZ3TSTIMwXOALS+rYOvw61rrpuJLBaqvo5BbGmADkI9CfBLC08amCG80QmPFIcCM3Hxx/ru+hD9KxwVHfwUusrYJofjISma6sHH3JPMvY5MZGXII1yJdXJrDfKoOjhy9M6kbm13zqW/YvkwLcSis5hMWfs1UZcsMK61U/yohbNIAJvrFTJi1Mn5mPEah7gx/aSJGGqDOR76RA+y37Vmg6CsGncw6M7bbaNluy9ULA/MZyVBL2PEAWARk4i7dB7Sl1XJd3FWpfyR3H/T8KHxJGs0/Q/44bu6DTdKWa/eV/VsqN3lifCIPn3VNVNGMfu3yZk+Qd2egKcZRxiGKshIVPAMbXcXCt/U1LD8Yx/2IDZ5ZsHu5xaDuxX9F+o+41NoswrxFqY/JKjTc1t43GISmE0ANphFSUu6+OSAq6pqwmSZCGD7wm45UKo9ZkerbpmBy5kGuhcAjSSpFJT+XBqWlnOcagO3iR5vg3SYE7VlIfDT2WyA1ARHOT7b8RLH6pmR0tswaWNq1RZFob6+zTl1b+rtmPvkhenaiM5NU8DbXO9h8bBwkhH3WLQTJYUup+fDcPQBXw+UuuWjpvHa55vtTcBgZLIPdoP71lTDmZbTZeQdr7iaIyTjiFY+hApWngqElJxO+fVMyBl23mrHzmzKkO0gsxH2OuAQIDm81eEyJLJx4WDVpS261DobxJpjcnFhq5BVtKO2LbxtnceGI3nuUyhbI0Dqy7PwlyTFKzWaSrdpqzSjRryTcMdAoFUsM95MvgziL+GAloG575Eiwt3VYhkya8G9PCIdXACi+JtUD1c2rrJUnzWXug0AhFonhMeqs67E0hXPmpGEAfhYzNWvX7Am9E6ba6HQmED071EIhk9a/ZDZbfDEQ6YvurGPE3vgPOdgpHk2+wkxrHmAIJD0BApkNoTpr8U/W3ugRTLYxkaRzOtJQYgTeZ/vNoXMtAA4AFHd7+m4HevG0Y0e8ePxj+AyRGjv2Hzc3vxzCBfLUPr/hWcPeciW4pHOpuS4yE8jJwMCnOM/HQKt/krxlv8j97FEjrh62c0/CkQ1lohUhoMj5oI5ctvFOxR3eO0dU0UBhdNpYyuA4eHQVNZnxKFVm9iH5KV/X2m33Hp8TS7f0P7dPR0oh1tV5bQCe/fODsoiuWptq/K5UMPUYfCSd26IzDfSUE/J/45eUnFkQ6pJeAPi5Xgb+pY8GWytiVbEngrX7htVmxUNSd/Y7Q5MvqqftIDJjDliYgzMrCWEwHHb3Xd83QEY+osvUZbusIvndnL7pGocSrtUwK/wnrWO7mDFF8Mb55oioBjlpq25cVb4hwbCJUXn3hDfJXaZrYHr3+ZnbnRIY99P62CojNFxBPkXlnFmlokbDXVqjMKVfwWAA4JAwaPBCgUEmi0XAi093NPQe8KG8oEErE3tlREFM9xpT5rb5ei0/+Ld+YJdNQN9MBjgLtQnixrw5wbsP3XGYx1ufqjb8T76T/HIbm5ODhcvXnulb6sEPu6TgHyFD/PDujxrSWgOwfidRhUS5eTXAn9cZj3uf+5HDQZPcZLy6Goo88uCcOYmIwN/6jzja0P6lwWYhUuGzs48flRrYynLSDbkLYDFqVTD+7G49d7GUkdlNv8wKgh0Awr7+lJe8PdBfAw7INfkVWXEkXcLLQS7pen9pTDvxXBE4nvym693CpB0JOio5bBgt2AfVcQUSxnZ01oDYd9aaDLUDH4nqJy9pvoNTjd+YQ40+Z0KLAl4TaFLByKWEnVGntZs219AOxuM42SDoXHVok3+u7mquKb4iq7ru3G/kgasOtCTcmJSvSC8+l27c3LJtEcaDA886dubLIoFBeIkg7O11+s1wsN86vf5wiMLMvD0D9n7E1J/Aw2gDz3nwJo0oklJJ6GHE3HVppVAfCD7s/CjYZI2BL+qR3oXsHZUf3RWLMhukQC/5KEGKOjzfGiZQneHCyh5tJpovJ6E4RHITj4q/0qyZfIzKhXzUNJjWODyGGv+NvCNj7+Q4RMiu0pmeu8PdMiOOKG0ygt12lZfJCSsRfx2Kavq60FpiJxw9/HagMAASK2CcsI50t1my9rDgXIEBycb9q17vBK1jLGgDA9CMtNFMPQ2LPf/Jnkhc5llZrAyB08qvCQfDdv4Az1y4/L6QkUeac/aGcZi4Lsqg6Dvp8gGWWjBrwxIMCOcsJD9FlwkO4GnOghP9dAcA6HnJdsKN6jQX96UiaqQzgvmXDT2Z6ZX9t/Ntkhb/VzWVGcLBIfH+8zpOKx+cP0bDsGmpFK/gK+hScoBHBYNxifND8vQ+1rsKHgFFA45/Ge1O8Jw8IYeP5h3gR4m3khR+VRcH7KeUD61BkKBidjMtlNuU/gbW1tdH3+l79hq4MAbWtcSMR/mScMG5ris2ERg8tNx1r2z6ufvzibeSpN6Nsi9bofVsKMYt4ZqzLvuYs4WoQjE6K4+iC44drhHO+HCThxTSe9NQE2odE3TYXzJ+jGxRDKpWZqvBvajXbegi1oD+ANw80ZX1PGc5aYl5uFx+g1KDsU0WysTQ6/oRB5BDMG7KEbZnBFgI6bqhJb9zhlDhUuzqYI705ttjHw0rwYyzKpKd3R2cchvqmUouKDmLU1z3u6kTv0lqAT3bR22WWk2UQ3ZYxhlQb0WmY8mqncvYDN+qPZS4BUPDf9q+VVCzQ4TNoQFy0vIoWId+qV5L8lmpEhRKwT75EGJQ2UEsCS9LutNmehY7M5eaVM8fsRQpxmaygdNSdMR+nR/FwXB9PUKQUg6TXTpT2z8IKXoeDqiJMx3Bov7WLvb511Ljhl3m+yTv6C3Bma4s4AxNTybdLL+8vYLaI66Y03tbSBtoa8Wh+1vlR09cS3VO7k71Uh/xpcH7Ra9mpSannCvt8KRmh5oRp1PC7TBdDPgMrnwOyZ7MpnAqZq1e1bEDDSTVacT2ecFzHmTEFXPxHy+jE02/jqH/CnTGC81CGFta2FomsXYL3bZND1WXkr3qznLSfUjnWK/Tehi3jbdtGt1faYv+zrlAWDWYwvRaE4QbmxAGM9ifUHpcYT24jvd6qDCdHEX4mz3Va6/aNNXMUTi2S6JXrVRH6LnpR+RSCkRVsZwZ3p6EA2Phw5TXdbMtai8smrwgB5VmPN8WwG2KKxLD39UapUE/gRHalw5JKg9Ep1gKYWpxdlFQQTJ3nWLusKjgB69AGaWCdIuj47cInW0Vv61un6Lw7JkrUfw2muZ3pp09eN9SkZN4/3K9GbN/UeIGyI+JwvqKCJBVgIZJPK+WyUddSvIFO91nN/IxzR2ZPjIblMkuPiA+Q9oYBQDqBKM5mcrU3CW81ThrrR2tAFZvi3BbTUqagP21getVoBr/ReRtrZSdLBLJ7m7gOrHjojWR+ypvEv1aFjNv9NqDVjzDlbTZ7PKl0VizU6YDdaG2VZ65uK6uAM3D4p3/BURAkCE1cxpjwum08gRlTGZDiIm8fRORBS5/GKNKyGnT8l0MgX8rcAx8Gk39vEmdNLsico/lfvzqMyO0oXcBjK3qGiM6/ycwUmeJs88bUUQ2I3qb00A+nAG2+Lf2K8ly57dkpJiUKKzxvSYtgbo6TzWZ95CBjD5Gtl5d+BRtm8ZA1VocFk4HSZniE1LFwoNQU7ecgKQ4YFxuTQ3Bu50L6i7WA+37gDcCS/J/YQ+7BR84xT0xVAXmywloH79COn0YacGebFJO9KOGRJUjQAlK0pkXXd6siQ4gr6LrdMfvcfQIOdKvGtB2Gt3LoEd5xidb6X/eDijzSl0jJXRcitiDjEbATKYuDp2U/0Ek+EVuyeqvP6agc0rZeXFHrmhiTtUpN3wQGpGVygfylerm6hY/CeT2OxGEnHlQOB6rfejjt5SDIcVsT62fncc0nQEYvoUgcfucZYrCa4OmNXSapMoSifoIcVxEOu8GdArMJSOdfHt+DLJgv1k+kdUsXsDHm3o1hOuEmpJieJqlXkA4+ocfoiSbr4SJzihVk0qktS7Cy1mKUBD6rDfVYnyMOqCINbsS1FVWy4KQmuR6v7MhbIcYWzt81RKcRW0BuRL9JoOyHKrNODH13g5Kv6nuOrfI9fUh6BA0MQBqWxXJMJXgAEQweF1wnmbzKJmGylnLK/2WZH4Z408PMPFdOJX5bL03aZqsmr22ka1dAI9ymd2/qiK32+zzSFHjcDgOpX+g4uylELOGcoZoRElG6Vbxkc+d3SEbq+e8kaaiYsezaSwV3CIUZmwu7sVcLFdo+ePjcRfdZHOJ8evaFqN9tTGYEMjyI1IVL2xteXBrWti/Nh3ewpXE16JkxV5aDEDd9XyLJ5BEFpp8ooJZR8WzuONSKM7G1tWBlmZw49uT4QPSOUZvnOV9FQO76vQuQyvkxdU+nlTwxAQG75Oz5U+AMoB4cx9ILbBaL5MfV3YRBN0+SOhVNJYuaGI2V7aR9vluOTeGYbHQ50BJdPPIBGpLhqqrYdDHsOG3prl0XbrZjB8dsqjYSk3bYlEwFWFDAIfeXkYbpsZtqQCrw8qi1Rr245/CvM+SO961BgpnfygaqgCKFBtIAaRkP6GLAuDLNvUkUsCwWR2tXfdHJtAFmZuPqzeMFadGZ+6asrbK2mmXa/GO+QOZTIa/VeDncFXlwtAtMrfmtB67aWgqtXOhffLDYPh9WeYnGx376ZcgEEQ6I4QnTI3BcnNS/84qWZB9HQrw25c3AsmAZN4=</DEVCERT><MACHINECERTIFICATE>A Bunch Of Junk</MACHINECERTIFICATE></CLIENTINFO>";
            private const string ClientInfoTamperedDevCert =         "<CLIENTINFO><CLIENTID>AgAAAPiqsL8f!76t6sjrZjnhKc2gzpxSdxXFerkjLITea76j0i0M9DE3SCVe!EGYFlss5zJrvmNeh1x*afnOY3L2GxY0eYpAAHE1NuMeoIJ1iWxnlJlkEzKyEz!0djMKmtMHANTrLE2L7ADYzg2Ej0ulrbVR4zsAFbzH0CAMcGJbMo10gCaqwaPXoqBKdA1nKSV9UIg2VagA8YAEsKg94aF!ciQy!4S5</CLIENTID><CLIENTVERSION>9.00.00.2778</CLIENTVERSION><SECURITYVERSION>2.4.105.189</SECURITYVERSION><APPSECURITY>2000</APPSECURITY><SUBJECTID1>1313</SUBJECTID1><SUBJECTID2></SUBJECTID2><DRMKVERSION></DRMKVERSION><DEVCERT>FY6J1+KSUbabQ0AV7pPyM/S6aYUNuRM739Mcg5sp+bgdGXu8sOnnSc+TluSjB6saCSEhSyJk33jLKnAWdVrdCumX/YlZNmAfKxMRkNqoR2iBiARbXcIhQF/XuiyI91rDLQVG/s1+u2IynSvMz53LRbV76HEaJlGc6AL6aes8oeiNa6YfI2NYp0Vd52LaGdavhM6ZJfmOeZf/CtCCkcfjfmjBjy7HtslzrKJZqUYAsiQQKafEuPTegGCnAno5ywhWRLX81au7fg2svpWWwfOwNtxeocTphmd5hH3eQB+MNw+wfb4uV1QGf4gvkTDAUs8/E9jIcf9oPT3yqUv4MiEcv1WAx4Ys50JO9iPu02Sd3X9bKzvli6SLC0di7H2zx63TjK2RUVs8JFJDqq2SMydfDE4llH0py2Rv8nMwo2QlkkrhmzaZDse2aRhVGV7wymfoZDSvSsLUs69P2g1Y6Ay1KqWSg+mpi7+mZO+JVvQeFwKIPP3DHW+415OmQzOof4o2ElGBGNjVj5Z+QpjmlzROthl4uxp8p7gvGvaYlvM5U2qi7eThBgRvWTkX14uxW05R737JuCfXl4bPQfeNN9ZgdqN5eFKxgROIdQ4BZ89qQG1oak6aMEcgDKSit3oO217/RPQ/6SxkuQcl4EXAqjhzcdvcsrfoTS9GXpxOP9zUj3GeEqjh43dODSwlNNnG4vokXjEPfxlwKLl7nUEXpWpzVRw8gNIydM8rB+hbUsQ3LCETpfFgdRvZFdCQ5pLVm3fr4OqkCG6nJlX71IfzclaW4V+07+KBN/Smag1BstkETJQKpzpJ7OZFVfVBwUxvLiN8KHMTe2/nAW7bAGMjC/Ls4BTnUICgm7cEPOjDIvRzrzAoz3kHvGr1HFw+kdExuEJLzmEVWp61f6QlREFFdo1ucTLss5mgvG78YuaM7E6irjikClc8NeZsYWrkpqqz9wccq6bYq5cWm86FlBOzLHUOBfov5IOK0VCyFpRQ0neYtr4noCjMvrH7H/OT33lHcfMRc+ZX9lSMa2gbTYJLuUS19BXf1Q7ybUH6CBLkeuVwSs6zrXDZs+sfzlmf+NMLIafB+93sQUO22wLs7OfxImrivRXhOQmD/yiBLVOvDtlHcv9F8sTPO1uFl1ZaCeZ4uHqUZsTeCLcrY8l21At0s7QA2An/8gDMwNVBqH6VsaMSMcf1YzTiGRBRBGkWEbsGwl+KPzn6Q6PXPT/VUPMgLoZjtY/kEHHF3QPYridz648qE6nSCSgouaF5YzgElq6TRmH81qtU6VkJiE6PPRZBEzmmasdYlmJ/DDQCIOJk+6sXaZODwv53wrS69fxxBXX7gjCqGWnrOXxUZQearKBJzGAzrUg/0ZzfEB6j7+zfKp0orPVEA9yPSl7flGratHGBUYYmGZ3TSTIMwXOALS+rYOvw61rrpuJLBaqvo5BbGmADkI9CfBLC08amCG80QmPFIcCM3Hxx/ru+hD9KxwVHfwUusrYJofjISma6sHH3JPMvY5MZGXII1yJdXJrDfKoOjhy9M6kbm13zqW/YvkwLcSis5hMWfs1UZcsMK61U/yohbNIAJvrFTJi1Mn5mPEah7gx/aSJGGqDOR76RA+y37Vmg6CsGncw6M7bbaNluy9ULA/MZyVBL2PEAWARk4i7dB7Sl1XJd3FWpfyR3H/T8KHxJGs0/Q/44bu6DTdKWa/eV/VsqN3lifCIPn3VNVNGMfu3yZk+Qd2egKcZRxiGKshIVPAMbXcXCt/U1LD8Yx/2IDZ5ZsHu5xaDuxX9F+o+41NoswrxFqY/JKjTc1t43GISmE0ANphFSUu6+OSAq6pqwmSZCGD7wm45UKo9ZkerbpmBy5kGuhcAjSSpFJT+XBqWlnOcagO3iR5vg3SYE7VlIfDT2WyA1ARHOT7b8RLH6pmR0tswaWNq1RZFob6+zTl1b+rtmPvkhenaiM5NU8DbXO9h8bBwkhH3WLQTJYUup+fDcPQBXw+UuuWjpvHa55vtTcBgZLIPdoP71lTDmZbTZeQdr7iaIyTjiFY+hApWngqElJxO+fVMyBl23mrHzmzKkO0gsxH2OuAQIDm81eEyJLJx4WDVpS261DobxJpjcnFhq5BVtKO2LbxtnceGI3nuUyhbI0Dqy7PwlyTFKzWaSrdpqzSjRryTcMdAoFUsM95MvgziL+GAloG575Eiwt3VYhkya8G9PCIdXACi+JtUD1c2rrJUnzWXug0AhFonhMeqs67E0hXPmpGEAfhYzNWvX7Am9E6ba6HQmED071EIhk9a/ZDZbfDEQ6YvurGPE3vgPOdgpHk2+wkxrHmAIJD0BApkNoTpr8U/W3ugRTLYxkaRzOtJQYgTeZ/vNoXMtAA4AFHd7+m4HevG0Y0e8ePxj+AyRGjv2Hzc3vxzCBfLUPr/hWcPeciW4pHOpuS4yE8jJwMCnOM/HQKt/krxlv8j97FEjrh62c0/CkQ1lohUhoMj5oI5ctvFOxR3eO0dU0UBhdNpYyuA4eHQVNZnxKFVm9iH5KV/X2m33Hp8TS7f0P7dPR0oh1tV5bQCe/fODsoiuWptq/K5UMPUYfCSd26IzDfSUE/J/45eUnFkQ6pJeAPi5Xgb+pY8GWytiVbEngrX7htVmxUNSd/Y7Q5MvqqftIDJjDliYgzMrCWEwHHb3Xd83QEY+osvUZbusIvndnL7pGocSrtUwK/wnrWO7mDFF8Mb55oioBjlpq25cVb4hwbCJUXn3hDfJXaZrYHr3+ZnbnRIY99P62CojNFxBPkXlnFmlokbDXVqjMKVfwWAA4JAwaPBCgUEmi0XAi093NPQe8KG8oEErE3tlREFM9xpT5rb5ei0/+Ld+YJdNQN9MBjgLtQnixrw5wbsP3XGYx1ufqjb8T76T/HIbm5ODhcvXnulb6sEPu6TgHyFD/PDujxrSWgOwfidRhUS5eTXAn9cZj3uf+5HDQZPcZLy6Goo88uCcOYmIwN/6jzja0P6lwWYhUuGzs48flRrYynLSDbkLYDFqVTD+7G49d7GUkdlNv8wKgh0Awr7+lJe8PdBfAw7INfkVWXEkXcLLQS7pen9pTDvxXBE4nvym693CpB0JOio5bBgt2AfVcQUSxnZ01oDYd9aaDLUDH4nqJy9pvoNTjd+YQ40+Z0KLAl4TaFLByKWEnVGntZs219AOxuM42SDoXHVok3+u7mquKb4iq7ru3G/kgasOtCTcmJSvSC8+l27c3LJtEcaDA886dubLIoFBeIkg7O11+s1wsN86vf5wiMLMvD0D9n7E1J/Aw2gDz3nwJo0oklJJ6GHE3HVppVAfCD7s/CjYZI2BL+qR3oXsHZUf3RWLMhukQC/5KEGKOjzfGiZQneHCyh5tJpovJ6E4RHITj4q/0qyZfIzKhXzUNJjWODyGGv+NvCNj7+Q4RMiu0pmeu8PdMiOOKG0ygt12lZfJCSsRfx2Kavq60FpiJxw9/HagMAASK2CcsI50t1my9rDgXIEBycb9q17vBK1jLGgDA9CMtNFMPQ2LPf/Jnkhc5llZrAyB08qvCQfDdv4Az1y4/L6QkUeac/aGcZi4Lsqg6Dvp8gGWWjBrwxIMCOcsJD9FlwkO4GnOghP9dAcA6HnJdsKN6jQX96UiaqQzgvmXDT2Z6ZX9t/Ntkhb/VzWVGcLBIfH+8zpOKx+cP0bDsGmpFK/gK+hScoBHBYNxifND8vQ+1rsKHgFFA45/Ge1O8Jw8IYeP5h3gR4m3khR+VRcH7KeUD61BkKBidjMtlNuU/gbW1tdH3+l79hq4MAbWtcSMR/mScMG5ris2ERg8tNx1r2z6ufvzibeSpN6Nsi9bofVsKMYt4ZqzLvuYs4WoQjE6K4+iC44drhHO+HCThxTSe9NQE2odE3TYXzJ+jGxRDKpWZqvBvajXbegi1oD+ANw80ZX1PGc5aYl5uFx+g1KDsU0WysTQ6/oRB5BDMG7KEbZnBFgI6bqhJb9zhlDhUuzqYI705ttjHw0rwYyzKpKd3R2cchvqmUouKDmLU1z3u6kTv0lqAT3bR22WWk2UQ3ZYxhlQb0WmY8mqncvYDN+qPZS4BUPDf9q+VVCzQ4TNoQFy0vIoWId+qV5L8lmpEhRKwT75EGJQ2UEsCS9LutNmehY7M5eaVM8fsRQpxmaygdNSdMR+nR/FwXB9PUKQUg6TXTpT2z8IKXoeDqiJMx3Bov7WLvb511Ljhl3m+yTv6C3Bma4s4AxNTybdLL+8vYLaI66Y03tbSBtoa8Wh+1vlR09cS3VO7k71Uh/xpcH7Ra9mpSannCvt8KRmh5oRp1PC7TBdDPgMrnwOyZ7MpnAqZq1e1bEDDSTVacT2ecFzHmTEFXPxHy+jE02/jqH/CnTGC81CGFta2FomsXYL3bZND1WXkr3qznLSfUjnWK/Tehi3jbdtGt1faYv+zrlAWDWYwvRaE4QbmxAGM9ifUHpcYT24jvd6qDCdHEX4mz3Va6/aNNXMUTi2S6JXrVRH6LnpR+RSCkRVsZwZ3p6EA2Phw5TXdbMtai8smrwgB5VmPN8WwG2KKxLD39UapUE/gRHalw5JKg9Ep1gKYWpxdlFQQTJ3nWLusKjgB69AGaWCdIuj47cInW0Vv61un6Lw7JkrUfw2muZ3pp09eN9SkZN4/3K9GbN/UeIGyI+JwvqKCJBVgIZJPK+WyUddSvIFO91nN/IxzR2ZPjIblMkuPiA+Q9oYBQDqBKM5mcrU3CW81ThrrR2tAFZvi3BbTUqagP21getVoBr/ReRtrZSdLBLJ7m7gOrHjojWR+ypvEv1aFjNv9NqDVjzDlbTZ7PKl0VizU6YDdaG2VZ65uK6uAM3D4p3/BURAkCE1cxpjwum08gRlTGZDiIm8fRORBS5/GKNKyGnT8l0MgX8rcAx8Gk39vEmdNLsico/lfvzqMyO0oXcBjK3qGiM6/ycwUmeJs88bUUQ2I3qb00A+nAG2+Lf2K8ly57dkpJiUKKzxvSYtgbo6TzWZ95CBjD5Gtl5d+BRtm8ZA1VocFk4HSZniE1LFwoNQU7ecgKQ4YFxuTQ3Bu50L6i7WA+37gDcCS/J/YQ+7BR84xT0xVAXmywloH79COn0YacGebFJO9KOGRJUjQAlK0pkXXd6siQ4gr6LrdMfvcfQIOdKvGtB2Gt3LoEd5xidb6X/eDijzSl0jJXRcitiDjEbATKYuDp2U/0Ek+EVuyeqvP6agc0rZeXFHrmhiTtUpN3wQGpGVygfylerm6hY/CeT2OxGEnHlQOB6rfejjt5SDIcVsT62fncc0nQEYvoUgcfucZYrCa4OmNXSapMoSifoIcVxEOu8GdArMJSOdfHt+DLJgv1k+kdUsXsDHm3o1hOuEmpJieJqlXkA4+ocfoiSbr4SJzihVk0qktS7Cy1mKUBD6rDfVYnyMOqCINbsS1FVWy4KQmuR6v7MhbIcYWzt81RKcRW0BuRL9JoOyHKrNODH13g5Kv6nuOrfI9fUh6BA0MQBqWxXJMJXgAEQweF1wnmbzKJmGylnLK/2WZH4Z408PMPFdOJX5bL03aZqsmr22ka1dAI9ymd2/qiK32+zzSFHjcDgOpX+g4uylELOGcoZoRElG6Vbxkc+d3SEbq+e8kaaiYsezaSwV3CIUZmwu7sVcLFdo+ePjcRfdZHOJ8evaFqN9tTGYEMjyI1IVL2xteXBrWti/Nh3ewpXE16JkxV5aDEDd9XyLJ5BEFpp8ooJZR8WzuONSKM7G1tWBlmZw49uT4QPSOUZvnOV9FQO76vQuQyvkxdU+nlTwxAQG75Oz5U+AMoB4cx9ILbBaL5MfV3YRBN0+SOhVNJYuaGI2V7aR9vluOTeGYbHQ50BJdPPIBGpLhqqrYdDHsOG3prl0XbrZjB8dsqjYSk3bYlEwFWFDAIfeXkYbpsZtqQCrw8qi1Rr245/CvM+SO961BgpnfygaqgCKFBtIAaRkP6GLAuDLNvUkUsCwWR2tXfdHJtAFmZuPqzeMFadGZ+6asrbK2mmXa/GO+QOZTIa/VeDncFXlwtAtMrfmtB67aWgqtXOhffLDYPh9WeYnGx376ZcgEEQ6I4QnTI3BcnNS/84qWZB9HQrw25c3AsmAZN4=</DEVCERT></CLIENTINFO>";
            private const string ClientInfoExploitedDorado =         "<CLIENTINFO><CLIENTID>AgAAAC6iqwsMJCJBvLWOdn8glDlvlxSG9AOtBLh*btQFl7BRYJdpPO1RLoGJHAtZYUh9y0fN2gGStexD*h1ENL1zigbW1huBHS!1jbw03reZ!ANzTHu8JVU4q3qVCttvbqupMDgGv7n39Odz9OKG*M3podcvPVl8dm!za5abT!d7IKkM2OIydUBzeIEScSCep1O6fyt3wTTPgJYzRX9jNI4gESyYCLcb</CLIENTID><REVINFO></REVINFO><CLIENTVERSION>11.0.5705.5043</CLIENTVERSION><SECURITYVERSION>2.8.0.1</SECURITYVERSION><APPSECURITY>50</APPSECURITY><SUBJECTID1>221</SUBJECTID1><SUBJECTID2></SUBJECTID2><DRMKVERSION>2.2.0.0</DRMKVERSION></CLIENTINFO>";
            private const string ClientInfoWithTamperedMachineCert = "<CLIENTINFO><CLIENTID>AgAAABHqCIuPyiBM4aY5CV9UM9c08!5t9i8vXhvcPyIkuwGRiiW1o3Al2Qf7mABwQru!wQzbMBtiT8pIdnMPPit9zW5ExG33kqqvyIngw5rRsWYjeTQJrMW*QeLg4SGAsZYAAvPPpkdkXD!bsIdxRS9NSHPn8zhCrsZW7Go!typ*VNp1ZnVPrd9nmfgwZE!e7h1oVJaLpCadThlbCa!1H9Y2t2XcdLNJ</CLIENTID><MACHINECERTIFICATE>PGM6Q2VydGlmaWNhdGVDb2xsZWN0aW9uIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIiB4bWxuczpjPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIGM6VmVyc2lvbj0iMi4wIj48YzpDZXJ0aWZpY2F0ZSBjOlZlcnNpb249IjIuMCIgeG1sbnM6Yz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9jZXJ0Ij48YzpEYXRhIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIiB4bWxuczpjPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIHhtbG5zOm09Imh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9tc2xwIj48YzpTZWN1cml0eVZlcnNpb24!My45LjAuMTwvYzpTZWN1cml0eVZlcnNpb24!PGM6UHVibGljS2V5PjxLZXlWYWx1ZT48UlNBS2V5VmFsdWU!PE1vZHVsdXM!cU8xYjdtamlZdDBuSTFScHg0RVJ5aWtUbzdXOS9NK1FKV1hqTGh5K1c1N0orZWl3NDhPOTRMUkZLK1VFZGdYV2lpSmxOeDZNWmpHREZ6SVZ0RkwxOTlTUWQ0L09ZNEFFZlRzYjFzbzNnbmZObVR5ZjhLNXhxbm9PeTZaRm5zcVFZQThNb1VDK3FxZkI0TXhNWVhMSnFhZGRLd3FNUzlzZk9nTUdua0Y3dWkwPTwvTW9kdWx1cz48RXhwb25lbnQ!QVFBQjwvRXhwb25lbnQ!PC9SU0FLZXlWYWx1ZT48L0tleVZhbHVlPjwvYzpQdWJsaWNLZXk!PGM6UEtDZXJ0PitJaEMydFlaRmZXcXI0ZDlXalpxS2ZtWXJnT1hFSW03azJFaTQvdDllUEEvM3ptUXRwUk5NQUlKQUFGcmM3OFRGWkFCUVRVV3hGdlFlSVZTUHJrUk1LR0xLTW1DUFQ4SCtKSTh0Znc4TjlvL2VveDY8L2M6UEtDZXJ0PjxjOlBLU2lnbmluZ0NlcnQ!TDFxb2g1bllyYXFTSi9zQ1FvNE9xNURORGlTQ1NTaWJPdnpmY21QZUhNUUcreE5OaXZYWUxBSUpBQUhYR2VrS01nRTJ3UXJtYzNvZ05KTGh2NUFVQ3VwSTVxSHdBRGNoYVdxN1JXblkrWHFYYTUwRDwvYzpQS1NpZ25pbmdDZXJ0PjxjOkhhcmR3YXJlSUQ!MjBFSEd0RG9RcEppa0tMTzhTTFY3ZWwyd0hnPTwvYzpIYXJkd2FyZUlEPjxjOlNlY3VyaXR5TGV2ZWw!MjAwMDwvYzpTZWN1cml0eUxldmVsPjxjOktleVVzYWdlPjxjOkVuY3J5cHRLZXk!MTwvYzpFbmNyeXB0S2V5PjwvYzpLZXlVc2FnZT48YzpGZWF0dXJlcz48YzpXTURSTVRyYW5zbWl0dGVyPjE8L2M6V01EUk1UcmFuc21pdHRlcj48YzpXTURSTVJlY2VpdmVyPjE8L2M6V01EUk1SZWNlaXZlcj48YzpXTURSTVNoYXJlZENlcnRpZmljYXRlPjE8L2M6V01EUk1TaGFyZWRDZXJ0aWZpY2F0ZT48L2M6RmVhdHVyZXM!PGM6TWFudWZhY3R1cmVyRGF0YT48YzpNYW51ZmFjdHVyZXJOYW1lPlVua25vd248L2M6TWFudWZhY3R1cmVyTmFtZT48YzpNb2RlbE5hbWU!VW5rbm93bjwvYzpNb2RlbE5hbWU!PGM6TW9kZWxOdW1iZXI!VW5rbm93bjwvYzpNb2RlbE51bWJlcj48L2M6TWFudWZhY3R1cmVyRGF0YT48L2M6RGF0YT48U2lnbmF0dXJlIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj48U2lnbmVkSW5mbz48Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLXhtbC1jMTRuLTIwMDEwMzE1Ij48L0Nhbm9uaWNhbGl6YXRpb25NZXRob2Q!PFNpZ25hdHVyZU1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vRFJNLzIwMDQvMDIvQ0VSVC9Sc2Etc2hhMSI!PC9TaWduYXR1cmVNZXRob2Q!PFJlZmVyZW5jZT48VHJhbnNmb3Jtcz48VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9DRVJUL0RhdGEiPjwvVHJhbnNmb3JtPjxUcmFuc2Zvcm0gQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy14bWwtYzE0bi0yMDAxMDMxNSI!PC9UcmFuc2Zvcm0!PC9UcmFuc2Zvcm1zPjxEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjc2hhMSI!PC9EaWdlc3RNZXRob2Q!PERpZ2VzdFZhbHVlPkJETWo1bTdYK294MVFZTGdMR2NPekE4YjF1bz08L0RpZ2VzdFZhbHVlPjwvUmVmZXJlbmNlPjwvU2lnbmVkSW5mbz48U2lnbmF0dXJlVmFsdWU!VHU4eUNhTnkwSThSYnFUWkdoNWVyMXd4ZnhMWklhSHFqbE5Jb1VBdUZzenhvNTRoMWUxTFQ1TDRlbnk0N0ZRWGIrbUMwVWFnZHdFcGhyY3JTVUZkM2o0ZHBWVC9kMlBTOGJTdVgyUGl1V1AzblF6L1JtMkthMXNhaTRUZ2ZUdmdXQzJkUW9Xdm5YTTRKRHUvbWJFOGo4Q21zT2FMOWg3bWtCazBUaFR0akd3PTwvU2lnbmF0dXJlVmFsdWU!PEtleUluZm8!PEtleVZhbHVlPjxSU0FLZXlWYWx1ZT48TW9kdWx1cz50M2o1cGFFa0JLL1pFWW1IZis1SEVUVWkzSmFaZ2xreDNPbU1oOThWQllOeW9sR1EwTUpFMFgwS3dYdnVWMGRxR2JGK2ZlcEJON0c1RC9uOTE4RDdiUy9ROTZyNGYzOXFrSkRlUk1hbTg1K3p5aUhOQWpBbUdvWG44bWliUTlkZk9CZXdUUlluVVJBVEVlTHRMR01TaGJnSytESHN6WDJyUzdrUU4xYUVUOWM9PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48L1JTQUtleVZhbHVlPjwvS2V5VmFsdWU!PC9LZXlJbmZvPjwvU2lnbmF0dXJlPjwvYzpDZXJ0aWZpY2F0ZT48YzpDZXJ0aWZpY2F0ZSBjOlZlcnNpb249IjIuMCIgeG1sbnM6Yz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9jZXJ0Ij48YzpEYXRhIHhtbG5zPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIHhtbG5zOm09Imh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8xMS9tc2xwIj48YzpTZWN1cml0eVZlcnNpb24!My45LjAuMTwvYzpTZWN1cml0eVZlcnNpb24!PGM6UHVibGljS2V5PjxLZXlWYWx1ZT48UlNBS2V5VmFsdWU!PE1vZHVsdXM!dDNqNXBhRWtCSy9aRVltSGYrNUhFVFVpM0phWmdsa3gzT21NaDk4VkJZTnlvbEdRME1KRTBYMEt3WHZ1VjBkcUdiRitmZXBCTjdHNUQvbjkxOEQ3YlMvUTk2cjRmMzlxa0pEZVJNYW04NSt6eWlITkFqQW1Hb1huOG1pYlE5ZGZPQmV3VFJZblVSQVRFZUx0TEdNU2hiZ0srREhzelgyclM3a1FOMWFFVDljPTwvTW9kdWx1cz48RXhwb25lbnQ!QVFBQjwvRXhwb25lbnQ!PC9SU0FLZXlWYWx1ZT48L0tleVZhbHVlPjwvYzpQdWJsaWNLZXk!PFZhbGlkYXRpb25NZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL2RybS8yMDA0LzAyL2NlcnQvdmFsaWRhdGVfdjIiIFZlcnNpb249IjIuMCI!PC9WYWxpZGF0aW9uTWV0aG9kPjxjOlNlY3VyaXR5TGV2ZWw!MjAwMDwvYzpTZWN1cml0eUxldmVsPjxjOktleVVzYWdlPjxjOlNpZ25DZXJ0aWZpY2F0ZT4xPC9jOlNpZ25DZXJ0aWZpY2F0ZT48L2M6S2V5VXNhZ2U!PGM6RmVhdHVyZXM!PG06V01EUk1UcmFuc21pdHRlcj4xPC9tOldNRFJNVHJhbnNtaXR0ZXI!PC9jOkZlYXR1cmVzPjxjOk1hbnVmYWN0dXJlckRhdGE!PGM6TWFudWZhY3R1cmVyTmFtZT5NaWNyb3NvZnQ8L2M6TWFudWZhY3R1cmVyTmFtZT48L2M6TWFudWZhY3R1cmVyRGF0YT48L2M6RGF0YT48U2lnbmF0dXJlIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj48U2lnbmVkSW5mbz48Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLXhtbC1jMTRuLTIwMDEwMzE1Ij48L0Nhbm9uaWNhbGl6YXRpb25NZXRob2Q!PFNpZ25hdHVyZU1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vRFJNLzIwMDQvMDIvQ0VSVC9Sc2Etc2hhMSI!PC9TaWduYXR1cmVNZXRob2Q!PFJlZmVyZW5jZT48VHJhbnNmb3Jtcz48VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9DRVJUL0RhdGEiPjwvVHJhbnNmb3JtPjxUcmFuc2Zvcm0gQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy14bWwtYzE0bi0yMDAxMDMxNSI!PC9UcmFuc2Zvcm0!PC9UcmFuc2Zvcm1zPjxEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjc2hhMSI!PC9EaWdlc3RNZXRob2Q!PERpZ2VzdFZhbHVlPjJjRmtmYkNYQ21GSS9jSXF0SGpEenF2UTZpRT08L0RpZ2VzdFZhbHVlPjwvUmVmZXJlbmNlPjwvU2lnbmVkSW5mbz48U2lnbmF0dXJlVmFsdWU!TzRWWUVHWjBMdElzQ01LcUYyd2ROMG9TMmdIS2g2cUV4cEN2ZWp3TWphTndVc1dHRVAwbVZocWp0eVprOWp1ZHRodFBqdERHUERnMERMNWcxOHNtMWgvUHJlcHF1SFVia0NPejU5YUhIRGZqRXMyYVFZbW5hbnRmeFFEWWQxQnJBc25Sa3Flbk1RWWFPS1J3dWlycitXMWxNblVUZXYvUzN5aGtNYXBuZkYwPTwvU2lnbmF0dXJlVmFsdWU!PEtleUluZm8!PEtleVZhbHVlPjxSU0FLZXlWYWx1ZT48TW9kdWx1cz53VFI2T0F0ajNydjZxNHprTWc2ak5DSkloaEVFblBwMDNocnlnNkprSWRhanI4RE5ra3RSWlAxNlRzOXpaWE10UHRJSjF5aGtGT3RkclFTZ1FOamlGdm9WZk5BclNxcHpzN2RZelozNUM1WEU0K0Jid2dzOWNwVTc0UEFERk84MTZtWEpZTGx4N3lEcWdPZXVleTE3UGhVTkhteXFOcE9pSGI4bTljcjZPZXM9PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48L1JTQUtleVZhbHVlPjwvS2V5VmFsdWU!PC9LZXlJbmZvPjwvU2lnbmF0dXJlPjwvYzpDZXJ0aWZpY2F0ZT48YzpDZXJ0aWZpY2F0ZSBjOlZlcnNpb249IjIuMCIgeG1sbnM6Yz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9jZXJ0Ij48YzpEYXRhIHhtbG5zPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIHhtbG5zOm09Imh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8xMS9tc2xwIj48YzpTZWN1cml0eVZlcnNpb24!My45LjAuMTwvYzpTZWN1cml0eVZlcnNpb24!PGM6UHVibGljS2V5PjxLZXlWYWx1ZT48UlNBS2V5VmFsdWU!PE1vZHVsdXM!d1RSNk9BdGozcnY2cTR6a01nNmpOQ0pJaGhFRW5QcDAzaHJ5ZzZKa0lkYWpyOEROa2t0UlpQMTZUczl6WlhNdFB0SUoxeWhrRk90ZHJRU2dRTmppRnZvVmZOQXJTcXB6czdkWXpaMzVDNVhFNCtCYndnczljcFU3NFBBREZPODE2bVhKWUxseDd5RHFnT2V1ZXkxN1BoVU5IbXlxTnBPaUhiOG05Y3I2T2VzPTwvTW9kdWx1cz48RXhwb25lbnQ!QVFBQjwvRXhwb25lbnQ!PC9SU0FLZXlWYWx1ZT48L0tleVZhbHVlPjwvYzpQdWJsaWNLZXk!PFZhbGlkYXRpb25NZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL2RybS8yMDA0LzAyL2NlcnQvdmFsaWRhdGVfdjIiIFZlcnNpb249IjIuMCI!PC9WYWxpZGF0aW9uTWV0aG9kPjxjOlNlY3VyaXR5TGV2ZWw!MjAwMDwvYzpTZWN1cml0eUxldmVsPjxjOktleVVzYWdlPjxjOlNpZ25DZXJ0aWZpY2F0ZT4xPC9jOlNpZ25DZXJ0aWZpY2F0ZT48L2M6S2V5VXNhZ2U!PGM6RmVhdHVyZXM!PG06V01EUk1UcmFuc21pdHRlcj4xPC9tOldNRFJNVHJhbnNtaXR0ZXI!PC9jOkZlYXR1cmVzPjxjOk1hbnVmYWN0dXJlckRhdGE!PGM6TWFudWZhY3R1cmVyTmFtZT5NaWNyb3NvZnQ8L2M6TWFudWZhY3R1cmVyTmFtZT48L2M6TWFudWZhY3R1cmVyRGF0YT48L2M6RGF0YT48U2lnbmF0dXJlIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj48U2lnbmVkSW5mbz48Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLXhtbC1jMTRuLTIwMDEwMzE1Ij48L0Nhbm9uaWNhbGl6YXRpb25NZXRob2Q!PFNpZ25hdHVyZU1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vRFJNLzIwMDQvMDIvQ0VSVC9Sc2Etc2hhMSI!PC9TaWduYXR1cmVNZXRob2Q!PFJlZmVyZW5jZT48VHJhbnNmb3Jtcz48VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9DRVJUL0RhdGEiPjwvVHJhbnNmb3JtPjxUcmFuc2Zvcm0gQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy14bWwtYzE0bi0yMDAxMDMxNSI!PC9UcmFuc2Zvcm0!PC9UcmFuc2Zvcm1zPjxEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjc2hhMSI!PC9EaWdlc3RNZXRob2Q!PERpZ2VzdFZhbHVlPlFFWmltSGQ2ZmZvUENDaFhYVXBRNFZMNzMxRT08L0RpZ2VzdFZhbHVlPjwvUmVmZXJlbmNlPjwvU2lnbmVkSW5mbz48U2lnbmF0dXJlVmFsdWU!Q3Z4MlFraEMvVEk0UHhpM1NqYkprb0JxNlcvV2JxMXhWU21HN1VsR0lRR1Qwd0lqWTgvT2RkK2tOZkpCajVIQjRQb09TSWFRNTlFNEVXaGwrVkdyejJWVXBPVjZXUnp0MlBwVmRqODltM2pHdjN6S3psZFhsTXV1ejJRT0lieG1tUUF6WnI5aHo4Z1NFeHJqcktBekt2R0VQWUFHcDhCbUVybUI2ZzdZWXQ4PTwvU2lnbmF0dXJlVmFsdWU!PEtleUluZm8!PEtleVZhbHVlPjxSU0FLZXlWYWx1ZT48TW9kdWx1cz5wam9lV0xTVExEb25RRzhTaGU2UWhrWWJZb3R0OWZQWjh0SGRCMTI4WkVUY2dobjVLSG95aW43SGtKRWNQSjBFZzRVZFN2YTBLRElZRGpBM0VYZDY5UjNDTjJXcC9ReU9vMFpQWVdZcDNOWHBKNzAwdEtQZ0lwbHpvNXdWZC82OWc3aitqOE02Nlc3Vk5tRHdhTnM5bURjMXAyK1ZWTXNEaE9zVi9BdTZFK0U9PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48L1JTQUtleVZhbHVlPjwvS2V5VmFsdWU!PC9LZXlJbmZvPjwvU2lnbmF0dXJlPjwvYzpDZXJ0aWZpY2F0ZT48L2M6Q2VydGlmaWNhdGVDb2xsZWN0aW9uPg==</MACHINECERTIFICATE><REVINFO></REVINFO><CLIENTVERSION>11.0.7600.16385</CLIENTVERSION><SECURITYVERSION>2.9.0.1</SECURITYVERSION><APPSECURITY>50</APPSECURITY><SUBJECTID1>221</SUBJECTID1><SUBJECTID2></SUBJECTID2></CLIENTINFO>";
            private const string ClientInfoWithEmptyMachineCert =    "<CLIENTINFO><CLIENTID>AgAAAP2*fQksLfgZShUxVCdp6XhpHqoEU2kb4Jg10Nojht3U4OJn0cliT2CYi7aq52pdfkAPuXe4MrQEzwcif6OGPC1RFT9ss!o99UU3HAlPCGMZTnpjk9rfw4EMI8ClskGu!yq4xFAB7kwp2K6cgj!t6nxZ8up6BDHGY3Tcv*AyfxcMme4cm5e7PncYOWNZNOA**RFZeAVJvfuA3XwnCASPZKQCvEvC</CLIENTID><MACHINECERTIFICATE></MACHINECERTIFICATE><REVINFO></REVINFO><CLIENTVERSION>11.0.7600.16385</CLIENTVERSION><SECURITYVERSION>2.9.0.1</SECURITYVERSION><APPSECURITY>50</APPSECURITY><SUBJECTID1>221</SUBJECTID1><SUBJECTID2></SUBJECTID2></CLIENTINFO>";
            private const string ClientInfoWithBadBase64 =           "<CLIENTINFO><CLIENTID>AgAAAP2*fQksLfgZShUxVCdp6XhpHqoEU2kb4Jg10Nojht3U4OJn0cliT2CYi7aq52pdfkAPuXe4MrQEzwcif6OGPC1RFT9ss!o99UU3HAlPCGMZTnpjk9rfw4EMI8ClskGu!yq4xFAB7kwp2K6cgj!t6nxZ8up6BDHGY3Tcv*AyfxcMme4cm5e7PncYOWNZNOA**RFZeAVJvfuA3XwnCASPZKQCvEvC</CLIENTID><MACHINECERTIFICATE>PGMQ2VydGlmaWNhdGVDb2xsZWN0aW9uIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIiB4bWxuczpjPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIGM6VmVyc2lvbj0iMi4wIj48YzpDZXJ0aWZpY2F0ZSBjOlZlcnNpb249IjIuMCIgeG1sbnM6Yz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9jZXJ0Ij48YzpEYXRhIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIiB4bWxuczpjPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIHhtbG5zOm09Imh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9tc2xwIj48YzpTZWN1cml0eVZlcnNpb24!My44LjAuMTwvYzpTZWN1cml0eVZlcnNpb24!PGM6UHVibGljS2V5PjxLZXlWYWx1ZT48UlNBS2V5VmFsdWU!PE1vZHVsdXM!eUVmT0o0VEpvZVoxdjNzTFV6clk0U0Q1YTVQTTBHM0ROdTN2cjRrNDNVcWpTWkJsNzMrRUwydHVURDN4bHozRFFyUDNWVk00TVB4RmY5cHQvTDduMXRhOGRVM2FrSU9Sb1E2SHdaZnIvL2Y2VG9Nb016UXJ0d0dvdTloeisyQnRveW5lV2lCbThwYnVqaW1oamtrM2JGVTJsOUpCRG5pSDhwOFRLZnFLR0dNPTwvTW9kdWx1cz48RXhwb25lbnQ!QVFBQjwvRXhwb25lbnQ!PC9SU0FLZXlWYWx1ZT48L0tleVZhbHVlPjwvYzpQdWJsaWNLZXk!PGM6UEtDZXJ0PnphUEZRazM5SnpHcm1VTVpYczJjeE5jVGNHeXJ2WXpJTGEvaDhSOEczbjBiSERUT2RrUFFaUUlKQUFHMnJVcHRkK0ViQUVOOGNNRytGVjkvTWxYdEtjT3M1dFcwV0xmd0xhMDYxM1h4Vlc3QnU1NVc8L2M6UEtDZXJ0PjxjOlBLU2lnbmluZ0NlcnQ!RVN3MisvNUVINE9MUkhDRjZtRytkUnNhRGtzNVEwTGVKWS9IQjFkajBvZStEYjBlMUR2blVBSUpBQUdGLzlUV2VNQThqSG5WOTd4N1Zucjh2bStzU2ZMYlljQlk4dGFkMmhvUGljV3dHdE9uakt0ZDwvYzpQS1NpZ25pbmdDZXJ0PjxjOkhhcmR3YXJlSUQ!d0hmWG03QmcyU1liKzIxQlZzaG0vOEg1c2pJPTwvYzpIYXJkd2FyZUlEPjxjOlNlY3VyaXR5TGV2ZWw!MjAwMDwvYzpTZWN1cml0eUxldmVsPjxjOktleVVzYWdlPjxjOkVuY3J5cHRLZXk!MTwvYzpFbmNyeXB0S2V5PjwvYzpLZXlVc2FnZT48YzpGZWF0dXJlcz48YzpXTURSTVRyYW5zbWl0dGVyPjE8L2M6V01EUk1UcmFuc21pdHRlcj48YzpXTURSTVJlY2VpdmVyPjE8L2M6V01EUk1SZWNlaXZlcj48YzpXTURSTVNoYXJlZENlcnRpZmljYXRlPjE8L2M6V01EUk1TaGFyZWRDZXJ0aWZpY2F0ZT48L2M6RmVhdHVyZXM!PGM6TWFudWZhY3R1cmVyRGF0YT48YzpNYW51ZmFjdHVyZXJOYW1lPlVua25vd248L2M6TWFudWZhY3R1cmVyTmFtZT48YzpNb2RlbE5hbWU!VW5rbm93bjwvYzpNb2RlbE5hbWU!PGM6TW9kZWxOdW1iZXI!VW5rbm93bjwvYzpNb2RlbE51bWJlcj48L2M6TWFudWZhY3R1cmVyRGF0YT48L2M6RGF0YT48U2lnbmF0dXJlIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj48U2lnbmVkSW5mbz48Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLXhtbC1jMTRuLTIwMDEwMzE1Ij48L0Nhbm9uaWNhbGl6YXRpb25NZXRob2Q!PFNpZ25hdHVyZU1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vRFJNLzIwMDQvMDIvQ0VSVC9Sc2Etc2hhMSI!PC9TaWduYXR1cmVNZXRob2Q!PFJlZmVyZW5jZT48VHJhbnNmb3Jtcz48VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9DRVJUL0RhdGEiPjwvVHJhbnNmb3JtPjxUcmFuc2Zvcm0gQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy14bWwtYzE0bi0yMDAxMDMxNSI!PC9UcmFuc2Zvcm0!PC9UcmFuc2Zvcm1zPjxEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjc2hhMSI!PC9EaWdlc3RNZXRob2Q!PERpZ2VzdFZhbHVlPmNHWWJwS0hnNG0zeXZTbmt6d0tnblNHdXV6bz08L0RpZ2VzdFZhbHVlPjwvUmVmZXJlbmNlPjwvU2lnbmVkSW5mbz48U2lnbmF0dXJlVmFsdWU!VklTWWtEV0ZmcGJGeGFlSUhCNFhFWkc5RXI1bThvalVZM3FXM0orUndjbXlBbDIyN2ZCSnNKcW1icGJzSFlMelVNZ1ZoVVNPdEVzVUF5RGN2Y0pzU293bTh6OG95eXViWmJsTjFYMVZRNWdoT0J1MGZlUzE0eWI3RjRMQjZkRmFPYTFhZEVxdnlGMFIvTHh1U3pMcXhENHJvMUNEdkhpcVlOMGVyTDFBSERnPTwvU2lnbmF0dXJlVmFsdWU!PEtleUluZm8!PEtleVZhbHVlPjxSU0FLZXlWYWx1ZT48TW9kdWx1cz50M2o1cGFFa0JLL1pFWW1IZis1SEVUVWkzSmFaZ2xreDNPbU1oOThWQllOeW9sR1EwTUpFMFgwS3dYdnVWMGRxR2JGK2ZlcEJON0c1RC9uOTE4RDdiUy9ROTZyNGYzOXFrSkRlUk1hbTg1K3p5aUhOQWpBbUdvWG44bWliUTlkZk9CZXdUUlluVVJBVEVlTHRMR01TaGJnSytESHN6WDJyUzdrUU4xYUVUOWM9PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48L1JTQUtleVZhbHVlPjwvS2V5VmFsdWU!PC9LZXlJbmZvPjwvU2lnbmF0dXJlPjwvYzpDZXJ0aWZpY2F0ZT48YzpDZXJ0aWZpY2F0ZSBjOlZlcnNpb249IjIuMCIgeG1sbnM6Yz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9jZXJ0Ij48YzpEYXRhIHhtbG5zPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIHhtbG5zOm09Imh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8xMS9tc2xwIj48YzpTZWN1cml0eVZlcnNpb24!My44LjAuMTwvYzpTZWN1cml0eVZlcnNpb24!PGM6UHVibGljS2V5PjxLZXlWYWx1ZT48UlNBS2V5VmFsdWU!PE1vZHVsdXM!dDNqNXBhRWtCSy9aRVltSGYrNUhFVFVpM0phWmdsa3gzT21NaDk4VkJZTnlvbEdRME1KRTBYMEt3WHZ1VjBkcUdiRitmZXBCTjdHNUQvbjkxOEQ3YlMvUTk2cjRmMzlxa0pEZVJNYW04NSt6eWlITkFqQW1Hb1huOG1pYlE5ZGZPQmV3VFJZblVSQVRFZUx0TEdNU2hiZ0srREhzelgyclM3a1FOMWFFVDljPTwvTW9kdWx1cz48RXhwb25lbnQ!QVFBQjwvRXhwb25lbnQ!PC9SU0FLZXlWYWx1ZT48L0tleVZhbHVlPjwvYzpQdWJsaWNLZXk!PFZhbGlkYXRpb25NZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL2RybS8yMDA0LzAyL2NlcnQvdmFsaWRhdGVfdjIiIFZlcnNpb249IjIuMCI!PC9WYWxpZGF0aW9uTWV0aG9kPjxjOlNlY3VyaXR5TGV2ZWw!MjAwMDwvYzpTZWN1cml0eUxldmVsPjxjOktleVVzYWdlPjxjOlNpZ25DZXJ0aWZpY2F0ZT4xPC9jOlNpZ25DZXJ0aWZpY2F0ZT48L2M6S2V5VXNhZ2U!PGM6RmVhdHVyZXM!PG06V01EUk1UcmFuc21pdHRlcj4xPC9tOldNRFJNVHJhbnNtaXR0ZXI!PC9jOkZlYXR1cmVzPjxjOk1hbnVmYWN0dXJlckRhdGE!PGM6TWFudWZhY3R1cmVyTmFtZT5NaWNyb3NvZnQ8L2M6TWFudWZhY3R1cmVyTmFtZT48L2M6TWFudWZhY3R1cmVyRGF0YT48L2M6RGF0YT48U2lnbmF0dXJlIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj48U2lnbmVkSW5mbz48Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLXhtbC1jMTRuLTIwMDEwMzE1Ij48L0Nhbm9uaWNhbGl6YXRpb25NZXRob2Q!PFNpZ25hdHVyZU1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vRFJNLzIwMDQvMDIvQ0VSVC9Sc2Etc2hhMSI!PC9TaWduYXR1cmVNZXRob2Q!PFJlZmVyZW5jZT48VHJhbnNmb3Jtcz48VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9DRVJUL0RhdGEiPjwvVHJhbnNmb3JtPjxUcmFuc2Zvcm0gQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy14bWwtYzE0bi0yMDAxMDMxNSI!PC9UcmFuc2Zvcm0!PC9UcmFuc2Zvcm1zPjxEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjc2hhMSI!PC9EaWdlc3RNZXRob2Q!PERpZ2VzdFZhbHVlPjJjRmtmYkNYQ21GSS9jSXF0SGpEenF2UTZpRT08L0RpZ2VzdFZhbHVlPjwvUmVmZXJlbmNlPjwvU2lnbmVkSW5mbz48U2lnbmF0dXJlVmFsdWU!TzRWWUVHWjBMdElzQ01LcUYyd2ROMG9TMmdIS2g2cUV4cEN2ZWp3TWphTndVc1dHRVAwbVZocWp0eVprOWp1ZHRodFBqdERHUERnMERMNWcxOHNtMWgvUHJlcHF1SFVia0NPejU5YUhIRGZqRXMyYVFZbW5hbnRmeFFEWWQxQnJBc25Sa3Flbk1RWWFPS1J3dWlycitXMWxNblVUZXYvUzN5aGtNYXBuZkYwPTwvU2lnbmF0dXJlVmFsdWU!PEtleUluZm8!PEtleVZhbHVlPjxSU0FLZXlWYWx1ZT48TW9kdWx1cz53VFI2T0F0ajNydjZxNHprTWc2ak5DSkloaEVFblBwMDNocnlnNkprSWRhanI4RE5ra3RSWlAxNlRzOXpaWE10UHRJSjF5aGtGT3RkclFTZ1FOamlGdm9WZk5BclNxcHpzN2RZelozNUM1WEU0K0Jid2dzOWNwVTc0UEFERk84MTZtWEpZTGx4N3lEcWdPZXVleTE3UGhVTkhteXFOcE9pSGI4bTljcjZPZXM9PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48L1JTQUtleVZhbHVlPjwvS2V5VmFsdWU!PC9LZXlJbmZvPjwvU2lnbmF0dXJlPjwvYzpDZXJ0aWZpY2F0ZT48YzpDZXJ0aWZpY2F0ZSBjOlZlcnNpb249IjIuMCIgeG1sbnM6Yz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9jZXJ0Ij48YzpEYXRhIHhtbG5zPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIHhtbG5zOm09Imh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8xMS9tc2xwIj48YzpTZWN1cml0eVZlcnNpb24!NC4wLjAuMTwvYzpTZWN1cml0eVZlcnNpb24!PGM6UHVibGljS2V5PjxLZXlWYWx1ZT48UlNBS2V5VmFsdWU!PE1vZHVsdXM!d1RSNk9BdGozcnY2cTR6a01nNmpOQ0pJaGhFRW5QcDAzaHJ5ZzZKa0lkYWpyOEROa2t0UlpQMTZUczl6WlhNdFB0SUoxeWhrRk90ZHJRU2dRTmppRnZvVmZOQXJTcXB6czdkWXpaMzVDNVhFNCtCYndnczljcFU3NFBBREZPODE2bVhKWUxseDd5RHFnT2V1ZXkxN1BoVU5IbXlxTnBPaUhiOG05Y3I2T2VzPTwvTW9kdWx1cz48RXhwb25lbnQ!QVFBQjwvRXhwb25lbnQ!PC9SU0FLZXlWYWx1ZT48L0tleVZhbHVlPjwvYzpQdWJsaWNLZXk!PFZhbGlkYXRpb25NZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL2RybS8yMDA0LzAyL2NlcnQvdmFsaWRhdGVfdjIiIFZlcnNpb249IjIuMCI!PC9WYWxpZGF0aW9uTWV0aG9kPjxjOlNlY3VyaXR5TGV2ZWw!MjAwMDwvYzpTZWN1cml0eUxldmVsPjxjOktleVVzYWdlPjxjOlNpZ25DZXJ0aWZpY2F0ZT4xPC9jOlNpZ25DZXJ0aWZpY2F0ZT48L2M6S2V5VXNhZ2U!PGM6RmVhdHVyZXM!PG06V01EUk1UcmFuc21pdHRlcj4xPC9tOldNRFJNVHJhbnNtaXR0ZXI!PC9jOkZlYXR1cmVzPjxjOk1hbnVmYWN0dXJlckRhdGE!PGM6TWFudWZhY3R1cmVyTmFtZT5NaWNyb3NvZnQ8L2M6TWFudWZhY3R1cmVyTmFtZT48L2M6TWFudWZhY3R1cmVyRGF0YT48L2M6RGF0YT48U2lnbmF0dXJlIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj48U2lnbmVkSW5mbz48Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLXhtbC1jMTRuLTIwMDEwMzE1Ij48L0Nhbm9uaWNhbGl6YXRpb25NZXRob2Q!PFNpZ25hdHVyZU1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vRFJNLzIwMDQvMDIvQ0VSVC9Sc2Etc2hhMSI!PC9TaWduYXR1cmVNZXRob2Q!PFJlZmVyZW5jZT48VHJhbnNmb3Jtcz48VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9DRVJUL0RhdGEiPjwvVHJhbnNmb3JtPjxUcmFuc2Zvcm0gQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy14bWwtYzE0bi0yMDAxMDMxNSI!PC9UcmFuc2Zvcm0!PC9UcmFuc2Zvcm1zPjxEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjc2hhMSI!PC9EaWdlc3RNZXRob2Q!PERpZ2VzdFZhbHVlPlFFWmltSGQ2ZmZvUENDaFhYVXBRNFZMNzMxRT08L0RpZ2VzdFZhbHVlPjwvUmVmZXJlbmNlPjwvU2lnbmVkSW5mbz48U2lnbmF0dXJlVmFsdWU!Q3Z4MlFraEMvVEk0UHhpM1NqYkprb0JxNlcvV2JxMXhWU21HN1VsR0lRR1Qwd0lqWTgvT2RkK2tOZkpCajVIQjRQb09TSWFRNTlFNEVXaGwrVkdyejJWVXBPVjZXUnp0MlBwVmRqODltM2pHdjN6S3psZFhsTXV1ejJRT0lieG1tUUF6WnI5aHo4Z1NFeHJqcktBekt2R0VQWUFHcDhCbUVybUI2ZzdZWXQ4PTwvU2lnbmF0dXJlVmFsdWU!PEtleUluZm8!PEtleVZhbHVlPjxSU0FLZXlWYWx1ZT48TW9kdWx1cz5wam9lV0xTVExEb25RRzhTaGU2UWhrWWJZb3R0OWZQWjh0SGRCMTI4WkVUY2dobjVLSG95aW43SGtKRWNQSjBFZzRVZFN2YTBLRElZRGpBM0VYZDY5UjNDTjJXcC9ReU9vMFpQWVdZcDNOWHBKNzAwdEtQZ0lwbHpvNXdWZC82OWc3aitqOE02Nlc3Vk5tRHdhTnM5bURjMXAyK1ZWTXNEaE9zVi9BdTZFK0U9PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48L1JTQUtleVZhbHVlPjwvS2V5VmFsdWU!PC9LZXlJbmZvPjwvU2lnbmF0dXJlPjwvYzpDZXJ0aWZpY2F0ZT48L2M6Q2VydGlmaWNhdGVDb2xsZWN0aW9uPg==</MACHINECERTIFICATE><REVINFO></REVINFO><CLIENTVERSION>11.0.7600.16385</CLIENTVERSION><SECURITYVERSION>2.9.0.1</SECURITYVERSION><APPSECURITY>50</APPSECURITY><SUBJECTID1>221</SUBJECTID1><SUBJECTID2></SUBJECTID2></CLIENTINFO>";
            private const string ClientInfoXboxOldVersion = "<CLIENTINFO><CLIENTID>AgAAAIcU7SQ1dNzrRF9TC6TJ1Gu!TTckCs2c33A0ChkLQBNGQD9O3R!yQBPkBMvmGA56AJNOFNDx0cHLcLFlWEFprZDaAaE7nIzZLuJBzPofxDcLekEbQZ7eWzU5ALozHAi1I76vXgL!M09dAYOsC!OKp6xZ7aVEfqlihiV!T7783MQuPLGGENP33grnzfLKvrSB3LIWETRSfrDWxlZKEcq0FzjeFS3X</CLIENTID><MACHINECERTIFICATE>PGM6Q2VydGlmaWNhdGVDb2xsZWN0aW9uIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIiB4bWxuczpjPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIGM6VmVyc2lvbj0iMi4wIj48YzpDZXJ0aWZpY2F0ZSBjOlZlcnNpb249IjIuMCIgeG1sbnM6Yz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9jZXJ0Ij48YzpEYXRhIHhtbG5zPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIHhtbG5zOm09Imh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8xMS9tc2xwIj48YzpTZWN1cml0eVZlcnNpb24!My4wLjAuMDwvYzpTZWN1cml0eVZlcnNpb24!PGM6UHVibGljS2V5PjxLZXlWYWx1ZT48UlNBS2V5VmFsdWU!PE1vZHVsdXM!NmNkdjVSMXExT0lpWS9MRE5nMmh1ZlZ2WXB0RzhvMXVEcitJajhSdm1zZlhsKzlTQ2JoN25wU1RtYWpRR3hUQ3FPUjByRklKT05kSlVWU0hneEFXUFgzcG1BdmZIYWV3NG5DUnBvS01Va1R5RHhZUkhuanlBQkJEazVvZmJCZ1JPckRWdFo4RzV1Mi9YdkJaZTg3OEtkSllxMlVETlNQd3M4YWlrNGhVeVJFPTwvTW9kdWx1cz48RXhwb25lbnQ!QVFBQjwvRXhwb25lbnQ!PC9SU0FLZXlWYWx1ZT48L0tleVZhbHVlPjwvYzpQdWJsaWNLZXk!PGM6UEtDZXJ0PjFITzBQdmVLbXpYckdIM1hET0VLUDlVaTlrNU5iWTJSMUFJcTVJUEFxekxlQkFPOXJHVjJOd0lGQUFBYzVuWXhHT0lkaENXb0JueWRvZzNCckRhSVJMR1l6K0dPWVM0d0lUMHRYSHVkZjNFaEVqUXA8L2M6UEtDZXJ0PjxjOlNlY3VyaXR5TGV2ZWw!MjAwMDwvYzpTZWN1cml0eUxldmVsPjxjOkhhcmR3YXJlSUQ!ckF6aFExK2s3S3FiKy9ZMWVKUklBWGNleWtJPTwvYzpIYXJkd2FyZUlEPjxjOktleVVzYWdlPjxjOkVuY3J5cHRLZXk!MTwvYzpFbmNyeXB0S2V5PjwvYzpLZXlVc2FnZT48YzpGZWF0dXJlcz48YzpXTURSTVRyYW5zbWl0dGVyPjE8L2M6V01EUk1UcmFuc21pdHRlcj48YzpXTURSTVJlY2VpdmVyPjE8L2M6V01EUk1SZWNlaXZlcj48YzpXTURSTVNoYXJlZENlcnRpZmljYXRlPjE8L2M6V01EUk1TaGFyZWRDZXJ0aWZpY2F0ZT48L2M6RmVhdHVyZXM!PGM6TWFudWZhY3R1cmVyRGF0YT48YzpNYW51ZmFjdHVyZXJOYW1lPlVua25vd248L2M6TWFudWZhY3R1cmVyTmFtZT48YzpNb2RlbE5hbWU!VW5rbm93bjwvYzpNb2RlbE5hbWU!PGM6TW9kZWxOdW1iZXI!VW5rbm93bjwvYzpNb2RlbE51bWJlcj48L2M6TWFudWZhY3R1cmVyRGF0YT48L2M6RGF0YT48U2lnbmF0dXJlIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj48U2lnbmVkSW5mbz48Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLXhtbC1jMTRuLTIwMDEwMzE1Ij48L0Nhbm9uaWNhbGl6YXRpb25NZXRob2Q!PFNpZ25hdHVyZU1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vRFJNLzIwMDQvMDIvQ0VSVC9Sc2Etc2hhMSI!PC9TaWduYXR1cmVNZXRob2Q!PFJlZmVyZW5jZT48VHJhbnNmb3Jtcz48VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9DRVJUL0RhdGEiPjwvVHJhbnNmb3JtPjxUcmFuc2Zvcm0gQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy14bWwtYzE0bi0yMDAxMDMxNSI!PC9UcmFuc2Zvcm0!PC9UcmFuc2Zvcm1zPjxEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjc2hhMSI!PC9EaWdlc3RNZXRob2Q!PERpZ2VzdFZhbHVlPk4ycnh4djA1a2xJak9keTgyc3FQVVdNejJvcz08L0RpZ2VzdFZhbHVlPjwvUmVmZXJlbmNlPjwvU2lnbmVkSW5mbz48U2lnbmF0dXJlVmFsdWU!UnptOVM3QUwwV0oyL2N0WWo3MzhnbkhWME84V2lQTDU1MWpmVjhwV1ZEMkRBc0RQbmtaa1VXQW9rMGtKUEhiVXpVb2lWaWYyWmJ0MDBSVlVPSFU0VEJBK3hITGprb1huNVQvR0ZHOCt5SEtaTmZaLzBxNkVuS2JYbytIZ0pBWEdPNEE5a0g2Z0FuekkrVlNmbE5vV3A5YmpUK1ozMktENFc0Y3JzemN2ckJrPTwvU2lnbmF0dXJlVmFsdWU!PEtleUluZm8!PEtleVZhbHVlPjxSU0FLZXlWYWx1ZT48TW9kdWx1cz5wME9WaVdYbDl4a1pJR2VPeTdNdnAzOGJIK3RkZDlhOVNpb0xGVG12aytCSWRhUkp2c3l4bVZQK210WXRCVWJjN2ptUWdNczFQS3d3UzJkKzZGejE4OGEra3p6ODZReXM3bUxvQ2IvL3FpVTgxaFUyR1owTkxoK1cwZ253R1UzZk1YbnBvUFRHUlNrMGVWVkpDeVRSM0FMMUFkT2d0ditoR1JoT2dUZjdtUHM9PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48L1JTQUtleVZhbHVlPjwvS2V5VmFsdWU!PC9LZXlJbmZvPjwvU2lnbmF0dXJlPjwvYzpDZXJ0aWZpY2F0ZT48YzpDZXJ0aWZpY2F0ZSBjOlZlcnNpb249IjIuMCIgeG1sbnM6Yz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9jZXJ0Ij48YzpEYXRhIHhtbG5zPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIHhtbG5zOm09Imh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8xMS9tc2xwIj48YzpTZWN1cml0eVZlcnNpb24!My4wLjAuMDwvYzpTZWN1cml0eVZlcnNpb24!PGM6UHVibGljS2V5PjxLZXlWYWx1ZT48UlNBS2V5VmFsdWU!PE1vZHVsdXM!cDBPVmlXWGw5eGtaSUdlT3k3TXZwMzhiSCt0ZGQ5YTlTaW9MRlRtdmsrQklkYVJKdnN5eG1WUCttdFl0QlViYzdqbVFnTXMxUEt3d1MyZCs2RnoxODhhK2t6ejg2UXlzN21Mb0NiLy9xaVU4MWhVMkdaME5MaCtXMGdud0dVM2ZNWG5wb1BUR1JTazBlVlZKQ3lUUjNBTDFBZE9ndHYraEdSaE9nVGY3bVBzPTwvTW9kdWx1cz48RXhwb25lbnQ!QVFBQjwvRXhwb25lbnQ!PC9SU0FLZXlWYWx1ZT48L0tleVZhbHVlPjwvYzpQdWJsaWNLZXk!PGM6U2VjdXJpdHlMZXZlbD4yMDAwPC9jOlNlY3VyaXR5TGV2ZWw!PGM6S2V5VXNhZ2U!PGM6U2lnbkNlcnRpZmljYXRlPjE8L2M6U2lnbkNlcnRpZmljYXRlPjwvYzpLZXlVc2FnZT48YzpGZWF0dXJlcz48bTpXTURSTVRyYW5zbWl0dGVyPjE8L206V01EUk1UcmFuc21pdHRlcj48L2M6RmVhdHVyZXM!PGM6TWFudWZhY3R1cmVyRGF0YT48YzpNYW51ZmFjdHVyZXJOYW1lPk1pY3Jvc29mdDwvYzpNYW51ZmFjdHVyZXJOYW1lPjwvYzpNYW51ZmFjdHVyZXJEYXRhPjwvYzpEYXRhPjxTaWduYXR1cmUgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvMDkveG1sZHNpZyMiPjxTaWduZWRJbmZvPjxDYW5vbmljYWxpemF0aW9uTWV0aG9kIEFsZ29yaXRobT0iaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMS9SRUMteG1sLWMxNG4tMjAwMTAzMTUiPjwvQ2Fub25pY2FsaXphdGlvbk1ldGhvZD48U2lnbmF0dXJlTWV0aG9kIEFsZ29yaXRobT0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9DRVJUL1JzYS1zaGExIj48L1NpZ25hdHVyZU1ldGhvZD48UmVmZXJlbmNlPjxUcmFuc2Zvcm1zPjxUcmFuc2Zvcm0gQWxnb3JpdGhtPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL0NFUlQvRGF0YSI!PC9UcmFuc2Zvcm0!PFRyYW5zZm9ybSBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLXhtbC1jMTRuLTIwMDEwMzE1Ij48L1RyYW5zZm9ybT48L1RyYW5zZm9ybXM!PERpZ2VzdE1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvMDkveG1sZHNpZyNzaGExIj48L0RpZ2VzdE1ldGhvZD48RGlnZXN0VmFsdWU!cHR3S1F3Q3VLY2JzZU1ZSUFDeCswVkljNDdFPTwvRGlnZXN0VmFsdWU!PC9SZWZlcmVuY2U!PC9TaWduZWRJbmZvPjxTaWduYXR1cmVWYWx1ZT5qKzVmT3A5U0o1dFh5dW1jSVdIU0wySnQwdEdZaUtQbGJLdGZZY3ptT3J4TGp3aS9iQ21PRW5lQ1JmRkxydnVBTUsxQ3pWcHh5MGd3MzZTZ3NRYmliam94TEFIOTd4b2Z5TzAwVXVNQ29GRjB5NlZNN3BMY1RzaDNESkV2a3ZDTWRnMlUrbXQ0N1FCaHM3aWZoc0k0a2xjbStCOTVUci95WXBhdXNMcGRuakk9PC9TaWduYXR1cmVWYWx1ZT48S2V5SW5mbz48S2V5VmFsdWU!PFJTQUtleVZhbHVlPjxNb2R1bHVzPnM2bGZIM3paK205bzducFNWanFWSVZ5N2l1YVhjNWtLbncwL2xZSFZ1bHpBaTZTeDRYZkFUQm1tSGFjUzdCT004dDNRTFBvWFAyVUV1VS85QzB1b3BaajdPajQ0clZFWlFmbHMxTk9IQ0FuT3B1cHFXOVBYU2VRc1VUTnpoRy9BRVJ3Q1dQYTJxYjVORGl0UTlIckR4L2k3UitFUEMrcDlxa09md3B3RGdkRT08L01vZHVsdXM!PEV4cG9uZW50PkFRQUI8L0V4cG9uZW50PjwvUlNBS2V5VmFsdWU!PC9LZXlWYWx1ZT48L0tleUluZm8!PC9TaWduYXR1cmU!PC9jOkNlcnRpZmljYXRlPjxjOkNlcnRpZmljYXRlIGM6VmVyc2lvbj0iMi4wIiB4bWxuczpjPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiPjxjOkRhdGEgeG1sbnM9Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vRFJNLzIwMDQvMDIvY2VydCIgeG1sbnM6bT0iaHR0cDovL3d3dy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzExL21zbHAiPjxjOlB1YmxpY0tleT48S2V5VmFsdWU!PFJTQUtleVZhbHVlPjxNb2R1bHVzPnM2bGZIM3paK205bzducFNWanFWSVZ5N2l1YVhjNWtLbncwL2xZSFZ1bHpBaTZTeDRYZkFUQm1tSGFjUzdCT004dDNRTFBvWFAyVUV1VS85QzB1b3BaajdPajQ0clZFWlFmbHMxTk9IQ0FuT3B1cHFXOVBYU2VRc1VUTnpoRy9BRVJ3Q1dQYTJxYjVORGl0UTlIckR4L2k3UitFUEMrcDlxa09md3B3RGdkRT08L01vZHVsdXM!PEV4cG9uZW50PkFRQUI8L0V4cG9uZW50PjwvUlNBS2V5VmFsdWU!PC9LZXlWYWx1ZT48L2M6UHVibGljS2V5PjxjOlNlY3VyaXR5TGV2ZWw!MjAwMDwvYzpTZWN1cml0eUxldmVsPjxjOktleVVzYWdlPjxjOlNpZ25DZXJ0aWZpY2F0ZT4xPC9jOlNpZ25DZXJ0aWZpY2F0ZT48L2M6S2V5VXNhZ2U!PGM6RmVhdHVyZXM!PG06V01EUk1UcmFuc21pdHRlcj4xPC9tOldNRFJNVHJhbnNtaXR0ZXI!PC9jOkZlYXR1cmVzPjxjOk1hbnVmYWN0dXJlckRhdGE!PGM6TWFudWZhY3R1cmVyTmFtZT5NaWNyb3NvZnQ8L2M6TWFudWZhY3R1cmVyTmFtZT48L2M6TWFudWZhY3R1cmVyRGF0YT48L2M6RGF0YT48U2lnbmF0dXJlIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj48U2lnbmVkSW5mbz48Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLXhtbC1jMTRuLTIwMDEwMzE1Ij48L0Nhbm9uaWNhbGl6YXRpb25NZXRob2Q!PFNpZ25hdHVyZU1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vRFJNLzIwMDQvMDIvQ0VSVC9Sc2Etc2hhMSI!PC9TaWduYXR1cmVNZXRob2Q!PFJlZmVyZW5jZT48VHJhbnNmb3Jtcz48VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9DRVJUL0RhdGEiPjwvVHJhbnNmb3JtPjxUcmFuc2Zvcm0gQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy14bWwtYzE0bi0yMDAxMDMxNSI!PC9UcmFuc2Zvcm0!PC9UcmFuc2Zvcm1zPjxEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjc2hhMSI!PC9EaWdlc3RNZXRob2Q!PERpZ2VzdFZhbHVlPjBaOGI5YWN5Mnh1VFoyUzc5OERkSE1CMDR3UT08L0RpZ2VzdFZhbHVlPjwvUmVmZXJlbmNlPjwvU2lnbmVkSW5mbz48U2lnbmF0dXJlVmFsdWU!ZU5VOEpMNkxBNnBLcXIwM1VCOWxlNTJ2NHZNMVF1dnE4WS9KeTR6SURQQ3p4a3gzM3NFMUZ3N1d2MHltZ1M1UVZJaEd2dVJNQll4c00yanVKaldlSHErUGRaUVVoRi9TbVlUamlOZ1I4Q3plWTV1Mjk0Q1R5ZTBrZzBmdlRIM09WczFwNzl3WHQ3aURlKzh5RGxkRUN5RnJ6cHlvZTZlelQxUGh4Qzh6R0ZnPTwvU2lnbmF0dXJlVmFsdWU!PEtleUluZm8!PEtleVZhbHVlPjxSU0FLZXlWYWx1ZT48TW9kdWx1cz5wam9lV0xTVExEb25RRzhTaGU2UWhrWWJZb3R0OWZQWjh0SGRCMTI4WkVUY2dobjVLSG95aW43SGtKRWNQSjBFZzRVZFN2YTBLRElZRGpBM0VYZDY5UjNDTjJXcC9ReU9vMFpQWVdZcDNOWHBKNzAwdEtQZ0lwbHpvNXdWZC82OWc3aitqOE02Nlc3Vk5tRHdhTnM5bURjMXAyK1ZWTXNEaE9zVi9BdTZFK0U9PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48L1JTQUtleVZhbHVlPjwvS2V5VmFsdWU!PC9LZXlJbmZvPjwvU2lnbmF0dXJlPjwvYzpDZXJ0aWZpY2F0ZT48L2M6Q2VydGlmaWNhdGVDb2xsZWN0aW9uPg==</MACHINECERTIFICATE><REVINFO></REVINFO><CLIENTVERSION>11.0.6000.6324</CLIENTVERSION><SECURITYVERSION>2.5.0.0</SECURITYVERSION><APPSECURITY>50</APPSECURITY><SUBJECTID1>221</SUBJECTID1><SUBJECTID2></SUBJECTID2></CLIENTINFO>";

            // Good ClientInfo blocks
            private const string ClientInfoDoradoKnownGood = "<CLIENTINFO><CLIENTID>AgAAAKtvzNznbmgjPmtp0xa3c3zy4UFDftjEW3RbO7OLkEzDmusID2zrvxDsRvzLRKRQGYq8Rlq6F!DICE1CFfDA1dEPxiI73oQIWPDDko2ikvBDamWraqeS8vrFSBT4Mn!ucLn5lvFrob37crvgU1xHUMqcCFsZfg8OuB14GaHfQa9PeNunCxXsoWu*FLs3mlObIOS8OOclm7MVsPcquYwrQ7NY!NE2</CLIENTID><MACHINECERTIFICATE>PGM6Q2VydGlmaWNhdGVDb2xsZWN0aW9uIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIiB4bWxuczpjPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIGM6VmVyc2lvbj0iMi4wIj48YzpDZXJ0aWZpY2F0ZSBjOlZlcnNpb249IjIuMCIgeG1sbnM6Yz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9jZXJ0Ij48YzpEYXRhIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIiB4bWxuczpjPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIHhtbG5zOm09Imh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9tc2xwIj48YzpTZWN1cml0eVZlcnNpb24!My44LjAuMTwvYzpTZWN1cml0eVZlcnNpb24!PGM6UHVibGljS2V5PjxLZXlWYWx1ZT48UlNBS2V5VmFsdWU!PE1vZHVsdXM!eUVmT0o0VEpvZVoxdjNzTFV6clk0U0Q1YTVQTTBHM0ROdTN2cjRrNDNVcWpTWkJsNzMrRUwydHVURDN4bHozRFFyUDNWVk00TVB4RmY5cHQvTDduMXRhOGRVM2FrSU9Sb1E2SHdaZnIvL2Y2VG9Nb016UXJ0d0dvdTloeisyQnRveW5lV2lCbThwYnVqaW1oamtrM2JGVTJsOUpCRG5pSDhwOFRLZnFLR0dNPTwvTW9kdWx1cz48RXhwb25lbnQ!QVFBQjwvRXhwb25lbnQ!PC9SU0FLZXlWYWx1ZT48L0tleVZhbHVlPjwvYzpQdWJsaWNLZXk!PGM6UEtDZXJ0PnphUEZRazM5SnpHcm1VTVpYczJjeE5jVGNHeXJ2WXpJTGEvaDhSOEczbjBiSERUT2RrUFFaUUlKQUFHMnJVcHRkK0ViQUVOOGNNRytGVjkvTWxYdEtjT3M1dFcwV0xmd0xhMDYxM1h4Vlc3QnU1NVc8L2M6UEtDZXJ0PjxjOlBLU2lnbmluZ0NlcnQ!RVN3MisvNUVINE9MUkhDRjZtRytkUnNhRGtzNVEwTGVKWS9IQjFkajBvZStEYjBlMUR2blVBSUpBQUdGLzlUV2VNQThqSG5WOTd4N1Zucjh2bStzU2ZMYlljQlk4dGFkMmhvUGljV3dHdE9uakt0ZDwvYzpQS1NpZ25pbmdDZXJ0PjxjOkhhcmR3YXJlSUQ!d0hmWG03QmcyU1liKzIxQlZzaG0vOEg1c2pJPTwvYzpIYXJkd2FyZUlEPjxjOlNlY3VyaXR5TGV2ZWw!MjAwMDwvYzpTZWN1cml0eUxldmVsPjxjOktleVVzYWdlPjxjOkVuY3J5cHRLZXk!MTwvYzpFbmNyeXB0S2V5PjwvYzpLZXlVc2FnZT48YzpGZWF0dXJlcz48YzpXTURSTVRyYW5zbWl0dGVyPjE8L2M6V01EUk1UcmFuc21pdHRlcj48YzpXTURSTVJlY2VpdmVyPjE8L2M6V01EUk1SZWNlaXZlcj48YzpXTURSTVNoYXJlZENlcnRpZmljYXRlPjE8L2M6V01EUk1TaGFyZWRDZXJ0aWZpY2F0ZT48L2M6RmVhdHVyZXM!PGM6TWFudWZhY3R1cmVyRGF0YT48YzpNYW51ZmFjdHVyZXJOYW1lPlVua25vd248L2M6TWFudWZhY3R1cmVyTmFtZT48YzpNb2RlbE5hbWU!VW5rbm93bjwvYzpNb2RlbE5hbWU!PGM6TW9kZWxOdW1iZXI!VW5rbm93bjwvYzpNb2RlbE51bWJlcj48L2M6TWFudWZhY3R1cmVyRGF0YT48L2M6RGF0YT48U2lnbmF0dXJlIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj48U2lnbmVkSW5mbz48Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLXhtbC1jMTRuLTIwMDEwMzE1Ij48L0Nhbm9uaWNhbGl6YXRpb25NZXRob2Q!PFNpZ25hdHVyZU1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vRFJNLzIwMDQvMDIvQ0VSVC9Sc2Etc2hhMSI!PC9TaWduYXR1cmVNZXRob2Q!PFJlZmVyZW5jZT48VHJhbnNmb3Jtcz48VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9DRVJUL0RhdGEiPjwvVHJhbnNmb3JtPjxUcmFuc2Zvcm0gQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy14bWwtYzE0bi0yMDAxMDMxNSI!PC9UcmFuc2Zvcm0!PC9UcmFuc2Zvcm1zPjxEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjc2hhMSI!PC9EaWdlc3RNZXRob2Q!PERpZ2VzdFZhbHVlPmNHWWJwS0hnNG0zeXZTbmt6d0tnblNHdXV6bz08L0RpZ2VzdFZhbHVlPjwvUmVmZXJlbmNlPjwvU2lnbmVkSW5mbz48U2lnbmF0dXJlVmFsdWU!VklTWWtEV0ZmcGJGeGFlSUhCNFhFWkc5RXI1bThvalVZM3FXM0orUndjbXlBbDIyN2ZCSnNKcW1icGJzSFlMelVNZ1ZoVVNPdEVzVUF5RGN2Y0pzU293bTh6OG95eXViWmJsTjFYMVZRNWdoT0J1MGZlUzE0eWI3RjRMQjZkRmFPYTFhZEVxdnlGMFIvTHh1U3pMcXhENHJvMUNEdkhpcVlOMGVyTDFBSERnPTwvU2lnbmF0dXJlVmFsdWU!PEtleUluZm8!PEtleVZhbHVlPjxSU0FLZXlWYWx1ZT48TW9kdWx1cz50M2o1cGFFa0JLL1pFWW1IZis1SEVUVWkzSmFaZ2xreDNPbU1oOThWQllOeW9sR1EwTUpFMFgwS3dYdnVWMGRxR2JGK2ZlcEJON0c1RC9uOTE4RDdiUy9ROTZyNGYzOXFrSkRlUk1hbTg1K3p5aUhOQWpBbUdvWG44bWliUTlkZk9CZXdUUlluVVJBVEVlTHRMR01TaGJnSytESHN6WDJyUzdrUU4xYUVUOWM9PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48L1JTQUtleVZhbHVlPjwvS2V5VmFsdWU!PC9LZXlJbmZvPjwvU2lnbmF0dXJlPjwvYzpDZXJ0aWZpY2F0ZT48YzpDZXJ0aWZpY2F0ZSBjOlZlcnNpb249IjIuMCIgeG1sbnM6Yz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9jZXJ0Ij48YzpEYXRhIHhtbG5zPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIHhtbG5zOm09Imh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8xMS9tc2xwIj48YzpTZWN1cml0eVZlcnNpb24!My44LjAuMTwvYzpTZWN1cml0eVZlcnNpb24!PGM6UHVibGljS2V5PjxLZXlWYWx1ZT48UlNBS2V5VmFsdWU!PE1vZHVsdXM!dDNqNXBhRWtCSy9aRVltSGYrNUhFVFVpM0phWmdsa3gzT21NaDk4VkJZTnlvbEdRME1KRTBYMEt3WHZ1VjBkcUdiRitmZXBCTjdHNUQvbjkxOEQ3YlMvUTk2cjRmMzlxa0pEZVJNYW04NSt6eWlITkFqQW1Hb1huOG1pYlE5ZGZPQmV3VFJZblVSQVRFZUx0TEdNU2hiZ0srREhzelgyclM3a1FOMWFFVDljPTwvTW9kdWx1cz48RXhwb25lbnQ!QVFBQjwvRXhwb25lbnQ!PC9SU0FLZXlWYWx1ZT48L0tleVZhbHVlPjwvYzpQdWJsaWNLZXk!PFZhbGlkYXRpb25NZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL2RybS8yMDA0LzAyL2NlcnQvdmFsaWRhdGVfdjIiIFZlcnNpb249IjIuMCI!PC9WYWxpZGF0aW9uTWV0aG9kPjxjOlNlY3VyaXR5TGV2ZWw!MjAwMDwvYzpTZWN1cml0eUxldmVsPjxjOktleVVzYWdlPjxjOlNpZ25DZXJ0aWZpY2F0ZT4xPC9jOlNpZ25DZXJ0aWZpY2F0ZT48L2M6S2V5VXNhZ2U!PGM6RmVhdHVyZXM!PG06V01EUk1UcmFuc21pdHRlcj4xPC9tOldNRFJNVHJhbnNtaXR0ZXI!PC9jOkZlYXR1cmVzPjxjOk1hbnVmYWN0dXJlckRhdGE!PGM6TWFudWZhY3R1cmVyTmFtZT5NaWNyb3NvZnQ8L2M6TWFudWZhY3R1cmVyTmFtZT48L2M6TWFudWZhY3R1cmVyRGF0YT48L2M6RGF0YT48U2lnbmF0dXJlIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj48U2lnbmVkSW5mbz48Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLXhtbC1jMTRuLTIwMDEwMzE1Ij48L0Nhbm9uaWNhbGl6YXRpb25NZXRob2Q!PFNpZ25hdHVyZU1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vRFJNLzIwMDQvMDIvQ0VSVC9Sc2Etc2hhMSI!PC9TaWduYXR1cmVNZXRob2Q!PFJlZmVyZW5jZT48VHJhbnNmb3Jtcz48VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9DRVJUL0RhdGEiPjwvVHJhbnNmb3JtPjxUcmFuc2Zvcm0gQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy14bWwtYzE0bi0yMDAxMDMxNSI!PC9UcmFuc2Zvcm0!PC9UcmFuc2Zvcm1zPjxEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjc2hhMSI!PC9EaWdlc3RNZXRob2Q!PERpZ2VzdFZhbHVlPjJjRmtmYkNYQ21GSS9jSXF0SGpEenF2UTZpRT08L0RpZ2VzdFZhbHVlPjwvUmVmZXJlbmNlPjwvU2lnbmVkSW5mbz48U2lnbmF0dXJlVmFsdWU!TzRWWUVHWjBMdElzQ01LcUYyd2ROMG9TMmdIS2g2cUV4cEN2ZWp3TWphTndVc1dHRVAwbVZocWp0eVprOWp1ZHRodFBqdERHUERnMERMNWcxOHNtMWgvUHJlcHF1SFVia0NPejU5YUhIRGZqRXMyYVFZbW5hbnRmeFFEWWQxQnJBc25Sa3Flbk1RWWFPS1J3dWlycitXMWxNblVUZXYvUzN5aGtNYXBuZkYwPTwvU2lnbmF0dXJlVmFsdWU!PEtleUluZm8!PEtleVZhbHVlPjxSU0FLZXlWYWx1ZT48TW9kdWx1cz53VFI2T0F0ajNydjZxNHprTWc2ak5DSkloaEVFblBwMDNocnlnNkprSWRhanI4RE5ra3RSWlAxNlRzOXpaWE10UHRJSjF5aGtGT3RkclFTZ1FOamlGdm9WZk5BclNxcHpzN2RZelozNUM1WEU0K0Jid2dzOWNwVTc0UEFERk84MTZtWEpZTGx4N3lEcWdPZXVleTE3UGhVTkhteXFOcE9pSGI4bTljcjZPZXM9PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48L1JTQUtleVZhbHVlPjwvS2V5VmFsdWU!PC9LZXlJbmZvPjwvU2lnbmF0dXJlPjwvYzpDZXJ0aWZpY2F0ZT48YzpDZXJ0aWZpY2F0ZSBjOlZlcnNpb249IjIuMCIgeG1sbnM6Yz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9jZXJ0Ij48YzpEYXRhIHhtbG5zPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIHhtbG5zOm09Imh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8xMS9tc2xwIj48YzpTZWN1cml0eVZlcnNpb24!NC4wLjAuMTwvYzpTZWN1cml0eVZlcnNpb24!PGM6UHVibGljS2V5PjxLZXlWYWx1ZT48UlNBS2V5VmFsdWU!PE1vZHVsdXM!d1RSNk9BdGozcnY2cTR6a01nNmpOQ0pJaGhFRW5QcDAzaHJ5ZzZKa0lkYWpyOEROa2t0UlpQMTZUczl6WlhNdFB0SUoxeWhrRk90ZHJRU2dRTmppRnZvVmZOQXJTcXB6czdkWXpaMzVDNVhFNCtCYndnczljcFU3NFBBREZPODE2bVhKWUxseDd5RHFnT2V1ZXkxN1BoVU5IbXlxTnBPaUhiOG05Y3I2T2VzPTwvTW9kdWx1cz48RXhwb25lbnQ!QVFBQjwvRXhwb25lbnQ!PC9SU0FLZXlWYWx1ZT48L0tleVZhbHVlPjwvYzpQdWJsaWNLZXk!PFZhbGlkYXRpb25NZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL2RybS8yMDA0LzAyL2NlcnQvdmFsaWRhdGVfdjIiIFZlcnNpb249IjIuMCI!PC9WYWxpZGF0aW9uTWV0aG9kPjxjOlNlY3VyaXR5TGV2ZWw!MjAwMDwvYzpTZWN1cml0eUxldmVsPjxjOktleVVzYWdlPjxjOlNpZ25DZXJ0aWZpY2F0ZT4xPC9jOlNpZ25DZXJ0aWZpY2F0ZT48L2M6S2V5VXNhZ2U!PGM6RmVhdHVyZXM!PG06V01EUk1UcmFuc21pdHRlcj4xPC9tOldNRFJNVHJhbnNtaXR0ZXI!PC9jOkZlYXR1cmVzPjxjOk1hbnVmYWN0dXJlckRhdGE!PGM6TWFudWZhY3R1cmVyTmFtZT5NaWNyb3NvZnQ8L2M6TWFudWZhY3R1cmVyTmFtZT48L2M6TWFudWZhY3R1cmVyRGF0YT48L2M6RGF0YT48U2lnbmF0dXJlIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj48U2lnbmVkSW5mbz48Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLXhtbC1jMTRuLTIwMDEwMzE1Ij48L0Nhbm9uaWNhbGl6YXRpb25NZXRob2Q!PFNpZ25hdHVyZU1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vRFJNLzIwMDQvMDIvQ0VSVC9Sc2Etc2hhMSI!PC9TaWduYXR1cmVNZXRob2Q!PFJlZmVyZW5jZT48VHJhbnNmb3Jtcz48VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9DRVJUL0RhdGEiPjwvVHJhbnNmb3JtPjxUcmFuc2Zvcm0gQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy14bWwtYzE0bi0yMDAxMDMxNSI!PC9UcmFuc2Zvcm0!PC9UcmFuc2Zvcm1zPjxEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjc2hhMSI!PC9EaWdlc3RNZXRob2Q!PERpZ2VzdFZhbHVlPlFFWmltSGQ2ZmZvUENDaFhYVXBRNFZMNzMxRT08L0RpZ2VzdFZhbHVlPjwvUmVmZXJlbmNlPjwvU2lnbmVkSW5mbz48U2lnbmF0dXJlVmFsdWU!Q3Z4MlFraEMvVEk0UHhpM1NqYkprb0JxNlcvV2JxMXhWU21HN1VsR0lRR1Qwd0lqWTgvT2RkK2tOZkpCajVIQjRQb09TSWFRNTlFNEVXaGwrVkdyejJWVXBPVjZXUnp0MlBwVmRqODltM2pHdjN6S3psZFhsTXV1ejJRT0lieG1tUUF6WnI5aHo4Z1NFeHJqcktBekt2R0VQWUFHcDhCbUVybUI2ZzdZWXQ4PTwvU2lnbmF0dXJlVmFsdWU!PEtleUluZm8!PEtleVZhbHVlPjxSU0FLZXlWYWx1ZT48TW9kdWx1cz5wam9lV0xTVExEb25RRzhTaGU2UWhrWWJZb3R0OWZQWjh0SGRCMTI4WkVUY2dobjVLSG95aW43SGtKRWNQSjBFZzRVZFN2YTBLRElZRGpBM0VYZDY5UjNDTjJXcC9ReU9vMFpQWVdZcDNOWHBKNzAwdEtQZ0lwbHpvNXdWZC82OWc3aitqOE02Nlc3Vk5tRHdhTnM5bURjMXAyK1ZWTXNEaE9zVi9BdTZFK0U9PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48L1JTQUtleVZhbHVlPjwvS2V5VmFsdWU!PC9LZXlJbmZvPjwvU2lnbmF0dXJlPjwvYzpDZXJ0aWZpY2F0ZT48L2M6Q2VydGlmaWNhdGVDb2xsZWN0aW9uPg==</MACHINECERTIFICATE><REVINFO></REVINFO><CLIENTVERSION>11.0.8102.0</CLIENTVERSION><SECURITYVERSION>2.9.0.1</SECURITYVERSION><APPSECURITY>50</APPSECURITY><SUBJECTID1>221</SUBJECTID1><SUBJECTID2></SUBJECTID2></CLIENTINFO>";
            private const string ClientInfoXboxKnownGood = "<CLIENTINFO><CLIENTID>AgAAAPiqsL8f!76t6sjrZjnhKc2gzpxSdxXFerkjLITea76j0i0M9DE3SCVe!EGYFlss5zJrvmNeh1x*afnOY3L2GxY0eYpAAHE1NuMeoIJ1iWxnlJlkEzKyEz!0djMKmtMHANTrLE2L7ADYzg2Ej0ulrbVR4zsAFbzH0CAMcGJbMo10gCaqwaPXoqBKdA1nKSV9UIg2VagA8YAEsKg94aF!ciQy!4S5</CLIENTID><CLIENTVERSION>9.00.00.2778</CLIENTVERSION><SECURITYVERSION>2.4.105.189</SECURITYVERSION><APPSECURITY>2000</APPSECURITY><SUBJECTID1>1313</SUBJECTID1><SUBJECTID2></SUBJECTID2><DRMKVERSION></DRMKVERSION><DEVCERT>lY6J1+KSUbabQ0AV7pPyM/S6aYUNuRM739Mcg5sp+bgdGXu8sOnnSc+TluSjB6saCSEjSyJk33jLKnAWdVrdCumX/YlZNmAfKxMRkNqoR2iBiARbXcIhQF/XuiyI91rDLQVG/s1+u2IynSvMz53LRbV76HEaJlGc6AL6aes8oeiNa6YfI2NYp0Vd52LaGdavhM6ZJfmOeZf/CtCCkcfjfmjBjy7HtslzrKJZqUYAsiQQKafEuPTegGCnAno5ywhWRLX81au7fg2svpWWwfOwNtxeocTphmd5hH3eQB+MNw+wfb4uV1QGf4gvkTDAUs8/E9jIcf9oPT3yqUv4MiEcv1WAx4Ys50JO9iPu02Sd3X9bKzvli6SLC0di7H2zx63TjK2RUVs8JFJDqq2SMydfDE4llH0py2Rv8nMwo2QlkkrhmzaZDse2aRhVGV7wymfoZDSvSsLUs69P2g1Y6Ay1KqWSg+mpi7+mZO+JVvQeFwKIPP3DHW+415OmQzOof4o2ElGBGNjVj5Z+QpjmlzROthl4uxp8p7gvGvaYlvM5U2qi7eThBgRvWTkX14uxW05R737JuCfXl4bPQfeNN9ZgdqN5eFKxgROIdQ4BZ89qQG1oak6aMEcgDKSit3oO217/RPQ/6SxkuQcl4EXAqjhzcdvcsrfoTS9GXpxOP9zUj3GeEqjh43dODSwlNNnG4vokXjEPfxlwKLl7nUEXpWpzVRw8gNIydM8rB+hbUsQ3LCETpfFgdRvZFdCQ5pLVm3fr4OqkCG6nJlX71IfzclaW4V+07+KBN/Smag1BstkETJQKpzpJ7OZFVfVBwUxvLiN8KHMTe2/nAW7bAGMjC/Ls4BTnUICgm7cEPOjDIvRzrzAoz3kHvGr1HFw+kdExuEJLzmEVWp61f6QlREFFdo1ucTLss5mgvG78YuaM7E6irjikClc8NeZsYWrkpqqz9wccq6bYq5cWm86FlBOzLHUOBfov5IOK0VCyFpRQ0neYtr4noCjMvrH7H/OT33lHcfMRc+ZX9lSMa2gbTYJLuUS19BXf1Q7ybUH6CBLkeuVwSs6zrXDZs+sfzlmf+NMLIafB+93sQUO22wLs7OfxImrivRXhOQmD/yiBLVOvDtlHcv9F8sTPO1uFl1ZaCeZ4uHqUZsTeCLcrY8l21At0s7QA2An/8gDMwNVBqH6VsaMSMcf1YzTiGRBRBGkWEbsGwl+KPzn6Q6PXPT/VUPMgLoZjtY/kEHHF3QPYridz648qE6nSCSgouaF5YzgElq6TRmH81qtU6VkJiE6PPRZBEzmmasdYlmJ/DDQCIOJk+6sXaZODwv53wrS69fxxBXX7gjCqGWnrOXxUZQearKBJzGAzrUg/0ZzfEB6j7+zfKp0orPVEA9yPSl7flGratHGBUYYmGZ3TSTIMwXOALS+rYOvw61rrpuJLBaqvo5BbGmADkI9CfBLC08amCG80QmPFIcCM3Hxx/ru+hD9KxwVHfwUusrYJofjISma6sHH3JPMvY5MZGXII1yJdXJrDfKoOjhy9M6kbm13zqW/YvkwLcSis5hMWfs1UZcsMK61U/yohbNIAJvrFTJi1Mn5mPEah7gx/aSJGGqDOR76RA+y37Vmg6CsGncw6M7bbaNluy9ULA/MZyVBL2PEAWARk4i7dB7Sl1XJd3FWpfyR3H/T8KHxJGs0/Q/44bu6DTdKWa/eV/VsqN3lifCIPn3VNVNGMfu3yZk+Qd2egKcZRxiGKshIVPAMbXcXCt/U1LD8Yx/2IDZ5ZsHu5xaDuxX9F+o+41NoswrxFqY/JKjTc1t43GISmE0ANphFSUu6+OSAq6pqwmSZCGD7wm45UKo9ZkerbpmBy5kGuhcAjSSpFJT+XBqWlnOcagO3iR5vg3SYE7VlIfDT2WyA1ARHOT7b8RLH6pmR0tswaWNq1RZFob6+zTl1b+rtmPvkhenaiM5NU8DbXO9h8bBwkhH3WLQTJYUup+fDcPQBXw+UuuWjpvHa55vtTcBgZLIPdoP71lTDmZbTZeQdr7iaIyTjiFY+hApWngqElJxO+fVMyBl23mrHzmzKkO0gsxH2OuAQIDm81eEyJLJx4WDVpS261DobxJpjcnFhq5BVtKO2LbxtnceGI3nuUyhbI0Dqy7PwlyTFKzWaSrdpqzSjRryTcMdAoFUsM95MvgziL+GAloG575Eiwt3VYhkya8G9PCIdXACi+JtUD1c2rrJUnzWXug0AhFonhMeqs67E0hXPmpGEAfhYzNWvX7Am9E6ba6HQmED071EIhk9a/ZDZbfDEQ6YvurGPE3vgPOdgpHk2+wkxrHmAIJD0BApkNoTpr8U/W3ugRTLYxkaRzOtJQYgTeZ/vNoXMtAA4AFHd7+m4HevG0Y0e8ePxj+AyRGjv2Hzc3vxzCBfLUPr/hWcPeciW4pHOpuS4yE8jJwMCnOM/HQKt/krxlv8j97FEjrh62c0/CkQ1lohUhoMj5oI5ctvFOxR3eO0dU0UBhdNpYyuA4eHQVNZnxKFVm9iH5KV/X2m33Hp8TS7f0P7dPR0oh1tV5bQCe/fODsoiuWptq/K5UMPUYfCSd26IzDfSUE/J/45eUnFkQ6pJeAPi5Xgb+pY8GWytiVbEngrX7htVmxUNSd/Y7Q5MvqqftIDJjDliYgzMrCWEwHHb3Xd83QEY+osvUZbusIvndnL7pGocSrtUwK/wnrWO7mDFF8Mb55oioBjlpq25cVb4hwbCJUXn3hDfJXaZrYHr3+ZnbnRIY99P62CojNFxBPkXlnFmlokbDXVqjMKVfwWAA4JAwaPBCgUEmi0XAi093NPQe8KG8oEErE3tlREFM9xpT5rb5ei0/+Ld+YJdNQN9MBjgLtQnixrw5wbsP3XGYx1ufqjb8T76T/HIbm5ODhcvXnulb6sEPu6TgHyFD/PDujxrSWgOwfidRhUS5eTXAn9cZj3uf+5HDQZPcZLy6Goo88uCcOYmIwN/6jzja0P6lwWYhUuGzs48flRrYynLSDbkLYDFqVTD+7G49d7GUkdlNv8wKgh0Awr7+lJe8PdBfAw7INfkVWXEkXcLLQS7pen9pTDvxXBE4nvym693CpB0JOio5bBgt2AfVcQUSxnZ01oDYd9aaDLUDH4nqJy9pvoNTjd+YQ40+Z0KLAl4TaFLByKWEnVGntZs219AOxuM42SDoXHVok3+u7mquKb4iq7ru3G/kgasOtCTcmJSvSC8+l27c3LJtEcaDA886dubLIoFBeIkg7O11+s1wsN86vf5wiMLMvD0D9n7E1J/Aw2gDz3nwJo0oklJJ6GHE3HVppVAfCD7s/CjYZI2BL+qR3oXsHZUf3RWLMhukQC/5KEGKOjzfGiZQneHCyh5tJpovJ6E4RHITj4q/0qyZfIzKhXzUNJjWODyGGv+NvCNj7+Q4RMiu0pmeu8PdMiOOKG0ygt12lZfJCSsRfx2Kavq60FpiJxw9/HagMAASK2CcsI50t1my9rDgXIEBycb9q17vBK1jLGgDA9CMtNFMPQ2LPf/Jnkhc5llZrAyB08qvCQfDdv4Az1y4/L6QkUeac/aGcZi4Lsqg6Dvp8gGWWjBrwxIMCOcsJD9FlwkO4GnOghP9dAcA6HnJdsKN6jQX96UiaqQzgvmXDT2Z6ZX9t/Ntkhb/VzWVGcLBIfH+8zpOKx+cP0bDsGmpFK/gK+hScoBHBYNxifND8vQ+1rsKHgFFA45/Ge1O8Jw8IYeP5h3gR4m3khR+VRcH7KeUD61BkKBidjMtlNuU/gbW1tdH3+l79hq4MAbWtcSMR/mScMG5ris2ERg8tNx1r2z6ufvzibeSpN6Nsi9bofVsKMYt4ZqzLvuYs4WoQjE6K4+iC44drhHO+HCThxTSe9NQE2odE3TYXzJ+jGxRDKpWZqvBvajXbegi1oD+ANw80ZX1PGc5aYl5uFx+g1KDsU0WysTQ6/oRB5BDMG7KEbZnBFgI6bqhJb9zhlDhUuzqYI705ttjHw0rwYyzKpKd3R2cchvqmUouKDmLU1z3u6kTv0lqAT3bR22WWk2UQ3ZYxhlQb0WmY8mqncvYDN+qPZS4BUPDf9q+VVCzQ4TNoQFy0vIoWId+qV5L8lmpEhRKwT75EGJQ2UEsCS9LutNmehY7M5eaVM8fsRQpxmaygdNSdMR+nR/FwXB9PUKQUg6TXTpT2z8IKXoeDqiJMx3Bov7WLvb511Ljhl3m+yTv6C3Bma4s4AxNTybdLL+8vYLaI66Y03tbSBtoa8Wh+1vlR09cS3VO7k71Uh/xpcH7Ra9mpSannCvt8KRmh5oRp1PC7TBdDPgMrnwOyZ7MpnAqZq1e1bEDDSTVacT2ecFzHmTEFXPxHy+jE02/jqH/CnTGC81CGFta2FomsXYL3bZND1WXkr3qznLSfUjnWK/Tehi3jbdtGt1faYv+zrlAWDWYwvRaE4QbmxAGM9ifUHpcYT24jvd6qDCdHEX4mz3Va6/aNNXMUTi2S6JXrVRH6LnpR+RSCkRVsZwZ3p6EA2Phw5TXdbMtai8smrwgB5VmPN8WwG2KKxLD39UapUE/gRHalw5JKg9Ep1gKYWpxdlFQQTJ3nWLusKjgB69AGaWCdIuj47cInW0Vv61un6Lw7JkrUfw2muZ3pp09eN9SkZN4/3K9GbN/UeIGyI+JwvqKCJBVgIZJPK+WyUddSvIFO91nN/IxzR2ZPjIblMkuPiA+Q9oYBQDqBKM5mcrU3CW81ThrrR2tAFZvi3BbTUqagP21getVoBr/ReRtrZSdLBLJ7m7gOrHjojWR+ypvEv1aFjNv9NqDVjzDlbTZ7PKl0VizU6YDdaG2VZ65uK6uAM3D4p3/BURAkCE1cxpjwum08gRlTGZDiIm8fRORBS5/GKNKyGnT8l0MgX8rcAx8Gk39vEmdNLsico/lfvzqMyO0oXcBjK3qGiM6/ycwUmeJs88bUUQ2I3qb00A+nAG2+Lf2K8ly57dkpJiUKKzxvSYtgbo6TzWZ95CBjD5Gtl5d+BRtm8ZA1VocFk4HSZniE1LFwoNQU7ecgKQ4YFxuTQ3Bu50L6i7WA+37gDcCS/J/YQ+7BR84xT0xVAXmywloH79COn0YacGebFJO9KOGRJUjQAlK0pkXXd6siQ4gr6LrdMfvcfQIOdKvGtB2Gt3LoEd5xidb6X/eDijzSl0jJXRcitiDjEbATKYuDp2U/0Ek+EVuyeqvP6agc0rZeXFHrmhiTtUpN3wQGpGVygfylerm6hY/CeT2OxGEnHlQOB6rfejjt5SDIcVsT62fncc0nQEYvoUgcfucZYrCa4OmNXSapMoSifoIcVxEOu8GdArMJSOdfHt+DLJgv1k+kdUsXsDHm3o1hOuEmpJieJqlXkA4+ocfoiSbr4SJzihVk0qktS7Cy1mKUBD6rDfVYnyMOqCINbsS1FVWy4KQmuR6v7MhbIcYWzt81RKcRW0BuRL9JoOyHKrNODH13g5Kv6nuOrfI9fUh6BA0MQBqWxXJMJXgAEQweF1wnmbzKJmGylnLK/2WZH4Z408PMPFdOJX5bL03aZqsmr22ka1dAI9ymd2/qiK32+zzSFHjcDgOpX+g4uylELOGcoZoRElG6Vbxkc+d3SEbq+e8kaaiYsezaSwV3CIUZmwu7sVcLFdo+ePjcRfdZHOJ8evaFqN9tTGYEMjyI1IVL2xteXBrWti/Nh3ewpXE16JkxV5aDEDd9XyLJ5BEFpp8ooJZR8WzuONSKM7G1tWBlmZw49uT4QPSOUZvnOV9FQO76vQuQyvkxdU+nlTwxAQG75Oz5U+AMoB4cx9ILbBaL5MfV3YRBN0+SOhVNJYuaGI2V7aR9vluOTeGYbHQ50BJdPPIBGpLhqqrYdDHsOG3prl0XbrZjB8dsqjYSk3bYlEwFWFDAIfeXkYbpsZtqQCrw8qi1Rr245/CvM+SO961BgpnfygaqgCKFBtIAaRkP6GLAuDLNvUkUsCwWR2tXfdHJtAFmZuPqzeMFadGZ+6asrbK2mmXa/GO+QOZTIa/VeDncFXlwtAtMrfmtB67aWgqtXOhffLDYPh9WeYnGx376ZcgEEQ6I4QnTI3BcnNS/84qWZB9HQrw25c3AsmAZN4=</DEVCERT></CLIENTINFO>";

            // Exploited ClientInfo blocks provided by MusiWave
            private const string ClientInfoEmptyDevCertNode = "<CLIENTINFO><CLIENTID>AgAAAPs3HhPoNx65VHWTDciDUDNq8tUMYqzYBCrkiehLS1*HHTePZOzfC0bikKPH5mPUW*byEZzyPZ4pZJ7SaYwojGcs6sk6*uBhdRcqut*KMEUMFxpZtgfEj3Y62ALVsFM5EvVsB09NeUYl*DEohf4jT5Wht1pBcQyWZoTNYhDLVmfiInrI1F131Nzgfs!LUxLQwZyPxa6X8Ngp2!O*strkXvZ7jBJ0</CLIENTID><REVINFO></REVINFO><CLIENTVERSION>11.0.7600.16385</CLIENTVERSION><SECURITYVERSION>2.9.0.1</SECURITYVERSION><APPSECURITY>50</APPSECURITY><SUBJECTID1><DEVCERT></DEVCERT></SUBJECTID1><SUBJECTID2></SUBJECTID2></CLIENTINFO>";
            private const string ClientInfoRemoveAllCertificateNodesExceptLastOne = "<CLIENTINFO><CLIENTID>AgAAAP2*fQksLfgZShUxVCdp6XhpHqoEU2kb4Jg10Nojht3U4OJn0cliT2CYi7aq52pdfkAPuXe4MrQEzwcif6OGPC1RFT9ss!o99UU3HAlPCGMZTnpjk9rfw4EMI8ClskGu!yq4xFAB7kwp2K6cgj!t6nxZ8up6BDHGY3Tcv*AyfxcMme4cm5e7PncYOWNZNOA**RFZeAVJvfuA3XwnCASPZKQCvEvC</CLIENTID><MACHINECERTIFICATE>PGM6Q2VydGlmaWNhdGVDb2xsZWN0aW9uIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIiB4bWxuczpjPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIGM6VmVyc2lvbj0iMi4wIj48YzpDZXJ0aWZpY2F0ZSBjOlZlcnNpb249IjIuMCIgeG1sbnM6Yz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9jZXJ0Ij48YzpEYXRhIHhtbG5zPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIHhtbG5zOm09Imh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8xMS9tc2xwIj48YzpTZWN1cml0eVZlcnNpb24!NC4wLjAuMTwvYzpTZWN1cml0eVZlcnNpb24!PGM6UHVibGljS2V5PjxLZXlWYWx1ZT48UlNBS2V5VmFsdWU!PE1vZHVsdXM!d1RSNk9BdGozcnY2cTR6a01nNmpOQ0pJaGhFRW5QcDAzaHJ5ZzZKa0lkYWpyOEROa2t0UlpQMTZUczl6WlhNdFB0SUoxeWhrRk90ZHJRU2dRTmppRnZvVmZOQXJTcXB6czdkWXpaMzVDNVhFNCtCYndnczljcFU3NFBBREZPODE2bVhKWUxseDd5RHFnT2V1ZXkxN1BoVU5IbXlxTnBPaUhiOG05Y3I2T2VzPTwvTW9kdWx1cz48RXhwb25lbnQ!QVFBQjwvRXhwb25lbnQ!PC9SU0FLZXlWYWx1ZT48L0tleVZhbHVlPjwvYzpQdWJsaWNLZXk!PFZhbGlkYXRpb25NZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL2RybS8yMDA0LzAyL2NlcnQvdmFsaWRhdGVfdjIiIFZlcnNpb249IjIuMCI!PC9WYWxpZGF0aW9uTWV0aG9kPjxjOlNlY3VyaXR5TGV2ZWw!MjAwMDwvYzpTZWN1cml0eUxldmVsPjxjOktleVVzYWdlPjxjOlNpZ25DZXJ0aWZpY2F0ZT4xPC9jOlNpZ25DZXJ0aWZpY2F0ZT48L2M6S2V5VXNhZ2U!PGM6RmVhdHVyZXM!PG06V01EUk1UcmFuc21pdHRlcj4xPC9tOldNRFJNVHJhbnNtaXR0ZXI!PC9jOkZlYXR1cmVzPjxjOk1hbnVmYWN0dXJlckRhdGE!PGM6TWFudWZhY3R1cmVyTmFtZT5NaWNyb3NvZnQ8L2M6TWFudWZhY3R1cmVyTmFtZT48L2M6TWFudWZhY3R1cmVyRGF0YT48L2M6RGF0YT48U2lnbmF0dXJlIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj48U2lnbmVkSW5mbz48Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLXhtbC1jMTRuLTIwMDEwMzE1Ij48L0Nhbm9uaWNhbGl6YXRpb25NZXRob2Q!PFNpZ25hdHVyZU1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vRFJNLzIwMDQvMDIvQ0VSVC9Sc2Etc2hhMSI!PC9TaWduYXR1cmVNZXRob2Q!PFJlZmVyZW5jZT48VHJhbnNmb3Jtcz48VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9DRVJUL0RhdGEiPjwvVHJhbnNmb3JtPjxUcmFuc2Zvcm0gQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy14bWwtYzE0bi0yMDAxMDMxNSI!PC9UcmFuc2Zvcm0!PC9UcmFuc2Zvcm1zPjxEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjc2hhMSI!PC9EaWdlc3RNZXRob2Q!PERpZ2VzdFZhbHVlPlFFWmltSGQ2ZmZvUENDaFhYVXBRNFZMNzMxRT08L0RpZ2VzdFZhbHVlPjwvUmVmZXJlbmNlPjwvU2lnbmVkSW5mbz48U2lnbmF0dXJlVmFsdWU!Q3Z4MlFraEMvVEk0UHhpM1NqYkprb0JxNlcvV2JxMXhWU21HN1VsR0lRR1Qwd0lqWTgvT2RkK2tOZkpCajVIQjRQb09TSWFRNTlFNEVXaGwrVkdyejJWVXBPVjZXUnp0MlBwVmRqODltM2pHdjN6S3psZFhsTXV1ejJRT0lieG1tUUF6WnI5aHo4Z1NFeHJqcktBekt2R0VQWUFHcDhCbUVybUI2ZzdZWXQ4PTwvU2lnbmF0dXJlVmFsdWU!PEtleUluZm8!PEtleVZhbHVlPjxSU0FLZXlWYWx1ZT48TW9kdWx1cz5wam9lV0xTVExEb25RRzhTaGU2UWhrWWJZb3R0OWZQWjh0SGRCMTI4WkVUY2dobjVLSG95aW43SGtKRWNQSjBFZzRVZFN2YTBLRElZRGpBM0VYZDY5UjNDTjJXcC9ReU9vMFpQWVdZcDNOWHBKNzAwdEtQZ0lwbHpvNXdWZC82OWc3aitqOE02Nlc3Vk5tRHdhTnM5bURjMXAyK1ZWTXNEaE9zVi9BdTZFK0U9PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48L1JTQUtleVZhbHVlPjwvS2V5VmFsdWU!PC9LZXlJbmZvPjwvU2lnbmF0dXJlPjwvYzpDZXJ0aWZpY2F0ZT48L2M6Q2VydGlmaWNhdGVDb2xsZWN0aW9uPg==</MACHINECERTIFICATE><REVINFO></REVINFO><CLIENTVERSION>11.0.7600.16385</CLIENTVERSION><SECURITYVERSION>2.9.0.1</SECURITYVERSION><APPSECURITY>50</APPSECURITY><SUBJECTID1>221</SUBJECTID1><SUBJECTID2></SUBJECTID2></CLIENTINFO>";
            private const string ClientInfoHackedCertInMachineCertCertCollection = "<CLIENTINFO><CLIENTID>AgAAAP2*fQksLfgZShUxVCdp6XhpHqoEU2kb4Jg10Nojht3U4OJn0cliT2CYi7aq52pdfkAPuXe4MrQEzwcif6OGPC1RFT9ss!o99UU3HAlPCGMZTnpjk9rfw4EMI8ClskGu!yq4xFAB7kwp2K6cgj!t6nxZ8up6BDHGY3Tcv*AyfxcMme4cm5e7PncYOWNZNOA**RFZeAVJvfuA3XwnCASPZKQCvEvC</CLIENTID><MACHINECERTIFICATE>PGM6Q2VydGlmaWNhdGVDb2xsZWN0aW9uIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIiB4bWxuczpjPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIGM6VmVyc2lvbj0iMi4wIj48YzpDZXJ0aWZpY2F0ZSBjOlZlcnNpb249IjIuMCIgeG1sbnM6Yz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9jZXJ0Ij48YzpEYXRhIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIiB4bWxuczpjPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIHhtbG5zOm09Imh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9tc2xwIj48YzpTZWN1cml0eVZlcnNpb24+My45LjAuMTwvYzpTZWN1cml0eVZlcnNpb24+PGM6UHVibGljS2V5PjxLZXlWYWx1ZT48UlNBS2V5VmFsdWU+PE1vZHVsdXM+dVlsVElFVnFobk1FNUUrVjAwSHdiZ1IxVmNJV0J3bFFwajFIM21ib3JUclhmdk5WenlrVm0xZFQ0bmVlZzdwNEtMd2dnWjRPVzBGYVU5YVBVV096Wm9wZDhWYkV3SmpnN1REZVJ2c3hhdGo2cW5vQ05wV0l0R2p6V2N3djFBdE96NjRjL3FyTkJ1MUVwNG55UTUyK3htNE5MbzRrWXRESm41b0JjdlR0ODBzPTwvTW9kdWx1cz48RXhwb25lbnQ+QVFBQjwvRXhwb25lbnQ+PC9SU0FLZXlWYWx1ZT48L0tleVZhbHVlPjwvYzpQdWJsaWNLZXk+PGM6UEtDZXJ0PmtZbVBrQTZtZzJrTm5zeTd6V3NjY0srMy9WcGFJbTRjcC9nNG5OanBxbFIrbmh1YkFCZHVWUUlKQUFHNTg5RDVDa2V0TFk5ZFozVDMwbS93WDB5UVhRYjRLd3JZQytST2w0WWRnaUxKMWgxbHlvcGE8L2M6UEtDZXJ0PjxjOlBLU2lnbmluZ0NlcnQ+UHVWdWtHQVVRVjJFU0tKV0l2TzRTSDhIQzB1cjJYUFBhNXVyZkRwLzJCNzg2ZnhOMjZzc1pBSUpBQUdKa1ZuaWVCMVlaN012cjhMTDkyWUdKZ2ttYVlBR0dWcjFJekhxdEJ4T0VtOTRpWWQrM0F3azwvYzpQS1NpZ25pbmdDZXJ0PjxjOkhhcmR3YXJlSUQ+cDFmSm1sQ2dMV1pkVkR1MVZGTVRCZ1JnRUU4PTwvYzpIYXJkd2FyZUlEPjxjOlNlY3VyaXR5TGV2ZWw+MjAwMDwvYzpTZWN1cml0eUxldmVsPjxjOktleVVzYWdlPjxjOkVuY3J5cHRLZXk+MTwvYzpFbmNyeXB0S2V5PjwvYzpLZXlVc2FnZT48YzpGZWF0dXJlcz48YzpXTURSTVRyYW5zbWl0dGVyPjE8L2M6V01EUk1UcmFuc21pdHRlcj48YzpXTURSTVJlY2VpdmVyPjE8L2M6V01EUk1SZWNlaXZlcj48YzpXTURSTVNoYXJlZENlcnRpZmljYXRlPjE8L2M6V01EUk1TaGFyZWRDZXJ0aWZpY2F0ZT48L2M6RmVhdHVyZXM+PGM6TWFudWZhY3R1cmVyRGF0YT48YzpNYW51ZmFjdHVyZXJOYW1lPlVua25vd248L2M6TWFudWZhY3R1cmVyTmFtZT48YzpNb2RlbE5hbWU+VW5rbm93bjwvYzpNb2RlbE5hbWU+PGM6TW9kZWxOdW1iZXI+VW5rbm93bjwvYzpNb2RlbE51bWJlcj48L2M6TWFudWZhY3R1cmVyRGF0YT48L2M6RGF0YT48U2lnbmF0dXJlIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj48U2lnbmVkSW5mbz48Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLXhtbC1jMTRuLTIwMDEwMzE1Ij48L0Nhbm9uaWNhbGl6YXRpb25NZXRob2Q+PFNpZ25hdHVyZU1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vRFJNLzIwMDQvMDIvQ0VSVC9Sc2Etc2hhMSI+PC9TaWduYXR1cmVNZXRob2Q+PFJlZmVyZW5jZT48VHJhbnNmb3Jtcz48VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9DRVJUL0RhdGEiPjwvVHJhbnNmb3JtPjxUcmFuc2Zvcm0gQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy14bWwtYzE0bi0yMDAxMDMxNSI+PC9UcmFuc2Zvcm0+PC9UcmFuc2Zvcm1zPjxEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjc2hhMSI+PC9EaWdlc3RNZXRob2Q+PERpZ2VzdFZhbHVlPmhjaVJQYm5HVDhWMGJWUkFBcml3RTFxNy9TND08L0RpZ2VzdFZhbHVlPjwvUmVmZXJlbmNlPjwvU2lnbmVkSW5mbz48U2lnbmF0dXJlVmFsdWU+QjBtZVhnM2tMYXc1RlNuU0pjSzRTbFVERjY4QThaSDAwWVh5eTc1MEh1TUU5czlpWXRRRHJiUnVGdEhaVkdGZnNTZ29QL0xDRm9wN3lyN3JxL1RwbDFxelJTVS9JNFFibDdoWm9lVUFQcjBKVGptYXg1aVBKcFY5ZURKUlRydlJPRzR6QlA4WnIyMUVXdmNqcnY4TGc4akVET0E5MzJnak1oTnkzbWtJV1hJPTwvU2lnbmF0dXJlVmFsdWU+PEtleUluZm8+PEtleVZhbHVlPjxSU0FLZXlWYWx1ZT48TW9kdWx1cz50M2o1cGFFa0JLL1pFWW1IZis1SEVUVWkzSmFaZ2xreDNPbU1oOThWQllOeW9sR1EwTUpFMFgwS3dYdnVWMGRxR2JGK2ZlcEJON0c1RC9uOTE4RDdiUy9ROTZyNGYzOXFrSkRlUk1hbTg1K3p5aUhOQWpBbUdvWG44bWliUTlkZk9CZXdUUlluVVJBVEVlTHRMR01TaGJnSytESHN6WDJyUzdrUU4xYUVUOWM9PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48L1JTQUtleVZhbHVlPjwvS2V5VmFsdWU+PC9LZXlJbmZvPjwvU2lnbmF0dXJlPjwvYzpDZXJ0aWZpY2F0ZT48YzpDZXJ0aWZpY2F0ZSBjOlZlcnNpb249IjIuMCIgeG1sbnM6Yz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9jZXJ0Ij48YzpEYXRhIHhtbG5zPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIHhtbG5zOm09Imh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8xMS9tc2xwIj48YzpTZWN1cml0eVZlcnNpb24+My44LjAuMTwvYzpTZWN1cml0eVZlcnNpb24+PGM6UHVibGljS2V5PjxLZXlWYWx1ZT48UlNBS2V5VmFsdWU+PE1vZHVsdXM+dDNqNXBhRWtCSy9aRVltSGYrNUhFVFVpM0phWmdsa3gzT21NaDk4VkJZTnlvbEdRME1KRTBYMEt3WHZ1VjBkcUdiRitmZXBCTjdHNUQvbjkxOEQ3YlMvUTk2cjRmMzlxa0pEZVJNYW04NSt6eWlITkFqQW1Hb1huOG1pYlE5ZGZPQmV3VFJZblVSQVRFZUx0TEdNU2hiZ0srREhzelgyclM3a1FOMWFFVDljPTwvTW9kdWx1cz48RXhwb25lbnQ+QVFBQjwvRXhwb25lbnQ+PC9SU0FLZXlWYWx1ZT48L0tleVZhbHVlPjwvYzpQdWJsaWNLZXk+PFZhbGlkYXRpb25NZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL2RybS8yMDA0LzAyL2NlcnQvdmFsaWRhdGVfdjIiIFZlcnNpb249IjIuMCI+PC9WYWxpZGF0aW9uTWV0aG9kPjxjOlNlY3VyaXR5TGV2ZWw+MjAwMDwvYzpTZWN1cml0eUxldmVsPjxjOktleVVzYWdlPjxjOlNpZ25DZXJ0aWZpY2F0ZT4xPC9jOlNpZ25DZXJ0aWZpY2F0ZT48L2M6S2V5VXNhZ2U+PGM6RmVhdHVyZXM+PG06V01EUk1UcmFuc21pdHRlcj4xPC9tOldNRFJNVHJhbnNtaXR0ZXI+PC9jOkZlYXR1cmVzPjxjOk1hbnVmYWN0dXJlckRhdGE+PGM6TWFudWZhY3R1cmVyTmFtZT5NaWNyb3NvZnQ8L2M6TWFudWZhY3R1cmVyTmFtZT48L2M6TWFudWZhY3R1cmVyRGF0YT48L2M6RGF0YT48U2lnbmF0dXJlIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj48U2lnbmVkSW5mbz48Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLXhtbC1jMTRuLTIwMDEwMzE1Ij48L0Nhbm9uaWNhbGl6YXRpb25NZXRob2Q+PFNpZ25hdHVyZU1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vRFJNLzIwMDQvMDIvQ0VSVC9Sc2Etc2hhMSI+PC9TaWduYXR1cmVNZXRob2Q+PFJlZmVyZW5jZT48VHJhbnNmb3Jtcz48VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9DRVJUL0RhdGEiPjwvVHJhbnNmb3JtPjxUcmFuc2Zvcm0gQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy14bWwtYzE0bi0yMDAxMDMxNSI+PC9UcmFuc2Zvcm0+PC9UcmFuc2Zvcm1zPjxEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjc2hhMSI+PC9EaWdlc3RNZXRob2Q+PERpZ2VzdFZhbHVlPjJjRmtmYkNYQ21GSS9jSXF0SGpEenF2UTZpRT08L0RpZ2VzdFZhbHVlPjwvUmVmZXJlbmNlPjwvU2lnbmVkSW5mbz48U2lnbmF0dXJlVmFsdWU+TzRWWUVHWjBMdElzQ01LcUYyd2ROMG9TMmdIS2g2cUV4cEN2ZWp3TWphTndVc1dHRVAwbVZocWp0eVprOWp1ZHRodFBqdERHUERnMERMNWcxOHNtMWgvUHJlcHF1SFVia0NPejU5YUhIRGZqRXMyYVFZbW5hbnRmeFFEWWQxQnJBc25Sa3Flbk1RWWFPS1J3dWlycitXMWxNblVUZXYvUzN5aGtNYXBuZkYwPTwvU2lnbmF0dXJlVmFsdWU+PEtleUluZm8+PEtleVZhbHVlPjxSU0FLZXlWYWx1ZT48TW9kdWx1cz53VFI2T0F0ajNydjZxNHprTWc2ak5DSkloaEVFblBwMDNocnlnNkprSWRhanI4RE5ra3RSWlAxNlRzOXpaWE10UHRJSjF5aGtGT3RkclFTZ1FOamlGdm9WZk5BclNxcHpzN2RZelozNUM1WEU0K0Jid2dzOWNwVTc0UEFERk84MTZtWEpZTGx4N3lEcWdPZXVleTE3UGhVTkhteXFOcE9pSGI4bTljcjZPZXM9PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48L1JTQUtleVZhbHVlPjwvS2V5VmFsdWU+PC9LZXlJbmZvPjwvU2lnbmF0dXJlPjwvYzpDZXJ0aWZpY2F0ZT48YzpDZXJ0aWZpY2F0ZSBjOlZlcnNpb249IjIuMCIgeG1sbnM6Yz0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9jZXJ0Ij48YzpEYXRhIHhtbG5zPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL0RSTS8yMDA0LzAyL2NlcnQiIHhtbG5zOm09Imh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8xMS9tc2xwIj48YzpTZWN1cml0eVZlcnNpb24+NC4wLjAuMTwvYzpTZWN1cml0eVZlcnNpb24+PGM6UHVibGljS2V5PjxLZXlWYWx1ZT48UlNBS2V5VmFsdWU+PE1vZHVsdXM+d1RSNk9BdGozcnY2cTR6a01nNmpOQ0pJaGhFRW5QcDAzaHJ5ZzZKa0lkYWpyOEROa2t0UlpQMTZUczl6WlhNdFB0SUoxeWhrRk90ZHJRU2dRTmppRnZvVmZOQXJTcXB6czdkWXpaMzVDNVhFNCtCYndnczljcFU3NFBBREZPODE2bVhKWUxseDd5RHFnT2V1ZXkxN1BoVU5IbXlxTnBPaUhiOG05Y3I2T2VzPTwvTW9kdWx1cz48RXhwb25lbnQ+QVFBQjwvRXhwb25lbnQ+PC9SU0FLZXlWYWx1ZT48L0tleVZhbHVlPjwvYzpQdWJsaWNLZXk+PFZhbGlkYXRpb25NZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL2RybS8yMDA0LzAyL2NlcnQvdmFsaWRhdGVfdjIiIFZlcnNpb249IjIuMCI+PC9WYWxpZGF0aW9uTWV0aG9kPjxjOlNlY3VyaXR5TGV2ZWw+MjAwMDwvYzpTZWN1cml0eUxldmVsPjxjOktleVVzYWdlPjxjOlNpZ25DZXJ0aWZpY2F0ZT4xPC9jOlNpZ25DZXJ0aWZpY2F0ZT48L2M6S2V5VXNhZ2U+PGM6RmVhdHVyZXM+PG06V01EUk1UcmFuc21pdHRlcj4xPC9tOldNRFJNVHJhbnNtaXR0ZXI+PC9jOkZlYXR1cmVzPjxjOk1hbnVmYWN0dXJlckRhdGE+PGM6TWFudWZhY3R1cmVyTmFtZT5NaWNyb3NvZnQ8L2M6TWFudWZhY3R1cmVyTmFtZT48L2M6TWFudWZhY3R1cmVyRGF0YT48L2M6RGF0YT48U2lnbmF0dXJlIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjIj48U2lnbmVkSW5mbz48Q2Fub25pY2FsaXphdGlvbk1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDEvUkVDLXhtbC1jMTRuLTIwMDEwMzE1Ij48L0Nhbm9uaWNhbGl6YXRpb25NZXRob2Q+PFNpZ25hdHVyZU1ldGhvZCBBbGdvcml0aG09Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vRFJNLzIwMDQvMDIvQ0VSVC9Sc2Etc2hhMSI+PC9TaWduYXR1cmVNZXRob2Q+PFJlZmVyZW5jZT48VHJhbnNmb3Jtcz48VHJhbnNmb3JtIEFsZ29yaXRobT0iaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9EUk0vMjAwNC8wMi9DRVJUL0RhdGEiPjwvVHJhbnNmb3JtPjxUcmFuc2Zvcm0gQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy14bWwtYzE0bi0yMDAxMDMxNSI+PC9UcmFuc2Zvcm0+PC9UcmFuc2Zvcm1zPjxEaWdlc3RNZXRob2QgQWxnb3JpdGhtPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzA5L3htbGRzaWcjc2hhMSI+PC9EaWdlc3RNZXRob2Q+PERpZ2VzdFZhbHVlPlFFWmltSGQ2ZmZvUENDaFhYVXBRNFZMNzMxRT08L0RpZ2VzdFZhbHVlPjwvUmVmZXJlbmNlPjwvU2lnbmVkSW5mbz48U2lnbmF0dXJlVmFsdWU+Q3Z4MlFraEMvVEk0UHhpM1NqYkprb0JxNlcvV2JxMXhWU21HN1VsR0lRR1Qwd0lqWTgvT2RkK2tOZkpCajVIQjRQb09TSWFRNTlFNEVXaGwrVkdyejJWVXBPVjZXUnp0MlBwVmRqODltM2pHdjN6S3psZFhsTXV1ejJRT0lieG1tUUF6WnI5aHo4Z1NFeHJqcktBekt2R0VQWUFHcDhCbUVybUI2ZzdZWXQ4PTwvU2lnbmF0dXJlVmFsdWU+PEtleUluZm8+PEtleVZhbHVlPjxSU0FLZXlWYWx1ZT48TW9kdWx1cz5wam9lV0xTVExEb25RRzhTaGU2UWhrWWJZb3R0OWZQWjh0SGRCMTI4WkVUY2dobjVLSG95aW43SGtKRWNQSjBFZzRVZFN2YTBLRElZRGpBM0VYZDY5UjNDTjJXcC9ReU9vMFpQWVdZcDNOWHBKNzAwdEtQZ0lwbHpvNXdWZC82OWc3aitqOE02Nlc3Vk5tRHdhTnM5bURjMXAyK1ZWTXNEaE9zVi9BdTZFK0U9PC9Nb2R1bHVzPjxFeHBvbmVudD5BUUFCPC9FeHBvbmVudD48L1JTQUtleVZhbHVlPjwvS2V5VmFsdWU+PC9LZXlJbmZvPjwvU2lnbmF0dXJlPjwvYzpDZXJ0aWZpY2F0ZT48L2M6Q2VydGlmaWNhdGVDb2xsZWN0aW9uPg==</MACHINECERTIFICATE><REVINFO></REVINFO><CLIENTVERSION>11.0.7600.16385</CLIENTVERSION><SECURITYVERSION>2.9.0.1</SECURITYVERSION><APPSECURITY>50</APPSECURITY><SUBJECTID1>221</SUBJECTID1><SUBJECTID2></SUBJECTID2></CLIENTINFO>";
            [TestGroup]
            public class Xbox360 : TestNode
            {
                [TestCase, TestCasePriority(1)]
                [Description("Purchase a piece of DTO content and verifies the license can be acquired")]
                public class P_Acquire_DTO : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();
                        helper.PurchaseVideo(LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode);
                    }

                    public override void Run()
                    {
                        helper.AcquireMediaLicense();
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(1)]
                [Description("Purchase a piece of PPV content and verifies the license can be acquired")]
                public class P_Acquire_PPV : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();
                        helper.PurchaseVideo(LicenseType.SyncCastPPV, MediaTypeInfo.Movie);
                    }

                    public override void Run()
                    {
                        helper.AcquireMediaLicense();
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(1)]
                [Description("Purchase a piece of PPV content and verifies the license can be acquired and acknowledged")]
                public class P_Acknowledge_PPV : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();
                        helper.PurchaseVideo(LicenseType.SyncCastPPV, MediaTypeInfo.Movie);
                    }

                    public override void Run()
                    {
                        helper.AcquireMediaLicense();
                        helper.AcknowledgeMediaLicense();
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(1)]
                [Description("Purchase a piece of DTO and PPV content, acquire for both then acknowledge PPV")]
                public class P_Acquire_DTO_PPV_Acknowledge : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();
                        helper.PurchaseVideo(LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode);
                        helper.PurchaseVideo(LicenseType.SyncCastPPV, MediaTypeInfo.Movie);
                    }

                    public override void Run()
                    {
                        // Acquire license for both
                        helper.AcquireMediaLicense();
                        // Acknowledge the PPV license
                        helper.AcknowledgeMediaLicense();
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(1)]
                [Description("Purchase and acquire licenses for multiple pieces of DTO content")]
                public class P_Acquire_Multiple_DTO : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();
                        helper.PurchaseVideo(LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode, 3);
                    }

                    public override void Run()
                    {
                        helper.AcquireMediaLicense();
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(1)]
                [Description("Purchase, acquire, and acknowledge licenses for multiple pieces of PPV content")]
                public class P_AcquireAcknowledge_Multiple_PPV : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();
                        helper.PurchaseVideo(LicenseType.SyncCastPPV, MediaTypeInfo.Movie, 3);
                    }

                    public override void Run()
                    {
                        helper.AcquireMediaLicense();
                        helper.AcknowledgeMediaLicense();
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(1)]
                [Description("Purchase a piece of DTO content and verifies the license can be acquired twice")]
                public class P_Acquire_DTO_Twice : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();
                        helper.PurchaseVideo(LicenseType.SyncCastDTO, MediaTypeInfo.Movie);
                    }

                    public override void Run()
                    {
                        helper.AcquireMediaLicense();
                        helper.AcquireMediaLicense();
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(1)]
                [Description("Purchase a piece of PPV content and verifies the license can be acquired twice then and acknowledged")]
                public class P_Acquire_PPV_Twice_Acknowledge : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();
                        helper.PurchaseVideo(LicenseType.SyncCastPPV, MediaTypeInfo.Movie);
                    }

                    public override void Run()
                    {
                        helper.AcquireMediaLicense();
                        helper.AcquireMediaLicense();
                        helper.AcknowledgeMediaLicense();
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(1)]
                [Description("Purchase, acquire, and ack a piece of PPV content then attempt to acquire again")]
                public class P_AcquireAck_PPV_Reacquire : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();
                        helper.PurchaseVideo(LicenseType.SyncCastPPV, MediaTypeInfo.Movie);
                    }

                    public override void Run()
                    {
                        helper.AcquireMediaLicense();
                        helper.AcknowledgeMediaLicense();

                        helper.AcquireMediaLicense(0x80070005);
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(1)]
                [Description("Purchase, acquire, and ack a piece of PPV content then repeat")]
                public class P_Repurchase_PPV : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();
                        helper.PurchaseVideo(LicenseType.SyncCastPPV, MediaTypeInfo.Movie);
                    }

                    public override void Run()
                    {
                        helper.AcquireMediaLicense();
                        helper.AcknowledgeMediaLicense();

                        // NOTE: This step does not work, need to figure out whan purchase 
                        // updates so that reaquire can work properly

                        // Then repurchase the same video and acquire and acknowledge it
                        // To simulate the repurchase, we just update the purchase date to now
                        UserCommercedbWS.UpdatePPVPurchasedDate(helper.UserPuid, DateTime.UtcNow);
                        helper.AcquireMediaLicense();
                        helper.AcknowledgeMediaLicense();
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [CompoundCase("DTO_PurchaseHDGetSD", LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode, true)]
                [CompoundCase("DTO_PurchaseSDDontGetHD", LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode, false)]
                [CompoundCase("PPV_PurchaseHDGetSD", LicenseType.SyncCastPPV, MediaTypeInfo.Movie, true)]
                [CompoundCase("PPV_PurchaseSDDontGetHD", LicenseType.SyncCastPPV, MediaTypeInfo.Movie, false)]
                [TestCase, TestCasePriority(2), Description("Purchases a piece of HD content and ensures that the SD content is also recieved")]
                public class P_MultipleMediaInstances : TestNode
                {
                    VideoInformation hdOffer;
                    VideoInformation sdInstance;
                    VideoInformation sdOffer;


                    AcquireMediaLicenseHelper helper;
                    LicenseType licenseType;
                    Boolean purchaseHd;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();

                        // NOTE: We don't actually care about the type of the content involved, we're just checking
                        // that the license are available as expected, we just use the HD/SD moniker as it's an easy
                        // way to differentiate between the pieces of content and we can ensure we get the results
                        // that we're expecting easily

                        licenseType = (LicenseType)MyValues[0];
                        Int32 mediaType = (Int32)MyValues[1];
                        purchaseHd = (Boolean)MyValues[2];

                        // Generate a piece of DTO HD Content
                        hdOffer = VideoInformation.Generate(licenseType, mediaType, true);
                        // This generates a new media instance that associated with the same 
                        // offer and offerInstance and populates it in the database
                        sdInstance = (VideoInformation)hdOffer.GenerateNewMediaInstance();
                        // Now generate a new offer for this specific (SD) piece of content
                        sdOffer = (VideoInformation)sdInstance.GenerateNewOffer();

                        helper.Purchase(purchaseHd ? hdOffer : sdOffer);
                    }

                    public override void Run()
                    {
                        if (purchaseHd)
                        {
                            // Attempt to acquire a license for the HD instance and the SD instance
                            helper.AcquireMediaLicense(hdOffer, sdInstance);
                        }
                        else
                        {
                            // Attempt to acquire a license for the 
                            helper.AcquireMediaLicense(new VideoInformation[] { hdOffer, sdOffer },
                                                                   new uint[] { 0x80070005, 0x0 });
                        }

                        if (licenseType == LicenseType.SyncCastPPV)
                        {
                            // Juck ack which ever offer was actually purchase
                            helper.AcknowledgeMediaLicense();
                        }
                    }

                    public override void PostRun()
                    {
                        helper.AddPurchasedItem(hdOffer);
                        helper.AddPurchasedItem(sdInstance);
                        helper.AddPurchasedItem(sdOffer);

                        helper.Cleanup();
                    }
                }

                [CompoundCase("DTO", LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode)]
                [CompoundCase("PPV", LicenseType.SyncCastPPV, MediaTypeInfo.Movie)]
                [TestCase, TestCasePriority(2), Description("Purchases a DTO media item, then acquires the license on a second machine.")]
                public class P_Acquire_SecondClient : TestNode
                {
                    AcquireMediaLicenseHelper helper;
                    AcquireMediaLicenseHelper secondHelper;
                    VideoInformation video = null;

                    LicenseType licenseType;
                    Int32 mediaType;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();

                        // Create a new client but use the same user
                        secondHelper = new AcquireMediaLicenseHelper(null, helper.User);
                        // We don't want to overwrite the user
                        secondHelper.Reset(false);

                        licenseType = (LicenseType)MyValues[0];
                        mediaType = (Int32)MyValues[1];

                        // Purchase the media on the first client
                        video = helper.PurchaseVideo(licenseType, mediaType, VideoQuality.HD);
                    }

                    public override void Run()
                    {
                        // The attempt to acquire the license one the second client
                        secondHelper.AddPurchasedItem(video);
                        secondHelper.AcquireMediaLicense();
                        if (licenseType == LicenseType.SyncCastPPV)
                        {
                            secondHelper.AcknowledgeMediaLicense();
                        }
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(2), Description("Purchases a piece of DTO content, then attempts to acquire a license for that content and a piece of non-purchased PPV content.")]
                public class P_Acquire_ValidDTO_InvalidPPV : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();

                        helper.PurchaseVideo(LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode, VideoQuality.HD);

                        // Generate a movie
                        VideoInformation movie = VideoInformation.Generate(LicenseType.SyncCastPPV, MediaTypeInfo.Movie);
                        // Add it to the helper, but don't actually purchase
                        helper.AddPurchasedItem(movie);
                    }

                    public override void Run()
                    {
                        // TV should succeed, Movie should fail
                        helper.AcquireMediaLicense(0x0, 0x80070005);
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(2), Description("Purchases a piece of DTO content without using an associated machine puid, then acquires a license for that content.")]
                public class P_Acquire_DTO_Delayed_License : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();

                        // Purchase and add a TV show without using the machine puid
                        List<VideoInformation> tvOffers = new List<VideoInformation> 
                        { 
                            VideoInformation.Generate(LicenseType.SyncCastPPV, MediaTypeInfo.TVEpisode) 
                        };
                        helper.Purchase(helper.UserPuid, 0, tvOffers.ToArray());
                    }

                    public override void Run()
                    {
                        // The acquire call should succeed
                        helper.AcquireMediaLicense(0x0);

                        // Todo: Additional verification of result.  We need to make sure that
                        // the machine puid stored in the database for this license is the one
                        // that's expected
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, Description("Verifies that a license can still be acquired after a license transfer.")]
                public class P_Acquire_DTO_After_LicenseTransfer : TestNode
                {
                    AcquireMediaLicenseHelper helper1;
                    AcquireMediaLicenseHelper helper2;
                    VideoInformation episode = null;

                    public override void PreRun()
                    {
                        helper1 = new AcquireMediaLicenseHelper();
                        helper1.Reset();

                        helper2 = new AcquireMediaLicenseHelper(helper1.User);
                        helper2.Reset(false);

                        episode = helper1.PurchaseVideo(LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode, VideoQuality.HD);
                    }

                    public override void Run()
                    {
                        Global.RO.Info("Acquiring on first machine...");
                        helper1.AcquireMediaLicense();

                        Global.RO.Info("Acquiring on second machine...");
                        helper2.AddPurchasedItem(episode);
                        helper2.AcquireMediaLicense();

                        Global.RO.Info("Migrating license to second machine...");
                        LicenseMigration.LicensesState state = new SigTest.LicenseMigration.LicensesState();
                        state.Update_BuyVideo(episode.OfferId, helper1.UserPuid, helper1.MachinePuid);

                        LicenseMigration.LicenseMigrationUtils.XrlSimpleTransferLicenses(
                            helper1.UserPuid,
                            helper2.Machine.ConsoleId,
                            helper2.MachinePuid,
                            state);

                        Global.RO.Info("Acquiring on first machine");
                        helper1.AcquireMediaLicense();

                        Global.RO.Info("Acquiring on second machine");
                        helper2.AcquireMediaLicense();
                    }
                }

                [TestCase, TestCasePriority(2)]
                [CompoundCase("OutOfCountry", "24.36.22.55", false, "Stoney Creek, ON, Canada", true)]
                [CompoundCase("OutOfCountry_NotGeofenced", "24.36.22.55", true, "Stoney Creek, ON, Canada", false)]
                [CompoundCase("MappedTerritory_PuertoRico", "24.42.0.0", true, "Pureto Rico, USA", true)]
                [CompoundCase("MappedTerritory_Guam", "116.68.0.0", true, "Guam, USA", true)]
                [CompoundCase("UnknownLocation", "1.1.1.1", true, "Unknown Location", true)]
                [Description("Verifies various geofencing scenarios for AcquireMediaLicenses")]
                public class P_Acquire_Geofenced : TestNode
                {
                    AcquireMediaLicenseHelper helper;
                    VideoInformation episode;

                    public override void PreRun()
                    {
                        Boolean shouldGeofence = (Boolean)MyValues[3];

                        // Generate a piece of geofenced (or not) content
                        episode = VideoInformation.Generate(LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode, false);
                        episode.GeoCheckPolicy = shouldGeofence ? GeoCheckPolicy.GeoFence : GeoCheckPolicy.DoNotGeoFence;
                        episode.InsertIntoCatalog();

                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();
                        helper.Purchase(episode);
                    }

                    public override void Run()
                    {
                        // Check if geofencing is enabled
                        if (!Global.XEnv.GetBoolSetting("geofencing_videoGeoFencingEnabled"))
                        {
                            throw new DidNotExecuteException("Video GeoFencing is not enabled, unable to run geofencing test.  Check geofencing_videoGeoFencingEnabled");
                        }

                        Global.RO.Info("Verifying acquire works properly...");
                        // Make sure it works normally
                        helper.AcquireMediaLicense();
                        Global.RO.Info("Acquired a media license normally.");


                        String ipAddressString = (String)MyValues[0];
                        Boolean shouldSucceed = (Boolean)MyValues[1];
                        String newLocation = (String)MyValues[2];

                        var acquire = Signature.GenerateAcquireMediaLicensesRequest(helper.UserPuid, episode.MediaInstanceIdOfferIdPair);

                        Global.RO.Info("'Moving' to {0}[{1}]...", newLocation, ipAddressString);
                        // Set the IP address to the one provided
                        acquire.Slot.ipaI = BitConverter.ToUInt32(IPAddress.Parse(ipAddressString).GetAddressBytes(), 0);

                        if (acquire.Execute(helper.MachinePuid))
                        {
                            if (shouldSucceed)
                            {
                                Global.RO.Success("Request succeeded as expected");
                            }
                            else
                            {
                                throw new UnexpectedTestResultException("Expected AcquireMediaLicenses call to fail.");
                            }
                        }
                        else
                        {
                            // If it should fail
                            if (!shouldSucceed)
                            {
                                // Make sure that we got the geo fence failure
                                ValueCheck.Test<HResult, HResult>("HResult", HResult.XONLINE_E_GEO_DENIED, acquire.XErr);
                                Global.RO.Success("Request failed as expected with geofenced request.");
                            }
                            else
                            {
                                // It should have succeeded but it failed
                                throw new UnexpectedTestResultException("AcquireMediaLicense call failed: " + acquire.GetDumpString());
                            }
                        }
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(3), Description("Verifies that acquiring which updates machine puid, calls the billing history flush")]
                public class P_Acquire_DTO_History_Flush : TestNode
                {
                    AcquireMediaLicenseHelper helper;
                    VideoInformation episode = null;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();

                        episode = VideoInformation.Generate(LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode);
                        helper.Purchase(helper.UserPuid, 0, episode);
                    }

                    public override void Run()
                    {
                        Int32 historyCount = 0;

                        try
                        {
                            //make a call to get the billing history.. this will cause the current state to be cached
                            historyCount = Utils.GetUserHistoryBillingCount(helper.UserPuid, helper.MachinePuid);
                            ValueCheck.Test("Purchase History Count", 1, historyCount);
                        }
                        catch (Exception e)
                        {
                            throw new DidNotExecuteException("Unable to get user billing history", e);
                        }

                        //add joust to the users' purchases
                        Global.RO.Debug("Adding joust to the User's purchases.");
                        UserEditor userEditor = UserEditor.FromPuid(helper.UserPuid);
                        userEditor.AddPurchasedLicense(0x584107D800000001, helper.MachinePuid);

                        //make the call to get the billing history.. it should hit the cache and return 1 still
                        historyCount = Utils.GetUserHistoryBillingCount(helper.UserPuid, helper.MachinePuid);
                        ValueCheck.Test("Purchase History Count", 1, historyCount);

                        //call the acquire
                        helper.AcquireMediaLicense();

                        //make the call to get the billing history again.. the cache should have been flushed by the acquire, so we'll have the real value now.
                        historyCount = Utils.GetUserHistoryBillingCount(helper.UserPuid, helper.MachinePuid);
                        ValueCheck.Test("Purchase History Count", 2, historyCount);
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                // Negative Test Cases
                [TestCase, TestCasePriority(2), Description("Verifies that a license can't be acquired for an invalid MIID.")]
                public class N_Acquire_InvalidMIID : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();
                    }

                    public override void Run()
                    {
                        MediaInstanceIdOfferIdPair[] mioids = new MediaInstanceIdOfferIdPair[]
                        {
                            new MediaInstanceIdOfferIdPair
                            {
                                miid = new Guid("11111111-1111-1111-1111-111111111111"),
                                oid = new Guid("11111111-1111-1111-1111-111111111111"),
                            },
                        };

                        helper.AcquireMediaLicense(mioids, new uint[] { 0x80070005 });
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(2), Description("Verifies that a license can't be acknowledged for an invalid MIID.")]
                public class N_Acknowledge_InvalidMIID : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();
                    }

                    public override void Run()
                    {
                        MediaInstanceIdOfferIdPair[] mioids = new MediaInstanceIdOfferIdPair[1]
                        {
                            new MediaInstanceIdOfferIdPair
                            {
                                miid = new Guid("11111111-1111-1111-1111-111111111111"),
                                oid = new Guid("11111111-1111-1111-1111-111111111111"),
                            },
                        };

                        helper.AcknowledgeMediaLicense(mioids, new uint[] { 0x80070005 });
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(3), Description("Verifies that a license can't be acknowledged for a piece of purchased DTO content.")]
                public class N_Acknowledge_DTO : TestNode
                {
                    AcquireMediaLicenseHelper helper;
                    List<VideoInformation> tvOffer;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();

                        // Get a DTO offer
                        tvOffer = helper.PurchaseVideo(LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode, VideoQuality.HD, 1);
                    }

                    public override void Run()
                    {
                        // Then acquire a license
                        helper.AcquireMediaLicense();

                        // Then attempt to acknowledge it (we don't need to ack DTO media)
                        // We need to explicitly state the media because by defualt we only ack
                        // PPV media.  This behavior may have to be changed.
                        helper.AcknowledgeMediaLicense(tvOffer, new uint[] { 0x80070005 });
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(3)]
                [CompoundCase("DTO_NoPurchase", 1, 0, true, false)]
                [CompoundCase("PPV_NoPurchase", 0, 1, true, false)]
                [CompoundCase("DTO_Multiple_NoPurchase", 2, 0, true, false)]
                [CompoundCase("PPV_Multiple_NoPurchase", 0, 2, true, false)]
                [CompoundCase("DTOPPV_Multiple_NoPurchase", 1, 1, true, false)]
                public class N_Acquire_NoPurchase : TestNode
                {
                    AcquireMediaLicenseHelper helper;
                    List<VideoInformation> media = null;

                    public override void PreRun()
                    {
                        Int32 dtoCount = (Int32)MyValues[0];
                        Int32 ppvCount = (Int32)MyValues[1];
                        Boolean shouldAcquire = (Boolean)MyValues[2];
                        Boolean shouldAck = (Boolean)MyValues[3];

                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();

                        media = new List<VideoInformation>();

                        for (int i = 0; i < dtoCount; i++)
                        {
                            media.Add(VideoInformation.Generate(LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode));
                        }

                        for (int i = 0; i < ppvCount; i++)
                        {
                            media.Add(VideoInformation.Generate(LicenseType.SyncCastPPV, MediaTypeInfo.Movie));
                        }
                    }

                    public override void Run()
                    {
                        // Then attempt to acquire it without purchasing it
                        helper.AcquireMediaLicense(media, Enumerable.Repeat(0x80070005, media.Count).ToArray());
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(3), Description("Verifies that a license can't be acknowledged for a piece of PPV content not purchased.")]
                public class N_Acknowledge_PPV_NoPurchase : TestNode
                {
                    AcquireMediaLicenseHelper helper;
                    List<VideoInformation> movieOffer;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();

                        // Get a PPV offer
                        movieOffer = new List<VideoInformation> { VideoInformation.Generate(LicenseType.SyncCastPPV, MediaTypeInfo.Movie) };
                    }

                    public override void Run()
                    {
                        // Then attempt to acknowledge it it without purchasing it
                        helper.AcknowledgeMediaLicense(movieOffer, new uint[] { 0x80070005 });
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase(144865, BugDatabase="ISS All"), TestCasePriority(2)]
                [Description("Verifies that a license can't be acknowledged for a piece of PPV content not acquired.")]
                public class N_Acknowledge_PPV_NoAcquire : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();

                        // Purchase a PPV offer
                        helper.PurchaseVideo(LicenseType.SyncCastPPV, MediaTypeInfo.Movie, VideoQuality.HD);
                    }

                    public override void Run()
                    {
                        // Then attempt to acknowledge it without acquiring it
                        helper.AcknowledgeMediaLicense(0x80070005);
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(3)]
                [Description("Verifies that a license can't be acquired by a second user on the same machine")]
                public class N_Acquire_DTO_SecondAccount : TestNode
                {
                    AcquireMediaLicenseHelper helper;
                    AcquireMediaLicenseHelper secondHelper;
                    List<VideoInformation> tvOffer;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();

                        secondHelper = new AcquireMediaLicenseHelper(helper.Machine);
                        // We don't want to overwrite the client
                        secondHelper.Reset(false);

                        // Purchase a DTO offer with the first user
                        tvOffer = helper.PurchaseVideo(LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode, VideoQuality.HD, 1);
                    }

                    public override void Run()
                    {
                        // Then attempt to acquire licenses with the second user
                        secondHelper.AcquireMediaLicense(tvOffer, new uint[] { 0x80070005 });
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(3)]
                [Description("Verifies that a license can't be acknowledged by a second user on the same machine")]
                public class N_Acknowledge_PPV_SecondAccount : TestNode
                {
                    AcquireMediaLicenseHelper helper;
                    AcquireMediaLicenseHelper secondHelper;
                    List<VideoInformation> movieOffer;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.Reset();

                        secondHelper = new AcquireMediaLicenseHelper(helper.Machine);
                        // We don't want to overwrite the client
                        secondHelper.Reset(false);

                        // Purchase a PPV offer with the first user
                        movieOffer = helper.PurchaseVideo(LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode, VideoQuality.HD, 1);
                    }

                    public override void Run()
                    {
                        // And acquire it
                        helper.AcquireMediaLicense();

                        // Then attempt to acquire licenses with the second user
                        secondHelper.AcknowledgeMediaLicense(movieOffer, new uint[] { 0x80070005 });
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }
            }

            [TestGroup]
            public class Zune : TestNode
            {

                [TestCase, TestCasePriority(1)]
                [Description("Verifies that a Zune client gets a license for a piece of purchased content")]
                public class Acquire_BVT : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.UseXSigWeb = true;
                        helper.Reset();

                        helper.Purchase(MediaMatrix.ZuneDTOVideoOffer_1);
                    }

                    public override void Run()
                    {
                        helper.AcquireMediaLicense();
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(1)]
                [Description("Verifies that a Zune client gets a license for a piece of promotional content")]
                public class Acquire_Promotional : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.UseXSigWeb = true;
                        helper.Reset();

                        helper.Purchase(MediaMatrix.ZuneDTOVideoPromo);
                    }

                    public override void Run()
                    {
                        helper.AcquireMediaLicense();
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(1)]
                [Description("Verifies that a Zune client does not get a license for a piece of non-purchased content")]
                public class Acquire_NoPurchase : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.UseXSigWeb = true;
                        helper.Reset();

                        helper.AddPurchasedItem(MediaMatrix.ZuneDTOVideoOffer_2);
                    }

                    public override void Run()
                    {
                        helper.AcquireMediaLicense(new UInt32[] { 0x80070005 });
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(2)]
                [Description("Verifies that a Zune client can get a license for multiple pieces of content")]
                public class Acquire_MultipleDTO : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.UseXSigWeb = true;
                        helper.Reset();

                        helper.Purchase(MediaMatrix.ZuneDTOVideoOffer_1);
                        helper.Purchase(MediaMatrix.ZuneDTOVideoOffer_2);
                    }

                    public override void Run()
                    {
                        helper.AcquireMediaLicense();
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(2)]
                [Description("Verifies that a Zune client can gets appropriate licenses for multiple pieces of content")]
                public class Acquire_MultipleDTO_SinglePurchase : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.UseXSigWeb = true;
                        helper.Reset();

                        helper.Purchase(MediaMatrix.ZuneDTOVideoOffer_1);
                        helper.AddPurchasedItem(MediaMatrix.ZuneDTOVideoOffer_2);
                    }

                    public override void Run()
                    {
                        helper.AcquireMediaLicense(new UInt32[] { 0x0, 0x80070005 });
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(3)]
                [Description("Ensures that a Zune client does not get a license for a piece of Xbox PPV content")]
                public class Acquire_PPV : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.UseXSigWeb = true;
                        helper.Reset();

                        helper.Purchase(zunePpvVideo);
                    }

                    public override void Run()
                    {
                        helper.AcquireMediaLicense(new UInt32[] { 0x80070005 });
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(3)]
                [Description("Ensures that a Zune client can't acquire a license for Xbox PPV content")]
                public class CantAcquireXboxPPV : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.UseXSigWeb = true;
                        helper.Reset();

                        helper.PurchaseVideo(LicenseType.SyncCastPPV, MediaTypeInfo.Movie);
                    }

                    public override void Run()
                    {
                        helper.AcquireMediaLicense(new UInt32[] { 0x80070005 });
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }


                [TestCase(BugDatabase = "ISS ALL", BugID = 131223), TestCasePriority(1)]
                [CompoundCase("No_Dev_Or_Machine_Cert", ClientInfoNoDevCert, CatalogClientTypeEnum.Xbox360, false, HResult.XONLINE_E_SIGNATURE_INVALID_WMRM_RSA_VERSION)]
                [CompoundCase("Both_Dev_And_Machine_Cert", ClientInfoBothDevAndMachineCert, CatalogClientTypeEnum.Xbox360, false, HResult.XONLINE_E_SIGNATURE_INVALID_WMRM_RSA_VERSION)]
                [CompoundCase("Empty_Dev_Cert1", ClientInfoEmptyDevCert1, CatalogClientTypeEnum.Xbox360, false, HResult.XONLINE_E_SIGNATURE_INVALID_WMRM_RSA_VERSION)]
                [CompoundCase("Empty_Dev_Cert2", ClientInfoEmptyDevCert2, CatalogClientTypeEnum.Xbox360, false, HResult.XONLINE_E_SIGNATURE_INVALID_WMRM_RSA_VERSION)]
                [CompoundCase("Dorado_Known_Good", ClientInfoDoradoKnownGood, CatalogClientTypeEnum.WindowsPcClient, true, HResult.S_OK)]
                [CompoundCase("Dorado_Exploited", ClientInfoExploitedDorado, CatalogClientTypeEnum.WindowsPcClient, false, HResult.XONLINE_E_SIGNATURE_INVALID_WMRM_RSA_VERSION)]
                [CompoundCase("Dorado_Tampered_Machine_Cert", ClientInfoWithTamperedMachineCert, CatalogClientTypeEnum.WindowsPcClient, false, HResult.XONLINE_E_SIGNATURE_GENERATE_LICENSE_RESPONSE_ERROR)]
                [CompoundCase("XBox_Known_Good", ClientInfoXboxKnownGood, CatalogClientTypeEnum.Xbox360, true, HResult.S_OK)]
                [CompoundCase("XBox_Old_Version", ClientInfoXboxOldVersion, CatalogClientTypeEnum.Xbox360, false, HResult.XONLINE_E_SIGNATURE_INVALID_WMRM_RSA_VERSION)]
                [CompoundCase("MusiWave_Empty_Dev_Cert_Node", ClientInfoEmptyDevCertNode, CatalogClientTypeEnum.Xbox360, false, HResult.XONLINE_E_SIGNATURE_INVALID_WMRM_RSA_VERSION)]
                [CompoundCase("MusiWave_Remove_All_Certs_In_MachineCert_Cert_Collection_Except_Last_One", ClientInfoRemoveAllCertificateNodesExceptLastOne, CatalogClientTypeEnum.Xbox360, true, HResult.S_OK)]
                [CompoundCase("Hacked_Cert_In_Machine_Cert_Collection", ClientInfoHackedCertInMachineCertCertCollection, CatalogClientTypeEnum.Xbox360, false, HResult.XONLINE_E_SIGNATURE_GENERATE_LICENSE_RESPONSE_ERROR)]
                [CompoundCase("Tampered_Dev_Cert", ClientInfoTamperedDevCert, CatalogClientTypeEnum.Xbox360, false, HResult.XONLINE_E_SIGNATURE_GENERATE_LICENSE_RESPONSE_ERROR)]
                [CompoundCase("Empty_Machine_Cert", ClientInfoWithEmptyMachineCert, CatalogClientTypeEnum.Xbox360, false, HResult.XONLINE_E_SIGNATURE_INVALID_WMRM_RSA_VERSION)]
                [CompoundCase("Bad_Machine_Cert_Base_64_Encoding", ClientInfoWithBadBase64, CatalogClientTypeEnum.Xbox360, false, HResult.XONLINE_E_SIGNATURE_INVALID_WMRM_RSA_VERSION)]
                [Description("Verifies the proper handling of various known good and bad ClientInfo blocks.")]
                public class ClientInfo_Handling_Validation : TestNode
                {
                    AcquireMediaLicenseHelper helper;
                    VideoInformation episode;

                    public override void PreRun()
                    {
                        // Generate a piece of content
                        episode = VideoInformation.Generate(LicenseType.ZunePCDTO, MediaTypeInfo.TVEpisode, false);
                        //episode.ClientTypeId = (CatalogClientTypeEnum)this.MyValues[1];
                        episode.ClientTypeId = CatalogClientTypeEnum.WindowsPcClient;
                        episode.InsertIntoCatalog();

                        helper = new AcquireMediaLicenseHelper();
                        helper.UseXSigWeb = true;
                        helper.Reset();

                        helper.Purchase(episode);
                    }

                    public override void Run()
                    {
                        String clientInfoBlock = (string)this.MyValues[0];
                        bool shouldSucceed = (bool)this.MyValues[2];
                        HResult expectedHResult = (uint)this.MyValues[3];
                        MediaLicense[] result = Signature.AcquireMediaLicensesWeb(
                            helper.UserPuid,
                            helper.User.PassportPuid,
                            null,
                            clientInfoBlock,
                            episode.MediaInstanceIdOfferIdPair);

                            if (shouldSucceed)
                            {
                                if (HResult.Succeeded(result[0].Hr))
                                {
                                    Global.RO.Success("Request succeeded as expected");
                                }
                                else
                                {
                                    throw new UnexpectedTestResultException(String.Format(
                                        "Expected AcquireMediaLicenses call to succeed.  Got: {0:X8}", result[0].Hr));
                                }
                            }
                            else
                            {
                                ValueCheck.Test<HResult, HResult>("AcquireMediaLicensesWeb Failure HR", expectedHResult, result[0].Hr);
                                Global.RO.Success("Request failed as expected");
                            }
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(1)]
                [Description("Verifies that xsig respects the minimum client version")]
                [Ignore("XSig does not reload the versions dynamically")]
                public class Acquire_OverrideMinClientVersion : TestNode
                {
                    AcquireMediaLicenseHelper helper;
                    ServerTestFramework.LiveService.SettingState clientVersionOverride;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.UseXSigWeb = true;
                        helper.Reset();

                        helper.Purchase(MediaMatrix.ZuneDTOVideoOffer_1);

                        helper.AcquireMediaLicense(0x8015B015);
                        clientVersionOverride = Global.XEnv.OverrideSetting("xsig", "ALL", "signature_minimum_WMRM_Client_Version", "11.0.0.0");
                    }

                    public override void Run()
                    {
                        var mediaToAcq  = helper.VideoInfo.Select(v => v.MediaInstanceIdOfferIdPair).ToArray();
                        var resp = Signature.AcquireMediaLicensesWeb(helper.UserPuid, helper.User.PassportPuid, null, ClientInfoXboxOldVersion, mediaToAcq                            );

                        ValueCheck.Test("AcquireMediaLicenses result", HResult.S_OK, resp[0].hr);
                    }

                    public override void PostRun()
                    {
                        Global.XEnv.RestoreOverrideSettingState(clientVersionOverride);
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(2)]
                [Description("Verifies that the acquire limit is honoured")]
                public class ClientAcquireLimit : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.UseXSigWeb = true;
                        helper.Reset();

                        helper.Purchase(MediaMatrix.ZuneDTOVideoOffer_1);
                    }

                    public override void Run()
                    {
                        for (int i = 0; i < 5; i++)
                        {
                            helper.AcquireMediaLicense();
                        }

                        helper.AcquireMediaLicense(0x8015B00B);
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(3)]
                [Description("Verifies that acquire license fails with a piece of invalid content")]
                public class Acquire_InvalidContent : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.UseXSigWeb = true;
                        helper.Reset();
                    }

                    public override void Run()
                    {
                        MediaInstanceIdOfferIdPair[] media = new MediaInstanceIdOfferIdPair[]
                        {
                            new MediaInstanceIdOfferIdPair
                            {
                                miid = new Guid("11111111-1111-1111-1111-111111111111"),
                                oid = new Guid("11111111-1111-1111-1111-111111111111"),
                            }
                        };

                        helper.AcquireMediaLicense(media, new UInt32[] { 0x80070005 });
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase(144893, BugDatabase="ISS All"), TestCasePriority(3)]
                [Description("Verifies that acknowledge failes for Zune DTO content")]
                public class Acknowledge_DTO : TestNode
                {
                    AcquireMediaLicenseHelper helper;

                    public override void PreRun()
                    {
                        helper = new AcquireMediaLicenseHelper();
                        helper.UseXSigWeb = true;
                        helper.Reset();

                        helper.Purchase(MediaMatrix.ZuneDTOVideoOffer_1);
                    }

                    public override void Run()
                    {
                        helper.AcquireMediaLicense();
                        helper.AcknowledgeMediaLicense(helper.VideoInfo, new UInt32[] { 0x80070005 });
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

                [TestCase, TestCasePriority(2)]
                [CompoundCase("OutOfCountry", "24.36.22.55", false, "Stoney Creek, ON, Canada", true)]
                [CompoundCase("OutOfCountry_NotGeofenced", "24.36.22.55", true, "Stoney Creek, ON, Canada", false)]
                [CompoundCase("MappedTerritory_PuertoRico", "24.42.0.0", true, "Pureto Rico, USA", true)]
                [CompoundCase("MappedTerritory_Guam", "116.68.0.0", true, "Guam, USA", true)]
                [CompoundCase("UnknownLocation", "1.1.1.1", true, "Unknown Location", true)]
                [Description("Verifies various geofencing scenarios for AcquireMediaLicenses")]
                public class Acquire_Geofenced : TestNode
                {
                    AcquireMediaLicenseHelper helper;
                    VideoInformation episode;

                    public override void PreRun()
                    {
                        Boolean shouldGeofence = (Boolean)MyValues[3];

                        // Generate a piece of geofenced (or not) content
                        episode = VideoInformation.Generate(LicenseType.ZunePCDTO, MediaTypeInfo.TVEpisode, false);
                        episode.GeoCheckPolicy = shouldGeofence ? GeoCheckPolicy.GeoFence : GeoCheckPolicy.DoNotGeoFence;
                        episode.ClientTypeId = CatalogClientTypeEnum.WindowsPcClient;
                        episode.InsertIntoCatalog();

                        helper = new AcquireMediaLicenseHelper();
                        helper.UseXSigWeb = true;
                        helper.Reset();

                        helper.Purchase(episode);
                    }

                    public override void Run()
                    {
                        // Check if geofencing is enabled
                        if (!Global.XEnv.GetBoolSetting("geofencing_videoGeoFencingEnabled"))
                        {
                            throw new DidNotExecuteException("Video GeoFencing is not enabled, unable to run geofencing test.  Check geofencing_videoGeoFencingEnabled");
                        }

                        Global.RO.Info("Verifying acquire works properly...");
                        // Make sure it works normally
                        helper.AcquireMediaLicense();
                        Global.RO.Info("Acquired a media license normally.");

                        String ipAddressString = (String)MyValues[0];
                        Boolean shouldSucceed = (Boolean)MyValues[1];
                        String newLocation = (String)MyValues[2];

                        ulong passportPuid = helper.User.PassportPuid;

                        Global.RO.Info("'Moving' to {0}[{1}]...", newLocation, ipAddressString);
                        // Make the call, using the ipAddress provided

                        try
                        {
                            Signature.AcquireMediaLicensesWeb(helper.UserPuid, passportPuid, ipAddressString, episode.MediaInstanceIdOfferIdPair);

                            if (shouldSucceed)
                            {
                                Global.RO.Success("Request succeeded as expected");
                            }
                            else
                            {
                                throw new UnexpectedTestResultException("Expected AcquireMediaLicenses call to fail.");
                            }
                        }
                        catch (Exception e)
                        {
                            Global.RO.Error(e.ToString());

                            // If it should fail
                            if (!shouldSucceed)
                            {
                                // Make sure that we got the geo fence failure
                                ValueCheck.Test<HResult, HResult>("HResult", HResult.XONLINE_E_GEO_DENIED, 0x0);
                                Global.RO.Success("Request failed as expected with geofenced request.");
                            }
                            else
                            {
                                // It should have succeeded but it failed
                                throw new UnexpectedTestResultException("AcquireMediaLicense call failed: " + e.ToString());
                            }
                        }
                    }

                    public override void PostRun()
                    {
                        helper.Cleanup();
                    }
                }

            }
        }

        [TestGroup, Owner("BenRan"), TestFrequency("Regression")]
        public class CheckLicensesAvailability : TestNode
        {
            [TestCase, TestCasePriority(1)]
            [Description("Verifys that CheckLicensesAvalability returns a response")]
            public class CheckAvailability_BVT : TestNode
            {
                AcquireMediaLicenseHelper helper;

                public override void PreRun()
                {
                    helper = new AcquireMediaLicenseHelper();
                    helper.UseXSigWeb = true;
                    helper.Reset();

                    helper.Purchase(MediaMatrix.ZuneDTOVideoOffer_1);
                }

                public override void Run()
                {
                    helper.CheckLicensesAvailability();
                }

                public override void PostRun()
                {
                    helper.Cleanup();
                }
            }

            [TestCase, TestCasePriority(1)]
            [Description("Verifys that CheckLicensesAvalability returns a valid response for multiple pieces of content")]
            public class CheckAvailability_MultipleContent : TestNode
            {
                AcquireMediaLicenseHelper helper;

                public override void PreRun()
                {
                    helper = new AcquireMediaLicenseHelper();
                    helper.UseXSigWeb = true;
                    helper.Reset();

                    helper.Purchase(MediaMatrix.ZuneDTOVideoOffer_1);
                    helper.Purchase(MediaMatrix.ZuneDTOVideoOffer_2);
                }

                public override void Run()
                {
                    helper.CheckLicensesAvailability();
                }

                public override void PostRun()
                {
                    helper.Cleanup();
                }
            }

            [TestCase, TestCasePriority(2)]
            [Description("Verifys that CheckLicensesAvalability returns the correct response when content is not purchased")]
            public class CheckAvailability_NoPurchase : TestNode
            {
                AcquireMediaLicenseHelper helper;

                public override void PreRun()
                {
                    helper = new AcquireMediaLicenseHelper();
                    helper.UseXSigWeb = true;
                    helper.Reset();

                    helper.AddPurchasedItem(MediaMatrix.ZuneDTOVideoOffer_1);
                }

                public override void Run()
                {
                    helper.CheckLicensesAvailability(new uint[] { 0x80070005 });
                }

                public override void PostRun()
                {
                    helper.Cleanup();
                }
            }

            [TestCase, TestCasePriority(2)]
            [Description("Verifys that CheckLicensesAvalability respects the Acquire limit")]
            public class CheckAvailability_AcquireLimit : TestNode
            {
                AcquireMediaLicenseHelper helper;

                public override void PreRun()
                {
                    helper = new AcquireMediaLicenseHelper();
                    helper.UseXSigWeb = true;
                    helper.Reset();

                    helper.Purchase(MediaMatrix.ZuneDTOVideoOffer_1);
                }

                public override void Run()
                {
                    for (int i = 0; i < 5; i++)
                    {
                        helper.AcquireMediaLicense();
                    }
                    helper.CheckLicensesAvailability(new uint[] { 0x8015B00B });
                }

                public override void PostRun()
                {
                    helper.Cleanup();
                }
            }

            [TestCase, TestCasePriority(1)]
            [Description("Verifys that CheckLicensesAvalability returns a response")]
            public class CheckAvailability_InvalidContent : TestNode
            {
                AcquireMediaLicenseHelper helper;

                public override void PreRun()
                {
                    helper = new AcquireMediaLicenseHelper();
                    helper.UseXSigWeb = true;
                    helper.Reset();
                }

                public override void Run()
                {
                    MediaInstanceIdOfferIdPair[] invalidIds = new MediaInstanceIdOfferIdPair[] 
                    {
                        new MediaInstanceIdOfferIdPair
                        { 
                            miid = new Guid("11111111-1111-1111-1111-111111111111"),
                            oid = new Guid("11111111-1111-1111-1111-111111111111"),
                        },
                    };

                    helper.CheckLicensesAvailability(invalidIds, new uint[] { 0x80070005 });
                }

                public override void PostRun()
                {
                    helper.Cleanup();
                }
            }

            [TestCase, TestCasePriority(2)]
            [CompoundCase("OutOfCountry", "24.36.22.55", false, "Stoney Creek, ON, Canada", true)]
            [CompoundCase("OutOfCountry_NotGeofenced", "24.36.22.55", true, "Stoney Creek, ON, Canada", false)]
            [CompoundCase("MappedTerritory_PuertoRico", "24.42.0.0", true, "Pureto Rico, USA", true)]
            [CompoundCase("MappedTerritory_Guam", "116.68.0.0", true, "Guam, USA", true)]
            [CompoundCase("UnknownLocation", "1.1.1.1", true, "Unknown Location", true)]
            [Description("Verifies various geofencing scenarios for AcquireMediaLicenses")]
            public class CheckAvailability_Geofenced : TestNode
            {
                AcquireMediaLicenseHelper helper;
                VideoInformation episode;

                public override void PreRun()
                {
                    Boolean shouldGeofence = (Boolean)MyValues[3];

                    // Generate a piece of geofenced (or not) content
                    episode = VideoInformation.Generate(LicenseType.ZunePCDTO, MediaTypeInfo.TVEpisode, false);
                    episode.GeoCheckPolicy = shouldGeofence ? GeoCheckPolicy.GeoFence : GeoCheckPolicy.DoNotGeoFence;
                    episode.ClientTypeId = CatalogClientTypeEnum.WindowsPcClient;
                    episode.InsertIntoCatalog();

                    helper = new AcquireMediaLicenseHelper();
                    helper.UseXSigWeb = true;
                    helper.Reset();

                    helper.Purchase(episode);
                }

                public override void Run()
                {
                    // Check if geofencing is enabled
                    if (!Global.XEnv.GetBoolSetting("geofencing_videoGeoFencingEnabled"))
                    {
                        throw new DidNotExecuteException("Video GeoFencing is not enabled, unable to run geofencing test.  Check geofencing_videoGeoFencingEnabled");
                    }

                    Global.RO.Info("Verifying check license availability works properly...");
                    // Make sure it works normally
                    helper.CheckLicensesAvailability();
                    Global.RO.Info("Checking license availability normally.");

                    String ipAddressString = (String)MyValues[0];
                    Boolean shouldSucceed = (Boolean)MyValues[1];
                    String newLocation = (String)MyValues[2];

                    ulong passportPuid = helper.User.PassportPuid;

                    Global.RO.Info("'Moving' to {0}[{1}]...", newLocation, ipAddressString);
                    // Make the call, using the ipAddress provided
                    try
                    {
                        var availabilities = Signature.CheckLicensesAvalabilityWeb(helper.UserPuid, passportPuid, ipAddressString, episode.MediaInstanceIdOfferIdPair);

                        if (shouldSucceed)
                        {
                            AcquireMediaLicenseHelper.VerifyCheckAvailabilityResponse(
                                availabilities,
                                new uint[] { 0x0 },
                                new MediaInstanceIdOfferIdPair[] { episode.MediaInstanceIdOfferIdPair });
                            Global.RO.Success("CheckLicensesAvailability succeeded as expected");
                        }
                        else
                        {
                            throw new UnexpectedTestResultException("Expected CheckLicensesAvailability call to fail.");
                        }
                    }
                    catch (Exception e)
                    {
                        Global.RO.Error(e.ToString());

                        // If it should fail
                        if (!shouldSucceed)
                        {
                            // Make sure that we got the geo fence failure
                            ValueCheck.Test<HResult, HResult>("HResult", HResult.XONLINE_E_GEO_DENIED, 0x0);
                            Global.RO.Success("CheckLicensesAvailability request failed as expected with geofenced request.");
                        }
                        else
                        {
                            // It should have succeeded but it failed
                            throw new UnexpectedTestResultException("CheckLicensesAvailability call failed: " + e.ToString());
                        }
                    }
                }

                public override void PostRun()
                {
                    helper.Cleanup();
                }
            }

            [TestCase, TestCasePriority(3)]
            [Description("Ensures that a different user does not have available licenses")]
            public class CheckAvailability_DifferentUser : TestNode
            {
                AcquireMediaLicenseHelper helper;
                AcquireMediaLicenseHelper altHelper;

                public override void PreRun()
                {
                    helper = new AcquireMediaLicenseHelper();
                    helper.UseXSigWeb = true;
                    helper.Reset();

                    helper.Purchase(MediaMatrix.ZuneDTOVideoOffer_1);

                    altHelper = new AcquireMediaLicenseHelper(helper.Machine);
                    altHelper.UseXSigWeb = true;
                    // Use the same machine
                    altHelper.Reset(false);
                }

                public override void Run()
                {
                    helper.CheckLicensesAvailability();

                    altHelper.CheckLicensesAvailability(
                        new MediaInstanceIdOfferIdPair[] 
                        { 
                            MediaMatrix.ZuneDTOVideoOffer_1.MediaInstanceIdOfferIdPair,
                        },
                        new uint[]
                        {
                            0x80070005
                        });
                }

                public override void PostRun()
                {
                    helper.Cleanup();
                    altHelper.Cleanup();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\LicenseMigration\Reporting.cs ===
using System;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Billing.License;

using System.Collections.Generic;
using System.Data.SqlClient;
using SigTest.License;
using xonline.common.billing;
using xonline.common.sql.webstore;
using xonline.common.config;
using Microsoft.Webstore.WstClient;
using xonline.common.protocol;

namespace SigTest.LicenseMigration.Functional
{
    partial class LiceMigTests : TestNode
    {
        [TestGroup, Owner("BenRan"), TestFrequency("Regression")]
        public class Reporting : TestNode
        {
            [TestCase, TestCasePriority(1), Description("Aquire and migrate a single video license, and verify reporting stuff")]
            public class XrlBasicVideoTransfer : TestNode
            {
                private LicensesState state = null;
                private AcquireMediaLicenseHelper helper = null;
                private AcquireMediaLicenseHelper helperNew = null;

                public override void PreRun()
                {
                    state = new LicensesState();
                    helper = new AcquireMediaLicenseHelper();
                    helper.Reset();

                    helperNew = new AcquireMediaLicenseHelper(helper.User);
                    helperNew.Reset(false);

                    var videoInfo = helper.PurchaseVideo(LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode);
                    state.Update_BuyVideo(videoInfo.OfferId, helper.UserPuid, helper.MachinePuid);

                    ro.Debug("Verifying current license state...");
                    state.Verify();
                }

                public override void Run()
                {
                    ro.Info("Verifying reporting info...");
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperNew.MachinePuid, 0, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helper.UserPuid, 1, 0);

                    ro.Info("Performing user license transfer...");
                    LicenseMigrationUtils.XrlSimpleTransferLicenses(helper.UserPuid, helperNew.Machine.ConsoleId, helperNew.MachinePuid, state);

                    ro.Debug("Verifying licenses after transfer...");
                    state.Verify();

                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperNew.MachinePuid, 0, 1);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helper.UserPuid, 1, 1);

                    helperNew.AcquireMediaLicense(helper.VideoInfo);

                    ro.Debug("Verifying licenses after acquire...");
                    state.Verify();

                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperNew.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helper.UserPuid, 2, 0);
                }

                public override void PostRun()
                {
                    helper.Cleanup();
                    helperNew.Cleanup();
                }
            }

            [TestCase, TestCasePriority(1), Description("Aquire and migrate a single video license, and verify reporting stuff")]
            public class XrlVideoTransfer_MultipleVideos : TestNode
            {
                private LicensesState state = null;
                private AcquireMediaLicenseHelper helper = null;
                private AcquireMediaLicenseHelper helperNew = null;

                public override void PreRun()
                {
                    state = new LicensesState();
                    helper = new AcquireMediaLicenseHelper();
                    helper.Reset();

                    helperNew = new AcquireMediaLicenseHelper(helper.User);
                    helperNew.Reset(false);

                    var videoInfo = helper.PurchaseVideo(LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode);
                    state.Update_BuyVideo(videoInfo.OfferId, helper.UserPuid, helper.MachinePuid);

                    videoInfo = helper.PurchaseVideo(LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode);
                    state.Update_BuyVideo(videoInfo.OfferId, helper.UserPuid, helper.MachinePuid);

                    ro.Debug("Verifying current license state...");
                    state.Verify();
                }

                public override void Run()
                {
                    ro.Info("Verifying reporting info...");
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper.MachinePuid, 2, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperNew.MachinePuid, 0, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helper.UserPuid, 2, 0);

                    ro.Info("Performing user license transfer...");
                    LicenseMigrationUtils.XrlSimpleTransferLicenses(helper.UserPuid, helperNew.Machine.ConsoleId, helperNew.MachinePuid, state);

                    ro.Debug("Verifying licenses after transfer...");
                    state.Verify();

                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper.MachinePuid, 2, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperNew.MachinePuid, 0, 2);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helper.UserPuid, 2, 2);

                    helperNew.AcquireMediaLicense(helper.VideoInfo);

                    ro.Debug("Verifying licenses after acquire...");
                    state.Verify();

                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper.MachinePuid, 2, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperNew.MachinePuid, 2, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helper.UserPuid, 4, 0);
                }

                public override void PostRun()
                {
                    helper.Cleanup();
                    helperNew.Cleanup();
                }
            }

            [TestCase, TestCasePriority(1), Description("Aquire and migrate a single video license, and verify reporting stuff")]
            public class XrlVideoTransfer_MultipleVideosMultipleMachines : TestNode
            {
                private LicensesState state = null;
                private AcquireMediaLicenseHelper helperSrc1 = null;
                private AcquireMediaLicenseHelper helperSrc2 = null;
                private AcquireMediaLicenseHelper helperDst = null;

                public override void PreRun()
                {
                    state = new LicensesState();

                    helperSrc1 = new AcquireMediaLicenseHelper();
                    helperSrc1.Reset();

                    helperSrc2 = new AcquireMediaLicenseHelper(helperSrc1.User);
                    helperSrc2.Reset(false);

                    helperDst = new AcquireMediaLicenseHelper(helperSrc1.User);
                    helperDst.Reset(false);

                    var videoInfo = helperSrc1.PurchaseVideo(LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode);
                    state.Update_BuyVideo(videoInfo.OfferId, helperSrc1.UserPuid, helperSrc1.MachinePuid);

                    videoInfo = helperSrc2.PurchaseVideo(LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode);
                    state.Update_BuyVideo(videoInfo.OfferId, helperSrc2.UserPuid, helperSrc2.MachinePuid);

                    ro.Debug("Verifying current license state...");
                    state.Verify();
                }

                public override void Run()
                {
                    ro.Info("Verifying reporting info...");
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperSrc1.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperSrc2.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperDst.MachinePuid, 0, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helperSrc1.UserPuid, 2, 0);

                    ro.Info("Performing user license transfer...");
                    LicenseMigrationUtils.XrlSimpleTransferLicenses(helperSrc1.UserPuid, helperDst.Machine.ConsoleId, helperDst.MachinePuid, state);

                    ro.Debug("Verifying licenses after transfer...");
                    state.Verify();

                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperSrc1.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperSrc2.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperDst.MachinePuid, 0, 2);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helperSrc1.UserPuid, 2, 2);

                    helperDst.AcquireMediaLicense(helperSrc1.VideoInfo);

                    ro.Debug("Verifying licenses after first acquire...");
                    state.Verify();

                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperSrc1.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperSrc2.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperDst.MachinePuid, 1, 1);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helperSrc1.UserPuid, 3, 1);

                    helperDst.AcquireMediaLicense(helperSrc2.VideoInfo);

                    ro.Debug("Verifying licenses after second acquire...");
                    state.Verify();

                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperSrc1.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperSrc2.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperDst.MachinePuid, 2, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helperSrc1.UserPuid, 4, 0);
                }

                public override void PostRun()
                {
                    helperSrc1.Cleanup();
                    helperSrc2.Cleanup();
                    helperDst.Cleanup();
                }
            }

            [TestCase, TestCasePriority(2), Description("Migrate a license twice, then acquire and verify reporting stuff.")]
            public class XrlMigrateTwice_AcquireAtEnd : TestNode
            {
                LicensesState state;

                AcquireMediaLicenseHelper helper0;
                AcquireMediaLicenseHelper helper1;
                AcquireMediaLicenseHelper helper2;

                public override void PreRun()
                {
                    state = new LicensesState();
                    helper0 = new AcquireMediaLicenseHelper();
                    helper0.Reset();

                    helper1 = new AcquireMediaLicenseHelper(helper0.User);
                    helper1.Reset(false);

                    helper2 = new AcquireMediaLicenseHelper(helper0.User);
                    helper2.Reset(false);

                    var videoInfo = helper0.PurchaseVideo(LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode);
                    state.Update_BuyVideo(videoInfo.OfferId, helper0.UserPuid, helper0.MachinePuid);

                    ro.Debug("Verifying current license state...");
                    state.Verify();
                }

                public override void Run()
                {
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper0.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper1.MachinePuid, 0, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper2.MachinePuid, 0, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helper0.UserPuid, 1, 0);

                    //do the migration to machine 1 and verify
                    LicenseMigrationUtils.XrlSimpleTransferLicenses(helper0.UserPuid, helper1.Machine.ConsoleId, helper1.MachinePuid, state);

                    ro.Debug("Verifying licenses and purchase stuff...");
                    state.Verify();
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper0.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper1.MachinePuid, 0, 1);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper2.MachinePuid, 0, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helper0.UserPuid, 1, 1);

                    //now pass some time and transfer to machine 2, and verify
                    LicenseMigrationUtils.AdvanceTimeOnLicenseTransferState(helper0.UserPuid, new System.TimeSpan(366, 0, 0, 0));
                    LicenseMigrationUtils.XrlSimpleTransferLicenses(helper0.UserPuid, helper2.Machine.ConsoleId, helper2.MachinePuid, state);

                    ro.Debug("Verifying licenses and purchase stuff...");
                    state.Verify();
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper0.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper1.MachinePuid, 0, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper2.MachinePuid, 0, 1);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helper0.UserPuid, 1, 1);

                    //do the acquire and verify
                    helper2.AcquireMediaLicense(helper0.VideoInfo[0]);

                    ro.Debug("Verifying licenses and purchase stuff...");
                    state.Verify();
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper0.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper1.MachinePuid, 0, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper2.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helper0.UserPuid, 2, 0);
                }

                public override void PostRun()
                {
                    helper0.Cleanup();
                    helper1.Cleanup();
                    helper2.Cleanup();
                }
            }

            [TestCase, TestCasePriority(3), Description("Transfer a video using the xrl api twice, acquiring after each one")]
            public class XrlMigrateTwice_AcquireAfterBoth : TestNode
            {
                LicensesState state = null;
                AcquireMediaLicenseHelper helper0 = new AcquireMediaLicenseHelper();
                AcquireMediaLicenseHelper helper1 = new AcquireMediaLicenseHelper();
                AcquireMediaLicenseHelper helper2 = new AcquireMediaLicenseHelper();
                
                public override void PreRun()
                {
                    state = new LicensesState();

                    helper0 = new AcquireMediaLicenseHelper();
                    helper0.Reset();

                    helper1 = new AcquireMediaLicenseHelper(helper0.User);
                    helper1.Reset(false);

                    helper2 = new AcquireMediaLicenseHelper(helper0.User);
                    helper2.Reset(false);

                    var videoInfo = helper0.PurchaseVideo(LicenseType.SyncCastPPV, MediaTypeInfo.TVEpisode);
                    state.Update_BuyVideo(videoInfo.OfferId, helper0.UserPuid, helper0.MachinePuid);
                }

                public override void Run()
                {
                    ro.Debug("Verifying initial license state...");
                    state.Verify();
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper0.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper1.MachinePuid, 0, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper2.MachinePuid, 0, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helper0.UserPuid, 1, 0);

                    //do the migration to machine 1 and verify
                    LicenseMigrationUtils.XrlSimpleTransferLicenses(helper0.UserPuid, helper1.Machine.ConsoleId, helper1.MachinePuid, state);

                    ro.Debug("Verifying licenses after first transfer...");
                    state.Verify();
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper0.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper1.MachinePuid, 0, 1);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper2.MachinePuid, 0, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helper0.UserPuid, 1, 1);

                    //do the acquire and verify
                    helper1.AcquireMediaLicense(helper0.VideoInfo);

                    ro.Debug("Verifying licenses after first acquire...");
                    state.Verify();
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper0.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper1.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper2.MachinePuid, 0, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helper0.UserPuid, 2, 0);

                    //now pass some time and transfer to machine 2, and verify
                    LicenseMigrationUtils.AdvanceTimeOnLicenseTransferState(helper0.UserPuid, new System.TimeSpan(366, 0, 0, 0));
                    LicenseMigrationUtils.XrlSimpleTransferLicenses(helper0.UserPuid, helper2.Machine.ConsoleId, helper2.MachinePuid, state);

                    ro.Debug("Verifying licenses after second transfer...");
                    state.Verify();
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper0.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper1.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper2.MachinePuid, 0, 1);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helper0.UserPuid, 2, 1);

                    //do the acquire and verify
                    helper2.AcquireMediaLicense(helper0.VideoInfo);

                    ro.Debug("Verifying licenses after second acquire...");
                    state.Verify();
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper0.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper1.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helper2.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helper0.UserPuid, 3, 0);
                }

                public override void PostRun()
                {
                    helper0.Cleanup();
                    helper1.Cleanup();
                    helper2.Cleanup();
                }
            }

            [TestCase, TestCasePriority(2), Description("Migrate a game with the xrl api.  It should not show up in pending stuff")]
            public class XrlGameTransfer : TestNode
            {
                LicensesState state = null;

                AcquireMediaLicenseHelper srcHelper = null;
                AcquireMediaLicenseHelper dstHelper = null;

                public override void PreRun()
                {
                    state = new LicensesState();
                    srcHelper = new AcquireMediaLicenseHelper();
                    srcHelper.Reset();

                    dstHelper = new AcquireMediaLicenseHelper(srcHelper.User);
                    dstHelper.Reset(false);

                    srcHelper.Purchase(MediaMatrix.TexasHoldEmOffer);
                    state.Update_BuyGame(MediaMatrix.TexasHoldEmOffer.OfferId, srcHelper.UserPuid, srcHelper.MachinePuid);

                    ro.Debug("Verifying licenses and purchase stuff...");
                    state.Verify();
                }

                public override void Run()
                {
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(srcHelper.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(dstHelper.MachinePuid, 0, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(srcHelper.UserPuid, 1, 0);

                    //do the migration
                    LicenseMigrationUtils.XrlSimpleTransferLicenses(srcHelper.UserPuid, dstHelper.Machine.ConsoleId, dstHelper.MachinePuid, state);

                    //verify licenses
                    ro.Debug("Verifying licenses and purchase stuff...");
                    state.Verify();
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(srcHelper.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(dstHelper.MachinePuid, 0, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(srcHelper.UserPuid, 1, 0);
                }
            }

            [TestCase, TestCasePriority(2), Description("Migrate a game to a console with a duplicate")]
            public class XrlGameTransfer_DuplicateConsole : TestNode
            {
                LicensesState state = null;

                AcquireMediaLicenseHelper srcHelper = null;
                AcquireMediaLicenseHelper dstHelper = null;
                IMachine dstDupeMachine = null;

                public override void PreRun()
                {
                    state = new LicensesState();
                    srcHelper = new AcquireMediaLicenseHelper();
                    srcHelper.Reset();

                    dstHelper = new AcquireMediaLicenseHelper(srcHelper.User);
                    dstHelper.Reset(false);

                    dstDupeMachine = (MachineBase)MachineEditor.CreateDuplicateXbox360(dstHelper.Machine.ConsoleId);

                    srcHelper.Purchase(MediaMatrix.TexasHoldEmOffer);
                    state.Update_BuyGame(MediaMatrix.TexasHoldEmOffer.OfferId, srcHelper.UserPuid, srcHelper.MachinePuid);

                    ro.Debug("Verifying licenses and purchase stuff...");
                    state.Verify();
                }

                public override void Run()
                {
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(srcHelper.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(dstHelper.MachinePuid, 0, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(dstDupeMachine.Puid, 0, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(srcHelper.UserPuid, 1, 0);

                    //do the migration
                    LicenseMigrationUtils.XrlSimpleTransferLicenses(srcHelper.UserPuid, dstHelper.Machine.ConsoleId, dstHelper.MachinePuid, state);

                    //verify licenses
                    ro.Debug("Verifying licenses and purchase stuff...");
                    state.Verify();
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(srcHelper.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(dstHelper.MachinePuid, 0, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(dstDupeMachine.Puid, 0, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(srcHelper.UserPuid, 1, 0);
                }

                public override void PostRun()
                {
                    srcHelper.Cleanup();
                    dstHelper.Cleanup();
                }
            }

            [TestCase, TestCasePriority(2), Description("Transfer a video and game using and verify reporting stuff.")]
            public class XrlGameAndVideoTransfer : TestNode
            {
                LicensesState state;
                AcquireMediaLicenseHelper helperSrc;
                AcquireMediaLicenseHelper helperDst;

                public override void PreRun()
                {
                    state = new LicensesState();

                    helperSrc = new AcquireMediaLicenseHelper();
                    helperSrc.Reset();

                    helperDst = new AcquireMediaLicenseHelper(helperSrc.User);
                    helperDst.Reset(false);

                    helperSrc.Purchase(MediaMatrix.TexasHoldEmOffer);
                    state.Update_BuyGame(MediaMatrix.TexasHoldEmOffer.OfferId, helperSrc.UserPuid, helperSrc.MachinePuid);

                    var videoInfo = helperSrc.PurchaseVideo(LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode);
                    state.Update_BuyVideo(videoInfo.OfferId, helperSrc.UserPuid, helperSrc.MachinePuid);
                }

                public override void Run()
                {
                    //sanity check of licenses and purchase stuff
                    ro.Debug("Verifying initial license state...");
                    state.Verify();

                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperSrc.MachinePuid, 2, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperDst.MachinePuid, 0, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helperSrc.UserPuid, 2, 0);

                    //do the migration
                    LicenseMigrationUtils.XrlSimpleTransferLicenses(helperSrc.UserPuid, helperDst.Machine.ConsoleId, helperDst.MachinePuid, state);

                    ro.Debug("Verifying license state after transfer...");
                    state.Verify();

                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperSrc.MachinePuid, 2, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperDst.MachinePuid, 0, 1);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helperSrc.UserPuid, 2, 1);

                    helperDst.AcquireMediaLicense(helperSrc.VideoInfo);

                    ro.Debug("Verifying licenses tate after acquire...");
                    state.Verify();

                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperSrc.MachinePuid, 2, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperDst.MachinePuid, 1, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helperDst.UserPuid, 3, 0);
                }

                public override void PostRun()
                {
                    helperSrc.Cleanup();
                    helperDst.Cleanup();
                }
            }

            [TestCase, TestCasePriority(2), Description("Transfer a video and game using the soap api and verify reporting stuff.")]
            public class SoapTransfer : TestNode
            {
                LicensesState state;
                AcquireMediaLicenseHelper helperSrc;
                AcquireMediaLicenseHelper helperDst;

                public override void PreRun()
                {
                    state = new LicensesState();

                    helperSrc = new AcquireMediaLicenseHelper();
                    helperSrc.Reset();

                    helperDst = new AcquireMediaLicenseHelper(helperSrc.User);
                    helperDst.Reset(false);

                    helperSrc.Purchase(MediaMatrix.TexasHoldEmOffer);
                    state.Update_BuyGame(MediaMatrix.TexasHoldEmOffer.OfferId, helperSrc.UserPuid, helperSrc.MachinePuid);

                    var videoInfo = helperSrc.PurchaseVideo(LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode);
                    state.Update_BuyVideo(videoInfo.OfferId, helperSrc.UserPuid, helperSrc.MachinePuid);
                }

                public override void Run()
                {
                    //sanity check of licenses and purchase stuff
                    ro.Debug("Verifying initial license state...");
                    state.Verify();

                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperSrc.MachinePuid, 2, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperDst.MachinePuid, 0, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helperSrc.UserPuid, 2, 0);

                    //do the migration
                    // Note: Apparantly using the SOAP transfer API does weird stuff with video licenses
                    // in that it just seems to not do anything with them
                    LicenseMigrationUtils.WidgetTransferLicenses(helperSrc.UserPuid, helperDst.Machine.ConsoleId, helperDst.MachinePuid, state);

                    ro.Debug("Verifying license state after transfer...");
                    state.Verify();

                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperSrc.MachinePuid, 2, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperDst.MachinePuid, 0, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helperSrc.UserPuid, 2, 0);

                    helperDst.AcquireMediaLicense(helperSrc.VideoInfo);

                    ro.Debug("Verifying licenses tate after acquire...");
                    state.Verify();

                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperSrc.MachinePuid, 2, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForMachine(helperDst.MachinePuid, 0, 0);
                    LicenseMigrationUtils.VerifyReportingRowsForUser(helperDst.UserPuid, 2, 0);
                }

                public override void PostRun()
                {
                    helperSrc.Cleanup();
                    helperDst.Cleanup();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\LicenseMigration\BasicTransfers.cs ===
using System;
using System.Data.SqlClient;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
using xonline.common.config;
using SigTest.License;

namespace SigTest.LicenseMigration.Functional
{
    partial class LiceMigTests: TestNode
    {
        [TestGroup, Owner("BenRan"), TestFrequency("Regression")]
        public class BasicTransfers: MultiApiTestGroup
        {
            public override void PreRun()
            {
                //set debugpartner so it can access the api

                //widget call is the only one that needs this
                if ((int)MyValues[0] != 0)
                {
                    return;
                }

                bool didUpdate = false;

                string[] webDBServers = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.webdb);
                foreach (string server in webDBServers)
                {
                    SqlConnection c = new SqlConnection("Data Source=" + server + ";Initial Catalog=WebDB;Integrated Security=SSPI");
                    c.Open();

                    //see if its already set
                    string query = "use WebDB; select count(*) from t_partner_allowed_apis where vc_api_name='Signature.TransferUserLicenses' and i_partner_id=(select i_partner_id from t_partners where vc_subject_name='DebugPartner')";
                    SqlCommand cmd = new SqlCommand(query, c);
                    object o = cmd.ExecuteScalar();
                    if ((int)o > 0)
                    {
                        continue;
                    }

                    //update db
                    if (!didUpdate)
                    {
                        ro.Info("Setting DebugPartner permissions on the API...");
                        didUpdate = true;
                    }
                    query = "use WebDB; declare @grr int; set @grr=(select i_partner_id from t_partners where vc_subject_name='DebugPartner'); insert into t_partner_allowed_apis (i_partner_id,vc_api_name) values (@grr,'Signature.TransferUserLicenses');";
                    cmd = new SqlCommand(query, c);
                    cmd.ExecuteNonQuery();

                    c.Close();
                }

                //reload widget partners
                if (didUpdate)
                {
                    string[] widgetServers = Global.XEnv.GetServerListByInterface(Interface.wcsignature);
                    foreach (string server in widgetServers)
                    {
                        string result;
                        string xcmd = "e :wcsignature ReloadPartners";
                        bool worked = ManagementConsole.Execute(server, xcmd, out result);
                        if (worked)
                        {
                            Global.RO.Debug(server + " reloaded");
                        }
                        else
                        {
                            Global.RO.Error("Error executing \"" + xcmd + "\" on " + server + ": " + result);
                            Global.RO.Error("The DebugPartner may not be allowed to call the API as a result.");
                        }
                    }
                }
            }

            [TestCase, TestCasePriority(1), Description("Migrate one thing on a box with one user and to another box")]
            public class SimpleMigrateOne: MultiApiTestBase
            {
                LicensesState state = null;

                MediaTestHelper srcHelper;
                MediaTestHelper dstHelper;                

                public override void PreRun()
                {
                    state = new LicensesState();
                    
                    srcHelper = new MediaTestHelper();
                    srcHelper.Reset();

                    dstHelper = new MediaTestHelper(srcHelper.User);
                    dstHelper.Reset(false);

                    LicenseMigrationUtils.Purchase(srcHelper, MediaMatrix.TexasHoldEmOffer, state);

                    ro.Debug("Verifying license state...");
                    state.Verify();
                }

                public override void Run()
                {
                    ro.Info("Performing license transfer...");
                    DoTransfer(dstHelper.UserPuid, dstHelper.Machine.ConsoleId, dstHelper.MachinePuid, state);

                    ro.Debug("Verifying licenses after transfer...");
                    state.Verify();
                }

                public override void PostRun()
                {
                    srcHelper.Cleanup();
                    dstHelper.Cleanup();
                }
            }

            [TestCase, TestCasePriority(2), AsyncGroup(1), AsyncThreadDelay(200), AsyncThreadCount(5)]
            [Description("Performs a variety of purchase/migrate scenarios on multiple boxes with two users")]
            //                                        [                 user 0                ] [                  user 1               ]
            //                                         buyg0b0 buyg1b0 buyg0b1 buyg1b1 destbox   buyg0b0 buyg1b0 buyg0b1 buyg1b1 destbox
            [CompoundCase("u0=g0b0mv1     u1=g0b0nm",  true, false, false, false, 1, true,  false, false, false, -1)]
            [CompoundCase("u0=g0b0mv1     u1=g1b0nm",  true, false, false, false, 1, false, true,  false, false, -1)]
            [CompoundCase("u0=g0b0mv1     u1=g0b1nm",  true, false, false, false, 1, false, false, true,  false, -1)]
            [CompoundCase("u0=g0b0mv1     u1=g1b1nm",  true, false, false, false, 1, false, false, false, true,  -1)]
            [CompoundCase("u0=g0b0g1b0mv1 u1=g0b0nm",  true, true,  false, false, 1, true,  false, false, false, -1)]
            [CompoundCase("u0=g0b0g1b0mv1 u1=g1b0nm",  true, true,  false, false, 1, false, true,  false, false, -1)]
            [CompoundCase("u0=g0b0g1b0mv1 u1=g0b1nm",  true, true,  false, false, 1, false, false, true,  false, -1)]
            [CompoundCase("u0=g0b0g1b0mv1 u1=g1b1nm",  true, true,  false, false, 1, false, false, false, true,  -1)]
            [CompoundCase("u0=g0b0mv1     u1=g0b0mv0", true, false, false, false, 1, true,  false, false, false,  0)]
            [CompoundCase("u0=g0b0mv1     u1=g1b0mv0", true, false, false, false, 1, false, true,  false, false,  0)]
            [CompoundCase("u0=g0b0mv1     u1=g0b1mv0", true, false, false, false, 1, false, false, true,  false,  0)]
            [CompoundCase("u0=g0b0mv1     u1=g1b1mv0", true, false, false, false, 1, false, false, false, true,   0)]
            [CompoundCase("u0=g0b0g1b0mv1 u1=g0b0mv0", true, true,  false, false, 1, true,  false, false, false,  0)]
            [CompoundCase("u0=g0b0g1b0mv1 u1=g1b0mv0", true, true,  false, false, 1, false, true,  false, false,  0)]
            [CompoundCase("u0=g0b0g1b0mv1 u1=g0b1mv0", true, true,  false, false, 1, false, false, true,  false,  0)]
            [CompoundCase("u0=g0b0g1b0mv1 u1=g1b1mv0", true, true,  false, false, 1, false, false, false, true,   0)]
            [CompoundCase("u0=g0b0mv2     u1=g0b0mv2", true, false, false, false, 2, true,  false, false, false,  2)]
            [CompoundCase("u0=g0b0mv2     u1=g1b0mv2", true, false, false, false, 2, false, true,  false, false,  2)]
            [CompoundCase("u0=g0b0mv2     u1=g0b1mv2", true, false, false, false, 2, false, false, true,  false,  2)]
            [CompoundCase("u0=g0b0mv2     u1=g1b1mv2", true, false, false, false, 2, false, false, false, true,   2)]
            [CompoundCase("u0=g0b0g1b0mv2 u1=g0b0mv2", true, true,  false, false, 2, true,  false, false, false,  2)]
            [CompoundCase("u0=g0b0g1b0mv2 u1=g1b0mv2", true, true,  false, false, 2, false, true,  false, false,  2)]
            [CompoundCase("u0=g0b0g1b0mv2 u1=g0b1mv2", true, true,  false, false, 2, false, false, true,  false,  2)]
            [CompoundCase("u0=g0b0g1b0mv2 u1=g1b1mv2", true, true,  false, false, 2, false, false, false, true,   2)]
            [CompoundCase("u0=g0b0mv2     u1=g1b0mv1", true, false, false, false, 2, false, true,  false, false,  1)]
            [CompoundCase("u0=g0b0g1b1mv0 u1=g0b0mv1", true, false, false, true,  0, true,  false, false, false,  1)]
            [CompoundCase("u0=g0b0g1b1mv0",            true, false, false, true,  0, false, false, false, false, -1)]
            public class UserBoxGameMatrix : MultiApiTestBase
            {
                MediaTestHelper[][] helpers;
                LicensesState state;                

                bool buyGame0User0Box0;
                bool buyGame1User0Box0;
                bool buyGame0User0Box1;
                bool buyGame1User0Box1;
                int boxToMoveUser0To;

                bool buyGame0User1Box0;
                bool buyGame1User1Box0;
                bool buyGame0User1Box1;
                bool buyGame1User1Box1;
                int boxToMoveUser1To;


                public override void PreRun()
                {
                    //params
                    buyGame0User0Box0 = (bool)MyValues[0];
                    buyGame1User0Box0 = (bool)MyValues[1];
                    buyGame0User0Box1 = (bool)MyValues[2];
                    buyGame1User0Box1 = (bool)MyValues[3];
                    boxToMoveUser0To = (int)MyValues[4]; //-1 to not do

                    buyGame0User1Box0 = (bool)MyValues[5];
                    buyGame1User1Box0 = (bool)MyValues[6];
                    buyGame0User1Box1 = (bool)MyValues[7];
                    buyGame1User1Box1 = (bool)MyValues[8];
                    boxToMoveUser1To = (int)MyValues[9]; //-1 to not do

                    state = new LicensesState();

                    // Create all the users
                    IUser[] users = new IUser[2];
                    for (int i = 0; i < users.Length; i++)
                    {
                        users[i] = TestHelper.GetSharedUser();
                    }

                    // Then create all the machines
                    IMachine[] machines = new IMachine[3];
                    for (int i = 0; i < machines.Length; i++)
                    {
                        machines[i] = TestHelper.GetSharedMachine();
                    }

                    // Now create a helper with each user machine pair so we can easily 
                    // reference a user on a specific machine with helpers[user][machine]
                    helpers = new MediaTestHelper[users.Length][];
                    for (int i = 0; i < users.Length; i++)
                    {
                        helpers[i] = new MediaTestHelper[machines.Length];
                        for (int j = 0; j < machines.Length; j++)
                        {
                            helpers[i][j] = new MediaTestHelper(machines[j], users[i]);
                            helpers[i][j].Reset(false);
                            // When we're done with the user return them to the queu.e
                            helpers[i][j].ReuseUser = true;
                        }
                    }

                    //buy games
                    if (buyGame0User0Box0) LicenseMigrationUtils.Purchase(helpers[0][0], MediaMatrix.TexasHoldEmOffer, state);
                    if (buyGame1User0Box0) LicenseMigrationUtils.Purchase(helpers[0][0], MediaMatrix.ArcadeGame, state);
                    if (buyGame0User0Box1) LicenseMigrationUtils.Purchase(helpers[0][1], MediaMatrix.TexasHoldEmOffer, state);
                    if (buyGame1User0Box1) LicenseMigrationUtils.Purchase(helpers[0][1], MediaMatrix.ArcadeGame, state);
                    if (buyGame0User1Box0) LicenseMigrationUtils.Purchase(helpers[1][0], MediaMatrix.TexasHoldEmOffer, state);
                    if (buyGame1User1Box0) LicenseMigrationUtils.Purchase(helpers[1][0], MediaMatrix.ArcadeGame, state);
                    if (buyGame0User1Box1) LicenseMigrationUtils.Purchase(helpers[1][1], MediaMatrix.TexasHoldEmOffer, state);
                    if (buyGame1User1Box1) LicenseMigrationUtils.Purchase(helpers[1][1], MediaMatrix.ArcadeGame, state);

                    //sanity check of licenses
                    ro.Debug("Verifying initial state of the licenses...");
                    state.Verify();
                }

                public override void Run()
                {
                    //do migrations
                    if (boxToMoveUser0To != -1)
                    {
                        var dstHelper = helpers[0][boxToMoveUser0To];
                        DoTransfer(dstHelper.UserPuid, dstHelper.Machine.ConsoleId, dstHelper.MachinePuid, state);
                    }
                    if (boxToMoveUser1To != -1)
                    {
                        var dstHelper = helpers[1][boxToMoveUser1To];
                        DoTransfer(dstHelper.UserPuid, dstHelper.Machine.ConsoleId, dstHelper.MachinePuid, state);
                    }

                    //verify licenses
                    ro.Debug("Verifying licenses after transfer...");
                    state.Verify();
                }

                public override void PostRun()
                {
                    // Cleanup all the helpers.  This will safely ensure that all 
                    // users are only added to the user queue a single time.
                    for (int i = 0; i < helpers.Length; i++)
                    {
                        for (int j = 0; j < helpers[i].Length; j++)
                        {
                            helpers[i][j].Cleanup();
                        }
                    }
                }
            }

            [TestCase, TestCasePriority(2), Description("Try to migrate when a user has no licenses")]
            public void MigrateWithNoLicenses()
            {
                MediaTestHelper srcHelper = new MediaTestHelper();
                srcHelper.Reset();
                MediaTestHelper dstHelper = new MediaTestHelper(srcHelper.User);
                dstHelper.Reset();

                try
                {
                    ro.Info("Performing license transfer with no licenses.");
                    DoTransfer(dstHelper.UserPuid, dstHelper.Machine.ConsoleId, dstHelper.MachinePuid, null);
                }
                finally
                {
                    srcHelper.Cleanup();
                    dstHelper.Cleanup();
                }
            }

            [TestCase, TestCasePriority(2), Description("Try to migrate when the migration is a no-op")]
            public void MigrateToSelf()
            {
                LicensesState state=new LicensesState();

                ro.Debug("Creating original machine...");
                IMachine xmacsOrig = (MachineBase)SignatureUtils.CreateClient();

                IUser user = TestHelper.GetSharedUser();

                try
                {
                    LicenseMigrationUtils.BuyOffer(user, xmacsOrig, MediaMatrix.TexasHoldEmOffer.OfferMediaTypeExpectedPrice, state);

                    //sanity check of licenses
                    ro.Debug("Verifying licenses...");
                    state.Verify();

                    //do the migration
                    DoTransfer(user.Puid, xmacsOrig.ConsoleId, xmacsOrig.Puid, state);

                    //verify licenses
                    ro.Debug("Verifying licenses...");
                    state.Verify();
                }
                finally
                {
                    MediaTestHelper.CleanupUser(user);
                    TestHelper.ReturnSharedUser(user);
                }
            }

            [TestCase, TestCasePriority(2), Description("Create two machines with duplicate console ids, purchase content on both, migrate one, ensure other is not migrated")]
            public void MigrateToConsoleWithDuplicate()
            {
                LicensesState state = new LicensesState();

                // Create a machine to buy the license on
                ro.Debug("Creating purchase machine...");
                MachineBase purchaseMachine = MachineEditor.CreateNew(MachineType.Xbox360);

                // Create a user
                IUser user = TestHelper.GetSharedUser();
                user.MachinePuid = purchaseMachine.Puid;

                try
                {
                    //buy an arcade game
                    LicenseMigrationUtils.BuyOffer(user.Puid, purchaseMachine.Puid, MediaMatrix.TexasHoldEmOffer.OfferMediaTypeExpectedPrice, state);

                    //create a new machine that we'll move licenses to
                    ro.Debug("Creating destination machine...");
                    MachineBase destMachine = MachineEditor.CreateNew(MachineType.Xbox360);
                    // 'See' the user on the destination machine.  Basically the same as logging them in
                    UserMachineHistoryEditor.CreateOrUseExisting(user.Puid, destMachine.Puid);
                    
                    ro.Debug("Creating destination machine duplicate...");
                    MachineBase destDupeMachine = MachineEditor.CreateDuplicateXbox360(destMachine.ConsoleId);

                    // Transfer to the destination console
                    DoTransfer(user.Puid, destMachine.ConsoleId, destMachine.Puid, state);

                    // Verify licenses
                    ro.Debug("Verifying licenses...");
                    state.Verify();

                    // Just to be sure, verify that the dupe console doesn't have licences.  
                    ro.Debug("Verifying that duplicate console does not own anything");
                    LicenseMigrationUtils.VerifyOwnsOffer(MediaMatrix.TexasHoldEmOffer.OfferId, destDupeMachine.Puid, 0, false);
                }
                finally
                {
                    MediaTestHelper.CleanupUser(user);
                    TestHelper.ReturnSharedUser(user);
                }
            }

            [TestCase, TestCasePriority(2), Description("Create two machines with duplicate console ids, purchase content on both, migrate one, ensure other is not migrated")]
            public void MigrateFromConsoleWithDuplicate()
            {
                LicensesState state = new LicensesState();

                // Create a machine to buy the license on
                ro.Debug("Creating purchase machine...");
                MachineBase purchaseMachine = MachineEditor.CreateNew(MachineType.Xbox360);
                MachineBase purchaseDupeMachine = MachineEditor.CreateDuplicateXbox360(purchaseMachine.ConsoleId);

                // Create a user
                IUser user = TestHelper.GetSharedUser();
                user.MachinePuid = purchaseMachine.Puid;

                IUser secondUser = TestHelper.GetSharedUser();
                secondUser.MachinePuid = purchaseDupeMachine.Puid;

                try
                {
                    // Buy an arcade game on one machine
                    LicenseMigrationUtils.BuyOffer(user.Puid, purchaseMachine.Puid, MediaMatrix.TexasHoldEmOffer.OfferMediaTypeExpectedPrice, state);
                    // And another on the dupe (with another user)
                    LicenseMigrationUtils.BuyOffer(secondUser.Puid, purchaseDupeMachine.Puid, MediaMatrix.TexasHoldEmOffer.OfferMediaTypeExpectedPrice, state);

                    //create a new machine that we'll move licenses to
                    ro.Debug("Creating destination machine...");
                    MachineBase destMachine = MachineEditor.CreateNew(MachineType.Xbox360);

                    // Transfer to the destination console
                    DoTransfer(user.Puid, destMachine.ConsoleId, destMachine.Puid, state);

                    // Verify licenses
                    ro.Debug("Verifying licenses...");
                    state.Verify();

                    // Just to be sure, verify that the dupe console doesn't have licences.  
                    ro.Debug("Verifying that duplicate console still has a license");
                    LicenseMigrationUtils.VerifyOwnsOffer(MediaMatrix.TexasHoldEmOffer.OfferId, purchaseDupeMachine.Puid, 0, true);
                }
                finally
                {
                    MediaTestHelper.CleanupUser(user);
                    TestHelper.ReturnSharedUser(user);
                }

            }

            [TestCase, TestCasePriority(3), Description("Purchase on one platform and try to migrate to another.. nothing should happen")]
            public class PCPurchaseMigrateToXenon : MultiApiTestBase
            {
                LicensesState state;
                IMachine xmacsSrc;
                IMachine xmacsDst;
                IUser user;

                public override void PreRun()
                {
                    state = new LicensesState();

                    //make the 2 machines
                    ro.Debug("Creating machines...");
                    xmacsSrc = (MachineBase)SignatureUtils.CreateClient(AuthContext.ClientTypes.Panorama);
                    xmacsDst = (MachineBase)SignatureUtils.CreateClient(AuthContext.ClientTypes.Xenon);

                    user = TestHelper.GetSharedUser();
                    LicenseMigrationUtils.BuyOffer(user.Puid, xmacsSrc.Puid, MediaMatrix.TexasHoldEmOffer.OfferMediaTypeExpectedPrice, state);
                }

                public override void Run()
                {
                    //do the migration
                    DoTransfer(user.Puid, xmacsDst.ConsoleId, xmacsDst.Puid, state);

                    //verify licenses
                    ro.Debug("Verifying licenses...");
                    state.Verify();
                }
            }

            [TestCase, TestCasePriority(3), Description("Buy on box 0, ban box 0, migrate to box 1.  We're nice, so we let that work.")]
            public void MigrateFromBannedMachine()
            {
                LicensesState state = new LicensesState();

                //create a machine to buy the license on
                ro.Debug("Creating original machine...");
                IMachine xmacsOrig = (MachineBase)SignatureUtils.CreateClient();

                IUser user = TestHelper.GetSharedUser();

                try
                {
                    //buy an arcade game
                    LicenseMigrationUtils.BuyOffer(user, xmacsOrig, MediaMatrix.TexasHoldEmOffer.OfferMediaTypeExpectedPrice, state);

                    //ban the original machine
                    ProcessWrapper pr = new ProcessWrapper("MachineBan", "MachineBan.exe");
                    pr.SetEnvironmentVariable("XBL_CONFIG_SERVER", Global.CurrentEnvironment.NpdbIp);
                    pr.SetEnvironmentVariable("XBL_CONFIG_DATABASE", Global.CurrentEnvironment.NpdbName);
                    pr.EchoOutput = true;
                    pr.ExecutionTimeout = 60;
                    pr.Run("/ban:" + xmacsOrig.ConsoleId + " /consoleid /reason:LicenseMigrationTests");

                    //create a new machine that we'll move licenses to
                    ro.Debug("Creating destination machine...");
                    XmacsClient xmacsNew = SignatureUtils.CreateClient();

                    //do the migration
                    DoTransfer(user.Puid, xmacsNew.ConsoleId, xmacsNew.GetMachinePuid(), state);

                    //verify licenses
                    ro.Debug("Verifying licenses...");
                    state.Verify();
                }
                finally
                {
                    MediaTestHelper.CleanupUser(user);
                    TestHelper.ReturnSharedUser(user);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\LicenseMigration\Stress.cs ===
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.UserAccount;
using System;
using ServerTestFramework.LiveService.Billing;
using SigTest.License;
using xonline.common.billing;
using System.Collections.Generic;

namespace SigTest.LicenseMigration.Stress
{
    [TestGroup, Owner("BenRan"), TestFrequency("Regression")]
    public class LiceMigStress : TestNode
    {
        /// <summary>
        /// Wraps up all the user information that we need to perform
        /// the license migration test.  This also includes some info
        /// about failure counts so that we can discard users that are
        /// continually failing for whatever reason
        /// </summary>
        public class User
        {
            public ulong Puid;
            public int GameCount;
            public int VideoCount;

            public int ErrorsThisPass;
            public int ErrorsInLife;
        };

        #region Setup and Helpers
        static TimedQueue<IMachine> machines = new TimedQueue<IMachine>();

        static TimedQueue<User> usersReady = new TimedQueue<User>();
        static TimedQueue<User> usersAwaitingPresence = new TimedQueue<User>();
        static TimedQueue<User> usersAwaitingConfirmation = new TimedQueue<User>();
        static TimedQueue<User> usersFinished = new TimedQueue<User>();

        private static List<GameInformation> gameOffers;

        //offers base values to use for if we are using fake users
        public const ulong FakeGameOfferBase = 0xB00B00Ca7F00d000;
        public const ulong FakeVideoOfferBase = 0xB00B00D06F00d000;

        //setup stress stuff
        public override void PreRun()
        {
            machines.MinimumReuseTime = new TimeSpan(0, 0, 10);
            usersReady.MinimumReuseTime = new TimeSpan(0, 0, 2);
            usersAwaitingPresence.MinimumReuseTime = new TimeSpan(0, 0, 3);
            usersAwaitingConfirmation.MinimumReuseTime = new TimeSpan(0, 0, 3);
            usersFinished.MinimumReuseTime = new TimeSpan(0, 0, 1);

            LicenseMigrationUtils.VerboseOutput = false;
            ServerTestFramework.LiveService.PresNotiCommon.PNUser.Verbose = false;

            gameOffers = new List<GameInformation>();
            
            
            // Create 10 random offers
            for (int i = 0; i < 10; i++)
            {
                LicenseType licenseType = (LicenseType)RandomEx.GlobalRandGen.Next(11, 15);
                gameOffers.Add(GameInformation.Generate(licenseType, MediaTypeInfo.ArcadeGame));
            }

            //TODO: video stuff
        }

        public override void PostRun()
        {
            LicenseMigrationUtils.VerboseOutput = true;
            ServerTestFramework.LiveService.PresNotiCommon.PNUser.Verbose = true;

            gameOffers.ForEach(game => game.RemoveFromCatalog());
        }

        public static void AddNewMachineToPool()
        {
            try
            {
                machines.PushBack((MachineBase)MachineEditor.CreateNew());
            }
            catch (System.Exception e)
            {
                Global.RO.Warn("Exception creating machine: " + e);
            }
        }

        private static int concurrentUserCreation = 0; //because billing user creation collapses when pushed too hard
        public static void AddNewUserToPool()
        {
            int maxThreadsAllowed = (LicenseMigrationUtils.LiceMigSettings.UseFakeUsersForStress ? 60 : 2);
            if (concurrentUserCreation >= maxThreadsAllowed)
            {
                Global.RO.Warn("Bailing out on user creation because there are already at least " + maxThreadsAllowed + " threads trying to create users.");
                return;
            }

            //we need a machine
            IMachine machine = (MachineBase)MachineEditor.CreateNew();

            //now make the user
            System.Threading.Interlocked.Increment(ref concurrentUserCreation);
            try
            {
                User user = new User();
                System.DateTime creationTime;

                if (!LicenseMigrationUtils.LiceMigSettings.UseFakeUsersForStress) //make real billing users to use
                {
                    //do creation
                    XeUser xeuser = AuthContext.MakeNewBillingUser(false, true, true);
                    creationTime = System.DateTime.UtcNow;
                    user.Puid = xeuser.UserPuid;

                    //add some content to them
                    int games = ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(4);
                    int vids = ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(20);
                    user.GameCount = games;
                    user.VideoCount = vids;

                    for (int i = 0; i < games; ++i)
                    {
                        GameInformation gameInfo = gameOffers[RandomEx.GlobalRandGen.Next(gameOffers.Count) - 1];
                        LicenseMigrationUtils.BuyOffer(user.Puid, machine.Puid, gameInfo.OfferMediaTypeExpectedPrice, null);
                    }

                    for (int i = 0; i < vids; ++i)
                    {
                        LicenseMigrationUtils.BuyNewFakeRandomVideo(xeuser, machine.Puid);
                    }
                }
                else //directly create users and add content to them, in the db
                {
                    UserEditor ue = UserEditor.CreateNew();
                    creationTime = System.DateTime.UtcNow;
                    user.Puid = ue.Puid;

                    //add some content to them (TODO: video stuff)
                    int games = ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(100);
                    user.GameCount = games;

                    for (int i = 0; i < games; ++i)
                    {
                        ue.AddPurchasedLicense(FakeGameOfferBase + (ulong)i, machine.Puid);
                    }
                }

                //wait on xcache if needed, then place them into the pool
                int secondsToWait = 31 - (int)(System.DateTime.UtcNow - creationTime).TotalSeconds;
                if (secondsToWait > 0)
                {
                    Global.RO.Debug("Waiting " + secondsToWait + " seconds before adding user 0x{0:X} to pool...", user.Puid);
                    System.Threading.Thread.Sleep(secondsToWait * 1000);
                }

                Global.RO.Debug(String.Format("Adding user 0x{0:X16} to pool with {1} games and {2} videos on machine 0x{3:X16}",
                                user.Puid, user.GameCount, user.VideoCount, machine.Puid));
                usersReady.PushBack(user);
            }
            catch (System.Exception e)
            {
                Global.RO.Warn("Exception creating/setting up user: " + e);
            }
            finally
            {
                System.Threading.Interlocked.Decrement(ref concurrentUserCreation);
                machines.PushBack(machine);
            }
        }

        //Returns a user from a random pool, or null if none can be found.  The pool the user was taken from is also returned.
        public static User GetUserFromAnyPool(out TimedQueue<User> userPool)
        {
            //try each pool starting from a random one
            int offset = ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(4);
            for (int i = 0; i < 4; ++i)
            {
                int pool = (i + offset) % 4;

                if (pool == 0)
                {
                    User user = usersReady.PopFront();
                    if (user != null)
                    {
                        userPool = usersReady;
                        return user;
                    }
                }
                else if (pool == 1)
                {
                    User user = usersAwaitingPresence.PopFront();
                    if (user != null)
                    {
                        userPool = usersAwaitingPresence;
                        return user;
                    }
                }
                else if (pool == 2)
                {
                    User user = usersAwaitingConfirmation.PopFront();
                    if (user != null)
                    {
                        userPool = usersAwaitingConfirmation;
                        return user;
                    }
                }
                else if (pool == 3)
                {
                    User user = usersFinished.PopFront();
                    if (user != null)
                    {
                        userPool = usersFinished;
                        return user;
                    }
                }
            }

            userPool = null;
            return null;
        }

        #endregion //Setup and Helpers

        // -- soap API (support)

        [StressTest, Description("Use the WebCache SOAP api to migrate a user.")]
        public class SoapMigrate : TestNode
        {
            public override void Run()
            {
                //grab a machine and a user
                IMachine mach = machines.PopFront();
                if (mach == null)
                {
                    Global.RO.Debug("Pool has no available machines, adding one.");
                    AddNewMachineToPool();
                    throw new DidNotExecuteException("Pool has no available machines, adding one.");
                    
                }

                TimedQueue<User> pool;
                User user = GetUserFromAnyPool(out pool);
                if (user == null)
                {
                    Global.RO.Debug("Pools have no available users, adding one.");
                    machines.PushBack(mach); //return to pool
                    AddNewUserToPool();
                    throw new DidNotExecuteException("Pool has no available users, adding one.");                    
                }

                try
                {
                    //migrate
                    LicenseMigrationUtils.WidgetTransferLicenses(user.Puid, mach.ConsoleIdNoPrefix, mach.Puid, null);

                    //verify counts for machine
                    //TODO:
                }
                finally
                {
                    //return to pool
                    machines.PushBack(mach);
                    pool.PushBack(user);
                }
            }
        }

        #region XRL API (xbox.com)
        // IMPORTANT:  All of the Xrl Step# tests MUST be run at the same speed to keep the pools balanced.  The recycle step may (and should) be run faster.

        [StressTest, Description("Use the xsig XRL api to start a license transfer")]
        public class XrlUpdateLicenseTransferState_Step1Start : TestNode
        {
            public override void Run()
            {
                //grab a machine and a user
                IMachine mach = machines.PopFront();
                if (mach == null)
                {
                    Global.RO.Debug("Pool has no available machines, adding one.");
                    AddNewMachineToPool();
                    throw new DidNotExecuteException("Pool has no available machines, adding one.");
                }

                User user = usersReady.PopFront();
                if (user == null)
                {
                    Global.RO.Debug("Ready pool has no available users, adding one.");
                    machines.PushBack(mach); //return machine to pool
                    AddNewUserToPool();
                    throw new DidNotExecuteException("Pool has no available users, adding one.");
                }

                //start migration
                try
                {
                    LicenseMigrationUtils.DoXrlStartMigration(user.Puid);

                    //move them to the next step
                    usersAwaitingPresence.PushBack(user);

                    //TODO: verify stuff
                }
                catch (System.Exception)
                {
                    ++user.ErrorsThisPass;

                    if (user.ErrorsThisPass >= 2) //recycle user
                    {
                        usersFinished.PushBack(user);
                    }
                    else //retry user
                    {
                        usersReady.PushBack(user);
                    }

                    throw;
                }
                finally
                {
                    //return to pool
                    machines.PushBack(mach);
                }
            }
        }

        [StressTest, Description("Sign into presence with the user, which sets their console info into uodb.")]
        public class XrlUpdateLicenseTransferState_Step2SignInPresence : TestNode
        {
            public override void Run()
            {
                //grab a machine and a user
                IMachine mach = machines.PopFront();
                if (mach == null)
                {
                    Global.RO.Debug("Pool has no available machines, adding one.");
                    AddNewMachineToPool();
                    throw new DidNotExecuteException("Pool has no available machines, adding one.");                    
                }

                User user = usersAwaitingPresence.PopFront();
                if (user == null)
                {
                    Global.RO.Debug("WaitingForPresense pool has no available users, so executing step1 to rebalance pool.");
                    machines.PushBack(mach); //return machine to pool

                    //run step1 instead, since it bottlenecked us
                    try
                    {
                        XrlUpdateLicenseTransferState_Step1Start step1 = new XrlUpdateLicenseTransferState_Step1Start();
                        step1.Run();
                    }
                    catch (System.Exception e) //don't blame us for a step 1 failure.. it's too bad we can't blame step 1 if it fails though.
                    {
                        Global.RO.Error("Error executing step 1 from step 2: " + e);
                    }

                    throw new DidNotExecuteException("WaitingForPresence pool has no available users, executed step 1 to rebalance pool.");
                }

                try
                {
                    LicenseMigrationUtils.SignInPresence(user.Puid, mach.Puid);

                    //move them to the next step
                    usersAwaitingConfirmation.PushBack(user);

                    //TODO: verify stuff
                }
                catch (System.Exception)
                {
                    ++user.ErrorsThisPass;

                    if (user.ErrorsThisPass >= 2) //recycle user
                    {
                        usersFinished.PushBack(user);
                    }
                    else //retry user
                    {
                        usersAwaitingPresence.PushBack(user);
                    }

                    throw;
                }
                finally
                {
                    //return to pool
                    machines.PushBack(mach);
                }
            }
        }

        [StressTest, Description("Use the xsig XRL api to complete the license transfer")]
        public class XrlUpdateLicenseTransferState_Step3Complete : TestNode
        {
            public override void Run()
            {
                //grab a machine and a user
                IMachine mach = machines.PopFront();
                if (mach == null)
                {
                    Global.RO.Debug("Pool has no available machines, adding one.");
                    AddNewMachineToPool();
                    throw new DidNotExecuteException("Pool has no available machines, adding one.");
                }

                User user = usersAwaitingConfirmation.PopFront();
                if (user == null)
                {
                    Global.RO.Debug("WaitingForComplete pool has no available users, so executing step2 to rebalance pool.");
                    machines.PushBack(mach); //return machine to pool

                    //run step2 instead, since it bottlenecked us
                    try
                    {
                        XrlUpdateLicenseTransferState_Step2SignInPresence step2 = new XrlUpdateLicenseTransferState_Step2SignInPresence();
                        step2.Run();
                    }
                    catch (System.Exception e) //don't blame us for a step 2 failure.. it's too bad we can't blame step 2 if it fails though.
                    {
                        Global.RO.Error("Error executing step 2 from step 3: " + e);
                    }

                    throw new DidNotExecuteException("WaitingForComplete pool has no available users, so executing step2 to rebalance pool.");
                }

                try
                {
                    LicenseMigrationUtils.DoXrlCompleteMigration(user.Puid, mach.Puid, null);

                    //move them to the next step
                    usersFinished.PushBack(user);

                    //TODO: verify stuff
                }
                catch (System.Exception)
                {
                    ++user.ErrorsThisPass;

                    if (user.ErrorsThisPass >= 2) //recycle user
                    {
                        usersFinished.PushBack(user);
                    }
                    else //retry user
                    {
                        usersAwaitingConfirmation.PushBack(user);
                    }

                    throw;
                }
                finally
                {
                    //return to pool
                    machines.PushBack(mach);
                }
            }
        }

        [StressTest, Description("Adjust a user's last transfer time, so that they can be used again for a license transfer.")]
        public class XrlUpdateLicenseTransferState_Step4Recycle : TestNode
        {
            public override void Run()
            {
                //grab a finished user that is ready to be recycled... there may be none
                User user = usersFinished.PopFront();
                if (user == null)
                {
                    throw new DidNotExecuteException("No completed users available");
                }

                //accumulate errors.. if they seem to be a runt, throw them out
                user.ErrorsInLife += user.ErrorsThisPass;
                user.ErrorsThisPass = 0;

                if (user.ErrorsInLife >= 20)
                {
                    throw new UnexpectedTestResultException("User " + user.Puid + " had over 20 lifetime errors.  We are throwing it out of the pool.");
                }

                //recycle the user back to the ready pool
                try
                {
                    //advance time for the user so they can migrate again
                    LicenseMigrationUtils.AdvanceTimeOnLicenseTransferState(user.Puid, new TimeSpan(366, 0, 0, 0));
                }
                catch (System.Exception)
                {
                    //give it 1 more shot in case it was just webstore crudding out on us.. if this fails.. we'll just toss the user
                    LicenseMigrationUtils.AdvanceTimeOnLicenseTransferState(user.Puid, new TimeSpan(366, 0, 0, 0));
                }

                usersReady.PushBack(user);
            }
        }

        [StressTest, Description("Use the XSig XRL API to get a user's license transfer state.")]
        public class XrlGetLicenseTransferState : TestNode
        {
            public override void Run()
            {
                //grab a user
                TimedQueue<User> pool;
                User user = GetUserFromAnyPool(out pool);
                if (user == null)
                {
                    Global.RO.Debug("Pools have no available users, adding one.");
                    AddNewUserToPool();
                    throw new DidNotExecuteException("Pools have no available users, added one.");
                }

                try
                {
                    LicenseMigrationUtils.DoXrlGetTransferStatus(user.Puid);
                }
                finally
                {
                    //return to pool
                    pool.PushBack(user);
                }
            }
        }
        #endregion

        #region XRL API (Console)
        [StressTest, Description("Use the XSig XRL API to start a license transfer from a console")]
        public class XrlUpdateLicenseTransferState_Console_Step1Start : TestNode
        {
            public override void Run()
            {
                //grab a machine and a user
                IMachine mach = machines.PopFront();
                if (mach == null)
                {
                    Global.RO.Debug("Pool has no available machines, adding one.");
                    AddNewMachineToPool();
                    throw new DidNotExecuteException("Pool has no available machines, adding one.");
                }

                User user = usersReady.PopFront();
                if (user == null)
                {
                    Global.RO.Debug("Ready pool has no available users, adding one.");
                    machines.PushBack(mach); //return machine to pool
                    AddNewUserToPool();
                    throw new DidNotExecuteException("Pool has no available users, adding one.");
                }

                //start migration
                try
                {
                    LicenseMigrationUtils.DoXrlStartMigration(user.Puid, mach.Puid, true);

                    //move them to the last step
                    usersAwaitingConfirmation.PushBack(user);
                }
                catch (System.Exception)
                {
                    ++user.ErrorsThisPass;

                    if (user.ErrorsThisPass >= 2) //recycle user
                    {
                        usersFinished.PushBack(user);
                    }
                    else //retry user
                    {
                        usersReady.PushBack(user);
                    }

                    throw;
                }
                finally
                {
                    //return to pool
                    machines.PushBack(mach);
                }
            }
        }

        [StressTest, Description("Use the XSig XRL API to complete a license transfer from a console")]
        public class XrlUpdateLicenseTransferState_Console_Step2Complete : TestNode
        {
            public override void Run()
            {
                //grab a machine and a user
                IMachine mach = machines.PopFront();
                if (mach == null)
                {
                    Global.RO.Debug("Pool has no available machines, adding one.");
                    AddNewMachineToPool();
                    throw new DidNotExecuteException("Pool has no available machines, adding one.");
                }

                User user = usersAwaitingConfirmation.PopFront();
                if (user == null)
                {
                    Global.RO.Debug("WaitingForComplete pool has no available users, so executing step2 to rebalance pool.");
                    machines.PushBack(mach); //return machine to pool

                    throw new DidNotExecuteException("WaitingForComplete pool has no available users.");
                }

                try
                {
                    LicenseMigrationUtils.DoXrlCompleteMigration(user.Puid, mach.Puid, true, null);

                    //move them to the next step
                    usersFinished.PushBack(user);
                }
                catch (System.Exception)
                {
                    ++user.ErrorsThisPass;

                    if (user.ErrorsThisPass >= 2) //recycle user
                    {
                        usersFinished.PushBack(user);
                    }
                    else //retry user
                    {
                        usersAwaitingConfirmation.PushBack(user);
                    }

                    throw;
                }
                finally
                {
                    //return to pool
                    machines.PushBack(mach);
                }
            }
        }

        [StressTest, Description("Use the XSig XRL API to get a user's license transfer state.")]
        public class XrlGetLicenseTransferState_Console : TestNode
        {
            public override void Run()
            {
                //grab a machine
                IMachine mach = machines.PopFront();
                if (mach == null)
                {
                    Global.RO.Debug("Pool has no available machines, adding one.");
                    AddNewMachineToPool();
                    throw new DidNotExecuteException("Pool has no available machines, adding one.");
                }

                //grab a user
                TimedQueue<User> pool;
                User user = GetUserFromAnyPool(out pool);
                
                if (user == null)
                {
                    Global.RO.Debug("Pools have no available users, adding one.");
                    AddNewUserToPool();
                    throw new DidNotExecuteException("Pools have no available users, added one.");
                }

                try
                {
                    LicenseMigrationUtils.DoXrlGetTransferStatus(user.Puid, mach.Puid, true);
                }
                finally
                {
                    //return to pool
                    pool.PushBack(user);
                    machines.PushBack(mach);
                }
            }
        }
        #endregion

        [StressTest]
        public void DebugStatus()
        {
            Global.RO.Debug("Machine pool size: " + machines.Count);
            Global.RO.Debug("User pool size (ready): " + usersReady.Count);
            Global.RO.Debug("User pool size (awaiting presence): " + usersAwaitingPresence.Count);
            Global.RO.Debug("User pool size (awaiting confirmation): " + usersAwaitingConfirmation.Count);
            Global.RO.Debug("User pool size (finished): " + usersFinished.Count);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\LicenseMigration\XrlApi.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
using xonline.common.protocol;
using xonline.common.config;
using SigTest.License;

namespace SigTest.LicenseMigration.Functional
{
    partial class LiceMigTests: TestNode
    {
        [TestGroup, AsyncThreadCount(3), AsyncThreadDelay(1000), AsyncGroup(1,0), Owner("BenRan"), TestFrequency("Regression")]
        public class XrlSteppedApi: TestNode
        {
            [TestCase, TestCasePriority(1)]
            public void Simple()
            {
                LicensesState state = new LicensesState();

                //create machines to buy a license on and to migrate to
                ro.Debug("Creating machine...");
                MachineBase xmacsOrig = SignatureUtils.CreateClient();
                MachineBase xmacsNew = SignatureUtils.CreateClient();

                //make a user
                IUser user = TestHelper.GetSharedUser();
                user.MachinePuid = xmacsOrig.Puid;

                //buy an arcade game
                LicenseMigrationUtils.BuyOffer(user, xmacsOrig, MediaMatrix.TexasHoldEmOffer.OfferMediaTypeExpectedPrice, state);

                //verify initial state
                ro.Debug("Verifying licenses...");
                state.Verify();
                ro.Debug("Verifying GetLicenseTransferState...");
                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.NotStarted, true, null, state);

                //now start the process
                LicenseMigrationUtils.DoXrlStartMigration(user.Puid);
                DateTime lastUpdate = DateTime.UtcNow;
                ro.Debug("Verifying licenses...");
                state.Verify();
                ro.Debug("Verifying GetLicenseTransferState...");
                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.PendingConsoleSignIn, true, lastUpdate, state);

                //sign in presense
                LicenseMigrationUtils.SignInPresence(user.Puid, xmacsNew.Puid);
                lastUpdate = DateTime.UtcNow;
                ro.Debug("Verifying licenses...");
                state.Verify();
                ro.Debug("Verifying GetLicenseTransferState...");
                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, xmacsNew.ConsoleId, xmacsNew.Puid, LicenseTransferStatusEnum.PendingUserConfirmation, true, lastUpdate, state);

                //confirm it to finish
                LicenseMigrationUtils.DoXrlCompleteMigration(user.Puid, xmacsNew.Puid, state);
                lastUpdate = DateTime.UtcNow;
                ro.Debug("Verifying licenses...");
                state.Verify();
                ro.Debug("Verifying GetLicenseTransferState...");
                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, xmacsNew.ConsoleId, xmacsNew.Puid, LicenseTransferStatusEnum.Completed, false, lastUpdate, state);
            }

            [TestCase, TestCasePriority(2)]
            [CompoundCase("Same Machine", 1, 1, false)]
            [CompoundCase("Different Machines", 1, 2, false)]
            [CompoundCase("Different Machines With Orig First",  0, 1, false)]
            [CompoundCase("Different Machines With Orig Last",   1, 0, false)]
            public class SignIntoPresenceTwice: TestNode
            {
                public override void Run()
                {
                    bool shouldWork=(bool)MyValues[2];
                    LicensesState state=new LicensesState();

                    //create a machine to buy the license on
                    ro.Debug("Creating machines...");
                    XmacsClientWrapper[] xmacs = new XmacsClientWrapper[3];
                    xmacs[0]=SignatureUtils.CreateClient();
                    xmacs[1]=SignatureUtils.CreateClient();
                    xmacs[2]=SignatureUtils.CreateClient();
                    xmacs[0].SignInXmacs();
                    xmacs[1].SignInXmacs();
                    xmacs[2].SignInXmacs();

                    //make a user
                    IUser user = TestHelper.GetSharedUser();
                    user.MachinePuid = xmacs[0].Puid;

                    //buy an arcade game
                    LicenseMigrationUtils.BuyOffer(user, xmacs[0], MediaMatrix.TexasHoldEmOffer.OfferMediaTypeExpectedPrice, state);

                    //verify initial state
                    ro.Debug("Verifying licenses...");
                    state.Verify();
                    ro.Debug("Verifying GetLicenseTransferState...");
                    LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.NotStarted, true, null, state);

                    //now start the process
                    LicenseMigrationUtils.DoXrlStartMigration(user.Puid);
                    DateTime lastUpdate=DateTime.UtcNow;
                    ro.Debug("Verifying licenses...");
                    state.Verify();
                    ro.Debug("Verifying GetLicenseTransferState...");
                    LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.PendingConsoleSignIn, true, lastUpdate, state);

                    //sign in presense twice
                    int firstMachInd=(int)MyValues[0];
                    int secondMachInd=(int)MyValues[1];
                    LicenseMigrationUtils.SignInPresence(user.Puid, xmacs[firstMachInd].Puid);
                    LicenseMigrationUtils.SignInPresence(user.Puid, xmacs[secondMachInd].Puid);
                    lastUpdate=DateTime.UtcNow;

                    ro.Debug("Verifying licenses...");
                    state.Verify();

                    ro.Debug("Verifying GetLicenseTransferState...");
                    if (shouldWork)
                    {
                        LicenseMigrationUtils.VerifyTransferStatus(user.Puid, xmacs[secondMachInd].ConsoleId, xmacs[secondMachInd].Puid, LicenseTransferStatusEnum.PendingUserConfirmation, true, lastUpdate, state);
                    }
                    else
                    {
                        LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.MultipleSignInDetected, true, lastUpdate, state);
                    }

                    //confirm it
                    if (shouldWork)
                    {
                        LicenseMigrationUtils.DoXrlCompleteMigration(user.Puid, xmacs[secondMachInd].Puid, state);
                    }
                    else
                    {
                        try
                        {
                            LicenseMigrationUtils.DoXrlCompleteMigration(user.Puid, xmacs[secondMachInd].Puid, null);
                            throw new UnexpectedTestResultException("Did not expect call to complete to succeed.");
                        }
                        catch (LicenseMigrationUpdateException xmce)
                        {
                            if (xmce.XErr != HResult.XONLINE_E_SIGNATURE_LICENSE_TRANSFER_BAD_COMMAND)
                            {
                                throw;
                            }
                        }
                    }

                    ro.Debug("Verifying licenses...");
                    state.Verify();

                    ro.Debug("Verifying GetLicenseTransferState...");
                    if (shouldWork)
                    {
                        LicenseMigrationUtils.VerifyTransferStatus(user.Puid, xmacs[secondMachInd].ConsoleId, xmacs[secondMachInd].Puid, LicenseTransferStatusEnum.Completed, false, lastUpdate, state);
                    }
                    else
                    {
                        LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.MultipleSignInDetected, true, lastUpdate, state);
                        
                        //if it failed, verify that we can start again still
                        ro.Debug("Verifying that we can still start over...");
                        LicenseMigrationUtils.DoXrlStartMigration(user.Puid);
                        lastUpdate = DateTime.UtcNow;
                        LicenseMigrationUtils.VerifyTransferStatus(user.Puid, "", 0, LicenseTransferStatusEnum.PendingConsoleSignIn, true, lastUpdate, state);
                    }
                }
            }

            [TestCase, TestCasePriority(3)]
            [CompoundCase("After Start", true, false)]
            [CompoundCase("After Presence", false, true)]
            public class Timeout: TestNode
            {
                LicensesState state;

                IUser user;
                IMachine machineOrig;
                IMachine machineNew;

                Boolean timeoutAfterStart;
                Boolean timeoutAfterPres;

                public override void PreRun()
                {
                    timeoutAfterStart = (bool)MyValues[0];
                    timeoutAfterPres = (bool)MyValues[1];

                    state = new LicensesState();

                    //create machines to buy a license on and to migrate to
                    ro.Debug("Creating machine...");
                    machineOrig = (MachineBase)SignatureUtils.CreateClient();
                    machineNew = (MachineBase)SignatureUtils.CreateClient();

                    //make a user
                    user = TestHelper.GetSharedUser();
                    user.MachinePuid = machineOrig.Puid;

                    //buy an arcade game
                    LicenseMigrationUtils.BuyOffer(user, machineOrig, MediaMatrix.TexasHoldEmOffer.OfferMediaTypeExpectedPrice, state);

                    //verify initial state
                    ro.Debug("Verifying licenses...");
                    state.Verify();
                    ro.Debug("Verifying GetLicenseTransferState...");
                    LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.NotStarted, true, null, state);
                }

                public override void Run()
                {
                    // Start the transfer process
                    LicenseMigrationUtils.DoXrlStartMigration(user.Puid);
                    DateTime lastUpdate = DateTime.UtcNow;
                    state.Verify();

                    TimeSpan transferTimeout = LicenseMigrationUtils.LiceMigSettings.DefaultTransferTimeoutTime + TimeSpan.FromMinutes(1);

                    if (timeoutAfterStart)
                    {
                        LicenseMigrationUtils.AdvanceTimeOnLicenseTransferState(user.Puid, transferTimeout);
                        lastUpdate -= transferTimeout;
                        LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, machineNew.Puid, LicenseTransferStatusEnum.LicenseTransferTimeout, true, lastUpdate, state);
                    }
                    else
                    {
                        LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, machineNew.Puid, LicenseTransferStatusEnum.PendingConsoleSignIn, true, lastUpdate, state);
                    }

                    LicenseMigrationUtils.SignInPresence(user.Puid, machineNew.Puid);
                    if (!timeoutAfterStart)
                    {
                        lastUpdate = DateTime.UtcNow;
                    }
                    ro.Debug("Verifying licenses...");
                    state.Verify();

                    if (timeoutAfterPres || timeoutAfterStart)
                    {
                        if (timeoutAfterPres)
                        {
                            LicenseMigrationUtils.AdvanceTimeOnLicenseTransferState(user.Puid, transferTimeout);
                            lastUpdate -= transferTimeout;
                        }

                        LicenseMigrationUtils.VerifyTransferStatus(user.Puid, machineNew.ConsoleId, machineNew.Puid, LicenseTransferStatusEnum.LicenseTransferTimeout, true, null, state);
                    }
                    else
                    {
                        LicenseMigrationUtils.VerifyTransferStatus(user.Puid, machineNew.ConsoleId, machineNew.Puid, LicenseTransferStatusEnum.PendingUserConfirmation, true, lastUpdate, state);
                    }

                    // Verify that an attempt to complete it fails
                    try
                    {
                        LicenseMigrationUtils.DoXrlCompleteMigration(user.Puid, machineNew.Puid, state);
                        lastUpdate = DateTime.UtcNow;

                        throw new UnexpectedTestResultException("Did not expect call to complete to succeed.");
                    }
                    catch (LicenseMigrationUpdateException xmce)
                    {
                        if (xmce.XErr != HResult.XONLINE_E_SIGNATURE_LICENSE_TRANSFER_BAD_COMMAND)
                        {
                            throw;
                        }
                    }

                    ro.Debug("Verifying licenses...");
                    state.Verify();

                    if (timeoutAfterPres || timeoutAfterStart)
                    {
                        LicenseMigrationUtils.VerifyTransferStatus(user.Puid, machineNew.ConsoleId, machineNew.Puid, LicenseTransferStatusEnum.LicenseTransferTimeout, true, lastUpdate, state);

                        //verify that we can start it again still
                        ro.Debug("Verifying that we can still start over...");
                        LicenseMigrationUtils.DoXrlStartMigration(user.Puid);
                        lastUpdate = DateTime.UtcNow;
                        LicenseMigrationUtils.VerifyTransferStatus(user.Puid, "", 0, LicenseTransferStatusEnum.PendingConsoleSignIn, true, lastUpdate, state);
                    }
                    else
                    {
                        LicenseMigrationUtils.VerifyTransferStatus(user.Puid, machineNew.ConsoleId, machineNew.Puid, LicenseTransferStatusEnum.Completed, false, lastUpdate, state);
                    }
                }
            }

            [TestCase, TestCasePriority(2)]
            [CompoundCase("Immediately", "0:0:0", false)]
            [CompoundCase("1 minute", "0:1:0", false)]
            [CompoundCase("1 day", "1.0:0:0", false)]
            [CompoundCase("1 day before limit", "-1.0:0:0", false)]
            [CompoundCase("1 day after limit", "1.0:0:0", true)]
            public class MigrateAgain : TestNode
            {
                public override void Run()
                {
                    TimeSpan timeToAdvance = TimeSpan.Parse((String)MyValues[0]);
                    bool expectSuccess = (bool)MyValues[1];
                    LicensesState state = new LicensesState();

                    //create machines, user, and buy game
                    ro.Debug("Creating users and machines...");
                    MachineBase origMachine = MachineEditor.CreateNew(MachineType.Xbox360);
                    MachineBase destMachine1 = MachineEditor.CreateNew(MachineType.Xbox360);
                    MachineBase destMachine2 = MachineEditor.CreateNew(MachineType.Xbox360);

                    IUser user = TestHelper.GetSharedUser();
                    user.MachinePuid = origMachine.Puid;

                    LicenseMigrationUtils.BuyOffer(user, origMachine, MediaMatrix.TexasHoldEmOffer.OfferMediaTypeExpectedPrice, state);

                    //verify initial state
                    ro.Debug("Verifying initial state...");
                    state.Verify();
                    LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.NotStarted, true, null, state);

                    //now do the migration the first time
                    LicenseMigrationUtils.DoXrlStartMigration(user.Puid);
                    LicenseMigrationUtils.SignInPresence(user.Puid, destMachine1.Puid);
                    LicenseMigrationUtils.DoXrlCompleteMigration(user.Puid, destMachine1.Puid, state);
                    DateTime lastUpdate = DateTime.UtcNow;

                    //verify migrated state
                    ro.Debug("Verifying state...");
                    state.Verify();
                    LicenseMigrationUtils.VerifyTransferStatus(user.Puid, destMachine1.ConsoleId, destMachine1.Puid, LicenseTransferStatusEnum.Completed, false, lastUpdate, state);

                    // If we should succeed, or the time to advance is negative
                    // then we're setting the licence advance time relative to 
                    // transfer restart timeout
                    if (expectSuccess || timeToAdvance.TotalMinutes < 0)
                    {
                        Int32 minDays = Config.GetIntSetting("signature_licenseTransferMinDaysToRestart");
                        timeToAdvance += TimeSpan.FromDays(minDays);
                    }

                    //advance some time and re-verify status
                    if (timeToAdvance.TotalMinutes > 0)
                    {
                        LicenseMigrationUtils.AdvanceTimeOnLicenseTransferState(user.Puid, timeToAdvance);
                        lastUpdate -= timeToAdvance;
                    }

                    LicenseMigrationUtils.VerifyTransferStatus(user.Puid, destMachine1.ConsoleId, destMachine1.Puid, LicenseTransferStatusEnum.Completed, expectSuccess, lastUpdate, state);

                    //try to start it again
                    if (expectSuccess)
                    {
                        LicenseMigrationUtils.DoXrlStartMigration(user.Puid);
                        lastUpdate = DateTime.UtcNow;

                        LicenseMigrationUtils.VerifyTransferStatus(user.Puid, "", 0, LicenseTransferStatusEnum.PendingConsoleSignIn, true, lastUpdate, state);

                        //transfer it to a new machine
                        LicenseMigrationUtils.SignInPresence(user.Puid, destMachine2.Puid);
                        lastUpdate = DateTime.UtcNow;
                        LicenseMigrationUtils.VerifyTransferStatus(user.Puid, destMachine2.ConsoleId, destMachine2.Puid, LicenseTransferStatusEnum.PendingUserConfirmation, true, lastUpdate, state);

                        LicenseMigrationUtils.DoXrlCompleteMigration(user.Puid, destMachine2.Puid, state);
                        lastUpdate = DateTime.UtcNow;
                        LicenseMigrationUtils.VerifyTransferStatus(user.Puid, destMachine2.ConsoleId, destMachine2.Puid, LicenseTransferStatusEnum.Completed, false, lastUpdate, state);
                        state.Verify();
                    }
                    else
                    {
                        bool success = false;
                        try
                        {
                            LicenseMigrationUtils.DoXrlStartMigration(user.Puid);
                            success = true;
                        }
                        catch (LicenseMigrationUpdateException xmse)
                        {
                            if (xmse.XErr != HResult.XONLINE_E_SIGNATURE_LICENSE_TRANSFER_BAD_COMMAND)
                            {
                                throw;
                            }
                        }

                        if (success)
                        {
                            throw new UnexpectedTestResultException("Did not expect call to start to succeed.");
                        }
                    }
                }
            }

            [TestCase, TestCasePriority(2)]
            public void StartTwice()
            {
                LicensesState state=new LicensesState();

                //create machines, user, and buy game
                ro.Debug("Setting up...");
                MachineBase xmacsOrig = SignatureUtils.CreateClient();
                MachineBase xmacsNew = SignatureUtils.CreateClient();

                IUser user = TestHelper.GetSharedUser();
                user.MachinePuid=xmacsOrig.Puid;

                LicenseMigrationUtils.BuyOffer(user, xmacsOrig, MediaMatrix.TexasHoldEmOffer.OfferMediaTypeExpectedPrice, state);

                //verify initial state
                ro.Debug("Verifying initial state...");
                state.Verify();
                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.NotStarted, true, null, state);

                //now start the process
                LicenseMigrationUtils.DoXrlStartMigration(user.Puid);
                DateTime lastUpdate=DateTime.UtcNow;
                ro.Debug("Verifying GetLicenseTransferState...");
                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.PendingConsoleSignIn, true, lastUpdate, state);

                //try to start again
                bool succees=false;
                try
                {
                    LicenseMigrationUtils.DoXrlStartMigration(user.Puid);
                    succees=true;
                }
                catch (LicenseMigrationUpdateException xmse)
                {
                    if (xmse.XErr!=HResult.XONLINE_E_SIGNATURE_LICENSE_TRANSFER_BAD_COMMAND)
                    {
                        throw;
                    }
                }

                if (succees)
                {
                    throw new UnexpectedTestResultException("Did not expect call to start to succeed.");
                }

                //re-verify status
                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.PendingConsoleSignIn, true, lastUpdate, state);
            }

            [TestCase, TestCasePriority(2)]
            public void FinishTwice()
            {
                LicensesState state=new LicensesState();

                //create machines, user, and buy game
                ro.Debug("Setting up...");
                MachineBase xmacsOrig = SignatureUtils.CreateClient();
                MachineBase xmacsNew = SignatureUtils.CreateClient();

                IUser user = TestHelper.GetSharedUser();
                user.MachinePuid=xmacsOrig.Puid;

                LicenseMigrationUtils.BuyOffer(user, xmacsOrig, MediaMatrix.TexasHoldEmOffer.OfferMediaTypeExpectedPrice, state);

                //verify initial state
                ro.Debug("Verifying initial state...");
                state.Verify();
                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.NotStarted, true, null, state);

                //do the migration once
                LicenseMigrationUtils.DoXrlStartMigration(user.Puid);
                LicenseMigrationUtils.SignInPresence(user.Puid, xmacsNew.Puid);
                LicenseMigrationUtils.DoXrlCompleteMigration(user.Puid, xmacsNew.Puid, state);
                DateTime lastUpdate=DateTime.UtcNow;

                ro.Debug("Verifying state after normal migration...");
                state.Verify();
                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.Completed, false, lastUpdate, state);

                //try to call complete again
                bool success=false;
                try
                {
                    LicenseMigrationUtils.DoXrlCompleteMigration(user.Puid, xmacsNew.Puid, null);
                    success=true;
                }
                catch (LicenseMigrationUpdateException xmce)
                {
                    if (xmce.XErr!=HResult.XONLINE_E_SIGNATURE_LICENSE_TRANSFER_BAD_COMMAND)
                    {
                        throw;
                    }
                }

                if (success)
                {
                    throw new UnexpectedTestResultException("Did not expect call to complete to succeed.");
                }

                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.Completed, false, lastUpdate, state);
            }

            [TestCase, TestCasePriority(2)]
            public void CompleteWithoutPresence()
            {
                LicensesState state=new LicensesState();

                //create machines, user, and buy game
                ro.Debug("Setting up...");
                MachineBase xmacsOrig = SignatureUtils.CreateClient();
                MachineBase xmacsNew1 = SignatureUtils.CreateClient();

                IUser user = TestHelper.GetSharedUser();
                user.MachinePuid=xmacsOrig.Puid;

                LicenseMigrationUtils.BuyOffer(user, xmacsOrig, MediaMatrix.TexasHoldEmOffer.OfferMediaTypeExpectedPrice, state);

                //verify initial state
                ro.Debug("Verifying initial state...");
                state.Verify();
                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.NotStarted, true, null, state);

                //do the migration start
                LicenseMigrationUtils.DoXrlStartMigration(user.Puid);

                //verify state
                ro.Debug("Verifying state...");
                state.Verify();
                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.PendingConsoleSignIn, true, null, state);

                //now complete it
                bool success=false;
                try
                {
                    LicenseMigrationUtils.DoXrlCompleteMigration(user.Puid, xmacsNew1.Puid, null);
                    success=true;
                }
                catch (LicenseMigrationUpdateException xmce)
                {
                    if (xmce.XErr!=HResult.XONLINE_E_SIGNATURE_LICENSE_TRANSFER_BAD_COMMAND)
                    {
                        throw;
                    }
                }

                if (success)
                {
                    throw new UnexpectedTestResultException("Did not expect call to complete to succeed.");
                }

                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.PendingConsoleSignIn, true, null, state);
            }

            [TestCase, TestCasePriority(2)]
            public void StartWithNoHttpAuth()
            {
                //create machine, users, and buy game
                ro.Debug("Setting up...");
                MachineBase xmacsOrig = SignatureUtils.CreateClient();

                IUser user0 = TestHelper.GetSharedUser();
                user0.MachinePuid = xmacsOrig.Puid;

                LicenseMigrationUtils.BuyOffer(user0, xmacsOrig, MediaMatrix.TexasHoldEmOffer.OfferMediaTypeExpectedPrice, null);

                //try migration
                ro.Debug("Starting license migration...");

                XRLUpdateLicenseTransferState xrl=new XRLUpdateLicenseTransferState();
                xrl.Request.command = UpdateTransferStateEnum.Start;
                xrl.Request.userPuid = user0.Puid;
                xrl.UseHttpAuth=false;

                if (xrl.Execute())
                {
                    throw new UnexpectedTestResultException("UpdateLicenseTransferState succeeded unexpectedly.");
                }
                else
                {
                    ValueCheck.Test("HttpStatusCode", System.Net.HttpStatusCode.InternalServerError, xrl.httpStatus);
                    ValueCheck.Test("XErr", HResult.XONLINE_E_SIGNATURE_TRANSFER_USER_LICENSES_ERROR, xrl.XErr);

                    Global.RO.Success("UpdateLicenseTransferState failed as expected");
                }
            }

            [TestCase, TestCasePriority(2)]
            public void StartWithDifferentSGInfoUser()
            {
                //create machine, users, and buy game
                ro.Debug("Setting up...");
                MachineBase xmacsOrig = SignatureUtils.CreateClient();

                IUser user0 = TestHelper.GetSharedUser();
                user0.MachinePuid = xmacsOrig.Puid;
                IUser user1 = TestHelper.GetSharedUser();

                LicenseMigrationUtils.BuyOffer(user0, xmacsOrig, MediaMatrix.TexasHoldEmOffer.OfferMediaTypeExpectedPrice, null);

                //try migration
                ro.Debug("Starting license migration...");

                XRLUpdateLicenseTransferState xrl=new XRLUpdateLicenseTransferState();
                xrl.Request.command=UpdateTransferStateEnum.Start;
                xrl.Request.userPuid=user0.Puid;

                xrl.ManualPopulateSlot();
                xrl.Slot.userPuid0 = user1.Puid;

                if (xrl.Execute())
                {
                    throw new UnexpectedTestResultException("Did not expect call to succeed.");
                }
                else
                {
                    Global.RO.Debug("Call failed.");
                }

                ValueCheck.Test("HttpStatusCode", System.Net.HttpStatusCode.InternalServerError, xrl.httpStatus);
                ValueCheck.Test("XErr", HResult.XONLINE_E_SIGNATURE_TRANSFER_USER_LICENSES_ERROR, xrl.XErr);
            }

            [TestCase, TestCasePriority(2)]
            public void CancelWithoutStarting()
            {
                LicensesState state=new LicensesState();

                //create machines, user, and buy game
                ro.Debug("Setting up...");
                MachineBase xmacsOrig = SignatureUtils.CreateClient();

                IUser user = TestHelper.GetSharedUser();
                user.MachinePuid=xmacsOrig.Puid;

                LicenseMigrationUtils.BuyOffer(user, xmacsOrig, MediaMatrix.TexasHoldEmOffer.OfferMediaTypeExpectedPrice, state);

                //call cancel
                bool success=false;
                try
                {
                    LicenseMigrationUtils.DoXrlCancelMigration(user.Puid);
                    success=true;
                }
                catch (LicenseMigrationUpdateException xmce)
                {
                    if (xmce.XErr!=HResult.XONLINE_E_SIGNATURE_LICENSE_TRANSFER_BAD_COMMAND)
                    {
                        throw;
                    }
                }

                if (success)
                {
                    throw new UnexpectedTestResultException("Did not expect call to cancel to succeed.");
                }

                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.NotStarted, true, null, null);
            }

            [TestCase, TestCasePriority(2)]
            public void CancelAfterStarting()
            {
                LicensesState state=new LicensesState();

                //create machines, user, and buy game
                ro.Debug("Setting up...");
                MachineBase xmacsOrig = SignatureUtils.CreateClient();

                IUser user = TestHelper.GetSharedUser();
                user.MachinePuid=xmacsOrig.Puid;

                LicenseMigrationUtils.BuyOffer(user, xmacsOrig, MediaMatrix.TexasHoldEmOffer.OfferMediaTypeExpectedPrice, state);

                //start then cancel
                LicenseMigrationUtils.DoXrlStartMigration(user.Puid);
                LicenseMigrationUtils.DoXrlCancelMigration(user.Puid);

                state.Verify();
                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.NotStarted, true, null, state);
            }

            [TestCase, TestCasePriority(2)]
            public void CancelAfterPresence()
            {
                LicensesState state=new LicensesState();

                //create machines, user, and buy game
                ro.Debug("Setting up...");
                MachineBase xmacsOrig = SignatureUtils.CreateClient();
                MachineBase xmacsNew = SignatureUtils.CreateClient();

                IUser user = TestHelper.GetSharedUser();
                user.MachinePuid=xmacsOrig.Puid;

                LicenseMigrationUtils.BuyOffer(user, xmacsOrig, MediaMatrix.TexasHoldEmOffer.OfferMediaTypeExpectedPrice, state);

                //start, hit presence, then cancel
                LicenseMigrationUtils.DoXrlStartMigration(user.Puid);
                LicenseMigrationUtils.SignInPresence(user.Puid, xmacsNew.Puid);
                LicenseMigrationUtils.DoXrlCancelMigration(user.Puid);

                state.Verify();
                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.NotStarted, true, null, state);
            }

            [TestCase, TestCasePriority(2)]
            public void CancelAfterComplete()
            {
                LicensesState state=new LicensesState();

                //create machines, user, and buy game
                ro.Debug("Setting up...");
                MachineBase xmacsOrig = SignatureUtils.CreateClient();
                MachineBase xmacsNew = SignatureUtils.CreateClient();

                IUser user = TestHelper.GetSharedUser();
                user.MachinePuid=xmacsOrig.Puid;

                LicenseMigrationUtils.BuyOffer(user, xmacsOrig, MediaMatrix.TexasHoldEmOffer.OfferMediaTypeExpectedPrice, state);

                //start, hit presence, complete
                LicenseMigrationUtils.DoXrlStartMigration(user.Puid);
                LicenseMigrationUtils.SignInPresence(user.Puid, xmacsNew.Puid);
                LicenseMigrationUtils.DoXrlCompleteMigration(user.Puid, xmacsNew.Puid, state);

                state.Verify();
                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, xmacsNew.ConsoleId, xmacsNew.Puid, LicenseTransferStatusEnum.Completed, false, null, state);

                //try cancel
                bool success=false;
                try
                {
                    LicenseMigrationUtils.DoXrlCancelMigration(user.Puid);
                    success=true;
                }
                catch (LicenseMigrationUpdateException xmce)
                {
                    if (xmce.XErr!=HResult.XONLINE_E_SIGNATURE_LICENSE_TRANSFER_BAD_COMMAND)
                    {
                        throw;
                    }
                }

                if (success)
                {
                    throw new UnexpectedTestResultException("Did not expect call to cancel to succeed.");
                }

                state.Verify();
                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, xmacsNew.ConsoleId, xmacsNew.Puid, LicenseTransferStatusEnum.Completed, false, null, state);
            }

            [TestCase, TestCasePriority(2)]
            public void CancelThenRestart()
            {
                LicensesState state=new LicensesState();

                //create machines, user, and buy game
                ro.Debug("Setting up...");
                MachineBase xmacsOrig = SignatureUtils.CreateClient();

                IUser user = TestHelper.GetSharedUser();
                user.MachinePuid=xmacsOrig.Puid;

                LicenseMigrationUtils.BuyOffer(user, xmacsOrig, MediaMatrix.TexasHoldEmOffer.OfferMediaTypeExpectedPrice, state);

                //start then cancel
                LicenseMigrationUtils.DoXrlStartMigration(user.Puid);
                LicenseMigrationUtils.DoXrlCancelMigration(user.Puid);

                state.Verify();
                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.NotStarted, true, null, state);

                //start again
                LicenseMigrationUtils.DoXrlStartMigration(user.Puid);
                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.PendingConsoleSignIn, true, null, state);
            }

            [TestCase, TestCasePriority(3), Description("Verify the xrl api works after the widget api was called to transfer a license.")]
            public void AfterWidgetCall()
            {
                LicensesState state=new LicensesState();

                //create machines to buy a license on and to migrate to
                ro.Debug("Creating machine...");
                MachineBase xmacsOrig = SignatureUtils.CreateClient();
                MachineBase xmacsNew0=SignatureUtils.CreateClient();
                MachineBase xmacsNew1=SignatureUtils.CreateClient();

                //make a user
                IUser user = TestHelper.GetSharedUser();
                user.MachinePuid=xmacsOrig.Puid;

                //buy an arcade game
                LicenseMigrationUtils.BuyOffer(user, xmacsOrig, MediaMatrix.TexasHoldEmOffer.OfferMediaTypeExpectedPrice, state);

                //verify initial state
                ro.Debug("Verifying licenses...");
                state.Verify();
                ro.Debug("Verifying GetLicenseTransferState...");
                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.NotStarted, true, null, state);

                //transfer with widget
                ro.Debug("Calling widget API to transfer...");
                LicenseMigrationUtils.WidgetTransferLicenses(user.Puid, xmacsNew0.ConsoleId, xmacsNew0.Puid, state);

                //verify state
                ro.Debug("Verifying licenses...");
                state.Verify();
                ro.Debug("Verifying GetLicenseTransferState...");
                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.NotStarted, true, null, state);

                //now start the process for the xrl api
                LicenseMigrationUtils.DoXrlStartMigration(user.Puid);
                DateTime lastUpdate=DateTime.UtcNow;
                ro.Debug("Verifying licenses...");
                state.Verify();
                ro.Debug("Verifying GetLicenseTransferState...");
                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.PendingConsoleSignIn, true, lastUpdate, state);

                //sign in presense
                LicenseMigrationUtils.SignInPresence(user.Puid, xmacsNew1.Puid);
                lastUpdate=DateTime.UtcNow;
                ro.Debug("Verifying licenses...");
                state.Verify();
                ro.Debug("Verifying GetLicenseTransferState...");
                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, xmacsNew1.ConsoleId, xmacsNew1.Puid, LicenseTransferStatusEnum.PendingUserConfirmation, true, lastUpdate, state);

                //confirm it to finish
                LicenseMigrationUtils.DoXrlCompleteMigration(user.Puid, xmacsNew1.Puid, state);
                lastUpdate=DateTime.UtcNow;
                ro.Debug("Verifying licenses...");
                state.Verify();
                ro.Debug("Verifying GetLicenseTransferState...");
                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, xmacsNew1.ConsoleId, xmacsNew1.Puid, LicenseTransferStatusEnum.Completed, false, lastUpdate, state);
            }

            [TestCase, TestCasePriority(2)]
            public void GetState_FreshUser()
            {
                //make a user
                IUser user = TestHelper.GetSharedUser();

                ro.Debug("Verifying GetLicenseTransferState...");
                LicenseMigrationUtils.VerifyTransferStatus(user.Puid, null, 0, LicenseTransferStatusEnum.NotStarted, true, null, null);
            }

            [TestCase, TestCasePriority(3), Description("Pass invalid user values for to the API")]
            [CompoundCase("NullUser", 0)]
            [CompoundCase("BadUser", 0xfefefefefefefefe)]
            public class BadUserValues : TestNode
            {
                ulong userPuid;
                IMachine xmacsNew;

                public override void PreRun()
                {
                    // Grab the compound test case values we need
                    userPuid = Convert.ToUInt64(MyValues[0]);

                    ro.Debug("Creating users and machines...");

                    // Create the machine that the licenses will be moved to
                    xmacsNew = (MachineBase)MachineEditor.CreateNew(MachineType.Xbox360);
                }

                public override void Run()
                {
                    try
                    {
                        LicenseMigrationUtils.XrlSimpleTransferLicenses(userPuid, xmacsNew.ConsoleIdNoPrefix, xmacsNew.Puid, null);
                    }
                    catch (LicenseMigrationUpdateException lme)
                    {
                        ValueCheck.Test("LicenseMigrationState", UpdateTransferStateEnum.Start, lme.State);
                        ValueCheck.TestHR("UpdateResult", HResult.E_INVALIDARG, lme.XErr);

                        Global.RO.Success("Recieved expected error. " + lme.ToString());
                        return;
                    }

                    throw new UnexpectedTestResultException("Expected an exception to be thrown from calling the migration api.");
                }
            }
        }

        [TestGroup, AsyncThreadCount(3), AsyncThreadDelay(1000), AsyncGroup(1, 0), Owner("BenRan"), TestFrequency("Regression")]
        public class XrlImmediateApi : TestNode
        {
            [TestCase, TestCasePriority(3), Description("Pass invalid user values for to the API")]
            [CompoundCase("NullUser", 0)]
            [CompoundCase("BadUser", 0xfefefefefefefefe)]
            public class BadUserValues : TestNode
            {
                ulong userPuid;
                IMachine xmacsNew;

                public override void PreRun()
                {
                    // Grab the compound test case values we need
                    userPuid = Convert.ToUInt64(MyValues[0]);

                    ro.Debug("Creating users and machines...");

                    // Create the machine that the licenses will be moved to
                    xmacsNew = (MachineBase)MachineEditor.CreateNew(MachineType.Xbox360);
                }

                public override void Run()
                {
                    try
                    {
                        LicenseMigrationUtils.XrlSimpleTransferLicensesImmediate(userPuid, xmacsNew.ConsoleIdNoPrefix, xmacsNew.Puid, null);
                    }
                    catch (LicenseMigrationUpdateException lme)
                    {
                        ValueCheck.Test("LicenseMigrationState", UpdateTransferStateEnum.Start, lme.State);
                        ValueCheck.TestHR("UpdateResult", HResult.E_INVALIDARG, lme.XErr);

                        Global.RO.Success("Recieved expected error. " + lme.ToString());
                        return;
                    }

                    throw new UnexpectedTestResultException("Expected an exception to be thrown from calling the migration api.");
                }
            }

            [TestCase, TestCasePriority(3), Description("Pass invalid machine values for to the API")]
            [CompoundCase("NullMachine", "000000000000")]
            [CompoundCase("BadMachine", "499999999999")]
            public class BadMachineValues : TestNode
            {
                String consoleId;
                IUser user = null;

                public override void PreRun()
                {
                    // Grab the compound test case values we need
                    consoleId = (string)MyValues[0];

                    ro.Debug("Creating users and machines...");

                    // Create a user
                    user = TestHelper.GetSharedUser();
                }

                public override void Run()
                {
                    try
                    {
                        LicenseMigrationUtils.XrlSimpleTransferLicensesImmediate(user.Puid, consoleId, 0x1, null);
                    }
                    catch (LicenseMigrationUpdateException lme)
                    {
                        ValueCheck.Test("LicenseMigrationState", UpdateTransferStateEnum.Start, lme.State);
                        ValueCheck.TestHR("UpdateResult", HResult.XONLINE_E_SIGNATURE_TRANSFER_USER_LICENSES_ERROR, lme.XErr);

                        Global.RO.Success("Recieved expected error. " + lme.ToString());
                        return;
                    }

                    throw new UnexpectedTestResultException("Expected an exception to be thrown from calling the migration api.");
                }

                public override void PostRun()
                {
                    MediaTestHelper.CleanupUser(user);
                    TestHelper.ReturnSharedUser(user);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\LicenseMigration\LiceMigUtils.cs ===
﻿using System;
using System.Linq;
using System.Collections.Generic;
using Microsoft.Webstore.WstClient;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
using SigTest.License;
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using OfferExpectedPrice = ServerTestFramework.LiveService.Billing.OfferExpectedPrice;
using OfferMediaTypeExpectedPrice = ServerTestFramework.LiveService.Billing.OfferMediaTypeExpectedPrice;
using xonline.common.billing;

namespace SigTest.LicenseMigration
{
    /// <summary>
    /// Various methods, data, and settings used throughout the LicenseMigration tests
    /// </summary>
    public class LicenseMigrationUtils
    {
        /// <summary>
        /// Global License Migration Settings
        /// </summary>
        public class LiceMigSettings
        {
            public static bool UseFakeVideoGuid = false;
            public static bool UseFakeUsersForStress = true;

            private static TimeSpan? defaultTransferTimeoutTime = null;
            public static TimeSpan DefaultTransferTimeoutTime
            {
                get
                {
                    if (defaultTransferTimeoutTime == null)
                    {
                        defaultTransferTimeoutTime = new TimeSpan(0, Global.XEnv.GetIntSetting("signature_licenseTransferTimeoutInMinutes"), 0);
                    }

                    return defaultTransferTimeoutTime.Value;
                }
            }

            private static TimeSpan? defaultTransferAgainTime = null;
            public static TimeSpan DefaultTransferAgainTime
            {
                get
                {
                    if (defaultTransferAgainTime == null)
                    {
                        defaultTransferAgainTime = new TimeSpan(Global.XEnv.GetIntSetting("signature_licenseTransferMinDaysToRestart"), 0, 0, 0);
                    }

                    return defaultTransferAgainTime.Value;
                }
            }
        }

        /// <summary>
        /// A repository of data items (Content IDs, GUIDs, Offer IDs) used by the tests
        /// </summary>
        public class TestData
        {
            //offer IDs
            public const ulong Game_JoustOfferID = 0x584107d800000001;
            public const ulong Game_BvtOfferID = 0xFFFE07D1000000B6;
            public const ulong GamerPicture_BvtOfferID = 0xFFFE07D1000000B3;
            public const ulong InGameContent_BvtOfferID = 0xFFFE07D1000000B1;
            //MechAssault, Package 14, Premium DLC North America -- this needs to match the xbox1 special case title
            public const ulong Xbox1_BuyableOfferID = 0x4D53001700000035;

            //content ID tied to the offer IDs
            public static Dictionary<ulong, byte[]> ContentID = new Dictionary<ulong, byte[]>();

            //video junk
            public static Guid CatalogVideoCrap_Offer = new System.Guid("2fae983b-cd5b-4fe3-aa2a-0dcb113c9bf2"); //?(SD)
            public static Guid CatalogVideoCrap_MediaInstance = new System.Guid("acc82b27-a4bc-4688-86df-82531ed4cb56");
            public static uint CatalogVideoCrap_BvtPrice = 240;

            public static Guid CatalogVideoCrud_Offer = new System.Guid("a1f740fe-2f66-44aa-b74e-bace5a39b444"); //The Economist (SD)
            public static Guid CatalogVideoCrud_MediaInstance = new System.Guid("7701115F-91E0-4955-A494-2ADDA7DBD83B");
            public static uint CatalogVideoCrud_BvtPrice = 160;


            public static Guid FakeOldVideoGuid0 = new System.Guid("01234567-0123-0123-0123-000000000000");
            public static Guid FakeOldVideoGuid1 = new System.Guid("01234567-0123-0123-0123-111111111111");
            public static Guid FakeNewVideoGuid0 = new System.Guid("01234567-0123-0123-0123-222222222222");
            public static Guid FakeNewVideoGuid1 = new System.Guid("01234567-0123-0123-0123-333333333333");

            static TestData()
            {
                //read in content IDs
                try
                {
                    UodbTable contentDetailsTable = new UodbTable("t_offer_content_details");
                    contentDetailsTable.SetConstraint("bi_offer_id", Game_JoustOfferID);
                    UodbWS.ExecuteSQLSelect(contentDetailsTable);
                    ContentID[Game_JoustOfferID] = (byte[])contentDetailsTable.GetProperty("b_content_id");
                    ValueCheck.IsTrue(ContentID[Game_JoustOfferID] != null, "ContentID retrieved");
                }
                catch (Exception e)
                {
                    RO.Warn("Exception retrieving game joust content ID from UODB.  Will use a known hardcoded value.  Exception: " + e);
                    ContentID[Game_JoustOfferID] = Hexer.unhex("0xB7C618DC4D87E89B8E8E76AF6DC9B050603AFE9D");
                }

                try
                {
                    UodbTable contentDetailsTable = new UodbTable("t_offer_content_details");
                    contentDetailsTable.SetConstraint("bi_offer_id", Game_BvtOfferID);
                    UodbWS.ExecuteSQLSelect(contentDetailsTable);
                    ContentID[Game_BvtOfferID] = (byte[])contentDetailsTable.GetProperty("b_content_id");
                    ValueCheck.IsTrue(ContentID[Game_BvtOfferID] != null, "ContentID retrieved");
                }
                catch (Exception e)
                {
                    RO.Warn("Exception retrieving game bvt content ID from UODB.  Will use a known hardcoded value.  Exception: " + e);
                    ContentID[Game_BvtOfferID] = Hexer.unhex("0x10A9827D471992C542DF8B860DFE3912E03F24F7");
                }

                //we don't need anything valid for Xbox1_BuyableOfferID
                ContentID[Xbox1_BuyableOfferID] = Hexer.unhex("0x0000000000000000000000000000000000000000");

                //
                try
                {
                    UodbTable contentDetailsTable = new UodbTable("t_offer_content_details");
                    contentDetailsTable.SetConstraint("bi_offer_id", GamerPicture_BvtOfferID);
                    UodbWS.ExecuteSQLSelect(contentDetailsTable);
                    ContentID[GamerPicture_BvtOfferID] = (byte[])contentDetailsTable.GetProperty("b_content_id");
                    ValueCheck.IsTrue(ContentID[GamerPicture_BvtOfferID] != null, "ContentID retrieved");
                }
                catch (Exception e)
                {
                    RO.Warn("Exception retrieving gamer picture bvt content ID from UODB.  Will use a known hardcoded value.  Exception: " + e);
                    ContentID[GamerPicture_BvtOfferID] = Hexer.unhex("0xA72356565FA74652976B7C83DE8649CB839CE1A9");
                }

                try
                {
                    UodbTable contentDetailsTable = new UodbTable("t_offer_content_details");
                    contentDetailsTable.SetConstraint("bi_offer_id", InGameContent_BvtOfferID);
                    UodbWS.ExecuteSQLSelect(contentDetailsTable);
                    ContentID[InGameContent_BvtOfferID] = (byte[])contentDetailsTable.GetProperty("b_content_id");
                    ValueCheck.IsTrue(ContentID[InGameContent_BvtOfferID] != null, "ContentID retrieved");
                }
                catch (Exception e)
                {
                    RO.Warn("Exception retrieving in game content bvt content ID from UODB.  Will use a known hardcoded value.  Exception: " + e);
                    ContentID[InGameContent_BvtOfferID] = Hexer.unhex("0xAB5259811F2B1D1D042808C4737CB7CE1CE79768");
                }
            }
        }

        public static bool VerboseOutput { get; set; }

        private static Report ro = null;
        public static Report RO
        {
            get
            {
                if (ro == null)
                {
                    // This is temporary to ease transition to new class structure
                    //ro = SigTest.LicenseMigration.Functional.LiceMigTests.ro;
                    ro = new Report("LMT");
                }
                return ro;
            }
        }

        public static void BuyOffer(IUser user, IMachine machine, OfferMediaTypeExpectedPrice offer, LicensesState state)
        {
            BuyOffer(user.Puid, machine.Puid, offer, state);
        }

        public static void BuyOffer(ulong userPuid, ulong machinePuid, OfferMediaTypeExpectedPrice offer, LicensesState state)
        {
            UserCommercedbWS.SimulatePurchaseOffers(userPuid, machinePuid, offer.OfferId, offer.OfferId, offer.MediaTypeId, 1);

            if (state != null)
            {
                state.Update_BuyGame(offer.OfferId, userPuid, machinePuid);
            }
            Global.RO.Success("Successfully purchased game offer {0} for user 0x{1:X}.", offer.OfferId, userPuid);
        }

        public static void BuyOffer(XeUser user, XmacsClient machine, ulong offerId, LicensesState state)
        {
            BuyOffer(user.UserPuid, machine.MachinePuid, offerId, state);
        }

        public static void BuyOffer(ulong userPuid, ulong machinePuid, ulong offerId, LicensesState state)
        {
            XRLXeOfferPurchase req = new XRLXeOfferPurchase();

            req.SetDefaults();
            req.UserPuid = userPuid;
            req.MachinePuid = machinePuid;
            req.OfferID = offerId;

            if (!req.Execute())
            {
                throw new XErrException(req.XErr, String.Format("Unable to purchase offer 0x{0:X}: {1}", offerId, req.GetDumpString()));
            }

            if (state != null)
            {
                state.Update_BuyGame(offerId, userPuid, machinePuid);
            }
        }

        /// <summary>
        /// Verifies if a machine or user owns the offer
        /// </summary>
        /// <remarks>NOT for Videos</remarks>
        /// <param name="offerID">The ID of the offer to check</param>
        /// <param name="machPuid">The machine PUID to check (Must be valid)</param>
        /// <param name="userPuid">The user PUID to check (optional)</param>
        /// <param name="shouldOwn">The expected result</param>
        public static void VerifyOwnsOffer(ulong offerID, ulong machPuid, ulong userPuid, bool shouldOwn)
        {
            String cmd = String.Format("select count(*) from t_user_licenses where bi_offer_id={0} and (bi_user_id={1} or bi_machine_id={2})",
                (long)offerID, (long)userPuid, (long)machPuid);

            uint count = UodbWS.ExecuteSQLSelectCount(cmd);
            bool has = (count > 0);

            //check if should have worked
            ValueCheck.Test(string.Format("Owns license for offer=0x{2:X} machine=0x{0:X16} user=0x{1:X16}", machPuid, userPuid, offerID), shouldOwn, has);
            RO.Debug("Verified for " + string.Format("offer=0x{2:X} machine=0x{0:X16} user=0x{1:X16}", machPuid, userPuid, offerID) + ": has=" + has);
        }

        /// <summary>
        /// Verifies if a machine or user owns the offer
        /// </summary>
        /// <remarks>NOT for Videos</remarks>
        /// <param name="offerID">The ID of the offer to check</param>
        /// <param name="machPuid">The machine PUID to check (Must be valid)</param>
        /// <param name="userPuid">The user PUID to check (optional)</param>
        /// <param name="shouldOwn">The expected result</param>
        public static void VerifyOwnsOffer(Guid offerID, ulong machPuid, ulong userPuid, bool shouldOwn)
        {
            try
            {
                String cmd = String.Format("select count(*) from t_user_offer_instance_purchases where (uid_offer_id='{0}' and (bi_user_puid={1} or bi_machine_puid={2}))",
                    offerID, (long)userPuid, (long)machPuid);

                uint count = UserCommercedbWS.ExecuteSQLSelectCount(cmd);

                ValueCheck.Test(String.Format("User 0x{0:X16} or Machine 0x{1:X16} owns license for {2}", userPuid, machPuid, offerID), shouldOwn, count > 0);
                RO.Debug(String.Format("User 0x{0:X16} or Machine 0x{1:X16} correctly {3} a license for {2}", userPuid, machPuid, offerID, count > 0 ? "has" : "doesn't have"));
            }
            catch (Exception)
            {
                // This is just here to allow debugging some transient webstore issues.
                throw;
            }
        }

        public static List<VideoInformation> PurchaseVideo(ulong userPuid, MediaMatrix matrix, LicensesState state)
        {
            return PurchaseVideo(userPuid, 0, matrix, state);
        }

        public static List<VideoInformation> PurchaseVideo(ulong userPuid, ulong machinePuid, MediaMatrix matrix, LicensesState state)
        {
            return PurchaseVideo(userPuid, machinePuid, matrix, MediaTypeInfo.TVEpisode, VideoQuality.HD, 1, state);
        }

        public static List<VideoInformation> PurchaseVideo(ulong userPuid, MediaMatrix matrix, Int32 type, VideoQuality quality, LicensesState state)
        {
            return PurchaseVideo(userPuid, 0, matrix, type, quality, 1, state);
        }

        public static List<VideoInformation> PurchaseVideo(ulong userPuid, ulong machinePuid, MediaMatrix matrix, Int32 type, VideoQuality quality, LicensesState state)
        {
            return PurchaseVideo(userPuid, machinePuid, matrix, type, quality, 1, state);
        }

        public static List<VideoInformation> PurchaseVideo(ulong userPuid, MediaMatrix matrix, Int32 type, VideoQuality quality, uint count, LicensesState state)
        {
            return PurchaseVideo(userPuid, 0, matrix, type, quality, count, state);
        }

        /// <summary>
        /// Purchases a single video with the given properties
        /// </summary>
        /// <param name="userPuid">The user to perform the purchase with</param>
        /// <param name="machinePuid">The machine to perform the purchase on</param>
        /// <param name="matrix">The media information matrix</param>
        /// <param name="type">The type of video</param>
        /// <param name="quality">The video quality</param>
        /// <param name="count">The number of videos to purchase</param>
        /// <param name="state">The license state to update after the purchase is complete</param>
        /// <returns>A list of VideoInformation objects for all the purchased videos</returns>
        public static List<VideoInformation> PurchaseVideo(ulong userPuid, ulong machinePuid, MediaMatrix matrix, Int32 type, VideoQuality quality, uint count, LicensesState state)
        {
            List<VideoInformation> mediaInfo = matrix.GetOffers(type, quality, count);
            OfferMediaTypeExpectedPrice[] offers = mediaInfo.Select(i => i.OfferMediaTypeExpectedPrice).ToArray();

            if (!SignatureUtils.PurchaseMediaOffers(userPuid, machinePuid, offers))
            {
                throw new UnexpectedTestResultException("Unable to purchase video offers");
            }

            if (state != null)
            {
                foreach (MediaInformation info in mediaInfo)
                {
                    state.Update_BuyVideo(info.OfferId, userPuid, machinePuid);
                }
            }

            return mediaInfo;
        }

        public static List<VideoInformation> PurchaseVideo(MediaTestHelper helper, LicenseType licenseType, Int32 mediaType, LicensesState state)
        {
            var videoInfo = helper.PurchaseVideo(licenseType, mediaType);
            state.Update_BuyVideo(videoInfo.OfferId, helper.UserPuid, helper.MachinePuid);

            return new List<VideoInformation> { videoInfo };
        }

        public static void Purchase(MediaTestHelper helper, MediaInformation mediaInfo, LicensesState state)
        {
            helper.Purchase(mediaInfo);

            if (mediaInfo is GameInformation)
            {
                state.Update_BuyGame(mediaInfo.OfferId, helper.UserPuid, helper.MachinePuid);
            }
            else if (mediaInfo is VideoInformation)
            {
                state.Update_BuyVideo(mediaInfo.OfferId, helper.UserPuid, helper.MachinePuid);
            }
            else
            {
                throw new ArgumentException("mediaInfo must be either a GameInformation or a VideoInformation", "mediaInfo");
            }
        }

        //pretends to buy a video for a user + machine usng a random guid
        public static void BuyNewFakeRandomVideo(XeUser user, ulong machPuid)
        {
            Guid guid = Guid.NewGuid();

            UserCommercedbWS.SimulatePurchaseOffers(user.UserPuid, machPuid, guid, guid, 1, 1);
        }

        //verifies if a user or machine owns the video
        public static void VerifyOwnsNewVideo(Guid offerId, ulong machinePuid, ulong userPuid, bool shouldOwn)
        {
            String sql = String.Format("select count(*) from t_user_offer_instance_purchases where uid_offer_id='{0}' and (bi_user_puid=0x{1:X16} or bi_machine_puid=0x{2:X16})",
                offerId, userPuid, machinePuid);

            Boolean has = UserCommercedbWS.ExecuteSQLSelectCount(sql) > 0;

            //check if should have worked
            ValueCheck.Test(string.Format("Owns (new)video license for Offer={0} machine=0x{1:X16} user=0x{2:X16}", offerId, machinePuid, userPuid), shouldOwn, has);
            RO.Debug("Verified video for Offer={0} Machine=0x{1:X16} User=0x{2:X16}: Has={3}", offerId, machinePuid, userPuid, has);
        }

        /// <summary>
        /// Verifies if a user or machine owns the video
        /// </summary>
        /// <param name="offerID"></param>
        /// <param name="machPuid"></param>
        /// <param name="userPuid"></param>
        /// <param name="shouldOwn"></param>
        public static void VerifyOwnsOldVideo(Guid offerID, ulong machPuid, ulong userPuid, bool shouldOwn)
        {
            //just check the db.
            int count = 0;
            count += (int)UodbWS.ExecuteSQLSelectCount("select count(*) from t_user_video_licenses_console where uid_wmid='" + offerID + "' and bi_user_puid=" + (long)userPuid);
            count += (int)UodbWS.ExecuteSQLSelectCount("select count(*) from t_user_video_licenses_console where uid_wmid='" + offerID + "' and bi_machine_puid=" + (long)machPuid);
            bool has = (count > 0);

            //check if should have worked
            ValueCheck.Test(string.Format("Owns (old)video license for offer=0x{2} machine=0x{0:X} user=0x{1:X}", machPuid, userPuid, offerID), shouldOwn, has);
            RO.Debug("Verified (old)video for " + string.Format("offer=0x{2} machine=0x{0:X} user=0x{1:X}", machPuid, userPuid, offerID) + ": has=" + has);
        }

        public static void VerifyTransferStatus(ulong userPuid, string expectedConsoleID, ulong expectedMachinePuid, LicenseTransferStatusEnum? expectedStatus, bool? expectedResartAllowed, DateTime? expectedUpdateDate, LicensesState state)
        {
            VerifyTransferStatus(userPuid, 0, expectedConsoleID, expectedMachinePuid, expectedStatus, expectedResartAllowed, expectedUpdateDate, state);
        }

        /// <summary>
        /// verifies the license transfer status - if a state is provided, lists of counts are validated also
        /// </summary>
        /// <param name="userPuid"></param>
        /// <param name="machinePuid"></param>
        /// <param name="expectedConsoleID"></param>
        /// <param name="expectedMachinePuid"></param>
        /// <param name="expectedStatus"></param>
        /// <param name="expectedRestartAllowed"></param>
        /// <param name="expectedUpdateDate"></param>
        /// <param name="state"></param>
        public static void VerifyTransferStatus(ulong userPuid, ulong machinePuid, string expectedConsoleID, ulong expectedMachinePuid, LicenseTransferStatusEnum? expectedStatus, bool? expectedRestartAllowed, DateTime? expectedUpdateDate, LicensesState state)
        {
            GetLicenseTransferStateResponse res = DoXrlGetTransferStatus(userPuid, machinePuid, machinePuid != 0);

            if (VerboseOutput)
            {
                RO.Debug("GetLicenseTransferStateResponse:\n" + XrlGetTransferStatusToString(res));
            }

            if (expectedConsoleID != null)
            {
                if (expectedConsoleID.Length == 15)
                {
                    expectedConsoleID = expectedConsoleID.Substring(3);
                }
                ValueCheck.Test("ConsoleId", expectedConsoleID, res.consoleId);
            }

            if (expectedStatus != null)
            {
                ValueCheck.Test("Status", expectedStatus, res.currentStatus);
            }

            if (expectedRestartAllowed != null)
            {
                ValueCheck.Test("RestartAllowed", expectedRestartAllowed, res.restartAllowed);
            }

            if (expectedUpdateDate.HasValue)
            {
                // The tolerance is set pretty high right now because GetTransfer status actually returns
                // the value of the start time instead of the actual last update time
                ValueCheck.Test("LastUpdated", expectedUpdateDate.Value, res.lastUpdated, TimeSpan.FromSeconds(60));
            }

            if (state != null)
            {
                //verify game list
                Dictionary<ulong, int> gameCounts = state.GetGameLicenseCountsForUser(userPuid, false);
                ValueCheck.Test("Number of different consoles with game licenses", gameCounts.Count, res.sourceConsolesLength);

                // This creates a dictionary of consoleIds to game license counts
                var consoleIdToGameCount = gameCounts.Keys.ToDictionary(
                    m => MachineEditor.FromId(m).ConsoleId,
                    m => gameCounts[m]);

                foreach (ConsoleLicenseCount clc in res.sourceConsoles)
                {
                    string consoleId = "XE." + clc.consoleId;

                    Int32 expectedGameCount;
                    if (!consoleIdToGameCount.TryGetValue(consoleId, out expectedGameCount))
                    {
                        throw new UnexpectedTestResultException("sourceConsoles in transfer status contained an unexpected machine: " + consoleId);
                    }

                    ValueCheck.Test("Game license count for console " + consoleId, expectedGameCount, clc.licenseCount);
                    consoleIdToGameCount.Remove(consoleId);
                }

                //verify video list
                Dictionary<ulong, int> videoCounts = state.GetVideoLicenseCountsForUser(userPuid, false);
                ValueCheck.Test("Number of different consoles with video licenses", videoCounts.Count, res.sourceVideoConsolesLength);

                var consoleIdVideoCount = videoCounts.ToDictionary(
                    videoCount => MachineEditor.FromId(videoCount.Key).ConsoleId,
                    videoCount => videoCount.Value);

                foreach (ConsoleLicenseCount clc in res.sourceVideoConsoles)
                {
                    string consoleId = "XE." + clc.consoleId;

                    Int32 expectedVideoCount;
                    if (!consoleIdVideoCount.TryGetValue(consoleId, out expectedVideoCount))
                    {
                        throw new UnexpectedTestResultException("sourceVideoConsoles in transfer status contained an unexpected machine" + consoleId);
                    }

                    ValueCheck.Test("Video license count for console " + consoleId, expectedVideoCount, clc.licenseCount);
                    consoleIdVideoCount.Remove(consoleId);
                }
            }
        }

        //transfers all licenses from a user to a machine using the widget api
        public static void WidgetTransferLicenses(ulong userPuid, string consoleID, ulong machinePuid, LicensesState state)
        {
            if (VerboseOutput)
            {
                RO.Debug("Migrating licenses (widget api) for user=0x{0:X} to machine=0x{1:X}(consoleID={2})...", userPuid, machinePuid, consoleID);
            }

            ServerTestFramework.WebWidget.WCSignature wcSig = new ServerTestFramework.WebWidget.WCSignature();
            wcSig.TransferUserLicenses(userPuid, consoleID);

            if (state != null)
            {
                state.Update_Transfer(userPuid, machinePuid);
            }
        }

        #region Xrl Transfer Methods
        /// <summary>
        /// Transfers all licenses from a user to a machine using the XRL API, and verifies the final status
        /// </summary>
        /// <param name="userPuid">User to transfer from</param>
        /// <param name="consoleID">ConsoleID to transfer to</param>
        /// <param name="machinePuid">Machine PUID to transfer to</param>
        /// <param name="state">Current License State</param>
        public static void XrlSimpleTransferLicenses(ulong userPuid, string consoleID, ulong machinePuid, LicensesState state)
        {
            //start, sign into presence, then complete
            DoXrlStartMigration(userPuid);
            SignInPresence(userPuid, machinePuid);
            DoXrlCompleteMigration(userPuid, machinePuid, state);

            // Verify the result
            VerifyTransferStatus(userPuid, consoleID, machinePuid, LicenseTransferStatusEnum.Completed, false, DateTime.UtcNow, state);
        }

        /// <summary>
        /// Transfers all licenses from a user to a machine using the XRL Immediate API, and verifies the final status
        /// </summary>
        /// <param name="userPuid">User to transfer from</param>
        /// <param name="consoleID">ConsoleID to transfer to</param>
        /// <param name="machinePuid">Machine PUID to transfer to</param>
        /// <param name="state">Current License State</param>
        public static void XrlSimpleTransferLicensesImmediate(ulong userPuid, string consoleID, ulong machinePuid, LicensesState state)
        {
            // Start the transfer on the given machine
            DoXrlStartMigration(userPuid, machinePuid, true);
            // Then just complete it right away
            DoXrlCompleteMigration(userPuid, machinePuid, true, state);

            // Verify the result
            VerifyTransferStatus(userPuid, machinePuid, consoleID, machinePuid, LicenseTransferStatusEnum.Completed, false, DateTime.UtcNow, state);
        }

        /// <summary>
        /// Execute an UpdateLicenseTransferState request with the Start state
        /// </summary>
        /// <param name="userPuid">The user to start the transfer for</param>
        internal static void DoXrlStartMigration(ulong userPuid)
        {
            DoXrlStartMigration(userPuid, 0, false);
        }

        /// <summary>
        /// Execute an UpdateLicenseTransferState request with the Start state
        /// </summary>
        /// <param name="userPuid">The user to start the transfer for</param>
        /// <param name="machinePuid">The machine to start the transfer for</param>
        internal static void DoXrlStartMigration(ulong userPuid, ulong machinePuid, Boolean fromConsole)
        {
            if (VerboseOutput)
            {
                RO.Debug("Starting license migration (xrl api) for user=0x{0:X}", userPuid);
            }

            XRLUpdateLicenseTransferState xrl = new XRLUpdateLicenseTransferState();
            xrl.Request.command = UpdateTransferStateEnum.Start;
            xrl.Request.userPuid = userPuid;
            xrl.MachinePuid = machinePuid;
            xrl.UseHttpAuth = !fromConsole;

            if (!xrl.Execute())
            {
                throw new LicenseMigrationUpdateException(xrl.Request.command, xrl.XErr, xrl.ErrorStatusMessage);
            }
        }

        /// <summary>
        /// Execute an UpdateLicenseTransferState request to state Complete
        /// </summary>
        /// <param name="userPuid">The user to update the state for</param>
        /// <param name="machinePuid">The machine that the transfer occurs to.  This is only used to update the state</param>
        /// <param name="state">The license state info to update</param>
        internal static void DoXrlCompleteMigration(ulong userPuid, ulong machinePuid, LicensesState state)
        {
            DoXrlCompleteMigration(userPuid, machinePuid, false, state);
        }

        /// <summary>
        /// Execute an UpdateLicenseTransferState request to state Complete
        /// </summary>
        /// <param name="userPuid">The user to update the state for</param>
        /// <param name="machinePuid">The machine that the transfer occurs to</param>
        /// <param name="fromConsole">Indicates whether the request comes from a console or via LiveCache from Xbox.com</param>
        /// <param name="state">The license state info to update</param>
        internal static void DoXrlCompleteMigration(ulong userPuid, ulong machinePuid, Boolean fromConsole, LicensesState state)
        {
            if (VerboseOutput)
            {
                RO.Debug("Completing license migration (xrl api) for user=0x{0:X}...", userPuid);
            }

            XRLUpdateLicenseTransferState xrl = new XRLUpdateLicenseTransferState();
            xrl.Request.command = UpdateTransferStateEnum.Complete;
            xrl.Request.userPuid = userPuid;
            xrl.MachinePuid = machinePuid;
            xrl.UseHttpAuth = !fromConsole;

            if (!xrl.Execute())
            {
                throw new LicenseMigrationUpdateException(xrl.Request.command, xrl.XErr, xrl.ErrorStatusMessage);
            }

            if (state != null)
            {
                state.Update_Transfer(userPuid, machinePuid);
            }
        }

        /// <summary>
        /// Execute an UpdateLicenseTransferState request to state Cancel
        /// </summary>
        /// <param name="userPuid"></param>
        internal static void DoXrlCancelMigration(ulong userPuid)
        {
            if (VerboseOutput)
            {
                RO.Debug("Canceling license migration (xrl api) for user=0x{0:X}...", userPuid);
            }

            XRLUpdateLicenseTransferState xrl = new XRLUpdateLicenseTransferState();
            xrl.Request.command = UpdateTransferStateEnum.Cancel;
            xrl.Request.userPuid = userPuid;

            if (!xrl.Execute())
            {
                throw new LicenseMigrationUpdateException(xrl.Request.command, xrl.XErr, xrl.ErrorStatusMessage);
            }
        }

        //gets the status of a transfer
        internal static GetLicenseTransferStateResponse DoXrlGetTransferStatus(ulong userPuid)
        {
            return DoXrlGetTransferStatus(userPuid, 0, false);
        }

        internal static GetLicenseTransferStateResponse DoXrlGetTransferStatus(ulong userPuid, ulong machinePuid, Boolean fromConsole)
        {
            XRLGetLicenseTransferState xrl = new XRLGetLicenseTransferState();
            xrl.Request.userPuid = userPuid;
            xrl.MachinePuid = machinePuid;
            xrl.UseHttpAuth = !fromConsole;

            if (!xrl.Execute())
            {
                throw new XErrException(xrl.XErr, xrl.ErrorStatusMessage);
            }

            return xrl.Response;
        }

        internal static string XrlGetTransferStatusToString(GetLicenseTransferStateResponse resp)
        {
            if (resp == null)
            {
                return "null";
            }

            string s = "";
            s += "currentStatus: " + resp.currentStatus + "\n";
            s += "restartAllowed: " + resp.restartAllowed + "\n";
            s += "lastUpdated: " + resp.lastUpdated + "\n";
            s += "consoleIdLength: " + resp.consoleIdLength + " - ";
            s += "consoleId: " + resp.consoleId + "\n";
            s += "sourceConsolesLength: " + resp.sourceConsolesLength + "\n";
            foreach (ConsoleLicenseCount clc in resp.sourceConsoles)
            {
                s += "  licenseCount=" + clc.licenseCount + " - consoleIdLength=" + clc.consoleIdLength + " - consoleId=" + clc.consoleId + "\n";
            }
            s += "sourceVideoConsolesLength: " + resp.sourceVideoConsolesLength + "\n";
            foreach (ConsoleLicenseCount clc in resp.sourceVideoConsoles)
            {
                s += "  licenseCount=" + clc.licenseCount + " - consoleIdLength=" + clc.consoleIdLength + " - consoleId=" + clc.consoleId + "\n";
            }

            return s;
        }
        #endregion //Xrl Transfer Methods

        /// <summary>
        /// Signs a user into presense on a specific machine, which updates the license migration table
        /// </summary>
        /// <param name="userPuid">The user you want to sign into presence</param>
        /// <param name="machinePuid">The machine you want the user to sign into</param>
        internal static void SignInPresence(ulong userPuid, ulong machinePuid)
        {
            //lookup gamertag
            string gtag = (string)UodbWS.ExecuteSQLScalar("select vc_gamertag from t_users where bi_user_puid=" + userPuid, userPuid);
            if (gtag == null)
            {
                throw new Exception("Got back null from t_users lookup for " + userPuid);
            }
            if (gtag.Length == 0)
            {
                throw new Exception("Got back an empty string from t_users lookup for " + userPuid);
            }

            //do the presense stuff
            if (VerboseOutput)
            {
                RO.Debug("Signing into presence with " + gtag + "(0x{0:X}) on machine 0x{1:X}", userPuid, machinePuid);
            }
            PNXbox presXbox = new PNXbox(machinePuid, 0xfffe07d1, CSGInfo.ClientType.Xenon);
            PNUser presUser = new PNUser(gtag, userPuid, presXbox);

            for (int i = 0; i < 10; ++i)
            {
                try
                {
                    presUser.Connect(presXbox);
                    presUser.Alive();
                    break;
                }
                catch (Exception e)
                {
                    if (i == 9) throw;
                    RO.Debug("Presence sign in failed on try " + (i + 1) + " of 10... retrying... (" + e.Message + ")");
                    System.Threading.Thread.Sleep(i * 1000 / 2);
                }
                finally
                {
                    //totally disconnect from presence in every way possible to avoid lingering connection issues during stress
                    if (presUser != null)
                    {
                        try
                        {
                            presUser.Disconnect();
                        }
                        catch (System.Exception e)
                        {
                            RO.Warn("presUser.Disconnect() failed: " + e);
                        }
                    }

                    if (presXbox != null && presXbox.ConnectionServerConnection != null)
                    {
                        try
                        {
                            presXbox.ConnectionServerConnection.Disconnect();
                        }
                        catch (System.Exception e)
                        {
                            RO.Warn("presXbox.ConnectionServerConnection.Disconnect() failed: " + e);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Manually 'advances' the time since a license transfer has occured by modifying the
        /// license transfer database.  Advances transfer time by the default license transfer
        /// time limit (probably one year).
        /// </summary>
        /// <param name="userPuid">The user you want to advance the transfer time on</param>
        public static void AdvanceTimeOnLicenseTransferState(ulong userPuid)
        {
            AdvanceTimeOnLicenseTransferState(userPuid, LiceMigSettings.DefaultTransferAgainTime);
        }

        /// <summary>
        /// Manually 'advances' the time since a license transfer has occured by modifying the
        /// license transfer database.  Note that this actually subtracts the given amount of 
        /// time from the appropriate columns in the table (i.e. making the events occur that 
        /// far in the past).
        /// </summary>
        /// <param name="userPuid">The user you want to advance the transfer time on</param>
        /// <param name="amountOfTimeToPass">The amount of time to advance the transfer state</param>
        public static void AdvanceTimeOnLicenseTransferState(ulong userPuid, TimeSpan amountOfTimeToPass)
        {
            RO.Debug("Advancing time by {0} for user 0x{0:X}", amountOfTimeToPass, userPuid);

            // Note here that we're partitioning on the bi_xuid column as appropriate
            UodbTable licenseTransferInfo = new UodbTable("t_user_license_transfer", "bi_xuid");
            licenseTransferInfo.SetConstraint("bi_xuid", userPuid);

            // Grab the data from the database
            if (UserCommercedbWS.ExecuteSQLSelect(licenseTransferInfo) > 0)
            {
                // Get the three dates that we need
                DateTime startDate = (DateTime)licenseTransferInfo.GetProperty("dt_process_started");
                DateTime lastChange = (DateTime)licenseTransferInfo.GetProperty("dt_last_changed");
                DateTime changeDate = (DateTime)licenseTransferInfo.GetProperty("dt_change_datetime");

                // Modify them by the appropriate ammount
                licenseTransferInfo.SetProperty("dt_process_started", startDate - amountOfTimeToPass);
                licenseTransferInfo.SetProperty("dt_last_changed", lastChange - amountOfTimeToPass);
                licenseTransferInfo.SetProperty("dt_change_datetime", changeDate - amountOfTimeToPass);

                // Then commit them back to the database
                UserCommercedbWS.ExecuteSQLUpdate(licenseTransferInfo);
            }
        }

        public static void DoVideoLicenseAcquire(Int32 whichVideo, ulong userPuid, ulong machinePuid)
        {
            throw new UnexpectedTestResultException("This method is no longer supported");            
        }

        //verifies the purchase reporting tables have the number of rows we expect for each machine
        public static void VerifyReportingRowsForMachine(ulong machinePuid, uint numberOfPurchases, uint numberOfPending)
        {
            uint countPurchased0 = UserCommercedbWS.ExecuteSQLSelectCount("select count(*) from t_dmp_purchase_transactions where bi_machine_puid=" + (long)machinePuid);
            uint countPending = UserCommercedbWS.ExecuteSQLSelectCount("select count(*) from t_user_license_pending_dmp_reporting where bi_machine_puid=" + (long)machinePuid);

            ValueCheck.Test(string.Format("t_dmp_purchase_transactions for machine 0x{0:X}", machinePuid), numberOfPurchases, countPurchased0);
            ValueCheck.Test(string.Format("t_user_license_pending_dmp_reporting for machine 0x{0:X}", machinePuid), numberOfPending, countPending);

            if (VerboseOutput)
            {
                RO.Debug(string.Format("Verified that machine 0x{0:X} has " + countPurchased0 + " purchases and " + countPending + " pending", machinePuid));
            }
        }

        //verifies the purchase reporting tables have the number of rows we expect for each machine
        public static void VerifyReportingRowsForUser(ulong userPuid, uint numberOfPurchases, uint numberOfPending)
        {
            uint countPurchased0 = UserCommercedbWS.ExecuteSQLSelectCount("select count(*) from t_dmp_purchase_transactions where bi_user_puid=" + (long)userPuid);
            uint countPending = UserCommercedbWS.ExecuteSQLSelectCount("select count(*) from t_user_license_pending_dmp_reporting where bi_xuid=" + (long)userPuid);

            ValueCheck.Test(string.Format("t_dmp_purchase_transactions for user 0x{0:X}", userPuid), numberOfPurchases, countPurchased0);
            ValueCheck.Test(string.Format("t_user_license_pending_dmp_reporting for user 0x{0:X}", userPuid), numberOfPending, countPending);

            if (VerboseOutput)
            {
                RO.Debug(string.Format("Verified that user 0x{0:X} has " + countPurchased0 + " purchases and " + countPending + " pending", userPuid));
            }
        }
    }

    #region Test Classes
    /// <summary>
    /// TestGroup base class to automatically create a LicensceMigration
    /// test for both of the available APIs
    /// </summary>
    public class MultiApiTestGroup : TestNode
    {
        protected override void EditInstances(ref List<CompoundCaseAttribute> instances)
        {
            instances.Add(new CompoundCaseAttribute("WidgetApi", 0));
            instances.Add(new CompoundCaseAttribute("XrlApi", 1));
            instances.Add(new CompoundCaseAttribute("XrlImmediateApi", 2));
        }

        /// <summary>
        /// Do the actual transfer using the appropriate interface
        /// </summary>
        public void DoTransfer(ulong userPuid, string consoleID, ulong machinePuid, LicensesState state)
        {
            switch ((Int32)MyValues[0])
            {
                case 0:
                    // This is the WebWidget call which is the method that CSS uses to call these APIs
                    LicenseMigrationUtils.WidgetTransferLicenses(userPuid, consoleID, machinePuid, state);
                    break;
                case 1:
                    // This is the XRL API as called by Xbox.com through LiveCache
                    LicenseMigrationUtils.XrlSimpleTransferLicenses(userPuid, consoleID, machinePuid, state);
                    break;
                case 2:
                    // This is the XRL API as called by the console to perform an immediate transfer
                    LicenseMigrationUtils.XrlSimpleTransferLicensesImmediate(userPuid, consoleID, machinePuid, state);
                    break;
            }
        }
    }

    /// <summary>
    /// Test base class used to ensure that the API specificed by the group parent node is used
    /// </summary>
    public class MultiApiTestBase : TestNode
    {
        /// <summary>
        /// Delegate the API call to the appropriate interface in the parent group
        /// </summary>
        public void DoTransfer(ulong userPuid, string consoleID, ulong machinePuid, LicensesState state)
        {
            TestNode mainGroup = this.Parent;
            while (!(mainGroup is MultiApiTestGroup))
            {
                mainGroup = mainGroup.Parent;

                if (mainGroup == null)
                {
                    throw new Exception("Cannot find the shared group type parent node to call DoTransfer on.");
                }
            }

            ((MultiApiTestGroup)mainGroup).DoTransfer(userPuid, consoleID, machinePuid, state);
        }
    }
    #endregion // Test Classes

    /// <summary>
    /// An exception that is thrown when an error occurs during an update 
    /// of the license migration state
    /// </summary>
    public class LicenseMigrationUpdateException : XErrException
    {
        private UpdateTransferStateEnum state;
        public UpdateTransferStateEnum State
        {
            get { return state; }
        }

        public LicenseMigrationUpdateException(UpdateTransferStateEnum state, uint xErr)
            : base(xErr)
        {
            Initialize(state);
        }

        public LicenseMigrationUpdateException(UpdateTransferStateEnum state, uint xErr, string message)
            : base(xErr, message)
        {
            Initialize(state);
        }

        public LicenseMigrationUpdateException(UpdateTransferStateEnum state, uint xErr, string message, Exception inner)
            : base(xErr, message, inner)
        {
            Initialize(state);
        }

        private void Initialize(UpdateTransferStateEnum state)
        {
            this.state = state;
            Global.RO.Debug("License Migration Error - State: " + state);
        }
    }

    /// <summary>
    /// Tracks and verifies the state of licenses on different boxes
    /// </summary>
    public class LicensesState
    {
        /// <summary>
        /// Add a machine to the interal list of machines
        /// </summary>
        /// <param name="machine">The machine ID to add</param>
        private void AddMachine(ulong machine)
        {
            if (!seenMachines.Contains(machine))
            {
                seenMachines.Add(machine);
            }
        }

        /// <summary>
        /// Add a user to the internal list of users
        /// </summary>
        /// <param name="user">The user to add</param>
        private void AddUser(ulong user)
        {
            if (!seenUsers.Contains(user))
            {
                seenUsers.Add(user);
            }
        }

        /// <summary>
        /// Update state with indicated non-video license purchase
        /// </summary>
        /// <param name="offerID">Offer being purchased</param>
        /// <param name="user">User purchased by</param>
        /// <param name="machine">Machine purchased on</param>
        public void AddGameLicense(ulong offerID, ulong user, ulong machine)
        {
            AddUser(user);
            AddMachine(machine);

            gameLicenses.Add(new License(offerID, user, machine));
        }

        public void AddGameLicense(Guid offerId, ulong user, ulong machine)
        {
            AddUser(user);
            AddMachine(machine);

            gameLicenses.Add(new GameLicense(offerId, user, machine));
        }

        /// <summary>
        /// Update state with indicated video license purchase
        /// </summary>
        /// <param name="offerID">Offer being purchased</param>
        /// <param name="user">User purchased by</param>
        /// <param name="machine">Machine purchased on</param>
        public void AddVideoLicense(Guid offerID, ulong user, ulong machine)
        {
            AddUser(user);
            AddMachine(machine);

            this.videoLicenses.Add(new VideoLicense(offerID, user, machine));
        }

        //state change: nonvideo license purchaced
        public void Update_BuyGame(ulong offerID, ulong user, ulong machine)
        {
            AddGameLicense(offerID, user, machine);
        }

        public void Update_BuyGame(Guid offerId, ulong user, ulong machine)
        {
            AddGameLicense(offerId, user, machine);
        }

        //state change: video license purchaced
        public void Update_BuyVideo(Guid offerID, ulong user, ulong machine)
        {
            AddVideoLicense(offerID, user, machine);
        }

        //state change: license transferred
        public void Update_Transfer(ulong sourceUser, ulong destMachine)
        {
            if (!seenMachines.Contains(destMachine)) seenMachines.Add(destMachine);
            if (!seenUsers.Contains(sourceUser)) seenUsers.Add(sourceUser);

            foreach (LicenseBase l in gameLicenses)
            {
                if (l.UserOwner == sourceUser)
                {
                    //the platform (upper 16 bits) must also match for the transfer to occur
                    if ((0xffff000000000000 & l.MachineOwner) == (0xffff000000000000 & destMachine))
                    {
                        l.MachineOwner = destMachine;
                    }
                }
            }

            foreach (VideoLicense l in videoLicenses)
            {
                if (l.UserOwner == sourceUser)
                {
                    //the platform (upper 16 bits) must also match for the transfer to occur
                    if ((0xffff000000000000 & l.MachineOwner) == (0xffff000000000000 & destMachine))
                    {
                        l.MachineOwner = destMachine;
                    }
                }
            }
        }

        //verify that the state is correct
        public void Verify()
        {
            if (LicenseMigrationUtils.VerboseOutput)
            {
                LicenseMigrationUtils.RO.Debug("Verifying licenses...");
            }

            //make the "clean" machine if we need one
            if (thirdPartyMachine == 0)
            {
                XmacsClient xmacsOrig = SignatureUtils.CreateClient();
                thirdPartyMachine = xmacsOrig.GetMachinePuid();
            }

            //generate a list of unique offers
            List<ulong> offers = new List<ulong>();
            List<Guid> gameOffers = new List<Guid>();
            List<Guid> videos = new List<Guid>();

            foreach (License l in gameLicenses.FindAll(License.IsLicenseType))
            {
                if (!offers.Contains(l.OfferId)) offers.Add(l.OfferId);
            }

            foreach (GameLicense l in gameLicenses.FindAll(GameLicense.IsLicenseType))
            {
                if (!gameOffers.Contains(l.OfferId)) gameOffers.Add(l.OfferId);
            }

            foreach (VideoLicense l in videoLicenses)
            {
                if (!videos.Contains(l.OfferId)) videos.Add(l.OfferId);
            }

            //verify every machine
            foreach (ulong machine in seenMachines)
            {
                foreach (ulong offer in offers)
                {
                    bool shouldHave = MachineHasOffer(machine, offer);
                    LicenseMigrationUtils.VerifyOwnsOffer(offer, machine, 0, shouldHave);
                }

                foreach (Guid game in gameOffers)
                {
                    bool shouldHave = MachineHasOffer(machine, game);
                    LicenseMigrationUtils.VerifyOwnsOffer(game, machine, 0, shouldHave);
                }

                foreach (Guid video in videos)
                {
                    bool shouldHave = MachineHasVideo(machine, video);
                    LicenseMigrationUtils.VerifyOwnsNewVideo(video, machine, 0, shouldHave);
                }
            }

            //verify every user
            foreach (ulong user in seenUsers)
            {
                foreach (ulong offer in offers)
                {
                    bool shouldHave = UserHasOffer(user, offer);
                    LicenseMigrationUtils.VerifyOwnsOffer(offer, thirdPartyMachine, user, shouldHave);
                }

                foreach (Guid game in gameOffers)
                {
                    bool shouldHave = UserHasOffer(user, game);
                    LicenseMigrationUtils.VerifyOwnsOffer(game, thirdPartyMachine, user, shouldHave);
                }

                foreach (Guid video in videos)
                {
                    bool shouldHave = UserHasVideo(user, video);
                    LicenseMigrationUtils.VerifyOwnsNewVideo(video, thirdPartyMachine, user, shouldHave);
                }
            }
        }

        //retrieves a list of counts of game licenses on each machine for a specific user
        public Dictionary<ulong, int> GetGameLicenseCountsForUser(ulong userPuid, bool includeNonXenon)
        {
            const ulong prefixMask = 0xFFFF000000000000;
            const ulong xenonPrefix = 0xFA00000000000000;
            Dictionary<ulong, int> list = new Dictionary<ulong, int>();

            foreach (LicenseBase l in gameLicenses.Where(l => l.UserOwner == userPuid && (includeNonXenon || (l.MachineOwner & prefixMask) == xenonPrefix)))
            {
                if (!list.ContainsKey(l.MachineOwner))
                {
                    list.Add(l.MachineOwner, 0);
                }

                ++list[l.MachineOwner];
            }

            return list;
        }

        //retrieves a list of counts of vdeo licenses on each machine for a specific user
        public Dictionary<ulong, int> GetVideoLicenseCountsForUser(ulong userPuid, bool includeNonXenon)
        {
            Dictionary<ulong, int> list = new Dictionary<ulong, int>();

            foreach (VideoLicense l in videoLicenses)
            {
                if (l.UserOwner == userPuid)
                {
                    if (includeNonXenon || (!includeNonXenon && (l.MachineOwner >= 0xfa00000000000000 && l.MachineOwner <= 0xfaffffffffffffff)))
                    {
                        if (!list.ContainsKey(l.MachineOwner))
                        {
                            list.Add(l.MachineOwner, 0);
                        }

                        ++list[l.MachineOwner];
                    }
                }
            }

            return list;
        }

        //internals
        private class LicenseBase
        {
            public ulong UserOwner;
            public ulong MachineOwner;

            public LicenseBase(ulong user, ulong machine)
            {
                UserOwner = user;
                MachineOwner = machine;
            }

            public static bool CheckUserLicense<T>(ulong user, T offer, IEnumerable<LicenseBase> licenses)
            {
                foreach (LicenseBase<T> license in licenses)
                {
                    if (license.OfferId.Equals(offer) && license.UserOwner == user)
                    {
                        return true;
                    }
                }

                return false;
            }

            public static bool CheckMachineLicense<T>(ulong machine, T offer, IEnumerable<LicenseBase> licenses)
            {
                foreach (LicenseBase<T> license in licenses)
                {
                    if (license.OfferId.Equals(offer) && license.MachineOwner == machine)
                    {
                        return true;
                    }
                }

                return false;
            }

            public static bool IsLicenseType<T>(LicenseBase license)
            {
                return license is T;
            }
        }

        private class LicenseBase<T> : LicenseBase
        {
            public T OfferId;

            public LicenseBase(T offerId, ulong user, ulong machine)
                : base(user, machine)
            {
                OfferId = offerId;
            }

            public static bool IsLicenseType(LicenseBase license)
            {
                return license is LicenseBase<T>;
            }
        }

        private class License : LicenseBase<ulong>
        {
            public License(ulong offerId, ulong user, ulong machine) : base(offerId, user, machine) { }
        }

        private class GameLicense : LicenseBase<Guid>
        {
            public GameLicense(Guid offerId, ulong user, ulong machine) : base(offerId, user, machine) { }
        }

        private class VideoLicense : LicenseBase<Guid>
        {
            public VideoLicense(Guid offerId, ulong user, ulong machine) : base(offerId, user, machine) { }
        }

        private bool MachineHasOffer(ulong machine, ulong offer)
        {
            return LicenseBase.CheckMachineLicense(machine, offer, gameLicenses);
        }

        private bool MachineHasOffer(ulong machine, Guid offer)
        {
            return LicenseBase.CheckMachineLicense(machine, offer, gameLicenses);
        }

        private bool UserHasOffer(ulong user, ulong offer)
        {
            return LicenseBase.CheckUserLicense(user, offer, gameLicenses);
        }

        private bool UserHasOffer(ulong user, Guid offer)
        {
            return LicenseBase.CheckUserLicense(user, offer, gameLicenses);
        }

        private bool MachineHasVideo(ulong machine, Guid offer)
        {
            foreach (VideoLicense license in videoLicenses)
            {
                if (license.OfferId == offer && license.MachineOwner == machine)
                {
                    return true;
                }
            }

            return false;
        }

        private bool UserHasVideo(ulong user, Guid offer)
        {
            foreach (VideoLicense l in videoLicenses)
            {
                if (l.OfferId == offer && l.UserOwner == user)
                {
                    return true;
                }
            }

            return false;
        }

        List<LicenseBase> gameLicenses = new List<LicenseBase>();
        List<VideoLicense> videoLicenses = new List<VideoLicense>();

        ulong thirdPartyMachine = 0; //used to verify user licenses on an untouched machine

        List<ulong> seenMachines = new List<ulong>();
        List<ulong> seenUsers = new List<ulong>();
    }

    public class LicenseMigrationHelper : MediaTestHelper
    {
        protected LicensesState state;

        public LicenseMigrationHelper(MediaMatrix matrix) : base() { }

        public LicenseMigrationHelper(MediaMatrix matrix, MachineType machineType) : base(machineType) { }

        public LicenseMigrationHelper(MediaMatrix matrix, IUser user) : base(user) { }

        public LicenseMigrationHelper(MediaMatrix matrix, IMachine client) : base(client) { }

        public LicenseMigrationHelper(MediaMatrix matrix, IMachine client, IUser user) : base(client, user) { }

        public override void Reset(bool forceNewUserAndClient)
        {
            state = new LicensesState();

            base.Reset(forceNewUserAndClient);
        }

        public void PurchaseVideo(ulong userPuid, ulong machinePuid, params VideoInformation[] mediaToPurchase)
        {
            base.Purchase(userPuid, machinePuid, mediaToPurchase.Cast<MediaInformation>());

            foreach (VideoInformation info in mediaToPurchase)
            {
                state.Update_BuyVideo(info.OfferExpectedPrice.offerId, userPuid, machinePuid);
            }
        }

        public void PurchaseGame(ulong userPuid, ulong machinePuid, params GameInformation[] gamesToPurchase)
        {
            base.Purchase(userPuid, machinePuid, gamesToPurchase.Cast<MediaInformation>());

            foreach (GameInformation info in gameInfo)
            {
                state.Update_BuyGame(info.OfferId, userPuid, machinePuid);
            }
        }

        public void VerifyState()
        {
            state.Verify();
        }

        public void DoTransfer(IMachine targetMachine)
        {
            PerformLicenseMigration(targetMachine);
        }

        public void PerformLicenseMigration(IMachine targetMachine)
        {
            //PerformLicenseMigration(targetMachine.ConsoleId, targetMachine.GetMachinePuid());

            // Update the license state
            state.Update_Transfer(UserPuid, targetMachine.Puid);

            // Store this client 
            this.machine = targetMachine;
        }

        public override void Cleanup()
        {
            // Clear user license transfer stuff
            UserCommercedbWS.ExecuteSQLNonQuery(String.Format(
                "delete from t_user_license_pending_dmp_reporting where bi_user_puid = 0x{0:X}", User.Puid),
                User.Puid);
            UserCommercedbWS.ExecuteSQLNonQuery(String.Format(
                "delete from t_user_license_transfer where bi_user_puid = 0x{0:X}", User.Puid), 
                User.Puid);

            base.Cleanup();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\LicenseMigration\VideoTransfers.cs ===
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Billing.License;

using System.Collections.Generic;
using System.Data.SqlClient;

using xonline.common.config;
using xonline.common.protocol;
using SigTest.License;
using xonline.common.billing;
using System;

namespace SigTest.LicenseMigration.Functional
{
    partial class LiceMigTests: TestNode
    {
        [TestGroup, Owner("BenRan"), TestFrequency("Regression")]
        public class VideoTransfers : MultiApiTestGroup
        {
            // Video Only Tests
            [TestCase, TestCasePriority(2), Description("Buy on box 0, migrate to box 1, then migrate to box 2")]
            public void MigrateTwice()
            {
                LicensesState state = new LicensesState();

                MediaTestHelper srcHelper = new MediaTestHelper();
                srcHelper.Reset();
                MediaTestHelper dst1Helper = new MediaTestHelper(srcHelper.User);
                dst1Helper.Reset(false);
                MediaTestHelper dst2Helper = new MediaTestHelper(srcHelper.User);
                dst2Helper.Reset(false);

                // Purchase a video on the source machine
                LicenseMigrationUtils.PurchaseVideo(srcHelper, LicenseType.SyncCastPPV, MediaTypeInfo.Movie, state);

                // Migrate it to the first machine
                DoTransfer(dst1Helper.UserPuid, dst1Helper.Machine.ConsoleId, dst1Helper.MachinePuid, state);

                // Advance the time then migrate it to the second machine
                LicenseMigrationUtils.AdvanceTimeOnLicenseTransferState(srcHelper.UserPuid, new System.TimeSpan(366, 0, 0, 0));
                DoTransfer(dst2Helper.UserPuid, dst2Helper.Machine.ConsoleId, dst2Helper.MachinePuid, state);

                state.Verify();

                srcHelper.Cleanup();
                dst1Helper.Cleanup();
                dst2Helper.Cleanup();
            }

            [TestCase, TestCasePriority(2), Description("buy on box 0, migrate to box 1, buy something else on box 0, migrate to box 1")]
            public void MigrateTwiceToSameBox()
            {
                LicensesState state = new LicensesState();

                MediaTestHelper srcHelper = new MediaTestHelper();
                srcHelper.Reset();

                MediaTestHelper dstHelper = new MediaTestHelper(srcHelper.User);
                dstHelper.Reset(false);

                // Buy a random video
                LicenseMigrationUtils.PurchaseVideo(srcHelper, LicenseType.SyncCastPPV, MediaTypeInfo.Movie, state);

                // Migrate it to the destination machine
                DoTransfer(dstHelper.UserPuid, dstHelper.Machine.ConsoleId, dstHelper.MachinePuid, state);

                // Buy another video on the inital machine
                LicenseMigrationUtils.PurchaseVideo(srcHelper, LicenseType.SyncCastPPV, MediaTypeInfo.Movie, state);

                // Advance the license transfer time and transfer again to the same box
                LicenseMigrationUtils.AdvanceTimeOnLicenseTransferState(srcHelper.UserPuid, new System.TimeSpan(366, 0, 0, 0));
                DoTransfer(dstHelper.UserPuid, dstHelper.Machine.ConsoleId, dstHelper.MachinePuid, state);

                //verify licenses
                state.Verify();
            }

            [TestCase, TestCasePriority(2), AsyncGroup(1), AsyncThreadDelay(1000), Description("Main Matrix")]
            //                                        [               user 0                  ] [                  user 1               ]
            //                                         buyv0b0 buyv1b0 buyv0b1 buyv1b1 destbox   buyv0b0 buyv1b0 buyv0b1 buyv1b1 destbox
            [CompoundCase("u0=v0b0    mv0 u1=       ", true,   false,  false,  false,  0,        false,  false,  false,  false,  -1)] // No-op transfer
            [CompoundCase("u0=v0b0    mv1 u1=      ",  true,   false,  false,  false,  1,        false,  false,  false,  false,  -1)]
            [CompoundCase("u0=v0b0    mv1 u1=v0b0nm",  true,   false,  false,  false,  1,        true,   false,  false,  false,  -1)]
            [CompoundCase("u0=v0b0    mv1 u1=v1b0nm",  true,   false,  false,  false,  1,        false,  true,   false,  false,  -1)]
            [CompoundCase("u0=v0b0    mv1 u1=v0b1nm",  true,   false,  false,  false,  1,        false,  false,  true,   false,  -1)]
            [CompoundCase("u0=v0b0    mv1 u1=v1b1nm",  true,   false,  false,  false,  1,        false,  false,  false,  true,   -1)]
            [CompoundCase("u0=v0b0v1b0mv1 u1=v0b0nm",  true,   true,   false,  false,  1,        true,   false,  false,  false,  -1)]
            [CompoundCase("u0=v0b0v1b0mv1 u1=v1b0nm",  true,   true,   false,  false,  1,        false,  true,   false,  false,  -1)]
            [CompoundCase("u0=v0b0v1b0mv1 u1=v0b1nm",  true,   true,   false,  false,  1,        false,  false,  true,   false,  -1)]
            [CompoundCase("u0=v0b0v1b0mv1 u1=v1b1nm",  true,   true,   false,  false,  1,        false,  false,  false,  true,   -1)]
            [CompoundCase("u0=v0b0    mv1 u1=v0b0mv0", true,   false,  false,  false,  1,        true,   false,  false,  false,   0)]
            [CompoundCase("u0=v0b0    mv1 u1=v1b0mv0", true,   false,  false,  false,  1,        false,  true,   false,  false,   0)]
            [CompoundCase("u0=v0b0    mv1 u1=v0b1mv0", true,   false,  false,  false,  1,        false,  false,  true,   false,   0)]
            [CompoundCase("u0=v0b0    mv1 u1=v1b1mv0", true,   false,  false,  false,  1,        false,  false,  false,  true,    0)]
            [CompoundCase("u0=v0b0v1b0mv1 u1=v0b0mv0", true,   true,   false,  false,  1,        true,   false,  false,  false,   0)]
            [CompoundCase("u0=v0b0v1b0mv1 u1=v1b0mv0", true,   true,   false,  false,  1,        false,  true,   false,  false,   0)]
            [CompoundCase("u0=v0b0v1b0mv1 u1=v0b1mv0", true,   true,   false,  false,  1,        false,  false,  true,   false,   0)]
            [CompoundCase("u0=v0b0v1b0mv1 u1=v1b1mv0", true,   true,   false,  false,  1,        false,  false,  false,  true,    0)]
            [CompoundCase("u0=v0b0    mv2 u1=v0b0mv2", true,   false,  false,  false,  2,        true,   false,  false,  false,   2)]
            [CompoundCase("u0=v0b0    mv2 u1=v1b0mv2", true,   false,  false,  false,  2,        false,  true,   false,  false,   2)]
            [CompoundCase("u0=v0b0    mv2 u1=v0b1mv2", true,   false,  false,  false,  2,        false,  false,  true,   false,   2)]
            [CompoundCase("u0=v0b0    mv2 u1=v1b1mv2", true,   false,  false,  false,  2,        false,  false,  false,  true,    2)]
            [CompoundCase("u0=v0b0v1b0mv2 u1=v0b0mv2", true,   true,   false,  false,  2,        true,   false,  false,  false,   2)]
            [CompoundCase("u0=v0b0v1b0mv2 u1=v1b0mv2", true,   true,   false,  false,  2,        false,  true,   false,  false,   2)]
            [CompoundCase("u0=v0b0v1b0mv2 u1=v0b1mv2", true,   true,   false,  false,  2,        false,  false,  true,   false,   2)]
            [CompoundCase("u0=v0b0v1b0mv2 u1=v1b1mv2", true,   true,   false,  false,  2,        false,  false,  false,  true,    2)]
            [CompoundCase("u0=v0b0    mv2 u1=v1b0mv1", true,   false,  false,  false,  2,        false,  true,   false,  false,   1)]
            [CompoundCase("u0=v0b0v1b1mv0 u1=v0b0mv1", true,   false,  false,  true,   0,        true,   false,  false,  false,   1)]
            [CompoundCase("u0=v0b0v1b1mv0 u1=       ", true,   false,  false,  true,   0,        false,  false,  false,  false,  -1)]
            public class UserBoxVideoMatrix : MultiApiTestBase
            {
                LicensesState state = null;
                MediaTestHelper[][] helpers;

                bool buyVideo0User0Box0;
                bool buyVideo1User0Box0;
                bool buyVideo0User0Box1;
                bool buyVideo1User0Box1;
                int boxToMoveUser0To;

                bool buyVideo0User1Box0;
                bool buyVideo1User1Box0;
                bool buyVideo0User1Box1;
                bool buyVideo1User1Box1;
                int boxToMoveUser1To;

                public override void PreRun()
                {
                    state = new LicensesState();

                    //params
                    buyVideo0User0Box0 = (bool)MyValues[0];
                    buyVideo1User0Box0 = (bool)MyValues[1];
                    buyVideo0User0Box1 = (bool)MyValues[2];
                    buyVideo1User0Box1 = (bool)MyValues[3];
                    boxToMoveUser0To = (int)MyValues[4]; //-1 to not do

                    buyVideo0User1Box0 = (bool)MyValues[5];
                    buyVideo1User1Box0 = (bool)MyValues[6];
                    buyVideo0User1Box1 = (bool)MyValues[7];
                    buyVideo1User1Box1 = (bool)MyValues[8];
                    boxToMoveUser1To = (int)MyValues[9]; //-1 to not do

                    IUser[] users = new IUser[2];
                    for (int i = 0; i < users.Length; i++)
                    {
                        users[i] = TestHelper.GetSharedUser();
                    }

                    IMachine[] machines = new IMachine[3];
                    for (int i = 0; i < machines.Length; i++)
                    {
                        machines[i] = TestHelper.GetSharedMachine();
                    }

                    helpers = new MediaTestHelper[users.Length][];
                    for (int i = 0; i < users.Length; i++)
                    {
                        helpers[i] = new MediaTestHelper[machines.Length];
                        for (int j = 0; j < machines.Length; j++)
                        {
                            helpers[i][j] = new MediaTestHelper(machines[j], users[i]);
                            helpers[i][j].Reset(false);
                            helpers[i][j].ReuseUser = true;
                        }
                    }

                    // Purchase the videos
                    if (buyVideo0User0Box0) LicenseMigrationUtils.PurchaseVideo(helpers[0][0], LicenseType.SyncCastPPV, MediaTypeInfo.Movie, state);
                    if (buyVideo1User0Box0) LicenseMigrationUtils.PurchaseVideo(helpers[0][0], LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode, state);
                    if (buyVideo0User0Box1) LicenseMigrationUtils.PurchaseVideo(helpers[0][1], LicenseType.SyncCastPPV, MediaTypeInfo.Movie, state);
                    if (buyVideo1User0Box1) LicenseMigrationUtils.PurchaseVideo(helpers[0][1], LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode, state);
                    if (buyVideo0User1Box0) LicenseMigrationUtils.PurchaseVideo(helpers[1][0], LicenseType.SyncCastPPV, MediaTypeInfo.Movie, state);
                    if (buyVideo1User1Box0) LicenseMigrationUtils.PurchaseVideo(helpers[1][0], LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode, state);
                    if (buyVideo0User1Box1) LicenseMigrationUtils.PurchaseVideo(helpers[1][1], LicenseType.SyncCastPPV, MediaTypeInfo.Movie, state);
                    if (buyVideo1User1Box1) LicenseMigrationUtils.PurchaseVideo(helpers[1][1], LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode, state);

                    // License Sanity Check
                    ro.Debug("Verifying initial state of the licenses...");
                    state.Verify();
                }

                public override void Run()
                {
                    //do migrations
                    if (boxToMoveUser0To != -1)
                    {
                        var dstHelper = helpers[0][boxToMoveUser0To];
                        DoTransfer(dstHelper.UserPuid, dstHelper.Machine.ConsoleId, dstHelper.MachinePuid, state);
                    }
                    if (boxToMoveUser1To != -1)
                    {
                        var dstHelper = helpers[1][boxToMoveUser1To];
                        DoTransfer(dstHelper.UserPuid, dstHelper.Machine.ConsoleId, dstHelper.MachinePuid, state);
                    }

                    //verify licenses
                    ro.Debug("Verifying licenses after transfer...");
                    state.Verify();
                }

                public override void PostRun()
                {
                    // Cleanup all the helpers.  This will safely ensure that all 
                    // users are only added to the user queue a single time.
                    for (int i = 0; i < helpers.Length; i++)
                    {
                        for (int j = 0; j < helpers[i].Length; j++)
                        {
                            helpers[i][j].Cleanup();
                        }
                    }
                }
            }

            /// <summary>
            /// Test transferring content between two different platforms.  This should result in no change.
            /// </summary>
            /// <remarks>Xbox1 does not support purchasing video</remarks>
            /// <testcase>Xenon to PC</testcase>
            [TestCase, TestCasePriority(3), Description("Purchase on one platform and try to migrate to another.. nothing should happen")]
            [CompoundCase("Xenon to PC", MachineType.Xbox360, MachineType.PC)]
            [CompoundCase("Xenon to Phone", MachineType.Xbox360, MachineType.Phone)]
            public class DifferentPlatforms : MultiApiTestBase
            {
                LicensesState state;
                MediaTestHelper helperSrc;
                MediaTestHelper helperDst;

                public override void PreRun()
                {
                    state = new LicensesState();

                    helperSrc = new MediaTestHelper((MachineType)MyValues[0]);
                    helperSrc.Reset();

                    helperDst = new MediaTestHelper((MachineType)MyValues[1]);
                    helperDst.User = helperSrc.User;
                    helperDst.Reset(false);

                    var videoInfo = helperSrc.PurchaseVideo(LicenseType.SyncCastPPV, MediaTypeInfo.Movie);
                    state.Update_BuyVideo(videoInfo.OfferId, helperSrc.UserPuid, helperSrc.MachinePuid);
                }

                public override void Run()
                {
                    // Do the migration
                    DoTransfer(helperDst.UserPuid, helperDst.Machine.ConsoleId, helperDst.MachinePuid, state);

                    // Verify licenses
                    state.Verify();
                }

                public override void PostRun()
                {
                    helperSrc.Cleanup();
                    helperDst.Cleanup();
                }
            }

            // Mixed content license transfer

            [TestCase, TestCasePriority(2), Description("Purchase and Transfer Both a Video and Game License")]
            public class GameAndNewVideoTransfer : MultiApiTestBase
            {
                LicensesState state;
                MediaTestHelper helperSrc;
                MediaTestHelper helperDst;

                public override void PreRun()
                {
                    state = new LicensesState();

                    helperSrc = new MediaTestHelper();
                    helperSrc.Reset();

                    helperDst = new MediaTestHelper(helperSrc.User);
                    helperDst.Reset(false);

                    helperSrc.Purchase(MediaMatrix.TexasHoldEmOffer);
                    state.Update_BuyGame(MediaMatrix.TexasHoldEmOffer.OfferId, helperSrc.UserPuid, helperSrc.MachinePuid);

                    var videoInfo = helperSrc.PurchaseVideo(LicenseType.SyncCastDTO, MediaTypeInfo.TVEpisode);
                    state.Update_BuyVideo(videoInfo.OfferId, helperSrc.UserPuid, helperSrc.MachinePuid);

                    // Sanity check of license state
                    state.Verify();
                }

                public override void Run()
                {
                    // Migrate the content to the new console.
                    DoTransfer(helperSrc.UserPuid, helperDst.Machine.ConsoleId, helperDst.MachinePuid, state);

                    //verify licenses
                    state.Verify();
                }

                public override void PostRun()
                {
                    helperSrc.Cleanup();
                    helperDst.Cleanup();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\TestXsigWeb\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\LicenseMigration\WebApi.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Database;
using SigTest.License;

namespace SigTest.LicenseMigration.Functional
{
    partial class LiceMigTests: TestNode
    {
        [TestGroup, AsyncThreadCount(3), AsyncThreadDelay(1000), AsyncGroup(1, 0), Owner("BenRan"), TestFrequency("Regression")]
        public class WebWidget : TestNode
        {
            [TestCase, TestCasePriority(2), Description("buy on box 0, migrate to box 1, buy something else on box 0, migrate to box 1")]
            public void MigrateTwice()
            {
                LicensesState state = new LicensesState();

                //create a machine to buy the license on
                ro.Debug("Creating original machine...");
                IMachine xmacsOrig = (MachineBase)SignatureUtils.CreateClient();

                IUser user = TestHelper.GetSharedUser();

                // Note, this test only applies to the WebWidget as it ensures that a CSS call can successfully
                // migrate licenses twice for a user without waiting for any specific timeout
                try
                {
                    LicenseMigrationUtils.BuyOffer(user, xmacsOrig, MediaMatrix.TexasHoldEmOffer.OfferMediaTypeExpectedPrice, state);

                    //create a new machine that we'll move licenses to
                    ro.Debug("Creating destination machine...");
                    IMachine xmacsNew = (MachineBase)SignatureUtils.CreateClient();

                    //do the migration
                    LicenseMigrationUtils.WidgetTransferLicenses(user.Puid, xmacsNew.ConsoleId, xmacsNew.Puid, state);

                    //buy a different arcade game
                    LicenseMigrationUtils.BuyOffer(user, xmacsOrig, MediaMatrix.ArcadeGame.OfferMediaTypeExpectedPrice, state);

                    //do the migration
                    LicenseMigrationUtils.WidgetTransferLicenses(user.Puid, xmacsNew.ConsoleId, xmacsNew.Puid, state);

                    //verify licenses
                    ro.Debug("Verifying licenses...");
                    state.Verify();
                }
                finally
                {
                    MediaTestHelper.CleanupUser(user);
                    TestHelper.ReturnSharedUser(user);
                }
            }

            [TestCase, TestCasePriority(3), Description("Pass invalid user values for to the API")]
            [CompoundCase("NullUser",                 0)]
            [CompoundCase("BadUser", 0xfefefefefefefefe)]
            public class BadUserValues : TestNode
            {
                ulong userPuid;
                IMachine xmacsNew;

                public override void PreRun()
                {
                    // Grab the compound test case values we need
                    userPuid = Convert.ToUInt64(MyValues[0]);

                    ro.Debug("Creating users and machines...");

                    // Create the machine that the licenses will be moved to
                    xmacsNew = (MachineBase)MachineEditor.CreateNew(MachineType.Xbox360);
                }

                public override void Run()
                {
                    try
                    {
                        LicenseMigrationUtils.WidgetTransferLicenses(userPuid, xmacsNew.ConsoleIdNoPrefix, xmacsNew.Puid, null);
                    }
                    catch (System.Web.Services.Protocols.SoapException se) //support soap case
                    {
                        if (se.Message.Contains("Couldn't find user puid"))
                        {
                            return;
                        }
                        else
                        {
                            throw new UnexpectedTestResultException("Unexpected exception returned", se);
                        }
                    }

                    throw new UnexpectedTestResultException("Expected an exception to be thrown from calling the migration api.");
                }
            }

            [TestCase, TestCasePriority(3), Description("Pass invalid machine values for to the API")]
            [CompoundCase("NullMachine", "000000000000")]
            [CompoundCase("BadMachine",  "499999999999")]
            public class BadMachineValues : TestNode
            {
                String consoleId;
                IUser user = null;

                public override void PreRun()
                {
                    // Grab the compound test case values we need
                    consoleId = (string)MyValues[0];

                    ro.Debug("Creating users and machines...");

                    // Create a user
                    user = TestHelper.GetSharedUser();
                }

                public override void Run()
                {
                    try
                    {
                        LicenseMigrationUtils.WidgetTransferLicenses(user.Puid, consoleId, 0x1, null);
                    }
                    catch (System.Web.Services.Protocols.SoapException) //support soap case
                    {
                        // We can't get any more information from the Soap Exception, the 
                        // error message is swallowed up from XMachine and just returned 
                        // as a generic exception, but it should be good enough for now.
                        return;
                    }

                    throw new UnexpectedTestResultException("Expected an exception to be thrown from calling the migration api.");
                }

                public override void PostRun()
                {
                    MediaTestHelper.CleanupUser(user);
                    TestHelper.ReturnSharedUser(user);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\Oscar\Stress.cs ===
using System.Security.Cryptography.X509Certificates;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using xonline.common.protocol;
using System.Collections.Generic;

namespace SigTest.Oscar.Stress
{
    [TestGroup, Owner("BenRan"), TestFrequency("Regression")]
    public class OscarStress : TestNode
    {
        private StressBulkHelper bulkHelper = new StressBulkHelper();
        private Queue<CertState> certStates;

        public CertState GetCertState()
        {
            CertState certState = null;

            if (certStates.Count > 0)
            {
                lock (certStates)
                {
                    if (certStates.Count > 0)
                    {
                        certState = certStates.Dequeue();
                    }
                }
            }

            return certState ?? CreateCertState();
        }

        public void ReturnCertState(CertState certState)
        {
            if (certState != null)
            {
                certStates.Enqueue(certState);
            }
        }

        public CertState CreateCertState()
        {
            Global.RO.Debug("Creating new Oscar CertState...");
            return CertState.CreateOscar(false, false);
        }

        public override void PreRun()
        {
            bulkHelper.Initialize();

            // During stress, we're just going to ignore partial chains and invalid times on certificates
            // because the client we're running on might not have the required certs installed, and it will
            // get caught by the regualr tests if required
            CertHelper.ChainFlagsToIgnore = X509ChainStatusFlags.NotTimeValid | X509ChainStatusFlags.PartialChain;

            // The certificate states use real keys in the request, and that 
            // takes a long time to do.  So, we have a queue of states, which 
            // are used by each instance of the test and returned why complete.
            // New instances are created as required.
            certStates = new Queue<CertState>();
        }

        [StressTest]
        public void RequestOnly()
        {
            CertState certState = null;

            try
            {
                certState = GetCertState();
                certState.UserPuid = bulkHelper.GetNextBulkUserPuid();
                certState.MachineId = bulkHelper.GetNextBulkMachine().Id;
                certState.DoRequest();
            }
            finally
            {
                ReturnCertState(certState);
            }
        }

        [StressTest]
        public void RequestAndVerify()
        {
            CertState certState = null;

            try
            {
                certState = GetCertState();

                certState.UserPuid = bulkHelper.GetNextBulkUserPuid();
                MachineEditor mach = bulkHelper.GetNextBulkMachine();
                certState.MachineId = mach.Id;
                // The console ID (without "XE.") is used in cert subject, we
                // need it here so that we can verify the response.
                certState.ConsoleId = mach.ConsoleId.Substring(3);

                CreateCertificateResponse response = certState.DoRequest();
                X509Certificate2 cert = new X509Certificate2(response.Certificate);
                X509Certificate2 serializedCert = new X509Certificate2(response.SerializedCertificate);

                try
                {
                    // Verify that the certs are equivalent
                    CertHelper.CompareCerts(cert, serializedCert);
                    // Then verify the certificate completely
                    CertHelper.VerifyCert(cert, certState);
                }
                catch (UnexpectedTestResultException e)
                {
                    Global.RO.Warn("Cert verification failed: " + e.Message);
                }
            }
            finally
            {
                ReturnCertState(certState);
            }
        }

        [StressTest]
        public void BadKey()
        {
            //TODO: smarter fuzzing

            CertState state = CertState.CreateOscar(false, false);
            ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextBytes(state.PublicKey);

            state.UserPuid = bulkHelper.GetNextBulkUserPuid();
            MachineEditor mach = bulkHelper.GetNextBulkMachine();
            state.MachineId = mach.Id;

            try
            {
                state.DoRequest();
                throw new UnexpectedTestResultException("CreateCertificate Request with invalid key succeeded.");
            }
            catch (XErrException xcce)
            {
                if (xcce.XErr != HResult.XONLINE_E_INVALID_REQUEST)
                {
                    throw;
                }
            }
        }

        [StressTest]
        public void BadAppId()
        {
            //TODO: smarter and better fuzzing

            CertState state = CertState.CreateOscar(false, false);
            state.AppId = ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomNameString(ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next() % 64 + 1);

            state.UserPuid = bulkHelper.GetNextBulkUserPuid();
            MachineEditor mach = bulkHelper.GetNextBulkMachine();
            state.MachineId = mach.Id;

            try
            {
                state.DoRequest();
                throw new UnexpectedTestResultException("CreateCertificate Request with invalid AppId succeded.");
            }
            catch (XErrException xcce)
            {
                if (xcce.XErr != HResult.XONLINE_E_INVALID_REQUEST)
                {
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\Oscar\Func.cs ===
using System;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.LiveService.FakeSG;
using System.Security.Cryptography.X509Certificates;
using xonline.common.protocol;

namespace SigTest.Oscar.Functional
{
    [TestGroup, Description("Verifies that the Oscar Certification Generation functionality is working")]
    [Owner("BenRan"), TestFrequency("Regression")]
    [AsyncGroup(5, 1), AsyncThreadCount(5), AsyncThreadDelay(500)]
    public class Oscar : TestNode
    {
        public override void PreRun()
        {
            //init IDCRL
            AuthClientBase.InitializePassportIDCRL();

            CertHelper.Initialize();

            base.OneTimeSetup();
        }

        [TestCase, TestCasePriority(1), Description("Request an Oscar cert and verify we get a response")]
        public void BVT()
        {
            CertState state = CertState.CreateOscar();
            CreateCertificateResponse response = state.DoRequest();
        }

        [TestCase, TestCasePriority(1), Description("Request an Oscar cert and do some simple validation on it")]
        public void SimpleVerify()
        {
            CertState state = CertState.CreateOscar();
            CreateCertificateResponse response = state.DoRequest();

            CertHelper.VerifyCertificates(state, response.Certificate, response.SerializedCertificate);
        }

        [TestCase, TestCasePriority(2), Description("Request an Oscar cert using a real valid billing user")]
        [Ignore("Making real billing users is a pain.  Also, I don't think this test adds any useful info")]
        public void SimpleRealBillingUser()
        {
            CertState state = CertState.CreateOscar(true, false);
            Global.RO.Debug("Making user...");
            ServerTestFramework.LiveService.UserAccount.XeUser billingUser=AuthContext.MakeNewBillingUser(false, true, true);
            state.UserPuid=billingUser.UserPuid;;

            Global.RO.Info("Making call...");
            CreateCertificateResponse response=state.DoRequest();

            CertHelper.VerifyCertificates(state, response.Certificate, response.SerializedCertificate);
        }

        [TestCase, TestCasePriority(2), Description("Request an Oscar cert using random data for the public key.")]
        public void BadKey()
        {
            CertState state = CertState.CreateOscar();
            for (int i=0; i<10; ++i) //throw 10 at it... be rough, rar!
            {
                ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextBytes(state.PublicKey);

                try
                {
                    state.DoRequest();
                    throw new UnexpectedTestResultException("Did not expect request to succeed.");
                }
                catch (XErrException xcce)
                {
                    if (xcce.XErr!=HResult.XONLINE_E_INVALID_REQUEST)
                    {
                        throw;
                    }
                }
            }
        }

        [TestCase, TestCasePriority(2), Description("Try a request on platforms that should not be calling this.")]
        //[CompoundCase("Xbox1", AuthContext.ClientTypes.Xbox, HResult.XONLINE_E_SERVER_ERROR)]
        [CompoundCase("PC", AuthContext.ClientTypes.Panorama, HResult.XONLINE_E_SERVER_ERROR)]
        public class UnsupportedPlatform: TestNode
        {
            public override void Run()
            {
                AuthContext.ClientTypes clientType = (AuthContext.ClientTypes)MyValues[0];
                uint ExpectedError = (uint)MyValues[1];

                CertState state = CertState.CreateOscar(false, true);

                XmacsClient xmacs = SignatureUtils.CreateClient(clientType);

                state.MachineId = xmacs.GetMachinePuid();
                try
                {
                    state.ConsoleId = xmacs.ConsoleId;
                }
                catch
                {
                    state.ConsoleId = String.Empty;
                }

                try
                {
                    state.DoRequest();

                    throw new UnexpectedTestResultException("CreateCertificate request with invalid platform succeeded");
                }
                catch (XErrException xcce)
                {
                    if (xcce.XErr != ExpectedError)
                    {
                        throw;
                    }
                }
            }
        }

        [TestCase, TestCasePriority(3), Description("Make a request with user puid set to 0.")]
        public void NoUser()
        {
            CertState state = CertState.CreateOscar(true, false);
            state.UserPuid = 0;

            try
            {
                state.DoRequest();
                throw new UnexpectedTestResultException("CreateCertificate request with no user succeeded");
            }
            catch (XErrException xcce)
            {
                if (xcce.XErr!=HResult.XONLINE_E_SERVER_ERROR)
                {
                    throw;
                }
            }
        }

        [TestCase, TestCasePriority(3), Description("Make a request with user puid set differently than SGInfo.")]
        public void UserDifferentThanSGInfo()
        {
            CertState state = CertState.CreateOscar();

            XRLCreateCertificate xrl=new XRLCreateCertificate();
            xrl.Request.PubKey=state.PublicKey;
            xrl.Request.appId=state.AppId;
            xrl.Request.userPuid=state.UserPuid;

            xrl.ManualSlotSetup=true;
            xrl.Slot.machinePuid = state.MachineId;
            xrl.Slot.userPuid0 = state.UserPuid - 1;
            xrl.Slot.AddService(XOService.Signature_Server);

            if (xrl.Execute(state.MachineId))
            {
                throw new UnexpectedTestResultException("Did not expect request to succeed.");
            }

            Global.RO.Debug("Got "+xrl.ErrorStatusMessage);
            ValueCheck.Test("Xerr", HResult.XONLINE_E_SERVER_ERROR, xrl.XErr);
        }

        //TODO: is this case valid?  the SG might already protect against this.
        [TestCase, TestCasePriority(3), Description("Make a request without signature service granted.")]
        public void NoSignatureService()
        {
            CertState state = CertState.CreateOscar();

            XRLCreateCertificate xrl=new XRLCreateCertificate();
            xrl.Request.PubKey=state.PublicKey;
            xrl.Request.appId=state.AppId;
            xrl.Request.userPuid=state.UserPuid;

            xrl.ManualSlotSetup=true;
            xrl.Slot.machinePuid = state.MachineId;
            xrl.Slot.userPuid0 = state.UserPuid;
            xrl.Slot.ClearServices();
            xrl.Slot.AddService(XOService.PresNotification);

            if (xrl.Execute(state.MachineId))
            {
                throw new UnexpectedTestResultException("Did not expect request to succeed.");
            }

            Global.RO.Debug("Got "+xrl.ErrorStatusMessage);
            ValueCheck.Test("Xerr", HResult.XONLINE_E_SERVER_ERROR, xrl.XErr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\TestXsigWeb\TestXsigWebMain.cs ===
using System;

namespace TestXsigWeb
{
    public class TestXsigWeb
    {

        public static void Main(string[] args)
        {
            if (args.Length != 1)
            {
                Console.WriteLine("Remember to pass in the 'offer number'.");
                return;
            }

            XSigWeb xsigweb = new XSigWeb();

            string[] miids = new string[1] {String.Format("{0}0000000-0000-0000-0000-{0}0000000000{0}", args[0])};
            string[] oids = new string[1] {String.Format("00000000-0000-0000-0000-{0}0000000000{0}", args[0])};

            try
            {
                MediaLicense[] licenses = xsigweb.AcquireMediaLicenses(miids, oids, 2600292642018180, "client_info");
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\Playready\CreatePlayReadyCertificate.cs ===
﻿using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.Utilities;
using xonline.common.protocol;

namespace Sigtest.Playready.Functional
{
    [TestGroup, Owner("BenRan"), Description("Verifies that the PlayReady Certification generation functionality is working")]
    [TestFrequency("Regression"), AsyncGroup(7, 1), AsyncThreadCount(5), AsyncThreadDelay(1000)]
    public class Playready : TestNode
    {
        [TestCase, TestCasePriority(1), Description("Create a PlayReady certificate and verifiy that the result that is returned in valid")]
        public void CreatePlayReadyCert_BVT()
        {
            //Initialize the CreatePlayreadyCertificate request.
            //Generate the public keys for this request
            XRLCreatePlayReadyCertificate xrl = new XRLCreatePlayReadyCertificate();
            xrl.Request.flags = 0;
            xrl.Request.publicSigningKey = RandomEx.GlobalRandGen.GenerateRandomBlob(CreatePlayReadyCertificateRequest.PUBLIC_SIGNING_KEY_LEN);
            xrl.Request.publicEncryptionKey = RandomEx.GlobalRandGen.GenerateRandomBlob(CreatePlayReadyCertificateRequest.PUBLIC_ENCRYPTION_KEY_LEN);

            //Execute the request to the service
            if (!xrl.Execute())
            {
                throw new UnexpectedTestResultException("PlayReady certificate generation failed: " + xrl.GetDumpString());
            }

            Global.RO.Success("PlayReady certificate generation succeeded as expected.");
        }

        [CompoundCase("PC_MachinePuid",     0xfb00000000001234)]
        [CompoundCase("Xbox_MachinePuid",   0x0009000000001234)]
        [CompoundCase("DotCom_MachinePuid", 0xffed000000001234)]
        [TestCase, TestCasePriority(2), Description("Create a PlayReady certificate and verifiy that the result that is returned in valid")]
        public void CreatePlayReadyCert(TestNode me)
        {
            //Initialize the CreatePlayreadyCertificate request.
            //Generate the public keys for this request
            XRLCreatePlayReadyCertificate xrl = new XRLCreatePlayReadyCertificate();
            xrl.Request.flags = 0;
            xrl.Request.publicSigningKey = RandomEx.GlobalRandGen.GenerateRandomBlob(CreatePlayReadyCertificateRequest.PUBLIC_SIGNING_KEY_LEN);
            xrl.Request.publicEncryptionKey = RandomEx.GlobalRandGen.GenerateRandomBlob(CreatePlayReadyCertificateRequest.PUBLIC_ENCRYPTION_KEY_LEN);

            UInt64 machinePuid = Convert.ToUInt64(me.MyValues[0]);
            //Execute the request to the service
            if (xrl.Execute(machinePuid))
            {
                throw new UnexpectedTestResultException("PlayReady certificate generation succeeded with invalid MachineID.");
            }

            if (xrl.XErr != 0x8015B014)
            {
                throw new UnexpectedTestResultException("PlayReady certificate generation failed with unexpected error: " + xrl.GetDumpString());
            }

            Global.RO.Success("PlayReady certificate generation failed as expected: " + xrl.GetDumpString());
        }

        [TestCase, TestCasePriority(2), Description("Create a PlayReady certificate, verify its device certificate chain")]
        public void VerifyPlayreadyCertificateChain()
        {
            //Initialize the CreatePlayreadyCertificate request.
            //Generate the public keys for this request
            XRLCreatePlayReadyCertificate xrl = new XRLCreatePlayReadyCertificate();
            xrl.Request.flags = 0;
            xrl.Request.publicSigningKey = RandomEx.GlobalRandGen.GenerateRandomBlob(CreatePlayReadyCertificateRequest.PUBLIC_SIGNING_KEY_LEN);
            xrl.Request.publicEncryptionKey = RandomEx.GlobalRandGen.GenerateRandomBlob(CreatePlayReadyCertificateRequest.PUBLIC_ENCRYPTION_KEY_LEN);

            //Execute the request to the service
            if (!xrl.Execute())
            {
                throw new UnexpectedTestResultException("PlayReady certificate generation failed: " + xrl.GetDumpString());
            }

            //Get the cert blob from the response.
            byte[] theCert = GetCertBlockFromCertResponse(xrl.Response);

            Console.Write("Certificate length [" + theCert.Length + "].");

            //Verify the certificate chain from the response
            uint hr = VerifyPlayreadyDeviceCertDll.VerifyDeviceCertificateChain(theCert);

            if (hr != 0)
            {
                throw new UnexpectedTestResultException(String.Format("Returned 0x{0:X8}", hr));
            }
        }

        [TestCase, TestCasePriority(2), Description("Create random PR certificate block, verify device cert chain verification fails.")]
        public void VerifyCorruptPRCertificateChainFails()
        {
            byte[] theCert = RandomEx.GlobalRandGen.GenerateRandomBlob(10000);

            uint hr = VerifyPlayreadyDeviceCertDll.VerifyDeviceCertificateChain(theCert);

            if (hr == 0)
            {
                throw new UnexpectedTestResultException(String.Format("Returned 0x{0:X8}", hr));
            }
        }

        /// <summary>
        /// The Playready certificate is long enough that the response from the
        /// server may break it into arrays each 3k in size.
        /// 
        /// This function gets all the blocks from the response, and concatenates
        /// them together to form an array holding the whole certificate blob.
        /// </summary>
        /// <param name="response">The Playready response from the server.</param>
        /// <returns>A byte array holding the whole certificate blob from the response.</returns>
        private byte[] GetCertBlockFromCertResponse(CreatePlayReadyCertificateResponse response)
        {
            ushort totalBlockLength = 0;

            int numBlocks = response.certBlockCount;
            Console.WriteLine("Number of blocks in this response  [" + numBlocks + "]");

            //Get the total length of all the blocks
            for (int i = 0; i < numBlocks; i++)
            {
                totalBlockLength += response.certBlocks[i].blockLength;
            }

            //Create a byte[] of size totalBlockLength
            byte[] fullCertBlock = new byte[totalBlockLength];

            //The offset to which to copy the current block to.
            //This is to ensure the next block is concatenated to the
            //right position.
            int currDestOffset = 0;

            //Fill up the full cert block with the individual blocks from the response
            for (int j = 0; j < numBlocks; j++)
            {
                Buffer.BlockCopy(response.certBlocks[j].block,
                                 0,
                                 fullCertBlock,
                                 currDestOffset,
                                 response.certBlocks[j].blockLength);

                currDestOffset += response.certBlocks[j].blockLength;
            }

            return fullCertBlock;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\Playready\PlayreadyDllWrapper.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using System.Runtime.InteropServices;

using xonline.common.config;
using xonline.common.crypto;
using xonline.common.service;
using xonline.common.utilities;
using xonline.common.utilities2;

namespace Sigtest.Playready.Functional
{
    /// <summary>
    /// This class is a C# wrapper around the Playready verify functions 
    /// specifically in PlayReadyDeviceCertDll.cpp
    /// </summary>
    public static class VerifyPlayreadyDeviceCertDll
    {        
        [DllImport("PlayReadyDeviceCert.dll")]
        private static extern UInt32 VerifyDeviceCertChain(
            byte[] pabDeviceCertificate,
            uint cbDeviceCertificate);

        [DllImport("PlayReadyDeviceCert.dll")]
        private static extern bool ChkDrmSucceeded(
            HResult hr);

        /// <summary>
        /// This is a wrapper function around the VerifyDeviceCertChain
        /// native function in PlayReadyDeviceCertDll.cpp
        /// 
        /// This function verified a Playready certificate's certificate
        /// chain.
        /// </summary>
        /// <param name="pabDeviceCertificate">The blob containing the Playready certificate.</param>
        /// <returns>An Hresult value indicating success or failure.</returns>
        public static HResult VerifyDeviceCertificateChain(
            byte[] pabDeviceCertificate)
        {
            return VerifyDeviceCertChain(pabDeviceCertificate, (uint)pabDeviceCertificate.Length);
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\XSig\CheckRevocation.cs ===
using System;
using System.Security.Cryptography;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.config;

namespace SigTest.XSig.Functional
{
    //[TestGroup]
    public partial class XSig : TestNode
    {
        [TestGroup, Owner("BenRan"), TestFrequency("Regression")]
        public class CheckRevocation : TestNode
        {
            [TestCase, Description("Send 1 tuple/request with nothing banned")]
            [TestCasePriority(1)]
            public class BVT : TestNode
            {
                public override void Run()
                {
                    Utils.ReloadBlacklist();

                    XRLCheckRevocation req = new XRLCheckRevocation(1);

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.S_OK }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 1 tuple/request with the maximum title id and version")]
            [TestCasePriority(2), AsyncGroup(1)]
            public class Max_Title_ID_and_Version : TestNode
            {
                public override void Run()
                {
                    XRLCheckRevocation req = new XRLCheckRevocation(1);

                    req.Request.Tuples[0].TitleId = 0xffffffff;
                    req.Request.Tuples[0].TitleVersion = 0xffffffff;

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.S_OK }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }
            
            [TestCase, Description("Send 1 tuple/request with minimum title id and version")]
            [TestCasePriority(2), AsyncGroup(1)]
            class Min_Title_ID_and_Version : TestNode
            {
                public override void Run()
                {
                    XRLCheckRevocation req = new XRLCheckRevocation(1);

                    req.Request.Tuples[0].TitleId = 1;
                    req.Request.Tuples[0].TitleVersion = 1;

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.S_OK }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 1 tuple/request with MachineID")]
            [TestCasePriority(1), AsyncGroup(1)]
            class Machine_PUID : TestNode
            {
                public override void Run()
                {
                    XRLCheckRevocation req = new XRLCheckRevocation(1);

                    req.Request.Tuples[0].ConsolePuid = (ulong)new Random().Next();

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.S_OK }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 1 tuple/request with maximum Machine PUID")]
            [TestCasePriority(2), AsyncGroup(1)]
            class Max_Machine_PUID : TestNode
            {
                public override void Run()
                {
                    XRLCheckRevocation req = new XRLCheckRevocation(1);

                    req.Request.Tuples[0].ConsolePuid = 0xffffffffffffffff;

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.S_OK }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 1 tuple/request with minimum Machine PUID")]
            [TestCasePriority(2), AsyncGroup(1)]
            class Min_Machine_PUID : TestNode
            {
                public override void Run()
                {
                    XRLCheckRevocation req = new XRLCheckRevocation(1);

                    req.Request.Tuples[0].ConsolePuid = 1;

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.S_OK }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 1 tuple/request with User PUID")]
            [TestCasePriority(1), AsyncGroup(1)]
            class User_PUID : TestNode
            {
                public override void Run()
                {
                    XRLCheckRevocation req = new XRLCheckRevocation(1);

                    req.Request.Tuples[0].UserPuid[0] = (ulong)new Random().Next(); ;

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.S_OK }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 1 tuple/request with maximum User PUID")]
            [TestCasePriority(2), AsyncGroup(1)]
            class Max_User_PUID : TestNode
            {
                public override void Run()
                {
                    XRLCheckRevocation req = new XRLCheckRevocation(1);

                    req.Request.Tuples[0].UserPuid[0] = 0xffffffffffffffff;

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.S_OK }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 1 tuple/request with minimum User PUID")]
            [TestCasePriority(2), AsyncGroup(1)]
            class Min_User_PUID : TestNode
            {
                public override void Run()
                {
                    XRLCheckRevocation req = new XRLCheckRevocation(1);

                    req.Request.Tuples[0].UserPuid[0] = 0x1;

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.S_OK }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 1 tuple/request with maximum Console ID")]
            [TestCasePriority(2), AsyncGroup(1)]
            class Max_Console_ID : TestNode
            {
                public override void Run()
                {
                    XRLCheckRevocation req = new XRLCheckRevocation(1);

                    req.Request.Tuples[0].ConsoleId = new byte[5] { 0xff, 0xff, 0xff, 0xff, 0xff };

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.S_OK }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 1 tuple/request with minimum Console ID")]
            [TestCasePriority(2), AsyncGroup(1)]
            class Min_ConsoleId : TestNode
            {
                public override void Run()
                {
                    XRLCheckRevocation req = new XRLCheckRevocation(1);

                    req.Request.Tuples[0].ConsoleId = new byte[5] { 0x01, 0x00, 0x00, 0x00, 0x00 };

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.S_OK }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 1 tuple/request with banned titleID and titleVersion")]
            [TestCasePriority(2)]
            class Banned_Title_ID_And_Title_Version : TestNode
            {
                public override void Run()
                {
                    uint bannedTitle = (uint)new Random().Next();
                    uint bannedTitleVersion = (uint)new Random().Next();

                    // Blacklist the title.
                    NpdbUtility npdb = new NpdbUtility();
                    npdb.ConnectToServer();
                    npdb.BlacklistTitle(bannedTitle, bannedTitleVersion, true);
                    npdb.Close();
                    Utils.ReloadBlacklist();

                    XRLCheckRevocation req = new XRLCheckRevocation(1);
                    req.Request.Tuples[0].TitleId = bannedTitle;
                    req.Request.Tuples[0].TitleVersion = bannedTitleVersion;

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.XONLINE_E_SIGNATURE_BANNED_TITLE }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 1 tuple/request with unbanned titleID and titleVersion")]
            [TestCasePriority(2)]
            class Unbanned_Title_ID_And_Title_Version : TestNode
            {
                public override void Run()
                {
                    uint bannedTitle = (uint)new Random().Next();
                    uint bannedTitleVersion = (uint)new Random().Next();

                    // Unblacklist the title.
                    NpdbUtility npdb = new NpdbUtility();
                    npdb.ConnectToServer();
                    npdb.BlacklistTitle(bannedTitle, bannedTitleVersion, false);
                    npdb.Close();
                    Utils.ReloadBlacklist();

                    XRLCheckRevocation req = new XRLCheckRevocation(1);
                    req.Request.Tuples[0].TitleId = bannedTitle;
                    req.Request.Tuples[0].TitleVersion = bannedTitleVersion;

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.S_OK }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 1 tuple/request with banned titleID only")]
            [TestCasePriority(2)]
            class Banned_Title_ID_Only : TestNode
            {
                public override void Run()
                {
                    uint bannedTitle = (uint)new Random().Next();
                    uint bannedTitleVersion = 2;

                    NpdbUtility npdb = new NpdbUtility();
                    npdb.ConnectToServer();
                    npdb.BlacklistTitle(bannedTitle, bannedTitleVersion, true);
                    npdb.Close();
                    Utils.ReloadBlacklist();

                    XRLCheckRevocation req = new XRLCheckRevocation(1);
                    req.Request.Tuples[0].TitleId = bannedTitle;
                    req.Request.Tuples[0].TitleVersion = 1;

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.S_OK }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 1 tuple/request with banned ConsoleID")]
            [TestCasePriority(2)]
            class Banned_Console_ID : TestNode
            {
                public override void Run()
                {
                    byte[] bannedConsoleID = { 0xaa, 0xbb, 0xcc, 0xdd, 0xee };

                    NpdbUtility npdb = new NpdbUtility();
                    npdb.ConnectToServer();
                    npdb.BlacklistMachine(0xaabbccddee, true);
                    npdb.Close();
                    Utils.ReloadBlacklist();

                    XRLCheckRevocation req = new XRLCheckRevocation(1);
                    req.Request.Tuples[0].ConsoleId = bannedConsoleID;

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.XONLINE_E_SIGNATURE_BANNED_XBOX }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 1 tuple/request with unbanned ConsoleID")]
            [TestCasePriority(2)]
            class UnBanned_Console_ID : TestNode
            {
                public override void Run()
                {
                    byte[] unbannedConsoleID = { 0xaa, 0xbb, 0xcc, 0xdd, 0xee };

                    NpdbUtility npdb = new NpdbUtility();
                    npdb.ConnectToServer();
                    npdb.BlacklistMachine(0xaabbccddee, false);
                    npdb.Close();
                    Utils.ReloadBlacklist();

                    XRLCheckRevocation req = new XRLCheckRevocation(1);
                    req.Request.Tuples[0].ConsoleId = unbannedConsoleID;

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.S_OK }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 1 tuple/request with banned machine PUID")]
            [TestCasePriority(2)]
            class Banned_Machine_PUID : TestNode
            {
                public override void Run()
                {
                    ulong bannedMachinePUID = (ulong)(new Random().Next());

                    NpdbUtility npdb = new NpdbUtility();
                    npdb.ConnectToServer();
                    npdb.BlacklistMachine(bannedMachinePUID, true);
                    npdb.Close();
                    Utils.ReloadBlacklist();

                    XRLCheckRevocation req = new XRLCheckRevocation(1);
                    req.Request.Tuples[0].ConsolePuid = bannedMachinePUID;

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.XONLINE_E_SIGNATURE_BANNED_XBOX }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 1 tuple/request with unbanned machine PUID")]
            [TestCasePriority(2)]
            class Unbanned_Machine_PUID : TestNode
            {
                public override void Run()
                {
                    ulong bannedMachinePUID = (ulong)(new Random().Next());

                    NpdbUtility npdb = new NpdbUtility();
                    npdb.ConnectToServer();
                    npdb.BlacklistMachine(bannedMachinePUID, false);
                    npdb.Close();
                    Utils.ReloadBlacklist();

                    XRLCheckRevocation req = new XRLCheckRevocation(1);
                    req.Request.Tuples[0].ConsolePuid = bannedMachinePUID;

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.S_OK }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 1 tuple/request with banned digest")]
            [TestCasePriority(2)]
            class Banned_Digest : TestNode
            {
                public override void Run()
                {
                    byte[] bannedData = Encoding.ASCII.GetBytes("This data has been blacklisted.");
                    byte[] bannedDigest = new SHA1Managed().ComputeHash(bannedData);

                    NpdbUtility npdb = new NpdbUtility();
                    npdb.ConnectToServer();
                    npdb.BlacklistDigest(bannedDigest, true);
                    npdb.Close();
                    Utils.ReloadBlacklist();

                    XRLCheckRevocation req = new XRLCheckRevocation(1);
                    req.Request.Tuples[0].Digest = bannedDigest;

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.XONLINE_E_SIGNATURE_BANNED_DIGEST }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 1 tuple/request with unbanned digest")]
            [TestCasePriority(2)]
            class Unbanned_Digest : TestNode
            {
                public override void Run()
                {
                    byte[] bannedData = Encoding.ASCII.GetBytes("This data has been unblacklisted.");
                    byte[] bannedDigest = new SHA1Managed().ComputeHash(bannedData);

                    NpdbUtility npdb = new NpdbUtility();
                    npdb.ConnectToServer();
                    npdb.BlacklistDigest(bannedDigest, false);
                    npdb.Close();
                    Utils.ReloadBlacklist();

                    XRLCheckRevocation req = new XRLCheckRevocation(1);
                    req.Request.Tuples[0].Digest = bannedDigest;

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.S_OK }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 1 tuple/request with banned user PUID")]
            [TestCasePriority(2)]
            class Banned_User_PUID : TestNode
            {
                public override void Run()
                {
                    ulong bannedUserPUID = (ulong)(new Random().Next());
                    NpdbUtility npdb = new NpdbUtility();
                    npdb.ConnectToServer();
                    npdb.BlacklistUser(bannedUserPUID, true);
                    npdb.Close();
                    Utils.ReloadBlacklist();

                    XRLCheckRevocation req = new XRLCheckRevocation(1);
                    req.Request.Tuples[0].UserPuid[0] = bannedUserPUID;

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.XONLINE_E_SIGNATURE_BANNED_USER }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 1 tuple/request with unbanned user PUID")]
            [TestCasePriority(2)]
            class Unbanned_User_PUID : TestNode
            {
                public override void Run()
                {
                    ulong bannedUserPUID = (ulong)(new Random().Next());
                    NpdbUtility npdb = new NpdbUtility();
                    npdb.ConnectToServer();
                    npdb.BlacklistUser(bannedUserPUID, false);
                    npdb.Close();
                    Utils.ReloadBlacklist();

                    XRLCheckRevocation req = new XRLCheckRevocation(1);
                    req.Request.Tuples[0].UserPuid[0] = bannedUserPUID;

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.S_OK }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 1 tuple/request with 4 users all banned")]
            [TestCasePriority(2)]
            class Banned_Users_Multiple : TestNode
            {
                public override void Run()
                {
                    ulong[] bannedUserPUIDs = new ulong[4];

                    NpdbUtility npdb = new NpdbUtility();
                    npdb.ConnectToServer();
                    for (int i = 0; i < 4; i++)
                    {
                        bannedUserPUIDs[i] = (ulong)(new Random().Next());
                        npdb.BlacklistUser(bannedUserPUIDs[i], true);
                    }
                    npdb.Close();
                    Utils.ReloadBlacklist();

                    XRLCheckRevocation req = new XRLCheckRevocation(1);
                    for (int i = 0; i < 4; i++)
                    {
                        req.Request.Tuples[0].UserPuid[i] = bannedUserPUIDs[i];
                    }

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.XONLINE_E_SIGNATURE_BANNED_USER }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 1 tuple/request with 4 users all unbanned")]
            [TestCasePriority(2)]
            class Unbanned_Users_Multiple : TestNode
            {
                public override void Run()
                {
                    ulong[] bannedUserPUIDs = new ulong[4];

                    NpdbUtility npdb = new NpdbUtility();
                    npdb.ConnectToServer();
                    for (int i = 0; i < 4; i++)
                    {
                        bannedUserPUIDs[i] = (ulong)(new Random().Next());
                        npdb.BlacklistUser(bannedUserPUIDs[i], false);
                    }
                    npdb.Close();
                    Utils.ReloadBlacklist();

                    XRLCheckRevocation req = new XRLCheckRevocation(1);
                    for (int i = 0; i < 4; i++)
                    {
                        req.Request.Tuples[0].UserPuid[i] = bannedUserPUIDs[i];
                    }

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.S_OK }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 1 tuple/request with banned user PUID and digest")]
            [TestCasePriority(2)]
            class Banned_User_and_Digest : TestNode
            {
                public override void Run()
                {
                    ulong bannedUserPUID = (ulong)(new Random().Next());
                    byte[] bannedData = Encoding.ASCII.GetBytes("This data has been blacklisted.");
                    byte[] bannedDigest = new SHA1Managed().ComputeHash(bannedData);

                    NpdbUtility npdb = new NpdbUtility();
                    npdb.ConnectToServer();
                    npdb.BlacklistUser(bannedUserPUID, true);
                    npdb.BlacklistDigest(bannedDigest, true);
                    npdb.Close();
                    Utils.ReloadBlacklist();

                    XRLCheckRevocation req = new XRLCheckRevocation(1);
                    req.Request.Tuples[0].UserPuid[0] = bannedUserPUID;
                    req.Request.Tuples[0].Digest = bannedDigest;

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[1] { HResult.XONLINE_E_SIGNATURE_BANNED_DIGEST }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 2 tuples/request, first one with banned title, second with no banned ids.")]
            [TestCasePriority(2)]
            class Multiple_Tuples_Mixed_First_Banned : TestNode
            {
                public override void Run()
                {
                    uint bannedTitle = (uint)new Random().Next();
                    NpdbUtility npdb = new NpdbUtility();
                    npdb.ConnectToServer();
                    npdb.BlacklistTitle(bannedTitle, 1, true);
                    npdb.Close();
                    Utils.ReloadBlacklist();

                    XRLCheckRevocation req = new XRLCheckRevocation(2);
                    req.Request.Tuples[0].TitleId = bannedTitle;
                    req.Request.Tuples[0].TitleVersion = 1;

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.XONLINE_E_SIGNATURE_BANNED_TITLE, HResult.S_OK }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("send 2 tuples/request, 1st one with no banned ids, 2nd with banned title.")]
            [TestCasePriority(2)]
            class Multiple_Tuples_Mixed_Second_Banned : TestNode
            {
                public override void Run()
                {
                    uint bannedTitle = (uint)new Random().Next();
                    NpdbUtility npdb = new NpdbUtility();
                    npdb.ConnectToServer();
                    npdb.BlacklistTitle(bannedTitle, 1, true);
                    npdb.Close();
                    Utils.ReloadBlacklist();

                    XRLCheckRevocation req = new XRLCheckRevocation(2);
                    req.Request.Tuples[1].TitleId = bannedTitle;
                    req.Request.Tuples[1].TitleVersion = 1;

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.S_OK, HResult.XONLINE_E_SIGNATURE_BANNED_TITLE }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send max allowed tuples in one request with last half with banned Machine PUID.")]
            [TestCasePriority(2)]
            class Maximum_Tuples_Half_Banned : TestNode
            {
                public override void Run()
                {
                    XRLCheckRevocation req = new XRLCheckRevocation(XOn.XONLINE_SIG_MAX_CONTENT_TUPLES);
                    uint[] Hrs = new uint[XOn.XONLINE_SIG_MAX_CONTENT_TUPLES];

                    NpdbUtility npdb = new NpdbUtility();
                    npdb.ConnectToServer();

                    // 
                    // Blacklist half of the machines
                    //
                    uint numBannedMachines = (uint)XOn.XONLINE_SIG_MAX_CONTENT_TUPLES / 2;
                    ulong[] bannedMachines = new ulong[numBannedMachines];
                    for (uint i = 0; i < numBannedMachines; i++)
                    {
                        bannedMachines[i] = (ulong)(new Random().Next());
                        npdb.BlacklistMachine(bannedMachines[i], true);
                        req.Request.Tuples[i].ConsolePuid = bannedMachines[i];
                        Hrs[i] = HResult.XONLINE_E_SIGNATURE_BANNED_XBOX;
                    }
                    for (uint i = numBannedMachines; i < XOn.XONLINE_SIG_MAX_CONTENT_TUPLES; i++)
                    {
                        Hrs[i] = HResult.S_OK;
                    }
                    npdb.Close();
                    Utils.ReloadBlacklist();

                    if (!Utils.CheckRevocationSendAndVerify(req, Hrs))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send max allowed tuples in one request with last half all banned Machine PUID.")]
            [TestCasePriority(2)]
            class Maximum_Tuples_All_Banned : TestNode
            {
                public override void Run()
                {
                    XRLCheckRevocation req = new XRLCheckRevocation(XOn.XONLINE_SIG_MAX_CONTENT_TUPLES);
                    uint[] Hrs = new uint[XOn.XONLINE_SIG_MAX_CONTENT_TUPLES];

                    NpdbUtility npdb = new NpdbUtility();
                    npdb.ConnectToServer();

                    // 
                    // Blacklist half of the machines
                    //
                    uint numBannedMachines = (uint)XOn.XONLINE_SIG_MAX_CONTENT_TUPLES;
                    ulong[] bannedMachines = new ulong[numBannedMachines];
                    for (uint i = 0; i < numBannedMachines; i++)
                    {
                        bannedMachines[i] = (ulong)(new Random().Next());
                        npdb.BlacklistMachine(bannedMachines[i], true);
                        req.Request.Tuples[i].ConsolePuid = bannedMachines[i];
                        Hrs[i] = HResult.XONLINE_E_SIGNATURE_BANNED_XBOX;
                    }
                    npdb.Close();
                    Utils.ReloadBlacklist();

                    if (!Utils.CheckRevocationSendAndVerify(req, Hrs))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send max+1 tuples in one request")]
            [TestCasePriority(3)]
            class Overflow_Tuples : TestNode
            {
                public override void Run()
                {
                    XRLCheckRevocation req = new XRLCheckRevocation(XOn.XONLINE_SIG_MAX_CONTENT_TUPLES + 1);
                    if (!Utils.CheckRevocationTestNegative(req, HResult.E_INVALIDARG))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("X-Delay header checking for GetSigningKey")]
            [TestCasePriority(3)]
            class GetSigningKey_Throttle : TestNode
            {
                public override void PreRun()
                {
                    Global.XEnv.ExecuteXmgmtCommand(Interface.xsig, "e :xsig SetXDelay 0 CheckRevocation 3000");
                }

                public override void Run()
                {
                    XRLCheckRevocation req = new XRLCheckRevocation(1);

                    if (!Utils.CheckRevocationSendAndVerify(req, new uint[] { HResult.S_OK }))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }

                    if (req.XDelay != 3000)
                    {
                        throw new UnexpectedTestResultException("XDelay header was not set to the expected value.");
                    }
                }

                public override void PostRun()
                {
                    Global.XEnv.ExecuteXmgmtCommand(Interface.xsig, "exec :xsig ReloadThrottleConfig");
                }
            }

            [TestCase, Description("Send 19 bytes of digest in a request")]
            [TestCasePriority(2), AsyncGroup(1)]
            class Wrong_Digest_Size : TestNode
            {
                public override void Run()
                {
                    XRLCheckRevocation req = new XRLCheckRevocation(1);
                    req.Request.Tuples[0].SetManualArraySize(true);
                    req.Request.Tuples[0].Digest = new byte[19];
                    new Random().NextBytes(req.Request.Tuples[0].Digest);

                    if (!Utils.CheckRevocationTestNegative(req, HResult.XONLINE_E_END_OF_STREAM))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send 4 bytes of console ID in a request")]
            [TestCasePriority(2), AsyncGroup(1)]
            class Wrong_Console_ID_Size : TestNode
            {
                public override void Run()
                {
                    XRLCheckRevocation req = new XRLCheckRevocation(1);
                    req.Request.Tuples[0].SetManualArraySize(true);
                    req.Request.Tuples[0].ConsoleId = new byte[4];

                    if (!Utils.CheckRevocationTestNegative(req, HResult.XONLINE_E_END_OF_STREAM))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            [TestCase, Description("Send an array of 3 users, but only one is non-zero")]
            [TestCasePriority(2), AsyncGroup(1)]
            class User_Array_Manual_Define : TestNode
            {
                public override void Run()
                {
                    XRLCheckRevocation req = new XRLCheckRevocation(1);
                    req.Request.Tuples[0].SetManualArraySize(true);
                    req.Request.Tuples[0].UserPuid = new ulong[3] { 0x123, 0, 0 };

                    if (!Utils.CheckRevocationTestNegative(req, HResult.XONLINE_E_END_OF_STREAM))
                    {
                        throw new UnexpectedTestResultException("CheckRevocationSendAndVerify failed.");
                    }
                }
            }

            // This should be caught by xrlscan:
            // in npdb_config_component_info.sql: max length for xrlcheckrevocation is 50000
            // each tuple is 45 byte long; then maximum tuple allowed is (50000-4)/45=1111
            [TestCase, Description("Send 1112 tuples in a request")]
            [TestCasePriority(3), AsyncGroup(1)]
            class Overflow_XRL_Request : TestNode
            {
                public override void Run()
                {
                    XRLCheckRevocation req = new XRLCheckRevocation(1112);
                    if (req.Execute() && (req.httpStatus != System.Net.HttpStatusCode.NotFound))
                    {
                        throw new UnexpectedTestResultException("CheckRevocation request did not fail as expected.");
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\TestXsigWeb\XSigWeb.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1433
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml.Serialization;

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 


/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="XSigWebSoap", Namespace="urn:schemas-xbox-com:xsigweb-data")]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(WireData))]
public partial class XSigWeb : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    private System.Threading.SendOrPostCallback TestConnectionOperationCompleted;
    
    private System.Threading.SendOrPostCallback AcquireMediaLicensesOperationCompleted;
    
    private System.Threading.SendOrPostCallback AcknowledgeLicensesDeliveryOperationCompleted;
    
    private System.Threading.SendOrPostCallback CheckLicensesAvailabilityOperationCompleted;
    
    private System.Threading.SendOrPostCallback BlacklistDigestOperationCompleted;
    
    /// <remarks/>
    public XSigWeb() {
        this.Url = "http://tobiasb-xblobc:10120/xsig/xsigweb.asmx";
    }
    
    /// <remarks/>
    public event TestConnectionCompletedEventHandler TestConnectionCompleted;
    
    /// <remarks/>
    public event AcquireMediaLicensesCompletedEventHandler AcquireMediaLicensesCompleted;
    
    /// <remarks/>
    public event AcknowledgeLicensesDeliveryCompletedEventHandler AcknowledgeLicensesDeliveryCompleted;
    
    /// <remarks/>
    public event CheckLicensesAvailabilityCompletedEventHandler CheckLicensesAvailabilityCompleted;
    
    /// <remarks/>
    public event BlacklistDigestCompletedEventHandler BlacklistDigestCompleted;
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:xsigweb-data/TestConnection", RequestNamespace="urn:schemas-xbox-com:xsigweb-data", ResponseNamespace="urn:schemas-xbox-com:xsigweb-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public string TestConnection(string inputMessage) {
        object[] results = this.Invoke("TestConnection", new object[] {
                    inputMessage});
        return ((string)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginTestConnection(string inputMessage, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("TestConnection", new object[] {
                    inputMessage}, callback, asyncState);
    }
    
    /// <remarks/>
    public string EndTestConnection(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((string)(results[0]));
    }
    
    /// <remarks/>
    public void TestConnectionAsync(string inputMessage) {
        this.TestConnectionAsync(inputMessage, null);
    }
    
    /// <remarks/>
    public void TestConnectionAsync(string inputMessage, object userState) {
        if ((this.TestConnectionOperationCompleted == null)) {
            this.TestConnectionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTestConnectionOperationCompleted);
        }
        this.InvokeAsync("TestConnection", new object[] {
                    inputMessage}, this.TestConnectionOperationCompleted, userState);
    }
    
    private void OnTestConnectionOperationCompleted(object arg) {
        if ((this.TestConnectionCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.TestConnectionCompleted(this, new TestConnectionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:xsigweb-data/AcquireMediaLicenses", RequestNamespace="urn:schemas-xbox-com:xsigweb-data", ResponseNamespace="urn:schemas-xbox-com:xsigweb-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public MediaLicense[] AcquireMediaLicenses(string[] miids, string[] oids, ulong xuid, string clientInfo) {
        object[] results = this.Invoke("AcquireMediaLicenses", new object[] {
                    miids,
                    oids,
                    xuid,
                    clientInfo});
        return ((MediaLicense[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAcquireMediaLicenses(string[] miids, string[] oids, ulong xuid, string clientInfo, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AcquireMediaLicenses", new object[] {
                    miids,
                    oids,
                    xuid,
                    clientInfo}, callback, asyncState);
    }
    
    /// <remarks/>
    public MediaLicense[] EndAcquireMediaLicenses(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((MediaLicense[])(results[0]));
    }
    
    /// <remarks/>
    public void AcquireMediaLicensesAsync(string[] miids, string[] oids, ulong xuid, string clientInfo) {
        this.AcquireMediaLicensesAsync(miids, oids, xuid, clientInfo, null);
    }
    
    /// <remarks/>
    public void AcquireMediaLicensesAsync(string[] miids, string[] oids, ulong xuid, string clientInfo, object userState) {
        if ((this.AcquireMediaLicensesOperationCompleted == null)) {
            this.AcquireMediaLicensesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAcquireMediaLicensesOperationCompleted);
        }
        this.InvokeAsync("AcquireMediaLicenses", new object[] {
                    miids,
                    oids,
                    xuid,
                    clientInfo}, this.AcquireMediaLicensesOperationCompleted, userState);
    }
    
    private void OnAcquireMediaLicensesOperationCompleted(object arg) {
        if ((this.AcquireMediaLicensesCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.AcquireMediaLicensesCompleted(this, new AcquireMediaLicensesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:xsigweb-data/AcknowledgeLicensesDelivery", RequestNamespace="urn:schemas-xbox-com:xsigweb-data", ResponseNamespace="urn:schemas-xbox-com:xsigweb-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public Acknowledgement[] AcknowledgeLicensesDelivery(string[] miids, string[] oids, ulong xuid) {
        object[] results = this.Invoke("AcknowledgeLicensesDelivery", new object[] {
                    miids,
                    oids,
                    xuid});
        return ((Acknowledgement[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAcknowledgeLicensesDelivery(string[] miids, string[] oids, ulong xuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AcknowledgeLicensesDelivery", new object[] {
                    miids,
                    oids,
                    xuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public Acknowledgement[] EndAcknowledgeLicensesDelivery(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((Acknowledgement[])(results[0]));
    }
    
    /// <remarks/>
    public void AcknowledgeLicensesDeliveryAsync(string[] miids, string[] oids, ulong xuid) {
        this.AcknowledgeLicensesDeliveryAsync(miids, oids, xuid, null);
    }
    
    /// <remarks/>
    public void AcknowledgeLicensesDeliveryAsync(string[] miids, string[] oids, ulong xuid, object userState) {
        if ((this.AcknowledgeLicensesDeliveryOperationCompleted == null)) {
            this.AcknowledgeLicensesDeliveryOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAcknowledgeLicensesDeliveryOperationCompleted);
        }
        this.InvokeAsync("AcknowledgeLicensesDelivery", new object[] {
                    miids,
                    oids,
                    xuid}, this.AcknowledgeLicensesDeliveryOperationCompleted, userState);
    }
    
    private void OnAcknowledgeLicensesDeliveryOperationCompleted(object arg) {
        if ((this.AcknowledgeLicensesDeliveryCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.AcknowledgeLicensesDeliveryCompleted(this, new AcknowledgeLicensesDeliveryCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:xsigweb-data/CheckLicensesAvailability", RequestNamespace="urn:schemas-xbox-com:xsigweb-data", ResponseNamespace="urn:schemas-xbox-com:xsigweb-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public Availability[] CheckLicensesAvailability(string[] miids, string[] oids, ulong xuid) {
        object[] results = this.Invoke("CheckLicensesAvailability", new object[] {
                    miids,
                    oids,
                    xuid});
        return ((Availability[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCheckLicensesAvailability(string[] miids, string[] oids, ulong xuid, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CheckLicensesAvailability", new object[] {
                    miids,
                    oids,
                    xuid}, callback, asyncState);
    }
    
    /// <remarks/>
    public Availability[] EndCheckLicensesAvailability(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((Availability[])(results[0]));
    }
    
    /// <remarks/>
    public void CheckLicensesAvailabilityAsync(string[] miids, string[] oids, ulong xuid) {
        this.CheckLicensesAvailabilityAsync(miids, oids, xuid, null);
    }
    
    /// <remarks/>
    public void CheckLicensesAvailabilityAsync(string[] miids, string[] oids, ulong xuid, object userState) {
        if ((this.CheckLicensesAvailabilityOperationCompleted == null)) {
            this.CheckLicensesAvailabilityOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCheckLicensesAvailabilityOperationCompleted);
        }
        this.InvokeAsync("CheckLicensesAvailability", new object[] {
                    miids,
                    oids,
                    xuid}, this.CheckLicensesAvailabilityOperationCompleted, userState);
    }
    
    private void OnCheckLicensesAvailabilityOperationCompleted(object arg) {
        if ((this.CheckLicensesAvailabilityCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.CheckLicensesAvailabilityCompleted(this, new CheckLicensesAvailabilityCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:xsigweb-data/BlacklistDigest", RequestNamespace="urn:schemas-xbox-com:xsigweb-data", ResponseNamespace="urn:schemas-xbox-com:xsigweb-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void BlacklistDigest([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] digest) {
        this.Invoke("BlacklistDigest", new object[] {
                    digest});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginBlacklistDigest(byte[] digest, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("BlacklistDigest", new object[] {
                    digest}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndBlacklistDigest(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    public void BlacklistDigestAsync(byte[] digest) {
        this.BlacklistDigestAsync(digest, null);
    }
    
    /// <remarks/>
    public void BlacklistDigestAsync(byte[] digest, object userState) {
        if ((this.BlacklistDigestOperationCompleted == null)) {
            this.BlacklistDigestOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBlacklistDigestOperationCompleted);
        }
        this.InvokeAsync("BlacklistDigest", new object[] {
                    digest}, this.BlacklistDigestOperationCompleted, userState);
    }
    
    private void OnBlacklistDigestOperationCompleted(object arg) {
        if ((this.BlacklistDigestCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.BlacklistDigestCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    public new void CancelAsync(object userState) {
        base.CancelAsync(userState);
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:xsigweb-data")]
public partial class MediaLicense : WireData {
    
    private MediaInstanceIdOfferIdPair idPairField;
    
    private ushort licenseTypeField;
    
    private byte[] licenseField;
    
    private uint hrField;
    
    /// <remarks/>
    public MediaInstanceIdOfferIdPair idPair {
        get {
            return this.idPairField;
        }
        set {
            this.idPairField = value;
        }
    }
    
    /// <remarks/>
    public ushort licenseType {
        get {
            return this.licenseTypeField;
        }
        set {
            this.licenseTypeField = value;
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
    public byte[] license {
        get {
            return this.licenseField;
        }
        set {
            this.licenseField = value;
        }
    }
    
    /// <remarks/>
    public uint hr {
        get {
            return this.hrField;
        }
        set {
            this.hrField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:xsigweb-data")]
public partial class MediaInstanceIdOfferIdPair : WireData {
    
    private System.Guid miidField;
    
    private System.Guid oidField;
    
    /// <remarks/>
    public System.Guid miid {
        get {
            return this.miidField;
        }
        set {
            this.miidField = value;
        }
    }
    
    /// <remarks/>
    public System.Guid oid {
        get {
            return this.oidField;
        }
        set {
            this.oidField = value;
        }
    }
}

/// <remarks/>
[System.Xml.Serialization.XmlIncludeAttribute(typeof(Acknowledgement))]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(MediaInstanceIdOfferIdPair))]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(MediaLicense))]
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:xsigweb-data")]
public partial class WireData {
    
    private uint schemaVersionField;
    
    /// <remarks/>
    public uint SchemaVersion {
        get {
            return this.schemaVersionField;
        }
        set {
            this.schemaVersionField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:xsigweb-data")]
public partial class Availability {
    
    private MediaInstanceIdOfferIdPair idPairField;
    
    private uint hrField;
    
    /// <remarks/>
    public MediaInstanceIdOfferIdPair idPair {
        get {
            return this.idPairField;
        }
        set {
            this.idPairField = value;
        }
    }
    
    /// <remarks/>
    public uint hr {
        get {
            return this.hrField;
        }
        set {
            this.hrField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.SerializableAttribute()]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:xsigweb-data")]
public partial class Acknowledgement : WireData {
    
    private MediaInstanceIdOfferIdPair idPairField;
    
    private uint hrField;
    
    /// <remarks/>
    public MediaInstanceIdOfferIdPair idPair {
        get {
            return this.idPairField;
        }
        set {
            this.idPairField = value;
        }
    }
    
    /// <remarks/>
    public uint hr {
        get {
            return this.hrField;
        }
        set {
            this.hrField = value;
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void TestConnectionCompletedEventHandler(object sender, TestConnectionCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class TestConnectionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal TestConnectionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public string Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((string)(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void AcquireMediaLicensesCompletedEventHandler(object sender, AcquireMediaLicensesCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class AcquireMediaLicensesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal AcquireMediaLicensesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public MediaLicense[] Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((MediaLicense[])(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void AcknowledgeLicensesDeliveryCompletedEventHandler(object sender, AcknowledgeLicensesDeliveryCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class AcknowledgeLicensesDeliveryCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal AcknowledgeLicensesDeliveryCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public Acknowledgement[] Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((Acknowledgement[])(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void CheckLicensesAvailabilityCompletedEventHandler(object sender, CheckLicensesAvailabilityCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class CheckLicensesAvailabilityCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal CheckLicensesAvailabilityCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public Availability[] Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((Availability[])(this.results[0]));
        }
    }
}

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void BlacklistDigestCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\XSig\SignOnBehalf.cs ===
using System;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.Utilities;
using xonline.common.protocol;

namespace SigTest.XSig.Functional
{
    //[TestGroup]
    public partial class XSig : TestNode
    {
        [TestGroup, Owner("BenRan"), TestFrequency("Regression")]
        public class SignOnBehalf : TestNode
        {
            public static void ExecutePositiveRequest(XRLXSigSignOnBehalf signOnBehalf)
            {
                ExecutePositiveRequest(signOnBehalf, true);
            }

            public static void ExecutePositiveRequest(XRLXSigSignOnBehalf signOnBehalf, Boolean verify)
            {
                if (!signOnBehalf.Execute())
                {
                    throw new UnexpectedTestResultException("XSigSignOnBehalfRequest failed: " + signOnBehalf.GetDumpString());
                }

                if (verify)
                {
                    Utils.SignOnBehalfVerify(signOnBehalf.Requests, signOnBehalf.Responses);
                }
            }

            public static void ExecuteNegativeRequest(XRLXSigSignOnBehalf signOnBehalf, UInt32 expectedResult)
            {
                if (signOnBehalf.Execute())
                {
                    throw new UnexpectedTestResultException("XSigSignOnBehalfRequest succeeded unexpected.");
                }

                ValueCheck.TestHR("XSigSignOnBehalf HResult", expectedResult, signOnBehalf.XErr);
            }

            public static void ExecuteNegativeRequest(XRLXSigSignOnBehalf signOnBehalf, HttpStatusCode expectedResult)
            {
                if (signOnBehalf.Execute())
                {
                    throw new UnexpectedTestResultException("XSigSignOnBehalfRequest succeeded unexpected.");
                }

                ValueCheck.Test("XSigSignOnBehalf HttpStatusCode", expectedResult, signOnBehalf.httpStatus);
            }

            [TestCase, TestCasePriority(1), AsyncGroup(1), Description("SignOnBehalf = Ask the XSIG to sign a digest with the specified authdata as the input.")]
            class BVT : TestNode
            {
                public override void Run()
                {
                    byte[] data = System.Text.Encoding.ASCII.GetBytes("Hello, how are you?");
                    ExecutePositiveRequest(new XRLXSigSignOnBehalf((uint)XOService.PresNotification, data));
                }
            }

            [TestCase, TestCasePriority(2), AsyncGroup(1), Description("SignOnBehalf: Try different service IDs.  Non-zero ServiceIDs should succeed.")]
            [CompoundCase("PresNotification", (uint)XOService.PresNotification, HResult.S_OK)]
            [CompoundCase("Matchmaking", (uint)XOService.Matchmaking, HResult.S_OK)]
            [CompoundCase("Signature", (uint)XOService.Signature_Server, HResult.S_OK)]
            [CompoundCase("Service0x7FFFFFFF", 0x7FFFFFFF, HResult.S_OK)]
            [CompoundCase("Service0xFFFFFFFF", 0xFFFFFFFF, HResult.S_OK)]
            [CompoundCase("InvalidService", (uint)XOService.InvalidService, HResult.XONLINE_E_INVALID_REQUEST)]
            class Service_ID : TestNode
            {
                Byte[] data = System.Text.Encoding.ASCII.GetBytes("Do'n ok.");

                public override void Run()
                {
                    UInt32 serviceId = Convert.ToUInt32(MyValues[0]);
                    UInt32 expectedResult = Convert.ToUInt32(MyValues[1]);

                    XRLXSigSignOnBehalf sign = new XRLXSigSignOnBehalf(serviceId, data);
                    if (expectedResult == HResult.S_OK)
                    {
                        ExecutePositiveRequest(sign);
                    }
                    else
                    {
                        ExecuteNegativeRequest(sign, expectedResult);
                    }
                }
            }

            [TestCase, TestCasePriority(2), AsyncGroup(1), Description("SignOnBehalf: Tweak the AuthData that is sent to the server and have the server return respective data.")]
            class AuthData : TestNode
            {
                public override void Run()
                {
                    byte[] data = System.Text.Encoding.ASCII.GetBytes("And you?");

                    XRLXSigSignOnBehalf sign = new XRLXSigSignOnBehalf((uint)XOService.PresNotification, data);
                    sign.Requests[0]._authData._titleID = 0xFFC0FE06;
                    ExecutePositiveRequest(sign);

                    sign = new XRLXSigSignOnBehalf((uint)XOService.PresNotification, data);
                    sign.Requests[0]._authData._titleVersion = 18;
                    ExecutePositiveRequest(sign);

                    sign = new XRLXSigSignOnBehalf((uint)XOService.PresNotification, data);
                    sign.Requests[0]._authData._XboxID = 0xFF09000000001234;
                    ExecutePositiveRequest(sign);

                    sign = new XRLXSigSignOnBehalf((uint)XOService.PresNotification, data);
                    sign.Requests[0]._authData._userID1 = 0x0009000000001111;
                    sign.Requests[0]._authData._userID2 = 0x0009000000002222;
                    sign.Requests[0]._authData._userID3 = 0x0009000000003333;
                    sign.Requests[0]._authData._userID4 = 0x0009000000004444;
                    ExecutePositiveRequest(sign);
                }
            }

            [TestCase, TestCasePriority(2), AsyncGroup(1), Description("SignOnBehalf: Send the wrong amount of data.")]
            class Bad_Size : TestNode
            {
                public override void Run()
                {
                    byte[] data = System.Text.Encoding.ASCII.GetBytes("Hello, how are you?");
                    XRLXSigSignOnBehalf sign = new XRLXSigSignOnBehalf(0);

                    sign.ExtraData = new Byte[1];
                    ExecuteNegativeRequest(sign, HttpStatusCode.InternalServerError);

                    sign.ExtraData = new Byte[101];
                    ExecuteNegativeRequest(sign, HttpStatusCode.InternalServerError);

                    sign.ExtraData = new Byte[105];
                    ExecuteNegativeRequest(sign, HttpStatusCode.InternalServerError);

                    sign.ExtraData = new Byte[1039];
                    ExecuteNegativeRequest(sign, HttpStatusCode.InternalServerError);

                    sign.Requests = new XSigSignOnBehalfRequest[] { new XSigSignOnBehalfRequest() };
                    sign.Requests[0] = XRLXSigSignOnBehalf.CreateSignRequest(XOService.PresNotification, data);
                    sign.ExtraData = new Byte[1];
                    ExecuteNegativeRequest(sign, HttpStatusCode.InternalServerError);
                }
            }

            [TestCase, TestCasePriority(2), AsyncGroup(1), Description("SignOnBehalf: Send multiple commands in the same request.")]
            class Multiple_Requests : TestNode
            {
                public override void Run()
                {
                    byte[] data1 = System.Text.Encoding.ASCII.GetBytes("Polo.");
                    byte[] data2 = System.Text.Encoding.ASCII.GetBytes("Rugby.");
                    byte[] data3 = System.Text.Encoding.ASCII.GetBytes("Croquet.");

                    XRLXSigSignOnBehalf sign = new XRLXSigSignOnBehalf();

                    sign.Requests = new XSigSignOnBehalfRequest[] {
                        XRLXSigSignOnBehalf.CreateSignRequest(XOService.PresNotification, data1),
                        XRLXSigSignOnBehalf.CreateSignRequest(XOService.StringService, data2),
                        XRLXSigSignOnBehalf.CreateSignRequest(XOService.Signature_Server, data3)};
                    ExecutePositiveRequest(sign);

                    sign.Requests = new XSigSignOnBehalfRequest[] {
                        XRLXSigSignOnBehalf.CreateSignRequest(XOService.Matchmaking, data1),
                        XRLXSigSignOnBehalf.CreateSignRequest(XOService.Auto_Update, data2)};
                    ExecutePositiveRequest(sign);

                    sign.Requests = new XSigSignOnBehalfRequest[] {
                        XRLXSigSignOnBehalf.CreateSignRequest(XOService.Tou, data1),
                        XRLXSigSignOnBehalf.CreateSignRequest(XOService.PresNotification, data2),
                        XRLXSigSignOnBehalf.CreateSignRequest(XOService.User_Account, data3)};
                    sign.Requests[1]._authData._titleID = 0xFFC0FE07;
                    ExecutePositiveRequest(sign);

                    sign.Requests = new XSigSignOnBehalfRequest[] {
                        XRLXSigSignOnBehalf.CreateSignRequest(XOService.Storage, data1),
                        XRLXSigSignOnBehalf.CreateSignRequest(XOService.Base_Subscription, data2),
                        XRLXSigSignOnBehalf.CreateSignRequest(XOService.Lists, data3)};
                    sign.Requests[1]._authData._XboxID = 0xFF09000000000014;
                    ExecutePositiveRequest(sign);

                    sign.Requests = new XSigSignOnBehalfRequest[] {
                        XRLXSigSignOnBehalf.CreateSignRequest(XOService.PresNotification, data1),
                        XRLXSigSignOnBehalf.CreateSignRequest(XOService.InvalidService, data2),
                        XRLXSigSignOnBehalf.CreateSignRequest(XOService.Signature_Server, data3)};
                    ExecuteNegativeRequest(sign, HResult.XONLINE_E_INVALID_REQUEST);

                    // maxContentLength in xrlscan.ini is 50000
                    // one signing request is 72, so the maximum allowed is 50000/72=694
                    Int32 maxRequests = 694;
                    sign.Requests = new XSigSignOnBehalfRequest[maxRequests];

                    for (int i = 0; i < maxRequests; i++)
                    {
                        sign.Requests[i] = XRLXSigSignOnBehalf.CreateSignRequest(
                            (uint)RandomEx.GlobalRandGen.Next(1, (int)XOService.MaxService),
                            RandomEx.GlobalRandGen.GenerateRandomBlob(200));
                    }
                    ExecutePositiveRequest(sign);

                    Array.Resize(ref sign.Requests, 695);
                    sign.Requests[694] = XRLXSigSignOnBehalf.CreateSignRequest(
                        (uint)RandomEx.GlobalRandGen.Next(1, (int)XOService.MaxService), 
                        RandomEx.GlobalRandGen.GenerateRandomBlob(200));
                    ExecuteNegativeRequest(sign, HttpStatusCode.NotFound);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\XSig\CreateCertificate2.cs ===
﻿using System;
using System.IO;
using System.Net;
using System.Net.Security;
using System.Net.Sockets;
using System.Security.Authentication;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.Utilities;
using xonline.common.service;

namespace SigTest.XSig.Functional
{
    //[TestGroup]
    public partial class XSig : TestNode
    {
        [TestGroup, Description("Verifies that the CreateCertificate2 APIs are functioning correctly")]
        [Owner("BenRan"), TestFrequency("Regression")]
        [AsyncGroup(10, 6), AsyncThreadCount(5), AsyncThreadDelay(1000)]
        public class CreateCertificate2 : TestNode
        {
            public static String ValidConsoleCertConsoleId = "XE.029877704969";
            ConsoleCertificate ValidConsoleCert;

            public CreateCertificate2()
            {
                // Since the CreateCertificate2 API uses the real live Public Key to verify the console certificate
                // that we send up, the only way the call will succeed is if we have a real certificate that is signed
                // with the real key.  This hardcoded certificate and signatures comes from a devkit.  The first chunk 
                // (that ends at the ragged part) is the certificate, and the rest of it is the signature
                ValidConsoleCert = new ConsoleCertificate();

                // Valid Console Cert with invalid signature (not sure how this happened)
                /*
                ValidConsoleCert.ReadBytes(new Byte[]{
                    0x01, 0xA8, 0x07, 0x03, 0x0D, 0x77, 0xE8, 0x58, 0x38, 0x30, 0x33, 0x39, 0x35, 0x34, 0x2D, 0x00, 
                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x01, 0x30, 0x37, 0x2D, 0x30, 
                    0x39, 0x2D, 0x30, 0x35, 0x00, 0x01, 0x00, 0x01, 0x7C, 0xEF, 0x81, 0x29, 0xF0, 0x2C, 0x73, 0xA1, 
                    0xE8, 0x87, 0x1B, 0x56, 0x37, 0x16, 0xD6, 0xA0, 0x75, 0xEE, 0x3A, 0x81, 0xDC, 0xF0, 0xDE, 0x5A, 
                    0x57, 0x18, 0xEB, 0xD9, 0x11, 0xD1, 0x2A, 0xAF, 0xF0, 0x09, 0xD3, 0xB8, 0xB6, 0xFC, 0x0C, 0x15, 
                    0x63, 0x01, 0x44, 0x15, 0x29, 0xFA, 0xF2, 0xF9, 0x0A, 0x44, 0x3D, 0xDB, 0x5D, 0xC7, 0x68, 0x7D, 
                    0x9D, 0x03, 0xC8, 0xAE, 0x8C, 0x50, 0x79, 0x11, 0xAB, 0x70, 0xF6, 0x63, 0x20, 0xA0, 0x67, 0x9B, 
                    0x3B, 0x69, 0x75, 0x13, 0xEF, 0x18, 0x47, 0x41, 0x6B, 0x0C, 0xD6, 0x50, 0x79, 0x72, 0x1F, 0x44, 
                    0x42, 0x13, 0x3D, 0x93, 0x53, 0x69, 0x84, 0x4F, 0x0A, 0x54, 0x9D, 0x4B, 0x08, 0x4F, 0x61, 0x0B, 
                    0x38, 0x4D, 0x33, 0xAB, 0x54, 0xD5, 0x0D, 0xDD, 0x2A, 0x51, 0xD5, 0xB4, 0x6E, 0x3C, 0x00, 0x07, 
                    0xCB, 0xEA, 0xF2, 0x10, 0xA5, 0x6F, 0x6F, 0xAD, 0x0E, 0x8B, 0xA8, 0xEA, 0xAF, 0x50, 0x98, 0xCD, 
                    0x46, 0x67, 0x68, 0x92, 0x34, 0x01, 0xD8, 0xDE, 0x95, 0xAC, 0xF8, 0xDE, 0xB5, 0x27, 0x3C, 0xB9, 
                    0xB1, 0xE9, 0xB2, 0xDE, 0x77, 0x62, 0x46, 0xCA, 0x6B, 0x49, 0xEF, 0x04, 0xDD, 0xC5, 0x59, 0x25, 
                    0x0A, 0xF5, 0x25, 0xD7, 0x3A, 0xBC, 0x44, 0xD4, 0xA3, 0x90, 0x30, 0xE9, 0xDA, 0x5C, 0x89, 0x45, 
                    0x5A, 0x31, 0xC7, 0x79, 0x6A, 0x3A, 0x2A, 0x22, 0xD3, 0xA3, 0xD6, 0xF7, 0x19, 0xC8, 0xBD, 0xB2, 
                    0xE9, 0x28, 0x42, 0xB4, 0x90, 0xC8, 0xBA, 0x04, 0x90, 0x99, 0x23, 0xE6, 0x37, 0xD8, 0xA8, 0xC6, 
                    0x3D, 0x5F, 0xA5, 0x03, 0x6A, 0x30, 0x5E, 0x75, 0x4C, 0x3A, 0xEF, 0x74, 0x39, 0xED, 0xCF, 0x15, 
                    0x2A, 0xF3, 0x2C, 0x80, 0xA7, 0x42, 0xAB, 0x7B, 0xC7, 0x1D, 0x7F, 0x8F, 0x73, 0xD8, 0xE6, 0x5D, 
                    0xCD, 0x91, 0xA0, 0x93, 0x5B, 0x52, 0xFD, 0xA5, 0x99, 0x75, 0x5F, 0xB2, 0xE1, 0x9D, 0xBF, 0x80, 
                    0xA9, 0x24, 0xF4, 0x75, 0x39, 0xD3, 0xD8, 0x43, 0x06, 0x44, 0x43, 0x39, 0x7F, 0x93, 0x18, 0x11, 
                    0x95, 0x98, 0x5C, 0x76, 0x19, 0x31, 0xD8, 0xFB, 0x9E, 0x23, 0xB3, 0x25, 0x07, 0x05, 0xEC, 0x26, 
                    0xC0, 0x80, 0xC9, 0xB3, 0xA5, 0x30, 0x59, 0x08, 0x0D, 0x22, 0xAF, 0xDB, 0x1E, 0x11, 0x42, 0x45, 
                    0x13, 0x2C, 0x51, 0x65, 0x3A, 0xDB, 0xAD, 0x36, 0xD5, 0xED, 0xDA, 0x16, 0x14, 0x03, 0x6B, 0xA3, 
                    0x9D, 0xE0, 0x8D, 0x88, 0x4E, 0x1D, 0x0E, 0x29, 0x6B, 0x76, 0xA2, 0xFD, 0x4D, 0x38, 0x0B, 0xBA, 
                    0x47, 0x33, 0xF3, 0x85, 0xB3, 0x24, 0x12, 0x0B, 0x33, 0xCC, 0x7B, 0xF1, 0xDD, 0xB8, 0xBC, 0x7F, 
                    0x3C, 0xC5, 0xB0, 0xBE, 0x14, 0x04, 0x42, 0x34, 0xD7, 0x90, 0xD8, 0xA9, 0x3B, 0x53, 0xC4, 0x41, 
                    0x67, 0x10, 0x47, 0xDC, 0xA4, 0xA1, 0x57, 0x2E, 
                });
                //*/

                ValidConsoleCert.ReadBytes(new Byte[] {
                    0x01, 0xA8, 0x0B, 0x21, 0x5C, 0x28, 0x09, 0x58, 0x38, 0x31, 0x33, 0x39, 0x35, 0x33, 0x2D, 0x30, 
                    0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x31, 0x31, 0x2D, 0x31, 
                    0x34, 0x2D, 0x30, 0x37, 0x00, 0x01, 0x00, 0x01, 0xF4, 0xDE, 0x7B, 0x46, 0x97, 0x2F, 0x41, 0x4D, 
                    0xD3, 0xBD, 0xBC, 0xF1, 0xBC, 0x13, 0x78, 0x75, 0xD6, 0x3E, 0x49, 0x86, 0x82, 0xF3, 0xBF, 0x27, 
                    0x22, 0xB2, 0xC6, 0x02, 0x60, 0x3F, 0x80, 0x60, 0x0F, 0x64, 0xCC, 0x7B, 0x3C, 0x56, 0x4A, 0xDD, 
                    0xA5, 0x1C, 0xB9, 0x2E, 0x58, 0x03, 0x03, 0xCF, 0x46, 0x87, 0x8F, 0xA2, 0x2A, 0x52, 0xE7, 0xD9, 
                    0x21, 0x6C, 0x50, 0x14, 0xBD, 0x4B, 0x76, 0xA6, 0x8A, 0x6F, 0xC3, 0x16, 0xE1, 0x1F, 0xA3, 0x70, 
                    0xA0, 0xA0, 0xFF, 0xA6, 0x4C, 0x27, 0x4A, 0x38, 0xFD, 0xD8, 0xE1, 0x11, 0xFC, 0x56, 0x85, 0x02, 
                    0x47, 0x2B, 0x53, 0x99, 0xE4, 0x33, 0xC6, 0xDF, 0xA2, 0x24, 0xE6, 0x11, 0x11, 0x58, 0x92, 0xFF, 
                    0x29, 0x6E, 0xFC, 0x40, 0x42, 0x9A, 0x0A, 0xEA, 0x66, 0x3A, 0x1D, 0xD8, 0xAA, 0xC3, 0x44, 0xFE, 
                    0xC2, 0xEA, 0x28, 0xCC, 0xFD, 0x55, 0x8D, 0x2D, 
                    0xE8, 0xBE, 0x6D, 0xF6, 0xD8, 0xDD, 0x0A, 0x9B, 0xAE, 0x1C, 0x61, 0xCB, 0x1E, 0x0F, 0x60, 0x73, 
                    0x94, 0x02, 0xB2, 0xF7, 0x42, 0x91, 0x9D, 0x34, 0xEC, 0x93, 0xCD, 0xD8, 0xC7, 0xE6, 0xA3, 0x62, 
                    0x47, 0x6A, 0x11, 0x85, 0xF2, 0x89, 0xFE, 0x98, 0xCF, 0xC6, 0xB6, 0xDC, 0x03, 0xAD, 0x64, 0xC5, 
                    0x80, 0x83, 0x33, 0x7A, 0x46, 0x1A, 0x54, 0x45, 0xCC, 0x11, 0xD0, 0x2F, 0x96, 0x04, 0xE1, 0xD8, 
                    0x77, 0x67, 0x44, 0xB9, 0x59, 0x47, 0x2B, 0xD6, 0x0F, 0x7C, 0xE4, 0x51, 0xBE, 0x43, 0x68, 0xEE, 
                    0x61, 0xDF, 0x45, 0x52, 0x36, 0xE4, 0xB3, 0xCC, 0x5F, 0xD8, 0xDF, 0x26, 0x33, 0x32, 0x6F, 0x90, 
                    0x3C, 0xCE, 0x0A, 0xAC, 0x0B, 0xC9, 0xA7, 0xE3, 0x76, 0x8D, 0x4D, 0x9E, 0xCF, 0xF5, 0x27, 0x3E, 
                    0x9C, 0xF6, 0x86, 0xF0, 0x08, 0x10, 0x82, 0x0C, 0x64, 0xEA, 0x52, 0xC6, 0x57, 0xFE, 0x78, 0x4C, 
                    0x8F, 0x37, 0x9C, 0xA2, 0x19, 0xEB, 0x77, 0x80, 0x0D, 0x38, 0xBB, 0x54, 0xD5, 0xBF, 0x5B, 0x14, 
                    0x8C, 0xB2, 0xCB, 0x8A, 0xDE, 0x85, 0x51, 0x78, 0xB5, 0xE9, 0x9D, 0xD0, 0xB5, 0x3F, 0x6A, 0xB3, 
                    0xC2, 0xB5, 0xEA, 0xF0, 0x19, 0x33, 0xCD, 0x9E, 0x8E, 0xBD, 0xDF, 0xD7, 0x9C, 0xB2, 0x53, 0x13, 
                    0x34, 0xC3, 0xF9, 0x56, 0x19, 0x69, 0x5F, 0x91, 0xCE, 0x04, 0xFF, 0x7A, 0x8B, 0xAB, 0x14, 0xA9, 
                    0x5A, 0x6A, 0xE2, 0xDF, 0x8D, 0x81, 0x61, 0x69, 0xD3, 0x35, 0xF4, 0x4E, 0x4A, 0x40, 0xB9, 0x70, 
                    0x59, 0x60, 0xBC, 0xD6, 0x2B, 0x54, 0xDD, 0x81, 0xA3, 0x35, 0x38, 0x6F, 0x4E, 0xA9, 0x6D, 0x72, 
                    0xF2, 0x0C, 0xB5, 0xF6, 0x4E, 0x75, 0x00, 0xB5, 0x79, 0xE7, 0x99, 0x45, 0xDB, 0x06, 0xA4, 0x11, 
                    0x6A, 0xDC, 0x54, 0xAE, 0x17, 0x10, 0xAF, 0xAD, 0x3A, 0xE0, 0x64, 0x2C, 0x24, 0xBD, 0x26, 0x36, 
                });

                ValidConsoleCertConsoleId = xonline.common.utilities.ConsoleIdUtil.ConvertConsoleIdFromByteArrayToDecimalString(ValidConsoleCert.ConsoleId);
            }

            public override void PreRun()
            {
                CertHelper.Initialize();
            }

            /// <summary>
            /// Creates a valid CreateCertificate2 request with a real console certificate and an associated
            /// client with the correct console id (the same one as in the console certificate).  All tests
            /// which depend on having a valide Console Certificate use this to create an the xrl.
            /// </summary>
            /// <returns>An XRLCreateCertificate2 object initialized with a valid console cert</returns>
            public XRLCreateCertificate2 GetValidXrl()
            {
                XRLCreateCertificate2 xrl = new XRLCreateCertificate2();
                // Set the console certificate to our valid one.  We doing a deep copy the easy way
                xrl.ConsoleCert = new ConsoleCertificate();
                xrl.ConsoleCert.ReadBytes((byte[])ValidConsoleCert);
                // Create a new Xenon Client
                xrl.Client = SignatureUtils.CreateClient();
                // And then sign in with the same console id as the one in our hardcode certificate
                xrl.Client.SignInXmacsWithConsoleID(ValidConsoleCertConsoleId);

                return xrl;
            }

            /// <summary>
            /// Validate a given CreateCertificate2 response
            /// </summary>
            /// <param name="xrl">The XRL with the request and reponse</param>
            public static void ValidateResponse(XRLCreateCertificate2 xrl)
            {
                if (xrl.Response == null)
                {
                    throw new UnexpectedTestResultException("XRL has no response data");
                }

                // We need to make a copy so that we don't screw up the console cert in case
                // we want to use it again.
                Byte[] cpkMod = new Byte[xrl.ConsoleCert.ConsolePublicKey.Modulus.Length];
                Array.Copy(xrl.ConsoleCert.ConsolePublicKey.Modulus, cpkMod, cpkMod.Length);
                for (int i = 0; i < cpkMod.Length; i += 8)
                {
                    Array.Reverse(cpkMod, i, 8);
                }
                Array.Reverse(cpkMod);

                CertState state = new CertState(xrl.AppId);
                state.ConsoleId = xrl.ConsoleId;

                Global.RO.Info("Validating Ceritificate");
                X509Certificate2 cert = ValidateCertificate(cpkMod, xrl.Response.Certificate, xrl.Response.CertificateSize);
                X509Certificate2 serializedCert = ValidateCertificate(cpkMod, xrl.Response.SerializedCertificate, xrl.Response.SerializedCertificateSize);

                CertHelper.VerifyCertificates(state, cert, serializedCert);
            }

            /// <summary>
            /// Validate a single certificate and ensure that the public key in the cert
            /// is the same as the one expected
            /// </summary>
            /// <param name="expectedMod">The expected pubkey modulus.</param>
            /// <param name="rawCert">The raw certificate data</param>
            /// <param name="size">the expected size of the cert</param>
            /// <returns>The certificate represented by the raw data</returns>
            public static X509Certificate2 ValidateCertificate(Byte[] expectedMod, Byte[] rawCert, uint size)
            {
                if (rawCert == null || rawCert.Length != size)
                {
                    throw new UnexpectedTestResultException("The certificate data was not present or was the wrong size");
                }

                X509Certificate2 cert = new X509Certificate2(rawCert);
                Byte[] publicKeyMod = (cert.PublicKey.Key as RSACryptoServiceProvider).ExportParameters(false).Modulus;

                if (!ArrayEx.Equals(expectedMod, publicKeyMod))
                {
                    throw new UnexpectedTestResultException("The public key is the certificate did not match the one that was provided");
                }

                return cert;
            }

            [TestCase, TestCasePriority(1), Description("Baseline CreateCertificate2 test case")]
            public void P_BVT()
            {
                XRLCreateCertificate2 xrl = new XRLCreateCertificate2();
                xrl.Initialize();

                if (!xrl.Execute(true))
                {
                    // If the request failed, but it was a create certificate error, let it slide for
                    // the BVT since we really just want to make sure the service is up and running
                    if (xrl.XErr != HResult.XONLINE_E_SIGNATURE_CREATE_CERTIFICATE_ERROR)
                    {
                        throw new UnexpectedTestResultException("CreateCertificate2 request failed: " + xrl.GetDumpString());
                    }
                }
                else
                {
                    Global.RO.Warn("The call to CreateCertificate2 succeeded with what was probably an invalid certificate.  Ignoring for BVT");
                }

                Global.RO.Success("CreateCertificate2 BVT successful");
            }

            [TestCase, TestCasePriority(1), Description("Call CreateCertificate2 with a valid real console certificate and verify the response")]
            public void P_RequestAndVerify()
            {
                XRLCreateCertificate2 xrl = GetValidXrl();

                // Don't resign the certificate, it's already signed
                if (!xrl.Execute(false))
                {
                    throw new UnexpectedTestResultException("CreateCertificate2 request failed: " + xrl.GetDumpString());
                }

                ValidateResponse(xrl);
            }

            [TestCase, TestCasePriority(2), Description("Non-exhaustive verification that the serial number in the generated certificate is non-negative")]
            public void P_ValidatePositiveSerialNumber()
            {
                for (int i = 1; i < 10; i++)
                {
                    // It's just doing the same test a bunch of times and the regular validation checks this
                    P_RequestAndVerify();
                }
            }

            [TestCase, TestCasePriority(2), Description("Call CreateCertificate2 with an invalid certificate signature")]
            public void N_InvalidSignature()
            {
                XRLCreateCertificate2 xrl = new XRLCreateCertificate2();
                xrl.Initialize();

                // Mess up the signature.  Technically we don't need to do this since our 'generated' console certs are signed
                // with the test key which will fail on the service when checked against the real key, but it can't hurt.
                xrl.ConsoleCert.Signature = RandomEx.GlobalRandGen.GenerateRandomBlob(ConsoleCertificate.CONSOLE_CERTIFICATE_SIGNATURE_SIZE);

                // We don't want to resign the request
                if (xrl.Execute(false))
                {
                    throw new UnexpectedTestResultException("Expected CreateCertificate2 to fail with invalid signature");
                }

                if (xrl.XErr != HResult.XONLINE_E_SIGNATURE_CREATE_CERTIFICATE_ERROR)
                {
                    UnexpectedXRLTestResultException ex = new UnexpectedXRLTestResultException("Unexepected error was returned by CreateCertificate2 with invalid signature: " + xrl.GetDumpString());
                    ex.xrl = xrl;

                    throw ex;
                }
            }

            [TestCase, TestCasePriority(2), Description("Make a request with an empty console certificate")]
            public void N_EmptyCertificate()
            {
                // Setup the default stuff, we don't need a real cert because we're paving it anyway.
                XRLCreateCertificate2 xrl = new XRLCreateCertificate2();
                xrl.Initialize();

                // Then pave over the console certificate
                //xrl.ConsoleCert = new ConsoleCertificate();
                xrl.ConsoleCert.CertSize = 0;
                xrl.ConsoleCert.ConsoleId = new Byte[ConsoleCertificate.CONSOLE_ID_SIZE];
                xrl.ConsoleCert.ConsolePartNumber = new Byte[ConsoleCertificate.CONSOLE_CERT_PART_NUMBER_SIZE];
                xrl.ConsoleCert.ConsoleType = 0;
                xrl.ConsoleCert.ManufacturingDate = 0;
                xrl.ConsoleCert.Signature = new Byte[ConsoleCertificate.CONSOLE_CERTIFICATE_SIGNATURE_SIZE];
                xrl.ConsoleCert.ConsolePublicKey.Modulus = new Byte[128];
                xrl.ConsoleCert.ConsolePublicKey.PublicExp = new Byte[4];

                // Don't resign the cert before requesting
                if (xrl.Execute(false))
                {
                    throw new UnexpectedTestResultException("Expected CreateCertificate2 to fail due to empty console cert");
                }

                if (xrl.XErr != HResult.XONLINE_E_SIGNATURE_CREATE_CERTIFICATE_ERROR)
                {
                    UnexpectedXRLTestResultException ex = new UnexpectedXRLTestResultException(
                        "Unexepected error was returned by CreateCertificate2 with empty console cert: " + xrl.GetDumpString());
                    ex.xrl = xrl;

                    throw ex;
                }
            }

            [TestCase, TestCasePriority(2), Description("Make a request with a mismatched ConsoleId in the certificate")]
            public void N_MismatchedConsoleId()
            {
                // We don't need a real certificate here because we're gonna resign in anyway after with the test key
                XRLCreateCertificate2 xrl = new XRLCreateCertificate2();
                xrl.Initialize();

                // Ruin console id on the cert
                xrl.ConsoleCert.ConsoleId = RandomEx.GlobalRandGen.GenerateRandomBlob(ConsoleCertificate.CONSOLE_ID_SIZE);

                // Resign the certificate using the invalid console id
                if (xrl.Execute(true))
                {
                    throw new UnexpectedTestResultException("Expected CreateCertificate2 to fail with mismatched ConsoleId");
                }

                if (xrl.XErr != HResult.XONLINE_E_SIGNATURE_CREATE_CERTIFICATE_ERROR)
                {
                    UnexpectedXRLTestResultException ex = new UnexpectedXRLTestResultException(
                        "Unexepected error was returned by CreateCertificate2 with mismatched ConsoleId: " + xrl.GetDumpString());
                    ex.xrl = xrl;

                    throw ex;
                }
            }

            [TestCase, TestCasePriority(2), Description("Make a request with a machine puid that maps to a different console than the one in the certificate")]
            public void N_MismatchedMachinePuid()
            {
                XRLCreateCertificate2 xrl = new XRLCreateCertificate2();
                xrl.Initialize();

                xrl.ManualSlotSetup = true;
                IMachine newMachine = (MachineBase)ServerTestFramework.Database.MachineEditor.CreateNew();
                xrl.Slot.machinePuid = newMachine.Puid;
                xrl.Slot.AddService((int)XOService.Signature_Server);

                if (xrl.Execute(true))
                {
                    throw new UnexpectedTestResultException("Expected CreateCertificate2 to fail due to invalid machine puid");
                }

                if (xrl.XErr != HResult.XONLINE_E_SIGNATURE_CREATE_CERTIFICATE_ERROR)
                {
                    UnexpectedXRLTestResultException ex = new UnexpectedXRLTestResultException(
                        "Unexepected error was returned by CreateCertificate2 with invalid machine puid: " + xrl.GetDumpString());
                    ex.xrl = xrl;

                    throw ex;
                }
            }

            [TestCase, TestCasePriority(2), Description("Make a request with an random machine puid")]
            public void N_RandomMachinePuid()
            {
                XRLCreateCertificate2 xrl = GetValidXrl();

                xrl.ManualSlotSetup = true;
                xrl.Slot.machinePuid = RandomEx.GlobalRandGen.NextUlong();
                xrl.Slot.AddService((int)XOService.Signature_Server);

                if (xrl.Execute(true))
                {
                    throw new UnexpectedTestResultException("Expected CreateCertificate2 to fail due to invalid machine puid");
                }

                if (xrl.XErr != HResult.XONLINE_E_SERVER_ERROR)
                {
                    UnexpectedXRLTestResultException ex = new UnexpectedXRLTestResultException(
                        "Unexepected error was returned by CreateCertificate2 with invalid machine puid: " + xrl.GetDumpString());
                    ex.xrl = xrl;

                    throw ex;
                }
            }

            [TestCase, TestCasePriority(2), Description("Make a request with an invalid client type")]
            public void N_InvalidClientType()
            {
                XRLCreateCertificate2 xrl = GetValidXrl();

                xrl.ManualSlotSetup = true;
                xrl.Slot.machinePuid = ServerTestFramework.LiveService.FakeSG.CSGInfo.DefaultMachineId;
                xrl.Slot.SetClientType(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.PC);
                xrl.Slot.AddService((int)XOService.Signature_Server);

                if (xrl.Execute(true))
                {
                    throw new UnexpectedTestResultException("Expected CreateCertificate2 to fail due to invalid client type");
                }

                if (xrl.XErr != HResult.XONLINE_E_SIGNATURE_CREATE_CERTIFICATE_ERROR)
                {
                    UnexpectedXRLTestResultException ex = new UnexpectedXRLTestResultException(
                        "Unexepected error was returned by CreateCertificate2 with invalid client type: " + xrl.GetDumpString());
                    ex.xrl = xrl;

                    throw ex;
                }
            }

            // Test machine must have a DNS entry that points to the webserver IP defined below in order to 
            // resolve the DN to the appropriate ip address (actually on the same server)
            private static String SSLTestWebserverDN = "xboxssl.xboxssldc.nttest.microsoft.com";
            private static String SSLTestWebserverIP = "xboxssl"; // Temporarily set to the name to avoid errors when the box ip changes
            private static int SSLTestWebserverPort = 550;

            [TestCase, Description("Creates a valid certificate and attempts to use that cert to connect to a non-xbl SSL webservice")]
            [TestFrequency("Regression"), TestCasePriority(3)]
            [Ignore("IIS doesn't support regular authentication like this")]
            public class SimpleConnect : TestNode
            {
                //private X509Certificate2 cert = null;
                //private X509Certificate2Collection certCollection = null;

                bool serverUsesClientAuth = false;

                public override void PreRun()
                {
                    if (serverUsesClientAuth)
                    {
                        TcpClient client = new TcpClient(SSLTestWebserverIP, SSLTestWebserverPort);
                        // Request a steam which won't authenticate the server at all, and uses no cert.
                        SslStream stream = new SslStream(client.GetStream(), false, NullRemoteCertValidation, NullLocalCertSelection);
                        try
                        {
                            stream.AuthenticateAsClient(SSLTestWebserverDN, null, SslProtocols.Default, false);
                        }
                        catch (AuthenticationException)
                        {
                            // If we've failed authentication, it should be because the server rejected us because
                            // we're not authenticating the server at all.  Therefore...
                            serverUsesClientAuth = true;
                        }

                        SslStream stream2 = new SslStream(stream, false, NullRemoteCertValidation, NullLocalCertSelection);

                        try
                        {
                            stream2.AuthenticateAsClient(SSLTestWebserverDN, null, SslProtocols.Default, false);
                        }
                        catch (AuthenticationException)
                        {
                            serverUsesClientAuth = true;
                        }
                        finally
                        {
                            if (stream2 != null)
                            {
                                stream2.Close();
                            }
                        }
                        stream.Close();

                        client.Close();
                    }
                }

                public override void Run()
                {
                    serverUsesClientAuth = true;
                    if (!serverUsesClientAuth)
                    {
                        throw new DidNotExecuteException("Remote server isn't using client auth.  Ignoring test.");
                    }
                    /*
                    // Request a certificate from the server
                    Global.RO.Info("Creating 'generic_ssl' certificate");
                    CertState state = CertState.Create();
                    CreateCertificateResponse response = state.DoRequest();
                    cert = new X509Certificate2(response.Certificate);

                    state.SetPrivateKey(cert);

                    File.WriteAllBytes("XboxClientCertificate.cer", cert.Export(X509ContentType.Cert));
                    File.WriteAllBytes("XboxClientCertificate.p12", cert.Export(X509ContentType.Pkcs12));

                    certCollection = new X509Certificate2Collection(cert);

                    // Open a TCP Connection to the server
                    Global.RO.Info("Opening TCP Connection to server");
                    TcpClient client = new TcpClient();
                    client.Connect(SSLTestWebserverIP, SSLTestWebserverPort);

                    // Create a secure stream and then try to authenticate.
                    Global.RO.Info("Creating secure stream");
                    SslStream stream = new SslStream(client.GetStream(), true, RemoteCertValidation);
                    SslStream authStream = null;

                    try
                    {
                        Global.RO.Info("Attempting to authenticate as client using cert");
                        stream.AuthenticateAsClient(SSLTestWebserverDN, null, SslProtocols.Default, false);

                        authStream = new SslStream(stream, true, RemoteCertValidation);
                        authStream.AuthenticateAsClient(SSLTestWebserverDN, certCollection, SslProtocols.Default, false);
                    }
                    catch (AuthenticationException authEx)
                    {
                        Global.RO.Error("Unable to authenticate client using provided cert: " + authEx.Message);
                        Global.RO.Warn(stream.RemoteCertificate.ToString());
                        return TEST_RESULTS.FAILED;
                    }

                    Global.RO.Info("IsAuthenticated: {0}, IsMutuallyAuthenticated: {1}, IsEncrypted: {2}",
                        authStream.IsAuthenticated, authStream.IsMutuallyAuthenticated, authStream.IsEncrypted);

                    if (!stream.IsAuthenticated || !authStream.IsMutuallyAuthenticated)
                    {
                        Global.RO.Error("Client was not authenticated.");
                        return TEST_RESULTS.FAILED;
                    }
                    */
                }
            }

            [TestCase, Description("Perform and HTTPS web request and retrieve a text file from a secured server")]
            [TestFrequency("Regression"), TestCasePriority(3)]
            [Ignore("This test is not possible, because we need a real console certificate AND access to it's private key to use it for SSL")]
            public void HttpsRequest()
            {
                // Request a certificate from the server
                Global.RO.Info("Creating a ClientAuth console certificate");
                XRLCreateCertificate2 xrl = GetValidXrl();

                RSACryptoServiceProvider rsaCryptoProvider = new RSACryptoServiceProvider(1024);
                RSAParameters rsaParameters = rsaCryptoProvider.ExportParameters(false);
                xrl.ConsoleCert.ConsolePublicKey.Modulus = rsaParameters.Modulus;
                xrl.ConsoleCert.ConsolePublicKey.PublicExp = rsaParameters.Exponent;

                if (!xrl.Execute(true))
                {
                    throw new UnexpectedTestResultException("Unable to create console certificate: " + xrl.GetDumpString());
                }

                // Throw it into a collection
                X509Certificate2 cert = new X509Certificate2(xrl.Response.Certificate);
                cert.PrivateKey = rsaCryptoProvider;
                X509Certificate2Collection certCollection = new X509Certificate2Collection(cert);

                // Open a TCP Connection to the server
                ServicePointManager.CheckCertificateRevocationList = false;
                ServicePointManager.ServerCertificateValidationCallback = RemoteCertValidation;

                Uri requestUri = new Uri(String.Format("https://{0}:{1}/SSLRoot/SSL_Default.txt", SSLTestWebserverIP, SSLTestWebserverPort));
                Global.RO.Info("Create HTTPS Request for " + requestUri);
                HttpWebRequest httpsRequest = (HttpWebRequest)WebRequest.Create(requestUri);
                httpsRequest.UseDefaultCredentials = false;
                httpsRequest.AuthenticationLevel = AuthenticationLevel.MutualAuthRequired;
                httpsRequest.ClientCertificates = certCollection;

                HttpWebResponse httpsResponse = null;

                try
                {
                    Global.RO.Info("Attempting HTTPS Request to " + httpsRequest.Address);
                    httpsResponse = (HttpWebResponse)httpsRequest.GetResponse();
                }
                catch (Exception e)
                {
                    Global.RO.Error("Unable to complete HTTPS request. " + e.ToString());
                    throw e;
                }

                Global.RO.Success("Dumping response.");
                MemoryStream memStream = new MemoryStream();
                Stream responseStream = httpsResponse.GetResponseStream();
                byte[] responseBuffer = new Byte[responseStream.Length];
                responseStream.Read(responseBuffer, 0, (int)responseStream.Length);
                String responseString = Encoding.GetEncoding(httpsResponse.ContentEncoding).GetString(responseBuffer);
                Global.RO.Success(responseString);
            }

            #region Certificate Selection Methods
            private static bool NullRemoteCertValidation(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
            {
                return true;
            }

            private static bool RemoteCertValidation(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
            {
                Global.RO.Info("Server Certificate:\n" + certificate.ToString());

                if ((sslPolicyErrors & SslPolicyErrors.RemoteCertificateNameMismatch) == SslPolicyErrors.RemoteCertificateNameMismatch)
                {
                    Global.RO.Warn("There is a name mismatch on the server provided certificate.  Make sure that you're connecting where you think you are.");
                    //return false;
                }

                if ((sslPolicyErrors & SslPolicyErrors.RemoteCertificateChainErrors) == SslPolicyErrors.RemoteCertificateChainErrors)
                {
                    Global.RO.Warn("NOTE: There are errors in the remote cert.  We are NOT authenticating the server for this test.  You must verify that this cert is valid.");
                }

                // Right now we're not authenticating the server anymore.
                return true;
            }

            private static X509Certificate LocalCertSelection(Object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, string[] acceptableIssuers)
            {
                if (localCertificates.Count > 0)
                {
                    return localCertificates[0];
                }
                else
                {
                    return null;
                }
            }

            private static X509Certificate NullLocalCertSelection(Object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, string[] acceptableIssuers)
            {
                return null;
            }
            #endregion //Certificate Selection Methods
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\XSig\GetSigningKey.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Core.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.protocol;

namespace SigTest.XSig.Functional
{
    //[TestGroup]
    public partial class XSig : TestNode
    {
        [TestGroup, Owner("BenRan"), TestFrequency("Regression")]
        public class GetSigningKey : TestNode
        {
            [TestCase, TestCasePriority(1), AsyncGroup(1), Description("Ask XSIG to issue a new key")]
            class BVT : TestNode
            {
                public override void Run()
                {
                    // Run this ten times
                    for (int i = 0; i < 3; i++)
                        Utils.GetSigningKeyVerify(new XRLGetSigningKey().Execute());
                }
            }

            [TestCase, TestCasePriority(2), AsyncGroup(1), Description("Ask XSIG to issue a new key for different users, titles, etc")]
            class SGInfo : TestNode
            {
                public override void Run()
                {
                    XRLGetSigningKey xrl = new XRLGetSigningKey();
                    XSigSignature sig = new XSigSignature();
                    sig.Initialize();

                    xrl.machinePuid = 0x7F09000000000000;
                    sig._authData._XboxID = 0x7F09000000000000;
                    Global.RO.Info("Validating Machine Puid");
                    Utils.GetSigningKeyVerify(xrl.Execute(), sig);

                    xrl.titleID = 0x7fc0fe01;
                    sig._authData._titleID = 0x7fc0fe01;
                    Global.RO.Info("Validating Title ID");
                    Utils.GetSigningKeyVerify(xrl.Execute(), sig);

                    xrl.titleVersion = 2;
                    sig._authData._titleVersion = 2;
                    Global.RO.Info("Validating Title Version");
                    Utils.GetSigningKeyVerify(xrl.Execute(), sig);

                    xrl.userPuids = new ulong[4] { 0xFF09000000000002, 0, 0xFF09000000000003, 0 };
                    sig._authData._userID1 = 0xFF09000000000002;
                    sig._authData._userID2 = 0x0;
                    sig._authData._userID3 = 0xFF09000000000003;
                    sig._authData._userID4 = 0x0;
                    Global.RO.Info("Validating User Puids Partial");
                    Utils.GetSigningKeyVerify(xrl.Execute(), sig);

                    xrl.userPuids = new ulong[4] { 0xFF09000000000002, 0xFF09000000000003, 0xFF09000000000004, 0xFF09000000000005 };
                    sig._authData._userID1 = 0xFF09000000000002;
                    sig._authData._userID2 = 0xFF09000000000003;
                    sig._authData._userID3 = 0xFF09000000000004;
                    sig._authData._userID4 = 0xFF09000000000005;
                    Global.RO.Info("Validating Machine Puid All");
                    Utils.GetSigningKeyVerify(xrl.Execute(), sig);
                }
            }

            [TestCase, TestCasePriority(2), AsyncGroup(1), Description("Ask XSIG to issue a new key but pass it parameters when it doesn't expect them")]
            class Invalid_Size : TestNode
            {
                public override void Run()
                {
                    XRLGetSigningKey sig = new XRLGetSigningKey();

                    ValueCheck.IsTrue(sig.Execute(new byte[1]) == null &&
                                    sig.httpStatus == System.Net.HttpStatusCode.InternalServerError &&
                                    sig.XErr == HResult.XONLINE_E_INVALID_REQUEST,
                                    String.Format("Execute returned NULL. HttpStatus: {0}, XERR: {1}", sig.httpStatus, sig.XErr));
                    ValueCheck.IsTrue(sig.Execute(new byte[4096]) == null &&
                                    sig.httpStatus == System.Net.HttpStatusCode.InternalServerError &&
                                    sig.XErr == HResult.XONLINE_E_INVALID_REQUEST,
                                    String.Format("Execute with large sig failed. HttpStatus: {0}, XERR: {1}", sig.httpStatus, sig.XErr));

                }
            }

            [TestCase, TestCasePriority(2), Description("Ask XSIG to issue a new key for a banned user, machine or title")]
            class Blacklist : TestNode
            {
                public override void Run()
                {
                    NpdbUtility npdb = new NpdbUtility();
                    npdb.ConnectToServer();
                    npdb.BlacklistTitle(0x7FBADD02, 2, true);

                    ulong[] blacklistedMachines = new ulong[4];
                    for (int i = 0; i < blacklistedMachines.Length; i++)
                    {
                        blacklistedMachines[i] = (ulong)(new Random().Next());
                        npdb.BlacklistMachine(blacklistedMachines[i], true);
                    }

                    ulong[] blacklistedUsers = new ulong[4];
                    for (int i = 0; i < blacklistedUsers.Length; i++)
                    {
                        blacklistedUsers[i] = (ulong)(new Random().Next());
                        npdb.BlacklistUser(blacklistedUsers[i], true);
                    }
                    npdb.Close();

                    ulong[] goodUsers = new ulong[4];
                    goodUsers[0] = (ulong)(new Random().Next());
                    goodUsers[1] = (ulong)(new Random().Next());
                    goodUsers[2] = 0;
                    goodUsers[3] = 0;

                    Utils.ReloadBlacklist();

                    XRLGetSigningKey sig;

                    sig = new XRLGetSigningKey();
                    sig.titleID = 0x7FBADD02;
                    sig.titleVersion = 2;
                    ValueCheck.IsTrue(sig.Execute() == null && sig.httpStatus == System.Net.HttpStatusCode.InternalServerError &&
                        sig.XErr == HResult.XONLINE_E_SIGNATURE_BANNED_TITLE, "Expected XERR " + HResult.XONLINE_E_SIGNATURE_BANNED_TITLE + " Recieved " + sig.XErr);

                    sig = new XRLGetSigningKey();
                    foreach (ulong u in blacklistedMachines)
                    {
                        sig.machinePuid = u;
                        ValueCheck.IsTrue(sig.Execute() == null && sig.httpStatus == System.Net.HttpStatusCode.InternalServerError &&
                            sig.XErr == HResult.XONLINE_E_SIGNATURE_BANNED_XBOX, "Expected XERR " + HResult.XONLINE_E_SIGNATURE_BANNED_XBOX + " Recieved " + sig.XErr);
                    }

                    sig = new XRLGetSigningKey();
                    foreach (ulong u in blacklistedUsers)
                    {
                        sig.userPuids = new ulong[] { u, 0, 0, 0 };
                        ValueCheck.IsTrue(sig.Execute() == null && sig.httpStatus == System.Net.HttpStatusCode.InternalServerError &&
                            sig.XErr == HResult.XONLINE_E_SIGNATURE_BANNED_USER, "Expected XERR " + HResult.XONLINE_E_SIGNATURE_BANNED_USER + " Recieved " + sig.XErr);
                    }

                    sig = new XRLGetSigningKey();
                    for (int i = 0; i < blacklistedUsers.Length; i++)
                    {
                        sig.userPuids = new ulong[] { goodUsers[i], blacklistedUsers[i], 0, 0 };
                        ValueCheck.IsTrue(sig.Execute() == null && sig.httpStatus == System.Net.HttpStatusCode.InternalServerError &&
                            sig.XErr == HResult.XONLINE_E_SIGNATURE_BANNED_USER, "Expected XERR " + HResult.XONLINE_E_SIGNATURE_BANNED_USER + " Recieved " + sig.XErr);
                    }

                    sig = new XRLGetSigningKey();
                    sig.titleID = 0x7FBADD02;
                    sig.titleVersion = 2;
                    sig.userPuids = new ulong[] { 0, 0, goodUsers[0], blacklistedUsers[0] };
                    ValueCheck.IsTrue(sig.Execute() == null && sig.httpStatus == System.Net.HttpStatusCode.InternalServerError &&
                        sig.XErr == HResult.XONLINE_E_SIGNATURE_BANNED_TITLE, "Expected XERR " + HResult.XONLINE_E_SIGNATURE_BANNED_TITLE + " Recieved " + sig.XErr);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\XSig\CreateCertificate.cs ===
﻿using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;
using xonline.common.protocol;
using xonline.common.service;

namespace SigTest.XSig.Functional
{
    //[TestGroup]
    public partial class XSig : TestNode
    {
        [TestGroup, Description("Verifies that the CreateCertificate APIs are functioning correctly")]
        [Owner("BenRan"), TestFrequency("Regression")]
        [AsyncGroup(10, 6), AsyncThreadCount(5), AsyncThreadDelay(1000)]
        public class CreateCertificate : TestNode
        {
            public override void PreRun()
            {
                AuthClientBase.InitializePassportIDCRL();

                CertHelper.Initialize();
            }

            [TestCase, TestCasePriority(1), Description("Try a basic CreateCertificate request with the default AppId (generic_ssl) and check if it succeeds")]
            public void BVT()
            {
                CertState state = CertState.Create();
                CreateCertificateResponse response = state.DoRequest();

                System.IO.File.WriteAllBytes("Generic_SSL.cer", response.Certificate);

                if (response == null ||
                    response.Certificate == null || response.Certificate.Length != response.CertificateSize ||
                    response.SerializedCertificate == null || response.SerializedCertificate.Length != response.SerializedCertificateSize)
                {
                    throw new UnexpectedTestResultException("There was an issue with the CreateCertificate response");
                }
            }

            [TestCase, TestCasePriority(2), Description("Create a 'generic_ssl' certificate and verifiy that the result that is returned in valid")]
            public void SimpleVerify()
            {
                CertState state = CertState.Create();
                Global.RO.Info("Making call...");
                CreateCertificateResponse response = state.DoRequest();

                CertHelper.VerifyCertificates(state, response.Certificate, response.SerializedCertificate);
            }

            [TestCase, TestCasePriority(2), Description("Try to create a certificate with an invalid AppID")]
            [CompoundCase("Normal", "BadAppIdTest", HResult.XONLINE_E_INVALID_REQUEST)]
            [CompoundCase("LongNormal", "0123456789012345678901234567890123456789012345678901234567890123", HResult.XONLINE_E_INVALID_REQUEST)]
            [CompoundCase("LongEmpty", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", HResult.XONLINE_E_INVALID_REQUEST)]
            [CompoundCase("SingleEmpty", "\0", HResult.XONLINE_E_INVALID_REQUEST)]
            public class BadAppID : TestNode
            {
                public override void Run()
                {
                    string AppIDToUse = (string)MyValues[0];
                    uint ExpectedError = (uint)MyValues[1];

                    CertState state = CertState.Create(AppIDToUse);

                    try
                    {
                        state.DoRequest();
                        throw new UnexpectedTestResultException("CreateCertificate request with invalid AppID succeded.");
                    }
                    catch (XErrException xcce)
                    {
                        if (xcce.XErr != ExpectedError)
                        {
                            throw;
                        }
                    }
                }
            }

            [TestCase, TestCasePriority(2), Description("Attempt to create a certificate using a zero length public key"), Ignore("The way the xrl calls are made, there is no easy way to pass a public key of the incorrect length right now")]
            public class ZeroLengthPubKey : TestNode
            {
                public override void Run()
                {
                    CertState state = CertState.Create(CertState.DefaultAppId);
                    state.PublicKey = new Byte[0];

                    try
                    {
                        state.DoRequest();
                        throw new UnexpectedTestResultException("Create certificate with an empty public key succeeded");
                    }
                    catch (XErrException xcce)
                    {
                        if (xcce.XErr != HResult.XONLINE_E_XCRYPTO_ERROR)
                        {
                            throw;
                        }
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\XSig\StressCheckRevocation.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.Utilities;
using xonline.common.protocol;

namespace SigTest.XSig.Stress
{
    public class StressCheckRevocationSuite : TestNode
    {
        public override void PreRun()
        {
            //System.Net.ServicePointManager.DefaultConnectionLimit = 10000;

            Global.RO.Info("Injecting Sql Data(this takes a few minutes)...");

            // Insert a large number of items into the database to simulate
            // a fuller revocation list
            Npdb npdb = new Npdb();
            npdb.ConnectToServer();
            String sql;

            for (int j = 0; j < 10; j++)
            {
                sql = "";
                for (int i = 0; i < 5; i++)
                {
                    sql += String.Format("EXECUTE [p_xcbt_blacklist_digest] {0}, 1, 2, 'StressTest'\r\n",
                        ServerTestFramework.Utilities.RandomEx.GlobalRandGen.GenerateHexString(40));
                }
                npdb.IssueCommand(sql);
            }
        }

        public override void  PostRun()
        {
            Global.RO.Info("Cleaning up database...");

            Npdb npdb = new Npdb();
            npdb.ConnectToServer();

            string sql = "DELETE FROM t_blacklisted_digests WHERE vc_revocation_reason = 'StressTest'";
            int rows = npdb.IssueCommand(sql);

            Global.RO.Debug("{0} rows deleted", rows);
        }
    }

    [StressTest, Owner("BenRan"), TestFrequency("Regression"), TestCasePriority(1)]
    public class StressCheckRevocationSingleTupleRevoked : TestNode
    {
        private static String DummyDigestString;
        private static Byte[] DummyDigest;
        private static ContentTuple contentTuple;

        public override void OneTimeSetup()
        {
            DummyDigestString = RandomEx.GlobalRandGen.GenerateHexString(40);
            DummyDigest = Hexer.unhex(DummyDigestString);

            contentTuple = new ContentTuple();
            contentTuple.TitleId = 0x4D5307E6;
            contentTuple.TitleVersion = 2;
            contentTuple.ConsolePuid = 286230209;
            contentTuple.ConsoleId = new byte[5];
            contentTuple.UserPuid[0] = 286230209;
            contentTuple.Digest = DummyDigest;
        }

        public override void PreRun()
        {
            Global.RO.Info("Injecting SQL data for revoked tuples...");

            Npdb npdb = new Npdb();
            npdb.ConnectToServer();

            string sql = String.Format(" EXECUTE [p_xcbt_blacklist_digest] {0}, 1, 2, 'StressTest'",
                DummyDigestString);
            npdb.IssueCommand(sql);

            Utils.ReloadBlacklist();
        }

        public override void Run()
        {
            XRLCheckRevocation req = new XRLCheckRevocation(1);
            req.xAct.SendTimeOut = 2;
            req.xAct.ReceiveTimeOut = 2;
            req.Request.Tuples[0] = contentTuple;

            if (!req.Execute()|| req.Response.Hrs[0] == 0)
            {
                throw new UnexpectedTestResultException("CheckRevocation failed or had unexpected response.");
            }
        }
    }

    [StressTest, Owner("BenRan"), TestFrequency("Regression"), TestCasePriority(2)]
    public class StressCheckRevocationSingleTuple : TestNode
    {
        private static String DummyDigestString;
        private static Byte[] DummyDigest;
        private ContentTuple contentTuple;

        public override void OneTimeSetup()
        {
            DummyDigestString = RandomEx.GlobalRandGen.GenerateHexString(40);
            DummyDigest = Hexer.unhex(DummyDigestString);

            contentTuple = new ContentTuple();
            contentTuple.TitleId = 0x4D5307E6;
            contentTuple.TitleVersion = 2;
            contentTuple.ConsolePuid = 286230209;
            contentTuple.ConsoleId = new byte[5];
            contentTuple.UserPuid[0] = 286230209;
            contentTuple.Digest = DummyDigest;
        }

        public override void Run()
        {
            XRLCheckRevocation req = new XRLCheckRevocation(1);
            req.xAct.SendTimeOut = 2;
            req.xAct.ReceiveTimeOut = 2;
            req.Request.Tuples[0] = contentTuple;

            if (!req.Execute() || req.Response.Hrs[0] != 0)
            {
                throw new UnexpectedTestResultException("CheckRevocation failed or had unexpected response.");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\XSig\SigUtils.cs ===
﻿using System;
using System.IO;
using System.Security.Cryptography;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;

namespace SigTest.XSig
{
    public class Utils
    {
        public static bool CheckRevocationSendAndVerify(XRLCheckRevocation req, uint[] ExpectedHrs)
        {
            if (!req.Execute())
            {
                Global.RO.Error("Failed to send CheckRevocation request ");
                return false;
            }

            uint actualHrsLen = req.Response.NumHrs;
            if (actualHrsLen != ExpectedHrs.Length)
            {
                Global.RO.Error("The number of hr returned is wrong Expected:{0} Returned:{1}", ExpectedHrs.Length, actualHrsLen);
                return false;
            }

            for (int i = 0; i < actualHrsLen; i++)
            {
                if (req.Response.Hrs[i] != ExpectedHrs[i])
                {
                    string errStr = Global.XErrToString(req.Response.Hrs[i]);
                    string expectedErr = Global.XErrToString(ExpectedHrs[i]);
                    Global.RO.Error("Value Mismatch. Expected: {0} Got: {1}", expectedErr, errStr);
                    return false;
                }
                else
                {
                    Global.RO.Success("Verified hr[{0}] {1}", i, Global.XErrToString(req.Response.Hrs[i]));
                }
            }
            return true;
        }

        public static bool CheckRevocationTestNegative(XRLCheckRevocation req, uint XErr)
        {
            if (req.Execute())
            {
                Global.RO.Warn("Negative checkRevocation request succeed! Expected: {0}", Global.XErrToString(XErr));
                return false;
            }
            if (req.XErr != XErr)
            {
                Global.RO.Warn("Wrong error code. Expected: {0}, Got: {1}", Global.XErrToString(XErr), Global.XErrToString(req.XErr));
                return false;
            }
            return true;
        }

        public static void ReloadBlacklist()
        {
            //
            // Calling these individually is much faster for some reason
            //
            Global.XEnv.ExecuteXmgmtCommand(Interface.xsig, "e :xsig machineload");
            Global.XEnv.ExecuteXmgmtCommand(Interface.xsig, "e :xsig digestload");
            Global.XEnv.ExecuteXmgmtCommand(Interface.xsig, "e :xsig titleload");
            Global.XEnv.ExecuteXmgmtCommand(Interface.xsig, "e :xsig userload");
        }

        public static void GetSigningKeyVerify(XSigSignature sig) 
        {
            XSigSignature baseSig = new XSigSignature();
            baseSig.Initialize();
            GetSigningKeyVerify(sig, baseSig); 
        }
        
        public static void GetSigningKeyVerify(XSigSignature sig, XSigSignature inputSig)
        {
            ValueCheck.TestNotNull("SigningKey", sig);
            ValueCheck.Test("SignatureVersion", inputSig._signatureVersion, sig._signatureVersion);
            ValueCheck.Test("KeyVersion", inputSig._keyVersion, sig._keyVersion);
            ValueCheck.Test("ServiceId", inputSig._serviceId, sig._serviceId);
            ValueCheck.Test("Signature Time", new DateTime(inputSig._timeStamp), new DateTime(sig._timeStamp), TimeSpan.FromMinutes(5));
            ValueCheck.Test("TitleID", inputSig._authData._titleID, sig._authData._titleID);
            ValueCheck.Test("TitleVersion", inputSig._authData._titleVersion, sig._authData._titleVersion);
            ValueCheck.Test("MachinePuid", inputSig._authData._XboxID, sig._authData._XboxID);
            ValueCheck.Test("UserPuid1", inputSig._authData._userID1, sig._authData._userID1);
            ValueCheck.Test("UserPuid2", inputSig._authData._userID2, sig._authData._userID2);
            ValueCheck.Test("UserPuid3", inputSig._authData._userID3, sig._authData._userID3);
            ValueCheck.Test("UserPuid4", inputSig._authData._userID4, sig._authData._userID4);
            ValueCheck.Test("ReservedBytes", inputSig._reserved, sig._reserved);

            byte[] expectedSignature = sig.ComputeIntermediateSignature(Keys.SigMaster[0]);
            ValueCheck.Test("Signature", expectedSignature, sig._signature);
        }

        public static void SignOnBehalfVerify(XSigSignOnBehalfRequest[] reqs, XSigSignOnBehalfResponse[] resps)
        {
            ValueCheck.Test("Response count not equal to request count", reqs.Length, resps.Length);
            for (int i = 0; i < reqs.Length; i++)
            {
                SignOnBehalfVerify(reqs[i], resps[i]);
            }
        }

        public static void SignOnBehalfVerify(XSigSignOnBehalfRequest req, XSigSignOnBehalfResponse resp)
        {
            ValueCheck.TestHR("Unexpected Result", HResult.S_OK, resp._hresult);

            ValueCheck.Test("Sig version mismatch", 1, resp._signature._signatureVersion);
            ValueCheck.Test("Key version mismatch", 1, resp._signature._keyVersion);
            ValueCheck.Test("Service ID mismatch", req._serviceId, resp._signature._serviceId);

            // Get the difference between the current time and the signature timestamp
            ValueCheck.Test("Sig time is off by more than 5 minutes", DateTime.UtcNow, new DateTime(resp._signature._timeStamp), TimeSpan.FromMinutes(5));
            ValueCheck.Test("Title ID mismatch", resp._signature._authData._titleID, req._authData._titleID);
            ValueCheck.Test("Title version mismatch", resp._signature._authData._titleVersion, req._authData._titleVersion);
            ValueCheck.Test("Machine Puid mismatch", resp._signature._authData._XboxID, req._authData._XboxID);

            ValueCheck.TestAll("User Puid mismatch",
                new UInt64[] {
                    req._authData._userID1,
                    req._authData._userID2,
                    req._authData._userID3,
                    req._authData._userID4
                },
                new UInt64[] {
                    resp._signature._authData._userID1,
                    resp._signature._authData._userID2,
                    resp._signature._authData._userID3,
                    resp._signature._authData._userID4
                });

            for (int i = 0; i < 16; i++)
            {
                ValueCheck.TestZero("Reserved bytes not all zero", resp._signature._reserved[i]);
            }

            byte[] iSigKey = ComputeIntermediateSignature(resp._signature, Keys.SigMaster[0]);
            byte[] expectedSignature = ComputeHash(req._digest, iSigKey);
            for (int i = 0; i < 20; i++)
            {
                ValueCheck.Test("Incorrect signature.", expectedSignature, resp._signature._signature);
            }
        }

        public static Byte[] ComputeIntermediateSignature(XSigSignature sig, Byte[] key)
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter wr = new BinaryWriter(ms);

            wr.Write(sig._serviceId);
            wr.Write(sig._timeStamp);
            wr.Write(sig._authData._titleID);
            wr.Write(sig._authData._titleVersion);
            wr.Write(sig._authData._XboxID);
            wr.Write(sig._authData._userID1);
            wr.Write(sig._authData._userID2);
            wr.Write(sig._authData._userID3);
            wr.Write(sig._authData._userID4);

            return ComputeHash(ms.ToArray(), key);
        }

        public static Byte[] ComputeHash(Byte[] data, Byte[] key)
        {
            return new HMACSHA1(key).ComputeHash(data);
        }

        public static bool VerifySignedHeader(byte[] _header, uint _fileType, uint _fileSize, byte[] _hash)
        {
            bool valid = true;
            SignedHeader header = new SignedHeader();
            header.ReadBytes(_header);

            Global.RO.Debug("####[Signed Header Dump]####");
            Global.RO.Debug("-HeaderVersion:  {0}", header.headerVersion);
            Global.RO.Debug("-HeaderSize:     {0}", header.headerSize);
            Global.RO.Debug("-SignedDateTime: {0}", header.signedDateTime);   
            Global.RO.Debug("-Flags:          0x{0:X8}", header.flags);
            Global.RO.Debug("-FileType:       0x{0:X8}", header.fileType);
            Global.RO.Debug("-FileSize:       {0}", header.fileSize);
            Global.RO.Debug("-Hash:           {0}", ServerTestFramework.Utilities.Hexer.tohex(header.fileHash));
            Global.RO.Debug("-Signature:      {0}", ServerTestFramework.Utilities.Hexer.tohex(header.signature).Substring(0, 64));

            if (header.fileType != _fileType)
            {
                Global.RO.Error("Filetype did not match requested. Requested: {0}, Returned: {1}", _fileType, header.fileType);
                valid = false;
            }

            if (header.headerVersion != 1)
            {
                Global.RO.Error("Header Version was not valid. Expected: 1 Returned: {0}", header.headerVersion);
                valid = false;
            }

            if (header.fileSize != _fileSize)
            {
                Global.RO.Error("Filesize did not match requested. Requested: {0}, Returned: {1}", _fileSize, header.fileSize);
                valid = false;
            }

            if (header.flags != 0 && header.flags != 0x80000000)
            {
                Global.RO.Error("Header Flags was not a valid value. Expected: 0 or 0x80000000 Returned: {0:x8)", header.flags);
                valid = false;
            }

            // Since you can pass null as the hash to getsignedheader, we need to check for that. 
            // right now wiredata automatically makes it 000000000000000000000
            if (_hash != null)
            {
                if (!ArrayEx.Equals(header.fileHash, _hash))
                {
                    Global.RO.Error("Hash in header did not match passed hash");
                    Global.RO.Error("Expected: \t{0}", ServerTestFramework.Utilities.Hexer.tohex(_hash));
                    Global.RO.Error("Actual: \t{0}", ServerTestFramework.Utilities.Hexer.tohex(header.fileHash));
                    valid = false;
                }
            }
            // 
            // Strip the signature out of the header so we can verify that it is correctly signed.
            //
            byte[] noSigHeader = new byte[_header.Length - live.protocol.SignedHeader.SIGNATURE_SIZE];
            Buffer.BlockCopy(_header, 0, noSigHeader, 0, noSigHeader.Length);

            if (!SignatureUtils.VerifySignature(noSigHeader, header.signature))
            {
                valid = false;
            }

            return valid;
        }
    }

    public class SignedHeader : xonline.common.service.WireData
    {
        public const int XONLINE_HEADER_HASH_SIZE = 20;
        public const int SIGNATURE_SIZE = 256;

        public UInt32 fileType;
        public uint headerVersion;
        public UInt32 headerSize;
        public DateTime signedDateTime;
        public UInt32 fileSize;
        public uint flags;

        [xonline.common.service.WireInfo(ArraySize = XONLINE_HEADER_HASH_SIZE)]
        public byte[] fileHash;

        [xonline.common.service.WireInfo(ArraySize = SIGNATURE_SIZE)]
        public byte[] signature;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\XSig\StressGetSigningKey.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.Signature;

namespace SigTest.XSig.Stress
{
    [StressTest, Owner("BenRan"), TestFrequency("Regression")]
    public class StressGetSigningKey : TestNode
    {
        public override void Run()
        {
            Utils.GetSigningKeyVerify(new XRLGetSigningKey().Execute());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\XSig\StressReloadXSig.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using xonline.common.config;
using ServerTestFramework.Utilities;

using SigTest;

namespace SigTest.XSig.Stress
{
    [StressTest, Owner("BenRan"), TestFrequency("Regression")]
	public class StressReloadXSig : TestNode
	{
		static private System.Text.ASCIIEncoding ascii = new System.Text.ASCIIEncoding();

		public override void Run()
		{
			Global.XEnv.ExecuteXmgmtCommand(Interface.xsig,"e :xsig ReloadKeys");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\XSig\StressCreateCertificate2.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.LiveService.Auth;
using System.Security.Cryptography.X509Certificates;

namespace SigTest.XSig.Stress
{
    [StressTest]
    public class StressCreateCertificate2 : TestNode
    {
        public static readonly String ConsoleId = "XE.029877704969";

        XmacsClient client;
        Byte[] rawConsoleCert;

        public override void PreRun()
        {
            CertHelper.ChainFlagsToIgnore = X509ChainStatusFlags.PartialChain;

            // Create a new Xenon Client
            client = SignatureUtils.CreateClient();
            // And then sign in with the same console id as the one in our hardcode certificate
            client.SignInXmacsWithConsoleID(ConsoleId);

            // Since the CreateCertificate2 API uses the real live Public Key to verify the console certificate
            // that we send up, the only way the call will succeed is if we have a real certificate that is signed
            // with the real key.  This hardcoded certificate and signatures comes from a devkit.  The first chunk 
            // (that ends at the ragged part) is the certificate, and the rest of it is the signature
            rawConsoleCert = new Byte[] {
                    0x01, 0xA8, 0x0B, 0x21, 0x5C, 0x28, 0x09, 0x58, 0x38, 0x31, 0x33, 0x39, 0x35, 0x33, 0x2D, 0x30, 
                    0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x31, 0x31, 0x2D, 0x31, 
                    0x34, 0x2D, 0x30, 0x37, 0x00, 0x01, 0x00, 0x01, 0xF4, 0xDE, 0x7B, 0x46, 0x97, 0x2F, 0x41, 0x4D, 
                    0xD3, 0xBD, 0xBC, 0xF1, 0xBC, 0x13, 0x78, 0x75, 0xD6, 0x3E, 0x49, 0x86, 0x82, 0xF3, 0xBF, 0x27, 
                    0x22, 0xB2, 0xC6, 0x02, 0x60, 0x3F, 0x80, 0x60, 0x0F, 0x64, 0xCC, 0x7B, 0x3C, 0x56, 0x4A, 0xDD, 
                    0xA5, 0x1C, 0xB9, 0x2E, 0x58, 0x03, 0x03, 0xCF, 0x46, 0x87, 0x8F, 0xA2, 0x2A, 0x52, 0xE7, 0xD9, 
                    0x21, 0x6C, 0x50, 0x14, 0xBD, 0x4B, 0x76, 0xA6, 0x8A, 0x6F, 0xC3, 0x16, 0xE1, 0x1F, 0xA3, 0x70, 
                    0xA0, 0xA0, 0xFF, 0xA6, 0x4C, 0x27, 0x4A, 0x38, 0xFD, 0xD8, 0xE1, 0x11, 0xFC, 0x56, 0x85, 0x02, 
                    0x47, 0x2B, 0x53, 0x99, 0xE4, 0x33, 0xC6, 0xDF, 0xA2, 0x24, 0xE6, 0x11, 0x11, 0x58, 0x92, 0xFF, 
                    0x29, 0x6E, 0xFC, 0x40, 0x42, 0x9A, 0x0A, 0xEA, 0x66, 0x3A, 0x1D, 0xD8, 0xAA, 0xC3, 0x44, 0xFE, 
                    0xC2, 0xEA, 0x28, 0xCC, 0xFD, 0x55, 0x8D, 0x2D, 
                    0xE8, 0xBE, 0x6D, 0xF6, 0xD8, 0xDD, 0x0A, 0x9B, 0xAE, 0x1C, 0x61, 0xCB, 0x1E, 0x0F, 0x60, 0x73, 
                    0x94, 0x02, 0xB2, 0xF7, 0x42, 0x91, 0x9D, 0x34, 0xEC, 0x93, 0xCD, 0xD8, 0xC7, 0xE6, 0xA3, 0x62, 
                    0x47, 0x6A, 0x11, 0x85, 0xF2, 0x89, 0xFE, 0x98, 0xCF, 0xC6, 0xB6, 0xDC, 0x03, 0xAD, 0x64, 0xC5, 
                    0x80, 0x83, 0x33, 0x7A, 0x46, 0x1A, 0x54, 0x45, 0xCC, 0x11, 0xD0, 0x2F, 0x96, 0x04, 0xE1, 0xD8, 
                    0x77, 0x67, 0x44, 0xB9, 0x59, 0x47, 0x2B, 0xD6, 0x0F, 0x7C, 0xE4, 0x51, 0xBE, 0x43, 0x68, 0xEE, 
                    0x61, 0xDF, 0x45, 0x52, 0x36, 0xE4, 0xB3, 0xCC, 0x5F, 0xD8, 0xDF, 0x26, 0x33, 0x32, 0x6F, 0x90, 
                    0x3C, 0xCE, 0x0A, 0xAC, 0x0B, 0xC9, 0xA7, 0xE3, 0x76, 0x8D, 0x4D, 0x9E, 0xCF, 0xF5, 0x27, 0x3E, 
                    0x9C, 0xF6, 0x86, 0xF0, 0x08, 0x10, 0x82, 0x0C, 0x64, 0xEA, 0x52, 0xC6, 0x57, 0xFE, 0x78, 0x4C, 
                    0x8F, 0x37, 0x9C, 0xA2, 0x19, 0xEB, 0x77, 0x80, 0x0D, 0x38, 0xBB, 0x54, 0xD5, 0xBF, 0x5B, 0x14, 
                    0x8C, 0xB2, 0xCB, 0x8A, 0xDE, 0x85, 0x51, 0x78, 0xB5, 0xE9, 0x9D, 0xD0, 0xB5, 0x3F, 0x6A, 0xB3, 
                    0xC2, 0xB5, 0xEA, 0xF0, 0x19, 0x33, 0xCD, 0x9E, 0x8E, 0xBD, 0xDF, 0xD7, 0x9C, 0xB2, 0x53, 0x13, 
                    0x34, 0xC3, 0xF9, 0x56, 0x19, 0x69, 0x5F, 0x91, 0xCE, 0x04, 0xFF, 0x7A, 0x8B, 0xAB, 0x14, 0xA9, 
                    0x5A, 0x6A, 0xE2, 0xDF, 0x8D, 0x81, 0x61, 0x69, 0xD3, 0x35, 0xF4, 0x4E, 0x4A, 0x40, 0xB9, 0x70, 
                    0x59, 0x60, 0xBC, 0xD6, 0x2B, 0x54, 0xDD, 0x81, 0xA3, 0x35, 0x38, 0x6F, 0x4E, 0xA9, 0x6D, 0x72, 
                    0xF2, 0x0C, 0xB5, 0xF6, 0x4E, 0x75, 0x00, 0xB5, 0x79, 0xE7, 0x99, 0x45, 0xDB, 0x06, 0xA4, 0x11, 
                    0x6A, 0xDC, 0x54, 0xAE, 0x17, 0x10, 0xAF, 0xAD, 0x3A, 0xE0, 0x64, 0x2C, 0x24, 0xBD, 0x26, 0x36, 
                };
        }

        public override void Run()
        {
            XRLCreateCertificate2 xrl = new XRLCreateCertificate2();
            xrl.Client = client;
            xrl.ConsoleCert.ReadBytes(rawConsoleCert);

            // Don't resign the certificate, it's already signed
            if (!xrl.Execute(false))
            {
                throw new UnexpectedTestResultException("CreateCertificate2 request failed: " + xrl.GetDumpString());
            }
        }
    }

    [StressTest]
    public class StressCreateCertificate2AndVerify : TestNode
    {
        public static readonly String ConsoleId = "XE.029877704969";

        XmacsClient client;
        Byte[] rawConsoleCert;

        public override void PreRun()
        {
            CertHelper.ChainFlagsToIgnore = X509ChainStatusFlags.PartialChain;

            // Create a new Xenon Client
            client = SignatureUtils.CreateClient();
            // And then sign in with the same console id as the one in our hardcode certificate
            client.SignInXmacsWithConsoleID(ConsoleId);

            // Since the CreateCertificate2 API uses the real live Public Key to verify the console certificate
            // that we send up, the only way the call will succeed is if we have a real certificate that is signed
            // with the real key.  This hardcoded certificate and signatures comes from a devkit.  The first chunk 
            // (that ends at the ragged part) is the certificate, and the rest of it is the signature
            rawConsoleCert = new Byte[] {
                    0x01, 0xA8, 0x0B, 0x21, 0x5C, 0x28, 0x09, 0x58, 0x38, 0x31, 0x33, 0x39, 0x35, 0x33, 0x2D, 0x30, 
                    0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x31, 0x31, 0x2D, 0x31, 
                    0x34, 0x2D, 0x30, 0x37, 0x00, 0x01, 0x00, 0x01, 0xF4, 0xDE, 0x7B, 0x46, 0x97, 0x2F, 0x41, 0x4D, 
                    0xD3, 0xBD, 0xBC, 0xF1, 0xBC, 0x13, 0x78, 0x75, 0xD6, 0x3E, 0x49, 0x86, 0x82, 0xF3, 0xBF, 0x27, 
                    0x22, 0xB2, 0xC6, 0x02, 0x60, 0x3F, 0x80, 0x60, 0x0F, 0x64, 0xCC, 0x7B, 0x3C, 0x56, 0x4A, 0xDD, 
                    0xA5, 0x1C, 0xB9, 0x2E, 0x58, 0x03, 0x03, 0xCF, 0x46, 0x87, 0x8F, 0xA2, 0x2A, 0x52, 0xE7, 0xD9, 
                    0x21, 0x6C, 0x50, 0x14, 0xBD, 0x4B, 0x76, 0xA6, 0x8A, 0x6F, 0xC3, 0x16, 0xE1, 0x1F, 0xA3, 0x70, 
                    0xA0, 0xA0, 0xFF, 0xA6, 0x4C, 0x27, 0x4A, 0x38, 0xFD, 0xD8, 0xE1, 0x11, 0xFC, 0x56, 0x85, 0x02, 
                    0x47, 0x2B, 0x53, 0x99, 0xE4, 0x33, 0xC6, 0xDF, 0xA2, 0x24, 0xE6, 0x11, 0x11, 0x58, 0x92, 0xFF, 
                    0x29, 0x6E, 0xFC, 0x40, 0x42, 0x9A, 0x0A, 0xEA, 0x66, 0x3A, 0x1D, 0xD8, 0xAA, 0xC3, 0x44, 0xFE, 
                    0xC2, 0xEA, 0x28, 0xCC, 0xFD, 0x55, 0x8D, 0x2D, 
                    0xE8, 0xBE, 0x6D, 0xF6, 0xD8, 0xDD, 0x0A, 0x9B, 0xAE, 0x1C, 0x61, 0xCB, 0x1E, 0x0F, 0x60, 0x73, 
                    0x94, 0x02, 0xB2, 0xF7, 0x42, 0x91, 0x9D, 0x34, 0xEC, 0x93, 0xCD, 0xD8, 0xC7, 0xE6, 0xA3, 0x62, 
                    0x47, 0x6A, 0x11, 0x85, 0xF2, 0x89, 0xFE, 0x98, 0xCF, 0xC6, 0xB6, 0xDC, 0x03, 0xAD, 0x64, 0xC5, 
                    0x80, 0x83, 0x33, 0x7A, 0x46, 0x1A, 0x54, 0x45, 0xCC, 0x11, 0xD0, 0x2F, 0x96, 0x04, 0xE1, 0xD8, 
                    0x77, 0x67, 0x44, 0xB9, 0x59, 0x47, 0x2B, 0xD6, 0x0F, 0x7C, 0xE4, 0x51, 0xBE, 0x43, 0x68, 0xEE, 
                    0x61, 0xDF, 0x45, 0x52, 0x36, 0xE4, 0xB3, 0xCC, 0x5F, 0xD8, 0xDF, 0x26, 0x33, 0x32, 0x6F, 0x90, 
                    0x3C, 0xCE, 0x0A, 0xAC, 0x0B, 0xC9, 0xA7, 0xE3, 0x76, 0x8D, 0x4D, 0x9E, 0xCF, 0xF5, 0x27, 0x3E, 
                    0x9C, 0xF6, 0x86, 0xF0, 0x08, 0x10, 0x82, 0x0C, 0x64, 0xEA, 0x52, 0xC6, 0x57, 0xFE, 0x78, 0x4C, 
                    0x8F, 0x37, 0x9C, 0xA2, 0x19, 0xEB, 0x77, 0x80, 0x0D, 0x38, 0xBB, 0x54, 0xD5, 0xBF, 0x5B, 0x14, 
                    0x8C, 0xB2, 0xCB, 0x8A, 0xDE, 0x85, 0x51, 0x78, 0xB5, 0xE9, 0x9D, 0xD0, 0xB5, 0x3F, 0x6A, 0xB3, 
                    0xC2, 0xB5, 0xEA, 0xF0, 0x19, 0x33, 0xCD, 0x9E, 0x8E, 0xBD, 0xDF, 0xD7, 0x9C, 0xB2, 0x53, 0x13, 
                    0x34, 0xC3, 0xF9, 0x56, 0x19, 0x69, 0x5F, 0x91, 0xCE, 0x04, 0xFF, 0x7A, 0x8B, 0xAB, 0x14, 0xA9, 
                    0x5A, 0x6A, 0xE2, 0xDF, 0x8D, 0x81, 0x61, 0x69, 0xD3, 0x35, 0xF4, 0x4E, 0x4A, 0x40, 0xB9, 0x70, 
                    0x59, 0x60, 0xBC, 0xD6, 0x2B, 0x54, 0xDD, 0x81, 0xA3, 0x35, 0x38, 0x6F, 0x4E, 0xA9, 0x6D, 0x72, 
                    0xF2, 0x0C, 0xB5, 0xF6, 0x4E, 0x75, 0x00, 0xB5, 0x79, 0xE7, 0x99, 0x45, 0xDB, 0x06, 0xA4, 0x11, 
                    0x6A, 0xDC, 0x54, 0xAE, 0x17, 0x10, 0xAF, 0xAD, 0x3A, 0xE0, 0x64, 0x2C, 0x24, 0xBD, 0x26, 0x36, 
                };
        }

        public override void Run()
        {
            XRLCreateCertificate2 xrl = new XRLCreateCertificate2();
            xrl.Client = client;
            xrl.ConsoleCert.ReadBytes(rawConsoleCert);

            // Don't resign the certificate, it's already signed
            if (!xrl.Execute(false))
            {
                throw new UnexpectedTestResultException("CreateCertificate2 request failed: " + xrl.GetDumpString());
            }

            SigTest.XSig.Functional.XSig.CreateCertificate2.ValidateResponse(xrl);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\XSig\StressSignOnBehalf.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.Utilities;
using xonline.common.protocol;

namespace SigTest.XSig.Stress
{
    [StressTest, Owner("BenRan"), TestFrequency("Regression")]
    public class StressSignOnBehalf : TestNode
    {
        public override void Run()
        {
            Int32 numReqs = RandomEx.GlobalRandGen.NextLog() + 1;

            XRLXSigSignOnBehalf signOnBehalf = new XRLXSigSignOnBehalf();
            signOnBehalf.Requests = new XSigSignOnBehalfRequest[numReqs];
            for (int i = 0; i < numReqs; i++)
            {
                Byte[] data = RandomEx.GlobalRandGen.GenerateRandomBlob(RandomEx.GlobalRandGen.Next(100));
                uint serviceID = (uint)RandomEx.GlobalRandGen.Next(1, (int)XOService.MaxService - 1);

                signOnBehalf.Requests[i] = XRLXSigSignOnBehalf.CreateSignRequest(serviceID, data);
                signOnBehalf.Requests[i]._authData._titleID = (uint)RandomEx.GlobalRandGen.Next();
                signOnBehalf.Requests[i]._authData._titleVersion = (uint)RandomEx.GlobalRandGen.Next();
                signOnBehalf.Requests[i]._authData._XboxID = RandomEx.GlobalRandGen.NextPuid();
                signOnBehalf.Requests[i]._authData._userID1 = RandomEx.GlobalRandGen.NextPuid();
                signOnBehalf.Requests[i]._authData._userID2 = RandomEx.GlobalRandGen.NextPuid();
                signOnBehalf.Requests[i]._authData._userID3 = RandomEx.GlobalRandGen.NextPuid();
                signOnBehalf.Requests[i]._authData._userID4 = RandomEx.GlobalRandGen.NextPuid();
            }

            if (!signOnBehalf.Execute())
            {
                throw new UnexpectedTestResultException("XSigSignOnBehalf request failed: " + signOnBehalf.GetDumpString());
            }

            Utils.SignOnBehalfVerify(signOnBehalf.Requests, signOnBehalf.Responses);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\XSig\StressGetAAInfo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.Database;
using System.Threading;

namespace SigTest.XSig.Stress
{
    [StressTest, Owner("Benran"), Description("Stress the GetAAInfo API")]
    public class StressGetAAInfo : TestNode
    {
        IUser[] users;
        public static int UserCount = 10;
        public int userIndex = 0;
        public Object indexLock = new Object();

        public override void PreRun()
        {
            users = new IUser[UserCount];

            for (int i = 0; i < UserCount; i++)
            {
                users[i] = TestHelper.GetSharedUser();
            }
        }

        public override void Run()
        {
            XRLGetAAInfo xrl = new XRLGetAAInfo();
            IUser user = users[userIndex];
            lock (indexLock)
            {
                userIndex = ++userIndex % UserCount;
            }

            if (!xrl.Execute(user.PassportPuid, 0))
            {
                throw new UnexpectedTestResultException("GetAAInfo request failed: " + xrl.GetDumpString());
            }
        }

        public override void PostRun()
        {
            foreach (var user in users)
            {
                TestHelper.ReturnSharedUser(user);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\XSig\StressVerifySignature.cs ===
using System;
using System.Linq;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.Utilities;


namespace SigTest.XSig.Stress
{
    [StressTest, Owner("BenRan"), TestFrequency("Regression")]
    public class StressVerifySignature : TestNode
    {
        // Make a request with an invalid signature 1% of the time
        public double FailureChance = 0.01;

        public override void Run()
        {
            // Pick a number of requests to make
            Int32 numReqs = RandomEx.GlobalRandGen.NextLog() + 1;
            XRLXSigVerifySignature xrl = new XRLXSigVerifySignature(numReqs);
            // We expect all successes by default
            UInt32[] expectedResults = new UInt32[numReqs];

            for (int i = 0; i < numReqs; i++)
            {
                xrl.Requests[i] = XRLXSigVerifySignature.CreateVerifyRequest(
                    RandomEx.GlobalRandGen.GenerateRandomBlob(20));

                if (RandomEx.GlobalRandGen.NextDouble() < FailureChance)
                {
                    // Just generate a completely random signature
                    xrl.Requests[i]._digest[RandomEx.GlobalRandGen.Next(20)]++;
                    expectedResults[i] = HResult.XONLINE_E_SIGNATURE_VER_INVALID_SIGNATURE;
                }
            }

            if (!xrl.Execute())
            {
                throw new UnexpectedTestResultException("VerifySignature request failed:" + xrl.GetDumpString());
            }

            // Ensure all the responses are as expected
            ValueCheck.TestAll("VerifySignature Repsonses", expectedResults, xrl.Responses.Select(r => r._hresult).ToArray());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\XSig\StressXSigner.cs ===
using System;
using System.Security.Cryptography;
using ServerTestFramework;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
using xonline.common.protocol;

namespace SigTest.XSig.Stress
{
    [TestGroup, Owner("BenRan"), TestFrequency("Regression")]
    public class StressXSigner : TestNode
    {
        [StressTest, Description("Stress GetSignedHeader with the XRL API")]
        public class GetSignedHeader : TestNode
        {
            XRLGetSignedHeader xrl;
            Byte[] fileHash;
            uint fileSize;
            uint fileType;

            public override void PreRun()
            {
                xrl = new XRLGetSignedHeader();

                fileSize = 1024;
                Byte[] file = RandomEx.GlobalRandGen.GenerateRandomBlob(1024);
                SHA1Managed sha1 = new SHA1Managed();
                fileHash = sha1.ComputeHash(file);

                fileType = GetSignedHeaderRequest.ONLY_LEGAL_FILE_TYPE;
            }

            public override void Run()
            {
                if (!xrl.Execute(fileHash, fileSize, fileType))
                {
                    throw new UnexpectedTestResultException("GetSignedHeader request failed: " + xrl.GetDumpString());
                }
            }
        }

        [StressTest, Description("Stress GetSignedHeader with the XRL API and verify the result")]
        public class GetSignedHeaderAndVerify : TestNode
        {
            XRLGetSignedHeader xrl;
            Byte[] fileHash;
            uint fileSize;
            uint fileType;

            public override void PreRun()
            {
                xrl = new XRLGetSignedHeader();

                fileSize = 1024;
                Byte[] file = RandomEx.GlobalRandGen.GenerateRandomBlob(1024);
                SHA1Managed sha1 = new SHA1Managed();
                fileHash = sha1.ComputeHash(file);

                fileType = GetSignedHeaderRequest.ONLY_LEGAL_FILE_TYPE;
            }

            public override void Run()
            {
                if (!xrl.Execute(fileHash, fileSize, fileType))
                {
                    throw new UnexpectedTestResultException("GetSignedHeader request failed: " + xrl.GetDumpString());
                }

                if (!Utils.VerifySignedHeader(xrl.Response.header, fileType, fileSize, fileHash))
                {
                    throw new UnexpectedTestResultException("VerifySignedHeader response validation failed");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\XSig\StressValidateCertificate.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.LiveService.Signature;
using System.Security.Cryptography.X509Certificates;

namespace SigTest.XSig.Stress
{
    [StressTest, Owner("BenRan"), Description("Stress ValidateCertificate")]
    public class StressValidateCertificate: TestNode
    {
        X509Certificate2 cert = null;

        public override void OneTimeSetup()
        {
            cert = new X509Certificate2(@"SuitesData\Signature\GTE_CyberTrust_Global_Root.cer");
        }

        public override void Run()
        {
            XRLValidateCertificate validateCertificate = new XRLValidateCertificate();
            validateCertificate.Certificate = cert;

            if (!validateCertificate.Execute())
            {
                throw new UnexpectedTestResultException("ValidateCertificate request failed: " + validateCertificate.GetDumpString());
            }
        }
    }

    [StressTest, Owner("BenRan"), Description("Stress ValidateCertificate")]
    public class StressValidateCertificateAndVerify : TestNode
    {
        X509Certificate2 cert = null;

        public override void OneTimeSetup()
        {
            cert = new X509Certificate2(@"SuitesData\Signature\GTE_CyberTrust_Global_Root.cer");
        }

        public override void Run()
        {
            XRLValidateCertificate validateCertificate = new XRLValidateCertificate();
            validateCertificate.Certificate = cert;

            if (!validateCertificate.Execute())
            {
                throw new UnexpectedTestResultException("ValidateCertificate request failed: " + validateCertificate.GetDumpString());
            }

            if(!validateCertificate.ValidateResponse())
            {
                throw new UnexpectedTestResultException("ValidateCertificate response validation failed.");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\XSig\ValidateCertificate.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.Utilities;

using xonline.common.config;
using xonline.common.service;

namespace SigTest.XSig.Functional
{
    //[TestGroup]
    public partial class XSig : TestNode
    {
        [TestGroup, Owner("BenRan"), TestFrequency("Regression")]
        [AsyncGroup(60, 6), AsyncThreadCount(5), AsyncThreadDelay(1000)]
        public class ValidateCertificate
        {
            // Certificate Information:
            // Notes: There are a bunch of different certificates that are used in this suite,
            // I'm attempting to provide a clear explanation of what each certificate is for
            //
            // GTE_CyberTrust_Global_Root - A valid certificate that should be trusted on nearly
            //     all machines everywhere for a long time.  This cert has no Key Usage extensions
            //     so it should pass any of the key usage tests that we have.  Bug?
            // www.mikestoolbox.org - This is a valid certificate that chains to a root cert that
            //     nobody is going to trust and the cert is valid for a long time.
            // XboxSSLDC_RevokedCert - Amazingly enough, this is a revoked cert.  This can only be 
            //     validated by a manual test, because the root cert needs to be installed on the
            //     machine and the CRL server needs to be accessible.  
            // XboxSSLDC_RootCert - This is a certificate which has key usage flags, but does not 
            //     have the required ones for Validate Certificate.  Though it doesn't chain to a
            //     valid root, that's okay, because the key usage is checked first.

            /// <summary>
            /// Execute a positive validate request with a specified certificate
            /// </summary>
            /// <param name="certPath">The file path to the certificate to load</param>
            public static void ExecutePositive(string certPath)
            {
                ExecutePositive(certPath, false, HResult.S_OK);
            }

            /// <summary>
            /// Execute a positive validate request with a specified certificate
            /// </summary>
            /// <param name="certPath">The file path to the certificate to load</param>
            /// <param name="checkExpired">If true, the cert expiration will be checked before the test executes</param>
            public static void ExecutePositive(string certPath, bool checkExpired)
            {
                ExecutePositive(certPath, checkExpired, HResult.S_OK);
            }

            /// <summary>
            /// Execute a positive validate request with a specified certificate
            /// </summary>
            /// <param name="certPath">The file path to the certificate to load</param>
            /// <param name="checkExpired">If true, the cert expiration will be checked before the test executes</param>
            /// <param name="expectedResult">The expected result from the ValidateCertificate call</param>
            public static void ExecutePositive(string certPath, bool checkExpired, uint expectedResult)
            {
                X509Certificate2 cert = null;

                try
                {
                    cert = new X509Certificate2(certPath);

                    // Lots of tests will fail because the certs are expired, so lets just validate that 
                    // here so we get some better failure data when they do actually expire.
                    if (checkExpired)
                    {
                        if (DateTime.UtcNow > cert.NotAfter)
                        {
                            throw new UnexpectedTestResultException(
                                String.Format("Certificate {0} is expired and needs to be current for test", certPath));
                        }
                    }
                }
                catch (IOException ioe)
                {
                    throw new UnexpectedTestResultException(
                        String.Format("Unable to load certificate from {0}\n{1}", certPath, ioe.ToString()));
                }
                catch (CryptographicException ce)
                {
                    throw new UnexpectedTestResultException(
                        String.Format("Certificate {0} was invalid\n{1}", certPath, ce.ToString()));
                }
                ExecutePositive(cert, checkExpired, expectedResult);
            }

            /// <summary>
            /// Execute a positive validate request with a specified certificate
            /// </summary>
            /// <param name="cert">The certificate to validate</param>
            /// <param name="checkExpired">If true, the cert expiration will be checked before the test executes</param>
            /// <param name="expectedResult">The expected result from the ValidateCertificate call</param>
            public static void ExecutePositive(X509Certificate2 cert, bool checkExpired, uint expectedResult)
            {
                XRLValidateCertificate xrl = new XRLValidateCertificate();

                if (!xrl.Execute(cert))
                {
                    throw new UnexpectedTestResultException("ValidateCertificate request failed.\n" + xrl.GetDumpString());
                }

                if (!xrl.ValidateResponse(expectedResult))
                {
                    throw new UnexpectedTestResultException("ValidateCertificate response was invalid");
                }
            }

            /// <summary>
            /// Execute a negative validate request with a given cert and expected result
            /// </summary>
            /// <param name="certPath">The file path to the certificate to load</param>
            /// <param name="expectedResult">The expected result from the ValidateCertificate call</param>
            public static void ExecuteNegative(string certPath, uint expectedResult)
            {
                X509Certificate2 cert = new X509Certificate2(certPath);
                ExecuteNegative(cert, expectedResult);
            }

            public static void ExecuteNegative(X509Certificate2 cert, uint expectedResult)
            {
                XRLValidateCertificate xrl = new XRLValidateCertificate();

                Global.RO.Info("Calling ValidateCertificate");

                // We expect the call to succeed because the certificate is well formed, but invalid
                if (!xrl.Execute(cert))
                {
                    throw new UnexpectedTestResultException("ValidateCertificate request failed: " + xrl.ErrorStatusMessage);
                }

                if (xrl.Response.hr != expectedResult)
                {
                    String msg = String.Format("ValidateCertificate returned unexpected result. Expected: 0x{0:X} Got: 0x{1:X}", expectedResult, xrl.Response.hr);
                    throw new UnexpectedTestResultException(msg);
                }
                else
                {
                    Global.RO.Info("Recieved expected error code: 0x{0:X}", xrl.Response.hr);
                }
            }

            [TestCase, TestCasePriority(1), Description("Attempt to validate a trusted certificate that should succeed")]
            public void P_BVT_ValidateCert()
            {
                Global.RO.Info("Validating GTE CyberTrust Global Root");
                // This is a trivial verification because it's a root certificate, but it's the 
                // easiest way to ensure the there will be no breaks in the cert chain and can 
                // also ensure that it's probably valid.  This cert is valid till 2018

                // NOTE: Is this test failing? CHECK THE CERT VALIDITY!
                ExecutePositive(@"SuitesData\Signature\GTE_CyberTrust_Global_Root.cer", true);
            }

            [TestCase, TestCasePriority(2), Description("Attempt to validate a revoked certificate and ensure it's rejected")]
            [EnvRequirement("Manual")]
            public void N_RevokedCertWithCrlUrl()
            {
                if (!String.Equals(Global.CurrentEnvironment.Environment, "xblob", StringComparison.InvariantCultureIgnoreCase))
                {
                    Global.RO.Warn("Current environment is not an Xblob.\nIt is likly that you will be unable to access the CRL server that revoked the certificate.");
                }

                // This certificate has been revoked so the cert check should fail.  The CRL server is 
                // located on the Xbox SSL Server so the client that is running the test must have 
                // XboxSSL set as one of it's DNS servers
                Global.RO.Info("Validating a revoked XboxSSL root certificate");
                ExecuteNegative(@"SuitesData\Signature\XboxSSLDC_RevokedCert.cer", HResult.XONLINE_E_SIGNATURE_CERTIFICATE_INVALID);

                Global.RO.Success("Successfully rejected a revoked certificate against CRL");
            }

            [TestCase, TestCasePriority(3), Description("Change the valid until minutes and ensure that the correct time is returned")]
            [AsyncGroup(0)]
            public void P_UseDifferentValidUntilTime()
            {
                Global.RO.Info("Changing Valid Until duration in database");
                string validUntilSettingName = "signature_validateCertificateValidUntilMinutes";
                ServerTestFramework.LiveService.SettingState validUntilSetting = null;

                try
                {
                    // Override the setting with some random different value
                    validUntilSetting = Global.XEnv.OverrideSetting("ALL", "ALL", validUntilSettingName, "9999", -1);
                    // Force a local update so that when we validate the cert, we're using the changed value (validation gets values from database)
                    Config.CheckForUpdates();

                    // Force a cache refresh on the server
                    String xmgmtText = String.Empty;
                    if (!ServerTestFramework.LiveService.ManagementConsole.ExecuteOnAllIISProcess(
                        Interface.xsig, "xsig", "xsig configcacherefresh", out xmgmtText))
                    {
                        throw new UnexpectedTestResultException("Unable to reload settings: " + xmgmtText);
                    }
                    // Do a normal request
                    ExecutePositive(@"SuitesData\Signature\GTE_CyberTrust_Global_Root.cer");
                }
                finally
                {
                    if (validUntilSetting != null)
                    {
                        // Restore the old setting
                        Global.XEnv.RestoreOverrideSettingState(validUntilSetting);

                        Config.CheckForUpdates();

                        // Force a cache refresh on the server
                        String xmgmtText = String.Empty;
                        if (!ServerTestFramework.LiveService.ManagementConsole.ExecuteOnAllIISProcess(
                            Interface.xsig, "xsig", "xsig configcacherefresh", out xmgmtText))
                        {
                            throw new UnexpectedTestResultException("Unable to reload settings: " + xmgmtText);
                        }
                    }
                }
            }

            [TestCase, TestCasePriority(2), Description("Attempt to validate a certificate, without the proper cert usage")]
            public void N_InvalidCertUsage()
            {
                Global.RO.Info("Validating a certificate with invalid cert usage flags (XboxSSLDC Root Cert)");
                ExecuteNegative(@"SuitesData\Signature\xboxssldc_RootCert.cer", HResult.XONLINE_E_SIGNATURE_CERTIFICATE_INVALID);
            }

            [TestCase, TestCasePriority(2), Description("Attempt to validate a certificate that doesn't chain to a valid root cert")]
            public void N_InvalidRootCert()
            {

                ExecuteNegative(@"SuitesData\Signature\www.mikestoolbox.org.cer", HResult.XONLINE_E_SIGNATURE_CERTIFICATE_INVALID);
            }

            [TestCase(137507), TestCasePriority(2), Description("Attempt to validate a certificate that has been corrupted")]
            public void N_InvalidCertificate()
            {
                Global.RO.Info("Corrupting certificate and making request.");
                for (int iterations = 0; iterations < 50; iterations++)
                {
                    XRLValidateCertificate xrl = new XRLValidateCertificate();
                    X509Certificate2 cert = new X509Certificate2(@"SuitesData\Signature\GTE_CyberTrust_Global_Root.cer");
                    xrl.Certificate = cert;

                    for (int i = 0; i < 20; i++)
                    {
                        xrl.RawCertificate[RandomEx.GlobalRandGen.Next(xrl.RawCertificate.Length)] = (byte)RandomEx.GlobalRandGen.Next(Byte.MaxValue);
                    }

                    if (!xrl.Execute())
                    {
                        // This means we have a more serious problem, so don't keep going.
                        throw new UnexpectedTestResultException("Call failed when it was expected to succeed:" + xrl.ErrorStatusMessage);
                    }

                    if (xrl.Response.hr != HResult.XONLINE_E_SIGNATURE_CERTIFICATE_INVALID)
                    {
                        if (xrl.Response.hr == HResult.S_OK)
                        {
                            Global.RO.Error("Corrupted cert was successfully validated.  Saved out to: 'CorruptCert.cer'");
                            Global.RO.Info(xrl.Certificate.ToString());
                            System.IO.File.WriteAllBytes(@".\CorruptCert.cer", xrl.RawCertificate);
                        }

                        throw new UnexpectedTestResultException(
                            String.Format("Invalid Response returned for corrupted certificate. Expected: {0:X}, Got: {1:X}",
                            HResult.XONLINE_E_SIGNATURE_CERTIFICATE_INVALID, xrl.Response.hr));
                    }
                }
            }

            [TestCase(64057, BugDatabase="ISS All"), TestCasePriority(2)]
            public void P_LargeCertificate_LessThan12K()
            {
                Global.RO.Info("Generating a large certificate");
                CertificateGenerator gen = new CertificateGenerator("CN=LargeCertificateLessThan12K");

                // Add a bunch of data to the certificate (10Kish)
                Byte[] extData = RandomEx.GlobalRandGen.GenerateRandomBlob(10 * 1024);
                gen.AddExtension("2.13.61.4.4.26.12.114.2", false, extData);

                X509Certificate2 cert = gen.Generate();

                ExecuteNegative(cert, HResult.XONLINE_E_SIGNATURE_CERTIFICATE_INVALID);
            }

            [TestCase(64057, BugDatabase="ISS All"), TestCasePriority(3)]
            public void N_LargeCertificate_GreaterThan12K()
            {
                Global.RO.Info("Generating a large certificate");
                CertificateGenerator gen = new CertificateGenerator("CN=LargeCertificateGreaterThan12K");

                // Add a bunch of data to the certificate (12Kish)
                Byte[] extData = RandomEx.GlobalRandGen.GenerateRandomBlob(12 * 1024);
                gen.AddExtension("2.13.61.4.4.26.12.114.2", false, extData);

                X509Certificate2 cert = gen.Generate();

                ExecuteNegative(cert, HResult.XONLINE_E_SIGNATURE_VALIDATE_CERTIFICATE_ERROR);
            }
        }

        /*
        public class CertificateGeneratorHelper
        {
            public AsymmetricCipherKeyPair KeyPair { get; set; }
            public X509V3CertificateGenerator Generator { get; set; }

            public CertificateGeneratorHelper(String subject) : this(subject, 1024) { }

            public CertificateGeneratorHelper(String subject, Int32 keySize)
            {
                KeyPair = CreateKeyPair(keySize);
                Generator = CreateGenerator(subject, KeyPair);
            }

            public X509Certificate2 Generate()
            {
                return Generate("XSig Test Certificate");
            }

            public X509Certificate2 Generate(String friendlyName)
            {
                return ConvertToWindows(Generator.Generate(KeyPair.Private), KeyPair, friendlyName);
            }
            
            public static AsymmetricCipherKeyPair CreateKeyPair(Int32 keySize)
            {
                RsaKeyPairGenerator keyGen = new RsaKeyPairGenerator();
                keyGen.Init(
                    new KeyGenerationParameters(
                        new SecureRandom(new CryptoApiRandomGenerator()),
                        2048));

                return keyGen.GenerateKeyPair();
            }

            public static X509V3CertificateGenerator CreateGenerator(String subject, AsymmetricCipherKeyPair keyPair)
            {
                X509Name name = new X509Name(subject);

                X509V3CertificateGenerator gen = new X509V3CertificateGenerator();

                gen.SetSubjectDN(name);
                gen.SetIssuerDN(name);
                gen.SetSerialNumber(BigInteger.ProbablePrime(120, new Random()));
                gen.SetNotBefore(DateTime.UtcNow.AddDays(-1));
                gen.SetNotAfter(DateTime.UtcNow.AddYears(1));
                gen.SetSignatureAlgorithm("SHA1WithRSA");
                gen.SetPublicKey(keyPair.Public);

                // Add a key usage extension
                gen.AddExtension(X509Extensions.ExtendedKeyUsage.Id, false,
                        new ExtendedKeyUsage(KeyPurposeID.IdKPServerAuth, KeyPurposeID.IdKPClientAuth));

                return gen;
            }

            public static X509Certificate2 ConvertToWindows(Org.BouncyCastle.X509.X509Certificate newCert, AsymmetricCipherKeyPair kp, String friendlyName)
            {
                var tempStorePwd = "XblRocks!";

                var tempStore = new Pkcs12Store();
                var certEntry = new X509CertificateEntry(newCert);

                // Store the certificate and key in the temp store
                tempStore.SetCertificateEntry(friendlyName, certEntry);
                tempStore.SetKeyEntry(friendlyName, new AsymmetricKeyEntry(kp.Private), new[] { certEntry });

                // Write out the cert store to a memory stream
                using (var s = new MemoryStream())
                {
                    tempStore.Save(s, tempStorePwd.ToCharArray(), new SecureRandom(new CryptoApiRandomGenerator()));

                    // Then read the memory stream back into a .NET X509Certificate2
                    return new X509Certificate2(s.GetBuffer(), tempStorePwd, X509KeyStorageFlags.Exportable);
                }
            }
        }
        */
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\XSig\XSigner.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.Billing.WebBilling;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Signature;
using xonline.common.protocol;
using xonline.common.service;

namespace SigTest.XSig.Functional
{
    [TestGroup]
    [AsyncGroup(6, 1), AsyncThreadCount(10), AsyncThreadDelay(1000)]
    public partial class XSig : TestNode
    {
        [TestGroup, Owner("BenRan"), TestFrequency("Regression")]
        public class XSigner : TestNode
        {
            [TestCase, TestCasePriority(1), Description("GetSignedHeader BVT. Generates a random blob(file) and requests that it gets signed.")]
            public class BVT : TestNode
            {
                public override void Run()
                {
                    XRLGetSignedHeader xrl = new XRLGetSignedHeader();

                    if (!xrl.Execute())
                    {
                        throw new UnexpectedTestResultException("GetSignedHeader Request failed: " + xrl.GetDumpString());
                    }

                    if (!Utils.VerifySignedHeader(xrl.Response.header, xrl.Request.fileType, xrl.Request.fileSize, xrl.Request.fileHash))
                    {
                        throw new UnexpectedTestResultException("Verification of SignedHeader response failed");
                    }
                }
            }

            [TestCase, TestCasePriority(2), Description("Sends a random file type")]
            public class P_Random_FileType : TestNode
            {
                public override void Run()
                {
                    XRLGetSignedHeader xrl = new XRLGetSignedHeader();

                    Byte[] hash = RandomEx.GlobalRandGen.GenerateRandomBlob(GetSignedHeaderRequest.XONLINE_HEADER_HASH_SIZE);
                    UInt32 fileType = (UInt32)RandomEx.GlobalRandGen.Next(UInt32.MaxValue);

                    if (!xrl.Execute(hash, 1024, fileType))
                    {
                        throw new UnexpectedTestResultException("GetSignedHeader Request failed: " + xrl.GetDumpString());
                    }

                    if (!Utils.VerifySignedHeader(xrl.Response.header, xrl.Request.fileType, xrl.Request.fileSize, xrl.Request.fileHash))
                    {
                        throw new UnexpectedTestResultException("Verification of SignedHeader response failed");
                    }
                }
            }

            [TestCase, TestCasePriority(3), Description("Sends NULL hash to GetSignedHeader")]
            //[Ignore("The XRL currently automatically writes an array of the correct length to the stream")]
            public class P_Null_Hash : TestNode
            {
                public override void Run()
                {
                    XRLGetSignedHeader xrl = new XRLGetSignedHeader();

                    if (!xrl.Execute(null, 1024))
                    {
                        throw new UnexpectedTestResultException("GetSignedHeader Request failed: " + xrl.GetDumpString());
                    }

                    if (!Utils.VerifySignedHeader(xrl.Response.header, xrl.Request.fileType, xrl.Request.fileSize, xrl.Request.fileHash))
                    {
                        throw new UnexpectedTestResultException("Verification of SignedHeader response failed");
                    }
                }
            }

            [TestCase, TestCasePriority(2), Description("Sends Empty Byte Array to GetSignedHeader")]
            public class P_Empty_Hash : TestNode
            {
                public override void Run()
                {
                    XRLGetSignedHeader xrl = new XRLGetSignedHeader();

                    if (!xrl.Execute(new Byte[20], 1024))
                    {
                        throw new UnexpectedTestResultException("GetSignedHeader Request failed: " + xrl.GetDumpString());
                    }

                    if (!Utils.VerifySignedHeader(xrl.Response.header, xrl.Request.fileType, xrl.Request.fileSize, xrl.Request.fileHash))
                    {
                        throw new UnexpectedTestResultException("Verification of SignedHeader response failed");
                    }
                }
            }

            [TestCase, TestCasePriority(2), Description("Bad File Size of 0")]
            public class N_Invalid_File_Size : TestNode
            {
                public override void Run()
                {
                    XRLGetSignedHeader xrl = new XRLGetSignedHeader();
                    Byte[] hash = RandomEx.GlobalRandGen.GenerateRandomBlob(GetSignedHeaderRequest.XONLINE_HEADER_HASH_SIZE);

                    if (xrl.Execute(hash, 0))
                    {
                        throw new UnexpectedTestResultException("GetSignedHeader Request succeded with invalid filesize");
                    }

                    if (xrl.XErr != HResult.XONLINE_E_SIGNATURE_GET_SIGNED_HEADER_ERROR)
                    {
                        throw new UnexpectedTestResultException("GetSignedHeader Request returned unexpected error: " + xrl.GetDumpString());
                    }
                }
            }

            [TestCase, TestCasePriority(2), Description("Invalid Hash Inputs"), Ignore("Right now we can't pass an improper length hash")]
            public class N_Invalid_Hash : TestNode
            {
                public override void Run()
                {
                    XRLGetSignedHeader xrl = new XRLGetSignedHeader();
                    int failures = 0;
                    
                    // 
                    // Zero
                    //
                    Byte[] hash = { 0 };

                    if (!xrl.Execute(hash, 1024))
                    {
                        Global.RO.Success("GetSignedHeader falied as expected");
                        Global.RO.Success(xrl.GetDumpString());
                        failures++;
                    }
                    else
                    {
                        Global.RO.Error("GetSignedHeader succeeded with zero hash");
                    }

                    //
                    // Bad Size
                    //
                    hash = new byte[] { 0xFF, 0xFF, 0xFF };

                    if (!xrl.Execute(hash, 1024))
                    {
                        Global.RO.Success("GetSignedHeader falied as expected");
                        Global.RO.Success(xrl.GetDumpString());
                        failures++;
                    }
                    else
                    {
                        Global.RO.Error("GetSignedHeader succeeded with wrong length hash");
                    }

                    //
                    // Too long
                    //
                    hash = RandomEx.GlobalRandGen.GenerateRandomBlob(GetSignedHeaderRequest.XONLINE_HEADER_HASH_SIZE + 1);

                    if (!xrl.Execute(hash, 1024))
                    {
                        Global.RO.Success("GetSignedHeader falied as expected");
                        Global.RO.Success(xrl.GetDumpString());
                        failures++;
                    }
                    else
                    {
                        Global.RO.Error("GetSignedHeader succeeded with hash that was too long");
                    }

                    if (failures < 3)
                    {
                        throw new UnexpectedTestResultException("GetSignedHeader did not failed expected number of times.");
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\SocialCache\inh\Engine.cs ===
using System;
using System.Threading;
using System.Diagnostics;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.community.socialquery.protocol;

namespace xonline.server.SocialCache
{
    public enum ThreadType : ushort
    {
        eWorker,
        eData
    }

    public abstract class SocialCacheContext
    {
        public ThreadType m_threadType;
        public XomRequestTimeElapsed m_waitTime = null;
        
        public void ProcessContext(Object state)
        {
            SocialCacheEngineCounters.Total.WaitTimeAvg.IncrementBy(m_waitTime.TimeElapsed);
            SocialCacheEngineCounters.Total.WaitTimeAvgBase.Increment();
            SocialCacheEngineCounters.Total[this.ToString()].WaitTimeAvg.IncrementBy(m_waitTime.TimeElapsed);
            SocialCacheEngineCounters.Total[this.ToString()].WaitTimeAvgBase.Increment();

            XomRequestTimeElapsed executionTime = new XomRequestTimeElapsed();
            
            try
            {
                ProcessInternal(state);
            }
            catch (Exception e)
            {
              Xom.NtEvent(XEvent.Id.SOCIALCACHE_CONTEXT_EXCEPTION, e, "Unhandled exception while processing context.");
            }

            SocialCacheEngineCounters.Total.CompletionRate.Increment();
            SocialCacheEngineCounters.Total[this.ToString()].CompletionRate.Increment();
            SocialCacheEngineCounters.Total.ExecutionTimeAvg.IncrementBy(executionTime.TimeElapsed);
            SocialCacheEngineCounters.Total.ExecutionTimeAvgBase.Increment();
            SocialCacheEngineCounters.Total[this.ToString()].ExecutionTimeAvg.IncrementBy(executionTime.TimeElapsed);
            SocialCacheEngineCounters.Total[this.ToString()].ExecutionTimeAvgBase.Increment();
        }
        
        public abstract void ProcessInternal(Object state);
    };

    class SocialCacheEngine
    {                
        // custom thread pool for "worker" threads.  these threads access shared memory and do not block on i/o.
        private static FastThreadPool s_tpWorker;
        private static FastThreadPool s_tpData;
        private static LockFreeStack<byte[]> s_lfsBufferPool;

        private static int BYTES_PER_POOLED_BUFFER;

        public static void Init()
        {
            int cDataThreads = Config.GetIntSetting(Setting.SocialCache_DataThreadpoolSize);
            s_tpWorker = new FastThreadPool("socialcache - worker", Environment.ProcessorCount, ThreadPriority.AboveNormal);
            s_tpData = new FastThreadPool("socialcache - data", cDataThreads, ThreadPriority.Normal);
            s_lfsBufferPool = new LockFreeStack<byte[]>();
            BYTES_PER_POOLED_BUFFER = Config.GetIntSetting(Setting.SocialCache_BytesPerPooledBuffer);
        }

        public static void Shutdown()
        {
            s_tpWorker.Shutdown();
        }
        
        public unsafe static int ConsumeUserRequestBytes(byte[] rgbBuffer, int cBytesAvailable, ClientConnection cliConn)
        {
            int dwConsumed = 0;
            UserRequestContext reqCtx = cliConn.m_ctxPending;

            // check for an existing context to fill in.
            if (reqCtx != null)
            {
                // we're continuing a message in progress.
                int cbToWrite = Math.Min(cBytesAvailable, reqCtx.m_rgbEntireMessage.Length - reqCtx.m_dwWriteOffset);
                System.Buffer.BlockCopy(rgbBuffer, 0, reqCtx.m_rgbEntireMessage, reqCtx.m_dwWriteOffset, cbToWrite);
                reqCtx.m_dwWriteOffset += cbToWrite;
                cBytesAvailable -= cbToWrite;
                dwConsumed += cbToWrite;

                if (reqCtx.m_dwWriteOffset == reqCtx.m_rgbEntireMessage.Length)
                {
                    // we've got all the bytes, queue the message.
                    cliConn.m_ctxPending = null;
                    SocialCacheEngine.QueueContext(ThreadType.eWorker, reqCtx, null);
                }
            }

            // try to parse the message size.
            while (cBytesAvailable >= sizeof(SOCIALCACHE_BASE_MESSAGE_HEADER))
            {
                int dwMessageSize = 0;

                fixed (byte *pBuffer = &(rgbBuffer[dwConsumed]))
                {
                    SOCIALCACHE_BASE_MESSAGE_HEADER *pHeader = (SOCIALCACHE_BASE_MESSAGE_HEADER *)pBuffer;
                    dwMessageSize = (int)pHeader->dwTotalSize;
                }

                if (dwMessageSize >= Config.GetIntSetting(Setting.SocialCache_MaxMessageBytes))
                {
                    // message is too big to receive.  this shouldnt happen.
                    string sError = "Invalid message received from: " + cliConn.IPAddress + ".  Size (" + dwMessageSize + ") > " + 
                        Config.GetIntSetting(Setting.SocialCache_MaxMessageBytes) + ".";
                    Xom.NtEvent(XEvent.Id.SOCIALCACHE_MSG_TOO_BIG, sError);
                    throw new ApplicationException(sError);
                }

                // make a new context.
                reqCtx = new UserRequestContext(cliConn);
                reqCtx.m_rgbEntireMessage = new byte[dwMessageSize];

                int cbToWrite = Math.Min(cBytesAvailable, dwMessageSize);
                System.Buffer.BlockCopy(rgbBuffer, dwConsumed, reqCtx.m_rgbEntireMessage, 0, cbToWrite);
                reqCtx.m_dwWriteOffset += cbToWrite;
                cBytesAvailable -= cbToWrite;
                dwConsumed += cbToWrite;

                if (reqCtx.m_dwWriteOffset == dwMessageSize)
                {
                    // we've got all the bytes, queue the message.
                    SocialCacheEngine.QueueContext(ThreadType.eWorker, reqCtx, null);

                    SocialCacheNetworkCounters.Total["Client"].RequestRate.Increment();
                    SocialCacheNetworkCounters.Total.RequestRate.Increment();
                }
                else
                {
                    // don't have enough for this message.  hang onto it.
                    cliConn.m_ctxPending = reqCtx;
                    break;
                }
            }

            return dwConsumed;
        }
        
        public static void QueueContext(ThreadType threadType, SocialCacheContext ctx, Object state)
        {
            ctx.m_threadType = threadType;
            ctx.m_waitTime = new XomRequestTimeElapsed();
            
            switch (threadType)
            {
            case ThreadType.eWorker:
                s_tpWorker.QueueUserWorkItem(new WaitCallback(ctx.ProcessContext), state);
                break;
                
            case ThreadType.eData:
            default:
                s_tpData.QueueUserWorkItem(new WaitCallback(ctx.ProcessContext), state);
                break;
            }
        }

        public static byte[] GetSendBuffer(int cbSize)
        {
            if (cbSize > BYTES_PER_POOLED_BUFFER)
            {
                return new byte[cbSize];
            }
            
            byte[] rgbBuffer = s_lfsBufferPool.Pop();
            if (rgbBuffer == null)
            {
                rgbBuffer = new byte[BYTES_PER_POOLED_BUFFER];
                SocialCacheCounters.Current.TotalSendBuffers.Increment();
            }
            else
            {
                SocialCacheCounters.Current.FreeSendBuffers.Decrement();
            }

            return rgbBuffer;
        }

        public static void ReturnSendBuffer(byte[] rgbBuffer)
        {
            if (rgbBuffer.Length == BYTES_PER_POOLED_BUFFER)
            {
                s_lfsBufferPool.Push(rgbBuffer);
                SocialCacheCounters.Current.FreeSendBuffers.Increment();
            }
        }
    };

    [XomPerformanceCounterCategoryAttr("Social Cache - Engine", "Xbox Live Social Cache Server Per Context Type Counters")]
    public class SocialCacheEngineCounters : XomPerformanceCounterCategory
    {
        public SocialCacheEngineCounters()
            : base(true)
        {
        }

        public virtual SocialCacheEngineCounters this[string sType]
        {
            get
            {
                return (SocialCacheEngineCounters)GetInstance(sType);
            }
        }

        static public SocialCacheEngineCounters Total = new SocialCacheEngineCounters();

        [XomPerformanceCounterAttr(
            "Completion Rate",
            "Total number of all contexts per second processed by the server.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CompletionRate;

        [XomPerformanceCounterAttr(
            "Context Execution Time (ms)",
            "Average time (in milliseconds) a context takes to execute.",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter ExecutionTimeAvg;

        [XomPerformanceCounterAttr(
            "Average Execution Time Base",
            "Average time (in milliseconds) a context takes to execute.",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter ExecutionTimeAvgBase;

        [XomPerformanceCounterAttr(
            "Context Wait Time (ms)",
            "Average time (in milliseconds) a context waits to be processed.",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter WaitTimeAvg;

        [XomPerformanceCounterAttr(
            "Average Wait Time Base",
            "Average time (in milliseconds) a context waits to be processed.",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter WaitTimeAvgBase;
    }

    // There will be one instance per type of network connection to measure overall traffic between this server and each component it's
    // connected to.
    // For example:
    //  an instance for incoming connection from front doors to measure query bandwidth
    //  an instance for connection to acceleration, measuring presence lookup bandwidth
    // It will not be broken down per machine or per socket. This is an aggregate category to measure overall traffic.
    [XomPerformanceCounterCategoryAttr("Social Cache - Network", "Xbox Live Social Cache Server Per Network Connection Type Counters")]
    public class SocialCacheNetworkCounters : XomPerformanceCounterCategory
    {
        public SocialCacheNetworkCounters()
            : base(true)
        {
        }

        public virtual SocialCacheNetworkCounters this[string sType]
        {
            get
            {
                return (SocialCacheNetworkCounters)GetInstance(sType);
            }
        }

        static public SocialCacheNetworkCounters Total = new SocialCacheNetworkCounters();

        [XomPerformanceCounterAttr(
            "Request Rate",
            "Total number of network requests processed for this type of network connection per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestRate;

        [XomPerformanceCounterAttr(
            "Bytes Received/sec",
            "Total number of bytes received by this type of network connection per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ByteReadRate;

        [XomPerformanceCounterAttr(
            "Bytes Sent/sec",
            "Total number of bytes sent to this type of network connection per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ByteWriteRate;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\SocialCache\inh\Connection.cs ===
using System;

using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.ServiceProcess;
using System.Net;
using System.Net.Sockets;
using System.Text;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;

using System.Threading;
using xonline.common.config;

using MS.Msn.Messenger.Runtime; 


namespace xonline.server.SocialCache
{
    public class ClientConnection
    {
        private TcpStream m_stream = null;

        private int m_cbReceiveBuffer = 0;
        private byte[] m_rgbReceive = null;
        private int m_cbReadUsed = 0;
        private bool m_fDisconnectTriggered = false;
        private int m_cPendingSends = 0;

        public UserRequestContext m_ctxPending;

        private string m_ipAddress = null;
        public string IPAddress
        {
            get 
            {
                if (m_ipAddress == null)
                {
                    try
                    {
                        m_ipAddress = m_stream.IPAddress.ToString() + ":" + m_stream.Port.ToString();
                    }
                    catch (Exception)
                    {
                        m_ipAddress = null;
                    }
                }
                return m_ipAddress;
            }
        }

        public uint IPAddressDword
        {
            get
            {
                try
                {
                    return (uint)System.Net.IPAddress.NetworkToHostOrder((int)ConfigUtil.IpAddressToDword(m_stream.IPAddress));
                }
                catch (Exception)
                {
                    return 0;
                }
            }
        }
        public ushort IPPort
        {
            get
            {
                try
                {
                    return m_stream.Port;
                }
                catch (Exception)
                {
                    return 0;
                }
            }
        }

        private int m_dwNotificationSeqNum;
        public uint NotificationSequenceNumber
        {
            get
            {
                return (uint)Interlocked.Increment(ref m_dwNotificationSeqNum);
            }
        }

        ClientConnection(TcpStream stream)
        {
            m_stream = stream;
            m_cbReceiveBuffer = 2 * Config.GetIntSetting(Setting.SocialCache_SocketBufferSize);
            m_rgbReceive = new byte[m_cbReceiveBuffer];
        }
        
        public static void OnConnect(Object sender, TcpStream stream)
        {
            ClientConnection newClient = new ClientConnection(stream);
            stream.Disconnected += newClient.OnDisconnect;
            
            IAsyncResult arRead = stream.BeginRead(
                newClient.m_rgbReceive, 
                0, 
                newClient.m_cbReceiveBuffer, 
                newClient.OnRead, 
                newClient);

            Xom.Trace(XomAreaName.SocialCacheConnection, LogLevel.L_HIGH, "Connection from: " + newClient.IPAddress);
            SocialCache.Instance.Log("|", "SocketConnect", newClient.IPAddress);
            SocialCacheCounters.Current.NumConnections.Increment();
            SocialCacheCounters.Current.ConnectRate.Increment();
        }

        public void OnDisconnect(TcpStream sender, Exception reason)
        {
            m_fDisconnectTriggered = true;
            SocialCacheCounters.Current.NumConnections.Decrement();

            Xom.Trace(XomAreaName.SocialCacheConnection, LogLevel.L_HIGH, "Disconnected client at " + IPAddress + ".  Reason: " + ((reason == null) ? "{null}" : reason.ToString()));
            SocialCache.Instance.Log("|", "SocketDisconnect", IPAddress, reason);

            // move this to another thread so not to block the IO threads.
            ClientDisconnectContext ctx = new ClientDisconnectContext(this);
            SocialCacheEngine.QueueContext(ThreadType.eWorker, ctx, null);
        }

        public void OnRead(IAsyncResult ar)
        {
            Debug.Assert(this == (ClientConnection)ar.AsyncState);

            int cbRead = 0;

            try
            {
                // read the bytes delivered.
                cbRead = m_stream.EndRead(ar);

                SocialCacheNetworkCounters.Total["Client"].ByteReadRate.IncrementBy(cbRead);
                SocialCacheNetworkCounters.Total.ByteReadRate.IncrementBy(cbRead);
            }
            catch (SocketException se)
            {
                // EndRead can throw a socket exception and not disconnect.
                Xom.Trace(XomAreaName.SocialCacheConnection, LogLevel.L_NORMAL, IPAddress + ": " + se.ToString());
                DisconnectSocket();
                return;
            }

            // is this a disconnection?
            if (cbRead == 0)
            {
                Xom.Trace(XomAreaName.SocialCacheConnection, LogLevel.L_NORMAL, IPAddress + ": read 0 bytes.");
                DisconnectSocket();
                return;
            }

            m_cbReadUsed += cbRead;

            try
            {
                // try to parse a message.
                int dwConsumed = SocialCacheEngine.ConsumeUserRequestBytes(m_rgbReceive, m_cbReadUsed, this);

                if (dwConsumed > 0)
                {
                    Xom.Trace(XomAreaName.SocialCacheConnection, LogLevel.L_LOW, IPAddress + ": message received ( " + dwConsumed + " bytes).");
                    
                    // shift any left over bytes
                    System.Buffer.BlockCopy(m_rgbReceive, dwConsumed, m_rgbReceive, 0, m_cbReadUsed - dwConsumed);
                    m_cbReadUsed -= dwConsumed;
                }
            }
            catch (Exception)
            {
                DisconnectSocket();
                return;
            }

            IAsyncResult arRead = m_stream.BeginRead(
                m_rgbReceive, 
                m_cbReadUsed, 
                m_cbReceiveBuffer - m_cbReadUsed, 
                OnRead, 
                this);
        }

        public void OnWrite(IAsyncResult ar)
        {
            byte[] rgbBuffer = (byte[])ar.AsyncState;

            try
            {
                m_stream.EndWrite(ar);
                Xom.Trace(XomAreaName.SocialCacheConnection, LogLevel.L_LOW, IPAddress + ": message sent.");

                SocialCacheNetworkCounters.Total["Client"].ByteWriteRate.IncrementBy(rgbBuffer.Length);
                SocialCacheNetworkCounters.Total.ByteWriteRate.IncrementBy(rgbBuffer.Length);

                SocialCacheEngine.ReturnSendBuffer(rgbBuffer);

                if ((Interlocked.Decrement(ref m_cPendingSends) <= 0) && m_fDisconnectTriggered)
                {
                    DisconnectSocket();
                }
            }
            catch (SocketException se)
            {
                Xom.Trace(XomAreaName.SocialCacheConnection, LogLevel.L_NORMAL, IPAddress + ": " + se.ToString());
                DisconnectSocket();
            }
        }

        public void Disconnect()
        {
            m_fDisconnectTriggered = true;
            if (m_cPendingSends == 0)
            {
                DisconnectSocket();
            }
        }

        protected void DisconnectSocket()
        {
            Xom.Trace(XomAreaName.SocialCacheConnection, LogLevel.L_NORMAL, IPAddress + ": Disconnect() called.");

            // close the socket.
            m_stream.Close();
            m_rgbReceive = null;
            m_cbReadUsed = 0;
        }

        public void Send(byte[] rgbBuffer)
        {
            Send(rgbBuffer, rgbBuffer.Length);
        }
        public void Send(byte[] rgbBuffer, int cbSend)
        {
            if (m_fDisconnectTriggered)
            {
                // we're shutting down.  no more sends go.
                return;
            }
            
            Xom.Trace(XomAreaName.SocialCacheConnection, LogLevel.L_LOW, IPAddress + ": sending message (" + rgbBuffer.Length + "bytes).");

            Interlocked.Increment(ref m_cPendingSends);

            IAsyncResult arWrite = m_stream.BeginWrite(
                rgbBuffer,
                0,
                cbSend,
                OnWrite,
                rgbBuffer);
        }
    }

    public class ClientDisconnectContext : SocialCacheContext
    {
        private ClientConnection m_cliConn;
        
        public ClientDisconnectContext(ClientConnection cliConn)
        {
            m_cliConn = cliConn;
        }

        public override void ProcessInternal(Object state)
        {
        }
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\signature\test\XSig\VerifySignature.cs ===
using System;
using System.Linq;
using System.Net;
using System.Security.Cryptography;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Signature;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.protocol;

namespace SigTest.XSig.Functional
{
    //[TestGroup]
    public partial class XSig : TestNode
    {
        [TestGroup, Owner("BenRan"), TestFrequency("Regression")]
        public class VerifySignature : TestNode
        {
            public static void ExecutePositiveRequest(XRLXSigVerifySignature verify, params UInt32[] expectedResults)
            {
                ExecutePositiveRequest(null, verify, expectedResults);
            }

            public static void ExecutePositiveRequest(String message, XRLXSigVerifySignature verify, params UInt32[] expectedResults)
            {
                if (expectedResults == null || expectedResults.Length == 0)
                {
                    expectedResults = new UInt32[verify.Requests.Length];
                }

                message = (message != null) ? " (" + message + ")" : "";

                Global.RO.Info("Executing VerifySignature{0} request...", message);
 
                if(!verify.Execute())
                {
                    throw new UnexpectedTestResultException(String.Format(
                        "VerifySignature{0} request failed: {1}",
                        message,
                        verify.GetDumpString()));
                }

                ValueCheck.TestAll("VerifySignature" + message + " Repsonses", expectedResults, verify.Responses.Select(r=> r._hresult).ToArray());
            }

            [TestCase, TestCasePriority(1), AsyncGroup(1), Description("Ask XSIG to verify a signed digest")]
            public class BVT : TestNode
            {
                public override void Run()
                {
                    ExecutePositiveRequest(new XRLXSigVerifySignature(Encoding.ASCII.GetBytes("Hello, how are you?")));
                }
            }

            [TestCase, TestCasePriority(2), AsyncGroup(1), Description("Ask XSIG to verify an incorrectly signed digest")]
            public class Bad_Signature : TestNode
            {
                public override void Run()
                {
                    byte[] data = Encoding.ASCII.GetBytes("I'm doing fine, how about you?");
                    XRLXSigVerifySignature xrl = new XRLXSigVerifySignature(1);

                    xrl.Requests[0] = XRLXSigVerifySignature.CreateVerifyRequest(data);
                    xrl.Requests[0]._digest[0]++;
                    ExecutePositiveRequest(xrl, HResult.XONLINE_E_SIGNATURE_VER_INVALID_SIGNATURE);

                    xrl.Requests[0] = XRLXSigVerifySignature.CreateVerifyRequest(data);
                    xrl.Requests[0]._digest[19]--;
                    ExecutePositiveRequest(xrl, HResult.XONLINE_E_SIGNATURE_VER_INVALID_SIGNATURE);

                    xrl.Requests[0] = XRLXSigVerifySignature.CreateVerifyRequest(data);
                    xrl.Requests[0]._digest = RandomEx.GlobalRandGen.GenerateRandomBlob(xrl.Requests[0]._digest.Length);
                    ExecutePositiveRequest(xrl, HResult.XONLINE_E_SIGNATURE_VER_INVALID_SIGNATURE);

                    xrl.Requests[0] = XRLXSigVerifySignature.CreateVerifyRequest(data);
                    xrl.Requests[0]._signature._signature[0]++;
                    ExecutePositiveRequest(xrl, HResult.XONLINE_E_SIGNATURE_VER_INVALID_SIGNATURE);

                    xrl.Requests[0] = XRLXSigVerifySignature.CreateVerifyRequest(data);
                    xrl.Requests[0]._signature._serviceId++;
                    ExecutePositiveRequest(xrl, HResult.XONLINE_E_SIGNATURE_VER_INVALID_SIGNATURE);

                    xrl.Requests[0] = XRLXSigVerifySignature.CreateVerifyRequest(data);
                    xrl.Requests[0]._signature._authData._XboxID++;
                    ExecutePositiveRequest(xrl, HResult.XONLINE_E_SIGNATURE_VER_INVALID_SIGNATURE);

                    xrl.Requests[0] = XRLXSigVerifySignature.CreateVerifyRequest(data);
                    xrl.Requests[0]._signature._authData._titleID = 0xfec0fe00;
                    ExecutePositiveRequest(xrl, HResult.XONLINE_E_SIGNATURE_VER_INVALID_SIGNATURE);

                    xrl.Requests[0] = XRLXSigVerifySignature.CreateVerifyRequest(data);
                    xrl.Requests[0]._signature._authData._userID1 = 0xff09000000000006;
                    ExecutePositiveRequest(xrl, HResult.XONLINE_E_SIGNATURE_VER_INVALID_SIGNATURE);
                }
            }

            [TestCase, TestCasePriority(2), AsyncGroup(1), Description("Ask XSIG to verify a signed digest with different key versions")]
            [CompoundCase("KeyVersion2", 2, 1)]
            [CompoundCase("KeyVersion4", 4, 3)]
            [CompoundCase("KeyVersion5", 5, 4)]
            public class Key_Version : TestNode
            {
                public static readonly Byte[] data = Encoding.ASCII.GetBytes("I'm doing pretty well, too.");

                public override void Run()
                {
                    Int16 keyVersion = Convert.ToInt16(MyValues[0]);
                    Int32 keyIndex = Convert.ToInt32(MyValues[1]);
                    Byte[] key = Keys.SigMaster[keyIndex];

                    XRLXSigVerifySignature xrl = new XRLXSigVerifySignature(1);
                    xrl.Requests[0] = XRLXSigVerifySignature.CreateVerifyRequest(data, key);
                    xrl.Requests[0]._signature._keyVersion = keyVersion;

                    ExecutePositiveRequest(xrl);
                }
            }

            [TestCase, TestCasePriority(2), AsyncGroup(1), Description("Ask  XSIG to verify a signed digest signed on behalf from other servers.")]
            [CompoundCase("PresNotification", (UInt32)XOService.PresNotification)]
            [CompoundCase("Matchmaking", (UInt32)XOService.Matchmaking)]
            [CompoundCase("Signature", (UInt32)XOService.Signature_Server)]
            [CompoundCase("0x7FFFFFFF", 0x7FFFFFFF)]
            [CompoundCase("0xFFFFFFFF", 0xFFFFFFFF)]
            public class Service_ID : TestNode
            {
                public static readonly Byte[] data = Encoding.ASCII.GetBytes("What have you been up to lately?");

                public override void Run()
                {
                    XRLXSigVerifySignature xrl = new XRLXSigVerifySignature(1);
                    xrl.Requests[0] = XRLXSigVerifySignature.CreateVerifyRequest(data);
                    xrl.Requests[0]._signature._serviceId = Convert.ToUInt32(MyValues[0]);
                    xrl.Requests[0].Sign();

                    ExecutePositiveRequest(xrl);
                }
            }


            [TestCase, TestCasePriority(2), AsyncGroup(1), Description("Ask  XSIG to verify a signed digest with mismatched and/or invalid key and signature versions")]
            [CompoundCase("SignatureVersion_2",           2,     1, HResult.XONLINE_E_SIGNATURE_VER_UNKNOWN_SIGNATURE_VER)]
            [CompoundCase("SignatureVersion_-12002", -12002,     1, HResult.XONLINE_E_SIGNATURE_VER_UNKNOWN_SIGNATURE_VER)]
            [CompoundCase("KeyVersion_3",                 1,     3, HResult.XONLINE_E_SIGNATURE_VER_UNKNOWN_KEY_VER)]
            [CompoundCase("KeyVersion_-3533",             1, -3533, HResult.XONLINE_E_SIGNATURE_VER_UNKNOWN_KEY_VER)]
            class Bad_Version : TestNode
            {
                public static readonly Byte[] data = Encoding.ASCII.GetBytes("Not too much.  You?");

                public override void Run()
                {
                    XRLXSigVerifySignature xrl = new XRLXSigVerifySignature(1);
                    xrl.Requests[0] = XRLXSigVerifySignature.CreateVerifyRequest(data);
                    xrl.Requests[0]._signature._signatureVersion = Convert.ToInt16(MyValues[0]);
                    xrl.Requests[0]._signature._keyVersion = Convert.ToInt16(MyValues[1]);

                    UInt32 expectedResult = Convert.ToUInt32(MyValues[2]);

                    ExecutePositiveRequest(xrl, expectedResult);
                }
            }

            [TestCase, TestCasePriority(2), AsyncGroup(1), Description("Ask  XSIG to verify a signature that has the wrong amount of data inside")]
            [CompoundCase("RequestSize1", 1, false)]
            [CompoundCase("RequestSize101", 101, false)]
            [CompoundCase("RequestSize105", 105, false)]
            [CompoundCase("RequestSize1039", 1039, false)]
            [CompoundCase("RequestSize1_PlusValidRequest", 1, true)]
            class Bad_Size : TestNode
            {
                public override void Run()
                {
                    XRLXSigVerifySignature xrl = new XRLXSigVerifySignature(0);

                    xrl.ExtraData = new Byte[Convert.ToInt32(MyValues[0])];
                    if((bool)MyValues[1])
                    {
                        xrl.Requests = new XSigVerifySignatureRequest[] { 
                            XRLXSigVerifySignature.CreateVerifyRequest(RandomEx.GlobalRandGen.GenerateRandomBlob(20)) };
                    }
                    
                    if(xrl.Execute() || xrl.XErr != HResult.XONLINE_E_INVALID_REQUEST)
                    {
                        throw new UnexpectedTestResultException("Request with invalid size succeeded unexpectedly.");
                    }
                }
            }

            [TestCase, TestCasePriority(2), AsyncGroup(1), Description("Ask XSIG to verify a signature that has been revoked by digest, user, machine or title")]
            class Blacklisted_Data : TestNode
            {
                byte[] blacklistedData = Encoding.ASCII.GetBytes("This data has been blacklisted.");
                byte[] blacklistedData2 = Encoding.ASCII.GetBytes("This data and machinePuid is blacklisted.");
                byte[] unBlacklistedData = Encoding.ASCII.GetBytes("This data has been unblacklisted.");
                ulong blacklistedMachine = RandomEx.GlobalRandGen.NextPuid();
                ulong goodUser = RandomEx.GlobalRandGen.NextPuid();
                ulong blacklistedUser = RandomEx.GlobalRandGen.NextPuid();

                public override void PreRun()
                {
                    SHA1Managed sha1 = new SHA1Managed();

                    Global.RO.Info("Blacklisting digest, titles, users, and machines.");
                    NpdbUtility npdb = new NpdbUtility();
                    npdb.ConnectToServer();

                    npdb.BlacklistDigest(sha1.ComputeHash(blacklistedData), true);
                    npdb.BlacklistDigest(sha1.ComputeHash(blacklistedData2), true);
                    npdb.BlacklistDigest(sha1.ComputeHash(unBlacklistedData), false);
                    npdb.BlacklistTitle(0x7FBADD02, 2, true);
                    npdb.BlacklistMachine(blacklistedMachine, true);
                    npdb.BlacklistUser(blacklistedUser, true);
                    npdb.Close();
                    Utils.ReloadBlacklist();
                }

                public override void Run()
                {
                    XRLXSigVerifySignature xrl = new XRLXSigVerifySignature(1);
                    xrl.Requests[0] = XRLXSigVerifySignature.CreateVerifyRequest(blacklistedData);
                    ExecutePositiveRequest("Banned Digest", xrl, HResult.XONLINE_E_SIGNATURE_BANNED_DIGEST);

                    xrl.Requests[0] = XRLXSigVerifySignature.CreateVerifyRequest(unBlacklistedData);
                    ExecutePositiveRequest("Unbanned Digest", xrl);

                    xrl.Requests[0] = XRLXSigVerifySignature.CreateVerifyRequest(
                        Encoding.ASCII.GetBytes("This data is ok and the titleid, ver 1 is ok."));
                    xrl.Requests[0]._signature._authData._titleID = 0x7FBADD02;
                    xrl.Requests[0]._signature._authData._titleVersion = 1;
                    xrl.Requests[0].Sign();
                    ExecutePositiveRequest("Unblacklisted title and version", xrl);

                    xrl.Requests[0] = XRLXSigVerifySignature.CreateVerifyRequest(
                        Encoding.ASCII.GetBytes("This data is ok and the titleid, ver 2 is not."));
                    xrl.Requests[0]._signature._authData._titleID = 0x7FBADD02;
                    xrl.Requests[0]._signature._authData._titleVersion = 2;
                    xrl.Requests[0].Sign();
                    ExecutePositiveRequest("Blacklisted title and version", xrl, HResult.XONLINE_E_SIGNATURE_BANNED_TITLE);

                    xrl.Requests[0] = XRLXSigVerifySignature.CreateVerifyRequest(
                        Encoding.ASCII.GetBytes("This data is ok but the machinePuid is not."));
                    xrl.Requests[0]._signature._authData._XboxID = blacklistedMachine;
                    xrl.Requests[0].Sign();
                    ExecutePositiveRequest("Blacklisted machine id", xrl, HResult.XONLINE_E_SIGNATURE_BANNED_XBOX);

                    xrl.Requests[0] = XRLXSigVerifySignature.CreateVerifyRequest(
                        Encoding.ASCII.GetBytes("This data is ok but the userPuid is not."));
                    xrl.Requests[0]._signature._authData._userID1 = blacklistedUser;
                    xrl.Requests[0].Sign();
                    ExecutePositiveRequest("Blacklisted user", xrl, HResult.XONLINE_E_SIGNATURE_BANNED_USER);

                    xrl.Requests[0] = XRLXSigVerifySignature.CreateVerifyRequest(
                        Encoding.ASCII.GetBytes("This data is ok but one of the userPuids is not."));
                    xrl.Requests[0]._signature._authData._userID1 = goodUser;
                    xrl.Requests[0]._signature._authData._userID2 = blacklistedUser;
                    xrl.Requests[0].Sign();
                    ExecutePositiveRequest("Blacklisted user", xrl, HResult.XONLINE_E_SIGNATURE_BANNED_USER);

                    xrl.Requests[0] = XRLXSigVerifySignature.CreateVerifyRequest(
                        Encoding.ASCII.GetBytes("This data is ok but neither the titleID/version nor the userPuid is."));
                    xrl.Requests[0]._signature._authData._titleID = 0x7FBADD02;
                    xrl.Requests[0]._signature._authData._titleVersion = 2;
                    xrl.Requests[0]._signature._authData._userID1 = goodUser;
                    xrl.Requests[0]._signature._authData._userID2 = blacklistedUser;
                    xrl.Requests[0].Sign();
                    ExecutePositiveRequest("Blacklisted user", xrl, HResult.XONLINE_E_SIGNATURE_BANNED_TITLE);

                    xrl.Requests[0] = XRLXSigVerifySignature.CreateVerifyRequest(blacklistedData2);
                    xrl.Requests[0]._signature._authData._titleID = 0x7FBADD02;
                    xrl.Requests[0]._signature._authData._titleVersion = 1;
                    xrl.Requests[0]._signature._authData._userID1 = goodUser;
                    xrl.Requests[0]._signature._authData._userID2 = blacklistedUser;
                    xrl.Requests[0].Sign();
                    ExecutePositiveRequest("Blacklisted user", xrl, HResult.XONLINE_E_SIGNATURE_BANNED_DIGEST);
                }

                public override void PostRun()
                {
                    SHA1Managed sha1 = new SHA1Managed();
                    NpdbUtility npdb = new NpdbUtility();
                    npdb.ConnectToServer();

                    npdb.BlacklistDigest(sha1.ComputeHash(blacklistedData), false);
                    npdb.BlacklistDigest(sha1.ComputeHash(blacklistedData2), false);
                    npdb.BlacklistTitle(0x7FBADD02, 2, false);
                    npdb.BlacklistMachine(blacklistedMachine, false);
                    npdb.BlacklistUser(blacklistedUser, false);
                    npdb.Close();
                    Utils.ReloadBlacklist();
                }
            }

            [TestCase, TestCasePriority(2), AsyncGroup(1), Description("bug 13587:Ask XSIG to verify multiple signatures at one time")]
            class Multiple_Requests : TestNode
            {
                public override void Run()
                {
                    byte[] data1 = Encoding.ASCII.GetBytes("Polo.");
                    byte[] data2 = Encoding.ASCII.GetBytes("Rugby.");
                    byte[] data3 = Encoding.ASCII.GetBytes("Croquet.");

                    XRLXSigVerifySignature xrl = new XRLXSigVerifySignature();
                    
                    xrl.Requests = new XSigVerifySignatureRequest[] {
                        XRLXSigVerifySignature.CreateVerifyRequest(data1),
                        XRLXSigVerifySignature.CreateVerifyRequest(data2),
                        XRLXSigVerifySignature.CreateVerifyRequest(data3)
                    };
                    ExecutePositiveRequest(xrl);

                    xrl.Requests[0]._digest[0]++;
                    ExecutePositiveRequest(xrl, HResult.XONLINE_E_SIGNATURE_VER_INVALID_SIGNATURE, HResult.S_OK, HResult.S_OK);

                    xrl.Requests = new XSigVerifySignatureRequest[] {
                        XRLXSigVerifySignature.CreateVerifyRequest(data1),
                        XRLXSigVerifySignature.CreateVerifyRequest(data2, Keys.SigMaster[1]),
                        XRLXSigVerifySignature.CreateVerifyRequest(data3)
                    };
                    xrl.Requests[1]._signature._keyVersion = 2;
                    ExecutePositiveRequest(xrl);

                    xrl.Requests = new XSigVerifySignatureRequest[] {
                        XRLXSigVerifySignature.CreateVerifyRequest(data1),
                        XRLXSigVerifySignature.CreateVerifyRequest(data2, Keys.SigMaster[1]),
                        XRLXSigVerifySignature.CreateVerifyRequest(data3)
                    };
                    xrl.Requests[1]._signature._signatureVersion = 2;
                    ExecutePositiveRequest(xrl, HResult.S_OK, HResult.XONLINE_E_SIGNATURE_VER_UNKNOWN_SIGNATURE_VER, HResult.S_OK);

                    xrl.Requests = new XSigVerifySignatureRequest[416];
                    for (int i = 0; i < xrl.Requests.Length; i++)
                    {
                        xrl.Requests[i] = XRLXSigVerifySignature.CreateVerifyRequest(RandomEx.GlobalRandGen.GenerateRandomBlob(100));
                    }
                    ExecutePositiveRequest(xrl);

                    xrl.Requests = new XSigVerifySignatureRequest[417];
                    for (int i = 0; i < xrl.Requests.Length; i++)
                    {
                        xrl.Requests[i] = XRLXSigVerifySignature.CreateVerifyRequest(RandomEx.GlobalRandGen.GenerateRandomBlob(100));
                    }
                    ValueCheck.IsTrue(!xrl.Execute() && xrl.httpStatus == HttpStatusCode.NotFound, "Request larger than allowed buffer passed");
                }
            }

            [TestCase, TestCasePriority(3), Description("Check X-Delay header")]
            class Throttling : TestNode
            {
                public static readonly Byte[] data = Encoding.ASCII.GetBytes("Hello, how are you?");
                public override void PreRun()
                {
                    Global.XEnv.ExecuteXmgmtCommand(Interface.xsig, "e :xsig SetXDelay 0 VerifySignature 3000");
                }

                public override void Run()
                {
                    XRLXSigVerifySignature req = new XRLXSigVerifySignature(data);

                    if (!req.Execute())
                    {
                        throw new UnexpectedTestResultException("VerifySignature request failed: " + req.GetDumpString());
                    }
                    
                    if(req.XDelay != 3000)
                    {
                        throw new UnexpectedTestResultException("VerifySignature XDelay header not set to expected value.");
                    }
                }

                public override void PostRun()
                {
                    Global.XEnv.ExecuteXmgmtCommand(Interface.xsig, "exec :xsig ReloadThrottleConfig");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\SocialCache\inh\HashRelationships.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;

using xonline.common.mgmt;
using xonline.common.community;

namespace xonline.server.SocialCache
{
    // Right now this only holds the friends list for the user.
    // When friends tags and groups are added, tags and the user's group list
    // should be added to the Entry alongside the friend list.
    public class HashRelationshipsEntry : ILookupTableItem
    {
        public HashRelationshipsEntry(FriendsList friends)
        {
            m_key = friends.OwnerID;
            m_friends = friends;
        }

        private ulong m_key;
        object ILookupTableItem.Key
        {
            get
            {
                return m_key;
            }
        }

        protected ILookupTableItem m_next;
        ILookupTableItem ILookupTableItem.Next
        {
            get
            {
                return m_next;
            }
            set
            {
                m_next = value;
            }
        }

        private DateTime m_dtEntryTime;
        DateTime ILookupTableItem.EntryTime
        {
            get
            {
                return m_dtEntryTime;
            }
            set
            {
                m_dtEntryTime = value;
            }
        }

        FriendsList m_friends;
        public FriendsList Friends
        {
            get
            {
                return m_friends;
            }
        }
    }

    public class HashRelationships
    {
        private LookupTable m_table;

        public HashRelationships(int cBuckets)
        {
            m_table = new LookupTable(cBuckets, SocialCacheHashTableCounters.Total, SocialCacheHashTableCounters.Total["Relationships"]);
        }

        public bool InsertRelationships(FriendsList friends)
        {
            bool result = false;

            // lock the bucket.
            int iLockToken = m_table.LockItemByKey(friends.OwnerID);

            try
            {
                object o = m_table.FindLookupItem(iLockToken, friends.OwnerID);
                if (o == null)
                {
                    // add it to the table.
                    m_table.AddLookupItem(iLockToken, new HashRelationshipsEntry(friends));
                    result = true;
                }
            }
            finally
            {
                m_table.UnlockItem(iLockToken);
            }

            return result;
        }

        public void RemoveRelationships(ulong puid)
        {
            // Lock the bucket.
            int iLockToken = m_table.LockItemByKey(puid);

            try
            {
                ILookupTableItem item = m_table.FindLookupItem(iLockToken, puid);
                if (item != null)
                {
                    // Remove it from the table.
                    m_table.RemoveLookupItem(iLockToken, item);
                }
            }
            finally
            {
                m_table.UnlockItem(iLockToken);
            }
        }

        public FriendsList LookupRelationships(ulong puid)
        {
            FriendsList friends = null;

            // lock the bucket.
            int iLockToken = m_table.LockItemByKey(puid);

            try
            {
                HashRelationshipsEntry entry = m_table.FindLookupItem(iLockToken, puid) as HashRelationshipsEntry;
                if (entry != null)
                {
                    friends = entry.Friends;
                }
            }
            finally
            {
                m_table.UnlockItem(iLockToken);
            }

            return friends;
        }

        public CacheEntryStatus CheckRelationship(ulong puid)
        {
            CacheEntryStatus status = CacheEntryStatus.Missing;

            // lock the bucket.
            int iLockToken = m_table.LockItemByKey(puid);

            try
            {
                status = m_table.CheckItem(iLockToken, puid);
            }
            finally
            {
                m_table.UnlockItem(iLockToken);
            }

            return status;
        }

        public FriendsList ReadFriendsList(ulong user)
        {
            // Look in the hash table for the FriendsList.
            FriendsList friendsList = LookupRelationships(user);
            if (friendsList == null)
            {
                // Fall back to Acceleration (which falls back to uodb).
                friendsList = FriendsListUtil.GetFriendsListForXuid(user);
                if (friendsList != null)
                {
                    // If we got it, add it to the hash table.
                    InsertRelationships(friendsList);
                }
            }
            return friendsList;
        }

        public CacheEntryStatus CheckRelationshipCacheStatus(ulong puid)
        {
            return CheckRelationship(puid);
        }

        public bool ExpireRelationship(ulong userId, int timeToExpire)
        {
            bool fFoundUser = false;

            // lock the bucket.
            int iLockToken = m_table.LockItemByKey(userId);

            try
            {
                ILookupTableItem entry = m_table.FindLookupItem(iLockToken, userId);
                if (entry != null)
                {
                    TimeSpan expireTime = new TimeSpan(0, 0, SocialCache.Instance.CacheEntryExpirationTimeout - timeToExpire);
                    entry.EntryTime = DateTime.UtcNow.Subtract(expireTime);
                    fFoundUser = true;
                }
            }
            finally
            {
                m_table.UnlockItem(iLockToken);
            }


            return fFoundUser;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\SocialCache\inh\GetFriendsProcessorINH.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using System.Diagnostics;
using System.Text;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;
using xonline.common.community;
using xonline.common.community.socialquery.protocol;
using xonline.server.SocialCache;
using xonline.common.protocol.socialquery;
using xonline.common.protocol;

namespace xonline.common.community.socialquery
{
    // The INH specific version of the ISocialQueryProcessor 
    public class GetFriendsProcessorINH : GetFriendsListProcessorBase
    {
        // inh specific data for this api
        private UserRequestContext ctx;

        public GetFriendsProcessorINH(UserRequestContext requestContext)
        {
            ctx = requestContext;

            message = new GetFriendsINHRequest();
            message.ReadBytes(ctx.m_rgbEntireMessage);

            ctx.AddLogParameter(message.data.RequestorXuid);
        }

        public override void ProcessRequest()
        {
            Gather();
            Sort();     // implemented by the common base class
            Page();     // implemented by the common base class

            // queue up a worker context to send back the reply             
            SocialCacheEngine.QueueContext(ThreadType.eWorker, new QueryContext(this), null);
        }

        // delegate for INH filtering during the WalkFriends call
        public void ProcessUser(ulong Xuid, string Gamertag, uint UserState, uint FriendStatus, uint TitleId, object context)
        {
            List<SocialQueryUser> users = (List<SocialQueryUser>)context;
            bool bAdd = true;

            // If doing a friends-of-friends query, do some additional checks before adding this user to the list
            if(message.data.RequestorXuid != message.data.OwnerXuid) 
            {
                // Don't include the requestor in the friend's friend list - this is for Geneva parity.
                if(Xuid == message.data.RequestorXuid) 
                {
                    bAdd = false;
                }
                
                // Don't add users that are in the pending state.
                if((FriendStatus & PresDefs.P_BUDDY_STATUS_PENDING ) != 0 || (FriendStatus & PresDefs.P_BUDDY_STATUS_PENDING ) != 0) 
                {
                    bAdd = false;
                }
            }

            // Create a SocialQueryUser and set up the fields.
            if(bAdd) 
            {
                users.Add(new SocialQueryUser(Xuid, Gamertag, UserState, FriendStatus, TitleId));
            }
        }

        public override void Gather()
        {
            List<SocialQueryUser> users = new List<SocialQueryUser>();

            // WalkFriendsList will call the ProcessUser delegate above and add users to the users list.
            friendListVersion = SocialCache.WalkFriendsList(message.data.RequestorXuid, message.data.OwnerXuid, ProcessUser, users);

            friends = users.ToArray();
            totalNumUsers = (uint)users.Count;
            firstUserIndex = 0;
        }

        public override void Reply()
        {
            GetFriendsINHReply reply = new GetFriendsINHReply();

            if (friends != null)
            {
                reply.FriendListVersion = FriendListVersion;
                reply.TotalNumUsers = TotalNumUsers;
                reply.PageStartIndex = FirstUserIndex;
                reply.NumSqFriends = (uint)friends.Length;
                reply.Friends = friends;
            }
            
            UserRequestContext.SendResponse(reply, ctx, reply.dwMessageType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\SocialCache\inh\HealthCheck.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using System.Diagnostics;
using System.Text;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;

using xonline.common.community;
using xonline.server.SocialCache;
using xonline.common.community.socialquery.protocol;

namespace xonline.common.community.socialquery
{
    // The INH specific version of the ISocialQueryProcessor for the HealthCheck object
    public class HealthCheckINH : HealthCheckBase
    {
        // inh specific data for this api
        private UserRequestContext ctx;

        public HealthCheckINH(UserRequestContext requestContext)
        {
            ctx = requestContext;

            message = new HelloMessage();
            message.ReadBytes(ctx.m_rgbEntireMessage);                  
        }

        public override void ProcessRequest()
        {
            // queue up a worker context to send back the reply             
            SocialCacheEngine.QueueContext(ThreadType.eWorker, new QueryContext(this), null);
        }

        public override void Reply()
        {
            HelloReply reply = new HelloReply();                    
            UserRequestContext.SendResponse(reply, ctx, reply.dwMessageType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\SocialCache\inh\HashUser.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;

using xonline.common.mgmt;
using xonline.common.community;
using xonline.common.community.socialquery.protocol;
using xonline.common.service;

namespace xonline.server.SocialCache
{
    public class HashUserEntry : ILookupTableItem
    {
        public HashUserEntry(LimitedPresence userData)
        {
            m_key = userData.OwnerID;
            m_userData = userData;
        }

        private ulong m_key;
        object ILookupTableItem.Key
        {
            get
            {
                return m_key;
            }
        }

        protected ILookupTableItem m_next;
        ILookupTableItem ILookupTableItem.Next
        {
            get
            {
                return m_next;
            }
            set
            {
                m_next = value;
            }
        }

        private DateTime m_dtEntryTime;
        DateTime ILookupTableItem.EntryTime
        {
            get
            {
                return m_dtEntryTime;
            }
            set
            {
                m_dtEntryTime = value;
            }
        }

        LimitedPresence m_userData;
        public LimitedPresence UserData
        {
            get
            {
                return m_userData;
            }
        }
    }

    public class HashUser
    {
        private LookupTable m_table;

        public HashUser(int cBuckets)
        {
            m_table = new LookupTable(cBuckets, SocialCacheHashTableCounters.Total, SocialCacheHashTableCounters.Total["User"]);
        }

        public bool InsertUser(LimitedPresence userData)
        {
            bool result = false;

            // lock the bucket.
            int iLockToken = m_table.LockItemByKey(userData.OwnerID);

            try
            {
                object o = m_table.FindLookupItem(iLockToken, userData.OwnerID);
                if (o == null)
                {
                    // add it to the table.
                    m_table.AddLookupItem(iLockToken, new HashUserEntry(userData));
                    result = true;
                }
            }
            finally
            {
                m_table.UnlockItem(iLockToken);
            }

            return result;
        }

        public void RemoveUser(ulong puid)
        {
            // Lock the bucket.
            int iLockToken = m_table.LockItemByKey(puid);

            try
            {
                ILookupTableItem item = m_table.FindLookupItem(iLockToken, puid);
                if (item != null)
                {
                    // Remove it from the table.
                    m_table.RemoveLookupItem(iLockToken, item);
                }
            }
            finally
            {
                m_table.UnlockItem(iLockToken);
            }
        }

        public LimitedPresence LookupUser(ulong puid)
        {
            LimitedPresence user = null;

            // lock the bucket.
            int iLockToken = m_table.LockItemByKey(puid);

            try
            {
                HashUserEntry entry = m_table.FindLookupItem(iLockToken, puid) as HashUserEntry;
                if (entry != null)
                {
                    user = entry.UserData;
                }
            }
            finally
            {
                m_table.UnlockItem(iLockToken);
            }

            return user;
        }

        public CacheEntryStatus CheckUser(ulong puid)
        {
            CacheEntryStatus status = CacheEntryStatus.Missing;
            
            // lock the bucket.
            int iLockToken = m_table.LockItemByKey(puid);

            try
            {
                status = m_table.CheckItem(iLockToken, puid);
            }
            finally
            {
                m_table.UnlockItem(iLockToken);
            }

            return status;
        }

        public LimitedPresence[] ReadUsers(ulong[] rgUsers)
        {
            LimitedPresence[] rgUsersPresence = new LimitedPresence[rgUsers.Length];
            Dictionary<ulong, int> dictUsersNotInCache = new Dictionary<ulong,int>();
            
            //
            // First, go through the hash tables and check for these users.
            //

            for (int iUser = 0; iUser < rgUsers.Length; iUser++)
            {
                LimitedPresence userPresence;

                userPresence = LookupUser(rgUsers[iUser]);
                if (userPresence != null)
                {
                    rgUsersPresence[iUser] = userPresence;
                }
                else
                {
                    dictUsersNotInCache.Add(rgUsers[iUser], iUser);
                }
            }

            //
            // For any missed requests, we need to check Acceleration and XCache.
            //

            if (dictUsersNotInCache.Count > 0)
            {
                // Build the list of keys to do a batch read.
                string[] rgKeys = new string[dictUsersNotInCache.Count];
                ulong[] rgXuids = new ulong[dictUsersNotInCache.Count];
                int iKey = 0;
                foreach (ulong user in dictUsersNotInCache.Keys)
                {
                    rgKeys[iKey] = CacheUtil.BuildCacheKey(DATA_TYPES.eLimitedPresence, user);
                    rgXuids[iKey] = user;
                    iKey++;
                }

                // Grab the items from Acceleration.
                BaseDataHeader[] rgItems = CacheUtil.ReadFromNotificationCache(rgKeys);

                // the gamertag is in the limitedpresence cache object, but it's possible that we'll have a cache miss.
                // we want to return the gamertag for every user, even if he's offline.  so, just use xcache for all gamertags.
                string[] rgGamertags = GetGamertagsFromXCache(rgXuids);

                for (int iItem = 0; iItem < rgItems.Length; iItem++)
                {
                    LimitedPresence presence = rgItems[iItem] as LimitedPresence;

                    if (presence == null)
                    {
                        // make an empty record.
                        presence = new LimitedPresence();
                        presence.OwnerID = rgXuids[iItem];
                    }

                    // overwrite the gamertag.
                    presence.sGamertag = rgGamertags[iItem];

                    // Update the hash table.
                    InsertUser(presence);

                    // Add this user to the list being returned.
                    // Get the index we need to put them in from the dictionary.
                    int iIndex;
                    bool succeeded = dictUsersNotInCache.TryGetValue(rgXuids[iItem], out iIndex);
                    
                    // This should never not succeed, because we put the 
                    // xuids in that array from the dictionary in the first place.
                    if (succeeded)
                    {
                        rgUsersPresence[iIndex] = presence;
                    }
                }
            }

            return rgUsersPresence;
        }

        public CacheEntryStatus CheckUserCacheStatus(ulong puid)
        {
            return CheckUser(puid);
        }

        public bool ExpireUser(ulong userId, int timeToExpire)
        {
            bool fFoundUser = false;

            // lock the bucket.
            int iLockToken = m_table.LockItemByKey(userId);

            try
            {
                ILookupTableItem entry = m_table.FindLookupItem(iLockToken, userId);
                if (entry != null)
                {
                    TimeSpan expireTime = new TimeSpan(0,0,SocialCache.Instance.CacheEntryExpirationTimeout - timeToExpire);
                    entry.EntryTime = DateTime.UtcNow.Subtract(expireTime);
                    fFoundUser = true;
                }
            }
            finally
            {
                m_table.UnlockItem(iLockToken);
            }


            return fFoundUser;
        }

        /// <summary>
        /// Gets the gamertags from XCache
        /// </summary>
        private string[] GetGamertagsFromXCache(ulong[] xuids)
        {
            XCacheUserResponseData[] responses = XCache.LookupUsersByXUID(xuids);
            string[] gamerTags = Array.ConvertAll<XCacheUserResponseData, string>(responses, user => user.szGamertag);
            return gamerTags;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\SocialCache\inh\NYCLock.cs ===
using System;
using System.Threading;

namespace xonline.server.SocialCache
{
    // It's the spinny that never sleeps!
    public class NYCLock
    {
        protected int m_iThreadID;
        protected int m_cLockDepth;

        protected const int SPIN_COUNT = 0x1000;

        public NYCLock()
        {
        }

        public void Lock()
        {
            int iThreadID = Thread.CurrentThread.ManagedThreadId;
            if (iThreadID == m_iThreadID)
            {
                // already locked by us.
                m_cLockDepth++;
            }
            else
            {
                // spin
                while (Interlocked.CompareExchange(ref m_iThreadID, iThreadID, 0) != 0)
                {
                    for (int iSpin = 0; iSpin < SPIN_COUNT; iSpin++)
                    {
                        if (m_iThreadID == 0)
                        {
                            break;
                        }
                    }
                }

                // now we have the lock.
                m_cLockDepth = 1;
            }
        }

        public void Unlock()
        {
            // reduce lock depth.
            m_cLockDepth--;
            if (m_cLockDepth == 0)
            {
                // all locks released.  yield the lock.
                m_iThreadID = 0;
            }
        }

        public void WriteLock()
        {
            Lock();
        }

        public void ReadLock()
        {
            Lock();
        }

        public void WriteUnlock()
        {
            Unlock();
        }

        public void ReadUnlock()
        {
            Unlock();
        }
    }

    // regular c#, lock{} style.
    public class MonitorLock
    {
        public MonitorLock()
        {
        }

        public void Lock()
        {
            Monitor.Enter(this);
        }

        public void Unlock()
        {
            Monitor.Exit(this);
        }

        public void WriteLock()
        {
            Lock();
        }

        public void ReadLock()
        {
            Lock();
        }

        public void WriteUnlock()
        {
            Unlock();
        }

        public void ReadUnlock()
        {
            Unlock();
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\SocialCache\inh\LookupTable.cs ===
using System;
using System.Diagnostics;

using xonline.common.mgmt;

namespace xonline.server.SocialCache
{
    public interface ILookupTableItem
    {
        // obtain the key for an item.
        Object Key
        {
            get;
        }

        // get/set the next pointer for an item.
        ILookupTableItem Next
        {
            get;
            set;
        }

        // Time when this item was put in the cache
        DateTime EntryTime
        {
            get;
            set;
        }
    }

    public enum CacheEntryStatus
    {
        Found,
        Missing,
        Expired
    }

    public class LookupTable
    {
        protected int m_cBuckets;
        protected ILookupTableItem[] m_rgBuckets;
        protected MonitorLock[] m_rgBucketLocks;

        public int NumBuckets 
        {
            get
            {
                return m_cBuckets;
            }
        }

        private SocialCacheHashTableCounters m_perfTotal;
        private SocialCacheHashTableCounters m_perfInstance;

        // create a new lookup table with the specified number of buckets.
        public LookupTable(int cBuckets, SocialCacheHashTableCounters perfTotal, SocialCacheHashTableCounters perfInstance)
        {
            m_cBuckets = cBuckets;

            // make the buckets.
            m_rgBuckets = new ILookupTableItem[m_cBuckets];

            // make the bucket locks.
            m_rgBucketLocks = new MonitorLock[m_cBuckets];
            for (int iLock = 0; iLock < m_cBuckets; iLock++)
            {
                m_rgBucketLocks[iLock] = new MonitorLock();
            }

            m_perfTotal = perfTotal;
            m_perfInstance = perfInstance;
        }

        // lock a bucket for use.
        public int LockItemByKey(Object key)
        {
            m_perfTotal.LockRate.Increment();
            m_perfInstance.LockRate.Increment();

            int iBucket = Hash(key);

            // lock the bucket.
            m_rgBucketLocks[iBucket].WriteLock();

            return iBucket;
        }

        // unlock a bucket.
        public void UnlockItem(int iLockToken)
        {
            // unlock the bucket.
            m_rgBucketLocks[iLockToken].WriteUnlock();
        }

        // insert this item into the lookup table.
        public void AddLookupItem(int iLockToken, ILookupTableItem item)
        {
            m_perfTotal.Entries.Increment();
            m_perfInstance.Entries.Increment();
            m_perfTotal.WriteRate.Increment();
            m_perfInstance.WriteRate.Increment();

            // Set this item's EntryTime
            item.EntryTime = DateTime.UtcNow;

            // link this item into the chain for this bucket.
            item.Next = m_rgBuckets[iLockToken];
            m_rgBuckets[iLockToken] = item;
        }

        // find an item given its key.
        public ILookupTableItem FindLookupItem(int iLockToken, Object key)
        {
            // search the bucket for the key.
            ILookupTableItem bucketItem = m_rgBuckets[iLockToken];
            while (bucketItem != null)
            {
                if (key.Equals(bucketItem.Key))
                {
                    // found it!
                    if ((DateTime.UtcNow.Subtract(bucketItem.EntryTime)).TotalSeconds > SocialCache.Instance.CacheEntryExpirationTimeout)
                    {
                        // Exceeded expiration time.  Expire this entry.
                        RemoveLookupItem(iLockToken, bucketItem);

                        m_perfTotal.ExpirationRate.Increment();
                        m_perfInstance.ExpirationRate.Increment();

                        return null;
                    }

                    m_perfTotal.FoundRate.Increment();
                    m_perfInstance.FoundRate.Increment();

                    return bucketItem;
                }

                bucketItem = bucketItem.Next;
            }

            // didnt find the item.
            m_perfTotal.MissRate.Increment();
            m_perfInstance.MissRate.Increment();

            return null;
        }

        // Check the status of an item in the hash table given the key.
        public CacheEntryStatus CheckItem(int iLockToken, Object key)
        {
            // search the bucket for the key.
            ILookupTableItem bucketItem = m_rgBuckets[iLockToken];
            while (bucketItem != null)
            {
                if (key.Equals(bucketItem.Key))
                {
                    // found it!
                    if ((DateTime.UtcNow.Subtract(bucketItem.EntryTime)).TotalSeconds > SocialCache.Instance.CacheEntryExpirationTimeout)
                    {
                        return CacheEntryStatus.Expired;
                    }
                    return CacheEntryStatus.Found;
                }

                bucketItem = bucketItem.Next;
            }

            // didnt find the item.
            return CacheEntryStatus.Missing;
        }

        // remove this item from the lookup table.
        public bool RemoveLookupItem(int iLockToken, ILookupTableItem item)
        {
            Object key = item.Key;

            m_perfTotal.Entries.Decrement();
            m_perfInstance.Entries.Decrement();
            m_perfTotal.DeleteRate.Increment();
            m_perfInstance.DeleteRate.Increment();

            if (m_rgBuckets[iLockToken] != null)
            {
                // check the head pointer first.
                if (key.Equals(m_rgBuckets[iLockToken].Key))
                {
                    // head pointer is the match.  just advance the head pointer.
                    m_rgBuckets[iLockToken] = m_rgBuckets[iLockToken].Next;
                    return true;
                }
                else
                {
                    // start with the next pointer.
                    ILookupTableItem bucketItem = m_rgBuckets[iLockToken];
                    ILookupTableItem bucketNext = bucketItem.Next;
                    while (bucketNext != null)
                    {
                        if (key.Equals(bucketNext.Key))
                        {
                            // found the target to delete.  un-link it from the list.
                            bucketItem.Next = bucketNext.Next;
                            return true;
                        }

                        bucketItem = bucketNext;
                        bucketNext = bucketNext.Next;
                    }
                }
            }

            // didnt find the item.
            return false;
        }

        protected int Hash(Object key)
        {
            return (int)((uint)(key.GetHashCode()) % m_cBuckets);
        }
    }

    [XomPerformanceCounterCategoryAttr("Social Cache - Hash Table", "Xbox Live Social Cache Server Per Hash Table Counters")]
    public class SocialCacheHashTableCounters : XomPerformanceCounterCategory
    {
        public SocialCacheHashTableCounters()
            : base(true)
        {
        }

        public virtual SocialCacheHashTableCounters this[string sType]
        {
            get
            {
                return (SocialCacheHashTableCounters)GetInstance(sType);
            }
        }

        static public SocialCacheHashTableCounters Total = new SocialCacheHashTableCounters();

        [XomPerformanceCounterAttr(
            "Entries",
            "Number of entries in hash table",
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter Entries;

        [XomPerformanceCounterAttr(
            "Memory Used",
            "Memory used by all hash table entries, in bytes",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter MemoryUsed;

        [XomPerformanceCounterAttr(
            "Batch Rate",
            "Number of request batches per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter BatchRate;

        [XomPerformanceCounterAttr(
            "Key Lock Rate",
            "Number of key locks per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter LockRate;

        [XomPerformanceCounterAttr(
            "Found Rate",
            "Number of hash lookups found per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FoundRate;

        [XomPerformanceCounterAttr(
            "Miss Rate",
            "Number of hash lookups missed per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter MissRate;

        [XomPerformanceCounterAttr(
            "Write Rate",
            "Number of hash writes per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter WriteRate;

        [XomPerformanceCounterAttr(
            "Delete Rate",
            "Number of hash deletes per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter DeleteRate;

        [XomPerformanceCounterAttr(
            "Expiration Rate",
            "Number of entry expirations per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ExpirationRate;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\SocialCache\inh\NotificationHandlerContext.cs ===
﻿using System;
using xonline.common.community;
using xonline.common.mgmt;
using System.Diagnostics;

namespace xonline.server.SocialCache
{
    public class NotificationChangeHandlerContext : SocialCacheContext
    {
        private string[] m_rgChangedKeys;
        private Object[] m_rgKeyStates;

        public NotificationChangeHandlerContext(string[] rgKeys, Object[] rgKeyStates)
        {
            m_rgChangedKeys = rgKeys;
            m_rgKeyStates = rgKeyStates;
        }

        //-----------------------------------------------------------------------
        // Callback for when things change in the acceleration cache.
        //-----------------------------------------------------------------------
        public static void OnMemCacheNotification(string[] rgChangedKeys, Object[] rgKeyStates)
        {
            NotificationChangeHandlerContext ctxChange = new NotificationChangeHandlerContext(rgChangedKeys, rgKeyStates);
            SocialCacheEngine.QueueContext(ThreadType.eData, ctxChange, null);
        }

        //-----------------------------------------------------------------------
        // Process the keys.
        //-----------------------------------------------------------------------
        public override void ProcessInternal(Object state)
        {
            for (int iKey = 0; iKey < m_rgChangedKeys.Length; iKey++)
            {
                //
                // Check if m_rgChangedKeys[i] is a key we care about.
                // If it is, remove it from the appropriate hash table.
                //
                try
                {
                    DATA_OBJECT_SPECIFIER doSpec = CacheUtil.GetDataKeyFromString(m_rgChangedKeys[iKey]);
                    switch (doSpec.wDataType)
                    {
                        case (ushort)(DATA_TYPES.eFriendsList):
                            SocialCache.Relationships.RemoveRelationships(doSpec.qwOwnerXUID);
                            break;
                        case (ushort)(DATA_TYPES.eLimitedPresence):
                            SocialCache.Users.RemoveUser(doSpec.qwOwnerXUID);
                            break;
                        default:
                            // Skip this key.
                            break;
                    }
                }
                catch (ApplicationException)
                {
                    // Unknown notification type, skip it.
                 
                }
            }
            SocialCacheChangeNotificationCounters.Current.ItemRate.IncrementBy(m_rgChangedKeys.Length);
        }
    }

    [XomPerformanceCounterCategoryAttr("Social Cache - Change Notifications", "Xbox Live Social Cache Server Change Notification Counters")]
    public class SocialCacheChangeNotificationCounters : XomPerformanceCounterCategory
    {
        public SocialCacheChangeNotificationCounters()
            : base(true)
        {
        }

        static public SocialCacheChangeNotificationCounters Current = new SocialCacheChangeNotificationCounters();

        [XomPerformanceCounterAttr(
            "Item Rate",
            "Number of item notifications processed per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ItemRate;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\SocialCache\inh\ProjectInstaller.cs ===
//-----------------------------------------------------------------------
//  This file is part of the Microsoft .NET SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//-----------------------------------------------------------------------

using System;
using System.Collections;
using System.Configuration.Install;
using System.ServiceProcess;
using System.ComponentModel;
using System.Diagnostics;

using xonline.common.config;
using xonline.common.service;

[RunInstallerAttribute(true)]
public class ProjectInstaller: System.Configuration.Install.Installer
{

    private ServiceInstaller serviceInstaller;
    private ServiceProcessInstaller processInstaller;
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.Container components = null;

        public ProjectInstaller()
        {
            // This call is required by the Designer.
            InitializeComponent();
        }

        /// <summary> 
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if( disposing )
            {
                if(components != null)
                {
                    components.Dispose();
                }
            }
            base.Dispose( disposing );
        }


 #region Component Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            processInstaller = new ServiceProcessInstaller();
            serviceInstaller = new ServiceInstaller();
          

#if (DEV_TEST)
            processInstaller.Account = System.ServiceProcess.ServiceAccount.LocalSystem;
#else
            IComponentInfo compInfo = Config.GetComponent(xonline.common.config.Component.SocialCache);

            LSAUtil.GrantLogonRights( compInfo.Username );

            processInstaller.Account = System.ServiceProcess.ServiceAccount.User;
            processInstaller.Username = compInfo.Username;

            CSetupSecureResolver decoder = new CSetupSecureResolver();
            processInstaller.Password = decoder.UserSecret(compInfo.Password);
#endif
  
            serviceInstaller.ServiceName = "SocialCache";
            serviceInstaller.DisplayName = "Xbox Live Social Cache Server";
            serviceInstaller.Description = "Service for processing social graph requests Xbox Live users";
            serviceInstaller.StartType = System.ServiceProcess.ServiceStartMode.Automatic;
            serviceInstaller.Committed += new System.Configuration.Install.InstallEventHandler(this.SocialCache_Committed);

            Installers.Add(serviceInstaller);
            Installers.Add(processInstaller);

            }
#endregion

    private void SocialCache_Committed(object sender, System.Configuration.Install.InstallEventArgs e)
    {
        System.ServiceProcess.ServiceController svc = new System.ServiceProcess.ServiceController("SocialCache");
        svc.Start();
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\SocialCache\inh\Request.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using System.Diagnostics;
using System.Text;

using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.config;

using xonline.common.community;
using xonline.common.community.socialquery;
using xonline.common.community.socialquery.protocol;

namespace xonline.server.SocialCache
{
    public class QueryContext : SocialCacheContext
    {
        public ISocialQueryProcessor processor;

        public QueryContext(ISocialQueryProcessor processorIn)
        {
            processor = processorIn;
        }

        public override void ProcessInternal(Object state)
        {
            switch (m_threadType)
            {
                case ThreadType.eData:
                    processor.ProcessRequest();
                    break;

                case ThreadType.eWorker:
                    processor.Reply();
                    break;

                default:                                
                    Debug.Assert(false, "QueryContext:ProcessInternal() called on unknown thread type.");
                    break;            
            }            
        }
    }

    public class UserRequestContext : SocialCacheContext
    {      
        static UserRequestContext()
        {
            // initialize the request message map.
            s_MessageMap = new MessageHandler[]
            {
                new MessageHandler((uint)SOCIALCACHE_MESSAGE_TYPES.eHelloINH, typeof(HealthCheckINH)),
                new MessageHandler((uint)SOCIALCACHE_MESSAGE_TYPES.eGetFriendsINH, typeof(GetFriendsProcessorINH)),
                // add new message handler here
            };                
        }

        static MessageHandler[] s_MessageMap = null;

        public byte[] m_rgbEntireMessage;
        public int m_dwWriteOffset;
        
        protected ClientConnection m_cliConn;

        protected uint m_dwMsgType;
        protected uint m_dwSeqNum;
        protected uint m_dwHeaderFlags;
        
        protected XomRequestTimeElapsed m_timeElapsed = null;
        protected StringBuilder m_sbLogParams = null;
            
        public HResult m_hr = HResult.S_OK;

        public UserRequestContext(ClientConnection cliConn)
        {
            m_cliConn = cliConn;
        }

        public override void ProcessInternal(Object state)
        {
            m_timeElapsed = new XomRequestTimeElapsed();
            
            MessageHandler msgHandler = ValidateMessage();

            if (msgHandler != null)
            {
                AddLogParameter(SocialCacheDefs.MessageTypeToString(m_dwMsgType));
                AddLogParameter(m_cliConn.IPAddress);
                AddLogParameter(m_dwHeaderFlags.ToString("X"));
                AddLogParameter(m_dwSeqNum.ToString("X"));
                
                // call the actual handler for this message type.       
                ISocialQueryProcessor processor = (ISocialQueryProcessor)Activator.CreateInstance(msgHandler.type, new object[] { this });                              
                SocialCacheEngine.QueueContext(ThreadType.eData, new QueryContext(processor), null);            
            }
        }

        public void AddLogParameter(object logParam)
        {
            if (m_sbLogParams == null)
            {
                m_sbLogParams = new StringBuilder();
            }

            m_sbLogParams.Append(logParam.ToString());
            m_sbLogParams.Append("|");
        }

        private void CompleteAPI()
        {
            // update perfcounters
            SocialCacheAPICounters.Total[m_dwMsgType].RequestsPerSecond.Increment();
            SocialCacheAPICounters.Total.RequestsPerSecond.Increment();
            SocialCacheAPICounters.Total[m_dwMsgType].ResponseTimeAvgBase.Increment();
            SocialCacheAPICounters.Total.ResponseTimeAvgBase.Increment();
            SocialCacheAPICounters.Total[m_dwMsgType].ResponseTimeAvg.IncrementBy(m_timeElapsed.TimeElapsed);
            SocialCacheAPICounters.Total.ResponseTimeAvg.IncrementBy(m_timeElapsed.TimeElapsed);

            if (HResult.Succeeded(m_hr))
            {
                SocialCacheAPICounters.Total[m_dwMsgType].SuccessRate.Increment();
                SocialCacheAPICounters.Total.SuccessRate.Increment();
            }
            else
            {
                SocialCacheAPICounters.Total[m_dwMsgType].FailureRate.Increment();
                SocialCacheAPICounters.Total.FailureRate.Increment();
            }

            SocialCache.Instance.Log(m_sbLogParams.ToString());
        }

        private unsafe MessageHandler ValidateMessage()
        {
            MessageHandler msgHandler;
            
            fixed (byte *pBuffer = &(m_rgbEntireMessage[0]))
            {
                SOCIALCACHE_BASE_MESSAGE_HEADER *pHeader = (SOCIALCACHE_BASE_MESSAGE_HEADER *)pBuffer;

                if (pHeader->dwProtocolVersion > SocialCacheDefs.CURRENT_PROTOCOL_VERSION)
                {
                    Xom.NtEvent(XEvent.Id.SOCIALCACHE_PROTOCOL_VERSION_MISMATCH, "Invalid protocol version (" + pHeader->dwProtocolVersion + ") from client " + m_cliConn.IPAddress + ".");
                    return null;
                }

                if ((pHeader->dwMessageType < SocialCacheDefs.MIN_REQUEST_TYPE) ||
                    (pHeader->dwMessageType > SocialCacheDefs.MAX_REQUEST_TYPE))
                {
                    Xom.NtEvent(XEvent.Id.SOCIALCACHE_MSGTYPE_UNKNOWN, "Unknown message type (" + pHeader->dwMessageType + ") from client " + m_cliConn.IPAddress + ".");
                    return null;
                }

                msgHandler = s_MessageMap[pHeader->dwMessageType - SocialCacheDefs.MIN_REQUEST_TYPE];

                m_dwMsgType = pHeader->dwMessageType;
                m_dwSeqNum = pHeader->dwSeqNum;
                m_dwHeaderFlags = pHeader->dwHeaderFlags;                
            }

            return msgHandler;
        }
        
        public static void SendResponse(ErrorReply reply, UserRequestContext ctx, uint dwMessageType)
        {
            reply.dwSeqNum = ctx.m_dwSeqNum;
            reply.hr = HResult.S_OK;

            byte[] rgbResponse = (byte[])reply;

            ctx.m_cliConn.Send(rgbResponse, rgbResponse.Length);

            if (HResult.Failed(ctx.m_hr))
            {
                ctx.m_cliConn.Disconnect();
            }

            ctx.AddLogParameter(SocialCacheDefs.MessageTypeToString(dwMessageType));
            ctx.AddLogParameter(ctx.m_hr);

            ctx.CompleteAPI();
        }
        
        public static unsafe void ProcessUnsupportedMessage(UserRequestContext ctx)
        {
            uint dwMsgType;
            
            fixed (byte *pBuffer = &(ctx.m_rgbEntireMessage[0]))
            {
                SOCIALCACHE_BASE_MESSAGE_HEADER *pHeader = (SOCIALCACHE_BASE_MESSAGE_HEADER *)pBuffer;
                dwMsgType = pHeader->dwMessageType;
            }

            Xom.NtEvent(XEvent.Id.SOCIALCACHE_MSGTYPE_UNSUPPORTED, "Unsupported message type (" + dwMsgType + ") from client " + ctx.m_cliConn.IPAddress + ".");

            ctx.m_cliConn.Disconnect();
        }
        
        private class MessageHandler
        {
            public MessageHandler(uint msgType, Type typeIn)
            {
                dwMsgType = msgType;
                type = typeIn;
            }
            
            public uint dwMsgType;
            public Type type;            
        };
        
    };    

    [XomPerformanceCounterCategoryAttr( "Social Cache - API", "Xbox Live Social Cache Server Per API Counters" )]
    public class SocialCacheAPICounters : XomPerformanceCounterCategory
    {
        public SocialCacheAPICounters() : base(true)
        {
        }
               
        public virtual SocialCacheAPICounters this[uint dwMsgType]
        {
            get
            {
                return (SocialCacheAPICounters) GetInstance(SocialCacheDefs.MessageTypeToString(dwMsgType));
            }
        }

        static public SocialCacheAPICounters Total = new SocialCacheAPICounters();
        
        [XomPerformanceCounterAttr(
            "Requests per Second", 
            "Number of requests per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
            "Average Response Time (ms)", 
            "Average time (in milliseconds) a request takes to be processed.", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter ResponseTimeAvg;
        
        [XomPerformanceCounterAttr(
            "Average Respone Time Base", 
            "Base for Average time a request takes to be processed.",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter ResponseTimeAvgBase;

        [XomPerformanceCounterAttr(
            "Success Rate", 
            "Number of requests succeeded per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SuccessRate;

        [XomPerformanceCounterAttr(
            "Failure Rate", 
            "Number of requests failed per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailureRate;

    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\SocialCache\inh\msgr\AsyncResult.cs ===
//-----------------------------------------------------------------------
// <copyright file="AsyncResult.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//     Represents an asynchronous result object.
// </summary>
//
// <history>
//     2007/01/26  sgordon    Moved from the ServiceProxy library to the
//                            Messenger runtime.
//     2007/03/03  sgordon    Added support for the WaitHandle property.
// </history>
//-----------------------------------------------------------------------

namespace MS.Msn.Messenger.Runtime
{
    using System;
    using System.Threading;

    /// <summary>
    /// Generic IAsyncResult implementation. The result type is a generic type.
    /// </summary>
    /// <typeparam name="ResultType">Result that should be returned from the end method</typeparam>
    public class AsyncResult<ResultType> : IAsyncResult
    {
        /// <summary>
        /// The asynchronous callback.
        /// </summary>
        private readonly AsyncCallback callback;

        /// <summary>
        /// The associated state object.
        /// </summary>
        private readonly Object state;

        /// <summary>
        /// Whether the operation has completed.
        /// </summary>
        private bool isCompleted;

        /// <summary>
        /// Whether the operation completed synchronously.
        /// </summary>
        private bool completedSynchronously;

        /// <summary>
        /// The associated result code.
        /// </summary>
        private ResultType result;

        /// <summary>
        /// The associated exception.
        /// </summary>
        private Exception exception;

        /// <summary>
        /// The associated wait handle.
        /// </summary>
        private ManualResetEvent waitHandle;

        /// <summary>
        /// Ctor. Saves off callback and state values to be invoked later.
        /// </summary>
        /// <param name="callback">Callback to invoke when operation completes</param>
        /// <param name="state">State to associate with the operation</param>
        public AsyncResult(AsyncCallback callback, Object state)
        {
            this.callback = callback;
            this.state = state;
        }

        /// <summary>
        /// Returns operation result
        /// </summary>
        public ResultType Result
        {
            get { return this.result; }
        }

        /// <summary>
        /// Gets the associated exception, if any.
        /// </summary>
        public Exception Exception
        {
            get { return this.exception; }
        }

        /// <summary>
        /// AsyncState
        /// </summary>
        public object AsyncState
        {
            get { return this.state; }
        }

        /// <summary>
        /// Gets a WaitHandle that is used to wait for an asynchronous operation to complete.
        /// </summary>
        public WaitHandle AsyncWaitHandle
        {
            get
            {
                lock (this)
                {
                    if (this.waitHandle == null)
                    {
                        this.waitHandle = new ManualResetEvent(false);
                    }

                    // If the caller gets the WaitHandle, and we've already
                    // completed, we need to call Set so that they don't block
                    // forever.
                    if (this.IsCompleted)
                    {
                        try
                        {
                            this.waitHandle.Set();
                        }
                        catch (ObjectDisposedException)
                        {
                        }
                    }
                    }

                return this.waitHandle;
            }
        }

        /// <summary>
        /// <c>true</c> if operation completed synchronously
        /// </summary>
        public bool CompletedSynchronously
        {
            get { return this.completedSynchronously; }
        }

        /// <summary>
        /// <c>true</c> if operation completed
        /// </summary>
        public bool IsCompleted
        {
            get { return this.isCompleted; }
        }

        /// <summary>
        /// The callback that should be called upon completion.
        /// </summary>
        protected AsyncCallback Callback
        {
            get { return this.callback; }
        }

        /// <summary>
        /// Completes the request. Invokes saved off callback to notify caller
        /// that operation has been completed.
        /// </summary>
        /// <param name="result">Operation result</param>
        /// <param name="completedSynchronously"><c>true</c> if completed 
        /// synchronously</param>
        public virtual void CompleteRequest(ResultType result, bool completedSynchronously)
        {
            this.result = result;
            this.completedSynchronously = completedSynchronously;
            this.SignalCompleted();
        }

        /// <summary>
        /// Completes the request. Invokes the saved callback to notify the caller
        /// that the operation has completed with an exception.
        /// </summary>
        /// <param name="exception">The exception that occurred.</param>
        /// <param name="completedSynchronously">Whether the operation completed
        /// synchronously.</param>
        public void CompleteRequest(Exception exception, bool completedSynchronously)
        {
            this.exception = exception;
            this.completedSynchronously = completedSynchronously;
            this.SignalCompleted();
        }

        /// <summary>
        /// More efficient call than grabbing the AsyncWaitHandle - ManualResetEvent
        /// is not created if we've already completed.
        /// </summary>
        public void BlockUntilCompleted()
        {
            lock (this)
            {
                if (this.isCompleted)
                {
                    return;
                }
            }

            this.AsyncWaitHandle.WaitOne();
        }

        /// <summary>
        /// Signals that the async result has completed.
        /// </summary>
        private void SignalCompleted()
        {
            lock (this)
            {
                this.isCompleted = true;

                if (this.waitHandle != null)
                {
                    try
                    {
                        this.waitHandle.Set();
                    }
                    catch (ObjectDisposedException)
                    {
                    }
                }
            }

            if (this.callback != null)
            {
                this.callback(this);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\SocialCache\inh\msgr\interop.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Net;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Threading;

namespace MS.Msn.Messenger.Runtime
{

    /// <summary>
    /// Some of the imports from Kernel32
    /// </summary>
    internal class Kernel32
    {
        static public IntPtr INVALID_HANDLE_VALUE = (IntPtr)(-1);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern Int32 GetQueuedCompletionStatus(
            IntPtr CompletionPort,
            ref Int32 lpNumberOfBytes,
            ref Int32 lpCompletionKey,
            ref IntPtr lpOverlapped,
            Int32 dwMilliseconds
            );

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern Int32 PostQueuedCompletionStatus(
            IntPtr CompletionPort,
            Int32 NumberOfBytes,
            Int32 CompletionKey,
            IntPtr lpOverlapped
            );

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern Int32 ReadFile(
            IntPtr hFile,
            IntPtr lpBuffer,
            Int32 nNumberOfBytesToRead,
            IntPtr lpNumberOfBytesRead,
            IntPtr lpOverlapped
            );


        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern Int32 DuplicateHandle(
            IntPtr hSourceProcessHandle,
            IntPtr hSourceHandle,
            IntPtr hTargetProcessHandle,
            ref IntPtr lpTargetHandle,
            Int32 dwDesiredAccess,
            Int32 bInheritHandle,
            Int32 dwOptions
            );

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern Int32 CloseHandle(
            IntPtr hHandle
            );

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr CreateIoCompletionPort(
            IntPtr FileHandle,
            IntPtr ExistingCompletionPort,
            IntPtr CompletionKey,
            Int32 NumberOfConcurrentThreads
            );

        [DllImport("kernel32.dll", EntryPoint = "RtlZeroMemory", SetLastError = true)]
        public static extern void ZeroMemory(
            IntPtr Destination,
            IntPtr Length
            );

        [DllImport("kernel32.dll")]
        public static extern uint GetTickCount();
    }

    /// <summary>
    /// Some of the imports from Winsock
    /// </summary>
    internal class Winsock
    {
        public const int WSA_FLAG_OVERLAPPED = 1;

        [DllImport("ws2_32.dll", EntryPoint = "WSASocketW", SetLastError = true)]
        public static extern IntPtr WSASocket(
            AddressFamily af,
            SocketType type,
            ProtocolType protocol,
            IntPtr lpProtocolInfo,
            int g,
            int dwFlags
            );


        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int setsockopt(
            IntPtr socket,
            SocketOptionLevel level,
            SocketOptionName name,
            ref Int32 buffer,
            int bufferSize
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int setsockopt(
            IntPtr socket,
            SocketOptionLevel level,
            SocketOptionName name,
            ref byte buffer,
            int bufferSize
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int getsockopt(
            IntPtr socket,
            SocketOptionLevel level,
            SocketOptionName name,
            ref Int32 buffer,
            ref Int32 bufferSize
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int setsockopt(
            IntPtr socket,
            SocketOptionLevel level,
            SocketOptionName name,
            ref IntPtr buffer,
            int bufferSize
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int bind(
            IntPtr socket,
            ref sockaddr_in sockaddr,
            int size
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int listen(
            IntPtr socket,
            int backlog
            );

        [DllImport("mswsock.dll", SetLastError = true)]
        public static extern bool AcceptEx(
            IntPtr listenSocket,
            IntPtr acceptSocket,
            IntPtr outputBuffer,
            int receiveDataLength,
            int localAddressLength,
            int remoteAddressLength,
            ref int bytesReceived,
            IntPtr overlapped
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int shutdown(
            IntPtr socket
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int closesocket(
            IntPtr socket
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int WSARecv(
            IntPtr socket,
            ref WSABUF buf,
            int count,
            ref int readCount,
            ref int flags,
            IntPtr overlapped,
            IntPtr expectNULL
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int WSASend(
            IntPtr socket,
            ref WSABUF buf,
            int count,
            ref int writeCount,
            int flags,
            IntPtr  overlapped,
            IntPtr expectNULL
            );

        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int WSAGetOverlappedResult(
            IntPtr socket,
            IntPtr overlapped,
            ref int transferedBytes,
            int fWait,
            ref int flags
            );


        [DllImport("ws2_32.dll", SetLastError = true)]
        public static extern int WSAIoctl(
            IntPtr socket,
            IOControlCode ioControlCode,
            IntPtr inBuffer,
            int cbInBuffer,
            IntPtr outBuffer,
            int cbOutBuffer,
            ref int bytesReturned,
            IntPtr overlapped,
            IntPtr completionRoutine
            );

        [DllImport("wsock32.dll", SetLastError = true)]
        public static extern int getsockname(
            IntPtr socket,
            IntPtr buffer,
            ref int addrSize
            );

        // We use sockaddr_in here in place of sockaddr (these are equivalent)
        [DllImport("wsock32.dll", SetLastError = true)]
        public static extern int getpeername(
            IntPtr socket,
            ref sockaddr_in addr,
            ref int addrSize
            );

        [DllImport("wsock32.dll", SetLastError = true)]
        public static extern int WSAStartup(
            UInt16 wVersionRequested,
            ref WSADATA lpWSAData
            );


        [StructLayout(LayoutKind.Sequential)]
        public struct tcp_keepalive
        {
            public uint onOff;
            public uint keepAliveTime;
            public uint keepAliveInterval;
        };

        [StructLayout(LayoutKind.Sequential)]
        public struct WSADATA
        {
            ushort wVersion;
            ushort wHighVersion;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 256 + 1)]
            byte[] szDescription;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 128 + 1)]
            byte[] szSystemStatus;
            ushort iMaxSockets;
            ushort iMaxUdpDg;
            public IntPtr lpVendorInfo;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct WSABUF
        {
            public Int32 len;
            public IntPtr buf;
        };

        // Structures "sockaddr_in" and "sockaddr" are interchangeable in API. They
        // represent a different way to access for the same layout. We choose to
        // use sockaddr_in in some APIs that call for sockaddr.
        [StructLayout(LayoutKind.Sequential)]
        public struct sockaddr_in
        {
            public short sin_family;
            public ushort port;
            public int address;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
            public byte[] zeroes;

            public ushort sin_port
            {
                get { return (ushort)(((((ushort)port) & 0xFF) << 8) | (((ushort)port) >> 8)); }
            }

            public sockaddr_in(int address, int port)
            {
                sin_family = 2 /* AF_INET*/;
                this.port = (ushort)(((((ushort)port) & 0xFF) << 8) | (((ushort)port) >> 8));
                byte[] bytes = BitConverter.GetBytes(address);
                this.address = address;
                zeroes = new byte[8];
            }

            // Marshal.* makes a linkdemand which is not required by this function
            // This is ok as we are not shipping this dll for use by any other applications other than
            // messenger.  So the FXCOP warning here is not applicable.

            internal static readonly int Size = Marshal.SizeOf(new sockaddr_in());
        };

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\SocialCache\inh\msgr\SocketLayer.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Net;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Threading;

using xonline.common.mgmt;

namespace MS.Msn.Messenger.Runtime
{

    /// <summary>
    /// Called when a new socket has been accepted.
    /// </summary>
    /// <param name="acceptedSocketIndex"></param>
    /// <param name="error"></param>
    public delegate void AcceptCallback(int acceptedSocketIndex, SocketError error);

    /// <summary>
    /// Called when a read has been performed.
    /// </summary>
    /// <param name="socketIndex"></param>
    /// <param name="error"></param>
    /// <param name="buffer"></param>
    /// <param name="offset"></param>
    /// <param name="bytes"></param>
    public delegate void ReadCallback(int socketIndex, SocketError error, IntPtr buffer, int offset, int bytes);

    /// <summary>
    /// Called when a write has been performed.
    /// </summary>
    /// <param name="socketIndex"></param>
    /// <param name="error"></param>
    public delegate void WriteCallback(int socketIndex, SocketError error);

    /// <summary>
    /// Exception in the socket handling code.
    /// </summary>
    public class MySocketException : ApplicationException
    {
        /// <summary>
        ///
        /// </summary>
        public MySocketException() { }

        /// <summary>
        ///
        /// </summary>
        /// <param name="error"></param>
        public MySocketException(int error) : base("", new SocketException(error)) { }

        /// <summary>
        ///
        /// </summary>
        /// <param name="message"></param>
        public MySocketException(string message) : base(message) { }
    }


    internal struct MySocket
    {
        // The index into the SocketLayer.sockets array is composed of two
        // parts: the lower 24 bits indicate the actual array index (also
        // referred to as the 'realIndex'), while the upper 8 bits will
        // be incremented sequentially with every reuse of MySocket.
        // This compound number is return to TcpConnectionListener and
        // stored in TxpConnectionUsingSocketLayer.

        internal const int indexBits = 24;
        internal const int indexMask = 0xFFFFFF;
        internal int index;

        internal int nextFree;
        internal IntPtr sock;

        internal bool boundToIoPort;

        internal IntPtr readOverlappedPtr;
        internal IntPtr writeOverlappedPtr;
        internal IntPtr acceptOverlappedPtr;

        ReadCallback onRead;
        WriteCallback onWrite;
        AcceptCallback onAccept;

        int acceptSockIndex;

        IntPtr readBuffer;
        int readBufferSize;
        IntPtr writeBuffer;
        int writeBufferSize;
        int bytesToWrite;
        int bytesWritten;
        object syncObject;

        void Clear()
        { 
            bytesWritten = bytesToWrite = 0;
            onAccept = null;
            onRead = null;
            onWrite = null;
            acceptSockIndex = -1;
        }

        internal static void ClearOverlapped(IntPtr overlappedPtr)
        {
            Kernel32.ZeroMemory(overlappedPtr, (IntPtr)MyOverlapped.Size);
        }

        internal void VerifyIndex(int realIndex)
        {
            if (index != realIndex)
            {
                throw new ObjectDisposedException(
                    String.Format(
                    "Socket {0} must have been cleared out because current index at that slot = {1}.",
                    realIndex, index));
            }
        }


        void OnWrite(SocketError error)
        {
            WriteCallback writeCallback = onWrite;
            if (writeCallback != null)
            {
                writeCallback(index, error);
            }
        }


        bool OperationPending(int error)
        {
            return error == (int)SocketError.InProgress ||
                error == (int)SocketError.IOPending ||
                error == 996 /* ERROR_IO_INCOMPLETE */;
        }

        private void GetPeerIpAddress()
        {
            if (this.ipaddress == null)
            {
                Winsock.sockaddr_in addr = new Winsock.sockaddr_in();
                int addrSize = Winsock.sockaddr_in.Size;

                // An alternative to getpeername() is GetAcceptExSockaddrs(). However,
                // the latter is typically invoked right after AcceptEx(), at which point
                // the socket is not yet completely connected (it will be in IOPending
                // state). It could be because the "on accept" callback must complete
                // first.
                //
                // Attempts to execute getpeername() right after accept were not successful
                // with error codes indicating "not connected" (yet).
                if (Winsock.getpeername(this.sock, ref addr, ref addrSize) == 0)
                {
                    try
                    {
                        Int64 address = 0x00000000FFFFFFFF & Convert.ToInt64(addr.address);
                        this.ipaddress = new IPAddress(address);
                        this.port = addr.sin_port;
                    }
                    catch (Exception)
                    {
                        this.ipaddress = IPAddress.None;
                        this.port = 0;
                    }
                }
                else
                {
                    this.ipaddress = IPAddress.None;
                    this.port = 0;
                }
            }
        }

        internal int Initialize(int newIndex, IntPtr sock, IntPtr readBuffer, int readBufferSize, IntPtr writeBuffer, int writeBufferSize, IntPtr overlappedBuffers)
        {
            Clear();
            if (null == syncObject) syncObject = new Object();
            index = (((index >> indexBits) + 1) << indexBits) + newIndex;
            this.sock = sock;
            this.readBuffer = readBuffer;
            this.readBufferSize = readBufferSize;
            this.writeBuffer = writeBuffer;
            this.writeBufferSize = writeBufferSize;
            this.readOverlappedPtr = overlappedBuffers;
            this.writeOverlappedPtr = AddOffset(overlappedBuffers, MyOverlapped.Size);
            this.acceptOverlappedPtr = AddOffset(overlappedBuffers, MyOverlapped.Size * 2);
            this.ipaddress = null;
            this.port = 0;

            return index;
        }

        static internal IntPtr AddOffset(IntPtr baseAddress, int offset)
        {
            if (offset == 0) return baseAddress;
            return (IntPtr)(baseAddress.ToInt64() + offset);
        }

        internal bool Close(int socketIndex, bool clearIndex)
        {
            bool closedSocket = false;
            bool clearedIndex = false;

            lock (syncObject)
            {
                if (index == socketIndex)
                {
                    if (sock != Kernel32.INVALID_HANDLE_VALUE)
                    {
                        Winsock.shutdown(sock);
                        Winsock.closesocket(sock);
                        sock = Kernel32.INVALID_HANDLE_VALUE;
                        boundToIoPort = false;
                        closedSocket = true;
                    }

                    if (clearIndex)
                    {
                        index &= ~indexMask;
                        clearedIndex = true;
                    }

                    Clear();
                }
            }

            if (closedSocket) 
                Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogTcpConnectionClosed(" + socketIndex.ToString() +")");

            return clearedIndex;
        }

        internal SocketError PostAccept(int socketIndex, IntPtr acceptSocket, int acceptSocketIndex, AcceptCallback acceptCallback)
        {
            SocketError result;

            lock (syncObject)
            {
                VerifyIndex(socketIndex);

                if (HasOutstandingIO())
                {
                    return SocketError.AlreadyInProgress;
                }

                onAccept = acceptCallback;
                acceptSockIndex = acceptSocketIndex;
                int bytesReceived = 0; // don't care about this.

                ClearOverlapped(acceptOverlappedPtr);
                bool succeeded = Winsock.AcceptEx(
                    sock, acceptSocket, readBuffer, 0,
                    Winsock.sockaddr_in.Size + 16,
                    Winsock.sockaddr_in.Size + 16,
                    ref bytesReceived,
                    acceptOverlappedPtr
                    );
                result = ProcessResult(succeeded);
            }

            // $BUGBUG: should we call OnAccept if operation failed?

            return result;
        }

        internal SocketError PostRead(int socketIndex, ReadCallback readCallback)
        {
            SocketError result;

            lock (syncObject)
            {
                VerifyIndex(socketIndex);

                if (onRead != null)
                {
                    return SocketError.AlreadyInProgress;
                }

                this.GetPeerIpAddress();

                int bytes = 0;
                int flags = 0;
                Winsock.WSABUF buf;

                buf.buf = readBuffer;
                buf.len = readBufferSize;

                onRead = readCallback;
                ClearOverlapped(readOverlappedPtr);

                bool succeeded = (-1 != Winsock.WSARecv(sock, ref buf, 1, ref bytes, ref flags, readOverlappedPtr, IntPtr.Zero));
                result = ProcessResult(succeeded);
            }

            // $BUGBUG: should we call OnRead if operation failed?

            return result;
        }

        SocketError PostWriteNoStateCheck(int socketIndex, int bufferOffset, int bytesToWrite)
        {
            int bytes = 0;
            int flags = 0;
            Winsock.WSABUF buf;
            SocketError result;

            lock (syncObject)
            {
                if (socketIndex != index) return SocketError.NotConnected;

                buf.buf = AddOffset(writeBuffer, bufferOffset);
                buf.len = bytesToWrite;

                ClearOverlapped(writeOverlappedPtr);

                bool succeeded = (-1 != Winsock.WSASend(sock, ref buf, 1, ref bytes, flags, writeOverlappedPtr, IntPtr.Zero));
                result = ProcessResult(succeeded);
            }

            if (result != SocketError.Success)
            {
                OnWrite(result);
            }

            return result;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2122", Justification = "Verify false positive: Marshal.* makes a linkdemand which is not required by this function. This is ok as we are not shipping this dll for use by any other applications other than messenger.")]
        internal SocketError PostWrite(int socketIndex, byte[] buffer, int offset, int bytesToWrite, WriteCallback writeCallback)
        {
            lock (syncObject)
            {
                VerifyIndex(socketIndex);

                if (onWrite != null)
                {
                    return SocketError.AlreadyInProgress;
                }

                if (this.bytesToWrite + bytesToWrite > writeBufferSize)
                {
                    throw new MySocketException((int)SocketError.MessageSize);
                }

                onWrite = writeCallback;

                Marshal.Copy(buffer, offset, (IntPtr)(writeBuffer.ToInt64() + this.bytesToWrite), bytesToWrite);

                this.bytesToWrite += bytesToWrite;
            }

            if(writeCallback != null)
            {
                return PostWriteNoStateCheck(socketIndex, 0, bytesToWrite);
            }

            return SocketError.Success;
        }

        bool AcceptCompleted(int socketIndex)
        {
            int bytesCount = 0;
            int flags = 0;
            SocketError socketError = SocketError.Success;
            bool completed = false;
            AcceptCallback acceptCallback = null;
            int acceptSocketIndex = -1;

            lock (syncObject)
            {
                if (index != socketIndex) return false;

                acceptSocketIndex = acceptSockIndex;
                acceptCallback = onAccept;

                if (acceptCallback == null) return false;

                if (0 == Winsock.WSAGetOverlappedResult(sock, acceptOverlappedPtr, ref bytesCount, 0, ref flags))
                {
                    int error = Marshal.GetLastWin32Error();
                    if (!OperationPending(error))
                    {
                        socketError = (SocketError)error;
                        completed = true;
                    }
                }
                else
                {
                    completed = true;
                }

                if (completed)
                {
                    onAccept = null;
                    acceptSockIndex = -1;
                }
            }

            if (completed)
            {
                if (socketError != SocketError.Success) Close(acceptSocketIndex, false);
                acceptCallback(acceptSocketIndex, socketError);
                return true;
            }

            return false;
        }

        bool WriteCompleted(int socketIndex)
        {
            int bytesCount = 0;
            int flags = 0;
            SocketError socketError = SocketError.Success;
            bool completed = false;
            bool partialWrite = false;
            WriteCallback writeCallback = null;
            int partialWriteOffset = 0;
            int partialWriteCount = 0;

            lock (syncObject)
            {
                if (index != socketIndex) return false;

                writeCallback = onWrite;

                if (writeCallback == null) return false;

                if (0 == Winsock.WSAGetOverlappedResult(sock, writeOverlappedPtr, ref bytesCount, 0, ref flags))
                {
                    int error = Marshal.GetLastWin32Error();
                    if (!OperationPending(error))
                    {
                        socketError = (SocketError)error;
                        completed = true;
                    }
                }
                else
                {
                    bytesWritten += bytesCount;
                    if (bytesToWrite == bytesWritten)
                    {
                        bytesToWrite = bytesWritten = 0;
                        onWrite = null;
                        completed = true;
                    }
                    else
                    {
                        partialWrite = true;
                        partialWriteOffset = bytesWritten;
                        partialWriteCount = bytesToWrite - bytesWritten;
                    }
                }
            }

            if (completed)
            {
                if (socketError != SocketError.Success) Close(socketIndex, false);
                writeCallback(socketIndex, socketError);
                return true;
            }

            if (partialWrite)
            {
                //
                // Partial write? Schedule the rest of it.
                //

                PostWriteNoStateCheck(socketIndex, partialWriteOffset, partialWriteCount);
                return true;
            }

            return false;
        }

        bool ReadCompleted(int socketIndex)
        {
            int bytesCount = 0;
            int flags = 0;
            SocketError socketError = SocketError.Success;
            bool completed = false;
            ReadCallback readCallback = null;

            lock (syncObject)
            {
                if (index != socketIndex) return false;

                readCallback = onRead;

                if (readCallback == null) return false;

                if (0 == Winsock.WSAGetOverlappedResult(sock, readOverlappedPtr, ref bytesCount, 0, ref flags))
                {
                    int error = Marshal.GetLastWin32Error();
                    if (!OperationPending(error))
                    {
                        socketError = (SocketError)error;
                        completed = true;
                    }
                }
                else
                {
                    onRead = null;
                    completed = true;
                }
            }

            if (completed)
            {
                if (socketError != SocketError.Success) Close(socketIndex, false);
                readCallback(index, socketError, readBuffer, 0, bytesCount);
                return true;
            }

            return false;
        }

        internal void OnCompletion(int index, IntPtr overlappedPtr)
        {
            if (sock == Kernel32.INVALID_HANDLE_VALUE)
            {
                // we have already closed the socket, so we just ignore all the 
                // completion notification for this socket.

                if (overlappedPtr == acceptOverlappedPtr)
                {
                    onAccept = null;
                    return;
                }

                if (overlappedPtr == writeOverlappedPtr)
                {
                    onWrite = null;
                    return;
                }

                if (overlappedPtr == readOverlappedPtr)
                {
                    onRead = null;
                    return;
                }
            }

            //
            // Check if accept got done
            //

            if (overlappedPtr == acceptOverlappedPtr && AcceptCompleted(index)) return;

            //
            // Check if write got done.
            //

            if (overlappedPtr == writeOverlappedPtr && WriteCompleted(index)) return;

            //
            // Check if read got done
            //

            if (overlappedPtr == readOverlappedPtr && ReadCompleted(index)) return;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2122", Justification = "Verify false positive: Marshal.* makes a linkdemand which is not required by this function. This is ok as we are not shipping this dll for use by any other applications other than messenger.")]
        SocketError ProcessResult(bool succeeded)
        {
            SocketError result = SocketError.Success;
            if (!succeeded)
            {
                result = (SocketError)Marshal.GetLastWin32Error();
                if (result == SocketError.IOPending)
                {
                    result = SocketError.Success;
                }
                else
                {
                    Close(index, false);
                }
            }

            return result;
        }

        bool HasOutstandingIO()
        {
            return (onAccept != null || onRead != null || onWrite != null);
        }

        private IPAddress ipaddress;
        private ushort port;

        internal IPAddress IPAddress
        {
            get
            {
                return this.ipaddress;
            }
        }
        internal ushort Port
        {
            get
            {
                return this.port;
            }
        }
    }

    /// <summary>
    /// Helper structure with the only purpose being size computation
    /// </summary>
    [StructLayout(LayoutKind.Sequential)]
    internal struct MyOverlapped
    {
        public IntPtr Internal;
        public IntPtr InternalHigh;
        public Int32 Dword;
        public Int32 DwordHigh;
        public IntPtr EventHandle;

        internal static readonly MyOverlapped overlappedZero = new MyOverlapped();

        // Marshal.* makes a linkdemand which is not required by this function
        // This is ok as we are not shipping this dll for use by any other applications other than
        // messenger.  So the FXCOP warning here is not applicable.

        internal static readonly int Size = Marshal.SizeOf(overlappedZero); //IntPtr.Size *3 + 4*2; // sizeof (OVERLAPPED)
    };


    /// <summary>
    /// SocketLayer implementation
    /// </summary>
    public class SocketLayer
    {
        private const int MaxThreads = 2;
        private const int NumberOfInternalSocket = 1;

        MySocket[] sockets;
        IntPtr readBuffers;
        IntPtr writeBuffers;
        IntPtr overlappedBuffers;
        int readBufferSize;
        int writeBufferSize;
        uint tcpKeepAliveTimeout;
        int firstFree;
        int count;
        int lastFree;
        object syncRoot = new Object();
        IntPtr[] ioPorts;
        IntPtr listenIoPort = Kernel32.INVALID_HANDLE_VALUE;
        Thread[] workerThreads;
        Thread[] listenerThreads;
        private int unhandledSocketExceptionCount;
        private int unhandledUnmanagedExceptionCount;

        private int GetRealIndex(int index)
        {
            int newIndex = (index & MySocket.indexMask);
            sockets[newIndex].VerifyIndex(index);

            return newIndex;
        }

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="maxSockets"></param>
        /// <param name="readBufferSize"></param>
        /// <param name="writeBufferSize"></param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2122", Justification = "Verify false positive: Marshal.* makes a linkdemand which is not required by this function. This is ok as we are not shipping this dll for use by any other applications other than messenger.")]
        public SocketLayer(int maxSockets, int readBufferSize, int writeBufferSize, uint tcpKeepAliveTimeout)
            : this(maxSockets + SocketLayer.NumberOfInternalSocket, readBufferSize, writeBufferSize, tcpKeepAliveTimeout, SocketLayer.MaxThreads)
        {
        }

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="maxSockets"></param>
        /// <param name="readBufferSize"></param>
        /// <param name="writeBufferSize"></param>
        /// <param name="threads"></param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2122", Justification = "Verify false positive: Marshal.* makes a linkdemand which is not required by this function. This is ok as we are not shipping this dll for use by any other applications other than messenger.")]
        private SocketLayer(int maxSockets, int readBufferSize, int writeBufferSize, uint tcpKeepAliveTimeout, int threads)
        {
            Debug.Assert(writeBufferSize >= readBufferSize);

            sockets = new MySocket[maxSockets];

            readBuffers = Marshal.AllocHGlobal(readBufferSize * maxSockets);
            writeBuffers = Marshal.AllocHGlobal(writeBufferSize * maxSockets);
            // one for accept, one for read and one for write
            overlappedBuffers = Marshal.AllocHGlobal(MyOverlapped.Size * 3 * maxSockets);
            this.readBufferSize = readBufferSize;
            this.writeBufferSize = writeBufferSize;
            this.tcpKeepAliveTimeout = tcpKeepAliveTimeout;
            for (int i = 0; i < maxSockets; i++)
            {
                sockets[i].nextFree = i + 1;;
            }

            lastFree = sockets.Length - 1;
            sockets[lastFree].nextFree = -1;

            ioPorts = new IntPtr[threads];
            for (int i = 0; i < ioPorts.Length; i++)
            {
                ioPorts[i] = Kernel32.CreateIoCompletionPort(Kernel32.INVALID_HANDLE_VALUE, IntPtr.Zero, IntPtr.Zero, 0);
                if (ioPorts[i] == IntPtr.Zero)
                {
                    throw new MySocketException(String.Format("Unexpected error trying to create a CompletionPort: {0}", Marshal.GetLastWin32Error()));
                }
            }

            listenIoPort = Kernel32.CreateIoCompletionPort(Kernel32.INVALID_HANDLE_VALUE, IntPtr.Zero, IntPtr.Zero, 0);
            if (listenIoPort == IntPtr.Zero)
            {
                throw new MySocketException(String.Format("Unexpected error trying to create a CompletionPort for listening: {0}", Marshal.GetLastWin32Error()));
            }

            workerThreads = new Thread[threads];
            for (int i = 0; i < workerThreads.Length; i++)
            {
                workerThreads[i] = new Thread(new ParameterizedThreadStart(SocketWorkerRoutine));
                workerThreads[i].Start(ioPorts[i]);
            }

            listenerThreads = new Thread[1];
            for (int i = 0; i < listenerThreads.Length; i++)
            {
                listenerThreads[i] = new Thread(new ParameterizedThreadStart(SocketWorkerRoutine));
                listenerThreads[i].Start(listenIoPort);
            }

            Winsock.WSADATA data = new Winsock.WSADATA();
            int error = Winsock.WSAStartup(0x0202, ref data);
            if (error != 0)
            {
                throw new MySocketException(String.Format("WSAStartup failed!  Error = {0}.", error));
            }
        }

        /// <summary>
        /// Size in bytes of the read buffers.
        /// </summary>
        public int ReadBufferSize
        {
            get { return this.readBufferSize; }
        }

        /// <summary>
        /// Size in bytes of the write buffers.
        /// </summary>
        public int WriteBufferSize
        {
            get { return this.writeBufferSize; }
        }

        /// <summary>
        /// Start listening on the specified port.
        /// </summary>
        /// <param name="ipAddress"></param>
        /// <param name="port"></param>
        /// <returns>The index of the listen socket</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2122", Justification = "Verify false positive: Marshal.* makes a linkdemand which is not required by this function. This is ok as we are not shipping this dll for use by any other applications other than messenger.")]
        public int Listen(IPAddress ipAddress, int port)
        {
            byte[] addressBytes = ipAddress.GetAddressBytes();
            int SendBufferSize = 256;
            int ReceiveBufferSize = 128;

            //
            // Create socket and set default options.
            //

            IntPtr sock = Winsock.WSASocket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp, IntPtr.Zero, 0, Winsock.WSA_FLAG_OVERLAPPED);

            if (sock == Kernel32.INVALID_HANDLE_VALUE) throw new MySocketException(Marshal.GetLastWin32Error());

            if (Winsock.setsockopt(sock, SocketOptionLevel.Socket, SocketOptionName.SendBuffer, ref SendBufferSize, sizeof(int)) != 0 ||
                Winsock.setsockopt(sock, SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer, ref ReceiveBufferSize, sizeof(int)) != 0)
            {
                Winsock.closesocket(sock);

                throw new MySocketException(Marshal.GetLastWin32Error());
            }

            //
            // Enable keep-alives
            //

            int receiveSize = 0;
            Winsock.tcp_keepalive keepalive = new Winsock.tcp_keepalive();
            keepalive.onOff = 0;

            if (tcpKeepAliveTimeout > 0)
            {
                keepalive.onOff = 1;
                keepalive.keepAliveTime = tcpKeepAliveTimeout;
                keepalive.keepAliveInterval = 1000;
            }

            GCHandle hKeepalive = GCHandle.Alloc(keepalive, GCHandleType.Pinned);

            try
            {
                if (Winsock.WSAIoctl(sock, IOControlCode.KeepAliveValues, hKeepalive.AddrOfPinnedObject(), Marshal.SizeOf(keepalive), new IntPtr(0), 0, ref receiveSize, new IntPtr(0), new IntPtr(0)) != 0)
                {
                    Winsock.closesocket(sock);
                    
                    throw new MySocketException(Marshal.GetLastWin32Error());
                }
            }
            finally
            {
                hKeepalive.Free();
            }

            //
            // Bind socket
            //


            Winsock.sockaddr_in sockaddr = new Winsock.sockaddr_in(BitConverter.ToInt32(addressBytes, 0), port);

            if (Winsock.bind(sock, ref sockaddr, Marshal.SizeOf(sockaddr)) != 0)
            {
                Winsock.closesocket(sock);

                throw new MySocketException(Marshal.GetLastWin32Error());
            }

            //
            // set listen backlog
            //

            if (Winsock.listen(sock, 5000) != 0)
            {
                Winsock.closesocket(sock);

                throw new MySocketException(Marshal.GetLastWin32Error());
            }

            //
            // Allocate entry
            //

            int index = Allocate();
            if (index < 0)
            {
                Winsock.closesocket(sock);
                throw new OutOfMemoryException("Not enough room in the socket array.");
            }

            //
            // Initialize, bind to io port and return
            //

            int returnIndex = sockets[index].Initialize(
                index,
                sock,
                MySocket.AddOffset(readBuffers, readBufferSize * index),
                readBufferSize,
                MySocket.AddOffset(writeBuffers, writeBufferSize * index),
                writeBufferSize,
                MySocket.AddOffset(overlappedBuffers, 3 * index * MyOverlapped.Size)
                );

            IntPtr returnPort = Kernel32.CreateIoCompletionPort(sock, listenIoPort, (IntPtr)returnIndex, 0);
            if (returnPort != listenIoPort)
            {
                int error = Marshal.GetLastWin32Error();
                if (sockets[index].Close(returnIndex, true)) Free(index);

                throw new MySocketException(String.Format("Call to bind the listen socket {0} to the IoPort {1} returned {2} and failed with error {3}.",
                    sock, listenIoPort, returnPort, error));
            }

            return returnIndex;
        }

        /// <summary>
        /// Post an accept on the listen socket
        /// </summary>
        /// <param name="listenSocketIndex"></param>
        /// <param name="callback"></param>
        /// <returns></returns>
        public SocketError PostAccept(int listenSocketIndex, AcceptCallback callback)
        {
            int index = GetRealIndex(listenSocketIndex);
            IntPtr listenSocket = sockets[index].sock;
            IntPtr acceptSocket = Winsock.WSASocket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp, IntPtr.Zero, 0, Winsock.WSA_FLAG_OVERLAPPED);
            int acceptIndex = Allocate();
            if (acceptIndex < 0)
            {
                Winsock.closesocket(acceptSocket);
                return SocketError.TooManyOpenSockets;
            }
            acceptIndex = sockets[acceptIndex].Initialize(
                acceptIndex,
                acceptSocket,
                MySocket.AddOffset(readBuffers, readBufferSize * acceptIndex),
                readBufferSize,
                MySocket.AddOffset(writeBuffers, writeBufferSize * acceptIndex),
                writeBufferSize,
                MySocket.AddOffset(overlappedBuffers, 3 * acceptIndex * MyOverlapped.Size));
            SocketError error = sockets[index].PostAccept(listenSocketIndex, acceptSocket, acceptIndex, callback);
            if (SocketError.Success != error)
            {
                Close(acceptIndex);
            }

            return error;
        }

        /// <summary>
        /// Bind the newly accepted socket to the same io port as teh listen socket
        /// </summary>
        /// <param name="listenSocketIndex"></param>
        /// <param name="acceptSocketIndex"></param>
        /// <param name="sendBufferSize"></param>
        /// <param name="receiveBufferSize"></param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2122", Justification = "Verify false positive: Marshal.* makes a linkdemand which is not required by this function. This is ok as we are not shipping this dll for use by any other applications other than messenger.")]
        public void BindToIoPort(int listenSocketIndex, int acceptSocketIndex, int sendBufferSize, int receiveBufferSize)
        {
            listenSocketIndex = GetRealIndex(listenSocketIndex);
            int index = acceptSocketIndex = GetRealIndex(acceptSocketIndex);

            IntPtr listenSocket = sockets[listenSocketIndex].sock;
            IntPtr acceptSocket = sockets[acceptSocketIndex].sock;

            IntPtr returnPort = Kernel32.CreateIoCompletionPort(acceptSocket, ioPorts[acceptSocketIndex % ioPorts.Length], (IntPtr)sockets[acceptSocketIndex].index, 0);
            if (returnPort != ioPorts[acceptSocketIndex % ioPorts.Length])
            {
                sockets[index].Close(acceptSocketIndex, false);
                throw new MySocketException(String.Format(
                    "Call to bind the Listen socket to the ioport failed with error {0}.", Marshal.GetLastWin32Error()
                    ));
            }

            if (Winsock.setsockopt(
                acceptSocket, SocketOptionLevel.Socket, SocketOptionName.UpdateAcceptContext, ref listenSocket, IntPtr.Size) != 0)
            {
                sockets[index].Close(acceptSocketIndex, false);
                throw new MySocketException(String.Format(
                    "SetSockOpt(UpdateAcceptContext) failed with error {0}", Marshal.GetLastWin32Error()));
            }

            int noDelay = 1;
            if (Winsock.setsockopt(
                acceptSocket, SocketOptionLevel.Tcp, SocketOptionName.NoDelay, ref noDelay, sizeof(int)) != 0)
            {
                sockets[index].Close(acceptSocketIndex, false);
                throw new MySocketException(String.Format(
                    "SetSockOpt(NoDelay) failed with error {0}", Marshal.GetLastWin32Error()));
            }

            int keepAlive = (tcpKeepAliveTimeout > 0) ? 1 : 0;
            if (Winsock.setsockopt(
                acceptSocket, SocketOptionLevel.Socket, SocketOptionName.KeepAlive, ref keepAlive, sizeof(int)) != 0)
            {
                sockets[index].Close(acceptSocketIndex, false);
                throw new MySocketException(String.Format(
                    "SetSockOpt(KeepAlive) failed with error {0}", Marshal.GetLastWin32Error()));
            }

            int sendBufferSizeOverride = 0;
            if (Winsock.setsockopt(
                acceptSocket, SocketOptionLevel.Socket, SocketOptionName.SendBuffer, ref sendBufferSizeOverride, sizeof(int)) != 0)
            {
                sockets[index].Close(acceptSocketIndex, false);
                throw new MySocketException(String.Format(
                    "SetSockOpt(SendBuffer) failed with error {0}", Marshal.GetLastWin32Error()));
            }

            if (Winsock.setsockopt(
                acceptSocket, SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer, ref receiveBufferSize, sizeof(int)) != 0)
            {
                sockets[index].Close(acceptSocketIndex, false);
                throw new MySocketException(String.Format(
                    "SetSockOpt(ReceiveBuffer) failed with error {0}", Marshal.GetLastWin32Error()));
            }

            sockets[index].boundToIoPort = true;
        }

        /// <summary>
        /// Post a read on an accepted socket
        /// </summary>
        /// <param name="socketIndex"></param>
        /// <param name="callback"></param>
        /// <returns></returns>
        public SocketError PostRead(int socketIndex, ReadCallback callback)
        {
            int index = GetRealIndex(socketIndex);
            if (!sockets[index].boundToIoPort) throw new MySocketException("PostWrite must be called after binding the socket to an io port.");
            return sockets[index].PostRead(socketIndex, callback);
        }

        /// <summary>
        /// Post a write on an accepted socket
        /// </summary>
        /// <param name="socketIndex"></param>
        /// <param name="buffer"></param>
        /// <param name="offset"></param>
        /// <param name="bytesToWrite"></param>
        /// <param name="writeCallback"></param>
        /// <returns></returns>
        public SocketError PostWrite(int socketIndex, byte[] buffer, int offset, int bytesToWrite, WriteCallback writeCallback)
        {
            int index = GetRealIndex(socketIndex);
            if (!sockets[index].boundToIoPort) throw new MySocketException("PostWrite must be called after binding the socket to an io port.");
            return sockets[index].PostWrite(socketIndex, buffer, offset, bytesToWrite, writeCallback);
        }

        /// <summary>
        /// Close the socket
        /// </summary>
        /// <param name="socketIndex"></param>
        public void Close(int socketIndex)
        {
            int index = (socketIndex & MySocket.indexMask);
            if (sockets[index].Close(socketIndex, true)) Free(index);
        }

        /// <summary>
        /// The total number of sockets including listening sockets.
        /// </summary>
        public int ConnectionsCount
        {
            get { return count; }
        }

        /// <summary>
        /// Closedown the socket layer.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2122", Justification = "Verify false positive: Marshal.* makes a linkdemand which is not required by this function. This is ok as we are not shipping this dll for use by any other applications other than messenger.")]
        public void Close()
        {
            //
            // Get rid of all the threads.
            //

            if (workerThreads != null)
            {
                for (int i = 0; i < workerThreads.Length; i++)
                {
                    Kernel32.PostQueuedCompletionStatus(ioPorts[i], 0, -1, (IntPtr)0);
                }

                for (int i = 0; i < workerThreads.Length; i++)
                    workerThreads[i].Join();

                workerThreads = null;
            }

            if (listenerThreads != null)
            {
                for (int i = 0; i < listenerThreads.Length; i++)
                {
                    Kernel32.PostQueuedCompletionStatus(listenIoPort, 0, -1, (IntPtr)0);
                }

                for (int i = 0; i < listenerThreads.Length; i++)
                    listenerThreads[i].Join();

                listenerThreads = null;
            }

            if (IntPtr.Zero != readBuffers)
            {
                Marshal.FreeHGlobal(readBuffers);
                readBuffers = IntPtr.Zero;
            }

            if (IntPtr.Zero != writeBuffers)
            {
                Marshal.FreeHGlobal(writeBuffers);
                writeBuffers = IntPtr.Zero;
            }

            if (IntPtr.Zero != overlappedBuffers)
            {
                Marshal.FreeHGlobal(overlappedBuffers);
                overlappedBuffers = IntPtr.Zero;
            }

        }

        void SocketWorkerRoutine(object parameter)
        {
            IntPtr ioPort = (IntPtr)parameter;

            //
            // Get completion status and operate.
            //

            while (true)
            {

                try
                {
                    //
                    // Now call GetQueuedCompletionStatus to hang out there.
                    //

                    int bytesRead = 0;
                    int key = -1;
                    IntPtr overlappedPtr = IntPtr.Zero;
                    Kernel32.GetQueuedCompletionStatus(
                        ioPort,
                        ref bytesRead,
                        ref key,
                        ref overlappedPtr,
                        -1);

                    try
                    {
                        if (overlappedPtr != IntPtr.Zero)
                        {
                            int index = (key & MySocket.indexMask);
                            sockets[index].OnCompletion(key, overlappedPtr);
                        }
                        else
                        {
                            int error = Marshal.GetLastWin32Error();
                            Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogUnhandledSocketException(" + string.Format("GetQueuedCompletionStatus returned {0}. Quitting thread.", error) +")");

                            break; // exit the loop/
                        }
                    }
                    catch (Exception e)
                    {
                        unhandledSocketExceptionCount++;
                        Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogUnhandledSocketException(" + e.ToString() +")");
                    }
                }
                catch
                {
                    unhandledUnmanagedExceptionCount++;
                }
            }

        }

        int Allocate()
        {
            lock (syncRoot)
            {
                int i = firstFree;
                if (i >= 0)
                {
                    firstFree = sockets[i].nextFree;
                    count++;
                    sockets[i].nextFree = -1;
                    if (firstFree == -1) lastFree = -1;
                }

                return i;
            }
        }

        void Free(int index)
        {
            if (index >= 0)
            {
                lock (syncRoot)
                {
                    if (sockets[index].nextFree == -1)
                    {
                        if (lastFree >= 0)
                        {
                            sockets[lastFree].nextFree = index;
                        }
                        lastFree = index;
                        if (firstFree < 0) firstFree = lastFree;
                        count--;
                    }
                }
            }
        }

        public IPAddress IPAddress(int index)
        {
            return sockets[GetRealIndex(index)].IPAddress;
        }

        public ushort Port(int index)
        {
            return sockets[GetRealIndex(index)].Port;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\SocialCache\inh\msgr\TcpStream.cs ===
//-----------------------------------------------------------------------
// <copyright file="TcpStream.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
// TcpStream is an abstraction of the network connection.
// TcpConnection and TlsConnection are derived from this class.
// A System.IO.Stream implementation is provided via the Stream property for reading
// and writing. [However it does not derive from Stream because this prevents common 
// functionality from being added to the TcpStream base class]
// </summary>
//-----------------------------------------------------------------------

namespace MS.Msn.Messenger.Runtime
{
    using System;
    using System.Collections.Generic;
    using System.Net;
    using System.Threading;
    using System.IO;
    using System.Net.Sockets;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    /// <summary>
    /// TcpStream is an abstraction of the network connection.
    /// TcpConnection and TlsConnection are derived from this class.
    /// A System.IO.Stream implementation is provided via the Stream property for reading
    /// and writing. [However it does not derive from Stream because this prevents common 
    /// functionality from being added to the TcpStream base class]
    /// </summary>
    public class TcpStream : Stream
    {
        private Queue<WriteAsyncResult> writeBufferQueue = new Queue<WriteAsyncResult>();
        private int sock;
        private SocketLayer socketLayer;
        private ReadCallback readCallback;
        private WriteCallback writeCallback;
        private ReadAsyncResult currentReadState;
        private WriteAsyncResult currentWriteState;
        private bool writePending = false;
        private int firedDisconnected;

        /// <summary>
        /// The TcpStream class is created by the TcpConnectionListener so no public
        /// constructor is exposed.
        /// 
        /// </summary>
        /// <param name="sock">the underlying socket</param>
        /// <param name="socketLayer">parent socket layer</param>
        internal TcpStream(int sock, SocketLayer socketLayer)
            : base()
        {
            this.sock = sock;
            this.socketLayer = socketLayer;
            this.readCallback = new ReadCallback(this.OnReadCompleted);
            this.writeCallback = new WriteCallback(this.OnWriteCompleted);
        }

        /// <summary>
        /// Dispose of this stream and free up the socket.
        /// </summary>
        ~TcpStream()
        {
            this.Dispose(false);
        }

        /// <summary>
        /// Disconnect delegate
        /// </summary>
        /// <param name="sender">Stream that is being closed</param>
        /// <param name="reason">exception that was thrown (if any)</param>
        public delegate void DisconnectedEventHandler(TcpStream sender, Exception reason);

        /// <summary>
        /// Event that is invoked when a connection is disconnected
        /// A consumer of this method is the ConnectionController.
        /// </summary>
        public event DisconnectedEventHandler Disconnected;

        /// <summary>
        /// True.  Stream is readable.
        /// </summary>
        public override bool CanRead
        {
            get { return true; }
        }

        /// <summary>
        /// False.  (Stream does not support seek)
        /// </summary>
        public override bool CanSeek
        {
            get { return false; }
        }

        /// <summary>
        /// True.  Stream is writeable.
        /// </summary>
        public override bool CanWrite
        {
            get { return true; }
        }

        /// <summary>
        /// Throws exception.  (Stream does not support seek)
        /// </summary>
        public override long Length
        {
            get { throw new NotSupportedException("Cannot seek."); }
        }

        /// <summary>
        /// Throws exception.  (Stream does not support seek)
        /// </summary>
        public override long Position
        {
            get
            {
                throw new NotSupportedException("Cannot seek.");
            }

            set
            {
                throw new NotSupportedException("Cannot seek.");
            }
        }

        /// <summary>
        /// Socket ID
        /// </summary>
        public int Sock
        {
            get { return this.sock; }
        }

        /// <summary>
        /// Returns the remote IP address.
        /// </summary>
        public IPAddress IPAddress
        {
            get { return this.socketLayer.IPAddress(this.sock); }
        }

        /// <summary>
        /// Returns the remote port.
        /// </summary>
        public ushort Port
        {
            get { return this.socketLayer.Port(this.sock); }
        }

        /// <summary>
        /// Async read.  Blocks until bytes are received.  Should not be used except in testing.
        /// </summary>
        /// <param name="buffer">buffer to copy data to</param>
        /// <param name="offset">offset</param>
        /// <param name="count">max number of bytes to copy</param>
        /// <returns>number of bytes actually read.</returns>
        public override int Read(byte[] buffer, int offset, int count)
        {
            IAsyncResult result = this.BeginRead(buffer, offset, count, null, null);
            return this.EndRead(result);
        }

        /// <summary>
        /// Sync write.  Should only be called in unit tests, etc.  Not efficient.
        /// </summary>
        /// <param name="buffer">data to write</param>
        /// <param name="offset">offset from which to begin writing data</param>
        /// <param name="count">number of bytes to write</param>
        public override void Write(byte[] buffer, int offset, int count)
        {
            IAsyncResult result = this.BeginWrite(buffer, offset, count, null, null);
            this.EndWrite(result);
        }

        /// <summary>
        /// Not Supported
        /// </summary>
        /// <param name="offset">ignored</param>
        /// <param name="origin">ignored</param>
        /// <returns>nothing</returns>
        public override long Seek(long offset, SeekOrigin origin)
        {
            throw new NotSupportedException("Cannot seek.");
        }

        /// <summary>
        /// Not Supported
        /// </summary>
        /// <param name="value">ignored</param>
        public override void SetLength(long value)
        {
            throw new NotSupportedException("Cannot seek.");
        }

        /// <summary>
        /// Does nothing.  Writes are already flushed immediately.
        /// </summary>
        public override void Flush()
        {
            // Ignored.
        }

        /// <summary>
        /// Supply a buffer to read bytes into if data comes over the stream.
        /// </summary>
        /// <param name="buffer">byte buffer</param>
        /// <param name="offset">offset to start copying data to</param>
        /// <param name="size">number of bytes available in buffer</param>
        /// <param name="callback">callback</param>
        /// <param name="state">async state</param>
        /// <returns>async result</returns>
        public override IAsyncResult BeginRead(byte[] buffer, int offset, int size, AsyncCallback callback, object state)
        {
            // We shouldn't pass in a buffer that is smaller than we might possibly get back.
            if (this.socketLayer.ReadBufferSize > size)
            {
                string message = string.Format(
                    "Buffer passed in is too small ({0} bytes).  Must be at least as big as the socket buffer ({1} bytes)",
                    size,
                    this.socketLayer.ReadBufferSize);

                throw new ArgumentException(message, "size");
            }

            ReadAsyncResult result = new ReadAsyncResult(new BufferOffsetSize(buffer, offset, size, false), callback, state);

            int socketIndex = this.sock;

            if (socketIndex != -1)
            {
                // BUGBUG bgarris: technically we should probably lock on this, but we
                // have a logic bug if we can ever have simultaneous reads, so this shouldn't
                // be a problem.  (MySocket will throw an exception anyway)
                // Ultimately, it should be the MySocket layer that implements
                // a Begin/End pattern to solve this problem, but for now, this should be fine.
                this.currentReadState = result;

                SocketError error = this.socketLayer.PostRead(socketIndex, this.readCallback);
                if (error != SocketError.Success)
                {
                    result.CompleteRequest(error, true);
                }
            }

            return result;
        }

        /// <summary>
        /// End a read - should only be called in the callback passed into beginread,
        /// or (if sync is OK) with the return value of BeginRead.
        /// </summary>
        /// <param name="asyncResult">the async result returned from BeginRead or passed into the callback.</param>
        /// <param name="result">SocketError.Success if OK.  Some other error if not.</param>
        /// <returns>Number of bytes read</returns>
        public int EndRead(IAsyncResult asyncResult, out SocketError result)
        {
            ReadAsyncResult state = (ReadAsyncResult)asyncResult;
            state.BlockUntilCompleted();

            result = state.Result;
            return state.BytesRead;
        }

        /// <summary>
        /// End a read - should only be called in the callback passed into beginread,
        /// or (if sync is OK) with the return value of BeginRead.
        /// </summary>
        /// <param name="asyncResult">the async result returned from BeginRead or passed into the callback.</param>
        /// <exception cref="SocketException"></exception>
        /// <returns>Number of bytes read</returns>
        public override int EndRead(IAsyncResult asyncResult)
        {
            SocketError result;
            int bytesRead = this.EndRead(asyncResult, out result);
            if (result != SocketError.Success)
            {
                throw new SocketException((int)result);
            }

            return bytesRead;
        }

        /// <summary>
        /// Post a write.
        /// </summary>
        /// <param name="buffer">backing buffer.  should not be modified while write is being made.</param>
        /// <param name="offset">starting position to begin writing from</param>
        /// <param name="size">number of bytes to write</param>
        /// <param name="callback">callback to make after write is completed.</param>
        /// <param name="state">async state</param>
        /// <returns>async result</returns>
        public override IAsyncResult BeginWrite(byte[] buffer, int offset, int size, AsyncCallback callback, object state)
        {
            WriteAsyncResult result = new WriteAsyncResult(new BufferOffsetSize(buffer, offset, size, false), callback, state);
            AsyncResult<SocketError> resultToReturn = result;

            int socketIndex = this.sock;

            if (socketIndex == -1)
            {
                result.CompleteRequest(SocketError.Shutdown, true);
                return resultToReturn;  // BUGBUG bgarris: I don't like this comment that seems unsure of why we might
                                        // return here:
                                        // "got disposed?"
            }

            lock (this.writeBufferQueue)
            {
                if (size > this.socketLayer.WriteBufferSize)
                {
                    AggregateWriteAsyncResult parent = new AggregateWriteAsyncResult(result, this.socketLayer.WriteBufferSize, callback, state);
                    foreach (WriteAsyncResult subWrite in parent.SubWrites)
                    {
                        this.writeBufferQueue.Enqueue(subWrite);
                    }

                    resultToReturn = parent;

                    if (this.writePending)
                    {
                        return resultToReturn;
                    }
                    else
                    {
                        // we'll start writing the first one.  note that the result we're returning is still the
                        // parent state.
                        result = CoelesceWrites(socketIndex);
                    }
                }
                else
                {
                    if (this.writePending)
                    {
                        this.writeBufferQueue.Enqueue(result);
                        return resultToReturn;
                    }
                }

                this.writePending = true;
            }

            // we have logic to prevent PostWrite from being called multiple times, so as long as we only
            // assign to currentWriteState right before a PostWrite, we should be fine.
            this.currentWriteState = result;

            SocketError error = this.socketLayer.PostWrite(
                socketIndex,
                this.currentWriteState.Buffer.Buffer,
                this.currentWriteState.Buffer.Offset,
                this.currentWriteState.Buffer.Size,
                this.writeCallback);

            if (error != SocketError.Success)
            {
                this.currentWriteState.CompleteRequest(error, true);
            }

            // this might be an aggregate write or a normal write.
            return resultToReturn;
        }

        /// <summary>
        /// End a write - should only be called in the callback passed into beginwrite,
        /// or (if sync is OK) with the return value of BeginWrite.
        /// </summary>
        /// <param name="asyncResult">the async result returned from BeginWrite or passed into the callback.</param>
        /// <param name="result">SocketError.Success if OK.  Some other error if not.</param>
        public void EndWrite(IAsyncResult asyncResult, out SocketError result)
        {
            AsyncResult<SocketError> state = (AsyncResult<SocketError>)asyncResult;
            state.BlockUntilCompleted();
            result = state.Result;
        }

        /// <summary>
        /// End a write - should only be called in the callback passed into beginwrite,
        /// or (if sync is OK) with the return value of BeginWrite.
        /// </summary>
        /// <exception cref="SocketException"></exception>
        /// <param name="asyncResult">the async result returned from BeginWrite or passed into the callback.</param>
        public override void EndWrite(IAsyncResult asyncResult)
        {
            SocketError result;
            this.EndWrite(asyncResult, out result);
            if (result != SocketError.Success)
            {
                throw new SocketException((int)result);
            }
        }

        /// <summary>
        /// Dispose and close this socket.
        /// </summary>
        /// <param name="disposing">whether or not we're disposing</param>
        protected override void Dispose(bool disposing)
        {
            int disposeSocketIndex = Interlocked.Exchange(ref this.sock, -1);

            if (disposeSocketIndex != -1)
            {
                this.socketLayer.Close(disposeSocketIndex);
                if (disposing)
                {
                    this.OnDisconnected(null);
                }
            }
        }

        /// <summary>
        /// This function is invoked to raise the Disconnected event
        /// This could happen as a result of a network error or an explicit
        /// call to the Disconnect method
        /// </summary>
        /// <param name="reason">optional exception</param>
        private void OnDisconnected(Exception reason)
        {
            // we have to make sure that Disconnected is only called once
            int fired = Interlocked.Exchange(ref this.firedDisconnected, 1);
            if (this.Disconnected != null && fired != 1)
            {
                this.Disconnected(this, reason);
            }
        }

        private void OnReadCompleted(int socketIndex, SocketError error, IntPtr buffer, int offset, int bytes)
        {
            ReadAsyncResult state = this.currentReadState;

            if (error == SocketError.Success)
            {
                // we should have thrown an exception in BeginRead if the buffer wasn't large enough.
                Debug.Assert(bytes <= state.Buffer.Size);

                buffer = (IntPtr)(buffer.ToInt64() + offset);
                Marshal.Copy(buffer, state.Buffer.Buffer, state.Buffer.Offset, bytes);
            }

            state.CompleteRequest(error, false, bytes);
        }

        // called in the lock
        private WriteAsyncResult CoelesceWrites(int socketIndex)
        {
            MultiWriteAsyncResult states = new MultiWriteAsyncResult(this.socketLayer.WriteBufferSize);

            lock (this.writeBufferQueue)
            {
                while (this.writeBufferQueue.Count > 0)
                {
                    WriteAsyncResult state = this.writeBufferQueue.Peek();
                    if ((states.TotalSize + state.Buffer.Size) > states.MaxSize)
                    {
                        // no more room.
                        break;
                    }
                    
                    states.AddWrite(state);

                    SocketError error = this.socketLayer.PostWrite(
                        socketIndex,
                        state.Buffer.Buffer,
                        state.Buffer.Offset,
                        state.Buffer.Size,
                        null);

                    this.writeBufferQueue.Dequeue();
                }
            }

            // we shouldnt be here if the queue was empty to begin with, and nothing in the queue should be bigger than the
            // max size by itself.  so at least 1 item should have fit in the batch.
            Debug.Assert(states.TotalSize > 0);

            return states;
        }

        private void OnWriteCompleted(int socketIndex, SocketError error)
        {
            WriteAsyncResult state = this.currentWriteState;

            state.CompleteRequest(error, false);
            if (SocketError.Success != error)
            {
                // BUGBUG bgarris: ideally we should complete all of the queued writes with a failure.
                // not changing it now for parity with old code.
                return;
            }

            lock (this.writeBufferQueue)
            {
                if (this.writeBufferQueue.Count == 0)
                {
                    this.writePending = false;
                    return;
                }

                state = CoelesceWrites(socketIndex);
            }

            // we have logic to prevent PostWrite from being called multiple times, so as long as we only
            // assign to currentWriteState right before a PostWrite, we should be fine.
            this.currentWriteState = state;

            error = this.socketLayer.PostWrite(
                socketIndex,
                state.Buffer.Buffer,
                state.Buffer.Offset,
                state.Buffer.Size,
                this.writeCallback);

            if (error != SocketError.Success)
            {
                // we didn't complete synchronously because we were called in the callback of another
                // write.  (Even though this particular PostWrite call technically completed synchronously)
                state.CompleteRequest(error, false);
            }
        }

        internal class ReadAsyncResult : AsyncResult<SocketError>
        {
            private BufferOffsetSize buffer;
            private int bytesRead = 0;

            internal ReadAsyncResult(
                BufferOffsetSize buffer,
                AsyncCallback callback,
                object state)
                : base(callback, state)
            {
                this.buffer = buffer;
            }

            internal BufferOffsetSize Buffer
            {
                get { return this.buffer; }
            }

            internal int BytesRead
            {
                get { return this.bytesRead; }
                set { this.bytesRead = value; }
            }

            internal void CompleteRequest(SocketError result, bool completedSynchronously, int bytesRead)
            {
                this.bytesRead = bytesRead;
                base.CompleteRequest(result, completedSynchronously);
            }
        }

        internal class WriteAsyncResult : AsyncResult<SocketError>
        {
            private BufferOffsetSize buffer;

            internal WriteAsyncResult(
                BufferOffsetSize buffer,
                AsyncCallback callback,
                object state)
                : base(callback, state)
            {
                this.buffer = buffer;
            }

            internal BufferOffsetSize Buffer
            {
                get { return this.buffer; }
            }
        }

        internal class MultiWriteAsyncResult : WriteAsyncResult
        {
            static byte[] _emptyBuffer = new byte[0];
            
            private List<WriteAsyncResult> multiWrites;
            private int maxSize;
            private int totalSize;
            
            internal int TotalSize
            {
                get { return totalSize; }
            }

            internal int MaxSize
            {
                get { return maxSize; }
            }

            internal MultiWriteAsyncResult(int maxSize)
                : base(new BufferOffsetSize(_emptyBuffer, 0, 0, false), new AsyncCallback(OnWriteCompleted), null)
            {
                this.maxSize = maxSize;
                multiWrites = new List<WriteAsyncResult>();
            }

            internal void AddWrite(WriteAsyncResult result)
            {
                Debug.Assert((totalSize + result.Buffer.Size) <= maxSize);
                
                multiWrites.Add(result);
                totalSize += result.Buffer.Size;
            }

            public static void OnWriteCompleted(IAsyncResult asyncResult)
            {
                MultiWriteAsyncResult result = (MultiWriteAsyncResult)asyncResult;
                SocketError error = result.Result;

                foreach (WriteAsyncResult write in result.multiWrites)
                {
                    write.CompleteRequest(error, result.CompletedSynchronously);
                }
            }
        }

        /// <summary>
        /// We should use this class if a write is too large to be written in one write.
        /// It breaks the write into smaller chunks, and calls its callback when either
        /// the last one completes, or one of them completes with an error result.
        /// </summary>
        internal class AggregateWriteAsyncResult : AsyncResult<SocketError>
        {
            private List<WriteAsyncResult> subWrites;

            private bool hasAlreadyCompleted;

            internal AggregateWriteAsyncResult(
                WriteAsyncResult result,
                int maxSize,
                AsyncCallback callback,
                object state)
                : base(callback, state)
            {
                this.subWrites = this.Split(result, maxSize);
                this.hasAlreadyCompleted = false;
            }

            internal List<WriteAsyncResult> SubWrites
            {
                get { return this.subWrites; }
            }

            private List<WriteAsyncResult> Split(WriteAsyncResult result, int maxSize)
            {
                List<WriteAsyncResult> results = new List<WriteAsyncResult>();
                AsyncCallback writeCallback = new AsyncCallback(this.OnWriteCompleted);

                byte[] data = result.Buffer.Buffer;
                int offset = result.Buffer.Offset;
                int size = result.Buffer.Size;

                while (size > maxSize)
                {
                    BufferOffsetSize newBuff = new BufferOffsetSize(data, offset, maxSize, false);
                    WriteAsyncResult write = new WriteAsyncResult(newBuff, writeCallback, false);
                    results.Add(write);
                    offset += maxSize;
                    size -= maxSize;
                }

                // note that the async state is 'true' instead of 'false', to signify that this is the last
                // write.
                results.Add(new WriteAsyncResult(new BufferOffsetSize(data, offset, size, false), writeCallback, true));

                return results;
            }

            private void OnWriteCompleted(IAsyncResult asyncResult)
            {
                // no need for locking - Writes are completed one at a time.
                if (this.hasAlreadyCompleted)
                {
                    // we only want to complete if there is an error, or if we're on the last write.
                    // if we get here, that means we've already completed with an error, so we should
                    // ignore the values of all subsequent operations.
                    return;
                }

                WriteAsyncResult result = (WriteAsyncResult) asyncResult;
                bool isLastWrite = (bool)result.AsyncState;
                SocketError error = result.Result;

                if (isLastWrite || error != SocketError.Success)
                {
                    this.hasAlreadyCompleted = true;
                    this.CompleteRequest(error, result.CompletedSynchronously);
                }
            }
        }

        /// <summary>
        /// Copied from internal System.Net.BufferOffsetSize
        /// </summary>
        internal class BufferOffsetSize
        {
            private byte[] buffer;
            private int offset;
            private int size;

            internal BufferOffsetSize(byte[] buffer, bool copyBuffer)
                : this(buffer, 0, buffer.Length, copyBuffer)
            {
            }

            internal BufferOffsetSize(byte[] buffer, int offset, int size, bool copyBuffer)
            {
                if (copyBuffer)
                {
                    byte[] dst = new byte[size];
                    System.Buffer.BlockCopy(buffer, offset, dst, 0, size);
                    offset = 0;
                    buffer = dst;
                }

                this.buffer = buffer;
                this.offset = offset;
                this.size = size;
            }

            internal byte[] Buffer
            {
                get { return this.buffer; }
            }

            internal int Offset
            {
                get { return this.offset; }
            }

            internal int Size
            {
                get { return this.size; }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\SocialCache\inh\msgr\ConnectionListener.cs ===
using System;
using System.Net;
using System.Threading;
using System.IO;
using System.Net.Sockets;
using System.Diagnostics;

using xonline.common.mgmt;

namespace MS.Msn.Messenger.Runtime
{
    /// <summary>
    /// delegate for IConnectionListener.Connected event
    /// </summary>
    public delegate void ConnectedCallback(object Source, TcpStream c);

    /// <summary>
    /// Interface shared by all connection listeners.
    /// The ConnectionListener generates server-side TcpStream objects
    /// Subclasses included TCPListener and TLSListener
    /// </summary>
    public interface IConnectionListener
    {
        /// <summary>
        ///   This method starts listening for incoming connections
        ///   on the specified end point.
        /// </summary>
        void Start();

        /// <summary>
        /// Stops listening for incoming connections. Existing connections are not affected
        /// </summary>
        void Stop();

        /// <summary>
        /// Event raised when a new connection is created. Protocol handlers
        /// should consume this event.
        /// </summary>
        event ConnectedCallback Connected;
    }

    /// <summary>
    /// TCP Listener class. Implements generic IConnectionListener interface
    /// Provides asynchronous callback events that are raised when an incoming connection request
    /// is received.
    /// </summary>
    public class TcpConnectionListener : IConnectionListener, IDisposable
    {
        private const int MaxAcceptsPending = 1;

        private readonly SocketLayer socketLayer;
        private readonly IPEndPoint endPoint; 
        private readonly int sendBufferSize;
        private readonly int receiveBufferSize;
        private readonly TcpStream.DisconnectedEventHandler connectionDisconnected;

        // socket to listen for incoming connections
        int listenSocketIndex = -1;

        private int connectionCount = 0;
        private int acceptsPending = 0;

        /// <summary>
        /// Event raised when a new incoming Connection is available
        /// </summary>
        public event ConnectedCallback Connected;

        // callback that is called when BeginAccept on listenSocket completes
        AcceptCallback connectionAcceptedCallback;

        private int maxSocketCount;
        
        /// <summary>
        /// Create a TcpConnectionListener bound to the specified ConectionController and listening
        /// on the given IP address and port
        /// </summary>
        public TcpConnectionListener(IPEndPoint endPoint, int readBufferSize, int writeBufferSize, int maxSockets, uint tcpKeepAliveTimeout)
        {
            if (endPoint == null)
            {
                throw new ArgumentNullException("endPoint");
            }

            this.sendBufferSize = writeBufferSize;
            this.receiveBufferSize = readBufferSize;
            this.endPoint = endPoint;

            this.socketLayer = new SocketLayer(maxSockets, readBufferSize, writeBufferSize, tcpKeepAliveTimeout);
            this.maxSocketCount = maxSockets;

            this.connectionAcceptedCallback = new AcceptCallback(this.ConnectionAccepted);
            this.connectionDisconnected = new TcpStream.DisconnectedEventHandler(this.DisconnectedEventHandler);
        }

        public int ConnectionCount
        {
            get { return this.connectionCount; }
        }

        /// <summary>
        /// Start Listening.
        /// This method is called by the server application.
        /// The connection controller internally throttles acceptance of new connections so
        /// it is possible that the listen may be temporarily disabled.
        /// </summary>
        public virtual void Start()
        {
            lock (this)
            {
                if (listenSocketIndex != -1)
                {
                    throw new InvalidOperationException("Stack is already listening on "
                        + endPoint.ToString());
                }

                listenSocketIndex = socketLayer.Listen(endPoint.Address, endPoint.Port);

                Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogTcpConnectionListenerStart(" + endPoint.ToString() + ")");

                this.PostAccept();
            }
        }

        /// <summary>
        /// This method is called by the server application to stop listening for incoming connections.
        /// Existing connections are not affected.
        /// </summary>
        public virtual void Stop()
        {
            int socketIndex = -1;
            lock (this)
            {
                if (-1 != listenSocketIndex)
                {
                    socketIndex = listenSocketIndex;
                    listenSocketIndex = -1;
                }
            }

            if (-1 != socketIndex)
            {
                socketLayer.Close(socketIndex);
                Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_HIGH, "MessengerRuntimeEvents.LogTcpConnectionListenerStop()");
            }
        }

        /// <summary>
        /// Check whether we need to post an accept and post one if needed.
        /// Must be called with lock held.
        /// </summary>
        private void PostAccept()
        {
            if (listenSocketIndex != -1)
            {
                if (this.acceptsPending < MaxAcceptsPending)
                {
                    SocketError error = socketLayer.PostAccept(listenSocketIndex, connectionAcceptedCallback);

                    if (error != SocketError.Success)
                    {
                        Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogUnhandledSocketException(" + ((int)error).ToString() + ")");

                        if (SocketError.AlreadyInProgress != error && SocketError.TooManyOpenSockets != error)
                            Stop();
                    }
                    else
                    {
                        Interlocked.Increment(ref acceptsPending);
                    }
                }
            }
        }

        /// <summary>
        /// Raise the Connected event.
        /// </summary>
        /// <param name="connection"></param>
        protected void OnConnected(TcpStream connection)
        {
            // indicate the new connection to the protocol layer 
            try
            {
                if (this.Connected != null)
                {
                    this.Connected(this, connection);
                    Interlocked.Increment(ref this.connectionCount);

                    connection.Disconnected += this.connectionDisconnected;
                }
                else
                {
                    connection.Dispose();
                }
            }
            catch (Exception e)
            {
                Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogUnhandledSocketException(" + e.ToString() +")");
                throw;
            }
        }

        /// <summary>
        /// Handle an incoming connection
        /// This function is virtual so that it can be redefined for TlsConnectionListner
        /// </summary>
        /// <param name="connectedSocketIndex"></param>
        protected virtual void OnSocketConnected(int connectedSocketIndex)
        {
            // allow reads and writes
            socketLayer.BindToIoPort(listenSocketIndex, connectedSocketIndex, sendBufferSize, receiveBufferSize);

            // create a TcpConnection object
            TcpStream connection = new TcpStream(connectedSocketIndex, this.socketLayer);

            this.OnConnected(connection);
        }

        /// <summary>
        /// Called by Socket object on completion of BeginAccept
        /// </summary>
        /// <param name="acceptedSocketIndex"></param>
        /// <param name="error"></param>
        private void ConnectionAccepted(int acceptedSocketIndex, SocketError error)
        {
            if (SocketError.Success != error)
            {
                Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogUnhandledSocketException(" + ((int)error).ToString() +")");
            }
            else
            {
                Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogTcpConnectionListenerAccept(" + acceptedSocketIndex.ToString() +")");
            }

            lock (this)
            {
                Interlocked.Decrement(ref this.acceptsPending);
                this.PostAccept();
            }

            if (SocketError.Success != error)
            {
                this.socketLayer.Close(acceptedSocketIndex);
                return;
            }

            TcpStream connection = null;

            try
            {
                // new connection handling
                socketLayer.BindToIoPort(listenSocketIndex, acceptedSocketIndex, sendBufferSize, receiveBufferSize);
                connection = new TcpStream(acceptedSocketIndex, this.socketLayer);

                this.OnConnected(connection);
            }
            catch (Exception ex)
            {
                Xom.Trace(XomAreaName.XConnSrvConnection, LogLevel.L_NORMAL, "MessengerRuntimeEvents.LogUnhandledSocketException(" + ex.ToString() +")");
                if (connection != null) connection.Dispose();
            }
        }

        public void DisconnectedEventHandler(TcpStream sender, Exception reason)
        {
            int currentCount = Interlocked.Decrement(ref this.connectionCount);

            //
            // Always call PostAccept() to check whether we need to post a new accept.
            //
            // We rely on the lower SocketLayer to enforce the maximum number of simultaneous connections by
            // failing to post accepts when we are at capacity.
            //

            lock (this)
            {
                this.PostAccept();
            }
        }

        void IDisposable.Dispose()
        {
            if (null != socketLayer)
            {
                socketLayer.Close();
            }

            this.Stop();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\SocialCache\inh\SocialCache.cs ===
using System;

using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.ServiceProcess;
using System.Net;
using System.Text;

using xonline.common.mgmt;
using xonline.common.service;

using System.Threading;
using xonline.common.config;

using MS.Msn.Messenger.Runtime;
using xonline.common.community;
using xonline.common.protocol;

[assembly: ConfigAttribute(xonline.common.config.Component.SocialCache)]

[assembly: XomAreaDefinition(XomAreaName.SocialCacheLog)]
[assembly: XomAreaDefinition(XomAreaName.SocialCacheConnection)]
[assembly: XomAreaDefinition(XomAreaName.SocialCacheAPI)]

namespace xonline.server.SocialCache
{
    public class SocialCache : System.ServiceProcess.ServiceBase
    {
        private TcpConnectionListener m_ConnListener = null;

        private bool m_fRunAsConsole = false;

        private int m_iExpirationTimeout;
        public int CacheEntryExpirationTimeout
        {
            get
            {
                return m_iExpirationTimeout;
            }
            set
            {
                m_iExpirationTimeout = value;
            }
        }

        private IInterfaceInfo m_iface = null;
        public IInterfaceInfo LocalInterfaceInfo
        {
            get
            {
                return m_iface;
            }
        }

        private static SocialCache _instance = null;
        public static SocialCache Instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = new SocialCache();
                }
                return _instance;
            }
        }

        private static HashUser _users;
        public static HashUser Users
        {
            get
            {
                return _users;
            }
        }

        private static HashRelationships _relationships;
        public static HashRelationships Relationships
        {
            get
            {
                return _relationships;
            }
        }

        public SocialCache()
        {
        }

        public void Log(string sDelim, params Object[] args)
        {
            StringBuilder sb = new StringBuilder();
            for (int iArg = 0; iArg < args.Length; iArg++)
            {
                sb.Append((args[iArg] == null) ? "{null}" : args[iArg]);

                if (iArg < args.Length - 1)
                    sb.Append(sDelim);
            }

            Log(sb.ToString());
        }

        public void Log(string output)
        {
            if (m_fRunAsConsole)
            {
                Console.WriteLine(output);
            }

            Xom.Log(XomAreaName.SocialCacheLog, output);
        }

        /// <summary>
        /// Set things in motion so your service can do its work.
        /// </summary>
        protected override void OnStart(string[] args)
        {
            InitService();
            Xom.NtEvent(XEvent.Id.SOCIALCACHE_STARTED, "Social Cache server has been started.");
        }

        /// <summary>
        /// Stop this service.
        /// </summary>
        protected override void OnStop()
        {
            CloseService();
            _instance = null;
            Xom.NtEvent(XEvent.Id.SOCIALCACHE_SHUTDOWN, "Social Cache server has been shutdown.");
        }

        public void Start()
        {
            OnStart(null);
        }

        private void InitService()
        {
            try
            {
                Config.Assembly = System.Reflection.Assembly.GetExecutingAssembly();
                XomLoggingControl.Init();

                m_iExpirationTimeout = Config.GetIntSetting(Setting.SocialCache_CacheEntryExpirationTimeout);

                m_iface = Config.GetInterface(Interface.SocialCache);
                IVirtualInterfaceInfo ivii = Config.GetVirtualInterface(VirtualInterface.SocialCache);
                int cUserLookupTableBuckets = Config.GetIntSetting(Setting.SocialCache_UserLookupTableBuckets);
                int cRelationshipsLookupTableBuckets = Config.GetIntSetting(Setting.SocialCache_RelationshipsLookupTableBuckets);
                IPEndPoint ipListen = new IPEndPoint(IPAddress.Any, ivii.Port);
                int cbReadBuffer = Config.GetIntSetting(Setting.SocialCache_SocketBufferSize);
                int cbWriteBuffer = Config.GetIntSetting(Setting.SocialCache_SocketBufferSize);
                int cMaxSockets = Config.GetIntSetting(Setting.SocialCache_MaxClientSockets);
                uint tcpKeepAliveTimeout = Config.GetUIntSetting(Setting.SocialCache_TCPKeepAliveTimeout);

                XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnControlRequest);

                _users = new HashUser(cUserLookupTableBuckets);
                _relationships = new HashRelationships(cRelationshipsLookupTableBuckets);

                SocialCacheEngine.Init();

                m_ConnListener = new TcpConnectionListener(
                    ipListen,
                    cbReadBuffer,
                    cbWriteBuffer,
                    cMaxSockets,
                    tcpKeepAliveTimeout);

                m_ConnListener.Connected += ClientConnection.OnConnect;

                m_ConnListener.Start();

                // Register for cache changes
                CacheUtil.RegisterNotificationCacheNotificationHandler(NotificationChangeHandlerContext.OnMemCacheNotification);

                // Register for setting changes
                Config.InterfaceBucketChange += ChangeBucketMap;
                Config.SettingChange += OnSettingChange;

                xonline.common.health.HealthListener.InitializeHealthListener(Config.ComponentName);

                Log("|", "INIT", "Social Cache Server initialized.");
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.SOCIALCACHE_STARTUP_FAILURE, e, "Failed to initialize Social Cache server.");
                throw;
            }
        }

        private void CloseService()
        {
            Log("|", "SHTDWN", "Social Cache Server shutting down.");

            ((IDisposable)m_ConnListener).Dispose();

            CacheUtil.UnregisterNotificationCacheHandlers();

            SocialCacheEngine.Shutdown();

            XomLoggingControl.Close();
        }

        string HelpString
        {
            get
            {
                return
                "\r\nSocialCache Commands:\r\n\r\n" +
                "\tlookupuser [puid]:\tDisplays LimitedPresence for the user.\r\n" +
                "\tlookupusers [puid] [puid] [...]:\tDisplays LimitedPresence for multiple users.\r\n" +
                "\tcheckuser [puid]:\tDisplays the cache status of this user (Found, Missing, or expired).\r\n" +
                "\texpireuser [puid] [time(sec)]:\tSets the user's cache entry to expire in the seconds given in the input.  Leave blank for immediate. \r\n" +
                "\tlookupfriends [puid]:\tDisplays the number of friends for a user.\r\n" +
                "\tcheckfriends [puid]:\tDisplays the cache status of this friendslist (Found, Missing, or expired).\r\n" +
                "\texpirefriends [puid] [time(sec)]:\tSets the puid's friends cache entry to expire in the seconds  given in the input.  Leave blank for immediate. \r\n" +
                "\tlookupfriendsdetail [puid]:\tDisplays all friends xuids and state on a user's friendslist.\r\n" +
                "\thelp:\tshow this help message.\r\n" +
                "\r\n\tquit:\tshutdown server (console mode only).\r\n\r\n";
            }
        }

        public ulong ParseUserId(string inputString)
        {
            if (inputString.Substring(0, 2).CompareTo("0x") == 0)
            {
                return UInt64.Parse(inputString.Substring(2), System.Globalization.NumberStyles.HexNumber);
            }
            else
            {
                return UInt64.Parse(inputString);
            }
        }

        string HandleManangementCommand(ControlRequestEventArgs args)
        {
            switch (args.Command.ToLower())
            {
                case "lookupuser":
                    {
                        args.Handled = true;
                        ulong[] userarray = new ulong[1];
                        userarray[0] = ParseUserId(args.CommandArgs[0]);

                        LimitedPresence[] presList = Users.ReadUsers(userarray);
                        StringBuilder sbUserOutput = new StringBuilder();
                        if (presList.Length > 0)
                        {
                            sbUserOutput.AppendLine("Limited presence for user: " + String.Format("0x{0:X}", userarray[0]));
                            sbUserOutput.AppendLine("Gamertag: " + presList[0].sGamertag);
                            sbUserOutput.AppendLine("State: " + String.Format("0x{0:X}", presList[0].dwState));
                            sbUserOutput.AppendLine("Title: " + String.Format("0x{0:X}", presList[0].dwTitleID));
                            sbUserOutput.AppendLine("Last seen: " + MsgDefs.MsgTimeToDateTime(presList[0].mtLastSeen).ToString());
                        }
                        else
                        {
                            sbUserOutput.AppendLine("Nothing returned.");
                        }
                        return sbUserOutput.ToString();
                    }
                case "lookupusers":
                    {
                        args.Handled = true;
                        ulong[] userarray = new ulong[args.CommandArgs.Length];
                        for (int i = 0; i < userarray.Length; i++)
                        {
                            userarray[i] = ParseUserId(args.CommandArgs[i]);
                        }
                        LimitedPresence[] presList = Users.ReadUsers(userarray);
                        StringBuilder sbUserOutput = new StringBuilder();
                        if (presList.Length > 0)
                        {
                            sbUserOutput.AppendLine("Found presence for " + presList.Length + " users.");
                            for (int i = 0; i < presList.Length; i++)
                            {
                                sbUserOutput.AppendLine("------------------------------------");
                                sbUserOutput.AppendLine("Limited presence for userXuid: " + String.Format("0x{0:X}", userarray[i]));
                                sbUserOutput.AppendLine("Gamertag: " + presList[i].sGamertag);
                                sbUserOutput.AppendLine("State: " + String.Format("0x{0:X}", presList[i].dwState));
                                sbUserOutput.AppendLine("Title: " + String.Format("0x{0:X}", presList[i].dwTitleID));
                                sbUserOutput.AppendLine("Last seen: " + MsgDefs.MsgTimeToDateTime(presList[i].mtLastSeen).ToString());
                            }
                        }
                        else
                        {
                            sbUserOutput.AppendLine("Nothing returned.");
                        }
                        return sbUserOutput.ToString();
                    }
                case "checkuser":
                    {
                        args.Handled = true;
                        ulong user = ParseUserId(args.CommandArgs[0]);

                        CacheEntryStatus status = Users.CheckUserCacheStatus(user);

                        StringBuilder sbUserOutput = new StringBuilder();
                        sbUserOutput.AppendLine("Cache Status for user: " + String.Format("0x{0:X}", user));
                        sbUserOutput.AppendLine("Status: " + status.ToString());

                        return sbUserOutput.ToString();
                    }
                case "expireuser":
                    {
                        args.Handled = true;
                        ulong userId = ParseUserId(args.CommandArgs[0]);
                        int timeToExpire = 0;

                        if (args.CommandArgs.Length > 1)
                        {
                            timeToExpire = Int32.Parse(args.CommandArgs[1]);
                        }

                        bool success = Users.ExpireUser(userId, timeToExpire);

                        if (success)
                        {
                            return "Set user's expire time to " + timeToExpire + " seconds from now";
                        }
                        else
                        {
                            return "Could not find user: " + String.Format("0x{0:X}", userId);
                        }
                    }
                case "lookupfriends":
                    {
                        args.Handled = true;
                        ulong user = ParseUserId(args.CommandArgs[0]);

                        FriendsList friends = Relationships.ReadFriendsList(user);
                        StringBuilder sbFriendsListOutput = new StringBuilder();
                        if (friends != null)
                        {
                            sbFriendsListOutput.AppendLine("FriendsList for user: " + String.Format("0x{0:X}", user));
                            sbFriendsListOutput.AppendLine("Number of friends: " + friends.dwNumUsers);
                        }
                        else
                        {
                            sbFriendsListOutput.AppendLine("Returned NULL FriendsList");
                        }

                        return sbFriendsListOutput.ToString();
                    }
                case "checkfriends":
                    {
                        args.Handled = true;
                        ulong user = ParseUserId(args.CommandArgs[0]);

                        CacheEntryStatus status = Relationships.CheckRelationshipCacheStatus(user);

                        StringBuilder sbOutput = new StringBuilder();
                        sbOutput.AppendLine("Cache Status of friendslist for user: " + String.Format("0x{0:X}", user));
                        sbOutput.AppendLine("Status: " + status.ToString());

                        return sbOutput.ToString();
                    }
                case "expirefriends":
                    {
                        args.Handled = true;
                        ulong userId = ParseUserId(args.CommandArgs[0]);
                        int timeToExpire = 0;

                        if (args.CommandArgs.Length > 1)
                        {
                            timeToExpire = Int32.Parse(args.CommandArgs[1]);
                        }

                        bool success = Relationships.ExpireRelationship(userId, timeToExpire);

                        if (success)
                        {
                            return "Set user's expire time to " + timeToExpire + " seconds from now";
                        }
                        else
                        {
                            return "Could not find user: " + String.Format("0x{0:X}", userId);
                        }
                    }
                case "lookupfriendsdetail":
                    {
                        args.Handled = true;
                        ulong detailUser = ParseUserId(args.CommandArgs[0]);

                        FriendsList detailFriends = Relationships.ReadFriendsList(detailUser);
                        StringBuilder sbDetailFriendsListOutput = new StringBuilder();
                        if (detailFriends != null)
                        {
                            sbDetailFriendsListOutput.AppendLine("FriendsList for user: " + String.Format("0x{0:X}", detailUser));
                            sbDetailFriendsListOutput.AppendLine("Number of friends: " + detailFriends.dwNumUsers);
                            for (int i = 0; i < detailFriends.dwNumUsers; i++)
                            {
                                UserData friendData = detailFriends.rgUsers[i];
                                sbDetailFriendsListOutput.AppendLine("Friend[" + i + "]");
                                sbDetailFriendsListOutput.AppendLine("    xuid: " + String.Format("0x{0:X}", friendData.qwXUID));
                                sbDetailFriendsListOutput.AppendLine("    flags: " + String.Format("0x{0:X}", friendData.dwUserFlags));
                            }
                        }
                        else
                        {
                            sbDetailFriendsListOutput.AppendLine("Returned NULL FriendsList");
                        }

                        return sbDetailFriendsListOutput.ToString();
                    }
                case "help":
                    {
                        // leave handled as false to allow for all handlers to process help.
                        return HelpString;
                    }

                case "quit":
                    {
                        args.Handled = true;
                        if (m_fRunAsConsole != true)
                        {
                            return "Server running in service mode.  Cannot quit.\r\n";
                        }
                        else
                        {
                            m_fRunAsConsole = false;
                            return "Exiting.\r\n";
                        }
                    }
                default:
                    return "";
            }
        }

        void RunAsConsole(string[] args)
        {
            OnStart(args);

            try
            {
                Console.WriteLine("Running as console.  Type \"help\" for commands.");

                while (m_fRunAsConsole)
                {
                    string sCommand = Console.ReadLine();
                    string sResponse = "Invalid Command\r\n";
                    try
                    {
                        ControlRequestEventArgs cmdArgs = new ControlRequestEventArgs(sCommand, 0);
                        sResponse = HandleManangementCommand(cmdArgs);
                    }
                    catch (Exception e)
                    {
                        Console.Write("Error: " + e.ToString() + "\r\n\r\n");
                    }

                    Console.Write(sResponse);
                }
            }
            finally
            {
                OnStop();
            }
        }

        // The main entry point for the process
        static void Main(string[] args)
        {
            SocialCache srv = SocialCache.Instance;

            foreach (string sArg in args)
            {
                if (sArg.ToLower().Contains("console"))
                {
                    srv.m_fRunAsConsole = true;
                }
            }

            if (srv.m_fRunAsConsole)
            {
                srv.RunAsConsole(args);
            }
            else
            {
                System.ServiceProcess.ServiceBase.Run(srv);
            }
        }

        //This is implemented solely so that bucket remapping will now succeed.
        //See config.cs func RefreshInterfaceBuckets() -- if you don't add a bucketchange delegate
        //then the bucket change will NOT update the cache, breaking in Xenon 91109.
        public static void ChangeBucketMap(object sender, InterfaceBucketChangeEventArgs e)
        {
            return;
        }

        // -------------------------------------------------------------------------
        // OnSettingChange - handles changes to npdb settings
        // -------------------------------------------------------------------------
        public static void OnSettingChange(object sender, SettingChangeEventArgs eventArgs)
        {
            switch (eventArgs.Setting)
            {
                case Setting.SocialCache_CacheEntryExpirationTimeout:
                    SocialCache.Instance.CacheEntryExpirationTimeout = Int32.Parse(eventArgs.ValueNew);
                    break;

            }
            return;
        }

        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                string sResponse = SocialCache.Instance.HandleManangementCommand(args);
                XomControlConnection.SendMessage(sResponse, args.RequestId);
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }

        public delegate void ProcessUser(ulong Xuid, string Gamertag, uint UserState, uint FriendStatus, uint TitleId, object context);

        // Calls the delegate for each user visible to the requestor.
        // Returns the friend list version that was processed.
        public static uint WalkFriendsList(ulong xuidRequestor, ulong xuidOwner, ProcessUser processUser, object context)
        {
            FriendsList friendsList = SocialCache.Relationships.ReadFriendsList(xuidOwner);
            uint friendsListVersion = 0;

            if (friendsList != null && friendsList.CanShareList(xuidRequestor))
            {
                friendsListVersion = friendsList.dwListVersion;

                // create a new array with just the user ids for ReadUsers
                ulong[] userIds = Array.ConvertAll<UserData, ulong>(friendsList.rgUsers, u => u.qwXUID);

                // ReadUsers will hit our hash tables first, acceleration if necessary, and finally xcache if necessary
                LimitedPresence[] limitedPresenceUsers = SocialCache.Users.ReadUsers(userIds);

                for (int iUser = 0; iUser < limitedPresenceUsers.Length; iUser++)
                {
                    // privacy checks need to be made based on whether the user being viewed is a
                    // friend of the requestor. For friends of friends queries, the requestor won't be the same as the
                    // owner of the friends list.
                    FriendsList requestorFriends = friendsList;
                    if (xuidRequestor != xuidOwner)
                    {
                        requestorFriends = SocialCache.Relationships.ReadFriendsList(xuidRequestor);
                    }

                    uint UserState = 0;
                    uint TitlePlaying = 0;

                    if (CacheUtil.IsDataAccessible(
                        limitedPresenceUsers[iUser].OwnerID,
                        xuidRequestor,
                        limitedPresenceUsers[iUser].HeaderFlags,
                        requestorFriends.AreAcceptedBuddies))
                    {
                        UserState = limitedPresenceUsers[iUser].dwState;
                        TitlePlaying = limitedPresenceUsers[iUser].dwTitleID;
                    }

                    // call delegate for context object
                    processUser(
                        limitedPresenceUsers[iUser].OwnerID,
                        limitedPresenceUsers[iUser].sGamertag,
                        UserState,
                        friendsList.rgUsers[iUser].dwUserFlags,
                        TitlePlaying,
                        context);
                }
            }

            return friendsListVersion;
        }
    }

    [XomPerformanceCounterCategoryAttr( "Social Cache", "Xbox Live Social Cache Server" )]
    public class SocialCacheCounters : XomPerformanceCounterCategory
    {
        public SocialCacheCounters() : base(true)
        {
        }

        static public SocialCacheCounters Current = new SocialCacheCounters();

        [XomPerformanceCounterAttr(
            "Connection Rate",
            "Total number of connections being created per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ConnectRate;

        [XomPerformanceCounterAttr(
            "Reconnection Rate",
            "Number of connections being recreated per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ReconnectRate;

        [XomPerformanceCounterAttr(
            "Client Connections",
            "Total number of connected clients.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter NumConnections;

        [XomPerformanceCounterAttr(
            "Connected Users",
            "Total number of connected users.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter NumUsers;

        [XomPerformanceCounterAttr(
            "Total Subscriptions",
            "Total number of data subscriptions.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter NumSubscriptions;

        [XomPerformanceCounterAttr(
            "Free Send Buffers",
            "Number of send buffers free in the buffer pool.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FreeSendBuffers;

        [XomPerformanceCounterAttr(
            "Total Send Buffers",
            "Total number of send buffers.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalSendBuffers;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\SocialCache\test\stf\FuncLimitedPresence.cs ===
using System;
using System.Collections;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.XConnSrv;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;

using xonline.common.diagnostics;
using xonline.common.community;
using xonline.common.protocol;

namespace SocialCacheTest
{
    /// <summary>
    /// Functional tests for LimitedPresence
    /// </summary>
    [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(2)]
    public class FuncLimitedPresence : SocialCacheTestBaseGroup
    {

        private void InitTest(out PNUser user, out LimitedPresence limitedPresence, out PresenceRecord record)
        {
            uint dwState = 1;
            uint dwTitleID = 2;

            user = CreateXenonUser(false);
            record = PresenceRecord.Init(user.UserId, user.Name, dwTitleID, new xonline.common.protocol.SGADDR(), new xonline.common.community.UserPrivileges(user.UserId, new byte[32]));
            record.dtLastSeen = DateTime.UtcNow;

            // this will write the data to acceleration
            record.SetState(dwTitleID, dwState, 0, null, new string[0], new string[0], new xonline.common.protocol.SGADDR());

            // this will read the data from acceleration
            limitedPresence = new LimitedPresence();
            limitedPresence.OwnerID = user.UserId;
            CacheUtil.RefreshFromCache(limitedPresence);
        }

        /// <summary>
        /// Basic BVT Test creates limited presence for a single user
        /// </summary>
        [TestCase]
        public void BVT_NewRecord()
        {
            uint dwState = 1;
            uint dwTitleID = 2;

            PNUser user = CreateXenonUser(false);
            PresenceRecord record = PresenceRecord.Init(user.UserId, user.Name, dwTitleID, new xonline.common.protocol.SGADDR(), new xonline.common.community.UserPrivileges(user.UserId, new byte[32]));
            record.dtLastSeen = DateTime.UtcNow;

            // this will write the data to acceleration
            record.SetState(dwTitleID, dwState, 0, null, new string[0], new string[0], new xonline.common.protocol.SGADDR());

            // this will read t